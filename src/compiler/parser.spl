# Parser - Simple Language Parser
#
# Parses Simple source code into an Abstract Syntax Tree (AST).
# Uses tree-sitter for outline parsing, then detailed token-based parsing.
#
# AST type definitions are in parser_types.spl

use lexer.*
use treesitter.*
use blocks.*
use parser_types.*

impl Parser:
    static fn new(source: text) -> Parser:
        var p = Parser(
            source: source,
            lexer: Lexer.new(source),
            current: Token.eof(0, 1),
            previous: Token.eof(0, 1),
            errors: [],
            outline: nil,
            resolved_blocks: nil
        )
        p.advance()
        p

    static fn with_resolved_blocks(source: text, resolved: ResolvedModule) -> Parser:
        """Create parser with pre-resolved blocks."""
        var p = Parser(
            source: source,
            lexer: Lexer.new(source),
            current: Token.eof(0, 1),
            previous: Token.eof(0, 1),
            errors: [],
            outline: Some(resolved.outline),
            resolved_blocks: Some(resolved)
        )
        p.advance()
        p

    # ========================================================================
    # Main Entry Point
    # ========================================================================

    me parse() -> Module:
        """Parse source into a full Module."""
        # Pass 1: Get outline (reuse from resolved_blocks if available)
        if not self.outline.?:
            val ts = TreeSitter.new(self.source)
            self.outline = Some(ts.parse_outline())

        # Pass 2: Fill in bodies
        self.parse_full()

    me parse_full() -> Module:
        """Parse full module using outline."""
        val outline = self.outline.unwrap()

        var module = Module(
            name: outline.name,
            imports: [],
            exports: [],
            functions: {},
            classes: {},
            actors: {},
            structs: {},
            enums: {},
            bitfields: {},
            traits: {},
            impls: [],
            type_aliases: {},
            constants: {},
            static_asserts: []
        )

        # Convert imports
        for imp in outline.imports:
            module.imports = module.imports.push(self.convert_import(imp))

        # Convert exports
        for exp in outline.exports:
            module.exports = module.exports.push(Export(
                items: exp.items,
                span: exp.span
            ))

        # Parse function bodies
        var fn_idx = 0
        while fn_idx < outline.functions.len():
            val fn_outline = outline.functions[fn_idx]
            val fn_ = self.parse_function_body(fn_outline)
            var fns = module.functions
            fns[fn_.name] = fn_
            module.functions = fns
            fn_idx = fn_idx + 1

        # Parse class bodies
        for class_outline in outline.classes:
            val class_ = self.parse_class_body(class_outline)
            module.classes[class_.name] = class_

        # Parse actor bodies (guard against nil from TreeSitter)
        if outline.actors.?:
            for actor_outline in outline.actors:
                val actor_decl = self.parse_actor_body(actor_outline)
                module.actors[actor_decl.name] = actor_decl

        # Parse struct bodies
        for struct_outline in outline.structs:
            val struct_ = self.convert_struct(struct_outline)
            module.structs[struct_.name] = struct_

        # Parse enum bodies
        for enum_outline in outline.enums:
            val enum_ = self.convert_enum(enum_outline)
            module.enums[enum_.name] = enum_

        # Convert bitfields
        for bf_outline in outline.bitfields:
            val bf = self.convert_bitfield(bf_outline)
            module.bitfields[bf.name] = bf

        # Parse trait bodies
        for trait_outline in outline.traits:
            val trait_ = self.parse_trait_body(trait_outline)
            module.traits[trait_.name] = trait_

        # Parse impl bodies
        for impl_outline in outline.impls:
            val impl_ = self.parse_impl_body(impl_outline)
            module.impls = module.impls.push(impl_)

        # Convert type aliases
        for alias_outline in outline.type_aliases:
            val alias = self.convert_type_alias(alias_outline)
            module.type_aliases[alias.name] = alias

        # Parse constant values
        for const_outline in outline.constants:
            val const_ = self.parse_const_body(const_outline)
            module.constants[const_.name] = const_

        # Parse static assertions
        for assert_outline in outline.static_asserts:
            val assert_ = self.parse_static_assert_body(assert_outline)
            module.static_asserts = module.static_asserts.push(assert_)

        module

    # ========================================================================
    # Token Handling (for body parsing)
    # ========================================================================

    me advance() -> Token:
        self.previous = self.current
        # Copy-modify-reassign: nested field mutations don't propagate in interpreter
        var lexer = self.lexer
        self.current = lexer.next_token()
        self.lexer = lexer
        self.previous

    me peek() -> TokenKind:
        self.current.kind

    me check(kind: TokenKind) -> bool:
        self.current.kind == kind

    me match_token(kind: TokenKind) -> bool:
        if self.check(kind):
            self.advance()
            true
        else:
            false

    me expect(kind: TokenKind, message: text) -> bool:
        if self.check(kind):
            self.advance()
            true
        else:
            self.error(message)
            false

    me is_at_end() -> bool:
        # Handle nil token as end of input
        if not self.current.kind.?:
            return true
        self.current.kind == TokenKind.Eof

    me skip_newlines():
        while self.check(TokenKind.Newline):
            self.advance()

    me error(message: text):
        self.errors = self.errors.push(ParseError(
            message: message,
            span: self.current.span,
            severity: ErrorSeverity.Error
        ))

    me warning(message: text, span: Span):
        self.errors = self.errors.push(ParseError(
            message: message,
            span: span,
            severity: ErrorSeverity.Warning
        ))

    me reset_to_span(span: Span):
        """Reset lexer to parse from a specific span."""
        var lexer = Lexer.new(self.source)
        lexer.pos = span.start

        # Skip to the right position
        while lexer.pos < span.start and not lexer.is_at_end():
            lexer.advance()

        self.current = lexer.next_token()
        self.lexer = lexer
        self.previous = Token.eof(0, 1)

    # ========================================================================
    # Outline Conversion
    # ========================================================================

    # Helper: convert a list of TypeOutline to [Type]
    me convert_type_list(outlines: [TypeOutline]) -> [Type]:
        var result: [Type] = []
        for outline in outlines:
            result = result.push(self.convert_type(outline))
        result

    # Helper: convert a list of FieldOutline to [Field]
    me convert_field_list(outlines: [FieldOutline]) -> [Field]:
        var result: [Field] = []
        for outline in outlines:
            result = result.push(self.convert_field(outline))
        result

    # Helper: convert AttributeOutline to Attribute
    me convert_attribute(outline: AttributeOutline) -> Attribute:
        """Convert attribute outline to full attribute AST.

        Parses the args_span if present to extract attribute arguments.
        """
        var args: [Expr] = []
        if outline.args_span.?:
            args = self.parse_attr_args_at_span(outline.args_span.unwrap())

        Attribute(
            name: outline.name,
            args: args,
            span: outline.span
        )

    # Helper: convert a list of AttributeOutline to [Attribute]
    me convert_attributes(outlines: [AttributeOutline]) -> [Attribute]:
        var result: [Attribute] = []
        for outline in outlines:
            result = result.push(self.convert_attribute(outline))
        result

    me parse_attr_args_at_span(span: Span) -> [Expr]:
        """Parse attribute arguments at a given span."""
        self.reset_to_span(span)

        # Parse comma-separated expressions
        var args: [Expr] = []
        if not self.is_at_end():
            args = args.push(self.parse_expr())
            while self.match_token(TokenKind.Comma):
                if self.is_at_end():
                    break
                args = args.push(self.parse_expr())

        args

    me convert_import(outline: ImportOutline) -> Import:
        var items: [ImportItem] = []
        for item in outline.items:
            items = items.push(ImportItem(name: item, alias: nil))

        # Warn if "/" is used in import path (should use "." or relative paths)
        if outline.module.contains("/"):
            val suggestion = outline.module.replace("/", ".")
            self.warning(
                "Import path should not use '.' - use '.' for module paths or './' for relative paths (suggestion: use {suggestion})",
                outline.span
            )

        Import(
            module: outline.module,
            items: items,
            span: outline.span
        )

    me convert_type(outline: TypeOutline) -> Type:
        val kind = match outline.kind:
            case Named(name, args):
                TypeKind.Named(name, self.convert_type_list(args))
            case Tuple(elements):
                TypeKind.Tuple(self.convert_type_list(elements))
            case Array(element):
                TypeKind.Array(self.convert_type(element), nil)
            case Function(params, ret):
                TypeKind.Function(self.convert_type_list(params), self.convert_type(ret))
            case Optional(inner):
                TypeKind.Optional(self.convert_type(inner))
            case Reference(inner, mutable):
                TypeKind.Reference(self.convert_type(inner), mutable)
            case Atomic(inner):
                TypeKind.Atomic(self.convert_type(inner))
            case Isolated(inner):
                TypeKind.Isolated(self.convert_type(inner))
            case Infer:
                TypeKind.Infer

        Type(kind: kind, span: outline.span)

    me convert_type_param(outline: TypeParamOutline) -> TypeParam:
        var bounds: [Type] = []
        for b in outline.bounds:
            bounds = bounds.push(self.convert_type(b))

        TypeParam(
            name: outline.name,
            bounds: bounds,
            default: outline.default.map(\t: self.convert_type(t)),
            span: outline.span
        )

    me convert_param(outline: ParamOutline) -> Param:
        var default_expr: Expr? = nil
        if outline.default_span.?:
            default_expr = Some(self.parse_expr_at_span(outline.default_span.unwrap()))

        val type_result = outline.type_.map(\t: self.convert_type(t))
        Param(
            name: outline.name,
            type_: type_result,
            default: default_expr,
            span: outline.span
        )

    me convert_field(outline: FieldOutline) -> Field:
        var default_expr: Expr? = nil
        if outline.default_span.?:
            default_expr = Some(self.parse_expr_at_span(outline.default_span.unwrap()))

        # Parse fixed address if present
        var fixed_address: i64? = nil
        if outline.address_span.?:
            val addr_expr = self.parse_expr_at_span(outline.address_span.unwrap())
            fixed_address = self.extract_address(addr_expr)

        Field(
            name: outline.name,
            type_: self.convert_type(outline.type_),
            default: default_expr,
            is_public: outline.is_public,
            is_volatile: outline.is_volatile,
            fixed_address: fixed_address,
            span: outline.span
        )

    fn extract_address(expr: Expr) -> i64?:
        """Extract integer address from expression."""
        match expr.kind:
            case IntLit(value): Some(value)
            case _: nil

    me convert_struct(outline: StructOutline) -> Struct:
        var type_params: [TypeParam] = []
        for tp in outline.type_params:
            type_params = type_params.push(self.convert_type_param(tp))

        var fields: [Field] = []
        for f in outline.fields:
            fields = fields.push(self.convert_field(f))

        Struct(
            name: outline.name,
            type_params: type_params,
            fields: fields,
            is_public: outline.is_public,
            doc_comment: outline.doc_comment,
            attributes: self.convert_attributes(outline.attributes),
            span: outline.span
        )

    me convert_enum(outline: EnumOutline) -> Enum:
        var type_params: [TypeParam] = []
        for tp in outline.type_params:
            type_params = type_params.push(self.convert_type_param(tp))

        var variants: [Variant] = []
        for v in outline.variants:
            val kind = match v.payload:
                case nil:
                    VariantKind.Unit
                case Some(Tuple(types)):
                    VariantKind.Tuple(self.convert_type_list(types))
                case Some(Struct(fields)):
                    VariantKind.Struct(self.convert_field_list(fields))

            variants = variants.push(Variant(
                name: v.name,
                kind: kind,
                span: v.span
            ))

        Enum(
            name: outline.name,
            type_params: type_params,
            variants: variants,
            is_public: outline.is_public,
            doc_comment: outline.doc_comment,
            span: outline.span
        )

    me convert_type_alias(outline: TypeAliasOutline) -> TypeAlias:
        var type_params: [TypeParam] = []
        for tp in outline.type_params:
            type_params = type_params.push(self.convert_type_param(tp))

        TypeAlias(
            name: outline.name,
            type_params: type_params,
            type_: self.convert_type(outline.type_),
            is_public: outline.is_public,
            span: outline.span
        )

    me convert_bitfield(outline: BitfieldOutline) -> Bitfield:
        """Convert bitfield outline to bitfield AST."""
        var fields: [BitfieldField] = []
        for f in outline.fields:
            fields = fields.push(self.convert_bitfield_field(f))

        Bitfield(
            name: outline.name,
            backing_type: self.convert_type(outline.backing_type),
            fields: fields,
            is_public: outline.is_public,
            doc_comment: outline.doc_comment,
            attributes: self.convert_attributes(outline.attributes),
            span: outline.span
        )

    me convert_bitfield_field(outline: BitfieldFieldOutline) -> BitfieldField:
        """Convert bitfield field outline to AST."""
        BitfieldField(
            name: outline.name,
            type_: outline.type_.map(\t: self.convert_type(t)),
            bits: outline.bits,
            is_reserved: outline.is_reserved,
            span: outline.span
        )

    # ========================================================================
    # Body Parsing
    # ========================================================================

    me parse_function_body(outline: FunctionOutline) -> Function:
        """Parse function body from outline."""
        var type_params: [TypeParam] = []

        var params: [Param] = []
        var pi = 0
        while pi < outline.params.len():
            val p = outline.params[pi]
            params = params.push(self.convert_param(p))
            pi = pi + 1

        var body = Block(stmts: [], span: outline.body_span)
        if outline.body_span.len() > 0:
            body = self.parse_block_at_span(outline.body_span)

        Function(
            name: outline.name,
            type_params: type_params,
            params: params,
            return_type: outline.return_type.map(\t: self.convert_type(t)),
            body: body,
            is_async: outline.is_async,
            is_static: outline.is_static,
            is_public: outline.is_public,
            is_method: outline.is_method,
            is_mutable: outline.is_mutable,
            is_const: outline.is_const,
            is_kernel: outline.is_kernel,
            is_extern: outline.is_extern,
            doc_comment: outline.doc_comment,
            span: outline.span
        )

    me parse_class_body(outline: ClassOutline) -> Class:
        var type_params: [TypeParam] = []
        for tp in outline.type_params:
            type_params = type_params.push(self.convert_type_param(tp))

        var fields: [Field] = []
        for f in outline.fields:
            fields = fields.push(self.convert_field(f))

        var methods: Dict<text, Function> = {}
        for m in outline.methods:
            val fn_ = self.parse_function_body(m)
            methods[fn_.name] = fn_

        Class(
            name: outline.name,
            type_params: type_params,
            fields: fields,
            methods: methods,
            is_public: outline.is_public,
            doc_comment: outline.doc_comment,
            attributes: self.convert_attributes(outline.attributes),
            span: outline.span
        )

    me parse_actor_body(outline: ActorOutline) -> ActorDef:
        """Parse actor from outline (same structure as class)."""
        var type_params: [TypeParam] = []
        for tp in outline.type_params:
            type_params = type_params.push(self.convert_type_param(tp))

        var fields: [Field] = []
        for f in outline.fields:
            fields = fields.push(self.convert_field(f))

        var methods: Dict<text, Function> = {}
        for m in outline.methods:
            val fn_ = self.parse_function_body(m)
            methods[fn_.name] = fn_

        ActorDef(
            name: outline.name,
            type_params: type_params,
            fields: fields,
            methods: methods,
            is_public: outline.is_public,
            doc_comment: outline.doc_comment,
            attributes: self.convert_attributes(outline.attributes),
            span: outline.span
        )

    me parse_trait_body(outline: TraitOutline) -> Trait:
        var type_params: [TypeParam] = []
        for tp in outline.type_params:
            type_params = type_params.push(self.convert_type_param(tp))

        var methods: [Function] = []
        for m in outline.methods:
            val fn_ = self.parse_function_body(m)
            methods = methods.push(fn_)

        Trait(
            name: outline.name,
            type_params: type_params,
            methods: methods,
            is_public: outline.is_public,
            doc_comment: outline.doc_comment,
            span: outline.span
        )

    me parse_impl_body(outline: ImplOutline) -> Impl:
        var methods: Dict<text, Function> = {}
        for m in outline.methods:
            val fn_ = self.parse_function_body(m)
            methods[fn_.name] = fn_

        Impl(
            type_: self.convert_type(outline.type_),
            trait_: outline.trait_.map(\t: self.convert_type(t)),
            methods: methods,
            span: outline.span
        )

    me parse_const_body(outline: ConstOutline) -> Const:
        val value = self.parse_expr_at_span(outline.value_span)

        # Parse fixed address if present
        var fixed_address: i64? = nil
        if outline.address_span.?:
            val addr_expr = self.parse_expr_at_span(outline.address_span.unwrap())
            fixed_address = self.extract_address(addr_expr)

        Const(
            name: outline.name,
            type_: outline.type_.map(\t: self.convert_type(t)),
            value: value,
            is_mutable: outline.is_mutable,
            is_public: outline.is_public,
            is_volatile: outline.is_volatile,
            fixed_address: fixed_address,
            span: outline.span
        )

    me parse_static_assert_body(outline: StaticAssertOutline) -> StaticAssert:
        """Parse a static assertion from its outline."""
        val condition = self.parse_expr_at_span(outline.condition_span)

        StaticAssert(
            condition: condition,
            message: outline.message,
            span: outline.span
        )

    # ========================================================================
    # Expression Parsing
    # ========================================================================

    me parse_expr_at_span(span: Span) -> Expr:
        """Parse an expression at a specific span."""
        self.reset_to_span(span)
        self.parse_expr()

    me parse_block_at_span(span: Span) -> Block:
        """Parse a block at a specific span."""
        self.reset_to_span(span)
        self.parse_block()

    me parse_expr() -> Expr:
        """Parse an expression."""
        self.parse_pipeline_expr()

    me parse_pipeline_expr() -> Expr:
        """Parse pipeline expression (|>, ~>).

        Pipeline operators have lowest precedence and are left-associative.
        - |> : Forward pipe, passes left value as first argument to right function
        - ~> : Layer connect, composes neural network layers with dimension checking
        """
        var left = self.parse_parallel_expr()

        loop:
            if self.match_token(TokenKind.PipeForward):
                val right = self.parse_parallel_expr()
                left = Expr(
                    kind: ExprKind.Binary(BinOp.PipeForward, left, right),
                    span: left.span.merge(right.span)
                )
            elif self.match_token(TokenKind.LayerConnect):
                val right = self.parse_parallel_expr()
                left = Expr(
                    kind: ExprKind.Binary(BinOp.LayerConnect, left, right),
                    span: left.span.merge(right.span)
                )
            else:
                break

        left

    me parse_parallel_expr() -> Expr:
        """Parse parallel expression (//).

        Parallel operator combines branches for concurrent/parallel execution.
        Left-associative.
        """
        var left = self.parse_composition_expr()

        while self.match_token(TokenKind.Parallel):
            val right = self.parse_composition_expr()
            left = Expr(
                kind: ExprKind.Binary(BinOp.Parallel, left, right),
                span: left.span.merge(right.span)
            )

        left

    me parse_composition_expr() -> Expr:
        """Parse composition expression (>>, <<).

        Composition operators are right-associative (like Haskell's . operator).
        - >> : Forward compose, f >> g means g(f(x))
        - << : Backward compose, f << g means f(g(x))
        """
        val left = self.parse_or_expr()

        if self.match_token(TokenKind.Compose):
            val right = self.parse_composition_expr()  # Right-associative
            return Expr(
                kind: ExprKind.Binary(BinOp.Compose, left, right),
                span: left.span.merge(right.span)
            )

        if self.match_token(TokenKind.ComposeBack):
            val right = self.parse_composition_expr()  # Right-associative
            return Expr(
                kind: ExprKind.Binary(BinOp.ComposeBack, left, right),
                span: left.span.merge(right.span)
            )

        left

    me parse_or_expr() -> Expr:
        """Parse logical or expression."""
        var left = self.parse_xor_expr()

        while self.match_token(TokenKind.KwOr) or self.match_token(TokenKind.PipePipe):
            val right = self.parse_xor_expr()
            left = Expr(
                kind: ExprKind.Binary(BinOp.Or, left, right),
                span: left.span.merge(right.span)
            )

        left

    me parse_xor_expr() -> Expr:
        """Parse bitwise xor expression."""
        var left = self.parse_and_expr()

        while self.match_token(TokenKind.KwXor):
            val right = self.parse_and_expr()
            left = Expr(
                kind: ExprKind.Binary(BinOp.BitXor, left, right),
                span: left.span.merge(right.span)
            )

        left

    me parse_and_expr() -> Expr:
        """Parse logical and expression."""
        var left = self.parse_equality_expr()

        while self.match_token(TokenKind.KwAnd) or self.match_token(TokenKind.AmpAmp):
            val right = self.parse_equality_expr()
            left = Expr(
                kind: ExprKind.Binary(BinOp.And, left, right),
                span: left.span.merge(right.span)
            )

        left

    me parse_equality_expr() -> Expr:
        """Parse equality expression."""
        var left = self.parse_comparison_expr()

        loop:
            if self.match_token(TokenKind.Eq):
                val right = self.parse_comparison_expr()
                left = Expr(
                    kind: ExprKind.Binary(BinOp.Eq, left, right),
                    span: left.span.merge(right.span)
                )
            elif self.match_token(TokenKind.NotEq):
                val right = self.parse_comparison_expr()
                left = Expr(
                    kind: ExprKind.Binary(BinOp.NotEq, left, right),
                    span: left.span.merge(right.span)
                )
            else:
                break

        left

    me parse_comparison_expr() -> Expr:
        """Parse comparison expression."""
        var left = self.parse_range_expr()

        loop:
            if self.match_token(TokenKind.Lt):
                val right = self.parse_range_expr()
                left = Expr(
                    kind: ExprKind.Binary(BinOp.Lt, left, right),
                    span: left.span.merge(right.span)
                )
            elif self.match_token(TokenKind.LtEq):
                val right = self.parse_range_expr()
                left = Expr(
                    kind: ExprKind.Binary(BinOp.LtEq, left, right),
                    span: left.span.merge(right.span)
                )
            elif self.match_token(TokenKind.Gt):
                val right = self.parse_range_expr()
                left = Expr(
                    kind: ExprKind.Binary(BinOp.Gt, left, right),
                    span: left.span.merge(right.span)
                )
            elif self.match_token(TokenKind.GtEq):
                val right = self.parse_range_expr()
                left = Expr(
                    kind: ExprKind.Binary(BinOp.GtEq, left, right),
                    span: left.span.merge(right.span)
                )
            elif self.match_token(TokenKind.KwIn):
                val right = self.parse_range_expr()
                left = Expr(
                    kind: ExprKind.Binary(BinOp.In, left, right),
                    span: left.span.merge(right.span)
                )
            elif self.match_token(TokenKind.KwIs):
                val right = self.parse_range_expr()
                left = Expr(
                    kind: ExprKind.Binary(BinOp.Is, left, right),
                    span: left.span.merge(right.span)
                )
            else:
                break

        left

    me parse_range_expr() -> Expr:
        """Parse range expression."""
        val left = self.parse_additive_expr()

        if self.match_token(TokenKind.DotDot):
            var inclusive = false
            if self.match_token(TokenKind.Assign):  # ..=
                inclusive = true
            val right = self.parse_additive_expr()
            return Expr(
                kind: ExprKind.Range(Some(left), Some(right), inclusive, nil),
                span: left.span.merge(right.span)
            )

        left

    me parse_additive_expr() -> Expr:
        """Parse additive expression (including broadcast .+ and .-)."""
        var left = self.parse_matmul_expr()

        loop:
            if self.match_token(TokenKind.Plus):
                val right = self.parse_matmul_expr()
                left = Expr(
                    kind: ExprKind.Binary(BinOp.Add, left, right),
                    span: left.span.merge(right.span)
                )
            elif self.match_token(TokenKind.Minus):
                val right = self.parse_matmul_expr()
                left = Expr(
                    kind: ExprKind.Binary(BinOp.Sub, left, right),
                    span: left.span.merge(right.span)
                )
            elif self.match_token(TokenKind.DotPlus):
                val right = self.parse_matmul_expr()
                left = Expr(
                    kind: ExprKind.Binary(BinOp.BroadcastAdd, left, right),
                    span: left.span.merge(right.span)
                )
            elif self.match_token(TokenKind.DotMinus):
                val right = self.parse_matmul_expr()
                left = Expr(
                    kind: ExprKind.Binary(BinOp.BroadcastSub, left, right),
                    span: left.span.merge(right.span)
                )
            else:
                break

        left

    me parse_matmul_expr() -> Expr:
        """Parse matrix multiplication expression (@)."""
        var left = self.parse_multiplicative_expr()

        while self.match_token(TokenKind.At):
            val right = self.parse_multiplicative_expr()
            left = Expr(
                kind: ExprKind.Binary(BinOp.MatMul, left, right),
                span: left.span.merge(right.span)
            )

        left

    me parse_multiplicative_expr() -> Expr:
        """Parse multiplicative expression (including broadcast .* and ./)."""
        var left = self.parse_power_expr()

        loop:
            if self.match_token(TokenKind.Star):
                val right = self.parse_power_expr()
                left = Expr(
                    kind: ExprKind.Binary(BinOp.Mul, left, right),
                    span: left.span.merge(right.span)
                )
            elif self.match_token(TokenKind.Slash):
                val right = self.parse_power_expr()
                left = Expr(
                    kind: ExprKind.Binary(BinOp.Div, left, right),
                    span: left.span.merge(right.span)
                )
            elif self.match_token(TokenKind.Percent):
                val right = self.parse_power_expr()
                left = Expr(
                    kind: ExprKind.Binary(BinOp.Mod, left, right),
                    span: left.span.merge(right.span)
                )
            elif self.match_token(TokenKind.DotStar):
                val right = self.parse_power_expr()
                left = Expr(
                    kind: ExprKind.Binary(BinOp.BroadcastMul, left, right),
                    span: left.span.merge(right.span)
                )
            elif self.match_token(TokenKind.DotSlash):
                val right = self.parse_power_expr()
                left = Expr(
                    kind: ExprKind.Binary(BinOp.BroadcastDiv, left, right),
                    span: left.span.merge(right.span)
                )
            elif self.match_token(TokenKind.ImplicitMul):
                # Implicit multiplication (m{} only): 2x, 2(x+1), (a)(b)
                val right = self.parse_power_expr()
                left = Expr(
                    kind: ExprKind.Binary(BinOp.Mul, left, right),
                    span: left.span.merge(right.span)
                )
            else:
                break

        left

    me parse_power_expr() -> Expr:
        """Parse power expression (right-associative, including .^ broadcast)."""
        val left = self.parse_unary_expr()

        if self.match_token(TokenKind.StarStar):
            val right = self.parse_power_expr()  # Right-associative
            return Expr(
                kind: ExprKind.Binary(BinOp.Pow, left, right),
                span: left.span.merge(right.span)
            )

        if self.match_token(TokenKind.DotCaret):
            val right = self.parse_power_expr()  # Right-associative
            return Expr(
                kind: ExprKind.Binary(BinOp.BroadcastPow, left, right),
                span: left.span.merge(right.span)
            )

        if self.match_token(TokenKind.Caret):
            val right = self.parse_power_expr()  # Right-associative (inside m{})
            return Expr(
                kind: ExprKind.Binary(BinOp.Pow, left, right),
                span: left.span.merge(right.span)
            )

        left

    me parse_unary_expr() -> Expr:
        """Parse unary expression."""
        val start = self.current.span

        if self.match_token(TokenKind.Minus):
            val operand = self.parse_unary_expr()
            return Expr(
                kind: ExprKind.Unary(UnaryOp.Neg, operand),
                span: start.merge(operand.span)
            )

        if self.match_token(TokenKind.KwNot) or self.match_token(TokenKind.Bang):
            val operand = self.parse_unary_expr()
            return Expr(
                kind: ExprKind.Unary(UnaryOp.Not, operand),
                span: start.merge(operand.span)
            )

        if self.match_token(TokenKind.Tilde):
            val operand = self.parse_unary_expr()
            return Expr(
                kind: ExprKind.Unary(UnaryOp.BitNot, operand),
                span: start.merge(operand.span)
            )

        if self.match_token(TokenKind.Ampersand):
            val operand = self.parse_unary_expr()
            return Expr(
                kind: ExprKind.Unary(UnaryOp.Ref, operand),
                span: start.merge(operand.span)
            )

        if self.match_token(TokenKind.KwAwait):
            val operand = self.parse_unary_expr()
            return Expr(
                kind: ExprKind.Await(operand),
                span: start.merge(operand.span)
            )

        self.parse_postfix_expr()

    me parse_postfix_expr() -> Expr:
        """Parse postfix expression (calls, indexing, field access)."""
        var expr = self.parse_primary_expr()

        loop:
            if self.match_token(TokenKind.TripleLess):
                # Kernel launch: kernel<<<grid, block>>>(args)
                val grid_dim = self.parse_expr()
                self.expect(TokenKind.Comma, "expected ',' between grid and block dimensions")
                val block_dim = self.parse_expr()
                self.expect(TokenKind.TripleGreater, "expected '>>>' after launch config")
                self.expect(TokenKind.LParen, "expected '(' for kernel arguments")
                val args = self.parse_call_args()
                self.expect(TokenKind.RParen, "expected ')' after kernel arguments")
                expr = Expr(
                    kind: ExprKind.KernelLaunch(expr, grid_dim, block_dim, args),
                    span: expr.span.merge(self.previous.span)
                )
            elif self.match_token(TokenKind.LParen):
                # Function call
                val args = self.parse_call_args()
                self.expect(TokenKind.RParen, "expected ')' after arguments")
                expr = Expr(
                    kind: ExprKind.Call(expr, args),
                    span: expr.span.merge(self.previous.span)
                )
            elif self.match_token(TokenKind.LBracket):
                # Index
                val index = self.parse_expr()
                self.expect(TokenKind.RBracket, "expected ']' after index")
                expr = Expr(
                    kind: ExprKind.Index(expr, index),
                    span: expr.span.merge(self.previous.span)
                )
            elif self.match_token(TokenKind.Dot):
                # Field access or method call
                val field = self.parse_identifier()
                if self.match_token(TokenKind.LParen):
                    val args = self.parse_call_args()
                    self.expect(TokenKind.RParen, "expected ')' after arguments")
                    expr = Expr(
                        kind: ExprKind.MethodCall(expr, field, args),
                        span: expr.span.merge(self.previous.span)
                    )
                else:
                    expr = Expr(
                        kind: ExprKind.Field(expr, field),
                        span: expr.span.merge(self.previous.span)
                    )
            elif self.match_token(TokenKind.QuestionDot):
                # Optional chaining
                val field = self.parse_identifier()
                expr = Expr(
                    kind: ExprKind.OptionalChain(expr, field),
                    span: expr.span.merge(self.previous.span)
                )
            elif self.match_token(TokenKind.DotQuestion):
                # Exists check
                expr = Expr(
                    kind: ExprKind.ExistsCheck(expr),
                    span: expr.span.merge(self.previous.span)
                )
            elif self.match_token(TokenKind.Question):
                # Try operator
                expr = Expr(
                    kind: ExprKind.Try(expr),
                    span: expr.span.merge(self.previous.span)
                )
            elif self.match_token(TokenKind.QuestionQuestion):
                # Null coalesce - allow return/break/continue as RHS
                if self.check(TokenKind.KwReturn) or self.check(TokenKind.KwBreak) or self.check(TokenKind.KwContinue):
                    val right = self.parse_primary_expr()
                    expr = Expr(
                        kind: ExprKind.NullCoalesce(expr, right),
                        span: expr.span.merge(right.span)
                    )
                else:
                    val right = self.parse_unary_expr()
                    expr = Expr(
                        kind: ExprKind.NullCoalesce(expr, right),
                        span: expr.span.merge(right.span)
                    )
            elif self.match_token(TokenKind.Transpose):
                # Postfix transpose (m{} only)
                expr = Expr(
                    kind: ExprKind.Unary(UnaryOp.Transpose, expr),
                    span: expr.span.merge(self.previous.span)
                )
            else:
                break

        expr

    me parse_primary_expr() -> Expr:
        """Parse primary expression."""
        val start = self.current.span

        match self.peek():
            case IntLit:
                val text = self.current.text
                self.advance()
                val value = parse_int_literal(text)
                Expr(kind: ExprKind.IntLit(value), span: start)

            case FloatLit:
                val text = self.current.text
                self.advance()
                val value = parse_float_literal(text)
                Expr(kind: ExprKind.FloatLit(value), span: start)

            case StringLit:
                self.parse_string_literal()

            case BoolLit:
                val value = self.current.text == "true"
                self.advance()
                Expr(kind: ExprKind.BoolLit(value), span: start)

            case NilLit:
                self.advance()
                Expr(kind: ExprKind.NilLit, span: start)

            case Ident:
                val name = self.current.text
                self.advance()

                # Check for set literal: s{...}
                if name == "s" and self.check(TokenKind.LBrace):
                    self.parse_set_literal_after_s(start)
                else:
                    Expr(kind: ExprKind.Ident(name), span: start)

            case LParen:
                self.advance()
                if self.check(TokenKind.RParen):
                    # Unit tuple ()
                    self.advance()
                    Expr(kind: ExprKind.TupleLit([]), span: start.merge(self.previous.span))
                else:
                    val expr = self.parse_expr()
                    if self.match_token(TokenKind.Comma):
                        # Tuple literal
                        var elements = [expr]
                        if not self.check(TokenKind.RParen):
                            elements = elements.push(self.parse_expr())
                            while self.match_token(TokenKind.Comma):
                                if self.check(TokenKind.RParen):
                                    break
                                elements = elements.push(self.parse_expr())
                        self.expect(TokenKind.RParen, "expected ')' after tuple")
                        Expr(kind: ExprKind.TupleLit(elements), span: start.merge(self.previous.span))
                    else:
                        # Grouped expression
                        self.expect(TokenKind.RParen, "expected ')'")
                        expr

            case LBracket:
                self.parse_array_or_comprehension()

            case LBrace:
                self.parse_dict_literal()

            case BlockStart:
                # BlockStart could be a block (m{, loss{) or a set literal (s{)
                # Check the text field to distinguish
                if self.current.text == "s":
                    self.parse_set_literal()
                else:
                    # Regular block - handle it (TODO: implement block parsing in expr context)
                    self.error("blocks in expression context not yet supported")
                    Expr(kind: ExprKind.Error, span: self.current.span)

            case Backslash:
                self.parse_lambda()

            case KwIf:
                self.parse_if_expr()

            case KwMatch:
                self.parse_match_expr()

            case KwReturn:
                self.advance()
                var value: Expr? = nil
                if not self.check(TokenKind.Newline) and not self.check(TokenKind.Dedent):
                    value = Some(self.parse_expr())
                Expr(kind: ExprKind.Return(value), span: start.merge(self.previous.span))

            case KwBreak:
                self.advance()
                Expr(kind: ExprKind.Break(nil), span: start)

            case KwContinue:
                self.advance()
                Expr(kind: ExprKind.Continue(nil), span: start)

            case KwYield:
                self.advance()
                var value: Expr? = nil
                if not self.check(TokenKind.Newline) and not self.check(TokenKind.Dedent):
                    value = Some(self.parse_expr())
                Expr(kind: ExprKind.Yield(value), span: start.merge(self.previous.span))

            case KwAwait:
                self.advance()
                val awaited_expr = self.parse_primary_expr()
                Expr(kind: ExprKind.Await(awaited_expr), span: start.merge(awaited_expr.span))

            case KwSpawn:
                self.advance()
                val spawned_expr = self.parse_primary_expr()
                Expr(kind: ExprKind.Spawn(spawned_expr), span: start.merge(spawned_expr.span))

            case KwThrow:
                self.advance()
                val value = self.parse_expr()
                Expr(kind: ExprKind.Throw(value), span: start.merge(value.span))

            case KwLoss:
                self.parse_loss_block()

            case KwNograd:
                self.parse_nograd_block()

            case KwUnsafe:
                self.parse_unsafe_block()

            case KwAsm:
                self.parse_asm_expr()

            case BlockStart:
                # Custom block (sh{}, sql{}, re{}, etc.)
                val kind = self.current.text
                self.parse_resolved_block(kind)

            case _:
                self.error("expected expression")
                self.advance()
                Expr(kind: ExprKind.Error, span: start)

    me parse_string_literal() -> Expr:
        """Parse string literal with interpolation."""
        val start = self.current.span
        val text = self.current.text
        self.advance()

        # For bootstrap: plain string literals only (no interpolation scanning)
        # TODO: Add interpolation support when needed for self-hosting
        Expr(kind: ExprKind.StringLit(text, nil), span: start)

    me parse_array_or_comprehension() -> Expr:
        """Parse array literal or list comprehension.

        Handles suffix notation for tensor types:
        - [1, 2, 3]f32        - f32 array
        - [1, 2, 3]_f32_gpu   - f32 tensor on GPU
        - [1, 2, 3]f32_tr_cuda - trainable f32 tensor on CUDA
        """
        val start = self.current.span
        self.advance()  # Consume '['

        # Check for empty array: [] or []f32
        if self.check(TokenKind.RBracket):
            self.advance()
            return Expr(kind: ExprKind.ArrayLit([]), span: start.merge(self.previous.span))
        if self.check(TokenKind.ArraySuffix):
            val suffix_text = self.current.text
            self.advance()
            val suffix = TensorSuffix.from_string(suffix_text)
            return Expr(
                kind: ExprKind.ArrayLitSuffix([], suffix),
                span: start.merge(self.previous.span)
            )

        # Check for comprehension
        if self.check(TokenKind.KwFor):
            return self.parse_list_comprehension(start)

        # Array literal
        var elements: [Expr] = []
        elements = elements.push(self.parse_expr())

        while self.match_token(TokenKind.Comma):
            if self.check(TokenKind.RBracket) or self.check(TokenKind.ArraySuffix):
                break
            elements = elements.push(self.parse_expr())

        # Check for suffix (ArraySuffix token includes the ] and suffix)
        if self.check(TokenKind.ArraySuffix):
            val suffix_text = self.current.text
            self.advance()
            val suffix = TensorSuffix.from_string(suffix_text)
            return Expr(
                kind: ExprKind.ArrayLitSuffix(elements, suffix),
                span: start.merge(self.previous.span)
            )

        # Regular array, expect RBracket
        self.expect(TokenKind.RBracket, "expected ']' after array elements")
        Expr(kind: ExprKind.ArrayLit(elements), span: start.merge(self.previous.span))

    me parse_list_comprehension(start: Span) -> Expr:
        """Parse list comprehension [for x in y if cond: expr]."""
        var clauses: [ComprehensionClause] = []

        while self.match_token(TokenKind.KwFor):
            val var_start = self.current.span
            val var_ = self.parse_identifier()
            self.expect(TokenKind.KwIn, "expected 'in' in comprehension")
            val iter = self.parse_expr()
            clauses = clauses.push(ComprehensionClause(
                kind: ComprehensionKind.For(var_, iter),
                span: var_start.merge(iter.span)
            ))

            while self.match_token(TokenKind.KwIf):
                val cond_start = self.previous.span
                val cond = self.parse_expr()
                clauses = clauses.push(ComprehensionClause(
                    kind: ComprehensionKind.If(cond),
                    span: cond_start.merge(cond.span)
                ))

        self.expect(TokenKind.Colon, "expected ':' in comprehension")
        val expr = self.parse_expr()
        self.expect(TokenKind.RBracket, "expected ']' after comprehension")

        Expr(kind: ExprKind.ListComprehension(expr, clauses), span: start.merge(self.previous.span))

    me parse_dict_literal() -> Expr:
        """Parse dict literal {key: value, ...}."""
        val start = self.current.span
        self.advance()  # Consume '{'

        if self.check(TokenKind.RBrace):
            self.advance()
            return Expr(kind: ExprKind.DictLit([]), span: start.merge(self.previous.span))

        var entries: [(Expr, Expr)] = []
        val key = self.parse_expr()
        self.expect(TokenKind.Colon, "expected ':' after dict key")
        val value = self.parse_expr()
        entries = entries.push((key, value))

        while self.match_token(TokenKind.Comma):
            if self.check(TokenKind.RBrace):
                break
            val k = self.parse_expr()
            self.expect(TokenKind.Colon, "expected ':' after dict key")
            val v = self.parse_expr()
            entries = entries.push((k, v))

        self.expect(TokenKind.RBrace, "expected '}' after dict entries")
        Expr(kind: ExprKind.DictLit(entries), span: start.merge(self.previous.span))

    me parse_set_literal() -> Expr:
        """Parse set literal s{elem1, elem2, ...}.

        Called from BlockStart case (for lexer-based approach).
        """
        val start = self.current.span
        self.advance()  # Consume BlockStart token

        # Check for empty set: s{}
        if self.check(TokenKind.RBrace):
            self.advance()
            return Expr(kind: ExprKind.SetLit([]), span: start.merge(self.previous.span))

        # Parse elements (comma-separated expressions)
        var elements: [Expr] = []
        elements = elements.push(self.parse_expr())

        while self.match_token(TokenKind.Comma):
            if self.check(TokenKind.RBrace):
                break  # Trailing comma
            elements = elements.push(self.parse_expr())

        self.expect(TokenKind.RBrace, "expected '}' after set elements")
        Expr(kind: ExprKind.SetLit(elements), span: start.merge(self.previous.span))

    me parse_set_literal_after_s(start: Span) -> Expr:
        """Parse set literal after seeing 's' identifier.

        The 's' has been consumed, now we expect {elem1, elem2, ...}
        This is the parser-only approach that works with existing tokens.
        """
        self.advance()  # Consume LBrace

        # Check for empty set: s{}
        if self.check(TokenKind.RBrace):
            self.advance()
            return Expr(kind: ExprKind.SetLit([]), span: start.merge(self.previous.span))

        # Parse elements (comma-separated expressions)
        var elements: [Expr] = []
        elements = elements.push(self.parse_expr())

        while self.match_token(TokenKind.Comma):
            if self.check(TokenKind.RBrace):
                break  # Trailing comma
            elements = elements.push(self.parse_expr())

        self.expect(TokenKind.RBrace, "expected '}' after set elements")
        Expr(kind: ExprKind.SetLit(elements), span: start.merge(self.previous.span))

    me parse_lambda() -> Expr:
        """Parse lambda expression \x, y: expr."""
        val start = self.current.span
        self.advance()  # Consume '\'

        var params: [LambdaParam] = []

        if not self.check(TokenKind.Colon):
            params = params.push(self.parse_lambda_param())
            while self.match_token(TokenKind.Comma):
                params = params.push(self.parse_lambda_param())

        self.expect(TokenKind.Colon, "expected ':' after lambda parameters")
        val body = self.parse_expr()

        Expr(kind: ExprKind.Lambda(params, body), span: start.merge(body.span))

    me parse_lambda_param() -> LambdaParam:
        """Parse lambda parameter."""
        val start = self.current.span
        val name = self.parse_identifier()

        var type_: Type? = nil
        if self.match_token(TokenKind.Colon):
            type_ = Some(self.parse_type())

        LambdaParam(name: name, type_: type_, span: start.merge(self.previous.span))

    me parse_if_expr() -> Expr:
        """Parse if expression."""
        val start = self.current.span
        self.advance()  # Consume 'if'

        val cond = self.parse_expr()
        self.expect(TokenKind.Colon, "expected ':' after if condition")
        val then_ = self.parse_block()

        var else_: Block? = nil
        if self.match_token(TokenKind.KwElse):
            self.expect(TokenKind.Colon, "expected ':' after else")
            else_ = Some(self.parse_block())
        elif self.match_token(TokenKind.KwElif):
            # elif is sugar for else if
            val elif_expr = self.parse_if_expr()
            else_ = Some(Block(stmts: [Stmt(kind: StmtKind.Expr(elif_expr), span: elif_expr.span)], span: elif_expr.span))

        Expr(kind: ExprKind.If(cond, then_, else_), span: start.merge(self.previous.span))

    me parse_match_expr() -> Expr:
        """Parse match expression."""
        val start = self.current.span
        self.advance()  # Consume 'match'

        val scrutinee = self.parse_expr()
        self.expect(TokenKind.Colon, "expected ':' after match scrutinee")
        self.skip_newlines()
        self.expect(TokenKind.Indent, "expected indented match arms")

        var arms: [MatchArm] = []

        while not self.check(TokenKind.Dedent) and not self.is_at_end():
            self.skip_newlines()
            if self.check(TokenKind.Dedent):
                break

            # Support both syntaxes:
            # - `case pattern:` (traditional)
            # - `| pattern ->` (Erlang-style, preferred)
            val is_pipe_syntax = self.check(TokenKind.Pipe)
            if is_pipe_syntax:
                self.advance()  # consume `|`
            elif self.check(TokenKind.KwCase):
                self.advance()  # consume `case`
            else:
                self.error("expected 'case' or '|' in match arm")

            val pattern = self.parse_pattern()

            var guard: Expr? = nil
            if self.match_token(TokenKind.KwIf):
                guard = Some(self.parse_expr())

            # For `| pattern ->` syntax, expect `->`
            # For `case pattern:` syntax, accept `:` or `->`
            if is_pipe_syntax:
                self.expect(TokenKind.Arrow, "expected '->' after pattern in | syntax")
            elif self.check(TokenKind.Arrow):
                self.advance()
            else:
                self.expect(TokenKind.Colon, "expected ':' or '->' after pattern")

            val body = self.parse_block()

            arms = arms.push(MatchArm(
                pattern: pattern,
                guard: guard,
                body: body,
                span: pattern.span.merge(body.span)
            ))

        self.match_token(TokenKind.Dedent)

        Expr(kind: ExprKind.MatchCase(scrutinee, arms), span: start.merge(self.previous.span))

    me parse_loss_block() -> Expr:
        """Parse loss{ ... } block.

        Loss blocks enable gradient tracking and auto-backward.
        They inherit m{} math block features (^, ', implicit mul).
        """
        val start = self.current.span
        self.advance()  # Consume 'loss' (math mode already enabled by lexer)
        self.expect(TokenKind.LBrace, "expected '{' after 'loss'")
        val body = self.parse_block()
        self.expect(TokenKind.RBrace, "expected '}' after loss block")
        Expr(kind: ExprKind.LossBlock(body), span: start.merge(self.previous.span))

    me parse_nograd_block() -> Expr:
        """Parse nograd{ ... } block.

        Nograd blocks disable gradient tracking for faster inference.
        They inherit m{} math block features (^, ', implicit mul).
        """
        val start = self.current.span
        self.advance()  # Consume 'nograd' (math mode already enabled by lexer)
        self.expect(TokenKind.LBrace, "expected '{' after 'nograd'")
        val body = self.parse_block()
        self.expect(TokenKind.RBrace, "expected '}' after nograd block")
        Expr(kind: ExprKind.NogradBlock(body), span: start.merge(self.previous.span))

    me parse_unsafe_block() -> Expr:
        """Parse unsafe: block.

        Unsafe blocks allow raw pointer operations, FFI calls,
        inline assembly, and other operations that bypass safety checks.

        Syntax:
            unsafe:
                val ptr = 0x1000 as *u32
                val value = *ptr
        """
        val start = self.current.span
        self.advance()  # Consume 'unsafe'
        self.expect(TokenKind.Colon, "expected ':' after 'unsafe'")
        val body = self.parse_block()
        Expr(kind: ExprKind.UnsafeBlock(body), span: start.merge(self.previous.span))

    me parse_asm_expr() -> Expr:
        """Parse inline assembly expression.

        Supports two syntaxes:
        1. Simple: asm "mov eax, ebx"
        2. Full: asm volatile("mov r0, {op}", op = in(reg) value, clobber_abi("C"))

        Must be within unsafe block (enforced during type checking).
        """
        val start = self.current.span
        self.advance()  # Consume 'asm'

        # Check for 'volatile' keyword
        val is_volatile = if self.current.kind == TokenKind.Ident and self.current.text == "volatile":
            self.advance()
            true
        else:
            false

        # Expect opening paren (for both simple and full syntax)
        if not self.check(TokenKind.LParen):
            self.error("expected '(' after 'asm'")
            return Expr(kind: ExprKind.Error, span: start)

        self.advance()  # Consume '('

        # Parse assembly template string
        if self.current.kind != TokenKind.StringLit:
            self.error("expected assembly template string")
            return Expr(kind: ExprKind.Error, span: start)

        val asm_template = self.current.text
        self.advance()

        # Parse optional constraints
        var constraints: [AsmConstraint] = []
        var clobbers: [text] = []

        # If we see a comma, parse constraints
        while self.current.kind == TokenKind.Comma:
            self.advance()  # Consume ','

            # Check for clobber_abi("C") special case
            if self.current.kind == TokenKind.Ident and self.current.text == "clobber_abi":
                self.advance()  # Consume 'clobber_abi'
                self.expect(TokenKind.LParen, "expected '(' after 'clobber_abi'")
                if self.current.kind == TokenKind.StringLit:
                    # Just consume and ignore for now - we'll add proper handling later
                    self.advance()
                else:
                    self.error("expected ABI string")
                self.expect(TokenKind.RParen, "expected ')' after ABI")
                continue

            # Parse constraint: name = kind(location) value
            if self.current.kind != TokenKind.Ident:
                self.error("expected constraint name")
                break

            val constraint_name = self.current.text
            self.advance()

            self.expect(TokenKind.Assign, "expected '=' after constraint name")

            # Parse constraint kind: in, out, inout, lateout
            if self.current.kind != TokenKind.Ident:
                self.error("expected constraint kind (in, out, inout, lateout)")
                break

            val kind_str = self.current.text
            val kind = match kind_str:
                case "in": AsmConstraintKind.In
                case "out": AsmConstraintKind.Out
                case "inout": AsmConstraintKind.InOut
                case "lateout": AsmConstraintKind.LateOut
                case _:
                    self.error("invalid constraint kind: {kind_str}")
                    AsmConstraintKind.In

            self.advance()

            # Parse location: (reg) or (mem) or (imm)
            self.expect(TokenKind.LParen, "expected '(' after constraint kind")

            if self.current.kind != TokenKind.Ident:
                self.error("expected location specifier (reg, mem, imm)")
                break

            val location_str = self.current.text
            val location = match location_str:
                case "reg": AsmLocation.Reg
                case "mem": AsmLocation.Mem
                case "imm": AsmLocation.Imm
                case _:
                    # Specific register like "eax", "r0"
                    AsmLocation.RegSpec(location_str)

            self.advance()
            self.expect(TokenKind.RParen, "expected ')' after location")

            # Parse value expression
            val value = self.parse_expression()

            val constraint = AsmConstraint(
                name: constraint_name,
                kind: kind,
                location: location,
                value: value,
                span: start.merge(self.previous.span)
            )
            constraints.push(constraint)

        # Expect closing paren
        self.expect(TokenKind.RParen, "expected ')' after assembly expression")

        val asm_expr = AsmExpr(
            asm_template: asm_template,
            is_volatile: is_volatile,
            constraints: constraints,
            clobbers: clobbers,
            span: start.merge(self.previous.span)
        )

        Expr(kind: ExprKind.AsmBlock(asm_expr), span: start.merge(self.previous.span))

    # ========================================================================
    # Custom Block Parsing
    # ========================================================================

    me parse_resolved_block(kind: text) -> Expr:
        """Parse a custom block using pre-resolved value.

        Called when a BlockStart token is encountered. Looks up the
        pre-resolved value and skips the payload tokens.

        Args:
            kind: The block kind (e.g., "sh", "sql", "re")
        """
        val start = self.current.span
        self.advance()  # Consume BlockStart

        # Look up pre-resolved value
        if self.resolved_blocks.?:
            val resolved = self.resolved_blocks.unwrap()
            val block = resolved.lookup(start)

            if block.?:
                val rb = block.unwrap()
                # Skip payload tokens (already processed by BlockResolver)
                self.skip_to_block_end()

                # Consume the closing brace/BlockEnd
                if self.check(TokenKind.BlockEnd):
                    self.advance()
                elif self.check(TokenKind.RBrace):
                    self.advance()

                return Expr(
                    kind: ExprKind.CustomBlock(rb.kind, rb.value),
                    span: start.merge(self.previous.span)
                )

        # Fallback: inline parsing (block not pre-resolved)
        self.parse_block_inline(kind, start)

    me parse_block_inline(kind: text, start: Span) -> Expr:
        """Parse a block inline when not pre-resolved.

        This is a fallback for when blocks are parsed without going
        through the BlockResolver phase.
        """
        # Expect opening brace
        self.expect(TokenKind.LBrace, "expected '{{' after block keyword '{kind}'")

        # For inline parsing, we treat it as a raw block
        # Skip until matching closing brace
        var brace_depth = 1
        val payload_start = self.current.span.start

        while brace_depth > 0 and not self.is_at_end():
            match self.peek():
                case LBrace:
                    brace_depth = brace_depth + 1
                    self.advance()
                case RBrace:
                    brace_depth = brace_depth - 1
                    if brace_depth > 0:
                        self.advance()
                case BlockEnd:
                    brace_depth = brace_depth - 1
                    if brace_depth > 0:
                        self.advance()
                case _:
                    self.advance()

        val payload_end = self.previous.span.end
        val payload = self.source[payload_start:payload_end]

        # Consume closing brace
        if self.check(TokenKind.RBrace) or self.check(TokenKind.BlockEnd):
            self.advance()

        # Create a Raw block value for inline parsing
        Expr(
            kind: ExprKind.CustomBlock(kind, BlockValue.Raw(payload)),
            span: start.merge(self.previous.span)
        )

    me skip_to_block_end():
        """Skip tokens until reaching the end of a block.

        Used when the block payload has been pre-processed by BlockResolver.
        """
        var brace_depth = 1

        while brace_depth > 0 and not self.is_at_end():
            match self.peek():
                case LBrace:
                    brace_depth = brace_depth + 1
                    self.advance()
                case RBrace:
                    brace_depth = brace_depth - 1
                    if brace_depth > 0:
                        self.advance()
                    # Don't consume the final }
                case BlockEnd:
                    brace_depth = brace_depth - 1
                    if brace_depth > 0:
                        self.advance()
                    # Don't consume the final BlockEnd
                case BlockPayload:
                    # Skip raw payload token
                    self.advance()
                case _:
                    self.advance()

    me parse_call_args() -> [CallArg]:
        """Parse function call arguments."""
        var args: [CallArg] = []

        if not self.check(TokenKind.RParen):
            args = args.push(self.parse_call_arg())
            while self.match_token(TokenKind.Comma):
                if self.check(TokenKind.RParen):
                    break
                args = args.push(self.parse_call_arg())

        args

    me parse_call_arg() -> CallArg:
        """Parse single call argument."""
        val start = self.current.span

        # Check for named argument using 2-token lookahead (copy parser to peek)
        if self.check(TokenKind.Ident):
            var lookahead = self
            lookahead.advance()
            if lookahead.check(TokenKind.Colon):
                # Confirmed named argument: ident ':' expr
                val name = self.current.text
                self.advance()  # consume ident
                self.advance()  # consume colon
                val value = self.parse_expr()
                return CallArg(name: Some(name), value: value, span: start.merge(value.span))

        # Not a named argument, parse as full expression
        val value = self.parse_expr()
        CallArg(name: nil, value: value, span: start.merge(value.span))

    me parse_identifier() -> text:
        if self.check(TokenKind.Ident):
            val name = self.current.text
            self.advance()
            name
        else:
            self.error("expected identifier")
            "<error>"

    me parse_type() -> Type:
        """Parse a type expression (reuses outline type parsing logic)."""
        # Create temporary TreeSitter to parse type
        var ts = TreeSitter.new(self.source)
        var ts_lexer = ts.lexer
        ts_lexer.pos = self.lexer.pos
        ts.lexer = ts_lexer
        ts.current = self.current
        ts.previous = self.previous

        val outline = ts.parse_type_outline()
        self.current = ts.current
        self.previous = ts.previous
        var my_lexer = self.lexer
        my_lexer.pos = ts.lexer.pos
        self.lexer = my_lexer

        self.convert_type(outline)

    # ========================================================================
    # Pattern Parsing
    # ========================================================================

    me parse_pattern() -> Pattern:
        """Parse a pattern."""
        val start = self.current.span

        match self.peek():
            case Underscore:
                self.advance()
                Pattern(kind: PatternKind.Wildcard, span: start)

            case IntLit | FloatLit | StringLit | BoolLit | NilLit:
                val expr = self.parse_primary_expr()
                Pattern(kind: PatternKind.Literal(expr), span: start.merge(expr.span))

            case Ident:
                val name = self.current.text
                self.advance()

                if self.match_token(TokenKind.LParen):
                    # Enum pattern
                    self.parse_enum_pattern(name, start)
                elif self.match_token(TokenKind.LBrace):
                    # Struct pattern
                    self.parse_struct_pattern(name, start)
                else:
                    # Binding pattern
                    Pattern(kind: PatternKind.Binding(name, false), span: start)

            case KwVar:
                self.advance()
                val name = self.parse_identifier()
                Pattern(kind: PatternKind.Binding(name, true), span: start.merge(self.previous.span))

            case LParen:
                self.advance()
                if self.check(TokenKind.RParen):
                    self.advance()
                    Pattern(kind: PatternKind.Tuple([]), span: start.merge(self.previous.span))
                else:
                    var elements: [Pattern] = []
                    elements = elements.push(self.parse_pattern())
                    while self.match_token(TokenKind.Comma):
                        if self.check(TokenKind.RParen):
                            break
                        elements = elements.push(self.parse_pattern())
                    self.expect(TokenKind.RParen, "expected ')' after tuple pattern")
                    Pattern(kind: PatternKind.Tuple(elements), span: start.merge(self.previous.span))

            case LBracket:
                self.parse_array_pattern(start)

            case _:
                self.error("expected pattern")
                self.advance()
                Pattern(kind: PatternKind.Error, span: start)

    me parse_enum_pattern(enum_name: text, start: Span) -> Pattern:
        """Parse enum pattern Enum.Variant(...)."""
        var variant = enum_name
        var enum_ = ""

        # Check for Enum.Variant form
        if self.previous.kind == TokenKind.Dot:
            enum_ = enum_name
            variant = self.parse_identifier()

        var payload: EnumPatternPayload? = nil

        if not self.check(TokenKind.RParen):
            var patterns: [Pattern] = []
            patterns = patterns.push(self.parse_pattern())
            while self.match_token(TokenKind.Comma):
                if self.check(TokenKind.RParen):
                    break
                patterns = patterns.push(self.parse_pattern())
            payload = Some(EnumPatternPayload.Tuple(patterns))

        self.expect(TokenKind.RParen, "expected ')' after enum pattern")

        Pattern(
            kind: PatternKind.Enum(enum_, variant, payload),
            span: start.merge(self.previous.span)
        )

    me parse_struct_pattern(type_name: text, start: Span) -> Pattern:
        """Parse struct pattern Type { field, field: pattern }."""
        var fields: [(text, Pattern)] = []

        if not self.check(TokenKind.RBrace):
            val field = self.parse_identifier()
            var pattern: Pattern
            if self.match_token(TokenKind.Colon):
                pattern = self.parse_pattern()
            else:
                pattern = Pattern(kind: PatternKind.Binding(field, false), span: self.previous.span)
            fields = fields.push((field, pattern))

            while self.match_token(TokenKind.Comma):
                if self.check(TokenKind.RBrace):
                    break
                val f = self.parse_identifier()
                var p: Pattern
                if self.match_token(TokenKind.Colon):
                    p = self.parse_pattern()
                else:
                    p = Pattern(kind: PatternKind.Binding(f, false), span: self.previous.span)
                fields = fields.push((f, p))

        self.expect(TokenKind.RBrace, "expected '}' after struct pattern")

        Pattern(
            kind: PatternKind.Struct(type_name, fields),
            span: start.merge(self.previous.span)
        )

    me parse_array_pattern(start: Span) -> Pattern:
        """Parse array pattern [a, b, ..rest]."""
        self.advance()  # Consume '['

        var elements: [Pattern] = []
        var rest: text? = nil

        if not self.check(TokenKind.RBracket):
            if self.match_token(TokenKind.DotDot):
                rest = Some(self.parse_identifier())
            else:
                elements = elements.push(self.parse_pattern())

            while self.match_token(TokenKind.Comma):
                if self.check(TokenKind.RBracket):
                    break
                if self.match_token(TokenKind.DotDot):
                    rest = Some(self.parse_identifier())
                    break
                elements = elements.push(self.parse_pattern())

        self.expect(TokenKind.RBracket, "expected ']' after array pattern")

        Pattern(
            kind: PatternKind.Array(elements, rest),
            span: start.merge(self.previous.span)
        )

    # ========================================================================
    # Statement and Block Parsing
    # ========================================================================

    me parse_block() -> Block:
        """Parse a block of statements."""
        val start = self.current.span
        var stmts: [Stmt] = []

        self.skip_newlines()

        if self.match_token(TokenKind.Indent):
            while not self.check(TokenKind.Dedent) and not self.is_at_end():
                self.skip_newlines()
                if self.check(TokenKind.Dedent):
                    break
                stmts = stmts.push(self.parse_stmt())
            self.match_token(TokenKind.Dedent)
        else:
            # Single-line block
            stmts = stmts.push(self.parse_stmt())

        Block(stmts: stmts, span: start.merge(self.previous.span))

    me parse_stmt() -> Stmt:
        """Parse a statement."""
        # Guard against nil token
        if not self.current.kind.?:
            val empty_span = Span(start: 0, end: 0, line: 1, col: 1)
            val empty_expr = Expr(kind: ExprKind.Error("unexpected nil token"), span: empty_span)
            return Stmt(kind: StmtKind.Expr(empty_expr), span: empty_span)

        val start = self.current.span

        match self.peek():
            case KwVal:
                self.parse_val_stmt()
            case KwVar:
                self.parse_var_stmt()
            case KwShared:
                self.parse_shared_stmt()
            case KwFor:
                self.parse_for_stmt()
            case KwWhile:
                self.parse_while_stmt()
            case KwLoop:
                self.parse_loop_stmt()
            case KwReturn:
                self.advance()
                var value: Expr? = nil
                if not self.check(TokenKind.Newline) and not self.check(TokenKind.Dedent):
                    value = Some(self.parse_expr())
                self.skip_newlines()
                Stmt(kind: StmtKind.Return(value), span: start.merge(self.previous.span))
            case KwBreak:
                self.advance()
                self.skip_newlines()
                Stmt(kind: StmtKind.Break(nil), span: start)
            case KwContinue:
                self.advance()
                self.skip_newlines()
                Stmt(kind: StmtKind.Continue(nil), span: start)
            case KwYield:
                self.advance()
                var value: Expr? = nil
                if not self.check(TokenKind.Newline) and not self.check(TokenKind.Dedent):
                    value = Some(self.parse_expr())
                self.skip_newlines()
                Stmt(kind: StmtKind.Yield(value), span: start.merge(self.previous.span))
            case KwThrow:
                self.advance()
                val value = self.parse_expr()
                self.skip_newlines()
                Stmt(kind: StmtKind.Throw(value), span: start.merge(value.span))
            case KwWith:
                self.parse_with_stmt()
            case _:
                self.parse_expr_or_assign_stmt()

    me parse_val_stmt() -> Stmt:
        """Parse val statement.
        Supports continuation on next line: val x = \n    expr
        """
        val start = self.current.span
        self.advance()  # Consume 'val'

        val name = self.parse_identifier()

        var type_: Type? = nil
        if self.match_token(TokenKind.Colon):
            type_ = Some(self.parse_type())

        self.expect(TokenKind.Assign, "expected '=' in val declaration")
        # Skip newlines after = to allow continuation on next line
        self.skip_newlines()
        # Track if we consumed an indent (need to consume matching dedent)
        var consumed_indent = false
        if self.match_token(TokenKind.Indent):
            consumed_indent = true
        val init = self.parse_expr()
        # Consume matching dedent if we consumed an indent
        if consumed_indent:
            self.skip_newlines()
            self.match_token(TokenKind.Dedent)
        self.skip_newlines()

        Stmt(kind: StmtKind.Val(name, type_, init), span: start.merge(init.span))

    me parse_var_stmt() -> Stmt:
        """Parse var statement.
        Supports continuation on next line: var x = \n    expr
        """
        val start = self.current.span
        self.advance()  # Consume 'var'

        val name = self.parse_identifier()

        var type_: Type? = nil
        if self.match_token(TokenKind.Colon):
            type_ = Some(self.parse_type())

        var init: Expr? = nil
        if self.match_token(TokenKind.Assign):
            # Skip newlines after = to allow continuation on next line
            self.skip_newlines()
            # Track if we consumed an indent (need to consume matching dedent)
            var consumed_indent = false
            if self.match_token(TokenKind.Indent):
                consumed_indent = true
            init = Some(self.parse_expr())
            # Consume matching dedent if we consumed an indent
            if consumed_indent:
                self.skip_newlines()
                self.match_token(TokenKind.Dedent)

        self.skip_newlines()

        Stmt(kind: StmtKind.Var(name, type_, init), span: start.merge(self.previous.span))

    me parse_shared_stmt() -> Stmt:
        """Parse shared memory declaration.

        Syntax:
            shared val name: Type
            shared val name: [Type; size]
            shared var name: Type
            shared var name: [Type; size]

        Used for GPU shared memory in kernel functions.
        """
        val start = self.current.span
        self.advance()  # Consume 'shared'

        val is_mutable = self.check(TokenKind.KwVar)
        if not self.check(TokenKind.KwVal) and not self.check(TokenKind.KwVar):
            self.error("expected 'val' or 'var' after 'shared'")
            return Stmt(
                kind: StmtKind.Expr(Expr(kind: ExprKind.Error("expected val/var after shared"), span: start)),
                span: start
            )
        self.advance()  # Consume 'val' or 'var'

        val name = self.parse_identifier()

        # Type is required for shared memory
        self.expect(TokenKind.Colon, "expected ':' after shared variable name")
        val type_ = self.parse_type()

        # Optional size expression for arrays: [Type; size]
        var size: Expr? = nil
        if self.match_token(TokenKind.Semicolon):
            size = Some(self.parse_expr())

        self.skip_newlines()

        if is_mutable:
            Stmt(kind: StmtKind.SharedVar(name, type_, size), span: start.merge(self.previous.span))
        else:
            Stmt(kind: StmtKind.SharedVal(name, type_, size), span: start.merge(self.previous.span))

    me parse_for_stmt() -> Stmt:
        """Parse for statement."""
        val start = self.current.span
        self.advance()  # Consume 'for'

        val var_ = self.parse_identifier()
        self.expect(TokenKind.KwIn, "expected 'in' in for loop")
        val iter = self.parse_expr()
        self.expect(TokenKind.Colon, "expected ':' after for header")
        val body = self.parse_block()

        Stmt(kind: StmtKind.For(var_, iter, body), span: start.merge(body.span))

    me parse_while_stmt() -> Stmt:
        """Parse while statement."""
        val start = self.current.span
        self.advance()  # Consume 'while'

        val cond = self.parse_expr()
        self.expect(TokenKind.Colon, "expected ':' after while condition")
        val body = self.parse_block()

        Stmt(kind: StmtKind.While(cond, body), span: start.merge(body.span))

    me parse_loop_stmt() -> Stmt:
        """Parse loop statement."""
        val start = self.current.span
        self.advance()  # Consume 'loop'

        self.expect(TokenKind.Colon, "expected ':' after loop")
        val body = self.parse_block()

        Stmt(kind: StmtKind.Loop(body), span: start.merge(body.span))

    me parse_with_stmt() -> Stmt:
        """Parse with statement.

        Syntax:
            with expr as var:
                body
            with expr1 as var1, expr2 as var2:
                body
            with expr:
                body
        """
        val start = self.current.span
        self.advance()  # Consume 'with'

        var items: [WithItem] = []

        # Parse one or more context manager items
        var continue_parsing = true
        while continue_parsing:
            # Parse context expression
            val context_expr = self.parse_expr()

            # Check for optional 'as' binding
            var target: text? = nil
            if self.match_token(TokenKind.KwAs):
                target = self.parse_identifier()

            # Create WithItem
            val item = WithItem(
                context_expr: context_expr,
                target: target,
                span: start.merge(self.previous.span)
            )
            items = items.push(item)

            # Check for comma (multiple context managers)
            if self.check(TokenKind.Comma):
                self.advance()
                continue_parsing = true
            else:
                continue_parsing = false

        # Expect ':' before body
        self.expect(TokenKind.Colon, "expected ':' after with statement")

        # Parse block body
        val body = self.parse_block()

        Stmt(kind: StmtKind.With(items, body), span: start.merge(body.span))

    me parse_expr_or_assign_stmt() -> Stmt:
        """Parse expression or assignment statement."""
        val start = self.current.span
        val expr = self.parse_expr()

        # Check for assignment
        if self.check(TokenKind.Assign):
            self.advance()
            val value = self.parse_expr()
            self.skip_newlines()
            return Stmt(kind: StmtKind.Assign(expr, nil, value), span: start.merge(value.span))

        if self.check(TokenKind.PlusEq):
            self.advance()
            val value = self.parse_expr()
            self.skip_newlines()
            return Stmt(kind: StmtKind.Assign(expr, Some(AssignOp.Add), value), span: start.merge(value.span))

        if self.check(TokenKind.MinusEq):
            self.advance()
            val value = self.parse_expr()
            self.skip_newlines()
            return Stmt(kind: StmtKind.Assign(expr, Some(AssignOp.Sub), value), span: start.merge(value.span))

        if self.check(TokenKind.StarEq):
            self.advance()
            val value = self.parse_expr()
            self.skip_newlines()
            return Stmt(kind: StmtKind.Assign(expr, Some(AssignOp.Mul), value), span: start.merge(value.span))

        if self.check(TokenKind.SlashEq):
            self.advance()
            val value = self.parse_expr()
            self.skip_newlines()
            return Stmt(kind: StmtKind.Assign(expr, Some(AssignOp.Div), value), span: start.merge(value.span))

        if self.check(TokenKind.PercentEq):
            self.advance()
            val value = self.parse_expr()
            self.skip_newlines()
            return Stmt(kind: StmtKind.Assign(expr, Some(AssignOp.Mod), value), span: start.merge(value.span))

        self.skip_newlines()
        Stmt(kind: StmtKind.Expr(expr), span: expr.span)

# ============================================================================
# Helper Functions
# ============================================================================

fn parse_int_literal(text: text) -> i64:
    """Parse integer literal."""
    # Handle different bases
    if text.starts_with("0x") or text.starts_with("0X"):
        # Hex
        parse_int_base(text[2:], 16)
    elif text.starts_with("0b") or text.starts_with("0B"):
        # Binary
        parse_int_base(text[2:], 2)
    elif text.starts_with("0o") or text.starts_with("0O"):
        # Octal
        parse_int_base(text[2:], 8)
    else:
        # Decimal
        parse_int_base(text, 10)

fn parse_int_base(text: text, base: i64) -> i64:
    """Parse integer in given base."""
    var result: i64 = 0
    for ch in text:
        if ch == '_':
            pass  # Skip underscores (numeric separators)
        else:
            val digit = char_to_digit(ch, base)
            if digit < 0:
                return result  # Stop on invalid character
            result = result * base + digit
    result

fn char_to_digit(ch: text, base: i64) -> i64:
    """Convert a single character to its digit value in the given base."""
    val code = ch.ord()
    val digit = if code >= 48 and code <= 57:
        code - 48  # '0'-'9'
    elif code >= 65 and code <= 70:
        code - 55  # 'A'-'F' -> 10-15
    elif code >= 97 and code <= 102:
        code - 87  # 'a'-'f' -> 10-15
    else:
        -1
    if digit >= base:
        -1
    else:
        digit


# ============================================================================
# Factory functions (standalone, for interpreter compatibility)
# ============================================================================

fn create_parser(src: text) -> Parser:
    """Create a Parser from source text. Standalone function for interpreter compatibility.
    Use this instead of Parser.new() when running in interpreter mode."""
    var p = Parser(
        source: src,
        lexer: create_lexer(src),
        current: create_token_eof(0, 1),
        previous: create_token_eof(0, 1),
        errors: [],
        outline: nil,
        resolved_blocks: nil
    )
    p.advance()
    p

# ============================================================================
# Exports
# ============================================================================

export Parser, create_parser
