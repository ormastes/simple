# Construct Capsule: module
#
# Groups all compiler files that handle module/use declarations.
# Tier: meta (depends on all other constructs — organizes them)
# Dimension: construct (vertical second axis)
# Participation: shared_bind

use compiler.mdsoc.types.*

export module_capsule_def

fn module_capsule_def() -> ConstructCapsule:
    """Define the module construct capsule.

    Module system (use declarations, exports, module resolution)
    is a meta-tier construct that organizes all other constructs.
    """
    var cap = ConstructCapsule.new("module", ConstructKind.Module, ConstructTier.Meta)

    cap.exclusive_files = []

    # Shared files
    val sb_parser_decls = SharedBinding.new("10.frontend/core/parser_decls.spl", "func", 10)
    val sb_ast = SharedBinding.new("10.frontend/core/ast.spl", "func", 10)
    val sb_resolve = SharedBinding.new("35.semantics/resolve.spl", "variable", 35)
    val sb_module_loader = SharedBinding.new("99.loader/loader/module_loader.spl", "module", 99)
    val sb_driver = SharedBinding.new("80.driver/driver.spl", "module", 80)

    cap.shared_bindings = [sb_parser_decls, sb_ast, sb_resolve, sb_module_loader, sb_driver]

    # Meta tier — depends on everything below (summarized as key dependencies)
    cap.depends_on = ["func", "class_struct", "enum", "trait", "variable", "expr"]

    cap
