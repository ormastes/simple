# MDSOC Construct Dimension Type Definitions
#
# Types for the second (vertical) axis of MDSOC decomposition.
# Groups compiler code by language construct across all pipeline phases.
#
# These types complement the core MDSOC types in types.spl.

export ConstructKind, ConstructTier
export SharedBinding, ConstructCapsule
export CrossDimensionQuery, CrossDimensionResult

# ============================================================================
# Construct Dimension â€” Second Axis
# ============================================================================

enum ConstructKind:
    """Language construct categories for the vertical 'construct' dimension.

    Groups compiler code by what language construct it handles,
    across all horizontal pipeline phases.
    """
    Func
    ClassStruct
    Enum
    Trait
    Variable
    Control
    Match
    Expr
    Async
    Block
    Module
    Asm

impl ConstructKind:
    fn to_text() -> text:
        match self:
            ConstructKind.Func: "func"
            ConstructKind.ClassStruct: "class_struct"
            ConstructKind.Enum: "enum"
            ConstructKind.Trait: "trait"
            ConstructKind.Variable: "variable"
            ConstructKind.Control: "control"
            ConstructKind.Match: "match"
            ConstructKind.Expr: "expr"
            ConstructKind.Async: "async"
            ConstructKind.Block: "block"
            ConstructKind.Module: "module"
            ConstructKind.Asm: "asm"

    static fn from_text(s: text) -> ConstructKind?:
        if s == "func":
            return Some(ConstructKind.Func)
        if s == "class_struct":
            return Some(ConstructKind.ClassStruct)
        if s == "enum":
            return Some(ConstructKind.Enum)
        if s == "trait":
            return Some(ConstructKind.Trait)
        if s == "variable":
            return Some(ConstructKind.Variable)
        if s == "control":
            return Some(ConstructKind.Control)
        if s == "match":
            return Some(ConstructKind.Match)
        if s == "expr":
            return Some(ConstructKind.Expr)
        if s == "async":
            return Some(ConstructKind.Async)
        if s == "block":
            return Some(ConstructKind.Block)
        if s == "module":
            return Some(ConstructKind.Module)
        if s == "asm":
            return Some(ConstructKind.Asm)
        nil

enum ConstructTier:
    """Dependency tiers for the construct dimension.

    Tier ordering (lower_to_upper direction):
      Core -> Flow -> Decl -> Advanced -> Meta
    Higher tiers can depend on lower tiers, not vice versa.
    """
    Core
    Flow
    Decl
    Advanced
    Meta

impl ConstructTier:
    fn to_text() -> text:
        match self:
            ConstructTier.Core: "core"
            ConstructTier.Flow: "flow"
            ConstructTier.Decl: "decl"
            ConstructTier.Advanced: "advanced"
            ConstructTier.Meta: "meta"

    fn tier_level() -> i64:
        """Numeric level for ordering (0 = lowest dependency)."""
        match self:
            ConstructTier.Core: 0
            ConstructTier.Flow: 1
            ConstructTier.Decl: 2
            ConstructTier.Advanced: 3
            ConstructTier.Meta: 4

    static fn from_text(s: text) -> ConstructTier?:
        if s == "core":
            return Some(ConstructTier.Core)
        if s == "flow":
            return Some(ConstructTier.Flow)
        if s == "decl":
            return Some(ConstructTier.Decl)
        if s == "advanced":
            return Some(ConstructTier.Advanced)
        if s == "meta":
            return Some(ConstructTier.Meta)
        nil

struct SharedBinding:
    """Binding of a file to a construct capsule, allowing shared membership.

    A file can belong to multiple construct capsules (shared_bind policy).
    primary_construct marks which capsule owns it most directly.
    """
    source_path: text
    construct_tags: [text]
    primary_construct: text
    layer_number: i64

impl SharedBinding:
    static fn new(path: text, primary: text, layer: i64) -> SharedBinding:
        SharedBinding(
            source_path: path,
            construct_tags: [],
            primary_construct: primary,
            layer_number: layer
        )

    fn is_primary_for(construct_name: text) -> bool:
        self.primary_construct == construct_name

    fn has_tag(construct_name: text) -> bool:
        for tag in self.construct_tags:
            if tag == construct_name:
                return true
        false

struct ConstructCapsule:
    """A virtual capsule grouping compiler files by language construct.

    Groups files vertically across all pipeline layers by what construct
    they handle (e.g., all trait code from parsing to backend).
    """
    name: text
    kind: ConstructKind
    tier: ConstructTier
    exclusive_files: [text]
    shared_bindings: [SharedBinding]
    depends_on: [text]

impl ConstructCapsule:
    static fn new(name: text, kind: ConstructKind, tier: ConstructTier) -> ConstructCapsule:
        ConstructCapsule(
            name: name,
            kind: kind,
            tier: tier,
            exclusive_files: [],
            shared_bindings: [],
            depends_on: []
        )

    fn file_count() -> i64:
        self.exclusive_files.len() + self.shared_bindings.len()

    fn has_exclusive_file(path: text) -> bool:
        for f in self.exclusive_files:
            if f == path:
                return true
        false

    fn find_shared_binding(path: text) -> SharedBinding?:
        for sb in self.shared_bindings:
            if sb.source_path == path:
                return Some(sb)
        nil

    fn depends_on_construct(name: text) -> bool:
        for dep in self.depends_on:
            if dep == name:
                return true
        false

struct CrossDimensionQuery:
    """Query for files at the intersection of feature and construct dimensions.

    Enables queries like: "all trait code in the parsing phase (layers 10-15)".
    Empty strings mean no filter on that dimension.
    """
    feature_filter: text
    construct_filter: text
    layer_min: i64
    layer_max: i64

impl CrossDimensionQuery:
    static fn new(feature: text, construct: text, min_layer: i64, max_layer: i64) -> CrossDimensionQuery:
        CrossDimensionQuery(
            feature_filter: feature,
            construct_filter: construct,
            layer_min: min_layer,
            layer_max: max_layer
        )

    static fn for_construct(construct: text) -> CrossDimensionQuery:
        CrossDimensionQuery.new("", construct, -1, 999)

    static fn for_feature(feature: text) -> CrossDimensionQuery:
        CrossDimensionQuery.new(feature, "", -1, 999)

    fn has_feature_filter() -> bool:
        self.feature_filter != ""

    fn has_construct_filter() -> bool:
        self.construct_filter != ""

    fn has_layer_filter() -> bool:
        self.layer_min >= 0 or self.layer_max < 999

struct CrossDimensionResult:
    """Result of a cross-dimension query.

    Returns files matching both the feature and construct criteria,
    along with counts of exclusive vs shared memberships.
    """
    matching_files: [text]
    exclusive_count: i64
    shared_count: i64

impl CrossDimensionResult:
    static fn empty() -> CrossDimensionResult:
        CrossDimensionResult(
            matching_files: [],
            exclusive_count: 0,
            shared_count: 0
        )

    fn total_count() -> i64:
        self.matching_files.len()

    fn has_results() -> bool:
        self.matching_files.len() > 0
