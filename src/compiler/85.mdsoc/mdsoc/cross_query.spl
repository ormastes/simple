# MDSOC Cross-Dimension Query
#
# Enables queries across the feature (horizontal) and construct (vertical)
# dimensions simultaneously. Answers questions like:
#   - "All trait code in the parsing phase (layers 10-15)"
#   - "All async code across layers 10-50"
#   - "All files in the 'typing' feature that handle expressions"
#
# Uses the CrossDimensionQuery and CrossDimensionResult types from types.spl.

use compiler.mdsoc.types.*

export query_cross_dimension
export query_by_construct
export query_by_layer_range

# ============================================================================
# Cross-Dimension Query Function
# ============================================================================

fn query_cross_dimension(
    manifest: MdsocManifest,
    construct_capsules: [ConstructCapsule],
    query: CrossDimensionQuery
) -> CrossDimensionResult:
    """Query files at the intersection of feature and construct dimensions.

    Filters construct capsule files by:
    - construct_filter: only include files from matching construct capsule
    - layer_min/layer_max: only include files from matching layer range
    - feature_filter: only include files whose path contains the feature name

    Returns CrossDimensionResult with matching files and exclusive/shared counts.
    """
    var matching: [text] = []
    var exclusive_count: i64 = 0
    var shared_count: i64 = 0

    for cap in construct_capsules:
        # Filter by construct name
        if query.has_construct_filter():
            if cap.name != query.construct_filter:
                continue

        # Check exclusive files
        for file_path in cap.exclusive_files:
            val layer_num = _extract_layer_from_path(file_path)
            if _layer_in_range(layer_num, query.layer_min, query.layer_max):
                if _matches_feature(file_path, query.feature_filter):
                    matching.push(file_path)
                    exclusive_count = exclusive_count + 1

        # Check shared bindings
        for sb in cap.shared_bindings:
            val layer_num = sb.layer_number
            if _layer_in_range(layer_num, query.layer_min, query.layer_max):
                if _matches_feature(sb.source_path, query.feature_filter):
                    # Avoid duplicates: only add if not already in matching
                    if _not_in_list(matching, sb.source_path):
                        matching.push(sb.source_path)
                        shared_count = shared_count + 1

    CrossDimensionResult(
        matching_files: matching,
        exclusive_count: exclusive_count,
        shared_count: shared_count
    )

fn query_by_construct(
    construct_capsules: [ConstructCapsule],
    construct_name: text
) -> CrossDimensionResult:
    """Convenience: query all files for a specific construct across all layers."""
    val query = CrossDimensionQuery.for_construct(construct_name)
    var manifest = MdsocManifest.new("")
    query_cross_dimension(manifest, construct_capsules, query)

fn query_by_layer_range(
    construct_capsules: [ConstructCapsule],
    layer_min: i64,
    layer_max: i64
) -> CrossDimensionResult:
    """Convenience: query all construct files within a layer range."""
    val query = CrossDimensionQuery.new("", "", layer_min, layer_max)
    var manifest = MdsocManifest.new("")
    query_cross_dimension(manifest, construct_capsules, query)

# ============================================================================
# Helpers
# ============================================================================

fn _extract_layer_from_path(path: text) -> i64:
    """Extract the numeric layer prefix from a path like '25.traits/traits.spl'.

    Returns the two-digit layer number (e.g., 25), or -1 if not found.
    """
    # Find first '.' in path
    var i: i64 = 0
    var found_dot: i64 = -1
    for ch in path:
        if ch == ".":
            found_dot = i
            break
        i = i + 1

    if found_dot <= 0:
        return -1

    # Extract prefix before dot
    val prefix = path[0:found_dot]
    if prefix.len() == 0:
        return -1

    # Parse as integer
    var result: i64 = 0
    var is_num = true
    for ch in prefix:
        val digit_val = _digit_value(ch)
        if digit_val < 0:
            is_num = false
        else:
            result = result * 10 + digit_val

    if is_num and prefix.len() > 0:
        return result
    -1

fn _digit_value(ch: text) -> i64:
    """Return 0-9 if ch is a digit, -1 otherwise."""
    if ch == "0": return 0
    if ch == "1": return 1
    if ch == "2": return 2
    if ch == "3": return 3
    if ch == "4": return 4
    if ch == "5": return 5
    if ch == "6": return 6
    if ch == "7": return 7
    if ch == "8": return 8
    if ch == "9": return 9
    -1

fn _layer_in_range(layer_num: i64, min_layer: i64, max_layer: i64) -> bool:
    """Check if a layer number falls within [min_layer, max_layer].

    If layer_num is -1 (unrecognized), it passes any range filter.
    If min_layer is -1, no lower bound.
    """
    if layer_num < 0:
        return true
    if min_layer >= 0 and layer_num < min_layer:
        return false
    if max_layer < 999 and layer_num > max_layer:
        return false
    true

fn _matches_feature(path: text, feature_filter: text) -> bool:
    """Check if a path matches the feature filter.

    Empty filter matches everything.
    Non-empty filter requires path to contain the filter string.
    """
    if feature_filter == "":
        return true
    path.contains(feature_filter)

fn _not_in_list(list: [text], item: text) -> bool:
    """Return true if item is not already in list."""
    for existing in list:
        if existing == item:
            return false
    true
