# Trait Definitions
#
# Core trait definition types: TraitDef, MethodSignature, TraitBound.
# Split from traits.spl for modularity.

use compiler.hir.hir.*
use compiler.core.lexer.*

# ============================================================================
# Trait Definition
# ============================================================================

struct TraitDef:
    """Definition of a trait.

    A trait declares method signatures that types can implement.

    Example:
        trait Display:
            fn to_string() -> text
    """
    name: Symbol                    # Trait name
    methods: [MethodSignature]      # Required method signatures
    defaults: [HirFunction]         # Default implementations
    supertraits: [Symbol]           # Supertrait bounds (Trait: Supertrait)
    type_params: [Symbol]           # Generic parameters on trait
    span: Span

impl TraitDef:
    static fn create(name: Symbol, span: Span) -> TraitDef:
        """Create a new trait definition."""
        TraitDef(
            name: name,
            methods: [],
            defaults: [],
            supertraits: [],
            type_params: [],
            span: span
        )

    fn has_method(method_name: text) -> bool:
        """Check if trait has a method with given name."""
        for method in self.methods:
            if method.name == method_name:
                return true
        false

    fn get_method(method_name: text) -> MethodSignature?:
        """Get method signature by name."""
        for method in self.methods:
            if method.name == method_name:
                return Some(method)
        nil

struct MethodSignature:
    """Method signature in a trait definition."""
    name: text                      # Method name
    params: [HirType]               # Parameter types
    return_type: HirType            # Return type
    effects: [Effect]               # Effect annotations
    span: Span

impl MethodSignature:
    fn arity() -> i64:
        """Get number of parameters."""
        self.params.len()

# ============================================================================
# Trait Bound
# ============================================================================

struct TraitBound:
    """A constraint on a type parameter: T: Trait

    Used in:
    - Function signatures: fn foo<T: Display>(x: T)
    - Where clauses: fn foo<T>(x: T) where T: Display
    - Impl blocks: impl<T: Clone> Clone for Vec<T>
    """
    type_param: Symbol              # Type variable being constrained (e.g., T)
    trait_name: Symbol              # Required trait (e.g., Display)
    span: Span

impl TraitBound:
    static fn create(type_param: Symbol, trait_name: Symbol, span: Span) -> TraitBound:
        """Create a new trait bound."""
        TraitBound(
            type_param: type_param,
            trait_name: trait_name,
            span: span
        )

enum TraitBoundKind:
    """Kind of trait bound."""
    Single(Symbol)                  # T: Trait
    Multiple([Symbol])              # T: Trait1 + Trait2
    Supertrait(Symbol, Symbol)      # In trait definition: trait Ord: Eq

impl TraitBoundKind:
    fn is_single() -> bool:
        match self:
            case Single(_): true
            case _: false

    fn traits() -> [Symbol]:
        """Get list of trait symbols in this bound."""
        match self:
            case Single(t): [t]
            case Multiple(ts): ts
            case Supertrait(sub, sup): [sub, sup]


# Auto-generated desugared static method wrappers
fn TraitDef__create(name: Symbol, span: Span) -> TraitDef:
    """Create a new trait definition."""
    TraitDef(
        name: name,
        methods: [],
        defaults: [],
        supertraits: [],
        type_params: [],
        span: span
    )


export TraitDef, MethodSignature, TraitBound, TraitBoundKind
