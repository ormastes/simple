# MIR - Mid-level Intermediate Representation (Data Structures)
#
# Lower-level IR between HIR and native code generation.
# Features:
# - Explicit control flow (basic blocks, terminators)
# - Explicit memory operations (load, store, alloc)
# - SSA form (each value defined once)
# - Type-annotated values
# - Ready for optimization and codegen
#
# This module contains:
# - MIR module structure and function definitions
# - MIR type system
# - Basic block and instruction definitions
# - MIR builder API for constructing MIR

use hir.SymbolId
use lexer.Span
use blocks.value.BlockValue

# ============================================================================
# MIR Module Structure
# ============================================================================

struct MirModule:
    """Complete MIR module."""
    name: text
    functions: Dict<SymbolId, MirFunction>
    statics: Dict<SymbolId, MirStatic>
    constants: Dict<SymbolId, MirConstant>
    types: Dict<SymbolId, MirTypeDef>

struct MirFunction:
    """Function in MIR."""
    symbol: SymbolId
    name: text
    signature: MirSignature
    locals: [MirLocal]
    blocks: [MirBlock]
    entry_block: BlockId
    span: Span

    # Generic template metadata for .smf template storage
    generic_params: [text]
    is_generic_template: bool
    specialization_of: text?
    type_bindings: Dict<text, HirType>

struct MirSignature:
    """Function signature."""
    params: [MirType]
    return_type: MirType
    is_variadic: bool

struct MirLocal:
    """Local variable slot."""
    id: LocalId
    name: text?
    type_: MirType
    kind: LocalKind

struct LocalId:
    """Local variable identifier."""
    id: i64

"""Kind of local variable."""
enum LocalKind:
    Arg(index: i64)     # Function argument
    Var                  # Regular variable
    Temp                 # Temporary (SSA)
    Return               # Return slot

struct MirStatic:
    """Static/global variable."""
    symbol: SymbolId
    name: text
    type_: MirType
    init: MirConstant?
    is_mutable: bool

struct MirConstant:
    """Compile-time constant."""
    symbol: SymbolId
    name: text
    type_: MirType
    value: MirConstValue

"""Constant value."""
enum MirConstValue:
    Int(value: i64)
    Float(value: f64)
    Bool(value: bool)
    Str(value: text)
    Array(elements: [MirConstValue])
    Tuple(elements: [MirConstValue])
    Struct(fields: Dict<text, MirConstValue>)
    Zero                 # Zero-initialized

struct MirTypeDef:
    """Type definition."""
    symbol: SymbolId
    name: text
    kind: MirTypeDefKind

"""Type definition kind."""
enum MirTypeDefKind:
    Struct(fields: [MirFieldDef])
    Enum(variants: [MirVariantDef])
    Union(variants: [MirType])

struct MirFieldDef:
    """Struct field definition."""
    name: text
    type_: MirType
    offset: i64

struct MirVariantDef:
    """Enum variant definition."""
    name: text
    discriminant: i64
    payload: MirType?

# ============================================================================
# MIR Types
# ============================================================================

struct MirType:
    """MIR type."""
    kind: MirTypeKind

"""MIR type kind."""
enum MirTypeKind:
    # Primitives
    I8, I16, I32, I64
    U8, U16, U32, U64
    F32, F64
    Bool
    Char
    Unit

    # Pointers and references
    Ptr(pointee: MirType, mutable: bool)
    Ref(referent: MirType, mutable: bool)
    FuncPtr(signature: MirSignature)

    # Aggregates
    Array(element: MirType, size: i64)
    Slice(element: MirType)
    Tuple(elements: [MirType])
    Struct(symbol: SymbolId)
    Enum(symbol: SymbolId)

    # Special
    Never              # !
    Opaque(name: text) # Foreign type

    # Async types
    Promise(inner: MirType)    # Promise<T> - async computation result
    Generator(yield_: MirType, return_: MirType)  # Generator yielding and returning types
    ActorType(message: MirType)    # Actor handling message type

impl MirType:
    static fn i64() -> MirType:
        MirType(kind: MirTypeKind.I64)

    static fn f64() -> MirType:
        MirType(kind: MirTypeKind.F64)

    static fn bool() -> MirType:
        MirType(kind: MirTypeKind.Bool)

    static fn unit() -> MirType:
        MirType(kind: MirTypeKind.Unit)

    static fn ptr(pointee: MirType, mutable: bool) -> MirType:
        MirType(kind: MirTypeKind.Ptr(pointee, mutable))

    static fn promise(inner: MirType) -> MirType:
        """Create Promise<T> type for async computations."""
        MirType(kind: MirTypeKind.Promise(inner))

    static fn generator(yield_ty: MirType, return_ty: MirType) -> MirType:
        """Create Generator<Y, R> type for generators."""
        MirType(kind: MirTypeKind.Generator(yield_ty, return_ty))

    static fn actor_type(message_ty: MirType) -> MirType:
        """Create ActorType<M> type for actors."""
        MirType(kind: MirTypeKind.ActorType(message_ty))

    fn primitive_size() -> i64?:
        """Get size for primitive types, nil for composite types."""
        match self.kind:
            case I8 | U8 | Bool: Some(1)
            case I16 | U16 | Char: Some(2)
            case I32 | U32 | F32: Some(4)
            case I64 | U64 | F64 | Ptr(_, _) | Ref(_, _) | FuncPtr(_): Some(8)
            case _: nil

    fn size_bytes() -> i64:
        """Get size in bytes."""
        val prim = self.primitive_size()
        if prim.?:
            return prim.unwrap()

        match self.kind:
            case Unit | Never: 0
            case Array(elem, size): elem.size_bytes() * size
            case Tuple(elements):
                var total = 0
                for e in elements:
                    total = total + e.size_bytes()
                total
            case _: 8  # Default pointer size

    fn alignment() -> i64:
        """Get alignment in bytes."""
        val prim = self.primitive_size()
        if prim.?:
            return prim.unwrap()

        match self.kind:
            case Unit | Never: 1
            case Array(elem, _): elem.alignment()
            case Tuple(elements):
                var max_align = 1
                for e in elements:
                    val align = e.alignment()
                    if align > max_align:
                        max_align = align
                max_align
            case _: 8

# ============================================================================
# MIR Basic Blocks
# ============================================================================

struct BlockId:
    """Basic block identifier."""
    id: i64

impl BlockId:
    static fn new(id: i64) -> BlockId:
        BlockId(id: id)

    static fn entry() -> BlockId:
        BlockId.new(0)

struct MirBlock:
    """Basic block."""
    id: BlockId
    label: text?
    instructions: [MirInst]
    terminator: MirTerminator

# ============================================================================
# MIR Instructions
# ============================================================================

struct MirInst:
    """MIR instruction."""
    kind: MirInstKind
    span: Span?

"""MIR instruction kind."""
enum MirInstKind:
    # Constants
    Const(dest: LocalId, value: MirConstValue, type_: MirType)

    # Moves and copies
    Copy(dest: LocalId, src: LocalId)
    Move(dest: LocalId, src: LocalId)

    # Arithmetic
    BinOp(dest: LocalId, op: MirBinOp, left: MirOperand, right: MirOperand)
    UnaryOp(dest: LocalId, op: MirUnaryOp, operand: MirOperand)
    CheckedBinOp(dest: LocalId, op: MirBinOp, left: MirOperand, right: MirOperand)

    # Memory
    Alloc(dest: LocalId, type_: MirType)
    Load(dest: LocalId, ptr: MirOperand)
    Store(ptr: MirOperand, value: MirOperand)
    GetElementPtr(dest: LocalId, base: MirOperand, indices: [MirOperand])

    # Aggregates
    Aggregate(dest: LocalId, kind: AggregateKind, operands: [MirOperand])
    GetField(dest: LocalId, base: MirOperand, field: i64)
    SetField(base: MirOperand, field: i64, value: MirOperand)

    # Casts
    Cast(dest: LocalId, operand: MirOperand, target: MirType)
    Bitcast(dest: LocalId, operand: MirOperand, target: MirType)

    # Function calls
    Call(dest: LocalId?, func: MirOperand, args: [MirOperand])
    CallIndirect(dest: LocalId?, ptr: MirOperand, args: [MirOperand], sig: MirSignature)

    # Intrinsics
    Intrinsic(dest: LocalId?, name: text, args: [MirOperand])

    # Inline assembly (must be in unsafe block)
    InlineAsm(
        asm_template: text,              # Assembly template with {operand} placeholders
        is_volatile: bool,               # Prevent optimization
        inputs: [MirAsmOperand],         # Input operands
        outputs: [MirAsmOperand],        # Output operands
        clobbers: [text]                 # Clobbered registers
    )

    # Pipeline operators (require runtime function dispatch)
    PipeForward(dest: LocalId, value: MirOperand, func: MirOperand)
    Compose(dest: LocalId, f: MirOperand, g: MirOperand, forward: bool)
    Parallel(dest: LocalId, funcs: [MirOperand])
    LayerConnect(dest: LocalId, layer1: MirOperand, layer2: MirOperand)

    # Debug
    DebugValue(local: LocalId, name: text)
    Nop

    # Async/Await Operations
    # Creates a Promise<T> from an async expression body
    CreatePromise(dest: LocalId, body: LocalId, result_type: MirType)
    # Awaits a Promise, suspending until resolved
    Await(dest: LocalId, promise: MirOperand)
    # Yields a value from a generator, suspending execution
    Yield(value: MirOperand?)
    # Spawns an async task/actor
    Spawn(dest: LocalId, handler: MirOperand, args: [MirOperand])
    # Sends a message to an actor
    Send(target: MirOperand, message: MirOperand)
    # Receives a message from mailbox (blocking with optional timeout)
    Receive(dest: LocalId, timeout: MirOperand?)

    # Borrow checking instructions
    Ref(dest: LocalId, borrow_kind: MirBorrowKind, place: MirPlace)

    # GPU Instructions
    # Kernel definition - wraps a function body as a GPU kernel
    # WORKAROUND: Parser bug with multiple params of same custom type
    # GpuKernelDef(name: text, params: [MirLocal], body_block: BlockId)
    # GpuLaunch(kernel: MirOperand, grid_dim: MirOperand, block_dim: MirOperand, args: [MirOperand])
    GpuKernelDef(name: text)
    GpuLaunch(args: [text])
    # Thread ID accessors (dim: 0=x, 1=y, 2=z)
    GpuGlobalId(dest: LocalId, dim: i64)    # Global thread ID
    GpuLocalId(dest: LocalId, dim: i64)     # Local thread ID within block
    GpuBlockId(dest: LocalId, dim: i64)     # Block/workgroup ID
    GpuBlockDim(dest: LocalId, dim: i64)    # Block dimensions
    GpuGridDim(dest: LocalId, dim: i64)     # Grid dimensions
    # Synchronization
    GpuBarrier(scope: GpuBarrierScope)      # Thread synchronization barrier
    GpuMemFence(scope: GpuMemoryScope)      # Memory fence
    # Shared memory
    GpuSharedAlloc(dest: LocalId, type_: MirType, size: i64)  # Allocate shared memory
    # Atomic operations
    GpuAtomicOp(dest: LocalId, op: GpuAtomicOpKind, ptr: MirOperand, value: MirOperand)

# ============================================================================
# GPU Support Types
# ============================================================================

"""Barrier scope for GPU synchronization."""
enum GpuBarrierScope:
    Workgroup   # Synchronize threads within workgroup/block
    Device      # Synchronize all threads on device (expensive)
    Subgroup    # Synchronize threads within subgroup/warp

"""Memory scope for GPU memory fences."""
enum GpuMemoryScope:
    Workgroup   # Workgroup-level memory visibility
    Device      # Device-level memory visibility
    QueueFamily # Vulkan queue family scope
    All         # All memory (host + device)

"""Atomic operation kinds for GPU."""
enum GpuAtomicOpKind:
    Add         # Atomic add
    Sub         # Atomic subtract
    And         # Atomic bitwise and
    Or          # Atomic bitwise or
    Xor         # Atomic bitwise xor
    Min         # Atomic min
    Max         # Atomic max
    Exchange    # Atomic exchange
    CompareExchange  # Compare and exchange

# ============================================================================
# Borrow Checking Support Types
# ============================================================================

"""Borrow kind for borrow checking."""
enum MirBorrowKind:
    Shared      # &T - immutable borrow
    Mutable     # &mut T - exclusive mutable borrow

"""Place projection for borrow checking."""
enum MirProjection:
    Deref               # *place
    Field(idx: i64)     # place.field_idx
    Index(local: LocalId) # place[idx_local]
    Downcast(variant: i64) # place as Variant

"""Memory place for borrow checking."""
struct MirPlace:
    local: LocalId
    projection: [MirProjection]

impl MirPlace:
    static fn local_place(id: LocalId) -> MirPlace:
        """Create a place referring to a local variable."""
        MirPlace(local: id, projection: [])

    fn deref() -> MirPlace:
        """Add a dereference projection."""
        MirPlace(local: self.local, projection: self.projection.push(MirProjection.Deref))

    fn field(idx: i64) -> MirPlace:
        """Add a field projection."""
        MirPlace(local: self.local, projection: self.projection.push(MirProjection.Field(idx)))

    fn index(local: LocalId) -> MirPlace:
        """Add an index projection."""
        MirPlace(local: self.local, projection: self.projection.push(MirProjection.Index(local)))

    fn downcast(variant: i64) -> MirPlace:
        """Add a downcast projection."""
        MirPlace(local: self.local, projection: self.projection.push(MirProjection.Downcast(variant)))

    fn to_text() -> text:
        """Convert place to text representation."""
        var result = "_l{self.local.id}"
        for proj in self.projection:
            match proj:
                case Deref: result = "(*{result})"
                case Field(idx): result = "{result}.{idx}"
                case Index(local): result = "{result}[_l{local.id}]"
                case Downcast(variant): result = "{result} as v{variant}"
        result

"""Function body wrapper for borrow checking."""
struct MirBody:
    name: text
    blocks: [MirBlock]
    locals: [MirLocal]
    arg_count: i64
    return_ty: MirType

impl MirBody:
    static fn from_function(func: MirFunction) -> MirBody:
        """Create MirBody from MirFunction for borrow checking."""
        MirBody(
            name: func.name,
            blocks: func.blocks,
            locals: func.locals,
            arg_count: func.signature.params.len(),
            return_ty: func.signature.return_type
        )

"""Binary operation."""
enum MirBinOp:
    # Arithmetic
    Add, Sub, Mul, Div, Rem
    Pow                         # **
    # Matrix operations
    MatMul                      # @
    # Bitwise
    BitAnd, BitOr, BitXor, Shl, Shr
    # Comparison
    Eq, Ne, Lt, Le, Gt, Ge
    # Broadcast operations (dotted operators)
    BroadcastAdd                # .+
    BroadcastSub                # .-
    BroadcastMul                # .*
    BroadcastDiv                # ./
    BroadcastPow                # .^
    # Offset
    Offset  # Pointer arithmetic

"""Unary operation."""
enum MirUnaryOp:
    Neg
    Not
    BitNot
    Transpose   # ' (postfix, m{} only)

"""Aggregate construction kind."""
enum AggregateKind:
    Array(type_: MirType)
    Tuple
    Struct(symbol: SymbolId)
    Enum(symbol: SymbolId, variant: i64)

struct MirOperand:
    """Instruction operand."""
    kind: MirOperandKind

"""Operand kind."""
enum MirOperandKind:
    Copy(local: LocalId)
    Move(local: LocalId)
    Const(value: MirConstValue, type_: MirType)

# Helper: Copy MirFunction with new blocks (workaround for no struct spread syntax)
fn copy_mir_function_with_blocks(func: MirFunction, new_blocks: [MirBlock]) -> MirFunction:
    """Create a copy of MirFunction with modified blocks field.

    Common pattern in optimization passes that transform blocks but preserve
    all other function metadata.
    """
    MirFunction(
        symbol: func.symbol,
        name: func.name,
        signature: func.signature,
        locals: func.locals,
        blocks: new_blocks,
        entry_block: func.entry_block,
        span: func.span,
        generic_params: func.generic_params,
        is_generic_template: func.is_generic_template,
        specialization_of: func.specialization_of,
        type_bindings: func.type_bindings
    )

# Free functions for MirOperand construction (workaround for bootstrap)
fn mir_operand_copy(local: LocalId) -> MirOperand:
    MirOperand(kind: MirOperandKind.Copy(local))

fn mir_operand_move(local: LocalId) -> MirOperand:
    MirOperand(kind: MirOperandKind.Move(local))

fn mir_operand_const_int(value: i64) -> MirOperand:
    MirOperand(kind: MirOperandKind.Const(MirConstValue.Int(value), MirType.i64()))

fn mir_operand_const_float(value: f64) -> MirOperand:
    MirOperand(kind: MirOperandKind.Const(MirConstValue.Float(value), MirType.f64()))

fn mir_operand_const_bool(value: bool) -> MirOperand:
    MirOperand(kind: MirOperandKind.Const(MirConstValue.Bool(value), MirType.bool()))

impl MirOperand:
    static fn copy(local: LocalId) -> MirOperand:
        mir_operand_copy(local)

    static fn move(local: LocalId) -> MirOperand:
        mir_operand_move(local)

    static fn const_int(value: i64) -> MirOperand:
        mir_operand_const_int(value)

    static fn const_float(value: f64) -> MirOperand:
        mir_operand_const_float(value)

    static fn const_bool(value: bool) -> MirOperand:
        mir_operand_const_bool(value)

# ============================================================================
# MIR Terminators
# ============================================================================

"""Switch case mapping a constant value to a target block."""
struct SwitchCase:
    value: i64
    target: BlockId

"""Inline assembly operand."""
struct MirAsmOperand:
    """Assembly operand (input/output) with constraint information."""
    name: text                  # Operand name (e.g., "op", "result")
    kind: AsmConstraintKind     # in, out, inout, lateout
    location: AsmLocation       # reg, mem, imm, specific register
    operand: MirOperand         # MIR operand for the value

"""Block terminator."""
enum MirTerminator:
    # Unconditional
    Goto(target: BlockId)
    Return(value: MirOperand?)

    # Conditional
    If(cond: MirOperand, then_: BlockId, else_: BlockId)
    Switch(value: MirOperand, targets: [SwitchCase], default: BlockId)

    # Exceptional
    Unreachable
    Abort(message: text)

    # Call terminators (for unwinding)
    CallTerminator(
        dest: LocalId?,
        func: MirOperand,
        args: [MirOperand],
        normal: BlockId,
        unwind: BlockId?
    )

# ============================================================================
# MIR Builder
# ============================================================================

struct MirBuilder:
    """Builder for constructing MIR."""
    module: MirModule
    current_function: MirFunction?
    current_block: BlockId
    next_local_id: i64
    next_block_id: i64
    locals: [MirLocal]
    blocks: [MirBlock]
    instructions: [MirInst]

impl MirBuilder:
    static fn new() -> MirBuilder:
        MirBuilder(
            module: MirModule(
                name: "",
                functions: {},
                statics: {},
                constants: {},
                types: {}
            ),
            current_function: nil,
            current_block: BlockId.entry(),
            next_local_id: 0,
            next_block_id: 1,
            locals: [],
            blocks: [],
            instructions: []
        )

    # ========================================================================
    # Function Building
    # ========================================================================

    me begin_function(symbol: SymbolId, name: text, signature: MirSignature, span: Span):
        """Begin building a new function."""
        self.current_function = Some(MirFunction(
            symbol: symbol,
            name: name,
            signature: signature,
            locals: [],
            blocks: [],
            entry_block: BlockId.entry(),
            span: span,
            generic_params: [],
            is_generic_template: false,
            specialization_of: nil,
            type_bindings: {}
        ))
        self.next_local_id = 0
        self.next_block_id = 1
        self.locals = []
        self.blocks = []
        self.instructions = []
        self.current_block = BlockId.entry()

        # Create entry block
        self.blocks = self.blocks.push(MirBlock(
            id: BlockId.entry(),
            label: Some("entry"),
            instructions: [],
            terminator: MirTerminator.Unreachable  # Placeholder
        ))

        # Create return local
        if signature.return_type.kind != MirTypeKind.Unit:
            self.new_local(Some("_return"), signature.return_type, LocalKind.Return)

        # Create parameter locals
        for i in 0..signature.params.len():
            self.new_local(nil, signature.params[i], LocalKind.Arg(i))

    me end_function() -> MirFunction:
        """Finish building current function and return it."""
        # Finalize current block
        self.finalize_block()

        var fn_ = self.current_function.unwrap()
        fn_.locals = self.locals
        fn_.blocks = self.blocks
        self.current_function = nil
        fn_

    me add_function(fn_: MirFunction):
        """Add a completed function to the module."""
        var functions = self.module.functions
        functions[fn_.symbol] = fn_
        self.module.functions = functions

    # ========================================================================
    # Local Variables
    # ========================================================================

    me new_local(name: text?, type_: MirType, kind: LocalKind) -> LocalId:
        """Create a new local variable."""
        val id = LocalId(id: self.next_local_id)
        self.next_local_id = self.next_local_id + 1

        self.locals = self.locals.push(MirLocal(
            id: id,
            name: name,
            type_: type_,
            kind: kind
        ))

        id

    me new_temp(type_: MirType) -> LocalId:
        """Create a new temporary."""
        self.new_local(nil, type_, LocalKind.Temp)

    # ========================================================================
    # Basic Blocks
    # ========================================================================

    me new_block(label: text?) -> BlockId:
        """Create a new basic block."""
        val id = BlockId.new(self.next_block_id)
        self.next_block_id = self.next_block_id + 1

        self.blocks = self.blocks.push(MirBlock(
            id: id,
            label: label,
            instructions: [],
            terminator: MirTerminator.Unreachable  # Placeholder
        ))

        id

    me switch_to_block(block: BlockId):
        """Switch to building a different block."""
        self.finalize_block()
        self.current_block = block
        self.instructions = []

    me finalize_block():
        """Finalize current block with accumulated instructions."""
        if self.instructions.is_empty():
            return

        # Find and update current block
        for i in 0..self.blocks.len():
            if self.blocks[i].id.id == self.current_block.id:
                var block = self.blocks[i]
                block.instructions = self.instructions
                self.blocks[i] = block
                break

        self.instructions = []

    # ========================================================================
    # Instructions
    # ========================================================================

    me emit(inst: MirInst):
        """Emit an instruction to current block."""
        self.instructions = self.instructions + [inst]

    me emit_const(dest: LocalId, value: MirConstValue, type_: MirType):
        """Emit a constant load."""
        self.emit(MirInst(
            kind: MirInstKind.Const(dest, value, type_),
            span: nil
        ))

    me emit_const_int(value: i64) -> LocalId:
        """Emit an integer constant and return its local."""
        val dest = self.new_temp(MirType.i64())
        self.emit_const(dest, MirConstValue.Int(value), MirType.i64())
        dest

    me emit_const_float(value: f64) -> LocalId:
        """Emit a float constant and return its local."""
        val dest = self.new_temp(MirType.f64())
        self.emit_const(dest, MirConstValue.Float(value), MirType.f64())
        dest

    me emit_const_bool(value: bool) -> LocalId:
        """Emit a boolean constant and return its local."""
        val dest = self.new_temp(MirType.bool())
        self.emit_const(dest, MirConstValue.Bool(value), MirType.bool())
        dest

    me emit_copy(dest: LocalId, src: LocalId):
        """Emit a copy instruction."""
        self.emit(MirInst(
            kind: MirInstKind.Copy(dest, src),
            span: nil
        ))

    me emit_move(dest: LocalId, src: LocalId):
        """Emit a move instruction."""
        self.emit(MirInst(
            kind: MirInstKind.Move(dest, src),
            span: nil
        ))

    me emit_binop(op: MirBinOp, left: MirOperand, right: MirOperand, type_: MirType) -> LocalId:
        """Emit a binary operation and return result local."""
        val dest = self.new_temp(type_)
        self.emit(MirInst(
            kind: MirInstKind.BinOp(dest, op, left, right),
            span: nil
        ))
        dest

    me emit_unary(op: MirUnaryOp, operand: MirOperand, type_: MirType) -> LocalId:
        """Emit a unary operation and return result local."""
        val dest = self.new_temp(type_)
        self.emit(MirInst(
            kind: MirInstKind.UnaryOp(dest, op, operand),
            span: nil
        ))
        dest

    me emit_load(ptr: MirOperand, type_: MirType) -> LocalId:
        """Emit a load instruction."""
        val dest = self.new_temp(type_)
        self.emit(MirInst(
            kind: MirInstKind.Load(dest, ptr),
            span: nil
        ))
        dest

    me emit_store(ptr: MirOperand, value: MirOperand):
        """Emit a store instruction."""
        self.emit(MirInst(
            kind: MirInstKind.Store(ptr, value),
            span: nil
        ))

    me emit_alloc(type_: MirType) -> LocalId:
        """Emit an allocation."""
        val dest = self.new_temp(MirType.ptr(type_, true))
        self.emit(MirInst(
            kind: MirInstKind.Alloc(dest, type_),
            span: nil
        ))
        dest

    me emit_call(func: MirOperand, args: [MirOperand], return_type: MirType) -> LocalId?:
        """Emit a function call."""
        var dest: LocalId? = nil
        if return_type.kind != MirTypeKind.Unit:
            dest = Some(self.new_temp(return_type))

        self.emit(MirInst(
            kind: MirInstKind.Call(dest, func, args),
            span: nil
        ))

        dest

    me emit_call_indirect(ptr: MirOperand, args: [MirOperand], sig: MirSignature, return_type: MirType) -> LocalId?:
        """Emit an indirect function call (through closure or function pointer)."""
        var dest: LocalId? = nil
        if return_type.kind != MirTypeKind.Unit:
            dest = Some(self.new_temp(return_type))

        self.emit(MirInst(
            kind: MirInstKind.CallIndirect(dest, ptr, args, sig),
            span: nil
        ))

        dest

    me emit_cast(operand: MirOperand, target: MirType) -> LocalId:
        """Emit a type cast."""
        val dest = self.new_temp(target)
        self.emit(MirInst(
            kind: MirInstKind.Cast(dest, operand, target),
            span: nil
        ))
        dest

    me emit_aggregate(kind: AggregateKind, operands: [MirOperand], type_: MirType) -> LocalId:
        """Emit aggregate construction."""
        val dest = self.new_temp(type_)
        self.emit(MirInst(
            kind: MirInstKind.Aggregate(dest, kind, operands),
            span: nil
        ))
        dest

    me emit_get_field(base: MirOperand, field: i64, type_: MirType) -> LocalId:
        """Emit field access."""
        val dest = self.new_temp(type_)
        self.emit(MirInst(
            kind: MirInstKind.GetField(dest, base, field),
            span: nil
        ))
        dest

    me emit_set_field(base: MirOperand, field: i64, value: MirOperand):
        """Emit field assignment."""
        self.emit(MirInst(
            kind: MirInstKind.SetField(base, field, value),
            span: nil
        ))

    me emit_gep(base: MirOperand, indices: [MirOperand], type_: MirType) -> LocalId:
        """Emit GetElementPtr instruction."""
        val dest = self.new_temp(type_)
        self.emit(MirInst(
            kind: MirInstKind.GetElementPtr(dest, base, indices),
            span: nil
        ))
        dest

    # ========================================================================
    # Terminators
    # ========================================================================

    me terminate_goto(target: BlockId):
        """Terminate current block with unconditional jump."""
        self.set_terminator(MirTerminator.Goto(target))

    me terminate_return(value: MirOperand?):
        """Terminate current block with return."""
        self.set_terminator(MirTerminator.Return(value))

    me terminate_if(cond: MirOperand, then_: BlockId, else_: BlockId):
        """Terminate current block with conditional branch."""
        self.set_terminator(MirTerminator.If(cond, then_, else_))

    me terminate_switch(value: MirOperand, targets: [(i64, BlockId)], default: BlockId):
        """Terminate current block with switch."""
        self.set_terminator(MirTerminator.Switch(value, targets, default))

    me terminate_unreachable():
        """Terminate current block as unreachable."""
        self.set_terminator(MirTerminator.Unreachable)

    me set_terminator(term: MirTerminator):
        """Set terminator for current block."""
        self.finalize_block()

        for i in 0..self.blocks.len():
            if self.blocks[i].id.id == self.current_block.id:
                var block = self.blocks[i]
                block.terminator = term
                self.blocks[i] = block
                break

# ============================================================================
# Exports
# ============================================================================

export MirModule, MirFunction, MirSignature, MirLocal, LocalId, LocalKind
export MirStatic, MirConstant, MirConstValue
export MirTypeDef, MirTypeDefKind, MirFieldDef, MirVariantDef
export MirType, MirTypeKind
export BlockId, MirBlock
export MirInst, MirInstKind, MirBinOp, MirUnaryOp, AggregateKind
export MirOperand, MirOperandKind
export MirAsmOperand
export MirTerminator
export MirBuilder
export copy_mir_function_with_blocks
export mir_operand_copy, mir_operand_move, mir_operand_const_int, mir_operand_const_float, mir_operand_const_bool

# Borrow checking support types
export MirBorrowKind, MirPlace, MirProjection, MirBody

# GPU support types
export GpuBarrierScope, GpuMemoryScope, GpuAtomicOpKind
