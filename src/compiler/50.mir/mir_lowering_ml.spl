# MIR Lowering - ML/Async/Custom Block Lowering
#
# Specialized lowering for non-core expression types:
# - Custom blocks (sh{}, sql{}, re{}, etc.)
# - ML/tensor blocks (loss{}, nograd{})
# - Async/await expressions (await, yield, spawn, send, receive)

use mir_data.*
use hir.*
use lexer.Span
use compiler.blocks.value.BlockValue
use compiler.mir_lowering_types.{MirLowering, MirError}

# ============================================================================
# Custom Block Lowering
# ============================================================================

impl MirLowering:
    me lower_custom_block(kind: text, value: BlockValue, span: Span) -> LocalId:
        """Lower custom block to MIR.

        Custom blocks are lowered by calling a runtime handler function
        that processes the block value and returns a result.
        """
        # Create a local to hold the block kind as a constant
        # Strings in MIR are lowered as (ptr, len) tuples
        val str_type = MirType(kind: MirTypeKind.Tuple([
            MirType(kind: MirTypeKind.Ptr(MirType(kind: MirTypeKind.U8), false)),
            MirType(kind: MirTypeKind.U64)
        ]))
        val kind_dest = self.builder.new_temp(str_type)
        self.builder.emit_const(kind_dest, MirConstValue.Str(kind), str_type)
        val kind_local = kind_dest

        # Emit call to runtime block handler
        # rt_eval_block(kind: text, value: BlockValue) -> Any
        val result = self.builder.new_temp(MirType.i64())

        # For now, blocks that produce values just return unit
        # The actual evaluation happens at runtime via the interpreter
        # This is a placeholder for when we add full codegen support
        result

# ============================================================================
# ML/Tensor Block Lowering
# ============================================================================

    me lower_loss_block(body: HirBlock) -> LocalId:
        """Lower loss block to MIR.

        Loss blocks:
        1. Enable gradient tracking
        2. Evaluate the body
        3. Call backward() on the result
        4. Restore gradient tracking state
        """
        # Emit call to enable autograd
        # rt_autograd_push(enabled: bool)
        val _push_result = self.builder.new_temp(MirType.unit())

        # Lower the body
        val body_result = self.lower_block(body)

        # Emit call to backward
        # rt_backward(value: Tensor)
        if body_result.?:
            pass  # Would emit: rt_backward(body_result.unwrap())

        # Emit call to restore autograd state
        # rt_autograd_pop()
        val _pop_result = self.builder.new_temp(MirType.unit())

        body_result ?? self.builder.new_temp(MirType.unit())

    me lower_nograd_block(body: HirBlock) -> LocalId:
        """Lower nograd block to MIR.

        Nograd blocks:
        1. Disable gradient tracking
        2. Evaluate the body
        3. Restore gradient tracking state
        """
        # Emit call to disable autograd
        # rt_autograd_push(enabled: false)
        val _push_result = self.builder.new_temp(MirType.unit())

        # Lower the body
        val body_result = self.lower_block(body)

        # Emit call to restore autograd state
        # rt_autograd_pop()
        val _pop_result = self.builder.new_temp(MirType.unit())

        body_result ?? self.builder.new_temp(MirType.unit())

# ============================================================================
# Async/Await Lowering
# ============================================================================

    me lower_await(future_expr: HirExpr) -> LocalId:
        """Lower await expression to MIR.

        await expr:
        1. Lower the future/promise expression
        2. Emit Await instruction that suspends until promise resolves
        3. Return the resolved value
        """
        # Lower the future expression to get a Promise<T>
        val promise_local = self.lower_expr(future_expr)

        # Create destination for the awaited result
        # The result type should be the inner type of Promise<T>
        # For now, use i64 as placeholder (proper type inference in future)
        val result_type = MirType.i64()
        val dest = self.builder.new_temp(result_type)

        # Emit Await instruction
        self.builder.emit(MirInst(
            kind: MirInstKind.Await(dest: dest, promise: mir_operand_copy(promise_local)),
            span: nil
        ))

        dest

    me lower_yield(value: HirExpr?) -> LocalId:
        """Lower yield expression to MIR.

        yield expr:
        1. Lower the optional value expression
        2. Emit Yield instruction that suspends the generator
        3. Return unit (yield is a statement-like expression)
        """
        # Lower the optional value
        val value_operand = if value.?:
            val value_local = self.lower_expr(value.unwrap())
            Some(mir_operand_copy(value_local))
        else:
            nil

        # Emit Yield instruction
        self.builder.emit(MirInst(
            kind: MirInstKind.Yield(value: value_operand),
            span: nil
        ))

        # Yield returns unit
        self.builder.new_temp(MirType.unit())

    me lower_spawn(handler: HirExpr, args: [HirExpr]) -> LocalId:
        """Lower spawn expression to MIR.

        spawn handler(args):
        1. Lower the handler expression (async function)
        2. Lower all argument expressions
        3. Emit Spawn instruction
        4. Return the spawned task/actor handle
        """
        # Lower handler
        val handler_local = self.lower_expr(handler)

        # Lower arguments
        var arg_operands: [MirOperand] = []
        for arg in args:
            val arg_local = self.lower_expr(arg)
            arg_operands = arg_operands.push(mir_operand_copy(arg_local))

        # Create destination for the task handle
        val dest = self.builder.new_temp(MirType.i64())  # Task handle type

        # Emit Spawn instruction
        self.builder.emit(MirInst(
            kind: MirInstKind.Spawn(dest: dest, handler: mir_operand_copy(handler_local), args: arg_operands),
            span: nil
        ))

        dest

    me lower_send(target_expr: HirExpr, message: HirExpr) -> LocalId:
        """Lower send expression to MIR.

        target <- message:
        1. Lower the target expression
        2. Lower the message expression
        3. Emit Send instruction
        4. Return unit
        """
        # Lower target and message
        val target_local = self.lower_expr(target_expr)
        val message_local = self.lower_expr(message)

        # Emit Send instruction
        self.builder.emit(MirInst(
            kind: MirInstKind.Send(target: mir_operand_copy(target_local), message: mir_operand_copy(message_local)),
            span: nil
        ))

        # Send returns unit
        self.builder.new_temp(MirType.unit())

    me lower_receive(timeout: HirExpr?) -> LocalId:
        """Lower receive expression to MIR.

        receive or receive(timeout):
        1. Lower optional timeout expression
        2. Emit Receive instruction
        3. Return the received message
        """
        # Lower optional timeout
        val timeout_operand = if timeout.?:
            val timeout_local = self.lower_expr(timeout.unwrap())
            Some(mir_operand_copy(timeout_local))
        else:
            nil

        # Create destination for received message
        val dest = self.builder.new_temp(MirType.i64())  # Message type

        # Emit Receive instruction
        self.builder.emit(MirInst(
            kind: MirInstKind.Receive(dest: dest, timeout: timeout_operand),
            span: nil
        ))

        dest

# ============================================================================
# Exports
# ============================================================================

# Methods are attached to MirLowering via impl block above.
# No separate exports needed -- they are accessed through MirLowering instances.
