# Unsafe Context Tracking
#
# Tracks and validates unsafe operations in the compiler.
# Unsafe blocks are required for operations that could violate
# memory safety if misused.
#
# Unsafe operations:
# - Raw pointer dereference
# - Inline assembly
# - FFI calls to C functions
# - Accessing mutable statics
# - Transmuting between types
#
# Syntax:
#   unsafe:
#       val ptr = 0x1000 as *u32
#       val value = *ptr

from hir_types import {HirType, SymbolId}
from hir_definitions import {HirExpr, HirExprKind, HirStmt}
from lexer import {Span}

export UnsafeContext, UnsafeOp, UnsafeError
export is_unsafe_op, check_unsafe_context, require_unsafe

# Types of unsafe operations
enum UnsafeOp:
    # Raw pointer operations
    PointerDeref          # *ptr
    PointerArithmetic     # ptr.offset(n)
    PointerCast           # expr as *T

    # Memory operations
    Transmute             # transmute<T, U>(value)
    ReadUninitialized     # MaybeUninit::assume_init()
    WriteToRaw            # ptr.write(value)

    # FFI operations
    FfiCall               # extern "C" fn call
    InlineAssembly        # asm { ... }

    # Global state
    MutableStatic         # static mut VAR
    StaticReference       # &static or &mut static

    # Type system escapes
    UncheckedCast         # unchecked type cast
    UnionFieldAccess      # accessing union fields

impl UnsafeOp:
    fn description() -> text:
        match self:
            case UnsafeOp.PointerDeref: "dereferencing raw pointer"
            case UnsafeOp.PointerArithmetic: "pointer arithmetic"
            case UnsafeOp.PointerCast: "casting to raw pointer"
            case UnsafeOp.Transmute: "transmuting types"
            case UnsafeOp.ReadUninitialized: "reading uninitialized memory"
            case UnsafeOp.WriteToRaw: "writing through raw pointer"
            case UnsafeOp.FfiCall: "calling FFI function"
            case UnsafeOp.InlineAssembly: "inline assembly"
            case UnsafeOp.MutableStatic: "accessing mutable static"
            case UnsafeOp.StaticReference: "taking reference to static"
            case UnsafeOp.UncheckedCast: "unchecked type cast"
            case UnsafeOp.UnionFieldAccess: "accessing union field"

    fn severity() -> text:
        """Classification for documentation."""
        match self:
            case UnsafeOp.PointerDeref | UnsafeOp.WriteToRaw | UnsafeOp.Transmute:
                "critical"  # Can cause memory corruption
            case UnsafeOp.InlineAssembly | UnsafeOp.FfiCall:
                "high"      # Can have arbitrary effects
            case UnsafeOp.MutableStatic | UnsafeOp.PointerArithmetic:
                "medium"    # Data race or OOB risk
            case _:
                "low"       # Generally safe if preconditions met

# Unsafe operation instance
struct UnsafeOperation:
    op: UnsafeOp
    span: Span
    context: text?  # Optional context description

# Unsafe context tracks whether we're in an unsafe block
class UnsafeContext:
    # Stack of unsafe block depths
    unsafe_depth: i64
    # Accumulated unsafe operations (for lint reporting)
    operations: [UnsafeOperation]
    # Whether the current function is marked unsafe
    function_unsafe: bool
    # Whether to allow unsafe implicitly (for FFI modules)
    allow_implicit_unsafe: bool

impl UnsafeContext:
    static fn new() -> UnsafeContext:
        UnsafeContext(
            unsafe_depth: 0,
            operations: [],
            function_unsafe: false,
            allow_implicit_unsafe: false
        )

    # Enter an unsafe block
    me enter_unsafe():
        self.unsafe_depth = self.unsafe_depth + 1

    # Exit an unsafe block
    me exit_unsafe():
        if self.unsafe_depth > 0:
            self.unsafe_depth = self.unsafe_depth - 1

    # Check if currently in unsafe context
    fn is_unsafe() -> bool:
        self.unsafe_depth > 0 or self.function_unsafe or self.allow_implicit_unsafe

    # Mark current function as unsafe
    me set_function_unsafe(is_unsafe: bool):
        self.function_unsafe = is_unsafe

    # Record an unsafe operation
    me record_op(op: UnsafeOp, span: Span, context: text?):
        self.operations.push(UnsafeOperation(
            op: op,
            span: span,
            context: context
        ))

    # Get all recorded operations
    fn get_operations() -> [UnsafeOperation]:
        self.operations

    # Clear recorded operations
    me clear_operations():
        self.operations = []

# Unsafe error types
enum UnsafeError:
    # Operation requires unsafe block
    RequiresUnsafe(op: UnsafeOp, span: Span)
    # Unsafe block with no unsafe operations (lint)
    UnnecessaryUnsafe(span: Span)
    # Unsafe function called outside unsafe
    UnsafeFnCall(fn_name: text, span: Span)

impl UnsafeError:
    fn message() -> text:
        match self:
            case UnsafeError.RequiresUnsafe(op, _):
                "{op.description()} requires unsafe block"
            case UnsafeError.UnnecessaryUnsafe(_):
                "unnecessary unsafe block - no unsafe operations inside"
            case UnsafeError.UnsafeFnCall(name, _):
                "call to unsafe function '{name}' requires unsafe block"

    fn span() -> Span:
        match self:
            case UnsafeError.RequiresUnsafe(_, s): s
            case UnsafeError.UnnecessaryUnsafe(s): s
            case UnsafeError.UnsafeFnCall(_, s): s

    fn is_error() -> bool:
        match self:
            case UnsafeError.UnnecessaryUnsafe(_): false  # Just a lint
            case _: true

# Check if an expression is an unsafe operation
fn is_unsafe_op(expr: HirExpr) -> UnsafeOp?:
    match expr.kind:
        # Pointer dereference: *ptr
        case HirExprKind.Unary(op, operand):
            match op:
                case HirUnaryOp.Deref:
                    if is_raw_pointer_type(operand.type_):
                        return Some(UnsafeOp.PointerDeref)
                case _: pass

        # Inline assembly
        case HirExprKind.InlineAsm(_):
            return Some(UnsafeOp.InlineAssembly)

        # Cast to raw pointer
        case HirExprKind.Cast(_, target_type):
            if is_raw_pointer_type(target_type):
                return Some(UnsafeOp.PointerCast)

        # FFI call
        case HirExprKind.Call(callee, _, _):
            if is_ffi_function(callee):
                return Some(UnsafeOp.FfiCall)

        case _:
            pass

    None

# Check if type is a raw pointer
fn is_raw_pointer_type(type_: HirType?) -> bool:
    if not type_.?:
        return false
    val t = type_.unwrap()
    # Check for *T, *mut T, ptr<T> types
    val name = t.to_text()
    name.starts_with("*") or name.starts_with("ptr<")

# Check if callee is an FFI function
fn is_ffi_function(callee: HirExpr) -> bool:
    # Would need symbol table lookup to check if function is extern
    false  # Placeholder

# Check unsafe context for an operation
fn check_unsafe_context(ctx: UnsafeContext, op: UnsafeOp, span: Span) -> Result<(), UnsafeError>:
    if ctx.is_unsafe():
        ctx.record_op(op, span, None)
        Ok(())
    else:
        Err(UnsafeError.RequiresUnsafe(op, span))

# Require unsafe context, returning error if not in one
fn require_unsafe(ctx: UnsafeContext, op: UnsafeOp, span: Span) -> Result<(), UnsafeError>:
    check_unsafe_context(ctx, op, span)

# Validate that an unsafe block contains unsafe operations
fn validate_unsafe_block(ctx: UnsafeContext, block_span: Span) -> Result<(), UnsafeError>:
    if ctx.operations.len() == 0:
        return Err(UnsafeError.UnnecessaryUnsafe(block_span))
    Ok(())

# Built-in unsafe functions
val UNSAFE_BUILTINS: [text] = [
    "transmute",
    "read_volatile",
    "write_volatile",
    "copy_nonoverlapping",
    "copy",
    "swap",
    "drop_in_place",
    "forget",
    "zeroed",
    "uninitialized"
]

# Check if a function name is an unsafe builtin
fn is_unsafe_builtin(name: text) -> bool:
    for builtin in UNSAFE_BUILTINS:
        if builtin == name:
            return true
    false
