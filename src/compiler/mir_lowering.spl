# MIR Lowering - HIR to MIR Transformation
#
# This module handles lowering from HIR (High-level IR) to MIR (Mid-level IR).
# It converts:
# - Nested expressions to SSA form
# - Control flow to basic blocks
# - Memory operations to explicit loads/stores
# - Type system from HIR to MIR representation

use mir_data.*
use hir.*
use lexer.Span
use blocks.value.BlockValue

# ============================================================================
# HIR to MIR Lowering
# ============================================================================

struct MirLowering:
    """Lowers HIR to MIR."""
    builder: MirBuilder
    symbols: SymbolTable
    local_map: Dict<SymbolId, LocalId>
    loop_stack: [(BlockId, BlockId)]  # (continue_block, break_block)
    errors: [MirError]

struct MirError:
    """MIR lowering error."""
    message: text
    span: Span?

impl MirLowering:
    static fn new(symbols: SymbolTable) -> MirLowering:
        MirLowering(
            builder: MirBuilder.new(),
            symbols: symbols,
            local_map: {},
            loop_stack: [],
            errors: []
        )

    me lower_module(module: HirModule) -> MirModule:
        """Lower HIR module to MIR."""
        # Copy-modify-reassign: nested field mutations don't propagate in interpreter
        var builder = self.builder
        var builder_module = builder.module
        builder_module.name = module.name
        builder.module = builder_module
        self.builder = builder

        # Lower functions
        for fn_ in module.functions.values():
            val mir_fn = self.lower_function(fn_)
            # Copy-modify-reassign: self.builder.add_function() won't propagate
            var bldr = self.builder
            bldr.add_function(mir_fn)
            self.builder = bldr

        # Lower constants
        for const_ in module.constants.values():
            self.lower_const(const_)

        self.builder.module

    me lower_function(fn_: HirFunction) -> MirFunction:
        """Lower HIR function to MIR."""
        self.local_map = {}

        # Build signature
        var params: [MirType] = []
        for p in fn_.params:
            params = params.push(self.lower_type(p.type_))

        val return_type = self.lower_type(fn_.return_type)
        val signature = MirSignature(
            params: params,
            return_type: return_type,
            is_variadic: false
        )

        # Begin function (copy-modify-reassign for interpreter)
        var bldr = self.builder
        bldr.begin_function(fn_.symbol, fn_.name, signature, fn_.span)
        self.builder = bldr

        # Map parameters to locals
        for i in 0..fn_.params.len():
            val param = fn_.params[i]
            val local = LocalId(id: i + 1)  # +1 for return slot
            self.local_map[param.symbol] = local

        # Lower body
        val result = self.lower_block(fn_.body)

        # Return result (copy-modify-reassign for interpreter)
        var bldr2 = self.builder
        if result.?:
            bldr2.terminate_return(Some(mir_operand_copy(result.unwrap())))
        else:
            bldr2.terminate_return(nil)
        self.builder = bldr2

        var bldr3 = self.builder
        val fn_result = bldr3.end_function()
        self.builder = bldr3
        fn_result

    me lower_const(const_: HirConst):
        """Lower HIR constant to MIR static."""
        val value = self.lower_const_expr(const_.value)
        if value.?:
            # Copy-modify-reassign: self.builder.module nested access
            var bldr = self.builder
            var module = bldr.module
            var constants = module.constants
            constants[const_.symbol] = MirConstant(
                symbol: const_.symbol,
                name: const_.name,
                type_: self.lower_type(const_.type_),
                value: value.unwrap()
            )
            module.constants = constants
            bldr.module = module
            self.builder = bldr

    me lower_type(type_: HirType) -> MirType:
        """Lower HIR type to MIR type."""
        match type_.kind:
            case Int(bits, signed):
                if signed:
                    match bits:
                        case 8: MirType(kind: MirTypeKind.I8)
                        case 16: MirType(kind: MirTypeKind.I16)
                        case 32: MirType(kind: MirTypeKind.I32)
                        case _: MirType(kind: MirTypeKind.I64)
                else:
                    match bits:
                        case 8: MirType(kind: MirTypeKind.U8)
                        case 16: MirType(kind: MirTypeKind.U16)
                        case 32: MirType(kind: MirTypeKind.U32)
                        case _: MirType(kind: MirTypeKind.U64)
            case Float(bits):
                match bits:
                    case 32: MirType(kind: MirTypeKind.F32)
                    case _: MirType(kind: MirTypeKind.F64)
            case Bool:
                MirType(kind: MirTypeKind.Bool)
            case Char:
                MirType(kind: MirTypeKind.Char)
            case Str:
                # String is a fat pointer (ptr, len)
                MirType(kind: MirTypeKind.Tuple([
                    MirType(kind: MirTypeKind.Ptr(MirType(kind: MirTypeKind.U8), false)),
                    MirType(kind: MirTypeKind.U64)
                ]))
            case Unit:
                MirType(kind: MirTypeKind.Unit)
            case Tuple(elements):
                var mir_elements: [MirType] = []
                for e in elements:
                    mir_elements = mir_elements.push(self.lower_type(e))
                MirType(kind: MirTypeKind.Tuple(mir_elements))
            case Array(element, size):
                MirType(kind: MirTypeKind.Array(self.lower_type(element), size ?? 0))
            case Ref(inner, mutable):
                MirType(kind: MirTypeKind.Ref(self.lower_type(inner), mutable))
            case Optional(inner):
                # Optional is enum { nil, Some(T) }
                MirType(kind: MirTypeKind.Tuple([
                    MirType(kind: MirTypeKind.Bool),  # has_value
                    self.lower_type(inner)
                ]))
            case Named(symbol, _):
                MirType(kind: MirTypeKind.Struct(symbol))
            case Never:
                MirType(kind: MirTypeKind.Never)
            case _:
                self.error("unsupported MIR type kind: {type_.kind}", nil)
                MirType(kind: MirTypeKind.I64)

    me lower_block(block: HirBlock) -> LocalId?:
        """Lower HIR block to MIR, return result local if any."""
        for stmt in block.stmts:
            self.lower_stmt(stmt)

        if block.value.?:
            val local = self.lower_expr(block.value.unwrap())
            Some(local)
        else:
            nil

    me lower_stmt(stmt: HirStmt):
        """Lower HIR statement to MIR."""
        match stmt.kind:
            case Expr(expr):
                self.lower_expr(expr)

            case Let(symbol, type_, init):
                val mir_type = type_.map(\t: self.lower_type(t)) ?? MirType.i64()
                var b = self.builder
                val local = b.new_local(nil, mir_type, LocalKind.Var)
                self.builder = b
                self.local_map[symbol] = local

                val init_local = self.lower_expr(init)
                var b2 = self.builder
                b2.emit_copy(local, init_local)
                self.builder = b2

            case Assign(target, op, value):
                val value_local = self.lower_expr(value)
                self.lower_assign(target, op, value_local)

            case Block(block):
                self.lower_block(block)

    me lower_assign(target: HirExpr, op: HirAssignOp?, value_local: LocalId):
        """Lower assignment."""
        match target.kind:
            case Var(symbol):
                if self.local_map.contains_key(symbol):
                    val local = self.local_map[symbol]
                    if op.?:
                        # Compound assignment
                        val current = mir_operand_copy(local)
                        val new_val = mir_operand_copy(value_local)
                        val mir_op = self.lower_assign_op(op.unwrap())
                        var b = self.builder
                        val result = b.emit_binop(mir_op, current, new_val, MirType.i64())
                        b.emit_copy(local, result)
                        self.builder = b
                    else:
                        var b = self.builder
                        b.emit_copy(local, value_local)
                        self.builder = b

            case Field(base, field, resolved):
                # Field assignment: obj.field = value
                val receiver = self.lower_expr(base)
                # For now, use field index 0 (TODO: proper field resolution)
                val field_index = 0
                var b = self.builder
                b.emit_set_field(mir_operand_copy(receiver), field_index, mir_operand_copy(value_local))
                self.builder = b

            case Index(base, index):
                # Index assignment: arr[i] = value
                # Lower to runtime call: rt_array_set(arr, index, value)
                val receiver = self.lower_expr(base)
                val index_local = self.lower_expr(index)

                # Create function operand for rt_array_set
                val func_operand = MirOperand(kind: MirOperandKind.Const(
                    MirConstValue.Int(0),  # Function symbol (will be resolved in codegen)
                    MirType(kind: MirTypeKind.FuncPtr(MirSignature(params: [], return_type: MirType.unit(), is_variadic: false)))
                ))

                # Emit call with no return value
                self.builder.emit_call(func_operand, [mir_operand_copy(receiver), mir_operand_copy(index_local), mir_operand_copy(value_local)], MirType.unit())

            case _:
                self.error("unsupported MIR assignment target: {target.kind}", nil)

    me lower_receiver_and_args(receiver: HirExpr, args: [HirCallArg]) -> [MirOperand]:
        """Lower receiver and arguments for method calls."""
        val receiver_local = self.lower_expr(receiver)
        var arg_operands: [MirOperand] = [mir_operand_copy(receiver_local)]
        for arg in args:
            val arg_local = self.lower_expr(arg.value)
            arg_operands = arg_operands.push(mir_operand_copy(arg_local))
        arg_operands

    me lower_assign_op(op: HirAssignOp) -> MirBinOp:
        """Convert assignment op to binary op."""
        match op:
            case Add: MirBinOp.Add
            case Sub: MirBinOp.Sub
            case Mul: MirBinOp.Mul
            case Div: MirBinOp.Div
            case Mod: MirBinOp.Rem
            case _: MirBinOp.Add

    me lower_expr(expr: HirExpr) -> LocalId:
        """Lower HIR expression to MIR, return result local."""
        match expr.kind:
            case IntLit(value, _):
                var b = self.builder
                val result = b.emit_const_int(value)
                self.builder = b
                result

            case FloatLit(value, _):
                var b = self.builder
                val result = b.emit_const_float(value)
                self.builder = b
                result

            case BoolLit(value):
                var b = self.builder
                val result = b.emit_const_bool(value)
                self.builder = b
                result

            case StringLit(value, _):
                # Store string as constant; runtime resolves pointer
                var b = self.builder
                val dest = b.new_temp(MirType(kind: MirTypeKind.Opaque("str")))
                b.emit_const(dest, MirConstValue.Str(value), MirType(kind: MirTypeKind.Opaque("str")))
                self.builder = b
                dest

            case NilLit | UnitLit:
                var b = self.builder
                val result = b.new_temp(MirType.unit())
                self.builder = b
                result

            case Var(symbol):
                # Look up variable in local_map using contains_key first
                if self.local_map.contains_key(symbol):
                    self.local_map[symbol]
                else:
                    self.error("undefined variable", Some(expr.span))
                    var b_err = self.builder
                    val err_tmp = b_err.new_temp(MirType.i64())
                    self.builder = b_err
                    err_tmp

            case Binary(op, left, right):
                # Check if this is a special pipeline operator first
                val special_result = self.lower_binop_special(op, left, right)
                if special_result.?:
                    special_result.unwrap()
                else:
                    # Normal binary operation
                    val left_local = self.lower_expr(left)
                    val right_local = self.lower_expr(right)
                    val mir_op = self.lower_binop(op)
                    val result_type = self.infer_binop_type(op)
                    var b = self.builder
                    val binop_result = b.emit_binop(mir_op, mir_operand_copy(left_local), mir_operand_copy(right_local), result_type)
                    self.builder = b
                    binop_result

            case Unary(op, operand):
                val operand_local = self.lower_expr(operand)
                val mir_op = self.lower_unaryop(op)
                var b = self.builder
                val unary_result = b.emit_unary(mir_op, mir_operand_copy(operand_local), MirType.i64())
                self.builder = b
                unary_result

            case If(cond, then_, else_):
                self.lower_if(cond, then_, else_)

            case Call(callee, args, _):
                self.lower_call(callee, args)

            case MethodCall(receiver, method, args, resolution):
                self.lower_method_call(receiver, method, args, resolution)

            case ArrayLit(elements, _):
                self.lower_array_lit(elements)

            case SetLit(elements, _):
                self.lower_set_lit(elements)

            case TupleLit(elements):
                self.lower_tuple_lit(elements)

            case Block(block):
                val result = self.lower_block(block)
                if result.?:
                    result.unwrap()
                else:
                    var b = self.builder
                    val temp = b.new_temp(MirType.unit())
                    self.builder = b
                    temp

            case Loop(body, _):
                self.lower_loop(body)

            case While(cond, body, _):
                self.lower_while(cond, body)

            case For(var_, iter, body, _):
                self.lower_for(var_, iter, body)

            case Return(value):
                var br = self.builder
                if value.?:
                    val result = self.lower_expr(value.unwrap())
                    br = self.builder
                    br.terminate_return(Some(mir_operand_copy(result)))
                else:
                    br.terminate_return(nil)
                self.builder = br
                var br2 = self.builder
                val ret_temp = br2.new_temp(MirType.unit())
                self.builder = br2
                ret_temp

            case Break(break_label, break_value):
                if self.loop_stack.len() > 0:
                    val (loop_continue_block, break_block) = self.loop_stack[self.loop_stack.len() - 1]
                    var b = self.builder
                    b.terminate_goto(break_block)
                    self.builder = b
                var b = self.builder
                val break_temp = b.new_temp(MirType.unit())
                self.builder = b
                break_temp

            case Continue(cont_label):
                if self.loop_stack.len() > 0:
                    val (continue_block, loop_break_block) = self.loop_stack[self.loop_stack.len() - 1]
                    var b = self.builder
                    b.terminate_goto(continue_block)
                    self.builder = b
                var b = self.builder
                val cont_temp = b.new_temp(MirType.unit())
                self.builder = b
                cont_temp

            # Custom blocks (user-defined: sh{}, sql{}, re{}, etc.)
            case CustomBlock(kind, value):
                self.lower_custom_block(kind, value, expr.span)

            # Math/DL blocks with special semantics
            case LossBlock(body):
                self.lower_loss_block(body)

            case NogradBlock(body):
                self.lower_nograd_block(body)

            case Range(start, end, inclusive, step):
                self.lower_range(start, end, inclusive, step)

            # Async/Await expressions
            case Await(future_expr):
                self.lower_await(future_expr)

            case Yield(value):
                self.lower_yield(value)

            # Unsafe block - lower the body, no special handling
            case UnsafeBlock(body):
                self.lower_block(body) ?? self.builder.new_temp(MirType.unit())

            # Inline assembly
            case InlineAsm(asm):
                self.lower_inline_asm(asm)

            case _:
                self.error("unsupported MIR expression: {expr.kind}", nil)
                nil

    me lower_binop_special(op: HirBinOp, left: HirExpr, right: HirExpr) -> LocalId?:
        """Check if this is a special binary op needing non-BinOp lowering."""
        match op:
            case PipeForward:
                # x |> f  ->  PipeForward(x, f)
                val value_local = self.lower_expr(left)
                val func_local = self.lower_expr(right)
                val dest = self.builder.new_temp(MirType.i64())
                self.builder.emit(MirInst(kind: MirInstKind.PipeForward(dest, mir_operand_copy(value_local), mir_operand_copy(func_local)), span: nil))
                Some(dest)

            case Compose:
                # f >> g  ->  Compose(f, g, true)
                val f_local = self.lower_expr(left)
                val g_local = self.lower_expr(right)
                val dest = self.builder.new_temp(MirType.i64())
                self.builder.emit(MirInst(kind: MirInstKind.Compose(dest, mir_operand_copy(f_local), mir_operand_copy(g_local), true), span: nil))
                Some(dest)

            case ComposeBack:
                # f << g  ->  Compose(f, g, false)
                val f_local = self.lower_expr(left)
                val g_local = self.lower_expr(right)
                val dest = self.builder.new_temp(MirType.i64())
                self.builder.emit(MirInst(kind: MirInstKind.Compose(dest, mir_operand_copy(f_local), mir_operand_copy(g_local), false), span: nil))
                Some(dest)

            case Parallel:
                # f // g  ->  Parallel([f, g])
                val f_local = self.lower_expr(left)
                val g_local = self.lower_expr(right)
                val dest = self.builder.new_temp(MirType.i64())
                self.builder.emit(MirInst(kind: MirInstKind.Parallel(dest, [mir_operand_copy(f_local), mir_operand_copy(g_local)]), span: nil))
                Some(dest)

            case LayerConnect:
                # layer1 ~> layer2  ->  LayerConnect(layer1, layer2)
                val l1_local = self.lower_expr(left)
                val l2_local = self.lower_expr(right)
                val dest = self.builder.new_temp(MirType.i64())
                self.builder.emit(MirInst(kind: MirInstKind.LayerConnect(dest, mir_operand_copy(l1_local), mir_operand_copy(l2_local)), span: nil))
                Some(dest)

            case _:
                nil  # Not a special op, use normal BinOp

    me lower_binop(op: HirBinOp) -> MirBinOp:
        """Convert HIR binary op to MIR binary op."""
        match op:
            case Add: MirBinOp.Add
            case Sub: MirBinOp.Sub
            case Mul: MirBinOp.Mul
            case Div: MirBinOp.Div
            case Mod: MirBinOp.Rem
            case Pow: MirBinOp.Pow
            case MatMul: MirBinOp.MatMul
            case BitAnd: MirBinOp.BitAnd
            case BitOr: MirBinOp.BitOr
            case BitXor: MirBinOp.BitXor
            case Shl: MirBinOp.Shl
            case Shr: MirBinOp.Shr
            case Eq: MirBinOp.Eq
            case NotEq: MirBinOp.Ne
            case Lt: MirBinOp.Lt
            case LtEq: MirBinOp.Le
            case Gt: MirBinOp.Gt
            case GtEq: MirBinOp.Ge
            case BroadcastAdd: MirBinOp.BroadcastAdd
            case BroadcastSub: MirBinOp.BroadcastSub
            case BroadcastMul: MirBinOp.BroadcastMul
            case BroadcastDiv: MirBinOp.BroadcastDiv
            case BroadcastPow: MirBinOp.BroadcastPow
            case _: MirBinOp.Add

    me lower_unaryop(op: HirUnaryOp) -> MirUnaryOp:
        """Convert HIR unary op to MIR unary op."""
        match op:
            case Neg: MirUnaryOp.Neg
            case Not: MirUnaryOp.Not
            case BitNot: MirUnaryOp.BitNot
            case Transpose: MirUnaryOp.Transpose
            case _: MirUnaryOp.Neg

    me infer_binop_type(op: HirBinOp) -> MirType:
        """Infer result type of binary operation."""
        match op:
            case Eq | NotEq | Lt | LtEq | Gt | GtEq:
                MirType.bool()
            case _:
                MirType.i64()  # Default to i64

    me lower_if(cond: HirExpr, then_: HirBlock, else_: HirBlock?) -> LocalId:
        """Lower if expression."""
        val cond_local = self.lower_expr(cond)

        var b = self.builder
        val then_block = b.new_block(Some("then"))
        val else_block = b.new_block(Some("else"))
        val merge_block = b.new_block(Some("merge"))
        val result = b.new_temp(MirType.i64())
        b.terminate_if(mir_operand_copy(cond_local), then_block, else_block)
        self.builder = b

        # Then block
        var b2 = self.builder
        b2.switch_to_block(then_block)
        self.builder = b2
        val then_result = self.lower_block(then_)
        var b3 = self.builder
        if then_result.?:
            b3.emit_copy(result, then_result.unwrap())
        b3.terminate_goto(merge_block)
        self.builder = b3

        # Else block
        var b4 = self.builder
        b4.switch_to_block(else_block)
        self.builder = b4
        if else_.?:
            val else_result = self.lower_block(else_.unwrap())
            var b5 = self.builder
            if else_result.?:
                b5.emit_copy(result, else_result.unwrap())
            b5.terminate_goto(merge_block)
            self.builder = b5
        else:
            var b5 = self.builder
            b5.terminate_goto(merge_block)
            self.builder = b5

        # Merge block
        var b6 = self.builder
        b6.switch_to_block(merge_block)
        self.builder = b6

        result

    me lower_loop(body: HirBlock) -> LocalId:
        """Lower loop expression."""
        var b = self.builder
        val loop_block = b.new_block(Some("loop"))
        val exit_block = b.new_block(Some("loop_exit"))
        self.builder = b

        self.loop_stack = self.loop_stack.push((loop_block, exit_block))

        var b2 = self.builder
        b2.terminate_goto(loop_block)
        b2.switch_to_block(loop_block)
        self.builder = b2

        self.lower_block(body)

        var b3 = self.builder
        b3.terminate_goto(loop_block)
        self.builder = b3

        self.loop_stack = self.loop_stack[0:self.loop_stack.len() - 1]

        var b4 = self.builder
        b4.switch_to_block(exit_block)
        val loop_result = b4.new_temp(MirType.unit())
        self.builder = b4
        loop_result

    me lower_while(cond: HirExpr, body: HirBlock) -> LocalId:
        """Lower while expression."""
        var b = self.builder
        val cond_block = b.new_block(Some("while_cond"))
        val body_block = b.new_block(Some("while_body"))
        val exit_block = b.new_block(Some("while_exit"))
        self.builder = b

        self.loop_stack = self.loop_stack.push((cond_block, exit_block))

        var b2 = self.builder
        b2.terminate_goto(cond_block)
        b2.switch_to_block(cond_block)
        self.builder = b2

        val cond_local = self.lower_expr(cond)
        var b3 = self.builder
        b3.terminate_if(mir_operand_copy(cond_local), body_block, exit_block)
        b3.switch_to_block(body_block)
        self.builder = b3

        self.lower_block(body)

        var b4 = self.builder
        b4.terminate_goto(cond_block)
        self.builder = b4

        self.loop_stack = self.loop_stack[0:self.loop_stack.len() - 1]

        var b5 = self.builder
        b5.switch_to_block(exit_block)
        val while_result = b5.new_temp(MirType.unit())
        self.builder = b5
        while_result

    me lower_for(var_: SymbolId, iter: HirExpr, body: HirBlock) -> LocalId:
        """Lower for expression using the iterator protocol.

        Lowers:
            for x in collection:
                body

        Into:
            val _iter = collection.iter()
            while _iter.has_next():
                val x = _iter.next()
                body
        """
        # Step 1: Lower the iterable expression
        val collection_local = self.lower_expr(iter)

        # Step 2: Call iter() on the collection to get an iterator
        val iter_func_operand = MirOperand(kind: MirOperandKind.Const(
            MirConstValue.Int(0),
            MirType(kind: MirTypeKind.FuncPtr(MirSignature(params: [], return_type: MirType.i64(), is_variadic: false)))
        ))
        var b = self.builder
        val iter_result = b.emit_call(iter_func_operand, [mir_operand_copy(collection_local)], MirType.i64())
        val iter_local = if iter_result.?:
            self.builder = b
            iter_result.unwrap()
        else:
            val temp = b.new_temp(MirType.i64())
            self.builder = b
            temp

        # Step 3: Create loop blocks
        var b2 = self.builder
        val cond_block = b2.new_block(Some("for_cond"))
        val body_block = b2.new_block(Some("for_body"))
        val exit_block = b2.new_block(Some("for_exit"))
        self.builder = b2

        self.loop_stack = self.loop_stack.push((cond_block, exit_block))

        # Jump to condition check
        var b3 = self.builder
        b3.terminate_goto(cond_block)
        b3.switch_to_block(cond_block)
        self.builder = b3

        # Step 4: Condition block - call has_next() on iterator
        val has_next_func_operand = MirOperand(kind: MirOperandKind.Const(
            MirConstValue.Int(0),
            MirType(kind: MirTypeKind.FuncPtr(MirSignature(params: [], return_type: MirType.bool(), is_variadic: false)))
        ))
        var b4 = self.builder
        val has_next_result = b4.emit_call(has_next_func_operand, [mir_operand_copy(iter_local)], MirType.bool())
        val has_next_local = if has_next_result.?:
            self.builder = b4
            has_next_result.unwrap()
        else:
            val temp = b4.emit_const_bool(false)
            self.builder = b4
            temp
        var b5 = self.builder
        b5.terminate_if(mir_operand_copy(has_next_local), body_block, exit_block)
        b5.switch_to_block(body_block)
        self.builder = b5

        # Step 5: Body block - call next() to get element, bind to loop variable
        val next_func_operand = MirOperand(kind: MirOperandKind.Const(
            MirConstValue.Int(0),
            MirType(kind: MirTypeKind.FuncPtr(MirSignature(params: [], return_type: MirType.i64(), is_variadic: false)))
        ))
        var b6 = self.builder
        val next_result = b6.emit_call(next_func_operand, [mir_operand_copy(iter_local)], MirType.i64())
        val next_local = if next_result.?:
            self.builder = b6
            next_result.unwrap()
        else:
            val temp = b6.new_temp(MirType.i64())
            self.builder = b6
            temp

        # Bind the loop variable to the next() result
        var b7 = self.builder
        val loop_var = b7.new_local(nil, MirType.i64(), LocalKind.Var)
        b7.emit_copy(loop_var, next_local)
        self.builder = b7
        self.local_map[var_] = loop_var

        # Lower the loop body
        self.lower_block(body)

        # Jump back to condition
        var b8 = self.builder
        b8.terminate_goto(cond_block)
        self.builder = b8

        # Step 6: Exit block
        self.loop_stack = self.loop_stack[0:self.loop_stack.len() - 1]
        var b9 = self.builder
        b9.switch_to_block(exit_block)
        val for_result = b9.new_temp(MirType.unit())
        self.builder = b9
        for_result

    me lower_call(callee: HirExpr, args: [HirCallArg]) -> LocalId:
        """Lower function call.

        Handles both direct calls (Var) and indirect calls (closures, function pointers).
        """
        var arg_operands: [MirOperand] = []
        for arg in args:
            val arg_local = self.lower_expr(arg.value)
            arg_operands = arg_operands.push(mir_operand_copy(arg_local))

        # Check if this is a direct call (Var) or indirect call
        match callee.kind:
            case Var(symbol):
                # Direct call - use Call instruction
                val func_operand = self.symbol_to_operand(symbol)
                var b = self.builder
                val result = b.emit_call(func_operand, arg_operands, MirType.i64())
                if result.?:
                    self.builder = b
                    result.unwrap()
                else:
                    val temp = b.new_temp(MirType.unit())
                    self.builder = b
                    temp

            case _:
                # Indirect call - lower callee expression and use CallIndirect
                val callee_local = self.lower_expr(callee)
                # Infer parameter types from arguments
                var param_types: [MirType] = []
                for arg_op in arg_operands:
                    param_types.push(MirType.i64())
                # Infer return type from callee's type annotation if available
                val ret_type = if callee.type_.?:
                    self.lower_type(callee.type_.unwrap())
                else:
                    MirType.i64()
                val sig = MirSignature(
                    params: param_types,
                    return_type: ret_type,
                    is_variadic: false
                )
                var b = self.builder
                val result = b.emit_call_indirect(mir_operand_copy(callee_local), arg_operands, sig, MirType.i64())
                if result.?:
                    self.builder = b
                    result.unwrap()
                else:
                    val temp = b.new_temp(MirType.unit())
                    self.builder = b
                    temp

    me lower_method_call(receiver: HirExpr, method: text, args: [HirCallArg], resolution: MethodResolution) -> LocalId:
        """Lower method call based on resolution.

        UFCS: For FreeFunction resolution, receiver becomes first argument.
        """
        match resolution:
            case InstanceMethod(type_id, method_id):
                # Direct method call on type
                val arg_operands = self.lower_receiver_and_args(receiver, args)
                val method_operand = self.symbol_to_operand(method_id)
                var b = self.builder
                val result = b.emit_call(method_operand, arg_operands, MirType.i64())
                if result.?:
                    self.builder = b
                    result.unwrap()
                else:
                    val temp = b.new_temp(MirType.unit())
                    self.builder = b
                    temp

            case TraitMethod(trait_id, method_id):
                val arg_operands = self.lower_receiver_and_args(receiver, args)
                val method_operand = self.symbol_to_operand(method_id)
                var b = self.builder
                val result = b.emit_call(method_operand, arg_operands, MirType.i64())
                if result.?:
                    self.builder = b
                    result.unwrap()
                else:
                    val temp = b.new_temp(MirType.unit())
                    self.builder = b
                    temp

            case FreeFunction(func_id):
                val arg_operands = self.lower_receiver_and_args(receiver, args)
                val func_operand = self.symbol_to_operand(func_id)
                var b = self.builder
                val result = b.emit_call(func_operand, arg_operands, MirType.i64())
                if result.?:
                    self.builder = b
                    result.unwrap()
                else:
                    val temp = b.new_temp(MirType.unit())
                    self.builder = b
                    temp

            case StaticMethod(type_id, method_id):
                var arg_operands: [MirOperand] = []
                for arg in args:
                    val arg_local = self.lower_expr(arg.value)
                    arg_operands = arg_operands.push(mir_operand_copy(arg_local))

                val method_operand = self.symbol_to_operand(method_id)
                var b = self.builder
                val result = b.emit_call(method_operand, arg_operands, MirType.i64())
                if result.?:
                    self.builder = b
                    result.unwrap()
                else:
                    val temp = b.new_temp(MirType.unit())
                    self.builder = b
                    temp

            case Unresolved:
                self.error("unresolved method call: {method}", nil)
                var b = self.builder
                val temp = b.new_temp(MirType.unit())
                self.builder = b
                temp

    me symbol_to_operand(symbol: SymbolId) -> MirOperand:
        """Convert a symbol to a function pointer operand."""
        # Look up function name from symbol table for direct calls
        val sym = self.symbols.get(symbol)
        val name = if sym.?: sym.name else: "unknown_{symbol.id}"
        MirOperand(kind: MirOperandKind.Const(
            MirConstValue.Str(name),
            MirType(kind: MirTypeKind.FuncPtr(MirSignature(params: [], return_type: MirType.i64(), is_variadic: false)))
        ))

    me lower_array_lit(elements: [HirExpr]) -> LocalId:
        """Lower array literal."""
        var operands: [MirOperand] = []
        for elem in elements:
            val local = self.lower_expr(elem)
            operands = operands.push(mir_operand_copy(local))

        val elem_type = if elements.len() > 0 and elements[0].type_.?:
            self.lower_type(elements[0].type_.unwrap())
        else:
            MirType.i64()
        val array_type = MirType(kind: MirTypeKind.Array(elem_type, elements.len()))

        self.builder.emit_aggregate(
            AggregateKind.Array(elem_type),
            operands,
            array_type
        )

    me lower_tuple_lit(elements: [HirExpr]) -> LocalId:
        """Lower tuple literal."""
        var operands: [MirOperand] = []
        var types: [MirType] = []
        for elem in elements:
            val local = self.lower_expr(elem)
            operands = operands.push(mir_operand_copy(local))
            val elem_ty = if elem.type_.?:
                self.lower_type(elem.type_.unwrap())
            else:
                MirType.i64()
            types = types.push(elem_ty)

        val tuple_type = MirType(kind: MirTypeKind.Tuple(types))
        self.builder.emit_aggregate(AggregateKind.Tuple, operands, tuple_type)

    me lower_set_lit(elements: [HirExpr]) -> LocalId:
        """Lower set literal to Set.from() call.

        Transforms: s{1, 2, 3}
        Into: Set.from([1, 2, 3])

        This is simpler than Set.new() + insert() and works with current runtime.
        Future optimization: emit direct Set.new() + insert() calls.
        """
        # Infer element type from first element, or default to i64
        val elem_type = if elements.len() > 0 and elements[0].type_.?:
            self.lower_type(elements[0].type_.unwrap())
        else:
            MirType.i64()

        # Lower elements to array literal
        var elem_operands: [MirOperand] = []
        for elem in elements:
            val elem_local = self.lower_expr(elem)
            elem_operands = elem_operands.push(mir_operand_copy(elem_local))

        # Create array from elements
        val array_type = MirType(kind: MirTypeKind.Array(elem_type, elements.len()))
        val array_local = self.builder.emit_aggregate(
            AggregateKind.Array(elem_type),
            elem_operands,
            array_type
        )

        # Call Set.from(array) - using runtime function placeholder
        # In a real implementation, this would resolve Set.from symbol from symbol table
        # For now, create a function operand that will be resolved by codegen
        val set_from_operand = MirOperand(kind: MirOperandKind.Const(
            MirConstValue.Int(0),  # Placeholder - codegen will resolve "Set.from"
            MirType(kind: MirTypeKind.FuncPtr(MirSignature(
                params: [array_type],
                return_type: MirType(kind: MirTypeKind.Named("Set", [elem_type])),
                is_variadic: false
            )))
        ))

        val set_type = MirType(kind: MirTypeKind.Named("Set", [elem_type]))
        val result = self.builder.emit_call(
            set_from_operand,
            [mir_operand_copy(array_local)],
            set_type
        )

        result ?? self.builder.new_temp(set_type)

    me lower_const_expr(expr: HirExpr) -> MirConstValue?:
        """Lower constant expression."""
        match expr.kind:
            case IntLit(value, _):
                Some(MirConstValue.Int(value))
            case FloatLit(value, _):
                Some(MirConstValue.Float(value))
            case BoolLit(value):
                Some(MirConstValue.Bool(value))
            case StringLit(value, _):
                Some(MirConstValue.Str(value))
            case _:
                nil

    # ========================================================================
    # Custom Block Lowering
    # ========================================================================

    me lower_custom_block(kind: text, value: BlockValue, span: Span) -> LocalId:
        """Lower custom block to MIR.

        Custom blocks are lowered by calling a runtime handler function
        that processes the block value and returns a result.
        """
        # Create a local to hold the block kind as a constant
        # Strings in MIR are lowered as (ptr, len) tuples
        val str_type = MirType(kind: MirTypeKind.Tuple([
            MirType(kind: MirTypeKind.Ptr(MirType(kind: MirTypeKind.U8), false)),
            MirType(kind: MirTypeKind.U64)
        ]))
        val kind_dest = self.builder.new_temp(str_type)
        self.builder.emit_const(kind_dest, MirConstValue.Str(kind), str_type)
        val kind_local = kind_dest

        # Emit call to runtime block handler
        # rt_eval_block(kind: text, value: BlockValue) -> Any
        val result = self.builder.new_temp(MirType.i64())

        # For now, blocks that produce values just return unit
        # The actual evaluation happens at runtime via the interpreter
        # This is a placeholder for when we add full codegen support
        result

    me lower_loss_block(body: HirBlock) -> LocalId:
        """Lower loss block to MIR.

        Loss blocks:
        1. Enable gradient tracking
        2. Evaluate the body
        3. Call backward() on the result
        4. Restore gradient tracking state
        """
        # Emit call to enable autograd
        # rt_autograd_push(enabled: bool)
        val _push_result = self.builder.new_temp(MirType.unit())

        # Lower the body
        val body_result = self.lower_block(body)

        # Emit call to backward
        # rt_backward(value: Tensor)
        if body_result.?:
            pass  # Would emit: rt_backward(body_result.unwrap())

        # Emit call to restore autograd state
        # rt_autograd_pop()
        val _pop_result = self.builder.new_temp(MirType.unit())

        body_result ?? self.builder.new_temp(MirType.unit())

    me lower_nograd_block(body: HirBlock) -> LocalId:
        """Lower nograd block to MIR.

        Nograd blocks:
        1. Disable gradient tracking
        2. Evaluate the body
        3. Restore gradient tracking state
        """
        # Emit call to disable autograd
        # rt_autograd_push(enabled: false)
        val _push_result = self.builder.new_temp(MirType.unit())

        # Lower the body
        val body_result = self.lower_block(body)

        # Emit call to restore autograd state
        # rt_autograd_pop()
        val _pop_result = self.builder.new_temp(MirType.unit())

        body_result ?? self.builder.new_temp(MirType.unit())

    # ========================================================================
    # Async/Await Lowering
    # ========================================================================

    me lower_await(future_expr: HirExpr) -> LocalId:
        """Lower await expression to MIR.

        await expr:
        1. Lower the future/promise expression
        2. Emit Await instruction that suspends until promise resolves
        3. Return the resolved value
        """
        # Lower the future expression to get a Promise<T>
        val promise_local = self.lower_expr(future_expr)

        # Create destination for the awaited result
        # The result type should be the inner type of Promise<T>
        # For now, use i64 as placeholder (proper type inference in future)
        val result_type = MirType.i64()
        val dest = self.builder.new_temp(result_type)

        # Emit Await instruction
        self.builder.emit(MirInst(
            kind: MirInstKind.Await(dest: dest, promise: mir_operand_copy(promise_local)),
            span: nil
        ))

        dest

    me lower_yield(value: HirExpr?) -> LocalId:
        """Lower yield expression to MIR.

        yield expr:
        1. Lower the optional value expression
        2. Emit Yield instruction that suspends the generator
        3. Return unit (yield is a statement-like expression)
        """
        # Lower the optional value
        val value_operand = if value.?:
            val value_local = self.lower_expr(value.unwrap())
            Some(mir_operand_copy(value_local))
        else:
            nil

        # Emit Yield instruction
        self.builder.emit(MirInst(
            kind: MirInstKind.Yield(value: value_operand),
            span: nil
        ))

        # Yield returns unit
        self.builder.new_temp(MirType.unit())

    me lower_spawn(handler: HirExpr, args: [HirExpr]) -> LocalId:
        """Lower spawn expression to MIR.

        spawn handler(args):
        1. Lower the handler expression (async function)
        2. Lower all argument expressions
        3. Emit Spawn instruction
        4. Return the spawned task/actor handle
        """
        # Lower handler
        val handler_local = self.lower_expr(handler)

        # Lower arguments
        var arg_operands: [MirOperand] = []
        for arg in args:
            val arg_local = self.lower_expr(arg)
            arg_operands = arg_operands.push(mir_operand_copy(arg_local))

        # Create destination for the task handle
        val dest = self.builder.new_temp(MirType.i64())  # Task handle type

        # Emit Spawn instruction
        self.builder.emit(MirInst(
            kind: MirInstKind.Spawn(dest: dest, handler: mir_operand_copy(handler_local), args: arg_operands),
            span: nil
        ))

        dest

    me lower_send(target_expr: HirExpr, message: HirExpr) -> LocalId:
        """Lower send expression to MIR.

        target <- message:
        1. Lower the target expression
        2. Lower the message expression
        3. Emit Send instruction
        4. Return unit
        """
        # Lower target and message
        val target_local = self.lower_expr(target_expr)
        val message_local = self.lower_expr(message)

        # Emit Send instruction
        self.builder.emit(MirInst(
            kind: MirInstKind.Send(target: mir_operand_copy(target_local), message: mir_operand_copy(message_local)),
            span: nil
        ))

        # Send returns unit
        self.builder.new_temp(MirType.unit())

    me lower_receive(timeout: HirExpr?) -> LocalId:
        """Lower receive expression to MIR.

        receive or receive(timeout):
        1. Lower optional timeout expression
        2. Emit Receive instruction
        3. Return the received message
        """
        # Lower optional timeout
        val timeout_operand = if timeout.?:
            val timeout_local = self.lower_expr(timeout.unwrap())
            Some(mir_operand_copy(timeout_local))
        else:
            nil

        # Create destination for received message
        val dest = self.builder.new_temp(MirType.i64())  # Message type

        # Emit Receive instruction
        self.builder.emit(MirInst(
            kind: MirInstKind.Receive(dest: dest, timeout: timeout_operand),
            span: nil
        ))

        dest

    me lower_range(start: HirExpr?, end: HirExpr?, inclusive: bool, step: HirExpr?) -> LocalId:
        """Lower range expression to runtime call.

        Generates call to rt_range(start, end) or rt_range_inclusive(start, end).
        Step parameter is currently ignored (TODO: support step in runtime).
        """
        # Lower start and end to locals
        val start_local = if start.?: self.lower_expr(start.unwrap()) else: self.builder.emit_const_int(0)
        val end_local = if end.?: self.lower_expr(end.unwrap()) else: self.builder.emit_const_int(0)

        # Create function operand for rt_range or rt_range_inclusive
        val func_operand = MirOperand(kind: MirOperandKind.Const(
            MirConstValue.Int(0),  # Function symbol (will be resolved in codegen)
            MirType(kind: MirTypeKind.FuncPtr(MirSignature(params: [], return_type: MirType.i64(), is_variadic: false)))
        ))

        # Emit call: rt_range(start, end) or rt_range_inclusive(start, end)
        val result = self.builder.emit_call(func_operand, [
            mir_operand_copy(start_local),
            mir_operand_copy(end_local)
        ], MirType.i64())

        result ?? self.builder.new_temp(MirType.i64())

    me lower_inline_asm(asm: HirAsm) -> LocalId:
        """Lower inline assembly from HIR to MIR.

        Converts HIR inline assembly constraints to MIR operands.
        """
        # Lower all constraint value expressions to MIR operands
        var inputs: [MirAsmOperand] = []
        var outputs: [MirAsmOperand] = []

        for constraint in asm.constraints:
            # Lower the HIR expression to a local
            val value_local = self.lower_expr(constraint.value)
            val mir_operand = mir_operand_copy(value_local)

            val asm_operand = MirAsmOperand(
                name: constraint.name,
                kind: constraint.kind,
                location: constraint.location,
                operand: mir_operand
            )

            # Categorize as input or output
            match constraint.kind:
                case In:
                    inputs.push(asm_operand)
                case Out | LateOut:
                    outputs.push(asm_operand)
                case InOut:
                    # InOut constraints appear in both lists
                    inputs.push(asm_operand)
                    outputs.push(asm_operand)

        # Emit inline assembly instruction
        self.builder.emit(MirInst(
            kind: MirInstKind.InlineAsm(
                asm_template: asm.asm_template,
                is_volatile: asm.is_volatile,
                inputs: inputs,
                outputs: outputs,
                clobbers: asm.clobbers
            ),
            span: Some(asm.span)
        ))

        # Return a unit value (inline asm doesn't produce a value directly)
        self.builder.new_temp(MirType.unit())

    me error(message: text, span: Span?):
        """Record a lowering error."""
        self.errors = self.errors.push(MirError(message: message, span: span))

# ============================================================================
# Exports
# ============================================================================

export MirLowering, MirError
