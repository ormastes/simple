# NOTE: clone() calls reviewed â€” deferred (correctness risk with move semantics here)
# Partitioning of Generic Templates and Specialized Instances
#
# This module separates a monomorphized module into:
# - Generic templates (for later instantiation, stored in .smf)
# - Specialized instances (compiled to native code)
#
# Supports .smf template storage for deferred monomorphization.
#
# Port of: rust/compiler/src/monomorphize/partition.rs (449 lines)

export GenericTemplates
export SpecializedInstances
export partition_generic_constructs
export build_monomorphization_metadata
export build_monomorphization_metadata_from_constructs

use ..ast (Module, Node, FunctionDef, StructDef, ClassDef, EnumDef, TraitDef)
use .metadata (MonomorphizationMetadata, GenericFunctionMeta, GenericStructMeta)
use .metadata (GenericClassMeta, GenericEnumMeta, GenericTraitMeta)
use .metadata (SpecializationEntry)
use .types (ConcreteType, TypeBindings)

# ============================================================================
# Generic Templates
# ============================================================================

struct GenericTemplates:
    """Complete set of generic templates extracted from a module.

    Templates are stored in .smf files for later instantiation
    (deferred monomorphization).
    """
    functions: [FunctionDef]
    structs: [StructDef]
    classes: [ClassDef]
    enums: [EnumDef]
    traits: [TraitDef]


# ============================================================================
# GenericTemplates Methods (was: impl GenericTemplates:)
# ============================================================================

fn generictemplates_new() -> GenericTemplates:
        """Create an empty template set."""
        GenericTemplates(
            functions: [],
            structs: [],
            classes: [],
            enums: [],
            traits: []
        )


fn generictemplates_empty() -> GenericTemplates:
        """Create an empty template set (alias for new)."""
        generictemplates_new()


# ============================================================================
# Specialized Instances
# ============================================================================

struct SpecializedInstances:
    """Complete set of specialized instances.

    These are compiled to native code and included in the final binary.
    """
    functions: [FunctionDef]
    structs: [StructDef]
    classes: [ClassDef]
    enums: [EnumDef]
    # Note: Trait implementations are tracked in metadata, not as instances


# ============================================================================
# SpecializedInstances Methods (was: impl SpecializedInstances:)
# ============================================================================

fn specializedinstances_new() -> SpecializedInstances:
        """Create an empty instance set."""
        SpecializedInstances(
            functions: [],
            structs: [],
            classes: [],
            enums: []
        )


fn specializedinstances_empty() -> SpecializedInstances:
        """Create an empty instance set (alias for new)."""
        specializedinstances_new()


# ============================================================================
# Partition Generic Constructs
# ============================================================================

fn partition_generic_constructs(module: Module) -> (GenericTemplates, SpecializedInstances, MonomorphizationMetadata):
    """Partition a module into generic templates and specialized instances.

    This is used during compilation to separate:
    - Templates (stored in .smf for later instantiation)
    - Specializations (compiled to native code)

    Returns:
        [templates, specialized_instances, metadata]

    ROBUSTNESS:
    - Categorizes each AST node correctly
    - Updates metadata for tracking
    - Handles non-generic items
    """
    var templates = generictemplates_new()
    var specialized = specializedinstances_new()
    var metadata = monomorphizationmetadata_new()

    for item in module.items:
        match item:
            node_Function(f):
                partition_function(f, templates, specialized, metadata)

            node_Struct(s):
                partition_struct(s, templates, specialized, metadata)

            node_Class(c):
                partition_class(c, templates, specialized, metadata)

            node_Enum(e):
                partition_enum(e, templates, specialized, metadata)

            node_Trait(t):
                partition_trait(t, templates, metadata)

            _:
                # Other node types (imports, etc.) - skip
                ()

    [templates, specialized, metadata]

# ============================================================================
# Partition Individual Constructs
# ============================================================================

fn partition_function(
    f: FunctionDef,
    templates: GenericTemplates,
    specialized: SpecializedInstances,
    metadata: MonomorphizationMetadata
):
    """Partition a function into template or specialized instance.

    Categories:
    1. is_generic_template=true -> Template
    2. specialization_of=base -> Specialized instance
    3. Otherwise -> Non-generic function (goes to specialized)

    ROBUSTNESS: Updates metadata for both templates and specializations.
    """
    if f.is_generic_template:
        # Generic template
        templates.functions_push(functions, f.clone())

        # Create metadata entry if not exists
        if not metadata.functions_contains_key(functions, f.name):
            metadata.functions[f.name] = GenericFunctionMeta.new(
                f.name_clone(name),
                f.generic_params_clone(generic_params)
            )

    elif val base_name = f.specialization_of:
        # Specialized instance
        specialized.functions_push(functions, f.clone())

        # Add to metadata (create entry if needed)
        if not metadata.functions_contains_key(functions, base_name):
            metadata.functions[base_name] = genericfunctionmeta_new(base_name.clone(), [])

        val meta = metadata.functions[base_name]

        # Extract type args from bindings using type name conversion
        var type_args: [ConcreteType] = []
        for _item_0 in f.type_bindings_items(type_bindings):
            val ast_type = _item_0[1]
            val type_str = ast_type_to_string(ast_type)
            val concrete = match type_str:
                case "i32": ConcreteType.Int
                case "i64": ConcreteType.Int
                case "u32": ConcreteType.Int
                case "u64": ConcreteType.Int
                case "f32": ConcreteType.Float
                case "f64": ConcreteType.Float
                case "bool": ConcreteType.Bool
                case "text": ConcreteType.String
                case "str": ConcreteType.String
                case _: concretetype_Named(type_str)
            type_args_push(type_args, concrete)

        # Convert type bindings
        var concrete_bindings: TypeBindings = {}
        for _item_1 in f.type_bindings_items(type_bindings):
            val param = _item_1[0]
            val ast_type = _item_1[1]
            val type_str = ast_type_to_string(ast_type)
            val concrete = match type_str:
                case "i32": ConcreteType.Int
                case "i64": ConcreteType.Int
                case "u32": ConcreteType.Int
                case "u64": ConcreteType.Int
                case "f32": ConcreteType.Float
                case "f64": ConcreteType.Float
                case "bool": ConcreteType.Bool
                case "text": ConcreteType.String
                case "str": ConcreteType.String
                case _: concretetype_Named(type_str)
            concrete_bindings[param] = concrete

        # Add specialization entry
        meta.specializations.push(SpecializationEntry.new(
            type_args,
            f.name_clone(name),
            concrete_bindings
        ))

    else:
        # Non-generic function
        specialized.functions_push(functions, f.clone())

fn partition_struct(
    s: StructDef,
    templates: GenericTemplates,
    specialized: SpecializedInstances,
    metadata: MonomorphizationMetadata
):
    """Partition a struct into template or specialized instance."""
    if s.is_generic_template:
        templates.structs_push(structs, s.clone())

        if not metadata.structs_contains_key(structs, s.name):
            metadata.structs[s.name] = GenericStructMeta.new(
                s.name_clone(name),
                s.generic_params_clone(generic_params)
            )

    elif val base_name = s.specialization_of:
        specialized.structs_push(structs, s.clone())

        if not metadata.structs_contains_key(structs, base_name):
            metadata.structs[base_name] = genericstructmeta_new(base_name.clone(), [])

        val meta = metadata.structs[base_name]

        # Extract type args
        var type_args: [ConcreteType] = []
        for _item_2 in s.type_bindings_items(type_bindings):
            val ast_type = _item_2[1]
            type_args_push(type_args, ConcreteType.Named(ast_type.to_string()))

        # Convert bindings
        var concrete_bindings: TypeBindings = {}
        for _item_3 in s.type_bindings_items(type_bindings):
            val param = _item_3[0]
            val ast_type = _item_3[1]
            concrete_bindings[param] = concretetype_Named(ast_type.to_string())

        meta.specializations.push(SpecializationEntry.new(
            type_args,
            s.name_clone(name),
            concrete_bindings
        ))

    else:
        specialized.structs_push(structs, s.clone())

fn partition_class(
    c: ClassDef,
    templates: GenericTemplates,
    specialized: SpecializedInstances,
    metadata: MonomorphizationMetadata
):
    """Partition a class into template or specialized instance."""
    if c.is_generic_template:
        templates.classes_push(classes, c.clone())

        if not metadata.classes_contains_key(classes, c.name):
            metadata.classes[c.name] = GenericClassMeta.new(
                c.name_clone(name),
                c.generic_params_clone(generic_params)
            )

    elif val base_name = c.specialization_of:
        specialized.classes_push(classes, c.clone())

        if not metadata.classes_contains_key(classes, base_name):
            metadata.classes[base_name] = genericclassmeta_new(base_name.clone(), [])

        val meta = metadata.classes[base_name]

        # Extract type args
        var type_args: [ConcreteType] = []
        for _item_4 in c.type_bindings_items(type_bindings):
            val ast_type = _item_4[1]
            type_args_push(type_args, ConcreteType.Named(ast_type.to_string()))

        # Convert bindings
        var concrete_bindings: TypeBindings = {}
        for _item_5 in c.type_bindings_items(type_bindings):
            val param = _item_5[0]
            val ast_type = _item_5[1]
            concrete_bindings[param] = concretetype_Named(ast_type.to_string())

        meta.specializations.push(SpecializationEntry.new(
            type_args,
            c.name_clone(name),
            concrete_bindings
        ))

    else:
        specialized.classes_push(classes, c.clone())

fn partition_enum(
    e: EnumDef,
    templates: GenericTemplates,
    specialized: SpecializedInstances,
    metadata: MonomorphizationMetadata
):
    """Partition an enum into template or specialized instance."""
    if e.is_generic_template:
        templates.enums_push(enums, e.clone())

        if not metadata.enums_contains_key(enums, e.name):
            metadata.enums[e.name] = GenericEnumMeta.new(
                e.name_clone(name),
                e.generic_params_clone(generic_params)
            )

    elif val base_name = e.specialization_of:
        specialized.enums_push(enums, e.clone())

        if not metadata.enums_contains_key(enums, base_name):
            metadata.enums[base_name] = genericenummeta_new(base_name.clone(), [])

        val meta = metadata.enums[base_name]

        # Extract type args
        var type_args: [ConcreteType] = []
        for _item_6 in e.type_bindings_items(type_bindings):
            val ast_type = _item_6[1]
            type_args_push(type_args, ConcreteType.Named(ast_type.to_string()))

        # Convert bindings
        var concrete_bindings: TypeBindings = {}
        for _item_7 in e.type_bindings_items(type_bindings):
            val param = _item_7[0]
            val ast_type = _item_7[1]
            concrete_bindings[param] = concretetype_Named(ast_type.to_string())

        meta.specializations.push(SpecializationEntry.new(
            type_args,
            e.name_clone(name),
            concrete_bindings
        ))

    else:
        specialized.enums_push(enums, e.clone())

fn partition_trait(
    t: TraitDef,
    templates: GenericTemplates,
    metadata: MonomorphizationMetadata
):
    """Partition a trait (always goes to templates).

    Note: Traits are not specialized - implementations are specialized.
    """
    if t.is_generic_template or not t.generic_params_is_empty(generic_params):
        templates.traits_push(traits, t.clone())

        if not metadata.traits_contains_key(traits, t.name):
            metadata.traits[t.name] = GenericTraitMeta.new(
                t.name_clone(name),
                t.generic_params_clone(generic_params)
            )

# ============================================================================
# Build Monomorphization Metadata
# ============================================================================

fn build_monomorphization_metadata(module: Module) -> MonomorphizationMetadata:
    """Build monomorphization metadata from a module.

    Extracts all generic templates and specializations and builds metadata
    for tracking instantiation relationships.

    Returns:
        Metadata with all generic constructs and their specializations

    ROBUSTNESS: Complete metadata for all constructs.
    """
    val _destruct_8 = partition_generic_constructs(module)
    val metadata = _destruct_8[2]
    metadata

fn build_monomorphization_metadata_from_constructs(
    templates: GenericTemplates,
    specialized: SpecializedInstances
) -> MonomorphizationMetadata:
    """Build monomorphization metadata from pre-partitioned constructs.

    Takes already-separated templates and specialized instances and builds
    metadata tracking their relationships.

    Args:
        templates: Generic template constructs
        specialized: Specialized instance constructs

    Returns:
        Metadata with tracking information

    ROBUSTNESS: Processes all constructs and builds complete metadata.
    """
    var metadata = monomorphizationmetadata_new()

    # Process templates
    for func in templates.functions:
        if not metadata.functions_contains_key(functions, func.name):
            metadata.functions[func.name] = GenericFunctionMeta.new(
                func.name_clone(name),
                func.generic_params_clone(generic_params)
            )

    for struct_def in templates.structs:
        if not metadata.structs_contains_key(structs, struct_def.name):
            metadata.structs[struct_def.name] = GenericStructMeta.new(
                struct_def.name_clone(name),
                struct_def.generic_params_clone(generic_params)
            )

    for class_def in templates.classes:
        if not metadata.classes_contains_key(classes, class_def.name):
            metadata.classes[class_def.name] = GenericClassMeta.new(
                class_def.name_clone(name),
                class_def.generic_params_clone(generic_params)
            )

    for enum_def in templates.enums:
        if not metadata.enums_contains_key(enums, enum_def.name):
            metadata.enums[enum_def.name] = GenericEnumMeta.new(
                enum_def.name_clone(name),
                enum_def.generic_params_clone(generic_params)
            )

    for trait_def in templates.traits:
        if not metadata.traits_contains_key(traits, trait_def.name):
            metadata.traits[trait_def.name] = GenericTraitMeta.new(
                trait_def.name_clone(name),
                trait_def.generic_params_clone(generic_params)
            )

    # Process specializations
    for func in specialized.functions:
        if val base_name = func.specialization_of:
            # Ensure base template exists in metadata
            if not metadata.functions_contains_key(functions, base_name):
                metadata.functions[base_name] = genericfunctionmeta_new(base_name.clone(), [])

            val meta = metadata.functions[base_name]

            # Extract type args from bindings
            var type_args: [ConcreteType] = []
            for _item_9 in func.type_bindings_items(type_bindings):
                val ast_type = _item_9[1]
                type_args_push(type_args, ConcreteType.Named(ast_type.to_string()))

            # Convert type bindings
            var concrete_bindings: TypeBindings = {}
            for _item_10 in func.type_bindings_items(type_bindings):
                val param = _item_10[0]
                val ast_type = _item_10[1]
                concrete_bindings[param] = concretetype_Named(ast_type.to_string())

            # Add specialization entry
            meta.specializations.push(SpecializationEntry.new(
                type_args,
                func.name_clone(name),
                concrete_bindings
            ))

    for struct_def in specialized.structs:
        if val base_name = struct_def.specialization_of:
            if not metadata.structs_contains_key(structs, base_name):
                metadata.structs[base_name] = genericstructmeta_new(base_name.clone(), [])

            val meta = metadata.structs[base_name]

            var type_args: [ConcreteType] = []
            for _item_11 in struct_def.type_bindings_items(type_bindings):
                val ast_type = _item_11[1]
                type_args_push(type_args, ConcreteType.Named(ast_type.to_string()))

            var concrete_bindings: TypeBindings = {}
            for _item_12 in struct_def.type_bindings_items(type_bindings):
                val param = _item_12[0]
                val ast_type = _item_12[1]
                concrete_bindings[param] = concretetype_Named(ast_type.to_string())

            meta.specializations.push(SpecializationEntry.new(
                type_args,
                struct_def.name_clone(name),
                concrete_bindings
            ))

    for class_def in specialized.classes:
        if val base_name = class_def.specialization_of:
            if not metadata.classes_contains_key(classes, base_name):
                metadata.classes[base_name] = genericclassmeta_new(base_name.clone(), [])

            val meta = metadata.classes[base_name]

            var type_args: [ConcreteType] = []
            for _item_13 in class_def.type_bindings_items(type_bindings):
                val ast_type = _item_13[1]
                type_args_push(type_args, ConcreteType.Named(ast_type.to_string()))

            var concrete_bindings: TypeBindings = {}
            for _item_14 in class_def.type_bindings_items(type_bindings):
                val param = _item_14[0]
                val ast_type = _item_14[1]
                concrete_bindings[param] = concretetype_Named(ast_type.to_string())

            meta.specializations.push(SpecializationEntry.new(
                type_args,
                class_def.name_clone(name),
                concrete_bindings
            ))

    for enum_def in specialized.enums:
        if val base_name = enum_def.specialization_of:
            if not metadata.enums_contains_key(enums, base_name):
                metadata.enums[base_name] = genericenummeta_new(base_name.clone(), [])

            val meta = metadata.enums[base_name]

            var type_args: [ConcreteType] = []
            for _item_15 in enum_def.type_bindings_items(type_bindings):
                val ast_type = _item_15[1]
                type_args_push(type_args, ConcreteType.Named(ast_type.to_string()))

            var concrete_bindings: TypeBindings = {}
            for _item_16 in enum_def.type_bindings_items(type_bindings):
                val param = _item_16[0]
                val ast_type = _item_16[1]
                concrete_bindings[param] = concretetype_Named(ast_type.to_string())

            meta.specializations.push(SpecializationEntry.new(
                type_args,
                enum_def.name_clone(name),
                concrete_bindings
            ))

    metadata

# ============================================================================
# Usage Example
# ============================================================================
#
# # Partition a module
# val (templates, specialized, metadata) = partition_generic_constructs(module)
#
# print "Templates:"
# print "  Functions: {templates.functions.len()}"
# print "  Structs: {templates.structs.len()}"
# print "  Classes: {templates.classes.len()}"
# print "  Enums: {templates.enums.len()}"
# print "  Traits: {templates.traits.len()}"
#
# print "Specialized:"
# print "  Functions: {specialized.functions.len()}"
# print "  Structs: {specialized.structs.len()}"
# print "  Classes: {specialized.classes.len()}"
# print "  Enums: {specialized.enums.len()}"
#
# # Save templates to .smf file
# smf_writer.write_templates(templates)?
#
# # Compile specialized instances to native code
# codegen.compile_instances(specialized)?
#
# ============================================================================
# Partitioning Logic
# ============================================================================
#
# For each AST node:
#
# 1. is_generic_template = true
#    -> Add to templates (for .smf storage)
#    -> Create metadata entry
#
# 2. specialization_of = base_name
#    -> Add to specialized instances (for native code)
#    -> Add specialization entry to metadata
#
# 3. Otherwise (non-generic)
#    -> Add to specialized instances (normal code)
#
# Metadata tracks:
# - Generic templates (name, generic params)
# - All specializations (type args, mangled name, bindings)
# - Dependencies between templates
#
# ============================================================================
# Performance Notes
# ============================================================================
#
# - partition_generic_constructs: O(n) where n = number of AST nodes
# - Per-node partition: O(1) classification + O(1) metadata update
# - Type arg extraction: O(k) where k = number of type parameters
#
# Expected performance: Same as Rust (same algorithm, linear traversal)
#
# ============================================================================
# Robustness Checklist
# ============================================================================
#
# Logic Correctness:
# - [x] All generic templates identified
# - [x] All specializations identified
# - [x] Non-generic items handled
# - [x] Metadata updated correctly
# - [x] Type bindings preserved
#
# Edge Cases:
# - [x] Empty module (returns empty sets)
# - [x] No generics (all goes to specialized)
# - [x] Only templates (specialized is empty)
# - [x] Mixed generic and non-generic
#
# Memory Safety:
# - [x] No buffer overflows (Simple arrays safe)
# - [x] No use-after-free (clone() creates copies)
#
# Remaining work:
# - [ ] Implement ast_type_to_concrete conversion (currently placeholder)
# - [ ] Add support for trait implementations
# - [ ] Add incremental partitioning (delta updates)
