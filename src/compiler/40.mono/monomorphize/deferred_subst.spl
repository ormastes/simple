# Deferred Monomorphization - Type Substitution & Specialization Helpers
#
# Text-level type substitution for creating specialized definitions from
# generic templates. Replaces type parameter names with concrete type strings
# in all text fields of AST definitions (FunctionDef, StructDef, etc.).
#
# Also provides error handling state, mangled name generation, and
# type binding construction used by the deferred monomorphizer.
#
# RUNTIME COMPATIBILITY: Uses nil-check error pattern instead of Result<T,E>

export deferred_last_error
export deferred_clear_error
export deferred_set_error
export InstantiationMode

use .types (ConcreteType, SpecializationKey, TypeBindings)
use ..ast (FunctionDef, StructDef, ClassDef, EnumDef)

# ============================================================================
# Error Handling (Runtime-Safe Pattern)
# ============================================================================

var deferred_last_error: text = ""

fn deferred_clear_error():
    deferred_last_error = ""

fn deferred_set_error(msg: text):
    deferred_last_error = msg

# ============================================================================
# Text-Level Type Substitution
# ============================================================================
# The AST definitions (FunctionDef, StructDef, ClassDef, EnumDef) store type
# information as text. Specialization works by replacing type parameter names
# with concrete type strings in all text fields.

fn _concrete_type_to_text(ct: ConcreteType) -> text:
    """Convert a ConcreteType to its text representation for substitution."""
    match ct:
        ConcreteType.Int: "Int"
        ConcreteType.Float: "Float"
        ConcreteType.Bool: "Bool"
        ConcreteType.String: "String"
        ConcreteType.Nil: "Nil"
        ConcreteType.Named(n): n
        ConcreteType.Array(elem): "[{_concrete_type_to_text(elem)}]"
        ConcreteType.Tuple(elems):
            var parts: [text] = []
            for e in elems:
                parts.push(_concrete_type_to_text(e))
            "({parts.join(', ')})"
        ConcreteType.Dict(k, v):
            val kt = _concrete_type_to_text(k)
            val vt = _concrete_type_to_text(v)
            "{{{kt}: {vt}}}"
        ConcreteType.Function(params, ret):
            var param_parts: [text] = []
            for p in params:
                param_parts.push(_concrete_type_to_text(p))
            "fn({param_parts.join(', ')}) -> {_concrete_type_to_text(ret)}"
        ConcreteType.Optional(inner): "{_concrete_type_to_text(inner)}?"
        ConcreteType.Pointer(_, _, inner): _concrete_type_to_text(inner)
        ConcreteType.Specialized(name, args):
            var arg_parts: [text] = []
            for a in args:
                arg_parts.push(_concrete_type_to_text(a))
            "{name}<{arg_parts.join(', ')}>"

fn _concrete_type_to_mangled(ct: ConcreteType) -> text:
    """Convert a ConcreteType to a mangling-safe text form (no special chars)."""
    match ct:
        ConcreteType.Int: "Int"
        ConcreteType.Float: "Float"
        ConcreteType.Bool: "Bool"
        ConcreteType.String: "String"
        ConcreteType.Nil: "Nil"
        ConcreteType.Named(n): n
        ConcreteType.Array(elem): "Array_{_concrete_type_to_mangled(elem)}"
        ConcreteType.Tuple(elems):
            var parts: [text] = []
            for e in elems:
                parts.push(_concrete_type_to_mangled(e))
            "Tuple_{parts.join('_')}"
        ConcreteType.Dict(k, v):
            "Dict_{_concrete_type_to_mangled(k)}_{_concrete_type_to_mangled(v)}"
        ConcreteType.Function(params, ret):
            var param_parts: [text] = []
            for p in params:
                param_parts.push(_concrete_type_to_mangled(p))
            "Fn_{param_parts.join('_')}_{_concrete_type_to_mangled(ret)}"
        ConcreteType.Optional(inner): "Opt_{_concrete_type_to_mangled(inner)}"
        ConcreteType.Pointer(_, _, inner): _concrete_type_to_mangled(inner)
        ConcreteType.Specialized(name, args):
            var arg_parts: [text] = []
            for a in args:
                arg_parts.push(_concrete_type_to_mangled(a))
            "{name}_{arg_parts.join('_')}"

fn _is_identifier_char(c: text) -> bool:
    """Check if a character can appear in a type parameter name."""
    if c.len() != 1:
        return false
    val code = c.char_code_at(0)
    # a-z, A-Z, 0-9, _
    val is_lower = code >= 97 and code <= 122
    val is_upper = code >= 65 and code <= 90
    val is_digit = code >= 48 and code <= 57
    val is_underscore = code == 95
    is_lower or is_upper or is_digit or is_underscore

fn _substitute_type_in_text(s: text, param: text, replacement: text) -> text:
    """Replace occurrences of a type parameter name in a text string.

    Only replaces whole-word occurrences (not substrings of longer identifiers).
    Handles type parameter names appearing in type annotations like 'T', 'List<T>',
    'fn(T) -> T', etc.
    """
    if s.len() == 0:
        return s
    if param.len() == 0:
        return s

    var result = ""
    var i = 0
    val slen = s.len()
    val plen = param.len()

    while i < slen:
        # Check if param appears at position i
        val remaining = slen - i
        if remaining >= plen:
            val candidate = s[i..(i + plen)]
            if candidate == param:
                # Check word boundaries: char before must not be identifier char
                var before_ok = true
                if i > 0:
                    val before_char = s[(i - 1)..i]
                    before_ok = not _is_identifier_char(before_char)

                # Check word boundary after
                var after_ok = true
                val after_pos = i + plen
                if after_pos < slen:
                    val after_char = s[after_pos..(after_pos + 1)]
                    after_ok = not _is_identifier_char(after_char)

                if before_ok and after_ok:
                    result = result + replacement
                    i = i + plen
                    continue

        result = result + s[i..(i + 1)]
        i = i + 1

    result

fn _substitute_all_params_in_text(s: text, generic_params: [text], type_args: [ConcreteType]) -> text:
    """Substitute all type parameters in a text string with concrete type names."""
    var current = s
    var idx = 0
    for param in generic_params:
        if idx < type_args.len():
            val replacement = _concrete_type_to_text(type_args[idx])
            current = _substitute_type_in_text(current, param, replacement)
        idx = idx + 1
    current

fn _substitute_in_text_list(items: [text], generic_params: [text], type_args: [ConcreteType]) -> [text]:
    """Substitute type parameters in a list of text items."""
    var result: [text] = []
    for item in items:
        result.push(_substitute_all_params_in_text(item, generic_params, type_args))
    result

fn _substitute_in_text_dict(dict: {text: text}, generic_params: [text], type_args: [ConcreteType]) -> {text: text}:
    """Substitute type parameters in a text dict's values (type bindings)."""
    var result: {text: text} = {}
    for (k, v) in dict.items():
        result[k] = _substitute_all_params_in_text(v, generic_params, type_args)
    result

fn _make_mangled_name(base_name: text, type_args: [ConcreteType]) -> text:
    """Generate a mangled name for a specialized definition."""
    if type_args.is_empty():
        return base_name
    var arg_parts: [text] = []
    for arg in type_args:
        arg_parts.push(_concrete_type_to_mangled(arg))
    "{base_name}${arg_parts.join('_')}"

fn _build_type_bindings_text(generic_params: [text], type_args: [ConcreteType]) -> {text: text}:
    """Build a text-level type bindings map for a specialization."""
    var bindings: {text: text} = {}
    var idx = 0
    for param in generic_params:
        if idx < type_args.len():
            bindings[param] = _concrete_type_to_text(type_args[idx])
        idx = idx + 1
    bindings

fn _build_type_bindings(generic_params: [text], type_args: [ConcreteType]) -> TypeBindings:
    """Build a TypeBindings map for metadata tracking."""
    var bindings: TypeBindings = {}
    var idx = 0
    for param in generic_params:
        if idx < type_args.len():
            bindings[param] = type_args[idx]
        idx = idx + 1
    bindings

# ============================================================================
# Specialization Functions
# ============================================================================

fn _specialize_function_def(func: FunctionDef, type_args: [ConcreteType]) -> FunctionDef:
    """Create a specialized FunctionDef by substituting type parameters.

    Substitutes type params in:
    - params (parameter type annotations)
    - return_type
    - body (all type references in function body)
    - type_bindings (records the substitution)

    Sets:
    - name to the mangled name
    - generic_params to empty (fully specialized)
    - is_generic_template to false
    - specialization_of to original name
    """
    val mangled = _make_mangled_name(func.name, type_args)
    val gp = func.generic_params
    val new_params = _substitute_in_text_list(func.params, gp, type_args)
    val new_body = _substitute_in_text_list(func.body, gp, type_args)
    val new_bindings = _build_type_bindings_text(gp, type_args)

    var new_return_type: text? = nil
    if func.return_type != nil:
        new_return_type = _substitute_all_params_in_text(func.return_type, gp, type_args)

    FunctionDef(
        name: mangled,
        generic_params: [],
        params: new_params,
        return_type: new_return_type,
        body: new_body,
        is_generic_template: false,
        specialization_of: func.name,
        type_bindings: new_bindings
    )

fn _specialize_struct_def(s: StructDef, type_args: [ConcreteType]) -> StructDef:
    """Create a specialized StructDef by substituting type parameters.

    Substitutes type params in:
    - fields (field type annotations)
    - type_bindings (records the substitution)

    Sets:
    - name to the mangled name
    - generic_params to empty (fully specialized)
    - is_generic_template to false
    - specialization_of to original name
    """
    val mangled = _make_mangled_name(s.name, type_args)
    val gp = s.generic_params
    val new_fields = _substitute_in_text_list(s.fields, gp, type_args)
    val new_bindings = _build_type_bindings_text(gp, type_args)

    StructDef(
        name: mangled,
        generic_params: [],
        fields: new_fields,
        is_generic_template: false,
        specialization_of: s.name,
        type_bindings: new_bindings
    )

fn _specialize_class_def(c: ClassDef, type_args: [ConcreteType]) -> ClassDef:
    """Create a specialized ClassDef by substituting type parameters.

    Substitutes type params in:
    - fields (field type annotations)
    - methods (method signatures and bodies)
    - type_bindings (records the substitution)

    Sets:
    - name to the mangled name
    - generic_params to empty (fully specialized)
    - is_generic_template to false
    - specialization_of to original name
    """
    val mangled = _make_mangled_name(c.name, type_args)
    val gp = c.generic_params
    val new_fields = _substitute_in_text_list(c.fields, gp, type_args)
    val new_methods = _substitute_in_text_list(c.methods, gp, type_args)
    val new_bindings = _build_type_bindings_text(gp, type_args)

    ClassDef(
        name: mangled,
        generic_params: [],
        fields: new_fields,
        methods: new_methods,
        is_generic_template: false,
        specialization_of: c.name,
        type_bindings: new_bindings
    )

fn _specialize_enum_def(e: EnumDef, type_args: [ConcreteType]) -> EnumDef:
    """Create a specialized EnumDef by substituting type parameters.

    Substitutes type params in:
    - variants (variant type annotations)
    - type_bindings (records the substitution)

    Sets:
    - name to the mangled name
    - generic_params to empty (fully specialized)
    - is_generic_template to false
    - specialization_of to original name
    """
    val mangled = _make_mangled_name(e.name, type_args)
    val gp = e.generic_params
    val new_variants = _substitute_in_text_list(e.variants, gp, type_args)
    val new_bindings = _build_type_bindings_text(gp, type_args)

    EnumDef(
        name: mangled,
        generic_params: [],
        variants: new_variants,
        is_generic_template: false,
        specialization_of: e.name,
        type_bindings: new_bindings
    )

# ============================================================================
# Instantiation Mode
# ============================================================================

enum InstantiationMode:
    """Instantiation mode for deferred monomorphization."""

    # Link-time instantiation for native binary builds.
    # Instantiates all needed specializations before final linking.
    LinkTime

    # JIT-time instantiation for .smf loader execution.
    # Instantiates specializations on-demand during runtime.
    JitTime
