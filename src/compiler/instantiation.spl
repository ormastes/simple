# Shared Template Instantiator
#
# Common instantiation logic used by compiler, JIT, and linker contexts.
# Handles caching, cycle detection, and delegation to CompilationContext.

use compilation_context.{CompilationContext, ConcreteType, InstantiationMode}
use backend_types.CompiledUnit
use monomorphize.note_sdn.{InstantiationEntry, InstantiationStatus}

# ============================================================================
# Name Mangling
# ============================================================================

fn mangle(template_name, type_args):
    """Mangle a template name with concrete type arguments."""
    if type_args.is_empty():
        return template_name
    val args_str = type_args.map(\t: t.to_string()).join(",")
    "{template_name}${args_str}"

# ============================================================================
# TemplateInstantiator
# ============================================================================

class TemplateInstantiator:
    """Shared instantiation logic for compiler, JIT, and linker."""
    context: CompilationContext
    in_progress: Set<text>
    cache: Dict<text, CompiledUnit>

    me instantiate(template_name, type_args):
        val key = mangle(template_name, type_args)

        # 1. Cache check
        if self.cache.contains_key(key):
            return Ok(self.cache[key])

        # 2. Cycle detection
        if self.in_progress.contains(key):
            return Err("Circular dependency: {key}")

        self.in_progress = self.in_progress.insert(key)

        # 3. Load template from context
        val load_result = self.context.load_template(template_name)
        if load_result.is_err():
            self.in_progress = self.in_progress.remove(key)
            return load_result

        val tmpl = load_result.unwrap()

        # 4. Compile through full pipeline (context handles AOP/DI/contracts)
        val compile_result = self.context.compile_template(tmpl, type_args)
        if compile_result.is_err():
            self.in_progress = self.in_progress.remove(key)
            return compile_result

        val unit = compile_result.unwrap()

        # 5. Record metadata
        val inst_entry = InstantiationEntry { template_name: template_name, type_args: type_args.map(\t: t.to_string()).join(","), mangled_name: key, from_file: "instantiator", from_loc: "instantiator:0:0", to_obj: "output", status: InstantiationStatus.Compiled }
        self.context.record_instantiation(inst_entry)

        # 6. Cache
        self.cache[key] = unit
        self.in_progress = self.in_progress.remove(key)
        Ok(unit)

    fn is_cached(template_name, type_args):
        val key = mangle(template_name, type_args)
        self.cache.contains_key(key)

    fn cache_size():
        self.cache.len()

# ============================================================================
# Exports
# ============================================================================

export TemplateInstantiator, mangle
