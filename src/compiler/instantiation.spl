# Shared Template Instantiator
#
# Common instantiation logic used by compiler, JIT, and linker contexts.
# Handles caching, cycle detection, and delegation to CompilationContext.

use compilation_context.{CompilationContext, ConcreteType, InstantiationMode}
use backend_types.CompiledUnit
use monomorphize/note_sdn.{InstantiationEntry, InstantiationStatus}

# ============================================================================
# Name Mangling
# ============================================================================

fn mangle(template_name: text, type_args: [ConcreteType]) -> text:
    """Mangle a template name with concrete type arguments."""
    if type_args.is_empty():
        return template_name
    val args_str = type_args.map(\t: t.to_string()).join(",")
    "{template_name}${args_str}"

# ============================================================================
# TemplateInstantiator
# ============================================================================

class TemplateInstantiator:
    """Shared instantiation logic for compiler, JIT, and linker."""
    context: CompilationContext
    in_progress: Set<text>
    cache: Dict<text, CompiledUnit>

    me instantiate(template_name: text, type_args: [ConcreteType]) -> Result<CompiledUnit, text>:
        val key = mangle(template_name, type_args)

        # 1. Cache check
        if self.cache.contains_key(key):
            return Ok(self.cache[key])

        # 2. Cycle detection
        if self.in_progress.contains(key):
            return Err("Circular dependency: {key}")

        self.in_progress = self.in_progress.insert(key)

        # 3. Load template from context
        val template = self.context.load_template(template_name)?

        # 4. Compile through full pipeline (context handles AOP/DI/contracts)
        val unit = self.context.compile_template(template, type_args)?

        # 5. Record metadata
        self.context.record_instantiation(InstantiationEntry(
            template_name: template_name,
            type_args: type_args.map(\t: t.to_string()).join(","),
            mangled_name: key,
            from_file: "instantiator",
            from_loc: "instantiator:0:0",
            to_obj: "output",
            status: InstantiationStatus.Compiled
        ))

        # 6. Cache
        self.cache[key] = unit
        self.in_progress = self.in_progress.remove(key)
        Ok(unit)

    fn is_cached(template_name: text, type_args: [ConcreteType]) -> bool:
        val key = mangle(template_name, type_args)
        self.cache.contains_key(key)

    fn cache_size() -> i32:
        self.cache.len()

# ============================================================================
# Exports
# ============================================================================

export TemplateInstantiator, mangle
