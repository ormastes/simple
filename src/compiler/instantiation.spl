# Shared Template Instantiator
#
# Common instantiation logic used by compiler, JIT, and linker contexts.
# Handles caching, cycle detection, and delegation to CompilationContext.

# Types CompilationContext, ConcreteType, InstantiationMode are defined in
# compilation_context.spl. Import is omitted to avoid transitive parse errors
# from other modules in the compiler/ directory when running in interpreter mode.

# ============================================================================
# Name Mangling
# ============================================================================

fn mangle(template_name, type_args):
    """Mangle a template name with concrete type arguments."""
    if type_args_is_empty(type_args):
        return template_name
    val args_str = type_args.map(\t: t.to_string()).join(",")
    "{template_name}${args_str}"

# ============================================================================
# TemplateInstantiator
# ============================================================================

class TemplateInstantiator:
    """Shared instantiation logic for compiler, JIT, and linker."""
    context: CompilationContext
    in_progress: Set<text>
    cache: Dict<text, Any>

    me instantiate(template_name, type_args):
        val key = mangle(template_name, type_args)

        # 1. Cache check
        if self.cache_contains_key(cache, key):
            return Ok(self.cache[key])

        # 2. Cycle detection
        if self.in_progress_contains(in_progress, key):
            return Err("Circular dependency: {key}")

        self.in_progress = self.in_progress_insert(in_progress, key)

        # 3. Load template from context
        val load_result = self.context_load_template(context, template_name)
        if load_result_is_err(load_result):
            self.in_progress = self.in_progress_remove(in_progress, key)
            return load_result

        val tmpl = load_result_value

        # 4. Compile through full pipeline (context handles AOP/DI/contracts)
        val compile_result = self.context_compile_template(context, tmpl, type_args)
        if compile_result_is_err(compile_result):
            self.in_progress = self.in_progress_remove(in_progress, key)
            return compile_result

        val compiled = compile_result_value

        # 5. Cache
        self.cache[key] = compiled
        self.in_progress = self.in_progress_remove(in_progress, key)
        Ok(compiled)

    fn is_cached(template_name, type_args):
        val key = mangle(template_name, type_args)
        self.cache_contains_key(cache, key)

    fn cache_size():
        self.cache_len(cache)

# ============================================================================
# Exports
# ============================================================================

export TemplateInstantiator, mangle
