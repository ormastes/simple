use compiler.test_common.*
use compiler.hir_lowering.*
use compiler.mir_lowering.*
use compiler.mir_data.*

val source = "fn main() -> i64:\n    0\n"
var parser = Parser.new(source)
val ast_module = parser.parse()
print "AST: {ast_module.functions.keys()}"

var hir_lowering = HirLowering.new()
val hir_module = hir_lowering.lower_module(ast_module)
print "HIR functions: {hir_module.functions.keys()}"

# Check HIR function body
for key in hir_module.functions.keys():
    val fn_ = hir_module.functions[key]
    print "HIR fn: {fn_.name}"
    print "  Return type: {fn_.return_type}"
    print "  Body: {fn_.body}"
    print "  Body.value: {fn_.body.value}"
    if fn_.body.value.?:
        val val_expr = fn_.body.value.unwrap()
        print "  Body expr kind: {val_expr.kind}"

var mir_ctx = MirLowering.new(hir_lowering.symbols)

# Debug: check builder state before
print "Builder before: locals={mir_ctx.builder.locals.len()}, blocks={mir_ctx.builder.blocks.len()}"

val mir_module = mir_ctx.lower_module(hir_module)
print "MIR functions: {mir_module.functions.keys().len()}"
for key in mir_module.functions.keys():
    val fn_ = mir_module.functions[key]
    print "MIR fn: {fn_.name}, blocks={fn_.blocks.len()}, locals={fn_.locals.len()}"
    for blk in fn_.blocks:
        print "  Block {blk.id.id}: insts={blk.instructions.len()}, term={blk.terminator}"
        for inst in blk.instructions:
            print "    Inst: {inst.kind}"
