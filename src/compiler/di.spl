# Dependency Injection Container
#
# DI container with profile-based bindings for compiler services.
# Profiles: dev, test, prod, sdn â€” each binds different implementations.

use compiler.config (CompilerProfile)

# Local panic function for DI errors
fn di_panic(msg: text):
    print "DI PANIC: {msg}"

# ============================================================================
# Binding
# ============================================================================

struct Binding:
    """A named binding: factory + optional profile restriction."""
    factory: fn() -> Any
    profile: CompilerProfile?    # nil = all profiles
    tags: [text]

# ============================================================================
# DiContainer
# ============================================================================

class DiContainer:
    """Dependency injection container with profile-based bindings.

    Usage:
        val di = DiContainer(bindings: {}, singletons: {}, profile: "dev", all_bindings: [])
        di.bind("Backend", \: InterpreterBackendImpl())
        di.bind_for_profile("Backend", CompilerProfile.Prod, \: CompilerBackendImpl.jit())
        val backend = di.resolve("Backend")
    """
    bindings: Dict<text, fn() -> Any>
    singletons: Dict<text, Any>
    profile: text
    all_bindings: [Binding]

impl DiContainer:
    static fn for_profile(profile: CompilerProfile) -> DiContainer:
        """Create container configured for a specific profile."""
        DiContainer(
            bindings: {},
            singletons: {},
            profile: profile.to_text(),
            all_bindings: []
        )

    me bind(name: text, factory: fn() -> Any):
        """Bind a factory function to a name (all profiles)."""
        var b = self.bindings
        b[name] = factory
        self.bindings = b
        self.all_bindings = self.all_bindings.push(Binding(
            factory: factory,
            profile: nil,
            tags: []
        ))

    me bind_for_profile(name: text, profile: CompilerProfile, factory: fn() -> Any):
        """Bind a factory that only activates for a specific profile."""
        val binding = Binding(
            factory: factory,
            profile: Some(profile),
            tags: []
        )
        self.all_bindings = self.all_bindings.push(binding)
        # If current profile matches, register as active binding
        if profile.to_text() == self.profile:
            var b = self.bindings
            b[name] = factory
            self.bindings = b

    me bind_tagged(name: text, tags: [text], factory: fn() -> Any):
        """Bind with tags for filtered resolution."""
        var b = self.bindings
        b[name] = factory
        self.bindings = b
        self.all_bindings = self.all_bindings.push(Binding(
            factory: factory,
            profile: nil,
            tags: tags
        ))

    me bind_instance(name: text, instance: Any):
        """Bind an already-created instance directly (no closure needed)."""
        var s = self.singletons
        s[name] = instance
        self.singletons = s

    fn resolve(name: text) -> Any:
        """Resolve a binding by name. Singletons checked first."""
        if self.singletons.contains(name):
            return self.singletons[name]
        if self.bindings.contains(name):
            val instance = self.bindings[name]()
            return instance
        di_panic("No binding found for: {name}")
        nil

    fn resolve_or(name: text, default: Any) -> Any:
        """Resolve a binding, returning default if not found."""
        if self.singletons.contains(name):
            return self.singletons[name]
        if self.bindings.contains(name):
            return self.bindings[name]()
        default

    fn has(name: text) -> bool:
        """Check if a binding exists."""
        self.singletons.contains(name) or self.bindings.contains(name)

    me resolve_singleton(name: text) -> Any:
        """Resolve and cache as singleton for future calls."""
        if self.singletons.contains(name):
            return self.singletons[name]
        if self.bindings.contains(name):
            val instance = self.bindings[name]()
            var s = self.singletons
            s[name] = instance
            self.singletons = s
            return instance
        di_panic("No binding found for: {name}")
        nil

# ============================================================================
# Global container access
# ============================================================================

var _global_container: DiContainer? = nil

fn set_container(container: DiContainer):
    """Set the global DI container."""
    _global_container = Some(container)

fn get_container() -> DiContainer:
    """Get the global DI container (creates default if not set)."""
    if _global_container.?:
        return _global_container.unwrap()
    val default = DiContainer.for_profile(CompilerProfile.Dev)
    _global_container = Some(default)
    default

export DiContainer, Binding
export set_container, get_container
