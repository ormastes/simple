"""
Effect System - Canonical Standalone Effect Infrastructure

This is the single canonical effect module for the 00.common layer.
All other 00.common/effects_*.spl files import from here.

The HIR layer (20.hir/hir_types.spl) defines the richer Effect/EffectKind types
used in the compiler pipeline. This module provides a lightweight EffectTag enum
for standalone effect inference that maps to EffectKind.Async / default.

## Algorithm

1. Initialize all functions as Sync
2. Mark built-in async functions (FFI)
3. Fixed-point iteration:
   - Scan function bodies for suspension operators (~, ~=, if~, while~, for~)
   - Scan function calls (async calls -> function becomes async)
   - Repeat until no changes
4. Validate `fn sync` annotations
5. Propagate effects to HirFunction.effects via effect_pass.spl
"""

# Symbol type alias for function names
type Symbol = text

# ============================================================================
# Effect Tag (lightweight, maps to HIR EffectKind.Async / default)
# ============================================================================

enum EffectTag:
    """
    Lightweight effect tag for standalone inference in 00.common layer.

    Maps to HIR EffectKind:
    - Sync -> no Async in EffectKind list (default/pure)
    - Async -> EffectKind.Async present

    The full Effect/EffectKind types live in 20.hir/hir_types.spl.
    """
    Sync
    Async

    fn to_string() -> text:
        match self:
            case Sync: "sync"
            case Async: "async"

    fn is_async() -> bool:
        """Check if effect is Async"""
        match self:
            case Async: true
            case Sync: false

    fn is_sync() -> bool:
        """Check if effect is Sync"""
        match self:
            case Sync: true
            case Async: false

    fn combine(other: EffectTag) -> EffectTag:
        """
        Combine two effects: if either is Async, result is Async
        """
        match (self, other):
            case (Async, _): Async
            case (_, Async): Async
            case (Sync, Sync): Sync

impl EffectTag:
    static fn combine_all(effects: [EffectTag]) -> EffectTag:
        """
        Combine multiple effects: if any is Async, result is Async
        """
        var result = EffectTag.Sync
        for eff in effects:
            result = result.combine(eff)
        result

# ============================================================================
# Effect Environment
# ============================================================================

class EffectEnv:
    """
    Tracks function effects during inference.

    Fields:
    - effects: Function name -> inferred EffectTag
    - builtins: Built-in FFI function effects (http.get, file.read_async, etc.)
    - dirty: Functions whose effect changed (for fixed-point iteration)
    """
    effects: Dict<Symbol, EffectTag>
    builtins: Dict<text, EffectTag>
    dirty: Set<Symbol>

impl EffectEnv:
    static fn new() -> EffectEnv:
        """Create new effect environment with built-in annotations"""
        EffectEnv(
            effects: {},
            builtins: init_builtins(),
            dirty: Set.new()
        )

    fn get_effect(sym: Symbol) -> EffectTag:
        """
        Get effect for function symbol.

        Priority:
        1. Local effects (inferred)
        2. Built-ins (FFI annotations)
        3. Default to Sync
        """
        # Check local effects first
        if val Some(eff) = self.effects.get(sym):
            return eff

        # Check builtins by function name
        if val Some(eff) = self.builtins.get(sym):
            return eff

        # Default to Sync
        EffectTag.Sync

    fn set_effect(sym: Symbol, eff: EffectTag):
        """
        Set effect for function symbol.

        If effect changed, mark symbol as dirty for next iteration.
        """
        val old_eff = self.get_effect(sym)

        if old_eff != eff:
            self.effects[sym] = eff
            self.dirty.insert(sym)

    fn is_dirty() -> bool:
        """Check if any functions changed effect (for fixed-point check)"""
        not self.dirty.is_empty()

    fn clear_dirty():
        """Clear dirty set (start new fixed-point iteration)"""
        self.dirty.clear()

    fn iter_effects() -> [(Symbol, EffectTag)]:
        """Iterate over all inferred effects"""
        self.effects.iter().collect()

    fn count_async() -> i64:
        """Count number of async functions"""
        var count = 0
        for (_, eff) in self.effects.iter():
            if eff.is_async():
                count = count + 1
        count

    fn count_sync() -> i64:
        """Count number of sync functions"""
        var count = 0
        for (_, eff) in self.effects.iter():
            if eff.is_sync():
                count = count + 1
        count

# ============================================================================
# Built-in Effect Annotations (FFI Functions)
# ============================================================================

fn init_builtins() -> Dict<text, EffectTag>:
    """
    Initialize built-in effect annotations for FFI functions.

    Categories:
    - HTTP: All async (network I/O)
    - File: Async variants marked
    - Sleep/Timer: Async
    - Sync I/O: Marked sync explicitly
    """
    var builtins: Dict<text, EffectTag> = {}

    # HTTP module - all async
    builtins["http.get"] = EffectTag.Async
    builtins["http.post"] = EffectTag.Async
    builtins["http.put"] = EffectTag.Async
    builtins["http.delete"] = EffectTag.Async
    builtins["http.patch"] = EffectTag.Async
    builtins["http.request"] = EffectTag.Async

    # WebSocket - async
    builtins["websocket.connect"] = EffectTag.Async
    builtins["websocket.send"] = EffectTag.Async
    builtins["websocket.receive"] = EffectTag.Async

    # File I/O - async variants
    builtins["file.read_async"] = EffectTag.Async
    builtins["file.write_async"] = EffectTag.Async
    builtins["file.append_async"] = EffectTag.Async
    builtins["file.read"] = EffectTag.Sync      # Blocking sync variant
    builtins["file.write"] = EffectTag.Sync     # Blocking sync variant

    # Timer/Sleep - async
    builtins["sleep"] = EffectTag.Async
    builtins["timer.wait"] = EffectTag.Async
    builtins["timeout"] = EffectTag.Async

    # Database - async
    builtins["db.query"] = EffectTag.Async
    builtins["db.execute"] = EffectTag.Async
    builtins["db.transaction"] = EffectTag.Async

    # Process - async
    builtins["process.spawn"] = EffectTag.Async
    builtins["process.wait"] = EffectTag.Async

    # Console/stdio - sync (buffered)
    builtins["print"] = EffectTag.Sync
    builtins["println"] = EffectTag.Sync
    builtins["eprint"] = EffectTag.Sync
    builtins["eprintln"] = EffectTag.Sync

    # Math/String/Collection ops - all sync
    # (No need to list, default is Sync)

    builtins

# ============================================================================
# Effect Error
# ============================================================================

class EffectError:
    """
    Effect inference error.

    Examples:
    - Function annotated `fn sync` but contains suspension operators
    - Suspend operator on non-Promise type
    - Fixed-point solver failed to converge
    """
    message: text
    func_name: text
    # # DESUGARED: span_text: text
    has_span_text: bool
    span_text: text

    fn to_string() -> text:
        "[Effect Error] {self.func_name}: {self.message}"

# ============================================================================
# Statistics
# ============================================================================

class EffectStats:
    """Statistics about effect inference run"""
    total_functions: i64
    async_functions: i64
    sync_functions: i64
    iterations: i64
    builtins_count: i64

    fn to_string() -> text:
        """
        Effect Inference Statistics:
        - Total functions: 150
        - Async functions: 42 (28%)
        - Sync functions: 108 (72%)
        - Fixed-point iterations: 3
        - Built-in annotations: 30
        """
        val async_pct = if self.total_functions > 0:
            (self.async_functions * 100) / self.total_functions
        else:
            0

        val sync_pct = if self.total_functions > 0:
            (self.sync_functions * 100) / self.total_functions
        else:
            0

        """
Effect Inference Statistics:
- Total functions: {self.total_functions}
- Async functions: {self.async_functions} ({async_pct}%)
- Sync functions: {self.sync_functions} ({sync_pct}%)
- Fixed-point iterations: {self.iterations}
- Built-in annotations: {self.builtins_count}
        """

# ============================================================================
# FunctionEffectInfo - Lightweight descriptor for effect inference
# ============================================================================

struct FunctionEffectInfo:
    """Lightweight function descriptor for effect inference.

    Used by the effect pass to collect function metadata before
    running fixed-point inference. Maps to real HirFunction data
    via effect_pass.spl.
    """
    name: text
    is_async: bool
    contains_suspension: bool
    called_functions: [text]

# ============================================================================
# Module Functions
# ============================================================================

fn effect_tag_to_string(eff: EffectTag) -> text:
    """Convert effect tag to string (convenience function)"""
    eff.to_string()

fn tag_is_async(eff: EffectTag) -> bool:
    """Check if effect tag is async (convenience function)"""
    eff.is_async()

fn tag_is_sync(eff: EffectTag) -> bool:
    """Check if effect tag is sync (convenience function)"""
    eff.is_sync()

# ============================================================================
# Exports
# ============================================================================

export EffectTag, EffectEnv, EffectError, EffectStats, FunctionEffectInfo
export init_builtins, effect_tag_to_string, tag_is_async, tag_is_sync

# ============================================================================
# Tests (Inline Unit Tests)
# ============================================================================

fn test_effect_basic():
    """Test basic effect operations"""
    val sync = EffectTag.Sync
    val async_ = EffectTag.Async

    # to_string
    assert sync.to_string() == "sync"
    assert async_.to_string() == "async"

    # is_async / is_sync
    assert sync.is_sync()
    assert not sync.is_async()
    assert async_.is_async()
    assert not async_.is_sync()

fn test_effect_combine():
    """Test effect combination"""
    val sync = EffectTag.Sync
    val async_ = EffectTag.Async

    assert sync.combine(sync) == EffectTag.Sync
    assert sync.combine(async_) == EffectTag.Async
    assert async_.combine(sync) == EffectTag.Async
    assert async_.combine(async_) == EffectTag.Async

fn test_effect_combine_all():
    """Test combining multiple effects"""
    assert EffectTag.combine_all([]) == EffectTag.Sync
    assert EffectTag.combine_all([EffectTag.Sync, EffectTag.Sync]) == EffectTag.Sync
    assert EffectTag.combine_all([EffectTag.Sync, EffectTag.Async]) == EffectTag.Async
    assert EffectTag.combine_all([EffectTag.Async, EffectTag.Sync, EffectTag.Sync]) == EffectTag.Async

fn test_effect_env_basic():
    """Test EffectEnv creation and basic operations"""
    val env = EffectEnv.new()

    # Should have built-ins
    assert env.builtins.len() > 0

    # Check specific built-ins
    assert env.get_effect("http.get") == EffectTag.Async
    assert env.get_effect("print") == EffectTag.Sync
    assert env.get_effect("unknown_function") == EffectTag.Sync  # Default

fn test_effect_env_set_get():
    """Test setting and getting effects"""
    val env = EffectEnv.new()
    val sym = "my_function"

    # Initially Sync (default)
    assert env.get_effect(sym) == EffectTag.Sync

    # Set to Async
    env.set_effect(sym, EffectTag.Async)
    assert env.get_effect(sym) == EffectTag.Async

    # Should be marked dirty
    assert env.is_dirty()

fn test_effect_env_dirty():
    """Test dirty tracking"""
    val env = EffectEnv.new()
    val sym = "test"

    # Initially not dirty
    assert not env.is_dirty()

    # Setting same effect shouldn't mark dirty
    env.set_effect(sym, EffectTag.Sync)
    env.clear_dirty()
    env.set_effect(sym, EffectTag.Sync)
    assert not env.is_dirty()

    # Changing effect should mark dirty
    env.set_effect(sym, EffectTag.Async)
    assert env.is_dirty()

fn test_builtins():
    """Test built-in effect annotations"""
    val builtins = init_builtins()

    # Check HTTP functions are async
    assert builtins["http.get"] == EffectTag.Async
    assert builtins["http.post"] == EffectTag.Async

    # Check sync I/O
    assert builtins["print"] == EffectTag.Sync
    assert builtins["file.read"] == EffectTag.Sync

    # Check async I/O
    assert builtins["file.read_async"] == EffectTag.Async
    assert builtins["sleep"] == EffectTag.Async

# Run tests if executed directly
fn main():
    print "Running effect system tests..."

    test_effect_basic()
    test_effect_combine()
    test_effect_combine_all()
    test_effect_env_basic()
    test_effect_env_set_get()
    test_effect_env_dirty()
    test_builtins()

    print "All effect system infrastructure tests passed!"
