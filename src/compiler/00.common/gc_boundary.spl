# GC Boundary Checker
#
# Detects and warns about cross-GC-mode boundary calls.
# When a function in GC mode calls a function in NoGC mode (or vice versa),
# a warning is emitted to alert the developer about potential
# ownership/lifetime mismatches.
#
# These are warnings (not errors) - compilation continues.
# Severity: Warn (default). Can be elevated to Error via lint config.

from parser_types import {Span}

export GcBoundaryChecker
export GC_BOUNDARY_LINT_NAME

use compiler.gc_config (GcMode, GcConfig, GcMismatchWarning)

# Lint category name for cross-mode warnings
val GC_BOUNDARY_LINT_NAME: text = "gc_boundary_crossing"

# ============================================================================
# GC Boundary Checker
# ============================================================================

struct GcBoundaryChecker:
    """Checks for and collects cross-GC-mode boundary warnings.

    Used during type checking to detect when function calls cross
    GC mode boundaries (e.g., a GC-mode function calling a NoGC-mode
    function or vice versa).

    Warnings are collected and emitted at the end of type checking.
    """
    # Collected warnings
    warnings: [GcMismatchWarning]

    # Current GC config for the file/module being checked
    current_gc_config: GcConfig

impl GcBoundaryChecker:
    static fn new(gc_config: GcConfig) -> GcBoundaryChecker:
        """Create a new boundary checker for a compilation unit."""
        GcBoundaryChecker(
            warnings: [],
            current_gc_config: gc_config
        )

    me check_call(callee_gc_config: GcConfig, callee_name: text, span: Span):
        """Check a function call for GC mode boundary crossing.

        If the caller's GC mode differs from the callee's GC mode,
        a CrossModeCall warning is recorded.

        Arguments:
        - callee_gc_config: GC config of the function being called
        - callee_name: Name of the function being called
        - span: Source location of the call
        """
        val caller_mode = self.current_gc_config.mode
        val callee_mode = callee_gc_config.mode
        if not caller_mode.eq(callee_mode):
            self.warnings.push(GcMismatchWarning.CrossModeCall(
                caller_mode: caller_mode,
                callee_mode: callee_mode,
                callee_name: callee_name,
                span: span
            ))

    me check_return(return_gc_config: GcConfig, fn_name: text, span: Span):
        """Check a function return for GC mode mismatch.

        If a function returns a value whose GC mode differs from
        the function's own mode, a CrossModeReturn warning is recorded.

        Arguments:
        - return_gc_config: GC config of the returned value's origin
        - fn_name: Name of the function returning
        - span: Source location of the return
        """
        val fn_mode = self.current_gc_config.mode
        val return_mode = return_gc_config.mode
        if not fn_mode.eq(return_mode):
            self.warnings.push(GcMismatchWarning.CrossModeReturn(
                fn_mode: fn_mode,
                return_mode: return_mode,
                fn_name: fn_name,
                span: span
            ))

    me check_implicit_conversion(from_gc_config: GcConfig, span: Span):
        """Check for implicit GC mode conversion (e.g., assignment).

        If a value from one GC mode is assigned to a variable in a
        different GC mode context, an ImplicitConversion warning is recorded.

        Arguments:
        - from_gc_config: GC config of the source value
        - span: Source location of the conversion
        """
        val to_mode = self.current_gc_config.mode
        val from_mode = from_gc_config.mode
        if not to_mode.eq(from_mode):
            self.warnings.push(GcMismatchWarning.ImplicitConversion(
                from_mode: from_mode,
                to_mode: to_mode,
                span: span
            ))

    fn has_warnings() -> bool:
        """Check if any warnings were recorded."""
        not self.warnings.is_empty()

    fn warning_count() -> i64:
        """Get the number of warnings recorded."""
        self.warnings.len()

    fn format_warnings() -> [text]:
        """Format all warnings as human-readable messages."""
        var messages: [text] = []
        for warning in self.warnings:
            messages.push("warning[{GC_BOUNDARY_LINT_NAME}]: {warning.message()}")
        messages
