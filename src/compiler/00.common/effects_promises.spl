"""
Effect System - Promise Type Operations

Provides utility functions for Promise type wrapping/unwrapping based on
effect tags. Uses the canonical EffectTag from effects.spl.

Note: Actual HirType-based Promise wrapping will be done in the effect pass
(30.types layer) which has access to real HIR types. This module provides
text-based helpers for standalone use.
"""

use compiler.common.effects.{EffectTag, EffectEnv}

# ============================================================================
# Promise Type Helpers (text-based, standalone)
# ============================================================================

fn is_promise_type_name(type_name: text) -> bool:
    """Check if a type name represents a Promise type."""
    type_name.starts_with("Promise<") or type_name == "Promise"

fn wrap_in_promise_name(type_name: text) -> text:
    """Wrap a type name in Promise<T> if not already wrapped."""
    if is_promise_type_name(type_name):
        type_name
    else:
        "Promise<{type_name}>"

fn unwrap_promise_name(type_name: text) -> text?:
    """Extract inner type name from Promise<T>. Returns nil if not a Promise."""
    if type_name.starts_with("Promise<") and type_name.ends_with(">"):
        val inner = type_name[8:type_name.len() - 1]
        Some(inner)
    else:
        nil

fn needs_promise_wrapping(func_name: text, env: EffectEnv) -> bool:
    """Check if a function needs its return type wrapped in Promise."""
    val eff = env.get_effect(func_name)
    eff.is_async()

# ============================================================================
# Exports
# ============================================================================

export is_promise_type_name, wrap_in_promise_name, unwrap_promise_name
export needs_promise_wrapping
