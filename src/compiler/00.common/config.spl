# Compiler Configuration
#
# Configuration types and loaders for the compiler.
# Supports: .sdn files, env vars, CLI args, profile selection.

use compiler.ffi (env_get)

# ============================================================================
# Profile
# ============================================================================

enum CompilerProfile:
    """Compilation profile controlling backend selection and logging."""
    Dev      # FullHirInst + DebugLogger
    Test     # FullHirInst + TestLogger (deterministic)
    Prod     # FullHirInst + ProductionLogger
    Sdn      # SdnHirInst (no-op) + SdnLogger

impl CompilerProfile:
    fn to_text() -> text:
        match self:
            case Dev: "dev"
            case Test: "test"
            case Prod: "prod"
            case Sdn: "sdn"

    static fn from_text(s: text) -> CompilerProfile:
        match s.lower():
            case "dev" | "development": CompilerProfile.Dev
            case "test" | "testing": CompilerProfile.Test
            case "prod" | "production" | "release": CompilerProfile.Prod
            case "sdn" | "data": CompilerProfile.Sdn
            case _: CompilerProfile.Dev

# ============================================================================
# Config (key-value bag)
# ============================================================================

struct Config:
    """Runtime configuration."""
    values: Dict<text, text>

    static fn default() -> Config:
        Config(values: {})

    fn get(self, key: text) -> text?:
        self.values.get(key)

    me set(self, key: text, value: text):
        self.values[key] = value

# ============================================================================
# CompilerConfig (unified config from all sources)
# ============================================================================

struct CompilerConfig:
    """Unified compiler configuration from .sdn, env vars, and CLI args.

    Precedence (highest first): CLI args > env vars > .sdn file > defaults.
    """
    profile: CompilerProfile
    log_level: i64
    type_inference: TypeInferenceConfig
    values: Dict<text, text>
    # Flags
    use_rust_types: bool      # --use-rust-types fallback
    use_rust_interp: bool     # --fast-interp Rust interpreter fallback
    use_rust_lexer: bool      # --fast-lex Rust lexer fallback
    deterministic: bool       # Deterministic mode (fixed seeds, sorted)
    coverage_enabled: bool

impl CompilerConfig:
    static fn default() -> CompilerConfig:
        CompilerConfig(
            profile: CompilerProfile.Dev,
            log_level: 0,
            type_inference: TypeInferenceConfig__default(),
            values: {},
            use_rust_types: false,
            use_rust_interp: false,
            use_rust_lexer: false,
            deterministic: false,
            coverage_enabled: false
        )

    static fn from_env() -> CompilerConfig:
        """Load config from environment variables."""
        var config = CompilerConfig__default()

        val profile_env = env_get("SIMPLE_PROFILE")
        if profile_env.?:
            config.profile = CompilerProfile__from_text(profile_env.unwrap())

        val log_env = env_get("SIMPLE_LOG")
        if log_env.?:
            config.log_level = match log_env.unwrap():
                case "trace": 20
                case "debug": 10
                case "info": 4
                case "warn": 2
                case "error": 1
                case _: 0

        val det_env = env_get("SIMPLE_DETERMINISTIC")
        if det_env.? and det_env.unwrap() == "1":
            config.deterministic = true

        val cov_env = env_get("SIMPLE_COVERAGE")
        if cov_env.? and cov_env.unwrap() == "1":
            config.coverage_enabled = true

        config

    me apply_cli_args(args: [text]):
        """Apply CLI arguments (highest precedence)."""
        var i = 0
        while i < args.len():
            val arg = args[i]
            match arg:
                case "--profile":
                    if i + 1 < args.len():
                        self.profile = CompilerProfile__from_text(args[i + 1])
                        i = i + 1
                case "--use-rust-types":
                    self.use_rust_types = true
                case "--fast-interp":
                    self.use_rust_interp = true
                case "--fast-lex":
                    self.use_rust_lexer = true
                case "--deterministic":
                    self.deterministic = true
                case "--coverage":
                    self.coverage_enabled = true
                case _:
                    # Check for --key=value form
                    if arg.starts_with("--") and arg.contains("="):
                        val parts: [text] = arg[2:].split("=")
                        if parts.len() >= 2:
                            self.values[parts[0]] = parts[1]
            i = i + 1

    me apply_sdn(content: text):
        """Apply config from SDN content (lowest precedence, only fills gaps)."""
        for line in content.split("\n"):
            val trimmed = line.trim()
            if trimmed.is_empty() or trimmed.starts_with("#"):
                continue
            val parts = trimmed.split(":")
            if parts.len() >= 2:
                val key = parts[0].trim()
                val value = parts[1].trim()
                if not self.values.contains(key):
                    self.values[key] = value

    fn logger() -> Logger:
        """Create a Logger matching this config."""
        Logger(level: self.log_level)

    fn get(key: text) -> text?:
        self.values.get(key)

class Logger:
    """Simple logger.

    Log levels:
      1 = Error, 2 = Warn, 4 = Info, 10 = Debug, 20 = Trace

    Controlled by SIMPLE_LOG env var:
      SIMPLE_LOG=debug  -> level 10
      SIMPLE_LOG=trace  -> level 20
      SIMPLE_LOG=info   -> level 4
      SIMPLE_LOG=warn   -> level 2
      SIMPLE_LOG=error  -> level 1
      (unset)           -> level 0 (silent)
    """
    level: i64

    static fn from_env() -> Logger:
        """Create logger with level from SIMPLE_LOG env var."""
        val env_val = env_get("SIMPLE_LOG")
        val level = if env_val.?:
            match env_val.unwrap():
                case "trace": 20
                case "debug": 10
                case "info": 4
                case "warn": 2
                case "error": 1
                case _: 0
        else:
            0
        Logger(level: level)

    fn log(level: i64, prefix: text, message: text):
        if level <= self.level:
            print "[{prefix}] {message}"

    fn trace(message: text):
        self.log(20, "TRACE", message)

    fn debug(message: text):
        self.log(10, "DEBUG", message)

    fn info(message: text):
        self.log(4, "INFO", message)

    fn warn(message: text):
        self.log(2, "WARN", message)

    fn error(message: text):
        self.log(1, "ERROR", message)

# ============================================================================
# Type Inference Configuration
# ============================================================================

"""Default element type identifiers.

These match the TypeId constants in the Rust compiler:
- VOID = 0
- I32 = 4
- I64 = 5
- F64 = 11
- STRING = 12
- ANY = 14
"""
enum TypeDefault:
    Void        # TypeId(0)
    Bool        # TypeId(1)
    I8          # TypeId(2)
    I16         # TypeId(3)
    I32         # TypeId(4)
    I64         # TypeId(5)
    U8          # TypeId(6)
    U16         # TypeId(7)
    U32         # TypeId(8)
    U64         # TypeId(9)
    F32         # TypeId(10)
    F64         # TypeId(11)
    String      # TypeId(12)
    Nil         # TypeId(13)
    Any         # TypeId(14)

impl TypeDefault:
    fn to_text() -> text:
        match self:
            case Void: "void"
            case Bool: "bool"
            case I8: "i8"
            case I16: "i16"
            case I32: "i32"
            case I64: "i64"
            case U8: "u8"
            case U16: "u16"
            case U32: "u32"
            case U64: "u64"
            case F32: "f32"
            case F64: "f64"
            case String: "text"
            case Nil: "nil"
            case Any: "any"
            case _: "unknown"

    static fn from_text(s: text) -> TypeDefault?:
        match s.lower():
            case "void" | "unit" | "()": Some(TypeDefault.Void)
            case "bool": Some(TypeDefault.Bool)
            case "i8": Some(TypeDefault.I8)
            case "i16": Some(TypeDefault.I16)
            case "i32" | "int": Some(TypeDefault.I32)
            case "i64" | "long": Some(TypeDefault.I64)
            case "u8" | "byte": Some(TypeDefault.U8)
            case "u16": Some(TypeDefault.U16)
            case "u32" | "uint": Some(TypeDefault.U32)
            case "u64" | "ulong": Some(TypeDefault.U64)
            case "f32" | "float": Some(TypeDefault.F32)
            case "f64" | "double": Some(TypeDefault.F64)
            case "text" | "string" | "str": Some(TypeDefault.String)
            case "nil" | "null" | "none": Some(TypeDefault.Nil)
            case "any" | "dynamic": Some(TypeDefault.Any)
            case _: nil

struct TypeInferenceConfig:
    """Configuration for type inference of empty collections.

    Configurable at:
    1. Project level via simple.sdn type_inference section
    2. Module level via type_defaults.sdn file
    """
    empty_array_default: TypeDefault
    empty_vector_default: TypeDefault
    empty_dict_key_default: TypeDefault
    empty_dict_value_default: TypeDefault
    strict_empty_collections: bool

impl TypeInferenceConfig:
    static fn default() -> TypeInferenceConfig:
        """Default configuration: i32 for arrays, f64 for vectors."""
        TypeInferenceConfig(
            empty_array_default: TypeDefault.I32,
            empty_vector_default: TypeDefault.F64,
            empty_dict_key_default: TypeDefault.String,
            empty_dict_value_default: TypeDefault.Any,
            strict_empty_collections: false
        )

    static fn strict() -> TypeInferenceConfig:
        """Strict mode: require explicit type annotations for empty collections."""
        TypeInferenceConfig(
            empty_array_default: TypeDefault.I32,
            empty_vector_default: TypeDefault.F64,
            empty_dict_key_default: TypeDefault.String,
            empty_dict_value_default: TypeDefault.Any,
            strict_empty_collections: true
        )

    static fn from_sdn(content: text) -> Result<TypeInferenceConfig, text>:
        """Parse type inference config from SDN content."""
        var config = TypeInferenceConfig__default()

        for line in content.split("\n"):
            val trimmed = line.trim()
            if trimmed.is_empty() or trimmed.starts_with("#") or trimmed.starts_with("|"):
                continue
            if trimmed.starts_with("type_inference"):
                continue

            # Parse "key, value" rows
            val parts = trimmed.split(",")
            if parts.len() >= 2:
                val key = parts[0].trim()
                val value = parts[1].trim()

                match key:
                    case "empty_array" | "empty_array_default":
                        val ty = TypeDefault__from_text(value)
                        if ty.?:
                            config.empty_array_default = ty.unwrap()
                    case "empty_vector" | "empty_vector_default":
                        val ty = TypeDefault__from_text(value)
                        if ty.?:
                            config.empty_vector_default = ty.unwrap()
                    case "empty_dict_key" | "empty_dict_key_default":
                        val ty = TypeDefault__from_text(value)
                        if ty.?:
                            config.empty_dict_key_default = ty.unwrap()
                    case "empty_dict_value" | "empty_dict_value_default":
                        val ty = TypeDefault__from_text(value)
                        if ty.?:
                            config.empty_dict_value_default = ty.unwrap()
                    case "strict" | "strict_empty_collections":
                        config.strict_empty_collections = value == "true"
                    case _:
                        pass  # Ignore unknown keys

        Ok(config)

    fn merge(module_config: TypeInferenceConfig) -> TypeInferenceConfig:
        """Merge module-level config over this config."""
        # Module config takes full precedence
        module_config

# ============================================================================
# Literal Configuration (used by unified registry in blocks layer)
# ============================================================================

struct LiteralDefinition:
    """Configuration for a collection literal type."""
    kind: text               # "array", "dict", "set", "sorted_set", etc.
    enabled: bool
    prefix: text             # e.g., "s", "arr", "sorted" (empty = no prefix)
    brackets: text           # e.g., "{}", "[]"
    backend_class: text?     # Optional: custom class (e.g., "SortedSet")

struct LiteralsConfig:
    """Configuration for all collection literal types."""
    array: LiteralDefinition
    dict: LiteralDefinition
    set: LiteralDefinition
    custom: Dict<text, LiteralDefinition>

export CompilerProfile, Config, CompilerConfig, Logger
export TypeDefault, TypeInferenceConfig
export LiteralDefinition, LiteralsConfig
