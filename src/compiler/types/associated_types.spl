"""
Associated Types - Consolidated from Phase 4A-4D

Unified module for associated type definitions, implementations,
type projection/resolution, and trait solver integration.

Phase 4A: AssocTypeDef, TraitDefEx, TraitRegistryEx
Phase 4B: AssocTypeImpl, ImplBlockEx, ImplValidator
Phase 4C: AssocTypeProjection, AssocTypeResolver
Phase 4D: Obligation, TraitSolverEx
"""


type Symbol = text

# ============================================================================
# Type System (Phase 4D version - most complete, includes TypeVar)
# ============================================================================

enum HirType:
    Int
    Str
    Bool
    Named(name: Symbol)
    Generic(name: Symbol, args: [HirType])
    Projection(base: HirType, assoc_name: Symbol)
    TypeVar(id: i64)  # For generics
    Error

impl HirType:
    fn to_string() -> text:
        match self:
            case Int: "i32"
            case Str: "String"
            case Bool: "bool"
            case Named(name): name
            case Generic(name, args):
                val args_str = if args.len() > 0: "<...>" else: ""
                "{name}{args_str}"
            case Projection(base, assoc_name):
                "{base.to_string()}.{assoc_name}"
            case TypeVar(id): "T{id}"
            case Error: "<error>"

    fn type_name() -> Symbol:
        match self:
            case Int: "i32"
            case Str: "String"
            case Bool: "bool"
            case Named(name): name
            case Generic(name, _): name
            case Projection(base, _): base.type_name()
            case TypeVar(id): "T{id}"
            case Error: "<error>"

    fn matches(other: HirType) -> bool:
        """Simplified type matching"""
        match (self, other):
            case (Int, Int): true
            case (Str, Str): true
            case (Bool, Bool): true
            case (Named(n1), Named(n2)): n1 == n2
            case (TypeVar(_), _): true
            case (_, TypeVar(_)): true
            case (Error, _): true
            case (_, Error): true
            case _: false

# ============================================================================
# Trait Reference (Phase 4D version - includes to_string)
# ============================================================================

class TraitRef:
    name: text

impl TraitRef:
    static fn new(name: Symbol) -> TraitRef:
        TraitRef(name: name)

    fn to_string() -> text:
        self.name

# ============================================================================
# Associated Type Definition (Phase 4A)
# ============================================================================

class AssocTypeDef:
    """
    Associated type definition in a trait

    Example:
        trait Iterator:
            type Item           # No bounds, no default
            type Error: Display # With bound
            type Index = i64    # With default
    """
    name: text
    bounds: text       # Placeholder for [TraitRef]
    default_type: text # Placeholder for Option<HirType>

impl AssocTypeDef:
    static fn new(name: Symbol) -> AssocTypeDef:
        AssocTypeDef(
            name: name,
            bounds: "[]",
            default_type: "None"
        )

    static fn with_bounds(name: Symbol, bounds: [TraitRef]) -> AssocTypeDef:
        val assoc_type = AssocTypeDef__new(name)
        val bounds_dict = {}
        for bound in bounds:
            bounds_dict[bound.name] = bound
        val new_assoc = AssocTypeDef(
            name: name,
            bounds: bounds_dict,
            default_type: "None"
        )
        new_assoc

    static fn with_default(name: Symbol, default_type: HirType) -> AssocTypeDef:
        val assoc_type = AssocTypeDef__new(name)
        val new_assoc = AssocTypeDef(
            name: name,
            bounds: "[]",
            default_type: default_type
        )
        new_assoc

    fn has_bounds() -> bool:
        self.bounds != "[]"

    fn has_default() -> bool:
        self.default_type != "None"

    fn to_string() -> text:
        var result = "type {self.name}"

        if self.has_bounds():
            result = "{result}: <bounds>"

        if self.has_default():
            result = "{result} = <default>"

        result

# ============================================================================
# Extended Trait Definition (Phase 4A)
# ============================================================================

class TraitDefEx:
    """
    Extended trait definition with associated types

    Example:
        trait Iterator:
            type Item           # Associated type
            fn next() -> Item?  # Method using associated type
    """
    name: text
    methods: text      # Placeholder for [MethodSig]
    supertraits: text  # Placeholder for [Symbol]
    assoc_types: text  # Dict<Symbol, AssocTypeDef>

impl TraitDefEx:
    static fn new(name: Symbol) -> TraitDefEx:
        TraitDefEx(
            name: name,
            methods: "[]",
            supertraits: "[]",
            assoc_types: {}
        )

    me add_assoc_type(assoc_type: AssocTypeDef):
        """Add an associated type to this trait"""
        self.assoc_types[assoc_type.name] = assoc_type

    fn has_assoc_type(name: Symbol) -> bool:
        """Check if trait has this associated type"""
        name in self.assoc_types

    fn get_assoc_type(name: Symbol) -> AssocTypeDef:
        """Get associated type by name (returns dummy if not found)"""
        if name in self.assoc_types:
            return self.assoc_types[name]

        # Return dummy
        AssocTypeDef__new("NotFound")

    fn assoc_type_count() -> i64:
        """Count associated types"""
        self.assoc_types.len()

    fn to_string() -> text:
        var result = "trait {self.name}"

        if self.assoc_type_count() > 0:
            result = "{result} (with {self.assoc_type_count()} assoc types)"

        result

# ============================================================================
# Extended Trait Registry (Phase 4A)
# ============================================================================

class TraitRegistryEx:
    """
    Extended trait registry supporting associated types
    """
    traits: text  # Dict<Symbol, TraitDefEx>

impl TraitRegistryEx:
    static fn new() -> TraitRegistryEx:
        val registry_data = {
            "traits": {}
        }
        TraitRegistryEx(traits: registry_data)

    me register_trait(trait_def: TraitDefEx) -> bool:
        """Register a trait definition"""
        val traits = self.traits["traits"]

        if trait_def.name in traits:
            return false  # Already registered

        traits[trait_def.name] = trait_def
        true

    fn get_trait(name: Symbol) -> TraitDefEx:
        """Get trait by name"""
        val traits = self.traits["traits"]

        if name in traits:
            return traits[name]

        # Return dummy
        TraitDefEx__new("NotFound")

    fn has_trait(name: Symbol) -> bool:
        """Check if trait exists"""
        val traits = self.traits["traits"]
        name in traits

    fn count_traits() -> i64:
        """Count registered traits"""
        val traits = self.traits["traits"]
        traits.len()

    me define_builtin_traits():
        """Define standard library traits with associated types"""

        # Iterator trait (with Item associated type)
        val iterator = TraitDefEx__new("Iterator")
        val item_type = AssocTypeDef__new("Item")
        iterator.add_assoc_type(item_type)
        self.register_trait(iterator)

        # Collection trait (with Item and Index)
        val collection = TraitDefEx__new("Collection")
        val coll_item = AssocTypeDef__new("Item")
        val index_type = AssocTypeDef__with_default("Index", HirType.Int)
        collection.add_assoc_type(coll_item)
        collection.add_assoc_type(index_type)
        self.register_trait(collection)

        # Result trait (with Ok and Err types)
        val result_trait = TraitDefEx__new("Result")
        val ok_type = AssocTypeDef__new("Ok")
        val err_type = AssocTypeDef__new("Err")
        result_trait.add_assoc_type(ok_type)
        result_trait.add_assoc_type(err_type)
        self.register_trait(result_trait)

        # Display trait (no associated types - for comparison)
        val display = TraitDefEx__new("Display")
        self.register_trait(display)

# ============================================================================
# Associated Type Implementation (Phase 4B)
# ============================================================================

class AssocTypeImpl:
    """
    Concrete implementation of an associated type

    Example:
        impl Iterator for Range:
            type Item = i64  # AssocTypeImpl
    """
    name: text
    concrete_type: text  # HirType

impl AssocTypeImpl:
    static fn new(name: Symbol, concrete_type: HirType) -> AssocTypeImpl:
        AssocTypeImpl(
            name: name,
            concrete_type: concrete_type
        )

    fn to_string() -> text:
        val type_str = self.concrete_type.to_string()
        "type {self.name} = {type_str}"

    fn get_type() -> HirType:
        self.concrete_type

# ============================================================================
# Extended Obligation (Phase 4D)
# ============================================================================

class Obligation:
    """
    Extended obligation with associated type constraints

    Examples:
        T: Iterator                    # Basic bound
        T: Iterator<Item=i64>          # With assoc type constraint
        I: Iterator, I.Item: Display   # Multiple constraints
    """
    ty: text                    # HirType
    trait_ref: text             # TraitRef
    span: text                  # Span (for errors)
    assoc_type_constraints: text  # Dict<Symbol, HirType>

impl Obligation:
    static fn new(ty: HirType, trait_ref: TraitRef) -> Obligation:
        Obligation(
            ty: ty,
            trait_ref: trait_ref,
            span: "unknown",
            assoc_type_constraints: {}
        )

    static fn with_assoc_constraint(
        ty: HirType,
        trait_ref: TraitRef,
        assoc_name: Symbol,
        assoc_type: HirType
    ) -> Obligation:
        """Create obligation with associated type constraint"""
        val obligation = Obligation__new(ty, trait_ref)
        val new_obligation = Obligation(
            ty: ty,
            trait_ref: trait_ref,
            span: "unknown",
            assoc_type_constraints: {assoc_name: assoc_type}
        )
        new_obligation

    me add_assoc_constraint(assoc_name: Symbol, assoc_type: HirType):
        """Add an associated type constraint"""
        self.assoc_type_constraints[assoc_name] = assoc_type

    fn has_assoc_constraints() -> bool:
        """Check if obligation has associated type constraints"""
        self.assoc_type_constraints.len() > 0

    fn to_string() -> text:
        val type_str = self.ty.to_string()
        val trait_str = self.trait_ref.name
        var result = "{type_str}: {trait_str}"

        if self.has_assoc_constraints():
            val constraints = self.assoc_type_constraints
            var constraint_strs = []

            for assoc_name in constraints:
                val assoc_type = constraints[assoc_name]
                val constraint_str = "{assoc_name}={assoc_type.to_string()}"
                constraint_strs.push(constraint_str)

            if constraint_strs.len() > 0:
                val joined = constraint_strs[0]
                result = "{result}<{joined}>"

        result

# ============================================================================
# Extended Impl Block (Phase 4D version - includes matches_obligation)
# ============================================================================

class ImplBlockEx:
    """
    Extended impl block with associated type implementations

    Example:
        impl Iterator for Range:
            type Item = i64           # Associated type impl
            fn next() -> i64?: ...    # Method impl
    """
    trait_ref: text      # TraitRef
    for_type: text       # HirType
    methods: text        # Dict<Symbol, MethodImpl>
    assoc_type_impls: text  # Dict<Symbol, AssocTypeImpl>

impl ImplBlockEx:
    static fn new(trait_ref: TraitRef, for_type: HirType) -> ImplBlockEx:
        ImplBlockEx(
            trait_ref: trait_ref,
            for_type: for_type,
            methods: {},
            assoc_type_impls: {}
        )

    me add_assoc_type_impl(name: Symbol, concrete_type: HirType):
        """Add an associated type implementation"""
        val assoc_impl = {
            "name": name,
            "type": concrete_type
        }
        self.assoc_type_impls[name] = assoc_impl

    fn get_assoc_type_impl(name: Symbol) -> HirType:
        """Get concrete type for associated type"""
        if name in self.assoc_type_impls:
            val assoc_impl = self.assoc_type_impls[name]
            return assoc_impl["type"]

        # Return error type if not found
        HirType.Error

    fn has_assoc_type_impl(name: Symbol) -> bool:
        """Check if associated type is implemented"""
        name in self.assoc_type_impls

    fn assoc_type_impl_count() -> i64:
        """Count associated type implementations"""
        self.assoc_type_impls.len()

    fn matches_type(ty: HirType) -> bool:
        """Check if this impl is for the given type"""
        self.for_type.matches(ty)

    fn matches_obligation(obligation: Obligation) -> bool:
        """Check if this impl satisfies obligation (including assoc type constraints)"""
        # Check trait matches
        if self.trait_ref.name != obligation.trait_ref.name:
            return false

        # Check type matches
        if not self.for_type.matches(obligation.ty):
            return false

        # Check associated type constraints
        val constraints = obligation.assoc_type_constraints
        for assoc_name in constraints:
            val expected_type = constraints[assoc_name]

            # Check if this impl has the associated type
            if not self.has_assoc_type_impl(assoc_name):
                return false

            # Check if types match
            val actual_type = self.get_assoc_type_impl(assoc_name)
            if not actual_type.matches(expected_type):
                return false

        true

    fn to_string() -> text:
        val trait_name = self.trait_ref.name
        val type_name = self.for_type.type_name()
        var result = "impl {trait_name} for {type_name}"

        if self.assoc_type_impl_count() > 0:
            result = "{result} ({self.assoc_type_impl_count()} assoc types)"

        result

# ============================================================================
# Extended Impl Registry (Combined lookup methods from 4B/4C/4D)
# ============================================================================

class ImplRegistryEx:
    """
    Extended impl registry supporting associated types
    """
    impls: text      # [ImplBlockEx]
    index: text      # Dict<"trait::type", ImplBlockEx>

impl ImplRegistryEx:
    static fn new() -> ImplRegistryEx:
        ImplRegistryEx(
            impls: [],
            index: {}
        )

    me register_impl(impl_block: ImplBlockEx) -> bool:
        """Register an impl block"""
        val trait_name = impl_block.trait_ref.name
        val type_name = impl_block.for_type.type_name()
        val key = "{trait_name}::{type_name}"

        # Check for duplicate
        if key in self.index:
            return false  # Conflict

        # Register
        self.impls.push(impl_block)
        self.index[key] = impl_block
        true

    # From Phase 4B: lookup by trait name + type name strings
    fn find_impl(trait_name: Symbol, type_name: Symbol) -> ImplBlockEx:
        """Find impl block for (trait, type) pair by name"""
        val key = "{trait_name}::{type_name}"

        if key in self.index:
            return self.index[key]

        # Return dummy impl
        val dummy_trait = TraitRef__new("NotFound")
        val dummy_type = HirType.Named(name: "NotFound")
        ImplBlockEx__new(dummy_trait, dummy_type)

    fn has_impl(trait_name: Symbol, type_name: Symbol) -> bool:
        """Check if impl exists by name"""
        val key = "{trait_name}::{type_name}"
        key in self.index

    # From Phase 4C: lookup by trait name + HirType
    fn find_impl_for_type(trait_name: Symbol, ty: HirType) -> ImplBlockEx:
        """Find impl block for (trait, type) pair"""
        val type_name = ty.type_name()
        val key = "{trait_name}::{type_name}"

        if key in self.index:
            return self.index[key]

        # Return dummy
        val dummy_trait = TraitRef__new("NotFound")
        val dummy_type = HirType.Named(name: "NotFound")
        ImplBlockEx__new(dummy_trait, dummy_type)

    # From Phase 4C: find all impls matching a type
    fn find_impls_for_type(ty: HirType) -> [ImplBlockEx]:
        """Find all impls for a given type"""
        var result = []

        for impl_block in self.impls:
            if impl_block.matches_type(ty):
                result.push(impl_block)

        result

    # From Phase 4D: find impls matching an obligation (with assoc type constraints)
    fn find_matching_impls(obligation: Obligation) -> [ImplBlockEx]:
        """Find all impls that could satisfy obligation (with assoc type constraints)"""
        var matches = []

        for impl_block in self.impls:
            if impl_block.matches_obligation(obligation):
                matches.push(impl_block)

        matches

    me define_builtin_impls():
        """Define standard library impls with associated types"""

        # impl Iterator for Range
        val range_iter = ImplBlockEx__new(
            TraitRef__new("Iterator"),
            HirType.Named(name: "Range")
        )
        range_iter.add_assoc_type_impl("Item", HirType.Int)
        self.register_impl(range_iter)

        # impl Iterator for Vec<T> (generic)
        val vec_t = HirType.Generic(name: "Vec", args: [HirType.Named(name: "T")])
        val vec_iter = ImplBlockEx__new(
            TraitRef__new("Iterator"),
            vec_t
        )
        vec_iter.add_assoc_type_impl("Item", HirType.Named(name: "T"))
        self.register_impl(vec_iter)

        # impl Collection for Vec<T>
        val vec_collection = ImplBlockEx__new(
            TraitRef__new("Collection"),
            vec_t
        )
        vec_collection.add_assoc_type_impl("Item", HirType.Named(name: "T"))
        vec_collection.add_assoc_type_impl("Index", HirType.Int)  # Uses default
        self.register_impl(vec_collection)

# ============================================================================
# Impl Validator (Phase 4B)
# ============================================================================

class ImplValidator:
    """
    Validates impl blocks with associated types
    """
    trait_def: text  # TraitDefEx

impl ImplValidator:
    static fn new(trait_def: TraitDefEx) -> ImplValidator:
        ImplValidator(trait_def: trait_def)

    fn validate_completeness(impl_block: ImplBlockEx) -> bool:
        """
        Check all required associated types are implemented

        Returns: true if complete, false if missing required types
        """
        val assoc_types = self.trait_def.assoc_types

        for assoc_name in assoc_types:
            val assoc_def = self.trait_def.get_assoc_type(assoc_name)

            # Skip if has default
            if assoc_def.has_default():
                pass

            # Check if implemented
            if not impl_block.has_assoc_type_impl(assoc_name):
                return false  # Missing required associated type

        true

    fn validate_bounds(impl_block: ImplBlockEx) -> bool:
        """
        Check associated type impls satisfy trait bounds

        Placeholder - always returns true for now
        """
        true

    fn find_missing_assoc_types(impl_block: ImplBlockEx) -> [Symbol]:
        """Find all missing required associated types"""
        var missing = []
        val assoc_types = self.trait_def.assoc_types

        for assoc_name in assoc_types:
            val assoc_def = self.trait_def.get_assoc_type(assoc_name)

            # Skip defaults
            if assoc_def.has_default():
                pass

            # Check if implemented
            if not impl_block.has_assoc_type_impl(assoc_name):
                missing.push(assoc_name)

        missing

# ============================================================================
# Type Projection (Phase 4C)
# ============================================================================

class AssocTypeProjection:
    """
    Represents an associated type projection: T.Item

    Example: In fn sum<I: Iterator>(iter: I) -> I.Item
             I.Item is an AssocTypeProjection
    """
    base_type: text     # HirType - the type being projected (I)
    assoc_name: text    # Symbol - the associated type name (Item)
    resolved: text      # Option<HirType> - cached resolution

impl AssocTypeProjection:
    static fn new(base_type: HirType, assoc_name: Symbol) -> AssocTypeProjection:
        AssocTypeProjection(
            base_type: base_type,
            assoc_name: assoc_name,
            resolved: "None"
        )

    fn to_string() -> text:
        "{self.base_type.to_string()}.{self.assoc_name}"

    fn is_resolved() -> bool:
        self.resolved != "None"

    fn get_resolved() -> HirType:
        if self.is_resolved():
            return self.resolved
        HirType.Error

    me set_resolved(ty: HirType):
        self.resolved = ty

# ============================================================================
# Associated Type Resolver (Phase 4C)
# ============================================================================

class AssocTypeResolver:
    """
    Core resolver for associated type projections

    Algorithm:
    1. For projection T.Item:
       - Find impl blocks for type T
       - Look up Item in each impl
       - Return concrete type

    2. Normalization:
       - Recursively reduce projections to concrete types
       - Handle nested projections (T.Assoc1.Assoc2)
    """
    impl_registry: text  # ImplRegistryEx
    cache: text          # Dict<projection_str, HirType>

impl AssocTypeResolver:
    static fn new(impl_registry: ImplRegistryEx) -> AssocTypeResolver:
        AssocTypeResolver(
            impl_registry: impl_registry,
            cache: {}
        )

    me resolve_projection(projection: AssocTypeProjection) -> HirType:
        """
        Resolve a projection to a concrete type

        Example:
            Given: Range.Item where impl Iterator for Range with Item = i64
            Returns: i64
        """
        # Check cache first
        val cache_key = projection.to_string()
        if cache_key in self.cache:
            return self.cache[cache_key]

        # 1. Get base type
        val base_type = projection.base_type

        # 2. Normalize base type first (in case it's also a projection)
        val normalized_base = self.normalize(base_type)

        # 3. Find impl blocks for normalized base type
        val impls = self.impl_registry.find_impls_for_type(normalized_base)

        # 4. Look up associated type in each impl
        for impl_block in impls:
            if impl_block.has_assoc_type_impl(projection.assoc_name):
                val concrete_type = impl_block.get_assoc_type_impl(projection.assoc_name)

                # Cache result
                self.cache[cache_key] = concrete_type

                # Set resolved on projection
                projection.set_resolved(concrete_type)

                return concrete_type

        # 5. Not found - return error
        HirType.Error

    me normalize(ty: HirType) -> HirType:
        """
        Normalize a type by reducing projections to concrete types

        Examples:
            Range.Item -> i64 (if impl Iterator for Range with Item = i64)
            Vec<Range.Item> -> Vec<i64>
        """
        match ty:
            case Projection(base, assoc_name):
                # Create projection object
                val projection = AssocTypeProjection__new(base, assoc_name)
                # Resolve it
                self.resolve_projection(projection)

            case Generic(name, args):
                # Normalize each type argument
                var normalized_args = []
                for arg in args:
                    val normalized_arg = self.normalize(arg)
                    normalized_args.push(normalized_arg)

                HirType.Generic(name: name, args: normalized_args)

            case _:
                # Already normalized
                ty

    fn find_impl_for_projection(projection: AssocTypeProjection) -> ImplBlockEx:
        """
        Find impl block that provides this projection

        Returns: impl block or dummy if not found
        """
        val base_type = projection.base_type
        val impls = self.impl_registry.find_impls_for_type(base_type)

        for impl_block in impls:
            if impl_block.has_assoc_type_impl(projection.assoc_name):
                return impl_block

        # Return dummy
        val dummy_trait = TraitRef__new("NotFound")
        val dummy_type = HirType.Named(name: "NotFound")
        ImplBlockEx__new(dummy_trait, dummy_type)

# ============================================================================
# Extended Trait Solver (Phase 4D)
# ============================================================================

class TraitSolverEx:
    """
    Extended trait solver handling associated type constraints
    """
    impl_registry: text  # ImplRegistryEx
    max_depth: i64

impl TraitSolverEx:
    static fn new(impl_registry: ImplRegistryEx) -> TraitSolverEx:
        TraitSolverEx(
            impl_registry: impl_registry,
            max_depth: 10
        )

    fn solve(obligation: Obligation) -> bool:
        """
        Solve obligation with associated type constraints

        Algorithm:
        1. Find matching impls for (trait, type)
        2. Check associated type constraints match
        3. Return true if satisfied
        """
        val matches = self.impl_registry.find_matching_impls(obligation)
        matches.len() > 0

    fn solve_all(obligations: [Obligation]) -> [Obligation]:
        """Solve multiple obligations"""
        var unsatisfied = []

        for obligation in obligations:
            if not self.solve(obligation):
                unsatisfied.push(obligation)

        unsatisfied

    fn can_satisfy(ty: HirType, trait_name: Symbol) -> bool:
        """Check if type can satisfy trait (without assoc constraints)"""
        val obligation = Obligation__new(ty, TraitRef__new(trait_name))
        self.solve(obligation)

    fn can_satisfy_with_assoc(
        ty: HirType,
        trait_name: Symbol,
        assoc_name: Symbol,
        assoc_type: HirType
    ) -> bool:
        """Check if type satisfies trait with associated type constraint"""
        val obligation = Obligation__with_assoc_constraint(
            ty,
            TraitRef__new(trait_name),
            assoc_name,
            assoc_type
        )
        self.solve(obligation)

# ============================================================================
# Test Setup Helpers
# ============================================================================

fn setup_test_registry() -> ImplRegistryEx:
    """Setup registry with test impls (from Phase 4C)"""
    val registry = ImplRegistryEx__new()

    # impl Iterator for Range with Item = i64
    val range_iter = ImplBlockEx__new(
        TraitRef__new("Iterator"),
        HirType.Named(name: "Range")
    )
    range_iter.add_assoc_type_impl("Item", HirType.Int)
    registry.register_impl(range_iter)

    # impl Iterator for Vec<T> with Item = T
    val vec_t = HirType.Generic(name: "Vec", args: [HirType.Named(name: "T")])
    val vec_iter = ImplBlockEx__new(
        TraitRef__new("Iterator"),
        vec_t
    )
    vec_iter.add_assoc_type_impl("Item", HirType.Named(name: "T"))
    registry.register_impl(vec_iter)

    # impl Collection for Vec<T> with Item = T, Index = i64
    val vec_coll = ImplBlockEx__new(
        TraitRef__new("Collection"),
        vec_t
    )
    vec_coll.add_assoc_type_impl("Item", HirType.Named(name: "T"))
    vec_coll.add_assoc_type_impl("Index", HirType.Int)
    registry.register_impl(vec_coll)

    registry

fn setup_registry() -> ImplRegistryEx:
    """Setup registry with test impls including String iterator (from Phase 4D)"""
    val registry = ImplRegistryEx__new()

    # impl Iterator for Range with Item = i64
    val range_iter = ImplBlockEx__new(
        TraitRef__new("Iterator"),
        HirType.Named(name: "Range")
    )
    range_iter.add_assoc_type_impl("Item", HirType.Int)
    registry.register_impl(range_iter)

    # impl Iterator for Vec<T> with Item = T
    val vec_t = HirType.Generic(name: "Vec", args: [HirType.Named(name: "T")])
    val vec_iter = ImplBlockEx__new(
        TraitRef__new("Iterator"),
        vec_t
    )
    vec_iter.add_assoc_type_impl("Item", HirType.Named(name: "T"))
    registry.register_impl(vec_iter)

    # impl Iterator for String with Item = String (different from T)
    val string_iter = ImplBlockEx__new(
        TraitRef__new("Iterator"),
        HirType.Str
    )
    string_iter.add_assoc_type_impl("Item", HirType.Str)
    registry.register_impl(string_iter)

    registry

# ============================================================================
# Phase 4A Tests (8 tests)
# ============================================================================

fn test_assoc_type_basic():
    """Test basic associated type definition"""
    val item_type = AssocTypeDef__new("Item")

    assert item_type.name == "Item", "Name is Item"
    assert not item_type.has_bounds(), "No bounds"
    assert not item_type.has_default(), "No default"
    assert item_type.to_string() == "type Item", "String representation"

    print "  pass: Basic associated type"

fn test_multiple_assoc_types():
    """Test trait with multiple associated types"""
    val trait_def = TraitDefEx__new("Collection")

    val item_type = AssocTypeDef__new("Item")
    val index_type = AssocTypeDef__new("Index")

    trait_def.add_assoc_type(item_type)
    trait_def.add_assoc_type(index_type)

    assert trait_def.assoc_type_count() == 2, "Two associated types"
    assert trait_def.has_assoc_type("Item"), "Has Item"
    assert trait_def.has_assoc_type("Index"), "Has Index"
    assert not trait_def.has_assoc_type("Unknown"), "No Unknown"

    print "  pass: Multiple associated types"

fn test_assoc_type_with_bounds():
    """Test associated type with trait bounds"""
    val display_ref = TraitRef__new("Display")
    val node_type = AssocTypeDef__with_bounds("Node", [display_ref])

    assert node_type.name == "Node", "Name is Node"
    assert node_type.has_bounds(), "Has bounds"
    assert not node_type.has_default(), "No default"

    print "  pass: Associated type with bounds"

fn test_default_assoc_type():
    """Test associated type with default"""
    val index_type = AssocTypeDef__with_default("Index", HirType.Int)

    assert index_type.name == "Index", "Name is Index"
    assert not index_type.has_bounds(), "No bounds"
    assert index_type.has_default(), "Has default"

    print "  pass: Default associated type"

fn test_builtin_iterator_trait():
    """Test built-in Iterator trait"""
    val registry = TraitRegistryEx__new()
    registry.define_builtin_traits()

    assert registry.has_trait("Iterator"), "Has Iterator trait"

    val iterator = registry.get_trait("Iterator")
    assert iterator.assoc_type_count() == 1, "Iterator has 1 assoc type"
    assert iterator.has_assoc_type("Item"), "Iterator has Item"

    val item = iterator.get_assoc_type("Item")
    assert item.name == "Item", "Item assoc type"

    print "  pass: Built-in Iterator trait"

fn test_trait_registry_ex():
    """Test extended trait registry"""
    val registry = TraitRegistryEx__new()

    assert registry.count_traits() == 0, "Empty initially"

    # Register Iterator trait
    val iterator = TraitDefEx__new("Iterator")
    val item = AssocTypeDef__new("Item")
    iterator.add_assoc_type(item)

    val registered = registry.register_trait(iterator)
    assert registered, "Registered"
    assert registry.count_traits() == 1, "One trait"

    # Lookup
    val found = registry.get_trait("Iterator")
    assert found.name == "Iterator", "Found Iterator"
    assert found.has_assoc_type("Item"), "Has Item"

    print "  pass: Extended trait registry"

fn test_projection_type():
    """Test projection type representation"""
    val base = HirType.Named(name: "T")
    val projection = HirType.Projection(base: base, assoc_name: "Item")

    assert projection.to_string() == "T.Item", "Projection string"
    assert projection.type_name() == "T", "Base type name"

    print "  pass: Projection type"

fn test_builtin_collection():
    """Test Collection trait with default Index"""
    val registry = TraitRegistryEx__new()
    registry.define_builtin_traits()

    val collection = registry.get_trait("Collection")
    assert collection.assoc_type_count() == 2, "Two assoc types"
    assert collection.has_assoc_type("Item"), "Has Item"
    assert collection.has_assoc_type("Index"), "Has Index"

    val index = collection.get_assoc_type("Index")
    assert index.has_default(), "Index has default"

    print "  pass: Collection with default Index"

# ============================================================================
# Phase 4B Tests (8 tests)
# ============================================================================

fn test_assoc_type_impl_basic():
    """Test basic associated type implementation"""
    val item_impl = AssocTypeImpl__new("Item", HirType.Int)

    assert item_impl.name == "Item", "Name is Item"
    assert item_impl.to_string() == "type Item = i32", "String representation"

    val concrete = item_impl.get_type()
    assert concrete.type_name() == "i32", "Concrete type is i32"

    print "  pass: Basic associated type impl"

fn test_multiple_assoc_type_impls():
    """Test impl block with multiple associated types"""
    val impl_block = ImplBlockEx__new(
        TraitRef__new("Collection"),
        HirType.Named(name: "Vec")
    )

    impl_block.add_assoc_type_impl("Item", HirType.Int)
    impl_block.add_assoc_type_impl("Index", HirType.Int)

    assert impl_block.assoc_type_impl_count() == 2, "Two assoc type impls"
    assert impl_block.has_assoc_type_impl("Item"), "Has Item"
    assert impl_block.has_assoc_type_impl("Index"), "Has Index"

    val item_type = impl_block.get_assoc_type_impl("Item")
    assert item_type.type_name() == "i32", "Item is i32"

    print "  pass: Multiple associated type impls"

fn test_missing_assoc_type():
    """Test validation catches missing associated type"""
    val trait_def = TraitDefEx__new("Iterator")
    val item_assoc = AssocTypeDef__new("Item")
    trait_def.add_assoc_type(item_assoc)

    val impl_block = ImplBlockEx__new(
        TraitRef__new("Iterator"),
        HirType.Named(name: "Range")
    )
    # Not adding Item implementation

    val validator = ImplValidator__new(trait_def)
    val is_complete = validator.validate_completeness(impl_block)

    assert not is_complete, "Incomplete - missing Item"

    val missing = validator.find_missing_assoc_types(impl_block)
    assert missing.len() == 1, "One missing type"

    print "  pass: Missing associated type detected"

fn test_assoc_type_bound_satisfied():
    """Test associated type bound satisfaction (placeholder)"""
    val trait_def = TraitDefEx__new("Graph")
    val node_assoc = AssocTypeDef__new("Node")
    trait_def.add_assoc_type(node_assoc)

    val impl_block = ImplBlockEx__new(
        TraitRef__new("Graph"),
        HirType.Named(name: "SimpleGraph")
    )
    impl_block.add_assoc_type_impl("Node", HirType.Int)

    val validator = ImplValidator__new(trait_def)
    val bounds_ok = validator.validate_bounds(impl_block)

    assert bounds_ok, "Bounds satisfied (placeholder)"

    print "  pass: Associated type bound satisfaction"

fn test_default_assoc_type_usage():
    """Test using default associated type"""
    val trait_def = TraitDefEx__new("Collection")
    val item_assoc = AssocTypeDef__new("Item")
    val index_assoc = AssocTypeDef__new("Index")
    # Mark index as having default
    val index_with_default = AssocTypeDef(
        name: "Index",
        bounds: "[]",
        default_type: HirType.Int
    )

    trait_def.add_assoc_type(item_assoc)
    trait_def.add_assoc_type(index_with_default)

    val impl_block = ImplBlockEx__new(
        TraitRef__new("Collection"),
        HirType.Named(name: "Vec")
    )
    impl_block.add_assoc_type_impl("Item", HirType.Int)
    # Not specifying Index - should use default

    val validator = ImplValidator__new(trait_def)
    val is_complete = validator.validate_completeness(impl_block)

    assert is_complete, "Complete - Index has default"

    print "  pass: Default associated type usage"

fn test_builtin_range_iterator():
    """Test built-in Range iterator impl"""
    val registry = ImplRegistryEx__new()
    registry.define_builtin_impls()

    assert registry.has_impl("Iterator", "Range"), "Has Iterator for Range"

    val range_iter = registry.find_impl("Iterator", "Range")
    assert range_iter.has_assoc_type_impl("Item"), "Range has Item"

    val item_type = range_iter.get_assoc_type_impl("Item")
    assert item_type.type_name() == "i32", "Item is i32"

    print "  pass: Built-in Range iterator"

fn test_impl_registry_ex():
    """Test extended impl registry"""
    val registry = ImplRegistryEx__new()

    # Register Iterator for Range
    val impl_block = ImplBlockEx__new(
        TraitRef__new("Iterator"),
        HirType.Named(name: "Range")
    )
    impl_block.add_assoc_type_impl("Item", HirType.Int)

    val registered = registry.register_impl(impl_block)
    assert registered, "Registered"

    # Lookup
    val found = registry.find_impl("Iterator", "Range")
    assert found.trait_ref.name == "Iterator", "Found Iterator"
    assert found.has_assoc_type_impl("Item"), "Has Item"

    print "  pass: Extended impl registry"

fn test_generic_impl():
    """Test impl for generic type"""
    val vec_t = HirType.Generic(name: "Vec", args: [HirType.Named(name: "T")])

    val impl_block = ImplBlockEx__new(
        TraitRef__new("Iterator"),
        vec_t
    )
    impl_block.add_assoc_type_impl("Item", HirType.Named(name: "T"))

    assert impl_block.to_string() == "impl Iterator for Vec (1 assoc types)", "String rep"
    assert impl_block.has_assoc_type_impl("Item"), "Has Item"

    val item = impl_block.get_assoc_type_impl("Item")
    assert item.type_name() == "T", "Item is T"

    print "  pass: Generic impl"

# ============================================================================
# Phase 4C Tests (7 tests)
# ============================================================================

fn test_projection_basic():
    """Test basic projection resolution"""
    val registry = setup_test_registry()
    val resolver = AssocTypeResolver__new(registry)

    # Range.Item -> i64
    val range_type = HirType.Named(name: "Range")
    val projection = AssocTypeProjection__new(range_type, "Item")

    val resolved = resolver.resolve_projection(projection)
    assert resolved.type_name() == "i32", "Range.Item resolves to i32"
    assert projection.is_resolved(), "Projection is marked resolved"

    print "  pass: Basic projection resolution"

fn test_nested_projection():
    """Test nested projections (T.Assoc1.Assoc2)"""
    val registry = setup_test_registry()
    val resolver = AssocTypeResolver__new(registry)

    # First level: Range.Item -> i64
    val range_item = HirType.Projection(
        base: HirType.Named(name: "Range"),
        assoc_name: "Item"
    )

    val normalized = resolver.normalize(range_item)
    assert normalized.type_name() == "i32", "Nested projection resolved"

    print "  pass: Nested projection"

fn test_projection_with_generic():
    """Test projection with generic base type"""
    val registry = setup_test_registry()
    val resolver = AssocTypeResolver__new(registry)

    # Vec<T>.Item -> T
    val vec_t = HirType.Generic(name: "Vec", args: [HirType.Named(name: "T")])
    val projection = AssocTypeProjection__new(vec_t, "Item")

    val resolved = resolver.resolve_projection(projection)
    assert resolved.type_name() == "T", "Vec<T>.Item resolves to T"

    print "  pass: Projection with generic base"

fn test_projection_normalization():
    """Test type normalization with projections"""
    val registry = setup_test_registry()
    val resolver = AssocTypeResolver__new(registry)

    # Normalize: Vec<Range.Item> -> Vec<i64>
    val range_item = HirType.Projection(
        base: HirType.Named(name: "Range"),
        assoc_name: "Item"
    )
    val vec_of_range_item = HirType.Generic(
        name: "Vec",
        args: [range_item]
    )

    val normalized = resolver.normalize(vec_of_range_item)
    assert normalized.type_name() == "Vec", "Normalized to Vec"

    print "  pass: Projection normalization"

fn test_projection_default():
    """Test projection with default type (placeholder)"""
    val registry = setup_test_registry()
    val resolver = AssocTypeResolver__new(registry)

    # Vec<T>.Index -> i64 (using default)
    val vec_t = HirType.Generic(name: "Vec", args: [HirType.Named(name: "T")])
    val projection = AssocTypeProjection__new(vec_t, "Index")

    val resolved = resolver.resolve_projection(projection)
    assert resolved.type_name() == "i32", "Vec<T>.Index resolves to i32 (default)"

    print "  pass: Projection with default"

fn test_projection_error():
    """Test projection resolution error (missing impl)"""
    val registry = setup_test_registry()
    val resolver = AssocTypeResolver__new(registry)

    # String.Item -> Error (no impl)
    val string_type = HirType.Str
    val projection = AssocTypeProjection__new(string_type, "Item")

    val resolved = resolver.resolve_projection(projection)
    assert resolved.type_name() == "<error>", "Missing impl returns Error"

    print "  pass: Projection error handling"

fn test_projection_caching():
    """Test projection resolution caching"""
    val registry = setup_test_registry()
    val resolver = AssocTypeResolver__new(registry)

    # Resolve Range.Item twice
    val range_type = HirType.Named(name: "Range")
    val projection1 = AssocTypeProjection__new(range_type, "Item")
    val projection2 = AssocTypeProjection__new(range_type, "Item")

    val resolved1 = resolver.resolve_projection(projection1)
    val resolved2 = resolver.resolve_projection(projection2)

    assert resolved1.type_name() == "i32", "First resolution"
    assert resolved2.type_name() == "i32", "Second resolution (from cache)"

    print "  pass: Projection caching"

# ============================================================================
# Phase 4D Tests (8 tests)
# ============================================================================

fn test_generic_with_assoc_return():
    """Test generic function with associated type in return"""
    val registry = setup_registry()
    val solver = TraitSolverEx__new(registry)

    # fn first<I: Iterator>(iter: I) -> I.Item
    # Check: Range: Iterator
    val range_type = HirType.Named(name: "Range")
    val can_use = solver.can_satisfy(range_type, "Iterator")

    assert can_use, "Range satisfies Iterator"

    print "  pass: Generic with assoc type return"

fn test_trait_bound_with_assoc_constraint():
    """Test trait bound with associated type constraint"""
    val registry = setup_registry()
    val solver = TraitSolverEx__new(registry)

    # fn process<I: Iterator<Item=i64>>(iter: I)
    # Check: Range: Iterator<Item=i64>
    val range_type = HirType.Named(name: "Range")
    val satisfies = solver.can_satisfy_with_assoc(
        range_type,
        "Iterator",
        "Item",
        HirType.Int
    )

    assert satisfies, "Range satisfies Iterator<Item=i64>"

    # Check: String: Iterator<Item=i64> (should fail)
    val string_type = HirType.Str
    val string_satisfies = solver.can_satisfy_with_assoc(
        string_type,
        "Iterator",
        "Item",
        HirType.Int
    )

    assert not string_satisfies, "String does NOT satisfy Iterator<Item=i64>"

    print "  pass: Trait bound with assoc constraint"

fn test_method_with_assoc_type():
    """Test method using associated types"""
    val registry = setup_registry()
    val solver = TraitSolverEx__new(registry)

    # trait Iterator:
    #     type Item
    #     fn next() -> Item?
    #     fn collect() -> [Item]

    # Check: Range implements Iterator
    val range_type = HirType.Named(name: "Range")
    assert solver.can_satisfy(range_type, "Iterator"), "Range: Iterator"

    # The return type would be: Range.Item which resolves to i64

    print "  pass: Method with associated type"

fn test_obligation_with_constraints():
    """Test obligation creation with constraints"""
    val ty = HirType.TypeVar(id: 0)
    val trait_ref = TraitRef__new("Iterator")
    val obligation = Obligation__with_assoc_constraint(
        ty,
        trait_ref,
        "Item",
        HirType.Int
    )

    assert obligation.has_assoc_constraints(), "Has constraints"
    assert obligation.to_string() == "T0: Iterator<Item=i32>", "String representation"

    print "  pass: Obligation with constraints"

fn test_multiple_constraints():
    """Test obligation with multiple associated type constraints"""
    val ty = HirType.TypeVar(id: 0)
    val trait_ref = TraitRef__new("Collection")
    val obligation = Obligation__new(ty, trait_ref)

    obligation.add_assoc_constraint("Item", HirType.Int)
    obligation.add_assoc_constraint("Index", HirType.Int)

    assert obligation.has_assoc_constraints(), "Has constraints"

    print "  pass: Multiple constraints"

fn test_solver_basic():
    """Test basic solving without constraints"""
    val registry = setup_registry()
    val solver = TraitSolverEx__new(registry)

    # Range: Iterator (without Item constraint)
    val range_type = HirType.Named(name: "Range")
    val obligation = Obligation__new(range_type, TraitRef__new("Iterator"))

    assert solver.solve(obligation), "Range: Iterator"

    print "  pass: Basic solving"

fn test_solver_with_constraints():
    """Test solving with associated type constraints"""
    val registry = setup_registry()
    val solver = TraitSolverEx__new(registry)

    # Range: Iterator<Item=i64> (should succeed)
    val range_type = HirType.Named(name: "Range")
    val obligation1 = Obligation__with_assoc_constraint(
        range_type,
        TraitRef__new("Iterator"),
        "Item",
        HirType.Int
    )

    assert solver.solve(obligation1), "Range: Iterator<Item=i64>"

    # Range: Iterator<Item=String> (should fail)
    val obligation2 = Obligation__with_assoc_constraint(
        range_type,
        TraitRef__new("Iterator"),
        "Item",
        HirType.Str
    )

    assert not solver.solve(obligation2), "Range NOT Iterator<Item=String>"

    print "  pass: Solver with constraints"

fn test_solve_multiple():
    """Test solving multiple obligations"""
    val registry = setup_registry()
    val solver = TraitSolverEx__new(registry)

    var obligations = []

    # Range: Iterator<Item=i64> (should pass)
    val ob1 = Obligation__with_assoc_constraint(
        HirType.Named(name: "Range"),
        TraitRef__new("Iterator"),
        "Item",
        HirType.Int
    )
    obligations.push(ob1)

    # String: Iterator<Item=String> (should pass)
    val ob2 = Obligation__with_assoc_constraint(
        HirType.Str,
        TraitRef__new("Iterator"),
        "Item",
        HirType.Str
    )
    obligations.push(ob2)

    # Bool: Iterator (should fail - no impl)
    val ob3 = Obligation__new(HirType.Bool, TraitRef__new("Iterator"))
    obligations.push(ob3)

    val unsatisfied = solver.solve_all(obligations)

    assert unsatisfied.len() == 1, "One unsatisfied"
    assert unsatisfied[0].ty.type_name() == "bool", "Bool unsatisfied"

    print "  pass: Solve multiple"

# ============================================================================
# Main - runs all 31 tests
# ============================================================================

fn main():
    print ""
    print "Associated Types - Consolidated Tests"
    print "======================================"

    print ""
    print "Phase 4A: Definitions"
    test_assoc_type_basic()
    test_multiple_assoc_types()
    test_assoc_type_with_bounds()
    test_default_assoc_type()
    test_builtin_iterator_trait()
    test_trait_registry_ex()
    test_projection_type()
    test_builtin_collection()

    print ""
    print "Phase 4B: Implementations"
    test_assoc_type_impl_basic()
    test_multiple_assoc_type_impls()
    test_missing_assoc_type()
    test_assoc_type_bound_satisfied()
    test_default_assoc_type_usage()
    test_builtin_range_iterator()
    test_impl_registry_ex()
    test_generic_impl()

    print ""
    print "Phase 4C: Projection & Resolution"
    test_projection_basic()
    test_nested_projection()
    test_projection_with_generic()
    test_projection_normalization()
    test_projection_default()
    test_projection_error()
    test_projection_caching()

    print ""
    print "Phase 4D: Integration & Bounds"
    test_generic_with_assoc_return()
    test_trait_bound_with_assoc_constraint()
    test_method_with_assoc_type()
    test_obligation_with_constraints()
    test_multiple_constraints()
    test_solver_basic()
    test_solver_with_constraints()
    test_solve_multiple()

    print ""
    print "All 31 tests passed."
    print ""


# Auto-generated desugared static method wrappers
fn AssocTypeDef__new(name: Symbol) -> AssocTypeDef:
    AssocTypeDef(
        name: name,
        bounds: "[]",
        default_type: "None"
    )


fn AssocTypeDef__with_bounds(name: Symbol, bounds: [TraitRef]) -> AssocTypeDef:
    val assoc_type = AssocTypeDef__new(name)
    val bounds_dict = {}
    for bound in bounds:
        bounds_dict[bound.name] = bound
    val new_assoc = AssocTypeDef(
        name: name,
        bounds: bounds_dict,
        default_type: "None"
    )
    new_assoc


fn AssocTypeDef__with_default(name: Symbol, default_type: HirType) -> AssocTypeDef:
    val assoc_type = AssocTypeDef__new(name)
    val new_assoc = AssocTypeDef(
        name: name,
        bounds: "[]",
        default_type: default_type
    )
    new_assoc


fn AssocTypeImpl__new(name: Symbol, concrete_type: HirType) -> AssocTypeImpl:
    AssocTypeImpl(
        name: name,
        concrete_type: concrete_type
    )


fn AssocTypeProjection__new(base_type: HirType, assoc_name: Symbol) -> AssocTypeProjection:
    AssocTypeProjection(
        base_type: base_type,
        assoc_name: assoc_name,
        resolved: "None"
    )


fn AssocTypeResolver__new(impl_registry: ImplRegistryEx) -> AssocTypeResolver:
    AssocTypeResolver(
        impl_registry: impl_registry,
        cache: {}
    )


fn ImplBlockEx__new(trait_ref: TraitRef, for_type: HirType) -> ImplBlockEx:
    ImplBlockEx(
        trait_ref: trait_ref,
        for_type: for_type,
        methods: {},
        assoc_type_impls: {}
    )


fn ImplRegistryEx__new() -> ImplRegistryEx:
    ImplRegistryEx(
        impls: [],
        index: {}
    )


fn ImplValidator__new(trait_def: TraitDefEx) -> ImplValidator:
    ImplValidator(trait_def: trait_def)


fn Obligation__new(ty: HirType, trait_ref: TraitRef) -> Obligation:
    Obligation(
        ty: ty,
        trait_ref: trait_ref,
        span: "unknown",
        assoc_type_constraints: {}
    )


fn TraitDefEx__new(name: Symbol) -> TraitDefEx:
    TraitDefEx(
        name: name,
        methods: "[]",
        supertraits: "[]",
        assoc_types: {}
    )


fn TraitRef__new(name: Symbol) -> TraitRef:
    TraitRef(name: name)


fn TraitRegistryEx__new() -> TraitRegistryEx:
    val registry_data = {
        "traits": {}
    }
    TraitRegistryEx(traits: registry_data)


fn TraitSolverEx__new(impl_registry: ImplRegistryEx) -> TraitSolverEx:
    TraitSolverEx(
        impl_registry: impl_registry,
        max_depth: 10
    )

