# SIMD Intrinsics - Consolidated from Phase 9A-9C
#
# Vector types, arithmetic operations, platform detection, and intrinsics.

type Symbol = text

# ============================================================================
# Vector Types
# ============================================================================

struct Vec2f:
    """2-element f32 vector (64-bit aligned)"""
    x: f32
    y: f32

impl Vec2f:
    static fn splat(value: f32) -> Vec2f:
        """Create vector with all elements set to value"""
        Vec2f(x: value, y: value)

    static fn from_array(arr: [f32]) -> Vec2f:
        """Create from array (must have 2+ elements)"""
        assert arr.len() >= 2, "Array must have at least 2 elements"
        Vec2f(x: arr[0], y: arr[1])

    static fn zero() -> Vec2f:
        """Zero vector"""
        Vec2f(x: 0.0, y: 0.0)

    fn to_array() -> [f32]:
        """Convert to array"""
        [self.x, self.y]

    fn get(index: i64) -> f32:
        """Get element by index"""
        match index:
            case 0: self.x
            case 1: self.y
            case _:
                assert false, "Index out of bounds: {index}"
                0.0  # Unreachable but needed for type checking

    fn set(index: i64, value: f32) -> Vec2f:
        """Set element by index (returns new vector)"""
        match index:
            case 0: Vec2f(x: value, y: self.y)
            case 1: Vec2f(x: self.x, y: value)
            case _:
                assert false, "Index out of bounds: {index}"
                self

    fn to_string() -> text:
        """String representation"""
        "Vec2f({self.x}, {self.y})"

struct Vec4f:
    """4-element f32 vector (128-bit SSE register)"""
    x: f32
    y: f32
    z: f32
    w: f32

impl Vec4f:
    # ========================================================================
    # Constructors
    # ========================================================================

    static fn splat(value: f32) -> Vec4f:
        """Create vector with all elements set to value"""
        Vec4f(x: value, y: value, z: value, w: value)

    static fn from_array(arr: [f32]) -> Vec4f:
        """Create from array (must have 4+ elements)"""
        assert arr.len() >= 4, "Array must have at least 4 elements"
        Vec4f(x: arr[0], y: arr[1], z: arr[2], w: arr[3])

    static fn zero() -> Vec4f:
        """Zero vector"""
        Vec4f(x: 0.0, y: 0.0, z: 0.0, w: 0.0)

    fn to_array() -> [f32]:
        """Convert to array"""
        [self.x, self.y, self.z, self.w]

    fn get(index: i64) -> f32:
        """Get element by index"""
        match index:
            case 0: self.x
            case 1: self.y
            case 2: self.z
            case 3: self.w
            case _:
                assert false, "Index out of bounds: {index}"
                0.0

    fn set(index: i64, value: f32) -> Vec4f:
        """Set element by index (returns new vector)"""
        match index:
            case 0: Vec4f(x: value, y: self.y, z: self.z, w: self.w)
            case 1: Vec4f(x: self.x, y: value, z: self.z, w: self.w)
            case 2: Vec4f(x: self.x, y: self.y, z: value, w: self.w)
            case 3: Vec4f(x: self.x, y: self.y, z: self.z, w: value)
            case _:
                assert false, "Index out of bounds: {index}"
                self

    fn to_string() -> text:
        """String representation"""
        "Vec4f({self.x}, {self.y}, {self.z}, {self.w})"

    # ========================================================================
    # Arithmetic Operations (SIMD-optimized)
    # ========================================================================

    fn add(other: Vec4f) -> Vec4f:
        """Vector addition (SIMD)"""
        Vec4f(
            x: self.x + other.x,
            y: self.y + other.y,
            z: self.z + other.z,
            w: self.w + other.w
        )

    fn sub(other: Vec4f) -> Vec4f:
        """Vector subtraction (SIMD)"""
        Vec4f(
            x: self.x - other.x,
            y: self.y - other.y,
            z: self.z - other.z,
            w: self.w - other.w
        )

    fn mul(other: Vec4f) -> Vec4f:
        """Element-wise multiplication (SIMD)"""
        Vec4f(
            x: self.x * other.x,
            y: self.y * other.y,
            z: self.z * other.z,
            w: self.w * other.w
        )

    fn div(other: Vec4f) -> Vec4f:
        """Element-wise division (SIMD)"""
        Vec4f(
            x: self.x / other.x,
            y: self.y / other.y,
            z: self.z / other.z,
            w: self.w / other.w
        )

    # ========================================================================
    # Scalar Operations
    # ========================================================================

    fn scale(scalar: f32) -> Vec4f:
        """Multiply by scalar"""
        Vec4f(
            x: self.x * scalar,
            y: self.y * scalar,
            z: self.z * scalar,
            w: self.w * scalar
        )

    fn scale_add(scalar: f32, offset: f32) -> Vec4f:
        """Multiply by scalar and add offset: v * scalar + offset"""
        Vec4f(
            x: self.x * scalar + offset,
            y: self.y * scalar + offset,
            z: self.z * scalar + offset,
            w: self.w * scalar + offset
        )

    # ========================================================================
    # Reductions (SIMD with horizontal ops)
    # ========================================================================

    fn sum() -> f32:
        """Sum all elements"""
        self.x + self.y + self.z + self.w

    fn product() -> f32:
        """Product of all elements"""
        self.x * self.y * self.z * self.w

    fn min_element() -> f32:
        """Minimum element"""
        val xy = if self.x < self.y: self.x else: self.y
        val zw = if self.z < self.w: self.z else: self.w
        if xy < zw: xy else: zw

    fn max_element() -> f32:
        """Maximum element"""
        val xy = if self.x > self.y: self.x else: self.y
        val zw = if self.z > self.w: self.z else: self.w
        if xy > zw: xy else: zw

    # ========================================================================
    # Dot Product and Length
    # ========================================================================

    fn dot(other: Vec4f) -> f32:
        """Dot product: sum of element-wise multiplication"""
        val prod = self.mul(other)
        prod.sum()

    fn length_squared() -> f32:
        """Squared length (avoids sqrt)"""
        self.dot(self)

    fn length() -> f32:
        """Vector length (magnitude)"""
        self.length_squared().sqrt()

    fn distance_squared(other: Vec4f) -> f32:
        """Squared distance to other vector"""
        val diff = self.sub(other)
        diff.length_squared()

    fn distance(other: Vec4f) -> f32:
        """Distance to other vector"""
        self.distance_squared(other).sqrt()

    fn normalize() -> Vec4f:
        """Normalized vector (unit length)"""
        val len = self.length()
        if len > 0.0:
            self.scale(1.0 / len)
        else:
            Vec4f__zero()

    # ========================================================================
    # Comparisons
    # ========================================================================

    fn equals(other: Vec4f) -> bool:
        """Element-wise equality (exact)"""
        (self.x == other.x and
        self.y == other.y and
        self.z == other.z and
        self.w == other.w)

    fn approx_equals(other: Vec4f, epsilon: f32) -> bool:
        """Element-wise approximate equality"""
        val diff = self.sub(other)
        val abs_x = if diff.x < 0.0: -diff.x else: diff.x
        val abs_y = if diff.y < 0.0: -diff.y else: diff.y
        val abs_z = if diff.z < 0.0: -diff.z else: diff.z
        val abs_w = if diff.w < 0.0: -diff.w else: diff.w

        abs_x < epsilon and abs_y < epsilon and abs_z < epsilon and abs_w < epsilon

    fn less_than(other: Vec4f) -> [bool]:
        """Element-wise less than"""
        [
            self.x < other.x,
            self.y < other.y,
            self.z < other.z,
            self.w < other.w
        ]

    fn less_than_or_equal(other: Vec4f) -> [bool]:
        """Element-wise less than or equal"""
        [
            self.x <= other.x,
            self.y <= other.y,
            self.z <= other.z,
            self.w <= other.w
        ]

    # ========================================================================
    # Min/Max Operations
    # ========================================================================

    fn min(other: Vec4f) -> Vec4f:
        """Element-wise minimum"""
        Vec4f(
            x: if self.x < other.x: self.x else: other.x,
            y: if self.y < other.y: self.y else: other.y,
            z: if self.z < other.z: self.z else: other.z,
            w: if self.w < other.w: self.w else: other.w
        )

    fn max(other: Vec4f) -> Vec4f:
        """Element-wise maximum"""
        Vec4f(
            x: if self.x > other.x: self.x else: other.x,
            y: if self.y > other.y: self.y else: other.y,
            z: if self.z > other.z: self.z else: other.z,
            w: if self.w > other.w: self.w else: other.w
        )

    fn clamp(min_val: Vec4f, max_val: Vec4f) -> Vec4f:
        """Clamp each element to [min, max]"""
        self.max(min_val).min(max_val)

    # ========================================================================
    # Utility Functions
    # ========================================================================

    fn abs() -> Vec4f:
        """Absolute value of each element"""
        Vec4f(
            x: if self.x < 0.0: -self.x else: self.x,
            y: if self.y < 0.0: -self.y else: self.y,
            z: if self.z < 0.0: -self.z else: self.z,
            w: if self.w < 0.0: -self.w else: self.w
        )

    fn negate() -> Vec4f:
        """Negate each element"""
        Vec4f(x: -self.x, y: -self.y, z: -self.z, w: -self.w)

    fn reciprocal() -> Vec4f:
        """Reciprocal of each element (1/x)"""
        Vec4f(
            x: 1.0 / self.x,
            y: 1.0 / self.y,
            z: 1.0 / self.z,
            w: 1.0 / self.w
        )

struct Vec8f:
    """8-element f32 vector (256-bit AVX register)"""
    e0: f32
    e1: f32
    e2: f32
    e3: f32
    e4: f32
    e5: f32
    e6: f32
    e7: f32

impl Vec8f:
    static fn splat(value: f32) -> Vec8f:
        """Create vector with all elements set to value"""
        Vec8f(
            e0: value, e1: value, e2: value, e3: value,
            e4: value, e5: value, e6: value, e7: value
        )

    static fn from_array(arr: [f32]) -> Vec8f:
        """Create from array (must have 8+ elements)"""
        assert arr.len() >= 8, "Array must have at least 8 elements"
        Vec8f(
            e0: arr[0], e1: arr[1], e2: arr[2], e3: arr[3],
            e4: arr[4], e5: arr[5], e6: arr[6], e7: arr[7]
        )

    static fn zero() -> Vec8f:
        """Zero vector"""
        Vec8f(
            e0: 0.0, e1: 0.0, e2: 0.0, e3: 0.0,
            e4: 0.0, e5: 0.0, e6: 0.0, e7: 0.0
        )

    fn to_array() -> [f32]:
        """Convert to array"""
        [self.e0, self.e1, self.e2, self.e3, self.e4, self.e5, self.e6, self.e7]

    fn get(index: i64) -> f32:
        """Get element by index"""
        match index:
            case 0: self.e0
            case 1: self.e1
            case 2: self.e2
            case 3: self.e3
            case 4: self.e4
            case 5: self.e5
            case 6: self.e6
            case 7: self.e7
            case _:
                assert false, "Index out of bounds: {index}"
                0.0

    fn set(index: i64, value: f32) -> Vec8f:
        """Set element by index (returns new vector)"""
        match index:
            case 0: Vec8f(e0: value, e1: self.e1, e2: self.e2, e3: self.e3, e4: self.e4, e5: self.e5, e6: self.e6, e7: self.e7)
            case 1: Vec8f(e0: self.e0, e1: value, e2: self.e2, e3: self.e3, e4: self.e4, e5: self.e5, e6: self.e6, e7: self.e7)
            case 2: Vec8f(e0: self.e0, e1: self.e1, e2: value, e3: self.e3, e4: self.e4, e5: self.e5, e6: self.e6, e7: self.e7)
            case 3: Vec8f(e0: self.e0, e1: self.e1, e2: self.e2, e3: value, e4: self.e4, e5: self.e5, e6: self.e6, e7: self.e7)
            case 4: Vec8f(e0: self.e0, e1: self.e1, e2: self.e2, e3: self.e3, e4: value, e5: self.e5, e6: self.e6, e7: self.e7)
            case 5: Vec8f(e0: self.e0, e1: self.e1, e2: self.e2, e3: self.e3, e4: self.e4, e5: value, e6: self.e6, e7: self.e7)
            case 6: Vec8f(e0: self.e0, e1: self.e1, e2: self.e2, e3: self.e3, e4: self.e4, e5: self.e5, e6: value, e7: self.e7)
            case 7: Vec8f(e0: self.e0, e1: self.e1, e2: self.e2, e3: self.e3, e4: self.e4, e5: self.e5, e6: self.e6, e7: value)
            case _:
                assert false, "Index out of bounds: {index}"
                self

    fn to_string() -> text:
        """String representation"""
        "Vec8f({self.e0}, {self.e1}, {self.e2}, {self.e3}, {self.e4}, {self.e5}, {self.e6}, {self.e7})"

struct Vec2d:
    """2-element f64 vector (128-bit aligned)"""
    x: f64
    y: f64

impl Vec2d:
    static fn splat(value: f64) -> Vec2d:
        """Create vector with all elements set to value"""
        Vec2d(x: value, y: value)

    static fn from_array(arr: [f64]) -> Vec2d:
        """Create from array (must have 2+ elements)"""
        assert arr.len() >= 2, "Array must have at least 2 elements"
        Vec2d(x: arr[0], y: arr[1])

    static fn zero() -> Vec2d:
        """Zero vector"""
        Vec2d(x: 0.0, y: 0.0)

    fn to_array() -> [f64]:
        """Convert to array"""
        [self.x, self.y]

    fn get(index: i64) -> f64:
        """Get element by index"""
        match index:
            case 0: self.x
            case 1: self.y
            case _:
                assert false, "Index out of bounds: {index}"
                0.0

    fn set(index: i64, value: f64) -> Vec2d:
        """Set element by index (returns new vector)"""
        match index:
            case 0: Vec2d(x: value, y: self.y)
            case 1: Vec2d(x: self.x, y: value)
            case _:
                assert false, "Index out of bounds: {index}"
                self

    fn to_string() -> text:
        """String representation"""
        "Vec2d({self.x}, {self.y})"

struct Vec4d:
    """4-element f64 vector (256-bit AVX register)"""
    x: f64
    y: f64
    z: f64
    w: f64

impl Vec4d:
    static fn splat(value: f64) -> Vec4d:
        """Create vector with all elements set to value"""
        Vec4d(x: value, y: value, z: value, w: value)

    static fn from_array(arr: [f64]) -> Vec4d:
        """Create from array (must have 4+ elements)"""
        assert arr.len() >= 4, "Array must have at least 4 elements"
        Vec4d(x: arr[0], y: arr[1], z: arr[2], w: arr[3])

    static fn zero() -> Vec4d:
        """Zero vector"""
        Vec4d(x: 0.0, y: 0.0, z: 0.0, w: 0.0)

    fn to_array() -> [f64]:
        """Convert to array"""
        [self.x, self.y, self.z, self.w]

    fn get(index: i64) -> f64:
        """Get element by index"""
        match index:
            case 0: self.x
            case 1: self.y
            case 2: self.z
            case 3: self.w
            case _:
                assert false, "Index out of bounds: {index}"
                0.0

    fn set(index: i64, value: f64) -> Vec4d:
        """Set element by index (returns new vector)"""
        match index:
            case 0: Vec4d(x: value, y: self.y, z: self.z, w: self.w)
            case 1: Vec4d(x: self.x, y: value, z: self.z, w: self.w)
            case 2: Vec4d(x: self.x, y: self.y, z: value, w: self.w)
            case 3: Vec4d(x: self.x, y: self.y, z: self.z, w: value)
            case _:
                assert false, "Index out of bounds: {index}"
                self

    fn to_string() -> text:
        """String representation"""
        "Vec4d({self.x}, {self.y}, {self.z}, {self.w})"

# ============================================================================
# SIMD Platform Detection
# ============================================================================

enum SimdPlatform:
    """SIMD instruction sets"""
    None_Platform  # No SIMD support (renamed to avoid keyword conflict)
    SSE           # x86 SSE (128-bit)
    SSE2          # x86 SSE2 (128-bit, doubles)
    AVX           # x86 AVX (256-bit)
    AVX2          # x86 AVX2 (256-bit, integers)
    AVX512        # x86 AVX-512 (512-bit)
    NEON          # ARM NEON (128-bit)
    SVE           # ARM SVE (variable length)

impl SimdPlatform:
    fn to_string() -> text:
        """String representation"""
        match self:
            case None_Platform: "None"
            case SSE: "SSE"
            case SSE2: "SSE2"
            case AVX: "AVX"
            case AVX2: "AVX2"
            case AVX512: "AVX-512"
            case NEON: "NEON"
            case SVE: "SVE"

    fn register_width() -> i64:
        """Get SIMD register width in bits"""
        match self:
            case SSE: 128
            case SSE2: 128
            case AVX: 256
            case AVX2: 256
            case AVX512: 512
            case NEON: 128
            case SVE: 0  # Variable length
            case None_Platform: 0

class SimdCapabilities:
    """
    Runtime SIMD capability detection

    Detects available SIMD instructions at runtime and provides
    optimal code path selection.
    """
    platform: SimdPlatform

impl SimdCapabilities:
    static fn detect() -> SimdCapabilities:
        """
        Detect available SIMD platform by parsing /proc/cpuinfo on Linux.

        Detection order (best to worst):
        1. AVX-512 (512-bit)
        2. AVX2 (256-bit, integers)
        3. AVX (256-bit)
        4. SSE2 (128-bit, doubles)
        5. SSE (128-bit)
        6. NEON (ARM, 128-bit)
        7. None_Platform (scalar fallback)

        Falls back to architecture-based heuristics if /proc/cpuinfo
        is not available.
        """
        # Try to detect platform via /proc/cpuinfo parsing
        var detected = _detect_from_cpuinfo()
        SimdCapabilities(platform: detected)

    static fn detect_x86() -> SimdPlatform:
        """
        Detect x86/x86_64 SIMD capabilities from /proc/cpuinfo flags.

        Checks for flags in order:
        - avx512f -> AVX-512
        - avx2 -> AVX2
        - avx -> AVX
        - sse2 -> SSE2
        - sse -> SSE
        """
        var flags = _read_cpuinfo_flags()
        if flags == "":
            # /proc/cpuinfo not available; x86_64 guarantees SSE2
            return SimdPlatform.SSE2

        # Check from highest to lowest capability
        var has_avx512 = _flags_contain(flags, "avx512f")
        if has_avx512:
            return SimdPlatform.AVX512

        var has_avx2 = _flags_contain(flags, "avx2")
        if has_avx2:
            return SimdPlatform.AVX2

        var has_avx = _flags_contain(flags, "avx")
        if has_avx:
            return SimdPlatform.AVX

        var has_sse2 = _flags_contain(flags, "sse2")
        if has_sse2:
            return SimdPlatform.SSE2

        var has_sse = _flags_contain(flags, "sse")
        if has_sse:
            return SimdPlatform.SSE

        # x86_64 always has SSE2
        SimdPlatform.SSE2

    static fn detect_arm() -> SimdPlatform:
        """
        Detect ARM SIMD capabilities from /proc/cpuinfo Features field.

        Checks:
        - sve flag -> SVE
        - asimd/neon flag -> NEON
        """
        var flags = _read_cpuinfo_flags()
        if flags == "":
            # AArch64 always has NEON (called ASIMD)
            return SimdPlatform.NEON

        var has_sve = _flags_contain(flags, "sve")
        if has_sve:
            return SimdPlatform.SVE

        var has_asimd = _flags_contain(flags, "asimd")
        if has_asimd:
            return SimdPlatform.NEON

        var has_neon = _flags_contain(flags, "neon")
        if has_neon:
            return SimdPlatform.NEON

        SimdPlatform.NEON

    fn has_sse() -> bool:
        """Check if SSE is available"""
        match self.platform:
            case SSE: true
            case SSE2: true  # SSE2 includes SSE
            case AVX: true
            case AVX2: true
            case AVX512: true
            case _: false

    fn has_sse2() -> bool:
        """Check if SSE2 is available"""
        match self.platform:
            case SSE2: true
            case AVX: true  # AVX includes SSE2
            case AVX2: true
            case AVX512: true
            case _: false

    fn has_avx() -> bool:
        """Check if AVX is available"""
        match self.platform:
            case AVX: true
            case AVX2: true  # AVX2 includes AVX
            case AVX512: true
            case _: false

    fn has_avx2() -> bool:
        """Check if AVX2 is available"""
        match self.platform:
            case AVX2: true
            case AVX512: true  # AVX-512 includes AVX2
            case _: false

    fn has_avx512() -> bool:
        """Check if AVX-512 is available"""
        match self.platform:
            case AVX512: true
            case _: false

    fn has_neon() -> bool:
        """Check if ARM NEON is available"""
        match self.platform:
            case NEON: true
            case SVE: true  # SVE includes NEON
            case _: false

    fn has_sve() -> bool:
        """Check if ARM SVE is available"""
        match self.platform:
            case SVE: true
            case _: false

    fn register_width() -> i64:
        """Get SIMD register width in bits"""
        self.platform.register_width()

    fn vector_width_f32() -> i64:
        """How many f32 values fit in SIMD register"""
        self.register_width() / 32

    fn vector_width_f64() -> i64:
        """How many f64 values fit in SIMD register"""
        self.register_width() / 64

    fn vector_width_i32() -> i64:
        """How many i32 values fit in SIMD register"""
        self.register_width() / 32

    fn vector_width_i64() -> i64:
        """How many i64 values fit in SIMD register"""
        self.register_width() / 64

    fn best_platform() -> SimdPlatform:
        """Get the best available platform"""
        self.platform

    fn to_string() -> text:
        """String representation"""
        "SimdCapabilities(platform: {self.platform.to_string()}, width: {self.register_width()}-bit)"

# ============================================================================
# SIMD Intrinsics (Placeholder)
# ============================================================================

class SimdIntrinsics:
    """
    SIMD intrinsics for low-level operations

    In a real implementation, these would be extern functions
    that map to LLVM intrinsics or inline assembly.

    For now, they're placeholders showing the API.
    """

impl SimdIntrinsics:
    # ========================================================================
    # SSE Intrinsics (128-bit, 4x f32)
    # ========================================================================

    static fn sse_add_ps(a: Vec4f, b: Vec4f) -> Vec4f:
        """SSE: Add 4x f32 (addps)"""
        # In real impl: __builtin_ia32_addps(a, b)
        a.add(b)

    static fn sse_sub_ps(a: Vec4f, b: Vec4f) -> Vec4f:
        """SSE: Subtract 4x f32 (subps)"""
        # In real impl: __builtin_ia32_subps(a, b)
        a.sub(b)

    static fn sse_mul_ps(a: Vec4f, b: Vec4f) -> Vec4f:
        """SSE: Multiply 4x f32 (mulps)"""
        # In real impl: __builtin_ia32_mulps(a, b)
        a.mul(b)

    static fn sse_div_ps(a: Vec4f, b: Vec4f) -> Vec4f:
        """SSE: Divide 4x f32 (divps)"""
        # In real impl: __builtin_ia32_divps(a, b)
        a.div(b)

    static fn sse_sqrt_ps(a: Vec4f) -> Vec4f:
        """SSE: Square root 4x f32 (sqrtps)"""
        # In real impl: __builtin_ia32_sqrtps(a)
        Vec4f(
            x: a.x.sqrt(),
            y: a.y.sqrt(),
            z: a.z.sqrt(),
            w: a.w.sqrt()
        )

    static fn sse_min_ps(a: Vec4f, b: Vec4f) -> Vec4f:
        """SSE: Minimum 4x f32 (minps)"""
        # In real impl: __builtin_ia32_minps(a, b)
        a.min(b)

    static fn sse_max_ps(a: Vec4f, b: Vec4f) -> Vec4f:
        """SSE: Maximum 4x f32 (maxps)"""
        # In real impl: __builtin_ia32_maxps(a, b)
        a.max(b)

    # ========================================================================
    # AVX Intrinsics (256-bit, 8x f32)
    # ========================================================================

    static fn avx_add_ps(a: Vec8f, b: Vec8f) -> Vec8f:
        """AVX: Add 8x f32 (vaddps)"""
        # In real impl: __builtin_ia32_addps256(a, b)
        Vec8f(
            e0: a.e0 + b.e0, e1: a.e1 + b.e1,
            e2: a.e2 + b.e2, e3: a.e3 + b.e3,
            e4: a.e4 + b.e4, e5: a.e5 + b.e5,
            e6: a.e6 + b.e6, e7: a.e7 + b.e7
        )

    static fn avx_sub_ps(a: Vec8f, b: Vec8f) -> Vec8f:
        """AVX: Subtract 8x f32 (vsubps)"""
        Vec8f(
            e0: a.e0 - b.e0, e1: a.e1 - b.e1,
            e2: a.e2 - b.e2, e3: a.e3 - b.e3,
            e4: a.e4 - b.e4, e5: a.e5 - b.e5,
            e6: a.e6 - b.e6, e7: a.e7 - b.e7
        )

    static fn avx_mul_ps(a: Vec8f, b: Vec8f) -> Vec8f:
        """AVX: Multiply 8x f32 (vmulps)"""
        Vec8f(
            e0: a.e0 * b.e0, e1: a.e1 * b.e1,
            e2: a.e2 * b.e2, e3: a.e3 * b.e3,
            e4: a.e4 * b.e4, e5: a.e5 * b.e5,
            e6: a.e6 * b.e6, e7: a.e7 * b.e7
        )

# ============================================================================
# Internal: /proc/cpuinfo Parsing
# ============================================================================

# SFFI binding for file reading (needed for /proc/cpuinfo)
extern fn rt_file_read_text(path: text) -> text

# Read CPU flags from /proc/cpuinfo.
# Returns a space-delimited string of flags, or "" if unavailable.
fn _read_cpuinfo_flags() -> text:
    # Read /proc/cpuinfo using SFFI
    var cpuinfo = rt_file_read_text("/proc/cpuinfo")
    if cpuinfo == "":
        return ""

    # Find the "flags" line (x86) or "Features" line (ARM)
    var lines = cpuinfo.split("\n")
    var i = 0
    while i < lines.len():
        var line = lines[i]
        var trimmed = line.trim()
        # x86: "flags		: sse sse2 avx avx2 ..."
        var is_flags_line = trimmed.starts_with("flags")
        if is_flags_line:
            var colon_pos = trimmed.index_of(":")
            if colon_pos >= 0:
                var flags_part = trimmed.substring(colon_pos + 1, trimmed.length())
                return flags_part.trim()
        # ARM: "Features	: fp asimd evtstrm ..."
        var is_features_line = trimmed.starts_with("Features")
        if is_features_line:
            var colon_pos = trimmed.index_of(":")
            if colon_pos >= 0:
                var features_part = trimmed.substring(colon_pos + 1, trimmed.length())
                return features_part.trim()
        i = i + 1

    ""

# Check if a space-delimited flags string contains the given flag
fn _flags_contain(flags: text, flag: text) -> bool:
    # Check for exact word match (surrounded by spaces or at start/end)
    var search = " " + flag + " "
    var padded = " " + flags + " "
    padded.contains(search)

# Detect SIMD platform from /proc/cpuinfo with architecture fallbacks
fn _detect_from_cpuinfo() -> SimdPlatform:
    var flags = _read_cpuinfo_flags()

    if flags != "":
        # Determine architecture from flags content
        var has_sse_flag = _flags_contain(flags, "sse")
        var has_asimd_flag = _flags_contain(flags, "asimd")
        var has_neon_flag = _flags_contain(flags, "neon")

        # x86 detection path
        if has_sse_flag:
            return SimdCapabilities__detect_x86()

        # ARM detection path
        var is_arm = has_asimd_flag or has_neon_flag
        if is_arm:
            return SimdCapabilities__detect_arm()

        # Check for SVE (ARM-only)
        var has_sve = _flags_contain(flags, "sve")
        if has_sve:
            return SimdPlatform.SVE

    # Fallback: use compile-time architecture knowledge
    # On modern x86_64 Linux, SSE2 is guaranteed
    SimdPlatform.SSE2

# ============================================================================
# Tests - Phase 9A: Vector Types
# ============================================================================

fn test_vec2f_create():
    """Test Vec2f creation"""
    val v = Vec2f(x: 1.0, y: 2.0)

    assert v.x == 1.0, "x is 1.0"
    assert v.y == 2.0, "y is 2.0"

    print "Vec2f creation passed"

fn test_vec2f_splat():
    """Test Vec2f splat constructor"""
    val v = Vec2f__splat(5.0)

    assert v.x == 5.0, "x is 5.0"
    assert v.y == 5.0, "y is 5.0"

    print "Vec2f splat passed"

fn test_vec2f_from_array():
    """Test Vec2f from_array"""
    val arr = [10.0, 20.0]
    val v = Vec2f__from_array(arr)

    assert v.x == 10.0, "x is 10.0"
    assert v.y == 20.0, "y is 20.0"

    print "Vec2f from_array passed"

fn test_vec2f_to_array():
    """Test Vec2f to_array"""
    val v = Vec2f(x: 3.0, y: 4.0)
    val arr = v.to_array()

    assert arr.len() == 2, "Array has 2 elements"
    assert arr[0] == 3.0, "First element is 3.0"
    assert arr[1] == 4.0, "Second element is 4.0"

    print "Vec2f to_array passed"

fn test_vec2f_get():
    """Test Vec2f element access"""
    val v = Vec2f(x: 7.0, y: 8.0)

    assert v.get(0) == 7.0, "Get x"
    assert v.get(1) == 8.0, "Get y"

    print "Vec2f get passed"

fn test_vec4f_create():
    """Test Vec4f creation"""
    val v = Vec4f(x: 1.0, y: 2.0, z: 3.0, w: 4.0)

    assert v.x == 1.0, "x is 1.0"
    assert v.y == 2.0, "y is 2.0"
    assert v.z == 3.0, "z is 3.0"
    assert v.w == 4.0, "w is 4.0"

    print "Vec4f creation passed"

fn test_vec4f_splat():
    """Test Vec4f splat constructor"""
    val v = Vec4f__splat(9.0)

    assert v.x == 9.0, "x is 9.0"
    assert v.y == 9.0, "y is 9.0"
    assert v.z == 9.0, "z is 9.0"
    assert v.w == 9.0, "w is 9.0"

    print "Vec4f splat passed"

fn test_vec4f_from_array():
    """Test Vec4f from_array"""
    val arr = [10.0, 20.0, 30.0, 40.0]
    val v = Vec4f__from_array(arr)

    assert v.x == 10.0, "x is 10.0"
    assert v.y == 20.0, "y is 20.0"
    assert v.z == 30.0, "z is 30.0"
    assert v.w == 40.0, "w is 40.0"

    print "Vec4f from_array passed"

fn test_vec4f_to_array():
    """Test Vec4f to_array"""
    val v = Vec4f(x: 1.0, y: 2.0, z: 3.0, w: 4.0)
    val arr = v.to_array()

    assert arr.len() == 4, "Array has 4 elements"
    assert arr[0] == 1.0, "First element"
    assert arr[1] == 2.0, "Second element"
    assert arr[2] == 3.0, "Third element"
    assert arr[3] == 4.0, "Fourth element"

    print "Vec4f to_array passed"

fn test_vec4f_get():
    """Test Vec4f element access"""
    val v = Vec4f(x: 5.0, y: 6.0, z: 7.0, w: 8.0)

    assert v.get(0) == 5.0, "Get x"
    assert v.get(1) == 6.0, "Get y"
    assert v.get(2) == 7.0, "Get z"
    assert v.get(3) == 8.0, "Get w"

    print "Vec4f get passed"

fn test_vec8f_create():
    """Test Vec8f creation"""
    val v = Vec8f(
        e0: 1.0, e1: 2.0, e2: 3.0, e3: 4.0,
        e4: 5.0, e5: 6.0, e6: 7.0, e7: 8.0
    )

    assert v.e0 == 1.0, "e0 is 1.0"
    assert v.e7 == 8.0, "e7 is 8.0"

    print "Vec8f creation passed"

fn test_vec8f_splat():
    """Test Vec8f splat constructor"""
    val v = Vec8f__splat(3.0)

    assert v.e0 == 3.0, "e0 is 3.0"
    assert v.e7 == 3.0, "e7 is 3.0"

    print "Vec8f splat passed"

fn test_vec8f_from_array():
    """Test Vec8f from_array"""
    val arr = [10.0, 20.0, 30.0, 40.0, 50.0, 60.0, 70.0, 80.0]
    val v = Vec8f__from_array(arr)

    assert v.e0 == 10.0, "e0 is 10.0"
    assert v.e7 == 80.0, "e7 is 80.0"

    print "Vec8f from_array passed"

fn test_vec8f_to_array():
    """Test Vec8f to_array"""
    val v = Vec8f(
        e0: 1.0, e1: 2.0, e2: 3.0, e3: 4.0,
        e4: 5.0, e5: 6.0, e6: 7.0, e7: 8.0
    )
    val arr = v.to_array()

    assert arr.len() == 8, "Array has 8 elements"
    assert arr[0] == 1.0, "First element"
    assert arr[7] == 8.0, "Last element"

    print "Vec8f to_array passed"

fn test_vec2d_create():
    """Test Vec2d creation"""
    val v = Vec2d(x: 1.5, y: 2.5)

    assert v.x == 1.5, "x is 1.5"
    assert v.y == 2.5, "y is 2.5"

    print "Vec2d creation passed"

fn test_vec4d_create():
    """Test Vec4d creation"""
    val v = Vec4d(x: 1.5, y: 2.5, z: 3.5, w: 4.5)

    assert v.x == 1.5, "x is 1.5"
    assert v.w == 4.5, "w is 4.5"

    print "Vec4d creation passed"

fn test_vec4f_zero():
    """Test Vec4f zero constructor"""
    val v = Vec4f__zero()

    assert v.x == 0.0, "x is 0.0"
    assert v.y == 0.0, "y is 0.0"
    assert v.z == 0.0, "z is 0.0"
    assert v.w == 0.0, "w is 0.0"

    print "Vec4f zero passed"

# ============================================================================
# Tests - Phase 9B: SIMD Operations
# ============================================================================

fn test_vec4f_add():
    """Test vector addition"""
    val v1 = Vec4f(x: 1.0, y: 2.0, z: 3.0, w: 4.0)
    val v2 = Vec4f(x: 5.0, y: 6.0, z: 7.0, w: 8.0)

    val result = v1.add(v2)

    assert result.x == 6.0, "x is 6.0"
    assert result.y == 8.0, "y is 8.0"
    assert result.z == 10.0, "z is 10.0"
    assert result.w == 12.0, "w is 12.0"

    print "Vector addition passed"

fn test_vec4f_sub():
    """Test vector subtraction"""
    val v1 = Vec4f(x: 10.0, y: 20.0, z: 30.0, w: 40.0)
    val v2 = Vec4f(x: 1.0, y: 2.0, z: 3.0, w: 4.0)

    val result = v1.sub(v2)

    assert result.x == 9.0, "x is 9.0"
    assert result.y == 18.0, "y is 18.0"
    assert result.z == 27.0, "z is 27.0"
    assert result.w == 36.0, "w is 36.0"

    print "Vector subtraction passed"

fn test_vec4f_mul():
    """Test element-wise multiplication"""
    val v1 = Vec4f(x: 2.0, y: 3.0, z: 4.0, w: 5.0)
    val v2 = Vec4f(x: 10.0, y: 10.0, z: 10.0, w: 10.0)

    val result = v1.mul(v2)

    assert result.x == 20.0, "x is 20.0"
    assert result.y == 30.0, "y is 30.0"
    assert result.z == 40.0, "z is 40.0"
    assert result.w == 50.0, "w is 50.0"

    print "Element-wise multiplication passed"

fn test_vec4f_div():
    """Test element-wise division"""
    val v1 = Vec4f(x: 20.0, y: 30.0, z: 40.0, w: 50.0)
    val v2 = Vec4f(x: 10.0, y: 10.0, z: 10.0, w: 10.0)

    val result = v1.div(v2)

    assert result.x == 2.0, "x is 2.0"
    assert result.y == 3.0, "y is 3.0"
    assert result.z == 4.0, "z is 4.0"
    assert result.w == 5.0, "w is 5.0"

    print "Element-wise division passed"

fn test_vec4f_scale():
    """Test scalar multiplication"""
    val v = Vec4f(x: 1.0, y: 2.0, z: 3.0, w: 4.0)

    val result = v.scale(2.0)

    assert result.x == 2.0, "x is 2.0"
    assert result.y == 4.0, "y is 4.0"
    assert result.z == 6.0, "z is 6.0"
    assert result.w == 8.0, "w is 8.0"

    print "Scalar multiplication passed"

fn test_vec4f_sum():
    """Test sum reduction"""
    val v = Vec4f(x: 1.0, y: 2.0, z: 3.0, w: 4.0)

    val result = v.sum()

    assert result == 10.0, "Sum is 10.0"

    print "Sum reduction passed"

fn test_vec4f_dot():
    """Test dot product"""
    val v1 = Vec4f(x: 1.0, y: 2.0, z: 3.0, w: 4.0)
    val v2 = Vec4f(x: 5.0, y: 6.0, z: 7.0, w: 8.0)

    val result = v1.dot(v2)

    # 1*5 + 2*6 + 3*7 + 4*8 = 5 + 12 + 21 + 32 = 70
    assert result == 70.0, "Dot product is 70.0"

    print "Dot product passed"

fn test_vec4f_length():
    """Test length calculation"""
    val v = Vec4f(x: 3.0, y: 4.0, z: 0.0, w: 0.0)

    val len_sq = v.length_squared()
    val len = v.length()

    assert len_sq == 25.0, "Squared length is 25.0"
    assert len == 5.0, "Length is 5.0"

    print "Length calculation passed"

fn test_vec4f_normalize():
    """Test normalization"""
    val v = Vec4f(x: 3.0, y: 4.0, z: 0.0, w: 0.0)

    val norm = v.normalize()
    val len = norm.length()

    # Normalized vector should have length 1.0
    val diff = if len > 1.0: len - 1.0 else: 1.0 - len
    assert diff < 0.001, "Normalized length is ~1.0"

    print "Normalization passed"

fn test_vec4f_distance():
    """Test distance calculation"""
    val v1 = Vec4f(x: 0.0, y: 0.0, z: 0.0, w: 0.0)
    val v2 = Vec4f(x: 3.0, y: 4.0, z: 0.0, w: 0.0)

    val dist = v1.distance(v2)

    assert dist == 5.0, "Distance is 5.0"

    print "Distance calculation passed"

fn test_vec4f_equals():
    """Test exact equality"""
    val v1 = Vec4f(x: 1.0, y: 2.0, z: 3.0, w: 4.0)
    val v2 = Vec4f(x: 1.0, y: 2.0, z: 3.0, w: 4.0)
    val v3 = Vec4f(x: 1.0, y: 2.0, z: 3.0, w: 5.0)

    assert v1.equals(v2), "Equal vectors"
    assert not v1.equals(v3), "Not equal vectors"

    print "Exact equality passed"

fn test_vec4f_less_than():
    """Test element-wise less than"""
    val v1 = Vec4f(x: 1.0, y: 2.0, z: 3.0, w: 4.0)
    val v2 = Vec4f(x: 2.0, y: 3.0, z: 2.0, w: 5.0)

    val result = v1.less_than(v2)

    assert result[0], "x: 1 < 2"
    assert result[1], "y: 2 < 3"
    assert not result[2], "z: 3 not < 2"
    assert result[3], "w: 4 < 5"

    print "Element-wise less than passed"

fn test_vec4f_min():
    """Test element-wise minimum"""
    val v1 = Vec4f(x: 1.0, y: 5.0, z: 3.0, w: 8.0)
    val v2 = Vec4f(x: 2.0, y: 4.0, z: 6.0, w: 7.0)

    val result = v1.min(v2)

    assert result.x == 1.0, "min(1, 2) = 1"
    assert result.y == 4.0, "min(5, 4) = 4"
    assert result.z == 3.0, "min(3, 6) = 3"
    assert result.w == 7.0, "min(8, 7) = 7"

    print "Element-wise minimum passed"

fn test_vec4f_max():
    """Test element-wise maximum"""
    val v1 = Vec4f(x: 1.0, y: 5.0, z: 3.0, w: 8.0)
    val v2 = Vec4f(x: 2.0, y: 4.0, z: 6.0, w: 7.0)

    val result = v1.max(v2)

    assert result.x == 2.0, "max(1, 2) = 2"
    assert result.y == 5.0, "max(5, 4) = 5"
    assert result.z == 6.0, "max(3, 6) = 6"
    assert result.w == 8.0, "max(8, 7) = 8"

    print "Element-wise maximum passed"

fn test_vec4f_abs():
    """Test absolute value"""
    val v = Vec4f(x: -1.0, y: 2.0, z: -3.0, w: 4.0)

    val result = v.abs()

    assert result.x == 1.0, "abs(-1) = 1"
    assert result.y == 2.0, "abs(2) = 2"
    assert result.z == 3.0, "abs(-3) = 3"
    assert result.w == 4.0, "abs(4) = 4"

    print "Absolute value passed"

fn test_vec4f_negate():
    """Test negation"""
    val v = Vec4f(x: 1.0, y: -2.0, z: 3.0, w: -4.0)

    val result = v.negate()

    assert result.x == -1.0, "-1 = -1"
    assert result.y == 2.0, "-(-2) = 2"
    assert result.z == -3.0, "-3 = -3"
    assert result.w == 4.0, "-(-4) = 4"

    print "Negation passed"

fn test_vec4f_min_element():
    """Test minimum element"""
    val v = Vec4f(x: 5.0, y: 2.0, z: 8.0, w: 3.0)

    val min_val = v.min_element()

    assert min_val == 2.0, "Minimum element is 2.0"

    print "Minimum element passed"

fn test_vec4f_max_element():
    """Test maximum element"""
    val v = Vec4f(x: 5.0, y: 2.0, z: 8.0, w: 3.0)

    val max_val = v.max_element()

    assert max_val == 8.0, "Maximum element is 8.0"

    print "Maximum element passed"

# ============================================================================
# Tests - Phase 9C: Platform Detection & Intrinsics
# ============================================================================

fn test_platform_detect():
    """Test platform detection"""
    val caps = SimdCapabilities__detect()

    # Detects real platform from /proc/cpuinfo or falls back to SSE2
    val platform = caps.best_platform()

    print "Platform detection: {platform.to_string()}"

fn test_has_sse():
    """Test SSE capability check"""
    val caps = SimdCapabilities__detect()

    val has_sse = caps.has_sse()

    print "SSE capability check: {has_sse}"

fn test_has_sse2():
    """Test SSE2 capability check"""
    val caps = SimdCapabilities__detect()

    val has_sse2 = caps.has_sse2()

    print "SSE2 capability check: {has_sse2}"

fn test_has_avx():
    """Test AVX capability check"""
    val caps = SimdCapabilities__detect()

    val has_avx = caps.has_avx()

    print "AVX capability check: {has_avx}"

fn test_register_width():
    """Test register width calculation"""
    val caps = SimdCapabilities__detect()

    val width = caps.register_width()

    # SSE2 has 128-bit registers
    assert width == 128, "SSE2 has 128-bit registers"

    print "Register width: {width}-bit"

fn test_vector_width_f32():
    """Test f32 vector width"""
    val caps = SimdCapabilities__detect()

    val width = caps.vector_width_f32()

    # 128-bit / 32-bit = 4 elements
    assert width == 4, "4 f32 values in SSE2 register"

    print "Vector width f32: {width} elements"

fn test_vector_width_f64():
    """Test f64 vector width"""
    val caps = SimdCapabilities__detect()

    val width = caps.vector_width_f64()

    # 128-bit / 64-bit = 2 elements
    assert width == 2, "2 f64 values in SSE2 register"

    print "Vector width f64: {width} elements"

fn test_sse_add():
    """Test SSE add intrinsic"""
    val v1 = Vec4f(x: 1.0, y: 2.0, z: 3.0, w: 4.0)
    val v2 = Vec4f(x: 5.0, y: 6.0, z: 7.0, w: 8.0)

    val result = SimdIntrinsics__sse_add_ps(v1, v2)

    assert result.x == 6.0, "x is 6.0"
    assert result.w == 12.0, "w is 12.0"

    print "SSE add intrinsic passed"

fn test_sse_sub():
    """Test SSE subtract intrinsic"""
    val v1 = Vec4f(x: 10.0, y: 20.0, z: 30.0, w: 40.0)
    val v2 = Vec4f(x: 1.0, y: 2.0, z: 3.0, w: 4.0)

    val result = SimdIntrinsics__sse_sub_ps(v1, v2)

    assert result.x == 9.0, "x is 9.0"
    assert result.w == 36.0, "w is 36.0"

    print "SSE subtract intrinsic passed"

fn test_sse_mul():
    """Test SSE multiply intrinsic"""
    val v1 = Vec4f(x: 2.0, y: 3.0, z: 4.0, w: 5.0)
    val v2 = Vec4f(x: 10.0, y: 10.0, z: 10.0, w: 10.0)

    val result = SimdIntrinsics__sse_mul_ps(v1, v2)

    assert result.x == 20.0, "x is 20.0"
    assert result.w == 50.0, "w is 50.0"

    print "SSE multiply intrinsic passed"

fn test_sse_min():
    """Test SSE minimum intrinsic"""
    val v1 = Vec4f(x: 1.0, y: 5.0, z: 3.0, w: 8.0)
    val v2 = Vec4f(x: 2.0, y: 4.0, z: 6.0, w: 7.0)

    val result = SimdIntrinsics__sse_min_ps(v1, v2)

    assert result.x == 1.0, "min(1, 2) = 1"
    assert result.y == 4.0, "min(5, 4) = 4"

    print "SSE minimum intrinsic passed"

fn test_sse_max():
    """Test SSE maximum intrinsic"""
    val v1 = Vec4f(x: 1.0, y: 5.0, z: 3.0, w: 8.0)
    val v2 = Vec4f(x: 2.0, y: 4.0, z: 6.0, w: 7.0)

    val result = SimdIntrinsics__sse_max_ps(v1, v2)

    assert result.x == 2.0, "max(1, 2) = 2"
    assert result.z == 6.0, "max(3, 6) = 6"

    print "SSE maximum intrinsic passed"

fn test_avx_add():
    """Test AVX add intrinsic"""
    val v1 = Vec8f(
        e0: 1.0, e1: 2.0, e2: 3.0, e3: 4.0,
        e4: 5.0, e5: 6.0, e6: 7.0, e7: 8.0
    )
    val v2 = Vec8f(
        e0: 10.0, e1: 10.0, e2: 10.0, e3: 10.0,
        e4: 10.0, e5: 10.0, e6: 10.0, e7: 10.0
    )

    val result = SimdIntrinsics__avx_add_ps(v1, v2)

    assert result.e0 == 11.0, "e0 is 11.0"
    assert result.e7 == 18.0, "e7 is 18.0"

    print "AVX add intrinsic passed"

fn test_platform_to_string():
    """Test platform string representation"""
    val sse = SimdPlatform.SSE
    val avx = SimdPlatform.AVX

    val sse_str = sse.to_string()
    val avx_str = avx.to_string()

    assert sse_str == "SSE", "SSE string"
    assert avx_str == "AVX", "AVX string"

    print "Platform to_string passed"

fn test_capabilities_to_string():
    """Test capabilities string representation"""
    val caps = SimdCapabilities__detect()

    val str_repr = caps.to_string()

    # Should contain "SimdCapabilities" and "128-bit" (for SSE2)
    assert "SimdCapabilities" in str_repr, "Contains 'SimdCapabilities'"
    assert "128" in str_repr, "Contains '128' (bit width)"

    print "Capabilities to_string passed"

# ============================================================================
# Main
# ============================================================================

fn main():
    print ""
    print "SIMD Intrinsics - Consolidated Tests"
    print "====================================="

    # Phase 9A: Vector Types
    print ""
    print "--- Phase 9A: Vector Types ---"
    test_vec2f_create()
    test_vec2f_splat()
    test_vec2f_from_array()
    test_vec2f_to_array()
    test_vec2f_get()
    test_vec4f_create()
    test_vec4f_splat()
    test_vec4f_from_array()
    test_vec4f_to_array()
    test_vec4f_get()
    test_vec8f_create()
    test_vec8f_splat()
    test_vec8f_from_array()
    test_vec8f_to_array()
    test_vec2d_create()
    test_vec4d_create()
    test_vec4f_zero()

    # Phase 9B: SIMD Operations
    print ""
    print "--- Phase 9B: SIMD Operations ---"
    test_vec4f_add()
    test_vec4f_sub()
    test_vec4f_mul()
    test_vec4f_div()
    test_vec4f_scale()
    test_vec4f_sum()
    test_vec4f_dot()
    test_vec4f_length()
    test_vec4f_normalize()
    test_vec4f_distance()
    test_vec4f_equals()
    test_vec4f_less_than()
    test_vec4f_min()
    test_vec4f_max()
    test_vec4f_abs()
    test_vec4f_negate()
    test_vec4f_min_element()
    test_vec4f_max_element()

    # Phase 9C: Platform Detection & Intrinsics
    print ""
    print "--- Phase 9C: Platform Detection & Intrinsics ---"
    test_platform_detect()
    test_has_sse()
    test_has_sse2()
    test_has_avx()
    test_register_width()
    test_vector_width_f32()
    test_vector_width_f64()
    test_sse_add()
    test_sse_sub()
    test_sse_mul()
    test_sse_min()
    test_sse_max()
    test_avx_add()
    test_platform_to_string()
    test_capabilities_to_string()

    print ""
    print "All SIMD tests complete (50 tests)"


# Auto-generated desugared static method wrappers
fn SimdCapabilities__detect() -> SimdCapabilities:
    """
    Detect available SIMD platform by parsing /proc/cpuinfo on Linux.

    Detection order (best to worst):
    1. AVX-512 (512-bit)
    2. AVX2 (256-bit, integers)
    3. AVX (256-bit)
    4. SSE2 (128-bit, doubles)
    5. SSE (128-bit)
    6. NEON (ARM, 128-bit)
    7. None_Platform (scalar fallback)

    Falls back to architecture-based heuristics if /proc/cpuinfo
    is not available.
    """
    # Try to detect platform via /proc/cpuinfo parsing
    var detected = _detect_from_cpuinfo()
    SimdCapabilities(platform: detected)


fn SimdCapabilities__detect_arm() -> SimdPlatform:
    """
    Detect ARM SIMD capabilities from /proc/cpuinfo Features field.

    Checks:
    - sve flag -> SVE
    - asimd/neon flag -> NEON
    """
    var flags = _read_cpuinfo_flags()
    if flags == "":
        # AArch64 always has NEON (called ASIMD)
        return SimdPlatform.NEON

    var has_sve = _flags_contain(flags, "sve")
    if has_sve:
        return SimdPlatform.SVE

    var has_asimd = _flags_contain(flags, "asimd")
    if has_asimd:
        return SimdPlatform.NEON

    var has_neon = _flags_contain(flags, "neon")
    if has_neon:
        return SimdPlatform.NEON

    SimdPlatform.NEON


fn SimdCapabilities__detect_x86() -> SimdPlatform:
    """
    Detect x86/x86_64 SIMD capabilities from /proc/cpuinfo flags.

    Checks for flags in order:
    - avx512f -> AVX-512
    - avx2 -> AVX2
    - avx -> AVX
    - sse2 -> SSE2
    - sse -> SSE
    """
    var flags = _read_cpuinfo_flags()
    if flags == "":
        # /proc/cpuinfo not available; x86_64 guarantees SSE2
        return SimdPlatform.SSE2

    # Check from highest to lowest capability
    var has_avx512 = _flags_contain(flags, "avx512f")
    if has_avx512:
        return SimdPlatform.AVX512

    var has_avx2 = _flags_contain(flags, "avx2")
    if has_avx2:
        return SimdPlatform.AVX2

    var has_avx = _flags_contain(flags, "avx")
    if has_avx:
        return SimdPlatform.AVX

    var has_sse2 = _flags_contain(flags, "sse2")
    if has_sse2:
        return SimdPlatform.SSE2

    var has_sse = _flags_contain(flags, "sse")
    if has_sse:
        return SimdPlatform.SSE

    # x86_64 always has SSE2
    SimdPlatform.SSE2


fn SimdIntrinsics__avx_add_ps(a: Vec8f, b: Vec8f) -> Vec8f:
    """AVX: Add 8x f32 (vaddps)"""
    # In real impl: __builtin_ia32_addps256(a, b)
    Vec8f(
        e0: a.e0 + b.e0, e1: a.e1 + b.e1,
        e2: a.e2 + b.e2, e3: a.e3 + b.e3,
        e4: a.e4 + b.e4, e5: a.e5 + b.e5,
        e6: a.e6 + b.e6, e7: a.e7 + b.e7
    )


fn SimdIntrinsics__sse_add_ps(a: Vec4f, b: Vec4f) -> Vec4f:
    """SSE: Add 4x f32 (addps)"""
    # In real impl: __builtin_ia32_addps(a, b)
    a.add(b)


fn SimdIntrinsics__sse_max_ps(a: Vec4f, b: Vec4f) -> Vec4f:
        """SSE: Maximum 4x f32 (maxps)"""
        # In real impl: __builtin_ia32_maxps(a, b)
        a.max(b)

    # ========================================================================
    # AVX Intrinsics (256-bit, 8x f32)
    # ========================================================================


fn SimdIntrinsics__sse_min_ps(a: Vec4f, b: Vec4f) -> Vec4f:
    """SSE: Minimum 4x f32 (minps)"""
    # In real impl: __builtin_ia32_minps(a, b)
    a.min(b)


fn SimdIntrinsics__sse_mul_ps(a: Vec4f, b: Vec4f) -> Vec4f:
    """SSE: Multiply 4x f32 (mulps)"""
    # In real impl: __builtin_ia32_mulps(a, b)
    a.mul(b)


fn SimdIntrinsics__sse_sub_ps(a: Vec4f, b: Vec4f) -> Vec4f:
    """SSE: Subtract 4x f32 (subps)"""
    # In real impl: __builtin_ia32_subps(a, b)
    a.sub(b)


fn Vec2f__from_array(arr: [f32]) -> Vec2f:
    """Create from array (must have 2+ elements)"""
    assert arr.len() >= 2, "Array must have at least 2 elements"
    Vec2f(x: arr[0], y: arr[1])


fn Vec2f__splat(value: f32) -> Vec2f:
    """Create vector with all elements set to value"""
    Vec2f(x: value, y: value)


fn Vec4f__from_array(arr: [f32]) -> Vec4f:
    """Create from array (must have 4+ elements)"""
    assert arr.len() >= 4, "Array must have at least 4 elements"
    Vec4f(x: arr[0], y: arr[1], z: arr[2], w: arr[3])


fn Vec4f__splat(value: f32) -> Vec4f:
    """Create vector with all elements set to value"""
    Vec4f(x: value, y: value, z: value, w: value)


fn Vec4f__zero() -> Vec4f:
    """Zero vector"""
    Vec4f(x: 0.0, y: 0.0, z: 0.0, w: 0.0)


fn Vec8f__from_array(arr: [f32]) -> Vec8f:
    """Create from array (must have 8+ elements)"""
    assert arr.len() >= 8, "Array must have at least 8 elements"
    Vec8f(
        e0: arr[0], e1: arr[1], e2: arr[2], e3: arr[3],
        e4: arr[4], e5: arr[5], e6: arr[6], e7: arr[7]
    )


fn Vec8f__splat(value: f32) -> Vec8f:
    """Create vector with all elements set to value"""
    Vec8f(
        e0: value, e1: value, e2: value, e3: value,
        e4: value, e5: value, e6: value, e7: value
    )

