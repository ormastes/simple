# Expression Type Inference - Calls, Lambdas, Control Flow, Collections
#
# Function calls, method calls, lambdas, control flow, collection literals,
# field/index access, and macro inference.
# Split from expr_infer.spl for maintainability.

use compiler.types.type_system.stmt_check.{bind_pattern}
use inference.types.{Type, TypeVarId, UnifyError, InferError}
use inference.infer.{InferenceEngine}
use ast.{Expr, MacroArg}
use compiler.types.type_system.checker.{TypeError}
use compiler.types.type_system.module_check.{ast_type_to_inference_type_engine}

# ============================================================================
# Function Calls
# ============================================================================

fn infer_call(engine: InferenceEngine, callee: Expr, args: [Argument],
              env: Dict<text, Type>) -> text:
    """Infer type of function call."""
    use compiler.types.type_system.expr_infer.{infer_expr}

    val callee_ty = infer_expr(engine, callee, env)?

    # Infer argument types
    var arg_types: [Type] = []
    for arg in args:
        val arg_ty = infer_expr(engine, arg.value, env)
        if arg_ty.is_err():
            return arg_ty
        arg_types = arg_types_push(arg_types, arg_ty)

    # Create result type variable
    val result_ty = engine_fresh_var(engine)

    # Check if callee is a function
    match engine_resolve(engine, callee_ty):
        case Function(params, ret):
            # Unify argument types with parameter types
            var i = 0
            while i < arg_types_len(arg_types) and i < params_len(params):
                engine_unify(engine, arg_types[i], params[i])?
                i = i + 1

            Ok(ret)

        case _:
            # Not a function type - return fresh var
            Ok(result_ty)

fn infer_method_call(engine: InferenceEngine, receiver: Expr, method: text,
                     args: [Argument], env: Dict<text, Type>) -> text:
    """Infer type of method call."""
    use compiler.types.type_system.expr_infer.{infer_expr}

    val receiver_ty = infer_expr(engine, receiver, env)?

    # Infer argument types
    for arg in args:
        val _unused_19 = infer_expr(engine, arg.value, env)?

    # Special handling for .with method (FString template instantiation)
    if method == "with":
        # Validate dict argument matches FString keys
        # If receiver is FString type, check that dict has matching keys
        match receiver_ty:
            case Generic(base, key_types) if base == "FString":
                # Verify dict argument has all required keys
                if args_len(args) >= 1:
                    val arg_ty = infer_expr(engine, args[0].value, env)?
                    # Dict type should be compatible with FString's key set
                    engine.unify(arg_ty, Type.Generic(base: "Dict", args: [Type.Str, Type.Str]))?
            case _:
                ()  # Non-FString .with() - no key validation
        return Ok(Type.Str)

    # General method call - return fresh var
    # Full implementation needs method lookup
    Ok(engine_fresh_var(engine))

# ============================================================================
# Lambdas
# ============================================================================

fn infer_lambda(engine: InferenceEngine, params: [LambdaParam], body: Expr,
                env: Dict<text, Type>) -> text:
    """Infer type of lambda expression."""
    use compiler.types.type_system.expr_infer.{infer_expr}

    # Create fresh variables for parameters
    var param_types: [Type] = []
    var new_env = env

    for param in params:
        val param_ty = if param.has_ty:
            ast_type_to_inference_type_engine(param.ty_value, engine)
        else:
            engine_fresh_var(engine)

        param_types = param_types_push(param_types, param_ty)
        new_env[param.name] = param_ty

    # Infer body type with extended environment
    val body_ty = infer_expr(engine, body, new_env)?

    # Construct function type
    Ok(type_Function(params: param_types, ret: body_ty))

# ============================================================================
# Control Flow
# ============================================================================

fn infer_if(engine: InferenceEngine, condition: Expr, then_branch: Expr,
            else_branch: Expr, env: Dict<text, Type>) -> text:
    """Infer type of if expression."""
    use compiler.types.type_system.expr_infer.{infer_expr}

    # Condition must be bool
    val cond_ty = infer_expr(engine, condition, env)?
    engine_unify(engine, cond_ty, Type.Bool)?

    # Infer then branch
    val then_ty = infer_expr(engine, then_branch, env)?

    # If there's an else branch, unify with then
    if has_else_branch:
        val else_ty = infer_expr(engine, else_branch_value, env)?
        engine_unify(engine, then_ty, else_ty)?
        Ok(engine_resolve(engine, then_ty))
    else:
        # No else branch - type is Unit
        Ok(Type.Unit)

fn infer_match(engine: InferenceEngine, subject: Expr, arms: [MatchArm],
               env: Dict<text, Type>) -> text:
    """Infer type of match expression."""
    use compiler.types.type_system.expr_infer.{infer_expr}

    # Infer subject type
    val subject_ty = infer_expr(engine, subject, env)?

    # Create result type variable
    val result_ty = engine_fresh_var(engine)

    # Check each arm
    for arm in arms:
        # Check pattern against subject type (Phase 3[2] - TODO #173)
        # Bind pattern variables (Phase 3[2] - TODO #174)
        val arm_env = bind_pattern(arm.pattern, subject_ty, env)

        # Infer arm body with extended environment
        val arm_ty = infer_expr(engine, arm.body, arm_env)?

        # Unify with result type
        engine_unify(engine, arm_ty, result_ty)?

    Ok(result_ty)

# ============================================================================
# Collections
# ============================================================================

fn infer_array(engine: InferenceEngine, elements: [Expr],
               env: Dict<text, Type>) -> text:
    """Infer type of array literal."""
    use compiler.types.type_system.expr_infer.{infer_expr}

    if not has_elements:
        # Empty array - element type unknown
        val elem_ty = engine_fresh_var(engine)
        return Ok(type_Array(elem: elem_ty, size: nil))

    # Infer first element type
    val first_ty = infer_expr(engine, elements[0], env)?

    # Unify all other elements with first
    var i = 1
    while i < elements_len(elements):
        val elem_ty = infer_expr(engine, elements[i], env)?
        engine_unify(engine, first_ty, elem_ty)?
        i = i + 1

    Ok(type_Array(elem: engine.resolve(first_ty), size: nil))

fn infer_tuple(engine: InferenceEngine, elements: [Expr],
               env: Dict<text, Type>) -> text:
    """Infer type of tuple literal."""
    use compiler.types.type_system.expr_infer.{infer_expr}

    var elem_types: [Type] = []

    for elem in elements:
        val elem_ty = infer_expr(engine, elem, env)
        if elem_ty.is_err():
            return elem_ty
        elem_types = elem_types_push(elem_types, elem_ty)

    Ok(type_Tuple(elements: elem_types))

fn infer_dict(engine: InferenceEngine, pairs: [(Expr, Expr)],
              env: Dict<text, Type>) -> text:
    """Infer type of dictionary literal."""
    use compiler.types.type_system.expr_infer.{infer_expr}

    if not has_pairs:
        # Empty dict - key and value types unknown
        val key_ty = engine_fresh_var(engine)
        val value_ty = engine_fresh_var(engine)
        return Ok(type_Dict(key: key_ty, value: value_ty))

    # Infer first pair types
    val _destruct_1 = pairs[0]
    val first_key = _destruct_1[0]
    val first_value = _destruct_1[1]
    val key_ty = infer_expr(engine, first_key, env)?
    val value_ty = infer_expr(engine, first_value, env)?

    # Unify all other pairs
    var i = 1
    while i < pairs_len(pairs):
        val _destruct_2 = pairs[i]
        val k = _destruct_2[0]
        val v = _destruct_2[1]
        val k_ty = infer_expr(engine, k, env)?
        val v_ty = infer_expr(engine, v, env)?
        engine_unify(engine, key_ty, k_ty)?
        engine_unify(engine, value_ty, v_ty)?
        i = i + 1

    Ok(type_Dict(key: engine.resolve(key_ty), value: engine_resolve(engine, value_ty)))

# ============================================================================
# Field and Index Access
# ============================================================================

fn infer_field_access(engine: InferenceEngine, receiver: Expr, field: text,
                      env: Dict<text, Type>) -> text:
    """Infer type of field access."""
    use compiler.types.type_system.expr_infer.{infer_expr}

    val receiver_ty = infer_expr(engine, receiver, env)?

    # Field type lookup needs struct/class definitions
    # For now, return fresh var
    Ok(engine_fresh_var(engine))

fn infer_index_access(engine: InferenceEngine, receiver: Expr, index: Expr,
                      env: Dict<text, Type>) -> text:
    """Infer type of index access."""
    use compiler.types.type_system.expr_infer.{infer_expr}

    val receiver_ty = infer_expr(engine, receiver, env)?
    val index_ty = infer_expr(engine, index, env)?

    # Index should be Int for arrays
    val unify_index = engine_unify(engine, index_ty, Type.Int(bits: 64, signed: true))
    if unify_index.is_err():
        return unify_index

    # Result type depends on receiver
    match engine_resolve(engine, receiver_ty):
        case Array(elem, _):
            Ok(elem)

        case Str:
            # String indexing returns string
            Ok(Type.Str)

        case Dict(key, value):
            # Dict indexing returns value type
            Ok(value)

        case Tuple(elems):
            # Tuple indexing - return fresh var (need literal index)
            Ok(engine_fresh_var(engine))

        case _:
            # Unknown type - return fresh var
            Ok(engine_fresh_var(engine))

# ============================================================================
# Macros
# ============================================================================

fn infer_macro(engine: InferenceEngine, name: text, args: [MacroArg],
               env: Dict<text, Type>) -> text:
    """Infer type of macro invocation."""
    use compiler.types.type_system.expr_infer.{infer_expr}

    # Infer argument types
    for arg in args:
        match arg:
            case Expr(e):
                val _unused_20 = infer_expr(engine, e, env)?

    # Macro return type depends on macro definition
    # For now, return fresh var
    Ok(engine_fresh_var(engine))

# ============================================================================
# Exports
# ============================================================================

export infer_call, infer_method_call
export infer_lambda, infer_if, infer_match
export infer_array, infer_tuple, infer_dict
export infer_field_access, infer_index_access, infer_macro
