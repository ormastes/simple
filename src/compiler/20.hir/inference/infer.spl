# Shared Inference Engine
#
# Used by compiler (compile-time), loader (load-time), and linker (link-time).
# Each context creates an InferenceEngine with its own environment,
# but the core algorithm is identical.

use compiler.inference.types.*
use compiler.inference.unify (Unifier)
use compiler.suffix_registry (SuffixRegistry, SuffixRegistry__new)

# ============================================================================
# Deferred Hint (for link-time resolution)
# ============================================================================

struct DeferredHint:
    """A hint about a deferred type for cross-module resolution.

    Written to SMF note.sdn section (InferenceHints, type 14).
    """
    type_var: TypeVarId
    constraints: [Constraint]
    source_module: text
    fallback: Type?

# ============================================================================
# InferenceEngine
# ============================================================================

class InferenceEngine:
    """Shared type inference engine.

    The same engine is used by:
    - Compiler: infers types at compile-time, emits DeferredHints for generics
    - Loader: resolves DeferredHints when loading modules at JIT time
    - Linker: resolves cross-module DeferredHints at link time
    """
    unifier: Unifier
    env: TypeEnv
    deferred: [DeferredHint]
    errors: [InferError]
    suffix_registry: SuffixRegistry

impl InferenceEngine:
    static fn create() -> InferenceEngine:
        InferenceEngine(
            unifier: Unifier.empty(),
            env: TypeEnv.empty(),
            deferred: [],
            errors: [],
            suffix_registry: SuffixRegistry__new()
        )

    me fresh_var() -> Type:
        """Create a fresh type variable."""
        self.unifier.fresh_var()

    me unify(t1: Type, t2: Type) -> Result<(), UnifyError>:
        """Unify two types."""
        self.unifier.unify(t1, t2)

    fn resolve(ty: Type) -> Type:
        """Resolve a type through substitutions."""
        self.unifier.apply(ty)

    me push_scope():
        self.env.push_scope()

    me pop_scope():
        self.env.pop_scope()

    me bind(name: text, ty: Type):
        """Bind a name to a monomorphic type."""
        self.env.bind(name, ty)

    me bind_scheme(name: text, scheme: TypeScheme):
        """Bind a name to a polymorphic type scheme."""
        self.env.bind_scheme(name, scheme)

    fn lookup(name: text) -> TypeScheme?:
        """Look up a name in the environment."""
        self.env.lookup(name)

    fn resolve_suffix(suffix: text) -> Type?:
        """Resolve a unit suffix to its named type."""
        val entry = self.suffix_registry.resolve(suffix)
        if entry.?:
            Some(Type.Named(entry.type_name))
        else:
            nil

    me instantiate(scheme: TypeScheme) -> Type:
        """Instantiate a polymorphic scheme with fresh variables."""
        if scheme.is_mono():
            return scheme.ty

        var subst: Dict<i64, Type> = {}
        for var_id in scheme.vars:
            subst[var_id.id] = self.unifier.fresh_var()

        self.substitute_type(scheme.ty, subst)

    fn substitute_type(ty: Type, subst: Dict<i64, Type>) -> Type:
        """Apply a variable substitution to a type."""
        match ty:
            case Var(id):
                if subst.contains(id.id):
                    subst[id.id]
                else:
                    ty
            case Function(params, ret):
                Type.Function(
                    params: params.map(\p: self.substitute_type(p, subst)),
                    ret: self.substitute_type(ret, subst)
                )
            case Array(elem, size):
                Type.Array(elem: self.substitute_type(elem, subst), size: size)
            case Tuple(elems):
                Type.Tuple(elements: elems.map(\e: self.substitute_type(e, subst)))
            case Optional(inner):
                Type.Optional(inner: self.substitute_type(inner, subst))
            case Generic(name, args):
                Type.Generic(base: name, args: args.map(\a: self.substitute_type(a, subst)))
            case _: ty

    me generalize(ty: Type) -> TypeScheme:
        """Generalize a type into a polymorphic scheme.

        Collects all free type variables not bound in the environment.
        """
        val resolved = self.resolve(ty)
        val free_vars = self.free_vars(resolved)
        if free_vars.is_empty():
            TypeScheme.mono(resolved)
        else:
            TypeScheme.poly(free_vars, resolved)

    fn free_vars(ty: Type) -> [TypeVarId]:
        """Collect free type variables in a type."""
        match ty:
            case Var(id):
                if self.unifier.substitutions.contains(id.id):
                    self.free_vars(self.unifier.resolve(ty))
                else:
                    [id]
            case Function(params, ret):
                var result: [TypeVarId] = []
                for p in params:
                    result = result.merge(self.free_vars(p))
                result.merge(self.free_vars(ret))
            case Array(elem, _): self.free_vars(elem)
            case Tuple(elems):
                var result: [TypeVarId] = []
                for e in elems:
                    result = result.merge(self.free_vars(e))
                result
            case Optional(inner): self.free_vars(inner)
            case Generic(_, args):
                var result: [TypeVarId] = []
                for a in args:
                    result = result.merge(self.free_vars(a))
                result
            case _: []

    # ========================================================================
    # Deferred Hints (for cross-module/link-time inference)
    # ========================================================================

    me add_deferred(type_var: TypeVarId, constraints: [Constraint], source: text, fallback: Type?):
        """Record a deferred type for later resolution."""
        self.deferred = self.deferred.push(DeferredHint(
            type_var: type_var,
            constraints: constraints,
            source_module: source,
            fallback: fallback
        ))

    fn pending_deferred() -> [DeferredHint]:
        """Get all unresolved deferred hints."""
        self.deferred.filter(\h:
            match self.unifier.resolve(Type.Var(id: h.type_var)):
                case Var(_): true  # Still unresolved
                case _: false
        )

    me resolve_deferred(hint: DeferredHint, ty: Type) -> Result<(), UnifyError>:
        """Resolve a deferred hint with a concrete type."""
        self.unifier.unify(Type.Var(id: hint.type_var), ty)

    # ========================================================================
    # Error Recovery
    # ========================================================================

    me try_unify(t1: Type, t2: Type) -> bool:
        """Try to unify, recording error on failure but continuing.
        Returns true if unification succeeded."""
        val result = self.unifier.unify(t1, t2)
        match result:
            case Ok(_): true
            case Err(e):
                self.errors = self.errors.push(InferError.UnifyError(e))
                false

    me add_error(error: InferError):
        """Record an inference error (continue checking after errors)."""
        self.errors = self.errors.push(error)

    fn has_errors() -> bool:
        self.errors.?

    fn get_errors() -> [InferError]:
        self.errors

    # ========================================================================
    # Type Display (for error messages)
    # ========================================================================

    fn type_to_text(ty: Type) -> text:
        """Convert type to human-readable string."""
        val resolved = self.resolve(ty)
        match resolved:
            case Int(bits, signed):
                if signed: "i{bits}" else: "u{bits}"
            case Float(bits): "f{bits}"
            case Bool: "bool"
            case Str: "text"
            case Nil: "nil"
            case Unit: "()"
            case Var(id): "?{id.id}"
            case Skolem(id): "'{id.id}"
            case Function(params, ret):
                val param_strs = params.map(\p: self.type_to_text(p))
                "fn({param_strs.join(", ")}) -> {self.type_to_text(ret)}"
            case Array(elem, _): "[{self.type_to_text(elem)}]"
            case Tuple(elems):
                val elem_strs = elems.map(\e: self.type_to_text(e))
                "({elem_strs.join(", ")})"
            case Optional(inner): "{self.type_to_text(inner)}?"
            case Result(ok, err): "Result<{self.type_to_text(ok)}, {self.type_to_text(err)}>"
            case Named(name): name
            case Generic(base, args):
                val arg_strs = args.map(\a: self.type_to_text(a))
                "{base}<{arg_strs.join(", ")}>"
            case TypeParam(name): name
            case Dict(key, value): "Dict<{self.type_to_text(key)}, {self.type_to_text(value)}>"
            case Borrow(inner): "&{self.type_to_text(inner)}"
            case BorrowMut(inner): "&mut {self.type_to_text(inner)}"
            case DynTrait(name): "dyn {name}"
            case Simd(lanes, elem): "Simd<{lanes}, {self.type_to_text(elem)}>"
            case _: "?"

export InferenceEngine, DeferredHint
