# Deferred Type Hints for Link-Time Inference
#
# When the compiler encounters a generic that can't be fully resolved
# at compile-time, it emits a DeferredHint. The loader and linker
# use these hints to instantiate generics at load/link time.

use compiler.hir.inference.types.*
use compiler.hir.inference.infer (DeferredHint)

# ============================================================================
# Deferred Hint Store
# ============================================================================

class DeferredStore:
    """Stores deferred hints from multiple modules for link-time resolution."""
    hints: [DeferredHint]
    resolved: Dict<i64, Type>

impl DeferredStore:
    static fn empty() -> DeferredStore:
        DeferredStore(hints: [], resolved: {})

    me add_hint(hint: DeferredHint):
        """Add a deferred hint from a module."""
        self.hints = self.hints.push(hint)

    me add_hints(hints: [DeferredHint]):
        """Add multiple hints (e.g., from loading a module's note.sdn)."""
        for hint in hints:
            self.hints = self.hints.push(hint)

    me mark_resolved(type_var: TypeVarId, ty: Type):
        """Mark a deferred type as resolved."""
        self.resolved[type_var.id] = ty

    fn is_resolved(type_var: TypeVarId) -> bool:
        self.resolved.contains(type_var.id)

    fn get_resolved(type_var: TypeVarId) -> Type?:
        if self.resolved.contains(type_var.id):
            Some(self.resolved[type_var.id])
        else:
            nil

    fn unresolved() -> [DeferredHint]:
        """Get all hints that haven't been resolved yet."""
        var result: [DeferredHint] = []
        for h in self.hints:
            if not self.is_resolved(h.type_var):
                result = result.push(h)
        result

    fn unresolved_for_module(module: text) -> [DeferredHint]:
        """Get unresolved hints from a specific module."""
        var result: [DeferredHint] = []
        for h in self.hints:
            if h.source_module == module and not self.is_resolved(h.type_var):
                result = result.push(h)
        result

    me resolve_with_fallbacks():
        """Resolve remaining hints using their fallback types."""
        for hint in self.unresolved():
            if hint.fallback.?:
                self.resolved[hint.type_var.id] = hint.fallback.unwrap()

export DeferredStore
