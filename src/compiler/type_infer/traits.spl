# Trait Collection and Obligation Generation
#
# Implements trait-aware type checking:
# - Trait collection from HIR modules (Phase B.1)
# - Trait conversion (HirTrait → TraitDef, HirImpl → ImplBlock)
# - Obligation generation (Phase B.2)
# - Trait obligation solving
#
# Obligations are generated during type inference and solved after
# unification completes. This ensures we verify that all trait bounds
# are satisfied (e.g., T: Display when calling print<T>(x: T)).

use compiler.hir.*
use core.lexer.*
use compiler.traits.*
use type_infer_types.*

impl HmInferContext:
    # =========================================================================
    # Trait Collection (Phase B.1)
    # =========================================================================

    me collect_traits_from_module(module: HirModule):
        """Collect all traits from a HIR module into the trait solver.

        Iterates through module.traits and registers each trait definition.
        """
        for trait_id in module.traits.keys():
            val hir_trait = module.traits[trait_id]
            val trait_def = self.convert_hir_trait_to_def(hir_trait)
            self.trait_solver.add_trait(trait_def)

    me collect_impls_from_module(module: HirModule):
        """Collect all impl blocks from a HIR module into the trait solver.

        Iterates through module.impls and registers each impl block.
        """
        for hir_impl in module.impls:
            val impl_block = self.convert_hir_impl_to_block(hir_impl)
            self.trait_solver.add_impl(impl_block)

    me collect_function_bounds_from_module(module: HirModule):
        """Collect trait bounds from all functions in a module.

        Stores trait bounds indexed by function symbol ID for obligation
        generation during function calls.
        """
        for func_id in module.functions.keys():
            val hir_fn = module.functions[func_id]

            # Collect all trait bounds from type parameters
            var all_bounds: [HirTraitBound] = []

            # Bounds from type parameters (T: Trait in fn foo<T: Trait>)
            for tp in hir_fn.type_params:
                for bound_type in tp.bounds:
                    # Convert bound type to HirTraitBound
                    match bound_type.kind:
                        case Named(trait_symbol, _):
                            val bound = HirTraitBound(
                                type_param: tp.symbol,
                                trait_: bound_type,
                                span: tp.span
                            )
                            all_bounds = all_bounds.push(bound)
                        case _: pass

            # Store bounds indexed by function symbol
            if not all_bounds.is_empty():
                self.function_bounds[hir_fn.symbol.id] = all_bounds

    fn convert_hir_trait_to_def(hir_trait: HirTrait) -> TraitDef:
        """Convert HirTrait to TraitDef for the trait solver.

        Extracts method signatures from HirFunctions.
        """
        var methods: [MethodSignature] = []
        for hir_fn in hir_trait.methods:
            val sig = MethodSignature(
                name: hir_fn.name,
                params: hir_fn.params.map(\p: p.type_),
                return_type: hir_fn.return_type,
                effects: hir_fn.effects,
                span: hir_fn.span
            )
            methods = methods.push(sig)

        # Extract supertrait symbols
        var supertraits: [Symbol] = []
        for st_type in hir_trait.supertraits:
            # Extract symbol from Named type
            match st_type.kind:
                case Named(symbol, _):
                    supertraits = supertraits.push(symbol)
                case _: pass  # Skip non-named supertraits for now

        # Extract type parameter symbols
        var type_params: [Symbol] = []
        for tp in hir_trait.type_params:
            type_params = type_params.push(tp.symbol)

        TraitDef(
            name: hir_trait.symbol,
            methods: methods,
            defaults: hir_trait.defaults,
            supertraits: supertraits,
            type_params: type_params,
            span: hir_trait.span
        )

    fn convert_hir_impl_to_block(hir_impl: HirImpl) -> ImplBlock:
        """Convert HirImpl to ImplBlock for the trait solver.

        Resolves method implementations from symbol IDs.
        """
        # Extract trait symbol from trait type
        var trait_symbol: Symbol? = nil
        if hir_impl.trait_.?:
            match hir_impl.trait_.unwrap().kind:
                case Named(symbol, _):
                    trait_symbol = Some(symbol)
                case _: pass

        # For inherent impls (no trait), use a special marker symbol
        val trait_name = trait_symbol ?? SymbolId(id: -1)

        # Extract type parameter symbols
        var type_params: [Symbol] = []
        for tp in hir_impl.type_params:
            type_params = type_params.push(tp.symbol)

        # Note: Method implementations would be looked up from module.functions
        # For now, create empty impl block (methods resolved during obligation solving)
        ImplBlock(
            trait_name: trait_name,
            for_type: hir_impl.type_,
            type_params: type_params,
            where_clause: hir_impl.where_clause,
            methods: if hir_impl.method_symbols.?:
                hir_impl.method_symbols.unwrap()
            else:
                [],
            span: hir_impl.span
        )

    # =========================================================================
    # Obligation Generation (Phase B.2)
    # =========================================================================

    me generate_obligation_for_bound(ty: HirType, bound: HirTraitBound, span: Span):
        """Generate an obligation from a trait bound.

        When we have a type `T` and a bound `T: Trait`, create an obligation
        that must be proven by finding an impl block.
        """
        # Extract trait symbol from bound
        var trait_symbol: SymbolId? = nil
        match bound.trait_.kind:
            case Named(symbol, _):
                trait_symbol = Some(symbol)
            case _: pass

        if trait_symbol.?:
            val cause = ObligationCause.TraitBound(bound.type_param)
            self.trait_solver.add_obligation(ty, trait_symbol.unwrap(), cause, span)

    me generate_obligations_for_function_call(func_symbol: SymbolId, type_args: [HirType], span: Span):
        """Generate obligations from a function call with trait-bounded type parameters.

        When calling `fn foo<T: Display>(x: T)` with T=i64, we need to prove `i64: Display`.

        Algorithm:
        1. Look up function's trait bounds from function_bounds
        2. For each bound `TypeParam: Trait`:
           - Find the concrete type that TypeParam is instantiated with
           - Generate obligation: concrete_type must implement Trait
        """
        # Look up trait bounds for this function
        if not self.function_bounds[func_symbol.id].?:
            return  # No trait bounds on this function

        val bounds = self.function_bounds[func_symbol.id]

        # For each trait bound, generate an obligation
        for bound in bounds:
            # Find which type parameter this bound refers to
            # Map type parameters to type arguments by matching param names
            # Look up the type_param index from the function's generic parameters
            self.generate_obligation_for_bound_with_args(bound, type_args, span)

    me generate_obligation_for_bound_with_args(bound: HirTraitBound, type_args: [HirType], span: Span):
        """Generate obligation for a bound given concrete type arguments.

        Maps the type parameter in the bound to its concrete type from type_args,
        then creates an obligation.
        """
        # Map bound.type_param to the corresponding type_arg by index
        # Type parameters are ordered, so bound index corresponds to type_args index
        val param_index = bound.param_index ?? 0
        if param_index < type_args.len():
            self.generate_obligation_for_bound(type_args[param_index], bound, span)
        elif not type_args.is_empty():
            # Fallback: use first type arg if index not available
            self.generate_obligation_for_bound(type_args[0], bound, span)

    me generate_obligation_for_method_call(receiver_ty: HirType, method_name: text, span: Span):
        """Generate obligations for a method call.

        When calling `receiver.method_name()`, we need to check:
        1. If it's an instance method, no trait obligation needed
        2. If it's a trait method, generate obligation `receiver_ty: Trait`

        For now, this is a simplified implementation.
        """
        # Determine which trait defines this method by looking up in trait solver
        val defining_trait = self.trait_solver.find_trait_for_method(method_name)
        if defining_trait.?:
            val trait_sym = defining_trait.unwrap()
            val cause = ObligationCause.MethodCall(method_name)
            self.trait_solver.add_obligation(receiver_ty, trait_sym, cause, span)
            return

        # Fallback: For common trait methods, generate known obligations
        match method_name:
            case "to_string":
                # Assume Display trait (would need to look this up properly)
                # For now, skip - will be enhanced in Phase C (method resolution)
                pass
            case "clone":
                # Assume Clone trait
                pass
            case _:
                pass

    me generate_obligations_for_type(ty: HirType, bounds: [HirTraitBound], span: Span):
        """Generate obligations for all trait bounds on a type.

        Given a type and its bounds, create obligations for each bound.
        Used when instantiating generic functions or types.
        """
        for bound in bounds:
            self.generate_obligation_for_bound(ty, bound, span)

    me solve_trait_obligations() -> Result<(), [TraitError]>:
        """Solve all pending trait obligations.

        Should be called after type inference is complete for a module.
        Returns errors if any obligations cannot be satisfied.
        """
        match self.trait_solver.solve_all():
            case Ok(_):
                Ok(())
            case Err(trait_errors):
                # Convert trait errors to type inference errors
                for trait_err in trait_errors:
                    match trait_err:
                        case Unsatisfied(obligation):
                            val type_err = TypeInferError.TraitNotImplemented(
                                ty: obligation.type_,
                                trait_name: obligation.trait_.id.to_text(),
                                span: obligation.span
                            )
                            self.errors = self.errors.push(type_err)
                        case _:
                            # Other trait errors
                            pass
                Err(trait_errors)
