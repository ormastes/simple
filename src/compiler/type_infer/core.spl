# Core Unification and Substitution Algorithms
#
# Implements the fundamental operations of Algorithm W:
# - Substitution application (apply_subst, resolve)
# - Occurs check (prevents infinite types)
# - Unification (type equality with substitution)
#
# These are the core operations of Hindley-Milner type inference.
# All type checking ultimately reduces to unification.

use compiler.hir.*
use core.lexer.*
use compiler.dim_constraints.*
use type_infer_types.*

impl HmInferContext:
    # =========================================================================
    # Substitution
    # =========================================================================

    fn apply_subst(ty: HirType) -> HirType:
        """Apply current substitution to a type (resolve all known variables)."""
        self.subst.apply(ty)

    fn resolve(ty: HirType) -> HirType:
        """Get the fully resolved type (chase all substitutions)."""
        self.apply_subst(ty)

    # =========================================================================
    # Occurs Check
    # =========================================================================

    fn occurs(var_id: i64, ty: HirType) -> bool:
        """Check if type variable occurs in type (for occurs check)."""
        val resolved = self.resolve(ty)
        match resolved.kind:
            case Infer(id, _):
                id == var_id
            case Function(params, ret, _):
                for p in params:
                    if self.occurs(var_id, p):
                        return true
                self.occurs(var_id, ret)
            case Tuple(elements):
                for e in elements:
                    if self.occurs(var_id, e):
                        return true
                false
            case Array(element, _) | Slice(element):
                self.occurs(var_id, element)
            case Dict(key, value):
                self.occurs(var_id, key) or self.occurs(var_id, value)
            case Optional(inner) | Ref(inner, _) | Ptr(inner, _):
                self.occurs(var_id, inner)
            case Result(ok, err):
                self.occurs(var_id, ok) or self.occurs(var_id, err)
            case Named(_, args):
                for a in args:
                    if self.occurs(var_id, a):
                        return true
                false
            case Tensor(element, _, _):
                self.occurs(var_id, element)
            case Layer(_, _):
                false  # Layer dimensions don't contain type variables
            case _:
                false

    # =========================================================================
    # Unification
    # =========================================================================

    me unify(t1: HirType, t2: HirType) -> Result<(), TypeInferError>:
        """Unify two types, updating the substitution."""
        val ty1 = self.resolve(t1)
        val ty2 = self.resolve(t2)

        match (ty1.kind, ty2.kind):
            # Same primitive types unify trivially
            case (Int(b1, s1), Int(b2, s2)) if b1 == b2 and s1 == s2:
                Ok(())
            case (Float(b1), Float(b2)) if b1 == b2:
                Ok(())
            case (Bool, Bool):
                Ok(())
            case (Char, Char):
                Ok(())
            case (Str, Str):
                Ok(())
            case (Unit, Unit):
                Ok(())
            case (Never, Never):
                Ok(())

            # Type variable unification
            case (Infer(id1, _), Infer(id2, _)) if id1 == id2:
                Ok(())
            case (Infer(id, level), _):
                if self.occurs(id, ty2):
                    Err(TypeInferError.OccursCheck(id, ty2, ty1.span))
                else:
                    self.subst.insert(id, ty2)
                    Ok(())
            case (_, Infer(id, level)):
                if self.occurs(id, ty1):
                    Err(TypeInferError.OccursCheck(id, ty1, ty2.span))
                else:
                    self.subst.insert(id, ty1)
                    Ok(())

            # Function types
            case (Function(p1, r1, _), Function(p2, r2, _)) if p1.len() == p2.len():
                var i = 0
                while i < p1.len():
                    match self.unify(p1[i], p2[i]):
                        case Err(e): return Err(e)
                        case _: pass
                    i = i + 1
                self.unify(r1, r2)

            # Tuple types
            case (Tuple(e1), Tuple(e2)) if e1.len() == e2.len():
                var i = 0
                while i < e1.len():
                    match self.unify(e1[i], e2[i]):
                        case Err(e): return Err(e)
                        case _: pass
                    i = i + 1
                Ok(())

            # Array types
            case (Array(el1, _), Array(el2, _)):
                self.unify(el1, el2)

            # Slice types
            case (Slice(el1), Slice(el2)):
                self.unify(el1, el2)

            # Dict types
            case (Dict(k1, v1), Dict(k2, v2)):
                match self.unify(k1, k2):
                    case Err(e): Err(e)
                    case _: self.unify(v1, v2)

            # Optional types
            case (Optional(i1), Optional(i2)):
                self.unify(i1, i2)

            # Result types
            case (Result(o1, e1), Result(o2, e2)):
                match self.unify(o1, o2):
                    case Err(e): Err(e)
                    case _: self.unify(e1, e2)

            # Reference types
            case (Ref(i1, m1), Ref(i2, m2)) if m1 == m2:
                self.unify(i1, i2)
            case (Ptr(i1, m1), Ptr(i2, m2)) if m1 == m2:
                self.unify(i1, i2)

            # Named types
            case (Named(s1, a1), Named(s2, a2)) if s1.id == s2.id and a1.len() == a2.len():
                var i = 0
                while i < a1.len():
                    match self.unify(a1[i], a2[i]):
                        case Err(e): return Err(e)
                        case _: pass
                    i = i + 1
                Ok(())

            # Type parameters
            case (TypeParam(n1, _), TypeParam(n2, _)) if n1 == n2:
                Ok(())

            # Tensor types
            case (Tensor(el1, dims1, dev1), Tensor(el2, dims2, dev2)):
                # Unify element types
                match self.unify(el1, el2):
                    case Err(e): return Err(e)
                    case _: pass
                # Check dimension count
                if dims1.len() != dims2.len():
                    return Err(TypeInferError.Other(
                        "tensor dimension count mismatch: {dims1.len()} vs {dims2.len()}",
                        ty1.span
                    ))
                # Add dimension equality constraints
                for i in 0..dims1.len():
                    self.dim_solver.add_equal(dims1[i], dims2[i], ty1.span)
                Ok(())

            # Layer types
            case (Layer(in1, out1), Layer(in2, out2)):
                # Check input dimension count
                if in1.len() != in2.len():
                    return Err(TypeInferError.Other(
                        "layer input dimension count mismatch: {in1.len()} vs {in2.len()}",
                        ty1.span
                    ))
                # Check output dimension count
                if out1.len() != out2.len():
                    return Err(TypeInferError.Other(
                        "layer output dimension count mismatch: {out1.len()} vs {out2.len()}",
                        ty1.span
                    ))
                # Add dimension equality constraints
                for i in 0..in1.len():
                    self.dim_solver.add_equal(in1[i], in2[i], ty1.span)
                for i in 0..out1.len():
                    self.dim_solver.add_equal(out1[i], out2[i], ty1.span)
                Ok(())

            # Mismatch
            case _:
                Err(TypeInferError.Mismatch(ty1, ty2, ty1.span))
