# Backend - Compiler Backend Implementations (FACADE)
#
# This is a facade module that re-exports all backend implementations.
# The actual implementation is split into focused modules:
#
# - backend/env.spl: Environment and scoping utilities (shared)
# - backend/interpreter.spl: Tree-walking interpreter backend
# - backend/compiler.spl: Native code generation (Cranelift JIT/AOT)
# - backend/sdn.spl: SDN export backend (data-only, blocks execution)
#
# This module maintains the original public API while delegating
# to specialized modules for better code organization.

use compiler.hir.*
use compiler.mir.*
use compiler.lexer.Span
use backend_types.*

# Import submodules
mod backend.env
mod backend.interpreter
mod backend.jit_interpreter
mod backend.compiler
mod backend.sdn

# Re-export environment types and utilities
use backend.env.{EvalContext, Environment, empty_env_scope, HirVisitor}

# Re-export backend implementations
use backend.interpreter.InterpreterBackendImpl
use backend.jit_interpreter.{JitInterpreterBackend, JitInterpreterConfig, JitMode}
use backend.compiler.CompilerBackendImpl
use backend.sdn.SdnBackendImpl

# ============================================================================
# Backend Factory
# ============================================================================

pub fn create_backend(kind: BackendKind) -> Backend:
    """Create a backend by kind."""
    match kind:
        case Interpreter:
            # Default to JIT-enabled interpreter for better performance
            JitInterpreterBackend.default()
        case Compiler:
            CompilerBackendImpl()
        case Sdn:
            SdnBackendImpl()
        case CraneliftJit:
            # JIT interpreter with Cranelift backend
            JitInterpreterBackend.new(JitInterpreterConfig(
                mode: JitMode.AlwaysJit,
                backend: "cranelift",
                jit_threshold: 0,
                verbose: false
            ))
        case LlvmJit:
            # JIT interpreter with LLVM backend
            JitInterpreterBackend.new(JitInterpreterConfig(
                mode: JitMode.AlwaysJit,
                backend: "llvm",
                jit_threshold: 0,
                verbose: false
            ))
        case AutoJit:
            # Auto-select JIT backend (hybrid mode)
            JitInterpreterBackend.new(JitInterpreterConfig.auto_jit())
        case Custom(name):
            # Try to resolve from DI container
            val container = get_container()
            val result = container.resolve("Backend")
            if result.is_ok():
                result.unwrap()
            else:
                # Fall back to JIT interpreter
                JitInterpreterBackend.default()

pub fn get_backend() -> Backend:
    """Get the backend from DI container."""
    val container = get_container()
    val result = container.resolve("Backend")
    if result.is_ok():
        result.unwrap()
    else:
        # Default to JIT interpreter
        JitInterpreterBackend.default()

# ============================================================================
# Exports
# ============================================================================

export Backend, BackendKind, BackendResult, BackendError, BackendErrorKind
export CompiledUnit, CompiledSymbol, CompiledSymbolKind, Relocation, RelocKind
export SdnValue, SdnValueKind
export Value, EnumPayloadValue, FunctionValue, ClosureValue, ObjectValue
export EvalContext, Environment
export HirVisitor
export create_backend, get_backend
export InterpreterBackendImpl, JitInterpreterBackend, JitInterpreterConfig, JitMode
export CompilerBackendImpl, SdnBackendImpl
