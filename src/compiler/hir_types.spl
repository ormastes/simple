# HIR Types - Core Types and Symbol Table
#
# This module contains:
# - HIR module structure and imports
# - Symbol table with name resolution and UFCS support
# - HIR type system (primitives, composites, references, user-defined)
# - Dimension types for compile-time tensor checking
# - Effect system

use parser.*
use lexer.Span

# ============================================================================
# HIR Module Structure
# ============================================================================

struct HirModule:
    """Complete HIR module."""
    name: text
    path: text
    imports: [HirImport]
    exports: [text]
    symbols: SymbolTable
    functions: Dict<SymbolId, HirFunction>
    classes: Dict<SymbolId, HirClass>
    structs: Dict<SymbolId, HirStruct>
    enums: Dict<SymbolId, HirEnum>
    traits: Dict<SymbolId, HirTrait>
    impls: [HirImpl]
    constants: Dict<SymbolId, HirConst>
    static_asserts: [HirStaticAssert]   # Static assertions evaluated at compile time

struct HirImport:
    """Import declaration."""
    module_path: text
    items: [HirImportItem]
    span: Span

struct HirImportItem:
    """Single imported item."""
    name: text
    alias: text?
    resolved: SymbolId?     # Resolved after linking

# ============================================================================
# Symbol Table
# ============================================================================

struct SymbolId:
    """Unique identifier for a symbol."""
    id: i64

impl SymbolId:
    static fn new(id: i64) -> SymbolId:
        SymbolId(id: id)

    fn is_valid() -> bool:
        self.id >= 0

struct Symbol:
    """Symbol table entry."""
    id: SymbolId
    name: text
    kind: SymbolKind
    type_: HirType?
    scope: ScopeId
    span: Span
    is_public: bool
    is_mutable: bool
    defining_module: text?   # Which module defined this symbol (for visibility checking)

"""Kind of symbol."""
enum SymbolKind:
    Function
    Method
    Variable
    Parameter
    Field
    Class
    Struct
    Enum
    EnumVariant
    Trait
    TypeAlias
    TypeParam
    Const
    Module
    Import

# ============================================================================
# Method Resolution (UFCS Support)
# ============================================================================

"""How a method call was resolved.

Supports UFCS (Uniform Function Call Syntax) where `x.method()` can resolve to:
1. Instance method on x's type (highest priority)
2. Trait method implemented by x's type
3. Free function `method(x)` where first param matches x's type (UFCS)

Examples:
    x.map()  ->  InstanceMethod if x's class has map()
    x.map()  ->  TraitMethod if x implements trait with map()
    x.map()  ->  FreeFunction(map) if map(x) exists and first param matches
"""
enum MethodResolution:
    # Direct method on the receiver's type
    InstanceMethod(type_id: SymbolId, method_id: SymbolId)

    # Method from an implemented trait
    TraitMethod(trait_id: SymbolId, method_id: SymbolId)

    # UFCS: Free function where receiver becomes first argument
    # x.method(a, b) -> method(x, a, b)
    FreeFunction(func_id: SymbolId)

    # Static method on a type (no receiver)
    # Type.method(a, b) - no self parameter
    StaticMethod(type_id: SymbolId, method_id: SymbolId)

    # Not yet resolved (before resolution pass)
    Unresolved

impl MethodResolution:
    fn is_resolved() -> bool:
        """Check if method has been resolved."""
        match self:
            case Unresolved: false
            case _: true

    fn is_ufcs() -> bool:
        """Check if this is a UFCS resolution (free function)."""
        match self:
            case FreeFunction(_): true
            case _: false

    fn get_symbol_id() -> SymbolId?:
        """Get the resolved symbol ID if available."""
        match self:
            case InstanceMethod(_, method_id): Some(method_id)
            case TraitMethod(_, method_id): Some(method_id)
            case FreeFunction(func_id): Some(func_id)
            case StaticMethod(_, method_id): Some(method_id)
            case Unresolved: nil

struct ScopeId:
    """Unique identifier for a scope."""
    id: i64

struct Scope:
    """Lexical scope."""
    id: ScopeId
    parent: ScopeId?
    kind: ScopeKind
    symbols: Dict<text, SymbolId>

"""Kind of scope."""
enum ScopeKind:
    Module
    Function
    Block
    Loop
    Match
    Class
    Impl

class SymbolTable:
    """Symbol table for name resolution."""
    symbols: Dict<i64, Symbol>
    scopes: Dict<i64, Scope>
    current_scope: ScopeId
    next_symbol_id: i64
    next_scope_id: i64

impl SymbolTable:
    static fn new() -> SymbolTable:
        var table = SymbolTable(
            symbols: {},
            scopes: {},
            current_scope: ScopeId(id: 0),
            next_symbol_id: 0,
            next_scope_id: 1
        )
        # Create root scope (direct mutation avoids copy-modify-reassign bug)
        table.scopes[0] = Scope(
            id: ScopeId(id: 0),
            parent: nil,
            kind: ScopeKind.Module,
            symbols: {}
        )
        table

    me define(name: text, kind: SymbolKind, type_: HirType?, span: Span, is_public: bool, is_mutable: bool, defining_module: text?) -> SymbolId:
        """Define a new symbol in current scope."""
        val id = SymbolId.new(self.next_symbol_id)
        self.next_symbol_id = self.next_symbol_id + 1

        val symbol = Symbol(
            id: id,
            name: name,
            kind: kind,
            type_: type_,
            scope: self.current_scope,
            span: span,
            is_public: is_public,
            is_mutable: is_mutable,
            defining_module: defining_module
        )

        self.symbols[id.id] = symbol

        # Direct nested field mutation (avoids copy-modify-reassign bug in compiled mode)
        self.scopes[self.current_scope.id].symbols[name] = id

        id

    fn lookup(name: text) -> SymbolId?:
        """Look up a symbol by name, searching up scope chain."""
        var scope_id = self.current_scope

        loop:
            val scope = self.scopes[scope_id.id]
            # Use contains_key to check if key exists before accessing
            if scope.symbols.contains_key(name):
                return Some(scope.symbols[name])

            if scope.parent.?:
                scope_id = scope.parent.unwrap()
            else:
                break

        nil

    fn get(id: SymbolId) -> Symbol?:
        """Get symbol by ID."""
        self.symbols[id.id]

    me push_scope(kind: ScopeKind) -> ScopeId:
        """Push a new scope."""
        val id = ScopeId(id: self.next_scope_id)
        self.next_scope_id = self.next_scope_id + 1

        self.scopes[id.id] = Scope(
            id: id,
            parent: Some(self.current_scope),
            kind: kind,
            symbols: {}
        )

        self.current_scope = id
        id

    me pop_scope():
        """Pop current scope."""
        val scope = self.scopes[self.current_scope.id]
        if scope.parent.?:
            self.current_scope = scope.parent.unwrap()

    # ========================================================================
    # Method Resolution Helpers (for UFCS support)
    # ========================================================================

    fn lookup_function(name: text) -> SymbolId?:
        """Look up a free function by name."""
        val sym_id = self.lookup(name)
        if sym_id.?:
            val sym = self.get(sym_id.unwrap())
            if sym.?:
                match sym.unwrap().kind:
                    case Function: return sym_id
                    case _: pass
        nil

    fn lookup_method_in_type(type_id: SymbolId, method_name: text) -> SymbolId?:
        """Look up a method in a class/struct type.

        Searches for a method named `method_name` defined in the type
        identified by `type_id`.
        """
        # Get the type's scope (class or struct body)
        val type_sym = self.get(type_id)
        if not type_sym.?:
            return None

        # Look for a Method symbol with matching name in the type's members
        # This requires traversing impl blocks associated with the type
        # For now, use a naming convention: Type::method
        val qualified_name = "{type_sym.unwrap().name}::{method_name}"
        for sym in self.symbols.values():
            if sym.name == qualified_name:
                match sym.kind:
                    case Method: return Some(sym.id)
                    case Function: return Some(sym.id)  # Static methods
                    case _: pass

        nil

    fn lookup_trait_method(trait_id: SymbolId, method_name: text) -> SymbolId?:
        """Look up a method in a trait.

        Searches for a method named `method_name` defined in the trait
        identified by `trait_id`.
        """
        val trait_sym = self.get(trait_id)
        if not trait_sym.?:
            return None

        # Look for trait method using qualified name
        val qualified_name = "{trait_sym.unwrap().name}::{method_name}"
        for sym in self.symbols.values():
            if sym.name == qualified_name:
                match sym.kind:
                    case Method: return Some(sym.id)
                    case _: pass

        nil

    fn lookup_static_method(type_id: SymbolId, method_name: text) -> SymbolId?:
        """Look up a static method in a class/struct/enum.

        Static methods are defined with `static fn` and don't have a `self` parameter.
        """
        val type_sym = self.get(type_id)
        if not type_sym.?:
            return None

        # Static methods are stored as Function symbols with qualified names
        val qualified_name = "{type_sym.unwrap().name}::{method_name}"
        for sym in self.symbols.values():
            if sym.name == qualified_name:
                match sym.kind:
                    case Function: return Some(sym.id)  # Static methods
                    case _: pass

        nil

    fn get_symbol_type(id: SymbolId) -> HirType?:
        """Get the type of a symbol."""
        val sym = self.get(id)
        if sym.?:
            sym.unwrap().type_
        else:
            nil

    fn is_function(id: SymbolId) -> bool:
        """Check if symbol is a function."""
        val sym = self.get(id)
        if sym.?:
            match sym.unwrap().kind:
                case Function: true
                case _: false
        else:
            false

    fn is_method(id: SymbolId) -> bool:
        """Check if symbol is a method."""
        val sym = self.get(id)
        if sym.?:
            match sym.unwrap().kind:
                case Method: true
                case _: false
        else:
            false

    fn get_methods_for_type(type_id: SymbolId) -> [text]:
        """Get all method names for a type (for error suggestions)."""
        var methods: [text] = []
        val type_sym = self.get(type_id)
        if not type_sym.?:
            return methods

        val type_name = type_sym.unwrap().name
        val prefix = "{type_name}::"

        for sym in self.symbols.values():
            if not sym.?:
                pass
            elif not sym.name.?:
                pass
            elif sym.name.starts_with(prefix):
                match sym.kind:
                    case Method:
                        # Extract method name from qualified name
                        val method_name = sym.name[prefix.len():]
                        methods = methods.push(method_name)
                    case _: pass

        methods

    fn get_all_functions() -> [text]:
        """Get all function names (for error suggestions)."""
        var functions: [text] = []

        for sym in self.symbols.values():
            match sym.kind:
                case Function:
                    # Only include non-qualified names (free functions)
                    if not sym.name.contains("::"):
                        functions = functions.push(sym.name)
                case _: pass

        functions

# ============================================================================
# HIR Types
# ============================================================================

struct HirType:
    """Type in HIR."""
    kind: HirTypeKind
    span: Span

"""Type kind."""
enum HirTypeKind:
    # Primitive types
    Int(bits: i64, signed: bool)    # i8, i16, i32, i64, u8, u16, u32, u64
    Float(bits: i64)                 # f32, f64
    Bool
    Char
    Str
    Unit                             # ()

    # Composite types
    Tuple(elements: [HirType])
    Array(element: HirType, size: i64?)
    Slice(element: HirType)
    Dict(key: HirType, value: HirType)

    # Reference types
    Ref(inner: HirType, mutable: bool)
    Ptr(inner: HirType, mutable: bool)
    Optional(inner: HirType)
    Result(ok: HirType, err: HirType)

    # User-defined types
    Named(symbol: SymbolId, args: [HirType])
    TypeParam(name: text, bounds: [HirType])

    # Trait types
    DynTrait(trait_: SymbolId)       # dyn Trait (trait object for dynamic dispatch)

    # Function types
    Function(params: [HirType], ret: HirType, effects: [Effect])

    # Special
    # Type inference variable with level for HM generalization
    # - id: unique identifier for the variable
    # - level: scope level at which the variable was created
    #   Higher level = more recently introduced, can be generalized
    Infer(id: i64, level: i64)
    Error
    Never                            # ! type (never returns)

    # Tensor and Layer types (for dimension checking)
    Tensor(element: HirType, dims: [DimExpr], device: DeviceType?)
    Layer(input: [DimExpr], output: [DimExpr])

# ============================================================================
# Dimension Types (for compile-time dimension checking)
# ============================================================================

struct DimExpr:
    """Dimension expression for tensor shape checking."""
    kind: DimExprKind
    span: Span

"""Dimension expression kind."""
enum DimExprKind:
    Literal(value: i64)                     # 784
    Named(name: text, lo: i64?, hi: i64?)   # batch: 1..128
    Var(id: i64)                            # Inference variable
    Dynamic                                  # Runtime only
    Broadcast                                # Broadcasting dimension
    ConstParam(name: text)                  # Reference to const generic
    # Arithmetic operations
    Add(left: DimExpr, right: DimExpr)
    Mul(left: DimExpr, right: DimExpr)
    Div(left: DimExpr, right: DimExpr)

impl DimExpr:
    static fn literal(value: i64, span: Span) -> DimExpr:
        DimExpr(kind: DimExprKind.Literal(value), span: span)

    static fn named(name: text, span: Span) -> DimExpr:
        DimExpr(kind: DimExprKind.Named(name, nil, nil), span: span)

    static fn named_range(name: text, lo: i64, hi: i64, span: Span) -> DimExpr:
        DimExpr(kind: DimExprKind.Named(name, Some(lo), Some(hi)), span: span)

    static fn var(id: i64, span: Span) -> DimExpr:
        DimExpr(kind: DimExprKind.Var(id), span: span)

    static fn dynamic(span: Span) -> DimExpr:
        DimExpr(kind: DimExprKind.Dynamic, span: span)

    fn is_literal() -> bool:
        match self.kind:
            case Literal(_): true
            case _: false

    fn get_literal() -> i64?:
        match self.kind:
            case Literal(v): Some(v)
            case _: nil

"""Device type for tensors."""
enum DeviceType:
    CPU
    GPU
    CUDA(id: i64)

struct LayerType:
    """Type for neural network layers with input/output shapes."""
    input_shape: [DimExpr]
    output_shape: [DimExpr]
    params: [ParamShape]
    device: DeviceType?

struct ParamShape:
    """Shape of a trainable parameter in a layer."""
    name: text
    shape: [DimExpr]
    trainable: bool

impl LayerType:
    static fn new(input: [DimExpr], output: [DimExpr]) -> LayerType:
        LayerType(
            input_shape: input,
            output_shape: output,
            params: [],
            device: nil
        )

    static fn with_device_of(layer: LayerType, device: DeviceType) -> LayerType:
        LayerType(
            input_shape: layer.input_shape,
            output_shape: layer.output_shape,
            params: layer.params,
            device: Some(device)
        )

struct Effect:
    """Effect annotation."""
    kind: EffectKind
    span: Span

"""Effect kind."""
enum EffectKind:
    Pure            # No side effects
    IO              # I/O operations
    Async           # Async operations
    Throws(type_: HirType)  # Can throw error
    Mutates         # Mutates state
    Allocates       # Heap allocation
    Custom(name: text)

# ============================================================================
# Exports
# ============================================================================

export HirModule, HirImport, HirImportItem
export SymbolId, Symbol, SymbolKind, ScopeId, Scope, ScopeKind, SymbolTable
export MethodResolution
export HirType, HirTypeKind
export DimExpr, DimExprKind, DeviceType, LayerType, ParamShape
export Effect, EffectKind
