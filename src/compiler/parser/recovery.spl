# Parser Error Recovery
#
# Detection of common mistakes from other languages, "did you mean?"
# suggestions, synchronization-based error recovery, and multi-error
# collection for better diagnostics.
#
# Port of rust/parser/src/error_recovery.rs (603 lines)

export CommonMistake, ErrorHintLevel, ErrorHint
export detect_common_mistake, RecoveryStrategy, ErrorCollector

# ============================================================================
# Common Mistakes from Other Languages
# ============================================================================

enum CommonMistake:
    # Python
    PythonDef           # def instead of fn
    PythonSelf          # self. instead of implicit self
    PythonNone          # nil instead of nil
    PythonTrue          # True instead of true
    PythonFalse         # False instead of false
    # Rust
    RustLetMut          # let mut instead of var
    RustFnMut           # fn(&mut self) instead of me fn()
    RustLifetime        # 'a not supported
    RustMacro           # macro! syntax
    RustTurbofish       # ::<T> instead of <T>
    # Java/C++
    JavaPublicClass     # public class instead of pub class
    JavaVoid            # void instead of no return type
    JavaNew             # new Type() instead of Type {}
    JavaThis            # this instead of self
    CppTemplate         # template<T> instead of <T>
    CppNamespace        # namespace instead of mod
    # TypeScript/JavaScript
    TsFunction          # function instead of fn
    TsConst             # const instead of val
    TsLet               # let instead of val
    TsInterface         # interface instead of trait
    TsArrowFunction     # => in function definition
    # C-style
    CSemicolon          # unnecessary semicolons
    CTypeFirst          # int x instead of val x: i32
    # Generic
    MissingColon        # missing : before block
    WrongBrackets       # [] instead of <> for generics
    ExplicitSelf        # (self) parameter when implicit
    MissingCommaInArgs  # func(x: 10 y: 20)
    MissingColonBeforeBlock
    MissingIndentAfterColon
    WrongIndentLevel

fn mistake_message(m: CommonMistake) -> text:
    match m:
        case PythonDef:
            "Use 'fn' to define functions in Simple, not 'def'.\n  Python:  def add(a, b):\n  Simple:  fn add(a, b):"
        case PythonSelf:
            "In Simple, 'self' is implicit in methods. Don't write 'self.'.\n  Python:  self.x = value\n  Simple:  x = value"
        case PythonNone:
            "Use 'nil' instead of 'None' in Simple.\n  Python:  return None\n  Simple:  return nil"
        case PythonTrue | PythonFalse:
            "Use lowercase 'true' and 'false' in Simple."
        case RustLetMut:
            "Use 'var' for mutable, 'val' for immutable.\n  Rust:    let mut x = 5;\n  Simple:  var x = 5"
        case RustFnMut:
            "Use 'me' keyword for mutable methods.\n  Rust:    fn update(&mut self) {}\n  Simple:  me update():"
        case RustLifetime:
            "Simple doesn't use lifetime annotations. Reference capabilities handle memory safety."
        case RustTurbofish:
            "Use <T> directly, not ::<T>."
        case RustMacro:
            "Simple uses '@' for macros, not '!'."
        case JavaPublicClass:
            "Use 'pub class' or 'pub struct' in Simple."
        case JavaVoid:
            "Omit return type for void functions.\n  Java:    void print(String s) {}\n  Simple:  fn print(s: text):"
        case JavaNew:
            "Use struct literal: Type(field: value) or Type { field: value }"
        case JavaThis:
            "Use 'self' (which is implicit in methods)."
        case CppTemplate:
            "Generic parameters come after the name: struct Vec<T>:"
        case CppNamespace:
            "Use 'mod' for modules instead of 'namespace'."
        case TsFunction:
            "Use 'fn' to define functions."
        case TsConst:
            "Use 'val' for immutable variables."
        case TsLet:
            "Use 'val' (immutable) or 'var' (mutable)."
        case TsInterface:
            "Use 'trait' instead of 'interface'."
        case TsArrowFunction:
            "Use ':' for function bodies, '=>' is not used.\n  Simple:  val add = \\a, b: a + b"
        case CSemicolon:
            "Semicolons are optional in Simple."
        case CTypeFirst:
            "Type comes after the name: val x: i32 = 5"
        case MissingColon:
            "Function and block definitions require ':' before the body."
        case WrongBrackets:
            "Use <> for generic types, not []."
        case ExplicitSelf:
            "'self' parameter is implicit in methods."
        case MissingCommaInArgs:
            "Missing comma between function arguments."
        case MissingColonBeforeBlock:
            "Missing colon before function body."
        case MissingIndentAfterColon:
            "Missing indentation after colon."
        case WrongIndentLevel:
            "Inconsistent indentation level."

fn mistake_suggestion(m: CommonMistake) -> text:
    match m:
        case PythonDef: "Replace 'def' with 'fn'"
        case PythonNone: "Replace 'None' with 'nil'"
        case PythonTrue: "Replace 'True' with 'true'"
        case PythonFalse: "Replace 'False' with 'false'"
        case RustLetMut: "Use 'var' instead of 'let mut'"
        case RustMacro: "Use '@' for macros instead of '!'"
        case RustFnMut: "Use 'me' keyword instead of '&mut self'"
        case JavaPublicClass: "Use 'pub class' or 'pub struct'"
        case JavaVoid: "Omit the return type"
        case JavaNew: "Use struct literal: Type(field: value)"
        case JavaThis: "Use 'self' (implicit in methods)"
        case TsFunction: "Replace 'function' with 'fn'"
        case TsConst: "Replace 'const' with 'val'"
        case TsLet: "Use 'val' or 'var'"
        case TsInterface: "Replace 'interface' with 'trait'"
        case MissingColon: "Add ':' before the body"
        case WrongBrackets: "Use <> instead of []"
        case MissingCommaInArgs: "Insert missing comma"
        case _: "See error message for details"

# ============================================================================
# Mistake Detection
# ============================================================================

# Known C-type names for CTypeFirst detection
val C_TYPE_NAMES = ["int", "uint", "float", "double", "char", "long",
                     "short", "byte", "boolean", "void", "string", "String"]

fn detect_common_mistake(current_lexeme: text, current_kind: text,
                         prev_kind: text, next_lexeme: text?) -> CommonMistake?:
    """Detect common mistakes from other languages based on token sequence."""

    # Python: def
    if current_lexeme == "def" and current_kind == "Identifier":
        return Some(CommonMistake.PythonDef)

    # Python: nil (but not in case patterns, enum bodies, or after return/=)
    if current_lexeme == "None" and current_kind == "Identifier":
        if prev_kind != "Case" and prev_kind != "Newline" and prev_kind != "Indent"
           and prev_kind != "Return" and prev_kind != "Assign":
            return Some(CommonMistake.PythonNone)

    # Python: True/False
    if current_lexeme == "True" and current_kind == "Identifier":
        return Some(CommonMistake.PythonTrue)
    if current_lexeme == "False" and current_kind == "Identifier":
        return Some(CommonMistake.PythonFalse)

    # Rust: let mut
    if prev_kind == "Let" and current_lexeme == "mut" and current_kind == "Identifier":
        return Some(CommonMistake.RustLetMut)

    # Java: public class
    if current_lexeme == "public" and current_kind == "Identifier":
        if next_lexeme.? and next_lexeme.unwrap() == "class":
            return Some(CommonMistake.JavaPublicClass)

    # Java: void (not after ->)
    if current_lexeme == "void" and current_kind == "Identifier" and prev_kind != "Arrow":
        return Some(CommonMistake.JavaVoid)

    # Java: this
    if current_lexeme == "this" and current_kind == "Identifier":
        return Some(CommonMistake.JavaThis)

    # TS: function
    if current_lexeme == "function" and current_kind == "Identifier":
        return Some(CommonMistake.TsFunction)

    # TS: const
    if current_lexeme == "const" and current_kind == "Identifier":
        return Some(CommonMistake.TsConst)

    # TS: interface
    if current_lexeme == "interface" and current_kind == "Identifier":
        return Some(CommonMistake.TsInterface)

    # C++: namespace
    if current_lexeme == "namespace" and current_kind == "Identifier":
        return Some(CommonMistake.CppNamespace)

    # C++: template
    if current_lexeme == "template" and current_kind == "Identifier":
        return Some(CommonMistake.CppTemplate)

    # Rust: turbofish ::<
    if current_kind == "Lt" and prev_kind == "DoubleColon":
        return Some(CommonMistake.RustTurbofish)

    # C-style type-first: int x
    if C_TYPE_NAMES.contains(current_lexeme) and current_kind == "Identifier":
        if next_lexeme.? and next_lexeme.unwrap().chars()[0].is_lowercase():
            return Some(CommonMistake.CTypeFirst)

    nil

# ============================================================================
# Error Hints (Diagnostics)
# ============================================================================

enum ErrorHintLevel:
    Error
    Warning
    Info
    Hint

struct ErrorHint:
    level: ErrorHintLevel
    message: text
    line: i64
    column: i64
    suggestion: text?
    help: text?

impl ErrorHint:
    static fn error(message: text, line: i64, column: i64) -> ErrorHint:
        ErrorHint(level: ErrorHintLevel.Error, message: message,
                  line: line, column: column, suggestion: nil, help: nil)

    static fn warning(message: text, line: i64, column: i64) -> ErrorHint:
        ErrorHint(level: ErrorHintLevel.Warning, message: message,
                  line: line, column: column, suggestion: nil, help: nil)

    fn with_suggestion(suggestion: text) -> ErrorHint:
        ErrorHint(level: self.level, message: self.message,
                  line: self.line, column: self.column,
                  suggestion: Some(suggestion), help: self.help)

    fn with_help(help: text) -> ErrorHint:
        ErrorHint(level: self.level, message: self.message,
                  line: self.line, column: self.column,
                  suggestion: self.suggestion, help: Some(help))

    fn format(source: text) -> text:
        val level_str = match self.level:
            case Error: "error"
            case Warning: "warning"
            case Info: "info"
            case Hint: "hint"
        var output = "{level_str}: {self.message}\n  --> line {self.line}:{self.column}\n"
        val lines = source.split("\n")
        if self.line > 0 and self.line <= lines.len():
            val line_text = lines[self.line - 1]
            output = output + "   |\n"
            output = output + "{self.line:3} | {line_text}\n"
            output = output + "   | {\" \".repeat(self.column - 1)}^\n"
        if self.suggestion.?:
            output = output + "\nSuggestion: {self.suggestion.unwrap()}\n"
        if self.help.?:
            output = output + "\nHelp: {self.help.unwrap()}\n"
        output

# ============================================================================
# Recovery Strategy
# ============================================================================

enum RecoveryStrategy:
    """How to recover from a parse error."""
    SkipToNewline           # Skip tokens until newline (next statement)
    SkipToToken(kind: text) # Skip until specific token kind
    SkipToClosingBrace      # Skip to matching }
    InsertToken(kind: text) # Pretend token exists, continue
    PopContext              # Pop current parsing context and retry

# ============================================================================
# Error Collector (Multi-Error Support)
# ============================================================================

class ErrorCollector:
    """Collects multiple parse errors instead of stopping at the first one.

    After the first error, the parser enters recovery mode:
    it skips tokens until a synchronization point, then continues parsing.
    """
    errors: [ErrorHint]
    max_errors: i64
    in_recovery: bool

impl ErrorCollector:
    static fn default() -> ErrorCollector:
        ErrorCollector(errors: [], max_errors: 50, in_recovery: false)

    static fn with_limit(max_errors: i64) -> ErrorCollector:
        ErrorCollector(errors: [], max_errors: max_errors, in_recovery: false)

    me add_error(hint: ErrorHint):
        if self.errors.len() < self.max_errors:
            self.errors = self.errors.push(hint)

    me add_warning(hint: ErrorHint):
        self.errors = self.errors.push(hint)

    me enter_recovery():
        self.in_recovery = true

    me exit_recovery():
        self.in_recovery = false

    fn is_recovering() -> bool:
        self.in_recovery

    fn has_errors() -> bool:
        self.errors.filter(\h: match h.level: case Error: true; case _: false).?

    fn error_count() -> i64:
        self.errors.filter(\h: match h.level: case Error: true; case _: false).len()

    fn warning_count() -> i64:
        self.errors.filter(\h: match h.level: case Warning: true; case _: false).len()

    fn all_hints() -> [ErrorHint]:
        self.errors

    fn format_all(source: text) -> text:
        """Format all collected errors for display."""
        var output = ""
        for hint in self.errors:
            output = output + hint.format(source) + NL
        if self.error_count() > 0:
            output = output + NL + "{self.error_count()} error(s)"
            if self.warning_count() > 0:
                output = output + ", {self.warning_count()} warning(s)"
            output = output + NL
        output

    fn at_limit() -> bool:
        self.errors.len() >= self.max_errors
