# State Enum Generation for Async State Machines
#
# Generates the state enum type for an async function's state machine.
# Each suspension point gets its own state variant that stores the
# live variables at that point.
#
# Example:
#   async fn fetch() -> text:
#       val a = 1
#       val b = await get_data()  # SP0
#       val c = await process(b)  # SP1
#       a + b + c
#
#   Generates:
#   enum FetchState:
#       State0                              # Initial state
#       State1(a: i64, fut: Future<Data>)  # After first await
#       State2(a: i64, b: Data, fut: Future<Result>)  # After second await

use compiler.parser_types.*
use compiler.desugar.suspension_analysis.{SuspensionPoint, SuspensionAnalysis}
use lexer.Span

# ================================================================
# Data Structures
# ================================================================

struct StateEnum:
    """Generated state enum for an async function's state machine.

    Contains:
    - name: Enum type name (e.g., "FetchState")
    - variants: List of state variants (State0, State1, ...)
    - doc_comment: Generated documentation
    """
    name: text
    variants: [StateVariant]
    doc_comment: text

struct StateVariant:
    """Single variant in a state enum.

    Each variant represents a point in the async function's execution:
    - State0: Initial state (no fields)
    - State1..N: After each await (with live variables + future)
    - StateTerminal: Final state (if needed)

    Fields:
    - name: Variant name (State0, State1, etc.)
    - fields: Fields stored in this variant
    - suspension_point_id: Which suspension point this state follows (nil for State0)
    - doc_comment: Documentation for this state
    """
    name: text
    fields: [Field]
    suspension_point_id: i64?
    doc_comment: text

# ================================================================
# State Enum Generation
# ================================================================

fn generate_state_enum(func_name: text, analysis: SuspensionAnalysis) -> StateEnum:
    """Generate state enum for an async function.

    Creates enum with:
    - State0 (initial, no fields)
    - State1..N (one per suspension point, with live variables + future)

    Args:
        func_name: Name of async function (used for enum name)
        analysis: Suspension point analysis result

    Returns:
        Generated StateEnum

    Example:
        func_name = "fetch"
        analysis = SuspensionAnalysis(suspension_points: [sp0, sp1], ...)

        Returns: StateEnum(
            name: "FetchState",
            variants: [State0, State1, State2]
        )
    """
    val enum_name = "{func_name}State"

    var variants = []

    # State0: Initial state (no fields)
    variants = variants.push(StateVariant(
        name: "State0",
        fields: [],
        suspension_point_id: nil,
        doc_comment: "Initial state (before first await)"
    ))

    # State1..N: One state per suspension point
    for sp in analysis.suspension_points:
        val state_name = "State{sp.id + 1}"
        val fields = generate_state_fields(sp)
        val doc = generate_state_doc(sp)

        variants = variants.push(StateVariant(
            name: state_name,
            fields: fields,
            suspension_point_id: sp.id,
            doc_comment: doc
        ))

    val doc = generate_enum_doc(func_name, analysis)

    StateEnum(
        name: enum_name,
        variants: variants,
        doc_comment: doc
    )

fn generate_state_fields(sp: SuspensionPoint) -> [Field]:
    """Generate fields for a state variant.

    Each state needs to store:
    1. Live variables from before the suspension point
    2. The future being awaited (to poll it when resuming)

    Args:
        sp: Suspension point

    Returns:
        List of fields for the state variant

    Example:
        sp has live_variables: ["a", "b"]
        Returns: [
            Field(name: "a", type: <inferred>),
            Field(name: "b", type: <inferred>),
            Field(name: "future", type: Future<T>)
        ]
    """
    var fields = []

    # Add fields for live variables
    for var_name in sp.live_variables:
        # For now, use generic Type - type inference will fill in actual types
        val field = Field(
            name: var_name,
            type_: make_inferred_type(sp.span),
            default: nil,
            is_public: false,
            is_volatile: false,
            fixed_address: nil,
            span: sp.span
        )
        fields = fields.push(field)

    # Add field for the future being awaited
    val future_field = Field(
        name: "future",
        type_: make_future_type(sp.span),
        default: nil,
        is_public: false,
        is_volatile: false,
        fixed_address: nil,
        span: sp.span
    )
    fields = fields.push(future_field)

    fields

fn generate_state_doc(sp: SuspensionPoint) -> text:
    """Generate documentation for a state variant.

    Args:
        sp: Suspension point

    Returns:
        Documentation string

    Example:
        "State after await #0 (live variables: a, b)"
    """
    val live_vars = sp.live_variables.join(", ")
    "State after await #{sp.id} (live variables: {live_vars})"

fn generate_enum_doc(func_name: text, analysis: SuspensionAnalysis) -> text:
    """Generate documentation for the state enum.

    Args:
        func_name: Function name
        analysis: Suspension analysis

    Returns:
        Documentation string
    """
    val num_states = analysis.total_states
    val num_awaits = analysis.suspension_points.len()

    "State machine for async function '{func_name}'.\n\
     Contains {num_states} states for {num_awaits} suspension points."

# ================================================================
# AST Generation Helpers
# ================================================================

fn make_inferred_type(span: Span) -> Type:
    """Create a type that will be inferred by type checker.

    Args:
        span: Source location

    Returns:
        Inferred type placeholder
    """
    Type(
        kind: TypeKind.Inferred,
        span: span
    )

fn make_future_type(span: Span) -> Type:
    """Create Future<T> type with inferred T.

    Args:
        span: Source location

    Returns:
        Future<Inferred> type
    """
    Type(
        kind: TypeKind.Generic(
            "Future",
            [make_inferred_type(span)]
        ),
        span: span
    )

# ================================================================
# State Enum Conversion to AST
# ================================================================

fn state_enum_to_ast(state_enum: StateEnum, span: Span) -> Enum:
    """Convert StateEnum to AST Enum node.

    Args:
        state_enum: Generated state enum
        span: Source location

    Returns:
        AST Enum node ready for insertion into module
    """
    var ast_variants = []

    for variant in state_enum.variants:
        val ast_variant = EnumVariant(
            name: variant.name,
            fields: variant.fields,
            discriminant: nil,
            doc_comment: variant.doc_comment,
            span: span
        )
        ast_variants = ast_variants.push(ast_variant)

    Enum(
        name: state_enum.name,
        type_params: [],
        variants: ast_variants,
        is_public: false,  # State enum is implementation detail
        doc_comment: state_enum.doc_comment,
        attributes: [],
        span: span
    )

# ================================================================
# Debugging Helpers
# ================================================================

fn format_state_enum(state_enum: StateEnum) -> text:
    """Format state enum for debugging.

    Args:
        state_enum: State enum to format

    Returns:
        Human-readable string representation

    Example output:
        enum FetchState:
            State0  // Initial state
            State1(a: i64, future: Future<Data>)  // After await #0
            State2(a: i64, b: Data, future: Future<Result>)  // After await #1
    """
    var lines = []
    lines = lines.push("enum {state_enum.name}:")

    for variant in state_enum.variants:
        if variant.fields.len() == 0:
            lines = lines.push("    {variant.name}  // {variant.doc_comment}")
        else:
            val field_strs = variant.fields.map(\f: "{f.name}: <type>")
            val fields_joined = field_strs.join(", ")
            lines = lines.push("    {variant.name}({fields_joined})  // {variant.doc_comment}")

    lines.join("\n")

# ================================================================
# Exports
# ================================================================

export StateEnum
export StateVariant
export generate_state_enum
export state_enum_to_ast
export format_state_enum
