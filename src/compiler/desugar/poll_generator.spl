# Poll Loop Generation for Async State Machines
#
# Generates the poll() function that drives an async function's state machine.
# The poll function takes the current state and a waker, executes the next
# chunk of work, and returns the new state plus a Poll result.
#
# Example generated poll function:
#   fn poll(state: FetchState, waker: Waker) -> (FetchState, Poll<text>):
#       match state:
#           case State0:
#               val future = get_data()
#               (State1(future: future), Poll.Pending)
#           case State1(future):
#               match future.poll(waker):
#                   case Ready(data):
#                       (State0, Poll.Ready(data))
#                   case Pending:
#                       (State1(future: future), Poll.Pending)

use compiler.parser_types.*
use compiler.desugar.suspension_analysis.{SuspensionPoint, SuspensionAnalysis}
use compiler.desugar.state_enum.{StateEnum, StateVariant}
use lexer.Span

# ================================================================
# Data Structures
# ================================================================

struct PollFunction:
    """Generated poll function for an async state machine.

    The poll function is the core of the state machine - it takes the
    current state and waker, executes code, and returns the next state
    plus a Poll<T> result.

    Fields:
        name: Function name (e.g., "poll_fetch")
        state_param: State parameter name
        waker_param: Waker parameter name
        return_type: Return type (State, Poll<T>)
        body: Function body (match expression on state)
        doc_comment: Generated documentation
    """
    name: text
    state_param: text
    waker_param: text
    return_type: Type
    body: Block
    doc_comment: text

# ================================================================
# Poll Function Generation
# ================================================================

fn generate_poll_function(
    func_name: text,
    func_body: Block,
    analysis: SuspensionAnalysis,
    state_enum: StateEnum
) -> PollFunction:
    """Generate poll function for an async state machine.

    Creates a function that:
    1. Matches on the current state
    2. For State0: executes code until first await, transitions to State1
    3. For State1..N: polls the future, either continues or returns Pending
    4. Returns (new_state, Poll<T>)

    Args:
        func_name: Name of the async function
        func_body: Original async function body
        analysis: Suspension point analysis
        state_enum: Generated state enum

    Returns:
        Generated poll function
    """
    val poll_name = "poll_{func_name}"
    val state_param = "state"
    val waker_param = "waker"

    # Generate match arms for each state
    var match_arms = []

    # State0: Initial state - execute until first await
    val state0_arm = generate_state0_arm(func_body, analysis, state_enum)
    match_arms = match_arms.push(state0_arm)

    # State1..N: Resume after each await
    for i in 0..analysis.suspension_points.len():
        val sp = analysis.suspension_points[i]
        val variant = state_enum.variants[i + 1]  # +1 because State0 is at index 0
        val arm = generate_resume_arm(sp, variant, func_body, analysis, state_enum, waker_param)
        match_arms = match_arms.push(arm)

    # Create match expression on state
    val match_expr = Expr(
        kind: ExprKind.Match(
            Expr(kind: ExprKind.Ident(state_param), span: dummy_span()),
            match_arms
        ),
        span: dummy_span()
    )

    # Wrap in block
    val body = Block(
        statements: [Stmt(
            kind: StmtKind.Expr(match_expr),
            span: dummy_span()
        )],
        span: dummy_span()
    )

    # Create return type: (StateEnum, Poll<T>)
    val return_type = make_poll_return_type(state_enum.name)

    val doc = generate_poll_doc(func_name, analysis)

    PollFunction(
        name: poll_name,
        state_param: state_param,
        waker_param: waker_param,
        return_type: return_type,
        body: body,
        doc_comment: doc
    )

fn generate_state0_arm(
    func_body: Block,
    analysis: SuspensionAnalysis,
    state_enum: StateEnum
) -> MatchArm:
    """Generate match arm for State0 (initial state).

    This arm executes code from the function start until the first await.
    It creates the future and transitions to State1.

    Returns match arm like:
        case State0:
            # Code before first await
            val future = get_data()
            (State1(future: future), Poll.Pending)
    """
    # Pattern: State0
    val pattern = Pattern(
        kind: PatternKind.EnumVariant("State0", []),
        span: dummy_span()
    )

    # Body: execute until first await, then create future and transition
    var body_stmts = []

    if analysis.suspension_points.len() > 0:
        val first_sp = analysis.suspension_points[0]

        # TODO: Extract code before first await from func_body
        # For now, create simple placeholder:
        # val future = <awaited_expression>

        val future_binding = Stmt(
            kind: StmtKind.Val(
                "future",
                nil,
                first_sp.awaited_future
            ),
            span: dummy_span()
        )
        body_stmts = body_stmts.push(future_binding)

        # Return (State1(future: future), Poll.Pending)
        val next_state = make_state_constructor("State1", ["future"])
        val return_expr = make_poll_tuple(next_state, make_pending())
        body_stmts = body_stmts.push(Stmt(
            kind: StmtKind.Expr(return_expr),
            span: dummy_span()
        ))
    else:
        # No awaits - immediately return ready
        # TODO: Extract return value from func_body
        val return_val = Expr(kind: ExprKind.UnitLiteral, span: dummy_span())
        val return_expr = make_poll_tuple(
            make_state_constructor("State0", []),
            make_ready(return_val)
        )
        body_stmts = body_stmts.push(Stmt(
            kind: StmtKind.Expr(return_expr),
            span: dummy_span()
        ))

    val body = Block(stmts: body_stmts, span: dummy_span())

    MatchArm(
        pattern: pattern,
        guard: nil,
        body: body
    )

fn generate_resume_arm(
    sp: SuspensionPoint,
    variant: StateVariant,
    func_body: Block,
    analysis: SuspensionAnalysis,
    state_enum: StateEnum,
    waker_param: text
) -> MatchArm:
    """Generate match arm for resumption state.

    This arm:
    1. Polls the future from the previous await
    2. If Ready: extracts value, continues to next await or returns
    3. If Pending: returns same state with Pending

    Returns match arm like:
        case State1(a, future):
            match future.poll(waker):
                case Ready(value):
                    # Continue to next await or return
                    ...
                case Pending:
                    (State1(a: a, future: future), Poll.Pending)
    """
    # Pattern: State{N}(field1, field2, ..., future)
    var pattern_bindings = []
    for field in variant.fields:
        pattern_bindings = pattern_bindings.push(field.name)

    val pattern = Pattern(
        kind: PatternKind.EnumVariant(variant.name, pattern_bindings),
        span: dummy_span()
    )

    # Body: poll the future, handle Ready/Pending
    var body_stmts = []

    # val poll_result = future.poll(waker)
    val poll_call = make_poll_call("future", waker_param)
    val poll_binding = Stmt(
        kind: StmtKind.Val("poll_result", nil, poll_call),
        span: dummy_span()
    )
    body_stmts = body_stmts.push(poll_binding)

    # match poll_result:
    #     case Ready(value): ...
    #     case Pending: ...
    val ready_arm = generate_ready_arm(sp, variant, analysis, state_enum)
    val pending_arm = generate_pending_arm(variant)

    val poll_match = Expr(
        kind: ExprKind.Match(
            Expr(kind: ExprKind.Ident("poll_result"), span: dummy_span()),
            [ready_arm, pending_arm]
        ),
        span: dummy_span()
    )

    body_stmts = body_stmts.push(Stmt(
        kind: StmtKind.Expr(poll_match),
        span: dummy_span()
    ))

    val body = Block(stmts: body_stmts, span: dummy_span())

    MatchArm(
        pattern: pattern,
        guard: nil,
        body: body
    )

fn generate_ready_arm(
    sp: SuspensionPoint,
    variant: StateVariant,
    analysis: SuspensionAnalysis,
    state_enum: StateEnum
) -> MatchArm:
    """Generate Ready arm of poll result match.

    If the future is ready, extract the value and either:
    - Continue to next await (create next future, transition to next state)
    - Return final value (if this was the last await)
    """
    val pattern = Pattern(
        kind: PatternKind.EnumVariant("Ready", ["value"]),
        span: dummy_span()
    )

    var body_stmts = []

    val next_sp_index = sp.id + 1
    if next_sp_index < analysis.suspension_points.len():
        # More awaits to go - transition to next state
        val next_sp = analysis.suspension_points[next_sp_index]

        # val next_future = <next_awaited_expr>
        val future_binding = Stmt(
            kind: StmtKind.Val("next_future", nil, next_sp.awaited_future),
            span: dummy_span()
        )
        body_stmts = body_stmts.push(future_binding)

        # Construct next state with live vars + next_future
        var field_names = []
        for field in variant.fields:
            if field.name != "future":
                field_names = field_names.push(field.name)
        field_names = field_names.push("value")  # Add the newly resolved value
        field_names = field_names.push("next_future")

        val next_state_name = "State{next_sp_index + 1}"
        val next_state = make_state_constructor(next_state_name, field_names)
        val return_expr = make_poll_tuple(next_state, make_pending())

        body_stmts = body_stmts.push(Stmt(
            kind: StmtKind.Expr(return_expr),
            span: dummy_span()
        ))
    else:
        # This was the last await - return the final value
        # TODO: Apply final computation from function body
        val return_expr = make_poll_tuple(
            make_state_constructor(variant.name, []),
            make_ready(Expr(kind: ExprKind.Ident("value"), span: dummy_span()))
        )

        body_stmts = body_stmts.push(Stmt(
            kind: StmtKind.Expr(return_expr),
            span: dummy_span()
        ))

    val body = Block(stmts: body_stmts, span: dummy_span())

    MatchArm(
        pattern: pattern,
        guard: nil,
        body: body
    )

fn generate_pending_arm(variant: StateVariant) -> MatchArm:
    """Generate Pending arm of poll result match.

    If the future is still pending, return the same state and Pending.

    Returns:
        case Pending:
            (State{N}(field1: field1, ...), Poll.Pending)
    """
    val pattern = Pattern(
        kind: PatternKind.EnumVariant("Pending", []),
        span: dummy_span()
    )

    # Reconstruct the same state with all fields
    var field_names = []
    for field in variant.fields:
        field_names = field_names.push(field.name)

    val same_state = make_state_constructor(variant.name, field_names)
    val return_expr = make_poll_tuple(same_state, make_pending())

    val body = Block(
        statements: [Stmt(
            kind: StmtKind.Expr(return_expr),
            span: dummy_span()
        )],
        span: dummy_span()
    )

    MatchArm(
        pattern: pattern,
        guard: nil,
        body: body
    )

# ================================================================
# AST Helper Functions
# ================================================================

fn dummy_span() -> Span:
    """Create a dummy span for generated code."""
    Span.new(0, 0, 1, 1)

fn make_poll_return_type(state_enum_name: text) -> Type:
    """Create return type: (StateEnum, Poll<T>).

    Args:
        state_enum_name: Name of state enum

    Returns:
        Tuple type (StateEnum, Poll<Inferred>)
    """
    Type(
        kind: TypeKind.Tuple([
            Type(kind: TypeKind.Named(state_enum_name), span: dummy_span()),
            Type(
                kind: TypeKind.Generic("Poll", [
                    Type(kind: TypeKind.Inferred, span: dummy_span())
                ]),
                span: dummy_span()
            )
        ]),
        span: dummy_span()
    )

fn make_state_constructor(state_name: text, field_names: [text]) -> Expr:
    """Create state constructor call: State{N}(field1: field1, ...).

    Args:
        state_name: Name of state variant
        field_names: List of field names

    Returns:
        Constructor call expression
    """
    var args = []
    for name in field_names:
        args = args.push(CallArg(
            value: Expr(kind: ExprKind.Ident(name), span: dummy_span()),
            name: name
        ))

    Expr(
        kind: ExprKind.Call(
            Expr(kind: ExprKind.Ident(state_name), span: dummy_span()),
            args
        ),
        span: dummy_span()
    )

fn make_poll_call(future_name: text, waker_name: text) -> Expr:
    """Create future.poll(waker) call.

    Args:
        future_name: Variable name of the future
        waker_name: Variable name of the waker

    Returns:
        Method call expression
    """
    Expr(
        kind: ExprKind.Call(
            Expr(
                kind: ExprKind.Field(
                    Expr(kind: ExprKind.Ident(future_name), span: dummy_span()),
                    "poll"
                ),
                span: dummy_span()
            ),
            [CallArg(
                value: Expr(kind: ExprKind.Ident(waker_name), span: dummy_span()),
                name: nil
            )]
        ),
        span: dummy_span()
    )

fn make_poll_tuple(state: Expr, poll_result: Expr) -> Expr:
    """Create tuple (state, poll_result).

    Args:
        state: State expression
        poll_result: Poll<T> expression

    Returns:
        Tuple expression
    """
    Expr(
        kind: ExprKind.Tuple([state, poll_result]),
        span: dummy_span()
    )

fn make_pending() -> Expr:
    """Create Poll.Pending expression."""
    Expr(
        kind: ExprKind.Field(
            Expr(kind: ExprKind.Ident("Poll"), span: dummy_span()),
            "Pending"
        ),
        span: dummy_span()
    )

fn make_ready(value: Expr) -> Expr:
    """Create Poll.Ready(value) expression.

    Args:
        value: Value to wrap in Ready

    Returns:
        Poll.Ready constructor call
    """
    Expr(
        kind: ExprKind.Call(
            Expr(
                kind: ExprKind.Field(
                    Expr(kind: ExprKind.Ident("Poll"), span: dummy_span()),
                    "Ready"
                ),
                span: dummy_span()
            ),
            [CallArg(value: value, name: nil)]
        ),
        span: dummy_span()
    )

fn generate_poll_doc(func_name: text, analysis: SuspensionAnalysis) -> text:
    """Generate documentation for poll function.

    Args:
        func_name: Function name
        analysis: Suspension analysis

    Returns:
        Documentation string
    """
    "Poll function for async function '{func_name}'.\n\
     Drives state machine with {analysis.suspension_points.len()} suspension points."

# ================================================================
# Poll Function Conversion to AST
# ================================================================

fn poll_function_to_ast(poll_func: PollFunction, span: Span) -> Function:
    """Convert PollFunction to AST Function node.

    Args:
        poll_func: Generated poll function
        span: Source location

    Returns:
        AST Function node ready for insertion
    """
    Function(
        name: poll_func.name,
        type_params: [],
        params: [
            Param(
                name: poll_func.state_param,
                type_: nil,  # Will be inferred
                default: nil,
                span: span
            ),
            Param(
                name: poll_func.waker_param,
                type_: nil,  # Will be inferred
                default: nil,
                span: span
            )
        ],
        return_type: poll_func.return_type,
        body: poll_func.body,
        is_async: false,
        is_static: false,
        is_public: false,  # Implementation detail
        is_method: false,
        is_mutable: false,
        is_const: false,
        is_kernel: false,
        doc_comment: poll_func.doc_comment,
        span: span
    )

# ================================================================
# Exports
# ================================================================

export PollFunction
export generate_poll_function
export poll_function_to_ast
