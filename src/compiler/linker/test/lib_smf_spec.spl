# Library SMF Test Specification
#
# This spec tests the Library SMF format functionality:
# - Creating library SMF archives
# - Reading modules from library SMF
# - Unified SMF getter interface

use std.sspec.*
use compiler.linker.lib_smf.*
use compiler.linker.lib_smf_writer.{LibSmfBuilder, create_lib_smf}
use compiler.linker.lib_smf_reader.{LibSmfReader}
use compiler.linker.smf_getter.{SmfGetter, SmfSourceType}
use app.io.{file_write, file_read, file_exists, file_delete}

# ============================================================================
# Test Helpers
# ============================================================================

fn create_dummy_smf(name: text) -> [u8]:
    """Create a dummy SMF file for testing."""
    var data: [u8] = []

    # SMF magic "SMF\0"
    data.push(83)  # S
    data.push(77)  # M
    data.push(70)  # F
    data.push(0)   # \0

    # Version 1.1
    data.push(1)   # major
    data.push(1)   # minor

    # Pad to at least 128 bytes (header size)
    while data.len() < 128:
        data.push(0)

    # Add some "code" data
    var i = 0
    while i < 100:
        data.push((name.len() + i) as u8)
        i = i + 1

    data

fn write_smf_file(path: text, data: [u8]) -> Result<(), text>:
    """Write SMF data to file."""
    var text_data = ""
    for b in data:
        val c = b as i64
        text_data = text_data + "{c}"

    file_write(path, text_data)

# ============================================================================
# LibSmfHeader Tests
# ============================================================================

describe "LibSmfHeader":
    it "creates a valid default header":
        val header = LibSmfHeader.new_default()

        expect(header.magic[0]).to_equal(76)  # L
        expect(header.magic[1]).to_equal(83)  # S
        expect(header.magic[2]).to_equal(77)  # M
        expect(header.magic[3]).to_equal(70)  # F
        expect(header.version_major).to_equal(1)
        expect(header.version_minor).to_equal(0)

    it "validates magic number correctly":
        val header = LibSmfHeader.new_default()
        expect(header.is_valid()).to_equal(true)

    it "serializes and deserializes correctly":
        val header = LibSmfHeader.new_default()
        header.module_count = 5
        header.library_hash = 123456789

        val bytes = header.to_bytes()
        expect(bytes.len()).to_equal(128)

        val parsed_result = LibSmfHeader.from_bytes(bytes)
        expect(parsed_result.is_ok()).to_equal(true)

        val parsed = parsed_result.unwrap()
        expect(parsed.module_count).to_equal(5)
        expect(parsed.library_hash).to_equal(123456789)

    it "gets version tuple":
        val header = LibSmfHeader.new_default()
        val (major, minor) = header.version()

        expect(major).to_equal(1)
        expect(minor).to_equal(0)

# ============================================================================
# ModuleIndexEntry Tests
# ============================================================================

describe "ModuleIndexEntry":
    it "creates entry with name":
        val entry = ModuleIndexEntry.new("std/io/mod", 1024, 256, 789)

        expect(entry.get_name()).to_equal("std/io/mod")
        expect(entry.offset).to_equal(1024)
        expect(entry.size).to_equal(256)
        expect(entry.hash).to_equal(789)

    it "serializes and deserializes correctly":
        val entry = ModuleIndexEntry.new("std/io/file", 2048, 512, 987654321)

        val bytes = entry.to_bytes()
        expect(bytes.len()).to_equal(128)

        val parsed_result = ModuleIndexEntry.from_bytes(bytes, 0)
        expect(parsed_result.is_ok()).to_equal(true)

        val parsed = parsed_result.unwrap()
        expect(parsed.get_name()).to_equal("std/io/file")
        expect(parsed.offset).to_equal(2048)
        expect(parsed.size).to_equal(512)

    it "handles long module names":
        val long_name = "std/collections/data_structures/trees/binary_search_tree"
        val entry = ModuleIndexEntry.new(long_name, 100, 200, 300)

        val retrieved_name = entry.get_name()
        # Name should be truncated to 63 chars (plus null terminator)
        expect(retrieved_name.len()).to_be_less_than(64)

# ============================================================================
# LibSmfBuilder Tests
# ============================================================================

describe "LibSmfBuilder":
    before_each:
        # Clean up test files
        if file_exists("test_output.lsm"):
            file_delete("test_output.lsm")

    it "creates empty builder":
        val builder = LibSmfBuilder.new()
        expect(builder.module_count()).to_equal(0)

    it "adds module from data":
        var builder = LibSmfBuilder.new()
        val smf_data = create_dummy_smf("test_mod")

        val result = builder.add_module_data("test/mod", smf_data)
        expect(result.is_ok()).to_equal(true)
        expect(builder.module_count()).to_equal(1)

    skip_it "adds module from file":
        # Create test SMF file
        val smf_data = create_dummy_smf("file_mod")
        val write_result = write_smf_file("test_mod.smf", smf_data)
        expect(write_result.is_ok()).to_equal(true)

        var builder = LibSmfBuilder.new()
        val result = builder.add_module("test/file_mod", "test_mod.smf")

        expect(result.is_ok()).to_equal(true)
        expect(builder.module_count()).to_equal(1)

        # Cleanup
        file_delete("test_mod.smf")

    skip_it "writes library file":
        var builder = LibSmfBuilder.new()
        builder.add_module_data("mod1", create_dummy_smf("mod1"))
        builder.add_module_data("mod2", create_dummy_smf("mod2"))

        val result = builder.write("test_output.lsm")
        expect(result.is_ok()).to_equal(true)
        expect(file_exists("test_output.lsm")).to_equal(true)

        # Cleanup
        file_delete("test_output.lsm")

    it "lists module names":
        var builder = LibSmfBuilder.new()
        builder.add_module_data("std/io", create_dummy_smf("io"))
        builder.add_module_data("std/file", create_dummy_smf("file"))

        val names = builder.module_names()
        expect(names.len()).to_equal(2)
        expect(names.contains("std/io")).to_equal(true)
        expect(names.contains("std/file")).to_equal(true)

# ============================================================================
# LibSmfReader Tests
# ============================================================================

describe "LibSmfReader":
    skip_it "opens library file":
        # First create a library
        var builder = LibSmfBuilder.new()
        builder.add_module_data("test/mod1", create_dummy_smf("mod1"))
        builder.add_module_data("test/mod2", create_dummy_smf("mod2"))
        builder.write("test_lib.lsm")

        # Now open it
        val reader_result = LibSmfReader.open("test_lib.lsm")
        expect(reader_result.is_ok()).to_equal(true)

        val reader = reader_result.unwrap()
        expect(reader.module_count()).to_equal(2)

        reader.close()
        file_delete("test_lib.lsm")

    skip_it "lists modules":
        # Create and open library
        var builder = LibSmfBuilder.new()
        builder.add_module_data("mod1", create_dummy_smf("mod1"))
        builder.add_module_data("mod2", create_dummy_smf("mod2"))
        builder.write("test_lib.lsm")

        val reader = LibSmfReader.open("test_lib.lsm").unwrap()
        val modules = reader.list_modules()

        expect(modules.len()).to_equal(2)
        expect(modules.contains("mod1")).to_equal(true)
        expect(modules.contains("mod2")).to_equal(true)

        reader.close()
        file_delete("test_lib.lsm")

    skip_it "checks module existence":
        # Create library
        var builder = LibSmfBuilder.new()
        builder.add_module_data("exists", create_dummy_smf("exists"))
        builder.write("test_lib.lsm")

        val reader = LibSmfReader.open("test_lib.lsm").unwrap()

        expect(reader.has_module("exists")).to_equal(true)
        expect(reader.has_module("not_exists")).to_equal(false)

        reader.close()
        file_delete("test_lib.lsm")

    skip_it "gets module data":
        # Create library
        val orig_data = create_dummy_smf("test_data")
        var builder = LibSmfBuilder.new()
        builder.add_module_data("test/data", orig_data)
        builder.write("test_lib.lsm")

        val reader = LibSmfReader.open("test_lib.lsm").unwrap()
        val data_result = reader.get_module("test/data")

        expect(data_result.is_ok()).to_equal(true)

        val data = data_result.unwrap()
        expect(data.len()).to_equal(orig_data.len())

        reader.close()
        file_delete("test_lib.lsm")

# ============================================================================
# SmfGetter Tests
# ============================================================================

describe "SmfGetter":
    it "creates new getter":
        val getter = SmfGetter.new()
        expect(getter.list_modules().len()).to_equal(0)

    it "adds search path":
        var getter = SmfGetter.new()
        getter.add_search_path("/usr/lib/simple")
        # No direct way to verify, but should not error

    skip_it "adds library":
        # Create test library
        var builder = LibSmfBuilder.new()
        builder.add_module_data("lib/mod1", create_dummy_smf("mod1"))
        builder.write("test_getter.lsm")

        var getter = SmfGetter.new()
        val result = getter.add_library("test_getter.lsm")

        expect(result.is_ok()).to_equal(true)
        expect(getter.has_module("lib/mod1")).to_equal(true)

        getter.close()
        file_delete("test_getter.lsm")

    skip_it "gets module data from library":
        # Create library
        val orig_data = create_dummy_smf("getter_test")
        var builder = LibSmfBuilder.new()
        builder.add_module_data("test/getter", orig_data)
        builder.write("test_getter.lsm")

        var getter = SmfGetter.new()
        getter.add_library("test_getter.lsm")

        val data_result = getter.get("test/getter")
        expect(data_result.is_ok()).to_equal(true)

        val data = data_result.unwrap()
        expect(data.len()).to_equal(orig_data.len())

        getter.close()
        file_delete("test_getter.lsm")

    it "lists all modules":
        var getter = SmfGetter.new()
        # Without adding any modules, list should be empty
        val modules = getter.list_modules()
        expect(modules.len()).to_equal(0)

# ============================================================================
# FNV-1a Hash Tests
# ============================================================================

describe "fnv1a_hash":
    it "hashes empty data":
        val hash = fnv1a_hash([])
        # Should equal FNV offset basis
        expect(hash).to_be_greater_than(0)

    it "hashes non-empty data":
        val data = [1, 2, 3, 4, 5]
        val hash = fnv1a_hash(data)
        expect(hash).to_be_greater_than(0)

    it "produces different hashes for different data":
        val hash1 = fnv1a_hash([1, 2, 3])
        val hash2 = fnv1a_hash([4, 5, 6])
        # Hashes should be different (very high probability)
        expect(hash1 != hash2).to_equal(true)

    it "is deterministic":
        val data = [10, 20, 30, 40]
        val hash1 = fnv1a_hash(data)
        val hash2 = fnv1a_hash(data)
        expect(hash1).to_equal(hash2)
