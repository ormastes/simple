# SMF Reader - Simple Module Format file reading.
#
# This module provides SMF file reading capabilities using:
# - Rust FFI for binary parsing (performance-critical)
# - Simple for high-level logic and metadata interpretation
#
# The SmfReader implements the SmfReader trait from obj_taker.spl.

use ..monomorphize.note_sdn.*
use .obj_taker (SmfSymbol, SymbolType, SymbolBinding)
use .smf_enums (Platform, Arch, CompressionType)

# ============================================================================
# Rust FFI Declarations
# ============================================================================
#
# These extern functions are implemented in src/rust/loader/src/smf/ffi.rs
# They handle low-level binary parsing for performance.

extern class SmfReaderFfi:
    """Rust FFI handle for SMF file reading."""

    static fn open(path: text) -> Result<SmfReaderFfi, text>:
        """Open an SMF file for reading."""
        ...

    fn read_header() -> SmfHeaderRaw:
        """Read the SMF header (from trailer at EOF-128 for v1.1)."""
        ...

    fn read_section(index: i32) -> [u8]:
        """Read section data by index."""
        ...

    fn read_symbol_table() -> [SmfSymbolRaw]:
        """Read the symbol table."""
        ...

    fn read_string_table() -> [u8]:
        """Read the string table."""
        ...

    fn close():
        """Close the file handle."""
        ...

# ============================================================================
# Raw Structures (from FFI)
# ============================================================================

struct SmfHeaderRaw:
    """Raw SMF header as returned from Rust FFI."""
    magic: [u8]           # "SMF\0"
    version_major: u8
    version_minor: u8
    platform: u8
    arch: u8
    flags: u32
    compression: u8
    section_count: u32
    section_table_offset: u64
    symbol_table_offset: u64
    symbol_count: u32
    exported_count: u32
    entry_point: u64
    stub_size: u32
    smf_data_offset: u32
    module_hash: u64
    source_hash: u64
    app_type: u8

struct SmfSymbolRaw:
    """Raw symbol as returned from Rust FFI."""
    name_offset: u32
    name_hash: u32
    sym_type: u8
    binding: u8
    visibility: u8
    flags: u8
    value: u64
    size: u64
    type_id: u32
    version: u32
    template_param_count: u8
    template_offset: u64

struct SmfSectionRaw:
    """Raw section as returned from Rust FFI."""
    section_type: u8
    flags: u8
    offset: u64
    size: u64
    name: [u8]

# ============================================================================
# High-Level Structures
# ============================================================================

struct SmfHeader:
    """Parsed SMF header."""
    version: (u8, u8)     # (major, minor)
    platform: Platform
    arch: Arch
    flags: SmfFlags
    section_count: i32
    symbol_count: i32
    entry_point: i64
    has_templates: bool
    has_note_sdn: bool
    compression: CompressionType

struct SmfFlags:
    executable: bool
    reloadable: bool
    debug_info: bool
    pic: bool
    has_stub: bool

impl SmfHeader:
    static fn from_raw(raw: SmfHeaderRaw) -> SmfHeader:
        """Convert raw header to parsed header."""
        SmfHeader(
            version: (raw.version_major, raw.version_minor),
            platform: parse_platform(raw.platform),
            arch: parse_arch(raw.arch),
            flags: parse_flags(raw.flags),
            section_count: raw.section_count as i32,
            symbol_count: raw.symbol_count as i32,
            entry_point: raw.entry_point as i64,
            has_templates: (raw.flags & 0x10) != 0,
            has_note_sdn: (raw.flags & 0x20) != 0,
            compression: parse_compression(raw.compression)
        )

    fn is_v1_1() -> bool:
        """Check if this is v1.1 format (trailer-based header)."""
        val (major, minor) = self.version
        major >= 1 and minor >= 1

# ============================================================================
# SMF Reader Implementation
# ============================================================================

struct SmfReaderImpl:
    """High-level SMF reader that implements SmfReader trait."""
    ffi: SmfReaderFfi
    file_path: text
    header: SmfHeader
    symbols: Dict<text, SmfSymbol>
    string_table: [u8]
    sections: [SmfSectionRaw]
    note_sdn_cache: NoteSdnMetadata?

impl SmfReaderImpl:
    static fn open(path: text) -> Result<SmfReaderImpl, text>:
        """Open an SMF file and parse headers."""
        # Open via Rust FFI
        val ffi = SmfReaderFfi.open(path)?

        # Read header
        val raw_header = ffi.read_header()
        val header = SmfHeader.from_raw(raw_header)

        # Read string table for symbol name resolution
        val string_table = ffi.read_string_table()

        # Read and parse symbol table
        val raw_symbols = ffi.read_symbol_table()
        var symbols: Dict<text, SmfSymbol> = {}

        for raw in raw_symbols:
            val name = read_string_from_table(string_table, raw.name_offset)
            val symbol = SmfSymbol(
                name: name,
                section_index: 0,  # TODO: Extract from raw
                offset: raw.value as i64,
                size: raw.size as i64,
                ty: parse_symbol_type(raw.sym_type),
                binding: parse_symbol_binding(raw.binding),
                is_generic_template: (raw.flags & 0x10) != 0,
                template_param_count: raw.template_param_count as i32,
                template_offset: raw.template_offset as i64
            )
            symbols[name] = symbol

        Ok(SmfReaderImpl(
            ffi: ffi,
            file_path: path,
            header: header,
            symbols: symbols,
            string_table: string_table,
            sections: [],
            note_sdn_cache: None
        ))

    fn path() -> text:
        """Get the file path."""
        self.file_path

    fn lookup_symbol(name: text) -> Result<SmfSymbol, text>:
        """Look up a symbol by name."""
        if self.symbols.contains_key(name):
            Ok(self.symbols[name])
        else:
            Err("Symbol not found: {name}")

    fn read_code(symbol: SmfSymbol) -> Result<[u8], text>:
        """Read code bytes for a symbol."""
        # Find the code section
        val section_data = self.ffi.read_section(symbol.section_index)

        # Extract symbol's code
        val start = symbol.offset as i32
        val end = start + symbol.size as i32

        if end > section_data.len():
            return Err("Symbol {symbol.name} extends beyond section")

        Ok(section_data[start..end])

    fn read_template_section(symbol: SmfSymbol) -> Result<[u8], text>:
        """Read template code section for a generic symbol."""
        if not symbol.is_generic_template:
            return Err("Symbol {symbol.name} is not a generic template")

        # Find TemplateCode section (type 12)
        val template_section_index = self.find_section_by_type(12)
        if template_section_index < 0:
            return Err("No TemplateCode section found")

        val section_data = self.ffi.read_section(template_section_index)

        # Extract template at offset
        val start = symbol.template_offset as i32
        if start >= section_data.len():
            return Err("Template offset out of bounds")

        # Template format: length prefix + data
        # TODO: Implement proper template parsing
        Ok(section_data[start..])

    me read_note_sdn() -> Result<NoteSdnMetadata, text>:
        """Read note.sdn metadata section."""
        # Check cache
        if self.note_sdn_cache.?:
            return Ok(self.note_sdn_cache.unwrap())

        # Find note.sdn section (type 13 with name "note.sdn")
        val section_index = self.find_note_sdn_section()
        if section_index < 0:
            return Err("No note.sdn section found")

        val section_data = self.ffi.read_section(section_index)

        # Parse SDN format
        val sdn_text = bytes_to_string(section_data)
        val metadata = parse_note_sdn(sdn_text)?

        # Cache result
        self.note_sdn_cache = Some(metadata)

        Ok(metadata)

    fn find_section_by_type(section_type: i32) -> i32:
        """Find section index by type."""
        # TODO: Implement section table reading
        # For now, use hardcoded indices based on convention
        match section_type:
            case 1: 0   # Code
            case 2: 1   # Data
            case 12: 2  # TemplateCode
            case 13: 3  # TemplateMeta/note.sdn
            case _: -1

    fn find_note_sdn_section() -> i32:
        """Find the note.sdn section index."""
        # note.sdn uses TemplateMeta section type (13) with name "note.sdn"
        # and size=0 (zero-size trick)
        self.find_section_by_type(13)

    fn exported_symbols() -> [SmfSymbol]:
        """Get all exported (global/weak) symbols."""
        self.symbols.values().filter(\s: s.is_exported())

    fn template_symbols() -> [SmfSymbol]:
        """Get all generic template symbols."""
        self.symbols.values().filter(\s: s.is_generic_template)

    fn close():
        """Close the reader and release resources."""
        self.ffi.close()

# ============================================================================
# Helper Functions
# ============================================================================

fn parse_platform(p: u8) -> Platform:
    Platform.from_u8(p)

fn parse_arch(a: u8) -> Arch:
    Arch.from_u8(a)

fn parse_compression(c: u8) -> CompressionType:
    CompressionType.from_u8(c)

fn parse_flags(f: u32) -> SmfFlags:
    SmfFlags(
        executable: (f & 0x01) != 0,
        reloadable: (f & 0x02) != 0,
        debug_info: (f & 0x04) != 0,
        pic: (f & 0x08) != 0,
        has_stub: (f & 0x10) != 0
    )

fn parse_symbol_type(t: u8) -> SymbolType:
    match t:
        case 0: SymbolType.Function
        case 1: SymbolType.Data
        case 2: SymbolType.Type
        case 3: SymbolType.Trait
        case 4: SymbolType.ActorSymbol
        case 5: SymbolType.Constant
        case _: SymbolType.Unknown

fn parse_symbol_binding(b: u8) -> SymbolBinding:
    match b:
        case 0: SymbolBinding.Local
        case 1: SymbolBinding.Global
        case 2: SymbolBinding.Weak
        case _: SymbolBinding.Local

fn read_string_from_table(table: [u8], offset: u32) -> text:
    """Read null-terminated string from string table."""
    var chars = []
    var i = offset as i32

    while i < table.len() and table[i] != 0:
        chars.push(char_from_byte(table[i]))
        i = i + 1

    chars.join("")

fn char_from_byte(b: u8) -> text:
    """Convert byte to single-character string."""
    # TODO: Implement proper byte-to-char conversion
    "{b as char}"

fn bytes_to_string(bytes: [u8]) -> text:
    """Convert byte array to string."""
    var chars = []
    for b in bytes:
        if b == 0:
            break
        chars.push(char_from_byte(b))
    chars.join("")

fn parse_note_sdn(sdn_text: text) -> Result<NoteSdnMetadata, text>:
    """Parse note.sdn SDN format text."""
    # TODO: Implement proper SDN parsing
    # For now, return empty metadata
    Ok(NoteSdnMetadata.new())

# ============================================================================
# Exports
# ============================================================================

export SmfReaderImpl
export SmfReaderFfi
export SmfHeader
export SmfHeaderRaw
export SmfSymbolRaw
export SmfSectionRaw
export Platform
export Arch
export CompressionType
export SmfFlags
