# Library SMF Writer - Create library SMF archives
#
# This module provides functionality to bundle multiple SMF modules into
# a single library SMF (.lsm) file with a location index.
#
# Usage:
#   val builder = LibSmfBuilder()
#   builder.add_module("std/io/mod", "path/to/io_mod.smf")
#   builder.add_module("std/io/file", "path/to/file.smf")
#   builder.write("libstd_io.lsm")

use app.io.{file_write, file_read, file_exists}
use compiler.linker.lib_smf.{LibSmfHeader, ModuleIndexEntry, LSMF_MAGIC, LSMF_HEADER_SIZE, LSMF_INDEX_ENTRY_SIZE, fnv1a_hash}

# ============================================================================
# Lib SMF Builder
# ============================================================================

"""Builder for creating library SMF files.

Example:
    val builder = LibSmfBuilder()
    builder.add_module("std/io/mod", "io_mod.smf")
    builder.add_module("std/io/file", "file.smf")
    builder.write("libstd_io.lsm")
"""
struct LibSmfBuilder:
    modules: [ModuleEntry]
    verbose: bool

struct ModuleEntry:
    name: text               # Module path (e.g., "std/io/mod")
    smf_path: text           # Path to SMF file
    data: [u8]               # SMF file data (cached)
    hash: u64                # FNV-1a hash of data

impl LibSmfBuilder:
    """Create a new library SMF builder."""
    static fn new() -> LibSmfBuilder:
        LibSmfBuilder(
            modules: [],
            verbose: false
        )

    """Enable verbose output."""
    me set_verbose(verbose: bool):
        self.verbose = verbose

    """Add a module to the library.

    Args:
        name: Module path (e.g., "std/io/mod")
        smf_path: Path to SMF file

    Returns:
        Result indicating success or error
    """
    me add_module(name: text, smf_path: text) -> Result<(), text>:
        # Check if file exists
        if not file_exists(smf_path):
            return Err("SMF file not found: {smf_path}")

        # Read SMF data
        val data_result = file_read(smf_path)
        if data_result.is_err():
            return Err("Failed to read SMF file: {smf_path}")

        val data_text = data_result.unwrap()
        val data = text_to_bytes(data_text)

        # Calculate hash
        val hash = fnv1a_hash(data)

        # Add to modules list
        val entry = ModuleEntry(
            name: name,
            smf_path: smf_path,
            data: data,
            hash: hash
        )
        self.modules.push(entry)

        if self.verbose:
            print "[lib-smf-writer] Added module: {name} ({data.len()} bytes, hash: {hash})"

        Ok(())

    """Add a module from in-memory data.

    Args:
        name: Module path
        data: SMF file data

    Returns:
        Result indicating success or error
    """
    me add_module_data(name: text, data: [u8]) -> Result<(), text>:
        # Calculate hash
        val hash = fnv1a_hash(data)

        # Add to modules list
        val entry = ModuleEntry(
            name: name,
            smf_path: "",
            data: data,
            hash: hash
        )
        self.modules.push(entry)

        if self.verbose:
            print "[lib-smf-writer] Added module: {name} ({data.len()} bytes)"

        Ok(())

    """Write the library SMF file.

    Args:
        output_path: Path to output .lsm file

    Returns:
        Result indicating success or error
    """
    fn write(output_path: text) -> Result<(), text>:
        if self.modules.len() == 0:
            return Err("No modules to write")

        if self.verbose:
            print "[lib-smf-writer] Writing library with {self.modules.len()} modules to {output_path}"

        # Build index entries
        var index_entries: [ModuleIndexEntry] = []
        var current_offset = LSMF_HEADER_SIZE + (LSMF_INDEX_ENTRY_SIZE * (self.modules.len() as i64))

        for entry in self.modules:
            val index_entry = ModuleIndexEntry.new(
                entry.name,
                current_offset as u64,
                entry.data.len() as u64,
                entry.hash
            )
            index_entries.push(index_entry)
            current_offset = current_offset + entry.data.len()

        # Build header
        var header = LibSmfHeader.new_default()
        header.module_count = self.modules.len() as u32
        header.index_offset = LSMF_HEADER_SIZE as u64
        header.index_size = (LSMF_INDEX_ENTRY_SIZE * (self.modules.len() as i64)) as u64
        header.data_offset = (LSMF_HEADER_SIZE + header.index_size as i64) as u64

        # Calculate index hash
        var index_bytes: [u8] = []
        for entry in index_entries:
            index_bytes = index_bytes + (entry.to_bytes())
        header.index_hash = fnv1a_hash(index_bytes)

        # Build complete file data
        var file_data: [u8] = []

        # 1. Header
        file_data = file_data + (header.to_bytes())

        # 2. Index table
        file_data = file_data + (index_bytes)

        # 3. Module data
        for entry in self.modules:
            file_data = file_data + (entry.data)

        # Calculate library hash (excluding header)
        var content_for_hash: [u8] = []
        content_for_hash = content_for_hash + (index_bytes)
        for entry in self.modules:
            content_for_hash = content_for_hash + (entry.data)
        header.library_hash = fnv1a_hash(content_for_hash)

        # Update header with library hash
        val header_bytes = header.to_bytes()
        var i = 0
        while i < header_bytes.len():
            file_data[i] = header_bytes[i]
            i = i + 1

        # Write to file
        val file_text = bytes_to_text(file_data)
        val write_result = file_write(output_path, file_text)
        if write_result.is_err():
            return Err("Failed to write library file: {output_path}")

        if self.verbose:
            print "[lib-smf-writer] Wrote {file_data.len()} bytes to {output_path}"

        Ok(())

    """Get number of modules in the library."""
    fn module_count() -> i64:
        self.modules.len()

    """Get module names."""
    fn module_names() -> [text]:
        var names: [text] = []
        for entry in self.modules:
            names.push(entry.name)
        names

# ============================================================================
# Helper Functions
# ============================================================================

"""Convert text to bytes."""
fn text_to_bytes(text: text) -> [u8]:
    var bytes: [u8] = []
    var i = 0
    while i < text.len():
        bytes.push(text[i] as u8)
        i = i + 1
    bytes

"""Convert bytes to text."""
fn bytes_to_text(bytes: [u8]) -> text:
    var chars: [text] = []
    for b in bytes:
        val c = b as i64
        chars.push("{c}")
    chars.join("")

# ============================================================================
# Convenience Functions
# ============================================================================

"""Create a library SMF from a list of SMF files.

Args:
    modules: Array of (module_name, smf_path) tuples
    output_path: Path to output .lsm file
    verbose: Enable verbose output

Returns:
    Result indicating success or error

Example:
    val modules = [
        ("std/io/mod", "io_mod.smf"),
        ("std/io/file", "file.smf")
    ]
    create_lib_smf(modules, "libstd_io.lsm", true)
"""
fn create_lib_smf(modules: [(text, text)], output_path: text, verbose: bool) -> Result<(), text>:
    var builder = LibSmfBuilder.new()
    builder.set_verbose(verbose)

    for module_info in modules:
        val (name, smf_path) = module_info
        val add_result = builder.add_module(name, smf_path)
        if add_result.is_err():
            return add_result

    builder.write(output_path)

# ============================================================================
# Exports
# ============================================================================

export LibSmfBuilder
export ModuleEntry
export create_lib_smf
