# Library SMF Writer - Create library SMF archives
#
# This module provides functionality to bundle multiple SMF modules into
# a single library SMF (.lsm) file with a location index.
#
# Usage:
#   val builder = LibSmfBuilder()
#   builder.add_module("std/io/mod", "path/to/io_mod.smf")
#   builder.add_module("std/io/file", "path/to/file.smf")
#   builder.write("libstd_io.lsm")

use app.io.{file_write, file_read, file_exists}
use compiler.linker.lib_smf.{LibSmfHeader, ModuleIndexEntry, LSMF_MAGIC, LSMF_HEADER_SIZE, LSMF_INDEX_ENTRY_SIZE, fnv1a_hash}

# ============================================================================
# Lib SMF Builder
# ============================================================================

"""Builder for creating library SMF files.

Example:
    val builder = LibSmfBuilder()
    builder.add_module("std/io/mod", "io_mod.smf")
    builder.add_module("std/io/file", "file.smf")
    builder.write("libstd_io.lsm")
"""
struct LibSmfBuilder:
    modules: [ModuleEntry]
    verbose: bool

struct ModuleEntry:
    name: text               # Module path (e.g., "std/io/mod")
    smf_path: text           # Path to SMF file
    data: [u8]               # SMF file data (cached)
    hash: u64                # FNV-1a hash of SMF data
    obj_path: text           # Path to object file (empty if none)
    obj_data: [u8]           # Object file data (empty if none)
    obj_hash: u64            # FNV-1a hash of object data (0 if none)

impl LibSmfBuilder:
    """Create a new library SMF builder."""
    static fn new() -> LibSmfBuilder:
        LibSmfBuilder(
            modules: [],
            verbose: false
        )

    """Enable verbose output."""
    me set_verbose(verbose: bool):
        self.verbose = verbose

    """Add a module to the library (SMF only, no object file).

    Args:
        name: Module path (e.g., "std/io/mod")
        smf_path: Path to SMF file

    Returns:
        Result indicating success or error
    """
    me add_module(name: text, smf_path: text) -> Result<(), text>:
        # Check if file exists
        if not file_exists(smf_path):
            return Err("SMF file not found: {smf_path}")

        # Read SMF data
        val data_result = file_read(smf_path)
        if data_result.is_err():
            return Err("Failed to read SMF file: {smf_path}")

        val data_text = data_result.unwrap()
        val data = text_to_bytes(data_text)

        # Calculate hash
        val hash = fnv1a_hash(data)

        # Add to modules list
        val entry = ModuleEntry(
            name: name,
            smf_path: smf_path,
            data: data,
            hash: hash,
            obj_path: "",
            obj_data: [],
            obj_hash: 0
        )
        self.modules.push(entry)

        if self.verbose:
            print "[lib-smf-writer] Added module: {name} ({data.len()} bytes, hash: {hash})"

        Ok(())

    """Add a module with both SMF and object file.

    Args:
        name: Module path (e.g., "std/io/mod")
        smf_path: Path to SMF file
        obj_path: Path to object file (.o)

    Returns:
        Result indicating success or error
    """
    me add_module_with_object(
        name: text,
        smf_path: text,
        obj_path: text
    ) -> Result<(), text>:
        # Check if SMF file exists
        if not file_exists(smf_path):
            return Err("SMF file not found: {smf_path}")

        # Check if object file exists
        if not file_exists(obj_path):
            return Err("Object file not found: {obj_path}")

        # Read SMF data
        val smf_result = file_read(smf_path)
        if smf_result.is_err():
            return Err("Failed to read SMF file: {smf_path}")

        val smf_text = smf_result.unwrap()
        val smf_data = text_to_bytes(smf_text)
        val smf_hash = fnv1a_hash(smf_data)

        # Read object data
        val obj_result = file_read(obj_path)
        if obj_result.is_err():
            return Err("Failed to read object file: {obj_path}")

        val obj_text = obj_result.unwrap()
        val obj_data = text_to_bytes(obj_text)
        val obj_hash = fnv1a_hash(obj_data)

        # Add to modules list
        val entry = ModuleEntry(
            name: name,
            smf_path: smf_path,
            data: smf_data,
            hash: smf_hash,
            obj_path: obj_path,
            obj_data: obj_data,
            obj_hash: obj_hash
        )
        self.modules.push(entry)

        if self.verbose:
            print "[lib-smf-writer] Added module with object: {name}"
            print "[lib-smf-writer]   SMF: {smf_data.len()} bytes, hash: {smf_hash}"
            print "[lib-smf-writer]   OBJ: {obj_data.len()} bytes, hash: {obj_hash}"

        Ok(())

    """Add a module from in-memory data (SMF only).

    Args:
        name: Module path
        data: SMF file data

    Returns:
        Result indicating success or error
    """
    me add_module_data(name: text, data: [u8]) -> Result<(), text>:
        # Calculate hash
        val hash = fnv1a_hash(data)

        # Add to modules list
        val entry = ModuleEntry(
            name: name,
            smf_path: "",
            data: data,
            hash: hash,
            obj_path: "",
            obj_data: [],
            obj_hash: 0
        )
        self.modules.push(entry)

        if self.verbose:
            print "[lib-smf-writer] Added module: {name} ({data.len()} bytes)"

        Ok(())

    """Add a module from in-memory data with object file.

    Args:
        name: Module path
        smf_data: SMF file data
        obj_data: Object file data

    Returns:
        Result indicating success or error
    """
    me add_module_data_with_object(
        name: text,
        smf_data: [u8],
        obj_data: [u8]
    ) -> Result<(), text>:
        # Calculate hashes
        val smf_hash = fnv1a_hash(smf_data)
        val obj_hash = fnv1a_hash(obj_data)

        # Add to modules list
        val entry = ModuleEntry(
            name: name,
            smf_path: "",
            data: smf_data,
            hash: smf_hash,
            obj_path: "",
            obj_data: obj_data,
            obj_hash: obj_hash
        )
        self.modules.push(entry)

        if self.verbose:
            print "[lib-smf-writer] Added module with object: {name}"
            print "[lib-smf-writer]   SMF: {smf_data.len()} bytes"
            print "[lib-smf-writer]   OBJ: {obj_data.len()} bytes"

        Ok(())

    """Write the library SMF file.

    Args:
        output_path: Path to output .lsm file

    Returns:
        Result indicating success or error
    """
    fn write(output_path: text) -> Result<(), text>:
        if self.modules.len() == 0:
            return Err("No modules to write")

        if self.verbose:
            print "[lib-smf-writer] Writing library with {self.modules.len()} modules to {output_path}"

        # Build index entries and calculate offsets
        var index_entries: [ModuleIndexEntry] = []
        var current_offset = LSMF_HEADER_SIZE + (LSMF_INDEX_ENTRY_SIZE * (self.modules.len() as i64))

        for entry in self.modules:
            val smf_offset = current_offset as u64
            val smf_size = entry.data.len() as u64
            val obj_offset_val = if entry.obj_data.len() > 0:
                (current_offset + entry.data.len()) as u64
            else:
                0 as u64
            val obj_size_val = entry.obj_data.len() as u64

            val index_entry = if entry.obj_data.len() > 0:
                ModuleIndexEntry.new_with_object(
                    entry.name,
                    smf_offset,
                    smf_size,
                    entry.hash,
                    obj_offset_val,
                    obj_size_val,
                    entry.obj_hash
                )
            else:
                ModuleIndexEntry.new(
                    entry.name,
                    smf_offset,
                    smf_size,
                    entry.hash
                )

            index_entries.push(index_entry)
            current_offset = current_offset + entry.data.len() + entry.obj_data.len()

        # Build header
        var header = LibSmfHeader.new_default()
        header.module_count = self.modules.len() as u32
        header.index_offset = LSMF_HEADER_SIZE as u64
        header.index_size = (LSMF_INDEX_ENTRY_SIZE * (self.modules.len() as i64)) as u64
        header.data_offset = (LSMF_HEADER_SIZE + header.index_size as i64) as u64

        # Calculate index hash
        var index_bytes: [u8] = []
        for entry in index_entries:
            index_bytes = index_bytes + (entry.to_bytes())
        header.index_hash = fnv1a_hash(index_bytes)

        # Build complete file data
        var file_data: [u8] = []

        # 1. Header
        file_data = file_data + (header.to_bytes())

        # 2. Index table
        file_data = file_data + (index_bytes)

        # 3. Module data (SMF + object files)
        for entry in self.modules:
            file_data = file_data + (entry.data)
            if entry.obj_data.len() > 0:
                file_data = file_data + (entry.obj_data)

        # Calculate library hash (excluding header)
        var content_for_hash: [u8] = []
        content_for_hash = content_for_hash + (index_bytes)
        for entry in self.modules:
            content_for_hash = content_for_hash + (entry.data)
            if entry.obj_data.len() > 0:
                content_for_hash = content_for_hash + (entry.obj_data)
        header.library_hash = fnv1a_hash(content_for_hash)

        # Update header with library hash
        val header_bytes = header.to_bytes()
        var i = 0
        while i < header_bytes.len():
            file_data[i] = header_bytes[i]
            i = i + 1

        # Write to file
        val file_text = bytes_to_text(file_data)
        val write_result = file_write(output_path, file_text)
        if write_result.is_err():
            return Err("Failed to write library file: {output_path}")

        if self.verbose:
            val obj_count = self.count_objects()
            print "[lib-smf-writer] Wrote {file_data.len()} bytes to {output_path}"
            print "[lib-smf-writer]   {self.modules.len()} modules, {obj_count} with object files"

        Ok(())

    """Count how many modules have object files."""
    fn count_objects() -> i64:
        var count = 0
        for entry in self.modules:
            if entry.obj_data.len() > 0:
                count = count + 1
        count

    """Get number of modules in the library."""
    fn module_count() -> i64:
        self.modules.len()

    """Get module names."""
    fn module_names() -> [text]:
        var names: [text] = []
        for entry in self.modules:
            names.push(entry.name)
        names

# ============================================================================
# Helper Functions
# ============================================================================

"""Convert text to bytes."""
fn text_to_bytes(text: text) -> [u8]:
    var bytes: [u8] = []
    var i = 0
    while i < text.len():
        bytes.push(text[i] as u8)
        i = i + 1
    bytes

"""Convert bytes to text."""
fn bytes_to_text(bytes: [u8]) -> text:
    var chars: [text] = []
    for b in bytes:
        val c = b as i64
        chars.push("{c}")
    chars.join("")

# ============================================================================
# Convenience Functions
# ============================================================================

"""Create a library SMF from a list of SMF files.

Args:
    modules: Array of (module_name, smf_path) tuples
    output_path: Path to output .lsm file
    verbose: Enable verbose output

Returns:
    Result indicating success or error

Example:
    val modules = [
        ("std/io/mod", "io_mod.smf"),
        ("std/io/file", "file.smf")
    ]
    create_lib_smf(modules, "libstd_io.lsm", true)
"""
fn create_lib_smf(modules: [(text, text)], output_path: text, verbose: bool) -> Result<(), text>:
    var builder = LibSmfBuilder.new()
    builder.set_verbose(verbose)

    for module_info in modules:
        val (name, smf_path) = module_info
        val add_result = builder.add_module(name, smf_path)
        if add_result.is_err():
            return add_result

    builder.write(output_path)

# ============================================================================
# Exports
# ============================================================================

export LibSmfBuilder
export ModuleEntry
export create_lib_smf
