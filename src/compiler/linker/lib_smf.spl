# Library SMF Format - Container for multiple SMF modules
#
# This module defines the Library SMF (.lsm) format, which bundles multiple
# SMF modules into a single archive file with a location index.
#
# Format Layout:
# ┌────────────────────────────────┐
# │  Lib SMF Header (128 bytes)    │  Magic, version, module count
# ├────────────────────────────────┤
# │  Module Index Table            │  Array of ModuleIndexEntry
# │  (128 bytes × module_count)    │  Each entry: name, offset, size, hash
# ├────────────────────────────────┤
# │  Module 1 SMF Data             │  Complete SMF file data
# ├────────────────────────────────┤
# │  Module 2 SMF Data             │  Complete SMF file data
# ├────────────────────────────────┤
# │  ...                           │
# ├────────────────────────────────┤
# │  Module N SMF Data             │  Complete SMF file data
# └────────────────────────────────┘
#
# Benefits:
# - Single file deployment for libraries
# - Fast random access via index
# - Reduced file system overhead
# - Atomic library updates

use app.io.{file_write, file_read, file_exists}

# ============================================================================
# Constants
# ============================================================================

val LSMF_MAGIC: [u8] = [76, 83, 77, 70]  # "LSMF" (Library SMF)
val LSMF_HEADER_SIZE: i64 = 128
val LSMF_INDEX_ENTRY_SIZE: i64 = 128
val LSMF_VERSION_MAJOR: u8 = 1
val LSMF_VERSION_MINOR: u8 = 0

# ============================================================================
# Lib SMF Header
# ============================================================================

# Library SMF header structure (128 bytes).
# The header is at the beginning of the file and contains:
# - Magic number, version, module count, index metadata
struct LibSmfHeader:
    # Identification (8 bytes)
    magic: [u8]              # Magic number "LSMF" (4 bytes)
    version_major: u8        # Major version (1)
    version_minor: u8        # Minor version (0)
    reserved1: [u8]          # Reserved (2 bytes)

    # Metadata (24 bytes)
    module_count: u32        # Number of modules in library
    index_offset: u64        # Offset to index table (always 128)
    index_size: u64          # Size of index table in bytes
    data_offset: u64         # Offset where module data begins

    # Hashing (16 bytes)
    library_hash: u64        # Hash of entire library content
    index_hash: u64          # Hash of index table

    # Reserved (80 bytes) - padding to 128 bytes
    reserved2: [u8]

impl LibSmfHeader:
    # Create a new library SMF header with defaults.
    static fn new_default() -> LibSmfHeader:
        LibSmfHeader(
            magic: LSMF_MAGIC,
            version_major: LSMF_VERSION_MAJOR,
            version_minor: LSMF_VERSION_MINOR,
            reserved1: [0, 0],
            module_count: 0,
            index_offset: LSMF_HEADER_SIZE as u64,
            index_size: 0,
            data_offset: 0,
            library_hash: 0,
            index_hash: 0,
            reserved2: [
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
            ]
        )

    # Check if magic number is valid.
    fn is_valid() -> bool:
        val check1 = self.magic[0] == 76 and self.magic[1] == 83
        val check2 = self.magic[2] == 77 and self.magic[3] == 70
        check1 and check2

    # Get version as (major, minor) tuple.
    fn version() -> (u8, u8):
        (self.version_major, self.version_minor)

    # Serialize header to bytes (exactly 128 bytes).
    fn to_bytes() -> [u8]:
        var bytes: [u8] = []

        # Identification (8 bytes)
        bytes = bytes + (self.magic)
        bytes.push(self.version_major)
        bytes.push(self.version_minor)
        bytes = bytes + (self.reserved1)

        # Metadata (24 bytes)
        bytes = bytes + (u32_to_bytes(self.module_count))
        bytes = bytes + (u64_to_bytes(self.index_offset))
        bytes = bytes + (u64_to_bytes(self.index_size))
        bytes = bytes + (u64_to_bytes(self.data_offset))

        # Hashing (16 bytes)
        bytes = bytes + (u64_to_bytes(self.library_hash))
        bytes = bytes + (u64_to_bytes(self.index_hash))

        # Reserved (80 bytes)
        bytes = bytes + (self.reserved2)

        bytes

    # Deserialize header from bytes.
    static fn from_bytes(bytes: [u8]) -> Result<LibSmfHeader, text>:
        if bytes.len() < 128:
            return Err("Invalid header size: expected 128 bytes")

        # Read magic
        val magic = [bytes[0], bytes[1], bytes[2], bytes[3]]
        if magic[0] != 76 or magic[1] != 83 or magic[2] != 77 or magic[3] != 70:
            return Err("Invalid magic number: expected LSMF")

        # Read version
        val version_major = bytes[4]
        val version_minor = bytes[5]
        val reserved1 = [bytes[6], bytes[7]]

        # Read metadata
        val module_count = bytes_to_u32(bytes, 8)
        val index_offset = bytes_to_u64(bytes, 12)
        val index_size = bytes_to_u64(bytes, 20)
        val data_offset = bytes_to_u64(bytes, 28)

        # Read hashing
        val library_hash = bytes_to_u64(bytes, 36)
        val index_hash = bytes_to_u64(bytes, 44)

        # Read reserved
        var reserved2: [u8] = []
        for i in 52..128:
            reserved2.push(bytes[i])

        Ok(LibSmfHeader(
            magic: magic,
            version_major: version_major,
            version_minor: version_minor,
            reserved1: reserved1,
            module_count: module_count,
            index_offset: index_offset,
            index_size: index_size,
            data_offset: data_offset,
            library_hash: library_hash,
            index_hash: index_hash,
            reserved2: reserved2
        ))

# ============================================================================
# Module Index Entry
# ============================================================================

# Module index entry (128 bytes).
# Each entry describes one module in the library:
# - Module path/name, location (offset/size), verification hashes
struct ModuleIndexEntry:
    # Module name (64 bytes) - null-terminated UTF-8
    name: [u8]               # Module path (e.g., "std/io/mod")

    # SMF Location (16 bytes)
    offset: u64              # Offset to module SMF data
    size: u64                # Size of module SMF data

    # Object Location (16 bytes)
    obj_offset: u64          # Offset to object file (0 if none)
    obj_size: u64            # Size of object file (0 if none)

    # Metadata (16 bytes)
    hash: u64                # FNV-1a hash of SMF data
    obj_hash: u64            # FNV-1a hash of object data (0 if none)

    # Reserved (16 bytes)
    reserved: [u8]

impl ModuleIndexEntry:
    # Create a new module index entry (SMF only).
    static fn new(name: text, offset: u64, size: u64, hash: u64) -> ModuleIndexEntry:
        var name_bytes: [u8] = []
        var name_limit = name.len()
        if name_limit > 63:
            name_limit = 63
        for i in 0..name_limit:
            name_bytes.push(name[i] as u8)
        # Null-terminate and pad to 64 bytes
        for i in name_bytes.len()..64:
            name_bytes.push(0)

        var reserved: [u8] = []
        for i in 0..16:
            reserved.push(0)

        ModuleIndexEntry(
            name: name_bytes,
            offset: offset,
            size: size,
            obj_offset: 0,
            obj_size: 0,
            hash: hash,
            obj_hash: 0,
            reserved: reserved
        )

    # Create a new module index entry with object file.
    static fn new_with_object(
        name: text,
        smf_offset: u64,
        smf_size: u64,
        smf_hash: u64,
        obj_offset: u64,
        obj_size: u64,
        obj_hash: u64
    ) -> ModuleIndexEntry:
        var name_bytes: [u8] = []
        var name_limit = name.len()
        if name_limit > 63:
            name_limit = 63
        for i in 0..name_limit:
            name_bytes.push(name[i] as u8)
        # Null-terminate and pad to 64 bytes
        for i in name_bytes.len()..64:
            name_bytes.push(0)

        var reserved: [u8] = []
        for i in 0..16:
            reserved.push(0)

        ModuleIndexEntry(
            name: name_bytes,
            offset: smf_offset,
            size: smf_size,
            obj_offset: obj_offset,
            obj_size: obj_size,
            hash: smf_hash,
            obj_hash: obj_hash,
            reserved: reserved
        )

    # Check if this entry includes an object file.
    fn has_object() -> bool:
        self.obj_size > 0

    # Get module name as text.
    fn get_name() -> text:
        var chars: [text] = []
        for i in 0..self.name.len():
            if self.name[i] == 0:
                return chars.join("")
            chars.push(char_from_byte(self.name[i]))
        chars.join("")

    # Serialize entry to bytes (exactly 128 bytes).
    fn to_bytes() -> [u8]:
        var bytes: [u8] = []

        # Name (64 bytes)
        bytes = bytes + (self.name)

        # SMF Location (16 bytes)
        bytes = bytes + (u64_to_bytes(self.offset))
        bytes = bytes + (u64_to_bytes(self.size))

        # Object Location (16 bytes)
        bytes = bytes + (u64_to_bytes(self.obj_offset))
        bytes = bytes + (u64_to_bytes(self.obj_size))

        # Metadata (16 bytes)
        bytes = bytes + (u64_to_bytes(self.hash))
        bytes = bytes + (u64_to_bytes(self.obj_hash))

        # Reserved (16 bytes)
        bytes = bytes + (self.reserved)

        bytes

    # Deserialize entry from bytes.
    static fn from_bytes(bytes: [u8], start: i64) -> Result<ModuleIndexEntry, text>:
        if bytes.len() < start + 128:
            return Err("Invalid entry size")

        # Read name (64 bytes)
        var name: [u8] = []
        for i in start..(start + 64):
            name.push(bytes[i])

        # Read SMF location (16 bytes)
        val offset = bytes_to_u64(bytes, start + 64)
        val size = bytes_to_u64(bytes, start + 72)

        # Read object location (16 bytes)
        val obj_offset = bytes_to_u64(bytes, start + 80)
        val obj_size = bytes_to_u64(bytes, start + 88)

        # Read metadata (16 bytes)
        val hash = bytes_to_u64(bytes, start + 96)
        val obj_hash = bytes_to_u64(bytes, start + 104)

        # Read reserved (16 bytes)
        var reserved: [u8] = []
        for i in (start + 112)..(start + 128):
            reserved.push(bytes[i])

        Ok(ModuleIndexEntry(
            name: name,
            offset: offset,
            size: size,
            obj_offset: obj_offset,
            obj_size: obj_size,
            hash: hash,
            obj_hash: obj_hash,
            reserved: reserved
        ))

# ============================================================================
# Helper Functions
# ============================================================================

# Convert u32 to bytes (little-endian).
fn u32_to_bytes(value: u32) -> [u8]:
    val b0 = (value and 0xFF) as u8
    val b1 = ((value >> 8) and 0xFF) as u8
    val b2 = ((value >> 16) and 0xFF) as u8
    val b3 = ((value >> 24) and 0xFF) as u8
    [b0, b1, b2, b3]

# Convert u64 to bytes (little-endian).
fn u64_to_bytes(value: u64) -> [u8]:
    val b0 = (value and 0xFF) as u8
    val b1 = ((value >> 8) and 0xFF) as u8
    val b2 = ((value >> 16) and 0xFF) as u8
    val b3 = ((value >> 24) and 0xFF) as u8
    val b4 = ((value >> 32) and 0xFF) as u8
    val b5 = ((value >> 40) and 0xFF) as u8
    val b6 = ((value >> 48) and 0xFF) as u8
    val b7 = ((value >> 56) and 0xFF) as u8
    [b0, b1, b2, b3, b4, b5, b6, b7]

# Read u32 from bytes (little-endian).
fn bytes_to_u32(bytes: [u8], offset: i64) -> u32:
    val v0 = bytes[offset] as u32
    val v1 = (bytes[offset + 1] as u32) << 8
    val v2 = (bytes[offset + 2] as u32) << 16
    val v3 = (bytes[offset + 3] as u32) << 24
    v0 or v1 or v2 or v3

# Read u64 from bytes (little-endian).
fn bytes_to_u64(bytes: [u8], offset: i64) -> u64:
    val v0 = bytes[offset] as u64
    val v1 = (bytes[offset + 1] as u64) << 8
    val v2 = (bytes[offset + 2] as u64) << 16
    val v3 = (bytes[offset + 3] as u64) << 24
    val v4 = (bytes[offset + 4] as u64) << 32
    val v5 = (bytes[offset + 5] as u64) << 40
    val v6 = (bytes[offset + 6] as u64) << 48
    val v7 = (bytes[offset + 7] as u64) << 56
    v0 or v1 or v2 or v3 or v4 or v5 or v6 or v7

# Convert byte to single-character text.
fn char_from_byte(b: u8) -> text:
    val c = b as i64
    "{c}"

# Calculate FNV-1a hash.
fn fnv1a_hash(data: [u8]) -> u64:
    # FNV_OFFSET = 14695981039346656037 (too large for literal, compute from parts)
    # 0xCBF29CE4_84222325
    val FNV_OFFSET_HI: u64 = 0x4BF29CE4
    val fnv_hi_shifted = (FNV_OFFSET_HI + 0x80000000) << 32
    val FNV_OFFSET: u64 = fnv_hi_shifted + 0x84222325
    val FNV_PRIME: u64 = 4294967296 + 435

    var hash = FNV_OFFSET
    for byte in data:
        hash = hash xor (byte as u64)
        hash = hash * FNV_PRIME

    hash

# ============================================================================
# Exports
# ============================================================================

export LibSmfHeader
export ModuleIndexEntry
export LSMF_MAGIC
export LSMF_HEADER_SIZE
export LSMF_INDEX_ENTRY_SIZE
export fnv1a_hash
