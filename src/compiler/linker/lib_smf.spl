# Library SMF Format - Container for multiple SMF modules
#
# This module defines the Library SMF (.lsm) format, which bundles multiple
# SMF modules into a single archive file with a location index.
#
# Format Layout:
# ┌────────────────────────────────┐
# │  Lib SMF Header (128 bytes)    │  Magic, version, module count
# ├────────────────────────────────┤
# │  Module Index Table            │  Array of ModuleIndexEntry
# │  (128 bytes × module_count)    │  Each entry: name, offset, size, hash
# ├────────────────────────────────┤
# │  Module 1 SMF Data             │  Complete SMF file data
# ├────────────────────────────────┤
# │  Module 2 SMF Data             │  Complete SMF file data
# ├────────────────────────────────┤
# │  ...                           │
# ├────────────────────────────────┤
# │  Module N SMF Data             │  Complete SMF file data
# └────────────────────────────────┘
#
# Benefits:
# - Single file deployment for libraries
# - Fast random access via index
# - Reduced file system overhead
# - Atomic library updates

use app.io.{file_write, file_read, file_exists}

# ============================================================================
# Constants
# ============================================================================

val LSMF_MAGIC: [u8] = [76, 83, 77, 70]  # "LSMF" (Library SMF)
val LSMF_HEADER_SIZE: i64 = 128
val LSMF_INDEX_ENTRY_SIZE: i64 = 128
val LSMF_VERSION_MAJOR: u8 = 1
val LSMF_VERSION_MINOR: u8 = 0

# ============================================================================
# Lib SMF Header
# ============================================================================

"""Library SMF header structure (128 bytes).

The header is located at the beginning of the file and contains:
- Magic number for format identification
- Version information
- Module count and index metadata
- Reserved space for future extensions
"""
struct LibSmfHeader:
    # Identification (8 bytes)
    magic: [u8]              # Magic number "LSMF" (4 bytes)
    version_major: u8        # Major version (1)
    version_minor: u8        # Minor version (0)
    reserved1: [u8]          # Reserved (2 bytes)

    # Metadata (24 bytes)
    module_count: u32        # Number of modules in library
    index_offset: u64        # Offset to index table (always 128)
    index_size: u64          # Size of index table in bytes
    data_offset: u64         # Offset where module data begins

    # Hashing (16 bytes)
    library_hash: u64        # Hash of entire library content
    index_hash: u64          # Hash of index table

    # Reserved (80 bytes) - padding to 128 bytes
    reserved2: [u8]

impl LibSmfHeader:
    """Create a new library SMF header with defaults."""
    static fn new_default() -> LibSmfHeader:
        LibSmfHeader(
            magic: LSMF_MAGIC,
            version_major: LSMF_VERSION_MAJOR,
            version_minor: LSMF_VERSION_MINOR,
            reserved1: [0, 0],
            module_count: 0,
            index_offset: LSMF_HEADER_SIZE as u64,
            index_size: 0,
            data_offset: 0,
            library_hash: 0,
            index_hash: 0,
            reserved2: [
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
            ]
        )

    """Check if magic number is valid."""
    fn is_valid() -> bool:
        val check1 = self.magic[0] == 76 and self.magic[1] == 83
        val check2 = self.magic[2] == 77 and self.magic[3] == 70
        check1 and check2

    """Get version as (major, minor) tuple."""
    fn version() -> (u8, u8):
        (self.version_major, self.version_minor)

    """Serialize header to bytes (exactly 128 bytes)."""
    fn to_bytes() -> [u8]:
        var bytes: [u8] = []

        # Identification (8 bytes)
        bytes = bytes + (self.magic)
        bytes.push(self.version_major)
        bytes.push(self.version_minor)
        bytes = bytes + (self.reserved1)

        # Metadata (24 bytes)
        bytes = bytes + (u32_to_bytes(self.module_count))
        bytes = bytes + (u64_to_bytes(self.index_offset))
        bytes = bytes + (u64_to_bytes(self.index_size))
        bytes = bytes + (u64_to_bytes(self.data_offset))

        # Hashing (16 bytes)
        bytes = bytes + (u64_to_bytes(self.library_hash))
        bytes = bytes + (u64_to_bytes(self.index_hash))

        # Reserved (80 bytes)
        bytes = bytes + (self.reserved2)

        bytes

    """Deserialize header from bytes."""
    static fn from_bytes(bytes: [u8]) -> Result<LibSmfHeader, text>:
        if bytes.len() < 128:
            return Err("Invalid header size: expected 128 bytes")

        # Read magic
        val magic = [bytes[0], bytes[1], bytes[2], bytes[3]]
        if magic[0] != 76 or magic[1] != 83 or magic[2] != 77 or magic[3] != 70:
            return Err("Invalid magic number: expected LSMF")

        # Read version
        val version_major = bytes[4]
        val version_minor = bytes[5]
        val reserved1 = [bytes[6], bytes[7]]

        # Read metadata
        val module_count = bytes_to_u32(bytes, 8)
        val index_offset = bytes_to_u64(bytes, 12)
        val index_size = bytes_to_u64(bytes, 20)
        val data_offset = bytes_to_u64(bytes, 28)

        # Read hashing
        val library_hash = bytes_to_u64(bytes, 36)
        val index_hash = bytes_to_u64(bytes, 44)

        # Read reserved
        var reserved2: [u8] = []
        var i = 52
        while i < 128:
            reserved2.push(bytes[i])
            i = i + 1

        Ok(LibSmfHeader(
            magic: magic,
            version_major: version_major,
            version_minor: version_minor,
            reserved1: reserved1,
            module_count: module_count,
            index_offset: index_offset,
            index_size: index_size,
            data_offset: data_offset,
            library_hash: library_hash,
            index_hash: index_hash,
            reserved2: reserved2
        ))

# ============================================================================
# Module Index Entry
# ============================================================================

"""Module index entry (128 bytes).

Each entry describes one module in the library:
- Module path/name (unique identifier)
- Location in file (offset and size)
- Verification hash
"""
struct ModuleIndexEntry:
    # Module name (64 bytes) - null-terminated UTF-8
    name: [u8]               # Module path (e.g., "std/io/mod")

    # Location (16 bytes)
    offset: u64              # Offset to module SMF data
    size: u64                # Size of module SMF data

    # Metadata (16 bytes)
    hash: u64                # FNV-1a hash of module data
    timestamp: u64           # Build timestamp (Unix epoch)

    # Reserved (32 bytes)
    reserved: [u8]

impl ModuleIndexEntry:
    """Create a new module index entry."""
    static fn new(name: text, offset: u64, size: u64, hash: u64) -> ModuleIndexEntry:
        var name_bytes: [u8] = []
        var i = 0
        while i < name.len() and i < 63:
            name_bytes.push(name[i] as u8)
            i = i + 1
        # Null-terminate
        name_bytes.push(0)
        # Pad to 64 bytes
        while name_bytes.len() < 64:
            name_bytes.push(0)

        var reserved: [u8] = []
        i = 0
        while i < 32:
            reserved.push(0)
            i = i + 1

        ModuleIndexEntry(
            name: name_bytes,
            offset: offset,
            size: size,
            hash: hash,
            timestamp: 0,
            reserved: reserved
        )

    """Get module name as text."""
    fn get_name() -> text:
        var chars: [text] = []
        var i = 0
        while i < self.name.len() and self.name[i] != 0:
            chars.push(char_from_byte(self.name[i]))
            i = i + 1
        chars.join("")

    """Serialize entry to bytes (exactly 128 bytes)."""
    fn to_bytes() -> [u8]:
        var bytes: [u8] = []

        # Name (64 bytes)
        bytes = bytes + (self.name)

        # Location (16 bytes)
        bytes = bytes + (u64_to_bytes(self.offset))
        bytes = bytes + (u64_to_bytes(self.size))

        # Metadata (16 bytes)
        bytes = bytes + (u64_to_bytes(self.hash))
        bytes = bytes + (u64_to_bytes(self.timestamp))

        # Reserved (32 bytes)
        bytes = bytes + (self.reserved)

        bytes

    """Deserialize entry from bytes."""
    static fn from_bytes(bytes: [u8], start: i64) -> Result<ModuleIndexEntry, text>:
        if bytes.len() < start + 128:
            return Err("Invalid entry size")

        # Read name (64 bytes)
        var name: [u8] = []
        var i = start
        while i < start + 64:
            name.push(bytes[i])
            i = i + 1

        # Read location (16 bytes)
        val offset = bytes_to_u64(bytes, start + 64)
        val size = bytes_to_u64(bytes, start + 72)

        # Read metadata (16 bytes)
        val hash = bytes_to_u64(bytes, start + 80)
        val timestamp = bytes_to_u64(bytes, start + 88)

        # Read reserved (32 bytes)
        var reserved: [u8] = []
        i = start + 96
        while i < start + 128:
            reserved.push(bytes[i])
            i = i + 1

        Ok(ModuleIndexEntry(
            name: name,
            offset: offset,
            size: size,
            hash: hash,
            timestamp: timestamp,
            reserved: reserved
        ))

# ============================================================================
# Helper Functions
# ============================================================================

"""Convert u32 to bytes (little-endian)."""
fn u32_to_bytes(value: u32) -> [u8]:
    [
        (value & 0xFF) as u8,
        ((value >> 8) & 0xFF) as u8,
        ((value >> 16) & 0xFF) as u8,
        ((value >> 24) & 0xFF) as u8
    ]

"""Convert u64 to bytes (little-endian)."""
fn u64_to_bytes(value: u64) -> [u8]:
    [
        (value & 0xFF) as u8,
        ((value >> 8) & 0xFF) as u8,
        ((value >> 16) & 0xFF) as u8,
        ((value >> 24) & 0xFF) as u8,
        ((value >> 32) & 0xFF) as u8,
        ((value >> 40) & 0xFF) as u8,
        ((value >> 48) & 0xFF) as u8,
        ((value >> 56) & 0xFF) as u8
    ]

"""Read u32 from bytes (little-endian)."""
fn bytes_to_u32(bytes: [u8], offset: i64) -> u32:
    (bytes[offset] as u32) |
    ((bytes[offset + 1] as u32) << 8) |
    ((bytes[offset + 2] as u32) << 16) |
    ((bytes[offset + 3] as u32) << 24)

"""Read u64 from bytes (little-endian)."""
fn bytes_to_u64(bytes: [u8], offset: i64) -> u64:
    (bytes[offset] as u64) |
    ((bytes[offset + 1] as u64) << 8) |
    ((bytes[offset + 2] as u64) << 16) |
    ((bytes[offset + 3] as u64) << 24) |
    ((bytes[offset + 4] as u64) << 32) |
    ((bytes[offset + 5] as u64) << 40) |
    ((bytes[offset + 6] as u64) << 48) |
    ((bytes[offset + 7] as u64) << 56)

"""Convert byte to single-character text."""
fn char_from_byte(b: u8) -> text:
    # Use string interpolation for byte-to-char conversion
    val c = b as i64
    "{c}"

"""Calculate FNV-1a hash."""
fn fnv1a_hash(data: [u8]) -> u64:
    val FNV_OFFSET: u64 = 14695981039346656037
    val FNV_PRIME: u64 = 1099511628211

    var hash = FNV_OFFSET
    for byte in data:
        hash = hash ^ (byte as u64)
        hash = hash * FNV_PRIME

    hash

# ============================================================================
# Exports
# ============================================================================

export LibSmfHeader
export ModuleIndexEntry
export LSMF_MAGIC
export LSMF_HEADER_SIZE
export LSMF_INDEX_ENTRY_SIZE
export fnv1a_hash
