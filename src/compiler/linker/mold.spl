# Mold Backend - Native binary generation via mold linker.
#
# This module provides integration with the mold linker for generating
# native ELF binaries from SMF files.
#
# Mold is a high-performance linker (~4x faster than GNU ld).
# https://github.com/rui314/mold
#
# Fallback chain: mold -> lld -> ld
#
# Pure Simple implementation - no Rust FFI required.
# Uses bin/mold/mold (locally bundled) or system linkers.

use std.io_runtime.{ShellResult, shell, shell_output, shell_bool, process_run, file_exists, file_write, file_delete, file_size_raw, cwd}

use .obj_taker (SymbolType)

# ============================================================================
# Linker Detection (Pure Simple)
# ============================================================================

fn find_mold_path() -> text?:
    """Find mold executable. Checks local bin/mold/mold first, then PATH."""
    val local_mold = cwd() + "/bin/mold/mold"
    if file_exists(local_mold):
        return Some(local_mold)
    # Check PATH
    val which_result = shell_output("which mold 2>/dev/null")
    if which_result.len() > 0:
        Some(which_result)
    else:
        None

fn find_lld_path() -> text?:
    """Find lld executable in PATH."""
    val which_result = shell_output("which lld 2>/dev/null")
    if which_result.len() > 0:
        Some(which_result)
    else:
        None

fn find_ld_path() -> text?:
    """Find system ld executable in PATH."""
    val which_result = shell_output("which ld 2>/dev/null")
    if which_result.len() > 0:
        Some(which_result)
    else:
        None

fn execute_linker(linker_path: text, args: [text]) -> Result<i64, text>:
    """Execute linker with arguments. Returns exit code."""
    val (stdout, stderr, code) = process_run(linker_path, args)
    if code != 0:
        var msg = "Linker failed (exit {code})"
        if stderr.len() > 0:
            msg = msg + ": " + stderr
        return Err(msg)
    Ok(code)

fn write_elf_object(code: [i64], name: text, output_path: text) -> Result<(), text>:
    """Write code bytes as ELF object file using GNU assembler.

    Generates a .s assembly file with .byte directives for the code bytes,
    then assembles it with `as --64 -o output.o input.s`.
    """
    # Generate assembly source with .byte directives
    var asm_lines = ".section .text\n"
    asm_lines = asm_lines + ".globl " + name + "\n"
    asm_lines = asm_lines + ".type " + name + ", @function\n"
    asm_lines = asm_lines + name + ":\n"

    # Emit .byte directives (one per line for clarity, batched for efficiency)
    var i = 0
    var batch_size = 16
    var code_len = code.len()
    for idx in range(0, code_len):
        if i % batch_size == 0:
            if i > 0:
                asm_lines = asm_lines + "\n"
            asm_lines = asm_lines + "    .byte "
        else:
            asm_lines = asm_lines + ", "
        # Mask to 0-255 range (code values are i64 representing bytes)
        val byte_val = code[idx] % 256
        asm_lines = asm_lines + "{byte_val}"
        i = i + 1

    asm_lines = asm_lines + "\n"
    asm_lines = asm_lines + ".size " + name + ", .-" + name + "\n"

    # Write assembly to temp file
    val asm_path = output_path + ".s"
    val wrote = file_write(asm_path, asm_lines)
    if not wrote:
        return Err("Failed to write assembly file: {asm_path}")

    # Assemble with GNU as
    val (stdout, stderr, exit_code) = process_run("as", ["--64", "-o", output_path, asm_path])
    # Cleanup temp assembly file
    file_delete(asm_path)

    if exit_code != 0:
        var msg = "Assembler failed (exit {exit_code})"
        if stderr.len() > 0:
            msg = msg + ": " + stderr
        return Err(msg)

    Ok(())

fn linker_file_size(path: text) -> i64:
    """Get file size in bytes using stat."""
    file_size_raw(path)

# ============================================================================
# Resolved Object
# ============================================================================

struct ResolvedObject:
    """An object ready for linking."""
    name: text
    code: [i64]
    symbol_type: SymbolType

# ============================================================================
# Mold Backend
# ============================================================================

enum LinkerType:
    Mold
    Lld
    Ld

impl LinkerType:
    fn to_string() -> text:
        match self:
            case Mold: "mold"
            case Lld: "lld"
            case Ld: "ld"

struct MoldBackend:
    """Backend for native binary generation via mold/lld/ld."""
    linker_path: text
    linker_type: LinkerType
    config: MoldConfig

struct MoldConfig:
    """Configuration for mold backend."""
    pie: bool
    debug: bool
    verbose: bool
    libraries: [text]
    library_paths: [text]
    extra_args: [text]

impl MoldConfig:
    static fn default() -> MoldConfig:
        MoldConfig(
            pie: true,
            debug: false,
            verbose: false,
            libraries: [],
            library_paths: [],
            extra_args: []
        )

    static fn from_link_config(config: any) -> MoldConfig:
        """Create MoldConfig from LinkConfig."""
        # Access fields via dynamic lookup
        var extra_args: [text] = []

        # Add target flags (CPU/architecture)
        val target_flags = config.target_flags ?? []
        for flag in target_flags:
            extra_args.push(flag)

        # Add custom linker flags
        val linker_flags = config.linker_flags ?? []
        for flag in linker_flags:
            extra_args.push(flag)

        MoldConfig(
            pie: config.pie ?? true,
            debug: config.debug ?? false,
            verbose: config.verbose ?? false,
            libraries: config.libraries ?? [],
            library_paths: config.library_paths ?? [],
            extra_args: extra_args
        )

impl MoldBackend:
    static fn create(link_config: any) -> Result<MoldBackend, text>:
        """Create a mold backend, falling back to lld or ld if needed."""
        val config = MoldConfig.from_link_config(link_config)

        # Try to find a linker in order of preference
        val (linker_path, linker_type) = find_linker()?

        if config.verbose:
            print "[mold] Using linker: {linker_type.to_string()} at {linker_path}"

        Ok(MoldBackend(
            linker_path: linker_path,
            linker_type: linker_type,
            config: config
        ))

    static fn with_config(config: MoldConfig) -> Result<MoldBackend, text>:
        """Create backend with explicit config."""
        val (linker_path, linker_type) = find_linker()?

        Ok(MoldBackend(
            linker_path: linker_path,
            linker_type: linker_type,
            config: config
        ))

    fn link(objects: [ResolvedObject], output: text) -> Result<(), text>:
        """Link objects to native binary."""
        if self.config.verbose:
            print "[mold] Linking {objects.len()} objects to {output}"

        # Create temporary directory for object files
        val temp_dir = create_temp_dir()?

        # Write each object as ELF .o file
        var obj_paths: [text] = []
        for (idx, obj) in objects.enumerate():
            val obj_path = "{temp_dir}/obj_{idx}.o"
            write_elf_object(obj.code, obj.name, obj_path)?
            obj_paths = obj_paths.push(obj_path)

        # Build linker arguments
        var args: [text] = []

        # Output file
        args = args.push("-o")
        args = args.push(output)

        # Object files
        for path in obj_paths:
            args = args.push(path)

        # Library paths
        for path in self.config.library_paths:
            args = args.push("-L")
            args = args.push(path)

        # Libraries
        for lib in self.config.libraries:
            args = args.push("-l")
            args = args.push(lib)

        # PIE
        if self.config.pie:
            args = args.push("-pie")

        # Debug info
        if self.config.debug:
            args = args.push("-g")

        # Extra args
        for arg in self.config.extra_args:
            args = args.push(arg)

        # Execute linker
        execute_linker(self.linker_path, args)?

        # Cleanup temp directory
        cleanup_temp_dir(temp_dir)

        if self.config.verbose:
            val size = linker_file_size(output)
            print "[mold] Output size: {size} bytes"

        Ok(())

    fn link_with_runtime(
        objects: [ResolvedObject],
        output: text,
        runtime_path: text?
    ) -> Result<(), text>:
        """Link objects with Simple runtime library."""
        var all_objects = objects

        # Add runtime if specified
        if runtime_path.?:
            # TODO: Load runtime symbols
            pass

        self.link(all_objects, output)

# ============================================================================
# Helper Functions
# ============================================================================

fn find_linker() -> Result<(text, LinkerType), text>:
    """Find an available linker in order of preference."""
    # Try mold first
    val mold_path = find_mold_path()
    if mold_path.?:
        return Ok((mold_path.unwrap(), LinkerType.Mold))

    # Try lld
    val lld_path = find_lld_path()
    if lld_path.?:
        return Ok((lld_path.unwrap(), LinkerType.Lld))

    # Try system ld
    val ld_path = find_ld_path()
    if ld_path.?:
        return Ok((ld_path.unwrap(), LinkerType.Ld))

    Err("No linker found. Please install mold, lld, or ensure ld is in PATH.")

fn create_temp_dir() -> Result<text, text>:
    """Create a temporary directory for object files."""
    val result = shell_output("mktemp -d /tmp/simple_link_XXXXXX")
    if result.len() > 0:
        Ok(result)
    else:
        Err("Failed to create temporary directory")

fn cleanup_temp_dir(path: text):
    """Remove temporary directory (with safety check)."""
    if path.starts_with("/tmp/simple_link_"):
        shell("rm -rf '{path}'")

# ============================================================================
# Exports
# ============================================================================

export MoldBackend
export MoldConfig
export LinkerType
export ResolvedObject
export find_linker
export find_mold_path, find_lld_path, find_ld_path
export execute_linker, write_elf_object, linker_file_size
