# SMF Reader (In-Memory) - Read SMF from byte array
#
# This module provides functionality to parse SMF data from memory
# without requiring file system access. Used for loading modules
# from library archives.
#
# Usage:
#   val reader = SmfReaderMemory.from_data(smf_bytes)?
#   val symbol = reader.lookup_symbol("function_name")?

use ..monomorphize.note_sdn.*
use .obj_taker.{SmfSymbol, SymbolType, SymbolBinding}
use .smf_enums.{Platform, Arch, CompressionType}
use compiler.linker.smf_header.{SMF_HEADER_SIZE}

# ============================================================================
# Structures
# ============================================================================

"""Parsed SMF header (compatible with smf_reader.spl)."""
struct SmfHeader:
    version: (u8, u8)     # (major, minor)
    platform: Platform
    arch: Arch
    flags: SmfFlags
    section_count: i32
    symbol_count: i32
    entry_point: i64
    has_templates: bool
    has_note_sdn: bool
    compression: CompressionType

impl SmfHeader:
    fn is_valid() -> bool:
        """Check if header is valid (called by from_data)."""
        # Magic check is done during parsing
        true

"""SMF flags."""
struct SmfFlags:
    executable: bool
    reloadable: bool
    debug_info: bool
    pic: bool
    has_stub: bool

# ============================================================================
# In-Memory SMF Reader
# ============================================================================

"""SMF reader that works with in-memory byte array."""
struct SmfReaderMemory:
    data: [u8]               # Complete SMF file data
    header: SmfHeader        # Parsed header
    symbols: Dict<text, SmfSymbol>  # Symbol table
    string_table: [u8]       # String table for names
    sections_offset: i64     # Offset to section table
    symbols_offset: i64      # Offset to symbol table

impl SmfReaderMemory:
    """Create reader from byte array.

    Args:
        data: Complete SMF file data

    Returns:
        SmfReaderMemory or error
    """
    static fn from_data(data: [u8]) -> Result<SmfReaderMemory, text>:
        # Validate minimum size
        if data.len() < 128:
            return Err("SMF data too small: {data.len()} bytes")

        # Parse header (first 128 bytes)
        val header = parse_header_from_bytes(data)?

        # Validate magic
        if not header.is_valid():
            return Err("Invalid SMF magic number")

        # Read section table offset
        val sections_offset = header.section_table_offset as i64

        # Read symbol table offset
        val symbols_offset = header.symbol_table_offset as i64

        # Parse string table (needed for symbol names)
        val string_table = extract_string_table(data, header)?

        # Parse symbol table
        val symbols = parse_symbol_table(data, header, string_table)?

        Ok(SmfReaderMemory(
            data: data,
            header: header,
            symbols: symbols,
            string_table: string_table,
            sections_offset: sections_offset,
            symbols_offset: symbols_offset
        ))

    """Look up a symbol by name."""
    fn lookup_symbol(name: text) -> Result<SmfSymbol, text>:
        if self.symbols.contains_key(name):
            Ok(self.symbols[name])
        else:
            Err("Symbol not found: {name}")

    """Get all exported symbols."""
    fn exported_symbols() -> [SmfSymbol]:
        var result: [SmfSymbol] = []
        for (name, symbol) in self.symbols:
            if symbol.binding == SymbolBinding.Global or symbol.binding == SymbolBinding.Weak:
                result.push(symbol)
        result

    """Read code bytes for a symbol."""
    fn read_code(symbol: SmfSymbol) -> Result<[u8], text>:
        # For now, return a stub implementation
        # Full implementation would:
        # 1. Find the code section using symbol.section_index
        # 2. Extract bytes from symbol.offset to symbol.offset + symbol.size
        Err("read_code not yet implemented for memory reader")

    """Get the parsed header."""
    fn get_header() -> SmfHeader:
        self.header

    """Get data size."""
    fn data_size() -> i64:
        self.data.len()

# ============================================================================
# Parsing Functions
# ============================================================================

"""Parse SMF header from byte array."""
fn parse_header_from_bytes(data: [u8]) -> Result<SmfHeader, text>:
    if data.len() < 128:
        return Err("Not enough data for header")

    # Extract header bytes
    var header_bytes: [u8] = []
    var i = 0
    while i < 128:
        header_bytes.push(data[i])
        i = i + 1

    # Parse magic
    val magic = [header_bytes[0], header_bytes[1], header_bytes[2], header_bytes[3]]

    # Validate magic
    val valid_magic = magic[0] == 83 and magic[1] == 77 and magic[2] == 70 and magic[3] == 0
    if not valid_magic:
        return Err("Invalid SMF magic: expected 'SMF\\0'")

    # Parse version
    val version_major = header_bytes[4]
    val version_minor = header_bytes[5]

    # Parse platform and arch
    val platform = Platform.from_u8(header_bytes[6])
    val arch = Arch.from_u8(header_bytes[7])

    # Parse flags (bytes 8-11, little endian u32)
    val flags_raw = bytes_to_u32(header_bytes, 8)

    # Parse flag bits
    val flags = SmfFlags(
        executable: (flags_raw & 0x01) != 0,
        reloadable: (flags_raw & 0x02) != 0,
        debug_info: (flags_raw & 0x04) != 0,
        pic: (flags_raw & 0x08) != 0,
        has_stub: (flags_raw & 0x10) != 0
    )

    # Parse compression (byte 12)
    val compression = CompressionType.from_u8(header_bytes[12])

    # Parse section count (bytes 16-19, little endian u32)
    val section_count = bytes_to_u32(header_bytes, 16)

    # Parse section table offset (bytes 20-27, little endian u64)
    val section_table_offset = bytes_to_u64(header_bytes, 20)

    # Parse symbol table offset (bytes 28-35, little endian u64)
    val symbol_table_offset = bytes_to_u64(header_bytes, 28)

    # Parse symbol count (bytes 36-39, little endian u32)
    val symbol_count = bytes_to_u32(header_bytes, 36)

    # Parse exported count (bytes 40-43, little endian u32)
    val exported_count = bytes_to_u32(header_bytes, 40)

    # Parse entry point (bytes 44-51, little endian u64)
    val entry_point = bytes_to_u64(header_bytes, 44)

    # Create header struct
    val header = SmfHeader(
        version: (version_major, version_minor),
        platform: platform,
        arch: arch,
        flags: flags,
        section_count: section_count as i32,
        symbol_count: symbol_count as i32,
        entry_point: entry_point as i64,
        has_templates: (flags_raw & 0x10) != 0,
        has_note_sdn: (flags_raw & 0x20) != 0,
        compression: compression
    )

    Ok(header)

"""Extract string table from SMF data."""
fn extract_string_table(data: [u8], header: SmfHeader) -> Result<[u8], text>:
    # String table location is typically after symbol table
    # For now, return an empty table as a stub
    # Full implementation would parse section table to find StrTab section
    Ok([])

"""Parse symbol table from SMF data."""
fn parse_symbol_table(data: [u8], header: SmfHeader, string_table: [u8]) -> Result<Dict<text, SmfSymbol>, text>:
    var symbols: Dict<text, SmfSymbol> = {}

    # Symbol table starts at symbol_table_offset
    # Each symbol is 72 bytes
    # For now, return empty as a stub
    # Full implementation would:
    # 1. Seek to symbol_table_offset
    # 2. Read symbol_count * 72 bytes
    # 3. Parse each symbol
    # 4. Resolve names from string table

    Ok(symbols)

# ============================================================================
# Helper Functions
# ============================================================================

"""Read u32 from bytes (little-endian)."""
fn bytes_to_u32(bytes: [u8], offset: i64) -> u32:
    val b0 = bytes[offset] as u32
    val b1 = bytes[offset + 1] as u32
    val b2 = bytes[offset + 2] as u32
    val b3 = bytes[offset + 3] as u32

    b0 | (b1 << 8) | (b2 << 16) | (b3 << 24)

"""Read u64 from bytes (little-endian)."""
fn bytes_to_u64(bytes: [u8], offset: i64) -> u64:
    val b0 = bytes[offset] as u64
    val b1 = bytes[offset + 1] as u64
    val b2 = bytes[offset + 2] as u64
    val b3 = bytes[offset + 3] as u64
    val b4 = bytes[offset + 4] as u64
    val b5 = bytes[offset + 5] as u64
    val b6 = bytes[offset + 6] as u64
    val b7 = bytes[offset + 7] as u64

    b0 | (b1 << 8) | (b2 << 16) | (b3 << 24) | (b4 << 32) | (b5 << 40) | (b6 << 48) | (b7 << 56)

# ============================================================================
# Exports
# ============================================================================

export SmfReaderMemory
