# Linker Wrapper - Unified Linking API
#
# This module provides a single entry point for all linking operations,
# replacing the hardcoded `cc` calls in driver.spl with platform-aware
# linker selection and adding self-contained executable SMF support.
#
# Three linking modes:
#   link_to_native()         - Platform-detected native binary (mold/lld/ld)
#   link_to_smf()            - SMF module file
#   link_to_self_contained() - Runtime + SMF data in one executable
#
# Self-contained binary format (trailer-based):
#   [Runtime Binary] [SMF Data] [32-byte Trailer]
#   Trailer: "SMFE"(4) + smf_offset(8) + smf_size(8) + checksum(8) + version(4)
#
# Interpreter-safe: no generics (<>) used.

use std.io_runtime.{ShellResult, shell, shell_output, file_exists, file_copy, file_delete, file_size_raw, env_get, host_os, host_arch, process_run, cwd}
use std.string.{NL}

use compiler.linker.mold.{MoldBackend, MoldConfig, find_linker, LinkerType, execute_linker, create_temp_dir, cleanup_temp_dir, linker_file_size}
use compiler.linker.smf_enums.{Platform, Arch}

# Runtime FFI for binary file operations
extern fn rt_file_write_bytes(path: text, data: [u8]) -> bool
extern fn rt_file_read_bytes(path: text) -> [i64]

# ============================================================================
# Result Type (Interpreter-Safe)
# ============================================================================

# Simple Result type without generics for interpreter compatibility
enum Result:
    Ok(value: text)
    Err(error: text)

impl Result:
    fn is_ok() -> bool:
        match self:
            case Ok(_): true
            case Err(_): false

    fn is_err() -> bool:
        match self:
            case Ok(_): false
            case Err(_): true

    fn unwrap() -> text:
        match self:
            case Ok(v): v
            case Err(e): ""

    fn unwrap_err() -> text:
        match self:
            case Ok(_): ""
            case Err(e): e

# ============================================================================
# Configuration Structs
# ============================================================================

struct NativeLinkConfig:
    libraries: [text]
    library_paths: [text]
    runtime_path: text       # Path to libsimple_compiler (empty = auto-detect)
    pie: bool
    debug: bool
    verbose: bool
    extra_flags: [text]

fn NativeLinkConfig__default() -> NativeLinkConfig:
    NativeLinkConfig(
        libraries: [],
        library_paths: [],
        runtime_path: "",
        pie: true,
        debug: false,
        verbose: false,
        extra_flags: []
    )

struct CrtFiles:
    crt1: text           # crt1.o or Scrt1.o (PIE)
    crti: text           # crti.o
    crtn: text           # crtn.o
    crtbegin: text       # crtbegin.o or crtbeginS.o (PIE)
    crtend: text         # crtend.o or crtendS.o (PIE)
    dynamic_linker: text # e.g., /lib64/ld-linux-x86-64.so.2
    lib_dirs: [text]     # System library search paths
    found: bool

struct SelfContainedConfig:
    runtime_binary: text     # Path to bootstrap/simple binary (empty = auto-detect)
    verbose: bool
    strip: bool              # Strip debug symbols from output

fn SelfContainedConfig__default() -> SelfContainedConfig:
    SelfContainedConfig(
        runtime_binary: "",
        verbose: false,
        strip: false
    )

# ============================================================================
# Self-Contained Binary Constants
# ============================================================================

# Trailer magic bytes: "SMFE" (SMF Executable)
val SMFE_MAGIC: [u8] = [83, 77, 70, 69]  # S=83, M=77, F=70, E=69
val SMFE_TRAILER_SIZE: i64 = 32
val SMFE_VERSION: i64 = 1

# ============================================================================
# Direct ELF Binary Writing (Phase 2.1)
# ============================================================================

fn write_elf_bytes_to_file(path: text, bytes: [u8]) -> Result:
    """Write raw ELF bytes directly to file without assembler.

    Uses rt_file_write_bytes() to write binary data efficiently.
    No intermediate assembly step needed. Verifies ELF magic number.

    Args:
        path: Output file path (.o object file)
        bytes: ELF file bytes ([u8] array)

    Returns:
        Ok(()) on success, Err(message) on failure
    """
    val success = rt_file_write_bytes(path, bytes)
    if not success:
        return Err("Failed to write ELF file: {path}")

    # Verify ELF magic number (0x7F 'E' 'L' 'F')
    if bytes.len() >= 4:
        val b0 = bytes[0]
        val b1 = bytes[1]
        val b2 = bytes[2]
        val b3 = bytes[3]
        if b0 != 127 or b1 != 69 or b2 != 76 or b3 != 70:
            return Err("Invalid ELF magic number in output: expected [0x7F, 'E', 'L', 'F'], got [{b0}, {b1}, {b2}, {b3}]")
    else:
        return Err("ELF file too small: {bytes.len()} bytes")

    Ok(())

fn verify_elf_file(path: text) -> bool:
    """Verify file is a valid ELF object by checking magic number.

    Args:
        path: Path to ELF file

    Returns:
        true if file exists and has valid ELF magic, false otherwise
    """
    if not file_exists(path):
        return false

    # Read first 4 bytes
    val bytes = rt_file_read_bytes(path)
    if bytes.len() < 4:
        return false

    # Check ELF magic: 0x7F 'E' 'L' 'F'
    val valid_magic = bytes[0] == 127 and bytes[1] == 69 and bytes[2] == 76 and bytes[3] == 70
    valid_magic

fn should_use_direct_elf_writing() -> bool:
    """Check if direct ELF writing should be used.

    Direct ELF writing is enabled by default for better performance.
    Can be disabled via SIMPLE_DISABLE_DIRECT_ELF environment variable.

    Returns:
        true to use direct writing, false to fall back to assembly
    """
    val disable = env_get("SIMPLE_DISABLE_DIRECT_ELF")
    val empty_or_false = disable == "" or disable == "0" or disable == "false"
    empty_or_false

# ============================================================================
# Native Linking
# ============================================================================

fn link_to_native(object_files: [text], output: text, config: NativeLinkConfig) -> Result:
    if object_files.len() == 0:
        return Err("No object files to link")

    val os = host_os()

    # Platform-specific linking
    if os == "windows":
        return link_native_windows(object_files, output, config)

    # Unix-like: Linux, macOS, FreeBSD
    link_native_unix(object_files, output, config)

fn link_native_unix(object_files: [text], output: text, config: NativeLinkConfig) -> Result:
    val os = host_os()
    val arch = host_arch()

    # Try to find platform linker (mold > lld > ld)
    val linker_result = find_linker()
    if linker_result.is_err():
        # Fall back to cc (always available on Unix)
        return link_native_cc(object_files, output, config)

    val linker_info = linker_result.unwrap()
    val linker_path = linker_info[0]
    val linker_type = linker_info[1]

    # Discover CRT files needed for direct linker invocation
    val crt = find_crt_files(config.pie, config.verbose)
    if not crt.found:
        if config.verbose:
            print "[linker-wrapper] CRT files not found, falling back to cc"
        return link_native_cc(object_files, output, config)

    if config.verbose:
        print "[linker-wrapper] Using {linker_type.to_string()} at {linker_path}"

    # Build linker arguments in correct order
    var args: [text] = []

    # Output file
    args.push("-o")
    args.push(output)

    # Emulation mode
    if os == "linux":
        if arch == "x86_64":
            args.push("-m")
            args.push("elf_x86_64")
        elif arch == "aarch64":
            args.push("-m")
            args.push("aarch64linux")
        elif arch == "i686" or arch == "i386":
            args.push("-m")
            args.push("elf_i386")
        elif arch == "armv7" or arch == "arm":
            args.push("-m")
            args.push("armelf_linux_eabi")
        elif arch == "riscv64":
            args.push("-m")
            args.push("elf64lriscv")
        elif arch == "riscv32":
            args.push("-m")
            args.push("elf32lriscv")

    # Dynamic linker
    if crt.dynamic_linker != "":
        args.push("-dynamic-linker")
        args.push(crt.dynamic_linker)

    # Hardening flags
    args.push("--eh-frame-hdr")
    args.push("--build-id")
    args.push("--hash-style=gnu")
    args.push("-z")
    args.push("relro")
    args.push("-z")
    args.push("now")

    # PIE
    if config.pie:
        args.push("-pie")

    # CRT prologue: crt1.o, crti.o, crtbegin.o (before user objects)
    args.push(crt.crt1)
    args.push(crt.crti)
    args.push(crt.crtbegin)

    # User object files
    for obj in object_files:
        args.push(obj)

    # Library search paths from CRT discovery
    for dir in crt.lib_dirs:
        args.push("-L")
        args.push(dir)

    # Library paths from config
    for lp in config.library_paths:
        args.push("-L")
        args.push(lp)

    # Auto-detect runtime library if not specified
    var runtime_dir = config.runtime_path
    if runtime_dir == "":
        runtime_dir = find_runtime_lib_dir()
    if runtime_dir != "":
        args.push("-L")
        args.push(runtime_dir)
        args.push("-lsimple_compiler")
        args.push("-rpath")
        args.push(runtime_dir)

    # Standard libraries (no -lgcc/-lgcc_s — clang provides compiler-rt)
    if os == "linux":
        args.push("-lc")
        args.push("-lpthread")
        args.push("-ldl")
        args.push("-lm")
    elif os == "macos":
        args.push("-lc")
        args.push("-lpthread")
        args.push("-lm")
        args.push("-lSystem")
    elif os == "freebsd":
        args.push("-lc")
        args.push("-lpthread")
        args.push("-lm")

    # Libraries from config
    for lib in config.libraries:
        args.push("-l")
        args.push(lib)

    # Debug info
    if config.debug:
        args.push("-g")

    # Extra flags
    for flag in config.extra_flags:
        args.push(flag)

    # CRT epilogue: crtend.o, crtn.o (after libs)
    args.push(crt.crtend)
    args.push(crt.crtn)

    # Execute linker
    val exec_result = execute_linker(linker_path, args)
    if exec_result.is_err():
        # Fallback to cc on failure
        if config.verbose:
            print "[linker-wrapper] Direct linker failed, falling back to cc: {exec_result.unwrap_err()}"
        return link_native_cc(object_files, output, config)

    if config.verbose:
        val size = linker_file_size(output)
        print "[linker-wrapper] Native binary: {output} ({size} bytes)"

    Ok(output)

fn link_native_cc(object_files: [text], output: text, config: NativeLinkConfig) -> Result:
    # Fallback: use cc (gcc/clang) for linking
    var cmd = "cc"
    for obj in object_files:
        cmd = cmd + " " + obj

    # Library paths
    for lp in config.library_paths:
        cmd = cmd + " -L" + lp

    # Auto-detect runtime library
    var runtime_dir = config.runtime_path
    if runtime_dir == "":
        runtime_dir = find_runtime_lib_dir()
    if runtime_dir != "":
        cmd = cmd + " -L{runtime_dir} -lsimple_compiler"
        cmd = cmd + " -Wl,-rpath,{runtime_dir}"

    # Standard libraries (OS-aware; no -lgcc_s — clang provides compiler-rt)
    var os_name = shell("uname -s").stdout
    os_name = os_name.trim()
    if os_name == "Darwin":
        cmd = cmd + " -lc -lpthread -lm -lSystem"
    elif os_name == "FreeBSD":
        cmd = cmd + " -lc -lpthread -lm"
    else:
        cmd = cmd + " -lc -lpthread -ldl -lm"

    # Libraries from config
    for lib in config.libraries:
        cmd = cmd + " -l" + lib

    # Extra flags
    for flag in config.extra_flags:
        cmd = cmd + " " + flag

    cmd = cmd + " -o " + output

    if config.verbose:
        print "[linker-wrapper] cc command: {cmd}"

    val result = shell(cmd)
    if result.exit_code == 0:
        Ok(output)
    else:
        val err_msg = result.stderr ?? "Unknown linking error"
        Err("cc linking failed: {err_msg}")

fn link_native_windows(object_files: [text], output: text, config: NativeLinkConfig) -> Result:
    # Windows linking via lld-link or MSVC link.exe
    # Try lld-link first
    val lld_check = shell("where lld-link 2>nul")
    var linker_cmd = "link"
    if lld_check.exit_code == 0:
        linker_cmd = "lld-link"

    var cmd = linker_cmd
    for obj in object_files:
        cmd = cmd + " " + obj

    cmd = cmd + " /OUT:{output}"

    # Libraries
    for lib in config.libraries:
        cmd = cmd + " {lib}.lib"

    # Extra flags
    for flag in config.extra_flags:
        cmd = cmd + " " + flag

    if config.verbose:
        print "[linker-wrapper] Windows linker: {cmd}"

    val result = shell(cmd)
    if result.exit_code == 0:
        Ok(output)
    else:
        val err_msg = result.stderr ?? "Unknown linking error"
        Err("Windows linking failed: {err_msg}")

# ============================================================================
# CRT File Discovery
# ============================================================================

fn find_crt_files(pie: bool, verbose: bool) -> CrtFiles:
    # Primary strategy: use cc -print-file-name=X
    val cc_result = find_crt_files_via_cc(pie, verbose)
    if cc_result.found:
        return cc_result

    # Fallback: probe well-known paths
    val fallback_result = find_crt_files_fallback(pie, verbose)
    if fallback_result.found:
        return fallback_result

    # Return empty (not found)
    CrtFiles(
        crt1: "", crti: "", crtn: "",
        crtbegin: "", crtend: "",
        dynamic_linker: find_dynamic_linker(),
        lib_dirs: [],
        found: false
    )

fn find_crt_files_via_cc(pie: bool, verbose: bool) -> CrtFiles:
    # Use cc -print-file-name to locate CRT files
    var crt1_name = "crt1.o"
    var crtbegin_name = "crtbegin.o"
    var crtend_name = "crtend.o"
    if pie:
        crt1_name = "Scrt1.o"
        crtbegin_name = "crtbeginS.o"
        crtend_name = "crtendS.o"

    val crt1 = cc_print_file(crt1_name)
    val crti = cc_print_file("crti.o")
    val crtn = cc_print_file("crtn.o")
    val crtbegin = cc_print_file(crtbegin_name)
    val crtend = cc_print_file(crtend_name)

    # Validate: cc returns the bare filename if not found, absolute path if found
    val all_found = crt1.contains("/") and crti.contains("/") and crtn.contains("/") and crtbegin.contains("/") and crtend.contains("/")

    if verbose and all_found:
        print "[linker-wrapper] CRT files found via cc:"
        print "[linker-wrapper]   crt1={crt1} crti={crti} crtn={crtn}"
        print "[linker-wrapper]   crtbegin={crtbegin} crtend={crtend}"

    # Collect library directories from CRT paths
    var lib_dirs: [text] = []
    if crt1.contains("/"):
        val dir = path_dirname(crt1)
        if dir != "":
            lib_dirs = lib_dirs.push(dir)
    if crtbegin.contains("/"):
        val dir = path_dirname(crtbegin)
        if dir != "":
            var already = false
            for d in lib_dirs:
                if d == dir:
                    already = true
            if not already:
                lib_dirs = lib_dirs.push(dir)

    CrtFiles(
        crt1: crt1,
        crti: crti,
        crtn: crtn,
        crtbegin: crtbegin,
        crtend: crtend,
        dynamic_linker: find_dynamic_linker(),
        lib_dirs: lib_dirs,
        found: all_found
    )

fn cc_print_file(name: text) -> text:
    val result = shell_output("cc -print-file-name={name} 2>/dev/null")
    val trimmed = result.trim()
    if trimmed.len() > 0:
        trimmed
    else:
        name

fn find_crt_files_fallback(pie: bool, verbose: bool) -> CrtFiles:
    # Probe well-known system paths
    val probe_dirs: [text] = [
        "/usr/lib/x86_64-linux-gnu",
        "/usr/lib/i386-linux-gnu",
        "/usr/lib/aarch64-linux-gnu",
        "/usr/lib/arm-linux-gnueabihf",
        "/usr/lib/riscv64-linux-gnu",
        "/usr/lib/riscv32-linux-gnu",
        "/usr/lib64",
        "/usr/lib32",
        "/usr/lib"
    ]

    var crt1_name = "crt1.o"
    var crtbegin_name = "crtbegin.o"
    var crtend_name = "crtend.o"
    if pie:
        crt1_name = "Scrt1.o"
        crtbegin_name = "crtbeginS.o"
        crtend_name = "crtendS.o"

    var crt1 = ""
    var crti = ""
    var crtn = ""
    var crtbegin = ""
    var crtend = ""
    var lib_dirs: [text] = []

    # Find crt1, crti, crtn in system dirs
    for dir in probe_dirs:
        if crt1 == "" and file_exists("{dir}/{crt1_name}"):
            crt1 = "{dir}/{crt1_name}"
        if crti == "" and file_exists("{dir}/crti.o"):
            crti = "{dir}/crti.o"
        if crtn == "" and file_exists("{dir}/crtn.o"):
            crtn = "{dir}/crtn.o"
        if crt1 != "" or crti != "":
            var already = false
            for d in lib_dirs:
                if d == dir:
                    already = true
            if not already:
                lib_dirs = lib_dirs.push(dir)

    # Find crtbegin/crtend in GCC lib dirs
    val gcc_dirs = find_gcc_lib_dirs()
    for dir in gcc_dirs:
        if crtbegin == "" and file_exists("{dir}/{crtbegin_name}"):
            crtbegin = "{dir}/{crtbegin_name}"
        if crtend == "" and file_exists("{dir}/{crtend_name}"):
            crtend = "{dir}/{crtend_name}"
        if crtbegin != "":
            var already = false
            for d in lib_dirs:
                if d == dir:
                    already = true
            if not already:
                lib_dirs = lib_dirs.push(dir)

    val all_found = crt1 != "" and crti != "" and crtn != "" and crtbegin != "" and crtend != ""

    if verbose and all_found:
        print "[linker-wrapper] CRT files found via fallback:"
        print "[linker-wrapper]   crt1={crt1} crti={crti} crtn={crtn}"
        print "[linker-wrapper]   crtbegin={crtbegin} crtend={crtend}"

    CrtFiles(
        crt1: crt1, crti: crti, crtn: crtn,
        crtbegin: crtbegin, crtend: crtend,
        dynamic_linker: find_dynamic_linker(),
        lib_dirs: lib_dirs,
        found: all_found
    )

fn find_gcc_lib_dirs() -> [text]:
    # Find GCC library directories by probing common triplets and versions
    var dirs: [text] = []
    val triplets = ["x86_64-linux-gnu", "x86_64-redhat-linux", "x86_64-pc-linux-gnu", "aarch64-linux-gnu", "i686-linux-gnu", "arm-linux-gnueabihf", "riscv64-linux-gnu", "riscv32-linux-gnu"]
    val versions = ["14", "13", "12", "11", "10", "9"]

    for triplet in triplets:
        for ver in versions:
            val dir = "/usr/lib/gcc/{triplet}/{ver}"
            if file_exists("{dir}/crtbegin.o"):
                dirs = dirs.push(dir)

    # Also try cc -print-search-dirs for gcc lib path
    val search_result = shell_output("cc -print-search-dirs 2>/dev/null")
    if search_result.len() > 0:
        val lines = search_result.split(NL)
        for line in lines:
            if line.starts_with("libraries: ="):
                val paths_str = line[12:]
                val paths = paths_str.split(":")
                for p in paths:
                    val trimmed = p.trim()
                    if trimmed.len() > 0 and file_exists("{trimmed}/crtbegin.o"):
                        dirs = dirs.push(trimmed)
    dirs

fn find_dynamic_linker() -> text:
    val os = host_os()
    val arch = host_arch()

    if os == "linux":
        if arch == "x86_64":
            if file_exists("/lib64/ld-linux-x86-64.so.2"):
                return "/lib64/ld-linux-x86-64.so.2"
            if file_exists("/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2"):
                return "/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2"
        elif arch == "aarch64":
            if file_exists("/lib/ld-linux-aarch64.so.1"):
                return "/lib/ld-linux-aarch64.so.1"
            if file_exists("/lib/aarch64-linux-gnu/ld-linux-aarch64.so.1"):
                return "/lib/aarch64-linux-gnu/ld-linux-aarch64.so.1"
        elif arch == "i686" or arch == "i386":
            if file_exists("/lib/ld-linux.so.2"):
                return "/lib/ld-linux.so.2"
            if file_exists("/lib/i386-linux-gnu/ld-linux.so.2"):
                return "/lib/i386-linux-gnu/ld-linux.so.2"
        elif arch == "armv7" or arch == "arm":
            if file_exists("/lib/ld-linux-armhf.so.3"):
                return "/lib/ld-linux-armhf.so.3"
            if file_exists("/lib/arm-linux-gnueabihf/ld-linux-armhf.so.3"):
                return "/lib/arm-linux-gnueabihf/ld-linux-armhf.so.3"
        elif arch == "riscv64":
            if file_exists("/lib/ld-linux-riscv64-lp64d.so.1"):
                return "/lib/ld-linux-riscv64-lp64d.so.1"
            if file_exists("/lib/riscv64-linux-gnu/ld-linux-riscv64-lp64d.so.1"):
                return "/lib/riscv64-linux-gnu/ld-linux-riscv64-lp64d.so.1"
        elif arch == "riscv32":
            if file_exists("/lib/ld-linux-riscv32-ilp32d.so.1"):
                return "/lib/ld-linux-riscv32-ilp32d.so.1"
            if file_exists("/lib/riscv32-linux-gnu/ld-linux-riscv32-ilp32d.so.1"):
                return "/lib/riscv32-linux-gnu/ld-linux-riscv32-ilp32d.so.1"
    elif os == "freebsd":
        return "/libexec/ld-elf.so.1"

    # macOS: dyld handles this, no dynamic linker needed
    ""

fn path_dirname(path: text) -> text:
    # Return directory part of a file path
    val last_slash = path.rfind("/")
    if last_slash >= 0:
        path[0:last_slash]
    else:
        ""

# ============================================================================
# SMF Linking
# ============================================================================

fn link_to_smf(smf_bytes: [u8], output: text, verbose: bool) -> Result:
    # Write SMF bytes directly to file
    # Use shell to write binary data via base64 encoding
    if smf_bytes.len() == 0:
        return Err("No SMF data to write")

    # Write bytes using file_write_bytes helper
    val wrote = write_bytes_to_file(output, smf_bytes)
    if not wrote:
        return Err("Failed to write SMF file: {output}")

    if verbose:
        print "[linker-wrapper] SMF module: {output} ({smf_bytes.len()} bytes)"

    Ok(output)

# ============================================================================
# Self-Contained Linking
# ============================================================================

fn link_to_self_contained(smf_data: [u8], output: text, config: SelfContainedConfig) -> Result:
    if smf_data.len() == 0:
        return Err("No SMF data for self-contained binary")

    # Find runtime binary
    var runtime_path = config.runtime_binary
    if runtime_path == "":
        val found = find_runtime_binary()
        if found.is_err():
            return Err(found.unwrap_err())
        runtime_path = found.unwrap()

    if config.verbose:
        print "[linker-wrapper] Runtime binary: {runtime_path}"

    # Step 1: Copy runtime binary to output
    if not file_copy(runtime_path, output):
        return Err("Failed to copy runtime binary to {output}")

    # Step 2: Get runtime binary size (= offset where SMF data starts)
    val runtime_size = file_size_raw(output)
    if runtime_size <= 0:
        file_delete(output)
        return Err("Runtime binary is empty or unreadable")

    # Step 3: Append SMF data to output
    val append_ok = append_bytes_to_file(output, smf_data)
    if not append_ok:
        file_delete(output)
        return Err("Failed to append SMF data to output")

    # Step 4: Build and append trailer (32 bytes)
    val smf_offset = runtime_size
    val smf_size = smf_data.len()
    val checksum = fnv1a_hash(smf_data)
    val trailer = build_trailer(smf_offset, smf_size, checksum)

    val trailer_ok = append_bytes_to_file(output, trailer)
    if not trailer_ok:
        file_delete(output)
        return Err("Failed to append trailer to output")

    # Step 5: Make output executable
    val os = host_os()
    if os != "windows":
        shell("chmod +x '{output}'")

    val total_size = file_size_raw(output)
    if config.verbose:
        print "[linker-wrapper] Self-contained binary: {output}"
        print "[linker-wrapper]   Runtime: {runtime_size} bytes"
        print "[linker-wrapper]   SMF data: {smf_size} bytes"
        print "[linker-wrapper]   Trailer: {SMFE_TRAILER_SIZE} bytes"
        print "[linker-wrapper]   Total: {total_size} bytes"

    Ok(output)

# ============================================================================
# Self-Contained Detection
# ============================================================================

fn detect_self_contained(exe_path: text) -> Result:
    # Read the last 32 bytes of the binary to check for SMFE trailer
    val total_size = file_size_raw(exe_path)
    if total_size < SMFE_TRAILER_SIZE:
        return Err("File too small for self-contained detection")

    # Read trailer using dd (portable across platforms)
    val trailer_offset = total_size - SMFE_TRAILER_SIZE
    val hex_result = shell("dd if='{exe_path}' bs=1 skip={trailer_offset} count={SMFE_TRAILER_SIZE} 2>/dev/null | od -A n -t x1 | tr -d ' \\n'")
    if hex_result.exit_code != 0:
        return Err("Failed to read trailer bytes")

    val hex = hex_result.stdout
    if hex.len() < 8:
        return Err("Trailer too short")

    # Check magic: "SMFE" = 53 4d 46 45
    val magic_hex = hex[0:8]
    if magic_hex != "534d4645":
        return Err("No SMFE magic found")

    # Parse trailer fields from hex
    val smf_offset = parse_hex_u64(hex, 8)
    val smf_size = parse_hex_u64(hex, 24)

    Ok("{smf_offset},{smf_size}")

# ============================================================================
# Runtime Binary Discovery
# ============================================================================

fn find_runtime_binary() -> Result:
    # 1. Check SIMPLE_RUNTIME_BINARY env var
    val env_path = env_get("SIMPLE_RUNTIME_BINARY")
    if env_path != "" and file_exists(env_path):
        return Ok(env_path)

    val current_dir = cwd()
    val os = host_os()
    val arch = host_arch()

    # 2. Check platform-specific path
    var platform_name = os + "-" + arch
    val platform_path = "{current_dir}/bin/release/{platform_name}/simple"
    if file_exists(platform_path):
        return Ok(platform_path)

    # 3. Check generic bootstrap path
    val generic_path = "{current_dir}/bin/release/simple"
    if file_exists(generic_path):
        return Ok(generic_path)

    # 4. Check ./bin/release/simple (relative)
    if file_exists("./bin/release/simple"):
        return Ok("./bin/release/simple")

    Err("Runtime binary not found. Set SIMPLE_RUNTIME_BINARY or ensure bin/release/simple exists.")

fn find_runtime_lib_dir() -> text:
    # Check env var first
    val env_path = env_get("SIMPLE_RUNTIME_PATH")
    if env_path != "" and file_exists(env_path):
        return env_path

    # No runtime library found - return empty (native linking may still work without it)
    ""

# ============================================================================
# Trailer Building
# ============================================================================

fn build_trailer(smf_offset: i64, smf_size: i64, checksum: i64) -> [u8]:
    var buf: [u8] = []

    # Magic: "SMFE" (4 bytes)
    buf = buf + (SMFE_MAGIC)

    # SMF offset (8 bytes, little-endian)
    buf = buf + (i64_to_le_bytes(smf_offset))

    # SMF size (8 bytes, little-endian)
    buf = buf + (i64_to_le_bytes(smf_size))

    # Checksum (8 bytes, little-endian)
    buf = buf + (i64_to_le_bytes(checksum))

    # Version (4 bytes, little-endian)
    buf = buf + (i32_to_le_bytes(SMFE_VERSION))

    buf

# ============================================================================
# Hash Function
# ============================================================================

fn fnv1a_hash(data: [u8]) -> i64:
    # FNV-1a 64-bit hash
    # Offset basis 0xcbf29ce484222325 as signed i64
    var hash: i64 = -3750763034362895579
    for byte in data:
        val b = byte
        hash = hash xor b
        hash = hash * 1099511628211
    hash

# ============================================================================
# Binary Helpers
# ============================================================================

fn i64_to_le_bytes(value: i64) -> [u8]:
    [
        (value & 0xFF),
        ((value >> 8) & 0xFF),
        ((value >> 16) & 0xFF),
        ((value >> 24) & 0xFF),
        ((value >> 32) & 0xFF),
        ((value >> 40) & 0xFF),
        ((value >> 48) & 0xFF),
        ((value >> 56) & 0xFF)
    ]

fn i32_to_le_bytes(value: i64) -> [u8]:
    [
        (value & 0xFF),
        ((value >> 8) & 0xFF),
        ((value >> 16) & 0xFF),
        ((value >> 24) & 0xFF)
    ]

fn parse_hex_u64(hex: text, offset: i64) -> i64:
    # Parse 16 hex chars (8 bytes) as little-endian u64
    var result: i64 = 0
    var i = 0
    for idx in range(0, 8):
        val pos = offset + (idx * 2)
        if pos + 2 <= hex.len():
            val byte_hex = hex[pos:pos + 2]
            val byte_val = hex_byte_to_int(byte_hex)
            result = result | (byte_val << (idx * 8))
        i = i + 1
    result

fn hex_byte_to_int(hex: text) -> i64:
    if hex.len() < 2:
        return 0
    val hi = hex_char_to_int(hex[0:1])
    val lo = hex_char_to_int(hex[1:2])
    (hi * 16) + lo

fn hex_char_to_int(c: text) -> i64:
    match c:
        case "0": 0
        case "1": 1
        case "2": 2
        case "3": 3
        case "4": 4
        case "5": 5
        case "6": 6
        case "7": 7
        case "8": 8
        case "9": 9
        case "a" | "A": 10
        case "b" | "B": 11
        case "c" | "C": 12
        case "d" | "D": 13
        case "e" | "E": 14
        case "f" | "F": 15
        case _: 0

# ============================================================================
# File I/O Helpers (using shell for binary data)
# ============================================================================

fn write_bytes_to_file(path: text, data: [u8]) -> bool:
    # For binary data, use a temp file approach with printf
    # Write each byte using shell's printf with octal escapes
    # For efficiency, batch into chunks
    if data.len() == 0:
        val result = shell("touch '{path}'")
        return result.exit_code == 0

    # Use base64 encoding via shell for reliable binary transfer
    var hex_str = ""
    for byte in data:
        val b = byte & 0xFF
        val hi = "0123456789abcdef"[(b >> 4):((b >> 4) + 1)]
        val lo = "0123456789abcdef"[(b & 0xF):((b & 0xF) + 1)]
        hex_str = hex_str + hi + lo

    # Write hex data and decode with xxd
    val result = shell("echo '{hex_str}' | xxd -r -p > '{path}'")
    result.exit_code == 0

fn append_bytes_to_file(path: text, data: [u8]) -> bool:
    if data.len() == 0:
        return true

    # Convert to hex and append using xxd
    var hex_str = ""
    for byte in data:
        val b = byte & 0xFF
        val hi = "0123456789abcdef"[(b >> 4):((b >> 4) + 1)]
        val lo = "0123456789abcdef"[(b & 0xF):((b & 0xF) + 1)]
        hex_str = hex_str + hi + lo

    val result = shell("echo '{hex_str}' | xxd -r -p >> '{path}'")
    result.exit_code == 0

# ============================================================================
# Runtime Stub Generation
# ============================================================================

fn generate_runtime_stub(output_path: text, verbose: bool) -> Result:
    """Generate a minimal C runtime stub and compile it to an object file.

    The stub provides:
    - __simple_runtime_init()     - Runtime initialization (currently no-op)
    - __simple_runtime_shutdown() - Runtime cleanup (currently no-op)
    - main()                      - OS entry point that calls __simple_main()

    The user's main function is compiled as __simple_main() by the LLVM backend,
    and this stub bridges the OS entry point to it.

    Returns Ok(path_to_stub_o) on success, Err(message) on failure.
    """
    # Generate a temp C file path based on the output
    val c_path = output_path + "_runtime_stub.c"
    val o_path = output_path + "_runtime_stub.o"

    # Write the C stub source
    var stub_src = "/* Simple runtime stub - generated by Simple compiler */" + NL
    stub_src = stub_src + "void __simple_runtime_init(void) {}" + NL
    stub_src = stub_src + "void __simple_runtime_shutdown(void) {}" + NL
    stub_src = stub_src + "int __simple_main(void);" + NL
    stub_src = stub_src + "int main(int argc, char **argv) {" + NL
    stub_src = stub_src + "    __simple_runtime_init();" + NL
    stub_src = stub_src + "    int result = __simple_main();" + NL
    stub_src = stub_src + "    __simple_runtime_shutdown();" + NL
    stub_src = stub_src + "    return result;" + NL
    stub_src = stub_src + "}" + NL

    # Write C source to file
    val write_result = shell("printf '%s' '{stub_src}' > '{c_path}'")
    if write_result.exit_code != 0:
        return Err("Failed to write runtime stub C source to {c_path}")

    if verbose:
        print "[linker-wrapper] Generated runtime stub: {c_path}"

    # Compile the C stub to an object file
    val compile_result = shell("cc -c -o '{o_path}' '{c_path}' 2>&1")

    # Clean up the C source file
    shell("rm -f '{c_path}'")

    if compile_result.exit_code != 0:
        val err_msg = compile_result.stdout
        return Err("Failed to compile runtime stub: {err_msg}")

    if verbose:
        print "[linker-wrapper] Compiled runtime stub: {o_path}"

    Ok(o_path)

# ============================================================================
# Exports
# ============================================================================

export NativeLinkConfig, NativeLinkConfig__default
export CrtFiles, find_crt_files
export SelfContainedConfig, SelfContainedConfig__default
export link_to_native, link_to_smf, link_to_self_contained
export detect_self_contained, find_runtime_binary, find_runtime_lib_dir
export build_trailer, fnv1a_hash
export generate_runtime_stub
export SMFE_MAGIC, SMFE_TRAILER_SIZE, SMFE_VERSION
export write_elf_bytes_to_file, verify_elf_file, should_use_direct_elf_writing
