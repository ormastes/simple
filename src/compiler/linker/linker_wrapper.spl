# Linker Wrapper - Unified Linking API
#
# This module provides a single entry point for all linking operations,
# replacing the hardcoded `cc` calls in driver.spl with platform-aware
# linker selection and adding self-contained executable SMF support.
#
# Three linking modes:
#   link_to_native()         - Platform-detected native binary (mold/lld/ld)
#   link_to_smf()            - SMF module file
#   link_to_self_contained() - Runtime + SMF data in one executable
#
# Self-contained binary format (trailer-based):
#   [Runtime Binary] [SMF Data] [32-byte Trailer]
#   Trailer: "SMFE"(4) + smf_offset(8) + smf_size(8) + checksum(8) + version(4)
#
# Interpreter-safe: no generics (<>) used.

use std.io_runtime.{ShellResult, shell, shell_output, file_exists, file_copy, file_delete, file_size_raw, env_get, host_os, host_arch, process_run, cwd}

use compiler.linker.mold.{MoldBackend, MoldConfig, find_linker, LinkerType, execute_linker, create_temp_dir, cleanup_temp_dir, linker_file_size}
use compiler.linker.smf_enums.{Platform, Arch}

# ============================================================================
# Configuration Structs
# ============================================================================

struct NativeLinkConfig:
    libraries: [text]
    library_paths: [text]
    runtime_path: text       # Path to libsimple_compiler (empty = auto-detect)
    pie: bool
    debug: bool
    verbose: bool
    extra_flags: [text]

fn NativeLinkConfig__default() -> NativeLinkConfig:
    NativeLinkConfig(
        libraries: [],
        library_paths: [],
        runtime_path: "",
        pie: true,
        debug: false,
        verbose: false,
        extra_flags: []
    )

struct SelfContainedConfig:
    runtime_binary: text     # Path to bootstrap/simple binary (empty = auto-detect)
    verbose: bool
    strip: bool              # Strip debug symbols from output

fn SelfContainedConfig__default() -> SelfContainedConfig:
    SelfContainedConfig(
        runtime_binary: "",
        verbose: false,
        strip: false
    )

# ============================================================================
# Self-Contained Binary Constants
# ============================================================================

# Trailer magic bytes: "SMFE" (SMF Executable)
val SMFE_MAGIC: [u8] = [83, 77, 70, 69]  # S=83, M=77, F=70, E=69
val SMFE_TRAILER_SIZE: i64 = 32
val SMFE_VERSION: i64 = 1

# ============================================================================
# Native Linking
# ============================================================================

fn link_to_native(object_files: [text], output: text, config: NativeLinkConfig) -> Result:
    if object_files.len() == 0:
        return Err("No object files to link")

    val os = host_os()

    # Platform-specific linking
    if os == "windows":
        return link_native_windows(object_files, output, config)

    # Unix-like: Linux, macOS, FreeBSD
    link_native_unix(object_files, output, config)

fn link_native_unix(object_files: [text], output: text, config: NativeLinkConfig) -> Result:
    val os = host_os()

    # Try to find platform linker (mold > lld > ld)
    val linker_result = find_linker()
    if linker_result.is_err():
        # Fall back to cc (always available on Unix)
        return link_native_cc(object_files, output, config)

    val linker_info = linker_result.unwrap()
    val linker_path = linker_info[0]
    val linker_type = linker_info[1]

    if config.verbose:
        print "[linker-wrapper] Using {linker_type.to_string()} at {linker_path}"

    # Build linker arguments
    var args: [text] = []

    # Output file
    args.push("-o")
    args.push(output)

    # Object files
    for obj in object_files:
        args.push(obj)

    # Library paths
    for lp in config.library_paths:
        args.push("-L")
        args.push(lp)

    # Auto-detect runtime library if not specified
    var runtime_dir = config.runtime_path
    if runtime_dir == "":
        runtime_dir = find_runtime_lib_dir()
    if runtime_dir != "":
        args.push("-L")
        args.push(runtime_dir)
        args.push("-lsimple_compiler")
        args.push("-Wl,-rpath,{runtime_dir}")

    # Standard libraries
    if os == "linux":
        args.push("-lc")
        args.push("-lpthread")
        args.push("-ldl")
        args.push("-lm")
        args.push("-lgcc_s")
    elif os == "macos":
        args.push("-lc")
        args.push("-lpthread")
        args.push("-lm")
        args.push("-lSystem")
    elif os == "freebsd":
        args.push("-lc")
        args.push("-lpthread")
        args.push("-lm")

    # Libraries from config
    for lib in config.libraries:
        args.push("-l")
        args.push(lib)

    # PIE
    if config.pie:
        args.push("-pie")

    # Debug info
    if config.debug:
        args.push("-g")

    # Extra flags
    for flag in config.extra_flags:
        args.push(flag)

    # Execute linker
    val exec_result = execute_linker(linker_path, args)
    if exec_result.is_err():
        return Err(exec_result.unwrap_err())

    if config.verbose:
        val size = linker_file_size(output)
        print "[linker-wrapper] Native binary: {output} ({size} bytes)"

    Ok(output)

fn link_native_cc(object_files: [text], output: text, config: NativeLinkConfig) -> Result:
    # Fallback: use cc (gcc/clang) for linking
    var cmd = "cc"
    for obj in object_files:
        cmd = cmd + " " + obj

    # Library paths
    for lp in config.library_paths:
        cmd = cmd + " -L" + lp

    # Auto-detect runtime library
    var runtime_dir = config.runtime_path
    if runtime_dir == "":
        runtime_dir = find_runtime_lib_dir()
    if runtime_dir != "":
        cmd = cmd + " -L{runtime_dir} -lsimple_compiler"
        cmd = cmd + " -Wl,-rpath,{runtime_dir}"

    # Standard libraries
    cmd = cmd + " -lc -lpthread -ldl -lm -lgcc_s"

    # Libraries from config
    for lib in config.libraries:
        cmd = cmd + " -l" + lib

    # Extra flags
    for flag in config.extra_flags:
        cmd = cmd + " " + flag

    cmd = cmd + " -o " + output

    if config.verbose:
        print "[linker-wrapper] cc command: {cmd}"

    val result = shell(cmd)
    if result.exit_code == 0:
        Ok(output)
    else:
        val err_msg = result.stderr ?? "Unknown linking error"
        Err("cc linking failed: {err_msg}")

fn link_native_windows(object_files: [text], output: text, config: NativeLinkConfig) -> Result:
    # Windows linking via lld-link or MSVC link.exe
    # Try lld-link first
    val lld_check = shell("where lld-link 2>nul")
    var linker_cmd = "link"
    if lld_check.exit_code == 0:
        linker_cmd = "lld-link"

    var cmd = linker_cmd
    for obj in object_files:
        cmd = cmd + " " + obj

    cmd = cmd + " /OUT:{output}"

    # Libraries
    for lib in config.libraries:
        cmd = cmd + " {lib}.lib"

    # Extra flags
    for flag in config.extra_flags:
        cmd = cmd + " " + flag

    if config.verbose:
        print "[linker-wrapper] Windows linker: {cmd}"

    val result = shell(cmd)
    if result.exit_code == 0:
        Ok(output)
    else:
        val err_msg = result.stderr ?? "Unknown linking error"
        Err("Windows linking failed: {err_msg}")

# ============================================================================
# SMF Linking
# ============================================================================

fn link_to_smf(smf_bytes: [u8], output: text, verbose: bool) -> Result:
    # Write SMF bytes directly to file
    # Use shell to write binary data via base64 encoding
    if smf_bytes.len() == 0:
        return Err("No SMF data to write")

    # Write bytes using file_write_bytes helper
    val wrote = write_bytes_to_file(output, smf_bytes)
    if not wrote:
        return Err("Failed to write SMF file: {output}")

    if verbose:
        print "[linker-wrapper] SMF module: {output} ({smf_bytes.len()} bytes)"

    Ok(output)

# ============================================================================
# Self-Contained Linking
# ============================================================================

fn link_to_self_contained(smf_data: [u8], output: text, config: SelfContainedConfig) -> Result:
    if smf_data.len() == 0:
        return Err("No SMF data for self-contained binary")

    # Find runtime binary
    var runtime_path = config.runtime_binary
    if runtime_path == "":
        val found = find_runtime_binary()
        if found.is_err():
            return Err(found.unwrap_err())
        runtime_path = found.unwrap()

    if config.verbose:
        print "[linker-wrapper] Runtime binary: {runtime_path}"

    # Step 1: Copy runtime binary to output
    if not file_copy(runtime_path, output):
        return Err("Failed to copy runtime binary to {output}")

    # Step 2: Get runtime binary size (= offset where SMF data starts)
    val runtime_size = file_size_raw(output)
    if runtime_size <= 0:
        file_delete(output)
        return Err("Runtime binary is empty or unreadable")

    # Step 3: Append SMF data to output
    val append_ok = append_bytes_to_file(output, smf_data)
    if not append_ok:
        file_delete(output)
        return Err("Failed to append SMF data to output")

    # Step 4: Build and append trailer (32 bytes)
    val smf_offset = runtime_size
    val smf_size = smf_data.len()
    val checksum = fnv1a_hash(smf_data)
    val trailer = build_trailer(smf_offset, smf_size, checksum)

    val trailer_ok = append_bytes_to_file(output, trailer)
    if not trailer_ok:
        file_delete(output)
        return Err("Failed to append trailer to output")

    # Step 5: Make output executable
    val os = host_os()
    if os != "windows":
        shell("chmod +x '{output}'")

    val total_size = file_size_raw(output)
    if config.verbose:
        print "[linker-wrapper] Self-contained binary: {output}"
        print "[linker-wrapper]   Runtime: {runtime_size} bytes"
        print "[linker-wrapper]   SMF data: {smf_size} bytes"
        print "[linker-wrapper]   Trailer: {SMFE_TRAILER_SIZE} bytes"
        print "[linker-wrapper]   Total: {total_size} bytes"

    Ok(output)

# ============================================================================
# Self-Contained Detection
# ============================================================================

fn detect_self_contained(exe_path: text) -> Result:
    # Read the last 32 bytes of the binary to check for SMFE trailer
    val total_size = file_size_raw(exe_path)
    if total_size < SMFE_TRAILER_SIZE:
        return Err("File too small for self-contained detection")

    # Read trailer using dd (portable across platforms)
    val trailer_offset = total_size - SMFE_TRAILER_SIZE
    val hex_result = shell("dd if='{exe_path}' bs=1 skip={trailer_offset} count={SMFE_TRAILER_SIZE} 2>/dev/null | od -A n -t x1 | tr -d ' \\n'")
    if hex_result.exit_code != 0:
        return Err("Failed to read trailer bytes")

    val hex = hex_result.stdout
    if hex.len() < 8:
        return Err("Trailer too short")

    # Check magic: "SMFE" = 53 4d 46 45
    val magic_hex = hex[0:8]
    if magic_hex != "534d4645":
        return Err("No SMFE magic found")

    # Parse trailer fields from hex
    val smf_offset = parse_hex_u64(hex, 8)
    val smf_size = parse_hex_u64(hex, 24)

    Ok("{smf_offset},{smf_size}")

# ============================================================================
# Runtime Binary Discovery
# ============================================================================

fn find_runtime_binary() -> Result:
    # 1. Check SIMPLE_RUNTIME_BINARY env var
    val env_path = env_get("SIMPLE_RUNTIME_BINARY")
    if env_path != "" and file_exists(env_path):
        return Ok(env_path)

    val current_dir = cwd()
    val os = host_os()
    val arch = host_arch()

    # 2. Check platform-specific path
    var platform_name = os + "-" + arch
    val platform_path = "{current_dir}/bin/bootstrap/{platform_name}/simple"
    if file_exists(platform_path):
        return Ok(platform_path)

    # 3. Check generic bootstrap path
    val generic_path = "{current_dir}/bin/bootstrap/simple"
    if file_exists(generic_path):
        return Ok(generic_path)

    # 4. Check ./bin/bootstrap/simple (relative)
    if file_exists("./bin/bootstrap/simple"):
        return Ok("./bin/bootstrap/simple")

    Err("Runtime binary not found. Set SIMPLE_RUNTIME_BINARY or ensure bin/bootstrap/simple exists.")

fn find_runtime_lib_dir() -> text:
    # Check env var first
    val env_path = env_get("SIMPLE_RUNTIME_PATH")
    if env_path != "" and file_exists(env_path):
        return env_path

    # Check standard paths
    if file_exists("rust/target/debug/libsimple_compiler.so"):
        return "rust/target/debug"
    if file_exists("rust/target/release/libsimple_compiler.so"):
        return "rust/target/release"

    # No runtime library found - return empty (native linking may still work without it)
    ""

# ============================================================================
# Trailer Building
# ============================================================================

fn build_trailer(smf_offset: i64, smf_size: i64, checksum: i64) -> [u8]:
    var buf: [u8] = []

    # Magic: "SMFE" (4 bytes)
    buf = buf + (SMFE_MAGIC)

    # SMF offset (8 bytes, little-endian)
    buf = buf + (i64_to_le_bytes(smf_offset))

    # SMF size (8 bytes, little-endian)
    buf = buf + (i64_to_le_bytes(smf_size))

    # Checksum (8 bytes, little-endian)
    buf = buf + (i64_to_le_bytes(checksum))

    # Version (4 bytes, little-endian)
    buf = buf + (i32_to_le_bytes(SMFE_VERSION))

    buf

# ============================================================================
# Hash Function
# ============================================================================

fn fnv1a_hash(data: [u8]) -> i64:
    # FNV-1a 64-bit hash
    # Offset basis 0xcbf29ce484222325 as signed i64
    var hash: i64 = -3750763034362895579
    for byte in data:
        val b = byte
        hash = hash xor b
        hash = hash * 1099511628211
    hash

# ============================================================================
# Binary Helpers
# ============================================================================

fn i64_to_le_bytes(value: i64) -> [u8]:
    [
        (value & 0xFF),
        ((value >> 8) & 0xFF),
        ((value >> 16) & 0xFF),
        ((value >> 24) & 0xFF),
        ((value >> 32) & 0xFF),
        ((value >> 40) & 0xFF),
        ((value >> 48) & 0xFF),
        ((value >> 56) & 0xFF)
    ]

fn i32_to_le_bytes(value: i64) -> [u8]:
    [
        (value & 0xFF),
        ((value >> 8) & 0xFF),
        ((value >> 16) & 0xFF),
        ((value >> 24) & 0xFF)
    ]

fn parse_hex_u64(hex: text, offset: i64) -> i64:
    # Parse 16 hex chars (8 bytes) as little-endian u64
    var result: i64 = 0
    var i = 0
    for idx in range(0, 8):
        val pos = offset + (idx * 2)
        if pos + 2 <= hex.len():
            val byte_hex = hex[pos:pos + 2]
            val byte_val = hex_byte_to_int(byte_hex)
            result = result | (byte_val << (idx * 8))
        i = i + 1
    result

fn hex_byte_to_int(hex: text) -> i64:
    if hex.len() < 2:
        return 0
    val hi = hex_char_to_int(hex[0:1])
    val lo = hex_char_to_int(hex[1:2])
    (hi * 16) + lo

fn hex_char_to_int(c: text) -> i64:
    match c:
        case "0": 0
        case "1": 1
        case "2": 2
        case "3": 3
        case "4": 4
        case "5": 5
        case "6": 6
        case "7": 7
        case "8": 8
        case "9": 9
        case "a" | "A": 10
        case "b" | "B": 11
        case "c" | "C": 12
        case "d" | "D": 13
        case "e" | "E": 14
        case "f" | "F": 15
        case _: 0

# ============================================================================
# File I/O Helpers (using shell for binary data)
# ============================================================================

fn write_bytes_to_file(path: text, data: [u8]) -> bool:
    # For binary data, use a temp file approach with printf
    # Write each byte using shell's printf with octal escapes
    # For efficiency, batch into chunks
    if data.len() == 0:
        val result = shell("touch '{path}'")
        return result.exit_code == 0

    # Use base64 encoding via shell for reliable binary transfer
    var hex_str = ""
    for byte in data:
        val b = byte & 0xFF
        val hi = "0123456789abcdef"[(b >> 4):((b >> 4) + 1)]
        val lo = "0123456789abcdef"[(b & 0xF):((b & 0xF) + 1)]
        hex_str = hex_str + hi + lo

    # Write hex data and decode with xxd
    val result = shell("echo '{hex_str}' | xxd -r -p > '{path}'")
    result.exit_code == 0

fn append_bytes_to_file(path: text, data: [u8]) -> bool:
    if data.len() == 0:
        return true

    # Convert to hex and append using xxd
    var hex_str = ""
    for byte in data:
        val b = byte & 0xFF
        val hi = "0123456789abcdef"[(b >> 4):((b >> 4) + 1)]
        val lo = "0123456789abcdef"[(b & 0xF):((b & 0xF) + 1)]
        hex_str = hex_str + hi + lo

    val result = shell("echo '{hex_str}' | xxd -r -p >> '{path}'")
    result.exit_code == 0

# ============================================================================
# Exports
# ============================================================================

export NativeLinkConfig, NativeLinkConfig__default
export SelfContainedConfig, SelfContainedConfig__default
export link_to_native, link_to_smf, link_to_self_contained
export detect_self_contained, find_runtime_binary, find_runtime_lib_dir
export build_trailer, fnv1a_hash
export SMFE_MAGIC, SMFE_TRAILER_SIZE, SMFE_VERSION
