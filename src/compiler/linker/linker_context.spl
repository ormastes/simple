# Linker Compilation Context
#
# CompilationContext implementation for link-time lazy instantiation.
# Templates come from input SMF object files.

use ../compilation_context.{CompilationContext, InstantiationMode, ContractMode, GenericTemplate, ConcreteType, TypeRegistry}
use ../backend_types.CompiledUnit
use ../di.DiContainer
use ../aop.AopWeaver
use ../pipeline_fn.compile_specialized_template
use ../monomorphize/note_sdn.InstantiationEntry

# ============================================================================
# LinkerCompilationContext
# ============================================================================

class LinkerCompilationContext(CompilationContext):
    """Linker loads templates from input SMF object files."""
    object_templates: Dict<text, GenericTemplate>
    project_di: DiContainer?
    project_aop: AopWeaver?
    type_reg: TypeRegistry
    recorded: [InstantiationEntry]

    fn load_template(name: text) -> Result<GenericTemplate, text>:
        if self.object_templates.contains_key(name):
            Ok(self.object_templates[name])
        else:
            Err("Template not in objects: {name}")

    fn has_template(name: text) -> bool:
        self.object_templates.contains_key(name)

    fn type_registry() -> TypeRegistry:
        self.type_reg

    fn contract_mode() -> ContractMode:
        # Linker applies all contracts
        ContractMode.All

    fn di_container() -> DiContainer?:
        self.project_di

    fn aop_weaver() -> AopWeaver?:
        self.project_aop

    fn coverage_enabled() -> bool:
        false

    fn compile_template(template: GenericTemplate, type_args: [ConcreteType]) -> Result<CompiledUnit, text>:
        compile_specialized_template(
            template, type_args,
            ContractMode.All,
            self.project_di,
            self.project_aop,
            false
        )

    fn instantiation_mode() -> InstantiationMode:
        InstantiationMode.LinkTime

    me record_instantiation(entry: InstantiationEntry):
        self.recorded = self.recorded.push(entry)

impl LinkerCompilationContext:
    static fn from_objects(
        templates: Dict<text, GenericTemplate>,
        di: DiContainer?,
        aop: AopWeaver?
    ) -> LinkerCompilationContext:
        LinkerCompilationContext(
            object_templates: templates,
            project_di: di,
            project_aop: aop,
            type_reg: TypeRegistry.empty(),
            recorded: []
        )

# ============================================================================
# Exports
# ============================================================================

export LinkerCompilationContext
