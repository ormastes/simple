# Trait Coherence Checking
#
# Verifies trait implementation coherence: orphan rules, overlapping impls,
# blanket impl conflicts, and associated type consistency.
#
# Port of rust/compiler/src/trait_coherence.rs (451 lines)

export CoherenceError, ImplInfo, CoherenceChecker

# ============================================================================
# Coherence Errors
# ============================================================================

enum CoherenceError:
    OrphanImpl(trait_name: text, target_type: text, suggestion: text?)
    OverlappingImpl(trait_name: text, type1: text, type2: text)
    ConflictingAssociatedType(trait_name: text, target_type: text, type_name: text)
    BlanketImplConflict(trait_name: text, general: text, specific: text)

impl CoherenceError:
    fn message() -> text:
        match self:
            case OrphanImpl(tr, ty, sugg):
                val base = "Cannot implement foreign trait '{tr}' for foreign type '{ty}'"
                if sugg.?: "{base}\n\nSuggestion: {sugg.unwrap()}"
                else: base
            case OverlappingImpl(tr, t1, t2):
                "Overlapping implementations of trait '{tr}' for types '{t1}' and '{t2}'"
            case ConflictingAssociatedType(tr, ty, tn):
                "Conflicting associated type '{tn}' in trait '{tr}' for type '{ty}'"
            case BlanketImplConflict(tr, gen, spec):
                "Blanket implementation '{gen}' for trait '{tr}' conflicts with specific implementation '{spec}'"

# ============================================================================
# Impl Registry Entry
# ============================================================================

struct ImplInfo:
    target_type: text
    trait_name: text?
    generic_params: [text]
    is_blanket: bool
    is_default: bool
    associated_types: {text: text}

# ============================================================================
# Coherence Checker
# ============================================================================

class CoherenceChecker:
    """Checks trait implementation coherence rules."""
    local_traits: [text]
    local_types: [text]
    impls: {text: [ImplInfo]}       # trait_name -> list of impls

impl CoherenceChecker:
    static fn create() -> CoherenceChecker:
        CoherenceChecker(local_traits: [], local_types: [], impls: {})

    me register_trait(name: text):
        if not self.local_traits.contains(name):
            self.local_traits = self.local_traits.push(name)

    me register_type(name: text):
        if not self.local_types.contains(name):
            self.local_types = self.local_types.push(name)

    me register_impl(info: ImplInfo):
        val key = info.trait_name ?? "_no_trait_"
        if not self.impls.contains_key(key):
            self.impls[key] = []
        self.impls[key] = self.impls[key].push(info)

    me check_all() -> [CoherenceError]:
        """Run all coherence checks."""
        var errors: [CoherenceError] = []
        errors = errors.merge(self.check_orphan_rules())
        errors = errors.merge(self.check_overlapping_impls())
        errors = errors.merge(self.check_blanket_conflicts())
        errors

    fn check_orphan_rules() -> [CoherenceError]:
        """Orphan rule: at least one of trait or type must be local."""
        var errors: [CoherenceError] = []
        for (trait_name, impl_list) in self.impls:
            if trait_name == "_no_trait_":
                continue
            for info in impl_list:
                val trait_local = self.local_traits.contains(trait_name)
                val type_local = self.local_types.contains(info.target_type)
                if not trait_local and not type_local:
                    val suggestion = if self.local_types.?:
                        Some("Create a newtype wrapper in your module")
                    else:
                        nil
                    errors = errors.push(CoherenceError.OrphanImpl(
                        trait_name: trait_name, target_type: info.target_type,
                        suggestion: suggestion))
        errors

    fn check_overlapping_impls() -> [CoherenceError]:
        """Check for overlapping implementations of the same trait."""
        var errors: [CoherenceError] = []
        for (trait_name, impl_list) in self.impls:
            if trait_name == "_no_trait_":
                continue
            # Check each pair for overlap
            for i in 0..impl_list.len():
                for j in (i + 1)..impl_list.len():
                    val a = impl_list[i]
                    val b = impl_list[j]
                    # Simple overlap: same concrete type
                    if (not a.is_blanket and not b.is_blanket and
                       a.target_type == b.target_type):
                        errors = errors.push(CoherenceError.OverlappingImpl(
                            trait_name: trait_name,
                            type1: a.target_type, type2: b.target_type))
        errors

    fn check_blanket_conflicts() -> [CoherenceError]:
        """Check blanket impls don't conflict with specific ones."""
        var errors: [CoherenceError] = []
        for (trait_name, impl_list) in self.impls:
            val blankets = impl_list.filter(\i: i.is_blanket and not i.is_default)
            val specifics = impl_list.filter(\i: not i.is_blanket)
            for blanket in blankets:
                for specific in specifics:
                    # Blanket could cover the specific type
                    if not specific.is_default:
                        errors = errors.push(CoherenceError.BlanketImplConflict(
                            trait_name: trait_name,
                            general: blanket.target_type,
                            specific: specific.target_type))
        errors
