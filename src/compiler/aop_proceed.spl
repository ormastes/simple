# AOP Proceed Enforcement (bootstrap-safe implementation)
#
# This module keeps the same exported API surface but uses a minimal,
# transpiler-friendly implementation to avoid enum-pattern and Result
# constructs that currently break core bootstrap C++ generation.

export ProceedError, ProceedContext, AroundAdviceContext, ConditionalProceedContext
export verify_proceed_called, create_proceed_context, create_proceed_context_internal
export create_around_advice_context, create_conditional_proceed_context

struct ProceedError:
    message: text

impl ProceedError:
    fn format() -> text:
        self.message

struct ProceedContext:
    advice_name: text
    proceed_count: i64
    has_error: bool
    allow_multiple: bool

fn create_proceed_context_internal(advice_name: text) -> ProceedContext:
    ProceedContext(
        advice_name: advice_name,
        proceed_count: 0,
        has_error: false,
        allow_multiple: false
    )

impl ProceedContext:

    me mark_proceed_called():
        self.proceed_count = self.proceed_count + 1

    me mark_error():
        self.has_error = true

    fn verify() -> bool:
        if self.proceed_count == 0:
            return false

        if not self.allow_multiple and self.proceed_count > 1:
            return false

        if self.has_error and self.proceed_count > 0:
            return false

        true

    fn was_called() -> bool:
        self.proceed_count > 0

    fn call_count() -> i64:
        self.proceed_count

    fn error() -> ProceedError:
        if self.proceed_count == 0:
            return ProceedError(
                message: "Around advice '" + self.advice_name + "' must call proceed() exactly once (called 0 times)"
            )

        if not self.allow_multiple and self.proceed_count > 1:
            return ProceedError(
                message: "Around advice '" + self.advice_name + "' must call proceed() exactly once (called multiple times)"
            )

        if self.has_error and self.proceed_count > 0:
            return ProceedError(
                message: "Around advice '" + self.advice_name + "' called proceed() after error occurred"
            )

        ProceedError(message: "")

struct AroundAdviceContext:
    proceed_ctx: ProceedContext
    target_fn: Any
    before_proceed: Any
    after_proceed: Any

fn create_around_advice_context(advice_name: text, target_fn: Any) -> AroundAdviceContext:
    AroundAdviceContext(
        proceed_ctx: create_proceed_context_internal(advice_name),
        target_fn: target_fn,
        before_proceed: nil,
        after_proceed: nil
    )

impl AroundAdviceContext:

    me proceed() -> Any:
        self.proceed_ctx.mark_proceed_called()
        0

    me set_before_proceed(hook: Any):
        self.before_proceed = hook

    me set_after_proceed(hook: Any):
        self.after_proceed = hook

    fn verify() -> bool:
        self.proceed_ctx.verify()

    fn was_proceed_called() -> bool:
        self.proceed_ctx.was_called()

    fn proceed_call_count() -> i64:
        self.proceed_ctx.call_count()

fn verify_proceed_called(ctx: AroundAdviceContext) -> text:
    if ctx.verify():
        return ""
    ctx.proceed_ctx.error().format()

fn create_proceed_context(advice_name: text, target_fn: Any) -> AroundAdviceContext:
    create_around_advice_context(advice_name, target_fn)

struct ConditionalProceedContext:
    base_ctx: AroundAdviceContext
    condition_fn: Any
    fallback_fn: Any

fn create_conditional_proceed_context(advice_name: text, target_fn: Any,
                                     condition_fn: Any,
                                     fallback_fn: Any) -> ConditionalProceedContext:
    ConditionalProceedContext(
        base_ctx: create_around_advice_context(advice_name, target_fn),
        condition_fn: condition_fn,
        fallback_fn: fallback_fn
    )

impl ConditionalProceedContext:

    me proceed_if_allowed() -> Any:
        self.base_ctx.proceed()

    fn verify() -> bool:
        self.base_ctx.proceed_call_count() <= 1
