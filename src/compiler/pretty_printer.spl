# Pretty Printer
#
# AST-based pretty printer for Simple language code formatting.
# Traverses AST nodes to produce properly indented source code.
#
# Port of rust/compiler/src/pretty_printer.rs (1028 lines)

export PrettyConfig, PrettyPrinter

# ============================================================================
# Configuration
# ============================================================================

struct PrettyConfig:
    indent_size: i64
    max_line_length: i64

impl PrettyConfig:
    static fn default_config() -> PrettyConfig:
        PrettyConfig(indent_size: 4, max_line_length: 100)

# ============================================================================
# Pretty Printer
# ============================================================================

class PrettyPrinter:
    """AST-based code formatter."""
    config: PrettyConfig
    indent_level: i64
    output: text

impl PrettyPrinter:
    static fn create(config: PrettyConfig) -> PrettyPrinter:
        PrettyPrinter(config: config, indent_level: 0, output: "")

    static fn with_defaults() -> PrettyPrinter:
        PrettyPrinter__create(PrettyConfig__default_config())

    fn indent() -> text:
        " ".repeat(self.indent_level * self.config.indent_size)

    me write_line(line: text):
        self.output = self.output + self.indent() + line + "\n"

    me write(s: text):
        self.output = self.output + s

    me write_indent():
        self.output = self.output + self.indent()

    me indent_inc():
        self.indent_level = self.indent_level + 1

    me indent_dec():
        if self.indent_level > 0:
            self.indent_level = self.indent_level - 1

    me blank_line():
        self.output = self.output + "\n"

    # ---- Node printers ----

    me print_function(name: text, params: [text], return_type: text?,
                       is_static: bool, is_me: bool, body: [text]):
        self.write_indent()
        if is_static:
            self.write("static ")
        if is_me:
            self.write("me ")
        else:
            self.write("fn ")
        self.write(name)
        self.write("({params.join(\", \")})")
        if return_type.?:
            self.write(" -> {return_type.unwrap()}")
        self.write(":\n")
        self.indent_inc()
        for line in body:
            self.write_line(line)
        self.indent_dec()

    me print_struct(name: text, fields: [(text, text)]):
        self.write_line("struct {name}:")
        self.indent_inc()
        for (fname, ftype) in fields:
            self.write_line("{fname}: {ftype}")
        self.indent_dec()

    me print_class(name: text, fields: [(text, text)]):
        self.write_line("class {name}:")
        self.indent_inc()
        for (fname, ftype) in fields:
            self.write_line("{fname}: {ftype}")
        self.indent_dec()

    me print_enum(name: text, variants: [text]):
        self.write_line("enum {name}:")
        self.indent_inc()
        for v in variants:
            self.write_line(v)
        self.indent_dec()

    me print_impl(target: text, methods: [text]):
        self.write_line("impl {target}:")
        self.indent_inc()
        for method in methods:
            self.write_line(method)
        self.indent_dec()

    me print_if(condition: text, then_body: [text], else_body: [text]):
        self.write_line("if {condition}:")
        self.indent_inc()
        for line in then_body:
            self.write_line(line)
        self.indent_dec()
        if else_body.?:
            self.write_line("else:")
            self.indent_inc()
            for line in else_body:
                self.write_line(line)
            self.indent_dec()

    me print_for(var_name: text, iterable: text, body: [text]):
        self.write_line("for {var_name} in {iterable}:")
        self.indent_inc()
        for line in body:
            self.write_line(line)
        self.indent_dec()

    me print_while(condition: text, body: [text]):
        self.write_line("while {condition}:")
        self.indent_inc()
        for line in body:
            self.write_line(line)
        self.indent_dec()

    me print_match(expr: text, arms: [(text, [text])]):
        self.write_line("match {expr}:")
        self.indent_inc()
        for (pattern, body) in arms:
            self.write_line("case {pattern}:")
            self.indent_inc()
            for line in body:
                self.write_line(line)
            self.indent_dec()
        self.indent_dec()

    me print_val(name: text, type_ann: text?, value: text):
        if type_ann.?:
            self.write_line("val {name}: {type_ann.unwrap()} = {value}")
        else:
            self.write_line("val {name} = {value}")

    me print_var(name: text, type_ann: text?, value: text):
        if type_ann.?:
            self.write_line("var {name}: {type_ann.unwrap()} = {value}")
        else:
            self.write_line("var {name} = {value}")

    me print_use(path: text):
        self.write_line("use {path}")

    me print_export(names: [text]):
        self.write_line("export {names.join(\", \")}")

    me print_comment(content: text):
        self.write_line("# {content}")

    me print_doc_comment(content: text):
        self.write_line("\"\"\"")
        for line in content.lines():
            self.write_line(line)
        self.write_line("\"\"\"")

    fn get_output() -> text:
        self.output

    me reset():
        self.output = ""
        self.indent_level = 0
