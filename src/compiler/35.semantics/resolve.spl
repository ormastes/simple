# Method Resolution Pass (UFCS Support)
#
# Resolves method calls using UFCS (Uniform Function Call Syntax) rules:
#   1. Instance method on receiver's type (highest priority)
#   2. Trait method implemented by receiver's type
#   3. Free function where receiver becomes first argument (UFCS)
#
# Example:
#   x.map()  -> InstanceMethod if x's class has map()
#   x.map()  -> TraitMethod if x implements trait with map()
#   x.map()  -> FreeFunction(map) if map(x) exists
#
# This pass runs after type inference to have full type information.
# Resolution strategies are in resolve_strategies.spl

use hir.*
use lexer.Span
use compiler.traits.*
use compiler.35.semantics.resolve_strategies.*

# ============================================================================
# Type Compatibility
# ============================================================================

struct TypeChecker:
    """Type compatibility checking for UFCS resolution."""

    fn is_compatible(self, a: HirType, b: HirType) -> bool:
        """Check if type `a` is compatible with type `b` for UFCS.

        For UFCS, we check if the receiver type can be passed as the
        first parameter of a function. This includes:
        - Exact type match
        - Reference compatibility (T matches &T, &mut T)
        - Subtype relationships
        """
        match (a.kind, b.kind):
            # Exact matches
            case (Int(bits_a, signed_a), Int(bits_b, signed_b)):
                bits_a == bits_b and signed_a == signed_b
            case (Float(bits_a), Float(bits_b)):
                bits_a == bits_b
            case (Bool, Bool): true
            case (Char, Char): true
            case (Str, Str): true
            case (Unit, Unit): true

            # Named types (classes, structs, enums)
            case (Named(sym_a, args_a), Named(sym_b, args_b)):
                if sym_a.id != sym_b.id:
                    false
                elif args_a.len() != args_b.len():
                    false
                else:
                    var compatible = true
                    var i = 0
                    while i < args_a.len() and compatible:
                        compatible = self.is_compatible(args_a[i], args_b[i])
                        i = i + 1
                    compatible

            # Reference types - T is compatible with &T and &mut T
            case (_, Ref(inner, _)):
                self.is_compatible(a, inner)

            # Array types
            case (Array(elem_a, _), Array(elem_b, _)):
                self.is_compatible(elem_a, elem_b)

            # Slice types
            case (Slice(elem_a), Slice(elem_b)):
                self.is_compatible(elem_a, elem_b)

            # Optional types
            case (Optional(inner_a), Optional(inner_b)):
                self.is_compatible(inner_a, inner_b)

            # Type parameters - compatible if same name
            case (TypeParam(name_a, _), TypeParam(name_b, _)):
                name_a == name_b

            # Inference variables - always compatible (will be unified)
            case (Infer(_, _), _): true
            case (_, Infer(_, _)): true

            # Default: not compatible
            case _: false

    fn get_type_symbol(ty: HirType) -> SymbolId?:
        """Get the symbol ID for a named type."""
        match ty.kind:
            case Named(sym, _): Some(sym)
            case _: nil

# ============================================================================
# Method Resolver
# ============================================================================

class MethodResolver:
    """Resolves method calls using UFCS rules.

    Walks the HIR and resolves each MethodCall expression by trying:
    1. Instance method on the receiver's type
    2. Trait method implemented by the receiver's type
    3. Free function where receiver becomes first argument

    The resolver modifies the `resolution` field of MethodCall expressions.
    """

    symbols: SymbolTable
    type_checker: TypeChecker
    errors: [ResolveError]
    # Track implemented traits for types (type_id -> [trait_id])
    trait_impls: Dict<i64, [SymbolId]>
    # Enhanced trait solver with generic matching, coherence checking, supertrait resolution
    trait_solver: TraitSolver

    static fn new(symbols: SymbolTable) -> MethodResolver:
        MethodResolver(
            symbols: symbols,
            type_checker: TypeChecker(),
            errors: [],
            trait_impls: {},
            trait_solver: TraitSolver.new()
        )

    static fn with_trait_solver(symbols: SymbolTable, solver: TraitSolver) -> MethodResolver:
        """Create a MethodResolver with an existing TraitSolver (for integration with type inference)."""
        MethodResolver(
            symbols: symbols,
            type_checker: TypeChecker(),
            errors: [],
            trait_impls: {},
            trait_solver: solver
        )

    # ========================================================================
    # Module Resolution
    # ========================================================================

    me resolve_module(module: HirModule) -> HirModule:
        """Resolve all method calls in a module."""
        # Build trait implementation map from impls
        self.build_trait_impls(module.impls)

        # Resolve functions
        var resolved_functions: Dict<SymbolId, HirFunction> = {}
        for key in module.functions.keys():
            val func = module.functions[key]
            resolved_functions[key] = self.resolve_function(func)

        # Resolve constants
        var resolved_constants: Dict<SymbolId, HirConst> = {}
        for key in module.constants.keys():
            val const_ = module.constants[key]
            resolved_constants[key] = HirConst(
                symbol: const_.symbol,
                name: const_.name,
                type_: const_.type_,
                value: self.resolve_expr(const_.value),
                is_mutable: const_.is_mutable,
                is_public: const_.is_public,
                span: const_.span
            )

        # Return resolved module
        HirModule(
            name: module.name,
            path: module.path,
            imports: module.imports,
            exports: module.exports,
            symbols: module.symbols,
            functions: resolved_functions,
            classes: module.classes,
            structs: module.structs,
            enums: module.enums,
            bitfields: module.bitfields,
            traits: module.traits,
            impls: module.impls,
            constants: resolved_constants,
            static_asserts: module.static_asserts,
            aop_advices: module.aop_advices,
            di_bindings: module.di_bindings,
            arch_rules: module.arch_rules,
            mock_decls: module.mock_decls
        )

    me build_trait_impls(impls: [HirImpl]):
        """Build a map of type -> implemented traits."""
        for impl_ in impls:
            if impl_.trait_.?:
                val type_sym = self.type_checker.get_type_symbol(impl_.type_)
                if type_sym.?:
                    val type_id = type_sym.unwrap().id
                    val trait_sym = self.type_checker.get_type_symbol(impl_.trait_.unwrap())
                    if trait_sym.?:
                        if not self.trait_impls[type_id].?:
                            self.trait_impls[type_id] = []
                        self.trait_impls[type_id] = self.trait_impls[type_id].push(trait_sym.unwrap())

    # ========================================================================
    # Function Resolution
    # ========================================================================

    me resolve_function(func: HirFunction) -> HirFunction:
        """Resolve method calls in a function body."""
        HirFunction(
            symbol: func.symbol,
            name: func.name,
            type_params: func.type_params,
            params: func.params,
            return_type: func.return_type,
            body: self.resolve_block(func.body),
            effects: func.effects,
            is_async: func.is_async,
            is_static: func.is_static,
            is_public: func.is_public,
            is_method: func.is_method,
            is_mutable: func.is_mutable,
            is_const: func.is_const,
            is_extern: func.is_extern,
            func_attr: func.func_attr,
            doc_comment: func.doc_comment,
            span: func.span
        )

    # ========================================================================
    # Block and Statement Resolution
    # ========================================================================

    me resolve_block(block: HirBlock) -> HirBlock:
        """Resolve method calls in a block."""
        var resolved_stmts: [HirStmt] = []
        for stmt in block.stmts:
            resolved_stmts = resolved_stmts.push(self.resolve_stmt(stmt))

        val resolved_value = if block.value.?:
            Some(self.resolve_expr(block.value.unwrap()))
        else:
            nil

        HirBlock(
            stmts: resolved_stmts,
            value: resolved_value,
            span: block.span
        )

    me resolve_stmt(stmt: HirStmt) -> HirStmt:
        """Resolve method calls in a statement."""
        val kind = match stmt.kind:
            case Expr(expr):
                HirStmtKind.Expr(self.resolve_expr(expr))

            case Let(symbol, type_, init):
                HirStmtKind.Let(symbol, type_, self.resolve_expr(init))

            case Assign(target, op, value):
                HirStmtKind.Assign(
                    self.resolve_expr(target),
                    op,
                    self.resolve_expr(value)
                )

            case Block(block):
                HirStmtKind.Block(self.resolve_block(block))

        HirStmt(kind: kind, span: stmt.span)

    # ========================================================================
    # Expression Resolution
    # ========================================================================

    me resolve_expr(expr: HirExpr) -> HirExpr:
        """Resolve method calls in an expression."""
        val kind = match expr.kind:
            # Method calls - the main target
            case MethodCall(receiver, method, args, resolution):
                val resolved_receiver = self.resolve_expr(receiver)
                val resolved_args = self.resolve_call_args(args)

                # Check if this is actually a static method call (Type.method())
                val is_static = self.is_static_method_call(resolved_receiver)

                # Only resolve if not already resolved
                val new_resolution = if resolution.is_resolved():
                    resolution
                elif is_static:
                    self.resolve_static_method(resolved_receiver, method, resolved_args)
                else:
                    self.resolve_method(resolved_receiver, method, resolved_args)

                HirExprKind.MethodCall(resolved_receiver, method, resolved_args, new_resolution)

            # Regular function calls - resolve arguments
            case Call(callee, args, type_args):
                HirExprKind.Call(
                    self.resolve_expr(callee),
                    self.resolve_call_args(args),
                    type_args
                )

            # Literals - no resolution needed
            case IntLit(_, _): expr.kind
            case FloatLit(_, _): expr.kind
            case StringLit(value, interps):
                if interps.?:
                    var resolved_interps: [HirInterpolation] = []
                    for interp in interps.unwrap():
                        resolved_interps = resolved_interps.push(HirInterpolation(
                            expr: self.resolve_expr(interp.expr),
                            format: interp.format,
                            span: interp.span
                        ))
                    HirExprKind.StringLit(value, Some(resolved_interps))
                else:
                    expr.kind
            case BoolLit(_): expr.kind
            case CharLit(_): expr.kind
            case UnitLit: expr.kind
            case NilLit: expr.kind

            # Variables
            case Var(_): expr.kind

            # Field access
            case Field(base, field, resolved):
                HirExprKind.Field(self.resolve_expr(base), field, resolved)

            # Index access
            case Index(base, index):
                HirExprKind.Index(self.resolve_expr(base), self.resolve_expr(index))

            case TupleIndex(base, index):
                HirExprKind.TupleIndex(self.resolve_expr(base), index)

            # Collections
            case ArrayLit(elements, type_):
                var resolved: [HirExpr] = []
                for e in elements:
                    resolved = resolved.push(self.resolve_expr(e))
                HirExprKind.ArrayLit(resolved, type_)

            case TupleLit(elements):
                var resolved: [HirExpr] = []
                for e in elements:
                    resolved = resolved.push(self.resolve_expr(e))
                HirExprKind.TupleLit(resolved)

            case DictLit(entries, key_type, value_type):
                var resolved: [(HirExpr, HirExpr)] = []
                for (k, v) in entries:
                    resolved = resolved.push((self.resolve_expr(k), self.resolve_expr(v)))
                HirExprKind.DictLit(resolved, key_type, value_type)

            # Optional operations
            case OptionalChain(base, field):
                HirExprKind.OptionalChain(self.resolve_expr(base), field)

            case NullCoalesce(left, right):
                HirExprKind.NullCoalesce(self.resolve_expr(left), self.resolve_expr(right))

            case ExistsCheck(base):
                HirExprKind.ExistsCheck(self.resolve_expr(base))

            case Unwrap(base):
                HirExprKind.Unwrap(self.resolve_expr(base))

            # Operators
            case Binary(op, left, right):
                HirExprKind.Binary(op, self.resolve_expr(left), self.resolve_expr(right))

            case Unary(op, operand):
                HirExprKind.Unary(op, self.resolve_expr(operand))

            # Control flow
            case If(cond, then_, else_):
                val resolved_else = if else_.?:
                    Some(self.resolve_block(else_.unwrap()))
                else:
                    nil
                HirExprKind.If(self.resolve_expr(cond), self.resolve_block(then_), resolved_else)

            case MatchCase(scrutinee, arms):
                var resolved_arms: [HirMatchArm] = []
                for arm in arms:
                    val resolved_guard = if arm.guard.?:
                        Some(self.resolve_expr(arm.guard.unwrap()))
                    else:
                        nil
                    resolved_arms = resolved_arms.push(HirMatchArm(
                        pattern: arm.pattern,
                        guard: resolved_guard,
                        body: self.resolve_block(arm.body),
                        span: arm.span
                    ))
                HirExprKind.MatchCase(self.resolve_expr(scrutinee), resolved_arms)

            case Loop(body, label):
                HirExprKind.Loop(self.resolve_block(body), label)

            case While(cond, body, label):
                HirExprKind.While(self.resolve_expr(cond), self.resolve_block(body), label)

            case For(var_, iter, body, label):
                HirExprKind.For(var_, self.resolve_expr(iter), self.resolve_block(body), label)

            # Closures
            case Lambda(params, body, captures):
                HirExprKind.Lambda(params, self.resolve_expr(body), captures)

            case Block(block):
                HirExprKind.Block(self.resolve_block(block))

            # Control transfer
            case Return(value):
                val resolved_value = if value.?: Some(self.resolve_expr(value.unwrap())) else: nil
                HirExprKind.Return(resolved_value)

            case Break(label, value):
                val resolved_value = if value.?: Some(self.resolve_expr(value.unwrap())) else: nil
                HirExprKind.Break(label, resolved_value)

            case Continue(label):
                HirExprKind.Continue(label)

            case Throw(value):
                HirExprKind.Throw(self.resolve_expr(value))

            case Try(e):
                HirExprKind.Try(self.resolve_expr(e))

            # Async
            case Await(e):
                HirExprKind.Await(self.resolve_expr(e))

            case Yield(value):
                val resolved_value = if value.?: Some(self.resolve_expr(value.unwrap())) else: nil
                HirExprKind.Yield(resolved_value)

            # Construction
            case StructLit(type_, fields):
                var resolved_fields: [(text, HirExpr)] = []
                for (name, value) in fields:
                    resolved_fields = resolved_fields.push((name, self.resolve_expr(value)))
                HirExprKind.StructLit(type_, resolved_fields)

            case EnumLit(type_, variant, payload):
                val resolved_payload = if payload.?:
                    match payload.unwrap():
                        case Tuple(values):
                            var resolved: [HirExpr] = []
                            for v in values:
                                resolved = resolved.push(self.resolve_expr(v))
                            Some(HirEnumPayload.Tuple(resolved))
                        case Struct(fields):
                            var resolved: [(text, HirExpr)] = []
                            for (name, value) in fields:
                                resolved = resolved.push((name, self.resolve_expr(value)))
                            Some(HirEnumPayload.Struct(resolved))
                else:
                    nil
                HirExprKind.EnumLit(type_, variant, resolved_payload)

            # Casts
            case Cast(e, target):
                HirExprKind.Cast(self.resolve_expr(e), target)

            case As(e, target):
                HirExprKind.As(self.resolve_expr(e), target)

            # Range
            case Range(start, end, inclusive, step):
                val resolved_start = if start.?: Some(self.resolve_expr(start.unwrap())) else: nil
                val resolved_end = if end.?: Some(self.resolve_expr(end.unwrap())) else: nil
                val resolved_step = if step.?: Some(self.resolve_expr(step.unwrap())) else: nil
                HirExprKind.Range(resolved_start, resolved_end, inclusive, resolved_step)

            # Comprehension
            case Comprehension(kind, e, clauses):
                var resolved_clauses: [HirCompClause] = []
                for clause in clauses:
                    resolved_clauses = resolved_clauses.push(self.resolve_comp_clause(clause))
                HirExprKind.Comprehension(kind, self.resolve_expr(e), resolved_clauses)

            # Custom blocks (pass through - no method resolution needed)
            case CustomBlock(kind, value):
                HirExprKind.CustomBlock(kind, value)

            # Math/DL blocks (resolve expressions in body)
            case LossBlock(body):
                HirExprKind.LossBlock(self.resolve_block(body))

            case NogradBlock(body):
                HirExprKind.NogradBlock(self.resolve_block(body))

            # Error
            case Error: expr.kind

        HirExpr(kind: kind, type_: expr.type_, span: expr.span)

    me resolve_call_args(args: [HirCallArg]) -> [HirCallArg]:
        """Resolve method calls in call arguments."""
        var resolved: [HirCallArg] = []
        for arg in args:
            resolved = resolved.push(HirCallArg(
                name: arg.name,
                value: self.resolve_expr(arg.value),
                span: arg.span
            ))
        resolved

    me resolve_comp_clause(clause: HirCompClause) -> HirCompClause:
        """Resolve method calls in comprehension clause."""
        val kind = match clause.kind:
            case For(var_, iter):
                HirCompClauseKind.For(var_, self.resolve_expr(iter))
            case If(cond):
                HirCompClauseKind.If(self.resolve_expr(cond))

        HirCompClause(kind: kind, span: clause.span)

    # ========================================================================
    # Method Resolution Logic (UFCS)
    # ========================================================================


# ============================================================================
# Resolution Errors
# ============================================================================

struct ResolveError:
    """Error during method resolution."""
    message: text
    span: Span

impl ResolveError:
    fn to_string() -> text:
        "resolve error at {self.span}: {self.message}"

# ============================================================================
# Public API
# ============================================================================

fn resolve_methods(module: HirModule) -> (HirModule, [ResolveError]):
    """Resolve all method calls in a module.

    This is the main entry point for the resolution pass.
    Returns the resolved module and any errors encountered.
    """
    var resolver = MethodResolver.new(module.symbols)
    val resolved = resolver.resolve_module(module)
    (resolved, resolver.get_errors())

fn resolve_methods_with_solver(module: HirModule, solver: TraitSolver) -> (HirModule, [ResolveError]):
    """Resolve all method calls in a module using an existing TraitSolver.

    This variant allows integration with type inference, where the TraitSolver
    has already been populated with trait definitions, impl blocks, and has
    checked trait obligations.

    Use this when:
    - Type inference has already run and created a TraitSolver
    - You want to use enhanced generic type matching for method resolution
    - You need trait bound checking during method resolution
    """
    var resolver = MethodResolver.with_trait_solver(module.symbols, solver)
    val resolved = resolver.resolve_module(module)
    (resolved, resolver.get_errors())
