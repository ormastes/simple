# Trait System for Simple
#
# Implements Rust-style traits:
# - Trait definitions with method signatures
# - Impl blocks for trait implementations
# - Trait bounds on generics (T: Trait)
# - Trait objects for dynamic dispatch (dyn Trait)
# - Obligation-based constraint solving
#
# Design: doc/design/trait_system_design.md

use compiler.hir.*
use compiler.lexer.*

# ============================================================================
# Trait Definition
# ============================================================================

struct TraitDef:
    """Definition of a trait.

    A trait declares method signatures that types can implement.

    Example:
        trait Display:
            fn to_string() -> text
    """
    name: Symbol                    # Trait name
    methods: [MethodSignature]      # Required method signatures
    defaults: [HirFunction]         # Default implementations
    supertraits: [Symbol]           # Supertrait bounds (Trait: Supertrait)
    type_params: [Symbol]           # Generic parameters on trait
    span: Span

impl TraitDef:
    static fn create(name: Symbol, span: Span) -> TraitDef:
        """Create a new trait definition."""
        TraitDef(
            name: name,
            methods: [],
            defaults: [],
            supertraits: [],
            type_params: [],
            span: span
        )

    fn has_method(method_name: text) -> bool:
        """Check if trait has a method with given name."""
        for method in self.methods:
            if method.name == method_name:
                return true
        false

    fn get_method(method_name: text) -> MethodSignature?:
        """Get method signature by name."""
        for method in self.methods:
            if method.name == method_name:
                return Some(method)
        nil

struct MethodSignature:
    """Method signature in a trait definition."""
    name: text                      # Method name
    params: [HirType]               # Parameter types
    return_type: HirType            # Return type
    effects: [Effect]               # Effect annotations
    span: Span

impl MethodSignature:
    fn arity() -> i64:
        """Get number of parameters."""
        self.params.len()

# ============================================================================
# Impl Block
# ============================================================================

struct ImplBlock:
    """Implementation of a trait for a specific type.

    Example:
        impl Display for Point:
            fn to_string() -> text:
                "Point({self.x}, {self.y})"
    """
    trait_name: Symbol              # Which trait is being implemented
    for_type: HirType               # Which type is implementing the trait
    type_params: [Symbol]           # Generic parameters (impl<T> Trait for Vec<T>)
    where_clause: [TraitBound]      # Where T: Trait constraints
    methods: [HirFunction]          # Method implementations
    span: Span

impl ImplBlock:
    static fn create(trait_name: Symbol, for_type: HirType, span: Span) -> ImplBlock:
        """Create a new impl block."""
        ImplBlock(
            trait_name: trait_name,
            for_type: for_type,
            type_params: [],
            where_clause: [],
            methods: [],
            span: span
        )

    fn has_method(method_name: text) -> bool:
        """Check if impl has a method with given name."""
        for method in self.methods:
            if method.name == method_name:
                return true
        false

    fn get_method(method_name: text) -> HirFunction?:
        """Get method implementation by name."""
        for method in self.methods:
            if method.name == method_name:
                return Some(method)
        nil

    fn matches_type(ty: HirType) -> bool:
        """Check if this impl matches the given type.

        Handles generic matching:
        - impl<T> Display for Vec<T> matches Vec<i64>
        - impl Display for Point matches Point

        Returns true if the impl can be instantiated to match ty.
        """
        match_types(self.for_type, ty)

# ============================================================================
# Generic Type Matching (Phase B.3.1)
# ============================================================================

fn match_types(pattern: HirType, concrete: HirType) -> bool:
    """Check if a type pattern matches a concrete type.

    Handles generic matching where pattern may contain type parameters.

    Examples:
    - match_types(Vec<T>, Vec<i64>) → true (T can be i64)
    - match_types(Point, Point) → true
    - match_types(Vec<T>, Point) → false

    Algorithm:
    - If pattern is TypeParam, always matches (can be anything)
    - If both are Named, check name matches and recursively check args
    - Otherwise, check structural equality
    """
    match pattern.kind:
        case TypeParam(_, _):
            # Type parameter matches any concrete type
            true

        case Named(pattern_symbol, pattern_args):
            match concrete.kind:
                case Named(concrete_symbol, concrete_args):
                    # Check if symbols match
                    if pattern_symbol != concrete_symbol:
                        return false

                    # Check if argument counts match
                    if pattern_args.len() != concrete_args.len():
                        return false

                    # Recursively check each type argument
                    for i in 0..pattern_args.len():
                        if not match_types(pattern_args[i], concrete_args[i]):
                            return false

                    true
                case _:
                    false

        case Function(pattern_params, pattern_ret, _):
            match concrete.kind:
                case Function(concrete_params, concrete_ret, _):
                    # Check parameter count
                    if pattern_params.len() != concrete_params.len():
                        return false

                    # Check each parameter
                    for i in 0..pattern_params.len():
                        if not match_types(pattern_params[i], concrete_params[i]):
                            return false

                    # Check return type
                    match_types(pattern_ret, concrete_ret)
                case _:
                    false

        case Tuple(pattern_elems):
            match concrete.kind:
                case Tuple(concrete_elems):
                    if pattern_elems.len() != concrete_elems.len():
                        return false

                    for i in 0..pattern_elems.len():
                        if not match_types(pattern_elems[i], concrete_elems[i]):
                            return false

                    true
                case _:
                    false

        case Array(pattern_elem, pattern_size):
            match concrete.kind:
                case Array(concrete_elem, concrete_size):
                    # Check sizes match (if both specified)
                    if pattern_size.? and concrete_size.?:
                        if pattern_size.unwrap() != concrete_size.unwrap():
                            return false

                    # Check element types match
                    match_types(pattern_elem, concrete_elem)
                case _:
                    false

        case _:
            # For other types, use structural equality
            pattern.kind == concrete.kind

# ============================================================================
# Trait Bound
# ============================================================================

struct TraitBound:
    """A constraint on a type parameter: T: Trait

    Used in:
    - Function signatures: fn foo<T: Display>(x: T)
    - Where clauses: fn foo<T>(x: T) where T: Display
    - Impl blocks: impl<T: Clone> Clone for Vec<T>
    """
    type_param: Symbol              # Type variable being constrained (e.g., T)
    trait_name: Symbol              # Required trait (e.g., Display)
    span: Span

impl TraitBound:
    static fn create(type_param: Symbol, trait_name: Symbol, span: Span) -> TraitBound:
        """Create a new trait bound."""
        TraitBound(
            type_param: type_param,
            trait_name: trait_name,
            span: span
        )

enum TraitBoundKind:
    """Kind of trait bound."""
    Single(Symbol)                  # T: Trait
    Multiple([Symbol])              # T: Trait1 + Trait2
    Supertrait(Symbol, Symbol)      # In trait definition: trait Ord: Eq

impl TraitBoundKind:
    fn is_single() -> bool:
        match self:
            case Single(_): true
            case _: false

    fn traits() -> [Symbol]:
        """Get list of trait symbols in this bound."""
        match self:
            case Single(t): [t]
            case Multiple(ts): ts
            case Supertrait(sub, sup): [sub, sup]

# ============================================================================
# Obligation
# ============================================================================

struct Obligation:
    """A trait bound that must be proven during type checking.

    Created when:
    - Calling a function with trait bounds
    - Using a method that requires a trait
    - Satisfying a where clause

    Must be satisfied by finding an impl block.
    """
    type_: HirType                  # The type that must implement the trait
    trait_: Symbol                  # The trait that must be implemented
    cause: ObligationCause          # Why this obligation was created
    span: Span                      # Source location

impl Obligation:
    static fn create(ty: HirType, trait_: Symbol, cause: ObligationCause, span: Span) -> Obligation:
        """Create a new obligation."""
        Obligation(
            type_: ty,
            trait_: trait_,
            cause: cause,
            span: span
        )

    fn description() -> text:
        """Get human-readable description."""
        "require {self.type_} : {self.trait_}"

enum ObligationCause:
    """Why an obligation was created (for error messages)."""
    FunctionCall(Symbol)            # From calling fn<T: Trait>
    MethodCall(Symbol, text)        # From calling method
    TraitBound(Symbol)              # From where clause
    FieldAccess(Symbol, text)       # From accessing field
    BuiltIn                         # From built-in constraint

impl ObligationCause:
    fn description() -> text:
        match self:
            case FunctionCall(name):
                "function call to {name}"
            case MethodCall(receiver, method):
                "method call {receiver}.{method}"
            case TraitBound(param):
                "trait bound on {param}"
            case FieldAccess(ty, field):
                "field access {ty}.{field}"
            case BuiltIn:
                "built-in constraint"

# ============================================================================
# Trait Solver
# ============================================================================

class TraitSolver:
    """Solves trait obligations by searching impl blocks.

    Algorithm (simplified Rust trait solver):
    1. Collect obligations from function calls and method calls
    2. For each obligation T: Trait:
       a. Search for impl Trait for T
       b. Check where clauses recursively
       c. Report error if no impl found
    3. Cache results to avoid duplicate work

    Note: This is a simplified solver. Full Rust solver handles:
    - Higher-ranked trait bounds
    - Associated types
    - Negative impls
    - Specialization
    - Coherence checking
    """
    # All known trait definitions
    traits: Dict<Symbol, TraitDef>

    # All known impl blocks (indexed by trait name)
    impls: Dict<Symbol, [ImplBlock]>

    # All known impl blocks (indexed by target type symbol)
    # Enables efficient lookup: "what traits does type X implement?"
    impls_by_type: Dict<Symbol, [ImplBlock]>

    # Cache of solved obligations: (type, trait) -> success
    cache: Dict<(HirType, Symbol), bool>

    # Current obligations to solve
    obligations: [Obligation]

    # Errors encountered during solving
    errors: [TraitError]

impl TraitSolver:
    static fn create() -> TraitSolver:
        """Create a new trait solver."""
        TraitSolver(
            traits: {},
            impls: {},
            impls_by_type: {},
            cache: {},
            obligations: [],
            errors: []
        )

    me add_trait(trait_def: TraitDef):
        """Register a trait definition."""
        self.traits[trait_def.name] = trait_def

    me add_impl(impl_block: ImplBlock):
        """Register an impl block.

        Indexes by both trait name and target type for efficient lookup.
        """
        val trait_name = impl_block.trait_name

        # Index by trait name
        var impl_list_by_trait = if self.impls[trait_name].?:
            self.impls[trait_name]
        else:
            []
        impl_list_by_trait = impl_list_by_trait.push(impl_block)
        self.impls[trait_name] = impl_list_by_trait

        # Index by target type (extract symbol from Named type)
        match impl_block.for_type.kind:
            case Named(type_symbol, _):
                var impl_list_by_type = if self.impls_by_type[type_symbol].?:
                    self.impls_by_type[type_symbol]
                else:
                    []
                impl_list_by_type = impl_list_by_type.push(impl_block)
                self.impls_by_type[type_symbol] = impl_list_by_type
            case _: pass  # Skip non-named types for now

    me add_obligation(ty: HirType, trait_: Symbol, cause: ObligationCause, span: Span):
        """Add an obligation to solve."""
        val obligation = Obligation.create(ty, trait_, cause, span)
        self.obligations = self.obligations.push(obligation)

    fn has_obligations() -> bool:
        """Check if there are pending obligations."""
        not self.obligations.is_empty()

    me solve_all() -> Result<(), [TraitError]>:
        """Solve all pending obligations.

        Returns Ok if all obligations satisfied, Err with errors otherwise.
        """
        for obligation in self.obligations:
            match self.solve_obligation(obligation):
                case Err(err):
                    self.errors = self.errors.push(err)
                case _: pass

        # Clear obligations after solving
        self.obligations = []

        if self.errors.is_empty():
            Ok(())
        else:
            val errors = self.errors
            self.errors = []  # Clear for next round
            Err(errors)

    me solve_obligation(obligation: Obligation) -> Result<(), TraitError>:
        """Solve a single obligation.

        Algorithm (Phase B.3.3 enhanced with supertrait resolution):
        1. Check cache for previously solved
        2. Search for matching impl block
        3. Recursively check where clauses
        4. Recursively check supertrait obligations
        5. Cache result
        """
        val ty = obligation.type_
        val trait_ = obligation.trait_

        # Check cache
        val cache_key = (ty, trait_)
        if self.cache[cache_key].?:
            if self.cache[cache_key]:
                return Ok(())
            else:
                return Err(TraitError.Unsatisfied(obligation))

        # Search for impl
        match self.find_impl(ty, trait_):
            case Some(impl_block):
                # Check where clauses recursively
                for bound in impl_block.where_clause:
                    match self.solve_trait_bound(bound, obligation.span):
                        case Err(e):
                            self.cache[cache_key] = false
                            return Err(e)
                        case _: pass

                # NEW (Phase B.3.3): Check supertrait obligations
                # When T: Ord, must also prove T: Eq (if Ord: Eq)
                match self.check_supertraits(ty, trait_, obligation.span):
                    case Err(e):
                        self.cache[cache_key] = false
                        return Err(e)
                    case _: pass

                # Success - cache it
                self.cache[cache_key] = true
                Ok(())

            case nil:
                # No impl found - cache failure
                self.cache[cache_key] = false
                Err(TraitError.Unsatisfied(obligation))

    fn find_impl(ty: HirType, trait_: Symbol) -> ImplBlock?:
        """Find impl block for type and trait.

        Returns the first matching impl (coherence ensures uniqueness).
        """
        if not self.impls[trait_].?:
            return nil

        val impl_list = self.impls[trait_]
        for impl_block in impl_list:
            if impl_block.matches_type(ty):
                return Some(impl_block)

        nil

    me solve_trait_bound(bound: TraitBound, span: Span) -> Result<(), TraitError>:
        """Solve a trait bound from a where clause.

        Creates a new obligation for the bound.
        """
        # Convert type param to type variable
        val ty = HirType(
            kind: HirTypeKind.TypeParam(bound.type_param, []),
            span: bound.span
        )

        val cause = ObligationCause.TraitBound(bound.type_param)
        self.add_obligation(ty, bound.trait_name, cause, span)

        # Will be solved in next solve_all() call
        Ok(())

    me check_supertraits(ty: HirType, trait_: Symbol, span: Span) -> Result<(), TraitError>:
        """Check that type implements all supertraits of the given trait (Phase B.3.3).

        When checking T: Ord, if Ord: Eq (supertrait), we must also check T: Eq.

        Algorithm:
        1. Look up trait definition
        2. For each supertrait, create obligation
        3. Recursively solve obligations

        Example:
        trait Eq:
            fn eq(other: Self) -> bool

        trait Ord: Eq:  # Eq is a supertrait
            fn cmp(other: Self) -> Ordering

        When proving Point: Ord, must also prove Point: Eq
        """
        # Look up the trait definition
        if not self.traits[trait_].?:
            return Ok(())  # Trait not found - skip supertrait check

        val trait_def = self.traits[trait_]

        # Check each supertrait recursively
        for supertrait_symbol in trait_def.supertraits:
            # Create obligation for the supertrait
            val cause = ObligationCause.TraitBound(trait_)  # Caused by trait bound
            val supertrait_obligation = Obligation.create(ty, supertrait_symbol, cause, span)

            # Recursively solve the supertrait obligation
            match self.solve_obligation(supertrait_obligation):
                case Err(e):
                    return Err(e)
                case _: pass

        Ok(())

    fn get_trait(name: Symbol) -> TraitDef?:
        """Get trait definition by name."""
        self.traits[name]

    fn get_impls_for_type(type_symbol: Symbol) -> [ImplBlock]:
        """Get all impl blocks for a given type.

        Returns all traits implemented by the type.
        Useful for: "what can I do with this type?"
        """
        if self.impls_by_type[type_symbol].?:
            self.impls_by_type[type_symbol]
        else:
            []

    fn get_impls_for_trait(trait_name: Symbol) -> [ImplBlock]:
        """Get all impl blocks for a given trait.

        Returns all types that implement the trait.
        Useful for: "what types implement this trait?"
        """
        if self.impls[trait_name].?:
            self.impls[trait_name]
        else:
            []

    fn find_impl_for_type_and_trait(type_symbol: Symbol, trait_name: Symbol) -> ImplBlock?:
        """Find specific impl block for (type, trait) pair.

        Most efficient lookup using both indices.
        """
        val impls_for_type = self.get_impls_for_type(type_symbol)
        for impl_block in impls_for_type:
            if impl_block.trait_name == trait_name:
                return Some(impl_block)
        nil

    me check_coherence():
        """Check coherence rules (no overlapping impls).

        Coherence ensures that for any concrete type and trait, there is
        at most one applicable impl. This prevents ambiguity.

        Examples of violations:
        - impl Display for Vec<i64>
        - impl<T> Display for Vec<T>
        These overlap because both match Vec<i64>.

        Algorithm (Phase B.3.2):
        For each trait, check all pairs of impls for potential overlap.
        Two impls overlap if there exists a concrete type that matches both.
        """
        for (trait_name, impl_list) in self.impls:
            # Check all pairs of impls for overlap
            for i in 0..impl_list.len():
                for j in (i + 1)..impl_list.len():
                    val impl1 = impl_list[i]
                    val impl2 = impl_list[j]

                    if impls_overlap(impl1, impl2):
                        # Found overlapping impls - this is an error
                        val error = TraitError.Overlapping(
                            trait_name,
                            impl1.for_type,
                            impl2.span
                        )
                        self.errors = self.errors.push(error)

fn impls_overlap(impl1: ImplBlock, impl2: ImplBlock) -> bool:
    """Check if two impl blocks could overlap (Phase B.3.2).

    Two impls overlap if there exists a concrete type that matches both.

    Examples:
    - impl Display for Vec<i64> and impl<T> Display for Vec<T> → overlap
    - impl Display for Point and impl Display for Vec<T> → no overlap
    - impl<T> Display for Vec<T> and impl<U> Clone for Vec<U> → no overlap (different traits)

    Simplified overlap detection:
    - If either impl has no generics, check if types are equal
    - If both have generics, check if base types could unify
    - Full overlap detection is complex (requires unification)
    """
    val ty1 = impl1.for_type
    val ty2 = impl2.for_type

    # Check if both types could match a common concrete type
    # For a conservative approximation:
    match ty1.kind:
        case Named(symbol1, args1):
            match ty2.kind:
                case Named(symbol2, args2):
                    # If different base types, no overlap
                    if symbol1 != symbol2:
                        return false

                    # Same base type - could overlap
                    # Examples:
                    # - Vec<i64> and Vec<T> → overlap (T=i64)
                    # - Vec<i64> and Vec<u32> → no overlap (concrete types differ)

                    # If both are fully concrete (no type params), check equality
                    val has_params1 = type_has_params(ty1)
                    val has_params2 = type_has_params(ty2)

                    if not has_params1 and not has_params2:
                        # Both concrete - overlap only if equal
                        return ty1 == ty2

                    # At least one has type parameters - conservative: assume overlap
                    # Full unification would be needed for precise check
                    true
                case _:
                    # Different type kinds
                    false
        case _:
            # For non-Named types, use simple equality check
            ty1 == ty2

fn type_has_params(ty: HirType) -> bool:
    """Check if a type contains type parameters."""
    match ty.kind:
        case TypeParam(_, _):
            true
        case Named(_, args):
            for arg in args:
                if type_has_params(arg):
                    return true
            false
        case Function(params, ret, _):
            for param in params:
                if type_has_params(param):
                    return true
            type_has_params(ret)
        case Tuple(elems):
            for elem in elems:
                if type_has_params(elem):
                    return true
            false
        case Array(elem, _):
            type_has_params(elem)
        case _:
            false

# ============================================================================
# Trait Errors
# ============================================================================

enum TraitError:
    """Errors from trait resolution."""
    Unsatisfied(obligation: Obligation)
    Ambiguous(type_: HirType, trait_: Symbol, candidates: [ImplBlock])
    Overlapping(trait_: Symbol, type_: HirType, span: Span)
    MissingMethod(trait_: Symbol, method: text, type_: HirType, span: Span)
    CyclicBound(type_param: Symbol, span: Span)
    UndefinedTrait(name: Symbol, span: Span)

impl TraitError:
    fn message() -> text:
        """Get human-readable error message."""
        match self:
            case Unsatisfied(obligation):
                "trait bound not satisfied: {obligation.type_} does not implement {obligation.trait_}\n  required by {obligation.cause.description()}"

            case Ambiguous(ty, trait_, candidates):
                "ambiguous trait impl: {candidates.len()} candidates for {ty} : {trait_}"

            case Overlapping(trait_, ty, _):
                "overlapping impls for {trait_} for {ty}"

            case MissingMethod(trait_, method, ty, _):
                "missing method '{method}' in impl {trait_} for {ty}"

            case CyclicBound(param, _):
                "cyclic trait bound on type parameter {param}"

            case UndefinedTrait(name, _):
                "undefined trait: {name}"

    fn span() -> Span:
        """Get source span for error."""
        match self:
            case Unsatisfied(obligation): obligation.span
            case Ambiguous(ty, _, _): ty.span
            case Overlapping(_, _, span): span
            case MissingMethod(_, _, _, span): span
            case CyclicBound(_, span): span
            case UndefinedTrait(_, span): span

# ============================================================================
# Built-in Traits
# ============================================================================

fn create_builtin_traits() -> [TraitDef]:
    """Create definitions for built-in traits.

    Built-in traits:
    - Clone: fn clone() -> Self
    - Copy: marker trait (Clone + trivial bitwise copy)
    - Debug: fn debug() -> text
    - Default: fn default() -> Self
    - Drop: fn drop()
    - Eq: fn eq(other: Self) -> bool
    - Ord: fn cmp(other: Self) -> Ordering (requires Eq)
    """
    var traits: [TraitDef] = []
    val dummy_span = Span(start: 0, end: 0, line: 0, col: 0)

    val self_type = HirType(kind: HirTypeKind.TypeParam(name: "Self", bounds: []), span: dummy_span)
    val bool_type = HirType(kind: HirTypeKind.Bool, span: dummy_span)
    val text_type = HirType(kind: HirTypeKind.Str, span: dummy_span)
    val unit_type = HirType(kind: HirTypeKind.Unit, span: dummy_span)
    val i32_type = HirType(kind: HirTypeKind.Int(bits: 32, signed: true), span: dummy_span)

    # Clone trait: fn clone() -> Self
    var clone_trait = TraitDef.create(Symbol(id: 1, name: "Clone"), dummy_span)
    clone_trait.methods = [MethodSignature(name: "clone", params: [], return_type: self_type, effects: [], span: dummy_span)]
    traits = traits.push(clone_trait)

    # Copy trait (marker, no methods - just requires Clone)
    var copy_trait = TraitDef.create(Symbol(id: 2, name: "Copy"), dummy_span)
    copy_trait.supertraits = [Symbol(id: 1, name: "Clone")]  # Copy: Clone
    traits = traits.push(copy_trait)

    # Debug trait: fn debug() -> text
    var debug_trait = TraitDef.create(Symbol(id: 3, name: "Debug"), dummy_span)
    debug_trait.methods = [MethodSignature(name: "debug", params: [], return_type: text_type, effects: [], span: dummy_span)]
    traits = traits.push(debug_trait)

    # Default trait: fn default() -> Self (static)
    var default_trait = TraitDef.create(Symbol(id: 4, name: "Default"), dummy_span)
    default_trait.methods = [MethodSignature(name: "default", params: [], return_type: self_type, effects: [], span: dummy_span)]
    traits = traits.push(default_trait)

    # Drop trait: fn drop()
    var drop_trait = TraitDef.create(Symbol(id: 5, name: "Drop"), dummy_span)
    drop_trait.methods = [MethodSignature(name: "drop", params: [], return_type: unit_type, effects: [], span: dummy_span)]
    traits = traits.push(drop_trait)

    # Eq trait: fn eq(other: Self) -> bool
    var eq_trait = TraitDef.create(Symbol(id: 6, name: "Eq"), dummy_span)
    eq_trait.methods = [MethodSignature(name: "eq", params: [self_type], return_type: bool_type, effects: [], span: dummy_span)]
    traits = traits.push(eq_trait)

    # Ord trait: fn cmp(other: Self) -> i32 (requires Eq)
    var ord_trait = TraitDef.create(Symbol(id: 7, name: "Ord"), dummy_span)
    ord_trait.supertraits = [Symbol(id: 6, name: "Eq")]  # Ord: Eq
    ord_trait.methods = [MethodSignature(name: "cmp", params: [self_type], return_type: i32_type, effects: [], span: dummy_span)]
    traits = traits.push(ord_trait)

    traits

# ============================================================================
# Exports
# ============================================================================

export TraitDef, MethodSignature
export ImplBlock
export TraitBound, TraitBoundKind
export Obligation, ObligationCause
export TraitSolver
export TraitError
export create_builtin_traits
