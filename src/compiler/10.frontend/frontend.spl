# Compiler Frontend Runner
#
# Shared frontend entrypoint for full Simple compiler modes:
# outline (TreeSitter) -> block resolution -> full parse -> desugar.
#
# This keeps frontend orchestration centralized so compiler modes
# (check/interpret/jit/aot) all consume exactly one parse pipeline.

use compiler.frontend.parser_types.{Module}
use compiler.frontend.treesitter.*
use compiler.tools.desugar_async.{desugar_module}
use compiler.core.parser.*
use compiler.core.parser_preprocessor.{preprocess_conditionals}
use compiler.blocks.blocks.*
use compiler.common.config.{Logger}
use compiler.driver.driver_types.{create_block_resolver}

fn parse_full_frontend(source: text, file_path: text, module_name: text, log: Logger) -> Module:
    val preprocessed = preprocess_conditionals(source)

    # Phase 2a: Outline parsing (TreeSitter)
    log.trace("2a: outline parsing...")
    var ts = TreeSitter__new(preprocessed)
    val outline = ts.parse_outline()

    # Phase 2b: Block resolution
    log.trace("2b: resolving blocks...")
    var resolver = create_block_resolver()
    resolver = resolver.with_file(file_path)
    resolver = resolver.with_module(module_name)
    val (resolved, block_diagnostics) = resolver.resolve(outline)

    # Keep behavior unchanged: diagnostics are gathered for future wiring.
    if block_diagnostics.len() > 0:
        log.trace("2b: block diagnostics={block_diagnostics.len()}")

    # Phase 2c: Full parse with resolved blocks
    log.trace("2c: full parse...")
    var parser = Parser__with_resolved_blocks(preprocessed, resolved)
    val module = parser.parse()

    # Phase 2d: Desugar async/await/spawn/actor syntax
    log.trace("2d: desugaring...")
    desugar_module(module)

export parse_full_frontend
