# Core Type Inference â€” Hindley-Milner Type Inference
#
# Implements bidirectional type checking and unification
# Uses constraint-based type inference for generic functions
# Compatible with seed compiler (no generics, parallel arrays only)

use compiler.core.types.{TYPE_VOID, TYPE_BOOL, TYPE_I64, TYPE_F64, TYPE_TEXT}
use compiler.core.types.{TYPE_ARRAY_ANY, TYPE_STRUCT, TYPE_FN, TYPE_ANY}

# ===== Type Variables =====
# Fresh type variables for unification (like ?T1, ?T2, etc.)

var type_var_counter: i64 = 0
val TYPE_VAR_BASE: i64 = 50000  # Base ID for type variables

fn type_var_fresh() -> i64:
    val var_id = TYPE_VAR_BASE + type_var_counter
    type_var_counter = type_var_counter + 1
    var_id

fn type_var_reset():
    type_var_counter = 0

fn is_type_var(type_id: i64) -> bool:
    type_id >= TYPE_VAR_BASE

# ===== Unification State =====
# Maps type variable IDs to their resolved types
# Uses parallel arrays for seed compatibility

var unify_var_ids: [i64] = []
var unify_var_types: [i64] = []

fn unify_reset():
    unify_var_ids = []
    unify_var_types = []

fn unify_bind(var_id: i64, type_id: i64):
    # Check if already bound
    for i in range(0, unify_var_ids.len()):
        if unify_var_ids[i] == var_id:
            unify_var_types[i] = type_id
            return
    # Add new binding
    unify_var_ids.push(var_id)
    unify_var_types.push(type_id)

fn unify_lookup(var_id: i64) -> i64:
    for i in range(0, unify_var_ids.len()):
        if unify_var_ids[i] == var_id:
            return unify_var_types[i]
    -1  # Unbound

fn unify_is_bound(var_id: i64) -> bool:
    unify_lookup(var_id) != -1

# ===== Type Substitution (Follow Chains) =====
# Resolve type through unification bindings

fn type_subst_apply(type_id: i64) -> i64:
    if not is_type_var(type_id):
        return type_id
    val resolved = unify_lookup(type_id)
    if resolved == -1:
        return type_id  # Unbound variable
    # Follow chain recursively
    type_subst_apply(resolved)

# ===== Occurs Check =====
# Prevent infinite types in unification (e.g., T = List<T>)

fn occurs_check(var_id: i64, type_id: i64) -> bool:
    val resolved = type_subst_apply(type_id)
    if resolved == var_id:
        return true  # Occurs!
    # For complex types, would need to recurse into structure
    # For now, simple check is sufficient
    false

# ===== Unification Algorithm =====
# Core type unification (bidirectional)

val UNIFY_SUCCESS: i64 = 0
val UNIFY_FAIL_MISMATCH: i64 = 1
val UNIFY_FAIL_OCCURS: i64 = 2

var unify_error_msg: text = ""

fn unify_get_error() -> text:
    unify_error_msg

fn unify_types(type1: i64, type2: i64) -> i64:
    # Apply existing substitutions
    val t1 = type_subst_apply(type1)
    val t2 = type_subst_apply(type2)
    # Case 1: Same types
    if t1 == t2:
        return UNIFY_SUCCESS
    # Case 2: One is a type variable
    if is_type_var(t1):
        if occurs_check(t1, t2):
            unify_error_msg = "Occurs check failed"
            return UNIFY_FAIL_OCCURS
        unify_bind(t1, t2)
        return UNIFY_SUCCESS
    if is_type_var(t2):
        if occurs_check(t2, t1):
            unify_error_msg = "Occurs check failed"
            return UNIFY_FAIL_OCCURS
        unify_bind(t2, t1)
        return UNIFY_SUCCESS
    # Case 3: Different concrete types
    unify_error_msg = "Type mismatch"
    return UNIFY_FAIL_MISMATCH

# ===== Constraint Generation =====
# Generate type constraints from expressions

var constraint_lhs: [i64] = []  # Left-hand side types
var constraint_rhs: [i64] = []  # Right-hand side types
var constraint_origins: [text] = []  # Source locations for errors

fn constraint_clear():
    constraint_lhs = []
    constraint_rhs = []
    constraint_origins = []

fn constraint_add(lhs: i64, rhs: i64, origin: text):
    constraint_lhs.push(lhs)
    constraint_rhs.push(rhs)
    constraint_origins.push(origin)

fn constraint_count() -> i64:
    constraint_lhs.len()

# ===== Constraint Solving =====
# Solve all constraints via unification

fn solve_constraints() -> bool:
    for i in range(0, constraint_lhs.len()):
        val lhs = constraint_lhs[i]
        val rhs = constraint_rhs[i]
        val result = unify_types(lhs, rhs)
        if result != UNIFY_SUCCESS:
            return false
    true

# ===== Expression Type Inference =====
# Infer types for expressions

# Expression type cache (maps expr_id -> inferred type)
var expr_type_ids: [i64] = []
var expr_type_tags: [i64] = []

fn expr_type_reset():
    expr_type_ids = []
    expr_type_tags = []

fn expr_type_set(expr_id: i64, type_tag: i64):
    # Check if already set
    for i in range(0, expr_type_ids.len()):
        if expr_type_ids[i] == expr_id:
            expr_type_tags[i] = type_tag
            return
    expr_type_ids.push(expr_id)
    expr_type_tags.push(type_tag)

fn expr_type_get(expr_id: i64) -> i64:
    for i in range(0, expr_type_ids.len()):
        if expr_type_ids[i] == expr_id:
            return expr_type_tags[i]
    -1  # Unknown

fn infer_literal_type(literal_value: text) -> i64:
    # Infer type from literal representation
    # Numbers: 42 -> i64, 3.14 -> f64
    # Strings: "hello" -> text
    # Booleans: true/false -> bool
    if literal_value == "true" or literal_value == "false":
        return TYPE_BOOL
    if literal_value == "nil":
        return TYPE_ANY  # nil can be any type
    if literal_value.contains("."):
        return TYPE_F64
    # Try parsing as integer
    val is_number = true
    for i in range(0, literal_value.len()):
        val ch = literal_value[i]
        if ch < "0" or ch > "9":
            if not (i == 0 and ch == "-"):
                is_number = false
                break
    if is_number:
        return TYPE_I64
    TYPE_TEXT

fn infer_binary_op_type(op: text, lhs_type: i64, rhs_type: i64) -> i64:
    # Infer result type of binary operation
    # Arithmetic ops: i64 + i64 -> i64, f64 + f64 -> f64
    # Comparison ops: any + any -> bool
    # String concat: text + text -> text
    if op == "+" or op == "-" or op == "*" or op == "/":
        # Arithmetic
        if lhs_type == TYPE_F64 or rhs_type == TYPE_F64:
            return TYPE_F64
        if lhs_type == TYPE_I64 and rhs_type == TYPE_I64:
            return TYPE_I64
        if lhs_type == TYPE_TEXT and rhs_type == TYPE_TEXT:
            return TYPE_TEXT  # String concatenation
        return TYPE_ANY
    if (op == "==" or op == "!=" or op == "<" or op == ">" or
        op == "<=" or op == ">="):
        return TYPE_BOOL
    if op == "and" or op == "or":
        return TYPE_BOOL
    TYPE_ANY

fn infer_unary_op_type(op: text, operand_type: i64) -> i64:
    if op == "not":
        return TYPE_BOOL
    if op == "-":
        return operand_type  # Negation preserves type
    TYPE_ANY

# ===== Function Type Inference =====
# Infer function parameter and return types

var func_param_types: [[i64]] = []  # Type variables for each param
var func_return_types: [i64] = []   # Type variable for return
var func_inference_ids: [i64] = []  # Function decl_id -> inference idx

fn func_inference_reset():
    func_param_types = []
    func_return_types = []
    func_inference_ids = []

fn func_inference_create(fn_decl_id: i64, param_count: i64) -> i64:
    val idx = func_inference_ids.len()
    func_inference_ids.push(fn_decl_id)
    # Create fresh type variables for params
    var param_vars: [i64] = []
    for i in range(0, param_count):
        param_vars.push(type_var_fresh())
    func_param_types.push(param_vars)
    # Create fresh type variable for return
    func_return_types.push(type_var_fresh())
    idx

fn func_inference_get_param_types(fn_idx: i64) -> [i64]:
    if fn_idx < 0 or fn_idx >= func_param_types.len():
        return []
    func_param_types[fn_idx]

fn func_inference_get_return_type(fn_idx: i64) -> i64:
    if fn_idx < 0 or fn_idx >= func_return_types.len():
        return -1
    func_return_types[fn_idx]

# ===== Bidirectional Type Checking =====
# Inference mode: infer type from expression
# Checking mode: check expression against expected type

fn infer_expr_type(expr_id: i64) -> i64:
    # Check cache
    val cached = expr_type_get(expr_id)
    if cached != -1:
        return cached
    # For now, return fresh type variable
    # Full implementation would walk AST and infer
    val inferred = type_var_fresh()
    expr_type_set(expr_id, inferred)
    inferred

fn check_expr_type(expr_id: i64, expected_type: i64) -> bool:
    val inferred = infer_expr_type(expr_id)
    constraint_add(inferred, expected_type, "expression check")
    solve_constraints()

# ===== Generalization =====
# Convert inferred types to generic type schemes

var generalized_fn_ids: [i64] = []
var generalized_type_vars: [[i64]] = []  # Free type variables

fn generalize_function_type(fn_idx: i64):
    val param_types = func_inference_get_param_types(fn_idx)
    val return_type = func_inference_get_return_type(fn_idx)
    # Collect free type variables (unbound after solving)
    var free_vars: [i64] = []
    for param_type in param_types:
        val resolved = type_subst_apply(param_type)
        if is_type_var(resolved) and not unify_is_bound(resolved):
            free_vars.push(resolved)
    val resolved_ret = type_subst_apply(return_type)
    if is_type_var(resolved_ret) and not unify_is_bound(resolved_ret):
        var already_added: bool = false
        for fv in free_vars:
            if fv == resolved_ret:
                already_added = true
                break
        if not already_added:
            free_vars.push(resolved_ret)
    # Store generalized type
    generalized_fn_ids.push(fn_idx)
    generalized_type_vars.push(free_vars)

fn get_generalized_vars(fn_idx: i64) -> [i64]:
    for i in range(0, generalized_fn_ids.len()):
        if generalized_fn_ids[i] == fn_idx:
            return generalized_type_vars[i]
    []

# ===== Instantiation =====
# Instantiate generic type scheme with fresh type variables

fn instantiate_function_type(fn_idx: i64) -> ([i64], i64):
    val generalized_vars = get_generalized_vars(fn_idx)
    if generalized_vars.len() == 0:
        # Not generic, return original types
        val params = func_inference_get_param_types(fn_idx)
        val ret = func_inference_get_return_type(fn_idx)
        return (params, ret)
    # Create fresh type variables for each generalized var
    var fresh_vars: [i64] = []
    for gv in generalized_vars:
        fresh_vars.push(type_var_fresh())
    # Substitute in parameter and return types
    val params = func_inference_get_param_types(fn_idx)
    var new_params: [i64] = []
    for param_type in params:
        val subst = instantiate_type(param_type, generalized_vars, fresh_vars)
        new_params.push(subst)
    val ret = func_inference_get_return_type(fn_idx)
    val new_ret = instantiate_type(ret, generalized_vars, fresh_vars)
    (new_params, new_ret)

fn instantiate_type(type_id: i64, old_vars: [i64], new_vars: [i64]) -> i64:
    for i in range(0, old_vars.len()):
        if type_id == old_vars[i]:
            return new_vars[i]
    type_id

# ===== Type Inference Entry Point =====

fn infer_function_types(fn_decl_id: i64, param_count: i64) -> bool:
    # Reset state
    type_var_reset()
    unify_reset()
    constraint_clear()
    # Create inference context
    val fn_idx = func_inference_create(fn_decl_id, param_count)
    # Generate constraints from function body
    # (would walk AST and generate constraints)
    # Solve constraints
    val success = solve_constraints()
    if not success:
        return false
    # Generalize inferred type
    generalize_function_type(fn_idx)
    true

fn infer_expr_types(expr_id: i64) -> i64:
    # Infer type for a single expression
    type_var_reset()
    unify_reset()
    constraint_clear()
    val inferred = infer_expr_type(expr_id)
    if not solve_constraints():
        return -1
    type_subst_apply(inferred)

# ===== Type Inference Statistics =====

fn type_var_count() -> i64:
    type_var_counter

fn constraint_count_total() -> i64:
    constraint_lhs.len()

fn unification_count() -> i64:
    unify_var_ids.len()

# ===== Public API =====

export type_var_fresh
export type_var_reset
export is_type_var
export unify_reset
export unify_types
export unify_get_error
export constraint_clear
export constraint_add
export solve_constraints
export infer_function_types
export infer_expr_types
export infer_literal_type
export infer_binary_op_type
export infer_unary_op_type
export check_expr_type
export generalize_function_type
export instantiate_function_type
export type_var_count
export constraint_count_total
export unification_count
export UNIFY_SUCCESS
export UNIFY_FAIL_MISMATCH
export UNIFY_FAIL_OCCURS
