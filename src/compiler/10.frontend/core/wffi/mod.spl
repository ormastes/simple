# Core Simple â€” WFFI (Wrapped Foreign Function Interface)
#
# Thin Simple wrappers around runtime dlopen/dlsym/dlclose.
# Allows dynamically loading shared libraries and calling functions.
#
# Seed-compatible: no generics, no closures.
#
# Usage:
#   val lib = wffi_load("libm.so")
#   val fptr = wffi_get(lib, "sqrt")
#   val result = wffi_call_1(fptr, 4)
#   wffi_free(lib)

extern fn spl_dlopen(path: text) -> i64
extern fn spl_dlsym(handle: i64, name: text) -> i64
extern fn spl_dlclose(handle: i64) -> i64
extern fn spl_wffi_call_i64(fptr: i64, args: [i64], nargs: i64) -> i64

# Load a shared library. Returns opaque handle (0 on failure).
fn wffi_load(path: text) -> i64:
    spl_dlopen(path)

# Look up a symbol by name. Returns function pointer as i64 (0 on failure).
fn wffi_get(handle: i64, name: text) -> i64:
    spl_dlsym(handle, name)

# Close a loaded library. Returns 0 on success.
fn wffi_close(handle: i64) -> i64:
    spl_dlclose(handle)

# Alias for wffi_close.
fn wffi_free(handle: i64) -> i64:
    spl_dlclose(handle)

# Call a function pointer with 0 arguments. Returns i64.
fn wffi_call_0(fptr: i64) -> i64:
    var args: [i64] = []
    spl_wffi_call_i64(fptr, args, 0)

# Call with 1 argument.
fn wffi_call_1(fptr: i64, a0: i64) -> i64:
    var args: [i64] = []
    args.push(a0)
    spl_wffi_call_i64(fptr, args, 1)

# Call with 2 arguments.
fn wffi_call_2(fptr: i64, a0: i64, a1: i64) -> i64:
    var args: [i64] = []
    args.push(a0)
    args.push(a1)
    spl_wffi_call_i64(fptr, args, 2)

# Call with 3 arguments.
fn wffi_call_3(fptr: i64, a0: i64, a1: i64, a2: i64) -> i64:
    var args: [i64] = []
    args.push(a0)
    args.push(a1)
    args.push(a2)
    spl_wffi_call_i64(fptr, args, 3)

# Call with 4 arguments.
fn wffi_call_4(fptr: i64, a0: i64, a1: i64, a2: i64, a3: i64) -> i64:
    var args: [i64] = []
    args.push(a0)
    args.push(a1)
    args.push(a2)
    args.push(a3)
    spl_wffi_call_i64(fptr, args, 4)

# Call with 5 arguments.
fn wffi_call_5(fptr: i64, a0: i64, a1: i64, a2: i64, a3: i64, a4: i64) -> i64:
    var args: [i64] = []
    args.push(a0)
    args.push(a1)
    args.push(a2)
    args.push(a3)
    args.push(a4)
    spl_wffi_call_i64(fptr, args, 5)

# Call with 6 arguments.
fn wffi_call_6(fptr: i64, a0: i64, a1: i64, a2: i64, a3: i64, a4: i64, a5: i64) -> i64:
    var args: [i64] = []
    args.push(a0)
    args.push(a1)
    args.push(a2)
    args.push(a3)
    args.push(a4)
    args.push(a5)
    spl_wffi_call_i64(fptr, args, 6)

# Call with 7 arguments.
fn wffi_call_7(fptr: i64, a0: i64, a1: i64, a2: i64, a3: i64, a4: i64, a5: i64, a6: i64) -> i64:
    var args: [i64] = []
    args.push(a0)
    args.push(a1)
    args.push(a2)
    args.push(a3)
    args.push(a4)
    args.push(a5)
    args.push(a6)
    spl_wffi_call_i64(fptr, args, 7)

# Call with 8 arguments.
fn wffi_call_8(fptr: i64, a0: i64, a1: i64, a2: i64, a3: i64, a4: i64, a5: i64, a6: i64, a7: i64) -> i64:
    var args: [i64] = []
    args.push(a0)
    args.push(a1)
    args.push(a2)
    args.push(a3)
    args.push(a4)
    args.push(a5)
    args.push(a6)
    args.push(a7)
    spl_wffi_call_i64(fptr, args, 8)

# Call with a pre-built args array. Dispatches by args.len().
fn wffi_call_n(fptr: i64, args: [i64]) -> i64:
    spl_wffi_call_i64(fptr, args, args.len())

# Call with 0 arguments, returning bool (non-zero = true).
fn wffi_call_bool(fptr: i64) -> bool:
    var args: [i64] = []
    spl_wffi_call_i64(fptr, args, 0) != 0

# Call with 1 argument, returning bool (non-zero = true).
fn wffi_call_bool_1(fptr: i64, a0: i64) -> bool:
    var args: [i64] = []
    args.push(a0)
    spl_wffi_call_i64(fptr, args, 1) != 0

export wffi_load, wffi_get, wffi_close, wffi_free
export wffi_call_0, wffi_call_1, wffi_call_2, wffi_call_3, wffi_call_4
export wffi_call_5, wffi_call_6, wffi_call_7, wffi_call_8
export wffi_call_n, wffi_call_bool, wffi_call_bool_1
