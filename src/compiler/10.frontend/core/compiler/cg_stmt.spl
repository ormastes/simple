# C Codegen — Statement Codegen & Block/Loop Expression Codegen
#
# Extracted from cg_expr.spl. Contains:
# - Block expression codegen (cg_block_expr)
# - For/While/Match expression codegen (emit as statements)
# - Statement dispatcher (cg_stmt) and all statement helpers
#
# These functions are mutually recursive with cg_expr (from cg_expr.spl),
# accessible via module namespace sharing.

use compiler.core.ast.{expr_get, expr_get_tag, expr_get_int, expr_get_str}
use compiler.core.ast.{expr_get_left, expr_get_right, expr_get_extra, expr_get_args, expr_get_stmts}
use compiler.core.ast.{stmt_get, stmt_get_tag, stmt_get_expr, stmt_get_name, stmt_get_type, stmt_get_body}
use compiler.core.ast.{elif_get_cond, elif_get_body, elif_get_else}
use compiler.core.ast.{arm_get_pattern, arm_get_body}
use compiler.core.ast.{EXPR_INT_LIT, EXPR_IDENT, EXPR_CALL, EXPR_INDEX, EXPR_RANGE}
use compiler.core.ast.{EXPR_STRUCT_LIT, EXPR_ARRAY_LIT}
use compiler.core.ast.{STMT_EXPR, STMT_VAL_DECL, STMT_VAR_DECL, STMT_ASSIGN, STMT_RETURN}
use compiler.core.ast.{STMT_IF, STMT_FOR, STMT_WHILE, STMT_MATCH, STMT_BLOCK}
use compiler.core.ast.{STMT_BREAK, STMT_CONTINUE, STMT_COMPOUND_ASSIGN}
use compiler.core.tokens.{TOK_PLUS, TOK_MINUS, TOK_STAR, TOK_SLASH, TOK_PERCENT}
use compiler.core.types.{TYPE_VOID, TYPE_I64, TYPE_TEXT}
use compiler.core.types.{TYPE_ARRAY_I64, TYPE_ARRAY_TEXT, TYPE_ARRAY_BOOL, TYPE_ARRAY_ANY}
use compiler.core.types.{TYPE_NAMED_BASE}
use compiler.core.types.{type_tag_to_c}
use compiler.core.types.{named_type_find, named_type_name}
use compiler.core.compiler.cg_helpers.{cg_emit, cg_emit_line, cg_emit_blank, cg_indent_inc, cg_indent_dec}
use compiler.core.compiler.cg_helpers.{vt_push_scope, vt_pop_scope, vt_add, vt_find}
use compiler.core.compiler.cg_helpers.{st_add, st_find, sa_find}
use compiler.core.compiler.cg_helpers.{is_text_type, is_array_type}
use compiler.core.compiler.cg_helpers.{cg_infer_expr_type, cg_spl_wrap, cg_spl_access}
use compiler.core.compiler.cg_helpers.{cg_compound_op_to_c}

# ===== Block Expression =====

fn cg_block_expr(idx: i64) -> text:
    val body_stmts = expr_get_stmts(idx)
    val value_idx = expr_get_left(idx)
    # Use GCC statement expression ({...})
    var result: text = "({"
    for i in range(0, body_stmts.len()):
        cg_stmt(body_stmts[i])
    if value_idx >= 0:
        result = result + cg_expr(value_idx) + ";"
    result = result + "})"
    result

# ===== For Expression (for codegen in expression context) =====

fn cg_for_expr(idx: i64) -> text:
    # For in expression context is unusual; emit as statement
    return "/* for_expr */"

fn cg_emit_for_as_stmt(idx: i64):
    val iter_name = expr_get_str(idx)
    val iterable = expr_get_left(idx)
    val body_stmts = expr_get_stmts(idx)
    val iter_tag = expr_get_tag(iterable)
    vt_push_scope()
    vt_add(iter_name, TYPE_I64)
    # range(start, end) pattern
    if iter_tag == EXPR_CALL:
        val callee_idx = expr_get_left(iterable)
        if expr_get_tag(callee_idx) == EXPR_IDENT:
            val callee_name = expr_get_str(callee_idx)
            if callee_name == "range":
                val range_args = expr_get_args(iterable)
                if range_args.len() == 2:
                    val start_c = cg_expr(range_args[0])
                    val end_c = cg_expr(range_args[1])
                    cg_emit_line("for (int64_t " + iter_name + " = " + start_c + "; " + iter_name + " < " + end_c + "; " + iter_name + "++) {")
                    cg_indent_inc()
                    for i in range(0, body_stmts.len()):
                        cg_stmt(body_stmts[i])
                    cg_indent_dec()
                    cg_emit_line("}")
                    vt_pop_scope()
                    return
                if range_args.len() == 1:
                    val end_c = cg_expr(range_args[0])
                    cg_emit_line("for (int64_t " + iter_name + " = 0; " + iter_name + " < " + end_c + "; " + iter_name + "++) {")
                    cg_indent_inc()
                    for i in range(0, body_stmts.len()):
                        cg_stmt(body_stmts[i])
                    cg_indent_dec()
                    cg_emit_line("}")
                    vt_pop_scope()
                    return
    # Range expression: for i in start..end
    if iter_tag == EXPR_RANGE:
        val start_c = cg_expr(expr_get_left(iterable))
        val end_c = cg_expr(expr_get_right(iterable))
        val inclusive = expr_get_int(iterable)
        var cmp: text = "<"
        if inclusive != 0:
            cmp = "<="
        cg_emit_line("for (int64_t " + iter_name + " = " + start_c + "; " + iter_name + " " + cmp + " " + end_c + "; " + iter_name + "++) {")
        cg_indent_inc()
        for i in range(0, body_stmts.len()):
            cg_stmt(body_stmts[i])
        cg_indent_dec()
        cg_emit_line("}")
        vt_pop_scope()
        return
    # Array iteration fallback
    val iter_c = cg_expr(iterable)
    cg_emit_line("for (int64_t __" + iter_name + "_i = 0; __" + iter_name + "_i < spl_array_len(" + iter_c + "); __" + iter_name + "_i++) {")
    cg_indent_inc()
    cg_emit_line("int64_t " + iter_name + " = spl_array_get(" + iter_c + ", __" + iter_name + "_i).as_int;")
    for i in range(0, body_stmts.len()):
        cg_stmt(body_stmts[i])
    cg_indent_dec()
    cg_emit_line("}")
    vt_pop_scope()

# ===== While Expression =====

fn cg_while_expr(idx: i64) -> text:
    return "/* while_expr */"

fn cg_emit_while_as_stmt(idx: i64):
    val cond = expr_get_left(idx)
    val body_stmts = expr_get_stmts(idx)
    val cond_c = cg_expr(cond)
    cg_emit_line("while (" + cond_c + ") {")
    cg_indent_inc()
    for i in range(0, body_stmts.len()):
        cg_stmt(body_stmts[i])
    cg_indent_dec()
    cg_emit_line("}")

# ===== Match Expression =====

fn cg_match_expr(idx: i64) -> text:
    return "/* match_expr */"

# ===== Statement Codegen =====

fn cg_stmt(idx: i64):
    val tag = stmt_get_tag(idx)

    if tag == STMT_EXPR:
        val e = stmt_get_expr(idx)
        if e >= 0:
            cg_emit_line(cg_expr(e) + ";")
        return

    if tag == STMT_VAL_DECL:
        cg_val_decl_stmt(idx)
        return

    if tag == STMT_VAR_DECL:
        cg_var_decl_stmt(idx)
        return

    if tag == STMT_ASSIGN:
        cg_assign_stmt(idx)
        return

    if tag == STMT_RETURN:
        val e = stmt_get_expr(idx)
        if e >= 0:
            cg_emit_line("return " + cg_expr(e) + ";")
        else:
            cg_emit_line("return;")
        return

    if tag == STMT_IF:
        cg_if_stmt(idx)
        return

    if tag == STMT_FOR:
        cg_for_stmt(idx)
        return

    if tag == STMT_WHILE:
        cg_while_stmt(idx)
        return

    if tag == STMT_MATCH:
        cg_match_stmt(idx)
        return

    if tag == STMT_BLOCK:
        cg_block_stmt(idx)
        return

    if tag == STMT_BREAK:
        cg_emit_line("break;")
        return

    if tag == STMT_CONTINUE:
        cg_emit_line("continue;")
        return

    if tag == STMT_COMPOUND_ASSIGN:
        cg_compound_assign_stmt(idx)
        return

    cg_emit_line("/* unhandled_stmt */")

# ===== Variable Declaration Statements =====

fn cg_val_decl_stmt(idx: i64):
    val name = stmt_get_name(idx)
    var type_tag = stmt_get_type(idx)
    val init_expr = stmt_get_expr(idx)

    # Infer type if not explicitly annotated
    if type_tag == TYPE_VOID:
        if init_expr >= 0:
            type_tag = cg_infer_expr_type(init_expr)
    val c_type = type_tag_to_c(type_tag)

    # Track variable type
    vt_add(name, type_tag)

    if is_array_type(type_tag):
        cg_emit_array_init(name, type_tag, init_expr, true)
        return

    if init_expr >= 0:
        val init_c = cg_expr(init_expr)
        # Check if init is a struct literal
        val init_tag = expr_get_tag(init_expr)
        if init_tag == EXPR_STRUCT_LIT:
            val sname = expr_get_str(init_expr)
            st_add(name, sname)
            cg_emit_line(sname + " " + name + " = " + init_c + ";")
            return
        # Check if init is a struct constructor call: val a = Dog()
        if init_tag == EXPR_CALL:
            val callee = expr_get_left(init_expr)
            if expr_get_tag(callee) == EXPR_IDENT:
                val cn = expr_get_str(callee)
                val sid = named_type_find(cn)
                if sid >= 0:
                    st_add(name, cn)
                    cg_emit_line(cn + " " + name + " = " + init_c + ";")
                    return
        # Check if inferred type is a named struct type
        if type_tag >= TYPE_NAMED_BASE:
            val nid = type_tag - TYPE_NAMED_BASE
            val sname = named_type_name(nid)
            if sname != "":
                st_add(name, sname)
                cg_emit_line(sname + " " + name + " = " + init_c + ";")
                return
        # Skip const prefix for TYPE_TEXT (already const char*)
        var prefix: text = "const "
        if type_tag == TYPE_TEXT:
            prefix = ""
        cg_emit_line(prefix + c_type + " " + name + " = " + init_c + ";")
    else:
        var prefix2: text = "const "
        if type_tag == TYPE_TEXT:
            prefix2 = ""
        cg_emit_line(prefix2 + c_type + " " + name + " = {};")

fn cg_var_decl_stmt(idx: i64):
    val name = stmt_get_name(idx)
    var type_tag = stmt_get_type(idx)
    val init_expr = stmt_get_expr(idx)

    # Infer type if not explicitly annotated
    if type_tag == TYPE_VOID:
        if init_expr >= 0:
            type_tag = cg_infer_expr_type(init_expr)
    val c_type = type_tag_to_c(type_tag)

    # Track variable type
    vt_add(name, type_tag)

    if is_array_type(type_tag):
        cg_emit_array_init(name, type_tag, init_expr, false)
        return

    if init_expr >= 0:
        val init_c = cg_expr(init_expr)
        val init_tag = expr_get_tag(init_expr)
        if init_tag == EXPR_STRUCT_LIT:
            val sname = expr_get_str(init_expr)
            st_add(name, sname)
            cg_emit_line(sname + " " + name + " = " + init_c + ";")
            return
        # Check struct constructor call: var a = Dog()
        if init_tag == EXPR_CALL:
            val callee = expr_get_left(init_expr)
            if expr_get_tag(callee) == EXPR_IDENT:
                val cn = expr_get_str(callee)
                val sid = named_type_find(cn)
                if sid >= 0:
                    st_add(name, cn)
                    cg_emit_line(cn + " " + name + " = " + init_c + ";")
                    return
        # Check if inferred type is a named struct type
        if type_tag >= TYPE_NAMED_BASE:
            val nid = type_tag - TYPE_NAMED_BASE
            val sname = named_type_name(nid)
            if sname != "":
                st_add(name, sname)
                cg_emit_line(sname + " " + name + " = " + init_c + ";")
                return
        cg_emit_line(c_type + " " + name + " = " + init_c + ";")
    else:
        cg_emit_line(c_type + " " + name + " = {};")

fn cg_emit_array_init(name: text, type_tag: i64, init_expr: i64, is_const: bool):
    if init_expr >= 0:
        val init_tag = expr_get_tag(init_expr)
        if init_tag == EXPR_ARRAY_LIT:
            val elements = expr_get_args(init_expr)
            cg_emit_line("SplArray* " + name + " = spl_array_new();")
            for i in range(0, elements.len()):
                val elem_c = cg_expr(elements[i])
                # Type-aware element wrapping
                if type_tag == TYPE_ARRAY_TEXT:
                    cg_emit_line("spl_array_push(" + name + ", spl_str(" + elem_c + "));")
                elif type_tag == TYPE_ARRAY_ANY:
                    cg_emit_line("spl_array_push(" + name + ", spl_array_val(" + elem_c + "));")
                else:
                    val elem_type = cg_infer_expr_type(elements[i])
                    val wrapped = cg_spl_wrap(elem_c, elem_type)
                    cg_emit_line("spl_array_push(" + name + ", " + wrapped + ");")
            return
        val init_c = cg_expr(init_expr)
        cg_emit_line("SplArray* " + name + " = " + init_c + ";")
    else:
        cg_emit_line("SplArray* " + name + " = spl_array_new();")

# ===== Assignment Statement =====

fn cg_assign_stmt(idx: i64):
    val target_expr = stmt_get_expr(idx)
    val body = stmt_get_body(idx)
    if body.len() > 0:
        val value_idx = body[0]
        val target_c = cg_expr(target_expr)
        val value_c = cg_expr(value_idx)

        # Check for array element assignment: arr[i] = value
        val target_tag = expr_get_tag(target_expr)
        if target_tag == EXPR_INDEX:
            val base_idx = expr_get_left(target_expr)
            val index_idx = expr_get_right(target_expr)
            val base_c = cg_expr(base_idx)
            val index_c = cg_expr(index_idx)
            cg_emit_line("spl_array_set(" + base_c + ", " + index_c + ", spl_int(" + value_c + "));")
            return

        cg_emit_line(target_c + " = " + value_c + ";")

# ===== Compound Assignment Statement =====

fn cg_compound_assign_stmt(idx: i64):
    val target_expr = stmt_get_expr(idx)
    val op = stmt_get_type(idx)
    val body = stmt_get_body(idx)
    if body.len() > 0:
        val value_idx = body[0]
        val target_c = cg_expr(target_expr)
        val value_c = cg_expr(value_idx)
        val c_op = cg_compound_op_to_c(op)
        cg_emit_line(target_c + " " + c_op + " " + value_c + ";")

# ===== If Statement =====

fn cg_if_stmt(idx: i64):
    val cond_expr = stmt_get_expr(idx)
    val then_body = stmt_get_body(idx)
    val elif_idx = stmt_get_type(idx)

    val cond_c = cg_expr(cond_expr)
    cg_emit_line("if (" + cond_c + ") {")
    cg_indent_inc()
    for i in range(0, then_body.len()):
        cg_stmt(then_body[i])
    cg_indent_dec()

    # Check for else branch via elif pool
    if elif_idx >= 0:
        val else_body = elif_get_else(elif_idx)
        if else_body.len() > 0:
            cg_emit_line("} else {")
            cg_indent_inc()
            for i in range(0, else_body.len()):
                cg_stmt(else_body[i])
            cg_indent_dec()
    cg_emit_line("}")

# ===== For Statement =====

fn cg_for_stmt(idx: i64):
    val iter_name = stmt_get_name(idx)
    val iterable = stmt_get_expr(idx)
    val body_stmts = stmt_get_body(idx)

    # Track loop variable
    vt_push_scope()
    vt_add(iter_name, TYPE_I64)

    val iter_tag = expr_get_tag(iterable)

    # range(start, end) pattern
    if iter_tag == EXPR_CALL:
        val callee_idx = expr_get_left(iterable)
        if expr_get_tag(callee_idx) == EXPR_IDENT:
            val callee_name = expr_get_str(callee_idx)
            if callee_name == "range":
                val range_args = expr_get_args(iterable)
                if range_args.len() == 2:
                    val start_c = cg_expr(range_args[0])
                    val end_c = cg_expr(range_args[1])
                    cg_emit_line("for (int64_t " + iter_name + " = " + start_c + "; " + iter_name + " < " + end_c + "; " + iter_name + "++) {")
                    cg_indent_inc()
                    for i in range(0, body_stmts.len()):
                        cg_stmt(body_stmts[i])
                    cg_indent_dec()
                    cg_emit_line("}")
                    vt_pop_scope()
                    return
                if range_args.len() == 1:
                    val end_c = cg_expr(range_args[0])
                    cg_emit_line("for (int64_t " + iter_name + " = 0; " + iter_name + " < " + end_c + "; " + iter_name + "++) {")
                    cg_indent_inc()
                    for i in range(0, body_stmts.len()):
                        cg_stmt(body_stmts[i])
                    cg_indent_dec()
                    cg_emit_line("}")
                    vt_pop_scope()
                    return

    # Range expression: for i in start..end
    if iter_tag == EXPR_RANGE:
        val start_c = cg_expr(expr_get_left(iterable))
        val end_c = cg_expr(expr_get_right(iterable))
        val inclusive = expr_get_int(iterable)
        var cmp: text = "<"
        if inclusive != 0:
            cmp = "<="
        cg_emit_line("for (int64_t " + iter_name + " = " + start_c + "; " + iter_name + " " + cmp + " " + end_c + "; " + iter_name + "++) {")
        cg_indent_inc()
        for i in range(0, body_stmts.len()):
            cg_stmt(body_stmts[i])
        cg_indent_dec()
        cg_emit_line("}")
        vt_pop_scope()
        return

    # Array iteration: for item in array
    val iter_c = cg_expr(iterable)

    # Check if iterating over a struct array
    if iter_tag == EXPR_IDENT:
        val arr_name = expr_get_str(iterable)
        val sa = sa_find(arr_name)
        if sa != "":
            st_add(iter_name, sa)
            cg_emit_line("for (size_t __" + iter_name + "_i = 0; __" + iter_name + "_i < " + iter_c + ".size(); __" + iter_name + "_i++) {")
            cg_indent_inc()
            cg_emit_line(sa + " " + iter_name + " = " + iter_c + "[__" + iter_name + "_i];")
            for i in range(0, body_stmts.len()):
                cg_stmt(body_stmts[i])
            cg_indent_dec()
            cg_emit_line("}")
            vt_pop_scope()
            return

    # Generic SplArray iteration — type-aware
    var iter_elem_type: text = "int64_t"
    var iter_accessor: text = ".as_int"
    if iter_tag == EXPR_IDENT:
        val iterable_name = expr_get_str(iterable)
        val iterable_type = vt_find(iterable_name)
        if iterable_type == TYPE_ARRAY_TEXT:
            iter_elem_type = "const char*"
            iter_accessor = ".as_str"
            vt_add(iter_name, TYPE_TEXT)
        elif iterable_type == TYPE_ARRAY_ANY:
            iter_elem_type = "SplArray*"
            iter_accessor = ".as_array"

    cg_emit_line("for (int64_t __" + iter_name + "_i = 0; __" + iter_name + "_i < spl_array_len(" + iter_c + "); __" + iter_name + "_i++) {")
    cg_indent_inc()
    cg_emit_line(iter_elem_type + " " + iter_name + " = spl_array_get(" + iter_c + ", __" + iter_name + "_i)" + iter_accessor + ";")
    for i in range(0, body_stmts.len()):
        cg_stmt(body_stmts[i])
    cg_indent_dec()
    cg_emit_line("}")
    vt_pop_scope()

# ===== While Statement =====

fn cg_while_stmt(idx: i64):
    val cond_expr = stmt_get_expr(idx)
    val body_stmts = stmt_get_body(idx)

    val cond_c = cg_expr(cond_expr)
    cg_emit_line("while (" + cond_c + ") {")
    cg_indent_inc()
    for i in range(0, body_stmts.len()):
        cg_stmt(body_stmts[i])
    cg_indent_dec()
    cg_emit_line("}")

# ===== Match Statement =====

fn cg_match_stmt(idx: i64):
    val scrutinee = stmt_get_expr(idx)
    val arm_indices = stmt_get_body(idx)

    val scrut_c = cg_expr(scrutinee)
    cg_emit_line("switch (" + scrut_c + ") {")
    cg_indent_inc()
    for i in range(0, arm_indices.len()):
        val arm_idx = arm_indices[i]
        val pattern_idx = arm_get_pattern(arm_idx)
        val arm_body = arm_get_body(arm_idx)
        val pat_tag = expr_get_tag(pattern_idx)

        # Wildcard pattern
        if pat_tag == EXPR_IDENT:
            val pat_name = expr_get_str(pattern_idx)
            if pat_name == "_":
                cg_emit_line("default: {")
            else:
                cg_emit_line("case " + cg_expr(pattern_idx) + ": {")
        elif pat_tag == EXPR_INT_LIT:
            cg_emit_line("case " + cg_expr(pattern_idx) + ": {")
        else:
            cg_emit_line("case " + cg_expr(pattern_idx) + ": {")

        cg_indent_inc()
        for j in range(0, arm_body.len()):
            cg_stmt(arm_body[j])
        cg_emit_line("break;")
        cg_indent_dec()
        cg_emit_line("}")
    cg_indent_dec()
    cg_emit_line("}")

# ===== Block Statement =====

fn cg_block_stmt(idx: i64):
    val body_stmts = stmt_get_body(idx)
    cg_emit_line("{")
    cg_indent_inc()
    vt_push_scope()
    for i in range(0, body_stmts.len()):
        cg_stmt(body_stmts[i])
    vt_pop_scope()
    cg_indent_dec()
    cg_emit_line("}")
