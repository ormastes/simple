# C Codegen â€” Helpers
#
# Output buffer, type tracking, inference, string helpers, operator mapping.
# Shared state and utilities used by cg_expr and c_codegen.

use compiler.core.ast.{expr_get, expr_get_tag, expr_get_int, expr_get_float, expr_get_str}
use compiler.core.ast.{expr_get_left, expr_get_right, expr_get_extra, expr_get_args, expr_get_stmts}
use compiler.core.ast.{EXPR_INT_LIT, EXPR_FLOAT_LIT, EXPR_STRING_LIT, EXPR_BOOL_LIT, EXPR_NIL_LIT}
use compiler.core.ast.{EXPR_IDENT, EXPR_BINARY, EXPR_UNARY, EXPR_CALL, EXPR_INDEX}
use compiler.core.ast.{EXPR_FIELD_ACCESS, EXPR_METHOD_CALL, EXPR_ARRAY_LIT}
use compiler.core.ast.{EXPR_RANGE, EXPR_ASM, EXPR_ASM_MATCH, EXPR_INTERPOLATED_STRING}
use compiler.core.ast.{EXPR_SLICE, EXPR_STRUCT_LIT}
use compiler.core.ast.{asm_arm_archs, asm_arm_os, asm_arm_abi, asm_arm_backend}
use compiler.core.ast.{asm_arm_asm_text, asm_arm_is_compile_error, asm_arm_error_msg, asm_arm_is_wildcard}
use compiler.core.tokens.{TOK_PLUS, TOK_MINUS, TOK_STAR, TOK_SLASH, TOK_PERCENT, TOK_STAR_STAR}
use compiler.core.tokens.{TOK_EQ, TOK_NOT_EQ, TOK_LT, TOK_GT, TOK_LT_EQ, TOK_GT_EQ}
use compiler.core.tokens.{TOK_KW_AND, TOK_KW_OR, TOK_KW_NOT}
use compiler.core.tokens.{TOK_PLUS_EQ, TOK_MINUS_EQ, TOK_STAR_EQ, TOK_SLASH_EQ, TOK_PERCENT_EQ}
use compiler.core.tokens.{TOK_AMPERSAND, TOK_PIPE, TOK_CARET, TOK_TILDE}
use compiler.core.types.{TYPE_VOID, TYPE_BOOL, TYPE_I64, TYPE_F64, TYPE_TEXT}
use compiler.core.types.{TYPE_ARRAY_I64, TYPE_ARRAY_TEXT, TYPE_ARRAY_BOOL, TYPE_ARRAY_ANY}
use compiler.core.types.{TYPE_STRUCT, TYPE_FN, TYPE_ANY, TYPE_NIL}
use compiler.core.types.{TYPE_OPTION, TYPE_RESULT, TYPE_NAMED_BASE}
use compiler.core.types.{type_tag_to_c, type_tag_name}
use compiler.core.types.{named_type_register, named_type_update, named_type_find, named_type_name, named_type_fields, named_type_field_type_tags}
use compiler.core.types.{fn_sig_register, fn_sig_find, fn_sig_ret_type}
use compiler.core.types.{fn_sig_param_count, fn_sig_get_param_names, fn_sig_get_param_types}
use compiler.core.types.{int_to_str}

# ===== Output Buffer =====

var cg_output: text = ""
var cg_indent: i64 = 0

fn cg_emit(s: text):
    cg_output = cg_output + s

fn cg_emit_line(s: text):
    for i in range(0, cg_indent):
        cg_output = cg_output + "    "
    cg_output = cg_output + s + "\n"

fn cg_emit_blank():
    cg_output = cg_output + "\n"

fn cg_indent_inc():
    cg_indent = cg_indent + 1

fn cg_indent_dec():
    cg_indent = cg_indent - 1

fn cg_output_get() -> text:
    cg_output

fn cg_reset():
    cg_output = ""
    cg_indent = 0

# ===== Variable Type Tracking =====
# Track local variable types for codegen decisions (string vs int operations).

var vt_names: [text] = []
var vt_types: [i64] = []
var vt_depths: [i64] = []
var vt_scope: i64 = 0

fn vt_reset():
    vt_names = []
    vt_types = []
    vt_depths = []
    vt_scope = 0

fn vt_push_scope():
    vt_scope = vt_scope + 1

fn vt_pop_scope():
    # Remove variables from current scope
    var new_names: [text] = []
    var new_types: [i64] = []
    var new_depths: [i64] = []
    for i in range(0, vt_names.len()):
        if vt_depths[i] < vt_scope:
            new_names.push(vt_names[i])
            new_types.push(vt_types[i])
            new_depths.push(vt_depths[i])
    vt_names = new_names
    vt_types = new_types
    vt_depths = new_depths
    vt_scope = vt_scope - 1

fn vt_add(name: text, type_tag: i64):
    vt_names.push(name)
    vt_types.push(type_tag)
    vt_depths.push(vt_scope)

fn vt_find(name: text) -> i64:
    # Search from end for shadowing
    val count = vt_names.len()
    if count == 0:
        return -1
    for i in range(0, count):
        val rev = count - 1 - i
        if vt_names[rev] == name:
            return vt_types[rev]
    -1

# ===== Struct Type Tracking =====
# Track which variables hold struct types, and which struct name.

var st_var_names: [text] = []
var st_struct_names: [text] = []

fn st_reset():
    st_var_names = []
    st_struct_names = []

fn st_add(var_name: text, struct_name: text):
    st_var_names.push(var_name)
    st_struct_names.push(struct_name)

fn st_find(var_name: text) -> text:
    val count = st_var_names.len()
    if count == 0:
        return ""
    for i in range(0, count):
        val rev = count - 1 - i
        if st_var_names[rev] == var_name:
            return st_struct_names[rev]
    ""

# ===== Struct Array Tracking =====
# Track which variables are [StructType] (use std::vector)

var sa_var_names: [text] = []
var sa_struct_names: [text] = []

fn sa_reset():
    sa_var_names = []
    sa_struct_names = []

fn sa_add(var_name: text, struct_name: text):
    sa_var_names.push(var_name)
    sa_struct_names.push(struct_name)

fn sa_find(var_name: text) -> text:
    val count = sa_var_names.len()
    if count == 0:
        return ""
    for i in range(0, count):
        val rev = count - 1 - i
        if sa_var_names[rev] == var_name:
            return sa_struct_names[rev]
    ""

# ===== Type Tag Helpers =====

fn is_text_type(tag: i64) -> bool:
    tag == TYPE_TEXT

fn is_array_type(tag: i64) -> bool:
    if tag == TYPE_ARRAY_I64: return true
    if tag == TYPE_ARRAY_TEXT: return true
    if tag == TYPE_ARRAY_BOOL: return true
    if tag == TYPE_ARRAY_ANY: return true
    false

fn is_struct_type(tag: i64) -> bool:
    tag == TYPE_STRUCT

# ===== Type Inference for Untyped Declarations =====

fn cg_infer_expr_type(idx: i64) -> i64:
    if idx < 0:
        return TYPE_VOID
    val tag = expr_get_tag(idx)
    if tag == EXPR_INT_LIT:
        return TYPE_I64
    if tag == EXPR_FLOAT_LIT:
        return TYPE_F64
    if tag == EXPR_STRING_LIT:
        return TYPE_TEXT
    if tag == EXPR_BOOL_LIT:
        return TYPE_BOOL
    if tag == EXPR_NIL_LIT:
        return TYPE_NIL
    if tag == EXPR_INTERPOLATED_STRING:
        return TYPE_TEXT
    if tag == EXPR_IDENT:
        val name = expr_get_str(idx)
        val vtype = vt_find(name)
        if vtype >= 0:
            return vtype
        return TYPE_I64
    if tag == EXPR_CALL:
        val callee_idx = expr_get_left(idx)
        if expr_get_tag(callee_idx) == EXPR_IDENT:
            val callee_name = expr_get_str(callee_idx)
            if callee_name == "int":
                return TYPE_I64
            if callee_name == "float":
                return TYPE_F64
            if callee_name == "str":
                return TYPE_TEXT
            if callee_name == "Some":
                return TYPE_OPTION
            if callee_name == "SplSome":
                return TYPE_OPTION
            if callee_name == "SplNone":
                return TYPE_OPTION
            if callee_name == "Ok":
                return TYPE_RESULT
            if callee_name == "Err":
                return TYPE_RESULT
            # Look up function return type
            val sig_id = fn_sig_find(callee_name)
            if sig_id >= 0:
                return fn_sig_ret_type(sig_id)
            # Check if struct constructor
            val struct_id = named_type_find(callee_name)
            if struct_id >= 0:
                return TYPE_STRUCT
        return TYPE_I64
    if tag == EXPR_BINARY:
        val op = expr_get_int(idx)
        # Comparison operators return bool
        if op == TOK_EQ: return TYPE_BOOL
        if op == TOK_NOT_EQ: return TYPE_BOOL
        if op == TOK_LT: return TYPE_BOOL
        if op == TOK_GT: return TYPE_BOOL
        if op == TOK_LT_EQ: return TYPE_BOOL
        if op == TOK_GT_EQ: return TYPE_BOOL
        if op == TOK_KW_AND: return TYPE_BOOL
        if op == TOK_KW_OR: return TYPE_BOOL
        # String concat: if left is text
        if op == TOK_PLUS:
            val left_type = cg_infer_expr_type(expr_get_left(idx))
            if left_type == TYPE_TEXT:
                return TYPE_TEXT
        # Arithmetic inherits from operands
        val left_type = cg_infer_expr_type(expr_get_left(idx))
        if left_type == TYPE_F64:
            return TYPE_F64
        return TYPE_I64
    if tag == EXPR_UNARY:
        val op = expr_get_int(idx)
        if op == TOK_KW_NOT:
            return TYPE_BOOL
        return cg_infer_expr_type(expr_get_left(idx))
    if tag == EXPR_FIELD_ACCESS:
        # Try to look up struct field type
        val fa_base = expr_get_left(idx)
        val fa_field = expr_get_str(idx)
        if expr_get_tag(fa_base) == EXPR_IDENT:
            val fa_var = expr_get_str(fa_base)
            val fa_sname = st_find(fa_var)
            if fa_sname != "":
                val fa_nid = named_type_find(fa_sname)
                if fa_nid >= 0:
                    val fa_fields = named_type_fields(fa_nid)
                    val fa_ftypes = named_type_field_type_tags(fa_nid)
                    for fa_i in range(0, fa_fields.len()):
                        if fa_fields[fa_i] == fa_field:
                            return fa_ftypes[fa_i]
        return TYPE_I64
    if tag == EXPR_METHOD_CALL:
        val method_name = expr_get_str(idx)
        if method_name == "len":
            return TYPE_I64
        if method_name == "contains":
            return TYPE_BOOL
        if method_name == "starts_with":
            return TYPE_BOOL
        if method_name == "ends_with":
            return TYPE_BOOL
        if method_name == "index_of":
            return TYPE_I64
        if method_name == "replace":
            return TYPE_TEXT
        if method_name == "trim":
            return TYPE_TEXT
        if method_name == "slice":
            return TYPE_TEXT
        # Look up struct method return type
        val mc_recv = expr_get_left(idx)
        if expr_get_tag(mc_recv) == EXPR_IDENT:
            val mc_recv_name = expr_get_str(mc_recv)
            val mc_sname = st_find(mc_recv_name)
            if mc_sname != "":
                val mc_mangled = mc_sname + "__" + method_name
                val mc_sig = fn_sig_find(mc_mangled)
                if mc_sig >= 0:
                    return fn_sig_ret_type(mc_sig)
            # Check static method call: Point.origin()
            val mc_type_id = named_type_find(mc_recv_name)
            if mc_type_id >= 0:
                val mc_mangled2 = mc_recv_name + "__" + method_name
                val mc_sig2 = fn_sig_find(mc_mangled2)
                if mc_sig2 >= 0:
                    return fn_sig_ret_type(mc_sig2)
        return TYPE_I64
    if tag == EXPR_INDEX:
        val base_idx = expr_get_left(idx)
        val base_type = cg_infer_expr_type(base_idx)
        if base_type == TYPE_ARRAY_TEXT:
            return TYPE_TEXT
        if base_type == TYPE_ARRAY_BOOL:
            return TYPE_BOOL
        if base_type == TYPE_ARRAY_ANY:
            return TYPE_ARRAY_I64
        return TYPE_I64
    if tag == EXPR_ARRAY_LIT:
        return TYPE_ARRAY_I64
    if tag == EXPR_RANGE:
        return TYPE_I64
    if tag == EXPR_ASM:
        return TYPE_I64
    if tag == EXPR_ASM_MATCH:
        return TYPE_I64
    if tag == EXPR_SLICE:
        return TYPE_TEXT
    # Default
    TYPE_I64

# ===== Type-Aware SplValue Wrapping =====

fn cg_spl_wrap(value_c: text, value_type: i64) -> text:
    # Wrap a C++ value in the appropriate SplValue constructor
    if value_type == TYPE_TEXT:
        return "spl_str(" + value_c + ")"
    if value_type == TYPE_ARRAY_I64:
        return "spl_array_val(" + value_c + ")"
    if value_type == TYPE_ARRAY_TEXT:
        return "spl_array_val(" + value_c + ")"
    if value_type == TYPE_ARRAY_BOOL:
        return "spl_array_val(" + value_c + ")"
    if value_type == TYPE_ARRAY_ANY:
        return "spl_array_val(" + value_c + ")"
    if value_type == TYPE_F64:
        return "spl_float(" + value_c + ")"
    if value_type == TYPE_BOOL:
        return "spl_bool(" + value_c + ")"
    "spl_int(" + value_c + ")"

fn cg_spl_access(array_type: i64) -> text:
    # Return the appropriate SplValue accessor for array element type
    if array_type == TYPE_ARRAY_TEXT:
        return ".as_str"
    if array_type == TYPE_ARRAY_ANY:
        return ".as_array"
    ".as_int"

# ===== C++ String Escaping =====

fn cg_escape_string(s: text) -> text:
    # Use replace chain instead of character iteration
    # (character indexing on strings generates wrong types in seed)
    var r0: text = s.replace("\\", "\\\\")
    var r1: text = r0.replace("\"", "\\\"")
    var r2: text = r1.replace("\n", "\\n")
    var r3: text = r2.replace("\t", "\\t")
    var r4: text = r3.replace("\r", "\\r")
    var r5: text = r4.replace("\0", "\\0")
    r5

# ===== Binary Operator to C++ =====

fn cg_binop_to_c(op: i64) -> text:
    if op == TOK_PLUS: return "+"
    if op == TOK_MINUS: return "-"
    if op == TOK_STAR: return "*"
    if op == TOK_SLASH: return "/"
    if op == TOK_PERCENT: return "%"
    if op == TOK_EQ: return "=="
    if op == TOK_NOT_EQ: return "!="
    if op == TOK_LT: return "<"
    if op == TOK_GT: return ">"
    if op == TOK_LT_EQ: return "<="
    if op == TOK_GT_EQ: return ">="
    if op == TOK_KW_AND: return "&&"
    if op == TOK_KW_OR: return "||"
    if op == TOK_AMPERSAND: return "&"
    if op == TOK_PIPE: return "|"
    if op == TOK_CARET: return "^"
    "/* unknown_op */"

fn cg_compound_op_to_c(op: i64) -> text:
    if op == TOK_PLUS_EQ: return "+="
    if op == TOK_MINUS_EQ: return "-="
    if op == TOK_STAR_EQ: return "*="
    if op == TOK_SLASH_EQ: return "/="
    if op == TOK_PERCENT_EQ: return "%="
    "/* unknown_compound_op */"

# ===== Asm Match/Assert Code Generation =====
# These functions only depend on cg_escape_string and AST asm_arm_* accessors.

fn cg_arch_to_cpp_macro(arch: text) -> text:
    """Map Simple arch name to C preprocessor check."""
    val lower = arch.lower()
    if lower == "x86_64" or lower == "amd64" or lower == "x64":
        return "defined(__x86_64__) || defined(_M_X64)"
    if lower == "x86" or lower == "i686" or lower == "i386":
        return "defined(__i386__) || defined(_M_IX86)"
    if lower == "aarch64" or lower == "arm64":
        return "defined(__aarch64__) || defined(_M_ARM64)"
    if lower == "arm" or lower == "armv7":
        return "defined(__ARM_ARCH)"
    if lower == "riscv64":
        return "defined(__riscv) && (__riscv_xlen == 64)"
    if lower == "riscv32":
        return "defined(__riscv) && (__riscv_xlen == 32)"
    if lower == "wasm32":
        return "defined(__wasm32__)"
    if lower == "wasm64":
        return "defined(__wasm64__)"
    if lower == "avr":
        return "defined(__AVR__)"
    if lower == "msp430":
        return "defined(__MSP430__)"
    if lower == "mcs51":
        return "defined(__SDCC_mcs51)"
    return "0 /* unknown arch: " + arch + " */"

fn cg_arm_condition(arm_idx: i64) -> text:
    """Generate C preprocessor condition for an asm arm."""
    val archs = asm_arm_archs[arm_idx]
    var parts: [text] = []
    for arch in archs:
        parts.push("(" + cg_arch_to_cpp_macro(arch) + ")")
    if parts.len() == 0:
        return "1"
    if parts.len() == 1:
        return parts[0]
    return parts.join(" || ")

fn cg_asm_match(arm_indices: [i64]) -> text:
    """Generate C preprocessor guards for asm match expression."""
    var result = "([&]() -> int64_t { "
    var first = true
    for i in 0..arm_indices.len():
        val arm_idx = arm_indices[i]
        val is_wildcard = asm_arm_is_wildcard[arm_idx]
        val is_ce = asm_arm_is_compile_error[arm_idx]

        if is_wildcard:
            if first:
                result = result + "\n#if 1\n"
            else:
                result = result + "\n#else\n"
            if is_ce:
                val msg = asm_arm_error_msg[arm_idx]
                result = result + "#error \"" + msg + "\"\n"
                result = result + "return (int64_t)0;\n"
            else:
                val asm_text = asm_arm_asm_text[arm_idx]
                val escaped = cg_escape_string(asm_text)
                result = result + "asm volatile(\"" + escaped + "\"); return (int64_t)0;\n"
        else:
            val cond = cg_arm_condition(arm_idx)
            if first:
                result = result + "\n#if " + cond + "\n"
                first = false
            else:
                result = result + "#elif " + cond + "\n"
            if is_ce:
                val msg = asm_arm_error_msg[arm_idx]
                result = result + "#error \"" + msg + "\"\n"
                result = result + "return (int64_t)0;\n"
            else:
                val asm_text = asm_arm_asm_text[arm_idx]
                val escaped = cg_escape_string(asm_text)
                result = result + "asm volatile(\"" + escaped + "\"); return (int64_t)0;\n"

    if first:
        # No arms at all
        result = result + "\n#error \"no asm match cases\"\n"
    result = result + "#endif\n"
    result = result + "return (int64_t)0; })()"
    result

fn cg_asm_assert(arm_indices: [i64]) -> text:
    """Generate C static_assert for asm assert expression."""
    if arm_indices.len() == 0:
        return "(int64_t)0"
    val arm_idx = arm_indices[0]
    val cond = cg_arm_condition(arm_idx)
    # Emit as an immediately-invoked lambda that includes the static_assert
    var result = "([&]() -> int64_t { "
    result = result + "\n#if !(" + cond + ")\n"
    result = result + "#error \"asm assert: target does not match\"\n"
    result = result + "#endif\n"
    result = result + "return (int64_t)0; })()"
    result

export cg_emit, cg_emit_line, cg_emit_blank, cg_indent_inc, cg_indent_dec
export cg_output_get, cg_reset
export vt_reset, vt_push_scope, vt_pop_scope, vt_add, vt_find
export st_reset, st_add, st_find
export sa_reset, sa_add, sa_find
export is_text_type, is_array_type, is_struct_type
export cg_infer_expr_type
export cg_spl_wrap, cg_spl_access
export cg_escape_string
export cg_binop_to_c, cg_compound_op_to_c
export cg_asm_match, cg_asm_assert
