# C Codegen — Expression Codegen
#
# Expression codegen (cg_expr). Statement codegen is in cg_stmt.spl
# (re-exported via wildcard import below).
# Depends on cg_helpers for output buffer, type tracking, and inference.

use compiler.core.ast.{expr_get, expr_get_tag, expr_get_int, expr_get_float, expr_get_str}
use compiler.core.ast.{expr_get_left, expr_get_right, expr_get_extra, expr_get_args, expr_get_stmts}
use compiler.core.ast.{stmt_get, stmt_get_tag, stmt_get_expr, stmt_get_name, stmt_get_type, stmt_get_body}
use compiler.core.ast.{elif_get_cond, elif_get_body, elif_get_else}
use compiler.core.ast.{arm_get_pattern, arm_get_body}
use compiler.core.ast.{EXPR_INT_LIT, EXPR_FLOAT_LIT, EXPR_STRING_LIT, EXPR_BOOL_LIT, EXPR_NIL_LIT}
use compiler.core.ast.{EXPR_IDENT, EXPR_BINARY, EXPR_UNARY, EXPR_CALL, EXPR_INDEX}
use compiler.core.ast.{EXPR_FIELD_ACCESS, EXPR_METHOD_CALL, EXPR_ARRAY_LIT, EXPR_DICT_LIT}
use compiler.core.ast.{EXPR_IF, EXPR_MATCH, EXPR_FOR, EXPR_WHILE, EXPR_BLOCK}
use compiler.core.ast.{EXPR_RETURN, EXPR_BREAK, EXPR_CONTINUE, EXPR_RANGE}
use compiler.core.ast.{EXPR_ASSIGN, EXPR_COMPOUND_ASSIGN, EXPR_STRUCT_LIT}
use compiler.core.ast.{EXPR_UNIT, EXPR_PASS, EXPR_PASS_TODO, EXPR_PASS_DO_NOTHING, EXPR_PASS_DN, EXPR_INTERPOLATED_STRING}
use compiler.core.ast.{EXPR_SLICE, EXPR_NULL_COALESCE, EXPR_CAST, EXPR_ASM, EXPR_ASM_MATCH}
use compiler.core.ast.{STMT_EXPR, STMT_VAL_DECL, STMT_VAR_DECL, STMT_ASSIGN, STMT_RETURN}
use compiler.core.ast.{STMT_IF, STMT_FOR, STMT_WHILE, STMT_MATCH, STMT_BLOCK}
use compiler.core.ast.{STMT_BREAK, STMT_CONTINUE, STMT_COMPOUND_ASSIGN}
use compiler.core.tokens.{TOK_PLUS, TOK_MINUS, TOK_STAR, TOK_SLASH, TOK_PERCENT, TOK_STAR_STAR}
use compiler.core.tokens.{TOK_EQ, TOK_NOT_EQ, TOK_LT, TOK_GT, TOK_LT_EQ, TOK_GT_EQ}
use compiler.core.tokens.{TOK_KW_AND, TOK_KW_OR, TOK_KW_NOT}
use compiler.core.tokens.{TOK_PLUS_EQ, TOK_MINUS_EQ, TOK_STAR_EQ, TOK_SLASH_EQ, TOK_PERCENT_EQ}
use compiler.core.tokens.{TOK_TILDE}
use compiler.core.types.{TYPE_VOID, TYPE_BOOL, TYPE_I64, TYPE_F64, TYPE_TEXT}
use compiler.core.types.{TYPE_ARRAY_I64, TYPE_ARRAY_TEXT, TYPE_ARRAY_BOOL, TYPE_ARRAY_ANY}
use compiler.core.types.{TYPE_STRUCT, TYPE_OPTION, TYPE_RESULT, TYPE_NAMED_BASE}
use compiler.core.types.{type_tag_to_c}
use compiler.core.types.{named_type_find, named_type_name}
use compiler.core.types.{fn_sig_find, fn_sig_ret_type}
use compiler.core.types.{int_to_str}
use compiler.core.compiler.cg_helpers.{cg_emit, cg_emit_line, cg_emit_blank, cg_indent_inc, cg_indent_dec}
use compiler.core.compiler.cg_helpers.{vt_push_scope, vt_pop_scope, vt_add, vt_find}
use compiler.core.compiler.cg_helpers.{st_add, st_find, sa_find}
use compiler.core.compiler.cg_helpers.{is_text_type, is_array_type}
use compiler.core.compiler.cg_helpers.{cg_infer_expr_type, cg_spl_wrap, cg_spl_access}
use compiler.core.compiler.cg_helpers.{cg_escape_string, cg_binop_to_c, cg_compound_op_to_c}
use compiler.core.compiler.cg_helpers.{cg_asm_match, cg_asm_assert}

# ===== Expression Codegen =====

fn cg_expr(idx: i64) -> text:
    val tag = expr_get_tag(idx)

    if tag == EXPR_INT_LIT:
        val v = expr_get_int(idx)
        return int_to_str(v)

    if tag == EXPR_FLOAT_LIT:
        return expr_get_float(idx)

    if tag == EXPR_STRING_LIT:
        val raw = expr_get_str(idx)
        val escaped = cg_escape_string(raw)
        return "\"" + escaped + "\""

    if tag == EXPR_BOOL_LIT:
        val v = expr_get_int(idx)
        if v != 0:
            return "true"
        return "false"

    if tag == EXPR_NIL_LIT:
        return "SplValue{}"

    if tag == EXPR_UNIT:
        return "/* unit */"

    if tag == EXPR_PASS:
        val msg = expr_get_str(idx)
        if msg == "":
            return "/* pass */"
        return "/* pass: " + msg + " */"

    if tag == EXPR_PASS_TODO:
        val msg = expr_get_str(idx)
        if msg == "":
            return "/* TODO */"
        return "/* TODO: " + msg + " */"

    if tag == EXPR_PASS_DO_NOTHING:
        val msg = expr_get_str(idx)
        if msg == "":
            return "/* intentional no-op */"
        return "/* no-op: " + msg + " */"

    if tag == EXPR_PASS_DN:
        val msg = expr_get_str(idx)
        if msg == "":
            return "/* intentional no-op */"
        return "/* no-op: " + msg + " */"

    if tag == EXPR_IDENT:
        return expr_get_str(idx)

    if tag == EXPR_BINARY:
        return cg_binary_expr(idx)

    if tag == EXPR_UNARY:
        return cg_unary_expr(idx)

    if tag == EXPR_CALL:
        return cg_call_expr(idx)

    if tag == EXPR_INDEX:
        return cg_index_expr(idx)

    if tag == EXPR_FIELD_ACCESS:
        return cg_field_access_expr(idx)

    if tag == EXPR_METHOD_CALL:
        return cg_method_call_expr(idx)

    if tag == EXPR_ARRAY_LIT:
        return cg_array_lit_expr(idx)

    if tag == EXPR_DICT_LIT:
        return cg_dict_lit_expr(idx)

    if tag == EXPR_STRUCT_LIT:
        return cg_struct_lit_expr(idx)

    if tag == EXPR_IF:
        return cg_if_expr(idx)

    if tag == EXPR_RETURN:
        val left = expr_get_left(idx)
        if left >= 0:
            return "return " + cg_expr(left)
        return "return"

    if tag == EXPR_BREAK:
        return "break"

    if tag == EXPR_CONTINUE:
        return "continue"

    if tag == EXPR_RANGE:
        return cg_range_expr(idx)

    if tag == EXPR_ASM:
        val asm_src = expr_get_str(idx)
        val asm_escaped = cg_escape_string(asm_src)
        return "([&](){ asm volatile(\"" + asm_escaped + "\"); return (int64_t)0; })()"

    if tag == EXPR_ASM_MATCH:
        val is_assert = expr_get_int(idx) == 1
        val arm_indices = expr_get_args(idx)
        if is_assert:
            return cg_asm_assert(arm_indices)
        else:
            return cg_asm_match(arm_indices)

    if tag == EXPR_ASSIGN:
        val assign_left = expr_get_left(idx)
        val assign_right = expr_get_right(idx)
        val left_tag = expr_get_tag(assign_left)
        if left_tag == EXPR_INDEX:
            # Array element assignment: arr[i] = value -> spl_array_set(arr, i, wrapped(value))
            val a_base = expr_get_left(assign_left)
            val a_index = expr_get_right(assign_left)
            val a_base_c = cg_expr(a_base)
            val a_index_c = cg_expr(a_index)
            val a_value_c = cg_expr(assign_right)
            val a_val_type = cg_infer_expr_type(assign_right)
            # Also check the array's element type for better inference
            if expr_get_tag(a_base) == EXPR_IDENT:
                val arr_name = expr_get_str(a_base)
                val arr_type = vt_find(arr_name)
                if arr_type == TYPE_ARRAY_TEXT:
                    return "spl_array_set(" + a_base_c + ", " + a_index_c + ", spl_str(" + a_value_c + "))"
                if arr_type == TYPE_ARRAY_ANY:
                    return "spl_array_set(" + a_base_c + ", " + a_index_c + ", spl_array_val(" + a_value_c + "))"
            val a_wrapped = cg_spl_wrap(a_value_c, a_val_type)
            return "spl_array_set(" + a_base_c + ", " + a_index_c + ", " + a_wrapped + ")"
        val target = cg_expr(assign_left)
        val value = cg_expr(assign_right)
        return target + " = " + value

    if tag == EXPR_COMPOUND_ASSIGN:
        val op = expr_get_int(idx)
        val target = cg_expr(expr_get_left(idx))
        val value = cg_expr(expr_get_right(idx))
        return target + " " + cg_compound_op_to_c(op) + " " + value

    if tag == EXPR_INTERPOLATED_STRING:
        return cg_interpolated_string_expr(idx)

    if tag == EXPR_SLICE:
        return cg_slice_expr(idx)

    if tag == EXPR_NULL_COALESCE:
        val left_c = cg_expr(expr_get_left(idx))
        val right_c = cg_expr(expr_get_right(idx))
        return "(" + left_c + ".has_value ? " + left_c + ".value : " + right_c + ")"

    if tag == EXPR_CAST:
        val src = cg_expr(expr_get_left(idx))
        val target_type = expr_get_int(idx)
        val c_type = type_tag_to_c(target_type)
        return "((" + c_type + ")(" + src + "))"

    if tag == EXPR_BLOCK:
        return cg_block_expr(idx)

    if tag == EXPR_FOR:
        return cg_for_expr(idx)

    if tag == EXPR_WHILE:
        return cg_while_expr(idx)

    if tag == EXPR_MATCH:
        return cg_match_expr(idx)

    # Fallback
    return "/* unhandled_expr */"

# ===== Binary Expression =====

fn cg_binary_expr(idx: i64) -> text:
    val op = expr_get_int(idx)
    val left_idx = expr_get_left(idx)
    val right_idx = expr_get_right(idx)

    # Handle nil comparison: expr == nil or expr != nil
    val right_tag = expr_get_tag(right_idx)
    if right_tag == EXPR_NIL_LIT:
        val left_c2 = cg_expr(left_idx)
        val left_type = cg_infer_expr_type(left_idx)
        if left_type == TYPE_TEXT:
            if op == TOK_EQ: return "(" + left_c2 + " == nullptr)"
            if op == TOK_NOT_EQ: return "(" + left_c2 + " != nullptr)"
        if left_type == TYPE_I64:
            if op == TOK_EQ: return "(" + left_c2 + " == -1)"
            if op == TOK_NOT_EQ: return "(" + left_c2 + " != -1)"
        if is_array_type(left_type):
            if op == TOK_EQ: return "(" + left_c2 + " == nullptr)"
            if op == TOK_NOT_EQ: return "(" + left_c2 + " != nullptr)"

    val left_c = cg_expr(left_idx)
    val right_c = cg_expr(right_idx)

    # String concatenation: text + text -> spl_str_concat
    val left_tag = expr_get_tag(left_idx)
    val is_left_str = left_tag == EXPR_STRING_LIT
    if is_left_str:
        if op == TOK_PLUS:
            return "spl_str_concat(" + left_c + ", " + right_c + ")"

    # Check if left is a known text variable
    if left_tag == EXPR_IDENT:
        val left_name = expr_get_str(left_idx)
        val left_type = vt_find(left_name)
        if left_type == TYPE_TEXT:
            if op == TOK_PLUS:
                return "spl_str_concat(" + left_c + ", " + right_c + ")"
            if op == TOK_EQ:
                return "spl_str_eq(" + left_c + ", " + right_c + ")"
            if op == TOK_NOT_EQ:
                return "(!spl_str_eq(" + left_c + ", " + right_c + "))"

    # String literal equality
    if is_left_str:
        if op == TOK_EQ:
            return "spl_str_eq(" + left_c + ", " + right_c + ")"
        if op == TOK_NOT_EQ:
            return "(!spl_str_eq(" + left_c + ", " + right_c + "))"

    # General text concat/compare: infer left type for expressions like spl_str_concat(a,b) + c
    if op == TOK_PLUS:
        val left_inferred = cg_infer_expr_type(left_idx)
        if left_inferred == TYPE_TEXT:
            return "spl_str_concat(" + left_c + ", " + right_c + ")"
    if op == TOK_EQ:
        val left_inferred2 = cg_infer_expr_type(left_idx)
        if left_inferred2 == TYPE_TEXT:
            return "spl_str_eq(" + left_c + ", " + right_c + ")"
    if op == TOK_NOT_EQ:
        val left_inferred3 = cg_infer_expr_type(left_idx)
        if left_inferred3 == TYPE_TEXT:
            return "(!spl_str_eq(" + left_c + ", " + right_c + "))"

    # Power operator -> pow()
    if op == TOK_STAR_STAR:
        return "pow(" + left_c + ", " + right_c + ")"

    val c_op = cg_binop_to_c(op)
    return "(" + left_c + " " + c_op + " " + right_c + ")"

# ===== Unary Expression =====

fn cg_unary_expr(idx: i64) -> text:
    val op = expr_get_int(idx)
    val operand = cg_expr(expr_get_left(idx))
    if op == TOK_MINUS:
        return "(-" + operand + ")"
    if op == TOK_KW_NOT:
        return "(!" + operand + ")"
    if op == TOK_TILDE:
        return "(~" + operand + ")"
    return "(/* unknown_unary */" + operand + ")"

# ===== Function Call Expression =====

fn cg_call_expr(idx: i64) -> text:
    val callee_idx = expr_get_left(idx)
    val call_args = expr_get_args(idx)
    val callee_tag = expr_get_tag(callee_idx)

    var callee_name: text = ""
    if callee_tag == EXPR_IDENT:
        callee_name = expr_get_str(callee_idx)

    # Built-in function mapping
    if callee_name == "print":
        return cg_print_call(call_args)

    if callee_name == "range":
        return cg_range_call(call_args)

    if callee_name == "int":
        if call_args.len() > 0:
            val arg_c = cg_expr(call_args[0])
            val arg_type = cg_infer_expr_type(call_args[0])
            if arg_type == TYPE_TEXT:
                return "atoll(" + arg_c + ")"
            return "((int64_t)(" + arg_c + "))"

    if callee_name == "float":
        if call_args.len() > 0:
            val arg_c = cg_expr(call_args[0])
            return "((double)(" + arg_c + "))"

    if callee_name == "str":
        if call_args.len() > 0:
            val arg_c = cg_expr(call_args[0])
            return "spl_i64_to_str(" + arg_c + ")"

    if callee_name == "int_to_str":
        if call_args.len() > 0:
            val arg_c = cg_expr(call_args[0])
            return "spl_to_str(" + arg_c + ")"

    # Option/Result constructors
    if callee_name == "Some":
        if call_args.len() > 0:
            val some_arg = cg_expr(call_args[0])
            val some_type = cg_infer_expr_type(call_args[0])
            val wrapped = cg_spl_wrap(some_arg, some_type)
            return "SplSome(" + wrapped + ")"
        return "SplSome(spl_int(0))"
    if callee_name == "None":
        return "SplNone()"
    if callee_name == "Ok":
        if call_args.len() > 0:
            val ok_arg = cg_expr(call_args[0])
            return "Ok(" + ok_arg + ")"
        return "Ok()"
    if callee_name == "Err":
        if call_args.len() > 0:
            val err_arg = cg_expr(call_args[0])
            return "Err(" + err_arg + ")"
        return "Err(\"\")"

    # Check if callee is a struct constructor
    if callee_name != "":
        val struct_id = named_type_find(callee_name)
        if struct_id >= 0:
            return cg_struct_construct(callee_name, call_args)

    # General function call
    val callee_c = cg_expr(callee_idx)
    var args_c: text = ""
    for i in range(0, call_args.len()):
        if i > 0:
            args_c = args_c + ", "
        args_c = args_c + cg_expr(call_args[i])
    return callee_c + "(" + args_c + ")"

fn cg_print_call(call_args: [i64]) -> text:
    if call_args.len() == 0:
        return "spl_println(\"\")"
    val arg_idx = call_args[0]
    val arg_tag = expr_get_tag(arg_idx)
    val arg_c = cg_expr(arg_idx)

    # String literal or text variable -> spl_println
    if arg_tag == EXPR_STRING_LIT:
        return "spl_println(" + arg_c + ")"
    if arg_tag == EXPR_INTERPOLATED_STRING:
        return "spl_println(" + arg_c + ")"

    # Check if known text variable
    if arg_tag == EXPR_IDENT:
        val name = expr_get_str(arg_idx)
        val vtype = vt_find(name)
        if vtype == TYPE_TEXT:
            return "spl_println(" + arg_c + ")"
        if vtype == TYPE_F64:
            return "printf(\"%g\\n\", " + arg_c + ")"
        if vtype == TYPE_BOOL:
            return "printf(\"%s\\n\", " + arg_c + " ? \"true\" : \"false\")"

    # Infer type for complex expressions (binary ops, function calls, etc.)
    val inferred = cg_infer_expr_type(arg_idx)
    if inferred == TYPE_TEXT:
        return "spl_println(" + arg_c + ")"
    if inferred == TYPE_F64:
        return "printf(\"%g\\n\", " + arg_c + ")"
    if inferred == TYPE_BOOL:
        return "printf(\"%s\\n\", " + arg_c + " ? \"true\" : \"false\")"

    # Default: assume integer
    return "printf(\"%lld\\n\", (long long)" + arg_c + ")"

fn cg_range_call(call_args: [i64]) -> text:
    # range() is handled at the for-loop level, not as a standalone call
    return "/* range */"

# ===== Struct Construction =====

fn cg_struct_construct(struct_name: text, call_args: [i64]) -> text:
    # Named field construction: StructName(field: value, ...)
    # For seed compat, use C99/C++ brace initialization
    var result: text = struct_name + "{"
    for i in range(0, call_args.len()):
        if i > 0:
            result = result + ", "
        result = result + cg_expr(call_args[i])
    result = result + "}"
    result

# ===== Struct Literal Expression =====

fn cg_struct_lit_expr(idx: i64) -> text:
    val type_name = expr_get_str(idx)
    val field_name_indices = expr_get_args(idx)
    val field_value_indices = expr_get_stmts(idx)
    # Use brace initialization (field order must match struct declaration)
    var result: text = type_name + "{"
    for i in range(0, field_value_indices.len()):
        if i > 0:
            result = result + ", "
        result = result + cg_expr(field_value_indices[i])
    result = result + "}"
    result

# ===== Index Expression =====

fn cg_index_expr(idx: i64) -> text:
    val base_idx = expr_get_left(idx)
    val index_idx = expr_get_right(idx)
    val base_c = cg_expr(base_idx)
    val index_c = cg_expr(index_idx)

    # Check if base is a text variable -> spl_str_index_char
    if expr_get_tag(base_idx) == EXPR_IDENT:
        val name = expr_get_str(base_idx)
        val vtype = vt_find(name)
        if vtype == TYPE_TEXT:
            return "spl_str_index_char(" + base_c + ", " + index_c + ")"
        # Check if struct array
        val sa = sa_find(name)
        if sa != "":
            return base_c + "[" + index_c + "]"
        if is_array_type(vtype):
            val accessor = cg_spl_access(vtype)
            return "spl_array_get(" + base_c + ", " + index_c + ")" + accessor

    # Fallback: infer type for complex base expressions
    val base_type = cg_infer_expr_type(base_idx)
    if base_type == TYPE_TEXT:
        return "spl_str_index_char(" + base_c + ", " + index_c + ")"

    return base_c + "[" + index_c + "]"

# ===== Field Access Expression =====

fn cg_field_access_expr(idx: i64) -> text:
    val base_idx = expr_get_left(idx)
    val field_name = expr_get_str(idx)
    val base_c = cg_expr(base_idx)
    # self.field -> self->field (self is a pointer in impl methods)
    if base_c == "self":
        return "self->" + field_name
    return base_c + "." + field_name

# ===== Method Call Expression =====

fn cg_method_call_expr(idx: i64) -> text:
    val receiver_idx = expr_get_left(idx)
    val method_name = expr_get_str(idx)
    val call_args = expr_get_args(idx)
    val recv_c = cg_expr(receiver_idx)

    # Built-in string methods
    if method_name == "len":
        return cg_method_len(receiver_idx, recv_c)
    if method_name == "push":
        return cg_method_push(receiver_idx, recv_c, call_args)
    if method_name == "pop":
        return cg_method_pop(receiver_idx, recv_c)
    if method_name == "contains":
        if call_args.len() > 0:
            val arg_c = cg_expr(call_args[0])
            # Check receiver type - array uses spl_array_contains_str
            if expr_get_tag(receiver_idx) == EXPR_IDENT:
                val contains_name = expr_get_str(receiver_idx)
                val contains_type = vt_find(contains_name)
                if is_array_type(contains_type):
                    return "spl_array_contains_str(" + recv_c + ", " + arg_c + ")"
            val contains_inferred = cg_infer_expr_type(receiver_idx)
            if is_array_type(contains_inferred):
                return "spl_array_contains_str(" + recv_c + ", " + arg_c + ")"
            return "spl_str_contains(" + recv_c + ", " + arg_c + ")"
    if method_name == "starts_with":
        if call_args.len() > 0:
            val arg_c = cg_expr(call_args[0])
            return "spl_str_starts_with(" + recv_c + ", " + arg_c + ")"
    if method_name == "ends_with":
        if call_args.len() > 0:
            val arg_c = cg_expr(call_args[0])
            return "spl_str_ends_with(" + recv_c + ", " + arg_c + ")"
    if method_name == "index_of":
        if call_args.len() > 0:
            val arg_c = cg_expr(call_args[0])
            return "spl_str_index_of(" + recv_c + ", " + arg_c + ")"
    if method_name == "replace":
        if call_args.len() >= 2:
            val arg1 = cg_expr(call_args[0])
            val arg2 = cg_expr(call_args[1])
            return "spl_str_replace(" + recv_c + ", " + arg1 + ", " + arg2 + ")"
    if method_name == "trim":
        return "spl_str_trim(" + recv_c + ")"
    if method_name == "slice":
        if call_args.len() >= 2:
            val arg1 = cg_expr(call_args[0])
            val arg2 = cg_expr(call_args[1])
            return "spl_str_slice(" + recv_c + ", " + arg1 + ", " + arg2 + ")"

    if method_name == "is_empty":
        val ie_inferred = cg_infer_expr_type(receiver_idx)
        if ie_inferred == TYPE_TEXT:
            return "(spl_str_len(" + recv_c + ") == 0)"
        if is_array_type(ie_inferred):
            return "(spl_array_len(" + recv_c + ") == 0)"
        return "(spl_str_len(" + recv_c + ") == 0)"

    if method_name == "unwrap":
        return "spl_option_unwrap(" + recv_c + ")"

    if method_name == "last_index_of":
        if call_args.len() > 0:
            val arg_c = cg_expr(call_args[0])
            return "spl_str_last_index_of(" + recv_c + ", " + arg_c + ")"

    if method_name == "to_upper":
        return "spl_str_to_upper(" + recv_c + ")"
    if method_name == "to_lower":
        return "spl_str_to_lower(" + recv_c + ")"

    if method_name == "split":
        if call_args.len() > 0:
            val arg_c = cg_expr(call_args[0])
            return "spl_str_split(" + recv_c + ", " + arg_c + ")"

    if method_name == "join":
        if call_args.len() > 0:
            val arg_c = cg_expr(call_args[0])
            return "spl_str_join(" + recv_c + ", " + arg_c + ")"

    # Check if receiver is a known struct instance -> mangled method call
    if expr_get_tag(receiver_idx) == EXPR_IDENT:
        val recv_name = expr_get_str(receiver_idx)
        val sn = st_find(recv_name)
        if sn != "":
            var args_c: text = "&" + recv_c
            for i in range(0, call_args.len()):
                args_c = args_c + ", " + cg_expr(call_args[i])
            return sn + "__" + method_name + "(" + args_c + ")"
        # Check if receiver is a struct type name -> static method call
        val type_id = named_type_find(recv_name)
        if type_id >= 0:
            var args_c: text = ""
            for i in range(0, call_args.len()):
                if i > 0:
                    args_c = args_c + ", "
                args_c = args_c + cg_expr(call_args[i])
            return recv_name + "__" + method_name + "(" + args_c + ")"

    # Generic method call -> mangled name guess
    var args_c: text = ""
    for i in range(0, call_args.len()):
        if i > 0:
            args_c = args_c + ", "
        args_c = args_c + cg_expr(call_args[i])
    return recv_c + "." + method_name + "(" + args_c + ")"

fn cg_method_len(receiver_idx: i64, recv_c: text) -> text:
    if expr_get_tag(receiver_idx) == EXPR_IDENT:
        val name = expr_get_str(receiver_idx)
        val vtype = vt_find(name)
        if vtype == TYPE_TEXT:
            return "spl_str_len(" + recv_c + ")"
        val sa = sa_find(name)
        if sa != "":
            return "(int64_t)" + recv_c + ".size()"
        if is_array_type(vtype):
            return "spl_array_len(" + recv_c + ")"
    # Fallback: infer type for non-identifier receivers (e.g. self.field)
    val len_inferred = cg_infer_expr_type(receiver_idx)
    if len_inferred == TYPE_TEXT:
        return "spl_str_len(" + recv_c + ")"
    if is_array_type(len_inferred):
        return "spl_array_len(" + recv_c + ")"
    # Default: assume array
    return "spl_array_len(" + recv_c + ")"

fn cg_method_push(receiver_idx: i64, recv_c: text, call_args: [i64]) -> text:
    if call_args.len() == 0:
        return recv_c + ".push(/* missing arg */)"
    val arg_c = cg_expr(call_args[0])

    if expr_get_tag(receiver_idx) == EXPR_IDENT:
        val name = expr_get_str(receiver_idx)
        val sa = sa_find(name)
        if sa != "":
            return recv_c + ".push_back(" + arg_c + ")"
        # Type-aware SplArray push
        val arr_type = vt_find(name)
        if arr_type == TYPE_ARRAY_TEXT:
            return "spl_array_push(" + recv_c + ", spl_str(" + arg_c + "))"
        if arr_type == TYPE_ARRAY_ANY:
            return "spl_array_push(" + recv_c + ", spl_array_val(" + arg_c + "))"
        # Infer from argument type as fallback
        val arg_type = cg_infer_expr_type(call_args[0])
        val wrapped = cg_spl_wrap(arg_c, arg_type)
        return "spl_array_push(" + recv_c + ", " + wrapped + ")"
    # Unknown receiver: infer from argument type
    val arg_type2 = cg_infer_expr_type(call_args[0])
    val wrapped2 = cg_spl_wrap(arg_c, arg_type2)
    return "spl_array_push(" + recv_c + ", " + wrapped2 + ")"

fn cg_method_pop(receiver_idx: i64, recv_c: text) -> text:
    if expr_get_tag(receiver_idx) == EXPR_IDENT:
        val name = expr_get_str(receiver_idx)
        val arr_type = vt_find(name)
        val accessor = cg_spl_access(arr_type)
        return "spl_array_pop(" + recv_c + ")" + accessor
    return "spl_array_pop(" + recv_c + ").as_int"

# ===== Array Literal Expression =====

fn cg_array_lit_expr(idx: i64) -> text:
    val elements = expr_get_args(idx)
    if elements.len() == 0:
        return "spl_array_new()"
    # Use inline init helper — infer element type from first element
    var result: text = "({SplArray* __arr = spl_array_new();"
    for i in range(0, elements.len()):
        val elem_c = cg_expr(elements[i])
        val elem_type = cg_infer_expr_type(elements[i])
        val wrapped = cg_spl_wrap(elem_c, elem_type)
        result = result + " spl_array_push(__arr, " + wrapped + ");"
    result = result + " __arr;})"
    result

fn cg_dict_lit_expr(idx: i64) -> text:
    val keys = expr_get_args(idx)
    val values = expr_get_stmts(idx)
    if keys.len() == 0:
        return "spl_dict_new()"
    # Use inline init helper
    var result: text = "({SplDict* __dict = spl_dict_new();"
    for i in range(0, keys.len()):
        val key_c = cg_expr(keys[i])
        val val_c = cg_expr(values[i])
        val val_type = cg_infer_expr_type(values[i])
        val wrapped = cg_spl_wrap(val_c, val_type)
        result = result + " spl_dict_set(__dict, " + key_c + ", " + wrapped + ");"
    result = result + " __dict;})"
    result

# ===== If Expression =====

fn cg_if_expr(idx: i64) -> text:
    val cond = cg_expr(expr_get_left(idx))
    val then_idx = expr_get_right(idx)
    val else_idx = expr_get_extra(idx)
    val then_c = cg_expr(then_idx)
    if else_idx >= 0:
        val else_c = cg_expr(else_idx)
        return "(" + cond + " ? " + then_c + " : " + else_c + ")"
    return "(" + cond + " ? " + then_c + " : SplValue{})"

# ===== Module-level If as Statement =====

fn cg_emit_if_as_stmt(idx: i64):
    val cond_c = cg_expr(expr_get_left(idx))
    cg_emit_line("if (" + cond_c + ") {")
    cg_indent_inc()
    val then_block = expr_get_right(idx)
    val then_stmts = expr_get_stmts(then_block)
    for i in range(0, then_stmts.len()):
        cg_stmt(then_stmts[i])
    cg_indent_dec()
    val else_block = expr_get_extra(idx)
    val else_tag = expr_get_tag(else_block)
    if else_tag == EXPR_BLOCK:
        val else_stmts = expr_get_stmts(else_block)
        if else_stmts.len() > 0:
            cg_emit_line("} else {")
            cg_indent_inc()
            for i in range(0, else_stmts.len()):
                cg_stmt(else_stmts[i])
            cg_indent_dec()
    cg_emit_line("}")

# ===== Range Expression =====

fn cg_range_expr(idx: i64) -> text:
    # Range is typically used in for loops, not as standalone expression
    val start = cg_expr(expr_get_left(idx))
    val end_val = cg_expr(expr_get_right(idx))
    return "/* range(" + start + ", " + end_val + ") */"

# ===== Interpolated String Expression =====

fn cg_interpolated_string_expr(idx: i64) -> text:
    val parts = expr_get_args(idx)
    if parts.len() == 0:
        return "\"\""
    if parts.len() == 1:
        val part_tag = expr_get_tag(parts[0])
        if part_tag == EXPR_STRING_LIT:
            return cg_expr(parts[0])
        return "spl_i64_to_str(" + cg_expr(parts[0]) + ")"

    # Build spl_str_concat chain
    var result: text = cg_interpolated_part(parts[0])
    for i in range(1, parts.len()):
        val part_c = cg_interpolated_part(parts[i])
        result = "spl_str_concat(" + result + ", " + part_c + ")"
    result

fn cg_interpolated_part(idx: i64) -> text:
    val tag = expr_get_tag(idx)
    if tag == EXPR_STRING_LIT:
        return cg_expr(idx)
    # Non-string part: convert to string
    val part_c = cg_expr(idx)
    # Check if it's a known text variable
    if tag == EXPR_IDENT:
        val name = expr_get_str(idx)
        val vtype = vt_find(name)
        if vtype == TYPE_TEXT:
            return part_c
        if vtype == TYPE_BOOL:
            return "(" + part_c + " ? \"true\" : \"false\")"
        if vtype == TYPE_F64:
            return "spl_f64_to_str(" + part_c + ")"
    return "spl_i64_to_str(" + part_c + ")"

# ===== Slice Expression =====

fn cg_slice_expr(idx: i64) -> text:
    val base = cg_expr(expr_get_left(idx))
    val start = cg_expr(expr_get_right(idx))
    val end_val = cg_expr(expr_get_extra(idx))
    return "spl_str_slice(" + base + ", " + start + ", " + end_val + ")"

# Re-export statement codegen (extracted to cg_stmt.spl)
use compiler.core.compiler.cg_stmt.*

export cg_expr, cg_stmt
export cg_emit_if_as_stmt, cg_emit_for_as_stmt, cg_emit_while_as_stmt
export cg_block_expr, cg_for_expr, cg_while_expr, cg_match_expr
export cg_val_decl_stmt, cg_var_decl_stmt, cg_assign_stmt, cg_compound_assign_stmt
export cg_if_stmt, cg_for_stmt, cg_while_stmt, cg_match_stmt, cg_block_stmt
export cg_emit_array_init
