# Parser â€” Primary Expression & ASM Parsing
#
# Extracted from parser_expr.spl. Contains:
# - parse_primary: primary expression parsing (literals, identifiers, keywords, etc.)
# - ASM parsing: asm match, asm assert, target spec parsing

use compiler.core.tokens.{tok_kind_name}
use compiler.core.tokens.{TOK_INT_LIT, TOK_FLOAT_LIT, TOK_STRING_LIT}
use compiler.core.tokens.{TOK_BOOL_LIT, TOK_NIL_LIT, TOK_IDENT}
use compiler.core.tokens.{TOK_KW_IF, TOK_KW_MATCH, TOK_KW_CASE}
use compiler.core.tokens.{TOK_KW_RETURN, TOK_KW_BREAK, TOK_KW_CONTINUE}
use compiler.core.tokens.{TOK_KW_NOT}
use compiler.core.tokens.{TOK_KW_PASS, TOK_KW_PASS_TODO, TOK_KW_PASS_DO_NOTHING, TOK_KW_PASS_DN}
use compiler.core.tokens.{TOK_KW_SELF}
use compiler.core.tokens.{TOK_KW_ASYNC, TOK_KW_AWAIT, TOK_KW_YIELD, TOK_KW_SPAWN}
use compiler.core.tokens.{TOK_KW_ASM}
use compiler.core.tokens.{TOK_MINUS, TOK_NOT}
use compiler.core.tokens.{TOK_EQ, TOK_LT, TOK_GEQ}
use compiler.core.tokens.{TOK_LPAREN, TOK_RPAREN, TOK_LBRACKET, TOK_RBRACKET}
use compiler.core.tokens.{TOK_LBRACE, TOK_RBRACE}
use compiler.core.tokens.{TOK_COLON, TOK_COMMA, TOK_PIPE}
use compiler.core.tokens.{TOK_NEWLINE, TOK_INDENT, TOK_DEDENT, TOK_EOF, TOK_ERROR}
use compiler.core.tokens.{TOK_UNDERSCORE, TOK_SEMICOLON}
use compiler.core.tokens.{TOK_SUFFIXED_INT, TOK_SUFFIXED_FLOAT}
use compiler.core.tokens.{TOK_KW_DO, TOK_KW_CE}
use compiler.core.tokens.{TOK_BACKTICK_IDENT}
use compiler.core.tokens.{TOK_AT, TOK_KW_KEYOF, TOK_KW_MIXIN, TOK_STAR}
use compiler.core.ast.{expr_int_lit, expr_float_lit, expr_string_lit}
use compiler.core.ast.{expr_bool_lit, expr_nil_lit, expr_ident}
use compiler.core.ast.{expr_unary, expr_call, expr_array_lit}
use compiler.core.ast.{expr_return_expr, expr_break_expr, expr_continue_expr}
use compiler.core.ast.{expr_unit, expr_pass, expr_pass_with_msg, expr_pass_todo, expr_pass_do_nothing, expr_pass_dn}
use compiler.core.ast.{expr_dict_lit}
use compiler.core.ast.{expr_suffixed_int, expr_suffixed_float, expr_suffixed_bool}
use compiler.core.ast.{expr_await, expr_yield, expr_spawn, expr_do_block, expr_atom}
use compiler.core.ast.{expr_asm, expr_asm_match, expr_asm_assert}
use compiler.core.ast.{asm_arm_new, asm_arm_is_compile_error, asm_arm_error_msg, asm_arm_asm_text}
use compiler.core.lexer.{lex_cur_suffix}
use compiler.core.parser.{par_kind, par_text, par_line, par_col, par_errors, par_had_error}
use compiler.core.parser.{parser_advance, parser_expect, parser_error, parser_skip_newlines}
use compiler.core.parser.{parser_parse_type}

# Forward declarations for mutual recursion
use compiler.core.parser_stmts.{parse_block, parse_match_stmt, parse_if_expr}
use compiler.core.parser_expr.{parse_expr, parse_not, parse_unary}

fn parse_primary() -> i64:
    # @annotation(...) -- compile-time introspection built-ins
    # @traits(query, T, ...) desugars to __traits("query", "T", ...)
    # @file, @line, @function desugar to __builtin_file etc.
    if par_kind == TOK_AT:
        parser_advance()
        val ann_name = par_text
        if par_kind == TOK_IDENT:
            parser_advance()
        if par_kind == TOK_LPAREN:
            parser_advance()
            var at_args: [i64] = []
            # First argument: the annotation name as a string literal
            at_args.push(expr_string_lit(ann_name, 0))
            for at_i in 0..20:
                if par_kind == TOK_RPAREN:
                    break
                if par_kind == TOK_COMMA:
                    parser_advance()
                    continue
                if par_kind == TOK_EOF:
                    break
                # Identifier args (type names) become string literals
                if par_kind == TOK_IDENT:
                    val id_arg = par_text
                    parser_advance()
                    at_args.push(expr_string_lit(id_arg, 0))
                else:
                    val expr_arg = parse_expr()
                    at_args.push(expr_arg)
            parser_expect(TOK_RPAREN)
            val at_callee = expr_ident("__traits", 0)
            return expr_call(at_callee, at_args, 0)
        # Simple @identifier (no parens): @file, @line, @function
        val at_builtin_name = "__builtin_" + ann_name
        return expr_ident(at_builtin_name, 0)

    # keyof T -- compile-time field name list (sugar for @traits("fields", "T"))
    if par_kind == TOK_KW_KEYOF:
        parser_advance()
        val keyof_type = par_text
        if par_kind == TOK_IDENT:
            parser_advance()
        var keyof_args: [i64] = []
        keyof_args.push(expr_string_lit("fields", 0))
        keyof_args.push(expr_string_lit(keyof_type, 0))
        val keyof_callee = expr_ident("__traits", 0)
        return expr_call(keyof_callee, keyof_args, 0)

    # mixin(code_text) -- compile-time code generation
    # Desugars to __mixin(code_text) builtin call
    if par_kind == TOK_KW_MIXIN:
        parser_advance()
        parser_expect(TOK_LPAREN)
        val mixin_arg = parse_expr()
        parser_expect(TOK_RPAREN)
        var mixin_args_list: [i64] = []
        mixin_args_list.push(mixin_arg)
        val mixin_callee = expr_ident("__mixin", 0)
        return expr_call(mixin_callee, mixin_args_list, 0)

    # asm "..." | asm: "..." | asm { "..." } | asm match: | asm assert [...]
    if par_kind == TOK_KW_ASM:
        parser_advance()

        # asm match: -- multi-target dispatch
        if par_kind == TOK_KW_MATCH:
            parser_advance()
            parser_expect(TOK_COLON)
            return parse_asm_match()

        # asm assert [...] -- compile-time target guard (parsed as expression, handled as stmt)
        if par_kind == TOK_IDENT and par_text == "assert":
            parser_advance()
            return parse_asm_assert_expr()

        if par_kind == TOK_STRING_LIT:
            val inline_asm = par_text
            parser_advance()
            return expr_asm(inline_asm, 0)

        if par_kind == TOK_COLON:
            parser_advance()
            parser_skip_newlines()
            if par_kind != TOK_INDENT:
                parser_error("expected indented asm block after 'asm:'")
                return expr_asm("", 0)
            parser_advance()
            var asm_lines: [text] = []
            for ai in 0..100000:
                parser_skip_newlines()
                if par_kind == TOK_DEDENT:
                    parser_advance()
                    break
                if par_kind == TOK_EOF:
                    break
                if par_kind == TOK_STRING_LIT:
                    asm_lines.push(par_text)
                    parser_advance()
                    continue
                parser_error("expected string literal in asm block")
                for aj in 0..10000:
                    val is_nl = par_kind == TOK_NEWLINE
                    val is_ded = par_kind == TOK_DEDENT
                    val is_eof = par_kind == TOK_EOF
                    if is_nl or is_ded or is_eof:
                        break
                    parser_advance()
            return expr_asm(asm_lines.join("\n"), 0)

        if par_kind == TOK_LBRACE:
            parser_advance()
            var asm_parts: [text] = []
            for ai in 0..100000:
                if par_kind == TOK_RBRACE:
                    parser_advance()
                    break
                if par_kind == TOK_EOF:
                    parser_error("unterminated asm { ... } block")
                    break
                if par_kind == TOK_NEWLINE or par_kind == TOK_COMMA or par_kind == TOK_SEMICOLON:
                    parser_advance()
                    continue
                if par_kind == TOK_STRING_LIT:
                    asm_parts.push(par_text)
                    parser_advance()
                    continue
                parser_error("expected string literal in asm { ... } block")
                parser_advance()
            return expr_asm(asm_parts.join("\n"), 0)

        parser_error("expected string literal, ':' block, or '{...}' after 'asm'")
        return expr_asm("", 0)

    if par_kind == TOK_INT_LIT:
        val int_text = par_text
        parser_advance()
        # Parse integer from text (supporting _ separators and 0x/0b/0o prefixes)
        var int_val = 0
        if int_text.len() > 2:
            val prefix = int_text[0:2]
            if prefix == "0x":
                # Hex literal: parse digit by digit
                val hex_digits = int_text[2:]
                var hex_val = 0
                var hi = 0
                while hi < hex_digits.len():
                    val hc = hex_digits[hi:hi+1]
                    if hc != "_":
                        var hd = 0
                        if hc >= "0" and hc <= "9":
                            hd = int(hc)
                        elif hc >= "a" and hc <= "f":
                            hd = int(hc) - int("a") + 10
                        elif hc >= "A" and hc <= "F":
                            hd = int(hc) - int("A") + 10
                        hex_val = hex_val * 16 + hd
                    hi = hi + 1
                return expr_int_lit(hex_val, 0)
            if prefix == "0b":
                # Binary literal: parse digit by digit
                val bin_digits = int_text[2:]
                var bin_val = 0
                var bi = 0
                while bi < bin_digits.len():
                    val bc = bin_digits[bi:bi+1]
                    if bc == "1":
                        bin_val = bin_val * 2 + 1
                    elif bc == "0":
                        bin_val = bin_val * 2
                    bi = bi + 1
                return expr_int_lit(bin_val, 0)
            if prefix == "0o":
                # Octal literal: parse digit by digit
                val oct_digits = int_text[2:]
                var oct_val = 0
                var oi = 0
                while oi < oct_digits.len():
                    val oc = oct_digits[oi:oi+1]
                    if oc != "_":
                        oct_val = oct_val * 8 + int(oc)
                    oi = oi + 1
                return expr_int_lit(oct_val, 0)
        # Decimal -- strip _ separators then parse
        var stripped: text = ""
        var si = 0
        while si < int_text.len():
            val sc = int_text[si:si+1]
            if sc != "_":
                stripped = stripped + sc
            si = si + 1
        if stripped.len() > 0:
            int_val = int(stripped)
        return expr_int_lit(int_val, 0)

    if par_kind == TOK_FLOAT_LIT:
        val float_text = par_text
        parser_advance()
        return expr_float_lit(float_text, 0)

    if par_kind == TOK_SUFFIXED_INT:
        val suf_text = par_text
        val suf_name = lex_cur_suffix
        parser_advance()
        val int_val = int(suf_text)
        return expr_suffixed_int(int_val, suf_name, 0)

    if par_kind == TOK_SUFFIXED_FLOAT:
        val suf_text = par_text
        val suf_name = lex_cur_suffix
        parser_advance()
        return expr_suffixed_float(suf_text, suf_name, 0)

    if par_kind == TOK_STRING_LIT:
        val str_text = par_text
        parser_advance()
        return expr_string_lit(str_text, 0)

    if par_kind == TOK_BOOL_LIT:
        val bool_text = par_text
        parser_advance()
        if bool_text == "true":
            return expr_bool_lit(1, 0)
        return expr_bool_lit(0, 0)

    if par_kind == TOK_NIL_LIT:
        parser_advance()
        return expr_nil_lit(0)

    if par_kind == TOK_IDENT:
        val id_name = par_text
        parser_advance()
        return expr_ident(id_name, 0)

    if par_kind == TOK_KW_SELF:
        parser_advance()
        return expr_ident("self", 0)

    if par_kind == TOK_KW_AWAIT:
        parser_advance()
        val future_expr = parse_expr()
        return expr_await(future_expr, 0)

    if par_kind == TOK_KW_YIELD:
        parser_advance()
        val value_expr = parse_expr()
        return expr_yield(value_expr, 0)

    if par_kind == TOK_KW_SPAWN:
        parser_advance()
        val call_expr = parse_expr()
        return expr_spawn(call_expr, 0)

    if par_kind == TOK_KW_DO:
        parser_advance()
        parser_expect(TOK_COLON)
        val do_body = parse_block()
        return expr_do_block(do_body, 0)

    if par_kind == TOK_KW_CE:
        # ce NAME: block as expression -- returns last value like do:
        parser_advance()
        var ce_builder_name = par_text
        parser_expect(TOK_IDENT)
        parser_expect(TOK_COLON)
        val ce_body = parse_block()
        return expr_do_block(ce_body, 0)

    if par_kind == TOK_BACKTICK_IDENT:
        val atom_name = par_text
        parser_advance()
        return expr_atom(atom_name, 0)

    if par_kind == TOK_LPAREN:
        parser_advance()
        if par_kind == TOK_RPAREN:
            parser_advance()
            return expr_unit(0)
        val inner = parse_expr()
        parser_expect(TOK_RPAREN)
        return inner

    if par_kind == TOK_LBRACKET:
        # Array literal: [1, 2, 3]
        parser_advance()
        var elements: [i64] = []
        if par_kind != TOK_RBRACKET:
            elements.push(parse_expr())
            for i in 0..10000:
                if par_kind != TOK_COMMA:
                    break
                parser_advance()
                if par_kind == TOK_RBRACKET:
                    break
                elements.push(parse_expr())
        parser_expect(TOK_RBRACKET)
        return expr_array_lit(elements, 0)

    if par_kind == TOK_KW_RETURN:
        parser_advance()
        val is_nl = par_kind == TOK_NEWLINE
        val is_ded = par_kind == TOK_DEDENT
        val is_eof = par_kind == TOK_EOF
        val no_value = is_nl or is_ded
        val no_val2 = no_value or is_eof
        if no_val2:
            return expr_return_expr(-1, 0)
        val ret_val = parse_expr()
        return expr_return_expr(ret_val, 0)

    if par_kind == TOK_KW_BREAK:
        parser_advance()
        return expr_break_expr(0)

    if par_kind == TOK_KW_CONTINUE:
        parser_advance()
        return expr_continue_expr(0)

    if par_kind == TOK_KW_PASS:
        parser_advance()
        var msg = ""
        if par_kind == TOK_LPAREN:
            parser_advance()
            if par_kind == TOK_STRING_LIT:
                msg = par_text
                parser_advance()
            parser_expect(TOK_RPAREN)
        if msg == "":
            return expr_pass(0)
        return expr_pass_with_msg(msg, 0)

    if par_kind == TOK_KW_PASS_TODO:
        parser_advance()
        var msg = ""
        if par_kind == TOK_LPAREN:
            parser_advance()
            if par_kind == TOK_STRING_LIT:
                msg = par_text
                parser_advance()
            parser_expect(TOK_RPAREN)
        return expr_pass_todo(msg, 0)

    if par_kind == TOK_KW_PASS_DO_NOTHING:
        parser_advance()
        var msg = ""
        if par_kind == TOK_LPAREN:
            parser_advance()
            if par_kind == TOK_STRING_LIT:
                msg = par_text
                parser_advance()
            parser_expect(TOK_RPAREN)
        return expr_pass_do_nothing(msg, 0)

    if par_kind == TOK_KW_PASS_DN:
        parser_advance()
        var msg = ""
        if par_kind == TOK_LPAREN:
            parser_advance()
            if par_kind == TOK_STRING_LIT:
                msg = par_text
                parser_advance()
            parser_expect(TOK_RPAREN)
        return expr_pass_dn(msg, 0)

    if par_kind == TOK_KW_NOT:
        parser_advance()
        val operand = parse_not()
        return expr_unary(TOK_NOT, operand, 0)

    if par_kind == TOK_MINUS:
        parser_advance()
        val operand = parse_unary()
        return expr_unary(TOK_MINUS, operand, 0)

    if par_kind == TOK_UNDERSCORE:
        parser_advance()
        return expr_ident("_", 0)

    # Dict literal: {key: value, ...} or empty {}
    if par_kind == TOK_LBRACE:
        parser_advance()
        var key_exprs: [i64] = []
        var value_exprs: [i64] = []

        # Check for empty dict {}
        if par_kind == TOK_RBRACE:
            parser_advance()
            return expr_dict_lit(key_exprs, value_exprs, 0)

        # Parse key-value pairs
        for i in 0..10000:
            # Parse key
            val key = parse_expr()
            key_exprs.push(key)

            # Expect colon
            parser_expect(TOK_COLON)

            # Parse value
            val value = parse_expr()
            value_exprs.push(value)

            # Check for comma or closing brace
            if par_kind == TOK_COMMA:
                parser_advance()
                # Allow trailing comma before }
                if par_kind == TOK_RBRACE:
                    parser_advance()
                    break
            elif par_kind == TOK_RBRACE:
                parser_advance()
                break
            else:
                parser_error("expected , or } in dict literal")
                break

        return expr_dict_lit(key_exprs, value_exprs, 0)

    # Lambda: \x: expr or \x, y: expr
    if par_kind == TOK_ERROR:
        if par_text == "unexpected character: \\":
            parser_advance()
            # Skip lambda params
            for i in 0..100:
                if par_kind == TOK_COLON:
                    parser_advance()
                    break
                if par_kind == TOK_EOF:
                    break
                if par_kind == TOK_NEWLINE:
                    break
                parser_advance()
            val lbody = parse_expr()
            return lbody

    # Handle keywords that may appear in expression position
    if par_kind == TOK_KW_MATCH:
        return parse_match_stmt()
    if par_kind == TOK_KW_IF:
        return parse_if_expr()

    parser_error("unexpected token in expression: " + tok_kind_name(par_kind) + " '" + par_text + "'")
    parser_advance()
    expr_nil_lit(0)

# ===== Asm Match/Assert Parsing =====

fn parse_asm_target_spec() -> i64:
    """Parse target spec: [arch | arch2, os, abi, backend >= ver]
    Returns index into asm_arm_* arena (as spec, not full arm).
    """
    parser_expect(TOK_LBRACKET)
    # Parse arch(es) with pipe grouping
    var archs: [text] = []
    if par_kind == TOK_IDENT:
        archs.push(par_text)
        parser_advance()
        # Check for pipe groups: arch | arch2
        for pi in 0..20:
            if par_kind == TOK_PIPE:
                parser_advance()
                if par_kind == TOK_IDENT:
                    archs.push(par_text)
                    parser_advance()
                else:
                    parser_error("expected architecture name after '|'")
            else:
                break
    else:
        parser_error("expected architecture name in target spec")

    # Parse optional os, abi, backend (comma-separated)
    var os_val = ""
    var abi_val = ""
    var backend_val = ""
    var ver_ops: [text] = []
    var ver_vals: [i64] = []
    var field_pos = 1  # 1=os, 2=abi, 3=backend

    for fi in 0..3:
        if par_kind != TOK_COMMA:
            break
        parser_advance()
        if par_kind == TOK_UNDERSCORE:
            # Wildcard _
            parser_advance()
            field_pos = field_pos + 1
            continue
        if par_kind == TOK_IDENT:
            val field_text = par_text
            parser_advance()
            if field_pos == 1:
                os_val = field_text
            elif field_pos == 2:
                abi_val = field_text
            elif field_pos == 3:
                backend_val = field_text
                # Check for version constraints after backend
                for vi in 0..4:
                    if par_kind == TOK_GEQ:
                        parser_advance()
                        if par_kind == TOK_INT_LIT:
                            ver_ops.push(">=")
                            ver_vals.push(parse_int_text(par_text))
                            parser_advance()
                        else:
                            parser_error("expected version number after '>='")
                    elif par_kind == TOK_EQ:
                        # Could be == (two tokens) or a single ==
                        parser_advance()
                        if par_kind == TOK_EQ:
                            parser_advance()
                        if par_kind == TOK_INT_LIT:
                            ver_ops.push("==")
                            ver_vals.push(parse_int_text(par_text))
                            parser_advance()
                        else:
                            parser_error("expected version number after '=='")
                    elif par_kind == TOK_LT:
                        parser_advance()
                        if par_kind == TOK_INT_LIT:
                            ver_ops.push("<")
                            ver_vals.push(parse_int_text(par_text))
                            parser_advance()
                        else:
                            parser_error("expected version number after '<'")
                    elif par_kind == TOK_IDENT and par_text == "~=":
                        parser_advance()
                        if par_kind == TOK_INT_LIT:
                            ver_ops.push("~=")
                            ver_vals.push(parse_int_text(par_text))
                            parser_advance()
                        else:
                            parser_error("expected version number after '~='")
                    else:
                        break
            field_pos = field_pos + 1
        else:
            parser_error("expected identifier or '_' in target spec")
            break

    parser_expect(TOK_RBRACKET)

    val arm_idx = asm_arm_new(archs, os_val, abi_val, backend_val,
                              ver_ops, ver_vals, "", false, "", false)
    arm_idx

fn parse_int_text(txt: text) -> i64:
    """Parse integer from text (simple decimal)."""
    var result = 0
    for i in 0..txt.len():
        val ch = txt[i]
        if ch >= "0" and ch <= "9":
            result = result * 10 + (ch.ord() - 48)
    result

fn parse_asm_match() -> i64:
    """Parse asm match: block with case arms.

    Syntax:
        asm match:
            case [spec]: asm_body
            case _: compile_error("msg")
    """
    parser_skip_newlines()
    if par_kind != TOK_INDENT:
        parser_error("expected indented block after 'asm match:'")
        return expr_asm("", 0)
    parser_advance()

    var arm_indices: [i64] = []
    for mi in 0..100:
        parser_skip_newlines()
        if par_kind == TOK_DEDENT:
            parser_advance()
            break
        if par_kind == TOK_EOF:
            break

        # Each arm starts with 'case'
        if par_kind != TOK_KW_CASE:
            parser_error("expected 'case' in asm match arm")
            parser_advance()
            continue

        parser_advance()  # consume 'case'

        # Check for wildcard: case _:
        if par_kind == TOK_UNDERSCORE:
            parser_advance()
            parser_expect(TOK_COLON)

            # Parse body: either compile_error("msg") or asm lines
            parser_skip_newlines()
            if par_kind == TOK_INDENT:
                parser_advance()
                parser_skip_newlines()

            if par_kind == TOK_IDENT and par_text == "compile_error":
                parser_advance()
                parser_expect(TOK_LPAREN)
                var err_msg = ""
                if par_kind == TOK_STRING_LIT:
                    err_msg = par_text
                    parser_advance()
                parser_expect(TOK_RPAREN)
                val arm_idx = asm_arm_new([], "", "", "", [], [], "", true, err_msg, true)
                arm_indices.push(arm_idx)
                # Skip to end of arm
                parser_skip_newlines()
                if par_kind == TOK_DEDENT:
                    parser_advance()
            else:
                # Wildcard with asm body
                var asm_lines: [text] = []
                for ai in 0..10000:
                    parser_skip_newlines()
                    if par_kind == TOK_DEDENT or par_kind == TOK_EOF:
                        break
                    if par_kind == TOK_KW_CASE:
                        break
                    if par_kind == TOK_STRING_LIT:
                        asm_lines.push(par_text)
                        parser_advance()
                    else:
                        parser_advance()
                val asm_text = asm_lines.join("\n")
                val arm_idx = asm_arm_new([], "", "", "", [], [], asm_text, false, "", true)
                arm_indices.push(arm_idx)
                if par_kind == TOK_DEDENT:
                    parser_advance()
            continue

        # case [spec]:
        val spec_idx = parse_asm_target_spec()
        parser_expect(TOK_COLON)

        # Parse body: either compile_error("msg") or asm lines
        parser_skip_newlines()
        if par_kind == TOK_INDENT:
            parser_advance()
            parser_skip_newlines()

        if par_kind == TOK_IDENT and par_text == "compile_error":
            parser_advance()
            parser_expect(TOK_LPAREN)
            var err_msg = ""
            if par_kind == TOK_STRING_LIT:
                err_msg = par_text
                parser_advance()
            parser_expect(TOK_RPAREN)
            # Update the arm to be compile_error
            asm_arm_is_compile_error[spec_idx] = true
            asm_arm_error_msg[spec_idx] = err_msg
            arm_indices.push(spec_idx)
            parser_skip_newlines()
            if par_kind == TOK_DEDENT:
                parser_advance()
        else:
            # Collect asm body lines
            var asm_lines: [text] = []
            for ai in 0..10000:
                parser_skip_newlines()
                if par_kind == TOK_DEDENT or par_kind == TOK_EOF:
                    break
                if par_kind == TOK_KW_CASE:
                    break
                if par_kind == TOK_STRING_LIT:
                    asm_lines.push(par_text)
                    parser_advance()
                else:
                    parser_advance()
            val asm_text = asm_lines.join("\n")
            asm_arm_asm_text[spec_idx] = asm_text
            arm_indices.push(spec_idx)
            if par_kind == TOK_DEDENT:
                parser_advance()

    return expr_asm_match(arm_indices, 0)

fn parse_asm_assert_expr() -> i64:
    """Parse asm assert [spec] -- compile-time target guard.

    Returns an expression (value is 0/unit in interpreter).
    Uses EXPR_ASM_MATCH with i_val=1 to distinguish from asm match.
    """
    val spec_idx = parse_asm_target_spec()
    return expr_asm_assert(spec_idx, 0)
