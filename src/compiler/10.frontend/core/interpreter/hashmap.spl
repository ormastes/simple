# Core Interpreter — Hash Map Utilities
#
# Seed-compilable hash function and bucket initialization.
# Used by eval.spl, env.spl, and jit.spl for O(1) average lookups.
#
# Hash maps use chained hashing with parallel arrays:
#   keys: [text]     — entry keys
#   vals: [i64]      — entry values (or parallel text array for text values)
#   buckets: [i64]   — bucket heads (size HM_SIZE, -1 = empty)
#   nexts: [i64]     — next pointers for chaining (parallel with keys)
#
# Lookup: hash(key) -> bucket -> walk chain -> O(1) average
# Insert: hash(key) -> bucket -> check chain -> append or update

# ===== Constants =====
val HM_SIZE: i64 = 64         # Bucket count for global maps
val SCOPE_HM_SIZE: i64 = 16   # Bucket count for scope-level maps (smaller, faster init)

# ===== Hash Function =====
# Polynomial hash using first, middle, and last characters + length.
# Much better distribution than old character-group approach.
# Caller applies % bucket_count.

fn hm_hash_text(s: text) -> i64:
    val slen = s.len()
    if slen == 0: return 0
    val first = s[0].ord()
    if slen == 1: return first
    val last = s[slen - 1].ord()
    val mid = s[slen / 2].ord()
    # Polynomial mixing: first*31^2 + mid*31 + last + len*7
    val h = first * 961 + mid * 31 + last + slen * 7
    # Ensure non-negative
    if h < 0: return 0 - h
    h

# ===== Bucket Initialization =====

fn hm_make_buckets(size: i64) -> [i64]:
    var buckets: [i64] = []
    var i: i64 = 0
    while i < size:
        buckets.push(-1)
        i = i + 1
    buckets

fn hm_make_global_buckets() -> [i64]:
    hm_make_buckets(HM_SIZE)

fn hm_make_scope_buckets() -> [i64]:
    hm_make_buckets(SCOPE_HM_SIZE)

export HM_SIZE, SCOPE_HM_SIZE
export hm_hash_text, hm_make_buckets, hm_make_global_buckets, hm_make_scope_buckets
