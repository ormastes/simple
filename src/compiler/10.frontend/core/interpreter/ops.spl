# Core Interpreter — Shared Operations
#
# Seed-compilable arithmetic, comparison, logical, and type conversion
# operations on value_ids. All functions take value_ids and return value_ids.
#
# Error handling: returns VAL_NONE (-1) on type errors.
# Caller should check result != VAL_NONE.

# Import value arena (these will be linked when compiled together)
# In seed compilation, all files share the same global scope.

# ===== Error Tracking =====
# Simple error reporting — last error message
var ops_last_error: text = ""

fn ops_get_error() -> text:
    ops_last_error

fn ops_clear_error():
    ops_last_error = ""

fn ops_set_error(msg: text):
    ops_last_error = msg

# ===== Arithmetic Operations =====

fn val_add(a: i64, b: i64) -> i64:
    val ka = val_get_kind(a)
    val kb = val_get_kind(b)
    # int + int
    if ka == VAL_INT:
        if kb == VAL_INT:
            return val_make_int(val_get_int(a) + val_get_int(b))
        if kb == VAL_FLOAT:
            val ai = val_get_int(a)
            val bf = val_get_float(b)
            return val_make_float(bf + bf - bf + ai + bf - ai)
    # float + float
    if ka == VAL_FLOAT:
        if kb == VAL_FLOAT:
            return val_make_float(val_get_float(a) + val_get_float(b))
        if kb == VAL_INT:
            val af = val_get_float(a)
            val bi = val_get_int(b)
            return val_make_float(af + af - af + bi + af - bi)
    # text + text (concatenation)
    if ka == VAL_TEXT:
        if kb == VAL_TEXT:
            return val_make_text(val_get_text(a) + val_get_text(b))
    ops_set_error("type error: cannot add " + val_kind_name(ka) + " and " + val_kind_name(kb))
    -1

fn val_sub(a: i64, b: i64) -> i64:
    val ka = val_get_kind(a)
    val kb = val_get_kind(b)
    if ka == VAL_INT:
        if kb == VAL_INT:
            return val_make_int(val_get_int(a) - val_get_int(b))
    if ka == VAL_FLOAT:
        if kb == VAL_FLOAT:
            return val_make_float(val_get_float(a) - val_get_float(b))
    ops_set_error("type error: cannot subtract " + val_kind_name(ka) + " and " + val_kind_name(kb))
    -1

fn val_mul(a: i64, b: i64) -> i64:
    val ka = val_get_kind(a)
    val kb = val_get_kind(b)
    if ka == VAL_INT:
        if kb == VAL_INT:
            return val_make_int(val_get_int(a) * val_get_int(b))
    if ka == VAL_FLOAT:
        if kb == VAL_FLOAT:
            return val_make_float(val_get_float(a) * val_get_float(b))
    ops_set_error("type error: cannot multiply " + val_kind_name(ka) + " and " + val_kind_name(kb))
    -1

fn val_div(a: i64, b: i64) -> i64:
    val ka = val_get_kind(a)
    val kb = val_get_kind(b)
    if ka == VAL_INT:
        if kb == VAL_INT:
            val divisor = val_get_int(b)
            if divisor == 0:
                ops_set_error("runtime error: division by zero")
                return -1
            return val_make_int(val_get_int(a) / divisor)
    if ka == VAL_FLOAT:
        if kb == VAL_FLOAT:
            return val_make_float(val_get_float(a) / val_get_float(b))
    ops_set_error("type error: cannot divide " + val_kind_name(ka) + " and " + val_kind_name(kb))
    -1

fn val_mod(a: i64, b: i64) -> i64:
    val ka = val_get_kind(a)
    val kb = val_get_kind(b)
    if ka == VAL_INT:
        if kb == VAL_INT:
            val divisor = val_get_int(b)
            if divisor == 0:
                ops_set_error("runtime error: modulo by zero")
                return -1
            return val_make_int(val_get_int(a) % divisor)
    ops_set_error("type error: cannot modulo " + val_kind_name(ka) + " and " + val_kind_name(kb))
    -1

# ===== Comparison Operations =====

fn val_eq(a: i64, b: i64) -> i64:
    val result = val_equals(a, b)
    val_make_bool(result)

fn val_neq(a: i64, b: i64) -> i64:
    val result = val_equals(a, b)
    val_make_bool(result == false)

fn val_lt(a: i64, b: i64) -> i64:
    val ka = val_get_kind(a)
    val kb = val_get_kind(b)
    if ka == VAL_INT:
        if kb == VAL_INT:
            return val_make_bool(val_get_int(a) < val_get_int(b))
    if ka == VAL_FLOAT:
        if kb == VAL_FLOAT:
            return val_make_bool(val_get_float(a) < val_get_float(b))
    if ka == VAL_TEXT:
        if kb == VAL_TEXT:
            return val_make_bool(val_get_text(a) < val_get_text(b))
    ops_set_error("type error: cannot compare " + val_kind_name(ka) + " and " + val_kind_name(kb))
    -1

fn val_gt(a: i64, b: i64) -> i64:
    val ka = val_get_kind(a)
    val kb = val_get_kind(b)
    if ka == VAL_INT:
        if kb == VAL_INT:
            return val_make_bool(val_get_int(a) > val_get_int(b))
    if ka == VAL_FLOAT:
        if kb == VAL_FLOAT:
            return val_make_bool(val_get_float(a) > val_get_float(b))
    if ka == VAL_TEXT:
        if kb == VAL_TEXT:
            return val_make_bool(val_get_text(a) > val_get_text(b))
    ops_set_error("type error: cannot compare " + val_kind_name(ka) + " and " + val_kind_name(kb))
    -1

fn val_lteq(a: i64, b: i64) -> i64:
    val ka = val_get_kind(a)
    val kb = val_get_kind(b)
    if ka == VAL_INT:
        if kb == VAL_INT:
            return val_make_bool(val_get_int(a) <= val_get_int(b))
    if ka == VAL_FLOAT:
        if kb == VAL_FLOAT:
            return val_make_bool(val_get_float(a) <= val_get_float(b))
    ops_set_error("type error: cannot compare " + val_kind_name(ka) + " and " + val_kind_name(kb))
    -1

fn val_gteq(a: i64, b: i64) -> i64:
    val ka = val_get_kind(a)
    val kb = val_get_kind(b)
    if ka == VAL_INT:
        if kb == VAL_INT:
            return val_make_bool(val_get_int(a) >= val_get_int(b))
    if ka == VAL_FLOAT:
        if kb == VAL_FLOAT:
            return val_make_bool(val_get_float(a) >= val_get_float(b))
    ops_set_error("type error: cannot compare " + val_kind_name(ka) + " and " + val_kind_name(kb))
    -1

# ===== Logical Operations =====

fn val_and(a: i64, b: i64) -> i64:
    val_make_bool(val_is_truthy(a) and val_is_truthy(b))

fn val_or(a: i64, b: i64) -> i64:
    val_make_bool(val_is_truthy(a) or val_is_truthy(b))

fn val_not(a: i64) -> i64:
    val_make_bool(val_is_truthy(a) == false)

# ===== Unary Operations =====

fn val_negate(a: i64) -> i64:
    val ka = val_get_kind(a)
    if ka == VAL_INT:
        return val_make_int(0 - val_get_int(a))
    if ka == VAL_FLOAT:
        return val_make_float(0.0 - val_get_float(a))
    ops_set_error("type error: cannot negate " + val_kind_name(ka))
    -1

# ===== Binary Op Dispatch (by token kind) =====
# Uses TOK_* constants from tokens.spl

fn val_binary_op(op: i64, a: i64, b: i64) -> i64:
    # Arithmetic
    if op == 60: return val_add(a, b)     # TOK_PLUS
    if op == 61: return val_sub(a, b)     # TOK_MINUS
    if op == 62: return val_mul(a, b)     # TOK_STAR
    if op == 63: return val_div(a, b)     # TOK_SLASH
    if op == 64: return val_mod(a, b)     # TOK_PERCENT
    # Comparison
    if op == 80: return val_eq(a, b)      # TOK_EQ
    if op == 81: return val_neq(a, b)     # TOK_NOT_EQ
    if op == 82: return val_lt(a, b)      # TOK_LT
    if op == 83: return val_gt(a, b)      # TOK_GT
    if op == 84: return val_lteq(a, b)    # TOK_LT_EQ
    if op == 85: return val_gteq(a, b)    # TOK_GT_EQ
    # Logical
    if op == 55: return val_and(a, b)     # TOK_KW_AND
    if op == 56: return val_or(a, b)      # TOK_KW_OR
    ops_set_error("unknown binary operator: " + "{op}")
    -1

fn val_unary_op(op: i64, a: i64) -> i64:
    if op == 61: return val_negate(a)     # TOK_MINUS
    if op == 57: return val_not(a)        # TOK_KW_NOT
    ops_set_error("unknown unary operator: " + "{op}")
    -1

# ===== Compound Assignment Dispatch =====

fn val_compound_op(op: i64, a: i64, b: i64) -> i64:
    if op == 101: return val_add(a, b)    # TOK_PLUS_EQ → add
    if op == 102: return val_sub(a, b)    # TOK_MINUS_EQ → sub
    if op == 103: return val_mul(a, b)    # TOK_STAR_EQ → mul
    if op == 104: return val_div(a, b)    # TOK_SLASH_EQ → div
    if op == 105: return val_mod(a, b)    # TOK_PERCENT_EQ → mod
    ops_set_error("unknown compound operator: " + "{op}")
    -1

export ops_get_error, ops_clear_error, ops_set_error
export val_add, val_sub, val_mul, val_div, val_mod
export val_eq, val_neq, val_lt, val_gt, val_lteq, val_gteq
export val_and, val_or, val_not, val_negate
export val_binary_op, val_unary_op, val_compound_op
