# Core Interpreter — Complex Expression Evaluators
#
# Split from eval.spl. Contains:
# - Float parsing utilities (parse_float_text, char_digit)
# - Call evaluation (eval_call, eval_function_call, eval_struct_constructor)
# - Method dispatch (eval_method_call, eval_method_with_args)
# - Built-in type methods (eval_array_method, eval_text_method)
# - Access evaluation (eval_field_access, eval_index_expr, eval_slice_expr)
# - Collection literals (eval_array_lit, eval_struct_lit)
# - Assignment (eval_assign_expr, eval_compound_assign_expr)
# - Misc (eval_return_expr, eval_interpolated_string, eval_null_coalesce)
#
# All evaluation returns a value_id (i64). Errors indicated by -1 (VAL_NONE).

use compiler.core.types.{TYPE_VOID, TYPE_BOOL, TYPE_I64, TYPE_F64, TYPE_TEXT, TYPE_ANY}
use compiler.core.monomorphize.{mono_cache_init, mono_cache_lookup, mono_cache_register, mono_specialize}

# ===== Float Parsing Utilities =====

fn parse_float_text(s: text) -> f64:
    """Parse a float from text representation (e.g. '3.14', '-2.5', '1e3')."""
    var result: f64 = 0.0
    var negative = false
    var i = 0
    # Handle sign
    if s.len() > 0 and s[0] == "-":
        negative = true
        i = 1
    elif s.len() > 0 and s[0] == "+":
        i = 1
    # Parse integer part
    while i < s.len():
        val c = s[i]
        if c == ".": break
        if c == "e" or c == "E": break
        if c != "_":
            val d = char_digit(c)
            if d >= 0.0:
                result = result * 10.0 + d
        i = i + 1
    # Parse fractional part
    if i < s.len() and s[i] == ".":
        i = i + 1
        var frac: f64 = 0.0
        var frac_div: f64 = 1.0
        while i < s.len():
            val c = s[i]
            if c == "e" or c == "E": break
            if c != "_":
                val d = char_digit(c)
                if d >= 0.0:
                    frac = frac * 10.0 + d
                    frac_div = frac_div * 10.0
            i = i + 1
        result = result + frac / frac_div
    # Parse exponent
    if i < s.len() and (s[i] == "e" or s[i] == "E"):
        i = i + 1
        var exp_neg = false
        if i < s.len() and s[i] == "-":
            exp_neg = true
            i = i + 1
        elif i < s.len() and s[i] == "+":
            i = i + 1
        var exp_val: f64 = 0.0
        while i < s.len():
            val c = s[i]
            if c != "_":
                val d = char_digit(c)
                if d >= 0.0:
                    exp_val = exp_val * 10.0 + d
            i = i + 1
        var power: f64 = 1.0
        var ei = 0
        while ei < int(exp_val):
            power = power * 10.0
            ei = ei + 1
        if exp_neg:
            result = result / power
        else:
            result = result * power
    if negative:
        0.0 - result
    else:
        result

fn char_digit(c: text) -> f64:
    """Convert single-char text to digit value, or -1.0 if not a digit."""
    if c == "0": 0.0
    elif c == "1": 1.0
    elif c == "2": 2.0
    elif c == "3": 3.0
    elif c == "4": 4.0
    elif c == "5": 5.0
    elif c == "6": 6.0
    elif c == "7": 7.0
    elif c == "8": 8.0
    elif c == "9": 9.0
    else: -1.0

# ===== Call Expression =====

fn eval_call(eid: i64) -> i64:
    val e_node = expr_get(eid)
    val callee_eid = e_node.left
    val arg_eids = e_node.args

    # Evaluate callee
    val callee_node = expr_get(callee_eid)
    val callee_tag = callee_node.tag

    # Direct function call by name
    if callee_tag == EXPR_IDENT:
        val name = callee_node.s_val

        # Check for struct constructor
        val struct_decl = struct_table_lookup(name)
        if struct_decl >= 0:
            return eval_struct_constructor(name, struct_decl, arg_eids)

        # Check for builtin
        val builtin_result = eval_builtin_call(name, arg_eids)
        if builtin_result >= -1:
            return builtin_result

        # Check function table
        val decl_id = func_table_lookup(name)
        if decl_id >= 0:
            return eval_function_call(decl_id, arg_eids)

        # Check environment for function value
        val fn_vid = env_lookup(name)
        if fn_vid >= 0:
            if val_is_function(fn_vid):
                val fn_decl = val_get_func_decl(fn_vid)
                return eval_function_call(fn_decl, arg_eids)

        eval_set_error("undefined function: " + name)
        return -1

    # Indirect call (call on expression result)
    val callee_val = eval_expr(callee_eid)
    if eval_had_error: return -1
    if val_is_function(callee_val):
        val fn_decl = val_get_func_decl(callee_val)
        return eval_function_call(fn_decl, arg_eids)

    eval_set_error("value is not callable")
    -1

fn eval_function_call(decl_id: i64, arg_eids: [i64]) -> i64:
    val d_node = decl_get(decl_id)
    val fn_name = d_node.name
    val param_names = d_node.param_names
    val param_types = d_node.param_types
    val type_params = d_node.type_params
    val body_stmts = d_node.body_stmts

    # Record call for JIT threshold tracking
    jit_record_call(fn_name)

    # Evaluate arguments
    var arg_values: [i64] = []
    for aeid in arg_eids:
        val av = eval_expr(aeid)
        if eval_had_error: return -1
        arg_values.push(av)

    # Check if function is generic (has type parameters)
    # If so, look up or create monomorphic instance
    var actual_decl_id = decl_id
    if type_params.len() > 0:
        val type_args_str = infer_type_args_from_values(arg_values)
        val cache_key = fn_name + "__" + type_args_str
        val cached_decl = mono_cache_lookup(cache_key)
        if cached_decl >= 0:
            actual_decl_id = cached_decl
        else:
            val type_tags = infer_type_tags_from_values(arg_values)
            val specialized_decl = mono_specialize(decl_id, type_params, type_tags)
            mono_cache_register(cache_key, specialized_decl)
            actual_decl_id = specialized_decl

    # Type check arguments if parameter types are specified
    if param_types.len() > 0:
        var pi: i64 = 0
        for av in arg_values:
            if pi < param_types.len():
                val expected_type = param_types[pi]
                if expected_type != 0:  # 0 = TYPE_VOID means no type annotation
                    val type_matches = type_check_value(av, expected_type)
                    if not type_matches:
                        val param_name = param_names[pi]
                        eval_set_error("type error: argument '" + param_name + "' in function '" + fn_name + "' type mismatch")
                        return -1
            pi = pi + 1

    # Try JIT execution if function is compiled
    if jit_is_compiled(fn_name):
        # Convert value_ids to raw i64s for JIT calling convention
        var raw_args: [i64] = []
        for av in arg_values:
            if val_is_int(av):
                raw_args.push(val_get_int(av))
            else:
                raw_args.push(av)
        val jit_result = jit_try_execute(fn_name, raw_args)
        if jit_result != -1:
            return val_make_int(jit_result)

    # Fall back to tree-walking
    val local_count = resolve_cached_local_count(actual_decl_id)
    val prev_decl_id = eval_current_decl_id
    eval_current_decl_id = actual_decl_id
    if local_count > 0:
        env_push_frame(local_count)
    env_push_scope()
    var pi: i64 = 0
    for pname in param_names:
        var pval = val_make_nil()
        if pi < arg_values.len():
            pval = arg_values[pi]
        env_define(pname, pval)
        # LOAD_FAST: set fast local for non-shadowed params
        if local_count > 0:
            val is_shadowed = resolve_is_slot_shadowed(actual_decl_id, pi)
            if is_shadowed == false:
                env_set_local(pi, pval)
        pi = pi + 1

    # Generator detection: push yield accumulator if body contains yield
    val is_gen = stmts_contain_yield(body_stmts)
    if is_gen:
        eval_yield_stack.push([])

    # Execute body
    var last_val = val_make_nil()
    for sid in body_stmts:
        if eval_had_error: break
        if eval_returning: break
        last_val = eval_stmt(sid)

    # Handle return
    var had_explicit_return = false
    if eval_returning:
        last_val = eval_return_value
        eval_returning = false
        eval_return_value = -1
        had_explicit_return = true

    # Generator: pop accumulator and return collected array
    if is_gen:
        val ys_len = eval_yield_stack.len()
        val yielded = eval_yield_stack[ys_len - 1]
        eval_yield_stack = eval_yield_stack[0:ys_len - 1]
        if had_explicit_return == false:
            last_val = val_make_array(yielded)

    env_pop_scope()
    if local_count > 0:
        env_pop_frame()
    eval_current_decl_id = prev_decl_id
    last_val

fn eval_struct_constructor(name: text, decl_id: i64, arg_eids: [i64]) -> i64:
    val d_node = decl_get(decl_id)
    val field_names = d_node.field_names
    val field_defaults = d_node.field_defaults
    var field_values: [i64] = []

    # Check for struct update spread (..base) - usually the last arg
    var base_struct: i64 = -1
    var spread_at: i64 = -1
    var spread_idx: i64 = 0
    for aeid in arg_eids:
        val etag = expr_get_tag(aeid)
        if etag == EXPR_SPREAD:
            spread_at = spread_idx
        spread_idx = spread_idx + 1

    # Evaluate non-spread arguments (positional mapping to fields)
    var explicit_pos: i64 = 0
    for aeid in arg_eids:
        val etag = expr_get_tag(aeid)
        if etag == EXPR_SPREAD:
            # Evaluate base struct for spread
            val inner_eid = expr_get_left(aeid)
            base_struct = eval_expr(inner_eid)
            if eval_had_error: return -1
        else:
            val av = eval_expr(aeid)
            if eval_had_error: return -1
            field_values.push(av)

    # Fill remaining fields: use base struct then defaults then nil
    val num_filled = field_values.len()
    var i: i64 = 0
    for fname in field_names:
        if i >= num_filled:
            var fv: i64 = -1
            # Try base struct field
            if base_struct >= 0:
                val bfv = val_struct_get_field(base_struct, fname)
                if bfv >= 0:
                    fv = bfv
            # Try declared default
            if fv < 0:
                if i < field_defaults.len():
                    val def_eid = field_defaults[i]
                    if def_eid >= 0:
                        fv = eval_expr(def_eid)
                        if eval_had_error: return -1
            if fv < 0:
                fv = val_make_nil()
            field_values.push(fv)
        i = i + 1

    val_make_struct(name, field_names, field_values)

# ===== Method Call =====

fn eval_method_call(eid: i64) -> i64:
    val e_node = expr_get(eid)
    val receiver_eid = e_node.left
    val method_name = e_node.s_val
    val arg_eids = e_node.args

    val receiver = eval_expr(receiver_eid)
    if eval_had_error: return -1

    # Built-in methods on types
    val kind = val_get_kind(receiver)

    # Array methods
    if kind == VAL_ARRAY:
        return eval_array_method(receiver, method_name, arg_eids)

    # Text methods
    if kind == VAL_TEXT:
        return eval_text_method(receiver, method_name, arg_eids)

    # Struct methods — look up Type__method in function table
    if kind == VAL_STRUCT:
        val type_name = val_get_struct_name(receiver)
        val full_name = type_name + "__" + method_name
        val decl_id = func_table_lookup(full_name)
        if decl_id >= 0:
            # Prepend receiver as first arg
            var all_arg_eids: [i64] = []
            for aeid in arg_eids:
                all_arg_eids.push(aeid)
            # Evaluate args, then call with receiver prepended
            var arg_values: [i64] = []
            arg_values.push(receiver)
            for aeid in all_arg_eids:
                val av = eval_expr(aeid)
                if eval_had_error: return -1
                arg_values.push(av)
            return eval_method_with_args(decl_id, arg_values)

    eval_set_error("no method '" + method_name + "' on " + val_kind_name(kind))
    -1

fn eval_method_with_args(decl_id: i64, arg_values: [i64]) -> i64:
    val d_node = decl_get(decl_id)
    val param_names = d_node.param_names
    val body_stmts = d_node.body_stmts

    env_push_scope()
    # Bind self + params
    var pi: i64 = 0
    for pname in param_names:
        if pi < arg_values.len():
            env_define(pname, arg_values[pi])
        else:
            env_define(pname, val_make_nil())
        pi = pi + 1

    var last_val = val_make_nil()
    for sid in body_stmts:
        if eval_had_error: break
        if eval_returning: break
        last_val = eval_stmt(sid)

    if eval_returning:
        last_val = eval_return_value
        eval_returning = false
        eval_return_value = -1

    env_pop_scope()
    last_val

# ===== Array Methods =====

fn eval_array_method(receiver: i64, method_name: text, arg_eids: [i64]) -> i64:
    val elements = val_get_array(receiver)

    if method_name == "len":
        return val_make_int(elements.len())

    if method_name == "push":
        if arg_eids.len() > 0:
            val new_elem = eval_expr(arg_eids[0])
            if eval_had_error: return -1
            var new_elems: [i64] = []
            for e in elements:
                new_elems.push(e)
            new_elems.push(new_elem)
            return val_make_array(new_elems)
        return receiver

    if method_name == "contains":
        if arg_eids.len() > 0:
            val target = eval_expr(arg_eids[0])
            if eval_had_error: return -1
            for e in elements:
                if val_equals(e, target): return val_make_bool(true)
            return val_make_bool(false)
        return val_make_bool(false)

    eval_set_error("no method '" + method_name + "' on array")
    -1

# ===== Text Methods =====

fn eval_text_method(receiver: i64, method_name: text, arg_eids: [i64]) -> i64:
    val s = val_get_text(receiver)

    if method_name == "len":
        return val_make_int(s.len())

    if method_name == "contains":
        if arg_eids.len() > 0:
            val target = eval_expr(arg_eids[0])
            if eval_had_error: return -1
            val t = val_get_text(target)
            return val_make_bool(s.contains(t))
        return val_make_bool(false)

    eval_set_error("no method '" + method_name + "' on text")
    -1

# ===== Field Access =====

fn eval_field_access(eid: i64) -> i64:
    val e_node = expr_get(eid)
    val base_eid = e_node.left
    val field_name = e_node.s_val

    val base_val = eval_expr(base_eid)
    if eval_had_error: return -1

    if val_is_struct(base_val):
        # Fast path: cached field index from previous access
        val cached_idx = expr_i_val[eid]
        if cached_idx >= 0:
            val ok = val_struct_check_field_idx(base_val, cached_idx, field_name)
            if ok:
                return val_struct_get_field_idx(base_val, cached_idx)
        # Slow path: linear search + cache index
        val fi = val_struct_find_field_idx(base_val, field_name)
        if fi >= 0:
            expr_i_val[eid] = fi
            return val_struct_get_field_idx(base_val, fi)
        eval_set_error("no field '" + field_name + "' on struct " + val_get_struct_name(base_val))
        return -1

    eval_set_error("cannot access field on " + val_kind_name(val_get_kind(base_val)))
    -1

# ===== Index Expression =====

fn eval_index_expr(eid: i64) -> i64:
    val e_node = expr_get(eid)
    val base_eid = e_node.left
    val index_eid = e_node.right

    val base_val = eval_expr(base_eid)
    if eval_had_error: return -1
    val index_val = eval_expr(index_eid)
    if eval_had_error: return -1

    if val_is_array(base_val):
        val elements = val_get_array(base_val)
        if val_is_int(index_val):
            val idx = val_get_int(index_val)
            if idx >= 0:
                val len = elements.len()
                if idx < len:
                    return elements[idx]
            eval_set_error("array index out of bounds: " + "{idx}")
            return -1

    if val_is_text(base_val):
        val s = val_get_text(base_val)
        if val_is_int(index_val):
            val idx = val_get_int(index_val)
            if idx >= 0:
                if idx < s.len():
                    return val_make_text(s[idx])
            eval_set_error("string index out of bounds: " + "{idx}")
            return -1

    eval_set_error("cannot index " + val_kind_name(val_get_kind(base_val)))
    -1

# ===== Slice Expression =====

fn eval_slice_expr(eid: i64) -> i64:
    """Evaluate slice expression: base[start:end]

    Handles string and array slicing with support for:
    - [:end] - slice from start (start=0)
    - [start:] - slice to end (end=-1 means len)
    - [start:end] - explicit range
    """
    val e_node = expr_get(eid)
    val base_eid = e_node.left
    val start_eid = e_node.right
    val end_eid = e_node.extra

    val base_val = eval_expr(base_eid)
    if eval_had_error: return -1
    val start_val = eval_expr(start_eid)
    if eval_had_error: return -1
    val end_val = eval_expr(end_eid)
    if eval_had_error: return -1

    if val_is_text(base_val):
        val s = val_get_text(base_val)
        val slen = s.len()

        # Get start index (default 0)
        var start_idx = 0
        if val_is_int(start_val):
            start_idx = val_get_int(start_val)
            if start_idx < 0:
                start_idx = 0

        # Get end index (default slen, -1 means slen)
        var end_idx = slen
        if val_is_int(end_val):
            end_idx = val_get_int(end_val)
            if end_idx < 0:
                end_idx = slen
            if end_idx > slen:
                end_idx = slen

        # Slice the string
        if start_idx >= slen:
            return val_make_text("")
        if end_idx <= start_idx:
            return val_make_text("")

        return val_make_text(s[start_idx:end_idx])

    if val_is_array(base_val):
        val elements = val_get_array(base_val)
        val alen = elements.len()

        # Get start index (default 0)
        var start_idx = 0
        if val_is_int(start_val):
            start_idx = val_get_int(start_val)
            if start_idx < 0:
                start_idx = 0

        # Get end index (default alen, -1 means alen)
        var end_idx = alen
        if val_is_int(end_val):
            end_idx = val_get_int(end_val)
            if end_idx < 0:
                end_idx = alen
            if end_idx > alen:
                end_idx = alen

        # Slice the array
        var result: [i64] = []
        if start_idx < alen and end_idx > start_idx:
            for i in start_idx..end_idx:
                result.push(elements[i])

        return val_make_array(result)

    eval_set_error("cannot slice " + val_kind_name(val_get_kind(base_val)))
    -1

# ===== Array Literal =====

fn eval_array_lit(eid: i64) -> i64:
    val elem_eids = expr_get(eid).args
    var elements: [i64] = []
    for e_eid in elem_eids:
        val ev = eval_expr(e_eid)
        if eval_had_error: return -1
        elements.push(ev)
    val_make_array(elements)

# ===== Tuple Literal =====
# Tuples are evaluated as arrays in the interpreter

fn eval_tuple_lit(eid: i64) -> i64:
    val elem_eids = expr_get(eid).args
    var elements: [i64] = []
    for e_eid in elem_eids:
        val ev = eval_expr(e_eid)
        if eval_had_error: return -1
        elements.push(ev)
    val_make_array(elements)

# ===== Struct Literal =====

fn eval_struct_lit(eid: i64) -> i64:
    val e_node = expr_get(eid)
    val type_name = e_node.s_val
    val field_name_eids = e_node.args
    val field_value_eids = e_node.stmts

    # Field names stored as ident expressions
    var field_names: [text] = []
    for fn_eid in field_name_eids:
        field_names.push(expr_get(fn_eid).s_val)

    var field_values: [i64] = []
    for fv_eid in field_value_eids:
        val fv = eval_expr(fv_eid)
        if eval_had_error: return -1
        field_values.push(fv)

    val_make_struct(type_name, field_names, field_values)

# ===== Assignment Expression =====

fn eval_assign_expr(eid: i64) -> i64:
    val e_node = expr_get(eid)
    val target_eid = e_node.left
    val value_eid = e_node.right

    val new_val = eval_expr(value_eid)
    if eval_had_error: return -1

    val target_node = expr_get(target_eid)
    val target_tag = target_node.tag
    if target_tag == EXPR_IDENT:
        val name = target_node.s_val
        val ok = env_assign(name, new_val)
        if ok == false:
            eval_set_error("undefined variable: " + name)
            return -1
        return new_val

    if target_tag == EXPR_FIELD_ACCESS:
        val base_eid2 = target_node.left
        val field_name = target_node.s_val
        val base_val = eval_expr(base_eid2)
        if eval_had_error: return -1
        if val_is_struct(base_val):
            # Fast path: cached field index
            val cached_idx = expr_i_val[target_eid]
            if cached_idx >= 0:
                val ok = val_struct_check_field_idx(base_val, cached_idx, field_name)
                if ok:
                    val_struct_set_field_idx(base_val, cached_idx, new_val)
                    return new_val
            # Slow path: find + set + cache
            val fi = val_struct_find_field_idx(base_val, field_name)
            if fi >= 0:
                val_struct_set_field_idx(base_val, fi, new_val)
                expr_i_val[target_eid] = fi
                return new_val
            eval_set_error("no field '" + field_name + "' on struct " + val_get_struct_name(base_val))
            return -1
        eval_set_error("cannot set field on " + val_kind_name(val_get_kind(base_val)))
        return -1

    eval_set_error("invalid assignment target")
    -1

fn eval_compound_assign_expr(eid: i64) -> i64:
    val e_node = expr_get(eid)
    val op = e_node.i_val
    val target_eid = e_node.left
    val value_eid = e_node.right

    val target_node = expr_get(target_eid)
    val target_tag = target_node.tag
    if target_tag == EXPR_IDENT:
        val name = target_node.s_val
        val old_val = env_lookup(name)
        if old_val < 0:
            eval_set_error("undefined variable: " + name)
            return -1
        val rhs_val = eval_expr(value_eid)
        if eval_had_error: return -1
        val new_val = val_compound_op(op, old_val, rhs_val)
        if new_val < 0:
            val err = ops_get_error()
            if err != "":
                eval_set_error(err)
            return -1
        env_assign(name, new_val)
        return new_val

    eval_set_error("invalid compound assignment target")
    -1

# ===== Return Expression =====

fn eval_return_expr(eid: i64) -> i64:
    val value_eid = expr_get(eid).left
    var ret_val = val_make_nil()
    if value_eid >= 0:
        ret_val = eval_expr(value_eid)
        if eval_had_error: return -1
    eval_returning = true
    eval_return_value = ret_val
    ret_val

# ===== Interpolated String =====

fn eval_interpolated_string(eid: i64) -> i64:
    val parts = expr_get(eid).args
    var parts_text: [text] = []
    for part_eid in parts:
        val part_val = eval_expr(part_eid)
        if eval_had_error: return -1
        parts_text = parts_text + [val_to_text(part_val)]
    val result = parts_text.join("")
    val_make_text(result)

# ===== Null Coalesce =====

fn eval_null_coalesce(eid: i64) -> i64:
    val e_node = expr_get(eid)
    val left = eval_expr(e_node.left)
    if eval_had_error: return -1
    if val_is_nil(left) == false: return left
    eval_expr(e_node.right)
