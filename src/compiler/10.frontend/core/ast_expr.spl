# Core Simple — AST Expression Nodes
#
# Expression kind tags, arena pools, constructors, and accessors.
# Split from ast.spl for maintainability.
#
# See ast.spl for the full AST module documentation.

# ===== Expression Kind Tags =====
val EXPR_INT_LIT = 1
val EXPR_FLOAT_LIT = 2
val EXPR_STRING_LIT = 3
val EXPR_BOOL_LIT = 4
val EXPR_NIL_LIT = 5
val EXPR_IDENT = 6
val EXPR_BINARY = 7
val EXPR_UNARY = 8
val EXPR_CALL = 9
val EXPR_INDEX = 10
val EXPR_FIELD_ACCESS = 11
val EXPR_METHOD_CALL = 12
val EXPR_ARRAY_LIT = 13
val EXPR_IF = 14
val EXPR_MATCH = 15
val EXPR_FOR = 16
val EXPR_WHILE = 17
val EXPR_BLOCK = 18
val EXPR_RETURN = 19
val EXPR_BREAK = 20
val EXPR_CONTINUE = 21
val EXPR_RANGE = 22
val EXPR_ASSIGN = 23
val EXPR_COMPOUND_ASSIGN = 24
val EXPR_DICT_LIT = 25
val EXPR_LAMBDA = 26
val EXPR_STRUCT_LIT = 27
val EXPR_TUPLE = 28
val EXPR_SLICE = 29
val EXPR_NULL_COALESCE = 30
val EXPR_OPTIONAL_CHAIN = 31
val EXPR_CAST = 32
val EXPR_UNIT = 33
val EXPR_INTERPOLATED_STRING = 34
val EXPR_PASS = 35
val EXPR_PASS_TODO = 40
val EXPR_PASS_DO_NOTHING = 41
val EXPR_PASS_DN = 43
val EXPR_SUFFIXED_LIT = 36
val EXPR_AWAIT = 37       # await future_expr
val EXPR_YIELD = 38       # yield value
val EXPR_SPAWN = 39       # spawn fn_call
val EXPR_ASYNC_BLOCK = 42 # async { ... }
val EXPR_DO_BLOCK = 44   # do: block expression (returns last value)
val EXPR_ATOM = 45       # `symbol atom literal (interned text, identity comparison)
val EXPR_SPREAD = 46     # ..expr spread in struct update syntax
val EXPR_ASM = 47        # asm text block/string (lowered by backend)
val EXPR_ASM_MATCH = 48  # asm match: multi-target dispatch
val EXPR_EXISTS_CHECK = 49  # .? existence check (returns T? — value if present, nil if absent)

# ===== Expression Arena Pools =====
# Each expression has:
#   - tag:    EXPR_* kind
#   - span:   span pool index
#   - i_val:  integer value (for int/bool literals, operator kind)
#   - f_val:  float value (stored as text to avoid precision issues)
#   - s_val:  string value (for string literals, identifiers, field names)
#   - left:   left child expression index (-1 = none)
#   - right:  right child expression index (-1 = none)
#   - extra:  extra expression index (else branch, etc.) (-1 = none)
#   - args:   argument list (indices into expr pool)
#   - stmts:  statement list (indices into stmt pool)

var expr_tag: [i64] = []
var expr_span: [i64] = []
var expr_i_val: [i64] = []
var expr_f_val: [text] = []
var expr_s_val: [text] = []
var expr_left: [i64] = []
var expr_right: [i64] = []
var expr_extra: [i64] = []
var expr_args: [[i64]] = []
var expr_stmts: [[i64]] = []

fn expr_count() -> i64:
    expr_tag.len()

# Allocate a new expression node, returns its index
fn expr_alloc(tag: i64, span_id: i64) -> i64:
    val idx = expr_tag.len()
    expr_tag.push(tag)
    expr_span.push(span_id)
    expr_i_val.push(0)
    expr_f_val.push("")
    expr_s_val.push("")
    expr_left.push(-1)
    expr_right.push(-1)
    expr_extra.push(-1)
    expr_args.push([])
    expr_stmts.push([])
    idx

# ===== Expression Constructors =====

fn expr_int_lit(value: i64, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_INT_LIT, span_id)
    expr_i_val[idx] = value
    idx

fn expr_float_lit(value: text, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_FLOAT_LIT, span_id)
    expr_f_val[idx] = value
    idx

fn expr_string_lit(value: text, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_STRING_LIT, span_id)
    expr_s_val[idx] = value
    idx

fn expr_bool_lit(value: i64, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_BOOL_LIT, span_id)
    expr_i_val[idx] = value
    idx

fn expr_nil_lit(span_id: i64) -> i64:
    expr_alloc(EXPR_NIL_LIT, span_id)

fn expr_ident(name: text, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_IDENT, span_id)
    expr_s_val[idx] = name
    expr_i_val[idx] = -1
    idx

fn expr_binary(op: i64, left_idx: i64, right_idx: i64, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_BINARY, span_id)
    expr_i_val[idx] = op
    expr_left[idx] = left_idx
    expr_right[idx] = right_idx
    idx

fn expr_unary(op: i64, operand: i64, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_UNARY, span_id)
    expr_i_val[idx] = op
    expr_left[idx] = operand
    idx

fn expr_call(callee: i64, call_args: [i64], span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_CALL, span_id)
    expr_left[idx] = callee
    expr_args[idx] = call_args
    idx

fn expr_index(base: i64, index_expr: i64, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_INDEX, span_id)
    expr_left[idx] = base
    expr_right[idx] = index_expr
    idx

fn expr_field_access(base: i64, field_name: text, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_FIELD_ACCESS, span_id)
    expr_left[idx] = base
    expr_s_val[idx] = field_name
    expr_i_val[idx] = -1
    idx

fn expr_method_call(receiver: i64, method_name: text, call_args: [i64], span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_METHOD_CALL, span_id)
    expr_left[idx] = receiver
    expr_s_val[idx] = method_name
    expr_args[idx] = call_args
    idx

fn expr_array_lit(elements: [i64], span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_ARRAY_LIT, span_id)
    expr_args[idx] = elements
    idx

fn expr_if_expr(cond: i64, then_branch: i64, else_branch: i64, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_IF, span_id)
    expr_left[idx] = cond
    expr_right[idx] = then_branch
    expr_extra[idx] = else_branch
    idx

fn expr_match_expr(scrutinee: i64, arms: [i64], span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_MATCH, span_id)
    expr_left[idx] = scrutinee
    expr_args[idx] = arms
    idx

fn expr_for_expr(iter_var: text, iterable: i64, body_stmts: [i64], span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_FOR, span_id)
    expr_s_val[idx] = iter_var
    expr_left[idx] = iterable
    expr_stmts[idx] = body_stmts
    idx

fn expr_while_expr(cond: i64, body_stmts: [i64], span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_WHILE, span_id)
    expr_left[idx] = cond
    expr_stmts[idx] = body_stmts
    idx

fn expr_block(body_stmts: [i64], value_expr: i64, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_BLOCK, span_id)
    expr_stmts[idx] = body_stmts
    expr_left[idx] = value_expr
    idx

fn expr_return_expr(value: i64, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_RETURN, span_id)
    expr_left[idx] = value
    idx

fn expr_break_expr(span_id: i64) -> i64:
    expr_alloc(EXPR_BREAK, span_id)

fn expr_continue_expr(span_id: i64) -> i64:
    expr_alloc(EXPR_CONTINUE, span_id)

fn expr_await(future_expr: i64, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_AWAIT, span_id)
    expr_left[idx] = future_expr
    idx

fn expr_yield(value_expr: i64, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_YIELD, span_id)
    expr_left[idx] = value_expr
    idx

fn expr_spawn(call_expr: i64, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_SPAWN, span_id)
    expr_left[idx] = call_expr
    idx

fn expr_do_block(body_stmts: [i64], span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_DO_BLOCK, span_id)
    expr_stmts[idx] = body_stmts
    idx

fn expr_atom(name: text, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_ATOM, span_id)
    expr_s_val[idx] = name
    idx

fn expr_spread(inner: i64, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_SPREAD, span_id)
    expr_left[idx] = inner
    idx

fn expr_asm(text_value: text, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_ASM, span_id)
    expr_s_val[idx] = text_value
    idx

# ===== Asm Match Arm Arena =====
# Parallel arrays for target-qualified asm match arms
var asm_arm_archs: [[text]] = []       # arch list per arm (pipe groups)
var asm_arm_os: [text] = []            # os per arm ("" = wildcard)
var asm_arm_abi: [text] = []           # abi per arm ("" = wildcard)
var asm_arm_backend: [text] = []       # backend per arm ("" = wildcard)
var asm_arm_ver_ops: [[text]] = []     # version constraint ops per arm
var asm_arm_ver_vals: [[i64]] = []     # version constraint values per arm
var asm_arm_asm_text: [text] = []      # asm body text per arm
var asm_arm_is_compile_error: [bool] = []  # is compile_error arm
var asm_arm_error_msg: [text] = []     # error message for compile_error arms
var asm_arm_is_wildcard: [bool] = []   # is wildcard (_) arm

fn asm_arm_new(archs: [text], os: text, abi: text, backend: text,
               ver_ops: [text], ver_vals: [i64], asm_text: text,
               is_compile_error: bool, error_msg: text, is_wildcard: bool) -> i64:
    """Allocate a new asm match arm, returns its index."""
    val idx = asm_arm_archs.len()
    asm_arm_archs.push(archs)
    asm_arm_os.push(os)
    asm_arm_abi.push(abi)
    asm_arm_backend.push(backend)
    asm_arm_ver_ops.push(ver_ops)
    asm_arm_ver_vals.push(ver_vals)
    asm_arm_asm_text.push(asm_text)
    asm_arm_is_compile_error.push(is_compile_error)
    asm_arm_error_msg.push(error_msg)
    asm_arm_is_wildcard.push(is_wildcard)
    idx

fn expr_asm_match(arm_indices: [i64], span_id: i64) -> i64:
    """Create asm match expression. arm_indices are indices into asm_arm_* arrays."""
    val idx = expr_alloc(EXPR_ASM_MATCH, span_id)
    expr_args[idx] = arm_indices
    idx

fn expr_asm_assert(arm_idx: i64, span_id: i64) -> i64:
    """Create asm assert expression. arm_idx is index into asm_arm_* arrays.
    Distinguished from asm match by i_val = 1.
    """
    val idx = expr_alloc(EXPR_ASM_MATCH, span_id)
    expr_args[idx] = [arm_idx]
    expr_i_val[idx] = 1
    idx

fn expr_range(start_expr: i64, end_expr: i64, inclusive: i64, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_RANGE, span_id)
    expr_left[idx] = start_expr
    expr_right[idx] = end_expr
    expr_i_val[idx] = inclusive
    idx

fn expr_assign(target: i64, value: i64, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_ASSIGN, span_id)
    expr_left[idx] = target
    expr_right[idx] = value
    idx

fn expr_compound_assign(op: i64, target: i64, value: i64, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_COMPOUND_ASSIGN, span_id)
    expr_i_val[idx] = op
    expr_left[idx] = target
    expr_right[idx] = value
    idx

fn expr_dict_lit(key_exprs: [i64], value_exprs: [i64], span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_DICT_LIT, span_id)
    expr_args[idx] = key_exprs
    expr_stmts[idx] = value_exprs
    idx

fn expr_lambda(param_names: [i64], body_stmts: [i64], span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_LAMBDA, span_id)
    expr_args[idx] = param_names
    expr_stmts[idx] = body_stmts
    idx

fn expr_struct_lit(type_name: text, field_names: [i64], field_values: [i64], span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_STRUCT_LIT, span_id)
    expr_s_val[idx] = type_name
    expr_args[idx] = field_names
    expr_stmts[idx] = field_values
    idx

fn expr_tuple(elements: [i64], span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_TUPLE, span_id)
    expr_args[idx] = elements
    idx

fn expr_slice(base: i64, start_expr: i64, end_expr: i64, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_SLICE, span_id)
    expr_left[idx] = base
    expr_right[idx] = start_expr
    expr_extra[idx] = end_expr
    idx

fn expr_null_coalesce(left_idx: i64, right_idx: i64, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_NULL_COALESCE, span_id)
    expr_left[idx] = left_idx
    expr_right[idx] = right_idx
    idx

fn expr_exists_check(base: i64, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_EXISTS_CHECK, span_id)
    expr_left[idx] = base
    idx

fn expr_optional_chain(base: i64, field_name: text, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_OPTIONAL_CHAIN, span_id)
    expr_left[idx] = base
    expr_s_val[idx] = field_name
    idx

fn expr_cast(value: i64, type_tag: i64, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_CAST, span_id)
    expr_left[idx] = value
    expr_i_val[idx] = type_tag
    idx

fn expr_unit(span_id: i64) -> i64:
    expr_alloc(EXPR_UNIT, span_id)

fn expr_interpolated_string(parts: [i64], span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_INTERPOLATED_STRING, span_id)
    expr_args[idx] = parts
    idx

fn expr_pass(span_id: i64) -> i64:
    expr_alloc(EXPR_PASS, span_id)

fn expr_pass_with_msg(msg: text, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_PASS, span_id)
    expr_s_val[idx] = msg
    idx

fn expr_pass_todo(msg: text, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_PASS_TODO, span_id)
    expr_s_val[idx] = msg
    idx

fn expr_pass_do_nothing(msg: text, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_PASS_DO_NOTHING, span_id)
    expr_s_val[idx] = msg
    idx

fn expr_pass_dn(msg: text, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_PASS_DN, span_id)
    expr_s_val[idx] = msg
    idx

fn expr_suffixed_int(value: i64, suffix: text, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_SUFFIXED_LIT, span_id)
    expr_i_val[idx] = value
    expr_s_val[idx] = suffix
    idx

fn expr_suffixed_float(value: text, suffix: text, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_SUFFIXED_LIT, span_id)
    expr_f_val[idx] = value
    expr_s_val[idx] = suffix
    idx

fn expr_suffixed_bool(value: i64, suffix: text, span_id: i64) -> i64:
    val idx = expr_alloc(EXPR_SUFFIXED_LIT, span_id)
    expr_i_val[idx] = value
    expr_extra[idx] = 1
    expr_s_val[idx] = suffix
    idx

# ===== Expression Accessors =====

fn expr_get_tag(idx: i64) -> i64:
    expr_tag[idx]

fn expr_get_span(idx: i64) -> i64:
    expr_span[idx]

fn expr_get_int(idx: i64) -> i64:
    expr_i_val[idx]

fn expr_get_float(idx: i64) -> text:
    expr_f_val[idx]

fn expr_get_str(idx: i64) -> text:
    expr_s_val[idx]

fn expr_get_left(idx: i64) -> i64:
    expr_left[idx]

fn expr_get_right(idx: i64) -> i64:
    expr_right[idx]

fn expr_get_extra(idx: i64) -> i64:
    expr_extra[idx]

fn expr_get_args(idx: i64) -> [i64]:
    expr_args[idx]

fn expr_get_stmts(idx: i64) -> [i64]:
    expr_stmts[idx]

# ===== Expression Kind Names (for debugging) =====

fn expr_kind_name(tag: i64) -> text:
    if tag == EXPR_INT_LIT: return "IntLit"
    if tag == EXPR_FLOAT_LIT: return "FloatLit"
    if tag == EXPR_STRING_LIT: return "StringLit"
    if tag == EXPR_BOOL_LIT: return "BoolLit"
    if tag == EXPR_NIL_LIT: return "NilLit"
    if tag == EXPR_IDENT: return "Ident"
    if tag == EXPR_BINARY: return "Binary"
    if tag == EXPR_UNARY: return "Unary"
    if tag == EXPR_CALL: return "Call"
    if tag == EXPR_INDEX: return "Index"
    if tag == EXPR_FIELD_ACCESS: return "FieldAccess"
    if tag == EXPR_METHOD_CALL: return "MethodCall"
    if tag == EXPR_ARRAY_LIT: return "ArrayLit"
    if tag == EXPR_IF: return "If"
    if tag == EXPR_MATCH: return "Match"
    if tag == EXPR_FOR: return "For"
    if tag == EXPR_WHILE: return "While"
    if tag == EXPR_BLOCK: return "Block"
    if tag == EXPR_RETURN: return "Return"
    if tag == EXPR_BREAK: return "Break"
    if tag == EXPR_CONTINUE: return "Continue"
    if tag == EXPR_RANGE: return "Range"
    if tag == EXPR_ASSIGN: return "Assign"
    if tag == EXPR_COMPOUND_ASSIGN: return "CompoundAssign"
    if tag == EXPR_DICT_LIT: return "DictLit"
    if tag == EXPR_LAMBDA: return "Lambda"
    if tag == EXPR_STRUCT_LIT: return "StructLit"
    if tag == EXPR_TUPLE: return "Tuple"
    if tag == EXPR_SLICE: return "Slice"
    if tag == EXPR_NULL_COALESCE: return "NullCoalesce"
    if tag == EXPR_OPTIONAL_CHAIN: return "OptionalChain"
    if tag == EXPR_CAST: return "Cast"
    if tag == EXPR_UNIT: return "Unit"
    if tag == EXPR_INTERPOLATED_STRING: return "InterpolatedString"
    if tag == EXPR_PASS: return "Pass"
    if tag == EXPR_PASS_TODO: return "PassTodo"
    if tag == EXPR_PASS_DO_NOTHING: return "PassDoNothing"
    if tag == EXPR_PASS_DN: return "PassDn"
    if tag == EXPR_SUFFIXED_LIT: return "SuffixedLit"
    if tag == EXPR_DO_BLOCK: return "DoBlock"
    if tag == EXPR_ATOM: return "Atom"
    if tag == EXPR_SPREAD: return "Spread"
    if tag == EXPR_ASM: return "Asm"
    if tag == EXPR_ASM_MATCH: return "AsmMatch"
    if tag == EXPR_EXISTS_CHECK: return "ExistsCheck"
    "Unknown({tag})"

export EXPR_INT_LIT, EXPR_FLOAT_LIT, EXPR_STRING_LIT, EXPR_BOOL_LIT, EXPR_NIL_LIT
export EXPR_IDENT, EXPR_BINARY, EXPR_UNARY, EXPR_CALL, EXPR_INDEX
export EXPR_FIELD_ACCESS, EXPR_METHOD_CALL, EXPR_ARRAY_LIT
export EXPR_IF, EXPR_MATCH, EXPR_FOR, EXPR_WHILE, EXPR_BLOCK
export EXPR_RETURN, EXPR_BREAK, EXPR_CONTINUE, EXPR_RANGE
export EXPR_ASSIGN, EXPR_COMPOUND_ASSIGN, EXPR_DICT_LIT, EXPR_LAMBDA
export EXPR_STRUCT_LIT, EXPR_TUPLE, EXPR_SLICE
export EXPR_NULL_COALESCE, EXPR_OPTIONAL_CHAIN, EXPR_CAST
export EXPR_UNIT, EXPR_INTERPOLATED_STRING, EXPR_PASS, EXPR_PASS_TODO, EXPR_PASS_DO_NOTHING, EXPR_PASS_DN, EXPR_SUFFIXED_LIT
export EXPR_AWAIT, EXPR_YIELD, EXPR_SPAWN, EXPR_ASYNC_BLOCK
export EXPR_DO_BLOCK, EXPR_ATOM, EXPR_SPREAD, EXPR_ASM, EXPR_ASM_MATCH, EXPR_EXISTS_CHECK
export expr_tag, expr_span, expr_i_val, expr_f_val, expr_s_val
export expr_left, expr_right, expr_extra, expr_args, expr_stmts
export expr_count, expr_alloc
export expr_int_lit, expr_float_lit, expr_string_lit, expr_bool_lit, expr_nil_lit
export expr_ident, expr_binary, expr_unary, expr_call, expr_index
export expr_field_access, expr_method_call, expr_array_lit
export expr_if_expr, expr_match_expr, expr_for_expr, expr_while_expr, expr_block
export expr_return_expr, expr_break_expr, expr_continue_expr, expr_range
export expr_assign, expr_compound_assign, expr_dict_lit, expr_lambda
export expr_struct_lit, expr_tuple, expr_slice
export expr_null_coalesce, expr_optional_chain, expr_cast
export expr_unit, expr_interpolated_string, expr_pass, expr_pass_with_msg, expr_pass_todo, expr_pass_do_nothing, expr_pass_dn
export expr_suffixed_int, expr_suffixed_float, expr_suffixed_bool
export expr_await, expr_yield, expr_spawn, expr_do_block, expr_atom, expr_spread, expr_asm, expr_asm_match, expr_asm_assert, expr_exists_check
export expr_get_tag, expr_get_span, expr_get_int, expr_get_float, expr_get_str
export expr_get_left, expr_get_right, expr_get_extra, expr_get_args, expr_get_stmts
export expr_kind_name
export asm_arm_new, asm_arm_archs, asm_arm_os, asm_arm_abi, asm_arm_backend
export asm_arm_ver_ops, asm_arm_ver_vals, asm_arm_asm_text
export asm_arm_is_compile_error, asm_arm_error_msg, asm_arm_is_wildcard
