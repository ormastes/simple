# Parser â€” Declaration Module
#
# Declaration parsing: fn, extern fn, struct/class, enum.
# Use/export/binding/impl declarations extracted to parser_decls_use.spl.

use compiler.core.tokens.{tok_kind_name}
use compiler.core.tokens.{TOK_INT_LIT, TOK_STRING_LIT}
use compiler.core.tokens.{TOK_IDENT}
use compiler.core.tokens.{TOK_KW_FN, TOK_KW_VAL, TOK_KW_VAR}
use compiler.core.tokens.{TOK_KW_IF, TOK_KW_FOR, TOK_KW_WHILE}
use compiler.core.tokens.{TOK_KW_STRUCT, TOK_KW_ENUM}
use compiler.core.tokens.{TOK_KW_EXTERN, TOK_KW_USE, TOK_KW_EXPORT, TOK_KW_IMPORT, TOK_KW_TRAIT}
use compiler.core.tokens.{TOK_KW_TYPE, TOK_KW_ASM}
use compiler.core.tokens.{TOK_PLUS, TOK_MINUS, TOK_STAR}
use compiler.core.tokens.{TOK_EQ, TOK_LT, TOK_GT, TOK_LEQ, TOK_GEQ, TOK_LT_GENERIC}
use compiler.core.tokens.{TOK_ASSIGN}
use compiler.core.tokens.{TOK_LPAREN, TOK_RPAREN, TOK_LBRACKET, TOK_RBRACKET}
use compiler.core.tokens.{TOK_LBRACE, TOK_RBRACE}
use compiler.core.tokens.{TOK_COLON, TOK_COMMA, TOK_DOT, TOK_DOTDOT}
use compiler.core.tokens.{TOK_ARROW}
use compiler.core.tokens.{TOK_QUESTION}
use compiler.core.tokens.{TOK_NEWLINE, TOK_INDENT, TOK_DEDENT, TOK_EOF}
use compiler.core.tokens.{TOK_SEMICOLON}
use compiler.core.tokens.{TOK_KW_SELF, TOK_KW_CLASS, TOK_KW_IMPL, TOK_KW_STATIC, TOK_KW_ME}
use compiler.core.tokens.{TOK_KW_ASYNC}
use compiler.core.tokens.{TOK_KW_CONST, TOK_KW_WHERE}
use compiler.core.tokens.{TOK_KW_LAZY, TOK_KW_EXTEND, TOK_KW_NEWTYPE}
use compiler.core.tokens.{TOK_KW_CE}
use compiler.core.tokens.{TOK_UNDERSCORE, TOK_TILDE}
use compiler.core.ast.{expr_ident, expr_call, expr_unit, expr_block}
use compiler.core.ast.{DECL_FN, DECL_EXTERN_FN, DECL_STRUCT, DECL_USE, DECL_EXPORT}
use compiler.core.ast.{DECL_VAL, DECL_VAR, DECL_ENUM, DECL_LAZY_VAL}
use compiler.core.ast.{DECL_CE, decl_ce_block}
use compiler.core.ast.{decl_fn, decl_extern_fn, decl_struct_def}
use compiler.core.ast.{decl_val_binding, decl_lazy_val_binding, decl_var_binding}
use compiler.core.ast.{decl_use_import, decl_export_names, decl_enum_def, decl_set_lazy}
use compiler.core.ast.{decl_impl_block}
use compiler.core.ast.{decl_set_comptime}
use compiler.core.ast.{module_set_path, module_add_decl}
use compiler.core.types.{TYPE_I64, TYPE_F64, TYPE_TEXT, TYPE_BOOL, TYPE_VOID}
use compiler.core.types.{TYPE_OPTION, TYPE_OPTION_I64, TYPE_OPTION_F64, TYPE_OPTION_TEXT, TYPE_OPTION_BOOL}
use compiler.core.types.{TYPE_RESULT, TYPE_NAMED_BASE, TYPE_DICT, TYPE_FN, TYPE_ANY}
use compiler.core.types.{int_to_str}
use compiler.core.types.{named_type_register, named_type_find}
use compiler.core.parser.{par_kind, par_text, par_line, par_col, par_errors, par_had_error, par_struct_names}
use compiler.core.parser.{parser_advance, parser_expect, parser_error}
use compiler.core.parser.{parser_skip_newlines, parser_skip_newlines_and_semicolons}
use compiler.core.parser.{parser_parse_type, parser_parse_type_with_union}

# Import from sibling split modules
use compiler.core.parser_expr.{parse_expr}
use compiler.core.parser_stmts.{parse_block, parse_if_expr, parse_for_expr, parse_while_expr}

# Re-export use/export/binding/impl declarations (extracted to parser_decls_use.spl)
use compiler.core.parser_decls_use.{*}

# ===== Helper Functions =====

fn parser_skip_tilde_if_present():
    # Skip ~ prefix for keyword-only parameter marker
    if par_kind == TOK_TILDE:
        parser_advance()

fn parser_expect_param_name():
    # Accept IDENT or SELF as parameter name
    val is_ident: bool = par_kind == TOK_IDENT
    val is_self: bool = par_kind == TOK_KW_SELF
    val is_valid: bool = is_ident or is_self
    if is_valid:
        parser_advance()
    else:
        parser_error("expected parameter name")
        parser_advance()

# ===== Generic Type Parameter Parsing =====

fn parse_type_params() -> [text]:
    # Parses <T>, <T, U>, etc. after function/class/struct name
    # Returns list of type parameter names (e.g., ["T", "U"])
    var type_params: [text] = []

    # Check for < token (either TOK_LT or TOK_LT_GENERIC)
    val has_lt: bool = par_kind == TOK_LT
    val has_lt_gen: bool = par_kind == TOK_LT_GENERIC
    val has_generic: bool = has_lt or has_lt_gen
    if not has_generic:
        return type_params

    parser_advance()

    # Parse first type parameter
    if par_kind != TOK_IDENT:
        parser_error("expected type parameter name")
        return type_params

    type_params.push(par_text)
    parser_advance()

    # Parse additional type parameters
    for i in 0..100:
        if par_kind != TOK_COMMA:
            break
        parser_advance()
        if par_kind != TOK_IDENT:
            parser_error("expected type parameter name")
            break
        type_params.push(par_text)
        parser_advance()

    # Expect closing >
    parser_expect(TOK_GT)

    type_params

# ===== Function Declarations =====

fn parse_fn_decl(is_async: i64) -> i64:
    parser_advance()
    val fn_name = par_text
    parser_expect(TOK_IDENT)

    # Parse optional type parameters: fn name<T, U>(...)
    val type_params = parse_type_params()

    parser_expect(TOK_LPAREN)

    var param_names: [text] = []
    var param_types: [i64] = []

    if par_kind != TOK_RPAREN:
        # First parameter (skip ~ keyword-only marker if present)
        parser_skip_tilde_if_present()
        val pname = par_text
        parser_expect_param_name()
        param_names.push(pname)
        var ptype = 0
        if par_kind == TOK_COLON:
            parser_advance()
            ptype = parser_parse_type_with_union()
        param_types.push(ptype)

        for i in 0..100:
            if par_kind != TOK_COMMA:
                break
            parser_advance()
            if par_kind == TOK_RPAREN:
                break
            parser_skip_tilde_if_present()
            val pn = par_text
            parser_expect_param_name()
            param_names.push(pn)
            var pt = 0
            if par_kind == TOK_COLON:
                parser_advance()
                pt = parser_parse_type_with_union()
            param_types.push(pt)

    parser_expect(TOK_RPAREN)

    # Return type
    var ret_type = TYPE_VOID
    if par_kind == TOK_ARROW:
        parser_advance()
        ret_type = parser_parse_type_with_union()

    # Skip optional where clause: where T: Bound
    if par_kind == TOK_KW_WHERE:
        parser_advance()
        # Skip until the body colon
        for where_i in 0..200:
            val at_colon: bool = par_kind == TOK_COLON
            val at_eof: bool = par_kind == TOK_EOF
            if at_colon or at_eof:
                break
            parser_advance()

    # Function body
    parser_expect(TOK_COLON)
    val body = parse_block()

    decl_fn(fn_name, param_names, param_types, ret_type, body, is_async, type_params, 0)

fn parse_extern_fn_decl() -> i64:
    # Already consumed 'extern'
    parser_expect(TOK_KW_FN)
    val fn_name = par_text
    parser_expect(TOK_IDENT)

    # Parse optional type parameters: extern fn name<T>(...)
    val type_params = parse_type_params()

    parser_expect(TOK_LPAREN)

    var param_names: [text] = []
    var param_types: [i64] = []

    if par_kind != TOK_RPAREN:
        val pname = par_text
        parser_expect_param_name()
        param_names.push(pname)
        var ptype = 0
        if par_kind == TOK_COLON:
            parser_advance()
            ptype = parser_parse_type()
        param_types.push(ptype)

        for i in 0..100:
            if par_kind != TOK_COMMA:
                break
            parser_advance()
            if par_kind == TOK_RPAREN:
                break
            val pn = par_text
            parser_expect_param_name()
            param_names.push(pn)
            var pt = 0
            if par_kind == TOK_COLON:
                parser_advance()
                pt = parser_parse_type()
            param_types.push(pt)

    parser_expect(TOK_RPAREN)

    var ret_type = TYPE_VOID
    if par_kind == TOK_ARROW:
        parser_advance()
        ret_type = parser_parse_type()

    decl_extern_fn(fn_name, param_names, param_types, ret_type, type_params, 0)

# ===== Struct/Class Declarations =====

fn parse_struct_decl() -> i64:
    parser_advance()
    val struct_name = par_text
    parser_expect(TOK_IDENT)
    par_struct_names.push(struct_name)

    # Parse optional type parameters: class Box<T>:, struct Node<T>:
    val type_params = parse_type_params()

    # Pre-register struct name so type references resolve during parsing
    named_type_register(struct_name, [], [])
    # Handle struct inheritance: struct X(Parent):
    if par_kind == TOK_LPAREN:
        parser_advance()
        # Skip parent type name(s)
        for i in 0..10:
            if par_kind == TOK_RPAREN:
                break
            parser_advance()
        parser_expect(TOK_RPAREN)
    # Handle "with" mixin: struct X with Y:
    if par_kind == TOK_IDENT:
        if par_text == "with":
            parser_advance()
            parser_expect(TOK_IDENT)
    parser_expect(TOK_COLON)
    parser_skip_newlines()
    parser_expect(TOK_INDENT)

    var field_names: [text] = []
    var field_types: [i64] = []
    var field_defaults: [i64] = []
    var class_method_ids: [i64] = []

    for i in 0..1000:
        parser_skip_newlines()
        if par_kind == TOK_DEDENT:
            parser_advance()
            break
        if par_kind == TOK_EOF:
            break

        # Skip docstrings in class/struct body
        if par_kind == TOK_STRING_LIT:
            parser_advance()
            parser_skip_newlines_and_semicolons()
            continue

        # Associated types: type Item = T (skip for now, just parse and ignore)
        if par_kind == TOK_KW_TYPE:
            parser_advance()
            # Skip: 'type IDENT' or 'type IDENT = Type'
            if par_kind == TOK_IDENT:
                parser_advance()
            if par_kind == TOK_ASSIGN:
                parser_advance()
                parser_parse_type()
            parser_skip_newlines_and_semicolons()
            continue

        # Handle methods in class/struct body
        if par_kind == TOK_KW_STATIC:
            val sm_id = parse_class_body_method(struct_name, true, false)
            if sm_id >= 0:
                class_method_ids.push(sm_id)
            continue
        if par_kind == TOK_KW_FN:
            val fm_id = parse_class_body_method(struct_name, false, false)
            if fm_id >= 0:
                class_method_ids.push(fm_id)
            continue
        if par_kind == TOK_KW_ME:
            val mm_id = parse_class_body_method(struct_name, false, true)
            if mm_id >= 0:
                class_method_ids.push(mm_id)
            continue

        val fname = par_text
        parser_expect(TOK_IDENT)
        parser_expect(TOK_COLON)
        val ftype = parser_parse_type()
        field_names.push(fname)
        field_types.push(ftype)
        var fdefault: i64 = -1
        if par_kind == TOK_ASSIGN:
            parser_advance()
            fdefault = parse_expr()
        field_defaults.push(fdefault)
        parser_skip_newlines_and_semicolons()

    val struct_d = decl_struct_def(struct_name, field_names, field_types, field_defaults, 0)

    # If class had methods, create an impl block for them
    if class_method_ids.len() > 0:
        val impl_d = decl_impl_block(struct_name, class_method_ids, 0)
        module_add_decl(impl_d)

    struct_d

fn parse_enum_decl() -> i64:
    parser_advance()
    val enum_name = par_text
    parser_expect(TOK_IDENT)

    # Parse optional type parameters: enum Result<T, E>:
    val type_params = parse_type_params()

    parser_expect(TOK_COLON)
    parser_skip_newlines()
    parser_expect(TOK_INDENT)

    var variant_names: [text] = []

    for i in 0..1000:
        parser_skip_newlines()
        if par_kind == TOK_DEDENT:
            parser_advance()
            break
        if par_kind == TOK_EOF:
            break

        # Skip docstrings in enum body
        if par_kind == TOK_STRING_LIT:
            parser_advance()
            parser_skip_newlines_and_semicolons()
            continue

        # Skip comments that may appear as idents
        val vname = par_text
        parser_expect(TOK_IDENT)
        # Handle enum variant data: Variant(field: type, ...)
        if par_kind == TOK_LPAREN:
            parser_advance()
            for j in 0..100:
                if par_kind == TOK_RPAREN:
                    break
                if par_kind == TOK_EOF:
                    break
                # Skip field_name: type pairs
                if par_kind == TOK_IDENT:
                    parser_advance()
                    if par_kind == TOK_COLON:
                        parser_advance()
                        parser_parse_type()
                        # Handle optional ? after type
                        if par_kind == TOK_QUESTION:
                            parser_advance()
                elif par_kind == TOK_LBRACKET:
                    parser_parse_type()
                else:
                    parser_advance()
                if par_kind == TOK_COMMA:
                    parser_advance()
            parser_expect(TOK_RPAREN)
        variant_names.push(vname)
        parser_skip_newlines_and_semicolons()

    decl_enum_def(enum_name, variant_names, 0)

# ===== Top-Level Module Parsing =====

fn parse_module_body():
    for i in 0..100000:
        parser_skip_newlines_and_semicolons()
        if par_kind == TOK_EOF:
            break
        if par_kind == TOK_DEDENT:
            # Stray dedent at module level -- skip it
            parser_advance()
        elif par_kind == TOK_KW_ASYNC:
            # Async function: async fn name()
            parser_advance()
            if par_kind == TOK_KW_FN:
                val d = parse_fn_decl(1)  # 1 = is_async
                module_add_decl(d)
            else:
                parser_error("expected 'fn' after 'async'")
        elif par_kind == TOK_KW_FN:
            val d = parse_fn_decl(0)  # 0 = not async
            module_add_decl(d)
        elif par_kind == TOK_KW_EXTERN:
            parser_advance()
            val d = parse_extern_fn_decl()
            module_add_decl(d)
        elif par_kind == TOK_KW_STRUCT:
            val d = parse_struct_decl()
            module_add_decl(d)
        elif par_kind == TOK_KW_ENUM:
            val d = parse_enum_decl()
            module_add_decl(d)
        elif par_kind == TOK_KW_CLASS:
            # class is treated like struct (fields + methods)
            val d = parse_struct_decl()
            module_add_decl(d)
        elif par_kind == TOK_KW_IMPL:
            val d = parse_impl_decl()
            module_add_decl(d)
        elif par_kind == TOK_KW_USE:
            val d = parse_use_decl()
            module_add_decl(d)
        elif par_kind == TOK_KW_EXPORT:
            val d = parse_export_decl()
            module_add_decl(d)
        elif par_kind == TOK_KW_VAL:
            val d = parse_val_decl()
            module_add_decl(d)
        elif par_kind == TOK_KW_LAZY:
            parser_advance()
            val d = parse_lazy_val_decl()
            module_add_decl(d)
        elif par_kind == TOK_KW_VAR:
            val d = parse_var_decl()
            module_add_decl(d)
        elif par_kind == TOK_KW_CONST:
            # const fn name(): or const binding: same as val/fn at module level
            parser_advance()
            if par_kind == TOK_KW_FN:
                # const fn -- parse as normal function
                val cfd = parse_fn_decl(0)
                module_add_decl(cfd)
            else:
                val const_name = par_text
                parser_expect(TOK_IDENT)
                var const_type = 0
                if par_kind == TOK_COLON:
                    parser_advance()
                    const_type = parser_parse_type_with_union()
                parser_expect(TOK_ASSIGN)
                val const_init = parse_expr()
                val cd = decl_val_binding(const_name, const_type, const_init, 0)
                module_add_decl(cd)
        elif par_kind == TOK_KW_IF:
            val if_expr = parse_if_expr()
            val d = decl_val_binding("_if_" + int_to_str(i), -1, if_expr, 0)
            module_add_decl(d)
        elif par_kind == TOK_KW_FOR:
            val for_expr = parse_for_expr()
            val d = decl_val_binding("_for_" + int_to_str(i), -1, for_expr, 0)
            module_add_decl(d)
        elif par_kind == TOK_KW_WHILE:
            val while_expr = parse_while_expr()
            val d = decl_val_binding("_while_" + int_to_str(i), -1, while_expr, 0)
            module_add_decl(d)
        elif par_kind == TOK_KW_IMPORT:
            # import X.{Y, Z} -- treat like use
            val d = parse_use_decl()
            module_add_decl(d)
        elif par_kind == TOK_KW_TRAIT:
            # trait is parsed like struct (skip body)
            val d = parse_struct_decl()
            module_add_decl(d)
        elif par_kind == TOK_KW_EXTEND:
            # extend TypeName: adds methods to an existing type
            val d = parse_impl_decl()
            module_add_decl(d)
        elif par_kind == TOK_KW_CE:
            # ce NAME: computation expression block at module level
            parser_advance()
            val ce_d = parse_ce_decl()
            module_add_decl(ce_d)
        elif par_kind == TOK_KW_NEWTYPE:
            # newtype Meters = i64 -- wrapper struct with single 'value' field
            parser_advance()
            val nt_name = par_text
            parser_expect(TOK_IDENT)
            parser_expect(TOK_ASSIGN)
            val inner_type = parser_parse_type()
            val nt_field_names: [text] = ["value"]
            val nt_field_types: [i64] = [inner_type]
            val nt_field_defaults: [i64] = [-1]
            val nt_d = decl_struct_def(nt_name, nt_field_names, nt_field_types, nt_field_defaults, 0)
            module_add_decl(nt_d)
            parser_skip_newlines_and_semicolons()
        elif par_kind == TOK_STRING_LIT:
            # Skip module-level docstrings
            parser_advance()
            parser_skip_newlines_and_semicolons()
        elif par_kind == TOK_KW_TYPE:
            # Type alias: type X = Y -- skip it
            parser_advance()
            # Skip until newline
            for j in 0..1000:
                val type_is_nl: bool = par_kind == TOK_NEWLINE
                val type_is_ded: bool = par_kind == TOK_DEDENT
                val type_is_eof: bool = par_kind == TOK_EOF
                val type_done: bool = type_is_nl or type_is_ded
                val type_done2: bool = type_done or type_is_eof
                if type_done2:
                    break
                parser_advance()
            parser_skip_newlines_and_semicolons()
        elif par_kind == TOK_KW_ASM:
            val asm_expr = parse_expr()
            val d = decl_val_binding("_asm_" + int_to_str(i), -1, asm_expr, 0)
            module_add_decl(d)
            parser_skip_newlines_and_semicolons()
        elif par_kind == TOK_INDENT:
            # Stray indent at module level -- skip it
            parser_advance()
        else:
            # Handle bare 'print' and 'from' at module level
            if par_kind == TOK_IDENT:
                if par_text == "from":
                    # from X import {Y, Z}
                    parser_advance()
                    var from_path: text = ""
                    if par_kind == TOK_IDENT:
                        from_path = par_text
                        parser_advance()
                    for j in 0..100:
                        if par_kind != TOK_DOT:
                            break
                        parser_advance()
                        if par_kind == TOK_IDENT:
                            from_path = from_path + "." + par_text
                            parser_advance()
                        else:
                            break
                    # Expect 'import' keyword
                    if par_kind == TOK_KW_IMPORT:
                        parser_advance()
                    # Parse import list {name1, name2}
                    var from_names: [text] = []
                    val from_has_brace: bool = par_kind == TOK_LBRACE
                    val from_has_paren: bool = par_kind == TOK_LPAREN
                    val from_has_list: bool = from_has_brace or from_has_paren
                    if from_has_list:
                        parser_advance()
                        for j in 0..100:
                            val from_at_end1: bool = par_kind == TOK_RBRACE
                            val from_at_end2: bool = par_kind == TOK_RPAREN
                            val from_at_end: bool = from_at_end1 or from_at_end2
                            if from_at_end:
                                break
                            if par_kind == TOK_EOF:
                                break
                            if par_kind == TOK_IDENT:
                                from_names.push(par_text)
                                parser_advance()
                            if par_kind == TOK_COMMA:
                                parser_advance()
                        parser_advance()
                    val fd = decl_use_import(from_path, from_names, 0)
                    module_add_decl(fd)
                    parser_skip_newlines_and_semicolons()
                elif par_text == "comptime":
                    # comptime val name = expr -- evaluated eagerly (treat like val)
                    parser_advance()
                    if par_kind == TOK_KW_VAL or par_kind == TOK_KW_VAR:
                        val d = parse_val_decl()
                        module_add_decl(d)
                    elif par_kind == TOK_KW_FN:
                        val ctfd = parse_fn_decl(0)
                        decl_set_comptime(ctfd)
                        module_add_decl(ctfd)
                    elif par_kind == TOK_COLON:
                        # comptime: block at module level -- wrap body stmts in an expr_block
                        parser_advance()
                        val ct_blk_body = parse_block()
                        val ct_blk_unit = expr_unit(0)
                        val ct_blk_expr = expr_block(ct_blk_body, ct_blk_unit, 0)
                        val ctbd = decl_val_binding("_ct_blk_" + int_to_str(i), -1, ct_blk_expr, 0)
                        module_add_decl(ctbd)
                    else:
                        val ct_expr = parse_expr()
                        val ctd = decl_val_binding("_ct_" + int_to_str(i), -1, ct_expr, 0)
                        module_add_decl(ctd)
                    parser_skip_newlines_and_semicolons()
                elif par_text == "print":
                    parser_advance()
                    val is_nl = par_kind == TOK_NEWLINE
                    val is_ded = par_kind == TOK_DEDENT
                    val is_eof = par_kind == TOK_EOF
                    val no_arg = is_nl or is_ded
                    val no_arg2 = no_arg or is_eof
                    var print_call: i64 = 0
                    if no_arg2:
                        val callee0 = expr_ident("print", 0)
                        var args0: [i64] = []
                        print_call = expr_call(callee0, args0, 0)
                    else:
                        val print_arg = parse_expr()
                        val callee1 = expr_ident("print", 0)
                        var args1: [i64] = []
                        args1.push(print_arg)
                        print_call = expr_call(callee1, args1, 0)
                    val d = decl_val_binding("_expr_" + int_to_str(i), -1, print_call, 0)
                    module_add_decl(d)
                    parser_skip_newlines_and_semicolons()
                else:
                    val expression = parse_expr()
                    val d = decl_val_binding("_expr_" + int_to_str(i), -1, expression, 0)
                    module_add_decl(d)
                    parser_skip_newlines_and_semicolons()
            else:
                # Module-level expression/statement
                val expression = parse_expr()
                val d = decl_val_binding("_expr_" + int_to_str(i), -1, expression, 0)
                module_add_decl(d)
                parser_skip_newlines_and_semicolons()

# ===== Exports =====

export parse_fn_decl, parse_extern_fn_decl, parse_struct_decl, parse_enum_decl
export parse_impl_decl, parse_class_body_method
export parse_use_decl, parse_export_decl, parse_val_decl, parse_lazy_val_decl, parse_var_decl
export parse_ce_decl
export parse_module_body
export parse_type_params
