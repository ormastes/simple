# Static Test Analyzer
#
# Extracts test metadata from source without executing DSL code.
# Enables fast test listing for large test suites.
#
# Port of rust/parser/src/test_analyzer.rs (511 lines)

export TestKind, TestMeta, TestGroupMeta, FileTestMeta
export extract_file_test_meta, extract_tests_from_source

# ============================================================================
# Test Metadata Types
# ============================================================================

enum TestKind:
    Normal
    Slow
    Skipped
    Ignored

struct TestMeta:
    description: text
    kind: TestKind
    line: i64
    tags: [text]
    group_path: [text]      # ["Math operations", "addition"]

impl TestMeta:
    static fn new(description: text, line: i64, kind: TestKind) -> TestMeta:
        TestMeta(description: description, kind: kind, line: line,
                 tags: [], group_path: [])

    fn with_tags(tags: [text]) -> TestMeta:
        TestMeta(description: self.description, kind: self.kind,
                 line: self.line, tags: tags, group_path: self.group_path)

    fn with_group_path(path: [text]) -> TestMeta:
        TestMeta(description: self.description, kind: self.kind,
                 line: self.line, tags: self.tags, group_path: path)

    fn full_name() -> text:
        """Get full test name including group path."""
        if self.group_path.?:
            self.group_path.join(" > ") + " > " + self.description
        else:
            self.description

    fn is_slow() -> bool:
        match self.kind: case Slow: true; case _: false

    fn is_skipped() -> bool:
        match self.kind: case Skipped: true; case Ignored: true; case _: false

struct TestGroupMeta:
    name: text
    line: i64
    tests: [TestMeta]
    children: [TestGroupMeta]

impl TestGroupMeta:
    static fn new(name: text, line: i64) -> TestGroupMeta:
        TestGroupMeta(name: name, line: line, tests: [], children: [])

    fn add_test(test: TestMeta) -> TestGroupMeta:
        TestGroupMeta(name: self.name, line: self.line,
                      tests: self.tests.push(test), children: self.children)

    fn add_child(child: TestGroupMeta) -> TestGroupMeta:
        TestGroupMeta(name: self.name, line: self.line,
                      tests: self.tests, children: self.children.push(child))

    fn all_tests() -> [TestMeta]:
        """Get all tests including from child groups."""
        var result = self.tests
        for child in self.children:
            result = result.merge(child.all_tests())
        result

    fn test_count() -> i64:
        self.all_tests().len()

struct FileTestMeta:
    file_path: text?
    groups: [TestGroupMeta]
    top_level_tests: [TestMeta]

impl FileTestMeta:
    static fn empty() -> FileTestMeta:
        FileTestMeta(file_path: nil, groups: [], top_level_tests: [])

    static fn for_file(path: text) -> FileTestMeta:
        FileTestMeta(file_path: Some(path), groups: [], top_level_tests: [])

    fn add_group(group: TestGroupMeta) -> FileTestMeta:
        FileTestMeta(file_path: self.file_path,
                     groups: self.groups.push(group),
                     top_level_tests: self.top_level_tests)

    fn add_test(test: TestMeta) -> FileTestMeta:
        FileTestMeta(file_path: self.file_path, groups: self.groups,
                     top_level_tests: self.top_level_tests.push(test))

    fn all_tests() -> [TestMeta]:
        var result = self.top_level_tests
        for group in self.groups:
            result = result.merge(group.all_tests())
        result

    fn test_count() -> i64:
        self.all_tests().len()

    fn slow_count() -> i64:
        var count = 0
        for t in self.all_tests():
            if t.is_slow():
                count = count + 1
        count

    fn skipped_count() -> i64:
        var count = 0
        for t in self.all_tests():
            if t.is_skipped():
                count = count + 1
        count

# ============================================================================
# DSL Function Names
# ============================================================================

val TEST_FUNCTIONS = ["it", "test", "example", "specify"]
val SLOW_TEST_FUNCTIONS = ["slow_it", "slow_test"]
val SKIP_TEST_FUNCTIONS = ["skip_it", "skip", "skip_test", "pending"]
val IGNORE_TEST_FUNCTIONS = ["ignore_it", "ignore_test", "ignored"]
val GROUP_FUNCTIONS = ["describe", "context", "feature", "scenario"]

# ============================================================================
# Source-Level Test Extraction
# ============================================================================

fn extract_tests_from_source(source: text, file_path: text?) -> FileTestMeta:
    """Extract test metadata from source without full AST parsing.

    Uses line-by-line analysis to detect test DSL calls.
    Fast and tolerant of syntax errors.
    """
    var meta: FileTestMeta
    if file_path.?:
        meta = FileTestMeta.for_file(file_path.unwrap())
    else:
        meta = FileTestMeta.empty()

    val lines = source.split("\n")
    var group_stack: [TestGroupMeta] = []
    var group_path: [text] = []
    var indent_stack: [i64] = []
    var pending_tags: [text] = []

    var line_num = 0
    while line_num < lines.len():
        val line = lines[line_num]
        val trimmed = line.trim()
        val indent = count_leading_spaces(line)

        # Collect tag comments
        if trimmed.starts_with("# @"):
            val tag = trimmed[3:].trim()
            pending_tags = pending_tags.push(tag)
            line_num = line_num + 1
            continue

        # Pop groups when indentation decreases
        while indent_stack.? and indent <= indent_stack[indent_stack.len() - 1]:
            indent_stack = indent_stack[:indent_stack.len() - 1]
            if group_stack.?:
                val completed = group_stack[group_stack.len() - 1]
                group_stack = group_stack[:group_stack.len() - 1]
                group_path = group_path[:group_path.len() - 1]
                if group_stack.?:
                    val parent_idx = group_stack.len() - 1
                    group_stack[parent_idx] = group_stack[parent_idx].add_child(completed)
                else:
                    meta = meta.add_group(completed)

        # Try to parse a DSL call
        val call = try_parse_dsl_call(trimmed)
        if call.?:
            val (func_name, description) = call.unwrap()

            if TEST_FUNCTIONS.contains(func_name):
                val test = TestMeta.new(description, line_num + 1, TestKind.Normal)
                    .with_tags(pending_tags).with_group_path(group_path)
                if group_stack.?:
                    val idx = group_stack.len() - 1
                    group_stack[idx] = group_stack[idx].add_test(test)
                else:
                    meta = meta.add_test(test)

            elif SLOW_TEST_FUNCTIONS.contains(func_name):
                val test = TestMeta.new(description, line_num + 1, TestKind.Slow)
                    .with_tags(pending_tags).with_group_path(group_path)
                if group_stack.?:
                    val idx = group_stack.len() - 1
                    group_stack[idx] = group_stack[idx].add_test(test)
                else:
                    meta = meta.add_test(test)

            elif SKIP_TEST_FUNCTIONS.contains(func_name):
                val test = TestMeta.new(description, line_num + 1, TestKind.Skipped)
                    .with_tags(pending_tags).with_group_path(group_path)
                if group_stack.?:
                    val idx = group_stack.len() - 1
                    group_stack[idx] = group_stack[idx].add_test(test)
                else:
                    meta = meta.add_test(test)

            elif IGNORE_TEST_FUNCTIONS.contains(func_name):
                val test = TestMeta.new(description, line_num + 1, TestKind.Ignored)
                    .with_tags(pending_tags).with_group_path(group_path)
                if group_stack.?:
                    val idx = group_stack.len() - 1
                    group_stack[idx] = group_stack[idx].add_test(test)
                else:
                    meta = meta.add_test(test)

            elif GROUP_FUNCTIONS.contains(func_name):
                val group = TestGroupMeta.new(description, line_num + 1)
                group_stack = group_stack.push(group)
                group_path = group_path.push(description)
                indent_stack = indent_stack.push(indent)

        pending_tags = []
        line_num = line_num + 1

    # Flush remaining groups
    while group_stack.?:
        val completed = group_stack[group_stack.len() - 1]
        group_stack = group_stack[:group_stack.len() - 1]
        if group_stack.?:
            val idx = group_stack.len() - 1
            group_stack[idx] = group_stack[idx].add_child(completed)
        else:
            meta = meta.add_group(completed)

    meta

fn extract_file_test_meta(source: text, file_path: text?) -> FileTestMeta:
    """Main entry point for static test analysis."""
    extract_tests_from_source(source, file_path)

fn try_parse_dsl_call(trimmed: text) -> (text, text)?:
    """Try to parse a DSL function call like `it "description":`.

    Returns (function_name, description) if found.
    """
    # Find first space (function name boundary)
    val space_idx = trimmed.find(" ")
    if not space_idx.?:
        return nil

    val func_name = trimmed[:space_idx.unwrap()]
    val rest = trimmed[space_idx.unwrap() + 1:]

    # Check if it's a known DSL function
    val all_dsl = TEST_FUNCTIONS.merge(SLOW_TEST_FUNCTIONS)
        .merge(SKIP_TEST_FUNCTIONS).merge(IGNORE_TEST_FUNCTIONS)
        .merge(GROUP_FUNCTIONS)
    if not all_dsl.contains(func_name):
        return nil

    # Extract string description
    val desc = extract_string_literal(rest)
    if desc.?:
        return Some((func_name, desc.unwrap()))

    nil

fn extract_string_literal(s: text) -> text?:
    """Extract a quoted string from the beginning of text."""
    val trimmed = s.trim()
    if trimmed.len() < 2:
        return nil
    if trimmed[0] != '"':
        return nil

    var end = 1
    while end < trimmed.len():
        if trimmed[end] == '\\':
            end = end + 2
            continue
        if trimmed[end] == '"':
            return Some(trimmed[1:end])
        end = end + 1

    nil

fn count_leading_spaces(line: text) -> i64:
    var count = 0
    while count < line.len() and line[count] == ' ':
        count = count + 1
    count
