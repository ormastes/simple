# TreeSitter Heuristic - Line-Based Error-Tolerant Fallback Parsing
#
# Provides fallback parsing when tree-sitter fails or for quick IDE features.
# Uses simple line scanning and pattern matching instead of full tokenization.
# Always produces results, even with syntax errors.

use compiler.lexer.*
use treesitter_types.*

# ============================================================================
# Heuristic Mode Types (for line-based error-tolerant parsing)
# ============================================================================

enum HeuristicOutlineKind:
    """Outline kind for heuristic parsing mode."""
    Function
    Method
    StaticMethod
    MutableMethod       # me fn()
    Class
    Struct
    Enum
    EnumVariant
    Trait
    Impl
    Module
    Import
    Export
    Val
    Var
    Const
    TypeAlias

struct HeuristicOutlineItem:
    """Lightweight outline item for heuristic parsing."""
    kind: HeuristicOutlineKind
    name: text
    line: i64
    column: i64
    end_line: i64
    visibility: text        # "pub", "pub(mod)", or ""
    parent: text?           # impl target or module name
    signature: text?        # fn signature or type annotation
    children: [HeuristicOutlineItem]

impl HeuristicOutlineItem:
    static fn new(kind: HeuristicOutlineKind, name: text, line: i64, column: i64) -> HeuristicOutlineItem:
        HeuristicOutlineItem(kind: kind, name: name, line: line, column: column,
                             end_line: line, visibility: "", parent: nil,
                             signature: nil, children: [])

    fn with_visibility(vis: text) -> HeuristicOutlineItem:
        HeuristicOutlineItem(kind: self.kind, name: self.name, line: self.line,
                             column: self.column, end_line: self.end_line,
                             visibility: vis, parent: self.parent,
                             signature: self.signature, children: self.children)

    fn with_parent(parent: text) -> HeuristicOutlineItem:
        HeuristicOutlineItem(kind: self.kind, name: self.name, line: self.line,
                             column: self.column, end_line: self.end_line,
                             visibility: self.visibility, parent: Some(parent),
                             signature: self.signature, children: self.children)

    fn with_signature(sig: text) -> HeuristicOutlineItem:
        HeuristicOutlineItem(kind: self.kind, name: self.name, line: self.line,
                             column: self.column, end_line: self.end_line,
                             visibility: self.visibility, parent: self.parent,
                             signature: Some(sig), children: self.children)

# ============================================================================
# Heuristic Parse Result
# ============================================================================

struct HeuristicParseResult:
    """Result of parsing a declaration in heuristic mode."""
    items: [HeuristicOutlineItem]
    impl_target: text?

# ============================================================================
# Heuristic Parsing Implementation
# ============================================================================

# Extension to TreeSitter for heuristic mode parsing
impl TreeSitter:
    me parse_outline_heuristic() -> OutlineModule:
        """Parse outline using line-based heuristics (error-tolerant).

        Uses simple line scanning and pattern matching instead of full tokenization.
        Always produces results, even with syntax errors.
        """
        val lines = self.lexer.source.split("\n")
        var items: [HeuristicOutlineItem] = []
        var current_impl_target: text? = nil
        var line_num = 0

        while line_num < lines.len():
            val line = lines[line_num]
            val trimmed = line.trim()
            val indent = self.heuristic_indent_level(line)

            # Skip empty lines and comments
            if trimmed.len() == 0 or (trimmed.len() > 0 and trimmed[0] == '#'):
                line_num = line_num + 1
                continue

            # Top-level declarations (indent 0)
            if indent == 0:
                current_impl_target = nil
                val result = self.heuristic_parse_declaration(trimmed, line_num + 1, indent, items, current_impl_target)
                items = result.items
                current_impl_target = result.impl_target

            # Nested members (indent 4 inside impl)
            elif indent == 4 and current_impl_target.?:
                items = self.heuristic_parse_member(trimmed, line_num + 1, items, current_impl_target.unwrap())

            line_num = line_num + 1

        # Convert lightweight items to rich OutlineModule
        self.heuristic_convert_to_module(items)

    me heuristic_parse_declaration(trimmed: text, line: i64, indent: i64,
                                     items: [HeuristicOutlineItem], impl_target: text?) -> HeuristicParseResult:
        """Parse a top-level declaration line (heuristic)."""
        var vis = ""
        var rest = trimmed
        var result_items = items
        var result_impl = impl_target

        # Check visibility
        if rest.starts_with("pub "):
            vis = "pub"
            rest = rest[4:]
        elif rest.starts_with("export "):
            val item = HeuristicOutlineItem.new(HeuristicOutlineKind.Export, rest[7:], line, 1)
            result_items = result_items.push(item)
            return HeuristicParseResult(items: result_items, impl_target: result_impl)

        # Match declaration keyword
        if rest.starts_with("fn "):
            val name = self.heuristic_extract_name(rest[3:])
            val sig = self.heuristic_extract_until_colon(rest)
            val item = HeuristicOutlineItem.new(HeuristicOutlineKind.Function, name, line, indent + 1)
                .with_visibility(vis).with_signature(sig)
            result_items = result_items.push(item)

        elif rest.starts_with("me "):
            val name = self.heuristic_extract_name(rest[3:])
            val sig = self.heuristic_extract_until_colon(rest)
            val item = HeuristicOutlineItem.new(HeuristicOutlineKind.MutableMethod, name, line, indent + 1)
                .with_visibility(vis).with_signature(sig)
            result_items = result_items.push(item)

        elif rest.starts_with("class "):
            val name = self.heuristic_extract_name(rest[6:])
            val item = HeuristicOutlineItem.new(HeuristicOutlineKind.Class, name, line, indent + 1)
                .with_visibility(vis)
            result_items = result_items.push(item)

        elif rest.starts_with("struct "):
            val name = self.heuristic_extract_name(rest[7:])
            val item = HeuristicOutlineItem.new(HeuristicOutlineKind.Struct, name, line, indent + 1)
                .with_visibility(vis)
            result_items = result_items.push(item)

        elif rest.starts_with("enum "):
            val name = self.heuristic_extract_name(rest[5:])
            val item = HeuristicOutlineItem.new(HeuristicOutlineKind.Enum, name, line, indent + 1)
                .with_visibility(vis)
            result_items = result_items.push(item)

        elif rest.starts_with("trait "):
            val name = self.heuristic_extract_name(rest[6:])
            val item = HeuristicOutlineItem.new(HeuristicOutlineKind.Trait, name, line, indent + 1)
                .with_visibility(vis)
            result_items = result_items.push(item)

        elif rest.starts_with("impl "):
            val name = self.heuristic_extract_name(rest[5:])
            result_impl = Some(name)
            val item = HeuristicOutlineItem.new(HeuristicOutlineKind.Impl, name, line, indent + 1)
                .with_visibility(vis)
            result_items = result_items.push(item)

        elif rest.starts_with("mod "):
            val name = self.heuristic_extract_name(rest[4:])
            val item = HeuristicOutlineItem.new(HeuristicOutlineKind.Module, name, line, indent + 1)
                .with_visibility(vis)
            result_items = result_items.push(item)

        elif rest.starts_with("val "):
            val name = self.heuristic_extract_name(rest[4:])
            val item = HeuristicOutlineItem.new(HeuristicOutlineKind.Val, name, line, indent + 1)
                .with_visibility(vis)
            result_items = result_items.push(item)

        elif rest.starts_with("var "):
            val name = self.heuristic_extract_name(rest[4:])
            val item = HeuristicOutlineItem.new(HeuristicOutlineKind.Var, name, line, indent + 1)
                .with_visibility(vis)
            result_items = result_items.push(item)

        elif rest.starts_with("import ") or rest.starts_with("use "):
            val keyword_len = if rest.starts_with("import ") { 7 } else { 4 }
            val item = HeuristicOutlineItem.new(HeuristicOutlineKind.Import, rest[keyword_len:], line, indent + 1)
            result_items = result_items.push(item)

        HeuristicParseResult(items: result_items, impl_target: result_impl)

    me heuristic_parse_member(trimmed: text, line: i64, items: [HeuristicOutlineItem], target: text) -> [HeuristicOutlineItem]:
        """Parse a member inside an impl block."""
        var vis = ""
        var rest = trimmed
        var result_items = items

        if rest.starts_with("pub "):
            vis = "pub"
            rest = rest[4:]

        if rest.starts_with("fn "):
            val name = self.heuristic_extract_name(rest[3:])
            val sig = self.heuristic_extract_until_colon(rest)
            val item = HeuristicOutlineItem.new(HeuristicOutlineKind.Method, name, line, 5)
                .with_visibility(vis).with_parent(target).with_signature(sig)
            result_items = result_items.push(item)

        elif rest.starts_with("static fn "):
            val name = self.heuristic_extract_name(rest[10:])
            val sig = self.heuristic_extract_until_colon(rest)
            val item = HeuristicOutlineItem.new(HeuristicOutlineKind.StaticMethod, name, line, 5)
                .with_visibility(vis).with_parent(target).with_signature(sig)
            result_items = result_items.push(item)

        elif rest.starts_with("me "):
            val name = self.heuristic_extract_name(rest[3:])
            val sig = self.heuristic_extract_until_colon(rest)
            val item = HeuristicOutlineItem.new(HeuristicOutlineKind.MutableMethod, name, line, 5)
                .with_visibility(vis).with_parent(target).with_signature(sig)
            result_items = result_items.push(item)

        result_items

    fn heuristic_extract_name(s: text) -> text:
        """Extract identifier name from start of string."""
        var end = 0
        while end < s.len():
            val ch = s[end]
            # Check if character is alphanumeric or underscore
            val is_valid = (ch >= 'a' and ch <= 'z') or (ch >= 'A' and ch <= 'Z') or (ch >= '0' and ch <= '9') or ch == '_'
            if is_valid:
                end = end + 1
            else:
                break
        if end == 0: "<unknown>" else: s[:end]

    fn heuristic_extract_until_colon(s: text) -> text:
        """Extract text up to (but not including) the trailing colon."""
        val idx = s.rfind(":")
        if idx.?: s[:idx.unwrap()].trim() else: s.trim()

    fn heuristic_indent_level(line: text) -> i64:
        """Count leading spaces."""
        var count = 0
        while count < line.len() and line[count] == ' ':
            count = count + 1
        count

    me heuristic_convert_to_module(items: [HeuristicOutlineItem]) -> OutlineModule:
        """Convert lightweight OutlineItem list to rich OutlineModule."""
        var functions: [FunctionOutline] = []
        var classes: [ClassOutline] = []
        var structs: [StructOutline] = []
        var enums: [EnumOutline] = []
        var traits: [TraitOutline] = []
        var impls: [ImplOutline] = []
        var imports: [ImportOutline] = []
        var exports: [ExportOutline] = []
        var type_aliases: [TypeAliasOutline] = []
        var constants: [ConstOutline] = []

        for item in items:
            match item.kind:
                case HeuristicOutlineKind.Function | HeuristicOutlineKind.Method | HeuristicOutlineKind.StaticMethod:
                    functions = functions.push(self.heuristic_item_to_function(item))
                case HeuristicOutlineKind.Class:
                    classes = classes.push(self.heuristic_item_to_class(item))
                case HeuristicOutlineKind.Struct:
                    structs = structs.push(self.heuristic_item_to_struct(item))
                case HeuristicOutlineKind.Enum:
                    enums = enums.push(self.heuristic_item_to_enum(item))
                case HeuristicOutlineKind.Trait:
                    traits = traits.push(self.heuristic_item_to_trait(item))
                case HeuristicOutlineKind.Impl:
                    impls = impls.push(self.heuristic_item_to_impl(item))
                case HeuristicOutlineKind.Import:
                    imports = imports.push(self.heuristic_item_to_import(item))
                case HeuristicOutlineKind.Export:
                    exports = exports.push(self.heuristic_item_to_export(item))
                case _:
                    pass  # Skip other kinds for now

        OutlineModule(
            name: "",
            imports: imports,
            exports: exports,
            functions: functions,
            classes: classes,
            actors: [],  # Heuristic mode doesn't parse actors yet
            structs: structs,
            enums: enums,
            bitfields: [],  # Heuristic mode doesn't parse bitfields yet
            traits: traits,
            impls: impls,
            type_aliases: type_aliases,
            constants: constants,
            static_asserts: [],  # Heuristic mode doesn't parse static asserts yet
            inline_blocks: [],  # Heuristic mode doesn't track blocks
            errors: []  # Heuristic mode is error-tolerant
        )

    # ========================================================================
    # Conversion Helpers
    # ========================================================================

    me heuristic_item_to_function(item: HeuristicOutlineItem) -> FunctionOutline:
        FunctionOutline(
            name: item.name,
            visibility: self.heuristic_parse_visibility(item.visibility),
            params: [],  # Heuristic mode doesn't parse params
            return_type: nil,
            type_params: [],
            span: Span(start_line: item.line, start_col: item.column,
                       end_line: item.end_line, end_col: 0),
            doc: nil
        )

    me heuristic_item_to_class(item: HeuristicOutlineItem) -> ClassOutline:
        ClassOutline(
            name: item.name,
            visibility: self.heuristic_parse_visibility(item.visibility),
            type_params: [],
            fields: [],
            methods: [],
            span: Span(start_line: item.line, start_col: item.column,
                       end_line: item.end_line, end_col: 0),
            doc: nil
        )

    me heuristic_item_to_struct(item: HeuristicOutlineItem) -> StructOutline:
        StructOutline(
            name: item.name,
            visibility: self.heuristic_parse_visibility(item.visibility),
            type_params: [],
            fields: [],
            span: Span(start_line: item.line, start_col: item.column,
                       end_line: item.end_line, end_col: 0),
            doc: nil
        )

    me heuristic_item_to_enum(item: HeuristicOutlineItem) -> EnumOutline:
        EnumOutline(
            name: item.name,
            visibility: self.heuristic_parse_visibility(item.visibility),
            type_params: [],
            variants: [],
            span: Span(start_line: item.line, start_col: item.column,
                       end_line: item.end_line, end_col: 0),
            doc: nil
        )

    me heuristic_item_to_trait(item: HeuristicOutlineItem) -> TraitOutline:
        TraitOutline(
            name: item.name,
            visibility: self.heuristic_parse_visibility(item.visibility),
            type_params: [],
            methods: [],
            span: Span(start_line: item.line, start_col: item.column,
                       end_line: item.end_line, end_col: 0),
            doc: nil
        )

    me heuristic_item_to_impl(item: HeuristicOutlineItem) -> ImplOutline:
        ImplOutline(
            target: item.name,
            trait_name: nil,
            type_params: [],
            methods: [],
            span: Span(start_line: item.line, start_col: item.column,
                       end_line: item.end_line, end_col: 0),
            doc: nil
        )

    me heuristic_item_to_import(item: HeuristicOutlineItem) -> ImportOutline:
        ImportOutline(
            module_path: item.name,
            items: [],
            alias: nil,
            span: Span(start_line: item.line, start_col: item.column,
                       end_line: item.line, end_col: 0)
        )

    me heuristic_item_to_export(item: HeuristicOutlineItem) -> ExportOutline:
        ExportOutline(
            name: item.name,
            span: Span(start_line: item.line, start_col: item.column,
                       end_line: item.line, end_col: 0)
        )

    fn heuristic_parse_visibility(vis: text) -> Visibility:
        if vis == "pub":
            Visibility.Public
        else:
            Visibility.Private

# ============================================================================
# Exports
# ============================================================================

export HeuristicOutlineKind, HeuristicOutlineItem, HeuristicParseResult
