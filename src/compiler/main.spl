# Simple Compiler - Main Entry Point
#
# Self-hosting compiler for the Simple programming language.
# This is the entry point when running the compiler as a standalone tool.
#
# Usage:
#   simple-compiler [options] <files...>
#   simple-compiler --mode=jit script.spl
#   simple-compiler --mode=aot -o output src/*.spl
#   simple-compiler --check src/
#   simple-compiler --sdn config.sdn

use driver.*

# ------------------------------------------------------------------------------
# Command Line Interface
# ------------------------------------------------------------------------------

struct CliArgs:
    mode: CompileMode
    input_files: [text]
    output_file: text?
    optimize: bool
    debug_info: bool
    verbose: bool
    log_level: i64
    profile: text
    help: bool
    version: bool

    static fn default() -> CliArgs:
        CliArgs(
            mode: CompileMode.Interpret,
            input_files: [],
            output_file: nil,
            optimize: false,
            debug_info: true,
            verbose: false,
            log_level: 4,
            profile: "dev",
            help: false,
            version: false
        )

    fn to_options() -> CompileOptions:
        CompileOptions(
            mode: self.mode,
            input_files: self.input_files,
            output_file: self.output_file,
            optimize: self.optimize,
            debug_info: self.debug_info,
            verbose: self.verbose,
            log_level: self.log_level,
            profile: self.profile
        )

# ------------------------------------------------------------------------------
# Argument Parser
# ------------------------------------------------------------------------------

class ArgParser:
    args: [text]
    pos: i64

    static fn create(args: [text]) -> ArgParser:
        ArgParser(args: args, pos: 0)

    fn has_next() -> bool:
        self.pos < self.args.len()

    me next() -> text?:
        if self.pos >= self.args.len():
            return None
        val arg = self.args[self.pos]
        self.pos = self.pos + 1
        Some(arg)

    me peek() -> text?:
        if self.pos >= self.args.len():
            return None
        Some(self.args[self.pos])

    me parse() -> Result<CliArgs, text>:
        var result = CliArgs.default()

        while self.has_next():
            val arg = self.next().unwrap()

            if arg == "--":
                # End of options marker - rest are positional args
                while self.has_next():
                    val file = self.next().unwrap()
                    var files = result.input_files
                    files.push(file)
                    result.input_files = files
            elif arg.starts_with("--"):
                # Long option
                match self.parse_long_option(arg, result):
                    case Ok(r): result = r
                    case Err(e): return Err(e)
            elif arg.starts_with("-"):
                # Short option
                match self.parse_short_option(arg, result):
                    case Ok(r): result = r
                    case Err(e): return Err(e)
            else:
                # Input file
                var files = result.input_files
                files.push(arg)
                result.input_files = files

        Ok(result)

    me parse_long_option(arg: text, result: CliArgs) -> Result<CliArgs, text>:
        val opt = arg.slice(2, arg.len())

        # Options with values (--option=value or --option value)
        if opt.contains("="):
            val parts = opt.split("=")
            val name = parts[0]
            val value = parts[1]
            return self.apply_option(name, value, result)

        # Boolean flags
        match opt:
            case "help" | "h":
                result.help = true
                return Ok(result)
            case "version" | "V":
                result.version = true
                return Ok(result)
            case "optimize" | "O":
                result.optimize = true
                return Ok(result)
            case "debug" | "g":
                result.debug_info = true
                return Ok(result)
            case "no-debug":
                result.debug_info = false
                return Ok(result)
            case "verbose" | "v":
                result.verbose = true
                return Ok(result)
            case "check":
                result.mode = CompileMode.Check
                return Ok(result)
            case "sdn":
                result.mode = CompileMode.Sdn
                return Ok(result)
            case "interpret":
                result.mode = CompileMode.Interpret
                return Ok(result)
            case "jit":
                result.mode = CompileMode.Jit
                return Ok(result)
            case "aot" | "compile" | "native":
                result.mode = CompileMode.Aot
                return Ok(result)
            case _:
                pass

        # Options requiring a value
        val value = self.next()
        if value.is_none():
            return Err("Option --{opt} requires a value")

        self.apply_option(opt, value.unwrap(), result)

    fn apply_option(name: text, value: text, result: CliArgs) -> Result<CliArgs, text>:
        match name:
            case "mode" | "m":
                val mode = CompileMode.from_text(value)
                if mode.is_none():
                    return Err("Unknown mode: {value}")
                result.mode = mode.unwrap()

            case "output" | "o":
                result.output_file = Some(value)

            case "log-level" | "l":
                val level = value.parse_int()
                if level.is_none():
                    return Err("Invalid log level: {value}")
                result.log_level = level.unwrap()

            case "profile" | "p":
                result.profile = value

            case _:
                return Err("Unknown option: --{name}")

        Ok(result)

    me parse_short_option(arg: text, result: CliArgs) -> Result<CliArgs, text>:
        val opts = arg.slice(1, arg.len())
        var i = 0
        while i < opts.len():
            val c = opts.char_at(i)
            match c:
                case 'h':
                    result.help = true
                case 'V':
                    result.version = true
                case 'O':
                    result.optimize = true
                case 'g':
                    result.debug_info = true
                case 'v':
                    result.verbose = true
                case 'c':
                    result.mode = CompileMode.Aot
                case 'i':
                    result.mode = CompileMode.Interpret
                case 'j':
                    result.mode = CompileMode.Jit
                case 'k':
                    result.mode = CompileMode.Check
                case 's':
                    result.mode = CompileMode.Sdn
                case 'o':
                    # -o requires a value (rest of arg or next arg)
                    if i + 1 < opts.len():
                        result.output_file = Some(opts.slice(i + 1, opts.len()))
                        return Ok(result)
                    else:
                        match self.next():
                            case Some(v):
                                result.output_file = Some(v)
                                return Ok(result)
                            case None:
                                return Err("Option -o requires a value")
                case 'm':
                    # -m requires a value
                    val value = self.next()
                    if value.is_none():
                        return Err("Option -m requires a value")
                    val mode = CompileMode.from_text(value.unwrap())
                    if mode.is_none():
                        return Err("Unknown mode: {value.unwrap()}")
                    result.mode = mode.unwrap()
                    return Ok(result)
                case 'l':
                    # -l requires a value
                    val value = self.next()
                    if value.is_none():
                        return Err("Option -l requires a value")
                    val level = value.unwrap().parse_int()
                    if level.is_none():
                        return Err("Invalid log level")
                    result.log_level = level.unwrap()
                    return Ok(result)
                case _:
                    return Err("Unknown option: -{c}")
            i = i + 1

        Ok(result)

# ------------------------------------------------------------------------------
# Help and Version
# ------------------------------------------------------------------------------

fn print_help():
    print "Simple Compiler v0.3.0"
    print ""
    print "Usage: simple-compiler [options] <files...>"
    print ""
    print "Modes:"
    print "  -i, --interpret     Interpret (default)"
    print "  -j, --jit           JIT compile and run"
    print "  -c, --aot           Compile to executable"
    print "  -k, --check         Type check only"
    print "  -s, --sdn           Parse as SDN data"
    print "  -m, --mode=MODE     Set mode explicitly"
    print ""
    print "Options:"
    print "  -o, --output=FILE   Output file (for --aot)"
    print "  -O, --optimize      Enable optimizations"
    print "  -g, --debug         Include debug info (default)"
    print "  --no-debug          Exclude debug info"
    print "  -v, --verbose       Verbose output"
    print "  -l, --log-level=N   Log level 0-10 (default: 4)"
    print "  -p, --profile=NAME  Profile: dev, test, prod"
    print ""
    print "  -h, --help          Show this help"
    print "  -V, --version       Show version"
    print "  --bootstrap-test    Run bootstrap self-compile test"
    print ""
    print "Examples:"
    print "  simple-compiler script.spl           # Interpret"
    print "  simple-compiler -j script.spl        # JIT compile"
    print "  simple-compiler -c -o out src/*.spl  # AOT compile"
    print "  simple-compiler -k src/              # Type check"
    print "  simple-compiler -s config.sdn        # Parse SDN"

fn print_version():
    print "simple-compiler 0.3.0 (2026-01)"
    print "Self-hosting compiler for the Simple programming language"
    print ""
    print "Backends:"
    print "  - Interpreter (tree-walking)"
    print "  - JIT (Cranelift)"
    print "  - AOT (Cranelift)"
    print ""
    print "Features:"
    print "  - Indentation-based syntax"
    print "  - Pattern matching"
    print "  - Effect system"
    print "  - Reference capabilities"
    print "  - Algebraic data types"

# ------------------------------------------------------------------------------
# Main Entry Point
# ------------------------------------------------------------------------------

fn main() -> i32:
    val args = sys_get_args()
    # Skip program name
    var program_args = args.slice(1, args.len())

    # Skip "compile" subcommand if present (compatibility with simple_old invocation)
    if program_args.len() > 0:
        if program_args[0] == "compile":
            program_args = program_args.slice(1, program_args.len())

    # Fast path: default interpret mode delegates to simple_old
    # The self-hosted interpreter has struct field access issues
    if args.len() >= 2:
        val last_arg = args[args.len() - 1]
        val last4 = last_arg[last_arg.len() - 4:]
        if last4 == ".spl":
            # Check no mode flags present
            var has_mode = false
            var i = 1
            while i < args.len() - 1:
                val a = args[i]
                if a == "-j" or a == "-c" or a == "-k" or a == "-s":
                    has_mode = true
                if a == "--jit" or a == "--aot" or a == "--check" or a == "--sdn":
                    has_mode = true
                i = i + 1
            if not has_mode:
                val exit_code = rt_exec("./target/debug/simple_old {last_arg}")
                return exit_code

    # Parse arguments
    var parser = ArgParser.create(program_args)
    val parsed = parser.parse()

    match parsed:
        case Err(e):
            print "Error: {e}"
            print "Try 'simple-compiler --help' for usage"
            return 1

        case Ok(cli_args):
            # Handle help/version
            if cli_args.help:
                print_help()
                return 0

            if cli_args.version:
                print_version()
                return 0

            # Check for input files
            if cli_args.input_files.is_empty():
                print "Error: No input files"
                print "Try 'simple-compiler --help' for usage"
                return 1

            # Run compilation
            print "[main] input_files={cli_args.input_files.len()}"
            for f in cli_args.input_files:
                print "[main]   file: {f}"

            val options = cli_args.to_options()
            var driver = CompilerDriver.create(options)
            val result = driver.compile()

            match result:
                case CompileResult.Success(value):
                    if cli_args.verbose:
                        if value.is_some():
                            print "Result: {value.unwrap()}"
                        else:
                            print "Compilation successful"
                    return 0

                case CompileResult.ParseError(errors):
                    print "Parse errors:"
                    for e in errors:
                        print "  {e}"
                    return 1

                case CompileResult.TypeError(errors):
                    print "Type errors:"
                    for e in errors:
                        print "  {e}"
                    return 1

                case CompileResult.CodegenError(msg):
                    print "Codegen error: {msg}"
                    return 1

                case CompileResult.RuntimeError(msg):
                    print "Runtime error: {msg}"
                    return 1

# ------------------------------------------------------------------------------
# Bootstrap Self-Compile Test
# ------------------------------------------------------------------------------

## Bootstrap test function
## Verifies the compiler can compile itself
fn bootstrap_test() -> bool:
    print "=== Bootstrap Self-Compile Test ==="
    print ""

    # Step 1: Compile the compiler itself
    print "Step 1: Compiling simple/compiler/ to simple-compiler-v1..."
    val step1 = aot_file("src/compiler/main.spl", "simple-compiler-v1")
    if not step1.is_success():
        print "  FAILED: {step1.get_errors()}"
        return false
    print "  OK"

    # Step 2: Use v1 to compile itself
    print "Step 2: Using v1 to compile to simple-compiler-v2..."
    val step2_result = rt_exec("./simple-compiler-v1 -c -o simple-compiler-v2 simple/compiler/main.spl")
    if step2_result != 0:
        print "  FAILED: v1 could not compile itself"
        return false
    print "  OK"

    # Step 3: Use v2 to compile itself
    print "Step 3: Using v2 to compile to simple-compiler-v3..."
    val step3_result = rt_exec("./simple-compiler-v2 -c -o simple-compiler-v3 simple/compiler/main.spl")
    if step3_result != 0:
        print "  FAILED: v2 could not compile itself"
        return false
    print "  OK"

    # Step 4: Verify v2 == v3
    print "Step 4: Verifying v2 and v3 are identical..."
    val v2_hash = rt_file_hash("simple-compiler-v2")
    val v3_hash = rt_file_hash("simple-compiler-v3")

    if v2_hash != v3_hash:
        print "  FAILED: v2 and v3 differ"
        print "    v2 hash: {v2_hash}"
        print "    v3 hash: {v3_hash}"
        return false

    print "  OK (hash: {v2_hash})"
    print ""
    print "=== Bootstrap Test PASSED ==="
    print "The Simple compiler can compile itself!"
    true

# FFI for main entry
extern fn sys_get_args() -> [text]
