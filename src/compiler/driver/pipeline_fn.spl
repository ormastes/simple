# Shared Compilation Pipeline
#
# Reusable compilation pipeline function that all CompilationContext
# implementations call from their compile_template() methods.
#
# Pipeline: monomorphize -> HIR -> MIR -> optimize -> AOP weave -> codegen

use compiler.common.compilation_context.{ContractMode, ConcreteType, GenericTemplate}
use compiler.backend.backend_types.{CompiledUnit, CompiledSymbol, CompiledSymbolKind}
use compiler.common.di.DiContainer
use compiler.tools.aop.AopWeaver
use compiler.mir.mir_lowering.MirLowering
use compiler.mir_opt.mir_opt_integration.{OptimizationConfig, optimize_mir_module}
use compiler.mono.monomorphize.type_subst.{TypeSubstitution, substitute_function}
use compiler.mono.monomorphize.engine.{generate_mangled_name, specialize_function_with_types}

# ============================================================================
# Pipeline Function
# ============================================================================

fn compile_specialized_template(
    template: GenericTemplate,
    type_args: [ConcreteType],
    contract_mode: ContractMode,
    di: DiContainer,
    aop: AopWeaver,
    coverage: bool,
    optimization: OptimizationConfig
) -> text:
    """Shared compilation pipeline.

    Steps:
    1. Monomorphize (substitute type parameters)
    2. Lower to HIR
    3. Lower to MIR (with contracts, DI injection)
    4. Optimize MIR (NEW!)
    5. AOP weaving (if configured)
    6. Codegen to native code
    """
    val name = template.name
    var args_strs: [text] = []
    for t in type_args:
        args_strs.push(t.to_string())
    val args_str = args_strs.join(",")
    val mangled = if args_str.is_empty(): name else: "{name}${args_str}"

    # Step 1: Monomorphize
    # Type substitution is now integrated into the driver (Phase 4)
    # The template should already be specialized when passed here
    # For explicit specialization requests:
    # val specialized = specialize_function_with_types(template.function, type_args)

    # Step 2: Lower to HIR
    # HIR lowering happens in driver Phase 3
    # val hir = lower_to_hir(specialized)

    # Step 3: Lower to MIR (with contracts, DI)
    # MIR lowering happens in driver lower_to_mir()
    # var mir = lower_to_mir(hir, contract_mode, di)

    # Step 4: Optimize MIR
    # MIR optimization is ready - uncomment when MIR lowering is wired:
    # mir = optimize_mir_module(mir, optimization)

    # Step 5: AOP weaving
    # if has_aop:
    #     mir = aop_value.weave(mir)

    # Step 6: Codegen
    # val code = codegen_to_native(mir)

    # For now, produce a compiled unit with the mangled name
    # Actual pipeline integration will follow as monomorphize/codegen mature
    Ok(CompiledUnit(
        name: mangled,
        code: [],
        symbols: {},
        #  # DESUGARED: entry_point: nil
        relocations: []
    ))

# ============================================================================
# Backward Compatible Wrappers
# ============================================================================

fn compile_specialized_template_default(
    template: GenericTemplate,
    type_args: [ConcreteType],
    contract_mode: ContractMode,
    di: DiContainer,
    aop: AopWeaver,
    coverage: bool
) -> text:
    """
    Compile with default optimization (debug = no optimization).

    For backward compatibility with existing code.
    """
    compile_specialized_template(
        template,
        type_args,
        contract_mode,
        di,
        aop,
        coverage,
        OptimizationConfig__debug()
    )

fn compile_specialized_template_release(
    template: GenericTemplate,
    type_args: [ConcreteType],
    contract_mode: ContractMode,
    di: DiContainer,
    aop: AopWeaver,
    coverage: bool
) -> text:
    """
    Compile with release optimization (speed optimization).

    Recommended for production builds.
    """
    compile_specialized_template(
        template,
        type_args,
        contract_mode,
        di,
        aop,
        coverage,
        OptimizationConfig__speed()
    )

# ============================================================================
# Exports
# ============================================================================

export compile_specialized_template
export compile_specialized_template_default, compile_specialized_template_release
