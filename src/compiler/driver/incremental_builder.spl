# Incremental Builder
#
# Tracks source files, dependencies, and compilation status for
# incremental compilation. Only recompiles files that changed or
# whose dependencies changed.
#
# Port of rust/compiler/src/incremental_builder.rs (524 lines)


# Auto-generated desugared static method wrappers
fn IncrementalState__create() -> IncrementalState:
    IncrementalState(sources: {}, statuses: {},
                     artifacts: {}, stats: IncrementalStats__empty())


fn IncrementalStats__empty() -> IncrementalStats:
    IncrementalStats(files_checked: 0, files_dirty: 0, cache_hits: 0, cache_misses: 0)


fn SourceInfo__from_path(path: text) -> SourceInfo:
    SourceInfo(path: path, content_hash: 0, dependencies: [],
               functions: [], types: [], macros: [])


export IncrementalBuilder, IncrementalState, SourceInfo
export CompilationStatus, CachedArtifact, IncrementalStats, IncrementalConfig

# ============================================================================
# Types
# ============================================================================

enum CompilationStatus:
    Unknown
    Dirty
    Complete
    Failed

struct IncrementalConfig:
    persist: bool
    validate_on_load: bool
    cache_dir: text?

impl IncrementalConfig:
    static fn default_config() -> IncrementalConfig:
        IncrementalConfig(persist: true, validate_on_load: true, cache_dir: nil)

    static fn memory_only() -> IncrementalConfig:
        IncrementalConfig(persist: false, validate_on_load: false, cache_dir: nil)

struct SourceInfo:
    path: text
    content_hash: i64
    dependencies: [text]
    functions: [text]
    types: [text]
    macros: [text]

impl SourceInfo:
    static fn from_path(path: text) -> SourceInfo:
        SourceInfo(path: path, content_hash: 0, dependencies: [],
                   functions: [], types: [], macros: [])

    fn update_from_content(content: text) -> SourceInfo:
        """Parse imports, functions, types, macros from content."""
        var deps: [text] = []
        var funcs: [text] = []
        var tys: [text] = []
        var macs: [text] = []

        for line in content.lines():
            val trimmed = line.trim()
            if trimmed.starts_with("import "):
                val rest = trimmed[7:]
                val token = rest.split_whitespace().first ?? ""
                if token.?:
                    val dep = if token.ends_with(".spl"): token else: "{token}.spl"
                    deps = deps.push(dep)
            elif trimmed.starts_with("use "):
                val rest = trimmed[4:]
                val module = rest.split(".").first ?? rest.split(" ").first ?? ""
                if module.?:
                    val dep = "{module}.spl"
                    if not deps.contains(dep):
                        deps = deps.push(dep)
            elif trimmed.starts_with("fn "):
                val rest = trimmed[3:]
                val name = rest.split("(").first ?? ""
                if name.trim().?:
                    funcs = funcs.push(name.trim())
            elif trimmed.starts_with("struct "):
                val slice: text = trimmed[7:]
                val name = slice.split_whitespace().first ?? ""
                if name.?:
                    tys = tys.push(name)
            elif trimmed.starts_with("class "):
                val slice: text = trimmed[6:]
                val name = slice.split_whitespace().first ?? ""
                if name.?:
                    tys = tys.push(name)
            elif trimmed.starts_with("enum "):
                val slice: text = trimmed[5:]
                val name = slice.split_whitespace().first ?? ""
                if name.?:
                    tys = tys.push(name)
            elif trimmed.starts_with("macro "):
                val slice: text = trimmed[6:]
                val name = slice.split("(").first ?? ""
                if name.trim().?:
                    macs = macs.push(name.trim())

        extern fn rt_hash_text(t: text) -> i64
        SourceInfo(path: self.path, content_hash: rt_hash_text(content),
                   dependencies: deps, functions: funcs, types: tys, macros: macs)

struct CachedArtifact:
    source: SourceInfo
    has_hir: bool
    has_mir: bool
    has_object: bool

impl CachedArtifact:
    static fn from_source(source: SourceInfo) -> CachedArtifact:
        CachedArtifact(source: source, has_hir: false, has_mir: false, has_object: false)

struct IncrementalStats:
    files_checked: i64
    files_dirty: i64
    cache_hits: i64
    cache_misses: i64

impl IncrementalStats:
    static fn empty() -> IncrementalStats:
        IncrementalStats(files_checked: 0, files_dirty: 0, cache_hits: 0, cache_misses: 0)

    fn hit_ratio() -> f64:
        val total = self.cache_hits + self.cache_misses
        if total == 0: 0.0
        else: self.cache_hits.to_f64() / total.to_f64()

    fn rebuild_ratio() -> f64:
        if self.files_checked == 0: 0.0
        else: self.files_dirty.to_f64() / self.files_checked.to_f64()

# ============================================================================
# Incremental State
# ============================================================================

class IncrementalState:
    """Tracks compilation state for all registered source files."""
    sources: {text: SourceInfo}
    statuses: {text: CompilationStatus}
    artifacts: {text: CachedArtifact}
    stats: IncrementalStats

impl IncrementalState:
    static fn create() -> IncrementalState:
        IncrementalState(sources: {}, statuses: {},
                         artifacts: {}, stats: IncrementalStats__empty())

    me register_source(info: SourceInfo):
        self.sources[info.path] = info

    fn get_status(path: text) -> CompilationStatus:
        if self.statuses.contains_key(path):
            self.statuses[path]
        else:
            CompilationStatus.Unknown

    fn get_artifact(path: text) -> CachedArtifact?:
        if self.artifacts.contains_key(path):
            Some(self.artifacts[path])
        else:
            nil

    me mark_dirty(path: text):
        """Mark a file and its direct dependents as dirty."""
        self.statuses[path] = CompilationStatus.Dirty

        # Cascade to dependents
        for (src_path, info) in self.sources:
            if info.dependencies.contains(path):
                self.statuses[src_path] = CompilationStatus.Dirty

    me mark_complete(path: text, artifact: CachedArtifact):
        self.statuses[path] = CompilationStatus.Complete
        self.artifacts[path] = artifact

    me mark_failed(path: text):
        self.statuses[path] = CompilationStatus.Failed

    me needs_recompile(path: text) -> bool:
        self.stats = IncrementalStats(
            files_checked: self.stats.files_checked + 1,
            files_dirty: self.stats.files_dirty,
            cache_hits: self.stats.cache_hits,
            cache_misses: self.stats.cache_misses)

        val status = self.get_status(path)
        match status:
            case Complete:
                self.stats = IncrementalStats(
                    files_checked: self.stats.files_checked,
                    files_dirty: self.stats.files_dirty,
                    cache_hits: self.stats.cache_hits + 1,
                    cache_misses: self.stats.cache_misses)
                false
            case _:
                self.stats = IncrementalStats(
                    files_checked: self.stats.files_checked,
                    files_dirty: self.stats.files_dirty,
                    cache_hits: self.stats.cache_hits,
                    cache_misses: self.stats.cache_misses + 1)
                true

    fn check_all() -> [text]:
        """Return paths of all files needing compilation."""
        var dirty: [text] = []
        for (path, _) in self.sources:
            val status = self.get_status(path)
            match status:
                case Complete: ()
                case _: dirty = dirty.push(path)
        dirty

    me clear():
        self.statuses = {}
        self.artifacts = {}

    fn get_stats() -> IncrementalStats:
        self.stats

# ============================================================================
# Incremental Builder
# ============================================================================

class IncrementalBuilder:
    """High-level incremental compilation builder."""
    state: IncrementalState

impl IncrementalBuilder:
    static fn create() -> IncrementalBuilder:
        IncrementalBuilder(state: IncrementalState__create())

    me add_source(path: text, content: text):
        val info = SourceInfo__from_path(path).update_from_content(content)
        self.state.register_source(info)

    fn build() -> [text]:
        """Returns files that need compilation."""
        self.state.check_all()

    me complete(path: text, has_hir: bool, has_mir: bool, has_object: bool):
        if self.state.sources.contains_key(path):
            val source = self.state.sources[path]
            val artifact = CachedArtifact(source: source,
                has_hir: has_hir, has_mir: has_mir, has_object: has_object)
            self.state.mark_complete(path, artifact)

    me fail(path: text):
        self.state.mark_failed(path)

    fn stats() -> IncrementalStats:
        self.state.get_stats()
