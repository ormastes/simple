"""
Associated Types - Core Type Definitions and Registries

Phase 4A: AssocTypeDef, TraitDefEx, TraitRegistryEx
Phase 4B: AssocTypeImpl, Obligation (definitions only)

Solver logic (ImplBlockEx, ImplRegistryEx, ImplValidator,
AssocTypeProjection, AssocTypeResolver, TraitSolverEx) is in
associated_types_solvers.spl.
"""

type Symbol = text

use compiler.types.associated_types_solvers.*

# ============================================================================
# Type System (Phase 4D version - most complete, includes TypeVar)
# ============================================================================

enum HirType:
    Int
    Str
    Bool
    Named(name: Symbol)
    Generic(name: Symbol, args: [HirType])
    Projection(base: HirType, assoc_name: Symbol)
    TypeVar(id: i64)  # For generics
    Error

impl HirType:
    fn to_string() -> text:
        match self:
            case Int: "i32"
            case Str: "String"
            case Bool: "bool"
            case Named(name): name
            case Generic(name, args):
                val args_str = if args.len() > 0: "<...>" else: ""
                "{name}{args_str}"
            case Projection(base, assoc_name):
                "{base.to_string()}.{assoc_name}"
            case TypeVar(id): "T{id}"
            case Error: "<error>"

    fn type_name() -> Symbol:
        match self:
            case Int: "i32"
            case Str: "String"
            case Bool: "bool"
            case Named(name): name
            case Generic(name, _): name
            case Projection(base, _): base.type_name()
            case TypeVar(id): "T{id}"
            case Error: "<error>"

    fn matches(other: HirType) -> bool:
        """Simplified type matching"""
        match (self, other):
            case (Int, Int): true
            case (Str, Str): true
            case (Bool, Bool): true
            case (Named(n1), Named(n2)): n1 == n2
            case (TypeVar(_), _): true
            case (_, TypeVar(_)): true
            case (Error, _): true
            case (_, Error): true
            case _: false

# ============================================================================
# Trait Reference (Phase 4D version - includes to_string)
# ============================================================================

class TraitRef:
    name: text

impl TraitRef:
    static fn new(name: Symbol) -> TraitRef:
        TraitRef(name: name)

    fn to_string() -> text:
        self.name

# ============================================================================
# Associated Type Definition (Phase 4A)
# ============================================================================

class AssocTypeDef:
    """
    Associated type definition in a trait

    Example:
        trait Iterator:
            type Item           # No bounds, no default
            type Error: Display # With bound
            type Index = i64    # With default
    """
    name: text
    bounds: text       # Placeholder for [TraitRef]
    default_type: text # Placeholder for Option<HirType>

impl AssocTypeDef:
    static fn new(name: Symbol) -> AssocTypeDef:
        AssocTypeDef(
            name: name,
            bounds: "[]",
            default_type: "None"
        )

    static fn with_bounds(name: Symbol, bounds: [TraitRef]) -> AssocTypeDef:
        val assoc_type = AssocTypeDef.new(name)
        val bounds_dict = {}
        for bound in bounds:
            bounds_dict[bound.name] = bound
        val new_assoc = AssocTypeDef(
            name: name,
            bounds: bounds_dict,
            default_type: "None"
        )
        new_assoc

    static fn with_default(name: Symbol, default_type: HirType) -> AssocTypeDef:
        val assoc_type = AssocTypeDef.new(name)
        val new_assoc = AssocTypeDef(
            name: name,
            bounds: "[]",
            default_type: default_type
        )
        new_assoc

    fn has_bounds() -> bool:
        self.bounds != "[]"

    fn has_default() -> bool:
        self.default_type != "None"

    fn to_string() -> text:
        var result = "type {self.name}"

        if self.has_bounds():
            result = "{result}: <bounds>"

        if self.has_default():
            result = "{result} = <default>"

        result

# ============================================================================
# Extended Trait Definition (Phase 4A)
# ============================================================================

class TraitDefEx:
    """
    Extended trait definition with associated types

    Example:
        trait Iterator:
            type Item           # Associated type
            fn next() -> Item?  # Method using associated type
    """
    name: text
    methods: text      # Placeholder for [MethodSig]
    supertraits: text  # Placeholder for [Symbol]
    assoc_types: text  # Dict<Symbol, AssocTypeDef>

impl TraitDefEx:
    static fn new(name: Symbol) -> TraitDefEx:
        TraitDefEx(
            name: name,
            methods: "[]",
            supertraits: "[]",
            assoc_types: {}
        )

    me add_assoc_type(assoc_type: AssocTypeDef):
        """Add an associated type to this trait"""
        self.assoc_types[assoc_type.name] = assoc_type

    fn has_assoc_type(name: Symbol) -> bool:
        """Check if trait has this associated type"""
        name in self.assoc_types

    fn get_assoc_type(name: Symbol) -> AssocTypeDef:
        """Get associated type by name (returns dummy if not found)"""
        if name in self.assoc_types:
            return self.assoc_types[name]

        # Return dummy
        AssocTypeDef.new("NotFound")

    fn assoc_type_count() -> i64:
        """Count associated types"""
        self.assoc_types.len()

    fn to_string() -> text:
        var result = "trait {self.name}"

        if self.assoc_type_count() > 0:
            result = "{result} (with {self.assoc_type_count()} assoc types)"

        result

# ============================================================================
# Extended Trait Registry (Phase 4A)
# ============================================================================

class TraitRegistryEx:
    """
    Extended trait registry supporting associated types
    """
    traits: text  # Dict<Symbol, TraitDefEx>

impl TraitRegistryEx:
    static fn new() -> TraitRegistryEx:
        val registry_data = {
            "traits": {}
        }
        TraitRegistryEx(traits: registry_data)

    me register_trait(trait_def: TraitDefEx) -> bool:
        """Register a trait definition"""
        val traits = self.traits["traits"]

        if trait_def.name in traits:
            return false  # Already registered

        traits[trait_def.name] = trait_def
        true

    fn get_trait(name: Symbol) -> TraitDefEx:
        """Get trait by name"""
        val traits = self.traits["traits"]

        if name in traits:
            return traits[name]

        # Return dummy
        TraitDefEx.new("NotFound")

    fn has_trait(name: Symbol) -> bool:
        """Check if trait exists"""
        val traits = self.traits["traits"]
        name in traits

    fn count_traits() -> i64:
        """Count registered traits"""
        val traits = self.traits["traits"]
        traits.len()

    me define_builtin_traits():
        """Define standard library traits with associated types"""

        # Iterator trait (with Item associated type)
        val iterator = TraitDefEx.new("Iterator")
        val item_type = AssocTypeDef.new("Item")
        iterator.add_assoc_type(item_type)
        self.register_trait(iterator)

        # Collection trait (with Item and Index)
        val collection = TraitDefEx.new("Collection")
        val coll_item = AssocTypeDef.new("Item")
        val index_type = AssocTypeDef.with_default("Index", HirType.Int)
        collection.add_assoc_type(coll_item)
        collection.add_assoc_type(index_type)
        self.register_trait(collection)

        # Result trait (with Ok and Err types)
        val result_trait = TraitDefEx.new("Result")
        val ok_type = AssocTypeDef.new("Ok")
        val err_type = AssocTypeDef.new("Err")
        result_trait.add_assoc_type(ok_type)
        result_trait.add_assoc_type(err_type)
        self.register_trait(result_trait)

        # Display trait (no associated types - for comparison)
        val display = TraitDefEx.new("Display")
        self.register_trait(display)

# ============================================================================
# Associated Type Implementation (Phase 4B)
# ============================================================================

class AssocTypeImpl:
    """
    Concrete implementation of an associated type

    Example:
        impl Iterator for Range:
            type Item = i64  # AssocTypeImpl
    """
    name: text
    concrete_type: text  # HirType

impl AssocTypeImpl:
    static fn new(name: Symbol, concrete_type: HirType) -> AssocTypeImpl:
        AssocTypeImpl(
            name: name,
            concrete_type: concrete_type
        )

    fn to_string() -> text:
        val type_str = self.concrete_type.to_string()
        "type {self.name} = {type_str}"

    fn get_type() -> HirType:
        self.concrete_type

# ============================================================================
# Extended Obligation (Phase 4D)
# ============================================================================

class Obligation:
    """
    Extended obligation with associated type constraints

    Examples:
        T: Iterator                    # Basic bound
        T: Iterator<Item=i64>          # With assoc type constraint
        I: Iterator, I.Item: Display   # Multiple constraints
    """
    ty: text                    # HirType
    trait_ref: text             # TraitRef
    span: text                  # Span (for errors)
    assoc_type_constraints: text  # Dict<Symbol, HirType>

impl Obligation:
    static fn new(ty: HirType, trait_ref: TraitRef) -> Obligation:
        Obligation(
            ty: ty,
            trait_ref: trait_ref,
            span: "unknown",
            assoc_type_constraints: {}
        )

    static fn with_assoc_constraint(
        ty: HirType,
        trait_ref: TraitRef,
        assoc_name: Symbol,
        assoc_type: HirType
    ) -> Obligation:
        """Create obligation with associated type constraint"""
        val obligation = Obligation.new(ty, trait_ref)
        val new_obligation = Obligation(
            ty: ty,
            trait_ref: trait_ref,
            span: "unknown",
            assoc_type_constraints: {assoc_name: assoc_type}
        )
        new_obligation

    me add_assoc_constraint(assoc_name: Symbol, assoc_type: HirType):
        """Add an associated type constraint"""
        self.assoc_type_constraints[assoc_name] = assoc_type

    fn has_assoc_constraints() -> bool:
        """Check if obligation has associated type constraints"""
        self.assoc_type_constraints.len() > 0

    fn to_string() -> text:
        val type_str = self.ty.to_string()
        val trait_str = self.trait_ref.name
        var result = "{type_str}: {trait_str}"

        if self.has_assoc_constraints():
            val constraints = self.assoc_type_constraints
            var constraint_strs = []

            for assoc_name in constraints:
                val assoc_type = constraints[assoc_name]
                val constraint_str = "{assoc_name}={assoc_type.to_string()}"
                constraint_strs.push(constraint_str)

            if constraint_strs.len() > 0:
                val joined = constraint_strs[0]
                result = "{result}<{joined}>"

        result

