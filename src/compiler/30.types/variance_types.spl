"""
Variance Checking - Types and Core Definitions

Variance enum, VarianceOps, type parameter definitions, variance environment,
HIR type system, variance inference, subtype environment, and variance checker.
"""

type Symbol = text

# ============================================================================
# Variance
# ============================================================================

enum Variance:
    """
    Variance of a type parameter

    Examples:
        Covariant (+T):     F<A> <: F<B> if A <: B (producer, read-only)
        Contravariant (-T): F<A> <: F<B> if B <: A (consumer, input)
        Inv (T):            F<A> <: F<B> only if A = B (both, mutable)
        Bivariant (±T):     F<A> <: F<B> always (unused parameter)
    """
    Covariant        # +T (producer, read-only)
    Contravariant    # -T (consumer, input)
    Inv              # T (both, mutable) - renamed from Invariant (keyword conflict)
    Bivariant        # ±T (unused)

impl Variance:
    fn to_string() -> text:
        match self:
            case Covariant: "+"
            case Contravariant: "-"
            case Inv: "="
            case Bivariant: "±"

    fn to_long_string() -> text:
        match self:
            case Covariant: "covariant"
            case Contravariant: "contravariant"
            case Inv: "inv"
            case Bivariant: "bivariant"

    fn is_covariant() -> bool:
        match self:
            case Covariant: true
            case _: false

    fn is_contravariant() -> bool:
        match self:
            case Contravariant: true
            case _: false

    fn is_inv() -> bool:
        match self:
            case Inv: true
            case _: false

    fn is_bivariant() -> bool:
        match self:
            case Bivariant: true
            case _: false

# ============================================================================
# Variance Operations
# ============================================================================

class VarianceOps:
    """Helper class for variance operations"""

    static fn flip(v: Variance) -> Variance:
        """
        Flip variance (for contravariant position)

        Examples:
            flip(Covariant) = Contravariant
            flip(Contravariant) = Covariant
            flip(Invariant) = Invariant
            flip(Bivariant) = Bivariant
        """
        match v:
            case Covariant: Variance.Contravariant
            case Contravariant: Variance.Covariant
            case Inv: Variance.Inv
            case Bivariant: Variance.Bivariant

    static fn compose(outer: Variance, inner: Variance) -> Variance:
        """
        Compose two variance contexts

        Rules:
            Covariant + v = v
            Contravariant + v = flip(v)
            Invariant + v = Invariant
            Bivariant + v = Bivariant

        Examples:
            compose(Covariant, Covariant) = Covariant
            compose(Contravariant, Covariant) = Contravariant
            compose(Contravariant, Contravariant) = Covariant (double flip)
            compose(Invariant, Covariant) = Invariant
        """
        match outer:
            case Covariant:
                # Covariant context preserves variance
                inner

            case Contravariant:
                # Contravariant context flips variance
                VarianceOps.flip(inner)

            case Inv:
                # Invariant context forces invariance
                Variance.Inv

            case Bivariant:
                # Bivariant context forces bivariance
                Variance.Bivariant

    static fn combine(v1: Variance, v2: Variance) -> Variance:
        """
        Combine two variance constraints (intersection)

        Rules:
            Bivariant + v = v (unused constraint)
            v + Bivariant = v (unused constraint)
            Covariant + Covariant = Covariant (both agree)
            Contravariant + Contravariant = Contravariant (both agree)
            Otherwise = Invariant (conflict)

        Examples:
            combine(Covariant, Bivariant) = Covariant
            combine(Covariant, Covariant) = Covariant
            combine(Covariant, Contravariant) = Invariant (conflict)
            combine(Invariant, Covariant) = Invariant (already most restrictive)
        """
        match (v1, v2):
            # Bivariant is identity (unused parameter)
            case (Bivariant, v): v
            case (v, Bivariant): v

            # Same variance → keep it
            case (Covariant, Covariant): Variance.Covariant
            case (Contravariant, Contravariant): Variance.Contravariant
            case (Invariant, Invariant): Variance.Inv

            # Conflict → invariant (most restrictive)
            case _: Variance.Inv

# ============================================================================
# Type Parameter Definition (Phase 6A)
# ============================================================================

class TypeParamDef:
    """
    Type parameter definition with variance

    Examples:
        +T (covariant, explicit)
        T (invariant by default, inferred)
        -U (contravariant, explicit)
    """
    name: Symbol
    variance: Variance  # Explicit or inferred

impl TypeParamDef:
    static fn covariant(name: Symbol) -> TypeParamDef:
        TypeParamDef(name: name, variance: Variance.Covariant)

    static fn contravariant(name: Symbol) -> TypeParamDef:
        TypeParamDef(name: name, variance: Variance.Contravariant)

    static fn inv(name: Symbol) -> TypeParamDef:
        TypeParamDef(name: name, variance: Variance.Inv)

    static fn bivariant(name: Symbol) -> TypeParamDef:
        TypeParamDef(name: name, variance: Variance.Bivariant)

    fn to_string() -> text:
        "{self.variance.to_string()}{self.name}"

# ============================================================================
# Variance Environment (Phase 6A)
# ============================================================================

class VarianceEnv:
    """
    Environment tracking variance for type parameters

    Maps: type name → parameter name → variance

    Example:
        Box → T → Covariant
        Cell → T → Invariant
        Fn → T → Contravariant
        Fn → U → Covariant
    """
    type_variances: text  # Dict<Symbol, Dict<Symbol, Variance>>

impl VarianceEnv:
    static fn empty() -> VarianceEnv:
        VarianceEnv(type_variances: {})

    me set_type_variance(type_name: Symbol, param_name: Symbol, variance: Variance):
        """Set variance for a type parameter"""
        if type_name not in self.type_variances:
            self.type_variances[type_name] = {}

        # Get inner dict, modify it, assign back
        var type_vars = self.type_variances[type_name]
        type_vars[param_name] = variance
        self.type_variances[type_name] = type_vars

    fn get_type_variance(type_name: Symbol, param_name: Symbol) -> Variance:
        """
        Get variance for a type parameter

        Returns: Variance or Bivariant if not found
        """
        if type_name not in self.type_variances:
            return Variance.Bivariant

        val type_vars = self.type_variances[type_name]

        if param_name not in type_vars:
            return Variance.Bivariant

        type_vars[param_name]

    fn get_type_variances(type_name: Symbol) -> [Variance]:
        """
        Get all variances for a type's parameters (in order)

        Returns: List of variances, empty if type not found
        """
        if type_name not in self.type_variances:
            return []

        val type_vars = self.type_variances[type_name]
        var result = []

        # NOTE: Dict iteration order may not match parameter order
        # In real implementation, would need to track parameter order separately
        for param_name in type_vars:
            result.push(type_vars[param_name])

        result

    me set_type_variances(type_name: Symbol, variances: [Variance], param_names: [Symbol]):
        """
        Set all variances for a type's parameters

        Requires: variances.len() == param_names.len()
        """
        if type_name not in self.type_variances:
            self.type_variances[type_name] = {}

        # Get inner dict, modify it, assign back
        var type_vars = self.type_variances[type_name]

        for i, param_name in param_names.enumerate():
            if i < variances.len():
                type_vars[param_name] = variances[i]

        self.type_variances[type_name] = type_vars

    fn has_type(type_name: Symbol) -> bool:
        """Check if type is in environment"""
        type_name in self.type_variances

    fn type_count() -> i64:
        """Count types in environment"""
        self.type_variances.len()

# ============================================================================
# Type System (Phase 6B)
# ============================================================================

enum HirType:
    """
    Simplified HIR type for variance inference

    Examples:
        TypeParam(0)                    # Type parameter T (id 0)
        Arrow(TypeParam(0), Int)        # fn(T) -> i32
        Generic("Box", [TypeParam(0)])  # Box<T>
        MutRef(TypeParam(0))            # mut T (always invariant)
    """
    Int
    Str
    Bool
    TypeParam(id: i64)                    # Type parameter reference
    Arrow(from: HirType, to: HirType)     # Function type
    Generic(name: Symbol, args: [HirType]) # Generic type
    MutRef(inner: HirType)                # Mutable reference (invariant)

impl HirType:
    fn to_string() -> text:
        match self:
            case Int: "i32"
            case Str: "String"
            case Bool: "bool"
            case TypeParam(id): "T{id}"
            case Arrow(from, to):
                "fn({from.to_string()}) -> {to.to_string()}"
            case Generic(name, args):
                if args.len() == 0:
                    name
                else:
                    val arg_strs = []
                    for arg in args:
                        arg_strs.push(arg.to_string())
                    val args_str = if arg_strs.len() > 0: arg_strs[0] else: ""
                    "{name}<{args_str}>"
            case MutRef(inner):
                "mut {inner.to_string()}"

# ============================================================================
# Type Definition (Phase 6B)
# ============================================================================

class FieldDef:
    """Field in a struct/class"""
    name: Symbol
    ty: HirType

class MethodDef:
    """Method in a struct/class"""
    name: Symbol
    params: [HirType]
    return_ty: HirType

class TypeDef:
    """
    Type definition for variance inference

    Examples:
        struct Box<T>:
            value: T

        struct Cell<T>:
            value: mut T

        type Fn<T, U> = fn(T) -> U
    """
    name: Symbol
    type_param_count: i64
    fields: [FieldDef]
    methods: [MethodDef]

# ============================================================================
# Variance Inference (Phase 6B)
# ============================================================================

class VarianceInference:
    """
    Infer variance for type parameters from type definitions

    Algorithm:
    1. Initialize all parameters to Bivariant (unused)
    2. Walk through type definition:
       - Fields: analyze in covariant context
       - Method params: analyze in contravariant context
       - Method return: analyze in covariant context
    3. Combine variances using composition rules
    4. Fixed-point iteration for recursive types
    """
    type_defs: text  # Dict<Symbol, TypeDef>
    variances: text  # Dict<Symbol, [Variance]> - type name → variances

impl VarianceInference:
    static fn empty() -> VarianceInference:
        VarianceInference(
            type_defs: {},
            variances: {}
        )

    me add_type_def(type_def: TypeDef):
        """Add a type definition"""
        self.type_defs[type_def.name] = type_def

    me infer_variance(type_name: Symbol) -> [Variance]:
        """
        Infer variance for all type parameters in a type

        Returns: List of variances (one per type parameter)
        """
        # Check if already computed
        if type_name in self.variances:
            return self.variances[type_name]

        # Get type definition
        if type_name not in self.type_defs:
            return []

        val type_def = self.type_defs[type_name]

        # Initialize all parameters to bivariant (unused)
        var variances = []
        for i in 0..type_def.type_param_count:
            variances.push(Variance.Bivariant)

        # Analyze fields (covariant context)
        for field in type_def.fields:
            val field_variances = self.analyze_type(
                field.ty,
                Variance.Covariant,
                variances
            )

            # Combine with existing
            variances = self.merge_variances(variances, field_variances)

        # Analyze methods
        for method in type_def.methods:
            # Parameters are contravariant
            for param in method.params:
                val param_variances = self.analyze_type(
                    param,
                    Variance.Contravariant,
                    variances
                )
                variances = self.merge_variances(variances, param_variances)

            # Return type is covariant
            val return_variances = self.analyze_type(
                method.return_ty,
                Variance.Covariant,
                variances
            )
            variances = self.merge_variances(variances, return_variances)

        # Cache and return
        self.variances[type_name] = variances
        variances

    me analyze_type(ty: HirType, context: Variance, current_variances: [Variance]) -> [Variance]:
        """
        Analyze a type in a given variance context

        Returns: Variances for each type parameter (indexed by param id)
        """
        match ty:
            case TypeParam(id):
                # Found usage of type parameter
                var result = []
                for i in 0..current_variances.len():
                    if i == id:
                        result.push(context)
                    else:
                        result.push(Variance.Bivariant)
                result

            case Arrow(from, to):
                # Function type: parameter is contravariant, return is covariant
                val from_variances = self.analyze_type(
                    from,
                    VarianceOps.flip(context),  # Flip for parameter
                    current_variances
                )
                val to_variances = self.analyze_type(
                    to,
                    context,  # Same context for return
                    current_variances
                )
                self.merge_variances(from_variances, to_variances)

            case Generic(name, args):
                # Look up variance of the generic type's parameters
                val type_variances = self.infer_variance(name)

                var result = []
                for i in 0..current_variances.len():
                    result.push(Variance.Bivariant)

                for i, arg in args.enumerate():
                    if i < type_variances.len():
                        val param_variance = type_variances[i]
                        val combined_context = VarianceOps.compose(context, param_variance)

                        val arg_variances = self.analyze_type(arg, combined_context, current_variances)
                        result = self.merge_variances(result, arg_variances)

                result

            case MutRef(inner):
                # Mutable reference is always invariant
                self.analyze_type(inner, Variance.Inv, current_variances)

            case _:
                # Primitives (Int, Str, Bool) don't use type parameters
                var result = []
                for i in 0..current_variances.len():
                    result.push(Variance.Bivariant)
                result

    fn merge_variances(v1: [Variance], v2: [Variance]) -> [Variance]:
        """Merge two variance lists (combine element-wise)"""
        var result = []

        val max_len = if v1.len() > v2.len(): v1.len() else: v2.len()

        for i in 0..max_len:
            val var1 = if i < v1.len(): v1[i] else: Variance.Bivariant
            val var2 = if i < v2.len(): v2[i] else: Variance.Bivariant

            result.push(VarianceOps.combine(var1, var2))

        result

    fn get_variance(type_name: Symbol) -> [Variance]:
        """Get inferred variance (or empty if not computed)"""
        if type_name in self.variances:
            return self.variances[type_name]
        []

# ============================================================================
# Subtyping Hierarchy (Phase 6C)
# ============================================================================

class SubtypeEnv:
    """
    Environment tracking subtyping relationships

    Examples:
        Cat <: Animal
        Dog <: Animal
        Animal <: Any
    """
    subtypes: text  # Dict<Symbol, [Symbol]> - type → list of supertypes

impl SubtypeEnv:
    static fn empty() -> SubtypeEnv:
        SubtypeEnv(subtypes: {})

    me add_subtype(sub: Symbol, sup: Symbol):
        """Declare sub <: sup"""
        if sub not in self.subtypes:
            self.subtypes[sub] = []

        var supers = self.subtypes[sub]
        supers.push(sup)
        self.subtypes[sub] = supers

    fn is_subtype(sub: Symbol, sup: Symbol) -> bool:
        """Check if sub <: sup (direct or transitive)"""
        if sub == sup:
            return true

        if sub not in self.subtypes:
            return false

        val supers = self.subtypes[sub]

        # Direct subtype
        if sup in supers:
            return true

        # Transitive: check if any supertype is subtype of sup
        for s in supers:
            if self.is_subtype(s, sup):
                return true

        false

# ============================================================================
# Variance Checker (Phase 6C)
# ============================================================================

class VarianceChecker:
    """
    Check subtyping using variance information

    Rules:
        Covariant:     F<A> <: F<B> if A <: B
        Contravariant: F<A> <: F<B> if B <: A (flipped!)
        Invariant:     F<A> <: F<B> only if A = B
        Bivariant:     F<A> <: F<B> always
    """
    variance_env: text   # Dict<Symbol, [Variance]> - type → variances
    subtype_env: SubtypeEnv

impl VarianceChecker:
    static fn new_checker(subtype_env: SubtypeEnv) -> VarianceChecker:
        VarianceChecker(
            variance_env: {},
            subtype_env: subtype_env
        )

    me set_variance(type_name: Symbol, variances: [Variance]):
        """Set variance for a type"""
        self.variance_env[type_name] = variances

    fn check_subtype(sub: HirType, sup: HirType) -> bool:
        """
        Check if sub <: sup

        Uses variance to determine if generic types are subtypes
        """
        match (sub, sup):
            case (Int, Int): true
            case (Str, Str): true
            case (Bool, Bool): true

            case (Generic(name1, args1), Generic(name2, args2)):
                if name1 != name2:
                    return false

                # Check type arguments according to variance
                if name1 not in self.variance_env:
                    # No variance info → assume invariant
                    return self.types_equal(sub, sup)

                val variances = self.variance_env[name1]

                for i, (arg1, arg2) in args1.zip(args2).enumerate():
                    if i >= variances.len():
                        # No variance for this param → invariant
                        if not self.types_equal(arg1, arg2):
                            return false
                    else:
                        val variance = variances[i]

                        match variance:
                            case Covariant:
                                # F<A> <: F<B> if A <: B
                                if not self.check_subtype(arg1, arg2):
                                    return false

                            case Contravariant:
                                # F<A> <: F<B> if B <: A (flipped!)
                                if not self.check_subtype(arg2, arg1):
                                    return false

                            case Inv:
                                # F<A> <: F<B> only if A = B
                                if not self.types_equal(arg1, arg2):
                                    return false

                            case Bivariant:
                                # F<A> <: F<B> always (unused parameter)
                                ()

                true

            case (Arrow(from1, to1), Arrow(from2, to2)):
                # fn(A) -> B <: fn(C) -> D
                # if C <: A (contravariant param) and B <: D (covariant return)
                self.check_subtype(from2, from1) and self.check_subtype(to1, to2)

            case _:
                # Structural subtyping not implemented
                false

    fn types_equal(ty1: HirType, ty2: HirType) -> bool:
        """Check if two types are equal"""
        match (ty1, ty2):
            case (Int, Int): true
            case (Str, Str): true
            case (Bool, Bool): true
            case (TypeParam(id1), TypeParam(id2)): id1 == id2

            case (Arrow(from1, to1), Arrow(from2, to2)):
                self.types_equal(from1, from2) and self.types_equal(to1, to2)

            case (Generic(name1, args1), Generic(name2, args2)):
                if name1 != name2:
                    return false
                if args1.len() != args2.len():
                    return false

                for i, (arg1, arg2) in args1.zip(args2).enumerate():
                    if not self.types_equal(arg1, arg2):
                        return false

                true

            case _: false

# ============================================================================
# Named Types for Testing (Phase 6C)
# ============================================================================

class NamedType:
    """Named type for subtyping tests (Cat, Animal, etc.)"""
    name: Symbol

# Helper to create named generic types
fn box_of(name: Symbol) -> HirType:
    HirType.Generic(name: "Box", args: [HirType.Generic(name: name, args: [])])

fn cell_of(name: Symbol) -> HirType:
    HirType.Generic(name: "Cell", args: [HirType.Generic(name: name, args: [])])

fn fn_type(param: Symbol, ret: Symbol) -> HirType:
    HirType.Arrow(
        from: HirType.Generic(name: param, args: []),
        to: HirType.Generic(name: ret, args: [])
    )

# ============================================================================
# Integrated Type Checker (Phase 6D)
# ============================================================================

class TypeCheckerIntegrated:
    """
    Type checker with integrated variance checking

    Simulates integration points for:
    - Assignment checking
    - Method call validation
    - Generic instantiation
    """
    variance_checker: VarianceChecker

impl TypeCheckerIntegrated:
    static fn new_checker(variance_checker: VarianceChecker) -> TypeCheckerIntegrated:
        TypeCheckerIntegrated(variance_checker: variance_checker)

    fn check_assignment(lhs_ty: HirType, rhs_ty: HirType) -> bool:
        """
        Check assignment: lhs = rhs

        Valid if rhs_ty <: lhs_ty
        """
        self.variance_checker.check_subtype(rhs_ty, lhs_ty)

    fn check_method_call(receiver_ty: HirType, expected_ty: HirType) -> bool:
        """
        Check method call receiver

        Valid if receiver_ty <: expected_ty
        """
        self.variance_checker.check_subtype(receiver_ty, expected_ty)

    fn check_generic_instantiation(type_name: Symbol, args: [HirType]) -> bool:
        """
        Check generic type instantiation

        For now, just returns true (placeholder)
        In real implementation, would check bounds, etc.
        """
        true

# ============================================================================
# Variance Annotation Validation (Phase 6D)
# ============================================================================

class VarianceAnnotation:
    """
    Validates explicit variance annotations match inferred variance

    Examples:
        struct Box<+T>:  # Explicit covariant annotation
            value: T     # Inferred: covariant

        If mismatch, emit warning
    """
    name: Symbol
    param_name: Symbol
    explicit: Variance
    inferred: Variance

impl VarianceAnnotation:
    fn matches() -> bool:
        """Check if explicit annotation matches inferred variance"""
        match (self.explicit, self.inferred):
            case (Covariant, Covariant): true
            case (Contravariant, Contravariant): true
            case (Inv, Inv): true
            case (Bivariant, Bivariant): true
            case _: false

    fn to_warning() -> text:
        """Generate warning message for mismatch"""
        "Warning: {self.name}<{self.param_name}>: explicit variance {self.explicit.to_long_string()} doesn't match inferred {self.inferred.to_long_string()}"

# ============================================================================
# Error Messages (Phase 6D)
# ============================================================================

class VarianceError:
    """Variance error for reporting"""
    message: text

impl VarianceError:
    static fn covariant_violation(sub: HirType, sup: HirType) -> VarianceError:
        VarianceError(
            message: "Variance error: cannot assign {sub.to_string()} to {sup.to_string()} (covariant type)"
        )

    static fn inv_violation(sub: HirType, sup: HirType) -> VarianceError:
        VarianceError(
            message: "Variance error: cannot assign {sub.to_string()} to {sup.to_string()} (invariant type)"
        )

    fn to_string() -> text:
        self.message
