"""
Const Keys - Consolidated from Phase 8A-8C

Implements:
- Key extraction from string templates (Phase 8A)
- Type system support for const key sets (Phase 8B)
- Validation of .with() calls against ConstKeySet types (Phase 8C)
"""

type Symbol = text

# ============================================================================
# Key Extractor (Phase 8A)
# ============================================================================

class KeyExtractor:
    """
    Extracts keys from string template

    Examples:
        "Hello {name}" -> ["name"]
        "{x} + {y} = {sum}" -> ["x", "y", "sum"]
        "No keys" -> []
    """

impl KeyExtractor:
    static fn extract_keys(tmpl: text) -> [Symbol]:
        """
        Extract keys from template string

        Algorithm:
        1. Scan through template character by character
        2. Track when inside braces {}
        3. Collect characters between braces as keys
        4. Return list of keys
        """
        var keys = []
        var in_brace = false
        var key_chars: [text] = []
        var i = 0

        while i < tmpl.len():
            val char = tmpl[i..i+1]

            if char == "{":
                in_brace = true
                key_chars = []
            elif char == "}":
                if in_brace:
                    val current_key = key_chars.join("")
                    if current_key.len() > 0:
                        keys.push(current_key)
                in_brace = false
                key_chars = []
            elif in_brace:
                key_chars = key_chars.push(char)

            i = i + 1

        keys

    static fn has_keys(tmpl: text) -> bool:
        """Check if template has any keys"""
        val keys = KeyExtractor.extract_keys(tmpl)
        keys.len() > 0

    static fn unique_keys(tmpl: text) -> [Symbol]:
        """Extract unique keys (deduplicate)"""
        val all_keys = KeyExtractor.extract_keys(tmpl)
        var unique = []

        for key in all_keys:
            if key not in unique:
                unique.push(key)

        unique

    static fn key_count(tmpl: text) -> i64:
        """Count number of keys"""
        val keys = KeyExtractor.extract_keys(tmpl)
        keys.len()

# ============================================================================
# Const Key Set (Phase 8A)
# ============================================================================

class ConstKeySet:
    """
    Set of compile-time known keys

    Examples:
        ConstKeySet(["name", "age"])
        ConstKeySet([])  # No keys
    """
    keys: [Symbol]

impl ConstKeySet:
    static fn from_template(tmpl: text) -> ConstKeySet:
        """Create ConstKeySet from template string"""
        val keys = KeyExtractor.extract_keys(tmpl)
        ConstKeySet(keys: keys)

    static fn from_keys(keys: [Symbol]) -> ConstKeySet:
        """Create ConstKeySet from key list"""
        ConstKeySet(keys: keys)

    static fn empty() -> ConstKeySet:
        """Create empty ConstKeySet (no keys)"""
        ConstKeySet(keys: [])

    fn has_key(key: Symbol) -> bool:
        """Check if key is in set"""
        key in self.keys

    fn key_count() -> i64:
        """Count number of keys"""
        self.keys.len()

    fn is_empty() -> bool:
        """Check if set is empty"""
        self.keys.len() == 0

    fn get_keys() -> [Symbol]:
        """Get list of keys"""
        self.keys

    fn missing_keys(provided: [Symbol]) -> [Symbol]:
        """Find keys in required but not in provided"""
        var missing = []

        for key in self.keys:
            if key not in provided:
                missing.push(key)

        missing

    fn extra_keys(provided: [Symbol]) -> [Symbol]:
        """Find keys in provided but not in required"""
        var extra = []

        for key in provided:
            if key not in self.keys:
                extra.push(key)

        extra

    fn to_string() -> text:
        """String representation"""
        if self.keys.len() == 0:
            return "ConstKeySet([])"

        var key_strs = []
        for key in self.keys:
            key_strs.push(key)

        val keys_str = if key_strs.len() > 0: key_strs[0] else: ""
        "ConstKeySet([{keys_str}, ...])"

# ============================================================================
# HirType Extensions for Const Keys (Phase 8B)
# ============================================================================

enum HirType:
    """
    Extended type system with const key support

    New variants:
    - ConstKeySet: Compile-time known keys from string template
    - DependentKeys: Runtime-determined keys from variable
    """
    # Core types
    Int
    Float
    Bool
    Str
    Unit

    # Collection types
    Array(elem_ty: HirType)
    Dict(key_ty: HirType, val_ty: HirType)

    # Const key types
    ConstKeySet(keys: [Symbol])      # Compile-time known keys
    DependentKeys(source: Symbol)    # Runtime-determined keys

    # Generic types
    TypeVar(name: Symbol)
    Generic(base: Symbol, args: [HirType])

impl HirType:
    # ========================================================================
    # Const Key Type Predicates
    # ========================================================================

    fn is_const_key_set() -> bool:
        """Check if type is ConstKeySet"""
        match self:
            case ConstKeySet(_): true
            case _: false

    fn is_dependent_keys() -> bool:
        """Check if type is DependentKeys"""
        match self:
            case DependentKeys(_): true
            case _: false

    fn has_const_keys() -> bool:
        """Check if type has compile-time known keys"""
        self.is_const_key_set()

    # ========================================================================
    # Key Extraction
    # ========================================================================

    fn get_keys() -> [Symbol]:
        """
        Get keys if ConstKeySet, empty otherwise

        Returns:
            List of keys for ConstKeySet
            Empty list for other types
        """
        match self:
            case ConstKeySet(keys): keys
            case _: []

    fn get_key_count() -> i64:
        """Count number of keys"""
        val keys = self.get_keys()
        keys.len()

    fn has_key(key: Symbol) -> bool:
        """Check if specific key exists"""
        val keys = self.get_keys()
        key in keys

    # ========================================================================
    # Type Equality with Const Keys
    # ========================================================================

    fn equals(other: HirType) -> bool:
        """
        Check type equality including const keys

        ConstKeySet equality:
            - Keys must match exactly (order matters)
            - Use structural equality for key lists
        """
        match (self, other):
            case (Int, Int): true
            case (Float, Float): true
            case (Bool, Bool): true
            case (Str, Str): true
            case (Unit, Unit): true

            case (Array(e1), Array(e2)):
                e1.equals(e2)

            case (Dict(k1, v1), Dict(k2, v2)):
                k1.equals(k2) and v1.equals(v2)

            case (ConstKeySet(keys1), ConstKeySet(keys2)):
                self.keys_equal(keys1, keys2)

            case (DependentKeys(s1), DependentKeys(s2)):
                s1 == s2

            case (TypeVar(n1), TypeVar(n2)):
                n1 == n2

            case (Generic(b1, args1), Generic(b2, args2)):
                b1 == b2 and self.args_equal(args1, args2)

            case _: false

    fn keys_equal(keys1: [Symbol], keys2: [Symbol]) -> bool:
        """Check if two key lists are equal"""
        if keys1.len() != keys2.len():
            return false

        var i = 0
        while i < keys1.len():
            if keys1[i] != keys2[i]:
                return false
            i = i + 1

        true

    fn args_equal(args1: [HirType], args2: [HirType]) -> bool:
        """Check if two type argument lists are equal"""
        if args1.len() != args2.len():
            return false

        var i = 0
        while i < args1.len():
            if not args1[i].equals(args2[i]):
                return false
            i = i + 1

        true

    # ========================================================================
    # String Representation
    # ========================================================================

    fn to_string() -> text:
        """String representation including const keys"""
        match self:
            case Int: "i64"
            case Float: "f64"
            case Bool: "bool"
            case Str: "text"
            case Unit: "()"

            case Array(elem_ty):
                "[{elem_ty.to_string()}]"

            case Dict(key_ty, val_ty):
                "Dict<{key_ty.to_string()}, {val_ty.to_string()}>"

            case ConstKeySet(keys):
                val keys_str = self.format_keys(keys)
                "ConstKeySet<[{keys_str}]>"

            case DependentKeys(source):
                "DependentKeys<{source}>"

            case TypeVar(name):
                name

            case Generic(base, args):
                val args_str = self.format_type_args(args)
                "{base}<{args_str}>"

    fn format_keys(keys: [Symbol]) -> text:
        """Format key list for display"""
        if keys.len() == 0:
            return ""

        var result = "\"{keys[0]}\""
        var i = 1
        while i < keys.len():
            result = result + ", \"{keys[i]}\""
            i = i + 1

        result

    fn format_type_args(args: [HirType]) -> text:
        """Format type argument list"""
        if args.len() == 0:
            return ""

        var result = args[0].to_string()
        var i = 1
        while i < args.len():
            result = result + ", " + args[i].to_string()
            i = i + 1

        result

# ============================================================================
# Template Type Inference (Phase 8B)
# ============================================================================

class TemplateTypeInference:
    """
    Infer ConstKeySet type for string templates

    Algorithm:
    1. Check if string literal contains {key} patterns
    2. Extract keys using KeyExtractor
    3. Return ConstKeySet if keys found, Str otherwise
    """

impl TemplateTypeInference:
    static fn infer_template(value: text) -> HirType:
        """
        Infer type of string literal

        Returns:
            ConstKeySet if template (has keys)
            Str if plain string (no keys)
        """
        val keys = KeyExtractor.extract_keys(value)

        if keys.len() > 0:
            HirType.ConstKeySet(keys: keys)
        else:
            HirType.Str

    static fn is_template(value: text) -> bool:
        """Check if string is a template"""
        val keys = KeyExtractor.extract_keys(value)
        keys.len() > 0

    static fn extract_keys_from_str(value: text) -> [Symbol]:
        """Extract keys from string literal"""
        KeyExtractor.extract_keys(value)

# ============================================================================
# Key Validation Errors (Phase 8C)
# ============================================================================

enum KeyError:
    """
    Key validation errors

    Variants:
    - MissingKeys: Required keys not provided
    - ExtraKeys: Unknown keys provided
    - NotConstKeySet: Template doesn't have const keys
    - BothErrors: Both missing and extra keys
    """
    MissingKeys(keys: [Symbol])
    ExtraKeys(keys: [Symbol])
    NotConstKeySet(message: text)
    BothErrors(missing: [Symbol], extra: [Symbol])

impl KeyError:
    fn to_string() -> text:
        """Error message"""
        match self:
            case MissingKeys(keys):
                val keys_str = format_key_list(keys)
                "Missing keys: [{keys_str}]"

            case ExtraKeys(keys):
                val keys_str = format_key_list(keys)
                "Unknown keys: [{keys_str}]"

            case NotConstKeySet(msg):
                msg

            case BothErrors(missing, extra):
                val missing_str = format_key_list(missing)
                val extra_str = format_key_list(extra)
                "Missing keys: [{missing_str}]; Unknown keys: [{extra_str}]"

    fn is_missing_keys() -> bool:
        match self:
            case MissingKeys(_): true
            case BothErrors(_, _): true
            case _: false

    fn is_extra_keys() -> bool:
        match self:
            case ExtraKeys(_): true
            case BothErrors(_, _): true
            case _: false

fn format_key_list(keys: [Symbol]) -> text:
    """Format key list for error message"""
    if keys.len() == 0:
        return ""

    var result = "\"{keys[0]}\""
    var i = 1
    while i < keys.len():
        result = result + ", \"{keys[i]}\""
        i = i + 1

    result

# ============================================================================
# Const Key Validator (Phase 8C)
# ============================================================================

class ConstKeyValidator:
    """
    Validates keys in .with() calls

    Algorithm:
    1. Check template type is ConstKeySet
    2. Find missing keys (required but not provided)
    3. Find extra keys (provided but not required)
    4. Return error if any issues found
    """

impl ConstKeyValidator:
    static fn validate_with_call(
        tmpl_ty: HirType,
        provided_keys: [Symbol]
    ) -> Result<(), KeyError>:
        """
        Validate .with() call against template type

        Args:
            tmpl_ty: Template type (must be ConstKeySet)
            provided_keys: Keys provided in .with() dict

        Returns:
            Ok(()) if valid
            Err(KeyError) if validation fails
        """
        # Check template type is ConstKeySet
        if not tmpl_ty.is_const_key_set():
            val msg = "Not a template with const keys"
            return Err(KeyError.NotConstKeySet(message: msg))

        val required_keys = tmpl_ty.get_keys()

        # Find missing and extra keys
        val missing = find_missing_keys(required_keys, provided_keys)
        val extra = find_extra_keys(required_keys, provided_keys)

        # Return appropriate error
        if missing.len() > 0 and extra.len() > 0:
            return Err(KeyError.BothErrors(missing: missing, extra: extra))

        if missing.len() > 0:
            return Err(KeyError.MissingKeys(keys: missing))

        if extra.len() > 0:
            return Err(KeyError.ExtraKeys(keys: extra))

        Ok(())

    static fn validate_keys_match(
        required: [Symbol],
        provided: [Symbol]
    ) -> bool:
        """
        Check if provided keys match required keys exactly

        Returns: true if all required keys provided and no extras
        """
        val missing = find_missing_keys(required, provided)
        val extra = find_extra_keys(required, provided)

        missing.len() == 0 and extra.len() == 0

    static fn has_missing_keys(
        required: [Symbol],
        provided: [Symbol]
    ) -> bool:
        """Check if any required keys are missing"""
        val missing = find_missing_keys(required, provided)
        missing.len() > 0

    static fn has_extra_keys(
        required: [Symbol],
        provided: [Symbol]
    ) -> bool:
        """Check if any extra keys provided"""
        val extra = find_extra_keys(required, provided)
        extra.len() > 0

fn find_missing_keys(required: [Symbol], provided: [Symbol]) -> [Symbol]:
    """
    Find keys in required but not in provided

    Algorithm: For each required key, check if it's in provided list
    """
    var missing = []

    for key in required:
        if key not in provided:
            missing.push(key)

    missing

fn find_extra_keys(required: [Symbol], provided: [Symbol]) -> [Symbol]:
    """
    Find keys in provided but not in required

    Algorithm: For each provided key, check if it's in required list
    """
    var extra = []

    for key in provided:
        if key not in required:
            extra.push(key)

    extra

# ============================================================================
# Result Type (Phase 8C)
# ============================================================================

enum Result<T, E>:
    Ok(value: T)
    Err(error: E)

impl Result<T, E>:
    fn is_ok() -> bool:
        match self:
            case Ok(_): true
            case _: false

    fn is_err() -> bool:
        match self:
            case Err(_): true
            case _: false

    fn unwrap() -> T:
        match self:
            case Ok(value): value
            case Err(_):
                assert false, "Called unwrap on Err"
                # Unreachable but needed for type checking
                val dummy = 0
                dummy as T

    fn unwrap_err() -> E:
        match self:
            case Err(error): error
            case Ok(_):
                assert false, "Called unwrap_err on Ok"
                val dummy = 0
                dummy as E

# ============================================================================
# Tests - Phase 8A (13 tests)
# ============================================================================

fn test_extract_single_key():
    """Test extracting single key"""
    val tmpl = "Hello {name}"
    val keys = KeyExtractor.extract_keys(tmpl)

    assert keys.len() == 1, "One key"
    assert keys[0] == "name", "Key is 'name'"

    print "  Extract single key"

fn test_extract_multiple_keys():
    """Test extracting multiple keys"""
    val tmpl = "User {name} has {points} points"
    val keys = KeyExtractor.extract_keys(tmpl)

    assert keys.len() == 2, "Two keys"
    assert keys[0] == "name", "First key is 'name'"
    assert keys[1] == "points", "Second key is 'points'"

    print "  Extract multiple keys"

fn test_extract_no_keys():
    """Test extracting from plain string (no keys)"""
    val tmpl = "Hello world"
    val keys = KeyExtractor.extract_keys(tmpl)

    assert keys.len() == 0, "No keys"

    print "  Extract no keys"

fn test_extract_duplicate_keys():
    """Test extracting duplicate keys"""
    val tmpl = "{x} + {x} = {sum}"
    val keys = KeyExtractor.extract_keys(tmpl)

    assert keys.len() == 3, "Three keys (including duplicate)"
    assert keys[0] == "x", "First x"
    assert keys[1] == "x", "Second x (duplicate)"
    assert keys[2] == "sum", "sum"

    print "  Extract duplicate keys"

fn test_has_keys():
    """Test has_keys predicate"""
    val tmpl1 = "Hello {name}"
    val tmpl2 = "Hello world"

    assert KeyExtractor.has_keys(tmpl1), "Has keys"
    assert not KeyExtractor.has_keys(tmpl2), "No keys"

    print "  Has keys predicate"

fn test_unique_keys():
    """Test unique key extraction"""
    val tmpl = "{x} + {x} = {sum}"
    val unique = KeyExtractor.unique_keys(tmpl)

    assert unique.len() == 2, "Two unique keys"
    assert unique[0] == "x", "x"
    assert unique[1] == "sum", "sum"

    print "  Unique keys"

fn test_key_count():
    """Test key counting"""
    val tmpl1 = "Hello {name}"
    val tmpl2 = "{x} + {y} = {sum}"
    val tmpl3 = "No keys"

    assert KeyExtractor.key_count(tmpl1) == 1, "One key"
    assert KeyExtractor.key_count(tmpl2) == 3, "Three keys"
    assert KeyExtractor.key_count(tmpl3) == 0, "No keys"

    print "  Key count"

fn test_const_key_set_from_template():
    """Test creating ConstKeySet from template"""
    val tmpl = "Hello {name}, you are {age} years old"
    val key_set = ConstKeySet.from_template(tmpl)

    assert key_set.key_count() == 2, "Two keys"
    assert key_set.has_key("name"), "Has name"
    assert key_set.has_key("age"), "Has age"

    print "  ConstKeySet from template"

fn test_const_key_set_empty():
    """Test empty ConstKeySet"""
    val key_set = ConstKeySet.empty()

    assert key_set.is_empty(), "Is empty"
    assert key_set.key_count() == 0, "Zero keys"

    print "  Empty ConstKeySet"

fn test_const_key_set_has_key():
    """Test has_key method"""
    val key_set = ConstKeySet.from_keys(["name", "age"])

    assert key_set.has_key("name"), "Has name"
    assert key_set.has_key("age"), "Has age"
    assert not key_set.has_key("unknown"), "Doesn't have unknown"

    print "  ConstKeySet has_key"

fn test_const_key_set_missing_keys():
    """Test finding missing keys"""
    val key_set = ConstKeySet.from_keys(["name", "age", "email"])
    val provided = ["name", "age"]

    val missing = key_set.missing_keys(provided)

    assert missing.len() == 1, "One missing key"
    assert missing[0] == "email", "Missing email"

    print "  ConstKeySet missing keys"

fn test_const_key_set_extra_keys():
    """Test finding extra keys"""
    val key_set = ConstKeySet.from_keys(["name", "age"])
    val provided = ["name", "age", "unknown", "extra"]

    val extra = key_set.extra_keys(provided)

    assert extra.len() == 2, "Two extra keys"
    assert extra[0] == "unknown", "Extra: unknown"
    assert extra[1] == "extra", "Extra: extra"

    print "  ConstKeySet extra keys"

fn test_const_key_set_perfect_match():
    """Test perfect match (no missing, no extra)"""
    val key_set = ConstKeySet.from_keys(["name", "age"])
    val provided = ["name", "age"]

    val missing = key_set.missing_keys(provided)
    val extra = key_set.extra_keys(provided)

    assert missing.len() == 0, "No missing"
    assert extra.len() == 0, "No extra"

    print "  Perfect key match"

# ============================================================================
# Tests - Phase 8B (12 tests)
# ============================================================================

fn test_const_key_set_type():
    """Test ConstKeySet type creation"""
    val ty = HirType.ConstKeySet(keys: ["name", "age"])

    assert ty.is_const_key_set(), "Is ConstKeySet"
    assert not ty.is_dependent_keys(), "Not DependentKeys"
    assert ty.has_const_keys(), "Has const keys"

    print "  ConstKeySet type creation"

fn test_get_keys():
    """Test key extraction from type"""
    val ty = HirType.ConstKeySet(keys: ["x", "y", "z"])
    val keys = ty.get_keys()

    assert keys.len() == 3, "Three keys"
    assert keys[0] == "x", "First key is x"
    assert keys[1] == "y", "Second key is y"
    assert keys[2] == "z", "Third key is z"

    print "  Get keys from type"

fn test_get_keys_empty():
    """Test get_keys on non-ConstKeySet types"""
    val str_ty = HirType.Str
    val keys = str_ty.get_keys()

    assert keys.len() == 0, "No keys for Str type"

    print "  Get keys empty for non-ConstKeySet"

fn test_has_key():
    """Test key membership check"""
    val ty = HirType.ConstKeySet(keys: ["name", "email"])

    assert ty.has_key("name"), "Has name"
    assert ty.has_key("email"), "Has email"
    assert not ty.has_key("age"), "Doesn't have age"

    print "  Has key check"

fn test_hir_key_count():
    """Test key counting on HirType"""
    val ty1 = HirType.ConstKeySet(keys: [])
    val ty2 = HirType.ConstKeySet(keys: ["a"])
    val ty3 = HirType.ConstKeySet(keys: ["a", "b", "c"])

    assert ty1.get_key_count() == 0, "Zero keys"
    assert ty2.get_key_count() == 1, "One key"
    assert ty3.get_key_count() == 3, "Three keys"

    print "  HirType key count"

fn test_type_equality_const_key_set():
    """Test ConstKeySet type equality"""
    val ty1 = HirType.ConstKeySet(keys: ["name", "age"])
    val ty2 = HirType.ConstKeySet(keys: ["name", "age"])
    val ty3 = HirType.ConstKeySet(keys: ["age", "name"])  # Different order
    val ty4 = HirType.ConstKeySet(keys: ["name"])  # Different keys

    assert ty1.equals(ty2), "Same keys, same order: equal"
    assert not ty1.equals(ty3), "Same keys, different order: not equal"
    assert not ty1.equals(ty4), "Different keys: not equal"

    print "  ConstKeySet type equality"

fn test_type_equality_other():
    """Test type equality for other types"""
    val int_ty = HirType.Int
    val str_ty = HirType.Str
    val arr_ty = HirType.Array(elem_ty: HirType.Int)

    assert int_ty.equals(HirType.Int), "Int equals Int"
    assert not int_ty.equals(str_ty), "Int not equals Str"
    assert arr_ty.equals(HirType.Array(elem_ty: HirType.Int)), "Array equals"

    print "  Type equality for other types"

fn test_infer_template_with_keys():
    """Test inference for template with keys"""
    val tmpl = "Hello {name}, you are {age} years old"
    val ty = TemplateTypeInference.infer_template(tmpl)

    assert ty.is_const_key_set(), "Is ConstKeySet"
    val keys = ty.get_keys()
    assert keys.len() == 2, "Two keys"
    assert keys[0] == "name", "First key is name"
    assert keys[1] == "age", "Second key is age"

    print "  Infer template with keys"

fn test_infer_plain_string():
    """Test inference for plain string (no keys)"""
    val plain = "Hello world"
    val ty = TemplateTypeInference.infer_template(plain)

    assert not ty.is_const_key_set(), "Not ConstKeySet"
    assert ty.equals(HirType.Str), "Is Str type"

    print "  Infer plain string"

fn test_is_template():
    """Test template detection"""
    val tmpl = "User {id} has {points} points"
    val plain = "No keys here"

    assert TemplateTypeInference.is_template(tmpl), "Is template"
    assert not TemplateTypeInference.is_template(plain), "Not template"

    print "  Template detection"

fn test_const_key_set_to_string():
    """Test string representation"""
    val ty1 = HirType.ConstKeySet(keys: ["name", "age"])
    val ty2 = HirType.ConstKeySet(keys: [])

    val str1 = ty1.to_string()
    val str2 = ty2.to_string()

    assert str1 == "ConstKeySet<[\"name\", \"age\"]>", "String with keys"
    assert str2 == "ConstKeySet<[]>", "String with no keys"

    print "  ConstKeySet to_string"

fn test_dependent_keys_type():
    """Test DependentKeys type"""
    val ty = HirType.DependentKeys(source: "user_input")

    assert ty.is_dependent_keys(), "Is DependentKeys"
    assert not ty.is_const_key_set(), "Not ConstKeySet"
    assert not ty.has_const_keys(), "No const keys"

    val str_repr = ty.to_string()
    assert str_repr == "DependentKeys<user_input>", "String representation"

    print "  DependentKeys type"

# ============================================================================
# Tests - Phase 8C (12 tests)
# ============================================================================

fn test_validate_with_call_success():
    """Test successful validation (all keys provided)"""
    val tmpl_ty = HirType.ConstKeySet(keys: ["name", "age"])
    val provided = ["name", "age"]

    val result = ConstKeyValidator.validate_with_call(tmpl_ty, provided)

    assert result.is_ok(), "Validation should succeed"

    print "  Valid with call"

fn test_validate_with_call_missing_keys():
    """Test validation with missing keys"""
    val tmpl_ty = HirType.ConstKeySet(keys: ["name", "age", "email"])
    val provided = ["name", "age"]

    val result = ConstKeyValidator.validate_with_call(tmpl_ty, provided)

    assert result.is_err(), "Should fail: missing email"
    val err = result.unwrap_err()
    assert err.is_missing_keys(), "Error is MissingKeys"

    print "  Missing keys detected"

fn test_validate_with_call_extra_keys():
    """Test validation with extra keys"""
    val tmpl_ty = HirType.ConstKeySet(keys: ["name"])
    val provided = ["name", "age", "unknown"]

    val result = ConstKeyValidator.validate_with_call(tmpl_ty, provided)

    assert result.is_err(), "Should fail: extra keys"
    val err = result.unwrap_err()
    assert err.is_extra_keys(), "Error is ExtraKeys"

    print "  Extra keys detected"

fn test_validate_with_call_both_errors():
    """Test validation with both missing and extra keys"""
    val tmpl_ty = HirType.ConstKeySet(keys: ["name", "email"])
    val provided = ["name", "age"]  # Missing: email, Extra: age

    val result = ConstKeyValidator.validate_with_call(tmpl_ty, provided)

    assert result.is_err(), "Should fail: both errors"
    val err = result.unwrap_err()
    assert err.is_missing_keys(), "Has missing keys"
    assert err.is_extra_keys(), "Has extra keys"

    print "  Both errors detected"

fn test_validate_with_call_not_const_key_set():
    """Test validation with non-ConstKeySet type"""
    val str_ty = HirType.Str
    val provided = ["name"]

    val result = ConstKeyValidator.validate_with_call(str_ty, provided)

    assert result.is_err(), "Should fail: not ConstKeySet"
    val err = result.unwrap_err()

    match err:
        case NotConstKeySet(_): pass
        case _: assert false, "Expected NotConstKeySet error"

    print "  Not ConstKeySet detected"

fn test_validate_keys_match():
    """Test exact key matching"""
    val required = ["name", "age"]
    val provided1 = ["name", "age"]
    val provided2 = ["name"]
    val provided3 = ["name", "age", "email"]

    assert ConstKeyValidator.validate_keys_match(required, provided1), "Exact match"
    assert not ConstKeyValidator.validate_keys_match(required, provided2), "Missing key"
    assert not ConstKeyValidator.validate_keys_match(required, provided3), "Extra key"

    print "  Keys match validation"

fn test_has_missing_keys():
    """Test missing key detection"""
    val required = ["name", "age", "email"]
    val provided1 = ["name", "age", "email"]
    val provided2 = ["name", "age"]

    assert not ConstKeyValidator.has_missing_keys(required, provided1), "No missing"
    assert ConstKeyValidator.has_missing_keys(required, provided2), "Has missing"

    print "  Has missing keys"

fn test_has_extra_keys():
    """Test extra key detection"""
    val required = ["name"]
    val provided1 = ["name"]
    val provided2 = ["name", "age"]

    assert not ConstKeyValidator.has_extra_keys(required, provided1), "No extra"
    assert ConstKeyValidator.has_extra_keys(required, provided2), "Has extra"

    print "  Has extra keys"

fn test_find_missing_keys():
    """Test missing key finding"""
    val required = ["name", "age", "email"]
    val provided = ["name", "age"]

    val missing = find_missing_keys(required, provided)

    assert missing.len() == 1, "One missing key"
    assert missing[0] == "email", "Missing: email"

    print "  Find missing keys"

fn test_find_extra_keys():
    """Test extra key finding"""
    val required = ["name", "age"]
    val provided = ["name", "age", "unknown", "extra"]

    val extra = find_extra_keys(required, provided)

    assert extra.len() == 2, "Two extra keys"
    assert extra[0] == "unknown", "Extra: unknown"
    assert extra[1] == "extra", "Extra: extra"

    print "  Find extra keys"

fn test_key_error_to_string():
    """Test error message formatting"""
    val err1 = KeyError.MissingKeys(keys: ["age", "email"])
    val err2 = KeyError.ExtraKeys(keys: ["unknown"])
    val err3 = KeyError.BothErrors(missing: ["age"], extra: ["unknown"])

    val msg1 = err1.to_string()
    val msg2 = err2.to_string()
    val msg3 = err3.to_string()

    assert msg1 == "Missing keys: [\"age\", \"email\"]", "Missing keys message"
    assert msg2 == "Unknown keys: [\"unknown\"]", "Extra keys message"

    # msg3 should contain both missing and unknown
    assert "Missing" in msg3, "Contains Missing"
    assert "Unknown" in msg3, "Contains Unknown"

    print "  Error message formatting"

fn test_typo_detection():
    """Test typo detection (missing + extra with similar names)"""
    val tmpl_ty = HirType.ConstKeySet(keys: ["name", "age"])
    val provided = ["name", "ag"]  # Typo: "ag" instead of "age"

    val result = ConstKeyValidator.validate_with_call(tmpl_ty, provided)

    assert result.is_err(), "Should detect typo"
    val err = result.unwrap_err()
    assert err.is_missing_keys(), "Has missing: age"
    assert err.is_extra_keys(), "Has extra: ag"

    print "  Typo detection"

# ============================================================================
# Main - Combined test runner
# ============================================================================

fn main():
    print ""
    print "Const Keys - Consolidated Tests (Phase 8A-8C)"
    print "=============================================="

    print ""
    print "Phase 8A: Key Extraction (13 tests)"
    print "------------------------------------"
    test_extract_single_key()
    test_extract_multiple_keys()
    test_extract_no_keys()
    test_extract_duplicate_keys()
    test_has_keys()
    test_unique_keys()
    test_key_count()
    test_const_key_set_from_template()
    test_const_key_set_empty()
    test_const_key_set_has_key()
    test_const_key_set_missing_keys()
    test_const_key_set_extra_keys()
    test_const_key_set_perfect_match()

    print ""
    print "Phase 8B: ConstKeySet Type (12 tests)"
    print "--------------------------------------"
    test_const_key_set_type()
    test_get_keys()
    test_get_keys_empty()
    test_has_key()
    test_hir_key_count()
    test_type_equality_const_key_set()
    test_type_equality_other()
    test_infer_template_with_keys()
    test_infer_plain_string()
    test_is_template()
    test_const_key_set_to_string()
    test_dependent_keys_type()

    print ""
    print "Phase 8C: Key Validation (12 tests)"
    print "------------------------------------"
    test_validate_with_call_success()
    test_validate_with_call_missing_keys()
    test_validate_with_call_extra_keys()
    test_validate_with_call_both_errors()
    test_validate_with_call_not_const_key_set()
    test_validate_keys_match()
    test_has_missing_keys()
    test_has_extra_keys()
    test_find_missing_keys()
    test_find_extra_keys()
    test_key_error_to_string()
    test_typo_detection()

    print ""
    print "All 37 tests passed!"
    print ""
