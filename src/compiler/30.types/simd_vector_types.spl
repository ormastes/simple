# SIMD Vector Types - Extracted from simd.spl
#
# Vector types: Vec2f, Vec4f, Vec8f (f32), Vec2d, Vec4d (f64)
# Constructors, element access, arithmetic, reductions, comparisons, utilities.

type Symbol = text

# ============================================================================
# Vector Types
# ============================================================================

struct Vec2f:
    """2-element f32 vector (64-bit aligned)"""
    x: f32
    y: f32

impl Vec2f:
    static fn splat(value: f32) -> Vec2f:
        """Create vector with all elements set to value"""
        Vec2f(x: value, y: value)

    static fn from_array(arr: [f32]) -> Vec2f:
        """Create from array (must have 2+ elements)"""
        assert arr.len() >= 2, "Array must have at least 2 elements"
        Vec2f(x: arr[0], y: arr[1])

    static fn zero() -> Vec2f:
        """Zero vector"""
        Vec2f(x: 0.0, y: 0.0)

    fn to_array() -> [f32]:
        """Convert to array"""
        [self.x, self.y]

    fn get(index: i64) -> f32:
        """Get element by index"""
        match index:
            case 0: self.x
            case 1: self.y
            case _:
                assert false, "Index out of bounds: {index}"
                0.0  # Unreachable but needed for type checking

    fn set(index: i64, value: f32) -> Vec2f:
        """Set element by index (returns new vector)"""
        match index:
            case 0: Vec2f(x: value, y: self.y)
            case 1: Vec2f(x: self.x, y: value)
            case _:
                assert false, "Index out of bounds: {index}"
                self

    fn to_string() -> text:
        """String representation"""
        "Vec2f({self.x}, {self.y})"

struct Vec4f:
    """4-element f32 vector (128-bit SSE register)"""
    x: f32
    y: f32
    z: f32
    w: f32

impl Vec4f:
    # ========================================================================
    # Constructors
    # ========================================================================

    static fn splat(value: f32) -> Vec4f:
        """Create vector with all elements set to value"""
        Vec4f(x: value, y: value, z: value, w: value)

    static fn from_array(arr: [f32]) -> Vec4f:
        """Create from array (must have 4+ elements)"""
        assert arr.len() >= 4, "Array must have at least 4 elements"
        Vec4f(x: arr[0], y: arr[1], z: arr[2], w: arr[3])

    static fn zero() -> Vec4f:
        """Zero vector"""
        Vec4f(x: 0.0, y: 0.0, z: 0.0, w: 0.0)

    fn to_array() -> [f32]:
        """Convert to array"""
        [self.x, self.y, self.z, self.w]

    fn get(index: i64) -> f32:
        """Get element by index"""
        match index:
            case 0: self.x
            case 1: self.y
            case 2: self.z
            case 3: self.w
            case _:
                assert false, "Index out of bounds: {index}"
                0.0

    fn set(index: i64, value: f32) -> Vec4f:
        """Set element by index (returns new vector)"""
        match index:
            case 0: Vec4f(x: value, y: self.y, z: self.z, w: self.w)
            case 1: Vec4f(x: self.x, y: value, z: self.z, w: self.w)
            case 2: Vec4f(x: self.x, y: self.y, z: value, w: self.w)
            case 3: Vec4f(x: self.x, y: self.y, z: self.z, w: value)
            case _:
                assert false, "Index out of bounds: {index}"
                self

    fn to_string() -> text:
        """String representation"""
        "Vec4f({self.x}, {self.y}, {self.z}, {self.w})"

    # ========================================================================
    # Arithmetic Operations (SIMD-optimized)
    # ========================================================================

    fn add(other: Vec4f) -> Vec4f:
        """Vector addition (SIMD)"""
        Vec4f(
            x: self.x + other.x,
            y: self.y + other.y,
            z: self.z + other.z,
            w: self.w + other.w
        )

    fn sub(other: Vec4f) -> Vec4f:
        """Vector subtraction (SIMD)"""
        Vec4f(
            x: self.x - other.x,
            y: self.y - other.y,
            z: self.z - other.z,
            w: self.w - other.w
        )

    fn mul(other: Vec4f) -> Vec4f:
        """Element-wise multiplication (SIMD)"""
        Vec4f(
            x: self.x * other.x,
            y: self.y * other.y,
            z: self.z * other.z,
            w: self.w * other.w
        )

    fn div(other: Vec4f) -> Vec4f:
        """Element-wise division (SIMD)"""
        Vec4f(
            x: self.x / other.x,
            y: self.y / other.y,
            z: self.z / other.z,
            w: self.w / other.w
        )

    # ========================================================================
    # Scalar Operations
    # ========================================================================

    fn scale(scalar: f32) -> Vec4f:
        """Multiply by scalar"""
        Vec4f(
            x: self.x * scalar,
            y: self.y * scalar,
            z: self.z * scalar,
            w: self.w * scalar
        )

    fn scale_add(scalar: f32, offset: f32) -> Vec4f:
        """Multiply by scalar and add offset: v * scalar + offset"""
        Vec4f(
            x: self.x * scalar + offset,
            y: self.y * scalar + offset,
            z: self.z * scalar + offset,
            w: self.w * scalar + offset
        )

    # ========================================================================
    # Reductions (SIMD with horizontal ops)
    # ========================================================================

    fn sum() -> f32:
        """Sum all elements"""
        self.x + self.y + self.z + self.w

    fn product() -> f32:
        """Product of all elements"""
        self.x * self.y * self.z * self.w

    fn min_element() -> f32:
        """Minimum element"""
        val xy = if self.x < self.y: self.x else: self.y
        val zw = if self.z < self.w: self.z else: self.w
        if xy < zw: xy else: zw

    fn max_element() -> f32:
        """Maximum element"""
        val xy = if self.x > self.y: self.x else: self.y
        val zw = if self.z > self.w: self.z else: self.w
        if xy > zw: xy else: zw

    # ========================================================================
    # Dot Product and Length
    # ========================================================================

    fn dot(other: Vec4f) -> f32:
        """Dot product: sum of element-wise multiplication"""
        val prod = self.mul(other)
        prod.sum()

    fn length_squared() -> f32:
        """Squared length (avoids sqrt)"""
        self.dot(self)

    fn length() -> f32:
        """Vector length (magnitude)"""
        self.length_squared().sqrt()

    fn distance_squared(other: Vec4f) -> f32:
        """Squared distance to other vector"""
        val diff = self.sub(other)
        diff.length_squared()

    fn distance(other: Vec4f) -> f32:
        """Distance to other vector"""
        self.distance_squared(other).sqrt()

    fn normalize() -> Vec4f:
        """Normalized vector (unit length)"""
        val len = self.length()
        if len > 0.0:
            self.scale(1.0 / len)
        else:
            Vec4f.zero()

    # ========================================================================
    # Comparisons
    # ========================================================================

    fn equals(other: Vec4f) -> bool:
        """Element-wise equality (exact)"""
        (self.x == other.x and
        self.y == other.y and
        self.z == other.z and
        self.w == other.w)

    fn approx_equals(other: Vec4f, epsilon: f32) -> bool:
        """Element-wise approximate equality"""
        val diff = self.sub(other)
        val abs_x = if diff.x < 0.0: -diff.x else: diff.x
        val abs_y = if diff.y < 0.0: -diff.y else: diff.y
        val abs_z = if diff.z < 0.0: -diff.z else: diff.z
        val abs_w = if diff.w < 0.0: -diff.w else: diff.w

        abs_x < epsilon and abs_y < epsilon and abs_z < epsilon and abs_w < epsilon

    fn less_than(other: Vec4f) -> [bool]:
        """Element-wise less than"""
        [
            self.x < other.x,
            self.y < other.y,
            self.z < other.z,
            self.w < other.w
        ]

    fn less_than_or_equal(other: Vec4f) -> [bool]:
        """Element-wise less than or equal"""
        [
            self.x <= other.x,
            self.y <= other.y,
            self.z <= other.z,
            self.w <= other.w
        ]

    # ========================================================================
    # Min/Max Operations
    # ========================================================================

    fn min(other: Vec4f) -> Vec4f:
        """Element-wise minimum"""
        Vec4f(
            x: if self.x < other.x: self.x else: other.x,
            y: if self.y < other.y: self.y else: other.y,
            z: if self.z < other.z: self.z else: other.z,
            w: if self.w < other.w: self.w else: other.w
        )

    fn max(other: Vec4f) -> Vec4f:
        """Element-wise maximum"""
        Vec4f(
            x: if self.x > other.x: self.x else: other.x,
            y: if self.y > other.y: self.y else: other.y,
            z: if self.z > other.z: self.z else: other.z,
            w: if self.w > other.w: self.w else: other.w
        )

    fn clamp(min_val: Vec4f, max_val: Vec4f) -> Vec4f:
        """Clamp each element to [min, max]"""
        self.max(min_val).min(max_val)

    # ========================================================================
    # Utility Functions
    # ========================================================================

    fn abs() -> Vec4f:
        """Absolute value of each element"""
        Vec4f(
            x: if self.x < 0.0: -self.x else: self.x,
            y: if self.y < 0.0: -self.y else: self.y,
            z: if self.z < 0.0: -self.z else: self.z,
            w: if self.w < 0.0: -self.w else: self.w
        )

    fn negate() -> Vec4f:
        """Negate each element"""
        Vec4f(x: -self.x, y: -self.y, z: -self.z, w: -self.w)

    fn reciprocal() -> Vec4f:
        """Reciprocal of each element (1/x)"""
        Vec4f(
            x: 1.0 / self.x,
            y: 1.0 / self.y,
            z: 1.0 / self.z,
            w: 1.0 / self.w
        )

struct Vec8f:
    """8-element f32 vector (256-bit AVX register)"""
    e0: f32
    e1: f32
    e2: f32
    e3: f32
    e4: f32
    e5: f32
    e6: f32
    e7: f32

impl Vec8f:
    static fn splat(value: f32) -> Vec8f:
        """Create vector with all elements set to value"""
        Vec8f(
            e0: value, e1: value, e2: value, e3: value,
            e4: value, e5: value, e6: value, e7: value
        )

    static fn from_array(arr: [f32]) -> Vec8f:
        """Create from array (must have 8+ elements)"""
        assert arr.len() >= 8, "Array must have at least 8 elements"
        Vec8f(
            e0: arr[0], e1: arr[1], e2: arr[2], e3: arr[3],
            e4: arr[4], e5: arr[5], e6: arr[6], e7: arr[7]
        )

    static fn zero() -> Vec8f:
        """Zero vector"""
        Vec8f(
            e0: 0.0, e1: 0.0, e2: 0.0, e3: 0.0,
            e4: 0.0, e5: 0.0, e6: 0.0, e7: 0.0
        )

    fn to_array() -> [f32]:
        """Convert to array"""
        [self.e0, self.e1, self.e2, self.e3, self.e4, self.e5, self.e6, self.e7]

    fn get(index: i64) -> f32:
        """Get element by index"""
        match index:
            case 0: self.e0
            case 1: self.e1
            case 2: self.e2
            case 3: self.e3
            case 4: self.e4
            case 5: self.e5
            case 6: self.e6
            case 7: self.e7
            case _:
                assert false, "Index out of bounds: {index}"
                0.0

    fn set(index: i64, value: f32) -> Vec8f:
        """Set element by index (returns new vector)"""
        match index:
            case 0: Vec8f(e0: value, e1: self.e1, e2: self.e2, e3: self.e3, e4: self.e4, e5: self.e5, e6: self.e6, e7: self.e7)
            case 1: Vec8f(e0: self.e0, e1: value, e2: self.e2, e3: self.e3, e4: self.e4, e5: self.e5, e6: self.e6, e7: self.e7)
            case 2: Vec8f(e0: self.e0, e1: self.e1, e2: value, e3: self.e3, e4: self.e4, e5: self.e5, e6: self.e6, e7: self.e7)
            case 3: Vec8f(e0: self.e0, e1: self.e1, e2: self.e2, e3: value, e4: self.e4, e5: self.e5, e6: self.e6, e7: self.e7)
            case 4: Vec8f(e0: self.e0, e1: self.e1, e2: self.e2, e3: self.e3, e4: value, e5: self.e5, e6: self.e6, e7: self.e7)
            case 5: Vec8f(e0: self.e0, e1: self.e1, e2: self.e2, e3: self.e3, e4: self.e4, e5: value, e6: self.e6, e7: self.e7)
            case 6: Vec8f(e0: self.e0, e1: self.e1, e2: self.e2, e3: self.e3, e4: self.e4, e5: self.e5, e6: value, e7: self.e7)
            case 7: Vec8f(e0: self.e0, e1: self.e1, e2: self.e2, e3: self.e3, e4: self.e4, e5: self.e5, e6: self.e6, e7: value)
            case _:
                assert false, "Index out of bounds: {index}"
                self

    fn to_string() -> text:
        """String representation"""
        "Vec8f({self.e0}, {self.e1}, {self.e2}, {self.e3}, {self.e4}, {self.e5}, {self.e6}, {self.e7})"

struct Vec2d:
    """2-element f64 vector (128-bit aligned)"""
    x: f64
    y: f64

impl Vec2d:
    static fn splat(value: f64) -> Vec2d:
        """Create vector with all elements set to value"""
        Vec2d(x: value, y: value)

    static fn from_array(arr: [f64]) -> Vec2d:
        """Create from array (must have 2+ elements)"""
        assert arr.len() >= 2, "Array must have at least 2 elements"
        Vec2d(x: arr[0], y: arr[1])

    static fn zero() -> Vec2d:
        """Zero vector"""
        Vec2d(x: 0.0, y: 0.0)

    fn to_array() -> [f64]:
        """Convert to array"""
        [self.x, self.y]

    fn get(index: i64) -> f64:
        """Get element by index"""
        match index:
            case 0: self.x
            case 1: self.y
            case _:
                assert false, "Index out of bounds: {index}"
                0.0

    fn set(index: i64, value: f64) -> Vec2d:
        """Set element by index (returns new vector)"""
        match index:
            case 0: Vec2d(x: value, y: self.y)
            case 1: Vec2d(x: self.x, y: value)
            case _:
                assert false, "Index out of bounds: {index}"
                self

    fn to_string() -> text:
        """String representation"""
        "Vec2d({self.x}, {self.y})"

struct Vec4d:
    """4-element f64 vector (256-bit AVX register)"""
    x: f64
    y: f64
    z: f64
    w: f64

impl Vec4d:
    static fn splat(value: f64) -> Vec4d:
        """Create vector with all elements set to value"""
        Vec4d(x: value, y: value, z: value, w: value)

    static fn from_array(arr: [f64]) -> Vec4d:
        """Create from array (must have 4+ elements)"""
        assert arr.len() >= 4, "Array must have at least 4 elements"
        Vec4d(x: arr[0], y: arr[1], z: arr[2], w: arr[3])

    static fn zero() -> Vec4d:
        """Zero vector"""
        Vec4d(x: 0.0, y: 0.0, z: 0.0, w: 0.0)

    fn to_array() -> [f64]:
        """Convert to array"""
        [self.x, self.y, self.z, self.w]

    fn get(index: i64) -> f64:
        """Get element by index"""
        match index:
            case 0: self.x
            case 1: self.y
            case 2: self.z
            case 3: self.w
            case _:
                assert false, "Index out of bounds: {index}"
                0.0

    fn set(index: i64, value: f64) -> Vec4d:
        """Set element by index (returns new vector)"""
        match index:
            case 0: Vec4d(x: value, y: self.y, z: self.z, w: self.w)
            case 1: Vec4d(x: self.x, y: value, z: self.z, w: self.w)
            case 2: Vec4d(x: self.x, y: self.y, z: value, w: self.w)
            case 3: Vec4d(x: self.x, y: self.y, z: self.z, w: value)
            case _:
                assert false, "Index out of bounds: {index}"
                self

    fn to_string() -> text:
        """String representation"""
        "Vec4d({self.x}, {self.y}, {self.z}, {self.w})"
