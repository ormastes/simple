"""
Macro Type Checker - Phase 7B: Macro call type checking

Contains:
- MacroCall: macro call site representation
- TypeEnv: type environment for expression type inference
- MacroTypeChecker: type checker for macro calls
- MacroTypeError: error reporting for macro type errors

Split from macro_checker.spl
"""

# ============================================================================
# Macro Call
# ============================================================================

class MacroCall:
    """
    Macro call site

    Examples:
        @assert(x > 0, "x must be positive")
        @log("INFO", "message1", "message2")
    """
    name: Symbol
    args: [Expr]

impl MacroCall:
    static fn new_call(name: Symbol, args: [Expr]) -> MacroCall:
        MacroCall(name: name, args: args)

    fn arg_count() -> i64:
        self.args.len()

    fn to_string() -> text:
        "@{self.name}({self.arg_count()} args)"

# ============================================================================
# Type Environment
# ============================================================================

class TypeEnv:
    """
    Type environment for inferring expression types
    """
    vars: text  # Dict<Symbol, HirType>

impl TypeEnv:
    static fn empty() -> TypeEnv:
        TypeEnv(vars: {})

    me bind_var(name: Symbol, ty: HirType):
        """Bind variable to type"""
        self.vars[name] = ty

    fn infer_expr(expr: Expr) -> HirType:
        """
        Infer type of expression

        Handles literals, variables, and block expressions
        """
        match expr:
            case IntLit(_): HirType.Int
            case StrLit(_): HirType.Str
            case BoolLit(_): HirType.Bool
            case Var(name):
                if name in self.vars:
                    self.vars[name]
                else:
                    HirType.Unit  # Unknown variable
            case Block(stmts):
                if stmts.len() > 0:
                    self.infer_expr(stmts[stmts.len() - 1])
                else:
                    HirType.Unit
            case _: HirType.Unit

# ============================================================================
# Macro Type Checker
# ============================================================================

class MacroTypeChecker:
    """
    Type checker for macro calls

    Validates:
    - Macro exists
    - Correct number of arguments
    - Argument types match parameters
    """
    registry: MacroRegistry
    type_env: TypeEnv

impl MacroTypeChecker:
    static fn new_checker(registry: MacroRegistry) -> MacroTypeChecker:
        MacroTypeChecker(
            registry: registry,
            type_env: TypeEnv.empty()
        )

    fn check_macro_call(call: MacroCall) -> bool:
        """
        Type check a macro call

        Returns: true if valid, false if error
        """
        # 1. Lookup macro
        if not self.registry.has_macro(call.name):
            return false

        val macro_def = self.registry.lookup_macro(call.name)

        # 2. Check arity
        if not self.check_arity(call.args, macro_def.params):
            return false

        # 3. Check argument types
        for i, (arg, param) in call.args.zip(macro_def.params).enumerate():
            # Infer argument type
            val arg_ty = self.type_env.infer_expr(arg)

            # Check against parameter type
            if not self.types_match(arg_ty, param.ty):
                return false

        true

    fn check_arity(args: [Expr], params: [MacroParam]) -> bool:
        """
        Check argument count matches parameters

        Handles variadic parameters:
        - Non-variadic: exact match
        - Variadic: at least non-variadic count
        """
        val non_variadic_count = self.count_non_variadic(params)
        val has_variadic = self.has_variadic_param(params)

        if has_variadic:
            # At least non_variadic_count arguments
            args.len() >= non_variadic_count
        else:
            # Exact match
            args.len() == params.len()

    fn count_non_variadic(params: [MacroParam]) -> i64:
        """Count non-variadic parameters"""
        var count = 0
        for param in params:
            if not param.is_variadic:
                count = count + 1
        count

    fn has_variadic_param(params: [MacroParam]) -> bool:
        """Check if params has variadic"""
        for param in params:
            if param.is_variadic:
                return true
        false

    fn types_match(ty1: HirType, ty2: HirType) -> bool:
        """
        Check if two types match

        Simplified: exact match only
        """
        match (ty1, ty2):
            case (Int, Int): true
            case (Str, Str): true
            case (Bool, Bool): true
            case (Unit, Unit): true
            case _: false

    fn get_expansion_type(call: MacroCall) -> HirType:
        """
        Get expansion type for a valid macro call

        Assumes call is valid (already checked)
        """
        val macro_def = self.registry.lookup_macro(call.name)
        macro_def.expansion_ty

# ============================================================================
# Error Reporting
# ============================================================================

class MacroTypeError:
    """Macro type error"""
    message: text

impl MacroTypeError:
    static fn macro_not_found(name: Symbol) -> MacroTypeError:
        MacroTypeError(message: "Macro '{name}' not found")

    static fn wrong_arity(name: Symbol, expected: i64, actual: i64) -> MacroTypeError:
        MacroTypeError(
            message: "Macro '{name}': expected {expected} arguments, got {actual}"
        )

    static fn type_mismatch(name: Symbol, arg_idx: i64, expected: HirType, actual: HirType) -> MacroTypeError:
        MacroTypeError(
            message: "Macro '{name}': argument {arg_idx} has type {actual.to_string()}, expected {expected.to_string()}"
        )

    fn to_string() -> text:
        self.message
