"""
Higher-Rank Polymorphism - Tests Phase 5D + Main

Test functions for:
- Phase 5D: Higher-Rank Unification
- main() entry point
"""

use compiler.types.higher_rank_poly_types.{Kind, TypeVar, HirType}
use compiler.types.higher_rank_poly_types.{QuantifierContext, HigherRankUnifier}
use compiler.types.higher_rank_poly_tests_abc.{test_quantifier_basic, test_poly_type_creation}
use compiler.types.higher_rank_poly_tests_abc.{test_nested_forall, test_skolem_type}
use compiler.types.higher_rank_poly_tests_abc.{test_kind_basic, test_type_var, test_type_scheme}
use compiler.types.higher_rank_poly_tests_abc.{test_multiple_quantifiers}
use compiler.types.higher_rank_poly_tests_abc.{test_context_scoping, test_bind_lookup}
use compiler.types.higher_rank_poly_tests_abc.{test_fresh_skolem, test_nested_scopes}
use compiler.types.higher_rank_poly_tests_abc.{test_scope_cleanup, test_quantifier_level}
use compiler.types.higher_rank_poly_tests_abc.{test_scope_tracker, test_reset}
use compiler.types.higher_rank_poly_tests_abc.{test_instantiate_basic, test_instantiate_multiple}
use compiler.types.higher_rank_poly_tests_abc.{test_skolemize_basic, test_skolemize_rigidity}
use compiler.types.higher_rank_poly_tests_abc.{test_deep_skolemize_rank2, test_deep_skolemize_nested}
use compiler.types.higher_rank_poly_tests_abc.{test_contravariance}

# ============================================================================
# Tests - Phase 5D: Higher-Rank Unification
# ============================================================================

fn test_unify_forall_left():
    """Test unification with forall on left"""
    val ctx = QuantifierContext.new()
    val unifier = HigherRankUnifier.new(ctx)

    # forall T. T -> T  ~  i32 -> i32
    val t_var = TypeVar(id: 0, name: "T", kind: Kind.Star)
    val forall_type = HirType.Forall(
        quantifiers: [t_var],
        body: HirType.Arrow(
            from: HirType.TypeVariable(id: 0),
            to: HirType.TypeVariable(id: 0)
        )
    )

    val concrete = HirType.Arrow(
        from: HirType.Int,
        to: HirType.Int
    )

    val result = unifier.unify(forall_type, concrete)
    assert result, "Forall left unifies with concrete"

    print "PASS: Unify forall left"

fn test_unify_forall_right():
    """Test unification with forall on right"""
    val ctx = QuantifierContext.new()
    val unifier = HigherRankUnifier.new(ctx)

    # i32 -> i32  ~  forall T. T -> T
    val concrete = HirType.Arrow(
        from: HirType.Int,
        to: HirType.Int
    )

    val t_var = TypeVar(id: 0, name: "T", kind: Kind.Star)
    val forall_type = HirType.Forall(
        quantifiers: [t_var],
        body: HirType.Arrow(
            from: HirType.TypeVariable(id: 0),
            to: HirType.TypeVariable(id: 0)
        )
    )

    val result = unifier.unify(concrete, forall_type)
    # This should fail because we'd skolemize the right side,
    # getting sk_0 -> sk_0, which can't unify with i32 -> i32
    assert not result, "Concrete doesn't unify with forall right"

    print "PASS: Unify forall right"

fn test_unify_skolem_rigid():
    """Test that skolems are rigid"""
    val ctx = QuantifierContext.new()
    val unifier = HigherRankUnifier.new(ctx)

    # sk_0  ~  ?1  should fail (skolem can't unify with inference var)
    val skolem = HirType.Skolem(id: 0)
    val inference = HirType.TypeVariable(id: 1)

    val result1 = unifier.unify(skolem, inference)
    assert not result1, "Skolem can't unify with inference var"

    val result2 = unifier.unify(inference, skolem)
    assert not result2, "Inference var can't unify with skolem"

    # sk_0  ~  sk_0  should succeed
    val result3 = unifier.unify(skolem, skolem)
    assert result3, "Skolem unifies with itself"

    # sk_0  ~  sk_1  should fail
    val skolem2 = HirType.Skolem(id: 1)
    val result4 = unifier.unify(skolem, skolem2)
    assert not result4, "Different skolems don't unify"

    print "PASS: Skolem rigidity"

fn test_unify_rank2():
    """Test rank-2 unification"""
    val ctx = QuantifierContext.new()
    val unifier = HigherRankUnifier.new(ctx)

    # (forall T. T -> T) -> i32  ~  (i32 -> i32) -> i32
    val t_var = TypeVar(id: 0, name: "T", kind: Kind.Star)
    val inner_forall = HirType.Forall(
        quantifiers: [t_var],
        body: HirType.Arrow(
            from: HirType.TypeVariable(id: 0),
            to: HirType.TypeVariable(id: 0)
        )
    )

    val rank2_type = HirType.Arrow(
        from: inner_forall,
        to: HirType.Int
    )

    val concrete = HirType.Arrow(
        from: HirType.Arrow(from: HirType.Int, to: HirType.Int),
        to: HirType.Int
    )

    # This should fail because:
    # - We instantiate the outer structure
    # - The argument forall T. T -> T becomes sk_0 -> sk_0 (skolemize)
    # - sk_0 -> sk_0 doesn't unify with i32 -> i32
    val result = unifier.unify(rank2_type, concrete)
    assert not result, "Rank-2 type doesn't unify with less polymorphic type"

    print "PASS: Rank-2 unification"

fn test_subsumption_basic():
    """Test basic subsumption"""
    val ctx = QuantifierContext.new()
    val unifier = HigherRankUnifier.new(ctx)

    # forall T. T -> T  subsumes  i32 -> i32
    val t_var = TypeVar(id: 0, name: "T", kind: Kind.Star)
    val poly = HirType.Forall(
        quantifiers: [t_var],
        body: HirType.Arrow(
            from: HirType.TypeVariable(id: 0),
            to: HirType.TypeVariable(id: 0)
        )
    )

    val concrete = HirType.Arrow(
        from: HirType.Int,
        to: HirType.Int
    )

    val result = unifier.subsumes(poly, concrete)
    assert result, "Polymorphic type subsumes concrete"

    print "PASS: Basic subsumption"

fn test_subsumption_rank2():
    """Test rank-2 subsumption"""
    val ctx = QuantifierContext.new()
    val unifier = HigherRankUnifier.new(ctx)

    # forall A. (forall T. T -> T) -> A
    # subsumes
    # (forall U. U -> U) -> i32

    val t_var = TypeVar(id: 0, name: "T", kind: Kind.Star)
    val a_var = TypeVar(id: 1, name: "A", kind: Kind.Star)

    val inner_forall = HirType.Forall(
        quantifiers: [t_var],
        body: HirType.Arrow(
            from: HirType.TypeVariable(id: 0),
            to: HirType.TypeVariable(id: 0)
        )
    )

    val poly1 = HirType.Forall(
        quantifiers: [a_var],
        body: HirType.Arrow(
            from: inner_forall,
            to: HirType.TypeVariable(id: 1)
        )
    )

    val u_var = TypeVar(id: 2, name: "U", kind: Kind.Star)
    val inner_forall2 = HirType.Forall(
        quantifiers: [u_var],
        body: HirType.Arrow(
            from: HirType.TypeVariable(id: 2),
            to: HirType.TypeVariable(id: 2)
        )
    )

    val poly2 = HirType.Arrow(
        from: inner_forall2,
        to: HirType.Int
    )

    val result = unifier.subsumes(poly1, poly2)
    assert result, "Rank-2 subsumption"

    print "PASS: Rank-2 subsumption"

fn test_st_monad():
    """Test ST monad type checking (classic rank-2 example)"""
    val ctx = QuantifierContext.new()
    val unifier = HigherRankUnifier.new(ctx)

    # run_st: forall A. (forall S. ST<S, A> -> A) -> A
    # The key is that S is universally quantified INSIDE the function argument

    # For simplicity, represent ST<S, A> as S -> A
    # run_st: forall A. (forall S. S -> A) -> A

    val s_var = TypeVar(id: 0, name: "S", kind: Kind.Star)
    val a_var = TypeVar(id: 1, name: "A", kind: Kind.Star)

    val inner_forall = HirType.Forall(
        quantifiers: [s_var],
        body: HirType.Arrow(
            from: HirType.TypeVariable(id: 0),
            to: HirType.TypeVariable(id: 1)
        )
    )

    val run_st_type = HirType.Forall(
        quantifiers: [a_var],
        body: HirType.Arrow(
            from: inner_forall,
            to: HirType.TypeVariable(id: 1)
        )
    )

    # Instantiate at i32: (forall S. S -> i32) -> i32
    val inst = unifier.instantiate(run_st_type)

    # Check that inst is an arrow
    match inst:
        case Arrow(from, to):
            match from:
                case Forall(_, _):
                    pass
                case _:
                    assert false, "from should be Forall"
            match to:
                case TypeVariable(_):
                    pass
                case _:
                    assert false, "to should be TypeVariable"
        case _:
            assert false, "Should be Arrow"

    print "PASS: ST monad"

# ============================================================================
# Main
# ============================================================================

fn main():
    print ""
    print "Higher-Rank Polymorphism - Consolidated Tests"
    print "=============================================="
    print ""

    # Phase 5A: Quantifier Representation
    print "--- Phase 5A: Quantifier Representation ---"
    test_quantifier_basic()
    test_poly_type_creation()
    test_nested_forall()
    test_skolem_type()
    test_kind_basic()
    test_type_var()
    test_type_scheme()
    test_multiple_quantifiers()
    print ""

    # Phase 5B: Quantifier Context & Scoping
    print "--- Phase 5B: Quantifier Context & Scoping ---"
    test_context_scoping()
    test_bind_lookup()
    test_fresh_skolem()
    test_nested_scopes()
    test_scope_cleanup()
    test_quantifier_level()
    test_scope_tracker()
    test_reset()
    print ""

    # Phase 5C: Instantiation & Skolemization
    print "--- Phase 5C: Instantiation & Skolemization ---"
    test_instantiate_basic()
    test_instantiate_multiple()
    test_skolemize_basic()
    test_skolemize_rigidity()
    test_deep_skolemize_rank2()
    test_deep_skolemize_nested()
    test_contravariance()
    print ""

    # Phase 5D: Higher-Rank Unification
    print "--- Phase 5D: Higher-Rank Unification ---"
    test_unify_forall_left()
    test_unify_forall_right()
    test_unify_skolem_rigid()
    test_unify_rank2()
    test_subsumption_basic()
    test_subsumption_rank2()
    test_st_monad()
    print ""

    print "All 30 tests passed!"
    print ""
    print "Complete higher-rank polymorphism system:"
    print "  - Kind system (Star, Arrow)"
    print "  - Quantifier representation (Forall/Exists)"
    print "  - Polymorphic types and type schemes"
    print "  - Quantifier context and scope tracking"
    print "  - Substitution"
    print "  - Instantiation and skolemization"
    print "  - Deep processing (rank-2+ types)"
    print "  - Variance-aware (contravariant/covariant)"
    print "  - Extended unification"
    print "  - Subsumption checking"
    print "  - ST monad support"
    print ""
