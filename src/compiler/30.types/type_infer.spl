# Hindley-Milner Type Inference
#
# Full Algorithm W type inference with level-based generalization.
# Enables zero-annotation code like ML/OCaml:
#
#   fn identity(x):     # Infers: forall a. a -> a
#       x
#
#   fn compose(f, g, x): # Infers: forall a b c. (b -> c) -> (a -> b) -> a -> c
#       f(g(x))
#
# Key features:
# - Level-based type variables for efficient generalization
# - Let-polymorphism at all let-bindings
# - Unification with occurs check
# - Type scheme instantiation
#
# References:
# - Damas-Milner Algorithm W
# - verification/type_inference_compile/src/Generics.lean
#
# Type definitions are in type_infer_types.spl
#
# ============================================================================
# FACADE PATTERN - Module Organization
# ============================================================================
#
# This file serves as a facade for the type_infer module, which has been
# refactored into 7 focused modules for better maintainability:
#
# Module Structure (2,175 lines -> 7 modules):
#
#   type_infer/core.spl (~230 lines)
#   - Core unification and substitution algorithms
#   - Occurs check (prevents infinite types)
#   - Fundamental operations of Algorithm W
#
#   type_infer/generalization.spl (~200 lines)
#   - Level-based generalization and instantiation
#   - Fresh type variable generation
#   - Free variable collection
#   - Let-polymorphism implementation
#
#   type_infer/traits.spl (~240 lines)
#   - Trait collection from HIR modules
#   - Trait/impl conversion (HirTrait -> TraitDef, HirImpl -> ImplBlock)
#   - Obligation generation and solving
#   - Trait-aware type checking
#
#   type_infer/context.spl (~120 lines)
#   - Context initialization and construction
#   - Builtin function registration
#   - Environment operations (lookup, bind)
#   - Error recording
#
#   type_infer/inference.spl (coordinator, ~45 lines)
#   - Facade that imports inference_expr and inference_control
#   - Re-exports public types for backward compatibility
#
#   type_infer/inference_expr.spl (~640 lines)
#   - Bidirectional type checking (synthesize/check)
#   - Algorithm W expression inference (infer_expr)
#   - Collection inference (arrays, tuples, dicts, sets)
#   - Function calls, method calls, field access, indexing
#   - If/match/range/closure inference
#   - Binary/unary operator inference
#
#   type_infer/inference_control.spl (~590 lines)
#   - Pipeline operators (|>, >>, <<, //)
#   - Deep learning operators (~>, @, broadcast)
#   - Dimension constraint solving and runtime check generation
#   - Block, statement, and pattern inference
#   - Function and module-level inference
#   - Effect inference and checking
#
# All implementation is in the submodules. This facade:
# - Declares the HmInferContext struct
# - Imports all submodules
# - Re-exports public types and functions

use compiler.hir.hir.*
use compiler.core.lexer.*
use compiler.types.dim_constraints.*
use compiler.traits.traits.*
use type_infer_types.*
use compiler.semantics.narrowing.*

struct HmInferContext:
    """Hindley-Milner inference context with level-based generalization.

    Levels enable efficient generalization control:
    - Each scope (let-binding, lambda) increments the level
    - Type variables are created at the current level
    - Only variables at level > environment level are generalizable

    Includes dimension constraint solver for tensor/layer type checking.
    Dimension checking happens in two phases:
    - Compile-time: Static dimension mismatches caught during type inference
    - Runtime: Dynamic dimension checks generated for before training/inference
    """
    # Type environment: maps names to polymorphic type schemes
    env: Dict<text, TypeScheme>
    # Current generalization level (incremented on enter_level)
    level: i64
    # Counter for generating fresh type variable IDs
    next_var: i64
    # Substitution map from type variable IDs to types
    subst: Substitution
    # Accumulated errors
    errors: [TypeInferError]
    # Dimension constraint solver for tensor/layer operations
    dim_solver: DimSolver
    # Runtime dimension check generator
    runtime_checks: DimCheckGenerator
    # Dimension check mode (controls runtime check generation)
    dim_check_mode: DimCheckMode
    # Trait solver for trait resolution
    trait_solver: TraitSolver
    # Function metadata: maps symbol ID to trait bounds
    # Stores trait bounds for each function to generate obligations during calls
    function_bounds: Dict<i64, [HirTraitBound]>
    # Flow-sensitive narrowing context for smart casts
    narrowing: NarrowingContext
    # Tracks which symbols are mutable (var vs val) for narrowing soundness
    # Only immutable (val) bindings are eligible for narrowing
    mutable_symbols: Dict<i64, bool>
    # Current function's accumulated effects (Phase 4: Async-from-Sync checking)
    current_function_effects: [Effect]

# Import all implementation modules
# NOTE: Using 'use' instead of 'mod' for bootstrap parser compatibility.
use compiler.types.type_infer.context.*
use compiler.types.type_infer.core.*
use compiler.types.type_infer.generalization.*
use compiler.types.type_infer.traits.*
use compiler.types.type_infer.inference.*
