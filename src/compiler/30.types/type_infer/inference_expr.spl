# Expression Type Inference
#
# Core expression inference using Algorithm W and bidirectional type checking:
# - Bidirectional type checking (synthesize vs check modes)
# - Expression inference (literals, variables, functions, operators)
# - Collection inference (arrays, tuples, dicts, sets)
# - Function calls and method calls with bidirectional lambda checking
# - Field access and indexing
# - If/match/range/closure inference
# - Binary/unary operator inference
#
# Part of the type_infer/inference split. See inference.spl for module overview.

use compiler.hir.hir.*
use compiler.core.lexer.*
use compiler.types.dim_constraints.*
use compiler.traits.traits.*
use type_infer_types.*
use compiler.semantics.narrowing.*

impl HmInferContext:
    # =========================================================================
    # Bidirectional Type Checking
    # =========================================================================
    #
    # Bidirectional type checking combines two modes:
    # - Synthesize: Infer type from expression structure (bottom-up)
    # - Check: Validate expression against expected type (top-down)
    #
    # The key advantage is propagating type information into lambdas:
    #   val f: fn(i64) -> i64 = \x: x + 1   # x inferred as i64
    #
    # Reference: "Complete and Easy Bidirectional Typechecking for Higher-Rank Polymorphism"
    #            by Joshua Dunfield and Neelakantan R. Krishnaswami

    me synthesize_expr(expr: HirExpr) -> Result<HirType, TypeInferError>:
        """Synthesize (infer) the type of an expression.

        Bottom-up type inference: determines type from expression structure.
        Used when no expected type is available.

        Examples:
            synthesize(42)         => i64
            synthesize(true)       => bool
            synthesize(\x: x + 1)  => fn(Infer) -> Infer  (params not known)
        """
        self._infer_expr_synth(expr)

    me check_expr(expr: HirExpr, expected: HirType) -> Result<(), TypeInferError>:
        """Check that an expression has the expected type.

        Top-down type checking: propagates expected type into expression.
        This enables better inference for lambdas and other constructs.

        Examples:
            check(\x: x + 1, fn(i64) -> i64) => Ok (x inferred as i64)
            check(42, text)                  => Err (type mismatch)
        """
        val span = expr.span

        # Special case: Lambda with expected function type
        # Propagate parameter types from expected into lambda
        match expr.kind:
            case Closure(params, body, captures):
                val resolved_expected = self.resolve(expected)
                match resolved_expected.kind:
                    case Function(param_types, return_type, effects):
                        # Check arity matches
                        if params.len() != param_types.len():
                            return Err(TypeInferError.Mismatch(
                                expected: expected,
                                found: HirType(kind: HirTypeKind.Function([], HirType(kind: HirTypeKind.Unit, span: span), []), span: span),
                                span: span
                            ))

                        # Enter new level for lambda scope
                        self.enter_level()

                        # Bind parameters with expected types
                        var i = 0
                        while i < params.len():
                            val param = params[i]
                            val expected_param_ty = param_types[i]

                            # Use expected type, or fresh var if expected is Infer
                            val param_ty = match expected_param_ty.kind:
                                case Infer(_, _): self.fresh_var(param.span)
                                case _: expected_param_ty

                            self.bind_mono(param.name, param_ty)
                            i = i + 1

                        # Check body against expected return type
                        match self.check_expr(body, return_type):
                            case Ok(_):
                                self.exit_level()
                                Ok(())
                            case Err(e):
                                self.exit_level()
                                Err(e)

                    case _:
                        # Expected is not a function type, fall back to synthesize+subsume
                        self._subsume_fallback(expr, expected)

            # If expression: propagate expected type into both branches (with narrowing)
            case If(cond, then_, else_):
                match self.infer_expr(cond, InferMode.Synthesize):
                    case Ok(cond_ty):
                        val bool_ty = HirType(kind: HirTypeKind.Bool, span: span)
                        match self.unify(cond_ty, bool_ty):
                            case Err(e): return Err(e)
                            case _: pass

                        # Analyze condition for narrowing facts
                        val narrowing_facts = analyze_condition(cond, \sym_id: self._lookup_symbol_type(sym_id))

                        # Push narrowing scope for then-branch
                        self.narrowing.push_scope()
                        self._add_immutable_facts(narrowing_facts)

                        val then_result = self.infer_block(then_)
                        val then_terminates = definitely_terminates(then_)
                        self.narrowing.pop_scope()

                        match then_result:
                            case Ok(then_ty):
                                match self.subsume(then_ty, expected):
                                    case Err(e): return Err(e)
                                    case _: pass
                                if else_.?:
                                    # Push narrowing scope with negated facts for else-branch
                                    self.narrowing.push_scope()
                                    val negated = negate_facts(narrowing_facts)
                                    self._add_immutable_facts(negated)

                                    val else_result = self.infer_block(else_.unwrap())
                                    val else_terminates = definitely_terminates(else_.unwrap())
                                    self.narrowing.pop_scope()

                                    # Early return promotion
                                    if then_terminates:
                                        self._add_immutable_facts(negate_facts(narrowing_facts))
                                    elif else_terminates:
                                        self._add_immutable_facts(narrowing_facts)

                                    match else_result:
                                        case Ok(else_ty):
                                            self.subsume(else_ty, expected)
                                        case Err(e): Err(e)
                                else:
                                    if then_terminates:
                                        val negated = negate_facts(narrowing_facts)
                                        self._add_immutable_facts(negated)
                                    Ok(())
                            case Err(e): Err(e)
                    case Err(e): Err(e)

            # Match expression: propagate expected type into arms
            case MatchCase(scrutinee, arms):
                match self.infer_expr(scrutinee, InferMode.Synthesize):
                    case Ok(scrut_ty):
                        for arm in arms:
                            match self.infer_pattern(arm.pattern, scrut_ty):
                                case Err(e): return Err(e)
                                case _: pass
                            if arm.guard.?:
                                match self.infer_expr(arm.guard.unwrap(), InferMode.Synthesize):
                                    case Ok(guard_ty):
                                        val bool_ty = HirType(kind: HirTypeKind.Bool, span: span)
                                        match self.unify(guard_ty, bool_ty):
                                            case Err(e): return Err(e)
                                            case _: pass
                                    case Err(e): return Err(e)
                            match self.infer_expr(arm.body, InferMode.Check(expected)):
                                case Ok(_): pass
                                case Err(e): return Err(e)
                        Ok(())
                    case Err(e): Err(e)

            # Tuple: propagate expected element types
            case TupleLit(elements):
                val resolved_expected = self.resolve(expected)
                match resolved_expected.kind:
                    case Tuple(expected_elems) if expected_elems.len() == elements.len():
                        var i = 0
                        while i < elements.len():
                            match self.check_expr(elements[i], expected_elems[i]):
                                case Err(e): return Err(e)
                                case _: pass
                            i = i + 1
                        Ok(())
                    case _:
                        self._subsume_fallback(expr, expected)

            # Array: propagate expected element type
            case ArrayLit(elems, _):
                val resolved_expected = self.resolve(expected)
                match resolved_expected.kind:
                    case Array(elem_ty, _):
                        for elem in elems:
                            match self.check_expr(elem, elem_ty):
                                case Err(e): return Err(e)
                                case _: pass
                        Ok(())
                    case _:
                        self._subsume_fallback(expr, expected)

            # For all other expressions, synthesize and subsume
            case _:
                self._subsume_fallback(expr, expected)

    me _subsume_fallback(expr: HirExpr, expected: HirType) -> Result<(), TypeInferError>:
        """Fallback for check mode: synthesize and then subsume against expected."""
        match self.synthesize_expr(expr):
            case Ok(inferred):
                self.subsume(inferred, expected)
            case Err(e): Err(e)

    me infer_expr(expr: HirExpr, mode: InferMode) -> Result<HirType, TypeInferError>:
        """Infer expression type using bidirectional type checking.

        This is the main entry point for all expression type inference.
        Dispatches to synthesize or check mode based on the mode parameter.

        Args:
            expr: Expression to type check
            mode: Synthesize or Check(expected_type)

        Returns:
            The type of the expression
        """
        match mode:
            case InferMode.Synthesize:
                self.synthesize_expr(expr)

            case InferMode.Check(expected):
                match self.check_expr(expr, expected):
                    case Ok(_):
                        # Return the expected type after successful check
                        Ok(expected)
                    case Err(e): Err(e)

    me subsume(inferred: HirType, expected: HirType) -> Result<(), TypeInferError>:
        """Check that inferred type is compatible with expected type.

        Used in bidirectional type checking for subtyping relationships.
        For now, this is equivalent to unification. Can be extended for
        variance-aware subtyping in the future.
        """
        self.unify(inferred, expected).map(\x: ())

    # =========================================================================
    # Type Inference (Algorithm W) - Synthesis Implementation
    # =========================================================================

    me _infer_expr_synth(expr: HirExpr) -> Result<HirType, TypeInferError>:
        """Synthesize the type of an expression using Algorithm W.

        This is the internal synthesis implementation. External callers
        should use infer_expr(expr, mode) which dispatches based on mode.
        """
        val span = expr.span

        match expr.kind:
            # Literals
            case IntLit(_, suffix):
                val bits = if suffix.?:
                    match suffix.unwrap():
                        case "i8": 8
                        case "i16": 16
                        case "i32": 32
                        case "u8": 8
                        case "u16": 16
                        case "u32": 32
                        case "u64": 64
                        case _: 64
                else: 64
                var signed = true
                if suffix.?:
                    if suffix.unwrap().starts_with("u"):
                        signed = false
                Ok(HirType(kind: HirTypeKind.Int(bits, signed), span: span))

            case FloatLit(_, suffix):
                var bits = 64
                if suffix.?:
                    if suffix.unwrap() == "f32":
                        bits = 32
                Ok(HirType(kind: HirTypeKind.Float(bits), span: span))

            case StringLit(_, _):
                Ok(HirType(kind: HirTypeKind.Str, span: span))

            case BoolLit(_):
                Ok(HirType(kind: HirTypeKind.Bool, span: span))

            case CharLit(_):
                Ok(HirType(kind: HirTypeKind.Char, span: span))

            case Unit:
                Ok(HirType(kind: HirTypeKind.Unit, span: span))

            # Variables - lookup with narrowing support
            case Var(symbol):
                val name = symbol.id.to_text()  # Get symbol name from ID
                self.lookup_with_narrowing(symbol.id, name, span)

            # Array literals
            case ArrayLit(elements, _):
                if elements.is_empty():
                    val elem_ty = self.fresh_var(span)
                    Ok(HirType(kind: HirTypeKind.Array(elem_ty, nil), span: span))
                else:
                    match self.synthesize_expr(elements[0]):
                        case Ok(elem_ty):
                            var i = 1
                            while i < elements.len():
                                match self.infer_expr(elements[i], InferMode.Check(elem_ty)):
                                    case Ok(_): pass
                                    case Err(e): return Err(e)
                                i = i + 1
                            Ok(HirType(kind: HirTypeKind.Array(self.resolve(elem_ty), nil), span: span))
                        case Err(e): Err(e)

            # Tuple literals
            case TupleLit(elements):
                var types: [HirType] = []
                for e in elements:
                    match self.synthesize_expr(e):
                        case Ok(ty): types = types.push(ty)
                        case Err(e): return Err(e)
                Ok(HirType(kind: HirTypeKind.Tuple(types), span: span))

            # Dict literals
            case DictLit(entries, _, _):
                if entries.is_empty():
                    val key_ty = self.fresh_var(span)
                    val val_ty = self.fresh_var(span)
                    Ok(HirType(kind: HirTypeKind.Dict(key_ty, val_ty), span: span))
                else:
                    val (k, v) = entries[0]
                    match self.synthesize_expr(k):
                        case Ok(key_ty):
                            match self.synthesize_expr(v):
                                case Ok(val_ty):
                                    var i = 1
                                    while i < entries.len():
                                        val (ki, vi) = entries[i]
                                        match self.infer_expr(ki, InferMode.Check(key_ty)):
                                            case Ok(_): pass
                                            case Err(e): return Err(e)
                                        match self.infer_expr(vi, InferMode.Check(val_ty)):
                                            case Ok(_): pass
                                            case Err(e): return Err(e)
                                        i = i + 1
                                    Ok(HirType(
                                        kind: HirTypeKind.Dict(self.resolve(key_ty), self.resolve(val_ty)),
                                        span: span
                                    ))
                                case Err(e): Err(e)
                        case Err(e): Err(e)

            # Set literals
            case SetLit(elements, _):
                if elements.is_empty():
                    # Empty set: create fresh type variable for element type
                    val elem_ty = self.fresh_var(span)
                    Ok(HirType(kind: HirTypeKind.Named("Set", [elem_ty]), span: span))
                else:
                    # Non-empty: infer from first element, check rest match
                    match self.synthesize_expr(elements[0]):
                        case Ok(elem_ty):
                            var i = 1
                            while i < elements.len():
                                match self.infer_expr(elements[i], InferMode.Check(elem_ty)):
                                    case Ok(_): pass
                                    case Err(e): return Err(e)
                                i = i + 1
                            Ok(HirType(
                                kind: HirTypeKind.Named("Set", [self.resolve(elem_ty)]),
                                span: span
                            ))
                        case Err(e): Err(e)

            # Binary operations
            case Binary(op, left, right):
                match self.synthesize_expr(left):
                    case Ok(left_ty):
                        match self.synthesize_expr(right):
                            case Ok(right_ty):
                                self.infer_binary_op(op, left_ty, right_ty, span)
                            case Err(e): Err(e)
                    case Err(e): Err(e)

            # Unary operations
            case Unary(op, operand):
                match self.synthesize_expr(operand):
                    case Ok(operand_ty):
                        self.infer_unary_op(op, operand_ty, span)
                    case Err(e): Err(e)

            # Function calls (with bidirectional type checking for all arguments)
            case Call(callee, args, type_args):
                match self.synthesize_expr(callee):
                    case Ok(callee_ty):
                        # Resolve callee type to get expected parameter types
                        val resolved_callee = self.resolve(callee_ty)

                        # Extract callee effects for tracking (Phase 3: Effect Integration)
                        val callee_effects = match resolved_callee.kind:
                            case Function(_, _, effects): effects
                            case _: []

                        # Accumulate callee effects into current function context
                        for eff in callee_effects:
                            self.accumulate_effect(eff)

                        # Try to extract parameter types for bidirectional checking
                        val expected_params = match resolved_callee.kind:
                            case Function(params, _, _): Some(params)
                            case _: nil

                        # Infer/check argument types with bidirectional mode
                        var arg_types: [HirType] = []
                        var i = 0
                        for arg in args:
                            # Use Check mode if we know the expected param type
                            val arg_result = if expected_params.? and i < expected_params.unwrap().len():
                                val expected_param = expected_params.unwrap()[i]
                                # Use Check mode for ALL arguments to propagate types
                                self.infer_expr(arg.value, InferMode.Check(expected_param))
                            else:
                                # No expected type, just synthesize
                                self.synthesize_expr(arg.value)

                            match arg_result:
                                case Ok(ty): arg_types = arg_types.push(ty)
                                case Err(e): return Err(e)

                            i = i + 1

                        val ret_ty = self.fresh_var(span)
                        val expected_fn_ty = HirType(
                            kind: HirTypeKind.Function(arg_types, ret_ty, []),
                            span: span
                        )

                        match self.unify(callee_ty, expected_fn_ty):
                            case Err(e): Err(e)
                            case _:
                                # Generate trait obligations if callee is a function with bounds
                                # Extract function symbol from callee expression
                                match callee.kind:
                                    case Var(func_symbol):
                                        # Lower type_args from AST types to HIR types
                                        var hir_type_args: [HirType] = []
                                        # Lower type_args from call expression
                                        if call_type_args.?:
                                            for ta in call_type_args.unwrap():
                                                hir_type_args.push(ta)
                                        self.generate_obligations_for_function_call(func_symbol, hir_type_args, span)
                                    case _: pass  # Not a direct function call

                                Ok(self.resolve(ret_ty))
                    case Err(e): Err(e)

            # Method calls
            case MethodCall(receiver, method, args, _):
                match self.synthesize_expr(receiver):
                    case Ok(receiver_ty):
                        # Infer argument types
                        for arg in args:
                            match self.synthesize_expr(arg.value):
                                case Err(e): return Err(e)
                                case _: pass

                        # Generate trait obligation for method call
                        # This will be enhanced in Phase C (Method Resolution)
                        self.generate_obligation_for_method_call(receiver_ty, method, span)

                        # Method resolution requires more type information
                        # For now, return fresh var
                        Ok(self.fresh_var(span))
                    case Err(e): Err(e)

            # Field access
            case Field(base, _, _):
                match self.synthesize_expr(base):
                    case Ok(_):
                        # Field resolution requires struct/class type info
                        Ok(self.fresh_var(span))
                    case Err(e): Err(e)

            # Index
            case Index(base, index):
                match self.synthesize_expr(base):
                    case Ok(base_ty):
                        match self.synthesize_expr(index):
                            case Ok(idx_ty):
                                val resolved_base = self.resolve(base_ty)

                                # Check if this is a slice operation (index is a Range)
                                val is_slice = match index.kind:
                                    case Range(_, _, _, _): true
                                    case _: false

                                # BUG FIX: If base is still an inference variable and we're slicing,
                                # constrain it to be Str to prevent incorrect enum type unification
                                match resolved_base.kind:
                                    case Infer(_, _) if is_slice:
                                        # For slicing on unresolved type, assume Str
                                        val str_ty = HirType(kind: HirTypeKind.Str, span: span)
                                        match self.unify(resolved_base, str_ty):
                                            case Ok(_): return Ok(str_ty)
                                            case Err(e): return Err(e)
                                    case _: pass

                                match resolved_base.kind:
                                    case Array(elem, _):
                                        if is_slice:
                                            Ok(HirType(kind: HirTypeKind.Slice(elem), span: span))
                                        else:
                                            Ok(elem)
                                    case Slice(elem):
                                        if is_slice:
                                            Ok(HirType(kind: HirTypeKind.Slice(elem), span: span))
                                        else:
                                            Ok(elem)
                                    case Dict(_, value):
                                        Ok(value)  # Dict doesn't support slicing
                                    case Str:
                                        if is_slice:
                                            Ok(HirType(kind: HirTypeKind.Str, span: span))
                                        else:
                                            Ok(HirType(kind: HirTypeKind.Char, span: span))
                                    case Named(sym_id, _):
                                        # BUG FIX: Handle Named types that might be text/string
                                        # If it's a Named type, try to resolve it further or default to Str for slicing
                                        if is_slice:
                                            Ok(HirType(kind: HirTypeKind.Str, span: span))
                                        else:
                                            # For single index, create fresh var (could be Dict-like)
                                            Ok(self.fresh_var(span))
                                    case _:
                                        Ok(self.fresh_var(span))
                            case Err(e): Err(e)
                    case Err(e): Err(e)

            # If expression (with flow-sensitive narrowing)
            case If(cond, then_, else_):
                match self.synthesize_expr(cond):
                    case Ok(cond_ty):
                        val bool_ty = HirType(kind: HirTypeKind.Bool, span: span)
                        match self.unify(cond_ty, bool_ty):
                            case Err(e): return Err(e)
                            case _: pass

                        # Analyze condition for narrowing facts
                        val narrowing_facts = analyze_condition(cond, \sym_id: self._lookup_symbol_type(sym_id))

                        # Push narrowing scope and add facts for then-branch
                        self.narrowing.push_scope()
                        self._add_immutable_facts(narrowing_facts)

                        val then_result = self.infer_block(then_)

                        # Check if then-branch definitely terminates (for early return narrowing)
                        val then_terminates = definitely_terminates(then_)

                        self.narrowing.pop_scope()

                        match then_result:
                            case Ok(then_ty):
                                if else_.?:
                                    # Push narrowing scope with negated facts for else-branch
                                    self.narrowing.push_scope()
                                    val negated = negate_facts(narrowing_facts)
                                    self._add_immutable_facts(negated)

                                    val else_result = self.infer_block(else_.unwrap())

                                    # Check if else-branch definitely terminates
                                    val else_terminates = definitely_terminates(else_.unwrap())

                                    self.narrowing.pop_scope()

                                    match else_result:
                                        case Ok(else_ty):
                                            # Early return promotion: if one branch terminates,
                                            # promote the other branch's narrowing to parent scope
                                            if then_terminates:
                                                # Then always returns, so else facts apply after if
                                                self._add_immutable_facts(negate_facts(narrowing_facts))
                                            elif else_terminates:
                                                # Else always returns, so then facts apply after if
                                                self._add_immutable_facts(narrowing_facts)

                                            match self.unify(then_ty, else_ty):
                                                case Err(e): Err(e)
                                                case _: Ok(self.resolve(then_ty))
                                        case Err(e): Err(e)
                                else:
                                    # No else branch. If then-branch terminates,
                                    # negated facts hold for rest of scope
                                    if then_terminates:
                                        val negated = negate_facts(narrowing_facts)
                                        self._add_immutable_facts(negated)
                                    Ok(self.resolve(then_ty))
                            case Err(e): Err(e)
                    case Err(e): Err(e)

            # Lambda (closure) - synthesis mode
            case Closure(params, body, _):
                self.enter_level()

                var param_types: [HirType] = []
                for p in params:
                    val param_ty = if p.type_.kind != HirTypeKind.Infer(0, 0):
                        p.type_
                    else:
                        self.fresh_var(p.span)
                    param_types = param_types.push(param_ty)
                    self.bind_mono(p.name, param_ty)

                match self.synthesize_expr(body):
                    case Ok(body_ty):
                        self.exit_level()
                        var resolved_params: [HirType] = []
                        for pt in param_types:
                            resolved_params = resolved_params.push(self.resolve(pt))
                        Ok(HirType(
                            kind: HirTypeKind.Function(resolved_params, self.resolve(body_ty), []),
                            span: span
                        ))
                    case Err(e):
                        self.exit_level()
                        Err(e)

            # Match expression
            case MatchCase(scrutinee, arms):
                match self.synthesize_expr(scrutinee):
                    case Ok(scrut_ty):
                        val result_ty = self.fresh_var(span)
                        for arm in arms:
                            match self.infer_pattern(arm.pattern, scrut_ty):
                                case Err(e): return Err(e)
                                case _: pass
                            if arm.guard.?:
                                match self.synthesize_expr(arm.guard.unwrap()):
                                    case Ok(guard_ty):
                                        val bool_ty = HirType(kind: HirTypeKind.Bool, span: span)
                                        match self.unify(guard_ty, bool_ty):
                                            case Err(e): return Err(e)
                                            case _: pass
                                    case Err(e): return Err(e)
                            match self.synthesize_expr(arm.body):
                                case Ok(arm_ty):
                                    match self.unify(result_ty, arm_ty):
                                        case Err(e): return Err(e)
                                        case _: pass
                                case Err(e): return Err(e)
                        Ok(self.resolve(result_ty))
                    case Err(e): Err(e)

            # Range expressions
            case Range(start, end, _, _):
                if start.?:
                    match self.synthesize_expr(start.unwrap()):
                        case Err(e): return Err(e)
                        case _: pass
                if end.?:
                    match self.synthesize_expr(end.unwrap()):
                        case Err(e): return Err(e)
                        case _: pass
                val int_ty = HirType(kind: HirTypeKind.Int(64, true), span: span)
                Ok(HirType(kind: HirTypeKind.Slice(int_ty), span: span))

            case _:
                Err(TypeInferError(message: "unsupported expression kind: {expr.kind}", span: span))

    me infer_binary_op(op: HirBinOp, left: HirType, right: HirType, span: Span) -> Result<HirType, TypeInferError>:
        """Infer type of binary operation."""
        match op:
            # Arithmetic: operands same type, return same type
            case Add | Sub | Mul | Div | Mod | Pow:
                match self.unify(left, right):
                    case Err(e): Err(e)
                    case _: Ok(self.resolve(left))

            # Comparison: operands same type, return bool
            case Eq | NotEq | Lt | LtEq | Gt | GtEq:
                match self.unify(left, right):
                    case Err(e): Err(e)
                    case _: Ok(HirType(kind: HirTypeKind.Bool, span: span))

            # Logical: operands bool, return bool
            case And | Or:
                val bool_ty = HirType(kind: HirTypeKind.Bool, span: span)
                match self.unify(left, bool_ty):
                    case Err(e): return Err(e)
                    case _: pass
                match self.unify(right, bool_ty):
                    case Err(e): Err(e)
                    case _: Ok(bool_ty)

            # Bitwise: operands int, return int
            case BitAnd | BitOr | BitXor | Shl | Shr:
                val int_ty = HirType(kind: HirTypeKind.Int(64, true), span: span)
                match self.unify(left, int_ty):
                    case Err(e): return Err(e)
                    case _: pass
                match self.unify(right, int_ty):
                    case Err(e): Err(e)
                    case _: Ok(int_ty)

            # Pipeline: x |> f becomes f(x)
            # Left operand is value, right operand is function
            case PipeForward:
                self.infer_pipe_forward(left, right, span)

            # Composition: f >> g means \x -> g(f(x))
            # Both operands are functions
            case Compose:
                self.infer_compose(left, right, span)

            # Backward composition: f << g means \x -> f(g(x))
            case ComposeBack:
                self.infer_compose(right, left, span)

            # Parallel: a // b runs both and combines results
            case Parallel:
                self.infer_parallel(left, right, span)

            # Layer connection: l1 ~> l2 composes layers with dimension checking
            case LayerConnect:
                self.infer_layer_connect(left, right, span)

            # Matrix multiplication
            case MatMul:
                self.infer_matmul(left, right, span)

            # Broadcast operations
            case BroadcastAdd | BroadcastSub | BroadcastMul | BroadcastDiv | BroadcastPow:
                self.infer_broadcast_op(left, right, span)

            case _:
                Err(TypeInferError(message: "unsupported binary operator: {op}", span: span))

    me infer_unary_op(op: HirUnaryOp, operand: HirType, span: Span) -> Result<HirType, TypeInferError>:
        """Infer type of unary operation."""
        match op:
            case Neg:
                Ok(operand)
            case Not:
                Ok(HirType(kind: HirTypeKind.Bool, span: span))
            case BitNot:
                Ok(operand)
            case Ref:
                Ok(HirType(kind: HirTypeKind.Ref(operand, false), span: span))
            case RefMut:
                Ok(HirType(kind: HirTypeKind.Ref(operand, true), span: span))
            case Deref:
                val resolved = self.resolve(operand)
                match resolved.kind:
                    case Ref(inner, _) | Ptr(inner, _):
                        Ok(inner)
                    case _:
                        Ok(self.fresh_var(span))
            case _:
                Ok(operand)

    # =========================================================================
    # Flow-Sensitive Narrowing Helpers
    # =========================================================================

    fn _lookup_symbol_type(sym_id: i64) -> HirType?:
        """Look up the current type of a symbol by ID for narrowing analysis.

        Used as the type_lookup callback for analyze_condition.
        Checks the type environment using the symbol ID as text key.
        """
        val name = sym_id.to_text()
        if self.env[name].?:
            val scheme = self.env[name]
            Some(scheme.ty)
        else:
            nil

    me _add_immutable_facts(facts: [NarrowingFact]):
        """Add narrowing facts to the current scope, filtering out mutable symbols.

        Only facts for immutable (val) bindings are added, since mutable (var)
        bindings could be reassigned between the check and use, invalidating
        the narrowing.
        """
        var i = 0
        while i < facts.len():
            val fact = facts[i]
            val is_mutable = self.mutable_symbols[fact.symbol_id]
            if is_mutable.? and is_mutable.unwrap():
                # Skip mutable symbols -- narrowing is unsound for var bindings
                pass
            else:
                # Immutable or unknown (default to allowing narrowing)
                self.narrowing.add_fact(fact)
            i = i + 1
