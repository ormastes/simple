# SIMD Intrinsics - Tests
#
# Tests for vector types, arithmetic operations, platform detection, and intrinsics.
# Type definitions are in simd_vector_types.spl and simd_platform.spl (same directory).

# ============================================================================
# Tests - Phase 9A: Vector Types
# ============================================================================

fn test_vec2f_create():
    """Test Vec2f creation"""
    val v = Vec2f(x: 1.0, y: 2.0)

    assert v.x == 1.0, "x is 1.0"
    assert v.y == 2.0, "y is 2.0"

    print "Vec2f creation passed"

fn test_vec2f_splat():
    """Test Vec2f splat constructor"""
    val v = Vec2f.splat(5.0)

    assert v.x == 5.0, "x is 5.0"
    assert v.y == 5.0, "y is 5.0"

    print "Vec2f splat passed"

fn test_vec2f_from_array():
    """Test Vec2f from_array"""
    val arr = [10.0, 20.0]
    val v = Vec2f.from_array(arr)

    assert v.x == 10.0, "x is 10.0"
    assert v.y == 20.0, "y is 20.0"

    print "Vec2f from_array passed"

fn test_vec2f_to_array():
    """Test Vec2f to_array"""
    val v = Vec2f(x: 3.0, y: 4.0)
    val arr = v.to_array()

    assert arr.len() == 2, "Array has 2 elements"
    assert arr[0] == 3.0, "First element is 3.0"
    assert arr[1] == 4.0, "Second element is 4.0"

    print "Vec2f to_array passed"

fn test_vec2f_get():
    """Test Vec2f element access"""
    val v = Vec2f(x: 7.0, y: 8.0)

    assert v.get(0) == 7.0, "Get x"
    assert v.get(1) == 8.0, "Get y"

    print "Vec2f get passed"

fn test_vec4f_create():
    """Test Vec4f creation"""
    val v = Vec4f(x: 1.0, y: 2.0, z: 3.0, w: 4.0)

    assert v.x == 1.0, "x is 1.0"
    assert v.y == 2.0, "y is 2.0"
    assert v.z == 3.0, "z is 3.0"
    assert v.w == 4.0, "w is 4.0"

    print "Vec4f creation passed"

fn test_vec4f_splat():
    """Test Vec4f splat constructor"""
    val v = Vec4f.splat(9.0)

    assert v.x == 9.0, "x is 9.0"
    assert v.y == 9.0, "y is 9.0"
    assert v.z == 9.0, "z is 9.0"
    assert v.w == 9.0, "w is 9.0"

    print "Vec4f splat passed"

fn test_vec4f_from_array():
    """Test Vec4f from_array"""
    val arr = [10.0, 20.0, 30.0, 40.0]
    val v = Vec4f.from_array(arr)

    assert v.x == 10.0, "x is 10.0"
    assert v.y == 20.0, "y is 20.0"
    assert v.z == 30.0, "z is 30.0"
    assert v.w == 40.0, "w is 40.0"

    print "Vec4f from_array passed"

fn test_vec4f_to_array():
    """Test Vec4f to_array"""
    val v = Vec4f(x: 1.0, y: 2.0, z: 3.0, w: 4.0)
    val arr = v.to_array()

    assert arr.len() == 4, "Array has 4 elements"
    assert arr[0] == 1.0, "First element"
    assert arr[1] == 2.0, "Second element"
    assert arr[2] == 3.0, "Third element"
    assert arr[3] == 4.0, "Fourth element"

    print "Vec4f to_array passed"

fn test_vec4f_get():
    """Test Vec4f element access"""
    val v = Vec4f(x: 5.0, y: 6.0, z: 7.0, w: 8.0)

    assert v.get(0) == 5.0, "Get x"
    assert v.get(1) == 6.0, "Get y"
    assert v.get(2) == 7.0, "Get z"
    assert v.get(3) == 8.0, "Get w"

    print "Vec4f get passed"

fn test_vec8f_create():
    """Test Vec8f creation"""
    val v = Vec8f(
        e0: 1.0, e1: 2.0, e2: 3.0, e3: 4.0,
        e4: 5.0, e5: 6.0, e6: 7.0, e7: 8.0
    )

    assert v.e0 == 1.0, "e0 is 1.0"
    assert v.e7 == 8.0, "e7 is 8.0"

    print "Vec8f creation passed"

fn test_vec8f_splat():
    """Test Vec8f splat constructor"""
    val v = Vec8f.splat(3.0)

    assert v.e0 == 3.0, "e0 is 3.0"
    assert v.e7 == 3.0, "e7 is 3.0"

    print "Vec8f splat passed"

fn test_vec8f_from_array():
    """Test Vec8f from_array"""
    val arr = [10.0, 20.0, 30.0, 40.0, 50.0, 60.0, 70.0, 80.0]
    val v = Vec8f.from_array(arr)

    assert v.e0 == 10.0, "e0 is 10.0"
    assert v.e7 == 80.0, "e7 is 80.0"

    print "Vec8f from_array passed"

fn test_vec8f_to_array():
    """Test Vec8f to_array"""
    val v = Vec8f(
        e0: 1.0, e1: 2.0, e2: 3.0, e3: 4.0,
        e4: 5.0, e5: 6.0, e6: 7.0, e7: 8.0
    )
    val arr = v.to_array()

    assert arr.len() == 8, "Array has 8 elements"
    assert arr[0] == 1.0, "First element"
    assert arr[7] == 8.0, "Last element"

    print "Vec8f to_array passed"

fn test_vec2d_create():
    """Test Vec2d creation"""
    val v = Vec2d(x: 1.5, y: 2.5)

    assert v.x == 1.5, "x is 1.5"
    assert v.y == 2.5, "y is 2.5"

    print "Vec2d creation passed"

fn test_vec4d_create():
    """Test Vec4d creation"""
    val v = Vec4d(x: 1.5, y: 2.5, z: 3.5, w: 4.5)

    assert v.x == 1.5, "x is 1.5"
    assert v.w == 4.5, "w is 4.5"

    print "Vec4d creation passed"

fn test_vec4f_zero():
    """Test Vec4f zero constructor"""
    val v = Vec4f.zero()

    assert v.x == 0.0, "x is 0.0"
    assert v.y == 0.0, "y is 0.0"
    assert v.z == 0.0, "z is 0.0"
    assert v.w == 0.0, "w is 0.0"

    print "Vec4f zero passed"

# ============================================================================
# Tests - Phase 9B: SIMD Operations
# ============================================================================

fn test_vec4f_add():
    """Test vector addition"""
    val v1 = Vec4f(x: 1.0, y: 2.0, z: 3.0, w: 4.0)
    val v2 = Vec4f(x: 5.0, y: 6.0, z: 7.0, w: 8.0)

    val result = v1.add(v2)

    assert result.x == 6.0, "x is 6.0"
    assert result.y == 8.0, "y is 8.0"
    assert result.z == 10.0, "z is 10.0"
    assert result.w == 12.0, "w is 12.0"

    print "Vector addition passed"

fn test_vec4f_sub():
    """Test vector subtraction"""
    val v1 = Vec4f(x: 10.0, y: 20.0, z: 30.0, w: 40.0)
    val v2 = Vec4f(x: 1.0, y: 2.0, z: 3.0, w: 4.0)

    val result = v1.sub(v2)

    assert result.x == 9.0, "x is 9.0"
    assert result.y == 18.0, "y is 18.0"
    assert result.z == 27.0, "z is 27.0"
    assert result.w == 36.0, "w is 36.0"

    print "Vector subtraction passed"

fn test_vec4f_mul():
    """Test element-wise multiplication"""
    val v1 = Vec4f(x: 2.0, y: 3.0, z: 4.0, w: 5.0)
    val v2 = Vec4f(x: 10.0, y: 10.0, z: 10.0, w: 10.0)

    val result = v1.mul(v2)

    assert result.x == 20.0, "x is 20.0"
    assert result.y == 30.0, "y is 30.0"
    assert result.z == 40.0, "z is 40.0"
    assert result.w == 50.0, "w is 50.0"

    print "Element-wise multiplication passed"

fn test_vec4f_div():
    """Test element-wise division"""
    val v1 = Vec4f(x: 20.0, y: 30.0, z: 40.0, w: 50.0)
    val v2 = Vec4f(x: 10.0, y: 10.0, z: 10.0, w: 10.0)

    val result = v1.div(v2)

    assert result.x == 2.0, "x is 2.0"
    assert result.y == 3.0, "y is 3.0"
    assert result.z == 4.0, "z is 4.0"
    assert result.w == 5.0, "w is 5.0"

    print "Element-wise division passed"

fn test_vec4f_scale():
    """Test scalar multiplication"""
    val v = Vec4f(x: 1.0, y: 2.0, z: 3.0, w: 4.0)

    val result = v.scale(2.0)

    assert result.x == 2.0, "x is 2.0"
    assert result.y == 4.0, "y is 4.0"
    assert result.z == 6.0, "z is 6.0"
    assert result.w == 8.0, "w is 8.0"

    print "Scalar multiplication passed"

fn test_vec4f_sum():
    """Test sum reduction"""
    val v = Vec4f(x: 1.0, y: 2.0, z: 3.0, w: 4.0)

    val result = v.sum()

    assert result == 10.0, "Sum is 10.0"

    print "Sum reduction passed"

fn test_vec4f_dot():
    """Test dot product"""
    val v1 = Vec4f(x: 1.0, y: 2.0, z: 3.0, w: 4.0)
    val v2 = Vec4f(x: 5.0, y: 6.0, z: 7.0, w: 8.0)

    val result = v1.dot(v2)

    # 1*5 + 2*6 + 3*7 + 4*8 = 5 + 12 + 21 + 32 = 70
    assert result == 70.0, "Dot product is 70.0"

    print "Dot product passed"

fn test_vec4f_length():
    """Test length calculation"""
    val v = Vec4f(x: 3.0, y: 4.0, z: 0.0, w: 0.0)

    val len_sq = v.length_squared()
    val len = v.length()

    assert len_sq == 25.0, "Squared length is 25.0"
    assert len == 5.0, "Length is 5.0"

    print "Length calculation passed"

fn test_vec4f_normalize():
    """Test normalization"""
    val v = Vec4f(x: 3.0, y: 4.0, z: 0.0, w: 0.0)

    val norm = v.normalize()
    val len = norm.length()

    # Normalized vector should have length 1.0
    val diff = if len > 1.0: len - 1.0 else: 1.0 - len
    assert diff < 0.001, "Normalized length is ~1.0"

    print "Normalization passed"

fn test_vec4f_distance():
    """Test distance calculation"""
    val v1 = Vec4f(x: 0.0, y: 0.0, z: 0.0, w: 0.0)
    val v2 = Vec4f(x: 3.0, y: 4.0, z: 0.0, w: 0.0)

    val dist = v1.distance(v2)

    assert dist == 5.0, "Distance is 5.0"

    print "Distance calculation passed"

fn test_vec4f_equals():
    """Test exact equality"""
    val v1 = Vec4f(x: 1.0, y: 2.0, z: 3.0, w: 4.0)
    val v2 = Vec4f(x: 1.0, y: 2.0, z: 3.0, w: 4.0)
    val v3 = Vec4f(x: 1.0, y: 2.0, z: 3.0, w: 5.0)

    assert v1.equals(v2), "Equal vectors"
    assert not v1.equals(v3), "Not equal vectors"

    print "Exact equality passed"

fn test_vec4f_less_than():
    """Test element-wise less than"""
    val v1 = Vec4f(x: 1.0, y: 2.0, z: 3.0, w: 4.0)
    val v2 = Vec4f(x: 2.0, y: 3.0, z: 2.0, w: 5.0)

    val result = v1.less_than(v2)

    assert result[0], "x: 1 < 2"
    assert result[1], "y: 2 < 3"
    assert not result[2], "z: 3 not < 2"
    assert result[3], "w: 4 < 5"

    print "Element-wise less than passed"

fn test_vec4f_min():
    """Test element-wise minimum"""
    val v1 = Vec4f(x: 1.0, y: 5.0, z: 3.0, w: 8.0)
    val v2 = Vec4f(x: 2.0, y: 4.0, z: 6.0, w: 7.0)

    val result = v1.min(v2)

    assert result.x == 1.0, "min(1, 2) = 1"
    assert result.y == 4.0, "min(5, 4) = 4"
    assert result.z == 3.0, "min(3, 6) = 3"
    assert result.w == 7.0, "min(8, 7) = 7"

    print "Element-wise minimum passed"

fn test_vec4f_max():
    """Test element-wise maximum"""
    val v1 = Vec4f(x: 1.0, y: 5.0, z: 3.0, w: 8.0)
    val v2 = Vec4f(x: 2.0, y: 4.0, z: 6.0, w: 7.0)

    val result = v1.max(v2)

    assert result.x == 2.0, "max(1, 2) = 2"
    assert result.y == 5.0, "max(5, 4) = 5"
    assert result.z == 6.0, "max(3, 6) = 6"
    assert result.w == 8.0, "max(8, 7) = 8"

    print "Element-wise maximum passed"

fn test_vec4f_abs():
    """Test absolute value"""
    val v = Vec4f(x: -1.0, y: 2.0, z: -3.0, w: 4.0)

    val result = v.abs()

    assert result.x == 1.0, "abs(-1) = 1"
    assert result.y == 2.0, "abs(2) = 2"
    assert result.z == 3.0, "abs(-3) = 3"
    assert result.w == 4.0, "abs(4) = 4"

    print "Absolute value passed"

fn test_vec4f_negate():
    """Test negation"""
    val v = Vec4f(x: 1.0, y: -2.0, z: 3.0, w: -4.0)

    val result = v.negate()

    assert result.x == -1.0, "-1 = -1"
    assert result.y == 2.0, "-(-2) = 2"
    assert result.z == -3.0, "-3 = -3"
    assert result.w == 4.0, "-(-4) = 4"

    print "Negation passed"

fn test_vec4f_min_element():
    """Test minimum element"""
    val v = Vec4f(x: 5.0, y: 2.0, z: 8.0, w: 3.0)

    val min_val = v.min_element()

    assert min_val == 2.0, "Minimum element is 2.0"

    print "Minimum element passed"

fn test_vec4f_max_element():
    """Test maximum element"""
    val v = Vec4f(x: 5.0, y: 2.0, z: 8.0, w: 3.0)

    val max_val = v.max_element()

    assert max_val == 8.0, "Maximum element is 8.0"

    print "Maximum element passed"

# ============================================================================
# Tests - Phase 9C: Platform Detection & Intrinsics
# ============================================================================

fn test_platform_detect():
    """Test platform detection"""
    val caps = SimdCapabilities.detect()

    # Detects real platform from /proc/cpuinfo or falls back to SSE2
    val platform = caps.best_platform()

    print "Platform detection: {platform.to_string()}"

fn test_has_sse():
    """Test SSE capability check"""
    val caps = SimdCapabilities.detect()

    val has_sse = caps.has_sse()

    print "SSE capability check: {has_sse}"

fn test_has_sse2():
    """Test SSE2 capability check"""
    val caps = SimdCapabilities.detect()

    val has_sse2 = caps.has_sse2()

    print "SSE2 capability check: {has_sse2}"

fn test_has_avx():
    """Test AVX capability check"""
    val caps = SimdCapabilities.detect()

    val has_avx = caps.has_avx()

    print "AVX capability check: {has_avx}"

fn test_register_width():
    """Test register width calculation"""
    val caps = SimdCapabilities.detect()

    val width = caps.register_width()

    # SSE2 has 128-bit registers
    assert width == 128, "SSE2 has 128-bit registers"

    print "Register width: {width}-bit"

fn test_vector_width_f32():
    """Test f32 vector width"""
    val caps = SimdCapabilities.detect()

    val width = caps.vector_width_f32()

    # 128-bit / 32-bit = 4 elements
    assert width == 4, "4 f32 values in SSE2 register"

    print "Vector width f32: {width} elements"

fn test_vector_width_f64():
    """Test f64 vector width"""
    val caps = SimdCapabilities.detect()

    val width = caps.vector_width_f64()

    # 128-bit / 64-bit = 2 elements
    assert width == 2, "2 f64 values in SSE2 register"

    print "Vector width f64: {width} elements"

fn test_sse_add():
    """Test SSE add intrinsic"""
    val v1 = Vec4f(x: 1.0, y: 2.0, z: 3.0, w: 4.0)
    val v2 = Vec4f(x: 5.0, y: 6.0, z: 7.0, w: 8.0)

    val result = SimdIntrinsics.sse_add_ps(v1, v2)

    assert result.x == 6.0, "x is 6.0"
    assert result.w == 12.0, "w is 12.0"

    print "SSE add intrinsic passed"

fn test_sse_sub():
    """Test SSE subtract intrinsic"""
    val v1 = Vec4f(x: 10.0, y: 20.0, z: 30.0, w: 40.0)
    val v2 = Vec4f(x: 1.0, y: 2.0, z: 3.0, w: 4.0)

    val result = SimdIntrinsics.sse_sub_ps(v1, v2)

    assert result.x == 9.0, "x is 9.0"
    assert result.w == 36.0, "w is 36.0"

    print "SSE subtract intrinsic passed"

fn test_sse_mul():
    """Test SSE multiply intrinsic"""
    val v1 = Vec4f(x: 2.0, y: 3.0, z: 4.0, w: 5.0)
    val v2 = Vec4f(x: 10.0, y: 10.0, z: 10.0, w: 10.0)

    val result = SimdIntrinsics.sse_mul_ps(v1, v2)

    assert result.x == 20.0, "x is 20.0"
    assert result.w == 50.0, "w is 50.0"

    print "SSE multiply intrinsic passed"

fn test_sse_min():
    """Test SSE minimum intrinsic"""
    val v1 = Vec4f(x: 1.0, y: 5.0, z: 3.0, w: 8.0)
    val v2 = Vec4f(x: 2.0, y: 4.0, z: 6.0, w: 7.0)

    val result = SimdIntrinsics.sse_min_ps(v1, v2)

    assert result.x == 1.0, "min(1, 2) = 1"
    assert result.y == 4.0, "min(5, 4) = 4"

    print "SSE minimum intrinsic passed"

fn test_sse_max():
    """Test SSE maximum intrinsic"""
    val v1 = Vec4f(x: 1.0, y: 5.0, z: 3.0, w: 8.0)
    val v2 = Vec4f(x: 2.0, y: 4.0, z: 6.0, w: 7.0)

    val result = SimdIntrinsics.sse_max_ps(v1, v2)

    assert result.x == 2.0, "max(1, 2) = 2"
    assert result.z == 6.0, "max(3, 6) = 6"

    print "SSE maximum intrinsic passed"

fn test_avx_add():
    """Test AVX add intrinsic"""
    val v1 = Vec8f(
        e0: 1.0, e1: 2.0, e2: 3.0, e3: 4.0,
        e4: 5.0, e5: 6.0, e6: 7.0, e7: 8.0
    )
    val v2 = Vec8f(
        e0: 10.0, e1: 10.0, e2: 10.0, e3: 10.0,
        e4: 10.0, e5: 10.0, e6: 10.0, e7: 10.0
    )

    val result = SimdIntrinsics.avx_add_ps(v1, v2)

    assert result.e0 == 11.0, "e0 is 11.0"
    assert result.e7 == 18.0, "e7 is 18.0"

    print "AVX add intrinsic passed"

fn test_platform_to_string():
    """Test platform string representation"""
    val sse = SimdPlatform.SSE
    val avx = SimdPlatform.AVX

    val sse_str = sse.to_string()
    val avx_str = avx.to_string()

    assert sse_str == "SSE", "SSE string"
    assert avx_str == "AVX", "AVX string"

    print "Platform to_string passed"

fn test_capabilities_to_string():
    """Test capabilities string representation"""
    val caps = SimdCapabilities.detect()

    val str_repr = caps.to_string()

    # Should contain "SimdCapabilities" and "128-bit" (for SSE2)
    assert "SimdCapabilities" in str_repr, "Contains 'SimdCapabilities'"
    assert "128" in str_repr, "Contains '128' (bit width)"

    print "Capabilities to_string passed"

# ============================================================================
# Main
# ============================================================================

fn main():
    print ""
    print "SIMD Intrinsics - Consolidated Tests"
    print "====================================="

    # Phase 9A: Vector Types
    print ""
    print "--- Phase 9A: Vector Types ---"
    test_vec2f_create()
    test_vec2f_splat()
    test_vec2f_from_array()
    test_vec2f_to_array()
    test_vec2f_get()
    test_vec4f_create()
    test_vec4f_splat()
    test_vec4f_from_array()
    test_vec4f_to_array()
    test_vec4f_get()
    test_vec8f_create()
    test_vec8f_splat()
    test_vec8f_from_array()
    test_vec8f_to_array()
    test_vec2d_create()
    test_vec4d_create()
    test_vec4f_zero()

    # Phase 9B: SIMD Operations
    print ""
    print "--- Phase 9B: SIMD Operations ---"
    test_vec4f_add()
    test_vec4f_sub()
    test_vec4f_mul()
    test_vec4f_div()
    test_vec4f_scale()
    test_vec4f_sum()
    test_vec4f_dot()
    test_vec4f_length()
    test_vec4f_normalize()
    test_vec4f_distance()
    test_vec4f_equals()
    test_vec4f_less_than()
    test_vec4f_min()
    test_vec4f_max()
    test_vec4f_abs()
    test_vec4f_negate()
    test_vec4f_min_element()
    test_vec4f_max_element()

    # Phase 9C: Platform Detection & Intrinsics
    print ""
    print "--- Phase 9C: Platform Detection & Intrinsics ---"
    test_platform_detect()
    test_has_sse()
    test_has_sse2()
    test_has_avx()
    test_register_width()
    test_vector_width_f32()
    test_vector_width_f64()
    test_sse_add()
    test_sse_sub()
    test_sse_mul()
    test_sse_min()
    test_sse_max()
    test_avx_add()
    test_platform_to_string()
    test_capabilities_to_string()

    print ""
    print "All SIMD tests complete (50 tests)"
