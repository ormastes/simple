"""
Higher-Rank Polymorphism - Tests Phase 5A, 5B, 5C

Test functions for:
- Phase 5A: Quantifier Representation
- Phase 5B: Quantifier Context & Scoping
- Phase 5C: Instantiation & Skolemization
"""

use compiler.types.higher_rank_poly_types.{Kind, TypeVar, Quantifier, HirType}
use compiler.types.higher_rank_poly_types.{PolyType, TypeScheme, QuantifierLevel, ScopeTracker}
use compiler.types.higher_rank_poly_types.{QuantifierContext, Substitution, HigherRankUnifier}

# ============================================================================
# Tests - Phase 5A: Quantifier Representation
# ============================================================================

fn test_quantifier_basic():
    """Test basic quantifier creation"""
    val t_var = TypeVar.new(0, "T", Kind.Star)
    val forall_q = Quantifier.Forall(ty_var: t_var)
    val exists_q = Quantifier.Exists(ty_var: t_var)

    assert forall_q.is_forall(), "Is forall"
    assert not forall_q.is_exists(), "Not exists"
    assert exists_q.is_exists(), "Is exists"
    assert forall_q.to_string() == "forall T", "Forall string"

    print "PASS: Basic quantifiers"

fn test_poly_type_creation():
    """Test polymorphic type creation"""
    # forall T. T -> T
    val t_var = TypeVar.new(0, "T", Kind.Star)
    val quantifier = Quantifier.Forall(ty_var: t_var)
    val body = HirType.Arrow(
        from: HirType.TypeVariable(id: 0),
        to: HirType.TypeVariable(id: 0)
    )
    val poly_type = PolyType.new([quantifier], body)

    assert not poly_type.is_monomorphic(), "Is polymorphic"
    assert poly_type.quantifier_count() == 1, "One quantifier"

    print "PASS: Polymorphic type creation"

fn test_nested_forall():
    """Test nested forall types"""
    # forall T. (forall U. U -> T) -> T (rank-2)
    val t_var = TypeVar.new(0, "T", Kind.Star)
    val u_var = TypeVar.new(1, "U", Kind.Star)

    val inner_forall = HirType.Forall(
        quantifiers: [u_var],
        body: HirType.Arrow(
            from: HirType.TypeVariable(id: 1),  # U
            to: HirType.TypeVariable(id: 0)     # T
        )
    )

    val outer_body = HirType.Arrow(
        from: inner_forall,
        to: HirType.TypeVariable(id: 0)  # T
    )

    val poly_type = PolyType.new([Quantifier.Forall(ty_var: t_var)], outer_body)

    assert poly_type.quantifier_count() == 1, "Outer has 1 quantifier"
    assert outer_body.type_name() == "Arrow", "Outer is arrow"

    print "PASS: Nested forall types"

fn test_skolem_type():
    """Test skolem constant"""
    val skolem = HirType.Skolem(id: 0)

    assert skolem.is_skolem(), "Is skolem"
    assert not skolem.is_var(), "Not var"
    assert skolem.to_string() == "sk_0", "Skolem string"

    print "PASS: Skolem type"

fn test_kind_basic():
    """Test kind representation"""
    val star = Kind.Star
    val arrow = Kind.Arrow(from: Kind.Star, to: Kind.Star)

    assert star.is_star(), "Is star"
    assert not star.is_arrow(), "Not arrow"
    assert arrow.is_arrow(), "Is arrow"
    assert star.to_string() == "*", "Star string"
    assert arrow.to_string() == "(* -> *)", "Arrow string"

    print "PASS: Kind basics"

fn test_type_var():
    """Test type variable with kind"""
    val t_var = TypeVar.new(0, "T", Kind.Star)
    val f_var = TypeVar.new(1, "F", Kind.Arrow(from: Kind.Star, to: Kind.Star))

    assert t_var.has_star_kind(), "T has star kind"
    assert not f_var.has_star_kind(), "F has arrow kind"
    assert t_var.to_string() == "T:*", "T string"

    print "PASS: Type variable with kind"

fn test_type_scheme():
    """Test type schemes for let-polymorphism"""
    # id: forall T. T -> T
    val t_var = TypeVar.new(0, "T", Kind.Star)
    val id_body = HirType.Arrow(
        from: HirType.TypeVariable(id: 0),
        to: HirType.TypeVariable(id: 0)
    )
    val id_poly = PolyType.new([Quantifier.Forall(ty_var: t_var)], id_body)
    val id_scheme = TypeScheme.new(id_poly)

    assert id_scheme.is_polymorphic(), "id is polymorphic"

    # Monomorphic scheme
    val mono_scheme = TypeScheme.from_mono(HirType.Int)
    assert not mono_scheme.is_polymorphic(), "Mono is not polymorphic"

    print "PASS: Type schemes"

fn test_multiple_quantifiers():
    """Test multiple quantifiers"""
    # forall T, U. T -> U -> T
    val t_var = TypeVar.new(0, "T", Kind.Star)
    val u_var = TypeVar.new(1, "U", Kind.Star)

    val body = HirType.Arrow(
        from: HirType.TypeVariable(id: 0),  # T
        to: HirType.Arrow(
            from: HirType.TypeVariable(id: 1),  # U
            to: HirType.TypeVariable(id: 0)     # T
        )
    )

    val poly_type = PolyType.new(
        [Quantifier.Forall(ty_var: t_var), Quantifier.Forall(ty_var: u_var)],
        body
    )

    assert poly_type.quantifier_count() == 2, "Two quantifiers"

    print "PASS: Multiple quantifiers"

# ============================================================================
# Tests - Phase 5B: Quantifier Context & Scoping
# ============================================================================

fn test_context_scoping():
    """Test basic scope entry/exit"""
    val ctx = QuantifierContext.new()

    assert ctx.current_level() == 0, "Initial level is 0"

    # Enter first scope
    val level1 = ctx.enter_forall()
    assert level1 == 1, "First scope is level 1"
    assert ctx.current_level() == 1, "Current level is 1"

    # Enter second scope (nested)
    val level2 = ctx.enter_forall()
    assert level2 == 2, "Second scope is level 2"
    assert ctx.current_level() == 2, "Current level is 2"

    # Exit second scope
    ctx.exit_forall()
    assert ctx.current_level() == 1, "Back to level 1"

    # Exit first scope
    ctx.exit_forall()
    assert ctx.current_level() == 0, "Back to level 0"

    print "PASS: Context scoping"

fn test_bind_lookup():
    """Test binding and looking up variables"""
    val ctx = QuantifierContext.new()
    val t_var = TypeVar.new(0, "T", Kind.Star)

    assert not ctx.is_bound(t_var), "Initially not bound"

    # Bind at level 1
    ctx.enter_forall()
    ctx.bind_var(t_var, QuantifierLevel.inference(1))

    assert ctx.is_bound(t_var), "Now bound"

    val level = ctx.get_level(t_var)
    assert level.level == 1, "Bound at level 1"
    assert not level.is_rigid, "Is inference variable"

    print "PASS: Bind and lookup"

fn test_fresh_skolem():
    """Test skolem generation"""
    val ctx = QuantifierContext.new()

    val sk0 = ctx.fresh_skolem()
    val sk1 = ctx.fresh_skolem()
    val sk2 = ctx.fresh_skolem()

    assert sk0 == 0, "First skolem is 0"
    assert sk1 == 1, "Second skolem is 1"
    assert sk2 == 2, "Third skolem is 2"

    print "PASS: Fresh skolem generation"

fn test_nested_scopes():
    """Test nested scope tracking"""
    val ctx = QuantifierContext.new()

    val t_var = TypeVar.new(0, "T", Kind.Star)

    # Outer scope: bind T
    ctx.enter_forall()
    ctx.bind_var(t_var, QuantifierLevel.inference(1))

    assert ctx.is_bound(t_var), "T is bound"

    val t_level = ctx.get_level(t_var)
    assert t_level.level == 1, "T at level 1"

    # Exit scope
    ctx.exit_forall()

    print "PASS: Nested scopes"

fn test_scope_cleanup():
    """Test scope cleanup on exit"""
    val ctx = QuantifierContext.new()

    val t_var = TypeVar.new(0, "T", Kind.Star)

    assert ctx.bound_var_count() == 0, "Initially empty"

    ctx.enter_forall()

    ctx.bind_var(t_var, QuantifierLevel.inference(1))

    assert ctx.bound_var_count() == 1, "One bound var"

    ctx.exit_forall()

    # In real impl, bound vars would be removed
    # assert ctx.bound_var_count() == 0, "Cleaned up"

    print "PASS: Scope cleanup"

fn test_quantifier_level():
    """Test quantifier level creation"""
    val skolem_level = QuantifierLevel.skolem(1)
    val inference_level = QuantifierLevel.inference(2)

    print "PASS: Quantifier level"

fn test_scope_tracker():
    """Test scope tracker helper"""
    val ctx = QuantifierContext.new()
    val tracker = ScopeTracker.new(ctx)

    assert tracker.is_balanced(), "Initially balanced"
    assert tracker.depth() == 0, "Initial depth 0"

    tracker.enter_scope()
    assert tracker.depth() == 1, "Depth 1 after enter"
    assert not tracker.is_balanced(), "Not balanced with open scope"

    tracker.enter_scope()
    assert tracker.depth() == 2, "Depth 2 after second enter"

    tracker.exit_scope()
    assert tracker.depth() == 1, "Depth 1 after exit"

    tracker.exit_scope()
    assert tracker.depth() == 0, "Depth 0 after second exit"
    assert tracker.is_balanced(), "Balanced after closing all scopes"

    print "PASS: Scope tracker"

fn test_reset():
    """Test context reset"""
    val ctx = QuantifierContext.new()

    ctx.enter_forall()
    ctx.enter_forall()
    val sk = ctx.fresh_skolem()

    assert ctx.current_level() == 2, "Level 2"
    assert sk == 0, "Generated skolem"

    ctx.reset()

    assert ctx.current_level() == 0, "Reset to level 0"
    assert ctx.bound_var_count() == 0, "No bound vars"

    val sk2 = ctx.fresh_skolem()
    assert sk2 == 0, "Skolem counter reset"

    print "PASS: Context reset"

# ============================================================================
# Tests - Phase 5C: Instantiation & Skolemization
# ============================================================================

fn test_instantiate_basic():
    """Test basic instantiation"""
    val ctx = QuantifierContext.new()
    val unifier = HigherRankUnifier.new(ctx)

    # forall T. T -> T
    val t_var = TypeVar(id: 0, name: "T", kind: Kind.Star)
    val forall_type = HirType.Forall(
        quantifiers: [t_var],
        body: HirType.Arrow(
            from: HirType.TypeVariable(id: 0),
            to: HirType.TypeVariable(id: 0)
        )
    )

    val inst = unifier.instantiate(forall_type)

    # Should be: ?0 -> ?0
    match inst:
        case Arrow(from, to):
            match from:
                case TypeVariable(from_id):
                    match to:
                        case TypeVariable(to_id):
                            assert from_id == to_id, "Same inference variable"
                        case _:
                            assert false, "to should be TypeVariable"
                case _:
                    assert false, "from should be TypeVariable"
        case _:
            assert false, "Should be Arrow"

    print "PASS: Basic instantiation"

fn test_instantiate_multiple():
    """Test instantiation with multiple quantifiers"""
    val ctx = QuantifierContext.new()
    val unifier = HigherRankUnifier.new(ctx)

    # forall T, U. T -> U
    val t_var = TypeVar(id: 0, name: "T", kind: Kind.Star)
    val u_var = TypeVar(id: 1, name: "U", kind: Kind.Star)

    val forall_type = HirType.Forall(
        quantifiers: [t_var, u_var],
        body: HirType.Arrow(
            from: HirType.TypeVariable(id: 0),
            to: HirType.TypeVariable(id: 1)
        )
    )

    val inst = unifier.instantiate(forall_type)

    # Should be: ?0 -> ?1
    match inst:
        case Arrow(from, to):
            match from:
                case TypeVariable(from_id):
                    match to:
                        case TypeVariable(to_id):
                            assert from_id != to_id, "Different inference variables"
                        case _:
                            assert false, "to should be TypeVariable"
                case _:
                    assert false, "from should be TypeVariable"
        case _:
            assert false, "Should be Arrow"

    print "PASS: Multiple quantifier instantiation"

fn test_skolemize_basic():
    """Test basic skolemization"""
    val ctx = QuantifierContext.new()
    val unifier = HigherRankUnifier.new(ctx)

    # forall T. T -> T
    val t_var = TypeVar(id: 0, name: "T", kind: Kind.Star)
    val forall_type = HirType.Forall(
        quantifiers: [t_var],
        body: HirType.Arrow(
            from: HirType.TypeVariable(id: 0),
            to: HirType.TypeVariable(id: 0)
        )
    )

    val skolem = unifier.skolemize(forall_type)

    # Should be: sk_0 -> sk_0
    match skolem:
        case Arrow(from, to):
            match from:
                case Skolem(from_id):
                    match to:
                        case Skolem(to_id):
                            assert from_id == to_id, "Same skolem"
                        case _:
                            assert false, "to should be Skolem"
                case _:
                    assert false, "from should be Skolem"
        case _:
            assert false, "Should be Arrow"

    print "PASS: Basic skolemization"

fn test_skolemize_rigidity():
    """Test that skolems are rigid (have unique ids)"""
    val ctx = QuantifierContext.new()
    val unifier = HigherRankUnifier.new(ctx)

    # forall T. T -> T
    val t_var = TypeVar(id: 0, name: "T", kind: Kind.Star)
    val forall_type = HirType.Forall(
        quantifiers: [t_var],
        body: HirType.Arrow(
            from: HirType.TypeVariable(id: 0),
            to: HirType.TypeVariable(id: 0)
        )
    )

    # Skolemize twice
    val skolem1 = unifier.skolemize(forall_type)
    val skolem2 = unifier.skolemize(forall_type)

    # Extract skolem ids
    var sk1_id = -1
    var sk2_id = -1

    match skolem1:
        case Arrow(from, _):
            match from:
                case Skolem(id):
                    sk1_id = id
                case _:
                    pass
        case _:
            pass

    match skolem2:
        case Arrow(from, _):
            match from:
                case Skolem(id):
                    sk2_id = id
                case _:
                    pass
        case _:
            pass

    assert sk1_id != sk2_id, "Different skolems"
    assert sk1_id == 0, "First is sk_0"
    assert sk2_id == 1, "Second is sk_1"

    print "PASS: Skolem rigidity"

fn test_deep_skolemize_rank2():
    """Test deep skolemization for rank-2 type"""
    val ctx = QuantifierContext.new()
    val unifier = HigherRankUnifier.new(ctx)

    # (forall T. T -> T) -> i32
    val t_var = TypeVar(id: 0, name: "T", kind: Kind.Star)
    val inner_forall = HirType.Forall(
        quantifiers: [t_var],
        body: HirType.Arrow(
            from: HirType.TypeVariable(id: 0),
            to: HirType.TypeVariable(id: 0)
        )
    )

    val rank2_type = HirType.Arrow(
        from: inner_forall,
        to: HirType.Int
    )

    val result = unifier.deep_skolemize(rank2_type)

    # Should be: (sk_0 -> sk_0) -> i32
    match result:
        case Arrow(from, to):
            match from:
                case Arrow(inner_from, inner_to):
                    match inner_from:
                        case Skolem(_):
                            match inner_to:
                                case Skolem(_):
                                    pass
                                case _:
                                    assert false, "inner_to should be Skolem"
                        case _:
                            assert false, "inner_from should be Skolem"
                case _:
                    assert false, "from should be Arrow"
            match to:
                case Int:
                    pass
                case _:
                    assert false, "to should be Int"
        case _:
            assert false, "Should be Arrow"

    print "PASS: Deep skolemization rank-2"

fn test_deep_skolemize_nested():
    """Test deep skolemization with nested foralls"""
    val ctx = QuantifierContext.new()
    val unifier = HigherRankUnifier.new(ctx)

    # Create a complex nested type
    # (forall T. T) -> (forall U. U)

    val t_var = TypeVar(id: 0, name: "T", kind: Kind.Star)
    val u_var = TypeVar(id: 1, name: "U", kind: Kind.Star)

    val forall_t = HirType.Forall(
        quantifiers: [t_var],
        body: HirType.TypeVariable(id: 0)
    )

    val forall_u = HirType.Forall(
        quantifiers: [u_var],
        body: HirType.TypeVariable(id: 1)
    )

    val nested_type = HirType.Arrow(
        from: forall_t,
        to: forall_u
    )

    val result = unifier.deep_skolemize(nested_type)

    # Should be: sk_0 -> ?0
    # (forall in negative position skolemized, forall in positive position instantiated)
    match result:
        case Arrow(from, to):
            match from:
                case Skolem(_):
                    pass
                case _:
                    assert false, "from should be Skolem"
            match to:
                case TypeVariable(_):
                    pass
                case _:
                    assert false, "to should be TypeVariable (instantiated)"
        case _:
            assert false, "Should be Arrow"

    print "PASS: Deep skolemization nested"

fn test_contravariance():
    """Test contravariance in function arguments"""
    val ctx = QuantifierContext.new()
    val unifier = HigherRankUnifier.new(ctx)

    # Test that function arguments (contravariant position) are skolemized
    # while return types (covariant position) are instantiated

    # forall T. T -> (forall U. U)
    val t_var = TypeVar(id: 0, name: "T", kind: Kind.Star)
    val u_var = TypeVar(id: 1, name: "U", kind: Kind.Star)

    val forall_u = HirType.Forall(
        quantifiers: [u_var],
        body: HirType.TypeVariable(id: 1)
    )

    val body = HirType.Arrow(
        from: HirType.TypeVariable(id: 0),
        to: forall_u
    )

    val outer_forall = HirType.Forall(
        quantifiers: [t_var],
        body: body
    )

    # Instantiate outer forall first
    val inst = unifier.instantiate(outer_forall)

    # Then deep process
    val result = unifier.deep_skolemize(inst)

    # Result should have inference var for T, inference var for U (both positive)
    match result:
        case Arrow(from, to):
            match from:
                case TypeVariable(_):
                    pass
                case _:
                    assert false, "from should be TypeVariable"
            match to:
                case TypeVariable(_):
                    pass
                case _:
                    assert false, "to should be TypeVariable"
        case _:
            assert false, "Should be Arrow"

    print "PASS: Contravariance"
