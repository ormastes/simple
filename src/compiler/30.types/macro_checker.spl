"""
Macro Checker - Tests for Phase 7A-7C

Tests for macro definition tracking, macro call type checking,
and macro expansion with parameter substitution and type inference.

Implementation split into:
- macro_def.spl: Phase 7A (HirType, Expr, MacroParam, MacroDef, MacroRegistry)
- macro_type_checker.spl: Phase 7B (MacroCall, TypeEnv, MacroTypeChecker, MacroTypeError)
- macro_expander.spl: Phase 7C (SubstitutionMap, MacroExpander)
"""

# ============================================================================
# Tests - Phase 7A: Macro Definition Representation
# ============================================================================

fn test_macro_param_regular():
    """Test regular macro parameter"""
    val param = MacroParam.regular("x", HirType.Int)

    assert param.name == "x", "Param name"
    assert not param.is_variadic, "Not variadic"
    assert param.ty.to_string() == "i32", "Param type"

    val str = param.to_string()
    assert str.len() > 0, "Param string"

    print "  [PASS] Regular macro parameter"

fn test_macro_param_variadic():
    """Test variadic macro parameter"""
    val param = MacroParam.variadic("args", HirType.Str)

    assert param.name == "args", "Param name"
    assert param.is_variadic, "Is variadic"
    assert param.ty.to_string() == "[String]", "Param type (list)"

    val str = param.to_string()
    assert str.len() > 0, "Param string"

    print "  [PASS] Variadic macro parameter"

fn test_macro_def_simple():
    """Test simple macro definition"""
    # @macro double(x: i32) -> i32:
    #     x + x
    val params = [
        MacroParam.regular("x", HirType.Int)
    ]
    val body = Expr.Var(name: "x")  # Simplified body

    val macro_def = MacroDef.new_macro(
        "double",
        params,
        body,
        HirType.Int
    )

    assert macro_def.name == "double", "Macro name"
    assert macro_def.param_count() == 1, "One parameter"
    assert not macro_def.has_variadic(), "No variadic param"
    assert macro_def.expansion_ty.to_string() == "i32", "Expansion type"

    print "  [PASS] Simple macro definition"

fn test_macro_def_variadic():
    """Test variadic macro definition"""
    # @macro log(...msgs: [text]):
    #     ...
    val params = [
        MacroParam.variadic("msgs", HirType.Str)
    ]
    val body = Expr.Block(stmts: [])

    val macro_def = MacroDef.new_macro(
        "log",
        params,
        body,
        HirType.Unit
    )

    assert macro_def.name == "log", "Macro name"
    assert macro_def.param_count() == 0, "Zero non-variadic params"
    assert macro_def.has_variadic(), "Has variadic param"

    print "  [PASS] Variadic macro definition"

fn test_macro_def_multiple_params():
    """Test macro with multiple parameters"""
    # @macro assert(cond: bool, msg: text):
    #     ...
    val params = [
        MacroParam.regular("cond", HirType.Bool),
        MacroParam.regular("msg", HirType.Str)
    ]
    val body = Expr.Block(stmts: [])

    val macro_def = MacroDef.new_macro(
        "assert",
        params,
        body,
        HirType.Unit
    )

    assert macro_def.param_count() == 2, "Two parameters"
    assert not macro_def.has_variadic(), "No variadic"

    print "  [PASS] Multiple parameter macro"

fn test_registry_register():
    """Test macro registration"""
    val registry = MacroRegistry.empty()

    assert registry.macro_count() == 0, "Initially empty"

    # Register macro
    val params = [MacroParam.regular("x", HirType.Int)]
    val body = Expr.Var(name: "x")
    val macro_def = MacroDef.new_macro("double", params, body, HirType.Int)

    registry.register_macro(macro_def)

    assert registry.macro_count() == 1, "One macro registered"
    assert registry.has_macro("double"), "Has 'double' macro"

    print "  [PASS] Macro registration"

fn test_registry_lookup():
    """Test macro lookup"""
    val registry = MacroRegistry.empty()

    # Register macro
    val params = [MacroParam.regular("x", HirType.Int)]
    val body = Expr.Var(name: "x")
    val macro_def = MacroDef.new_macro("double", params, body, HirType.Int)
    registry.register_macro(macro_def)

    # Lookup
    val found = registry.lookup_macro("double")
    assert found.name == "double", "Found macro"

    # Lookup missing
    val missing = registry.lookup_macro("missing")
    assert missing.name == "__missing__", "Missing macro returns dummy"

    print "  [PASS] Macro lookup"

fn test_registry_hygiene_scope():
    """Test hygiene scope assignment"""
    val registry = MacroRegistry.empty()

    # Register first macro
    val macro1 = MacroDef.new_macro(
        "macro1",
        [MacroParam.regular("x", HirType.Int)],
        Expr.Var(name: "x"),
        HirType.Int
    )
    registry.register_macro(macro1)

    val found1 = registry.lookup_macro("macro1")
    assert found1.hygiene_scope == 1, "First macro has scope 1"

    # Register second macro
    val macro2 = MacroDef.new_macro(
        "macro2",
        [MacroParam.regular("y", HirType.Str)],
        Expr.Var(name: "y"),
        HirType.Str
    )
    registry.register_macro(macro2)

    val found2 = registry.lookup_macro("macro2")
    assert found2.hygiene_scope == 2, "Second macro has scope 2"

    print "  [PASS] Hygiene scope assignment"

fn test_registry_clear():
    """Test registry clear"""
    val registry = MacroRegistry.empty()

    # Register macro
    val macro_def = MacroDef.new_macro(
        "test",
        [],
        Expr.Block(stmts: []),
        HirType.Unit
    )
    registry.register_macro(macro_def)

    assert registry.macro_count() == 1, "One macro"

    # Clear
    registry.clear()

    assert registry.macro_count() == 0, "Empty after clear"
    assert not registry.has_macro("test"), "Macro removed"

    print "  [PASS] Registry clear"

# ============================================================================
# Tests - Phase 7B: Macro Call Type Checking
# ============================================================================

fn test_macro_call():
    """Test macro call creation"""
    val args = [
        Expr.BoolLit(value: true),
        Expr.StrLit(value: "msg")
    ]
    val call = MacroCall.new_call("assert", args)

    assert call.name == "assert", "Call name"
    assert call.arg_count() == 2, "Two arguments"

    print "  [PASS] Macro call creation"

fn test_type_env():
    """Test type environment"""
    val env = TypeEnv.empty()

    env.bind_var("x", HirType.Int)

    val ty = env.infer_expr(Expr.Var(name: "x"))
    assert ty.to_string() == "i32", "Variable type"

    val lit_ty = env.infer_expr(Expr.IntLit(value: 42))
    assert lit_ty.to_string() == "i32", "Literal type"

    print "  [PASS] Type environment"

fn test_check_valid_call():
    """Test valid macro call"""
    val registry = MacroRegistry.empty()

    # Register macro: assert(cond: bool, msg: text)
    val params = [
        MacroParam.regular("cond", HirType.Bool),
        MacroParam.regular("msg", HirType.Str)
    ]
    val macro_def = MacroDef.new_macro(
        "assert",
        params,
        Expr.Block(stmts: []),
        HirType.Unit
    )
    registry.register_macro(macro_def)

    # Create checker
    val checker = MacroTypeChecker.new_checker(registry)

    # Valid call: @assert(true, "message")
    val args = [
        Expr.BoolLit(value: true),
        Expr.StrLit(value: "message")
    ]
    val call = MacroCall.new_call("assert", args)

    assert checker.check_macro_call(call), "Valid call"

    print "  [PASS] Valid macro call"

fn test_check_type_mismatch():
    """Test type mismatch error"""
    val registry = MacroRegistry.empty()

    # Register macro: assert(cond: bool, msg: text)
    val params = [
        MacroParam.regular("cond", HirType.Bool),
        MacroParam.regular("msg", HirType.Str)
    ]
    val macro_def = MacroDef.new_macro(
        "assert",
        params,
        Expr.Block(stmts: []),
        HirType.Unit
    )
    registry.register_macro(macro_def)

    val checker = MacroTypeChecker.new_checker(registry)

    # Invalid call: @assert(42, "message") - first arg is i32, not bool
    val args = [
        Expr.IntLit(value: 42),
        Expr.StrLit(value: "message")
    ]
    val call = MacroCall.new_call("assert", args)

    assert not checker.check_macro_call(call), "Type mismatch detected"

    print "  [PASS] Type mismatch detection"

fn test_check_wrong_arity():
    """Test wrong arity error"""
    val registry = MacroRegistry.empty()

    # Register macro: assert(cond: bool, msg: text)
    val params = [
        MacroParam.regular("cond", HirType.Bool),
        MacroParam.regular("msg", HirType.Str)
    ]
    val macro_def = MacroDef.new_macro(
        "assert",
        params,
        Expr.Block(stmts: []),
        HirType.Unit
    )
    registry.register_macro(macro_def)

    val checker = MacroTypeChecker.new_checker(registry)

    # Invalid call: @assert(true) - missing second argument
    val args = [Expr.BoolLit(value: true)]
    val call = MacroCall.new_call("assert", args)

    assert not checker.check_macro_call(call), "Wrong arity detected"

    print "  [PASS] Wrong arity detection"

fn test_check_variadic_call():
    """Test variadic macro call"""
    val registry = MacroRegistry.empty()

    # Register macro: log(...msgs: [text])
    val params = [
        MacroParam.variadic("msgs", HirType.Str)
    ]
    val macro_def = MacroDef.new_macro(
        "log",
        params,
        Expr.Block(stmts: []),
        HirType.Unit
    )
    registry.register_macro(macro_def)

    val checker = MacroTypeChecker.new_checker(registry)

    # Valid call: @log("a", "b", "c")
    val args = [
        Expr.StrLit(value: "a"),
        Expr.StrLit(value: "b"),
        Expr.StrLit(value: "c")
    ]
    val call = MacroCall.new_call("log", args)

    assert checker.check_macro_call(call), "Variadic call valid"

    # Valid call: @log() - zero arguments OK for variadic
    val empty_call = MacroCall.new_call("log", [])
    assert checker.check_macro_call(empty_call), "Empty variadic call valid"

    print "  [PASS] Variadic macro call"

fn test_macro_not_found():
    """Test macro not found error"""
    val registry = MacroRegistry.empty()
    val checker = MacroTypeChecker.new_checker(registry)

    val call = MacroCall.new_call("unknown", [])

    assert not checker.check_macro_call(call), "Macro not found detected"

    print "  [PASS] Macro not found detection"

fn test_get_expansion_type():
    """Test getting expansion type"""
    val registry = MacroRegistry.empty()

    # Register macro with i32 expansion type
    val macro_def = MacroDef.new_macro(
        "double",
        [MacroParam.regular("x", HirType.Int)],
        Expr.Var(name: "x"),
        HirType.Int
    )
    registry.register_macro(macro_def)

    val checker = MacroTypeChecker.new_checker(registry)

    val call = MacroCall.new_call("double", [Expr.IntLit(value: 5)])
    val exp_ty = checker.get_expansion_type(call)

    assert exp_ty.to_string() == "i32", "Expansion type"

    print "  [PASS] Get expansion type"

fn test_error_messages():
    """Test error message generation"""
    val err1 = MacroTypeError.macro_not_found("unknown")
    assert err1.to_string().len() > 0, "Macro not found message"

    val err2 = MacroTypeError.wrong_arity("test", 2, 1)
    assert err2.to_string().len() > 0, "Wrong arity message"

    val err3 = MacroTypeError.type_mismatch("test", 0, HirType.Bool, HirType.Int)
    assert err3.to_string().len() > 0, "Type mismatch message"

    print "  [PASS] Error messages"

# ============================================================================
# Tests - Phase 7C: Macro Expansion Type Inference
# ============================================================================

fn test_substitution_map():
    """Test substitution map"""
    val subst = SubstitutionMap.empty()

    subst.bind("x", Expr.IntLit(value: 42))

    assert subst.has("x"), "Has binding"
    val expr = subst.lookup("x")
    assert expr.to_string() == "42", "Lookup binding"

    val missing = subst.lookup("y")
    assert missing.to_string() == "y", "Missing returns var"

    print "  [PASS] Substitution map"

fn test_build_substitution_regular():
    """Test building substitution for regular parameters"""
    val expander = MacroExpander.new_expander(
        MacroTypeChecker.new_checker(MacroRegistry.empty())
    )

    val params = [
        MacroParam.regular("x", HirType.Int),
        MacroParam.regular("y", HirType.Int)
    ]
    val args = [
        Expr.IntLit(value: 5),
        Expr.IntLit(value: 10)
    ]

    val subst = expander.build_substitution(params, args)

    assert subst.has("x"), "Has x"
    assert subst.has("y"), "Has y"

    val x_expr = subst.lookup("x")
    assert x_expr.to_string() == "5", "x bound to 5"

    print "  [PASS] Build substitution (regular)"

fn test_build_substitution_variadic():
    """Test building substitution for variadic parameters"""
    val expander = MacroExpander.new_expander(
        MacroTypeChecker.new_checker(MacroRegistry.empty())
    )

    val params = [
        MacroParam.regular("level", HirType.Str),
        MacroParam.variadic("msgs", HirType.Str)
    ]
    val args = [
        Expr.StrLit(value: "INFO"),
        Expr.StrLit(value: "msg1"),
        Expr.StrLit(value: "msg2")
    ]

    val subst = expander.build_substitution(params, args)

    assert subst.has("level"), "Has level"
    assert subst.has("msgs"), "Has msgs"

    print "  [PASS] Build substitution (variadic)"

fn test_substitute_var():
    """Test substituting variables"""
    val expander = MacroExpander.new_expander(
        MacroTypeChecker.new_checker(MacroRegistry.empty())
    )

    val subst = SubstitutionMap.empty()
    subst.bind("x", Expr.IntLit(value: 42))

    # Substitute x in expression "x"
    val expr = Expr.Var(name: "x")
    val result = expander.substitute_in_expr(expr, subst)

    assert result.to_string() == "42", "Variable substituted"

    print "  [PASS] Substitute variable"

fn test_substitute_nested():
    """Test substituting in nested expressions"""
    val expander = MacroExpander.new_expander(
        MacroTypeChecker.new_checker(MacroRegistry.empty())
    )

    val subst = SubstitutionMap.empty()
    subst.bind("cond", Expr.BoolLit(value: true))
    subst.bind("body", Expr.IntLit(value: 42))

    # Substitute in: if cond: body
    val expr = Expr.If(
        cond: Expr.Var(name: "cond"),
        then_branch: Expr.Var(name: "body"),
        else_branch: Expr.IntLit(value: 0)
    )

    val result = expander.substitute_in_expr(expr, subst)
    assert result.to_string() == "if true ...", "Nested substitution"

    print "  [PASS] Substitute nested"

fn test_expand_simple_macro():
    """Test expanding simple macro"""
    val registry = MacroRegistry.empty()

    # Register macro: double(x) -> x + x
    val params = [MacroParam.regular("x", HirType.Int)]
    val body = Expr.Var(name: "x")  # Simplified: just returns x
    val macro_def = MacroDef.new_macro("double", params, body, HirType.Int)
    registry.register_macro(macro_def)

    val checker = MacroTypeChecker.new_checker(registry)
    val expander = MacroExpander.new_expander(checker)

    # Expand: @double(5)
    val call = MacroCall.new_call("double", [Expr.IntLit(value: 5)])
    val expanded = expander.expand_macro(call)

    assert expanded.to_string() == "5", "Expansion result"

    print "  [PASS] Expand simple macro"

fn test_expand_control_flow():
    """Test expanding control flow macro"""
    val registry = MacroRegistry.empty()

    # Register macro: unless(cond, body) -> if not cond: body
    val params = [
        MacroParam.regular("cond", HirType.Bool),
        MacroParam.regular("body", HirType.Unit)
    ]
    val body = Expr.If(
        cond: Expr.Var(name: "cond"),
        then_branch: Expr.Var(name: "body"),
        else_branch: Expr.IntLit(value: 0)
    )
    val macro_def = MacroDef.new_macro("unless", params, body, HirType.Unit)
    registry.register_macro(macro_def)

    val checker = MacroTypeChecker.new_checker(registry)
    val expander = MacroExpander.new_expander(checker)

    # Expand: @unless(true, print("hi"))
    val call = MacroCall.new_call("unless", [
        Expr.BoolLit(value: true),
        Expr.IntLit(value: 1)  # Simplified body
    ])
    val expanded = expander.expand_macro(call)

    assert expanded.to_string() == "if true ...", "Control flow expansion"

    print "  [PASS] Expand control flow macro"

fn test_expand_and_infer():
    """Test expanding and inferring type"""
    val registry = MacroRegistry.empty()

    # Register macro: get_int() -> 42
    val params = []
    val body = Expr.IntLit(value: 42)
    val macro_def = MacroDef.new_macro("get_int", params, body, HirType.Int)
    registry.register_macro(macro_def)

    val checker = MacroTypeChecker.new_checker(registry)
    val expander = MacroExpander.new_expander(checker)

    # Expand and infer: @get_int()
    val call = MacroCall.new_call("get_int", [])
    val ty = expander.expand_and_infer(call)

    assert ty.to_string() == "i32", "Inferred type"

    print "  [PASS] Expand and infer type"

# ============================================================================
# Main
# ============================================================================

fn main():
    print ""
    print "Macro Checker - Consolidated Tests (Phase 7A-7C)"
    print "================================================="

    print ""
    print "Phase 7A: Macro Definition Representation"
    print "-------------------------------------------"
    test_macro_param_regular()
    test_macro_param_variadic()
    test_macro_def_simple()
    test_macro_def_variadic()
    test_macro_def_multiple_params()
    test_registry_register()
    test_registry_lookup()
    test_registry_hygiene_scope()
    test_registry_clear()

    print ""
    print "Phase 7B: Macro Call Type Checking"
    print "-------------------------------------------"
    test_macro_call()
    test_type_env()
    test_check_valid_call()
    test_check_type_mismatch()
    test_check_wrong_arity()
    test_check_variadic_call()
    test_macro_not_found()
    test_get_expansion_type()
    test_error_messages()

    print ""
    print "Phase 7C: Macro Expansion Type Inference"
    print "-------------------------------------------"
    test_substitution_map()
    test_build_substitution_regular()
    test_build_substitution_variadic()
    test_substitute_var()
    test_substitute_nested()
    test_expand_simple_macro()
    test_expand_control_flow()
    test_expand_and_infer()

    print ""
    print "All 26 tests passed."
    print ""
    print "Consolidated components:"
    print "  - HirType: simplified type system"
    print "  - Expr: expression AST with Let variant"
    print "  - MacroParam: regular and variadic parameters"
    print "  - MacroDef: macro definitions with types"
    print "  - MacroRegistry: macro tracking, lookup, hygiene scopes"
    print "  - MacroCall: macro call site representation"
    print "  - TypeEnv: type inference for expressions"
    print "  - MacroTypeChecker: call validation with type matching"
    print "  - MacroTypeError: error messages"
    print "  - SubstitutionMap: parameter to argument mapping"
    print "  - MacroExpander: macro expansion engine"
