"""
Associated Types - Solver Logic

Split from associated_types_defs.spl.

Contains: ImplBlockEx, ImplRegistryEx, ImplValidator,
          AssocTypeProjection, AssocTypeResolver, TraitSolverEx

Phase 4B: ImplBlockEx, ImplRegistryEx, ImplValidator
Phase 4C: AssocTypeProjection, AssocTypeResolver
Phase 4D: TraitSolverEx
"""

use compiler.types.associated_types_defs.{HirType, TraitRef, Symbol}
use compiler.types.associated_types_defs.{AssocTypeDef, TraitDefEx, TraitRegistryEx}
use compiler.types.associated_types_defs.{AssocTypeImpl, Obligation}

# ============================================================================
# Extended Impl Block (Phase 4D version - includes matches_obligation)
# ============================================================================

class ImplBlockEx:
    """
    Extended impl block with associated type implementations

    Example:
        impl Iterator for Range:
            type Item = i64           # Associated type impl
            fn next() -> i64?: ...    # Method impl
    """
    trait_ref: text      # TraitRef
    for_type: text       # HirType
    methods: text        # Dict<Symbol, MethodImpl>
    assoc_type_impls: text  # Dict<Symbol, AssocTypeImpl>

impl ImplBlockEx:
    static fn new(trait_ref: TraitRef, for_type: HirType) -> ImplBlockEx:
        ImplBlockEx(
            trait_ref: trait_ref,
            for_type: for_type,
            methods: {},
            assoc_type_impls: {}
        )

    me add_assoc_type_impl(name: Symbol, concrete_type: HirType):
        """Add an associated type implementation"""
        val assoc_impl = {
            "name": name,
            "type": concrete_type
        }
        self.assoc_type_impls[name] = assoc_impl

    fn get_assoc_type_impl(name: Symbol) -> HirType:
        """Get concrete type for associated type"""
        if name in self.assoc_type_impls:
            val assoc_impl = self.assoc_type_impls[name]
            return assoc_impl["type"]

        # Return error type if not found
        HirType.Error

    fn has_assoc_type_impl(name: Symbol) -> bool:
        """Check if associated type is implemented"""
        name in self.assoc_type_impls

    fn assoc_type_impl_count() -> i64:
        """Count associated type implementations"""
        self.assoc_type_impls.len()

    fn matches_type(ty: HirType) -> bool:
        """Check if this impl is for the given type"""
        self.for_type.matches(ty)

    fn matches_obligation(obligation: Obligation) -> bool:
        """Check if this impl satisfies obligation (including assoc type constraints)"""
        # Check trait matches
        if self.trait_ref.name != obligation.trait_ref.name:
            return false

        # Check type matches
        if not self.for_type.matches(obligation.ty):
            return false

        # Check associated type constraints
        val constraints = obligation.assoc_type_constraints
        for assoc_name in constraints:
            val expected_type = constraints[assoc_name]

            # Check if this impl has the associated type
            if not self.has_assoc_type_impl(assoc_name):
                return false

            # Check if types match
            val actual_type = self.get_assoc_type_impl(assoc_name)
            if not actual_type.matches(expected_type):
                return false

        true

    fn to_string() -> text:
        val trait_name = self.trait_ref.name
        val type_name = self.for_type.type_name()
        var result = "impl {trait_name} for {type_name}"

        if self.assoc_type_impl_count() > 0:
            result = "{result} ({self.assoc_type_impl_count()} assoc types)"

        result

# ============================================================================
# Extended Impl Registry (Combined lookup methods from 4B/4C/4D)
# ============================================================================

class ImplRegistryEx:
    """
    Extended impl registry supporting associated types
    """
    impls: text      # [ImplBlockEx]
    index: text      # Dict<"trait::type", ImplBlockEx>

impl ImplRegistryEx:
    static fn new() -> ImplRegistryEx:
        ImplRegistryEx(
            impls: [],
            index: {}
        )

    me register_impl(impl_block: ImplBlockEx) -> bool:
        """Register an impl block"""
        val trait_name = impl_block.trait_ref.name
        val type_name = impl_block.for_type.type_name()
        val key = "{trait_name}::{type_name}"

        # Check for duplicate
        if key in self.index:
            return false  # Conflict

        # Register
        self.impls.push(impl_block)
        self.index[key] = impl_block
        true

    # From Phase 4B: lookup by trait name + type name strings
    fn find_impl(trait_name: Symbol, type_name: Symbol) -> ImplBlockEx:
        """Find impl block for (trait, type) pair by name"""
        val key = "{trait_name}::{type_name}"

        if key in self.index:
            return self.index[key]

        # Return dummy impl
        val dummy_trait = TraitRef.new("NotFound")
        val dummy_type = HirType.Named(name: "NotFound")
        ImplBlockEx.new(dummy_trait, dummy_type)

    fn has_impl(trait_name: Symbol, type_name: Symbol) -> bool:
        """Check if impl exists by name"""
        val key = "{trait_name}::{type_name}"
        key in self.index

    # From Phase 4C: lookup by trait name + HirType
    fn find_impl_for_type(trait_name: Symbol, ty: HirType) -> ImplBlockEx:
        """Find impl block for (trait, type) pair"""
        val type_name = ty.type_name()
        val key = "{trait_name}::{type_name}"

        if key in self.index:
            return self.index[key]

        # Return dummy
        val dummy_trait = TraitRef.new("NotFound")
        val dummy_type = HirType.Named(name: "NotFound")
        ImplBlockEx.new(dummy_trait, dummy_type)

    # From Phase 4C: find all impls matching a type
    fn find_impls_for_type(ty: HirType) -> [ImplBlockEx]:
        """Find all impls for a given type"""
        var result = []

        for impl_block in self.impls:
            if impl_block.matches_type(ty):
                result.push(impl_block)

        result

    # From Phase 4D: find impls matching an obligation (with assoc type constraints)
    fn find_matching_impls(obligation: Obligation) -> [ImplBlockEx]:
        """Find all impls that could satisfy obligation (with assoc type constraints)"""
        var matches = []

        for impl_block in self.impls:
            if impl_block.matches_obligation(obligation):
                matches.push(impl_block)

        matches

    me define_builtin_impls():
        """Define standard library impls with associated types"""

        # impl Iterator for Range
        val range_iter = ImplBlockEx.new(
            TraitRef.new("Iterator"),
            HirType.Named(name: "Range")
        )
        range_iter.add_assoc_type_impl("Item", HirType.Int)
        self.register_impl(range_iter)

        # impl Iterator for Vec<T> (generic)
        val vec_t = HirType.Generic(name: "Vec", args: [HirType.Named(name: "T")])
        val vec_iter = ImplBlockEx.new(
            TraitRef.new("Iterator"),
            vec_t
        )
        vec_iter.add_assoc_type_impl("Item", HirType.Named(name: "T"))
        self.register_impl(vec_iter)

        # impl Collection for Vec<T>
        val vec_collection = ImplBlockEx.new(
            TraitRef.new("Collection"),
            vec_t
        )
        vec_collection.add_assoc_type_impl("Item", HirType.Named(name: "T"))
        vec_collection.add_assoc_type_impl("Index", HirType.Int)  # Uses default
        self.register_impl(vec_collection)

# ============================================================================
# Impl Validator (Phase 4B)
# ============================================================================

class ImplValidator:
    """
    Validates impl blocks with associated types
    """
    trait_def: text  # TraitDefEx

impl ImplValidator:
    static fn new(trait_def: TraitDefEx) -> ImplValidator:
        ImplValidator(trait_def: trait_def)

    fn validate_completeness(impl_block: ImplBlockEx) -> bool:
        """
        Check all required associated types are implemented

        Returns: true if complete, false if missing required types
        """
        val assoc_types = self.trait_def.assoc_types

        for assoc_name in assoc_types:
            val assoc_def = self.trait_def.get_assoc_type(assoc_name)

            # Skip if has default
            if assoc_def.has_default():
                pass

            # Check if implemented
            if not impl_block.has_assoc_type_impl(assoc_name):
                return false  # Missing required associated type

        true

    fn validate_bounds(impl_block: ImplBlockEx) -> bool:
        """
        Check associated type impls satisfy trait bounds

        Placeholder - always returns true for now
        """
        true

    fn find_missing_assoc_types(impl_block: ImplBlockEx) -> [Symbol]:
        """Find all missing required associated types"""
        var missing = []
        val assoc_types = self.trait_def.assoc_types

        for assoc_name in assoc_types:
            val assoc_def = self.trait_def.get_assoc_type(assoc_name)

            # Skip defaults
            if assoc_def.has_default():
                pass

            # Check if implemented
            if not impl_block.has_assoc_type_impl(assoc_name):
                missing.push(assoc_name)

        missing

# ============================================================================
# Type Projection (Phase 4C)
# ============================================================================

class AssocTypeProjection:
    """
    Represents an associated type projection: T.Item

    Example: In fn sum<I: Iterator>(iter: I) -> I.Item
             I.Item is an AssocTypeProjection
    """
    base_type: text     # HirType - the type being projected (I)
    assoc_name: text    # Symbol - the associated type name (Item)
    resolved: text      # Option<HirType> - cached resolution

impl AssocTypeProjection:
    static fn new(base_type: HirType, assoc_name: Symbol) -> AssocTypeProjection:
        AssocTypeProjection(
            base_type: base_type,
            assoc_name: assoc_name,
            resolved: "None"
        )

    fn to_string() -> text:
        "{self.base_type.to_string()}.{self.assoc_name}"

    fn is_resolved() -> bool:
        self.resolved != "None"

    fn get_resolved() -> HirType:
        if self.is_resolved():
            return self.resolved
        HirType.Error

    me set_resolved(ty: HirType):
        self.resolved = ty

# ============================================================================
# Associated Type Resolver (Phase 4C)
# ============================================================================

class AssocTypeResolver:
    """
    Core resolver for associated type projections

    Algorithm:
    1. For projection T.Item:
       - Find impl blocks for type T
       - Look up Item in each impl
       - Return concrete type

    2. Normalization:
       - Recursively reduce projections to concrete types
       - Handle nested projections (T.Assoc1.Assoc2)
    """
    impl_registry: text  # ImplRegistryEx
    cache: text          # Dict<projection_str, HirType>

impl AssocTypeResolver:
    static fn new(impl_registry: ImplRegistryEx) -> AssocTypeResolver:
        AssocTypeResolver(
            impl_registry: impl_registry,
            cache: {}
        )

    me resolve_projection(projection: AssocTypeProjection) -> HirType:
        """
        Resolve a projection to a concrete type

        Example:
            Given: Range.Item where impl Iterator for Range with Item = i64
            Returns: i64
        """
        # Check cache first
        val cache_key = projection.to_string()
        if cache_key in self.cache:
            return self.cache[cache_key]

        # 1. Get base type
        val base_type = projection.base_type

        # 2. Normalize base type first (in case it's also a projection)
        val normalized_base = self.normalize(base_type)

        # 3. Find impl blocks for normalized base type
        val impls = self.impl_registry.find_impls_for_type(normalized_base)

        # 4. Look up associated type in each impl
        for impl_block in impls:
            if impl_block.has_assoc_type_impl(projection.assoc_name):
                val concrete_type = impl_block.get_assoc_type_impl(projection.assoc_name)

                # Cache result
                self.cache[cache_key] = concrete_type

                # Set resolved on projection
                projection.set_resolved(concrete_type)

                return concrete_type

        # 5. Not found - return error
        HirType.Error

    me normalize(ty: HirType) -> HirType:
        """
        Normalize a type by reducing projections to concrete types

        Examples:
            Range.Item -> i64 (if impl Iterator for Range with Item = i64)
            Vec<Range.Item> -> Vec<i64>
        """
        match ty:
            case Projection(base, assoc_name):
                # Create projection object
                val projection = AssocTypeProjection.new(base, assoc_name)
                # Resolve it
                self.resolve_projection(projection)

            case Generic(name, args):
                # Normalize each type argument
                var normalized_args = []
                for arg in args:
                    val normalized_arg = self.normalize(arg)
                    normalized_args.push(normalized_arg)

                HirType.Generic(name: name, args: normalized_args)

            case _:
                # Already normalized
                ty

    fn find_impl_for_projection(projection: AssocTypeProjection) -> ImplBlockEx:
        """
        Find impl block that provides this projection

        Returns: impl block or dummy if not found
        """
        val base_type = projection.base_type
        val impls = self.impl_registry.find_impls_for_type(base_type)

        for impl_block in impls:
            if impl_block.has_assoc_type_impl(projection.assoc_name):
                return impl_block

        # Return dummy
        val dummy_trait = TraitRef.new("NotFound")
        val dummy_type = HirType.Named(name: "NotFound")
        ImplBlockEx.new(dummy_trait, dummy_type)

# ============================================================================
# Extended Trait Solver (Phase 4D)
# ============================================================================

class TraitSolverEx:
    """
    Extended trait solver handling associated type constraints
    """
    impl_registry: text  # ImplRegistryEx
    max_depth: i64

impl TraitSolverEx:
    static fn new(impl_registry: ImplRegistryEx) -> TraitSolverEx:
        TraitSolverEx(
            impl_registry: impl_registry,
            max_depth: 10
        )

    fn solve(obligation: Obligation) -> bool:
        """
        Solve obligation with associated type constraints

        Algorithm:
        1. Find matching impls for (trait, type)
        2. Check associated type constraints match
        3. Return true if satisfied
        """
        val matches = self.impl_registry.find_matching_impls(obligation)
        matches.len() > 0

    fn solve_all(obligations: [Obligation]) -> [Obligation]:
        """Solve multiple obligations"""
        var unsatisfied = []

        for obligation in obligations:
            if not self.solve(obligation):
                unsatisfied.push(obligation)

        unsatisfied

    fn can_satisfy(ty: HirType, trait_name: Symbol) -> bool:
        """Check if type can satisfy trait (without assoc constraints)"""
        val obligation = Obligation.new(ty, TraitRef.new(trait_name))
        self.solve(obligation)

    fn can_satisfy_with_assoc(
        ty: HirType,
        trait_name: Symbol,
        assoc_name: Symbol,
        assoc_type: HirType
    ) -> bool:
        """Check if type satisfies trait with associated type constraint"""
        val obligation = Obligation.with_assoc_constraint(
            ty,
            TraitRef.new(trait_name),
            assoc_name,
            assoc_type
        )
        self.solve(obligation)
