"""
Variance Checking - Consolidated from Phase 6A-6D

Implements variance types, composition rules, inference algorithm,
subtyping validation, type checker integration, and annotation checking.
"""

type Symbol = text

# ============================================================================
# Variance
# ============================================================================

enum Variance:
    """
    Variance of a type parameter

    Examples:
        Covariant (+T):     F<A> <: F<B> if A <: B (producer, read-only)
        Contravariant (-T): F<A> <: F<B> if B <: A (consumer, input)
        Inv (T):            F<A> <: F<B> only if A = B (both, mutable)
        Bivariant (±T):     F<A> <: F<B> always (unused parameter)
    """
    Covariant        # +T (producer, read-only)
    Contravariant    # -T (consumer, input)
    Inv              # T (both, mutable) - renamed from Invariant (keyword conflict)
    Bivariant        # ±T (unused)

impl Variance:
    fn to_string() -> text:
        match self:
            case Covariant: "+"
            case Contravariant: "-"
            case Inv: "="
            case Bivariant: "±"

    fn to_long_string() -> text:
        match self:
            case Covariant: "covariant"
            case Contravariant: "contravariant"
            case Inv: "inv"
            case Bivariant: "bivariant"

    fn is_covariant() -> bool:
        match self:
            case Covariant: true
            case _: false

    fn is_contravariant() -> bool:
        match self:
            case Contravariant: true
            case _: false

    fn is_inv() -> bool:
        match self:
            case Inv: true
            case _: false

    fn is_bivariant() -> bool:
        match self:
            case Bivariant: true
            case _: false

# ============================================================================
# Variance Operations
# ============================================================================

class VarianceOps:
    """Helper class for variance operations"""

    static fn flip(v: Variance) -> Variance:
        """
        Flip variance (for contravariant position)

        Examples:
            flip(Covariant) = Contravariant
            flip(Contravariant) = Covariant
            flip(Invariant) = Invariant
            flip(Bivariant) = Bivariant
        """
        match v:
            case Covariant: Variance.Contravariant
            case Contravariant: Variance.Covariant
            case Inv: Variance.Inv
            case Bivariant: Variance.Bivariant

    static fn compose(outer: Variance, inner: Variance) -> Variance:
        """
        Compose two variance contexts

        Rules:
            Covariant + v = v
            Contravariant + v = flip(v)
            Invariant + v = Invariant
            Bivariant + v = Bivariant

        Examples:
            compose(Covariant, Covariant) = Covariant
            compose(Contravariant, Covariant) = Contravariant
            compose(Contravariant, Contravariant) = Covariant (double flip)
            compose(Invariant, Covariant) = Invariant
        """
        match outer:
            case Covariant:
                # Covariant context preserves variance
                inner

            case Contravariant:
                # Contravariant context flips variance
                VarianceOps.flip(inner)

            case Inv:
                # Invariant context forces invariance
                Variance.Inv

            case Bivariant:
                # Bivariant context forces bivariance
                Variance.Bivariant

    static fn combine(v1: Variance, v2: Variance) -> Variance:
        """
        Combine two variance constraints (intersection)

        Rules:
            Bivariant + v = v (unused constraint)
            v + Bivariant = v (unused constraint)
            Covariant + Covariant = Covariant (both agree)
            Contravariant + Contravariant = Contravariant (both agree)
            Otherwise = Invariant (conflict)

        Examples:
            combine(Covariant, Bivariant) = Covariant
            combine(Covariant, Covariant) = Covariant
            combine(Covariant, Contravariant) = Invariant (conflict)
            combine(Invariant, Covariant) = Invariant (already most restrictive)
        """
        match (v1, v2):
            # Bivariant is identity (unused parameter)
            case (Bivariant, v): v
            case (v, Bivariant): v

            # Same variance → keep it
            case (Covariant, Covariant): Variance.Covariant
            case (Contravariant, Contravariant): Variance.Contravariant
            case (Invariant, Invariant): Variance.Inv

            # Conflict → invariant (most restrictive)
            case _: Variance.Inv

# ============================================================================
# Type Parameter Definition (Phase 6A)
# ============================================================================

class TypeParamDef:
    """
    Type parameter definition with variance

    Examples:
        +T (covariant, explicit)
        T (invariant by default, inferred)
        -U (contravariant, explicit)
    """
    name: Symbol
    variance: Variance  # Explicit or inferred

impl TypeParamDef:
    static fn covariant(name: Symbol) -> TypeParamDef:
        TypeParamDef(name: name, variance: Variance.Covariant)

    static fn contravariant(name: Symbol) -> TypeParamDef:
        TypeParamDef(name: name, variance: Variance.Contravariant)

    static fn inv(name: Symbol) -> TypeParamDef:
        TypeParamDef(name: name, variance: Variance.Inv)

    static fn bivariant(name: Symbol) -> TypeParamDef:
        TypeParamDef(name: name, variance: Variance.Bivariant)

    fn to_string() -> text:
        "{self.variance.to_string()}{self.name}"

# ============================================================================
# Variance Environment (Phase 6A)
# ============================================================================

class VarianceEnv:
    """
    Environment tracking variance for type parameters

    Maps: type name → parameter name → variance

    Example:
        Box → T → Covariant
        Cell → T → Invariant
        Fn → T → Contravariant
        Fn → U → Covariant
    """
    type_variances: text  # Dict<Symbol, Dict<Symbol, Variance>>

impl VarianceEnv:
    static fn empty() -> VarianceEnv:
        VarianceEnv(type_variances: {})

    me set_type_variance(type_name: Symbol, param_name: Symbol, variance: Variance):
        """Set variance for a type parameter"""
        if type_name not in self.type_variances:
            self.type_variances[type_name] = {}

        # Get inner dict, modify it, assign back
        var type_vars = self.type_variances[type_name]
        type_vars[param_name] = variance
        self.type_variances[type_name] = type_vars

    fn get_type_variance(type_name: Symbol, param_name: Symbol) -> Variance:
        """
        Get variance for a type parameter

        Returns: Variance or Bivariant if not found
        """
        if type_name not in self.type_variances:
            return Variance.Bivariant

        val type_vars = self.type_variances[type_name]

        if param_name not in type_vars:
            return Variance.Bivariant

        type_vars[param_name]

    fn get_type_variances(type_name: Symbol) -> [Variance]:
        """
        Get all variances for a type's parameters (in order)

        Returns: List of variances, empty if type not found
        """
        if type_name not in self.type_variances:
            return []

        val type_vars = self.type_variances[type_name]
        var result = []

        # NOTE: Dict iteration order may not match parameter order
        # In real implementation, would need to track parameter order separately
        for param_name in type_vars:
            result.push(type_vars[param_name])

        result

    me set_type_variances(type_name: Symbol, variances: [Variance], param_names: [Symbol]):
        """
        Set all variances for a type's parameters

        Requires: variances.len() == param_names.len()
        """
        if type_name not in self.type_variances:
            self.type_variances[type_name] = {}

        # Get inner dict, modify it, assign back
        var type_vars = self.type_variances[type_name]

        for i, param_name in param_names.enumerate():
            if i < variances.len():
                type_vars[param_name] = variances[i]

        self.type_variances[type_name] = type_vars

    fn has_type(type_name: Symbol) -> bool:
        """Check if type is in environment"""
        type_name in self.type_variances

    fn type_count() -> i64:
        """Count types in environment"""
        self.type_variances.len()

# ============================================================================
# Type System (Phase 6B)
# ============================================================================

enum HirType:
    """
    Simplified HIR type for variance inference

    Examples:
        TypeParam(0)                    # Type parameter T (id 0)
        Arrow(TypeParam(0), Int)        # fn(T) -> i32
        Generic("Box", [TypeParam(0)])  # Box<T>
        MutRef(TypeParam(0))            # mut T (always invariant)
    """
    Int
    Str
    Bool
    TypeParam(id: i64)                    # Type parameter reference
    Arrow(from: HirType, to: HirType)     # Function type
    Generic(name: Symbol, args: [HirType]) # Generic type
    MutRef(inner: HirType)                # Mutable reference (invariant)

impl HirType:
    fn to_string() -> text:
        match self:
            case Int: "i32"
            case Str: "String"
            case Bool: "bool"
            case TypeParam(id): "T{id}"
            case Arrow(from, to):
                "fn({from.to_string()}) -> {to.to_string()}"
            case Generic(name, args):
                if args.len() == 0:
                    name
                else:
                    val arg_strs = []
                    for arg in args:
                        arg_strs.push(arg.to_string())
                    val args_str = if arg_strs.len() > 0: arg_strs[0] else: ""
                    "{name}<{args_str}>"
            case MutRef(inner):
                "mut {inner.to_string()}"

# ============================================================================
# Type Definition (Phase 6B)
# ============================================================================

class FieldDef:
    """Field in a struct/class"""
    name: Symbol
    ty: HirType

class MethodDef:
    """Method in a struct/class"""
    name: Symbol
    params: [HirType]
    return_ty: HirType

class TypeDef:
    """
    Type definition for variance inference

    Examples:
        struct Box<T>:
            value: T

        struct Cell<T>:
            value: mut T

        type Fn<T, U> = fn(T) -> U
    """
    name: Symbol
    type_param_count: i64
    fields: [FieldDef]
    methods: [MethodDef]

# ============================================================================
# Variance Inference (Phase 6B)
# ============================================================================

class VarianceInference:
    """
    Infer variance for type parameters from type definitions

    Algorithm:
    1. Initialize all parameters to Bivariant (unused)
    2. Walk through type definition:
       - Fields: analyze in covariant context
       - Method params: analyze in contravariant context
       - Method return: analyze in covariant context
    3. Combine variances using composition rules
    4. Fixed-point iteration for recursive types
    """
    type_defs: text  # Dict<Symbol, TypeDef>
    variances: text  # Dict<Symbol, [Variance]> - type name → variances

impl VarianceInference:
    static fn empty() -> VarianceInference:
        VarianceInference(
            type_defs: {},
            variances: {}
        )

    me add_type_def(type_def: TypeDef):
        """Add a type definition"""
        self.type_defs[type_def.name] = type_def

    me infer_variance(type_name: Symbol) -> [Variance]:
        """
        Infer variance for all type parameters in a type

        Returns: List of variances (one per type parameter)
        """
        # Check if already computed
        if type_name in self.variances:
            return self.variances[type_name]

        # Get type definition
        if type_name not in self.type_defs:
            return []

        val type_def = self.type_defs[type_name]

        # Initialize all parameters to bivariant (unused)
        var variances = []
        for i in 0..type_def.type_param_count:
            variances.push(Variance.Bivariant)

        # Analyze fields (covariant context)
        for field in type_def.fields:
            val field_variances = self.analyze_type(
                field.ty,
                Variance.Covariant,
                variances
            )

            # Combine with existing
            variances = self.merge_variances(variances, field_variances)

        # Analyze methods
        for method in type_def.methods:
            # Parameters are contravariant
            for param in method.params:
                val param_variances = self.analyze_type(
                    param,
                    Variance.Contravariant,
                    variances
                )
                variances = self.merge_variances(variances, param_variances)

            # Return type is covariant
            val return_variances = self.analyze_type(
                method.return_ty,
                Variance.Covariant,
                variances
            )
            variances = self.merge_variances(variances, return_variances)

        # Cache and return
        self.variances[type_name] = variances
        variances

    me analyze_type(ty: HirType, context: Variance, current_variances: [Variance]) -> [Variance]:
        """
        Analyze a type in a given variance context

        Returns: Variances for each type parameter (indexed by param id)
        """
        match ty:
            case TypeParam(id):
                # Found usage of type parameter
                var result = []
                for i in 0..current_variances.len():
                    if i == id:
                        result.push(context)
                    else:
                        result.push(Variance.Bivariant)
                result

            case Arrow(from, to):
                # Function type: parameter is contravariant, return is covariant
                val from_variances = self.analyze_type(
                    from,
                    VarianceOps.flip(context),  # Flip for parameter
                    current_variances
                )
                val to_variances = self.analyze_type(
                    to,
                    context,  # Same context for return
                    current_variances
                )
                self.merge_variances(from_variances, to_variances)

            case Generic(name, args):
                # Look up variance of the generic type's parameters
                val type_variances = self.infer_variance(name)

                var result = []
                for i in 0..current_variances.len():
                    result.push(Variance.Bivariant)

                for i, arg in args.enumerate():
                    if i < type_variances.len():
                        val param_variance = type_variances[i]
                        val combined_context = VarianceOps.compose(context, param_variance)

                        val arg_variances = self.analyze_type(arg, combined_context, current_variances)
                        result = self.merge_variances(result, arg_variances)

                result

            case MutRef(inner):
                # Mutable reference is always invariant
                self.analyze_type(inner, Variance.Inv, current_variances)

            case _:
                # Primitives (Int, Str, Bool) don't use type parameters
                var result = []
                for i in 0..current_variances.len():
                    result.push(Variance.Bivariant)
                result

    fn merge_variances(v1: [Variance], v2: [Variance]) -> [Variance]:
        """Merge two variance lists (combine element-wise)"""
        var result = []

        val max_len = if v1.len() > v2.len(): v1.len() else: v2.len()

        for i in 0..max_len:
            val var1 = if i < v1.len(): v1[i] else: Variance.Bivariant
            val var2 = if i < v2.len(): v2[i] else: Variance.Bivariant

            result.push(VarianceOps.combine(var1, var2))

        result

    fn get_variance(type_name: Symbol) -> [Variance]:
        """Get inferred variance (or empty if not computed)"""
        if type_name in self.variances:
            return self.variances[type_name]
        []

# ============================================================================
# Subtyping Hierarchy (Phase 6C)
# ============================================================================

class SubtypeEnv:
    """
    Environment tracking subtyping relationships

    Examples:
        Cat <: Animal
        Dog <: Animal
        Animal <: Any
    """
    subtypes: text  # Dict<Symbol, [Symbol]> - type → list of supertypes

impl SubtypeEnv:
    static fn empty() -> SubtypeEnv:
        SubtypeEnv(subtypes: {})

    me add_subtype(sub: Symbol, sup: Symbol):
        """Declare sub <: sup"""
        if sub not in self.subtypes:
            self.subtypes[sub] = []

        var supers = self.subtypes[sub]
        supers.push(sup)
        self.subtypes[sub] = supers

    fn is_subtype(sub: Symbol, sup: Symbol) -> bool:
        """Check if sub <: sup (direct or transitive)"""
        if sub == sup:
            return true

        if sub not in self.subtypes:
            return false

        val supers = self.subtypes[sub]

        # Direct subtype
        if sup in supers:
            return true

        # Transitive: check if any supertype is subtype of sup
        for s in supers:
            if self.is_subtype(s, sup):
                return true

        false

# ============================================================================
# Variance Checker (Phase 6C)
# ============================================================================

class VarianceChecker:
    """
    Check subtyping using variance information

    Rules:
        Covariant:     F<A> <: F<B> if A <: B
        Contravariant: F<A> <: F<B> if B <: A (flipped!)
        Invariant:     F<A> <: F<B> only if A = B
        Bivariant:     F<A> <: F<B> always
    """
    variance_env: text   # Dict<Symbol, [Variance]> - type → variances
    subtype_env: SubtypeEnv

impl VarianceChecker:
    static fn new_checker(subtype_env: SubtypeEnv) -> VarianceChecker:
        VarianceChecker(
            variance_env: {},
            subtype_env: subtype_env
        )

    me set_variance(type_name: Symbol, variances: [Variance]):
        """Set variance for a type"""
        self.variance_env[type_name] = variances

    fn check_subtype(sub: HirType, sup: HirType) -> bool:
        """
        Check if sub <: sup

        Uses variance to determine if generic types are subtypes
        """
        match (sub, sup):
            case (Int, Int): true
            case (Str, Str): true
            case (Bool, Bool): true

            case (Generic(name1, args1), Generic(name2, args2)):
                if name1 != name2:
                    return false

                # Check type arguments according to variance
                if name1 not in self.variance_env:
                    # No variance info → assume invariant
                    return self.types_equal(sub, sup)

                val variances = self.variance_env[name1]

                for i, (arg1, arg2) in args1.zip(args2).enumerate():
                    if i >= variances.len():
                        # No variance for this param → invariant
                        if not self.types_equal(arg1, arg2):
                            return false
                    else:
                        val variance = variances[i]

                        match variance:
                            case Covariant:
                                # F<A> <: F<B> if A <: B
                                if not self.check_subtype(arg1, arg2):
                                    return false

                            case Contravariant:
                                # F<A> <: F<B> if B <: A (flipped!)
                                if not self.check_subtype(arg2, arg1):
                                    return false

                            case Inv:
                                # F<A> <: F<B> only if A = B
                                if not self.types_equal(arg1, arg2):
                                    return false

                            case Bivariant:
                                # F<A> <: F<B> always (unused parameter)
                                ()

                true

            case (Arrow(from1, to1), Arrow(from2, to2)):
                # fn(A) -> B <: fn(C) -> D
                # if C <: A (contravariant param) and B <: D (covariant return)
                self.check_subtype(from2, from1) and self.check_subtype(to1, to2)

            case _:
                # Structural subtyping not implemented
                false

    fn types_equal(ty1: HirType, ty2: HirType) -> bool:
        """Check if two types are equal"""
        match (ty1, ty2):
            case (Int, Int): true
            case (Str, Str): true
            case (Bool, Bool): true
            case (TypeParam(id1), TypeParam(id2)): id1 == id2

            case (Arrow(from1, to1), Arrow(from2, to2)):
                self.types_equal(from1, from2) and self.types_equal(to1, to2)

            case (Generic(name1, args1), Generic(name2, args2)):
                if name1 != name2:
                    return false
                if args1.len() != args2.len():
                    return false

                for i, (arg1, arg2) in args1.zip(args2).enumerate():
                    if not self.types_equal(arg1, arg2):
                        return false

                true

            case _: false

# ============================================================================
# Named Types for Testing (Phase 6C)
# ============================================================================

class NamedType:
    """Named type for subtyping tests (Cat, Animal, etc.)"""
    name: Symbol

# Helper to create named generic types
fn box_of(name: Symbol) -> HirType:
    HirType.Generic(name: "Box", args: [HirType.Generic(name: name, args: [])])

fn cell_of(name: Symbol) -> HirType:
    HirType.Generic(name: "Cell", args: [HirType.Generic(name: name, args: [])])

fn fn_type(param: Symbol, ret: Symbol) -> HirType:
    HirType.Arrow(
        from: HirType.Generic(name: param, args: []),
        to: HirType.Generic(name: ret, args: [])
    )

# ============================================================================
# Integrated Type Checker (Phase 6D)
# ============================================================================

class TypeCheckerIntegrated:
    """
    Type checker with integrated variance checking

    Simulates integration points for:
    - Assignment checking
    - Method call validation
    - Generic instantiation
    """
    variance_checker: VarianceChecker

impl TypeCheckerIntegrated:
    static fn new_checker(variance_checker: VarianceChecker) -> TypeCheckerIntegrated:
        TypeCheckerIntegrated(variance_checker: variance_checker)

    fn check_assignment(lhs_ty: HirType, rhs_ty: HirType) -> bool:
        """
        Check assignment: lhs = rhs

        Valid if rhs_ty <: lhs_ty
        """
        self.variance_checker.check_subtype(rhs_ty, lhs_ty)

    fn check_method_call(receiver_ty: HirType, expected_ty: HirType) -> bool:
        """
        Check method call receiver

        Valid if receiver_ty <: expected_ty
        """
        self.variance_checker.check_subtype(receiver_ty, expected_ty)

    fn check_generic_instantiation(type_name: Symbol, args: [HirType]) -> bool:
        """
        Check generic type instantiation

        For now, just returns true (placeholder)
        In real implementation, would check bounds, etc.
        """
        true

# ============================================================================
# Variance Annotation Validation (Phase 6D)
# ============================================================================

class VarianceAnnotation:
    """
    Validates explicit variance annotations match inferred variance

    Examples:
        struct Box<+T>:  # Explicit covariant annotation
            value: T     # Inferred: covariant

        If mismatch, emit warning
    """
    name: Symbol
    param_name: Symbol
    explicit: Variance
    inferred: Variance

impl VarianceAnnotation:
    fn matches() -> bool:
        """Check if explicit annotation matches inferred variance"""
        match (self.explicit, self.inferred):
            case (Covariant, Covariant): true
            case (Contravariant, Contravariant): true
            case (Inv, Inv): true
            case (Bivariant, Bivariant): true
            case _: false

    fn to_warning() -> text:
        """Generate warning message for mismatch"""
        "Warning: {self.name}<{self.param_name}>: explicit variance {self.explicit.to_long_string()} doesn't match inferred {self.inferred.to_long_string()}"

# ============================================================================
# Error Messages (Phase 6D)
# ============================================================================

class VarianceError:
    """Variance error for reporting"""
    message: text

impl VarianceError:
    static fn covariant_violation(sub: HirType, sup: HirType) -> VarianceError:
        VarianceError(
            message: "Variance error: cannot assign {sub.to_string()} to {sup.to_string()} (covariant type)"
        )

    static fn inv_violation(sub: HirType, sup: HirType) -> VarianceError:
        VarianceError(
            message: "Variance error: cannot assign {sub.to_string()} to {sup.to_string()} (invariant type)"
        )

    fn to_string() -> text:
        self.message

# ============================================================================
# Tests - Phase 6A: Variance Representation
# ============================================================================

fn test_variance_basic():
    """Test basic variance creation"""
    val cov = Variance.Covariant
    val contra = Variance.Contravariant
    val inv = Variance.Inv
    val bi = Variance.Bivariant

    assert cov.is_covariant(), "Is covariant"
    assert contra.is_contravariant(), "Is contravariant"
    assert inv.is_inv(), "Is invariant"
    assert bi.is_bivariant(), "Is bivariant"

    assert cov.to_string() == "+", "Covariant symbol"
    assert contra.to_string() == "-", "Contravariant symbol"
    assert inv.to_string() == "=", "Invariant symbol"
    assert bi.to_string() == "±", "Bivariant symbol"

    print "  [pass] Basic variance"

fn test_variance_flip():
    """Test variance flipping"""
    val cov = Variance.Covariant
    val contra = Variance.Contravariant
    val inv = Variance.Inv
    val bi = Variance.Bivariant

    # Flip covariant → contravariant
    val flipped_cov = VarianceOps.flip(cov)
    assert flipped_cov.is_contravariant(), "Flip covariant"

    # Flip contravariant → covariant
    val flipped_contra = VarianceOps.flip(contra)
    assert flipped_contra.is_covariant(), "Flip contravariant"

    # Flip invariant → invariant
    val flipped_inv = VarianceOps.flip(inv)
    assert flipped_inv.is_inv(), "Flip invariant"

    # Flip bivariant → bivariant
    val flipped_bi = VarianceOps.flip(bi)
    assert flipped_bi.is_bivariant(), "Flip bivariant"

    print "  [pass] Variance flip"

fn test_variance_compose():
    """Test variance composition"""
    val cov = Variance.Covariant
    val contra = Variance.Contravariant
    val inv = Variance.Inv

    # Covariant + v = v
    val result1 = VarianceOps.compose(cov, cov)
    assert result1.is_covariant(), "Cov + Cov = Cov"

    val result2 = VarianceOps.compose(cov, contra)
    assert result2.is_contravariant(), "Cov + Contra = Contra"

    # Contravariant + v = flip(v)
    val result3 = VarianceOps.compose(contra, cov)
    assert result3.is_contravariant(), "Contra + Cov = Contra"

    val result4 = VarianceOps.compose(contra, contra)
    assert result4.is_covariant(), "Contra + Contra = Cov (double flip)"

    # Invariant + v = Invariant
    val result5 = VarianceOps.compose(inv, cov)
    assert result5.is_inv(), "Inv + Cov = Inv"

    print "  [pass] Variance compose"

fn test_variance_combine():
    """Test variance combination"""
    val cov = Variance.Covariant
    val contra = Variance.Contravariant
    val inv = Variance.Inv
    val bi = Variance.Bivariant

    # Bivariant is identity
    val result1 = VarianceOps.combine(bi, cov)
    assert result1.is_covariant(), "Bi + Cov = Cov"

    val result2 = VarianceOps.combine(cov, bi)
    assert result2.is_covariant(), "Cov + Bi = Cov"

    # Same variance → keep it
    val result3 = VarianceOps.combine(cov, cov)
    assert result3.is_covariant(), "Cov + Cov = Cov"

    val result4 = VarianceOps.combine(contra, contra)
    assert result4.is_contravariant(), "Contra + Contra = Contra"

    # Conflict → invariant
    val result5 = VarianceOps.combine(cov, contra)
    assert result5.is_inv(), "Cov + Contra = Inv (conflict)"

    val result6 = VarianceOps.combine(inv, cov)
    assert result6.is_inv(), "Inv + Cov = Inv (already invariant)"

    print "  [pass] Variance combine"

fn test_type_param_def():
    """Test type parameter definition"""
    val t_cov = TypeParamDef.covariant("T")
    val u_contra = TypeParamDef.contravariant("U")
    val v_inv = TypeParamDef.inv("V")

    assert t_cov.variance.is_covariant(), "T is covariant"
    assert u_contra.variance.is_contravariant(), "U is contravariant"
    assert v_inv.variance.is_inv(), "V is invariant"

    assert t_cov.to_string() == "+T", "T string"
    assert u_contra.to_string() == "-U", "U string"
    assert v_inv.to_string() == "=V", "V string"

    print "  [pass] Type parameter definition"

fn test_variance_env():
    """Test variance environment"""
    val env = VarianceEnv.empty()

    assert env.type_count() == 0, "Initially empty"

    # Set Box<T> = Covariant
    env.set_type_variance("Box", "T", Variance.Covariant)

    assert env.has_type("Box"), "Has Box"
    assert env.type_count() == 1, "One type"

    val t_var = env.get_type_variance("Box", "T")
    assert t_var.is_covariant(), "Box<T> is covariant"

    # Set Cell<T> = Invariant
    env.set_type_variance("Cell", "T", Variance.Inv)

    assert env.has_type("Cell"), "Has Cell"
    assert env.type_count() == 2, "Two types"

    val cell_t_var = env.get_type_variance("Cell", "T")
    assert cell_t_var.is_inv(), "Cell<T> is invariant"

    # Get unknown type → Bivariant
    val unknown = env.get_type_variance("Unknown", "X")
    assert unknown.is_bivariant(), "Unknown type is bivariant"

    print "  [pass] Variance environment"

fn test_variance_env_multiple():
    """Test variance environment with multiple parameters"""
    val env = VarianceEnv.empty()

    # Set Fn<T, U> = (Contravariant, Covariant)
    env.set_type_variance("Fn", "T", Variance.Contravariant)
    env.set_type_variance("Fn", "U", Variance.Covariant)

    val t_var = env.get_type_variance("Fn", "T")
    val u_var = env.get_type_variance("Fn", "U")

    assert t_var.is_contravariant(), "Fn<T> is contravariant"
    assert u_var.is_covariant(), "Fn<U> is covariant"

    print "  [pass] Variance environment multiple params"

fn test_variance_env_bulk():
    """Test setting all variances at once"""
    val env = VarianceEnv.empty()

    # Set Result<T, E> = (Covariant, Covariant)
    val variances = [Variance.Covariant, Variance.Covariant]
    val param_names = ["T", "E"]

    env.set_type_variances("Result", variances, param_names)

    val t_var = env.get_type_variance("Result", "T")
    val e_var = env.get_type_variance("Result", "E")

    assert t_var.is_covariant(), "Result<T> is covariant"
    assert e_var.is_covariant(), "Result<E> is covariant"

    print "  [pass] Variance environment bulk set"

# ============================================================================
# Tests - Phase 6B: Variance Inference
# ============================================================================

fn test_infer_box():
    """Test Box<T> (covariant)"""
    val infer = VarianceInference.empty()

    # struct Box<T>:
    #     value: T
    val box_def = TypeDef(
        name: "Box",
        type_param_count: 1,
        fields: [
            FieldDef(name: "value", ty: HirType.TypeParam(id: 0))
        ],
        methods: []
    )

    infer.add_type_def(box_def)

    val variances = infer.infer_variance("Box")

    assert variances.len() == 1, "One type parameter"
    assert variances[0].to_string() == "+", "T is covariant"

    print "  [pass] Infer Box<T> = Covariant"

fn test_infer_cell():
    """Test Cell<T> (invariant via mut)"""
    val infer = VarianceInference.empty()

    # struct Cell<T>:
    #     value: mut T
    val cell_def = TypeDef(
        name: "Cell",
        type_param_count: 1,
        fields: [
            FieldDef(
                name: "value",
                ty: HirType.MutRef(inner: HirType.TypeParam(id: 0))
            )
        ],
        methods: []
    )

    infer.add_type_def(cell_def)

    val variances = infer.infer_variance("Cell")

    assert variances.len() == 1, "One type parameter"
    assert variances[0].to_string() == "=", "T is invariant"

    print "  [pass] Infer Cell<T> = Invariant"

fn test_infer_function_type():
    """Test fn(T) -> U (contravariant/covariant)"""
    val infer = VarianceInference.empty()

    # type Fn<T, U> = fn(T) -> U
    # Represented as: Generic("Fn", [T, U]) where Fn has fields: [Arrow(T, U)]
    val fn_def = TypeDef(
        name: "Fn",
        type_param_count: 2,
        fields: [
            FieldDef(
                name: "call",
                ty: HirType.Arrow(
                    from: HirType.TypeParam(id: 0),  # T
                    to: HirType.TypeParam(id: 1)     # U
                )
            )
        ],
        methods: []
    )

    infer.add_type_def(fn_def)

    val variances = infer.infer_variance("Fn")

    assert variances.len() == 2, "Two type parameters"
    assert variances[0].to_string() == "-", "T is contravariant"
    assert variances[1].to_string() == "+", "U is covariant"

    print "  [pass] Infer Fn<T, U> = (Contravariant, Covariant)"

fn test_infer_nested_variance():
    """Test nested variance: Processor<T> with handler: fn(T) -> ()"""
    val infer = VarianceInference.empty()

    # struct Processor<T>:
    #     handler: fn(T) -> ()
    val processor_def = TypeDef(
        name: "Processor",
        type_param_count: 1,
        fields: [
            FieldDef(
                name: "handler",
                ty: HirType.Arrow(
                    from: HirType.TypeParam(id: 0),  # T
                    to: HirType.Int                  # () represented as Int
                )
            )
        ],
        methods: []
    )

    infer.add_type_def(processor_def)

    val variances = infer.infer_variance("Processor")

    # T appears in field (covariant context)
    # But inside fn(T) -> () (contravariant position in function)
    # Result: covariant context + contravariant position = contravariant
    assert variances.len() == 1, "One type parameter"
    assert variances[0].to_string() == "-", "T is contravariant"

    print "  [pass] Infer nested variance (Processor<T>)"

fn test_infer_multiple_uses():
    """Test type parameter used in multiple positions"""
    val infer = VarianceInference.empty()

    # struct Container<T>:
    #     get_value: fn() -> T      # T covariant (return)
    #     set_value: fn(T) -> ()    # T contravariant (param)
    val container_def = TypeDef(
        name: "Container",
        type_param_count: 1,
        fields: [],
        methods: [
            MethodDef(
                name: "get_value",
                params: [],
                return_ty: HirType.TypeParam(id: 0)  # T covariant
            ),
            MethodDef(
                name: "set_value",
                params: [HirType.TypeParam(id: 0)],  # T contravariant
                return_ty: HirType.Int
            )
        ]
    )

    infer.add_type_def(container_def)

    val variances = infer.infer_variance("Container")

    # T appears in both covariant and contravariant positions
    # Combine: Covariant + Contravariant = Invariant
    assert variances.len() == 1, "One type parameter"
    assert variances[0].to_string() == "=", "T is invariant"

    print "  [pass] Infer multiple uses (Container<T> = Invariant)"

fn test_infer_generic_composition():
    """Test generic type composition"""
    val infer = VarianceInference.empty()

    # First define Box<T> (covariant)
    val box_def = TypeDef(
        name: "Box",
        type_param_count: 1,
        fields: [FieldDef(name: "value", ty: HirType.TypeParam(id: 0))],
        methods: []
    )
    infer.add_type_def(box_def)

    # Then define Wrapper<T>:
    #     boxed: Box<T>
    val wrapper_def = TypeDef(
        name: "Wrapper",
        type_param_count: 1,
        fields: [
            FieldDef(
                name: "boxed",
                ty: HirType.Generic(
                    name: "Box",
                    args: [HirType.TypeParam(id: 0)]
                )
            )
        ],
        methods: []
    )
    infer.add_type_def(wrapper_def)

    val wrapper_variances = infer.infer_variance("Wrapper")

    # T in Wrapper appears in Box<T>
    # Box<T> is covariant, so T in Wrapper is covariant
    assert wrapper_variances.len() == 1, "One type parameter"
    assert wrapper_variances[0].to_string() == "+", "T is covariant"

    print "  [pass] Infer generic composition (Wrapper<Box<T>>)"

fn test_infer_bivariant():
    """Test unused type parameter (bivariant)"""
    val infer = VarianceInference.empty()

    # struct Marker<T>:
    #     # T not used
    #     marker: i32
    val marker_def = TypeDef(
        name: "Marker",
        type_param_count: 1,
        fields: [
            FieldDef(name: "marker", ty: HirType.Int)
        ],
        methods: []
    )

    infer.add_type_def(marker_def)

    val variances = infer.infer_variance("Marker")

    assert variances.len() == 1, "One type parameter"
    assert variances[0].to_string() == "±", "T is bivariant (unused)"

    print "  [pass] Infer bivariant (Marker<T> unused)"

# ============================================================================
# Tests - Phase 6C: Variance Checking
# ============================================================================

fn test_covariant_subtyping():
    """Test covariant subtyping (Box<Cat> <: Box<Animal>)"""
    val subtype_env = SubtypeEnv.empty()
    subtype_env.add_subtype("Cat", "Animal")

    val checker = VarianceChecker.new_checker(subtype_env)
    checker.set_variance("Box", [Variance.Covariant])

    # Box<Cat> <: Box<Animal>?
    val box_cat = box_of("Cat")
    val box_animal = box_of("Animal")

    assert checker.check_subtype(box_cat, box_animal), "Box<Cat> <: Box<Animal>"

    # Box<Animal> <: Box<Cat>? No.
    assert not checker.check_subtype(box_animal, box_cat), "Box<Animal> not <: Box<Cat>"

    print "  [pass] Covariant subtyping"

fn test_inv_rejection():
    """Test invariant rejection (Cell<Cat> not <: Cell<Animal>)"""
    val subtype_env = SubtypeEnv.empty()
    subtype_env.add_subtype("Cat", "Animal")

    val checker = VarianceChecker.new_checker(subtype_env)
    checker.set_variance("Cell", [Variance.Inv])

    # Cell<Cat> <: Cell<Animal>? No.
    val cell_cat = cell_of("Cat")
    val cell_animal = cell_of("Animal")

    assert not checker.check_subtype(cell_cat, cell_animal), "Cell<Cat> not <: Cell<Animal>"

    # Cell<Animal> <: Cell<Cat>? No.
    assert not checker.check_subtype(cell_animal, cell_cat), "Cell<Animal> not <: Cell<Cat>"

    # Cell<Cat> <: Cell<Cat>? Yes (same type)
    assert checker.check_subtype(cell_cat, cell_cat), "Cell<Cat> <: Cell<Cat>"

    print "  [pass] Invariant rejection"

fn test_contravariant_function():
    """Test contravariant function parameters"""
    val subtype_env = SubtypeEnv.empty()
    subtype_env.add_subtype("Cat", "Animal")

    val checker = VarianceChecker.new_checker(subtype_env)

    # fn(Animal) -> () <: fn(Cat) -> ()?
    # Check: fn(A) -> B <: fn(C) -> D if C <: A and B <: D
    # Here: Cat <: Animal (param) and () <: () (return)
    # Result: Yes
    val feed_animal = fn_type("Animal", "Unit")
    val feed_cat = fn_type("Cat", "Unit")

    assert checker.check_subtype(feed_animal, feed_cat), "fn(Animal) <: fn(Cat)"

    # fn(Cat) -> () <: fn(Animal) -> ()? No.
    assert not checker.check_subtype(feed_cat, feed_animal), "fn(Cat) not <: fn(Animal)"

    print "  [pass] Contravariant function parameters"

fn test_nested_variance():
    """Test nested variance checking"""
    val subtype_env = SubtypeEnv.empty()
    subtype_env.add_subtype("Cat", "Animal")

    val checker = VarianceChecker.new_checker(subtype_env)
    checker.set_variance("Box", [Variance.Covariant])

    # Box<Box<Cat>> <: Box<Box<Animal>>?
    # Outer Box is covariant, inner Box is covariant
    # Result: Yes
    val box_box_cat = HirType.Generic(
        name: "Box",
        args: [box_of("Cat")]
    )
    val box_box_animal = HirType.Generic(
        name: "Box",
        args: [box_of("Animal")]
    )

    assert checker.check_subtype(box_box_cat, box_box_animal), "Box<Box<Cat>> <: Box<Box<Animal>>"

    print "  [pass] Nested variance"

fn test_bivariant_always():
    """Test bivariant (unused parameter)"""
    val subtype_env = SubtypeEnv.empty()
    subtype_env.add_subtype("Cat", "Animal")

    val checker = VarianceChecker.new_checker(subtype_env)
    checker.set_variance("Marker", [Variance.Bivariant])

    # Marker<Cat> <: Marker<Animal>? Yes (bivariant)
    val marker_cat = HirType.Generic(name: "Marker", args: [HirType.Generic(name: "Cat", args: [])])
    val marker_animal = HirType.Generic(name: "Marker", args: [HirType.Generic(name: "Animal", args: [])])

    assert checker.check_subtype(marker_cat, marker_animal), "Marker<Cat> <: Marker<Animal>"

    # Marker<Animal> <: Marker<Cat>? Yes (bivariant)
    assert checker.check_subtype(marker_animal, marker_cat), "Marker<Animal> <: Marker<Cat>"

    print "  [pass] Bivariant always"

fn test_types_equal():
    """Test type equality"""
    val subtype_env = SubtypeEnv.empty()
    val checker = VarianceChecker.new_checker(subtype_env)

    val ty1 = HirType.Int
    val ty2 = HirType.Int
    val ty3 = HirType.Str

    assert checker.types_equal(ty1, ty2), "Int = Int"
    assert not checker.types_equal(ty1, ty3), "Int != Str"

    val box1 = box_of("Cat")
    val box2 = box_of("Cat")
    val box3 = box_of("Dog")

    assert checker.types_equal(box1, box2), "Box<Cat> = Box<Cat>"
    assert not checker.types_equal(box1, box3), "Box<Cat> != Box<Dog>"

    print "  [pass] Type equality"

# ============================================================================
# Tests - Phase 6D: Integration & Advanced Cases
# ============================================================================

fn test_assignment_checking():
    """Test assignment checking integration"""
    val subtype_env = SubtypeEnv.empty()
    subtype_env.add_subtype("Cat", "Animal")

    val checker = VarianceChecker.new_checker(subtype_env)
    checker.set_variance("Box", [Variance.Covariant])

    val type_checker = TypeCheckerIntegrated.new_checker(checker)

    # Valid: val animal_box: Box<Animal> = cat_box
    val cat_box = HirType.Generic(name: "Box", args: [HirType.Generic(name: "Cat", args: [])])
    val animal_box = HirType.Generic(name: "Box", args: [HirType.Generic(name: "Animal", args: [])])

    assert type_checker.check_assignment(animal_box, cat_box), "Valid assignment"

    # Invalid: val cat_box: Box<Cat> = animal_box
    assert not type_checker.check_assignment(cat_box, animal_box), "Invalid assignment"

    print "  [pass] Assignment checking integration"

fn test_method_call_validation():
    """Test method call receiver validation"""
    val subtype_env = SubtypeEnv.empty()
    subtype_env.add_subtype("Cat", "Animal")

    val checker = VarianceChecker.new_checker(subtype_env)
    checker.set_variance("Box", [Variance.Covariant])

    val type_checker = TypeCheckerIntegrated.new_checker(checker)

    # Method expects Box<Animal>, called with Box<Cat>
    val cat_box = HirType.Generic(name: "Box", args: [HirType.Generic(name: "Cat", args: [])])
    val animal_box = HirType.Generic(name: "Box", args: [HirType.Generic(name: "Animal", args: [])])

    assert type_checker.check_method_call(cat_box, animal_box), "Valid method call"
    assert not type_checker.check_method_call(animal_box, cat_box), "Invalid method call"

    print "  [pass] Method call validation"

fn test_variance_annotation_match():
    """Test variance annotation validation"""
    val annotation = VarianceAnnotation(
        name: "Box",
        param_name: "T",
        explicit: Variance.Covariant,
        inferred: Variance.Covariant
    )

    assert annotation.matches(), "Annotation matches"

    print "  [pass] Variance annotation match"

fn test_variance_annotation_mismatch():
    """Test variance annotation mismatch"""
    val annotation = VarianceAnnotation(
        name: "Box",
        param_name: "T",
        explicit: Variance.Inv,  # User said invariant
        inferred: Variance.Covariant  # But inference found covariant
    )

    assert not annotation.matches(), "Annotation doesn't match"

    val warning = annotation.to_warning()
    assert warning.len() > 0, "Warning generated"

    print "  [pass] Variance annotation mismatch"

fn test_error_messages():
    """Test variance error messages"""
    val cat_box = HirType.Generic(name: "Box", args: [HirType.Generic(name: "Cat", args: [])])
    val dog_box = HirType.Generic(name: "Box", args: [HirType.Generic(name: "Dog", args: [])])

    val error1 = VarianceError.covariant_violation(cat_box, dog_box)
    assert error1.to_string().len() > 0, "Error message generated"

    val error2 = VarianceError.inv_violation(cat_box, dog_box)
    assert error2.to_string().len() > 0, "Error message generated"

    print "  [pass] Error messages"

fn test_generic_instantiation():
    """Test generic instantiation checking"""
    val subtype_env = SubtypeEnv.empty()
    val checker = VarianceChecker.new_checker(subtype_env)
    val type_checker = TypeCheckerIntegrated.new_checker(checker)

    # Check instantiation (placeholder, always returns true)
    val result = type_checker.check_generic_instantiation(
        "Box",
        [HirType.Generic(name: "Cat", args: [])]
    )

    assert result, "Generic instantiation OK"

    print "  [pass] Generic instantiation"

# ============================================================================
# Main
# ============================================================================

fn main():
    print ""
    print "Variance Checking - All Phases (6A-6D)"
    print "======================================="

    print ""
    print "Phase 6A: Variance Representation"
    print "----------------------------------"
    test_variance_basic()
    test_variance_flip()
    test_variance_compose()
    test_variance_combine()
    test_type_param_def()
    test_variance_env()
    test_variance_env_multiple()
    test_variance_env_bulk()

    print ""
    print "Phase 6B: Variance Inference"
    print "----------------------------"
    test_infer_box()
    test_infer_cell()
    test_infer_function_type()
    test_infer_nested_variance()
    test_infer_multiple_uses()
    test_infer_generic_composition()
    test_infer_bivariant()

    print ""
    print "Phase 6C: Variance Checking"
    print "---------------------------"
    test_covariant_subtyping()
    test_inv_rejection()
    test_contravariant_function()
    test_nested_variance()
    test_bivariant_always()
    test_types_equal()

    print ""
    print "Phase 6D: Integration & Advanced Cases"
    print "---------------------------------------"
    test_assignment_checking()
    test_method_call_validation()
    test_variance_annotation_match()
    test_variance_annotation_mismatch()
    test_error_messages()
    test_generic_instantiation()

    print ""
    print "All 27 tests passed."
    print ""
