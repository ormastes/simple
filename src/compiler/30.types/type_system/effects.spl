# Effect Inference System
#
# Automatic async/sync effect detection based on function body analysis.
# Maps to Lean 4 model in verification/type_inference_compile/src/AsyncEffectInference.lean
#
# Properties (Formally Verified):
# 1. Effect Determinism: Each function has exactly one inferred effect
# 2. Effect Propagation: Calling async function makes caller async
# 3. Suspension Detection: ~=, if~, while~, for~ operators indicate async
# 4. Sync Safety: sync-annotated functions cannot contain suspension
#
# Port of rust/type/src/effects.rs

# ============================================================================
# Core Types
# ============================================================================

enum Effect:
    """Effect annotation for functions."""
    Sync   # Non-suspending, returns T directly
    Async  # May suspend, returns Promise<T>


# ============================================================================
# Effect Methods (was: impl Effect:)
# ============================================================================

# Effect environment: function name -> inferred effect
# Using Dict<text, Effect> as EffectEnv

# ============================================================================
# Return Wrap Mode (Phase 5: Promise Wrapping)
# ============================================================================

enum ReturnWrapMode:
    """How a return statement should be wrapped."""
    None_      # No wrapping (sync function)
    Resolved  # Wrap with promise_resolved(value)
    Rejected  # Wrap with promise_rejected(error)

# ============================================================================
# Await Mode (Phase 6: Await Inference)
# ============================================================================

enum AwaitMode:
    """Marker for expressions that need automatic await insertion."""
    None_      # No await needed
    Implicit  # Async function call in async-by-default mode
    Explicit  # Explicit suspension (~= operator)

enum TypedAwaitMode:
    """Extended await mode with type information."""
    None_           # No await needed
    ImplicitAwait  # Target expects unwrapped type T
    KeepPromise    # Target expects Promise<T>
    ExplicitAwait  # Explicit await (~= operator)

# ============================================================================
# Promise Type Info (Phase 5)
# ============================================================================

struct PromiseTypeInfo:
    """Information about Promise type wrapping for a function."""
    # # DESUGARED: inner_type: text
    has_inner_type: bool
    inner_type: text
    is_wrapped: bool     # Whether return type should be Promise-wrapped
    # # DESUGARED: original_type: text
    has_original_type: bool
    original_type: text


# ============================================================================
# PromiseTypeInfo Methods (was: impl PromiseTypeInfo:)
# ============================================================================

fn promisetypeinfo_sync_function(return_type: text?) -> PromiseTypeInfo:
        PromiseTypeInfo(inner_type: return_type, is_wrapped: false, original_type: return_type)


fn promisetypeinfo_async_function(return_type: text?) -> PromiseTypeInfo:
        PromiseTypeInfo(inner_type: return_type, is_wrapped: true, original_type: return_type)


# ============================================================================
# Suspension Detection
# ============================================================================

# These functions work on AST node handles (i64 IDs from Rust FFI).
# In pure-Simple mode, they work on Simple AST representations.

struct FunctionInfo:
    """Lightweight function descriptor for effect inference."""
    name: text
    is_sync: bool
    has_async_annotation: bool
    contains_suspension: bool
    called_functions: [text]

fn infer_function_effect(func: FunctionInfo, env: Dict<text, Effect>) -> Effect:
    """Infer the effect of a function based on its body."""
    # Explicit sync annotation
    if func.is_sync:
        return Effect.Sync

    # @async annotation
    if func.has_async_annotation:
        return Effect.Async

    # Suspension operators in body
    if func.contains_suspension:
        return Effect.Async

    # Calls any async function
    for callee in func.called_functions:
        val callee_effect = env_get(env, callee)
        if callee_effect.?:
            if callee_effect_value_is_async(callee_effect_value):
            return Effect.Async

    Effect.Sync

# ============================================================================
# Effect Environment Building
# ============================================================================

fn build_effect_env(functions: [FunctionInfo]) -> Dict<text, Effect>:
    """Build initial effect environment with fixed-point iteration."""
    var env: Dict<text, Effect> = {}

    # First pass: explicit annotations
    for func in functions:
        if func.is_sync:
            env[func.name] = Effect.Sync
        elif func.has_async_annotation:
            env[func.name] = Effect.Async

    # Fixed-point iteration for transitive propagation
    infer_mutual_effects(functions, env)

fn infer_mutual_effects(functions: [FunctionInfo], env: Dict<text, Effect>) -> Dict<text, Effect>:
    """Fixed-point iteration for mutually recursive functions."""
    var env_mut = env
    val max_iterations = 100
    var iteration = 0

    while iteration < max_iterations:
        var changed = false

        for func in functions:
            if env_contains(env_mut, func.name):
                continue

            val inferred = infer_function_effect(func, env_mut)
            val old = env_get(env_mut, func.name)

            if not old.? or old.unwrap() != inferred:
                env_mut[func.name] = inferred
                changed = true

        if not changed:
            break
        iteration = iteration + 1

    env_mut

# ============================================================================
# SCC-Based Effect Propagation (Tarjan)
# ============================================================================

fn propagate_effects_transitive(functions: [FunctionInfo]) -> Dict<text, Effect>:
    """Build effect environment with SCC analysis for mutual recursion.

    1. Find strongly connected components
    2. Process in reverse topological order
    3. All functions in an SCC share same effect (conservatively async if any is)
    """
    var env: Dict<text, Effect> = {}

    # First pass: explicit annotations
    for func in functions:
        if func.is_sync:
            env[func.name] = Effect.Sync
        elif func.has_async_annotation:
            env[func.name] = Effect.Async

    # Build call graph
    val func_names: Dict<text, bool> = {}
    for func in functions:
        func_names[func.name] = true

    var call_graph: Dict<text, [text]> = {}
    for func in functions:
        var callees: [text] = []
        for callee in func.called_functions:
            if func_names_contains(func_names, callee):
                callees = callees_push(callees, callee)
        call_graph[func.name] = callees

    # Find SCCs using Tarjan's algorithm
    val sccs = tarjan_scc(call_graph)

    # Build function lookup
    var func_map: Dict<text, FunctionInfo> = {}
    for func in functions:
        func_map[func.name] = func

    # Process SCCs
    for scc in sccs:
        var any_explicit_async = false
        for name in scc:
            val env_entry = env_get(env, name)
            if env_entry != nil:
                if env_entry.is_async():
                    any_explicit_async = true

        var any_suspension = false
        for name in scc:
            val f = func_map_get(func_map, name)
            if has_f:
                val func = f_value
                if not func.is_sync and func.contains_suspension:
                    any_suspension = true

        var any_calls_async = false
        for name in scc:
            val callees = call_graph_get(call_graph, name) ?? []
            for callee in callees:
                if not scc_contains(scc, callee):
                    val callee_entry = env_get(env, callee)
                    if callee_entry != nil:
                        if callee_entry.is_async():
                            any_calls_async = true

        val scc_effect = if any_explicit_async or any_suspension or any_calls_async:
            Effect.Async
        else:
            Effect.Sync

        for name in scc:
            if not env_contains(env, name):
                env[name] = scc_effect

    env

# Tarjan SCC (reusable algorithm)
fn tarjan_scc(graph: Dict<text, [text]>) -> [[text]]:
    """Find strongly connected components using Tarjan's algorithm."""
    var index_counter = 0
    var stack: [text] = []
    var on_stack: Dict<text, bool> = {}
    var indices: Dict<text, i64> = {}
    var lowlinks: Dict<text, i64> = {}
    var result: [[text]] = []

    for node in graph_keys(graph):
        if not indices_contains(indices, node):
            tarjan_dfs(node, graph, index_counter, stack, on_stack,
                       indices, lowlinks, result)

    result

fn tarjan_dfs(v: text, graph: Dict<text, [text]>,
              index_counter: i64, stack: [text],
              on_stack: Dict<text, bool>,
              indices: Dict<text, i64>, lowlinks: Dict<text, i64>,
              result: [[text]]):
    indices[v] = index_counter
    lowlinks[v] = index_counter
    index_counter = index_counter + 1
    stack_push(stack, v)
    on_stack[v] = true

    val successors = graph_get(graph, v) ?? []
    for w in successors:
        if not indices_contains(indices, w):
            tarjan_dfs(w, graph, index_counter, stack, on_stack,
                       indices, lowlinks, result)
            val w_low = lowlinks[w]
            if w_low < lowlinks[v]:
                lowlinks[v] = w_low
        elif on_stack_get(on_stack, w) ?? false:
            val w_idx = indices[w]
            if w_idx < lowlinks[v]:
                lowlinks[v] = w_idx

    if lowlinks[v] == indices[v]:
        var scc: [text] = []
        while true:
            val w = stack_pop(stack)
            on_stack[w] = false
            scc = scc_push(scc, w)
            if w == v:
                break
        result = result_push(result, scc)

# ============================================================================
# Validation
# ============================================================================

fn validate_sync_constraint(func: FunctionInfo) -> text:
    """Validate that a sync function doesn't contain suspension operators."""
    if func.is_sync:
        if func.contains_suspension:
        return Err("Sync function '{func.name}' cannot contain suspension operators (~=, await, etc.)")
    Ok(())

fn validate_suspension_context(func: FunctionInfo, env: Dict<text, Effect>) -> text:
    """Validate that suspension operators are only used in async contexts."""
    val effect = infer_function_effect(func, env)
    if effect_is_sync(effect):
        if func.contains_suspension:
        return Err("Sync function '{func.name}' cannot use suspension operators (~=, if~, while~, for~)")
    Ok(())

# ============================================================================
# Promise Type Operations
# ============================================================================

fn needs_promise_wrapping(func: FunctionInfo, env: Dict<text, Effect>) -> bool:
    """Check if function's return type needs Promise wrapping."""
    infer_function_effect(func, env).is_async()

fn get_return_wrap_mode(func: FunctionInfo, env: Dict<text, Effect>) -> ReturnWrapMode:
    """Determine how a return statement should be wrapped."""
    if needs_promise_wrapping(func, env):
        ReturnWrapMode.Resolved
    else:
        ReturnWrapMode.None

fn is_promise_type(type_name: text) -> bool:
    """Check if a type name represents a Promise type."""
    type_name.starts_with("Promise<") or type_name == "Promise"

fn wrap_in_promise(type_name: text) -> text:
    """Wrap a type in Promise<T> if not already wrapped."""
    if is_promise_type(type_name):
        type_name
    else:
        "Promise<{type_name}>"

    fn unwrap_promise(type_name: text) -> text:
        """Extract inner type from Promise<T>."""
        if type_name.starts_with("Promise<"):
            if type_name.ends_with(">"):
                type_name[8:type_name_len(type_name) - 1]
        else:
            nil

# ============================================================================
# Await Inference
# ============================================================================

fn needs_await(callee_name: text, env: Dict<text, Effect>) -> AwaitMode:
    """Check if calling a function needs automatic await insertion."""
    val effect = env_get(env, callee_name)
    if effect.?:
        if effect_value_is_async(effect_value):
        AwaitMode.Implicit
    else:
        AwaitMode.None

fn needs_await_typed(callee_name: text, env: Dict<text, Effect>, expected_type: text?) -> TypedAwaitMode:
    """Check if expression needs await based on target type."""
    val effect = env_get(env, callee_name)
    if not effect.? or effect_value_is_sync(effect_value):
        return TypedAwaitMode.None

    # Expression is async call - check expected type
    match expected_type:
        case expected:
            if is_promise_type(expected):
                TypedAwaitMode.KeepPromise
            else:
                TypedAwaitMode.ImplicitAwait
        case _:
            TypedAwaitMode.ImplicitAwait

fn infer_promise_type_info(func: FunctionInfo, env: Dict<text, Effect>) -> PromiseTypeInfo:
    """Infer Promise type information for a function."""
    val effect = infer_function_effect(func, env)
    match effect:
        case Sync: promisetypeinfo_sync_function(nil)
        case Async: promisetypeinfo_async_function(nil)

export Effect, ReturnWrapMode, AwaitMode, TypedAwaitMode
export PromiseTypeInfo, FunctionInfo
export infer_function_effect, build_effect_env, infer_mutual_effects
export propagate_effects_transitive, tarjan_scc
export validate_sync_constraint, validate_suspension_context
export needs_promise_wrapping, get_return_wrap_mode
export is_promise_type, wrap_in_promise, unwrap_promise
export needs_await, needs_await_typed, infer_promise_type_info
