# Volatile Memory Access
#
# Ensures memory reads/writes are not optimized away by the compiler.
# Essential for:
# - Memory-mapped I/O (MMIO) registers
# - Hardware status registers
# - Shared memory with DMA
# - Interrupt handlers
#
# Volatile Levels:
# 1. Field: @volatile val x: u32
# 2. Struct: @volatile struct Regs { ... }
# 3. File: module-level __volatile__ = true
# 4. Project: simple.sdn volatile = true

from hir_types import {HirType, SymbolId}
from hir_definitions import {HirExpr, HirExprKind}
from lexer import {Span}
from attributes import {FunctionAttr, VolatileAttr, VolatileMode, is_volatile}

export VolatileAccess, VolatileContext, VolatileKind
export is_volatile_access, mark_volatile, generate_volatile_read, generate_volatile_write
export volatile_for_naked_context

# Kind of volatile access
enum VolatileKind:
    Read            # Volatile read - always fetch from memory
    Write           # Volatile write - always commit to memory
    ReadWrite       # Both read and write are volatile
    None_            # Normal (non-volatile) access

impl VolatileKind:
    fn is_read_volatile() -> bool:
        match self:
            case VolatileKind.Read | VolatileKind.ReadWrite: true
            case _: false

    fn is_write_volatile() -> bool:
        match self:
            case VolatileKind.Write | VolatileKind.ReadWrite: true
            case _: false

    fn to_text() -> text:
        match self:
            case VolatileKind.Read: "read"
            case VolatileKind.Write: "write"
            case VolatileKind.ReadWrite: "read/write"
            case VolatileKind.None: "none"

# Volatile access descriptor
struct VolatileAccess:
    address: i64            # Memory address
    size: i64               # Access size in bytes
    kind: VolatileKind      # Type of volatile access
    type_: HirType          # Type being accessed
    span: Span

impl VolatileAccess:
    static fn read(addr: i64, size: i64, type_: HirType, span: Span) -> VolatileAccess:
        VolatileAccess(
            address: addr,
            size: size,
            kind: VolatileKind.Read,
            type_: type_,
            span: span
        )

    static fn write(addr: i64, size: i64, type_: HirType, span: Span) -> VolatileAccess:
        VolatileAccess(
            address: addr,
            size: size,
            kind: VolatileKind.Write,
            type_: type_,
            span: span
        )

# Volatile context tracks what's volatile in current scope
class VolatileContext:
    # Volatile variables by name
    volatile_vars: Dict<text, bool>
    # Volatile types by name
    volatile_types: Dict<text, bool>
    # File-level volatile flag
    file_volatile: bool
    # Project-level volatile flag
    project_volatile: bool

impl VolatileContext:
    static fn new() -> VolatileContext:
        VolatileContext(
            volatile_vars: {},
            volatile_types: {},
            file_volatile: false,
            project_volatile: false
        )

    # Mark a variable as volatile
    me mark_var_volatile(name: text):
        self.volatile_vars[name] = true

    # Mark a type as volatile
    me mark_type_volatile(name: text):
        self.volatile_types[name] = true

    # Check if a variable is volatile
    fn is_var_volatile(name: text) -> bool:
        if self.file_volatile or self.project_volatile:
            return true
        self.volatile_vars.contains_key(name) and self.volatile_vars[name]

    # Check if a type is volatile
    fn is_type_volatile(type_name: text) -> bool:
        if self.file_volatile or self.project_volatile:
            return true
        self.volatile_types.contains_key(type_name) and self.volatile_types[type_name]

# Check if an expression involves volatile access
fn is_volatile_access(expr: HirExpr, ctx: VolatileContext) -> bool:
    # File-level or project-level volatile makes everything volatile
    if ctx.file_volatile or ctx.project_volatile:
        return true

    match expr.kind:
        case HirExprKind.Var(sym):
            # Check if variable is in volatile context
            val name = sym.name
            val in_vars = ctx.volatile_vars.contains_key(name)
            if in_vars:
                return ctx.volatile_vars[name]
            # Check type-level volatility via context helper
            ctx.is_type_volatile(sym.type_name)
        case HirExprKind.Field(base, field, _):
            # Check if base type has volatile field or base is volatile
            is_volatile_access(base, ctx)
        case HirExprKind.Index(base, _):
            # Array access inherits volatility from base
            is_volatile_access(base, ctx)
        case _:
            false

# Mark an expression as requiring volatile access
fn mark_volatile(expr: HirExpr) -> HirExpr:
    # In practice, this would modify the expression's metadata
    # to indicate volatile access is required
    expr

# Generate volatile read operation
# Returns assembly/IR for a volatile read
fn generate_volatile_read(access: VolatileAccess) -> text:
    val size_suffix = match access.size:
        case 1: "b"  # byte
        case 2: "w"  # word
        case 4: "l"  # long/dword
        case 8: "q"  # quad
        case _: ""

    # For x86, volatile reads use regular mov but compiler
    # must not optimize them away
    match access.size:
        case 1:
            "mov{size_suffix} ({access.address:#x}), %al"
        case 2:
            "mov{size_suffix} ({access.address:#x}), %ax"
        case 4:
            "mov{size_suffix} ({access.address:#x}), %eax"
        case 8:
            "mov{size_suffix} ({access.address:#x}), %rax"
        case _:
            "# volatile read of size {access.size} not supported"

# Generate volatile write operation
fn generate_volatile_write(access: VolatileAccess, value_reg: text) -> text:
    val size_suffix = match access.size:
        case 1: "b"
        case 2: "w"
        case 4: "l"
        case 8: "q"
        case _: ""

    "mov{size_suffix} {value_reg}, ({access.address:#x})"

# Volatile memory intrinsics
# These are the primitive operations for volatile access

# Read a byte from a volatile address
fn volatile_read_u8(addr: i64) -> u8:
    var result: u8 = 0
    asm """
        movzx eax, byte ptr [{addr}]
        mov {result}, al
    """
    result

# Read a word from a volatile address
fn volatile_read_u16(addr: i64) -> u16:
    var result: u16 = 0
    asm """
        movzx eax, word ptr [{addr}]
        mov {result}, ax
    """
    result

# Read a dword from a volatile address
fn volatile_read_u32(addr: i64) -> u32:
    var result: u32 = 0
    asm """
        mov eax, dword ptr [{addr}]
        mov {result}, eax
    """
    result

# Read a qword from a volatile address
fn volatile_read_u64(addr: i64) -> u64:
    var result: u64 = 0
    asm """
        mov rax, qword ptr [{addr}]
        mov {result}, rax
    """
    result

# Write a byte to a volatile address
fn volatile_write_u8(addr: i64, value: u8):
    asm """
        mov byte ptr [{addr}], {value}
    """

# Write a word to a volatile address
fn volatile_write_u16(addr: i64, value: u16):
    asm """
        mov word ptr [{addr}], {value}
    """

# Write a dword to a volatile address
fn volatile_write_u32(addr: i64, value: u32):
    asm """
        mov dword ptr [{addr}], {value}
    """

# Write a qword to a volatile address
fn volatile_write_u64(addr: i64, value: u64):
    asm """
        mov qword ptr [{addr}], {value}
    """

# Memory barrier operations
# These ensure memory operations complete in order

# Full memory barrier (both loads and stores)
fn memory_barrier():
    asm """
        mfence
    """

# Load barrier (ensures all prior loads complete)
fn load_barrier():
    asm """
        lfence
    """

# Store barrier (ensures all prior stores complete)
fn store_barrier():
    asm """
        sfence
    """

# Compiler barrier (prevents compiler reordering, no CPU fence)
fn compiler_barrier():
    asm """
        # compiler barrier - no CPU instructions needed
        # just prevents optimization across this point
    """

# Volatile access kind for fields in attribute-marked functions
fn volatile_for_naked_context(vol_attr: VolatileAttr, func_attr: FunctionAttr) -> VolatileKind:
    """Determine volatile access kind for fields in attribute-marked functions.
    In naked functions, all volatile accesses are ReadWrite (no register save/restore)."""
    if func_attr.is_naked and is_volatile(vol_attr):
        VolatileKind.ReadWrite
    elif is_volatile(vol_attr):
        match vol_attr.mode:
            case VolatileMode.Full: VolatileKind.ReadWrite
            case VolatileMode.ReadOnly: VolatileKind.Read
            case VolatileMode.WriteOnly: VolatileKind.Write
            case _: VolatileKind.None_
    else:
        VolatileKind.None_
