# Lifetime Representation and Inference
#
# Implements lifetime tracking for borrow checking:
# - Lifetime variables and regions
# - Lifetime constraints (outlives relationships)
# - Lifetime inference algorithm
#
# Based on Rust's lifetime system and NLL (Non-Lexical Lifetimes).
#
# Key concepts:
# - Region: A span of code where a reference is valid
# - Lifetime: Named region ('a, 'b, 'static)
# - Outlives: 'a: 'b means 'a lives at least as long as 'b

# ============================================================================
# Lifetime - Manual Desugaring
# ============================================================================

# Manual desugaring of static methods for bootstrap runtime compatibility
fn Region__create(id: i64, lifetime: Lifetime) -> Region:
    Region(
        id: id,
        lifetime: lifetime,
        start_point: 0,
        end_point: 0,
        is_universal: false
    )

fn Region__universal(id: i64, lifetime: Lifetime) -> Region:
    Region(
        id: id,
        lifetime: lifetime,
        start_point: 0,
        end_point: i64.max(),
        is_universal: true
    )

fn LifetimeConstraint__outlives(longer: Lifetime, shorter: Lifetime, reason: text) -> LifetimeConstraint:
    LifetimeConstraint(
        kind: ConstraintKind.Outlives,
        lhs: longer,
        rhs: shorter,
        span: nil,
        reason: reason
    )

fn LifetimeConstraint__equals(a: Lifetime, b: Lifetime, reason: text) -> LifetimeConstraint:
    LifetimeConstraint(
        kind: ConstraintKind.Equals,
        lhs: a,
        rhs: b,
        span: nil,
        reason: reason
    )

fn LifetimeConstraint__is_static(lt: Lifetime, reason: text) -> LifetimeConstraint:
    LifetimeConstraint(
        kind: ConstraintKind.IsStatic,
        lhs: lt,
        rhs: Lifetime.Static,
        span: nil,
        reason: reason
    )

fn LifetimeEnv__create() -> LifetimeEnv:
    LifetimeEnv(
        lifetimes: {},
        regions: {},
        constraints: [],
        next_anon_id: 0,
        next_region_id: 0
    )

# ============================================================================
# Lifetime Representation
# ============================================================================

enum Lifetime:
    """A lifetime/region in the borrow checker.

    Lifetimes represent spans of code where references are valid.
    """
    # Named lifetime parameter ('a, 'b)
    Named(name: text)

    # Anonymous lifetime (inferred)
    Anonymous(id: i64)

    # Static lifetime ('static) - lives for entire program
    Static

    # Erased lifetime (for type erasure)
    Erased

impl Lifetime:
    fn to_text() -> text:
        match self:
            case Named(name): "'{name}"
            case Anonymous(id): "'_{id}"
            case Static: "'static"
            case Erased: "'_"

    fn is_static() -> bool:
        match self:
            case Static: true
            case _: false

    fn equals(other: Lifetime) -> bool:
        match (self, other):
            case (Named(a), Named(b)): a == b
            case (Anonymous(a), Anonymous(b)): a == b
            case (Static, Static): true
            case (Erased, Erased): true
            case _: false

# ============================================================================
# Region
# ============================================================================

struct Region:
    """A region of code where a borrow is active.

    Regions are represented as sets of program points (locations).
    """
    id: i64
    lifetime: Lifetime
    start_point: i64    # First program point
    end_point: i64      # Last program point (inclusive)
    is_universal: bool  # True for function parameters

impl Region:
    static fn create(id: i64, lifetime: Lifetime) -> Region:
        Region(
            id: id,
            lifetime: lifetime,
            start_point: 0,
            end_point: 0,
            is_universal: false
        )

    static fn universal(id: i64, lifetime: Lifetime) -> Region:
        """Create a universal region (function parameter lifetime)."""
        Region(
            id: id,
            lifetime: lifetime,
            start_point: 0,
            end_point: i64.max(),
            is_universal: true
        )

    fn contains_point(point: i64) -> bool:
        """Check if region contains a program point."""
        point >= self.start_point and point <= self.end_point

    fn overlaps(other: Region) -> bool:
        """Check if regions overlap."""
        not (self.end_point < other.start_point or other.end_point < self.start_point)

    me extend_to(point: i64):
        """Extend region to include a program point."""
        if point < self.start_point:
            self.start_point = point
        if point > self.end_point:
            self.end_point = point

# ============================================================================
# Lifetime Constraint
# ============================================================================

enum ConstraintKind:
    """Kind of lifetime constraint."""
    # 'a: 'b - 'a outlives 'b
    Outlives

    # 'a = 'b - 'a equals 'b (same region)
    Equals

    # 'a: 'static - 'a is static
    IsStatic

struct LifetimeConstraint:
    """Constraint between lifetimes.

    Constraints are generated during type checking and solved
    to determine if borrows are valid.
    """
    kind: ConstraintKind
    lhs: Lifetime           # Left-hand side
    rhs: Lifetime           # Right-hand side
    span: i64?              # Source location for error messages
    reason: text            # Why this constraint exists

impl LifetimeConstraint:
    static fn outlives(longer: Lifetime, shorter: Lifetime, reason: text) -> LifetimeConstraint:
        """Create 'longer: 'shorter constraint."""
        LifetimeConstraint(
            kind: ConstraintKind.Outlives,
            lhs: longer,
            rhs: shorter,
            span: nil,
            reason: reason
        )

    static fn equals(a: Lifetime, b: Lifetime, reason: text) -> LifetimeConstraint:
        """Create 'a = 'b constraint."""
        LifetimeConstraint(
            kind: ConstraintKind.Equals,
            lhs: a,
            rhs: b,
            span: nil,
            reason: reason
        )

    static fn is_static(lt: Lifetime, reason: text) -> LifetimeConstraint:
        """Create 'lt: 'static constraint."""
        LifetimeConstraint(
            kind: ConstraintKind.IsStatic,
            lhs: lt,
            rhs: Lifetime.Static,
            span: nil,
            reason: reason
        )

    fn to_text() -> text:
        match self.kind:
            case Outlives: "{self.lhs.to_text()}: {self.rhs.to_text()}"
            case Equals: "{self.lhs.to_text()} = {self.rhs.to_text()}"
            case IsStatic: "{self.lhs.to_text()}: 'static"

# ============================================================================
# Lifetime Environment
# ============================================================================

class LifetimeEnv:
    """Environment for tracking lifetimes during inference.

    Stores lifetime variables and their relationships.
    """
    lifetimes: Dict<text, Lifetime>
    regions: Dict<i64, Region>
    constraints: [LifetimeConstraint]
    next_anon_id: i64
    next_region_id: i64

    static fn create() -> LifetimeEnv:
        LifetimeEnv(
            lifetimes: {},
            regions: {},
            constraints: [],
            next_anon_id: 0,
            next_region_id: 0
        )

    me fresh_lifetime() -> Lifetime:
        """Create a fresh anonymous lifetime."""
        val id = self.next_anon_id
        self.next_anon_id = self.next_anon_id + 1
        Lifetime.Anonymous(id)

    me fresh_region(lifetime: Lifetime) -> Region:
        """Create a fresh region for a lifetime."""
        val id = self.next_region_id
        self.next_region_id = self.next_region_id + 1

        val region = Region.create(id, lifetime)
        self.regions[id] = region
        region

    me bind(name: text, lifetime: Lifetime):
        """Bind a named lifetime."""
        self.lifetimes[name] = lifetime

    fn lookup(name: text) -> Lifetime?:
        """Look up a named lifetime."""
        self.lifetimes.get(name)

    me add_constraint(constraint: LifetimeConstraint):
        """Add a lifetime constraint."""
        self.constraints = self.constraints.push(constraint)

    me add_outlives(longer: Lifetime, shorter: Lifetime, reason: text):
        """Add outlives constraint."""
        self.add_constraint(LifetimeConstraint.outlives(longer, shorter, reason))

    me add_equals(a: Lifetime, b: Lifetime, reason: text):
        """Add equality constraint."""
        self.add_constraint(LifetimeConstraint.equals(a, b, reason))

# ============================================================================
# Lifetime Inference
# ============================================================================

struct InferenceError:
    """Error during lifetime inference."""
    message: text
    span: i64?
    constraint: LifetimeConstraint?

impl InferenceError:
    static fn create(message: text) -> InferenceError:
        InferenceError(message: message, span: nil, constraint: nil)

    static fn from_constraint(message: text, constraint: LifetimeConstraint) -> InferenceError:
        InferenceError(message: message, span: constraint.span, constraint: Some(constraint))

class LifetimeInference:
    """Lifetime inference engine.

    Solves lifetime constraints to determine region assignments.
    Uses fixed-point iteration over constraint graph.
    """
    env: LifetimeEnv
    region_vars: Dict<i64, [i64]>  # Region ID -> set of points
    errors: [InferenceError]

    static fn create() -> LifetimeInference:
        LifetimeInference(
            env: LifetimeEnv.create(),
            region_vars: {},
            errors: []
        )

    me infer() -> bool:
        """Run lifetime inference.

        Returns true if inference succeeds (all constraints satisfied).
        """
        # Initialize region variables
        for id in self.env.regions.keys():
            val region = self.env.regions[id]
            var points: [i64] = []
            if region.start_point <= region.end_point:
                var p = region.start_point
                while p <= region.end_point:
                    points = points.push(p)
                    p = p + 1
            self.region_vars[id] = points

        # Fixed-point iteration
        var changed = true
        var iterations = 0
        val max_iterations = 100

        while changed and iterations < max_iterations:
            changed = false
            iterations = iterations + 1

            for constraint in self.env.constraints:
                if self.propagate_constraint(constraint):
                    changed = true

        # Check for errors
        self.check_constraints()

        self.errors.is_empty()

    me propagate_constraint(constraint: LifetimeConstraint) -> bool:
        """Propagate a single constraint.

        Returns true if any region was extended.
        """
        match constraint.kind:
            case Outlives:
                # 'a: 'b means region of 'a must include region of 'b
                val lhs_region = self.get_region_for_lifetime(constraint.lhs)
                val rhs_region = self.get_region_for_lifetime(constraint.rhs)

                if lhs_region.? and rhs_region.?:
                    self.extend_region(lhs_region.unwrap(), rhs_region.unwrap())
                else:
                    false

            case Equals:
                # 'a = 'b means regions must be equal
                val lhs_region = self.get_region_for_lifetime(constraint.lhs)
                val rhs_region = self.get_region_for_lifetime(constraint.rhs)

                if lhs_region.? and rhs_region.?:
                    val changed1 = self.extend_region(lhs_region.unwrap(), rhs_region.unwrap())
                    val changed2 = self.extend_region(rhs_region.unwrap(), lhs_region.unwrap())
                    changed1 or changed2
                else:
                    false

            case IsStatic:
                # 'a: 'static means 'a must cover all points
                val lhs_region = self.get_region_for_lifetime(constraint.lhs)
                if lhs_region.?:
                    val region_id = lhs_region.unwrap()
                    # Extend to all possible points (simplified)
                    var points = self.region_vars.get(region_id) ?? []
                    val had = points.len()
                    # Static regions cover everything
                    self.region_vars[region_id] = [0, i64.max()]
                    had != 2
                else:
                    false

    fn get_region_for_lifetime(lt: Lifetime) -> i64?:
        """Get the region ID for a lifetime."""
        for id in self.env.regions.keys():
            val region = self.env.regions[id]
            if region.lifetime.equals(lt):
                return Some(id)
        nil

    me extend_region(target_id: i64, source_id: i64) -> bool:
        """Extend target region to include all points from source."""
        val source_points = self.region_vars.get(source_id) ?? []
        var target_points = self.region_vars.get(target_id) ?? []

        val original_len = target_points.len()

        for point in source_points:
            if not target_points.contains(point):
                target_points = target_points.push(point)

        self.region_vars[target_id] = target_points
        target_points.len() > original_len

    me check_constraints():
        """Check all constraints are satisfied."""
        for constraint in self.env.constraints:
            match constraint.kind:
                case Outlives:
                    if not self.check_outlives(constraint):
                        self.errors = self.errors.push(InferenceError.from_constraint(
                            "Lifetime {constraint.lhs.to_text()} does not outlive {constraint.rhs.to_text()}",
                            constraint
                        ))

                case Equals:
                    if not self.check_equals(constraint):
                        self.errors = self.errors.push(InferenceError.from_constraint(
                            "Lifetimes {constraint.lhs.to_text()} and {constraint.rhs.to_text()} are not equal",
                            constraint
                        ))

                case IsStatic:
                    if not self.check_static(constraint):
                        self.errors = self.errors.push(InferenceError.from_constraint(
                            "Lifetime {constraint.lhs.to_text()} is not 'static",
                            constraint
                        ))

    fn check_outlives(constraint: LifetimeConstraint) -> bool:
        """Check if outlives constraint is satisfied."""
        val lhs_region = self.get_region_for_lifetime(constraint.lhs)
        val rhs_region = self.get_region_for_lifetime(constraint.rhs)

        if lhs_region.? and rhs_region.?:
            val lhs_points = self.region_vars.get(lhs_region.unwrap()) ?? []
            val rhs_points = self.region_vars.get(rhs_region.unwrap()) ?? []

            # All rhs points must be in lhs
            for point in rhs_points:
                if not lhs_points.contains(point):
                    return false
            true
        else:
            true  # Missing regions = no constraint

    fn check_equals(constraint: LifetimeConstraint) -> bool:
        """Check if equals constraint is satisfied."""
        val lhs_region = self.get_region_for_lifetime(constraint.lhs)
        val rhs_region = self.get_region_for_lifetime(constraint.rhs)

        if lhs_region.? and rhs_region.?:
            val lhs_points = self.region_vars.get(lhs_region.unwrap()) ?? []
            val rhs_points = self.region_vars.get(rhs_region.unwrap()) ?? []

            lhs_points.len() == rhs_points.len()
        else:
            true

    fn check_static(constraint: LifetimeConstraint) -> bool:
        """Check if static constraint is satisfied."""
        val lhs_region = self.get_region_for_lifetime(constraint.lhs)
        if lhs_region.?:
            val points = self.region_vars.get(lhs_region.unwrap()) ?? []
            # Static means covers everything (simplified check)
            points.len() >= 2  # Has start and end
        else:
            true

    fn get_errors() -> [InferenceError]:
        """Get inference errors."""
        self.errors

# ============================================================================
# Exports
# ============================================================================

export Lifetime, Region
export ConstraintKind, LifetimeConstraint
export LifetimeEnv
export InferenceError, LifetimeInference

# Export desugared static methods
export Region__create
export Region__universal
export LifetimeConstraint__outlives
export LifetimeConstraint__equals
export LifetimeConstraint__is_static
export LifetimeEnv__create
