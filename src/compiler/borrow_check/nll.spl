# Non-Lexical Lifetimes (NLL)
#
# Implements Non-Lexical Lifetimes for precise borrow checking.
# NLL allows borrows to end before the lexical scope ends,
# based on actual usage patterns.
#
# Based on Rust RFC 2094 (NLL) and Polonius.
#
# Key concepts:
# - Liveness: A variable is live if it may be used later
# - Region inference: Compute minimal regions for borrows
# - Error reporting: Generate helpful borrow errors

use compiler.borrow_check.lifetime.*
use compiler.borrow_check.borrow_graph.*

# ============================================================================
# Control Flow Graph
# ============================================================================

struct BasicBlock:
    """A basic block in the CFG."""
    id: i64
    statements: [i64]      # Statement indices
    terminator: Terminator
    predecessors: [i64]    # Block IDs
    successors: [i64]      # Block IDs

enum Terminator:
    """Block terminator."""
    Return
    Goto(target: i64)
    SwitchInt(targets: [i64], otherwise: i64)
    Call(target: i64?, unwind: i64?)
    Drop(target: i64, unwind: i64?)
    Unreachable

impl BasicBlock:
    static fn create(id: i64) -> BasicBlock:
        BasicBlock(
            id: id,
            statements: [],
            terminator: Terminator.Unreachable,
            predecessors: [],
            successors: []
        )

    me add_statement(stmt_id: i64):
        """Add statement to block."""
        self.statements = self.statements.push(stmt_id)

    me set_terminator(term: Terminator):
        """Set block terminator."""
        self.terminator = term

        # Update successors based on terminator
        self.successors = match term:
            case Return: []
            case Goto(target): [target]
            case SwitchInt(targets, otherwise):
                var succs = targets
                succs = succs.push(otherwise)
                succs
            case Call(target, unwind):
                var succs: [i64] = []
                if target.?: succs = succs.push(target.unwrap())
                if unwind.?: succs = succs.push(unwind.unwrap())
                succs
            case Drop(target, unwind):
                var succs = [target]
                if unwind.?: succs = succs.push(unwind.unwrap())
                succs
            case Unreachable: []

class ControlFlowGraph:
    """Control flow graph for a function."""
    blocks: Dict<i64, BasicBlock>
    entry: i64
    exit_blocks: [i64]

    static fn create() -> ControlFlowGraph:
        ControlFlowGraph(
            blocks: {},
            entry: 0,
            exit_blocks: []
        )

    me add_block(block: BasicBlock):
        """Add a block to the CFG."""
        self.blocks[block.id] = block

    me set_entry(block_id: i64):
        """Set the entry block."""
        self.entry = block_id

    me add_exit(block_id: i64):
        """Add an exit block."""
        self.exit_blocks = self.exit_blocks.push(block_id)

    me compute_predecessors():
        """Compute predecessor edges from successor edges."""
        for id in self.blocks.keys():
            val block = self.blocks[id]
            for succ_id in block.successors:
                match self.blocks.get(succ_id):
                    case Some(succ_block):
                        succ_block.predecessors = succ_block.predecessors.push(id)
                        self.blocks[succ_id] = succ_block
                    case None:
                        pass

    fn get_block(id: i64) -> BasicBlock?:
        """Get a block by ID."""
        self.blocks.get(id)

    fn reverse_postorder() -> [i64]:
        """Get blocks in reverse postorder (for dataflow)."""
        var visited: [i64] = []
        var order: [i64] = []

        self.dfs_postorder(self.entry, visited, order)

        # Reverse the order
        var result: [i64] = []
        var i = order.len() - 1
        while i >= 0:
            result = result.push(order[i])
            i = i - 1
        result

    me dfs_postorder(block_id: i64, visited: [i64], order: [i64]):
        """DFS for postorder traversal."""
        if visited.contains(block_id):
            return

        visited = visited.push(block_id)

        match self.blocks.get(block_id):
            case Some(block):
                for succ_id in block.successors:
                    self.dfs_postorder(succ_id, visited, order)
            case None:
                pass

        order = order.push(block_id)

# ============================================================================
# Liveness Analysis
# ============================================================================

struct LivenessResult:
    """Result of liveness analysis."""
    # Variables live at entry of each block
    live_in: Dict<i64, [i64]>
    # Variables live at exit of each block
    live_out: Dict<i64, [i64]>

class LivenessAnalysis:
    """Computes variable liveness.

    A variable is live at a point if it may be used before being redefined.
    """
    cfg: ControlFlowGraph
    # Variables used in each block (before any def)
    uses: Dict<i64, [i64]>
    # Variables defined in each block
    defs: Dict<i64, [i64]>

    static fn create(cfg: ControlFlowGraph) -> LivenessAnalysis:
        LivenessAnalysis(
            cfg: cfg,
            uses: {},
            defs: {}
        )

    me record_use(block_id: i64, var_id: i64):
        """Record a variable use."""
        var block_uses = self.uses.get(block_id) ?? []
        if not block_uses.contains(var_id):
            block_uses = block_uses.push(var_id)
        self.uses[block_id] = block_uses

    me record_def(block_id: i64, var_id: i64):
        """Record a variable definition."""
        var block_defs = self.defs.get(block_id) ?? []
        if not block_defs.contains(var_id):
            block_defs = block_defs.push(var_id)
        self.defs[block_id] = block_defs

    fn compute() -> LivenessResult:
        """Compute liveness using fixed-point iteration.

        Backward dataflow analysis:
        live_in[B] = use[B] ∪ (live_out[B] - def[B])
        live_out[B] = ∪ live_in[S] for all successors S
        """
        var live_in: Dict<i64, [i64]> = {}
        var live_out: Dict<i64, [i64]> = {}

        # Initialize
        for id in self.cfg.blocks.keys():
            live_in[id] = []
            live_out[id] = []

        # Fixed-point iteration (backward)
        var changed = true
        var iterations = 0
        val max_iter = 100

        while changed and iterations < max_iter:
            changed = false
            iterations = iterations + 1

            for id in self.cfg.blocks.keys():
                val block = self.cfg.blocks[id]
                # Compute live_out from successors
                var new_out: [i64] = []
                for succ_id in block.successors:
                    val succ_in = live_in.get(succ_id) ?? []
                    for var_id in succ_in:
                        if not new_out.contains(var_id):
                            new_out = new_out.push(var_id)

                # Compute live_in
                val block_uses = self.uses.get(id) ?? []
                val block_defs = self.defs.get(id) ?? []

                var new_in = block_uses
                for var_id in new_out:
                    if not block_defs.contains(var_id) and not new_in.contains(var_id):
                        new_in = new_in.push(var_id)

                # Check for changes
                val old_in = live_in.get(id) ?? []
                val old_out = live_out.get(id) ?? []

                if new_in.len() != old_in.len() or new_out.len() != old_out.len():
                    changed = true

                live_in[id] = new_in
                live_out[id] = new_out

        LivenessResult(live_in: live_in, live_out: live_out)

# ============================================================================
# NLL Borrow Checker
# ============================================================================

struct NLLError:
    """NLL borrow checking error."""
    message: text
    primary_span: i64?
    secondary_spans: [(i64, text)]  # (span, label)
    help: text?

impl NLLError:
    static fn borrow_conflict(borrow1: Borrow, borrow2: Borrow) -> NLLError:
        NLLError(
            message: "cannot borrow `{borrow1.place.to_text()}` as {borrow1.kind.to_text()} because it is also borrowed as {borrow2.kind.to_text()}",
            primary_span: Some(borrow1.borrow_point),
            secondary_spans: [(borrow2.borrow_point, "first borrow here")],
            help: Some("consider restructuring to avoid overlapping borrows")
        )

    static fn use_while_borrowed(place: Place, borrow: Borrow, point: i64) -> NLLError:
        NLLError(
            message: "cannot use `{place.to_text()}` because it was mutably borrowed",
            primary_span: Some(point),
            secondary_spans: [(borrow.borrow_point, "mutable borrow occurs here")],
            help: nil
        )

    static fn move_while_borrowed(place: Place, borrow: Borrow, point: i64) -> NLLError:
        NLLError(
            message: "cannot move out of `{place.to_text()}` because it is borrowed",
            primary_span: Some(point),
            secondary_spans: [(borrow.borrow_point, "borrow of `{place.to_text()}` occurs here")],
            help: nil
        )

class NLLChecker:
    """Non-Lexical Lifetimes borrow checker.

    Performs precise borrow checking using:
    1. Region inference to compute minimal lifetimes
    2. Liveness analysis to determine when borrows end
    3. Conflict detection for overlapping borrows
    """
    cfg: ControlFlowGraph
    borrow_graph: BorrowGraph
    liveness: LivenessAnalysis
    lifetime_inference: LifetimeInference
    errors: [NLLError]

    static fn create(cfg: ControlFlowGraph) -> NLLChecker:
        NLLChecker(
            cfg: cfg,
            borrow_graph: BorrowGraph.create(),
            liveness: LivenessAnalysis.create(cfg),
            lifetime_inference: LifetimeInference.create(),
            errors: []
        )

    me check() -> bool:
        """Run the NLL borrow checker.

        Returns true if no errors.
        """
        # Step 1: Compute liveness
        val liveness_result = self.liveness.compute()

        # Step 2: Process each block
        for block_id in self.cfg.reverse_postorder():
            self.check_block(block_id, liveness_result)

        # Step 3: Run lifetime inference
        if not self.lifetime_inference.infer():
            for err in self.lifetime_inference.get_errors():
                self.errors = self.errors.push(NLLError(
                    message: err.message,
                    primary_span: err.span,
                    secondary_spans: [],
                    help: nil
                ))

        # Step 4: Check borrow graph for conflicts
        for err in self.borrow_graph.get_errors():
            self.errors = self.errors.push(NLLError(
                message: err.message,
                primary_span: Some(err.point),
                secondary_spans: [],
                help: nil
            ))

        self.errors.is_empty()

    me check_block(block_id: i64, liveness: LivenessResult):
        """Check a single basic block."""
        match self.cfg.get_block(block_id):
            case Some(block):
                # Propagate borrows from predecessors
                for pred_id in block.predecessors:
                    self.borrow_graph.propagate_borrows(pred_id, block_id)

                # Check each statement
                var point = block_id * 1000  # Simple point numbering
                for stmt_id in block.statements:
                    self.check_statement(stmt_id, point)
                    point = point + 1

                # Check terminator
                self.check_terminator(block.terminator, point, liveness)

            case None:
                pass

    me check_statement(stmt_id: i64, point: i64):
        """Check a statement for borrow violations.

        This would dispatch based on statement kind in a full implementation.
        """
        # Simplified: statements are just IDs here
        # In full implementation, would check:
        # - Borrows being created
        # - Uses of borrowed places
        # - Moves invalidating borrows
        pass

    me check_terminator(term: Terminator, point: i64, liveness: LivenessResult):
        """Check terminator for borrow violations."""
        match term:
            case Return:
                # Check no borrows escape through return
                pass
            case Call(target, unwind):
                # Check borrows during call
                pass
            case Drop(target, unwind):
                # Check drop doesn't conflict with borrows
                pass
            case _:
                pass

    me record_borrow(point: i64, place: Place, kind: BorrowKind) -> bool:
        """Record a borrow and check for conflicts."""
        match self.borrow_graph.record_borrow(point, place, kind):
            case Some(borrow):
                # Add lifetime constraint
                self.lifetime_inference.env.add_outlives(
                    borrow.lifetime,
                    Lifetime.Anonymous(point),
                    "borrow must be valid at use"
                )
                true
            case None:
                false

    me record_use(point: i64, place: Place):
        """Record use of a place."""
        self.borrow_graph.record_use(point, place)

    me record_move(point: i64, place: Place):
        """Record move of a place."""
        self.borrow_graph.record_move(point, place)

    fn get_errors() -> [NLLError]:
        """Get all NLL errors."""
        self.errors

    fn format_errors() -> [text]:
        """Format errors for display."""
        var result: [text] = []
        for err in self.errors:
            var msg = "error: {err.message}"
            if err.help.?:
                msg = "{msg}\n  help: {err.help.unwrap()}"
            result = result.push(msg)
        result

# ============================================================================
# Exports
# ============================================================================

export BasicBlock, Terminator, ControlFlowGraph
export LivenessResult, LivenessAnalysis
export NLLError, NLLChecker
