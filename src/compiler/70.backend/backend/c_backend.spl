# C Backend - MIR to C++20 Translation
#
# Translates MIR to C++20 source code that links against runtime.h.
# Implements MirTextCodegen trait for shared instruction dispatch.
# Generated code uses the spl_ runtime API for strings, arrays, dicts.
#
# Output is C++20 suitable for clang++/g++ compilation:
#   clang++ -std=c++20 -O2 generated.cpp runtime.c -o output

use compiler.mir.mir_data.*
use compiler.backend.c_type_mapper.{CTypeMapper, CTypeMapper__create, CTypeMapper__create_for_target}
use compiler.backend.c_ir_builder.{CIRBuilder, CIRBuilder__create, escape_c_string}
use compiler.backend.common.mir_text_codegen.MirTextCodegen
use compiler.core.backend_types.{CodegenTarget, CompileOptions, CompiledModule}

# ============================================================================
# MIR to C++ Translator
# ============================================================================

class MirToC:
    """Translates MIR to C++20 source code."""
    builder: CIRBuilder
    type_mapper: CTypeMapper
    local_map: Dict
    local_types: Dict
    stack_slots: Dict
    stack_slot_sizes: Dict
    string_counter: i64

    static fn create(module_name: text) -> MirToC:
        MirToC(
            builder: CIRBuilder__create(module_name),
            type_mapper: CTypeMapper__create(),
            local_map: {},
            local_types: {},
            stack_slots: {},
            stack_slot_sizes: {},
            string_counter: 0
        )

    static fn create_for_target(module_name: text, target: CodegenTarget) -> MirToC:
        MirToC(
            builder: CIRBuilder__create(module_name),
            type_mapper: CTypeMapper__create_for_target(target),
            local_map: {},
            local_types: {},
            stack_slots: {},
            stack_slot_sizes: {},
            string_counter: 0
        )

# ============================================================================
# MirTextCodegen Trait Implementation
# ============================================================================

impl MirTextCodegen for MirToC:

    # === Required: top-level translation ===

    me translate_module(module: MirModule) -> text:
        """Translate entire MIR module to C++20 source (implementation file)."""
        self.builder.emit_header_file_header()
        self.builder.emit_impl_file_header()
        self.emit_type_definitions(module)

        self.builder.emit_header_raw(r"// Forward declarations")
        self.builder.emit_raw(r"// Forward declarations")
        for name, body in module.functions:
            self.emit_forward_declaration(name, body)
        self.builder.emit_header_raw("")
        self.builder.emit_blank()

        for name, body in module.functions:
            self.translate_function(name, body)

        self.builder.build()

    me translate_function(name: text, body: MirBody):
        """Translate a MIR function to C++."""
        self.local_types = {}
        for local in body.locals:
            val c_ty = self.type_mapper.map_type(local.type_)
            self.local_types[local.id.id] = c_ty
        self.prepare_stack_slots(body)

        var params: [text] = []
        for i in 0..body.arg_count:
            val param_ty = self.get_local_type(i)
            params = params.push(param_ty + r" _l" + i)
        val params_str = if params.len() == 0: "void" else: params.join(", ")

        val ret_ty = self.type_mapper.map_return_type(body.return_ty)
        self.builder.start_function(ret_ty, name, params_str)

        for local in body.locals:
            match local.kind:
                case Arg(_): pass_dn
                case _:
                    val ty = self.type_mapper.map_type(local.type_)
                    if ty != "void":
                        self.builder.emit_local_init(ty, r"_l" + local.id.id, self.zero_value(ty))
        for local_id, slot_name in self.stack_slots:
            val slot_size = self.stack_slot_sizes[local_id]
            self.builder.emit(r"alignas(16) unsigned char " + slot_name + r"[" + slot_size + r"];")

        self.builder.emit_blank()

        for block in body.blocks:
            self.translate_block(block)

        self.builder.end_function()

    me translate_block(block: MirBlock):
        """Translate a MIR basic block to C labeled block."""
        self.builder.emit_label(r"bb" + block.id.id)
        for inst in block.instructions:
            self.translate_instruction(inst)
        self.translate_terminator(block.terminator)

    me translate_terminator(term: MirTerminator):
        match term:
            case Return(value):
                if value.?:
                    val val_str = self.translate_operand(value.unwrap())
                    self.builder.emit_return(Some(val_str))
                else:
                    self.builder.emit_return(nil)

            case Goto(target):
                self.builder.emit_goto(r"bb" + target.id)

            case If(cond, then_, else_):
                val cond_val = self.translate_operand(cond)
                self.builder.emit_if(cond_val + r" != 0", r"bb" + then_.id, r"bb" + else_.id)

            case Switch(value, targets, default):
                val discr_val = self.translate_operand(value)
                self.builder.emit_switch_start(discr_val)
                for switch_case in targets:
                    self.builder.emit_switch_case(r"" + switch_case.value, r"bb" + switch_case.target.id)
                self.builder.emit_switch_default(r"bb" + default.id)
                self.builder.emit_switch_end()

            case Unreachable:
                self.builder.emit(r"SPL_UNREACHABLE();")

            case Abort(message):
                self.builder.emit(r"spl_panic(" + "\"" + escape_c_string(message) + "\"" + r");")

            case CallTerminator(dest, func, args, normal, unwind):
                val func_val = self.translate_operand(func)
                var arg_vals: [text] = []
                for arg in args:
                    arg_vals = arg_vals.push(self.translate_operand(arg))
                val args_str = arg_vals.join(", ")
                if dest.?:
                    val dest_name = self.get_local(dest.unwrap().id)
                    self.builder.emit_assign(dest_name, func_val + r"(" + args_str + r")")
                else:
                    self.builder.emit(func_val + r"(" + args_str + r");")
                self.builder.emit_goto(r"bb" + normal.id)

    # === Required: per-category instruction methods ===

    me translate_const(dest: LocalId, value: MirConstValue, ty: MirType):
        if self.translate_composite_const(dest, value):
            pass_dn
        else:
            val dest_name = self.get_local(dest.id)
            val const_val = self.translate_const_value(value)
            self.builder.emit_assign(dest_name, const_val)

    me translate_copy_move(dest: LocalId, src: LocalId, is_move: bool):
        val dest_name = self.get_local(dest.id)
        val src_name = self.get_local(src.id)
        self.builder.emit_assign(dest_name, src_name)

    me translate_binop(dest: LocalId, op: MirBinOp, left: MirOperand, right: MirOperand):
        val dest_name = self.get_local(dest.id)
        val left_val = self.translate_operand(left)
        val right_val = self.translate_operand(right)
        val ty = self.get_local_type(dest.id)

        match op:
            case Add:
                self.builder.emit_binop(dest_name, ty, "+", left_val, right_val)
            case Sub:
                self.builder.emit_binop(dest_name, ty, "-", left_val, right_val)
            case Mul:
                self.builder.emit_binop(dest_name, ty, "*", left_val, right_val)
            case Div:
                self.builder.emit_binop(dest_name, ty, "/", left_val, right_val)
            case Rem:
                self.builder.emit_binop(dest_name, ty, "%", left_val, right_val)
            case Pow:
                self.builder.emit_comment("pow")
                self.builder.emit_assign(dest_name, r"(" + ty + r")__simple_pow(" + left_val + r", " + right_val + r")")
            case BitAnd:
                self.builder.emit_binop(dest_name, ty, "&", left_val, right_val)
            case BitOr:
                self.builder.emit_binop(dest_name, ty, "|", left_val, right_val)
            case BitXor:
                self.builder.emit_binop(dest_name, ty, "^", left_val, right_val)
            case Shl:
                self.builder.emit_binop(dest_name, ty, "<<", left_val, right_val)
            case Shr:
                self.builder.emit_binop(dest_name, ty, ">>", left_val, right_val)
            case Eq:
                self.builder.emit_cmp(dest_name, ty, "==", left_val, right_val)
            case Ne:
                self.builder.emit_cmp(dest_name, ty, "!=", left_val, right_val)
            case Lt:
                self.builder.emit_cmp(dest_name, ty, "<", left_val, right_val)
            case Le:
                self.builder.emit_cmp(dest_name, ty, "<=", left_val, right_val)
            case Gt:
                self.builder.emit_cmp(dest_name, ty, ">", left_val, right_val)
            case Ge:
                self.builder.emit_cmp(dest_name, ty, ">=", left_val, right_val)
            case MatMul:
                self.builder.emit_assign(dest_name, r"(void*)__simple_runtime_matmul((void*)" + left_val + r", (void*)" + right_val + r")")
            case BroadcastAdd:
                self.builder.emit_assign(dest_name, r"(void*)__simple_runtime_broadcast_add((void*)" + left_val + r", (void*)" + right_val + r")")
            case BroadcastSub:
                self.builder.emit_assign(dest_name, r"(void*)__simple_runtime_broadcast_sub((void*)" + left_val + r", (void*)" + right_val + r")")
            case BroadcastMul:
                self.builder.emit_assign(dest_name, r"(void*)__simple_runtime_broadcast_mul((void*)" + left_val + r", (void*)" + right_val + r")")
            case BroadcastDiv:
                self.builder.emit_assign(dest_name, r"(void*)__simple_runtime_broadcast_div((void*)" + left_val + r", (void*)" + right_val + r")")
            case BroadcastPow:
                self.builder.emit_assign(dest_name, r"(void*)__simple_runtime_broadcast_pow((void*)" + left_val + r", (void*)" + right_val + r")")
            case Offset:
                self.builder.emit_assign(dest_name, r"(int64_t)((char*)(intptr_t)" + left_val + r" + " + right_val + r")")

    me translate_unaryop(dest: LocalId, op: MirUnaryOp, operand: MirOperand):
        val dest_name = self.get_local(dest.id)
        val operand_val = self.translate_operand(operand)
        val ty = self.get_local_type(dest.id)

        match op:
            case Neg:
                self.builder.emit_unaryop(dest_name, ty, "-", operand_val)
            case Not:
                self.builder.emit_cmp(dest_name, ty, "==", operand_val, "0")
            case BitNot:
                self.builder.emit_unaryop(dest_name, ty, "~", operand_val)
            case Transpose:
                self.builder.emit_assign(dest_name, r"(void*)__simple_runtime_transpose((void*)" + operand_val + r")")

    me translate_call(dest: LocalId?, func: MirOperand, args: [MirOperand]):
        val func_val = self.translate_operand(func)
        if self.translate_container_call(func_val, dest, args):
            pass_dn
        else:
            var arg_vals: [text] = []
            for arg in args:
                arg_vals = arg_vals.push(self.translate_operand(arg))
            val args_str = arg_vals.join(", ")
            if dest.?:
                val dest_name = self.get_local(dest.unwrap().id)
                val ret_ty = self.get_local_type(dest.unwrap().id)
                self.builder.emit_assign(dest_name, func_val + r"(" + args_str + r")")
            else:
                self.builder.emit(func_val + r"(" + args_str + r");")

    # === Required: helpers ===

    me translate_operand(operand: MirOperand) -> text:
        match operand.kind:
            case Copy(local):
                self.get_local(local)
            case Move(local):
                self.get_local(local)
            case Const(value, type_):
                self.translate_const_value(value)

    me translate_const_value(value: MirConstValue) -> text:
        match value:
            case Int(val): r"" + val
            case Float(val): r"" + val
            case Bool(val): if val: "1" else: "0"
            case Str(val):
                val var_name = self.builder.add_string_literal(val)
                r"(const char*)" + var_name
            case Zero: "0"
            case Array(elements):
                if elements.len() == 0:
                    "0 /* empty array */"
                else:
                    var init_vals: [text] = []
                    for elem in elements:
                        init_vals = init_vals.push(self.const_to_i64_expr(elem))
                    r"([]() -> int64_t { static int64_t v[" + elements.len() + r"] = {" + init_vals.join(", ") + r"}; return (int64_t)(intptr_t)v; }())"
            case Tuple(elements):
                if elements.len() == 0:
                    "0 /* empty tuple */"
                else:
                    var init_vals: [text] = []
                    for elem in elements:
                        init_vals = init_vals.push(self.const_to_i64_expr(elem))
                    r"([]() -> int64_t { static int64_t v[" + elements.len() + r"] = {" + init_vals.join(", ") + r"}; return (int64_t)(intptr_t)v; }())"
            case Struct(fields):
                if fields.len() == 0:
                    "0 /* empty struct */"
                else:
                    var init_vals: [text] = []
                    for field_name, field_val in fields:
                        init_vals = init_vals.push(self.const_to_i64_expr(field_val))
                    r"([]() -> int64_t { static int64_t v[" + fields.len() + r"] = {" + init_vals.join(", ") + r"}; return (int64_t)(intptr_t)v; }())"

    fn get_local(id: i64) -> text:
        r"_l" + id

    fn get_local_type(id: i64) -> text:
        match self.local_types.get(id):
            case Some(ty): ty
            case nil: "int64_t"

    fn get_operand_type(operand: MirOperand) -> text:
        match operand.kind:
            case Copy(local): self.get_local_type(local)
            case Move(local): self.get_local_type(local)
            case Const(value, type_): self.type_mapper.map_type(type_)

    # === Overrides: memory ===

    me translate_alloc(dest: LocalId, ty: MirType):
        val size = self.type_mapper.size_of(ty)
        val slot_name = self.ensure_stack_slot(dest.id, size)
        self.emit_pointer_assign(dest.id, slot_name)

    me translate_load(dest: LocalId, ptr: MirOperand):
        val dest_name = self.get_local(dest.id)
        val ptr_val = self.translate_operand(ptr)
        val ty = self.get_local_type(dest.id)
        self.builder.emit_assign(dest_name, r"*(" + ty + r"*)" + ptr_val)

    me translate_store(ptr: MirOperand, value: MirOperand):
        val ptr_val = self.translate_operand(ptr)
        val value_val = self.translate_operand(value)
        val ty = self.get_operand_type(value)
        self.builder.emit(r"*(" + ty + r"*)" + ptr_val + r" = " + value_val + r";")

    me translate_gep(dest: LocalId, base: MirOperand, indices: [MirOperand]):
        val dest_name = self.get_local(dest.id)
        val base_val = self.translate_operand(base)
        if indices.len() == 1:
            val idx_val = self.translate_operand(indices[0])
            self.builder.emit_assign(dest_name, r"(void*)((char*)" + base_val + r" + " + idx_val + r" * 8)")
        else:
            self.builder.emit_assign(dest_name, r"(void*)" + base_val)
            self.builder.emit_comment(r"GEP with " + indices.len() + r" indices")

    # === Overrides: aggregates ===

    me translate_aggregate(dest: LocalId, kind: AggregateKind, operands: [MirOperand]):
        val num_fields = operands.len()
        val byte_size = num_fields * 8
        val slot_name = self.ensure_stack_slot(dest.id, byte_size)
        self.builder.emit_comment(r"aggregate construction (" + num_fields + r" fields, " + byte_size + r" bytes) [stack slot]")
        self.emit_pointer_assign(dest.id, slot_name)
        var field_idx = 0
        for op in operands:
            val field_val = self.translate_operand(op)
            self.builder.emit(r"((int64_t*)(void*)" + slot_name + r")[" + field_idx + r"] = (int64_t)" + field_val + r";")
            field_idx = field_idx + 1

    me translate_get_field(dest: LocalId, base: MirOperand, field: i64):
        val dest_name = self.get_local(dest.id)
        val base_val = self.translate_operand(base)
        self.builder.emit_assign(dest_name, r"((int64_t*)" + base_val + r")[" + field + r"]")

    me translate_set_field(base: MirOperand, field: i64, value: MirOperand):
        val base_val = self.translate_operand(base)
        val value_val = self.translate_operand(value)
        self.builder.emit(r"((int64_t*)" + base_val + r")[" + field + r"] = " + value_val + r";")

    # === Overrides: casts ===

    me translate_cast(dest: LocalId, operand: MirOperand, target: MirType):
        val dest_name = self.get_local(dest.id)
        val operand_val = self.translate_operand(operand)
        val target_ty = self.type_mapper.map_type(target)
        self.builder.emit_assign(dest_name, r"(" + target_ty + r")" + operand_val)

    me translate_bitcast(dest: LocalId, operand: MirOperand, target: MirType):
        val dest_name = self.get_local(dest.id)
        val operand_val = self.translate_operand(operand)
        val target_ty = self.type_mapper.map_type(target)
        self.builder.emit_assign(dest_name, r"(" + target_ty + r")" + operand_val)

    # === Overrides: indirect calls / intrinsics ===

    me translate_call_indirect(dest: LocalId?, ptr: MirOperand, args: [MirOperand], sig: MirSignature):
        val ptr_val = self.translate_operand(ptr)
        var arg_vals: [text] = []
        for arg in args:
            arg_vals = arg_vals.push(self.translate_operand(arg))
        val args_str = arg_vals.join(", ")
        val ret_ty = self.type_mapper.map_type(sig.return_type)
        if dest.?:
            val dest_name = self.get_local(dest.unwrap().id)
            self.builder.emit_assign(dest_name, r"((" + ret_ty + r"(*)(...))(" + ptr_val + r"))(" + args_str + r")")
        else:
            self.builder.emit(r"((" + ret_ty + r"(*)(...))(" + ptr_val + r"))(" + args_str + r");")

    me translate_intrinsic(dest: LocalId?, name: text, args: [MirOperand]):
        var arg_vals: [text] = []
        for arg in args:
            arg_vals = arg_vals.push(self.translate_operand(arg))
        val args_str = arg_vals.join(", ")
        if dest.?:
            val dest_name = self.get_local(dest.unwrap().id)
            val ret_ty = self.get_local_type(dest.unwrap().id)
            self.builder.emit_assign(dest_name, r"__simple_intrinsic_" + name + r"(" + args_str + r")")
        else:
            self.builder.emit(r"__simple_intrinsic_" + name + r"(" + args_str + r");")

    me translate_inline_asm(asm_template: text, is_volatile: bool, inputs: [MirAsmOperand], outputs: [MirAsmOperand], clobbers: [text]):
        val volatile_str = if is_volatile: "volatile" else: ""
        self.builder.emit(r"#if !(defined(_MSC_VER) && !defined(__clang__))")
        self.builder.emit(r"asm " + volatile_str + r" (" + "\"" + asm_template + "\"" + r");")
        self.builder.emit(r"#endif")

    # === Overrides: pipeline operators ===

    me translate_pipe_forward(dest: LocalId, value: MirOperand, func: MirOperand):
        val dest_name = self.get_local(dest.id)
        val value_val = self.translate_operand(value)
        val func_val = self.translate_operand(func)
        val ret_ty = self.get_local_type(dest.id)
        self.builder.emit_assign(dest_name, r"((" + ret_ty + r"(*)(int64_t))(" + func_val + r"))(" + value_val + r")")

    me translate_compose(dest: LocalId, f: MirOperand, g: MirOperand, forward: bool):
        val dest_name = self.get_local(dest.id)
        val f_val = self.translate_operand(f)
        val g_val = self.translate_operand(g)
        self.builder.emit_assign(dest_name, "(void*)0")
        self.builder.emit_comment("compose (runtime support needed)")

    me translate_parallel(dest: LocalId, funcs: [MirOperand]):
        val dest_name = self.get_local(dest.id)
        self.builder.emit_assign(dest_name, "(void*)0")
        self.builder.emit_comment(r"parallel (" + funcs.len() + r" functions)")

    me translate_layer_connect(dest: LocalId, l1: MirOperand, l2: MirOperand):
        val dest_name = self.get_local(dest.id)
        val l1_val = self.translate_operand(l1)
        val l2_val = self.translate_operand(l2)
        self.builder.emit_assign(dest_name, "(void*)0")
        self.builder.emit_comment("layer connect (~>)")

    # === Overrides: borrow checking ===

    me translate_ref(dest: LocalId, kind: MirBorrowKind, place: MirPlace):
        val dest_name = self.get_local(dest.id)
        val place_val = self.get_local(place.local.id)
        self.builder.emit_assign(dest_name, place_val)

    # === Overrides: async/actor stubs ===

    me translate_create_promise(dest: LocalId, body: LocalId, result_type: MirType):
        val dest_name = self.get_local(dest.id)
        self.builder.emit_assign(dest_name, "(void*)0")
        self.builder.emit_comment("CreatePromise (async stub)")

    me translate_await(dest: LocalId, promise: MirOperand):
        val dest_name = self.get_local(dest.id)
        val promise_val = self.translate_operand(promise)
        self.builder.emit_assign(dest_name, "0")
        self.builder.emit_comment("Await (async stub)")

    me translate_yield(value: MirOperand?):
        self.builder.emit_comment("Yield (async stub)")

    me translate_spawn(dest: LocalId, handler: MirOperand, args: [MirOperand]):
        val dest_name = self.get_local(dest.id)
        self.builder.emit_assign(dest_name, "(void*)0")
        self.builder.emit_comment("Spawn (async stub)")

    me translate_send(target: MirOperand, message: MirOperand):
        self.builder.emit_comment("Send (actor stub)")

    me translate_receive(dest: LocalId, timeout: MirOperand?):
        val dest_name = self.get_local(dest.id)
        self.builder.emit_assign(dest_name, "0")
        self.builder.emit_comment("Receive (actor stub)")

    # === Overrides: GPU stubs ===

    me translate_gpu_kernel_def(name: text):
        self.builder.emit_comment(r"GpuKernelDef: " + name + r" (requires GPU backend)")

    me translate_gpu_launch(args: [text]):
        self.builder.emit_comment("GpuLaunch (requires GPU backend)")

    me translate_gpu_global_id(dest: LocalId, dim: i64):
        val dest_name = self.get_local(dest.id)
        self.builder.emit_assign(dest_name, "0")

    me translate_gpu_local_id(dest: LocalId, dim: i64):
        val dest_name = self.get_local(dest.id)
        self.builder.emit_assign(dest_name, "0")

    me translate_gpu_block_id(dest: LocalId, dim: i64):
        val dest_name = self.get_local(dest.id)
        self.builder.emit_assign(dest_name, "0")

    me translate_gpu_block_dim(dest: LocalId, dim: i64):
        val dest_name = self.get_local(dest.id)
        self.builder.emit_assign(dest_name, "0")

    me translate_gpu_grid_dim(dest: LocalId, dim: i64):
        val dest_name = self.get_local(dest.id)
        self.builder.emit_assign(dest_name, "0")

    me translate_gpu_barrier(scope: GpuBarrierScope):
        self.builder.emit_comment("GpuBarrier (requires GPU backend)")

    me translate_gpu_mem_fence(scope: GpuMemoryScope):
        self.builder.emit_comment("GpuMemFence (requires GPU backend)")

    me translate_gpu_shared_alloc(dest: LocalId, type_: MirType, size: i64):
        val slot_name = self.ensure_stack_slot(dest.id, size)
        self.emit_pointer_assign(dest.id, slot_name)

    me translate_gpu_atomic_op(dest: LocalId, op: GpuAtomicOpKind, ptr: MirOperand, value: MirOperand):
        val dest_name = self.get_local(dest.id)
        self.builder.emit_assign(dest_name, "0")
        self.builder.emit_comment("GpuAtomicOp (requires GPU backend)")

    # === Overrides: VHDL stubs ===

    me translate_vhdl_process(kind: VhdlProcessKind, body_block: BlockId):
        self.builder.emit_comment("VhdlProcess (requires VHDL backend)")

    me translate_vhdl_signal_assign(target: MirOperand, value: MirOperand, delay_ns: i64?):
        self.builder.emit_comment("VhdlSignalAssign (requires VHDL backend)")

    me translate_vhdl_var_assign(target: MirOperand, value: MirOperand):
        self.builder.emit_comment("VhdlVarAssign (requires VHDL backend)")

    me translate_vhdl_port_map(entity: text, instance: text, connections: [(text, MirOperand)]):
        self.builder.emit_comment(r"VhdlPortMap: " + entity + r"/" + instance + r" (requires VHDL backend)")

    me translate_vhdl_resize(dest: LocalId, operand: MirOperand, new_width: i64, signed: bool):
        val dest_name = self.get_local(dest.id)
        self.builder.emit_assign(dest_name, "0")

    me translate_vhdl_slice(dest: LocalId, signal: MirOperand, hi: i64, lo: i64):
        val dest_name = self.get_local(dest.id)
        self.builder.emit_assign(dest_name, "0")

    me translate_vhdl_concat(dest: LocalId, parts: [MirOperand]):
        val dest_name = self.get_local(dest.id)
        self.builder.emit_assign(dest_name, "0")

    # === Overrides: SIMD stubs ===

    me translate_simd_binop(dest: LocalId, a: MirOperand, b: MirOperand, op_name: text):
        val dest_name = self.get_local(dest.id)
        self.builder.emit_assign(dest_name, "0")
        self.builder.emit_comment(r"SIMD " + op_name + r" (scalar fallback stub)")

    me translate_simd_fma(dest: LocalId, a: MirOperand, b: MirOperand, c: MirOperand, op_name: text):
        val dest_name = self.get_local(dest.id)
        self.builder.emit_assign(dest_name, "0")
        self.builder.emit_comment(r"SIMD " + op_name + r" (stub)")

    me translate_simd_horizontal(dest: LocalId, a: MirOperand, op_name: text):
        val dest_name = self.get_local(dest.id)
        self.builder.emit_assign(dest_name, "0")
        self.builder.emit_comment(r"SIMD " + op_name + r" (stub)")

# ============================================================================
# C-Specific Helpers (not part of trait)
# ============================================================================

impl MirToC:

    me build_header() -> text:
        """Build the header file content."""
        self.builder.build_header()

    me emit_type_definitions(module: MirModule):
        """Register and emit C struct/enum definitions for all named types in the module."""
        for (key, type_def) in module.types:
            val c_name = sanitize_c_name(type_def.name)
            self.type_mapper.register_type(type_def.symbol.id, c_name)

        for (key, type_def) in module.types:
            val c_name = sanitize_c_name(type_def.name)
            match type_def.kind:
                case Struct(_):
                    self.builder.emit_header_raw("typedef struct " + c_name + "_s " + c_name + ";")
                case Enum(_):
                    self.builder.emit_header_raw("typedef struct " + c_name + "_s " + c_name + ";")
                case _: pass_dn
        self.builder.emit_header_raw("")

        for (key, type_def) in module.types:
            val c_name = sanitize_c_name(type_def.name)
            match type_def.kind:
                case Struct(fields):
                    self.builder.emit_header_raw("struct " + c_name + "_s {")
                    for field in fields:
                        val field_c_type = self.type_mapper.map_type(field.type_)
                        self.builder.emit_header_raw("    " + field_c_type + " " + field.name + ";")
                    self.builder.emit_header_raw("};")
                    self.builder.emit_header_raw("")
                case Enum(variants):
                    self.builder.emit_header_raw("struct " + c_name + "_s {")
                    self.builder.emit_header_raw("    int64_t tag;")
                    self.builder.emit_header_raw("    union {")
                    for variant in variants:
                        if variant.payload.?:
                            val payload_ty = self.type_mapper.map_type(variant.payload.unwrap())
                            self.builder.emit_header_raw("        " + payload_ty + " " + variant.name + "_payload;")
                    self.builder.emit_header_raw("    } data;")
                    self.builder.emit_header_raw("};")
                    self.builder.emit_header_raw("")
                case _: pass_dn

    me emit_forward_declaration(name: text, body: MirBody):
        """Emit forward declaration for a function to both header and impl."""
        val ret_ty = self.type_mapper.map_return_type(body.return_ty)
        var params: [text] = []
        for i in 0..body.arg_count:
            val param_ty = self.get_local_type_from_body(body, i)
            params = params.push(param_ty + r" _l" + i)
        val params_str = if params.len() == 0: "void" else: params.join(", ")
        self.builder.emit_forward_decl(ret_ty, name, params_str)
        self.builder.emit_header_raw(ret_ty + r" " + name + r"(" + params_str + r");")

    me translate_container_call(func_name: text, dest: LocalId?, args: [MirOperand]) -> bool:
        """Intercept spl_array_*/spl_dict_* runtime calls and emit C++ method calls."""
        var arg_vals: [text] = []
        for arg in args:
            arg_vals = arg_vals.push(self.translate_operand(arg))

        if func_name == "spl_array_new":
            if dest.?:
                val dest_name = self.get_local(dest.unwrap().id)
                val ty = self.get_local_type(dest.unwrap().id)
                self.builder.emit_assign(dest_name, ty + r"()")
            return true
        elif func_name == "spl_array_push":
            if arg_vals.len() >= 2:
                self.builder.emit(arg_vals[0] + r".push(" + arg_vals[1] + r");")
            return true
        elif func_name == "spl_array_get":
            if dest.? and arg_vals.len() >= 2:
                val dest_name = self.get_local(dest.unwrap().id)
                self.builder.emit_assign(dest_name, arg_vals[0] + r".get(" + arg_vals[1] + r")")
            return true
        elif func_name == "spl_array_len":
            if dest.? and arg_vals.len() >= 1:
                val dest_name = self.get_local(dest.unwrap().id)
                self.builder.emit_assign(dest_name, arg_vals[0] + r".len()")
            return true
        elif func_name == "spl_array_pop":
            if dest.? and arg_vals.len() >= 1:
                val dest_name = self.get_local(dest.unwrap().id)
                self.builder.emit_assign(dest_name, arg_vals[0] + r".pop()")
            return true
        elif func_name == "spl_array_set":
            if arg_vals.len() >= 3:
                self.builder.emit(arg_vals[0] + r".set(" + arg_vals[1] + r", " + arg_vals[2] + r");")
            return true
        elif func_name == "spl_dict_new":
            if dest.?:
                val dest_name = self.get_local(dest.unwrap().id)
                val ty = self.get_local_type(dest.unwrap().id)
                self.builder.emit_assign(dest_name, ty + r"()")
            return true
        elif func_name == "spl_dict_set":
            if arg_vals.len() >= 3:
                self.builder.emit(arg_vals[0] + r".set(" + arg_vals[1] + r", " + arg_vals[2] + r");")
            return true
        elif func_name == "spl_dict_get":
            if dest.? and arg_vals.len() >= 2:
                val dest_name = self.get_local(dest.unwrap().id)
                self.builder.emit_assign(dest_name, arg_vals[0] + r".get(" + arg_vals[1] + r")")
            return true
        elif func_name == "spl_dict_contains":
            if dest.? and arg_vals.len() >= 2:
                val dest_name = self.get_local(dest.unwrap().id)
                self.builder.emit_assign(dest_name, arg_vals[0] + r".contains(" + arg_vals[1] + r")")
            return true
        elif func_name == "spl_dict_keys":
            if dest.? and arg_vals.len() >= 1:
                val dest_name = self.get_local(dest.unwrap().id)
                self.builder.emit_assign(dest_name, arg_vals[0] + r".keys()")
            return true
        elif func_name == "spl_dict_len":
            if dest.? and arg_vals.len() >= 1:
                val dest_name = self.get_local(dest.unwrap().id)
                self.builder.emit_assign(dest_name, arg_vals[0] + r".len()")
            return true
        elif func_name == "spl_dict_remove":
            if arg_vals.len() >= 2:
                self.builder.emit(arg_vals[0] + r".remove(" + arg_vals[1] + r");")
            return true

        false

    me prepare_stack_slots(body: MirBody):
        self.stack_slots = {}
        self.stack_slot_sizes = {}
        for block in body.blocks:
            for inst in block.instructions:
                match inst.kind:
                    case Alloc(dest, type_):
                        self.ensure_stack_slot(dest.id, self.type_mapper.size_of(type_))
                    case Aggregate(dest, kind, operands):
                        self.ensure_stack_slot(dest.id, operands.len() * 8)
                    case GpuSharedAlloc(dest, type_, size):
                        self.ensure_stack_slot(dest.id, size)
                    case Const(dest, value, type_):
                        val sz = self.const_composite_size(value)
                        if sz > 0:
                            self.ensure_stack_slot(dest.id, sz)
                    case _:
                        pass_dn

    fn slot_name_for_local(local_id: i64) -> text:
        r"_slot_l" + local_id

    fn normalized_slot_size(size: i64) -> i64:
        if size <= 0: 1 else: size

    me ensure_stack_slot(local_id: i64, requested_size: i64) -> text:
        val required = self.normalized_slot_size(requested_size)
        match self.stack_slots.get(local_id):
            case Some(existing):
                val current = self.stack_slot_sizes[local_id]
                if required > current:
                    self.stack_slot_sizes[local_id] = required
                existing
            case nil:
                val slot_name = self.slot_name_for_local(local_id)
                self.stack_slots[local_id] = slot_name
                self.stack_slot_sizes[local_id] = required
                slot_name

    me emit_pointer_assign(dest_local_id: i64, ptr_expr: text):
        val dest_name = self.get_local(dest_local_id)
        val dest_ty = self.get_local_type(dest_local_id)
        if dest_ty == "void*":
            self.builder.emit_assign(dest_name, r"(void*)" + ptr_expr)
        else:
            self.builder.emit_assign(dest_name, r"(int64_t)(intptr_t)((void*)" + ptr_expr + r")")

    fn const_composite_size(value: MirConstValue) -> i64:
        match value:
            case Array(elements):
                if elements.len() == 0: 1 else: elements.len() * 8
            case Tuple(elements):
                if elements.len() == 0: 1 else: elements.len() * 8
            case Struct(fields):
                if fields.len() == 0: 1 else: fields.len() * 8
            case _:
                0

    me translate_composite_const(dest: LocalId, value: MirConstValue) -> bool:
        match value:
            case Array(elements):
                val slot_name = self.ensure_stack_slot(dest.id, self.const_composite_size(value))
                self.emit_pointer_assign(dest.id, slot_name)
                var idx = 0
                for elem in elements:
                    val elem_val = self.const_to_i64_expr(elem)
                    self.builder.emit(r"((int64_t*)(void*)" + slot_name + r")[" + idx + r"] = " + elem_val + r";")
                    idx = idx + 1
                true
            case Tuple(elements):
                val slot_name = self.ensure_stack_slot(dest.id, self.const_composite_size(value))
                self.emit_pointer_assign(dest.id, slot_name)
                var idx = 0
                for elem in elements:
                    val elem_val = self.const_to_i64_expr(elem)
                    self.builder.emit(r"((int64_t*)(void*)" + slot_name + r")[" + idx + r"] = " + elem_val + r";")
                    idx = idx + 1
                true
            case Struct(fields):
                val slot_name = self.ensure_stack_slot(dest.id, self.const_composite_size(value))
                self.emit_pointer_assign(dest.id, slot_name)
                var idx = 0
                for field_name, field_val in fields:
                    val elem_val = self.const_to_i64_expr(field_val)
                    self.builder.emit(r"((int64_t*)(void*)" + slot_name + r")[" + idx + r"] = " + elem_val + r";")
                    idx = idx + 1
                true
            case _:
                false

    me const_to_i64_expr(value: MirConstValue) -> text:
        match value:
            case Int(val):
                r"" + val
            case Float(val):
                r"(int64_t)(" + val + r")"
            case Bool(val):
                if val: "1" else: "0"
            case Str(_):
                val str_expr = self.translate_const_value(value)
                r"(int64_t)(intptr_t)(" + str_expr + r")"
            case Zero:
                "0"
            case _:
                val nested = self.translate_const_value(value)
                r"(int64_t)(intptr_t)(" + nested + r")"

    fn get_local_type_from_body(body: MirBody, id: i64) -> text:
        if id < body.locals.len():
            self.type_mapper.map_type(body.locals[id].type_)
        else:
            "int64_t"

    fn zero_value(ty: text) -> text:
        if ty == "void*":
            "nullptr"
        elif ty == "double" or ty == "float":
            "0.0"
        elif ty == "const char*":
            "nullptr"
        else:
            "0"

# Sanitize a SPL type name containing generics to a valid C identifier.
fn sanitize_c_name(name: text) -> text:
    var s = name.split("<").join("_")
    s = s.split(">").join("")
    s = s.split(",").join("_")
    s = s.split(" ").join("")
    s = s.split("::").join("_")
    s = s.split(".").join("_")
    s = s.split("-").join("_")
    # Handle C++ reserved words by appending underscore
    if (s == "class" or s == "new" or s == "delete" or s == "template" or
        s == "namespace" or s == "default" or s == "short" or s == "long" or
        s == "operator" or s == "register" or s == "virtual" or s == "this" or
        s == "throw" or s == "catch" or s == "try" or s == "public" or
        s == "private" or s == "protected" or s == "friend" or s == "typename" or
        s == "using" or s == "auto" or s == "extern" or s == "inline" or
        s == "static" or s == "const" or s == "volatile" or s == "mutable" or
        s == "signed" or s == "unsigned" or s == "char" or s == "int" or
        s == "float" or s == "double" or s == "bool" or s == "true" or
        s == "false" or s == "nullptr" or s == "union" or s == "struct" or
        s == "enum" or s == "typedef" or s == "sizeof" or s == "alignof" or
        s == "decltype" or s == "constexpr" or s == "consteval" or
        s == "concept" or s == "requires" or s == "co_await" or
        s == "co_yield" or s == "co_return" or s == "module" or
        s == "import" or s == "export" or s == "override" or s == "final"):
        s = s + "_"
    s

# ============================================================================
# CCodegenBackend - Backend interface for BackendFactory
# ============================================================================

class CCodegenBackend:
    """Backend wrapper for C++20 code generation via MIR."""
    target: CodegenTarget
    options: CompileOptions

    static fn create(target: CodegenTarget, options: CompileOptions) -> CCodegenBackend:
        CCodegenBackend(target: target, options: options)

    fn compile(module: MirModule) -> CompiledModule:
        var translator = MirToC__create(module.name)
        val c_source = translator.translate_module(module)
        val h_source = translator.build_header()
        CompiledModule(
            name: module.name,
            object_code: nil,
            assembly: c_source,
            has_llvm_ir: true,
            llvm_ir: h_source,
            symbols: [],
            compile_time_ms: 0
        )

# ============================================================================
# Export
# ============================================================================

fn MirToC__create(module_name: text) -> MirToC:
    MirToC.create(module_name)

fn MirToC__create_for_target(module_name: text, target: CodegenTarget) -> MirToC:
    MirToC.create_for_target(module_name, target)

export MirToC, CCodegenBackend
export MirToC__create, MirToC__create_for_target
