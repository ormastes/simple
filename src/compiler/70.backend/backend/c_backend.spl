# C Backend - MIR to C++20 Translation
#
# Translates MIR to C++20 source code that links against runtime.h.
# Follows the pattern of MirToLlvm in llvm_ir_builder.spl.
# Generated code uses the spl_ runtime API for strings, arrays, dicts.
#
# Output is C++20 suitable for clang++/g++ compilation:
#   clang++ -std=c++20 -O2 generated.cpp runtime.c -o output

use compiler.mir.mir_data.*
use compiler.backend.c_type_mapper.{CTypeMapper, CTypeMapper__create, CTypeMapper__create_for_target}
use compiler.backend.c_ir_builder.{CIRBuilder, CIRBuilder__create, escape_c_string}
use compiler.core.backend_types.{CodegenTarget, CompileOptions, CompiledModule}

# ============================================================================
# MIR to C++ Translator
# ============================================================================

class MirToC:
    """Translates MIR to C++20 source code."""
    builder: CIRBuilder
    type_mapper: CTypeMapper
    local_map: Dict
    local_types: Dict
    stack_slots: Dict
    stack_slot_sizes: Dict
    string_counter: i64

    static fn create(module_name: text) -> MirToC:
        MirToC(
            builder: CIRBuilder__create(module_name),
            type_mapper: CTypeMapper__create(),
            local_map: {},
            local_types: {},
            stack_slots: {},
            stack_slot_sizes: {},
            string_counter: 0
        )

    static fn create_for_target(module_name: text, target: CodegenTarget) -> MirToC:
        MirToC(
            builder: CIRBuilder__create(module_name),
            type_mapper: CTypeMapper__create_for_target(target),
            local_map: {},
            local_types: {},
            stack_slots: {},
            stack_slot_sizes: {},
            string_counter: 0
        )

    me translate_module(module: MirModule) -> text:
        """Translate entire MIR module to C++20 source (implementation file)."""
        # Emit header preamble
        self.builder.emit_header_file_header()

        # Emit impl preamble
        self.builder.emit_impl_file_header()

        # Emit named type definitions (sanitizes generic names like Box<i64> -> Box_i64)
        self.emit_type_definitions(module)

        # Forward declarations go to BOTH header and impl
        self.builder.emit_header_raw(r"// Forward declarations")
        self.builder.emit_raw(r"// Forward declarations")
        for name, body in module.functions:
            self.emit_forward_declaration(name, body)
        self.builder.emit_header_raw("")
        self.builder.emit_blank()

        # Function definitions go to impl only
        for name, body in module.functions:
            self.translate_function(name, body)

        self.builder.build()

    me build_header() -> text:
        """Build the header file content."""
        self.builder.build_header()

    me emit_type_definitions(module: MirModule):
        """Register and emit C struct/enum definitions for all named types in the module.
        Sanitizes generic type names (e.g. Box<i64> -> Box_i64) to valid C identifiers."""
        # Pass 1: register all C names so cross-referencing field types resolve correctly
        for (key, type_def) in module.types:
            val c_name = sanitize_c_name(type_def.name)
            self.type_mapper.register_type(type_def.symbol.id, c_name)

        # Pass 2: forward declarations (typedef) to header
        for (key, type_def) in module.types:
            val c_name = sanitize_c_name(type_def.name)
            match type_def.kind:
                case Struct(_):
                    self.builder.emit_header_raw("typedef struct " + c_name + "_s " + c_name + ";")
                case Enum(_):
                    self.builder.emit_header_raw("typedef struct " + c_name + "_s " + c_name + ";")
                case _: pass_dn
        self.builder.emit_header_raw("")

        # Pass 3: full struct/enum definitions to header
        for (key, type_def) in module.types:
            val c_name = sanitize_c_name(type_def.name)
            match type_def.kind:
                case Struct(fields):
                    self.builder.emit_header_raw("struct " + c_name + "_s {")
                    for field in fields:
                        val field_c_type = self.type_mapper.map_type(field.type_)
                        self.builder.emit_header_raw("    " + field_c_type + " " + field.name + ";")
                    self.builder.emit_header_raw("};")
                    self.builder.emit_header_raw("")
                case Enum(variants):
                    self.builder.emit_header_raw("struct " + c_name + "_s {")
                    self.builder.emit_header_raw("    int64_t tag;")
                    self.builder.emit_header_raw("    union {")
                    for variant in variants:
                        if variant.payload.?:
                            val payload_ty = self.type_mapper.map_type(variant.payload.unwrap())
                            self.builder.emit_header_raw("        " + payload_ty + " " + variant.name + "_payload;")
                    self.builder.emit_header_raw("    } data;")
                    self.builder.emit_header_raw("};")
                    self.builder.emit_header_raw("")
                case _: pass_dn

    me emit_forward_declaration(name: text, body: MirBody):
        """Emit forward declaration for a function to both header and impl."""
        val ret_ty = self.type_mapper.map_return_type(body.return_ty)
        var params: [text] = []
        for i in 0..body.arg_count:
            val param_ty = self.get_local_type_from_body(body, i)
            params = params.push(param_ty + r" _l" + i)
        val params_str = if params.len() == 0: "void" else: params.join(", ")
        self.builder.emit_forward_decl(ret_ty, name, params_str)
        self.builder.emit_header_raw(ret_ty + r" " + name + r"(" + params_str + r");")

    me translate_function(name: text, body: MirBody):
        """Translate a MIR function to C++."""
        # Build local type map
        self.local_types = {}
        for local in body.locals:
            val c_ty = self.type_mapper.map_type(local.type_)
            self.local_types[local.id.id] = c_ty
        # Precompute stack-backed storage for MIR ops that should not heap-allocate.
        self.prepare_stack_slots(body)

        # Build parameter list
        var params: [text] = []
        for i in 0..body.arg_count:
            val param_ty = self.get_local_type(i)
            params = params.push(param_ty + r" _l" + i)
        val params_str = if params.len() == 0: "void" else: params.join(", ")

        val ret_ty = self.type_mapper.map_return_type(body.return_ty)
        self.builder.start_function(ret_ty, name, params_str)

        # Declare all non-argument locals at function top
        for local in body.locals:
            match local.kind:
                case Arg(_): pass_dn
                case _:
                    val ty = self.type_mapper.map_type(local.type_)
                    if ty != "void":
                        self.builder.emit_local_init(ty, r"_l" + local.id.id, self.zero_value(ty))
        # Reusable function-local storage slots avoid spl_malloc leaks in generated code.
        for local_id, slot_name in self.stack_slots:
            val slot_size = self.stack_slot_sizes[local_id]
            self.builder.emit(r"alignas(16) unsigned char " + slot_name + r"[" + slot_size + r"];")

        self.builder.emit_blank()

        # Translate basic blocks
        for block in body.blocks:
            self.translate_block(block)

        self.builder.end_function()

    me translate_block(block: MirBlock):
        """Translate a MIR basic block to C labeled block."""
        self.builder.emit_label(r"bb" + block.id.id)

        for inst in block.instructions:
            self.translate_instruction(inst)

        self.translate_terminator(block.terminator)

    me translate_instruction(inst: MirInst):
        """Translate a MIR instruction to C++."""
        match inst.kind:
            # === Constants ===
            case Const(dest, value, type_):
                if self.translate_composite_const(dest, value):
                    pass_dn
                else:
                    val dest_name = self.get_local(dest.id)
                    val const_val = self.translate_const_value(value)
                    self.builder.emit_assign(dest_name, const_val)

            # === Copy/Move ===
            case Copy(dest, src):
                val dest_name = self.get_local(dest.id)
                val src_name = self.get_local(src.id)
                self.builder.emit_assign(dest_name, src_name)

            case Move(dest, src):
                val dest_name = self.get_local(dest.id)
                val src_name = self.get_local(src.id)
                self.builder.emit_assign(dest_name, src_name)

            # === Binary Operations ===
            case BinOp(dest, op, left, right):
                self.translate_binop(dest, op, left, right)

            # === Unary Operations ===
            case UnaryOp(dest, op, operand):
                self.translate_unaryop(dest, op, operand)

            # === Memory Operations ===
            case Alloc(dest, type_):
                val size = self.type_mapper.size_of(type_)
                val slot_name = self.ensure_stack_slot(dest.id, size)
                self.emit_pointer_assign(dest.id, slot_name)

            case Load(dest, ptr):
                val dest_name = self.get_local(dest.id)
                val ptr_val = self.translate_operand(ptr)
                val ty = self.get_local_type(dest.id)
                self.builder.emit_assign(dest_name, r"*(" + ty + r"*)" + ptr_val)

            case Store(ptr, value):
                val ptr_val = self.translate_operand(ptr)
                val value_val = self.translate_operand(value)
                val ty = self.get_operand_type(value)
                self.builder.emit(r"*(" + ty + r"*)" + ptr_val + r" = " + value_val + r";")

            case GetElementPtr(dest, base, indices):
                val dest_name = self.get_local(dest.id)
                val base_val = self.translate_operand(base)
                # Simple single-index GEP -> pointer arithmetic
                if indices.len() == 1:
                    val idx_val = self.translate_operand(indices[0])
                    self.builder.emit_assign(dest_name, r"(void*)((char*)" + base_val + r" + " + idx_val + r" * 8)")
                else:
                    self.builder.emit_assign(dest_name, r"(void*)" + base_val)
                    self.builder.emit_comment(r"GEP with " + indices.len() + r" indices")

            # === Function Calls ===
            case Call(dest, func, args):
                val func_val = self.translate_operand(func)
                # Try container call interception first
                if self.translate_container_call(func_val, dest, args):
                    pass_dn
                else:
                    var arg_vals: [text] = []
                    for arg in args:
                        arg_vals = arg_vals.push(self.translate_operand(arg))
                    val args_str = arg_vals.join(", ")
                    if dest.?:
                        val dest_name = self.get_local(dest.unwrap().id)
                        val ret_ty = self.get_local_type(dest.unwrap().id)
                        self.builder.emit_assign(dest_name, func_val + r"(" + args_str + r")")
                    else:
                        self.builder.emit(func_val + r"(" + args_str + r");")

            case CallIndirect(dest, ptr, args, sig):
                val ptr_val = self.translate_operand(ptr)
                var arg_vals: [text] = []
                for arg in args:
                    arg_vals = arg_vals.push(self.translate_operand(arg))
                val args_str = arg_vals.join(", ")
                val ret_ty = self.type_mapper.map_type(sig.return_type)
                if dest.?:
                    val dest_name = self.get_local(dest.unwrap().id)
                    self.builder.emit_assign(dest_name, r"((" + ret_ty + r"(*)(...))(" + ptr_val + r"))(" + args_str + r")")
                else:
                    self.builder.emit(r"((" + ret_ty + r"(*)(...))(" + ptr_val + r"))(" + args_str + r");")

            # === Casts ===
            case Cast(dest, operand, target):
                val dest_name = self.get_local(dest.id)
                val operand_val = self.translate_operand(operand)
                val target_ty = self.type_mapper.map_type(target)
                self.builder.emit_assign(dest_name, r"(" + target_ty + r")" + operand_val)

            case Bitcast(dest, operand, target):
                val dest_name = self.get_local(dest.id)
                val operand_val = self.translate_operand(operand)
                val target_ty = self.type_mapper.map_type(target)
                self.builder.emit_assign(dest_name, r"(" + target_ty + r")" + operand_val)

            # === Aggregates ===
            case Aggregate(dest, kind, operands):
                val num_fields = operands.len()
                val byte_size = num_fields * 8
                val slot_name = self.ensure_stack_slot(dest.id, byte_size)
                self.builder.emit_comment(r"aggregate construction (" + num_fields + r" fields, " + byte_size + r" bytes) [stack slot]")
                self.emit_pointer_assign(dest.id, slot_name)
                var field_idx = 0
                for op in operands:
                    val field_val = self.translate_operand(op)
                    self.builder.emit(r"((int64_t*)(void*)" + slot_name + r")[" + field_idx + r"] = (int64_t)" + field_val + r";")
                    field_idx = field_idx + 1

            case GetField(dest, base, field):
                val dest_name = self.get_local(dest.id)
                val base_val = self.translate_operand(base)
                self.builder.emit_assign(dest_name, r"((int64_t*)" + base_val + r")[" + field + r"]")

            case SetField(base, field, value):
                val base_val = self.translate_operand(base)
                val value_val = self.translate_operand(value)
                self.builder.emit(r"((int64_t*)" + base_val + r")[" + field + r"] = " + value_val + r";")

            # === Intrinsics ===
            case Intrinsic(dest, name, args):
                var arg_vals: [text] = []
                for arg in args:
                    arg_vals = arg_vals.push(self.translate_operand(arg))
                val args_str = arg_vals.join(", ")
                if dest.?:
                    val dest_name = self.get_local(dest.unwrap().id)
                    val ret_ty = self.get_local_type(dest.unwrap().id)
                    self.builder.emit_assign(dest_name, r"__simple_intrinsic_" + name + r"(" + args_str + r")")
                else:
                    self.builder.emit(r"__simple_intrinsic_" + name + r"(" + args_str + r");")

            case CheckedBinOp(dest, op, left, right):
                self.translate_binop(dest, op, left, right)

            # === Pipeline operators ===
            case PipeForward(dest, value, func):
                val dest_name = self.get_local(dest.id)
                val value_val = self.translate_operand(value)
                val func_val = self.translate_operand(func)
                val ret_ty = self.get_local_type(dest.id)
                self.builder.emit_assign(dest_name, r"((" + ret_ty + r"(*)(int64_t))(" + func_val + r"))(" + value_val + r")")

            case Compose(dest, f, g, forward):
                val dest_name = self.get_local(dest.id)
                val f_val = self.translate_operand(f)
                val g_val = self.translate_operand(g)
                self.builder.emit_assign(dest_name, "(void*)0")
                self.builder.emit_comment("compose (runtime support needed)")

            case Parallel(dest, funcs):
                val dest_name = self.get_local(dest.id)
                self.builder.emit_assign(dest_name, "(void*)0")
                self.builder.emit_comment(r"parallel (" + funcs.len() + r" functions)")

            case LayerConnect(dest, layer1, layer2):
                val dest_name = self.get_local(dest.id)
                val l1_val = self.translate_operand(layer1)
                val l2_val = self.translate_operand(layer2)
                self.builder.emit_assign(dest_name, "(void*)0")
                self.builder.emit_comment("layer connect (~>)")

            # === Inline Assembly ===
            case InlineAsm(asm_template, is_volatile, inputs, outputs, clobbers):
                val volatile_str = if is_volatile: "volatile" else: ""
                self.builder.emit(r"#if !(defined(_MSC_VER) && !defined(__clang__))")
                self.builder.emit(r"asm " + volatile_str + r" (" + "\"" + asm_template + "\"" + r");")
                self.builder.emit(r"#endif")

            # === Debug/Nop ===
            case DebugValue(local, name):
                pass_dn

            case Nop:
                pass_dn

            # === Async/Actor (stubs) ===
            case CreatePromise(dest, body, result_type):
                val dest_name = self.get_local(dest.id)
                self.builder.emit_assign(dest_name, "(void*)0")
                self.builder.emit_comment("CreatePromise (async stub)")

            case Await(dest, promise):
                val dest_name = self.get_local(dest.id)
                val promise_val = self.translate_operand(promise)
                self.builder.emit_assign(dest_name, "0")
                self.builder.emit_comment("Await (async stub)")

            case Yield(value):
                self.builder.emit_comment("Yield (async stub)")

            case Spawn(dest, handler, args):
                val dest_name = self.get_local(dest.id)
                self.builder.emit_assign(dest_name, "(void*)0")
                self.builder.emit_comment("Spawn (async stub)")

            case Send(target, message):
                self.builder.emit_comment("Send (actor stub)")

            case Receive(dest, timeout):
                val dest_name = self.get_local(dest.id)
                self.builder.emit_assign(dest_name, "0")
                self.builder.emit_comment("Receive (actor stub)")

            # === Borrow checking ===
            case Ref(dest, borrow_kind, place):
                val dest_name = self.get_local(dest.id)
                val place_val = self.get_local(place.local.id)
                self.builder.emit_assign(dest_name, place_val)

            # === GPU instructions (stubs) ===
            case GpuKernelDef(name):
                self.builder.emit_comment(r"GpuKernelDef: " + name + r" (requires GPU backend)")
            case GpuLaunch(args):
                self.builder.emit_comment("GpuLaunch (requires GPU backend)")
            case GpuGlobalId(dest, dim):
                val dest_name = self.get_local(dest.id)
                self.builder.emit_assign(dest_name, "0")
            case GpuLocalId(dest, dim):
                val dest_name = self.get_local(dest.id)
                self.builder.emit_assign(dest_name, "0")
            case GpuBlockId(dest, dim):
                val dest_name = self.get_local(dest.id)
                self.builder.emit_assign(dest_name, "0")
            case GpuBlockDim(dest, dim):
                val dest_name = self.get_local(dest.id)
                self.builder.emit_assign(dest_name, "0")
            case GpuGridDim(dest, dim):
                val dest_name = self.get_local(dest.id)
                self.builder.emit_assign(dest_name, "0")
            case GpuBarrier(scope):
                self.builder.emit_comment("GpuBarrier (requires GPU backend)")
            case GpuMemFence(scope):
                self.builder.emit_comment("GpuMemFence (requires GPU backend)")
            case GpuSharedAlloc(dest, type_, size):
                val slot_name = self.ensure_stack_slot(dest.id, size)
                self.emit_pointer_assign(dest.id, slot_name)
            case GpuAtomicOp(dest, op, ptr, value):
                val dest_name = self.get_local(dest.id)
                self.builder.emit_assign(dest_name, "0")
                self.builder.emit_comment("GpuAtomicOp (requires GPU backend)")

            # === VHDL instructions (stubs) ===
            case VhdlProcess(kind, body_block):
                self.builder.emit_comment("VhdlProcess (requires VHDL backend)")
            case VhdlSignalAssign(target, value, delay_ns):
                self.builder.emit_comment("VhdlSignalAssign (requires VHDL backend)")
            case VhdlVarAssign(target, value):
                self.builder.emit_comment("VhdlVarAssign (requires VHDL backend)")
            case VhdlPortMap(entity, instance, connections):
                self.builder.emit_comment(r"VhdlPortMap: " + entity + r"/" + instance + r" (requires VHDL backend)")
            case VhdlResize(dest, operand, new_width, signed):
                val dest_name = self.get_local(dest.id)
                self.builder.emit_assign(dest_name, "0")
            case VhdlSlice(dest, signal, hi, lo):
                val dest_name = self.get_local(dest.id)
                self.builder.emit_assign(dest_name, "0")
            case VhdlConcat(dest, parts):
                val dest_name = self.get_local(dest.id)
                self.builder.emit_assign(dest_name, "0")

            # === SIMD instructions (stubs) ===
            case SimdAddF32x4(dest, a, b):
                self.emit_simd_stub(dest, a, b, "+")
            case SimdSubF32x4(dest, a, b):
                self.emit_simd_stub(dest, a, b, "-")
            case SimdMulF32x4(dest, a, b):
                self.emit_simd_stub(dest, a, b, "*")
            case SimdDivF32x4(dest, a, b):
                self.emit_simd_stub(dest, a, b, "/")
            case SimdFmaF32x4(dest, a, b, c):
                val dest_name = self.get_local(dest.id)
                self.builder.emit_assign(dest_name, "0")
                self.builder.emit_comment("SimdFmaF32x4 (stub)")
            case SimdAddF32x8(dest, a, b):
                self.emit_simd_stub(dest, a, b, "+")
            case SimdSubF32x8(dest, a, b):
                self.emit_simd_stub(dest, a, b, "-")
            case SimdMulF32x8(dest, a, b):
                self.emit_simd_stub(dest, a, b, "*")
            case SimdDivF32x8(dest, a, b):
                self.emit_simd_stub(dest, a, b, "/")
            case SimdFmaF32x8(dest, a, b, c):
                val dest_name = self.get_local(dest.id)
                self.builder.emit_assign(dest_name, "0")
                self.builder.emit_comment("SimdFmaF32x8 (stub)")
            case SimdAddF64x4(dest, a, b):
                self.emit_simd_stub(dest, a, b, "+")
            case SimdSubF64x4(dest, a, b):
                self.emit_simd_stub(dest, a, b, "-")
            case SimdMulF64x4(dest, a, b):
                self.emit_simd_stub(dest, a, b, "*")
            case SimdDivF64x4(dest, a, b):
                self.emit_simd_stub(dest, a, b, "/")
            case SimdFmaF64x4(dest, a, b, c):
                val dest_name = self.get_local(dest.id)
                self.builder.emit_assign(dest_name, "0")
                self.builder.emit_comment("SimdFmaF64x4 (stub)")
            case SimdAddI32x4(dest, a, b):
                self.emit_simd_stub(dest, a, b, "+")
            case SimdSubI32x4(dest, a, b):
                self.emit_simd_stub(dest, a, b, "-")
            case SimdMulI32x4(dest, a, b):
                self.emit_simd_stub(dest, a, b, "*")
            case SimdAddI32x8(dest, a, b):
                self.emit_simd_stub(dest, a, b, "+")
            case SimdSubI32x8(dest, a, b):
                self.emit_simd_stub(dest, a, b, "-")
            case SimdMulI32x8(dest, a, b):
                self.emit_simd_stub(dest, a, b, "*")
            case SimdHaddF32x4(dest, a):
                val dest_name = self.get_local(dest.id)
                self.builder.emit_assign(dest_name, "0")
                self.builder.emit_comment("SimdHaddF32x4 (stub)")
            case SimdHmaxF32x4(dest, a):
                val dest_name = self.get_local(dest.id)
                self.builder.emit_assign(dest_name, "0")
                self.builder.emit_comment("SimdHmaxF32x4 (stub)")
            case SimdHminF32x4(dest, a):
                val dest_name = self.get_local(dest.id)
                self.builder.emit_assign(dest_name, "0")
                self.builder.emit_comment("SimdHminF32x4 (stub)")

    me emit_simd_stub(dest: LocalId, a: MirOperand, b: MirOperand, op: text):
        val dest_name = self.get_local(dest.id)
        self.builder.emit_assign(dest_name, "0")
        self.builder.emit_comment(r"SIMD " + op + r" (scalar fallback stub)")

    me translate_container_call(func_name: text, dest: LocalId?, args: [MirOperand]) -> bool:
        """Intercept spl_array_*/spl_dict_* runtime calls and emit C++ method calls.
        Returns true if the call was handled, false otherwise."""
        var arg_vals: [text] = []
        for arg in args:
            arg_vals = arg_vals.push(self.translate_operand(arg))

        # Array operations
        if func_name == "spl_array_new":
            if dest.?:
                val dest_name = self.get_local(dest.unwrap().id)
                val ty = self.get_local_type(dest.unwrap().id)
                self.builder.emit_assign(dest_name, ty + r"()")
            return true
        elif func_name == "spl_array_push":
            if arg_vals.len() >= 2:
                self.builder.emit(arg_vals[0] + r".push(" + arg_vals[1] + r");")
            return true
        elif func_name == "spl_array_get":
            if dest.? and arg_vals.len() >= 2:
                val dest_name = self.get_local(dest.unwrap().id)
                self.builder.emit_assign(dest_name, arg_vals[0] + r".get(" + arg_vals[1] + r")")
            return true
        elif func_name == "spl_array_len":
            if dest.? and arg_vals.len() >= 1:
                val dest_name = self.get_local(dest.unwrap().id)
                self.builder.emit_assign(dest_name, arg_vals[0] + r".len()")
            return true
        elif func_name == "spl_array_pop":
            if dest.? and arg_vals.len() >= 1:
                val dest_name = self.get_local(dest.unwrap().id)
                self.builder.emit_assign(dest_name, arg_vals[0] + r".pop()")
            return true
        elif func_name == "spl_array_set":
            if arg_vals.len() >= 3:
                self.builder.emit(arg_vals[0] + r".set(" + arg_vals[1] + r", " + arg_vals[2] + r");")
            return true
        # Dict operations
        elif func_name == "spl_dict_new":
            if dest.?:
                val dest_name = self.get_local(dest.unwrap().id)
                val ty = self.get_local_type(dest.unwrap().id)
                self.builder.emit_assign(dest_name, ty + r"()")
            return true
        elif func_name == "spl_dict_set":
            if arg_vals.len() >= 3:
                self.builder.emit(arg_vals[0] + r".set(" + arg_vals[1] + r", " + arg_vals[2] + r");")
            return true
        elif func_name == "spl_dict_get":
            if dest.? and arg_vals.len() >= 2:
                val dest_name = self.get_local(dest.unwrap().id)
                self.builder.emit_assign(dest_name, arg_vals[0] + r".get(" + arg_vals[1] + r")")
            return true
        elif func_name == "spl_dict_contains":
            if dest.? and arg_vals.len() >= 2:
                val dest_name = self.get_local(dest.unwrap().id)
                self.builder.emit_assign(dest_name, arg_vals[0] + r".contains(" + arg_vals[1] + r")")
            return true
        elif func_name == "spl_dict_keys":
            if dest.? and arg_vals.len() >= 1:
                val dest_name = self.get_local(dest.unwrap().id)
                self.builder.emit_assign(dest_name, arg_vals[0] + r".keys()")
            return true
        elif func_name == "spl_dict_len":
            if dest.? and arg_vals.len() >= 1:
                val dest_name = self.get_local(dest.unwrap().id)
                self.builder.emit_assign(dest_name, arg_vals[0] + r".len()")
            return true
        elif func_name == "spl_dict_remove":
            if arg_vals.len() >= 2:
                self.builder.emit(arg_vals[0] + r".remove(" + arg_vals[1] + r");")
            return true

        false

    # === Binary Operations ===

    me translate_binop(dest: LocalId, op: MirBinOp, left: MirOperand, right: MirOperand):
        val dest_name = self.get_local(dest.id)
        val left_val = self.translate_operand(left)
        val right_val = self.translate_operand(right)
        val ty = self.get_local_type(dest.id)

        match op:
            case Add:
                self.builder.emit_binop(dest_name, ty, "+", left_val, right_val)
            case Sub:
                self.builder.emit_binop(dest_name, ty, "-", left_val, right_val)
            case Mul:
                self.builder.emit_binop(dest_name, ty, "*", left_val, right_val)
            case Div:
                self.builder.emit_binop(dest_name, ty, "/", left_val, right_val)
            case Rem:
                self.builder.emit_binop(dest_name, ty, "%", left_val, right_val)
            case Pow:
                self.builder.emit_comment("pow")
                self.builder.emit_assign(dest_name, r"(" + ty + r")__simple_pow(" + left_val + r", " + right_val + r")")

            case BitAnd:
                self.builder.emit_binop(dest_name, ty, "&", left_val, right_val)
            case BitOr:
                self.builder.emit_binop(dest_name, ty, "|", left_val, right_val)
            case BitXor:
                self.builder.emit_binop(dest_name, ty, "^", left_val, right_val)
            case Shl:
                self.builder.emit_binop(dest_name, ty, "<<", left_val, right_val)
            case Shr:
                self.builder.emit_binop(dest_name, ty, ">>", left_val, right_val)

            case Eq:
                self.builder.emit_cmp(dest_name, ty, "==", left_val, right_val)
            case Ne:
                self.builder.emit_cmp(dest_name, ty, "!=", left_val, right_val)
            case Lt:
                self.builder.emit_cmp(dest_name, ty, "<", left_val, right_val)
            case Le:
                self.builder.emit_cmp(dest_name, ty, "<=", left_val, right_val)
            case Gt:
                self.builder.emit_cmp(dest_name, ty, ">", left_val, right_val)
            case Ge:
                self.builder.emit_cmp(dest_name, ty, ">=", left_val, right_val)

            case MatMul:
                self.builder.emit_assign(dest_name, r"(void*)__simple_runtime_matmul((void*)" + left_val + r", (void*)" + right_val + r")")
            case BroadcastAdd:
                self.builder.emit_assign(dest_name, r"(void*)__simple_runtime_broadcast_add((void*)" + left_val + r", (void*)" + right_val + r")")
            case BroadcastSub:
                self.builder.emit_assign(dest_name, r"(void*)__simple_runtime_broadcast_sub((void*)" + left_val + r", (void*)" + right_val + r")")
            case BroadcastMul:
                self.builder.emit_assign(dest_name, r"(void*)__simple_runtime_broadcast_mul((void*)" + left_val + r", (void*)" + right_val + r")")
            case BroadcastDiv:
                self.builder.emit_assign(dest_name, r"(void*)__simple_runtime_broadcast_div((void*)" + left_val + r", (void*)" + right_val + r")")
            case BroadcastPow:
                self.builder.emit_assign(dest_name, r"(void*)__simple_runtime_broadcast_pow((void*)" + left_val + r", (void*)" + right_val + r")")

            case Offset:
                self.builder.emit_assign(dest_name, r"(int64_t)((char*)(intptr_t)" + left_val + r" + " + right_val + r")")

    # === Unary Operations ===

    me translate_unaryop(dest: LocalId, op: MirUnaryOp, operand: MirOperand):
        val dest_name = self.get_local(dest.id)
        val operand_val = self.translate_operand(operand)
        val ty = self.get_local_type(dest.id)

        match op:
            case Neg:
                self.builder.emit_unaryop(dest_name, ty, "-", operand_val)
            case Not:
                self.builder.emit_cmp(dest_name, ty, "==", operand_val, "0")
            case BitNot:
                self.builder.emit_unaryop(dest_name, ty, "~", operand_val)
            case Transpose:
                self.builder.emit_assign(dest_name, r"(void*)__simple_runtime_transpose((void*)" + operand_val + r")")

    # === Terminators ===

    me translate_terminator(term: MirTerminator):
        match term:
            case Return(value):
                if value.?:
                    val val_str = self.translate_operand(value.unwrap())
                    self.builder.emit_return(Some(val_str))
                else:
                    self.builder.emit_return(nil)

            case Goto(target):
                self.builder.emit_goto(r"bb" + target.id)

            case If(cond, then_, else_):
                val cond_val = self.translate_operand(cond)
                self.builder.emit_if(cond_val + r" != 0", r"bb" + then_.id, r"bb" + else_.id)

            case Switch(value, targets, default):
                val discr_val = self.translate_operand(value)
                self.builder.emit_switch_start(discr_val)
                for switch_case in targets:
                    self.builder.emit_switch_case(r"" + switch_case.value, r"bb" + switch_case.target.id)
                self.builder.emit_switch_default(r"bb" + default.id)
                self.builder.emit_switch_end()

            case Unreachable:
                self.builder.emit(r"SPL_UNREACHABLE();")

            case Abort(message):
                self.builder.emit(r"spl_panic(" + "\"" + message + "\"" + r");")

            case CallTerminator(dest, func, args, normal, unwind):
                val func_val = self.translate_operand(func)
                var arg_vals: [text] = []
                for arg in args:
                    arg_vals = arg_vals.push(self.translate_operand(arg))
                val args_str = arg_vals.join(", ")
                if dest.?:
                    val dest_name = self.get_local(dest.unwrap().id)
                    self.builder.emit_assign(dest_name, func_val + r"(" + args_str + r")")
                else:
                    self.builder.emit(func_val + r"(" + args_str + r");")
                self.builder.emit_goto(r"bb" + normal.id)

    # === Helpers ===

    me prepare_stack_slots(body: MirBody):
        self.stack_slots = {}
        self.stack_slot_sizes = {}
        for block in body.blocks:
            for inst in block.instructions:
                match inst.kind:
                    case Alloc(dest, type_):
                        self.ensure_stack_slot(dest.id, self.type_mapper.size_of(type_))
                    case Aggregate(dest, kind, operands):
                        self.ensure_stack_slot(dest.id, operands.len() * 8)
                    case GpuSharedAlloc(dest, type_, size):
                        self.ensure_stack_slot(dest.id, size)
                    case Const(dest, value, type_):
                        val sz = self.const_composite_size(value)
                        if sz > 0:
                            self.ensure_stack_slot(dest.id, sz)
                    case _:
                        pass_dn

    fn slot_name_for_local(local_id: i64) -> text:
        r"_slot_l" + local_id

    fn normalized_slot_size(size: i64) -> i64:
        if size <= 0: 1 else: size

    me ensure_stack_slot(local_id: i64, requested_size: i64) -> text:
        val required = self.normalized_slot_size(requested_size)
        match self.stack_slots.get(local_id):
            case Some(existing):
                val current = self.stack_slot_sizes[local_id]
                if required > current:
                    self.stack_slot_sizes[local_id] = required
                existing
            case nil:
                val slot_name = self.slot_name_for_local(local_id)
                self.stack_slots[local_id] = slot_name
                self.stack_slot_sizes[local_id] = required
                slot_name

    me emit_pointer_assign(dest_local_id: i64, ptr_expr: text):
        val dest_name = self.get_local(dest_local_id)
        val dest_ty = self.get_local_type(dest_local_id)
        if dest_ty == "void*":
            self.builder.emit_assign(dest_name, r"(void*)" + ptr_expr)
        else:
            self.builder.emit_assign(dest_name, r"(int64_t)(intptr_t)((void*)" + ptr_expr + r")")

    fn const_composite_size(value: MirConstValue) -> i64:
        match value:
            case Array(elements):
                if elements.len() == 0: 1 else: elements.len() * 8
            case Tuple(elements):
                if elements.len() == 0: 1 else: elements.len() * 8
            case Struct(fields):
                if fields.len() == 0: 1 else: fields.len() * 8
            case _:
                0

    me translate_composite_const(dest: LocalId, value: MirConstValue) -> bool:
        match value:
            case Array(elements):
                val slot_name = self.ensure_stack_slot(dest.id, self.const_composite_size(value))
                self.emit_pointer_assign(dest.id, slot_name)
                var idx = 0
                for elem in elements:
                    val elem_val = self.const_to_i64_expr(elem)
                    self.builder.emit(r"((int64_t*)(void*)" + slot_name + r")[" + idx + r"] = " + elem_val + r";")
                    idx = idx + 1
                true
            case Tuple(elements):
                val slot_name = self.ensure_stack_slot(dest.id, self.const_composite_size(value))
                self.emit_pointer_assign(dest.id, slot_name)
                var idx = 0
                for elem in elements:
                    val elem_val = self.const_to_i64_expr(elem)
                    self.builder.emit(r"((int64_t*)(void*)" + slot_name + r")[" + idx + r"] = " + elem_val + r";")
                    idx = idx + 1
                true
            case Struct(fields):
                val slot_name = self.ensure_stack_slot(dest.id, self.const_composite_size(value))
                self.emit_pointer_assign(dest.id, slot_name)
                var idx = 0
                for field_name, field_val in fields:
                    val elem_val = self.const_to_i64_expr(field_val)
                    self.builder.emit(r"((int64_t*)(void*)" + slot_name + r")[" + idx + r"] = " + elem_val + r";")
                    idx = idx + 1
                true
            case _:
                false

    me translate_operand(operand: MirOperand) -> text:
        match operand.kind:
            case Copy(local):
                self.get_local(local)
            case Move(local):
                self.get_local(local)
            case Const(value, type_):
                self.translate_const_value(value)

    me translate_const_value(value: MirConstValue) -> text:
        match value:
            case Int(val): r"" + val
            case Float(val): r"" + val
            case Bool(val): if val: "1" else: "0"
            case Str(val):
                val var_name = self.builder.add_string_literal(val)
                r"(const char*)" + var_name
            case Zero: "0"
            case Array(elements):
                if elements.len() == 0:
                    "0 /* empty array */"
                else:
                    var init_vals: [text] = []
                    for elem in elements:
                        init_vals = init_vals.push(self.const_to_i64_expr(elem))
                    r"([]() -> int64_t { static int64_t v[" + elements.len() + r"] = {" + init_vals.join(", ") + r"}; return (int64_t)(intptr_t)v; }())"
            case Tuple(elements):
                if elements.len() == 0:
                    "0 /* empty tuple */"
                else:
                    var init_vals: [text] = []
                    for elem in elements:
                        init_vals = init_vals.push(self.const_to_i64_expr(elem))
                    r"([]() -> int64_t { static int64_t v[" + elements.len() + r"] = {" + init_vals.join(", ") + r"}; return (int64_t)(intptr_t)v; }())"
            case Struct(fields):
                if fields.len() == 0:
                    "0 /* empty struct */"
                else:
                    var init_vals: [text] = []
                    for field_name, field_val in fields:
                        init_vals = init_vals.push(self.const_to_i64_expr(field_val))
                    r"([]() -> int64_t { static int64_t v[" + fields.len() + r"] = {" + init_vals.join(", ") + r"}; return (int64_t)(intptr_t)v; }())"

    me const_to_i64_expr(value: MirConstValue) -> text:
        match value:
            case Int(val):
                r"" + val
            case Float(val):
                r"(int64_t)(" + val + r")"
            case Bool(val):
                if val: "1" else: "0"
            case Str(_):
                val str_expr = self.translate_const_value(value)
                r"(int64_t)(intptr_t)(" + str_expr + r")"
            case Zero:
                "0"
            case _:
                val nested = self.translate_const_value(value)
                r"(int64_t)(intptr_t)(" + nested + r")"

    fn get_local(id: i64) -> text:
        r"_l" + id

    fn get_local_type(id: i64) -> text:
        match self.local_types.get(id):
            case Some(ty): ty
            case nil: "int64_t"

    fn get_local_type_from_body(body: MirBody, id: i64) -> text:
        if id < body.locals.len():
            self.type_mapper.map_type(body.locals[id].type_)
        else:
            "int64_t"

    fn get_operand_type(operand: MirOperand) -> text:
        match operand.kind:
            case Copy(local): self.get_local_type(local)
            case Move(local): self.get_local_type(local)
            case Const(value, type_): self.type_mapper.map_type(type_)

    fn zero_value(ty: text) -> text:
        if ty == "void*":
            "nullptr"
        elif ty == "double" or ty == "float":
            "0.0"
        elif ty == "const char*":
            "nullptr"
        else:
            "0"

# Sanitize a SPL type name containing generics to a valid C identifier.
# Examples: "Box<i64>" -> "Box_i64", "Dict<Text, i64>" -> "Dict_Text_i64"
fn sanitize_c_name(name: text) -> text:
    var s = name.split("<").join("_")
    s = s.split(">").join("")
    s = s.split(",").join("_")
    s = s.split(" ").join("")
    s = s.split("::").join("_")
    s

# ============================================================================
# CCodegenBackend - Backend interface for BackendFactory
# ============================================================================

class CCodegenBackend:
    """Backend wrapper for C++20 code generation via MIR.

    Used by BackendFactory.create_specific() to create a C backend instance.
    Translates MIR modules to C++20 source stored in CompiledModule.assembly.
    """
    target: CodegenTarget
    options: CompileOptions

    static fn create(target: CodegenTarget, options: CompileOptions) -> CCodegenBackend:
        CCodegenBackend(target: target, options: options)

    fn compile(module: MirModule) -> CompiledModule:
        var translator = MirToC__create(module.name)
        val c_source = translator.translate_module(module)
        val h_source = translator.build_header()
        CompiledModule(
            name: module.name,
            object_code: nil,
            assembly: c_source,
            has_llvm_ir: true,
            llvm_ir: h_source,
            symbols: [],
            compile_time_ms: 0
        )

# ============================================================================
# Export
# ============================================================================

fn MirToC__create(module_name: text) -> MirToC:
    MirToC.create(module_name)

fn MirToC__create_for_target(module_name: text, target: CodegenTarget) -> MirToC:
    MirToC.create_for_target(module_name, target)

export MirToC, CCodegenBackend
export MirToC__create, MirToC__create_for_target
