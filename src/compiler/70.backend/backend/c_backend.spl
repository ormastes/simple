# C Backend - MIR to C++20 Translation
#
# Translates MIR to C++20 source code that links against runtime.h.
# Implements MirTextCodegen trait for shared instruction dispatch.
# Generated code uses the spl_ runtime API for strings, arrays, dicts.
#
# Output is C++20 suitable for clang++/g++ compilation:
#   clang++ -std=c++20 -O2 generated.cpp runtime.c -o output
#
# Split into three files:
#   c_backend.spl           - Class definition, control flow, helpers, wrapper
#   c_backend_translate.spl - Per-category instruction translation methods
#   c_backend_stubs.spl     - Stub trait methods (GPU, VHDL, SIMD, async/actor)

use compiler.mir.mir_data.*
use compiler.backend.c_type_mapper.{CTypeMapper, CTypeMapper__create, CTypeMapper__create_for_target}
use compiler.backend.c_ir_builder.{CIRBuilder, CIRBuilder__create, escape_c_string}
use compiler.backend.common.mir_text_codegen.MirTextCodegen
use compiler.core.backend_types.{CodegenTarget, CompileOptions, CompiledModule}

# ============================================================================
# MIR to C++ Translator
# ============================================================================

class MirToC:
    """Translates MIR to C++20 source code."""
    builder: CIRBuilder
    type_mapper: CTypeMapper
    local_map: Dict
    local_types: Dict
    stack_slots: Dict
    stack_slot_sizes: Dict
    string_counter: i64
    str_locals: Dict

    static fn create(module_name: text) -> MirToC:
        MirToC(
            builder: CIRBuilder__create(module_name),
            type_mapper: CTypeMapper__create(),
            local_map: {},
            local_types: {},
            stack_slots: {},
            stack_slot_sizes: {},
            string_counter: 0,
            str_locals: {}
        )

    static fn create_for_target(module_name: text, target: CodegenTarget) -> MirToC:
        MirToC(
            builder: CIRBuilder__create(module_name),
            type_mapper: CTypeMapper__create_for_target(target),
            local_map: {},
            local_types: {},
            stack_slots: {},
            stack_slot_sizes: {},
            string_counter: 0,
            str_locals: {}
        )

# ============================================================================
# MirTextCodegen Trait Implementation - Top-level & Control Flow
# ============================================================================

impl MirTextCodegen for MirToC:

    # === Required: top-level translation ===

    me translate_module(module: MirModule) -> text:
        """Translate entire MIR module to C++20 source (implementation file)."""
        self.builder.emit_header_file_header()
        self.builder.emit_impl_file_header()
        self.emit_type_definitions(module)

        self.builder.emit_header_raw(r"// Forward declarations")
        self.builder.emit_raw(r"// Forward declarations")
        for name, body in module.functions:
            self.emit_forward_declaration(name, body)
        self.builder.emit_header_raw("")
        self.builder.emit_blank()

        for name, body in module.functions:
            self.translate_function(name, body)

        self.builder.build()

    me translate_function(name: text, body: MirBody):
        """Translate a MIR function to C++."""
        self.local_types = {}
        self.str_locals = {}
        for local in body.locals:
            val c_ty = self.type_mapper.map_type(local.type_)
            self.local_types[local.id.id] = c_ty
            if c_ty == "const char*":
                self.str_locals[local.id.id] = 1
        self.prepare_stack_slots(body)

        var params: [text] = []
        for i in 0..body.arg_count:
            val param_ty = self.get_local_type(i)
            params = params.push(param_ty + r" _l" + i)
        val params_str = if params.len() == 0: "void" else: params.join(", ")

        val ret_ty = self.type_mapper.map_return_type(body.return_ty)
        self.builder.start_function(ret_ty, name, params_str)

        for local in body.locals:
            match local.kind:
                case Arg(_): pass_dn
                case _:
                    val ty = self.type_mapper.map_type(local.type_)
                    if ty != "void":
                        self.builder.emit_local_init(ty, r"_l" + local.id.id, self.zero_value(ty))
        for local_id, slot_name in self.stack_slots:
            val slot_size = self.stack_slot_sizes[local_id]
            self.builder.emit(r"alignas(16) unsigned char " + slot_name + r"[" + slot_size + r"];")

        self.builder.emit_blank()

        for block in body.blocks:
            self.translate_block(block)

        self.builder.end_function()

    me translate_block(block: MirBlock):
        """Translate a MIR basic block to C labeled block."""
        self.builder.emit_label(r"bb" + block.id.id)
        for inst in block.instructions:
            self.translate_instruction(inst)
        self.translate_terminator(block.terminator)

    me translate_terminator(term: MirTerminator):
        match term:
            case Return(value):
                if value.?:
                    val ret_operand = value.unwrap()
                    val ret_local_id = self.operand_local_id(ret_operand)
                    self.emit_str_cleanup_all(ret_local_id)
                    val val_str = self.translate_operand(ret_operand)
                    self.builder.emit_return(Some(val_str))
                else:
                    self.emit_str_cleanup_all(-1)
                    self.builder.emit_return(nil)

            case Goto(target):
                self.builder.emit_goto(r"bb" + target.id)

            case If(cond, then_, else_):
                val cond_val = self.translate_operand(cond)
                self.builder.emit_if(cond_val + r" != 0", r"bb" + then_.id, r"bb" + else_.id)

            case Switch(value, targets, default):
                val discr_val = self.translate_operand(value)
                self.builder.emit_switch_start(discr_val)
                for switch_case in targets:
                    self.builder.emit_switch_case(r"" + switch_case.value, r"bb" + switch_case.target.id)
                self.builder.emit_switch_default(r"bb" + default.id)
                self.builder.emit_switch_end()

            case Unreachable:
                self.builder.emit(r"SPL_UNREACHABLE();")

            case Abort(message):
                self.builder.emit(r"spl_panic(" + "\"" + escape_c_string(message) + "\"" + r");")

            case CallTerminator(dest, func, args, normal, unwind):
                val func_val = self.translate_operand(func)
                var arg_vals: [text] = []
                for arg in args:
                    arg_vals = arg_vals.push(self.translate_operand(arg))
                val args_str = arg_vals.join(", ")
                if dest.?:
                    self.emit_str_cleanup(dest.unwrap().id)
                    val dest_name = self.get_local(dest.unwrap().id)
                    self.builder.emit_assign(dest_name, func_val + r"(" + args_str + r")")
                else:
                    self.builder.emit(func_val + r"(" + args_str + r");")
                self.builder.emit_goto(r"bb" + normal.id)

# ============================================================================
# C-Specific Helpers (not part of trait)
# ============================================================================

impl MirToC:

    me build_header() -> text:
        """Build the header file content."""
        self.builder.build_header()

    me emit_type_definitions(module: MirModule):
        """Register and emit C struct/enum definitions for all named types in the module."""
        for (key, type_def) in module.types:
            val c_name = sanitize_c_name(type_def.name)
            self.type_mapper.register_type(type_def.symbol.id, c_name)

        for (key, type_def) in module.types:
            val c_name = sanitize_c_name(type_def.name)
            match type_def.kind:
                case Struct(_):
                    self.builder.emit_header_raw("typedef struct " + c_name + "_s " + c_name + ";")
                case Enum(_):
                    self.builder.emit_header_raw("typedef struct " + c_name + "_s " + c_name + ";")
                case _: pass_dn
        self.builder.emit_header_raw("")

        for (key, type_def) in module.types:
            val c_name = sanitize_c_name(type_def.name)
            match type_def.kind:
                case Struct(fields):
                    self.builder.emit_header_raw("struct " + c_name + "_s {")
                    for field in fields:
                        val field_c_type = self.type_mapper.map_type(field.type_)
                        self.builder.emit_header_raw("    " + field_c_type + " " + field.name + ";")
                    self.builder.emit_header_raw("};")
                    self.builder.emit_header_raw("")
                case Enum(variants):
                    self.builder.emit_header_raw("struct " + c_name + "_s {")
                    self.builder.emit_header_raw("    int64_t tag;")
                    self.builder.emit_header_raw("    union {")
                    for variant in variants:
                        if variant.payload.?:
                            val payload_ty = self.type_mapper.map_type(variant.payload.unwrap())
                            self.builder.emit_header_raw("        " + payload_ty + " " + variant.name + "_payload;")
                    self.builder.emit_header_raw("    } data;")
                    self.builder.emit_header_raw("};")
                    self.builder.emit_header_raw("")
                case _: pass_dn

    me emit_forward_declaration(name: text, body: MirBody):
        """Emit forward declaration for a function to both header and impl."""
        val ret_ty = self.type_mapper.map_return_type(body.return_ty)
        var params: [text] = []
        for i in 0..body.arg_count:
            val param_ty = self.get_local_type_from_body(body, i)
            params = params.push(param_ty + r" _l" + i)
        val params_str = if params.len() == 0: "void" else: params.join(", ")
        self.builder.emit_forward_decl(ret_ty, name, params_str)
        self.builder.emit_header_raw(ret_ty + r" " + name + r"(" + params_str + r");")

    me translate_container_call(func_name: text, dest: LocalId?, args: [MirOperand]) -> bool:
        """Intercept spl_array_*/spl_dict_* runtime calls and emit C++ method calls."""
        var arg_vals: [text] = []
        for arg in args:
            arg_vals = arg_vals.push(self.translate_operand(arg))

        if func_name == "spl_array_new":
            if dest.?:
                val dest_name = self.get_local(dest.unwrap().id)
                val ty = self.get_local_type(dest.unwrap().id)
                self.builder.emit_assign(dest_name, ty + r"()")
            return true
        elif func_name == "spl_array_push":
            if arg_vals.len() >= 2:
                self.builder.emit(arg_vals[0] + r".push(" + arg_vals[1] + r");")
            return true
        elif func_name == "spl_array_get":
            if dest.? and arg_vals.len() >= 2:
                val dest_name = self.get_local(dest.unwrap().id)
                self.builder.emit_assign(dest_name, arg_vals[0] + r".get(" + arg_vals[1] + r")")
            return true
        elif func_name == "spl_array_len":
            if dest.? and arg_vals.len() >= 1:
                val dest_name = self.get_local(dest.unwrap().id)
                self.builder.emit_assign(dest_name, arg_vals[0] + r".len()")
            return true
        elif func_name == "spl_array_pop":
            if dest.? and arg_vals.len() >= 1:
                val dest_name = self.get_local(dest.unwrap().id)
                self.builder.emit_assign(dest_name, arg_vals[0] + r".pop()")
            return true
        elif func_name == "spl_array_set":
            if arg_vals.len() >= 3:
                self.builder.emit(arg_vals[0] + r".set(" + arg_vals[1] + r", " + arg_vals[2] + r");")
            return true
        elif func_name == "spl_dict_new":
            if dest.?:
                val dest_name = self.get_local(dest.unwrap().id)
                val ty = self.get_local_type(dest.unwrap().id)
                self.builder.emit_assign(dest_name, ty + r"()")
            return true
        elif func_name == "spl_dict_set":
            if arg_vals.len() >= 3:
                self.builder.emit(arg_vals[0] + r".set(" + arg_vals[1] + r", " + arg_vals[2] + r");")
            return true
        elif func_name == "spl_dict_get":
            if dest.? and arg_vals.len() >= 2:
                val dest_name = self.get_local(dest.unwrap().id)
                self.builder.emit_assign(dest_name, arg_vals[0] + r".get(" + arg_vals[1] + r")")
            return true
        elif func_name == "spl_dict_contains":
            if dest.? and arg_vals.len() >= 2:
                val dest_name = self.get_local(dest.unwrap().id)
                self.builder.emit_assign(dest_name, arg_vals[0] + r".contains(" + arg_vals[1] + r")")
            return true
        elif func_name == "spl_dict_keys":
            if dest.? and arg_vals.len() >= 1:
                val dest_name = self.get_local(dest.unwrap().id)
                self.builder.emit_assign(dest_name, arg_vals[0] + r".keys()")
            return true
        elif func_name == "spl_dict_len":
            if dest.? and arg_vals.len() >= 1:
                val dest_name = self.get_local(dest.unwrap().id)
                self.builder.emit_assign(dest_name, arg_vals[0] + r".len()")
            return true
        elif func_name == "spl_dict_remove":
            if arg_vals.len() >= 2:
                self.builder.emit(arg_vals[0] + r".remove(" + arg_vals[1] + r");")
            return true

        false

    me prepare_stack_slots(body: MirBody):
        self.stack_slots = {}
        self.stack_slot_sizes = {}
        for block in body.blocks:
            for inst in block.instructions:
                match inst.kind:
                    case Alloc(dest, type_):
                        self.ensure_stack_slot(dest.id, self.type_mapper.size_of(type_))
                    case Aggregate(dest, kind, operands):
                        self.ensure_stack_slot(dest.id, operands.len() * 8)
                    case GpuSharedAlloc(dest, type_, size):
                        self.ensure_stack_slot(dest.id, size)
                    case Const(dest, value, type_):
                        val sz = self.const_composite_size(value)
                        if sz > 0:
                            self.ensure_stack_slot(dest.id, sz)
                    case _:
                        pass_dn

    fn slot_name_for_local(local_id: i64) -> text:
        r"_slot_l" + local_id

    fn normalized_slot_size(size: i64) -> i64:
        if size <= 0: 1 else: size

    me ensure_stack_slot(local_id: i64, requested_size: i64) -> text:
        val required = self.normalized_slot_size(requested_size)
        match self.stack_slots.get(local_id):
            case Some(existing):
                val current = self.stack_slot_sizes[local_id]
                if required > current:
                    self.stack_slot_sizes[local_id] = required
                existing
            case nil:
                val slot_name = self.slot_name_for_local(local_id)
                self.stack_slots[local_id] = slot_name
                self.stack_slot_sizes[local_id] = required
                slot_name

    me emit_pointer_assign(dest_local_id: i64, ptr_expr: text):
        val dest_name = self.get_local(dest_local_id)
        val dest_ty = self.get_local_type(dest_local_id)
        if dest_ty == "void*":
            self.builder.emit_assign(dest_name, r"(void*)" + ptr_expr)
        else:
            self.builder.emit_assign(dest_name, r"(int64_t)(intptr_t)((void*)" + ptr_expr + r")")

    fn const_composite_size(value: MirConstValue) -> i64:
        match value:
            case Array(elements):
                if elements.len() == 0: 1 else: elements.len() * 8
            case Tuple(elements):
                if elements.len() == 0: 1 else: elements.len() * 8
            case Struct(fields):
                if fields.len() == 0: 1 else: fields.len() * 8
            case _:
                0

    me translate_composite_const(dest: LocalId, value: MirConstValue) -> bool:
        match value:
            case Array(elements):
                val slot_name = self.ensure_stack_slot(dest.id, self.const_composite_size(value))
                self.emit_pointer_assign(dest.id, slot_name)
                var idx = 0
                for elem in elements:
                    val elem_val = self.const_to_i64_expr(elem)
                    self.builder.emit(r"((int64_t*)(void*)" + slot_name + r")[" + idx + r"] = " + elem_val + r";")
                    idx = idx + 1
                true
            case Tuple(elements):
                val slot_name = self.ensure_stack_slot(dest.id, self.const_composite_size(value))
                self.emit_pointer_assign(dest.id, slot_name)
                var idx = 0
                for elem in elements:
                    val elem_val = self.const_to_i64_expr(elem)
                    self.builder.emit(r"((int64_t*)(void*)" + slot_name + r")[" + idx + r"] = " + elem_val + r";")
                    idx = idx + 1
                true
            case Struct(fields):
                val slot_name = self.ensure_stack_slot(dest.id, self.const_composite_size(value))
                self.emit_pointer_assign(dest.id, slot_name)
                var idx = 0
                for field_name, field_val in fields:
                    val elem_val = self.const_to_i64_expr(field_val)
                    self.builder.emit(r"((int64_t*)(void*)" + slot_name + r")[" + idx + r"] = " + elem_val + r";")
                    idx = idx + 1
                true
            case _:
                false

    me const_to_i64_expr(value: MirConstValue) -> text:
        match value:
            case Int(v):
                r"" + v
            case Float(v):
                r"(int64_t)(" + v + r")"
            case Bool(v):
                if v: "1" else: "0"
            case Str(_):
                val str_expr = self.translate_const_value(value)
                r"(int64_t)(intptr_t)(" + str_expr + r")"
            case Zero:
                "0"
            case _:
                val nested = self.translate_const_value(value)
                r"(int64_t)(intptr_t)(" + nested + r")"

    fn get_local_type_from_body(body: MirBody, id: i64) -> text:
        if id < body.locals.len():
            self.type_mapper.map_type(body.locals[id].type_)
        else:
            "int64_t"

    fn is_str_local(id: i64) -> bool:
        self.str_locals.get(id).? and self.get_local_type(id) == "const char*"

    fn operand_local_id(operand: MirOperand) -> i64:
        match operand.kind:
            case Copy(local): local
            case Move(local): local
            case Const(_, _): -1

    me emit_str_cleanup(dest_id: i64):
        """Emit spl_free for a string local before reassignment."""
        if self.is_str_local(dest_id):
            val dest_name = self.get_local(dest_id)
            self.builder.emit(r"spl_free((void*)" + dest_name + r");")

    me emit_str_cleanup_all(skip_id: i64):
        """Free all string locals at function exit, skipping skip_id (return value)."""
        for local_id, _ in self.str_locals:
            if local_id != skip_id:
                val local_name = self.get_local(local_id)
                self.builder.emit(r"spl_free((void*)" + local_name + r");")

    fn zero_value(ty: text) -> text:
        if ty == "void*":
            "nullptr"
        elif ty == "double" or ty == "float":
            "0.0"
        elif ty == "const char*":
            "nullptr"
        else:
            "0"

# Sanitize a SPL type name containing generics to a valid C identifier.
# Single-pass replacement: <,.- -> '_', > and space -> removed, :: -> '_'
fn sanitize_c_name(name: text) -> text:
    var parts: [text] = []
    var seg_start = 0
    var i = 0
    var needs_work = false
    while i < name.len():
        val ch = name[i]
        if (ch == "<" or ch == "," or ch == "." or ch == "-"):
            if i > seg_start:
                parts = parts.push(name[seg_start:i])
            parts = parts.push("_")
            seg_start = i + 1
            needs_work = true
        elif (ch == ">" or ch == " "):
            if i > seg_start:
                parts = parts.push(name[seg_start:i])
            seg_start = i + 1
            needs_work = true
        elif ch == ":":
            # Handle :: -> _
            if i + 1 < name.len():
                if name[i + 1] == ":":
                    if i > seg_start:
                        parts = parts.push(name[seg_start:i])
                    parts = parts.push("_")
                    i = i + 1
                    seg_start = i + 1
                    needs_work = true
        i = i + 1
    var s = name
    if needs_work:
        if i > seg_start:
            parts = parts.push(name[seg_start:i])
        s = parts.join("")
    # Handle C++ reserved words by appending underscore
    if (s == "class" or s == "new" or s == "delete" or s == "template" or
        s == "namespace" or s == "default" or s == "short" or s == "long" or
        s == "operator" or s == "register" or s == "virtual" or s == "this" or
        s == "throw" or s == "catch" or s == "try" or s == "public" or
        s == "private" or s == "protected" or s == "friend" or s == "typename" or
        s == "using" or s == "auto" or s == "extern" or s == "inline" or
        s == "static" or s == "const" or s == "volatile" or s == "mutable" or
        s == "signed" or s == "unsigned" or s == "char" or s == "int" or
        s == "float" or s == "double" or s == "bool" or s == "true" or
        s == "false" or s == "nullptr" or s == "union" or s == "struct" or
        s == "enum" or s == "typedef" or s == "sizeof" or s == "alignof" or
        s == "decltype" or s == "constexpr" or s == "consteval" or
        s == "concept" or s == "requires" or s == "co_await" or
        s == "co_yield" or s == "co_return" or s == "module" or
        s == "import" or s == "export" or s == "override" or s == "final"):
        s = s + "_"
    s

# ============================================================================
# CCodegenBackend - Backend interface for BackendFactory
# ============================================================================

class CCodegenBackend:
    """Backend wrapper for C++20 code generation via MIR."""
    target: CodegenTarget
    options: CompileOptions

    static fn create(target: CodegenTarget, options: CompileOptions) -> CCodegenBackend:
        CCodegenBackend(target: target, options: options)

    fn compile(module: MirModule) -> CompiledModule:
        var translator = MirToC__create(module.name)
        val c_source = translator.translate_module(module)
        val h_source = translator.build_header()
        CompiledModule(
            name: module.name,
            object_code: nil,
            assembly: c_source,
            has_llvm_ir: true,
            llvm_ir: h_source,
            symbols: [],
            compile_time_ms: 0
        )

# ============================================================================
# Export
# ============================================================================

fn MirToC__create(module_name: text) -> MirToC:
    MirToC.create(module_name)

fn MirToC__create_for_target(module_name: text, target: CodegenTarget) -> MirToC:
    MirToC.create_for_target(module_name, target)

export MirToC, CCodegenBackend
export MirToC__create, MirToC__create_for_target
