"""
Backend Module - Compiler Backend Infrastructure

@tag:compiler
@tag:internal

This module provides the unified interface to all compiler backends.
The Simple compiler supports multiple code generation backends for different
targets and optimization levels.

## Architecture Overview

The backend system consists of three layers:

1. **Backend Selection** - Automatic or manual backend selection based on target
   architecture, build mode, and user preferences
2. **Type Mapping** - Convert Simple types to backend-specific representations
   (LLVM types, Cranelift types, WASM types, etc.)
3. **Code Generation** - Backend-specific implementations that transform MIR
   (Mid-level Intermediate Representation) to machine code

## Available Backends

### CPU Backends

- **Cranelift** - Fast JIT/AOT compilation, 64-bit focused
  - Best for: Debug builds (2.5x faster compilation than LLVM)
  - Targets: x86_64, AArch64
  - Default for: Debug mode on 64-bit platforms

- **LLVM** - Full optimization suite, 32-bit and 64-bit support
  - Best for: Release builds (15-30% faster runtime than Cranelift)
  - Targets: x86_64, x86, AArch64, ARM
  - Default for: Release mode, 32-bit targets
  - Requires: llc binary in PATH for object file generation

- **Native** - Direct machine code generation (no external dependencies)
  - Best for: Bootstrap builds, minimal dependencies
  - Targets: x86_64, AArch64
  - Features: Manual instruction selection and register allocation

- **Interpreter** - Tree-walking interpreter (no native code)
  - Best for: Test mode, rapid iteration
  - Targets: All (architecture-independent)
  - Default for: Test mode
  - Performance: ~100x slower than compiled code

### WebAssembly Backend

- **WASM** - WebAssembly bytecode generation
  - Best for: Browser deployment, sandboxed execution
  - Targets: wasm32
  - Output: .wasm modules

### GPU Backends

- **CUDA** - NVIDIA GPU compute (PTX output)
  - Targets: CUDA-capable GPUs
  - Output: PTX assembly
  - Features: Kernel generation, device functions, memory spaces

- **Vulkan** - Cross-platform GPU compute (SPIR-V output)
  - Targets: Vulkan-capable GPUs
  - Output: SPIR-V bytecode
  - Features: Compute shaders, descriptor sets, memory barriers

### Formal Verification Backend

- **Lean** - Export to Lean 4 theorem prover
  - Best for: Formal verification, proof generation
  - Output: Lean 4 code
  - Features: Type translation, proof obligations

## Backend Selection Strategy

The compiler automatically selects the best backend based on:

1. User preference (--backend flag) - overrides all other considerations
2. 32-bit targets → LLVM (only backend supporting 32-bit)
3. WebAssembly → WASM backend
4. GPU targets → CUDA or Vulkan backend
5. Test mode → Interpreter (no compilation overhead)
6. Debug mode → Cranelift (fast compilation)
7. Release mode → LLVM (optimized runtime)
8. Bootstrap mode → Cranelift or Native (minimal dependencies)

## Examples

### Automatic Backend Selection

```simple
use compiler.backend.backend_api.{Backend, CodegenTarget, BuildMode}

# Debug build - selects Cranelift for fast compilation
val debug_backend = Backend.for_target_and_mode(
    CodegenTarget.X86_64,
    BuildMode.Debug
)
print "Debug backend: {debug_backend.kind}"  # Cranelift

# Release build - selects LLVM for optimized code
val release_backend = Backend.for_target_and_mode(
    CodegenTarget.X86_64,
    BuildMode.Release
)
print "Release backend: {release_backend.kind}"  # Llvm

# Test mode - selects Interpreter for fast iteration
val test_backend = Backend.for_target_and_mode(
    CodegenTarget.X86_64,
    BuildMode.Test
)
print "Test backend: {test_backend.kind}"  # Interpreter
```

### Explicit Backend Selection

```simple
use compiler.backend.backend_api.{Backend, BackendKind, CodegenTarget, BuildMode}

# Force LLVM backend for Debug mode (slower compile, faster runtime)
val backend_result = Backend.for_target_mode_and_backend(
    CodegenTarget.X86_64,
    BuildMode.Debug,
    BackendKind.Llvm
)

match backend_result:
    Ok(backend):
        print "Using LLVM backend for debug build"
    Err(error):
        print "Backend error: {error}"
```

### Backend Compilation Workflow

```simple
use compiler.backend.backend_api.{compile_module_with_backend}
use compiler.backend.backend_api.{BackendKind, CodegenTarget, CompileOptions}
use compiler.mir_data.{MirModule}

# Create MIR module (simplified)
val mir_module = MirModule(
    name: "example",
    functions: [],
    globals: []
)

# Configure compilation options
val options = CompileOptions.default_options()
    .with_target(CodegenTarget.X86_64)
    .with_optimization(OptimizationLevel.O2)

# Compile with Cranelift backend
val result = compile_module_with_backend(
    BackendKind.Cranelift,
    mir_module,
    options
)

match result:
    Ok(compiled):
        print "Compiled to: {compiled.symbols.len()} symbols"
    Err(error):
        print "Compilation failed: {error}"
```

### 32-bit Target Support

```simple
use compiler.backend.backend_api.{Backend, CodegenTarget, BuildMode}

# 32-bit targets automatically select LLVM
val x86_backend = Backend.for_target_and_mode(
    CodegenTarget.X86,
    BuildMode.Release
)
print "32-bit backend: {x86_backend.kind}"  # Llvm (only option)
```

## Type Mapping

Each backend provides a TypeMapper implementation that converts Simple types
to backend-specific representations:

- **LlvmTypeMapper** - Maps to LLVM IR types (i32, i64, ptr, struct, etc.)
- **CraneliftTypeMapper** - Maps to Cranelift types (I32, I64, R64, etc.)
- **WasmTypeMapper** - Maps to WASM types (i32, i64, f32, f64)
- **InterpreterTypeMapper** - Maps to interpreter Value types
- **CudaTypeMapper** - Maps to PTX types (.s32, .s64, .f64, etc.)
- **VulkanTypeMapper** - Maps to SPIR-V types (OpTypeInt, OpTypeFloat, etc.)

## Code Generation Builders

For GPU backends, specialized builders construct target-specific code:

- **PtxBuilder** - CUDA PTX assembly generation
- **SpirvBuilder** - Vulkan SPIR-V bytecode generation

## See Also

- Backend API: `compiler.backend.backend_api`
- Backend Selection: `compiler.backend.backend_helpers`
- Backend Types: `core.backend_types`
- MIR Data Structures: `compiler.mir_data`
"""

# ============================================================================
# Codegen Trait Hierarchy
# ============================================================================
# Universal and domain-specific interfaces for all backends

# Codegen - Universal trait implemented by all backends
export common.Codegen

# CodegenOutput - Compilation result from any backend
export common.CodegenOutput

# CodegenOutputKind - Describes output type (ObjectCode, TextSource, GpuCode, etc.)
export common.CodegenOutputKind

# MirTextCodegen - MIR-to-text translation trait (LLVM, C, WASM)
export common.MirTextCodegen

# GpuCodegen - GPU kernel compilation trait (CUDA, Vulkan)
export common.GpuCodegen
export common.GpuBarrierScope
export common.GpuAtomicOpKind

# VerificationCodegen - Formal verification export trait (Lean)
export common.VerificationCodegen

# HardwareCodegen - Hardware description trait (VHDL)
export common.HardwareCodegen
export common.VhdlProcessKind

# NativeCodegen - Direct machine code generation trait
export common.NativeCodegen

# ============================================================================
# Codegen Adapters
# ============================================================================
# Adapter classes wrapping existing backends to implement Codegen trait

export llvm_codegen_adapter.LlvmCodegenAdapter
export c_codegen_adapter.CCodegenAdapter
export wasm_codegen_adapter.WasmCodegenAdapter
export native_codegen_adapter.NativeCodegenAdapter
export interpreter_codegen_adapter.InterpreterCodegenAdapter
export cranelift_codegen_adapter.CraneliftCodegenAdapter

# ============================================================================
# Codegen Factory
# ============================================================================
# Creates Codegen trait objects from BackendKind

export codegen_factory.CodegenFactory

# ============================================================================
# Backend Factory (legacy)
# ============================================================================
# Creates backend instances - DEPRECATED: Use backend_api.Backend.create() instead

export backend_factory.BackendFactory

# ============================================================================
# Shared Abstractions
# ============================================================================
# Common interfaces used across all backends for type conversion and evaluation

# TypeMapper - Converts Simple types to backend-specific representations
export common.TypeMapper

# PrimitiveType - Basic type categories (int, float, bool, pointer)
export common.PrimitiveType

# Mutability - Immutable vs mutable type qualifier
export common.Mutability

# LiteralConverter - Converts Simple literals to backend-specific constants
export common.LiteralConverter

# ExpressionEvaluator - Evaluates constant expressions at compile time
export common.ExpressionEvaluator

# EvalContext - Context for expression evaluation (symbol table, type info)
export common.EvalContext

# Environment - Symbol environment for variable lookups during evaluation
export common.Environment

# ============================================================================
# CPU Type Mapper Implementations
# ============================================================================
# Backend-specific type converters for CPU targets

# LlvmTypeMapper - Maps Simple types to LLVM IR types (i32, i64, ptr, struct)
export llvm_type_mapper.LlvmTypeMapper

# CraneliftTypeMapper - Maps Simple types to Cranelift types (I32, I64, R64)
export cranelift_type_mapper.CraneliftTypeMapper

# WasmTypeMapper - Maps Simple types to WebAssembly types (i32, i64, f32, f64)
export wasm_type_mapper.WasmTypeMapper

# InterpreterTypeMapper - Maps Simple types to interpreter Value types
export interpreter_type_mapper.InterpreterTypeMapper

# LeanTypeMapper - Maps Simple types to Lean 4 types for formal verification
export lean_type_mapper.LeanTypeMapper

# ============================================================================
# GPU Type Mapper Implementations
# ============================================================================
# Backend-specific type converters for GPU targets

# CudaTypeMapper - Maps Simple types to CUDA PTX types (.s32, .s64, .f64)
export cuda_type_mapper.CudaTypeMapper

# VulkanTypeMapper - Maps Simple types to SPIR-V types (OpTypeInt, OpTypeFloat)
export vulkan_type_mapper.VulkanTypeMapper

# SpirvImageDim - SPIR-V image dimension enumeration (1D, 2D, 3D, Cube)
export vulkan_type_mapper.SpirvImageDim

# SpirvBuiltin - SPIR-V built-in variable decorations (GlobalInvocationId, etc.)
export vulkan_type_mapper.SpirvBuiltin

# SpirvFeature - SPIR-V capability/extension requirements
export vulkan_type_mapper.SpirvFeature

# ============================================================================
# GPU Code Generation Builders
# ============================================================================
# Specialized builders for constructing GPU-specific code

# PtxBuilder - Generates CUDA PTX assembly for NVIDIA GPUs
export cuda.ptx_builder.PtxBuilder

# SpirvBuilder - Generates SPIR-V bytecode for Vulkan compute shaders
export vulkan.spirv_builder.SpirvBuilder

# ============================================================================
# GPU Backend Implementations
# ============================================================================
# Full backend implementations for GPU targets

# CudaBackend - CUDA backend for NVIDIA GPUs
export cuda_backend.CudaBackend

# CudaCompiledModule - Compiled CUDA module containing kernels and device functions
export cuda_backend.CudaCompiledModule

# CudaKernel - Individual CUDA kernel (grid-level parallelism)
export cuda_backend.CudaKernel

# CudaDeviceFunction - CUDA device function (callable from kernels)
export cuda_backend.CudaDeviceFunction

# VulkanBackend - Vulkan compute backend for cross-platform GPU compute
export vulkan_backend.VulkanBackend

# VulkanCompiledModule - Compiled Vulkan module containing compute shaders
export vulkan_backend.VulkanCompiledModule

# VulkanComputeShader - Individual Vulkan compute shader
export vulkan_backend.VulkanComputeShader

# ============================================================================
# CPU Backend Implementations
# ============================================================================
# Note: Backend implementations are accessed via backend_api.Backend
# These direct exports are deprecated and will be removed in future versions
# Use backend_api.Backend.create() or Backend.for_target_and_mode() instead

# Uncomment when ready to integrate (future work):
# export llvm_backend.LlvmBackend           # LLVM IR compilation backend
# export cranelift_backend.CraneliftBackend # Cranelift JIT/AOT backend
# export wasm_backend.WasmBackend           # WebAssembly compilation backend
# export interpreter_backend.InterpreterBackend # Tree-walking interpreter backend

# ============================================================================
# Backend API Types
# ============================================================================
# Core types for backend configuration and compilation results

# BackendKind - Enum of available backends (Cranelift, Llvm, Native, etc.)
export backend_api.BackendKind

# CodegenTarget - Target architecture enum (X86_64, AArch64, X86, WASM, etc.)
export backend_api.CodegenTarget

# OptimizationLevel - Optimization level enum (O0, O1, O2, O3)
export backend_api.OptimizationLevel

# BuildMode - Build mode enum (Debug, Release, Test, Bootstrap)
export backend_api.BuildMode

# CompileError - Compilation error results (type mismatch, unsupported target, etc.)
export backend_api.CompileError

# CompiledModule - Result of successful compilation (symbols, object code, metadata)
export backend_api.CompiledModule

# backend_for_name - Parse backend name from text (e.g., "cranelift" -> BackendKind.Cranelift)
export backend_api.backend_for_name

# ============================================================================
# Unified Backend Compilation
# ============================================================================
# High-level functions for compiling MIR modules with selected backends

# compile_module_with_backend - Compile MIR module using specified backend
export backend_api.compile_module_with_backend

# get_effective_backend_name - Get the name of the selected backend after auto-selection
export backend_api.get_effective_backend_name

# ============================================================================
# LLVM Backend Utilities
# ============================================================================
# Helper functions for LLVM-specific operations

# llc_available - Check if LLVM's llc binary is available in PATH
export llvm_backend.llc_available

# ============================================================================
# Memory Space Types
# ============================================================================
# Note: MemorySpace (GPU memory space enum) is defined in compiler.hir_types
# Import as: use compiler.hir_types.{MemorySpace}
# Values: Global, Shared, Local, Constant, Texture
