# Type Mapper - Shared Type Conversion for All Backends
#
# Provides unified interface for mapping MIR types to backend-specific
# type representations. Reduces duplication and ensures consistency.

use compiler.mir_data.*
use compiler.backend_api.*
use compiler.hir_types.MemorySpace

# ============================================================================
# Type Mapper Trait
# ============================================================================

trait TypeMapper:
    """
    Maps MIR types to backend-specific type representations.

    Backends implement this trait to provide their specific type system,
    while inheriting common logic for complex types.

    Example usage:
        val mapper = llvmtypemapper_create()
        val llvm_type = mapper_map_type(mapper, mir_type)
    """

    # === Abstract methods (must implement) ===

    fn map_primitive(ty: PrimitiveType) -> text:
        """
        Map primitive types (i64, f64, bool, etc.).
        Each backend provides its own representation.
        """
        pass  # Must implement

    fn map_pointer(pointee: text, mutability: Mutability) -> text:
        """
        Map pointer types.
        Backends handle pointers differently (opaque vs typed).
        """
        pass  # Must implement

    fn backend_name() -> text:
        """Backend name for error messages."""
        pass  # Must implement

    # === Shared methods (with default implementations) ===

    fn map_type(ty: MirType) -> text:
        """
        Map any MIR type to backend representation.
        Default implementation handles common cases.
        """
        match ty.kind:
            case I64:
                self.map_primitive(ty.kind)

            case I32:
                self.map_primitive(ty.kind)

            case I16:
                self.map_primitive(ty.kind)

            case I8:
                self.map_primitive(ty.kind)

            case F64:
                self.map_primitive(ty.kind)

            case F32:
                self.map_primitive(ty.kind)

            case Bool:
                self.map_primitive(ty.kind)

            case Unit:
                self.map_primitive(ty.kind)

            case Ptr(inner, mutability):
                val inner_ty = self.map_type(inner)
                self.map_pointer(inner_ty, mutability)

            case Struct(fields):
                self.map_struct(fields)

            case Array(element, size):
                self.map_array(element, size)

            case Tuple(elements):
                self.map_tuple(elements)

            case Function(params, ret):
                self.map_function(params, ret)

            case _:
                error("Unsupported type in {self.backend_name()}: {ty}")

    fn map_struct(fields: [(text, MirType)]) -> text:
        """
        Map struct type (default implementation).
        Backends can override for custom struct layouts.
        """
        var field_types: [text] = []
        for f in fields:
            field_types.push(self.map_type(f[1]))
        "struct {{ {field_types.join(', ')} }}"

    fn map_array(element: MirType, size: i64) -> text:
        """Map array type (default implementation)."""
        val elem_ty = self.map_type(element)
        "[{size} x {elem_ty}]"

    fn map_tuple(elements: [MirType]) -> text:
        """Map tuple type (default implementation)."""
        if elements.length == 0:
            "{}"  # Empty tuple
        else:
            var elem_types: [text] = []
            for e in elements:
                elem_types.push(self.map_type(e))
            "{{ {elem_types.join(', ')} }}"

    fn map_function(params: [MirType], ret: MirType) -> text:
        """Map function type (default implementation)."""
        var param_types: [text] = []
        for p in params:
            param_types.push(self.map_type(p))
        val ret_type = self.map_type(ret)
        "{ret_type} ({param_types.join(', ')})"

    # === GPU-specific methods (optional, with defaults) ===

    fn map_memory_space(space: MemorySpace) -> text:
        """
        Map GPU memory space to backend representation.
        Override in GPU backends (CUDA, Vulkan).
        Default returns empty string (no memory space qualifier).
        """
        ""

    fn map_vector_type(elem: text, width: i64) -> text:
        """
        Map SIMD/vector type (e.g., float4, int2).
        Override for backends with native vector support.
        Default returns array representation.
        """
        "[{width} x {elem}]"

    fn supports_half_precision() -> bool:
        """
        Check if backend supports half precision (f16).
        Override in backends with f16 support.
        """
        false

    fn supports_gpu() -> bool:
        """
        Check if backend supports GPU code generation.
        Override in GPU backends.
        """
        false

    # === Helper methods ===

    fn size_of(ty: MirType) -> i64:
        """
        Get size in bytes of a type.
        Default implementation uses target-specific info.
        """
        match ty.kind:
            case I64, F64, Ptr(_, _): 8
            case I32: 4
            case F32: 4
            case I16: 2
            case I8: 1
            case Bool: 1
            case Unit: 0
            case Struct(fields):
                # Sum of field sizes (unpadded)
                var field_sizes_sum: i64 = 0
                for f in fields:
                    field_sizes_sum = field_sizes_sum + self.size_of(f[1])
                field_sizes_sum
            case Array(elem, size):
                self.size_of(elem) * size
            case Tuple(elements):
                var elem_sizes_sum: i64 = 0
                for e in elements:
                    elem_sizes_sum = elem_sizes_sum + self.size_of(e)
                elem_sizes_sum
            case _:
                error("Cannot compute size of {ty}")

    fn align_of(ty: MirType) -> i64:
        """
        Get alignment in bytes of a type.
        Default implementation uses common rules.
        """
        match ty.kind:
            case I64, F64, Ptr(_, _): 8
            case I32: 4
            case F32: 4
            case I16: 2
            case I8: 1
            case Bool: 1
            case Struct(fields):
                # Alignment of struct is max alignment of fields
                if fields.length == 0:
                    1
                else:
                    var max_align: i64 = 1
                    for f in fields:
                        val a = self.align_of(f[1])
                        if a > max_align:
                            max_align = a
                    max_align
            case Array(elem, _):
                self.align_of(elem)
            case Tuple(elements):
                if elements.length == 0:
                    1
                else:
                    var max_elem_align: i64 = 1
                    for e in elements:
                        val a = self.align_of(e)
                        if a > max_elem_align:
                            max_elem_align = a
                    max_elem_align
            case _:
                1  # Default alignment

# ============================================================================
# Primitive Type Enum (for type mapping)
# ============================================================================

enum PrimitiveType:
    I64
    I32
    I16
    I8
    U64     # Unsigned types for GPU
    U32
    U16
    U8
    F64
    F32
    F16     # Half precision (GPU)
    Bool
    Unit

enum Mutability:
    Mutable
    Immutable

# ============================================================================
# Export
# ============================================================================

export TypeMapper, PrimitiveType, Mutability
