# MirTextCodegen Trait - MIR-to-Text Backend Interface
#
# Shared by LLVM, C, Cranelift, and WASM backends.
# Provides default instruction dispatch that decomposes
# translate_instruction into per-category methods.
#
# Backends implement the required category methods; the default
# translate_instruction match handles routing.

use compiler.mir.mir_data.*

# ============================================================================
# MirTextCodegen Trait
# ============================================================================

trait MirTextCodegen:
    """Interface for backends that translate MIR to text-based output."""

    # === Required (each backend implements) ===
    me translate_module(module: MirModule) -> text
    me translate_function(name: text, body: MirBody)
    me translate_block(block: MirBlock)
    me translate_terminator(term: MirTerminator)

    # Per-category instruction methods (required)
    me translate_const(dest: LocalId, value: MirConstValue, ty: MirType)
    me translate_copy_move(dest: LocalId, src: LocalId, is_move: bool)
    me translate_binop(dest: LocalId, op: MirBinOp, left: MirOperand, right: MirOperand)
    me translate_unaryop(dest: LocalId, op: MirUnaryOp, operand: MirOperand)
    me translate_call(dest: LocalId?, func: MirOperand, args: [MirOperand])

    # Helpers (required)
    me translate_operand(operand: MirOperand) -> text
    me translate_const_value(value: MirConstValue) -> text
    fn get_local(id: i64) -> text
    fn get_local_type(id: i64) -> text
    fn get_operand_type(operand: MirOperand) -> text

    # === Default: instruction dispatch ===
    me translate_instruction(inst: MirInst):
        match inst.kind:
            # Core
            case Const(dest, value, ty): self.translate_const(dest, value, ty)
            case Copy(dest, src): self.translate_copy_move(dest, src, false)
            case Move(dest, src): self.translate_copy_move(dest, src, true)
            case BinOp(dest, op, l, r): self.translate_binop(dest, op, l, r)
            case CheckedBinOp(dest, op, l, r): self.translate_binop(dest, op, l, r)
            case UnaryOp(dest, op, operand): self.translate_unaryop(dest, op, operand)

            # Memory
            case Alloc(dest, ty): self.translate_alloc(dest, ty)
            case Load(dest, ptr): self.translate_load(dest, ptr)
            case Store(ptr, value): self.translate_store(ptr, value)
            case GetElementPtr(dest, base, idx): self.translate_gep(dest, base, idx)

            # Aggregates
            case Aggregate(dest, kind, ops): self.translate_aggregate(dest, kind, ops)
            case GetField(dest, base, field): self.translate_get_field(dest, base, field)
            case SetField(base, field, value): self.translate_set_field(base, field, value)

            # Casts
            case Cast(dest, op, target): self.translate_cast(dest, op, target)
            case Bitcast(dest, op, target): self.translate_bitcast(dest, op, target)

            # Calls
            case Call(dest, func, args): self.translate_call(dest, func, args)
            case CallIndirect(dest, ptr, args, sig): self.translate_call_indirect(dest, ptr, args, sig)
            case Intrinsic(dest, name, args): self.translate_intrinsic(dest, name, args)

            # Inline assembly
            case InlineAsm(asm_template, is_volatile, inputs, outputs, clobbers):
                self.translate_inline_asm(asm_template, is_volatile, inputs, outputs, clobbers)

            # Pipeline operators
            case PipeForward(dest, v, f): self.translate_pipe_forward(dest, v, f)
            case Compose(dest, f, g, fwd): self.translate_compose(dest, f, g, fwd)
            case Parallel(dest, funcs): self.translate_parallel(dest, funcs)
            case LayerConnect(dest, l1, l2): self.translate_layer_connect(dest, l1, l2)

            # Borrow checking
            case Ref(dest, kind, place): self.translate_ref(dest, kind, place)

            # Async/Actor
            case CreatePromise(dest, body, result_type): self.translate_create_promise(dest, body, result_type)
            case Await(dest, promise): self.translate_await(dest, promise)
            case Yield(value): self.translate_yield(value)
            case Spawn(dest, handler, args): self.translate_spawn(dest, handler, args)
            case Send(target, message): self.translate_send(target, message)
            case Receive(dest, timeout): self.translate_receive(dest, timeout)

            # GPU
            case GpuKernelDef(name): self.translate_gpu_kernel_def(name)
            case GpuLaunch(args): self.translate_gpu_launch(args)
            case GpuGlobalId(dest, dim): self.translate_gpu_global_id(dest, dim)
            case GpuLocalId(dest, dim): self.translate_gpu_local_id(dest, dim)
            case GpuBlockId(dest, dim): self.translate_gpu_block_id(dest, dim)
            case GpuBlockDim(dest, dim): self.translate_gpu_block_dim(dest, dim)
            case GpuGridDim(dest, dim): self.translate_gpu_grid_dim(dest, dim)
            case GpuBarrier(scope): self.translate_gpu_barrier(scope)
            case GpuMemFence(scope): self.translate_gpu_mem_fence(scope)
            case GpuSharedAlloc(dest, type_, size): self.translate_gpu_shared_alloc(dest, type_, size)
            case GpuAtomicOp(dest, op, ptr, value): self.translate_gpu_atomic_op(dest, op, ptr, value)

            # VHDL
            case VhdlProcess(kind, body_block): self.translate_vhdl_process(kind, body_block)
            case VhdlSignalAssign(target, value, delay_ns): self.translate_vhdl_signal_assign(target, value, delay_ns)
            case VhdlVarAssign(target, value): self.translate_vhdl_var_assign(target, value)
            case VhdlPortMap(entity, instance, connections): self.translate_vhdl_port_map(entity, instance, connections)
            case VhdlResize(dest, operand, new_width, signed): self.translate_vhdl_resize(dest, operand, new_width, signed)
            case VhdlSlice(dest, signal, hi, lo): self.translate_vhdl_slice(dest, signal, hi, lo)
            case VhdlConcat(dest, parts): self.translate_vhdl_concat(dest, parts)

            # SIMD - f32x4 (128-bit)
            case SimdAddF32x4(dest, a, b): self.translate_simd_binop(dest, a, b, "add_f32x4")
            case SimdSubF32x4(dest, a, b): self.translate_simd_binop(dest, a, b, "sub_f32x4")
            case SimdMulF32x4(dest, a, b): self.translate_simd_binop(dest, a, b, "mul_f32x4")
            case SimdDivF32x4(dest, a, b): self.translate_simd_binop(dest, a, b, "div_f32x4")
            case SimdFmaF32x4(dest, a, b, c): self.translate_simd_fma(dest, a, b, c, "fma_f32x4")
            # SIMD - f32x8 (256-bit)
            case SimdAddF32x8(dest, a, b): self.translate_simd_binop(dest, a, b, "add_f32x8")
            case SimdSubF32x8(dest, a, b): self.translate_simd_binop(dest, a, b, "sub_f32x8")
            case SimdMulF32x8(dest, a, b): self.translate_simd_binop(dest, a, b, "mul_f32x8")
            case SimdDivF32x8(dest, a, b): self.translate_simd_binop(dest, a, b, "div_f32x8")
            case SimdFmaF32x8(dest, a, b, c): self.translate_simd_fma(dest, a, b, c, "fma_f32x8")
            # SIMD - f64x4 (256-bit)
            case SimdAddF64x4(dest, a, b): self.translate_simd_binop(dest, a, b, "add_f64x4")
            case SimdSubF64x4(dest, a, b): self.translate_simd_binop(dest, a, b, "sub_f64x4")
            case SimdMulF64x4(dest, a, b): self.translate_simd_binop(dest, a, b, "mul_f64x4")
            case SimdDivF64x4(dest, a, b): self.translate_simd_binop(dest, a, b, "div_f64x4")
            case SimdFmaF64x4(dest, a, b, c): self.translate_simd_fma(dest, a, b, c, "fma_f64x4")
            # SIMD - i32x4 (128-bit)
            case SimdAddI32x4(dest, a, b): self.translate_simd_binop(dest, a, b, "add_i32x4")
            case SimdSubI32x4(dest, a, b): self.translate_simd_binop(dest, a, b, "sub_i32x4")
            case SimdMulI32x4(dest, a, b): self.translate_simd_binop(dest, a, b, "mul_i32x4")
            # SIMD - i32x8 (256-bit)
            case SimdAddI32x8(dest, a, b): self.translate_simd_binop(dest, a, b, "add_i32x8")
            case SimdSubI32x8(dest, a, b): self.translate_simd_binop(dest, a, b, "sub_i32x8")
            case SimdMulI32x8(dest, a, b): self.translate_simd_binop(dest, a, b, "mul_i32x8")
            # SIMD - horizontal
            case SimdHaddF32x4(dest, a): self.translate_simd_horizontal(dest, a, "hadd_f32x4")
            case SimdHmaxF32x4(dest, a): self.translate_simd_horizontal(dest, a, "hmax_f32x4")
            case SimdHminF32x4(dest, a): self.translate_simd_horizontal(dest, a, "hmin_f32x4")

            # Debug/Nop
            case DebugValue(_, _): ()
            case Nop: ()

            case _: self.translate_unsupported(inst)

    # === Default stubs — memory/aggregate/cast (overridable per-backend) ===
    me translate_alloc(dest: LocalId, ty: MirType):
        ()
    me translate_load(dest: LocalId, ptr: MirOperand):
        ()
    me translate_store(ptr: MirOperand, value: MirOperand):
        ()
    me translate_gep(dest: LocalId, base: MirOperand, indices: [MirOperand]):
        ()
    me translate_aggregate(dest: LocalId, kind: AggregateKind, ops: [MirOperand]):
        ()
    me translate_get_field(dest: LocalId, base: MirOperand, field: i64):
        ()
    me translate_set_field(base: MirOperand, field: i64, value: MirOperand):
        ()
    me translate_cast(dest: LocalId, op: MirOperand, target: MirType):
        ()
    me translate_bitcast(dest: LocalId, op: MirOperand, target: MirType):
        ()
    me translate_call_indirect(dest: LocalId?, ptr: MirOperand, args: [MirOperand], sig: MirSignature):
        ()
    me translate_intrinsic(dest: LocalId?, name: text, args: [MirOperand]):
        ()
    me translate_inline_asm(asm_template: text, is_volatile: bool, inputs: [MirAsmOperand], outputs: [MirAsmOperand], clobbers: [text]):
        ()

    # === Default stubs — pipeline operators ===
    me translate_pipe_forward(dest: LocalId, value: MirOperand, func: MirOperand):
        ()
    me translate_compose(dest: LocalId, f: MirOperand, g: MirOperand, forward: bool):
        ()
    me translate_parallel(dest: LocalId, funcs: [MirOperand]):
        ()
    me translate_layer_connect(dest: LocalId, l1: MirOperand, l2: MirOperand):
        ()

    # === Default stubs — borrow checking ===
    me translate_ref(dest: LocalId, kind: MirBorrowKind, place: MirPlace):
        ()

    # === Default stubs — async/actor ===
    me translate_create_promise(dest: LocalId, body: LocalId, result_type: MirType):
        ()
    me translate_await(dest: LocalId, promise: MirOperand):
        ()
    me translate_yield(value: MirOperand?):
        ()
    me translate_spawn(dest: LocalId, handler: MirOperand, args: [MirOperand]):
        ()
    me translate_send(target: MirOperand, message: MirOperand):
        ()
    me translate_receive(dest: LocalId, timeout: MirOperand?):
        ()

    # === Default stubs — GPU ===
    me translate_gpu_kernel_def(name: text):
        ()
    me translate_gpu_launch(args: [text]):
        ()
    me translate_gpu_global_id(dest: LocalId, dim: i64):
        ()
    me translate_gpu_local_id(dest: LocalId, dim: i64):
        ()
    me translate_gpu_block_id(dest: LocalId, dim: i64):
        ()
    me translate_gpu_block_dim(dest: LocalId, dim: i64):
        ()
    me translate_gpu_grid_dim(dest: LocalId, dim: i64):
        ()
    me translate_gpu_barrier(scope: GpuBarrierScope):
        ()
    me translate_gpu_mem_fence(scope: GpuMemoryScope):
        ()
    me translate_gpu_shared_alloc(dest: LocalId, type_: MirType, size: i64):
        ()
    me translate_gpu_atomic_op(dest: LocalId, op: GpuAtomicOpKind, ptr: MirOperand, value: MirOperand):
        ()

    # === Default stubs — VHDL ===
    me translate_vhdl_process(kind: VhdlProcessKind, body_block: BlockId):
        ()
    me translate_vhdl_signal_assign(target: MirOperand, value: MirOperand, delay_ns: i64?):
        ()
    me translate_vhdl_var_assign(target: MirOperand, value: MirOperand):
        ()
    me translate_vhdl_port_map(entity: text, instance: text, connections: [(text, MirOperand)]):
        ()
    me translate_vhdl_resize(dest: LocalId, operand: MirOperand, new_width: i64, signed: bool):
        ()
    me translate_vhdl_slice(dest: LocalId, signal: MirOperand, hi: i64, lo: i64):
        ()
    me translate_vhdl_concat(dest: LocalId, parts: [MirOperand]):
        ()

    # === Default stubs — SIMD ===
    me translate_simd_binop(dest: LocalId, a: MirOperand, b: MirOperand, op_name: text):
        ()
    me translate_simd_fma(dest: LocalId, a: MirOperand, b: MirOperand, c: MirOperand, op_name: text):
        ()
    me translate_simd_horizontal(dest: LocalId, a: MirOperand, op_name: text):
        ()

    # === Default stubs — misc ===
    me translate_stub(dest: LocalId, name: text):
        ()
    me translate_unsupported(inst: MirInst):
        ()

# ============================================================================
# Exports
# ============================================================================

export MirTextCodegen
