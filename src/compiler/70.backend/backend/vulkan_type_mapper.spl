# Vulkan Type Mapper - Vulkan/SPIR-V-Specific Type Mapping Implementation
#
# Maps MIR types to SPIR-V type strings/opcodes.
# Implements TypeMapper trait for Vulkan backend.

use compiler.mir.mir_data.*
use compiler.backend.common.type_mapper.*
use compiler.hir.hir_types.MemorySpace

# ============================================================================
# Vulkan Type Mapper
# ============================================================================

class VulkanTypeMapper:
    """
    Maps MIR types to SPIR-V type representations.

    SPIR-V uses typed opcodes:
    - OpTypeInt width signed (e.g., OpTypeInt 32 1)
    - OpTypeFloat width (e.g., OpTypeFloat 32)
    - OpTypeBool
    - OpTypeVoid
    - OpTypePointer storage_class type

    Storage classes for memory:
    - StorageBuffer: Device global memory (SSBO)
    - Workgroup: Shared memory
    - Function: Thread-local
    - Uniform: Uniform buffer
    - PushConstant: Push constants

    Example mappings:
        I32 → "OpTypeInt 32 1"
        F32 → "OpTypeFloat 32"
        Bool → "OpTypeBool"
    """

    vulkan_version: (i64, i64)  # e.g., (1, 3) for Vulkan 1.3
    spirv_version: (i64, i64)   # e.g., (1, 6) for SPIR-V 1.6

    static fn create() -> VulkanTypeMapper:
        """Create mapper for Vulkan 1.3 / SPIR-V 1.6 (default)."""
        VulkanTypeMapper(
            vulkan_version: (1, 3),
            spirv_version: (1, 6)
        )

    static fn create_version(vk_major: i64, vk_minor: i64, spv_major: i64, spv_minor: i64) -> VulkanTypeMapper:
        """Create mapper for specific Vulkan/SPIR-V versions."""
        VulkanTypeMapper(
            vulkan_version: (vk_major, vk_minor),
            spirv_version: (spv_major, spv_minor)
        )

impl TypeMapper for VulkanTypeMapper:
    fn map_primitive(ty: PrimitiveType) -> text:
        """
        Map primitive types to SPIR-V type opcodes.

        SPIR-V type opcodes:
        - OpTypeInt width signed (1=signed, 0=unsigned)
        - OpTypeFloat width
        - OpTypeBool
        - OpTypeVoid
        """
        match ty:
            case I64: "OpTypeInt 64 1"
            case I32: "OpTypeInt 32 1"
            case I16: "OpTypeInt 16 1"
            case I8: "OpTypeInt 8 1"
            case U64: "OpTypeInt 64 0"
            case U32: "OpTypeInt 32 0"
            case U16: "OpTypeInt 16 0"
            case U8: "OpTypeInt 8 0"
            case F64: "OpTypeFloat 64"
            case F32: "OpTypeFloat 32"
            case F16: "OpTypeFloat 16"
            case Bool: "OpTypeBool"
            case Unit: "OpTypeVoid"

    fn map_pointer(pointee: text, mutability: Mutability) -> text:
        """
        Map pointer types to SPIR-V representation.

        SPIR-V pointers include storage class:
        OpTypePointer StorageClass Type
        """
        # Default to StorageBuffer for global pointers
        "OpTypePointer StorageBuffer {pointee}"

    fn backend_name() -> text:
        "Vulkan/SPIR-V"

    fn map_memory_space(space: MemorySpace) -> text:
        """
        Map GPU memory space to SPIR-V storage class.

        SPIR-V storage classes:
        - StorageBuffer: Device global memory (SSBO)
        - Workgroup: Shared memory
        - Function: Thread-local
        - Uniform: Uniform buffer (read-only)
        - PushConstant: Push constants
        """
        match space:
            case Global: "StorageBuffer"
            case Shared: "Workgroup"
            case Local: "Function"
            case Constant: "Uniform"
            case Uniform: "Uniform"

    fn map_vector_type(elem: text, width: i64) -> text:
        """
        Map SIMD/vector type to SPIR-V vector type.

        SPIR-V: OpTypeVector component_type component_count
        Valid widths: 2, 3, 4 (8, 16 with extensions)
        """
        if width >= 2 and width <= 4:
            "OpTypeVector {elem} {width}"
        else:
            # Fallback to array for non-standard widths
            "OpTypeArray {elem} {width}"

    fn supports_half_precision() -> bool:
        """
        Check if SPIR-V supports half precision.
        Requires Float16 capability.
        """
        true  # Modern Vulkan/SPIR-V supports f16

    fn supports_gpu() -> bool:
        true

impl VulkanTypeMapper:
    # === SPIR-V-specific methods ===

    fn map_struct(fields: [(text, MirType)]) -> text:
        """
        Map struct type to SPIR-V representation.

        SPIR-V: OpTypeStruct member_types...
        """
        val field_types = fields.map(\f: self.map_type(f.1))
        "OpTypeStruct {field_types.join(' ')}"

    fn map_array(element: MirType, size: i64) -> text:
        """
        Map array type to SPIR-V representation.

        SPIR-V: OpTypeArray element_type length
        """
        val elem_ty = self.map_type(element)
        "OpTypeArray {elem_ty} {size}"

    fn map_runtime_array(element: MirType) -> text:
        """
        Map runtime array (unsized) to SPIR-V representation.

        SPIR-V: OpTypeRuntimeArray element_type
        Used for SSBOs with dynamic size.
        """
        val elem_ty = self.map_type(element)
        "OpTypeRuntimeArray {elem_ty}"

    fn map_tuple(elements: [MirType]) -> text:
        """
        Map tuple type to SPIR-V struct representation.

        SPIR-V doesn't have tuples, use struct.
        """
        if elements.length == 0:
            "OpTypeStruct"
        else:
            val elem_types = elements.map(\e: self.map_type(e))
            "OpTypeStruct {elem_types.join(' ')}"

    fn map_function(params: [MirType], ret: MirType) -> text:
        """
        Map function type to SPIR-V function type.

        SPIR-V: OpTypeFunction return_type param_types...
        """
        val param_types = params.map(\p: self.map_type(p))
        val ret_type = self.map_type(ret)
        "OpTypeFunction {ret_type} {param_types.join(' ')}"

    fn map_image_type(dim: SpirvImageDim, sampled: bool, depth: bool) -> text:
        """
        Map image type to SPIR-V.

        SPIR-V: OpTypeImage sampled_type dim depth arrayed ms sampled format
        """
        val dim_str = match dim:
            case Dim1D: "Dim1D"
            case Dim2D: "Dim2D"
            case Dim3D: "Dim3D"
            case DimCube: "DimCube"
            case DimBuffer: "DimBuffer"
        val depth_val = if depth: 1 else: 0
        val sampled_val = if sampled: 1 else: 2
        "OpTypeImage OpTypeFloat 32 {dim_str} {depth_val} 0 {sampled_val} Unknown"

    fn map_sampler_type() -> text:
        """Map sampler type to SPIR-V."""
        "OpTypeSampler"

    fn map_sampled_image_type(image_type: text) -> text:
        """Map sampled image (combined image+sampler) to SPIR-V."""
        "OpTypeSampledImage {image_type}"

    fn pointer_with_storage(pointee: text, storage: MemorySpace) -> text:
        """
        Create pointer type with specific storage class.

        SPIR-V: OpTypePointer storage_class pointee_type
        """
        val storage_class = self.map_memory_space(storage)
        "OpTypePointer {storage_class} {pointee}"

    fn spirv_builtin(builtin: SpirvBuiltin) -> text:
        """
        Get SPIR-V builtin name.

        Used for decorating special input/output variables.
        """
        match builtin:
            case GlobalInvocationId: "GlobalInvocationId"
            case LocalInvocationId: "LocalInvocationId"
            case WorkgroupId: "WorkgroupId"
            case WorkgroupSize: "WorkgroupSize"
            case NumWorkgroups: "NumWorkgroups"
            case SubgroupId: "SubgroupId"
            case SubgroupSize: "SubgroupSize"
            case SubgroupLocalInvocationId: "SubgroupLocalInvocationId"

    fn spirv_execution_model() -> text:
        """Get execution model for compute shaders."""
        "GLCompute"

    fn spirv_capability_for_feature(feature: SpirvFeature) -> text:
        """Get SPIR-V capability for a feature."""
        match feature:
            case Float16: "Float16"
            case Float64: "Float64"
            case Int64: "Int64"
            case Int16: "Int16"
            case Int8: "Int8"
            case StorageBuffer8BitAccess: "StorageBuffer8BitAccess"
            case StorageBuffer16BitAccess: "StorageBuffer16BitAccess"
            case Subgroup: "GroupNonUniform"
            case AtomicFloat: "AtomicFloat32AddEXT"

    fn required_capabilities() -> [text]:
        """Get list of required SPIR-V capabilities."""
        ["Shader"]

    fn required_extensions() -> [text]:
        """Get list of required SPIR-V extensions."""
        []

    fn max_workgroup_size() -> (i64, i64, i64):
        """
        Get maximum workgroup size.
        Default Vulkan limit is typically 1024 total invocations.
        """
        (1024, 1024, 64)

    fn max_workgroup_invocations() -> i64:
        """Get maximum total invocations per workgroup."""
        1024

    fn max_shared_memory() -> i64:
        """
        Get maximum shared memory per workgroup in bytes.
        Typical Vulkan limit is 32KB-64KB.
        """
        49152  # 48 KB (common minimum)

    fn subgroup_size() -> i64:
        """
        Get subgroup size (wave/warp equivalent).
        Varies by vendor: NVIDIA=32, AMD=32/64, Intel=8-32.
        """
        32  # Conservative default

    # === Size and alignment (SPIR-V/Vulkan rules) ===

    fn size_of(ty: MirType) -> i64:
        """
        Get size in bytes of a type (Vulkan std430 layout rules).
        """
        match ty.kind:
            case I64 | U64 | F64: 8
            case I32 | U32 | F32: 4
            case I16 | U16: 2
            case I8 | U8 | Bool: 1
            case Unit: 0
            case Ptr(_, _): 8  # 64-bit logical pointers
            case Struct(fields):
                # std430 layout with padding
                var offset = 0
                for f in fields:
                    val align = self.align_of(f.1)
                    offset = ((offset + align - 1) / align) * align
                    offset = offset + self.size_of(f.1)
                offset
            case Array(elem, size):
                val elem_size = self.size_of(elem)
                val elem_align = self.align_of(elem)
                val stride = ((elem_size + elem_align - 1) / elem_align) * elem_align
                stride * size
            case Tuple(elements):
                elements.map(\e: self.size_of(e)).sum()
            case _:
                error("Cannot compute size of {ty}")

    fn align_of(ty: MirType) -> i64:
        """
        Get alignment in bytes of a type (Vulkan std430 layout rules).
        """
        match ty.kind:
            case I64 | U64 | F64 | Ptr(_, _): 8
            case I32 | U32 | F32: 4
            case I16 | U16: 2
            case I8 | U8 | Bool: 1
            case Struct(fields):
                if fields.length == 0:
                    1
                else:
                    # Struct alignment is largest member alignment
                    fields.map(\f: self.align_of(f.1)).max()
            case Array(elem, _):
                # Array alignment is element alignment (std430)
                self.align_of(elem)
            case Tuple(elements):
                if elements.length == 0:
                    1
                else:
                    elements.map(\e: self.align_of(e)).max()
            case _:
                1

# ============================================================================
# SPIR-V Support Types
# ============================================================================

"""SPIR-V image dimensions."""
enum SpirvImageDim:
    Dim1D
    Dim2D
    Dim3D
    DimCube
    DimBuffer

"""SPIR-V builtin variables."""
enum SpirvBuiltin:
    GlobalInvocationId
    LocalInvocationId
    WorkgroupId
    WorkgroupSize
    NumWorkgroups
    SubgroupId
    SubgroupSize
    SubgroupLocalInvocationId

"""SPIR-V features requiring capabilities."""
enum SpirvFeature:
    Float16
    Float64
    Int64
    Int16
    Int8
    StorageBuffer8BitAccess
    StorageBuffer16BitAccess
    Subgroup
    AtomicFloat

# ============================================================================
# Export
# ============================================================================

export VulkanTypeMapper
export SpirvImageDim, SpirvBuiltin, SpirvFeature
