# C/C++ Type Mapper - C Backend Type Mapping Implementation
#
# Maps MIR types to C++20 type strings for the C backend.
# Implements TypeMapper trait, following the pattern of llvm_type_mapper.spl.
# Generated code links against runtime.h (spl_ prefix functions).

use compiler.mir_data.*
use compiler.backend.common.type_mapper.*

# ============================================================================
# C Type Mapper
# ============================================================================

class CTypeMapper:
    """
    Maps MIR types to C++20 type representations.

    C++ type mappings:
        I64 -> "int64_t"
        I32 -> "int32_t"
        I16 -> "int16_t"
        I8  -> "int8_t"
        F64 -> "double"
        F32 -> "float"
        Bool -> "int64_t"  (runtime uses i64 for bools)
        Unit -> "void"
        Ptr  -> "void*"    (opaque pointers, like runtime)
    """

    target_bits: i64

    static fn create() -> CTypeMapper:
        CTypeMapper(target_bits: 64)

    static fn create_for_target(target: CodegenTarget) -> CTypeMapper:
        if target.is_32bit():
            CTypeMapper(target_bits: 32)
        else:
            CTypeMapper(target_bits: 64)

impl TypeMapper for CTypeMapper:
    fn map_primitive(ty: PrimitiveType) -> text:
        match ty:
            case I64: "int64_t"
            case I32: "int32_t"
            case I16: "int16_t"
            case I8: "int8_t"
            case F64: "double"
            case F32: "float"
            case Bool: "int64_t"
            case Unit: "void"

    fn map_pointer(pointee: text, mutability: Mutability) -> text:
        "void*"

    fn backend_name() -> text:
        "C"

impl CTypeMapper:
    fn map_type(ty: MirType) -> text:
        match ty.kind:
            case I64: "int64_t"
            case I32: "int32_t"
            case I16: "int16_t"
            case I8: "int8_t"
            case U64: "uint64_t"
            case U32: "uint32_t"
            case U16: "uint16_t"
            case U8: "uint8_t"
            case F64: "double"
            case F32: "float"
            case Bool: "int64_t"
            case Unit: "void"
            case Char: "int16_t"
            case Ptr(_, _): "void*"
            case Ref(_, _): "void*"
            case FuncPtr(_): "void*"
            case Array(elem, size):
                val elem_ty = self.map_type(elem)
                "spl_array_t*"
            case Slice(_): "spl_array_t*"
            case Tuple(elements):
                if elements.len() == 0:
                    "void"
                else:
                    "spl_tuple_t*"
            case Struct(_): "void*"
            case Enum(_): "int64_t"
            case Never: "void"
            case Opaque(_): "void*"
            case Promise(_): "void*"
            case Generator(_, _): "void*"
            case ActorType(_): "void*"
            case _: "int64_t"

    fn map_return_type(ty: MirType) -> text:
        match ty.kind:
            case Unit: "void"
            case _: self.map_type(ty)

    fn size_of(ty: MirType) -> i64:
        match ty.kind:
            case I64, U64, F64: 8
            case I32, U32, F32: 4
            case I16, U16, Char: 2
            case I8, U8, Bool: 1
            case Unit: 0
            case Ptr(_, _), Ref(_, _), FuncPtr(_):
                self.target_bits / 8
            case Array(elem, size): self.size_of(elem) * size
            case _: 8

    fn align_of(ty: MirType) -> i64:
        match ty.kind:
            case I64, U64, F64: 8
            case I32, U32, F32: 4
            case I16, U16, Char: 2
            case I8, U8, Bool: 1
            case Ptr(_, _), Ref(_, _), FuncPtr(_):
                self.target_bits / 8
            case _: 8

# ============================================================================
# Export
# ============================================================================

fn CTypeMapper__create() -> CTypeMapper:
    CTypeMapper.create()

fn CTypeMapper__create_for_target(target: CodegenTarget) -> CTypeMapper:
    CTypeMapper.create_for_target(target)

export CTypeMapper
export CTypeMapper__create, CTypeMapper__create_for_target
