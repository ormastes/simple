# C Backend - Instruction Translation Methods
#
# Per-category instruction translation methods for the MirTextCodegen trait.
# Includes: const, copy/move, binop, unaryop, call, operand/const helpers,
# memory, aggregates, casts, indirect calls, intrinsics, inline asm,
# pipeline operators, and borrow checking.
#
# Split from c_backend.spl - these are all `impl MirTextCodegen for MirToC`.

use compiler.mir.mir_data.*
use compiler.backend.c_type_mapper.{CTypeMapper, CTypeMapper__create, CTypeMapper__create_for_target}
use compiler.backend.c_ir_builder.{CIRBuilder, CIRBuilder__create, escape_c_string}
use compiler.backend.common.mir_text_codegen.MirTextCodegen
use compiler.core.backend_types.{CodegenTarget, CompileOptions, CompiledModule}

# ============================================================================
# Per-Category Instruction Methods
# ============================================================================

impl MirTextCodegen for MirToC:

    me translate_const(dest: LocalId, value: MirConstValue, ty: MirType):
        if self.translate_composite_const(dest, value):
            pass_dn
        else:
            self.emit_str_cleanup(dest.id)
            val dest_name = self.get_local(dest.id)
            val const_val = self.translate_const_value(value)
            if self.is_str_local(dest.id):
                self.builder.emit_assign(dest_name, r"spl_strdup(" + const_val + r")")
            else:
                self.builder.emit_assign(dest_name, const_val)

    me translate_copy_move(dest: LocalId, src: LocalId, is_move: bool):
        self.emit_str_cleanup(dest.id)
        val dest_name = self.get_local(dest.id)
        val src_name = self.get_local(src.id)
        if self.is_str_local(dest.id) and self.is_str_local(src.id):
            if is_move:
                self.builder.emit_assign(dest_name, src_name)
                self.builder.emit_assign(src_name, "nullptr")
            else:
                self.builder.emit_assign(dest_name, r"spl_strdup(" + src_name + r")")
        else:
            self.builder.emit_assign(dest_name, src_name)

    me translate_binop(dest: LocalId, op: MirBinOp, left: MirOperand, right: MirOperand):
        val dest_name = self.get_local(dest.id)
        val left_val = self.translate_operand(left)
        val right_val = self.translate_operand(right)
        val ty = self.get_local_type(dest.id)
        val left_ty = self.get_operand_type(left)

        match op:
            case Add:
                if left_ty == "const char*" or ty == "const char*":
                    self.emit_str_cleanup(dest.id)
                    self.builder.emit_assign(dest_name, r"spl_str_concat(" + left_val + r", " + right_val + r")")
                else:
                    self.builder.emit_binop(dest_name, ty, "+", left_val, right_val)
            case Sub:
                self.builder.emit_binop(dest_name, ty, "-", left_val, right_val)
            case Mul:
                self.builder.emit_binop(dest_name, ty, "*", left_val, right_val)
            case Div:
                self.builder.emit_binop(dest_name, ty, "/", left_val, right_val)
            case Rem:
                self.builder.emit_binop(dest_name, ty, "%", left_val, right_val)
            case Pow:
                self.builder.emit_comment("pow")
                self.builder.emit_assign(dest_name, r"(" + ty + r")__simple_pow(" + left_val + r", " + right_val + r")")
            case BitAnd:
                self.builder.emit_binop(dest_name, ty, "&", left_val, right_val)
            case BitOr:
                self.builder.emit_binop(dest_name, ty, "|", left_val, right_val)
            case BitXor:
                self.builder.emit_binop(dest_name, ty, "^", left_val, right_val)
            case Shl:
                self.builder.emit_binop(dest_name, ty, "<<", left_val, right_val)
            case Shr:
                self.builder.emit_binop(dest_name, ty, ">>", left_val, right_val)
            case Eq:
                if left_ty == "const char*":
                    self.builder.emit_assign(dest_name, r"(int64_t)spl_str_eq(" + left_val + r", " + right_val + r")")
                else:
                    self.builder.emit_cmp(dest_name, ty, "==", left_val, right_val)
            case Ne:
                if left_ty == "const char*":
                    self.builder.emit_assign(dest_name, r"(int64_t)(!spl_str_eq(" + left_val + r", " + right_val + r"))")
                else:
                    self.builder.emit_cmp(dest_name, ty, "!=", left_val, right_val)
            case Lt:
                self.builder.emit_cmp(dest_name, ty, "<", left_val, right_val)
            case Le:
                self.builder.emit_cmp(dest_name, ty, "<=", left_val, right_val)
            case Gt:
                self.builder.emit_cmp(dest_name, ty, ">", left_val, right_val)
            case Ge:
                self.builder.emit_cmp(dest_name, ty, ">=", left_val, right_val)
            case MatMul:
                self.builder.emit_assign(dest_name, r"(void*)__simple_runtime_matmul((void*)" + left_val + r", (void*)" + right_val + r")")
            case BroadcastAdd:
                self.builder.emit_assign(dest_name, r"(void*)__simple_runtime_broadcast_add((void*)" + left_val + r", (void*)" + right_val + r")")
            case BroadcastSub:
                self.builder.emit_assign(dest_name, r"(void*)__simple_runtime_broadcast_sub((void*)" + left_val + r", (void*)" + right_val + r")")
            case BroadcastMul:
                self.builder.emit_assign(dest_name, r"(void*)__simple_runtime_broadcast_mul((void*)" + left_val + r", (void*)" + right_val + r")")
            case BroadcastDiv:
                self.builder.emit_assign(dest_name, r"(void*)__simple_runtime_broadcast_div((void*)" + left_val + r", (void*)" + right_val + r")")
            case BroadcastPow:
                self.builder.emit_assign(dest_name, r"(void*)__simple_runtime_broadcast_pow((void*)" + left_val + r", (void*)" + right_val + r")")
            case Offset:
                self.builder.emit_assign(dest_name, r"(int64_t)((char*)(intptr_t)" + left_val + r" + " + right_val + r")")

    me translate_unaryop(dest: LocalId, op: MirUnaryOp, operand: MirOperand):
        val dest_name = self.get_local(dest.id)
        val operand_val = self.translate_operand(operand)
        val ty = self.get_local_type(dest.id)

        match op:
            case Neg:
                self.builder.emit_unaryop(dest_name, ty, "-", operand_val)
            case Not:
                self.builder.emit_cmp(dest_name, ty, "==", operand_val, "0")
            case BitNot:
                self.builder.emit_unaryop(dest_name, ty, "~", operand_val)
            case Transpose:
                self.builder.emit_assign(dest_name, r"(void*)__simple_runtime_transpose((void*)" + operand_val + r")")

    me translate_call(dest: LocalId?, func: MirOperand, args: [MirOperand]):
        val func_val = self.translate_operand(func)
        if self.translate_container_call(func_val, dest, args):
            pass_dn
        else:
            var arg_vals: [text] = []
            for arg in args:
                arg_vals = arg_vals.push(self.translate_operand(arg))
            val args_str = arg_vals.join(", ")
            if dest.?:
                self.emit_str_cleanup(dest.unwrap().id)
                val dest_name = self.get_local(dest.unwrap().id)
                val ret_ty = self.get_local_type(dest.unwrap().id)
                self.builder.emit_assign(dest_name, func_val + r"(" + args_str + r")")
            else:
                self.builder.emit(func_val + r"(" + args_str + r");")

    # === Helpers ===

    me translate_operand(operand: MirOperand) -> text:
        match operand.kind:
            case Copy(local):
                self.get_local(local)
            case Move(local):
                self.get_local(local)
            case Const(value, type_):
                self.translate_const_value(value)

    me translate_const_value(value: MirConstValue) -> text:
        match value:
            case Int(v): r"" + v
            case Float(v): r"" + v
            case Bool(v): if v: "1" else: "0"
            case Str(v):
                val var_name = self.builder.add_string_literal(v)
                r"(const char*)" + var_name
            case Zero: "0"
            case Array(elements):
                if elements.len() == 0:
                    "0 /* empty array */"
                else:
                    var init_vals: [text] = []
                    for elem in elements:
                        init_vals = init_vals.push(self.const_to_i64_expr(elem))
                    r"([]() -> int64_t { static int64_t v[" + elements.len() + r"] = {" + init_vals.join(", ") + r"}; return (int64_t)(intptr_t)v; }())"
            case Tuple(elements):
                if elements.len() == 0:
                    "0 /* empty tuple */"
                else:
                    var init_vals: [text] = []
                    for elem in elements:
                        init_vals = init_vals.push(self.const_to_i64_expr(elem))
                    r"([]() -> int64_t { static int64_t v[" + elements.len() + r"] = {" + init_vals.join(", ") + r"}; return (int64_t)(intptr_t)v; }())"
            case Struct(fields):
                if fields.len() == 0:
                    "0 /* empty struct */"
                else:
                    var init_vals: [text] = []
                    for field_name, field_val in fields:
                        init_vals = init_vals.push(self.const_to_i64_expr(field_val))
                    r"([]() -> int64_t { static int64_t v[" + fields.len() + r"] = {" + init_vals.join(", ") + r"}; return (int64_t)(intptr_t)v; }())"

    fn get_local(id: i64) -> text:
        r"_l" + id

    fn get_local_type(id: i64) -> text:
        match self.local_types.get(id):
            case Some(ty): ty
            case nil: "int64_t"

    fn get_operand_type(operand: MirOperand) -> text:
        match operand.kind:
            case Copy(local): self.get_local_type(local)
            case Move(local): self.get_local_type(local)
            case Const(value, type_): self.type_mapper.map_type(type_)

    # === Memory Overrides ===

    me translate_alloc(dest: LocalId, ty: MirType):
        val size = self.type_mapper.size_of(ty)
        val slot_name = self.ensure_stack_slot(dest.id, size)
        self.emit_pointer_assign(dest.id, slot_name)

    me translate_load(dest: LocalId, ptr: MirOperand):
        val dest_name = self.get_local(dest.id)
        val ptr_val = self.translate_operand(ptr)
        val ty = self.get_local_type(dest.id)
        self.builder.emit_assign(dest_name, r"*(" + ty + r"*)" + ptr_val)

    me translate_store(ptr: MirOperand, value: MirOperand):
        val ptr_val = self.translate_operand(ptr)
        val value_val = self.translate_operand(value)
        val ty = self.get_operand_type(value)
        self.builder.emit(r"*(" + ty + r"*)" + ptr_val + r" = " + value_val + r";")

    me translate_gep(dest: LocalId, base: MirOperand, indices: [MirOperand]):
        val dest_name = self.get_local(dest.id)
        val base_val = self.translate_operand(base)
        if indices.len() == 1:
            val idx_val = self.translate_operand(indices[0])
            self.builder.emit_assign(dest_name, r"(void*)((char*)" + base_val + r" + " + idx_val + r" * 8)")
        else:
            self.builder.emit_assign(dest_name, r"(void*)" + base_val)
            self.builder.emit_comment(r"GEP with " + indices.len() + r" indices")

    # === Aggregate Overrides ===

    me translate_aggregate(dest: LocalId, kind: AggregateKind, operands: [MirOperand]):
        val num_fields = operands.len()
        val byte_size = num_fields * 8
        val slot_name = self.ensure_stack_slot(dest.id, byte_size)
        self.builder.emit_comment(r"aggregate construction (" + num_fields + r" fields, " + byte_size + r" bytes) [stack slot]")
        self.emit_pointer_assign(dest.id, slot_name)
        var field_idx = 0
        for op in operands:
            val field_val = self.translate_operand(op)
            self.builder.emit(r"((int64_t*)(void*)" + slot_name + r")[" + field_idx + r"] = (int64_t)" + field_val + r";")
            field_idx = field_idx + 1

    me translate_get_field(dest: LocalId, base: MirOperand, field: i64):
        val dest_name = self.get_local(dest.id)
        val base_val = self.translate_operand(base)
        self.builder.emit_assign(dest_name, r"((int64_t*)" + base_val + r")[" + field + r"]")

    me translate_set_field(base: MirOperand, field: i64, value: MirOperand):
        val base_val = self.translate_operand(base)
        val value_val = self.translate_operand(value)
        self.builder.emit(r"((int64_t*)" + base_val + r")[" + field + r"] = " + value_val + r";")

    # === Cast Overrides ===

    me translate_cast(dest: LocalId, operand: MirOperand, target: MirType):
        val dest_name = self.get_local(dest.id)
        val operand_val = self.translate_operand(operand)
        val target_ty = self.type_mapper.map_type(target)
        self.builder.emit_assign(dest_name, r"(" + target_ty + r")" + operand_val)

    me translate_bitcast(dest: LocalId, operand: MirOperand, target: MirType):
        val dest_name = self.get_local(dest.id)
        val operand_val = self.translate_operand(operand)
        val target_ty = self.type_mapper.map_type(target)
        self.builder.emit_assign(dest_name, r"(" + target_ty + r")" + operand_val)

    # === Indirect Calls / Intrinsics ===

    me translate_call_indirect(dest: LocalId?, ptr: MirOperand, args: [MirOperand], sig: MirSignature):
        val ptr_val = self.translate_operand(ptr)
        var arg_vals: [text] = []
        for arg in args:
            arg_vals = arg_vals.push(self.translate_operand(arg))
        val args_str = arg_vals.join(", ")
        val ret_ty = self.type_mapper.map_type(sig.return_type)
        if dest.?:
            val dest_name = self.get_local(dest.unwrap().id)
            self.builder.emit_assign(dest_name, r"((" + ret_ty + r"(*)(...))(" + ptr_val + r"))(" + args_str + r")")
        else:
            self.builder.emit(r"((" + ret_ty + r"(*)(...))(" + ptr_val + r"))(" + args_str + r");")

    me translate_intrinsic(dest: LocalId?, name: text, args: [MirOperand]):
        var arg_vals: [text] = []
        for arg in args:
            arg_vals = arg_vals.push(self.translate_operand(arg))
        val args_str = arg_vals.join(", ")
        if dest.?:
            val dest_name = self.get_local(dest.unwrap().id)
            val ret_ty = self.get_local_type(dest.unwrap().id)
            self.builder.emit_assign(dest_name, r"__simple_intrinsic_" + name + r"(" + args_str + r")")
        else:
            self.builder.emit(r"__simple_intrinsic_" + name + r"(" + args_str + r");")

    me translate_inline_asm(asm_template: text, is_volatile: bool, inputs: [MirAsmOperand], outputs: [MirAsmOperand], clobbers: [text]):
        val volatile_str = if is_volatile: "volatile" else: ""
        self.builder.emit(r"#if !(defined(_MSC_VER) && !defined(__clang__))")
        self.builder.emit(r"asm " + volatile_str + r" (" + "\"" + asm_template + "\"" + r");")
        self.builder.emit(r"#endif")

    # === Pipeline Operators ===

    me translate_pipe_forward(dest: LocalId, value: MirOperand, func: MirOperand):
        val dest_name = self.get_local(dest.id)
        val value_val = self.translate_operand(value)
        val func_val = self.translate_operand(func)
        val ret_ty = self.get_local_type(dest.id)
        self.builder.emit_assign(dest_name, r"((" + ret_ty + r"(*)(int64_t))(" + func_val + r"))(" + value_val + r")")

    me translate_compose(dest: LocalId, f: MirOperand, g: MirOperand, forward: bool):
        val dest_name = self.get_local(dest.id)
        val f_val = self.translate_operand(f)
        val g_val = self.translate_operand(g)
        self.builder.emit_assign(dest_name, "(void*)0")
        self.builder.emit_comment("compose (runtime support needed)")

    me translate_parallel(dest: LocalId, funcs: [MirOperand]):
        val dest_name = self.get_local(dest.id)
        self.builder.emit_assign(dest_name, "(void*)0")
        self.builder.emit_comment(r"parallel (" + funcs.len() + r" functions)")

    me translate_layer_connect(dest: LocalId, l1: MirOperand, l2: MirOperand):
        val dest_name = self.get_local(dest.id)
        val l1_val = self.translate_operand(l1)
        val l2_val = self.translate_operand(l2)
        self.builder.emit_assign(dest_name, "(void*)0")
        self.builder.emit_comment("layer connect (~>)")

    # === Borrow Checking ===

    me translate_ref(dest: LocalId, kind: MirBorrowKind, place: MirPlace):
        val dest_name = self.get_local(dest.id)
        val place_val = self.get_local(place.local.id)
        self.builder.emit_assign(dest_name, place_val)
