# C IR Builder - C++20 Source Code Builder
#
# Builds C++20 source strings from MIR structures.
# Follows the pattern of LlvmIRBuilder in llvm_ir_builder.spl.
# Generated code links against runtime.h (spl_ prefix functions).


# ============================================================================
# C IR Builder
# ============================================================================

class CIRBuilder:
    """Builds C++20 source code from MIR."""
    module_name: text
    lines: [text]
    indent_level: i64
    local_counter: i64
    string_literals: [text]
    string_counter: i64

    static fn create(name: text) -> CIRBuilder:
        CIRBuilder(
            module_name: name,
            lines: [],
            indent_level: 0,
            local_counter: 0,
            string_literals: [],
            string_counter: 0
        )

    # === Indentation ===

    fn indent_str() -> text:
        var result = ""
        var i = 0
        while i < self.indent_level:
            result = result + "    "
            i = i + 1
        result

    me indent():
        self.indent_level = self.indent_level + 1

    me dedent():
        if self.indent_level > 0:
            self.indent_level = self.indent_level - 1

    # === Emission ===

    me emit(line: text):
        self.lines = self.lines.push(self.indent_str() + line)

    me emit_raw(line: text):
        self.lines = self.lines.push(line)

    me emit_blank():
        self.lines = self.lines.push("")

    # === File Header ===

    me emit_file_header():
        self.emit_raw("// Generated by Simple compiler (C backend)")
        self.emit_raw("// Module: {self.module_name}")
        self.emit_raw("// Build (clang):    clang++ -std=c++20 -O2 <this>.cpp runtime.c -I compiler_seed -o output")
        self.emit_raw("// Build (clang-cl): clang-cl /std:c++20 /EHsc /O2 <this>.cpp runtime.c /I compiler_seed /Fe:output.exe")
        self.emit_raw("#include <cstdint>")
        self.emit_raw("#include <cstddef>")
        self.emit_raw("#include <cstdlib>")
        self.emit_raw("#include <cstring>")
        self.emit_raw("")
        self.emit_raw("extern \"C\" {")
        self.emit_raw("#include \"runtime.h\"")
        self.emit_raw("}")
        self.emit_raw("")
        self.emit_raw("// Portability macros")
        self.emit_raw("#if defined(_MSC_VER) && !defined(__clang__)")
        self.emit_raw("#define SPL_UNREACHABLE() __assume(0)")
        self.emit_raw("#else")
        self.emit_raw("#define SPL_UNREACHABLE() __builtin_unreachable()")
        self.emit_raw("#endif")
        self.emit_raw("")

    # === Forward Declarations ===

    me emit_forward_decl(ret_ty: text, name: text, params: text):
        self.emit_raw("{ret_ty} {name}({params});")

    # === Function Definition ===

    me start_function(ret_ty: text, name: text, params: text):
        self.emit_raw("{ret_ty} {name}({params}) {{")
        self.indent()

    me end_function():
        self.dedent()
        self.emit_raw("}")
        self.emit_raw("")

    # === Variables ===

    me emit_local_decl(ty: text, name: text):
        self.emit("{ty} {name};")

    me emit_local_init(ty: text, name: text, value: text):
        self.emit("{ty} {name} = {value};")

    me emit_assign(dest: text, value: text):
        self.emit("{dest} = {value};")

    # === Arithmetic ===

    me emit_binop(dest: text, ty: text, op: text, lhs: text, rhs: text):
        self.emit("{ty} {dest} = ({ty})({lhs} {op} {rhs});")

    me emit_unaryop(dest: text, ty: text, op: text, operand: text):
        self.emit("{ty} {dest} = ({ty})({op}{operand});")

    # === Comparison ===

    me emit_cmp(dest: text, ty: text, op: text, lhs: text, rhs: text):
        self.emit("{ty} {dest} = ({ty})({lhs} {op} {rhs});")

    # === Memory ===

    me emit_alloca(dest: text, ty: text):
        self.emit("{ty} {dest};")

    me emit_load(dest: text, ty: text, ptr: text):
        self.emit("{ty} {dest} = *({ty}*){ptr};")

    me emit_store(ty: text, value: text, ptr: text):
        self.emit("*({ty}*){ptr} = {value};")

    # === Function Calls ===

    me emit_call(dest: text?, ret_ty: text, func: text, args: text):
        if dest.?:
            self.emit("{ret_ty} {dest.unwrap()} = {func}({args});")
        else:
            self.emit("{func}({args});")

    me emit_call_indirect(dest: text?, ret_ty: text, func_ptr: text, args: text):
        if dest.?:
            self.emit("{ret_ty} {dest.unwrap()} = (({ret_ty}(*)(...)){func_ptr})({args});")
        else:
            self.emit("(({ret_ty}(*)(...)){func_ptr})({args});")

    # === Control Flow ===

    me emit_return(value: text?):
        if value.?:
            self.emit("return {value.unwrap()};")
        else:
            self.emit("return;")

    me emit_goto(label: text):
        self.emit("goto {label};")

    me emit_label(name: text):
        self.dedent()
        self.emit_raw("{name}:;")
        self.indent()

    me emit_if(cond: text, then_label: text, else_label: text):
        self.emit("if ({cond}) goto {then_label}; else goto {else_label};")

    me emit_switch_start(value: text):
        self.emit("switch ({value}) {{")
        self.indent()

    me emit_switch_case(value: text, label: text):
        self.emit("case {value}: goto {label};")

    me emit_switch_default(label: text):
        self.emit("default: goto {label};")

    me emit_switch_end():
        self.dedent()
        self.emit("}")

    # === Comments ===

    me emit_comment(comment: text):
        self.emit("// {comment}")

    # === String Literals ===

    me add_string_literal(value: text) -> text:
        val id = self.string_counter
        self.string_counter = self.string_counter + 1
        val var_name = "_str_{id}"
        self.string_literals = self.string_literals.push(
            "static const char {var_name}[] = \"{value}\";"
        )
        var_name

    # === Fresh Local ===

    me fresh_local() -> text:
        val id = self.local_counter
        self.local_counter = self.local_counter + 1
        "_t{id}"

    # === Build Output ===

    fn build() -> text:
        var parts: [text] = []

        # String literals go near top
        if self.string_literals.len() > 0:
            parts = parts.push("// String constants")
            for lit in self.string_literals:
                parts = parts.push(lit)
            parts = parts.push("")

        # Main code
        for line in self.lines:
            parts = parts.push(line)

        parts.join("\n")

# ============================================================================
# Export
# ============================================================================

fn CIRBuilder__create(name: text) -> CIRBuilder:
    CIRBuilder.create(name)

export CIRBuilder
export CIRBuilder__create
