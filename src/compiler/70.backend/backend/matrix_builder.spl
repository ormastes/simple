"""
# Backend Support Matrix Builder

Generates support matrix documentation showing which backends support which instructions.

**Phase:** 3 - Documentation Generation
**Status:** Complete
"""

use compiler.backend.capability_tracker.{
    CapabilityTracker, InstructionCategory, create_default_tracker
}

# Matrix builder
class MatrixBuilder:
    tracker: CapabilityTracker

    # Generate markdown table for all instructions
    fn generate_full_matrix() -> text:
        var parts = []
        parts.append("# Backend Instruction Support Matrix" + "\n" + "\n")
        parts.append("| Instruction | Category | Cranelift | LLVM | Vulkan | Interpreter |" + "\n")
        parts.append("|-------------|----------|-----------|------|--------|-------------|" + "\n")

        for inst in self.tracker.instructions:
            val cran = if inst.cranelift: "âœ…" else: "âŒ"
            val llvm_ = if inst.llvm: "âœ…" else: "âŒ"
            val vulk = if inst.vulkan: "âœ…" else: "âŒ"
            val interp = if inst.interpreter: "âœ…" else: "âŒ"

            val cat_name = self.category_to_string(inst.category)

            parts.append("| {inst.instruction_name} | {cat_name} | {cran} | {llvm_} | {vulk} | {interp} |" + "\n")

        parts.join("")

    # Generate summary statistics
    fn generate_summary() -> text:
        val cran_cov = self.tracker.get_coverage("cranelift")
        val llvm_cov = self.tracker.get_coverage("llvm")
        val vulk_cov = self.tracker.get_coverage("vulkan")
        val interp_cov = self.tracker.get_coverage("interpreter")

        var parts = []
        parts.append("## Backend Coverage Summary" + "\n" + "\n")
        parts.append("| Backend | Coverage | Status |" + "\n")
        parts.append("|---------|----------|--------|" + "\n")
        parts.append("| Cranelift | {cran_cov}% | {self.coverage_status(cran_cov)} |" + "\n")
        parts.append("| LLVM | {llvm_cov}% | {self.coverage_status(llvm_cov)} |" + "\n")
        parts.append("| Vulkan | {vulk_cov}% | {self.coverage_status(vulk_cov)} |" + "\n")
        parts.append("| Interpreter | {interp_cov}% | {self.coverage_status(interp_cov)} |" + "\n")

        parts.join("")

    # Generate category breakdown
    fn generate_category_matrix() -> text:
        var parts = []
        parts.append("## Support by Category" + "\n" + "\n")
        parts.append(self.generate_category_section(InstructionCategory.Constants))
        parts.append(self.generate_category_section(InstructionCategory.Arithmetic))
        parts.append(self.generate_category_section(InstructionCategory.ControlFlow))
        parts.append(self.generate_category_section(InstructionCategory.SIMD))
        parts.append(self.generate_category_section(InstructionCategory.GPU))
        parts.append(self.generate_category_section(InstructionCategory.Async))
        parts.join("")

    # Generate section for one category
    fn generate_category_section(cat: InstructionCategory) -> text:
        val cat_name = self.category_to_string(cat)
        var parts = []
        parts.append("### {cat_name}" + "\n" + "\n")

        val insts = self.tracker.get_by_category(cat)
        if insts.len() == 0:
            return parts.join("") + "No instructions in this category." + "\n" + "\n"

        parts.append("| Instruction | Cranelift | LLVM | Vulkan | Interpreter |" + "\n")
        parts.append("|-------------|-----------|------|--------|-------------|" + "\n")

        for inst in insts:
            val cran = if inst.cranelift: "âœ…" else: "âŒ"
            val llvm_ = if inst.llvm: "âœ…" else: "âŒ"
            val vulk = if inst.vulkan: "âœ…" else: "âŒ"
            val interp = if inst.interpreter: "âœ…" else: "âŒ"

            parts.append("| {inst.instruction_name} | {cran} | {llvm_} | {vulk} | {interp} |" + "\n")

        parts.append("\n")
        parts.join("")

    # Helper: category to string
    fn category_to_string(cat: InstructionCategory) -> text:
        if cat == InstructionCategory.Constants:
            "Constants"
        else if cat == InstructionCategory.Arithmetic:
            "Arithmetic"
        else if cat == InstructionCategory.Bitwise:
            "Bitwise"
        else if cat == InstructionCategory.Comparison:
            "Comparison"
        else if cat == InstructionCategory.Memory:
            "Memory"
        else if cat == InstructionCategory.ControlFlow:
            "Control Flow"
        else if cat == InstructionCategory.Collections:
            "Collections"
        else if cat == InstructionCategory.SIMD:
            "SIMD"
        else if cat == InstructionCategory.GPU:
            "GPU"
        else if cat == InstructionCategory.Pointers:
            "Pointers"
        else if cat == InstructionCategory.Structs:
            "Structs"
        else if cat == InstructionCategory.Enums:
            "Enums"
        else if cat == InstructionCategory.Async:
            "Async"
        else if cat == InstructionCategory.ErrorHandling:
            "Error Handling"
        else if cat == InstructionCategory.Closures:
            "Closures"
        else:
            "Unknown"

    # Helper: coverage status
    fn coverage_status(pct: i32) -> text:
        if pct >= 90:
            "ğŸŸ¢ Excellent"
        else if pct >= 70:
            "ğŸŸ¡ Good"
        else if pct >= 50:
            "ğŸŸ  Partial"
        else:
            "ğŸ”´ Limited"

# Create builder with default tracker
fn create_matrix_builder() -> MatrixBuilder:
    MatrixBuilder(tracker: create_default_tracker())

# Generate complete documentation
fn generate_complete_docs() -> text:
    val builder = create_matrix_builder()
    var parts = []
    parts.append(builder.generate_summary())
    parts.append("\n" + "---" + "\n" + "\n")
    parts.append(builder.generate_category_matrix())
    parts.append("\n" + "---" + "\n" + "\n")
    parts.append(builder.generate_full_matrix())
    parts.join("")

export MatrixBuilder, create_matrix_builder, generate_complete_docs
