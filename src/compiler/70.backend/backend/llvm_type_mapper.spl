# LLVM Type Mapper - LLVM-Specific Type Mapping Implementation
#
# Maps MIR types to LLVM IR type strings.
# Implements TypeMapper trait for LLVM backend.

use compiler.mir_data.*
use compiler.backend.common.type_mapper.*

# ============================================================================
# LLVM Context - Type Caching
# ============================================================================

struct LlvmContext:
    """
    Context for caching type definitions and managing LLVM type system state.

    Caches named struct types to avoid duplicate definitions and enable
    recursive types.
    """
    named_structs: Dict<text, text>     # name -> llvm type string
    struct_counter: i64                  # for generating unique names

    static fn empty() -> LlvmContext:
        LlvmContext(named_structs: {}, struct_counter: 0)

    me register_struct(name: text, llvm_type: text):
        """Register a named struct type."""
        self.named_structs[name] = llvm_type

    fn get_struct(name: text) -> text?:
        """Get a previously registered struct type."""
        if self.named_structs.contains_key(name):
            Some(self.named_structs[name])
        else:
            nil

    me next_struct_name() -> text:
        """Generate a unique struct name."""
        val name = "%struct.anon.{self.struct_counter}"
        self.struct_counter = self.struct_counter + 1
        name

# ============================================================================
# LLVM Type Mapper
# ============================================================================

class LlvmTypeMapper:
    """
    Maps MIR types to LLVM IR type representations.

    LLVM uses typed pointers and explicit struct layouts.
    All integers are iN (i64, i32, i16, i8).
    All floats are double or float.

    Example mappings:
        I64 → "i64"
        F64 → "double"
        Ptr(I64, Mutable) → "ptr"  (opaque pointers in LLVM 15+)
        [I64 x 10] → "[10 x i64]"
    """

    target_bits: i64      # 32 or 64 for pointer size
    context: LlvmContext  # Type caching context

    static fn create() -> LlvmTypeMapper:
        """Create mapper for default 64-bit target."""
        LlvmTypeMapper(target_bits: 64, context: LlvmContext.empty())

    static fn create_32bit() -> LlvmTypeMapper:
        """Create mapper for 32-bit targets."""
        LlvmTypeMapper(target_bits: 32, context: LlvmContext.empty())

    static fn create_64bit() -> LlvmTypeMapper:
        """Create mapper for 64-bit targets."""
        LlvmTypeMapper(target_bits: 64, context: LlvmContext.empty())

    static fn create_for_target(target: CodegenTarget) -> LlvmTypeMapper:
        """Create mapper for specific target."""
        if target.is_32bit():
            LlvmTypeMapper.create_32bit()
        else:
            LlvmTypeMapper.create_64bit()

impl TypeMapper for LlvmTypeMapper:
    fn map_primitive(ty: PrimitiveType) -> text:
        """
        Map primitive types to LLVM IR types.

        LLVM primitives:
        - Integers: i64, i32, i16, i8
        - Floats: double (f64), float (f32)
        - Boolean: i1 (1-bit integer)
        - Unit: {} (empty struct)
        """
        match ty:
            case I64: "i64"
            case I32: "i32"
            case I16: "i16"
            case I8: "i8"
            case F64: "double"
            case F32: "float"
            case Bool: "i1"
            case Unit: "void"  # Void type for unit

    fn map_pointer(pointee: text, mutability: Mutability) -> text:
        """
        Map pointer types to LLVM IR.

        LLVM 15+ uses opaque pointers: all pointers are just "ptr".
        Mutability is tracked at value level, not type level.

        For older LLVM (<15), would use: "{pointee}*"
        """
        "ptr"  # Opaque pointers (LLVM 15+)

    fn backend_name() -> text:
        "LLVM"

impl LlvmTypeMapper:
    # === Override map_type to handle generics ===

    fn map_type(ty: MirType) -> text:
        """
        Map MIR type to LLVM IR type string.
        Overrides default to add generic checking.
        """
        # Check for unmonomorphized generics
        if ty.kind == Generic(_):
            error("LLVM backend cannot handle unmonomorphized generic types. " +
                  "Type must be monomorphized before lowering to LLVM IR.")

        # Delegate to default implementation
        match ty.kind:
            case I64 | I32 | I16 | I8 | F64 | F32 | Bool | Unit:
                self.map_primitive(ty.kind)

            case Ptr(inner, mutability):
                val inner_ty = self.map_type(inner)
                self.map_pointer(inner_ty, mutability)

            case Struct(fields):
                self.map_struct(fields)

            case Array(element, size):
                self.map_array(element, size)

            case Tuple(elements):
                self.map_tuple(elements)

            case Function(params, ret):
                self.map_function(params, ret)

            case _:
                error("Unsupported type in LLVM backend: {ty}")

    # === Custom LLVM-specific methods ===

    fn map_struct(fields: [(text, MirType)]) -> text:
        """
        Map struct type to LLVM struct type.

        LLVM structs use curly braces: { type1, type2, ... }
        Field names are not included (structural typing).

        Example:
            struct Point { x: i64, y: i64 } → "{ i64, i64 }"
        """
        if fields.length == 0:
            "{}"  # Empty struct
        else:
            val field_types = fields.map(\f: self.map_type(f.1))
            "{ {field_types.join(", ")} }"

    fn map_array(element: MirType, size: i64) -> text:
        """
        Map array type to LLVM array type.

        LLVM arrays: [count x element_type]

        Example:
            [i64 x 10] → array of 10 i64 values
        """
        val elem_ty = self.map_type(element)
        "[{size} x {elem_ty}]"

    fn map_tuple(elements: [MirType]) -> text:
        """
        Map tuple type to LLVM struct (unnamed).

        Tuples are structs without field names.

        Example:
            (i64, f64, bool) → "{ i64, double, i1 }"
        """
        if elements.length == 0:
            "{}"  # Empty tuple
        else:
            val elem_types = elements.map(\e: self.map_type(e))
            "{ {elem_types.join(", ")} }"

    fn map_function(params: [MirType], ret: MirType) -> text:
        """
        Map function type to LLVM function pointer type.

        LLVM function types: ret_type (param1_type, param2_type, ...)
        Function pointer: ptr (for opaque pointers)

        Example:
            (i64, i64) -> i64 → "ptr"  (all function pointers are opaque)
        """
        "ptr"  # All function pointers are opaque in LLVM 15+

    fn map_function_signature(params: [MirType], ret: MirType) -> text:
        """
        Map function signature (for declarations/definitions).

        Returns: "ret_type (param_types)"

        Example:
            (i64, i64) -> i64 → "i64 (i64, i64)"
        """
        val param_types = params.map(\p: self.map_type(p))
        val ret_type = self.map_type(ret)
        "{ret_type} ({param_types.join(", ")})"

    # === Size and alignment (LLVM-specific) ===

    fn size_of(ty: MirType) -> i64:
        """
        Get size in bytes of a type (LLVM target-specific).

        Uses target_bits to determine pointer size.
        """
        match ty.kind:
            case I64 | F64: 8
            case I32 | F32: 4
            case I16: 2
            case I8 | Bool: 1
            case Unit: 0
            case Ptr(_, _):
                self.target_bits / 8  # 4 bytes on 32-bit, 8 on 64-bit
            case Struct(fields):
                # Sum of field sizes (no padding in this simple version)
                fields.map(\f: self.size_of(f.1)).sum()
            case Array(elem, size):
                self.size_of(elem) * size
            case Tuple(elements):
                elements.map(\e: self.size_of(e)).sum()
            case _:
                error("Cannot compute size of {ty}")

    fn align_of(ty: MirType) -> i64:
        """
        Get alignment in bytes of a type (LLVM rules).

        LLVM alignment rules:
        - i64, double: 8 bytes
        - i32, float: 4 bytes
        - i16: 2 bytes
        - i8, i1: 1 byte
        - Pointers: target_bits / 8
        - Structs: max alignment of fields
        """
        match ty.kind:
            case I64 | F64: 8
            case I32 | F32: 4
            case I16: 2
            case I8 | Bool: 1
            case Ptr(_, _):
                self.target_bits / 8
            case Struct(fields):
                if fields.length == 0:
                    1
                else:
                    fields.map(\f: self.align_of(f.1)).max()
            case Array(elem, _):
                self.align_of(elem)
            case Tuple(elements):
                if elements.length == 0:
                    1
                else:
                    elements.map(\e: self.align_of(e)).max()
            case _:
                1  # Default alignment

# ============================================================================
# Export
# ============================================================================

# Export desugared static method names (for static method calls)
fn LlvmTypeMapper__create() -> LlvmTypeMapper:
    LlvmTypeMapper.create()

fn LlvmTypeMapper__create_32bit() -> LlvmTypeMapper:
    LlvmTypeMapper.create_32bit()

fn LlvmTypeMapper__create_64bit() -> LlvmTypeMapper:
    LlvmTypeMapper.create_64bit()

fn LlvmTypeMapper__create_for_target(target: CodegenTarget) -> LlvmTypeMapper:
    LlvmTypeMapper.create_for_target(target)

export LlvmContext, LlvmTypeMapper
export LlvmTypeMapper__create, LlvmTypeMapper__create_32bit, LlvmTypeMapper__create_64bit, LlvmTypeMapper__create_for_target
