# ARM NEON Code Generation
#
# Generates ARM NEON SIMD instructions for vector operations.
# Supports ARMv8-A NEON (128-bit Q registers, 32-bit opcodes).
#
# NEON Instructions use fixed 32-bit encoding:
#   FADD.4S Vd, Vn, Vm (add 4 single-precision floats)
#
# Instruction structure (32-bit):
#   [cond(4)] [opcode bits(24)] [Rd(4)] [Rn(4)] [Rm(4)]
#   For NEON: fixed encoding with register fields in specific positions
#
# Q registers (128-bit): Q0-Q15 (encoded as V0-V15 in ARMv8-A)
# D registers (64-bit): D0-D31 (lower half of Q registers)
#
# ARMv8-A NEON uses "Advanced SIMD" encoding with:
#   - Fixed 32-bit instruction size
#   - Vector registers V0-V31 (we use V0-V15 for Q register compatibility)
#   - Scalar and vector forms

use compiler.backend.native.mach_inst.{MachReg, MachRegKind, physical_reg, reg_id, Operand, OperandKind, MachInst, MachBlock, MachFunction, MachModule}
use compiler.backend.native.mach_inst.{AARCH64_Q0, AARCH64_Q1, AARCH64_Q2, AARCH64_Q3, AARCH64_Q4, AARCH64_Q5, AARCH64_Q6, AARCH64_Q7}
use compiler.backend.native.mach_inst.{AARCH64_Q8, AARCH64_Q9, AARCH64_Q10, AARCH64_Q11, AARCH64_Q12, AARCH64_Q13, AARCH64_Q14, AARCH64_Q15}
use compiler.backend.native.mach_inst.{AARCH64_Q_ALLOCATABLE}

# ============================================================================
# ARM NEON Register IDs (Re-export mach_inst constants for compatibility)
# ============================================================================

val ARM_Q0 = AARCH64_Q0
val ARM_Q1 = AARCH64_Q1
val ARM_Q2 = AARCH64_Q2
val ARM_Q3 = AARCH64_Q3
val ARM_Q4 = AARCH64_Q4
val ARM_Q5 = AARCH64_Q5
val ARM_Q6 = AARCH64_Q6
val ARM_Q7 = AARCH64_Q7
val ARM_Q8 = AARCH64_Q8
val ARM_Q9 = AARCH64_Q9
val ARM_Q10 = AARCH64_Q10
val ARM_Q11 = AARCH64_Q11
val ARM_Q12 = AARCH64_Q12
val ARM_Q13 = AARCH64_Q13
val ARM_Q14 = AARCH64_Q14
val ARM_Q15 = AARCH64_Q15

val ARM_Q_ALLOCATABLE = AARCH64_Q_ALLOCATABLE

fn arm_neon_reg_name(id: i64) -> text:
    if id >= 64 and id <= 79:
        val q_num = id - 64
        "q{q_num}"
    else:
        "q?"

# ============================================================================
# Register Encoding
# ============================================================================

fn q_to_index(q_id: i64) -> i64:
    """Convert Q register ID to index (0-15)."""
    if q_id >= 64 and q_id <= 79:
        q_id - 64
    else:
        0

# ============================================================================
# ARM NEON Instruction Encoding Helpers
# ============================================================================

fn neon_encode_f32x4_3reg(opcode_bits: i64, qd: i64, qn: i64, qm: i64) -> [i64]:
    """
    Encode 3-register NEON instruction (Vd, Vn, Vm format).
    ARMv8-A Advanced SIMD encoding for f32x4 operations.

    Format (32-bit little-endian):
    31-24: opcode high bits
    23-16: Rn field (4 bits) + opcode mid bits
    15-8:  Rd field (4 bits) + opcode low bits
    7-0:   Rm field (4 bits) + size/Q bits

    Example FADD.4S: 0x4E20D400 base + register fields
    """
    val d_idx = q_to_index(qd)
    val n_idx = q_to_index(qn)
    val m_idx = q_to_index(qm)

    # Build 32-bit instruction (stored as 4 bytes, little-endian)
    # Base opcode contains operation and size encoding
    var inst = opcode_bits

    # Insert register fields
    # Rd in bits 0-4
    inst = inst + d_idx

    # Rn in bits 5-9
    inst = inst + (n_idx * 32)

    # Rm in bits 16-20
    inst = inst + (m_idx * 65536)

    # Convert 32-bit value to 4 bytes (little-endian)
    val byte0 = inst % 256
    val byte1 = (inst / 256) % 256
    val byte2 = (inst / 65536) % 256
    val byte3 = (inst / 16777216) % 256

    [byte0, byte1, byte2, byte3]

fn neon_encode_f64x2_3reg(opcode_bits: i64, qd: i64, qn: i64, qm: i64) -> [i64]:
    """
    Encode 3-register NEON instruction for f64x2 (double precision).
    Same structure as f32x4 but with different size encoding.
    """
    neon_encode_f32x4_3reg(opcode_bits, qd, qn, qm)

fn neon_encode_i32x4_3reg(opcode_bits: i64, qd: i64, qn: i64, qm: i64) -> [i64]:
    """
    Encode 3-register NEON instruction for i32x4 (integer).
    Same structure as f32x4 but with different opcode.
    """
    neon_encode_f32x4_3reg(opcode_bits, qd, qn, qm)

# ============================================================================
# NEON f32x4 (128-bit Float) Instructions
# ============================================================================

fn encode_fadd_4s(qd: i64, qn: i64, qm: i64) -> [i64]:
    """
    Encode FADD.4S Vd.4S, Vn.4S, Vm.4S (128-bit float add).
    ARMv8-A encoding: 0 Q 0 01110 0 Sz 1 Rm 110101 Rn Rd
    Q=1 (128-bit), Sz=0 (single precision)
    Base opcode: 0x4E20D400
    """
    # FADD.4S base encoding:
    # 0100 1110 0010 0000 1101 0100 0000 0000
    # = 0x4E20D400
    encode_neon_f32x4_3reg(0x4E20D400, qd, qn, qm)

fn encode_fsub_4s(qd: i64, qn: i64, qm: i64) -> [i64]:
    """
    Encode FSUB.4S Vd.4S, Vn.4S, Vm.4S (128-bit float subtract).
    Base opcode: 0x4EA0D400
    """
    # FSUB.4S: bit 23 set (0x00800000) compared to FADD
    encode_neon_f32x4_3reg(0x4EA0D400, qd, qn, qm)

fn encode_fmul_4s(qd: i64, qn: i64, qm: i64) -> [i64]:
    """
    Encode FMUL.4S Vd.4S, Vn.4S, Vm.4S (128-bit float multiply).
    Base opcode: 0x6E20DC00
    """
    encode_neon_f32x4_3reg(0x6E20DC00, qd, qn, qm)

fn encode_fdiv_4s(qd: i64, qn: i64, qm: i64) -> [i64]:
    """
    Encode FDIV.4S Vd.4S, Vn.4S, Vm.4S (128-bit float divide).
    Base opcode: 0x6E20FC00
    """
    encode_neon_f32x4_3reg(0x6E20FC00, qd, qn, qm)

fn encode_fmla_4s(qd: i64, qn: i64, qm: i64) -> [i64]:
    """
    Encode FMLA.4S Vd.4S, Vn.4S, Vm.4S (fused multiply-add: Vd = Vd + Vn * Vm).
    Base opcode: 0x4E20CC00
    """
    encode_neon_f32x4_3reg(0x4E20CC00, qd, qn, qm)

# ============================================================================
# NEON f64x2 (128-bit Double) Instructions
# ============================================================================

fn encode_fadd_2d(qd: i64, qn: i64, qm: i64) -> [i64]:
    """
    Encode FADD.2D Vd.2D, Vn.2D, Vm.2D (128-bit double add).
    Base opcode: 0x4E60D400 (Sz=1 for double precision)
    """
    encode_neon_f64x2_3reg(0x4E60D400, qd, qn, qm)

fn encode_fsub_2d(qd: i64, qn: i64, qm: i64) -> [i64]:
    """
    Encode FSUB.2D Vd.2D, Vn.2D, Vm.2D (128-bit double subtract).
    Base opcode: 0x4EE0D400
    """
    encode_neon_f64x2_3reg(0x4EE0D400, qd, qn, qm)

fn encode_fmul_2d(qd: i64, qn: i64, qm: i64) -> [i64]:
    """
    Encode FMUL.2D Vd.2D, Vn.2D, Vm.2D (128-bit double multiply).
    Base opcode: 0x6E60DC00
    """
    encode_neon_f64x2_3reg(0x6E60DC00, qd, qn, qm)

fn encode_fdiv_2d(qd: i64, qn: i64, qm: i64) -> [i64]:
    """
    Encode FDIV.2D Vd.2D, Vn.2D, Vm.2D (128-bit double divide).
    Base opcode: 0x6E60FC00
    """
    encode_neon_f64x2_3reg(0x6E60FC00, qd, qn, qm)

fn encode_fmla_2d(qd: i64, qn: i64, qm: i64) -> [i64]:
    """
    Encode FMLA.2D Vd.2D, Vn.2D, Vm.2D (fused multiply-add double).
    Base opcode: 0x4E60CC00
    """
    encode_neon_f64x2_3reg(0x4E60CC00, qd, qn, qm)

# ============================================================================
# NEON i32x4 (128-bit Integer) Instructions
# ============================================================================

fn encode_add_4s_int(qd: i64, qn: i64, qm: i64) -> [i64]:
    """
    Encode ADD.4S Vd.4S, Vn.4S, Vm.4S (128-bit int32 add).
    Base opcode: 0x4EA08400
    """
    encode_neon_i32x4_3reg(0x4EA08400, qd, qn, qm)

fn encode_sub_4s_int(qd: i64, qn: i64, qm: i64) -> [i64]:
    """
    Encode SUB.4S Vd.4S, Vn.4S, Vm.4S (128-bit int32 subtract).
    Base opcode: 0x6EA08400
    """
    encode_neon_i32x4_3reg(0x6EA08400, qd, qn, qm)

fn encode_mul_4s_int(qd: i64, qn: i64, qm: i64) -> [i64]:
    """
    Encode MUL.4S Vd.4S, Vn.4S, Vm.4S (128-bit int32 multiply).
    Base opcode: 0x4EA09C00
    """
    encode_neon_i32x4_3reg(0x4EA09C00, qd, qn, qm)

# ============================================================================
# Load/Store Instructions
# ============================================================================

fn encode_ldr_q(qd: i64, base_reg: i64, offset: i64) -> [i64]:
    """
    Encode LDR Qd, [Xn, #offset] (load 128-bit from memory).
    ARMv8-A encoding: 0x3DC00000 base + Rt + Rn<<5 + imm12<<10
    offset must be multiple of 16, encoded as offset/16 in imm12 field.
    """
    val d_idx = q_to_index(qd)

    # Base encoding for LDR Q (128-bit load)
    # 00 111 1 01 01 imm12 Rn Rt
    var inst = 0x3DC00000

    # Rt (destination register, bits 0-4)
    inst = inst + d_idx

    # Rn (base register, bits 5-9)
    inst = inst + ((base_reg % 32) * 32)

    # imm12 (offset/16, bits 10-21)
    val imm12 = (offset / 16) % 4096
    inst = inst + (imm12 * 1024)

    # Convert to little-endian bytes
    val byte0 = inst % 256
    val byte1 = (inst / 256) % 256
    val byte2 = (inst / 65536) % 256
    val byte3 = (inst / 16777216) % 256

    [byte0, byte1, byte2, byte3]

fn encode_str_q(qs: i64, base_reg: i64, offset: i64) -> [i64]:
    """
    Encode STR Qd, [Xn, #offset] (store 128-bit to memory).
    ARMv8-A encoding: 0x3D800000 base + Rt + Rn<<5 + imm12<<10
    """
    val s_idx = q_to_index(qs)

    # Base encoding for STR Q (128-bit store)
    var inst = 0x3D800000

    # Rt (source register, bits 0-4)
    inst = inst + s_idx

    # Rn (base register, bits 5-9)
    inst = inst + ((base_reg % 32) * 32)

    # imm12 (offset/16, bits 10-21)
    val imm12 = (offset / 16) % 4096
    inst = inst + (imm12 * 1024)

    # Convert to little-endian bytes
    val byte0 = inst % 256
    val byte1 = (inst / 256) % 256
    val byte2 = (inst / 65536) % 256
    val byte3 = (inst / 16777216) % 256

    [byte0, byte1, byte2, byte3]

fn encode_ld1_4s(qd: i64, base_reg: i64) -> [i64]:
    """
    Encode LD1 {Vd.4S}, [Xn] (load 4 single-precision floats, structure load).
    Base opcode: 0x4C407000
    Used for interleaved/structure-of-arrays loads.
    """
    val d_idx = q_to_index(qd)

    # LD1 single structure encoding
    var inst = 0x4C407000

    # Rt (destination, bits 0-4)
    inst = inst + d_idx

    # Rn (base register, bits 5-9)
    inst = inst + ((base_reg % 32) * 32)

    val byte0 = inst % 256
    val byte1 = (inst / 256) % 256
    val byte2 = (inst / 65536) % 256
    val byte3 = (inst / 16777216) % 256

    [byte0, byte1, byte2, byte3]

fn encode_st1_4s(qs: i64, base_reg: i64) -> [i64]:
    """
    Encode ST1 {Vd.4S}, [Xn] (store 4 single-precision floats, structure store).
    Base opcode: 0x4C007000
    Used for interleaved/structure-of-arrays stores.
    """
    val s_idx = q_to_index(qs)

    # ST1 single structure encoding
    var inst = 0x4C007000

    # Rt (source, bits 0-4)
    inst = inst + s_idx

    # Rn (base register, bits 5-9)
    inst = inst + ((base_reg % 32) * 32)

    val byte0 = inst % 256
    val byte1 = (inst / 256) % 256
    val byte2 = (inst / 65536) % 256
    val byte3 = (inst / 16777216) % 256

    [byte0, byte1, byte2, byte3]

# ============================================================================
# Horizontal Operations
# ============================================================================

fn encode_faddp_4s(qd: i64, qn: i64, qm: i64) -> [i64]:
    """
    Encode FADDP.4S Vd.4S, Vn.4S, Vm.4S (pairwise add).
    Base opcode: 0x4E20D400
    Similar to FADD but with pairwise operation bit set.
    """
    encode_neon_f32x4_3reg(0x6E20D400, qd, qn, qm)

fn encode_fmaxnm_4s(qd: i64, qn: i64, qm: i64) -> [i64]:
    """
    Encode FMAXNM.4S Vd.4S, Vn.4S, Vm.4S (max of floats, NaN-aware).
    Base opcode: 0x4E20C400
    """
    encode_neon_f32x4_3reg(0x4E20C400, qd, qn, qm)

fn encode_fminnm_4s(qd: i64, qn: i64, qm: i64) -> [i64]:
    """
    Encode FMINNM.4S Vd.4S, Vn.4S, Vm.4S (min of floats, NaN-aware).
    Base opcode: 0x4EA0C400
    """
    encode_neon_f32x4_3reg(0x4EA0C400, qd, qn, qm)

# ============================================================================
# Helper function name compatibility
# ============================================================================

fn encode_neon_f32x4_3reg(opcode: i64, qd: i64, qn: i64, qm: i64) -> [i64]:
    """Wrapper for neon_encode_f32x4_3reg (name compatibility)."""
    neon_encode_f32x4_3reg(opcode, qd, qn, qm)

# ============================================================================
# Exports
# ============================================================================

export ARM_Q0, ARM_Q1, ARM_Q2, ARM_Q3, ARM_Q4, ARM_Q5, ARM_Q6, ARM_Q7
export ARM_Q8, ARM_Q9, ARM_Q10, ARM_Q11, ARM_Q12, ARM_Q13, ARM_Q14, ARM_Q15
export ARM_Q_ALLOCATABLE
export arm_neon_reg_name
export q_to_index
export neon_encode_f32x4_3reg, neon_encode_f64x2_3reg, neon_encode_i32x4_3reg

export encode_fadd_4s, encode_fsub_4s, encode_fmul_4s, encode_fdiv_4s, encode_fmla_4s
export encode_fadd_2d, encode_fsub_2d, encode_fmul_2d, encode_fdiv_2d, encode_fmla_2d
export encode_add_4s_int, encode_sub_4s_int, encode_mul_4s_int

export encode_ldr_q, encode_str_q
export encode_ld1_4s, encode_st1_4s

export encode_faddp_4s, encode_fmaxnm_4s, encode_fminnm_4s
