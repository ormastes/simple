# Native Backend - ELF Format Emission
#
# ELF object file emission for x86_64, AArch64, and RISC-V 64.
# Called by the main native backend dispatcher after ISel/RegAlloc/Encode.

use compiler.mir_data.{MirModule}
use compiler.backend.native.mach_inst.{MachModule, EncodedFunction}
use compiler.backend.native.elf_writer.{ElfWriter, ElfSection, ElfSectionKind, ElfSymbol, ElfSymbolBind, ElfSymbolType, ElfReloc, ElfRelocType, elf_writer_x86_64, elf_writer_aarch64, elf_writer_riscv64, elf_add_section, elf_add_symbol, new_text_section, new_data_section, new_rodata_section, section_add_reloc, new_func_symbol, new_extern_symbol, write_elf64}
use compiler.backend.native.layout_solver.{solve_layout, LayoutPlan}
use compiler.backend.native.native_layout.{reorder_by_layout}

# ============================================================================
# ELF Emission - x86_64
# ============================================================================

fn emit_elf_x86_64(
    encoded_funcs: [EncodedFunction],
    module: MachModule,
    mir_module: MirModule
) -> [i64]:
    var writer = elf_writer_x86_64()

    # Phase 4a: Generate layout plan and reorder functions
    val layout_plan = solve_layout(mir_module, nil)  # nil = no profile data yet
    val ordered_funcs = reorder_by_layout(encoded_funcs, layout_plan)

    # Track phase boundaries for padding
    var phase_boundaries: Dict<text, i64> = {}
    for group in layout_plan.groups:
        if group.functions.len() > 0:
            phase_boundaries[group.functions[0].name] = 4096  # 4KB padding

    # Combine all function code into a single .text section
    var all_code: [i64] = []
    var func_offsets: Dict<text, i64> = {}
    var all_relocs: [ElfReloc] = []

    # Build symbol name -> index mapping for relocations
    # Symbols are ordered: data labels, extern symbols, function names
    var sym_names: [text] = []
    var sym_name_to_idx: Dict<text, i64> = {}

    # First collect data entry labels (local symbols in rodata)
    var rodata_offset = 0
    var data_label_offsets: Dict<text, i64> = {}
    for entry in module.data_sections:
        if entry.is_readonly:
            if not sym_name_to_idx.contains(entry.name):
                val idx = sym_names.len()
                sym_names = sym_names + [entry.name]
                sym_name_to_idx[entry.name] = idx
                data_label_offsets[entry.name] = rodata_offset
            rodata_offset = rodata_offset + entry.data.len()

    # Then collect extern symbols
    for ext_sym in module.extern_symbols:
        if not sym_name_to_idx.contains(ext_sym):
            val idx = sym_names.len()
            sym_names = sym_names + [ext_sym]
            sym_name_to_idx[ext_sym] = idx

    # Then collect function names (using ordered functions)
    for func in ordered_funcs:
        if not sym_name_to_idx.contains(func.name):
            val idx = sym_names.len()
            sym_names = sym_names + [func.name]
            sym_name_to_idx[func.name] = idx

    # Count content sections for symbol index offset
    # ELF writer inserts section symbols: [0:null] [1..N:section syms] [N+1..:user syms]
    var num_content_sections = 1  # .text always present
    var has_rodata = false
    var has_data = false
    for entry in module.data_sections:
        if entry.is_readonly:
            has_rodata = true
        else:
            has_data = true
    if has_rodata:
        num_content_sections = num_content_sections + 1
    if has_data:
        num_content_sections = num_content_sections + 1
    val sym_base = 1 + num_content_sections

    # Concatenate function code and track offsets (using layout-ordered functions)
    for func in ordered_funcs:
        # Check if this function starts a new phase (needs 4KB alignment)
        if phase_boundaries.contains_key(func.name):
            val page_size = 4096
            val current_pos = all_code.len()
            val remainder = current_pos % page_size
            if remainder != 0:
                val padding_needed = page_size - remainder
                for i in 0..padding_needed:
                    all_code = all_code + [0xcc]  # int3 padding
        else:
            # Regular 16-byte alignment within phase
            var padding = all_code.len() % 16
            if padding != 0:
                padding = 16 - padding
            for i in 0..padding:
                all_code = all_code + [0xcc]  # int3 padding

        func_offsets[func.name] = all_code.len()

        val code_start = all_code.len()
        all_code = all_code + func.code

        # Adjust relocation offsets
        for reloc in func.relocations:
            var reloc_type = ElfRelocType.X86_64_PLT32
            if reloc.reloc_type == 2:
                reloc_type = ElfRelocType.X86_64_PC32
            elif reloc.reloc_type == 1:
                reloc_type = ElfRelocType.X86_64_64

            # Look up the symbol index
            var sym_idx = 0
            if sym_name_to_idx.contains(reloc.symbol_name):
                sym_idx = sym_name_to_idx[reloc.symbol_name]
            val elf_reloc = ElfReloc(
                offset: code_start + reloc.offset,
                reloc_type: reloc_type,
                symbol_index: sym_base + sym_idx,
                addend: reloc.addend
            )
            all_relocs = all_relocs + [elf_reloc]

    # Create .text section
    var text_section = new_text_section(all_code)
    for reloc in all_relocs:
        text_section = section_add_reloc(text_section, reloc)
    writer = elf_add_section(writer, text_section)

    # Create .rodata section for string constants
    var rodata_bytes: [i64] = []
    for entry in module.data_sections:
        if entry.is_readonly:
            rodata_bytes = rodata_bytes + entry.data
    if rodata_bytes.len() > 0:
        writer = elf_add_section(writer, new_rodata_section(rodata_bytes))

    # Create .data section for mutable data
    var data_bytes: [i64] = []
    for entry in module.data_sections:
        if not entry.is_readonly:
            data_bytes = data_bytes + entry.data
    if data_bytes.len() > 0:
        writer = elf_add_section(writer, new_data_section(data_bytes))

    # Add data label symbols (local, in rodata)
    for entry in module.data_sections:
        if entry.is_readonly:
            if data_label_offsets.contains(entry.name):
                val sym = ElfSymbol(
                    name: entry.name,
                    sym_bind: ElfSymbolBind.Local,
                    sym_type: ElfSymbolType.Object,
                    section_index: 2,
                    value: data_label_offsets[entry.name],
                    size: entry.data.len()
                )
                writer = elf_add_symbol(writer, sym)

    # Add extern symbols (undefined, global) â€” deduplicated
    var added_extern_syms: Dict<text, bool> = {}
    for ext_sym in module.extern_symbols:
        if not added_extern_syms.contains(ext_sym):
            added_extern_syms[ext_sym] = true
            writer = elf_add_symbol(writer, new_extern_symbol(ext_sym))

    # Add function symbols (defined, global) - use ordered functions
    for func in ordered_funcs:
        var offset = 0
        if func_offsets.contains(func.name):
            offset = func_offsets[func.name]
        val sym = new_func_symbol(func.name, 1, offset, func.code.len())
        writer = elf_add_symbol(writer, sym)

    write_elf64(writer)

# ============================================================================
# ELF Emission - AArch64
# ============================================================================

fn emit_elf_aarch64(
    encoded_funcs: [EncodedFunction],
    module: MachModule,
    mir_module: MirModule
) -> [i64]:
    var writer = elf_writer_aarch64()

    # Phase 4a: Generate layout plan and reorder functions
    val layout_plan = solve_layout(mir_module, nil)  # nil = no profile data yet
    val ordered_funcs = reorder_by_layout(encoded_funcs, layout_plan)

    # Track phase boundaries for padding
    var phase_boundaries: Dict<text, i64> = {}
    for group in layout_plan.groups:
        if group.functions.len() > 0:
            phase_boundaries[group.functions[0].name] = 4096  # 4KB padding

    # Combine all function code into a single .text section
    var all_code: [i64] = []
    var func_offsets: Dict<text, i64> = {}
    var all_relocs: [ElfReloc] = []
    var sym_names: [text] = []
    var sym_name_to_idx: Dict<text, i64> = {}

    # Collect data entry labels
    var rodata_offset_a = 0
    var data_label_offsets_a: Dict<text, i64> = {}
    for entry in module.data_sections:
        if entry.is_readonly:
            if not sym_name_to_idx.contains(entry.name):
                val idx = sym_names.len()
                sym_names = sym_names + [entry.name]
                sym_name_to_idx[entry.name] = idx
                data_label_offsets_a[entry.name] = rodata_offset_a
            rodata_offset_a = rodata_offset_a + entry.data.len()

    # Collect extern symbols
    for ext_sym in module.extern_symbols:
        if not sym_name_to_idx.contains(ext_sym):
            val idx = sym_names.len()
            sym_names = sym_names + [ext_sym]
            sym_name_to_idx[ext_sym] = idx

    # Collect function names (use ordered functions for correct layout)
    for func in ordered_funcs:
        if not sym_name_to_idx.contains(func.name):
            val idx = sym_names.len()
            sym_names = sym_names + [func.name]
            sym_name_to_idx[func.name] = idx

    # Count content sections for symbol index offset
    var num_cs_a = 1
    var has_rodata_a = false
    var has_data_a = false
    for entry in module.data_sections:
        if entry.is_readonly:
            has_rodata_a = true
        else:
            has_data_a = true
    if has_rodata_a:
        num_cs_a = num_cs_a + 1
    if has_data_a:
        num_cs_a = num_cs_a + 1
    val sym_base_a = 1 + num_cs_a

    # Concatenate function code (AArch64: 4-byte instruction alignment)
    for func in ordered_funcs:
        # Check for phase boundary (4KB page alignment)
        if phase_boundaries.contains(func.name):
            val page_size = phase_boundaries[func.name]
            val current_offset = all_code.len()
            val aligned_offset = ((current_offset + page_size - 1) / page_size) * page_size
            val boundary_padding = aligned_offset - current_offset
            for i in 0..boundary_padding:
                all_code = all_code + [0x00]

        # Standard 4-byte instruction alignment
        var padding = all_code.len() % 4
        if padding != 0:
            padding = 4 - padding
        for i in 0..padding:
            all_code = all_code + [0x00]
        func_offsets[func.name] = all_code.len()

        val code_start = all_code.len()
        all_code = all_code + func.code

        # Adjust relocation offsets
        for reloc in func.relocations:
            var reloc_type = ElfRelocType.Aarch64_Call26
            if reloc.reloc_type == 2:
                reloc_type = ElfRelocType.Aarch64_AdrPrelPgHi21

            var sym_idx = 0
            if sym_name_to_idx.contains(reloc.symbol_name):
                sym_idx = sym_name_to_idx[reloc.symbol_name]
            val elf_reloc = ElfReloc(
                offset: code_start + reloc.offset,
                reloc_type: reloc_type,
                symbol_index: sym_base_a + sym_idx,
                addend: reloc.addend
            )
            all_relocs = all_relocs + [elf_reloc]

    # Create .text section
    var text_section = new_text_section(all_code)
    for reloc in all_relocs:
        text_section = section_add_reloc(text_section, reloc)
    writer = elf_add_section(writer, text_section)

    # Create .rodata section
    var rodata_bytes: [i64] = []
    for entry in module.data_sections:
        if entry.is_readonly:
            rodata_bytes = rodata_bytes + entry.data
    if rodata_bytes.len() > 0:
        writer = elf_add_section(writer, new_rodata_section(rodata_bytes))

    # Create .data section
    var data_bytes: [i64] = []
    for entry in module.data_sections:
        if not entry.is_readonly:
            data_bytes = data_bytes + entry.data
    if data_bytes.len() > 0:
        writer = elf_add_section(writer, new_data_section(data_bytes))

    # Add data label symbols (local, in rodata)
    for entry in module.data_sections:
        if entry.is_readonly:
            if data_label_offsets_a.contains(entry.name):
                val sym = ElfSymbol(
                    name: entry.name,
                    sym_bind: ElfSymbolBind.Local,
                    sym_type: ElfSymbolType.Object,
                    section_index: 2,
                    value: data_label_offsets_a[entry.name],
                    size: entry.data.len()
                )
                writer = elf_add_symbol(writer, sym)

    # Add symbols
    for ext_sym in module.extern_symbols:
        writer = elf_add_symbol(writer, new_extern_symbol(ext_sym))

    for func in encoded_funcs:
        var offset = 0
        if func_offsets.contains(func.name):
            offset = func_offsets[func.name]
        val sym = new_func_symbol(func.name, 1, offset, func.code.len())
        writer = elf_add_symbol(writer, sym)

    write_elf64(writer)

# ============================================================================
# ELF Emission - RISC-V 64
# ============================================================================

fn emit_elf_riscv64(
    encoded_funcs: [EncodedFunction],
    module: MachModule,
    mir_module: MirModule
) -> [i64]:
    var writer = elf_writer_riscv64()

    # Phase 4a: Generate layout plan and reorder functions
    val layout_plan = solve_layout(mir_module, nil)  # nil = no profile data yet
    val ordered_funcs = reorder_by_layout(encoded_funcs, layout_plan)

    # Track phase boundaries for padding
    var phase_boundaries: Dict<text, i64> = {}
    for group in layout_plan.groups:
        if group.functions.len() > 0:
            phase_boundaries[group.functions[0].name] = 4096  # 4KB padding

    # Combine all function code into a single .text section
    var all_code: [i64] = []
    var func_offsets: Dict<text, i64> = {}
    var all_relocs: [ElfReloc] = []
    var sym_names: [text] = []
    var sym_name_to_idx: Dict<text, i64> = {}

    # Collect data entry labels
    var rodata_offset_r = 0
    var data_label_offsets_r: Dict<text, i64> = {}
    for entry in module.data_sections:
        if entry.is_readonly:
            if not sym_name_to_idx.contains(entry.name):
                val idx = sym_names.len()
                sym_names = sym_names + [entry.name]
                sym_name_to_idx[entry.name] = idx
                data_label_offsets_r[entry.name] = rodata_offset_r
            rodata_offset_r = rodata_offset_r + entry.data.len()

    # Collect extern symbols
    for ext_sym in module.extern_symbols:
        if not sym_name_to_idx.contains(ext_sym):
            val idx = sym_names.len()
            sym_names = sym_names + [ext_sym]
            sym_name_to_idx[ext_sym] = idx

    # Collect function names (use ordered functions for correct layout)
    for func in ordered_funcs:
        if not sym_name_to_idx.contains(func.name):
            val idx = sym_names.len()
            sym_names = sym_names + [func.name]
            sym_name_to_idx[func.name] = idx

    # Count content sections
    var num_cs_r = 1
    var has_rodata_r = false
    var has_data_r = false
    for entry in module.data_sections:
        if entry.is_readonly:
            has_rodata_r = true
        else:
            has_data_r = true
    if has_rodata_r:
        num_cs_r = num_cs_r + 1
    if has_data_r:
        num_cs_r = num_cs_r + 1
    val sym_base_r = 1 + num_cs_r

    # Concatenate function code (RISC-V: 4-byte instruction alignment)
    for func in ordered_funcs:
        # Check for phase boundary (4KB page alignment)
        if phase_boundaries.contains(func.name):
            val page_size = phase_boundaries[func.name]
            val current_offset = all_code.len()
            val aligned_offset = ((current_offset + page_size - 1) / page_size) * page_size
            val boundary_padding = aligned_offset - current_offset
            for i in 0..boundary_padding:
                all_code = all_code + [0x00]

        # Standard 4-byte instruction alignment
        var padding = all_code.len() % 4
        if padding != 0:
            padding = 4 - padding
        for i in 0..padding:
            all_code = all_code + [0x00]
        func_offsets[func.name] = all_code.len()

        val code_start = all_code.len()
        all_code = all_code + func.code

        # Adjust relocation offsets
        for reloc in func.relocations:
            var reloc_type = ElfRelocType.Riscv_CallPlt
            if reloc.reloc_type == 23:
                reloc_type = ElfRelocType.Riscv_PcrelHi20
            elif reloc.reloc_type == 24:
                reloc_type = ElfRelocType.Riscv_PcrelLo12I

            var sym_idx = 0
            if sym_name_to_idx.contains(reloc.symbol_name):
                sym_idx = sym_name_to_idx[reloc.symbol_name]
            val elf_reloc = ElfReloc(
                offset: code_start + reloc.offset,
                reloc_type: reloc_type,
                symbol_index: sym_base_r + sym_idx,
                addend: reloc.addend
            )
            all_relocs = all_relocs + [elf_reloc]

    # Create .text section
    var text_section = new_text_section(all_code)
    for reloc in all_relocs:
        text_section = section_add_reloc(text_section, reloc)
    writer = elf_add_section(writer, text_section)

    # Create .rodata section
    var rodata_bytes: [i64] = []
    for entry in module.data_sections:
        if entry.is_readonly:
            rodata_bytes = rodata_bytes + entry.data
    if rodata_bytes.len() > 0:
        writer = elf_add_section(writer, new_rodata_section(rodata_bytes))

    # Create .data section
    var data_bytes: [i64] = []
    for entry in module.data_sections:
        if not entry.is_readonly:
            data_bytes = data_bytes + entry.data
    if data_bytes.len() > 0:
        writer = elf_add_section(writer, new_data_section(data_bytes))

    # Add data label symbols (local, in rodata)
    for entry in module.data_sections:
        if entry.is_readonly:
            if data_label_offsets_r.contains(entry.name):
                val sym = ElfSymbol(
                    name: entry.name,
                    sym_bind: ElfSymbolBind.Local,
                    sym_type: ElfSymbolType.Object,
                    section_index: 2,
                    value: data_label_offsets_r[entry.name],
                    size: entry.data.len()
                )
                writer = elf_add_symbol(writer, sym)

    # Add symbols
    for ext_sym in module.extern_symbols:
        writer = elf_add_symbol(writer, new_extern_symbol(ext_sym))

    for func in encoded_funcs:
        var offset = 0
        if func_offsets.contains(func.name):
            offset = func_offsets[func.name]
        val sym = new_func_symbol(func.name, 1, offset, func.code.len())
        writer = elf_add_symbol(writer, sym)

    write_elf64(writer)

# ============================================================================
# Exports
# ============================================================================

export emit_elf_x86_64, emit_elf_aarch64, emit_elf_riscv64
