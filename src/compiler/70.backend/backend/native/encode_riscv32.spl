# RISC-V 32-bit Instruction Encoder
#
# Encodes MachInst to raw bytes for RISC-V 32-bit (RV32I+M) architecture.
# All RISC-V instructions are fixed-length: exactly 4 bytes (32-bit), little-endian.
#
# The instruction encoding formats are identical between RV32 and RV64:
#   R-type: funct7[31:25] | rs2[24:20] | rs1[19:15] | funct3[14:12] | rd[11:7] | opcode[6:0]
#   I-type: imm[31:20]   | rs1[19:15] | funct3[14:12] | rd[11:7]    | opcode[6:0]
#   S-type: imm[31:25]   | rs2[24:20] | rs1[19:15] | funct3[14:12] | imm[11:7] | opcode[6:0]
#   B-type: imm[12|10:5] | rs2[24:20] | rs1[19:15] | funct3[14:12] | imm[4:1|11] | opcode[6:0]
#   U-type: imm[31:12]   | rd[11:7]   | opcode[6:0]
#   J-type: imm[20|10:1|11|19:12] | rd[11:7] | opcode[6:0]
#
# Key RV32 differences from RV64:
# - LI only needs to materialize 32-bit values (LUI + ADDI is sufficient)
# - No LD/SD instructions for pointer-sized access (use LW/SW)
# - ELF output is ELFCLASS32 with 32-bit headers
# - R-type ALU opcode is 0x33 (same as RV64I base, no W-suffix variants)

use compiler.backend.native.mach_inst.{MachReg, MachRegKind, physical_reg, reg_id, Operand, OperandKind, MachInst, MachBlock, MachFunction, MachModule, EncodedReloc, EncodedFunction, new_encoded_function}
use compiler.backend.native.mach_inst.{RV_X0, RV_X1, RV_X2, RV_X3, RV_X4, RV_X5, RV_X6, RV_X7, RV_X8, RV_X9, RV_X10, RV_X11, RV_X12, RV_X13, RV_X14, RV_X15, RV_X16, RV_X17, RV_X18, RV_X19, RV_X20, RV_X21, RV_X22, RV_X23, RV_X24, RV_X25, RV_X26, RV_X27, RV_X28, RV_X29, RV_X30, RV_X31}
use compiler.backend.native.mach_inst.{RV_OP_ADD, RV_OP_SUB, RV_OP_MUL, RV_OP_DIV, RV_OP_REM, RV_OP_AND, RV_OP_OR, RV_OP_XOR, RV_OP_SLL, RV_OP_SRA, RV_OP_SRL, RV_OP_SLT, RV_OP_SLTU, RV_OP_ADDI, RV_OP_LUI, RV_OP_AUIPC, RV_OP_JAL, RV_OP_JALR, RV_OP_BEQ, RV_OP_BNE, RV_OP_BLT, RV_OP_BGE, RV_OP_LD, RV_OP_SD, RV_OP_LW, RV_OP_SW, RV_OP_MV, RV_OP_LI, RV_OP_NOP, RV_OP_RET, RV_OP_CALL, RV_OP_NEG, RV_OP_NOT, RV_OP_SEQZ, RV_OP_SNEZ}
use compiler.backend.native.operand_utils.{get_phys_reg_id, get_mem_base_id, get_mem_offset, get_imm_value, get_label_id, get_sym_name}
use compiler.backend.native.encode_common.{encode_module_with}
use compiler.backend.native.riscv_encoding.{riscv_emit_u32_le, riscv_encode_r_type, riscv_encode_i_type, riscv_encode_s_type, riscv_encode_b_type, riscv_encode_u_type, riscv_encode_j_type, riscv_alu_funct7, riscv_alu_funct3, riscv_branch_funct3}

# ============================================================================
# ELF32 Constants for RISC-V 32-bit
# ============================================================================

# ELF identification
val ELF32_EI_CLASS = 1       # ELFCLASS32
val ELF32_HEADER_SIZE = 52   # 32-bit ELF header is 52 bytes
val ELF32_PHDR_SIZE = 32     # 32-bit program header entry is 32 bytes
val ELF32_SHDR_SIZE = 40     # 32-bit section header entry is 40 bytes
val ELF32_SYM_SIZE = 16      # 32-bit symbol table entry is 16 bytes
val ELF32_REL_SIZE = 8       # 32-bit relocation entry is 8 bytes
val ELF32_RELA_SIZE = 12     # 32-bit relocation+addend entry is 12 bytes
val EM_RISCV = 0xF3          # e_machine value for RISC-V

# Emit a 16-bit value as 2 little-endian bytes (for ELF32 headers).
fn emit_u16_le_rv32(buf: [i64], value: i64) -> [i64]:
    var masked = value
    if masked < 0:
        masked = masked + 65536
    val b0 = masked % 256
    val b1 = (masked / 256) % 256
    var result = buf
    result = result + [b0, b1]
    result

# ============================================================================
# Encode Context
# ============================================================================

struct Rv32EncodeContext:
    code: [i64]
    relocations: [EncodedReloc]
    block_offsets: Dict<i64, i64>
    pending_jumps: [Rv32PendingJump]

struct Rv32PendingJump:
    code_offset: i64
    target_block: i64
    jump_kind: i64

# Jump kinds (same as RV64 - encoding format is identical)
val RV32_JUMP_JAL = 0       # J-type (JAL)
val RV32_JUMP_BRANCH = 1    # B-type (BEQ/BNE/BLT/BGE)

fn rv32_new_encode_context() -> Rv32EncodeContext:
    Rv32EncodeContext(code: [], relocations: [], block_offsets: {}, pending_jumps: [])

# Relocation type for RISC-V CALL (AUIPC+JALR pair) - same for RV32 and RV64
val RV32_R_RISCV_CALL_PLT = 19

# ============================================================================
# Load Immediate Helper
# ============================================================================

# Encode LI rd, imm - loads a 32-bit immediate into rd.
# For small values (fits in 12-bit signed): ADDI rd, x0, imm
# For 32-bit values: LUI + ADDI
# RV32 never needs more than LUI + ADDI since the address space is 32-bit.
fn encode_li_rv32(code: [i64], rd: i64, imm: i64) -> [i64]:
    var result = code
    # Truncate to 32-bit and sign-extend
    var imm32 = imm and 0xFFFFFFFF
    if imm32 >= 2147483648:
        imm32 = imm32 - 4294967296

    # Small immediate: fits in signed 12-bit [-2048, 2047]
    if imm32 >= -2048:
        if imm32 <= 2047:
            # ADDI rd, x0, imm
            val enc = riscv_encode_i_type(imm32 and 0xFFF, RV_X0, 0, rd, 0x13)
            result = riscv_emit_u32_le(result, enc)
            return result

    # 32-bit range: use LUI + ADDI
    # LUI loads imm[31:12], ADDI adds imm[11:0]
    # If bit 11 is set, LUI upper needs +1 to compensate for sign extension
    var upper = (bit_shr(imm32, 12)) and 0xFFFFF
    val lower = imm32 and 0xFFF
    # Check if lower 12 bits are negative when sign-extended
    if lower >= 2048:
        upper = upper + 1
    val lui_enc = riscv_encode_u_type(upper and 0xFFFFF, rd, 0x37)
    result = riscv_emit_u32_le(result, lui_enc)
    # Only emit ADDI if lower bits are nonzero
    if lower != 0:
        val addi_enc = riscv_encode_i_type(lower, rd, 0, rd, 0x13)
        result = riscv_emit_u32_le(result, addi_enc)
    result

# ============================================================================
# Instruction Encoding
# ============================================================================

fn encode_inst_rv32(ectx: Rv32EncodeContext, inst: MachInst) -> Rv32EncodeContext:
    var code = ectx.code
    var relocs = ectx.relocations
    var pending = ectx.pending_jumps

    if inst.opcode == RV_OP_NOP:
        # NOP = ADDI x0, x0, 0 = 0x00000013
        code = riscv_emit_u32_le(code, 0x00000013)

    elif inst.opcode == RV_OP_RET:
        # RET = JALR x0, x1, 0 = 0x00008067
        code = riscv_emit_u32_le(code, 0x00008067)

    elif inst.opcode == RV_OP_MV:
        # MV rd, rs = ADDI rd, rs, 0
        val rd = get_phys_reg_id(inst.operands[0])
        val rs = get_phys_reg_id(inst.operands[1])
        val enc = riscv_encode_i_type(0, rs, 0, rd, 0x13)
        code = riscv_emit_u32_le(code, enc)

    elif inst.opcode == RV_OP_LI:
        # LI rd, imm (pseudo-instruction, variable length)
        val rd = get_phys_reg_id(inst.operands[0])
        val imm = get_imm_value(inst.operands[1])
        code = encode_li_rv32(code, rd, imm)

    elif inst.opcode == RV_OP_ADD or inst.opcode == RV_OP_SUB or inst.opcode == RV_OP_MUL or inst.opcode == RV_OP_DIV or inst.opcode == RV_OP_REM or inst.opcode == RV_OP_AND or inst.opcode == RV_OP_OR or inst.opcode == RV_OP_XOR or inst.opcode == RV_OP_SLL or inst.opcode == RV_OP_SRA or inst.opcode == RV_OP_SRL or inst.opcode == RV_OP_SLT or inst.opcode == RV_OP_SLTU:
        # R-type ALU: rd, rs1, rs2
        # RV32I base opcode 0x33 (same as RV64I base, no W-suffix variants)
        val rd = get_phys_reg_id(inst.operands[0])
        val rs1 = get_phys_reg_id(inst.operands[1])
        val rs2 = get_phys_reg_id(inst.operands[2])
        val funct7 = riscv_alu_funct7(inst.opcode)
        val funct3 = riscv_alu_funct3(inst.opcode)
        val enc = riscv_encode_r_type(funct7, rs2, rs1, funct3, rd, 0x33)
        code = riscv_emit_u32_le(code, enc)

    elif inst.opcode == RV_OP_ADDI:
        # ADDI rd, rs1, imm12: I-type funct3=0x0, opcode=0x13
        val rd = get_phys_reg_id(inst.operands[0])
        val rs1 = get_phys_reg_id(inst.operands[1])
        val imm12 = get_imm_value(inst.operands[2])
        val enc = riscv_encode_i_type(imm12 and 0xFFF, rs1, 0, rd, 0x13)
        code = riscv_emit_u32_le(code, enc)

    elif inst.opcode == RV_OP_NEG:
        # NEG rd, rs = SUB rd, x0, rs
        val rd = get_phys_reg_id(inst.operands[0])
        val rs = get_phys_reg_id(inst.operands[1])
        val enc = riscv_encode_r_type(0x20, rs, RV_X0, 0, rd, 0x33)
        code = riscv_emit_u32_le(code, enc)

    elif inst.opcode == RV_OP_NOT:
        # NOT rd, rs = XORI rd, rs, -1
        val rd = get_phys_reg_id(inst.operands[0])
        val rs = get_phys_reg_id(inst.operands[1])
        val enc = riscv_encode_i_type(0xFFF, rs, 4, rd, 0x13)
        code = riscv_emit_u32_le(code, enc)

    elif inst.opcode == RV_OP_SEQZ:
        # SEQZ rd, rs = SLTIU rd, rs, 1
        val rd = get_phys_reg_id(inst.operands[0])
        val rs = get_phys_reg_id(inst.operands[1])
        val enc = riscv_encode_i_type(1, rs, 3, rd, 0x13)
        code = riscv_emit_u32_le(code, enc)

    elif inst.opcode == RV_OP_SNEZ:
        # SNEZ rd, rs = SLTU rd, x0, rs
        val rd = get_phys_reg_id(inst.operands[0])
        val rs = get_phys_reg_id(inst.operands[1])
        val enc = riscv_encode_r_type(0x00, rs, RV_X0, 3, rd, 0x33)
        code = riscv_emit_u32_le(code, enc)

    elif inst.opcode == RV_OP_LUI:
        # LUI rd, imm20: U-type opcode=0x37
        val rd = get_phys_reg_id(inst.operands[0])
        val imm20 = get_imm_value(inst.operands[1])
        val enc = riscv_encode_u_type(imm20, rd, 0x37)
        code = riscv_emit_u32_le(code, enc)

    elif inst.opcode == RV_OP_AUIPC:
        # AUIPC rd, imm20: U-type opcode=0x17
        val rd = get_phys_reg_id(inst.operands[0])
        match inst.operands[1].kind:
            case Sym(name):
                val reloc_offset = code_len(code)
                val enc = riscv_encode_u_type(0, rd, 0x17)
                code = riscv_emit_u32_le(code, enc)
                val reloc = EncodedReloc(
                    offset: reloc_offset,
                    symbol_name: name,
                    reloc_type: RV32_R_RISCV_CALL_PLT,
                    addend: 0
                )
                relocs = relocs + [reloc]
            case Imm(v):
                val enc = riscv_encode_u_type(v, rd, 0x17)
                code = riscv_emit_u32_le(code, enc)
            case _:
                val enc = riscv_encode_u_type(0, rd, 0x17)
                code = riscv_emit_u32_le(code, enc)

    elif inst.opcode == RV_OP_LW:
        # LW rd, offset(rs1): I-type funct3=0x2, opcode=0x03
        val rd = get_phys_reg_id(inst.operands[0])
        val base = get_mem_base_id(inst.operands[1])
        val offset = get_mem_offset(inst.operands[1])
        val enc = riscv_encode_i_type(offset and 0xFFF, base, 2, rd, 0x03)
        code = riscv_emit_u32_le(code, enc)

    elif inst.opcode == RV_OP_SW:
        # SW rs2, offset(rs1): S-type funct3=0x2, opcode=0x23
        val rs2 = get_phys_reg_id(inst.operands[0])
        val base = get_mem_base_id(inst.operands[1])
        val offset = get_mem_offset(inst.operands[1])
        val enc = riscv_encode_s_type(offset and 0xFFF, rs2, base, 2, 0x23)
        code = riscv_emit_u32_le(code, enc)

    elif inst.opcode == RV_OP_LD:
        # On RV32, LD is not a native instruction. Treat as LW for compatibility.
        # This handles cases where MIR still emits LD even when targeting RV32.
        val rd = get_phys_reg_id(inst.operands[0])
        val base = get_mem_base_id(inst.operands[1])
        val offset = get_mem_offset(inst.operands[1])
        val enc = riscv_encode_i_type(offset and 0xFFF, base, 2, rd, 0x03)
        code = riscv_emit_u32_le(code, enc)

    elif inst.opcode == RV_OP_SD:
        # On RV32, SD is not a native instruction. Treat as SW for compatibility.
        # This handles cases where MIR still emits SD even when targeting RV32.
        val rs2 = get_phys_reg_id(inst.operands[0])
        val base = get_mem_base_id(inst.operands[1])
        val offset = get_mem_offset(inst.operands[1])
        val enc = riscv_encode_s_type(offset and 0xFFF, rs2, base, 2, 0x23)
        code = riscv_emit_u32_le(code, enc)

    elif inst.opcode == RV_OP_JAL:
        # JAL rd, offset: J-type opcode=0x6F
        val rd = get_phys_reg_id(inst.operands[0])
        match inst.operands[1].kind:
            case Label(block_id):
                val jump_offset = code_len(code)
                val enc = riscv_encode_j_type(0, rd, 0x6F)
                code = riscv_emit_u32_le(code, enc)
                pending = pending + [Rv32PendingJump(code_offset: jump_offset, target_block: block_id, jump_kind: RV32_JUMP_JAL)]
            case Imm(v):
                val enc = riscv_encode_j_type(v, rd, 0x6F)
                code = riscv_emit_u32_le(code, enc)
            case _:
                val enc = riscv_encode_j_type(0, rd, 0x6F)
                code = riscv_emit_u32_le(code, enc)

    elif inst.opcode == RV_OP_JALR:
        # JALR rd, rs1, imm12: I-type funct3=0x0, opcode=0x67
        val rd = get_phys_reg_id(inst.operands[0])
        val rs1 = get_phys_reg_id(inst.operands[1])
        val imm12 = get_imm_value(inst.operands[2])
        val enc = riscv_encode_i_type(imm12 and 0xFFF, rs1, 0, rd, 0x67)
        code = riscv_emit_u32_le(code, enc)

    elif inst.opcode == RV_OP_BEQ or inst.opcode == RV_OP_BNE or inst.opcode == RV_OP_BLT or inst.opcode == RV_OP_BGE:
        # B-type branches: BEQ(f3=0), BNE(f3=1), BLT(f3=4), BGE(f3=5)
        val rs1 = get_phys_reg_id(inst.operands[0])
        val rs2 = get_phys_reg_id(inst.operands[1])
        val funct3 = riscv_branch_funct3(inst.opcode)
        match inst.operands[2].kind:
            case Label(block_id):
                val jump_offset = code_len(code)
                val enc = riscv_encode_b_type(0, rs2, rs1, funct3, 0x63)
                code = riscv_emit_u32_le(code, enc)
                pending = pending + [Rv32PendingJump(code_offset: jump_offset, target_block: block_id, jump_kind: RV32_JUMP_BRANCH)]
            case _:
                val enc = riscv_encode_b_type(0, rs2, rs1, funct3, 0x63)
                code = riscv_emit_u32_le(code, enc)

    elif inst.opcode == RV_OP_CALL:
        # CALL symbol (pseudo): AUIPC x1, offset_hi; JALR x1, x1, offset_lo
        # Emits 8 bytes (2 instructions), with R_RISCV_CALL_PLT relocation on the pair
        match inst.operands[0].kind:
            case Sym(name):
                val reloc_offset = code_len(code)
                # AUIPC x1(ra), 0 - placeholder upper
                val auipc_enc = riscv_encode_u_type(0, RV_X1, 0x17)
                code = riscv_emit_u32_le(code, auipc_enc)
                # JALR x1(ra), x1(ra), 0 - placeholder lower
                val jalr_enc = riscv_encode_i_type(0, RV_X1, 0, RV_X1, 0x67)
                code = riscv_emit_u32_le(code, jalr_enc)
                # Record relocation for the AUIPC+JALR pair
                val reloc = EncodedReloc(
                    offset: reloc_offset,
                    symbol_name: name,
                    reloc_type: RV32_R_RISCV_CALL_PLT,
                    addend: 0
                )
                relocs = relocs + [reloc]
            case Label(block_id):
                # Intra-function call via JAL x1, offset
                val jump_offset = code_len(code)
                val enc = riscv_encode_j_type(0, RV_X1, 0x6F)
                code = riscv_emit_u32_le(code, enc)
                pending = pending + [Rv32PendingJump(code_offset: jump_offset, target_block: block_id, jump_kind: RV32_JUMP_JAL)]
            case _:
                # Fallback: emit NOP pair
                code = riscv_emit_u32_le(code, 0x00000013)
                code = riscv_emit_u32_le(code, 0x00000013)

    else:
        # Unknown opcode - emit EBREAK (0x00100073) for debug
        code = riscv_emit_u32_le(code, 0x00100073)

    Rv32EncodeContext(code: code, relocations: relocs, block_offsets: ectx.block_offsets, pending_jumps: pending)

# ============================================================================
# Jump Patching
# ============================================================================

# Patch a 32-bit instruction at byte_offset with a branch/jump displacement.
fn patch_jump_rv32(code: [i64], byte_offset: i64, rel_offset: i64, kind: i64) -> [i64]:
    var patched = code
    # Read existing 4-byte LE instruction
    val b0 = patched[byte_offset]
    val b1 = patched[byte_offset + 1]
    val b2 = patched[byte_offset + 2]
    val b3 = patched[byte_offset + 3]
    val old_inst = b0 or (bit_shl(b1, 8)) or (bit_shl(b2, 16)) or (bit_shl(b3, 24))

    var new_inst = old_inst
    if kind == RV32_JUMP_JAL:
        # J-type: re-encode with the displacement
        # Extract rd and opcode from existing instruction
        val rd = (bit_shr(old_inst, 7)) and 0x1F
        val opcode = old_inst and 0x7F
        new_inst = riscv_encode_j_type(rel_offset, rd, opcode)
    elif kind == RV32_JUMP_BRANCH:
        # B-type: re-encode with the displacement
        # Extract rs1, rs2, funct3, opcode from existing instruction
        val rs1 = (bit_shr(old_inst, 15)) and 0x1F
        val rs2 = (bit_shr(old_inst, 20)) and 0x1F
        val funct3 = (bit_shr(old_inst, 12)) and 0x7
        val opcode = old_inst and 0x7F
        new_inst = riscv_encode_b_type(rel_offset, rs2, rs1, funct3, opcode)

    # Handle negative instruction values before byte extraction
    var unsigned_inst = new_inst
    if unsigned_inst < 0:
        unsigned_inst = unsigned_inst + 4294967296

    # Write back as 4 LE bytes using division/modulo
    patched[byte_offset] = unsigned_inst % 256
    patched[byte_offset + 1] = (unsigned_inst / 256) % 256
    patched[byte_offset + 2] = (unsigned_inst / 65536) % 256
    patched[byte_offset + 3] = (unsigned_inst / 16777216) % 256
    patched

# ============================================================================
# Function Encoding (two-pass)
# ============================================================================

fn encode_function_rv32(func: MachFunction) -> EncodedFunction:
    var ectx = rv32_new_encode_context()

    # Pass 1: encode all instructions, record block offsets and pending jumps
    for block in func.blocks:
        var offsets = ectx.block_offsets
        offsets[block.block_id] = ectx.code_len(code)
        ectx = Rv32EncodeContext(code: ectx.code, relocations: ectx.relocations, block_offsets: offsets, pending_jumps: ectx.pending_jumps)

        for inst in block.insts:
            ectx = encode_inst_rv32(ectx, inst)

    # Pass 2: patch branch/jump targets
    var final_code = ectx.code
    for i in 0..ectx.pending_jumps_len(pending_jumps):
        val pj = ectx.pending_jumps[i]
        val target_block = pj.target_block
        if ectx.block_offsets_contains(block_offsets, target_block):
            val target_offset = ectx.block_offsets[target_block]
            val rel_offset = target_offset - pj.code_offset
            final_code = patch_jump_rv32(final_code, pj.code_offset, rel_offset, pj.jump_kind)

    EncodedFunction(name: func.name, code: final_code, relocations: ectx.relocations)

# ============================================================================
# Module Encoding
# ============================================================================

fn encode_module_rv32(module: MachModule) -> [EncodedFunction]:
    encode_module_with(module, encode_function_rv32)

# ============================================================================
# ELF32 Header Generation for RISC-V 32-bit
# ============================================================================

# Generate a minimal ELF32 header for RISC-V 32-bit executable.
# Returns the header as a byte array.
fn rv32_elf32_header(entry_point: i64, phdr_count: i64, shdr_count: i64, shstrndx: i64) -> [i64]:
    var hdr: [i64] = []

    # e_ident[0..3]: ELF magic number
    hdr = hdr + [0x7F, 0x45, 0x4C, 0x46]

    # e_ident[4]: EI_CLASS = ELFCLASS32 (1)
    hdr = hdr + [ELF32_EI_CLASS]

    # e_ident[5]: EI_DATA = ELFDATA2LSB (1) - little endian
    hdr = hdr + [1]

    # e_ident[6]: EI_VERSION = EV_CURRENT (1)
    hdr = hdr + [1]

    # e_ident[7]: EI_OSABI = ELFOSABI_NONE (0)
    hdr = hdr + [0]

    # e_ident[8..15]: EI_ABIVERSION + padding (8 bytes of zero)
    hdr = hdr + [0, 0, 0, 0, 0, 0, 0, 0]

    # e_type: ET_EXEC (2) - 16-bit
    hdr = emit_u16_le_rv32(hdr, 2)

    # e_machine: EM_RISCV (0xF3) - 16-bit
    hdr = emit_u16_le_rv32(hdr, EM_RISCV)

    # e_version: EV_CURRENT (1) - 32-bit
    hdr = riscv_emit_u32_le(hdr, 1)

    # e_entry: entry point address - 32-bit (not 64-bit)
    hdr = riscv_emit_u32_le(hdr, entry_point)

    # e_phoff: program header table offset - 32-bit
    # Program headers immediately follow the ELF header
    hdr = riscv_emit_u32_le(hdr, ELF32_HEADER_SIZE)

    # e_shoff: section header table offset - 32-bit (0 = no section headers yet)
    hdr = riscv_emit_u32_le(hdr, 0)

    # e_flags: processor-specific flags - 32-bit
    # RISC-V flags: 0x0 for RV32I (float ABI = soft)
    hdr = riscv_emit_u32_le(hdr, 0)

    # e_ehsize: ELF header size - 16-bit
    hdr = emit_u16_le_rv32(hdr, ELF32_HEADER_SIZE)

    # e_phentsize: program header entry size - 16-bit
    hdr = emit_u16_le_rv32(hdr, ELF32_PHDR_SIZE)

    # e_phnum: number of program header entries - 16-bit
    hdr = emit_u16_le_rv32(hdr, phdr_count)

    # e_shentsize: section header entry size - 16-bit
    hdr = emit_u16_le_rv32(hdr, ELF32_SHDR_SIZE)

    # e_shnum: number of section header entries - 16-bit
    hdr = emit_u16_le_rv32(hdr, shdr_count)

    # e_shstrndx: section header string table index - 16-bit
    hdr = emit_u16_le_rv32(hdr, shstrndx)

    hdr

# Generate a 32-bit ELF program header (PT_LOAD segment).
fn rv32_elf32_phdr_load(offset: i64, vaddr: i64, filesz: i64, memsz: i64, flags: i64) -> [i64]:
    var phdr: [i64] = []

    # p_type: PT_LOAD (1) - 32-bit
    phdr = riscv_emit_u32_le(phdr, 1)

    # p_offset: offset in file - 32-bit
    phdr = riscv_emit_u32_le(phdr, offset)

    # p_vaddr: virtual address - 32-bit
    phdr = riscv_emit_u32_le(phdr, vaddr)

    # p_paddr: physical address - 32-bit (same as vaddr for simple executables)
    phdr = riscv_emit_u32_le(phdr, vaddr)

    # p_filesz: size in file - 32-bit
    phdr = riscv_emit_u32_le(phdr, filesz)

    # p_memsz: size in memory - 32-bit
    phdr = riscv_emit_u32_le(phdr, memsz)

    # p_flags: segment permissions - 32-bit
    # PF_R=4, PF_W=2, PF_X=1
    phdr = riscv_emit_u32_le(phdr, flags)

    # p_align: alignment - 32-bit
    phdr = riscv_emit_u32_le(phdr, 4096)

    phdr

# ============================================================================
# Exports
# ============================================================================

export Rv32EncodeContext, rv32_new_encode_context, Rv32PendingJump
export RV32_JUMP_JAL, RV32_JUMP_BRANCH, RV32_R_RISCV_CALL_PLT
export ELF32_EI_CLASS, ELF32_HEADER_SIZE, ELF32_PHDR_SIZE, ELF32_SHDR_SIZE, ELF32_SYM_SIZE, ELF32_REL_SIZE, ELF32_RELA_SIZE, EM_RISCV
export encode_function_rv32, encode_inst_rv32, encode_module_rv32
export rv32_elf32_header, rv32_elf32_phdr_load
export emit_u16_le_rv32
