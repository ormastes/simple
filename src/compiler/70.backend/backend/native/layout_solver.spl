# Layout Solver for Native Binary Compilation
#
# Optimizes function layout for better code locality and reduced page faults.
# Implements 4KB page-aligned layout optimization strategy.
#
# Algorithm:
# 1. Group functions by LayoutPhase (Startup, FirstFrame, Steady, Cold)
# 2. Calculate hotness scores based on call graph and execution profile
# 3. Pack functions into 4KB bins using First-Fit Decreasing
# 4. Generate ordered symbol list with phase boundaries and alignment

use mir_data.{MirModule, MirFunction, LayoutPhase}

# ============================================================================
# Data Structures
# ============================================================================

struct LayoutPlan:
    """Complete layout plan for a binary."""
    groups: [LayoutGroup]
    total_size: i64
    page_count: i64

struct LayoutGroup:
    """Group of functions in the same phase."""
    phase: LayoutPhase
    functions: [LayoutFunctionInfo]
    start_offset: i64
    total_size: i64
    page_aligned: bool

struct LayoutFunctionInfo:
    """Function information for layout."""
    name: text
    symbol_id: i64
    estimated_size: i64
    hotness_score: f64
    phase: LayoutPhase

struct HotnessProfile:
    """Profile data for hotness calculation."""
    call_counts: Dict<text, i64>
    execution_counts: Dict<text, i64>

    static fn empty() -> HotnessProfile:
        HotnessProfile(call_counts: {}, execution_counts: {})

# ============================================================================
# Main Layout Solver
# ============================================================================

fn solve_layout(module: MirModule, profile: HotnessProfile?) -> LayoutPlan:
    """
    Generate optimal layout plan for module.

    Steps:
    1. Extract function information
    2. Calculate hotness scores
    3. Group by phase
    4. Sort within phases by hotness
    5. Pack into 4KB-aligned pages
    6. Generate layout plan
    """
    # Extract function info
    var func_infos: [LayoutFunctionInfo] = []
    for (symbol_id, func) in module.functions:
        val info = extract_function_info(func, symbol_id, profile)
        func_infos.push(info)

    # Group by phase
    val groups = group_by_phase(func_infos)

    # Sort each group by hotness (hottest first)
    var sorted_groups: [LayoutGroup] = []
    var current_offset = 0

    for group in groups:
        val sorted_funcs = sort_by_hotness(group.functions)
        val group_size = calculate_group_size(sorted_funcs)

        sorted_groups.push(LayoutGroup(
            phase: group.phase,
            functions: sorted_funcs,
            start_offset: current_offset,
            total_size: group_size,
            page_aligned: true
        ))

        # Align to 4KB page boundary
        current_offset = align_to_page(current_offset + group_size)

    val total_size = current_offset
    val page_count = total_size / 4096

    LayoutPlan(
        groups: sorted_groups,
        total_size: total_size,
        page_count: page_count
    )

# ============================================================================
# Function Information Extraction
# ============================================================================

fn extract_function_info(
    func: MirFunction,
    symbol_id: i64,
    profile: HotnessProfile?
) -> LayoutFunctionInfo:
    """Extract layout-relevant information from MIR function."""

    # Estimate function size (rough approximation)
    val estimated_size = estimate_function_size(func)

    # Calculate hotness score
    val hotness = calculate_hotness(func.name, profile)

    # Determine phase (from attribute or heuristics)
    val phase = func.layout_phase ?? infer_phase(func)

    LayoutFunctionInfo(
        name: func.name,
        symbol_id: symbol_id,
        estimated_size: estimated_size,
        hotness_score: hotness,
        phase: phase
    )

fn estimate_function_size(func: MirFunction) -> i64:
    """Estimate function size in bytes (rough approximation)."""
    # Simple heuristic: count basic blocks and estimate instructions
    val block_count = func.blocks.len()
    val estimated_instructions = block_count * 10  # ~10 instructions per block
    val bytes_per_instruction = 4  # Average instruction size

    estimated_instructions * bytes_per_instruction

fn calculate_hotness(name: text, profile: HotnessProfile?) -> f64:
    """Calculate hotness score for function."""
    if not profile.?:
        return default_hotness(name)

    val prof = profile.unwrap()

    # Get call count and execution count
    val call_count = prof.call_counts.get(name) ?? 0
    val exec_count = prof.execution_counts.get(name) ?? 0

    # Weighted score: 70% execution, 30% calls
    val score = (exec_count * 0.7) + (call_count * 0.3)
    score.to_f64()

fn default_hotness(name: text) -> f64:
    """Default hotness when no profile data available."""
    # Heuristics based on function name
    if name.starts_with("main") or name.starts_with("init"):
        return 100.0  # Very hot
    elif name.starts_with("error_") or name.starts_with("panic_"):
        return 1.0    # Very cold
    elif name.starts_with("test_"):
        return 0.1    # Extremely cold
    else:
        return 50.0   # Medium

fn infer_phase(func: MirFunction) -> LayoutPhase:
    """Infer layout phase from function characteristics."""
    val name = func.name

    # Startup functions
    if name.contains("init") or name.contains("startup") or name.contains("_start"):
        return LayoutPhase.Startup

    # Cold functions (error handling, cleanup)
    if name.contains("error") or name.contains("panic") or name.contains("abort"):
        return LayoutPhase.Cold
    if name.contains("cleanup") or name.contains("destroy") or name.contains("free"):
        return LayoutPhase.Cold

    # Test functions
    if name.contains("test_") or name.contains("_test"):
        return LayoutPhase.Cold

    # Default: steady state
    LayoutPhase.Steady

# ============================================================================
# Grouping and Sorting
# ============================================================================

fn group_by_phase(funcs: [LayoutFunctionInfo]) -> [LayoutGroup]:
    """Group functions by layout phase."""
    var startup_funcs: [LayoutFunctionInfo] = []
    var first_frame_funcs: [LayoutFunctionInfo] = []
    var steady_funcs: [LayoutFunctionInfo] = []
    var cold_funcs: [LayoutFunctionInfo] = []

    for func in funcs:
        match func.phase:
            LayoutPhase.Startup:
                startup_funcs.push(func)
            LayoutPhase.FirstFrame:
                first_frame_funcs.push(func)
            LayoutPhase.Steady:
                steady_funcs.push(func)
            LayoutPhase.Cold:
                cold_funcs.push(func)

    var groups: [LayoutGroup] = []

    if startup_funcs.len() > 0:
        groups.push(LayoutGroup(
            phase: LayoutPhase.Startup,
            functions: startup_funcs,
            start_offset: 0,
            total_size: 0,
            page_aligned: true
        ))

    if first_frame_funcs.len() > 0:
        groups.push(LayoutGroup(
            phase: LayoutPhase.FirstFrame,
            functions: first_frame_funcs,
            start_offset: 0,
            total_size: 0,
            page_aligned: true
        ))

    if steady_funcs.len() > 0:
        groups.push(LayoutGroup(
            phase: LayoutPhase.Steady,
            functions: steady_funcs,
            start_offset: 0,
            total_size: 0,
            page_aligned: true
        ))

    if cold_funcs.len() > 0:
        groups.push(LayoutGroup(
            phase: LayoutPhase.Cold,
            functions: cold_funcs,
            start_offset: 0,
            total_size: 0,
            page_aligned: true
        ))

    groups

fn sort_by_hotness(funcs: [LayoutFunctionInfo]) -> [LayoutFunctionInfo]:
    """Sort functions by hotness score (descending)."""
    # Simple bubble sort for now (TODO: use efficient sort when available)
    var sorted = funcs
    var n = sorted.len()

    var i = 0
    while i < n:
        var j = 0
        while j < n - i - 1:
            if sorted[j].hotness_score < sorted[j + 1].hotness_score:
                # Swap
                val temp = sorted[j]
                sorted[j] = sorted[j + 1]
                sorted[j + 1] = temp
            j = j + 1
        i = i + 1

    sorted

fn calculate_group_size(funcs: [LayoutFunctionInfo]) -> i64:
    """Calculate total size of function group."""
    var total = 0
    for func in funcs:
        total = total + func.estimated_size
    total

# ============================================================================
# Alignment and Packing
# ============================================================================

fn align_to_page(offset: i64) -> i64:
    """Align offset to 4KB page boundary."""
    val page_size = 4096
    val remainder = offset % page_size
    if remainder == 0:
        return offset
    offset + (page_size - remainder)

fn pack_into_pages(funcs: [LayoutFunctionInfo]) -> [[LayoutFunctionInfo]]:
    """Pack functions into 4KB pages using First-Fit Decreasing."""
    val page_size = 4096
    var pages: [[LayoutFunctionInfo]] = []
    var current_page: [LayoutFunctionInfo] = []
    var current_size = 0

    # Sort by size (descending) for better packing
    val sorted = sort_by_size(funcs)

    for func in sorted:
        if current_size + func.estimated_size > page_size:
            # Start new page
            if current_page.len() > 0:
                pages.push(current_page)
            current_page = [func]
            current_size = func.estimated_size
        else:
            # Fit in current page
            current_page.push(func)
            current_size = current_size + func.estimated_size

    # Add last page
    if current_page.len() > 0:
        pages.push(current_page)

    pages

fn sort_by_size(funcs: [LayoutFunctionInfo]) -> [LayoutFunctionInfo]:
    """Sort functions by size (descending)."""
    var sorted = funcs
    var n = sorted.len()

    var i = 0
    while i < n:
        var j = 0
        while j < n - i - 1:
            if sorted[j].estimated_size < sorted[j + 1].estimated_size:
                val temp = sorted[j]
                sorted[j] = sorted[j + 1]
                sorted[j + 1] = temp
            j = j + 1
        i = i + 1

    sorted

# ============================================================================
# Layout Plan Formatting
# ============================================================================

fn format_layout_plan(plan: LayoutPlan) -> text:
    """Format layout plan as human-readable text."""
    var lines: [text] = []

    lines.push("Layout Plan:")
    lines.push("  Total Size: {plan.total_size} bytes")
    lines.push("  Pages: {plan.page_count}")
    lines.push("")

    for group in plan.groups:
        val phase_name = format_phase(group.phase)
        lines.push("  Phase: {phase_name}")
        lines.push("    Offset: {group.start_offset}")
        lines.push("    Size: {group.total_size}")
        lines.push("    Functions: {group.functions.len()}")

        for func in group.functions:
            lines.push("      - {func.name} (size={func.estimated_size}, hot={func.hotness_score})")

        lines.push("")

    lines.join("\n")

fn format_phase(phase: LayoutPhase) -> text:
    """Format phase name."""
    match phase:
        LayoutPhase.Startup: "Startup"
        LayoutPhase.FirstFrame: "FirstFrame"
        LayoutPhase.Steady: "Steady"
        LayoutPhase.Cold: "Cold"

# ============================================================================
# Exports
# ============================================================================

export LayoutPlan, LayoutGroup, LayoutFunctionInfo, HotnessProfile
export solve_layout, format_layout_plan
