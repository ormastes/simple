# CMake Generation for Multi-File C Backend Output
#
# When the C backend outputs to a directory, this module generates:
# - Per-module .cpp files (one per MIR module)
# - Per-subdirectory CMakeLists.txt (OBJECT libraries or add_subdirectory)
# - Root generated_sources.cmake for inclusion by the main CMakeLists.txt

extern fn rt_file_write_text(path: text, content: text) -> bool
extern fn rt_dir_create(path: text, recursive: bool) -> bool
extern fn rt_path_join(a: text, b: text) -> text

val CMAKE_HEADER = r"# Auto-generated by Simple compiler -- DO NOT EDIT"

fn generate_cmake_for_modules(output_dir: text, module_files: [(text, text)], log: Any) -> text?:
    """Generate CMake infrastructure for multi-file C backend output.

    Args:
        output_dir: Root output directory
        module_files: List of (module_name, relative_path) pairs where relative_path
                      is like "main.cpp" or "compiler/core/parser.cpp"
        log: Logger instance

    Returns nil on success, error message on failure.
    """
    # Collect directory info: which dirs have .cpp files, which have subdirs
    var dir_files: {text: [text]} = {}     # dir -> list of .cpp filenames
    var dir_subdirs: {text: [text]} = {}   # dir -> list of immediate child dirs
    var all_dirs: [text] = []              # all unique dirs that contain files
    var root_sources: [text] = []          # .cpp files in the root dir
    var object_libs: [text] = []           # all OBJECT library names

    for entry in module_files:
        val rel_path = entry.1
        val parts = rel_path.split("/")
        if parts.len() == 1:
            # Root-level file
            root_sources.push(rel_path)
        else:
            # File in a subdirectory
            val filename = parts[parts.len() - 1]
            val dir_parts = parts[0:parts.len() - 1]
            val dir_path = dir_parts.join("/")

            if dir_path not in dir_files:
                dir_files[dir_path] = []
                all_dirs.push(dir_path)
            dir_files[dir_path].push(filename)

            # Register parent->child relationships for all intermediate dirs
            var i = dir_parts.len() - 1
            while i > 0:
                val parent = dir_parts[0:i].join("/")
                val child = dir_parts[i]
                if parent not in dir_subdirs:
                    dir_subdirs[parent] = []
                if child not in dir_subdirs[parent]:
                    dir_subdirs[parent].push(child)
                i = i - 1

            # Top-level dir -> register under root
            val top_dir = dir_parts[0]
            if "" not in dir_subdirs:
                dir_subdirs[""] = []
            if top_dir not in dir_subdirs[""]:
                dir_subdirs[""].push(top_dir)

    # Generate leaf CMakeLists.txt (dirs with .cpp files)
    for dir_path in all_dirs:
        val files = dir_files[dir_path]
        val lib_name = "gen_" + dir_path.replace("/", "_")
        object_libs.push(lib_name)

        # Collect child subdirs for this directory (if any)
        var child_subdirs: [text] = []
        if dir_path in dir_subdirs:
            child_subdirs = dir_subdirs[dir_path]

        val cmake_content = generate_leaf_cmake(lib_name, files, child_subdirs)
        val cmake_path = rt_path_join(rt_path_join(output_dir, dir_path), "CMakeLists.txt")
        if not rt_file_write_text(cmake_path, cmake_content):
            return "Failed to write {cmake_path}"

    # Generate intermediate CMakeLists.txt (dirs with only subdirs, no .cpp files)
    for dir_path in dir_subdirs.keys():
        if dir_path == "":
            pass_dn
        elif dir_path not in dir_files:
            val subdirs = dir_subdirs[dir_path]
            val cmake_content = generate_intermediate_cmake(subdirs)
            val cmake_path = rt_path_join(rt_path_join(output_dir, dir_path), "CMakeLists.txt")
            rt_dir_create(rt_path_join(output_dir, dir_path), true)
            if not rt_file_write_text(cmake_path, cmake_content):
                return "Failed to write {cmake_path}"

    # Generate root generated_sources.cmake
    var top_dirs: [text] = []
    if "" in dir_subdirs:
        top_dirs = dir_subdirs[""]
    val root_cmake = generate_root_cmake(top_dirs, root_sources, object_libs)
    val root_cmake_path = rt_path_join(output_dir, "generated_sources.cmake")
    if not rt_file_write_text(root_cmake_path, root_cmake):
        return "Failed to write {root_cmake_path}"

    nil

fn generate_leaf_cmake(lib_name: text, files: [text], child_subdirs: [text]) -> text:
    """Generate CMakeLists.txt for a directory containing .cpp files (OBJECT library)."""
    val runtime_dir = r"${RUNTIME_DIR}"
    val gen_root = r"${SIMPLE_GENERATED_ROOT}"

    var parts = []
    parts.append(CMAKE_HEADER + "\n")
    parts.append("add_library({lib_name} OBJECT\n")
    for file in files:
        parts.append("    {file}\n")
    parts.append(")\n\n")
    parts.append("target_include_directories({lib_name} PRIVATE\n")
    parts.append("    {runtime_dir}\n")
    parts.append("    {runtime_dir}/platform\n")
    parts.append("    {gen_root}\n")
    parts.append(")\n")

    # Add subdirectory references if this dir also has child dirs
    if child_subdirs.len() > 0:
        parts.append("\n")
        for subdir in child_subdirs:
            parts.append("add_subdirectory({subdir})\n")

    parts.join("")

fn generate_intermediate_cmake(subdirs: [text]) -> text:
    """Generate CMakeLists.txt for a directory containing only subdirectories."""
    var parts = []
    parts.append(CMAKE_HEADER + "\n")
    for subdir in subdirs:
        parts.append("add_subdirectory({subdir})\n")
    parts.join("")

fn generate_root_cmake(top_dirs: [text], root_sources: [text], object_libs: [text]) -> text:
    """Generate the root generated_sources.cmake file."""
    val cmake_list_dir = r"${CMAKE_CURRENT_LIST_DIR}"
    val cmake_bin_dir = r"${CMAKE_CURRENT_BINARY_DIR}"

    var parts = []
    parts.append(CMAKE_HEADER + "\n")
    parts.append("# Include from the root CMakeLists.txt:\n")
    parts.append("#   include(<generated-dir>/generated_sources.cmake)\n\n")
    parts.append("set(SIMPLE_GENERATED_ROOT {cmake_list_dir})\n\n")

    # Add top-level subdirectories
    for dir in top_dirs:
        parts.append("add_subdirectory({cmake_list_dir}/{dir} {cmake_bin_dir}/generated_{dir})\n")
    parts.append("\n")

    # Root source files
    parts.append("set(GENERATED_ROOT_SOURCES\n")
    for src in root_sources:
        parts.append("    {cmake_list_dir}/{src}\n")
    parts.append(")\n\n")

    # Object library list
    parts.append("set(GENERATED_OBJECT_LIBS\n")
    for lib in object_libs:
        parts.append("    {lib}\n")
    parts.append(")\n")

    parts.join("")

export generate_cmake_for_modules
