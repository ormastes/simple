# Lean Backend - MIR-to-Lean Translation
#
# Extracted from lean_backend.spl. Contains MIR body/block/instruction
# translation to Lean 4 syntax.

use compiler.mir.mir_data.*

# ============================================================================
# MIR Type to Lean Conversion
# ============================================================================

fn mir_type_to_lean(ty: MirType) -> text:
    """Convert MIR type to Lean 4 type."""
    match ty.kind:
        case I64: "Int"
        case I32: "Int32"
        case I16: "UInt16"
        case I8: "UInt8"
        case F64: "Float"
        case F32: "Float"
        case Bool: "Bool"
        case Unit: "Unit"
        case Ptr(inner, _):
            "Ptr ({mir_type_to_lean(inner)})"
        case Array(elem, size):
            "Array ({mir_type_to_lean(elem)}) {size}"
        case Struct(id):
            "Struct{id}"
        case Tuple(elems):
            val elem_types = elems.map(\e: mir_type_to_lean(e)).join(" x ")
            "({elem_types})"
        case Option(inner):
            "Option ({mir_type_to_lean(inner)})"
        case Result(ok, err):
            "Except ({mir_type_to_lean(err)}) ({mir_type_to_lean(ok)})"
        case _: "Any"

# ============================================================================
# MIR-to-Lean Body Translation
# ============================================================================

fn translate_mir_body(body: MirBody) -> text:
    """Translate a MIR function body to a Lean 4 term.

    Walks the basic blocks and instructions of the MIR body,
    producing a let-binding chain that represents the computation.
    The final value is the return expression.
    """
    if body.blocks.is_empty():
        return "sorry"

    # Translate the entry block and follow the control flow
    var lines: [text] = []
    for block in body.blocks:
        val block_lines = translate_mir_block(block, body)
        for line in block_lines:
            lines = lines.push(line)

    if lines.is_empty():
        return "()"

    lines.join("\n")

fn translate_mir_block(block: MirBlock, body: MirBody) -> [text]:
    """Translate a single MIR basic block to Lean let-bindings."""
    var lines: [text] = []

    # Add block label as a comment if present
    if block.label.?:
        lines = lines.push("-- block: {block.label.unwrap()}")

    # Translate each instruction
    for inst in block.instructions:
        val translated = translate_mir_inst(inst)
        if translated != "":
            lines = lines.push(translated)

    # Translate the terminator
    val term_line = translate_mir_terminator(block.terminator)
    if term_line != "":
        lines = lines.push(term_line)

    lines

fn translate_mir_inst(inst: MirInst) -> text:
    """Translate a single MIR instruction to a Lean let-binding."""
    match inst.kind:
        case Const(dest, value, type_):
            val lean_val = translate_const_value(value)
            "let _l{dest.id} := {lean_val}"

        case Copy(dest, src):
            "let _l{dest.id} := _l{src.id}"

        case Move(dest, src):
            "let _l{dest.id} := _l{src.id}"

        case BinOp(dest, op, left, right):
            val lean_op = translate_binop(op)
            val l = translate_operand(left)
            val r = translate_operand(right)
            "let _l{dest.id} := {l} {lean_op} {r}"

        case UnaryOp(dest, op, operand):
            val lean_op = translate_unaryop(op)
            val o = translate_operand(operand)
            "let _l{dest.id} := {lean_op}{o}"

        case CheckedBinOp(dest, op, left, right):
            val lean_op = translate_binop(op)
            val l = translate_operand(left)
            val r = translate_operand(right)
            "let _l{dest.id} := {l} {lean_op} {r}  -- checked"

        case Alloc(dest, type_):
            val lean_ty = mir_type_to_lean(type_)
            "let _l{dest.id} : Ptr ({lean_ty}) := Ptr.alloc"

        case Load(dest, ptr):
            val p = translate_operand(ptr)
            "let _l{dest.id} := Ptr.read {p}"

        case Store(ptr, value):
            val p = translate_operand(ptr)
            val v = translate_operand(value)
            "let _ := Ptr.write {p} {v}"

        case GetElementPtr(dest, base, indices):
            val b = translate_operand(base)
            val idx_strs = indices.map(\i: translate_operand(i))
            val idx_str = idx_strs.join(" ")
            "let _l{dest.id} := Ptr.offset {b} {idx_str}"

        case Aggregate(dest, kind, operands):
            val ops = operands.map(\o: translate_operand(o))
            val ops_str = ops.join(", ")
            match kind:
                case Tuple:
                    "let _l{dest.id} := ({ops_str})"
                case Array(_):
                    "let _l{dest.id} := #[{ops_str}]"
                case Struct(sym):
                    "let _l{dest.id} := Struct.mk {ops_str}"
                case Enum(sym, variant):
                    "let _l{dest.id} := Enum.variant{variant} {ops_str}"

        case GetField(dest, base, field):
            val b = translate_operand(base)
            "let _l{dest.id} := {b}.{field}"

        case SetField(base, field, value):
            val b = translate_operand(base)
            val v = translate_operand(value)
            "let _ := set_field {b} {field} {v}"

        case Cast(dest, operand, target):
            val o = translate_operand(operand)
            val lean_ty = mir_type_to_lean(target)
            "let _l{dest.id} : {lean_ty} := cast {o}"

        case Call(dest, func, args):
            val f = translate_operand(func)
            val arg_strs = args.map(\a: translate_operand(a))
            val args_str = arg_strs.join(" ")
            if dest.?:
                val d = dest.unwrap()
                "let _l{d.id} := {f} {args_str}"
            else:
                "let _ := {f} {args_str}"

        case Intrinsic(dest, name, args):
            val arg_strs = args.map(\a: translate_operand(a))
            val args_str = arg_strs.join(" ")
            if dest.?:
                val d = dest.unwrap()
                "let _l{d.id} := intrinsic_{name} {args_str}"
            else:
                "let _ := intrinsic_{name} {args_str}"

        case DebugValue(local, name):
            "-- debug: {name} = _l{local.id}"

        case Nop:
            ""

        case _:
            "-- unsupported instruction"

fn translate_mir_terminator(term: MirTerminator) -> text:
    """Translate a MIR terminator to a Lean expression."""
    match term:
        case Return(value):
            if value.?:
                translate_operand(value.unwrap())
            else:
                "()"
        case Goto(target):
            "-- goto block{target.id}"
        case If(cond, then_, else_):
            val c = translate_operand(cond)
            "if {c} then goto_block{then_.id} else goto_block{else_.id}"
        case Switch(value, targets, default):
            val v = translate_operand(value)
            "-- switch {v} (default -> block{default.id})"
        case Unreachable:
            "absurd"
        case Abort(message):
            "panic \"{message}\""
        case CallTerminator(dest, func, args, normal, _):
            val f = translate_operand(func)
            val arg_strs = args.map(\a: translate_operand(a))
            val args_str = arg_strs.join(" ")
            if dest.?:
                val d = dest.unwrap()
                "let _l{d.id} := {f} {args_str}  -- continues at block{normal.id}"
            else:
                "let _ := {f} {args_str}  -- continues at block{normal.id}"

fn translate_operand(op: MirOperand) -> text:
    """Translate a MIR operand to a Lean term."""
    match op.kind:
        case Copy(local):
            "_l{local.id}"
        case Move(local):
            "_l{local.id}"
        case Const(value, _):
            translate_const_value(value)

fn translate_const_value(value: MirConstValue) -> text:
    """Translate a MIR constant value to a Lean literal."""
    match value:
        case Int(v):
            "{v}"
        case Float(v):
            "{v}"
        case Bool(v):
            if v: "true" else: "false"
        case Str(v):
            "\"{v}\""
        case Array(elements):
            val elems = elements.map(\e: translate_const_value(e))
            "#[{elems.join(\", \")}]"
        case Tuple(elements):
            val elems = elements.map(\e: translate_const_value(e))
            "({elems.join(\", \")})"
        case Struct(fields):
            "Struct.mk"
        case Zero:
            "0"

fn translate_binop(op: MirBinOp) -> text:
    """Translate a MIR binary operation to a Lean operator."""
    match op:
        case Add: "+"
        case Sub: "-"
        case Mul: "*"
        case Div: "/"
        case Rem: "%"
        case Pow: "^"
        case Eq: "=="
        case Ne: "!="
        case Lt: "<"
        case Le: "≤"
        case Gt: ">"
        case Ge: "≥"
        case BitAnd: "&&&"
        case BitOr: "|||"
        case BitXor: "^^^"
        case Shl: "<<<"
        case Shr: ">>>"
        case _: "+"

fn translate_unaryop(op: MirUnaryOp) -> text:
    """Translate a MIR unary operation to a Lean operator."""
    match op:
        case Neg: "-"
        case Not: "!"
        case BitNot: "~~~"
        case Transpose: "ᵀ"

export mir_type_to_lean
export translate_mir_body, translate_mir_block, translate_mir_inst
export translate_mir_terminator, translate_operand, translate_const_value
export translate_binop, translate_unaryop
