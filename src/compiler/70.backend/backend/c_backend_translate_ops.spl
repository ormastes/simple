# C Backend - MIR to C++20 Translation Helpers (MirToC lower-level methods)
#
# Lower-level translation helpers split from c_backend_translate.spl.
# Contains: translate_container_call, translate_binop, translate_unaryop,
#           translate_composite_const, translate_operand, translate_const_value,
#           and other helper methods for the MirToC class.
#
# impl MirToC blocks can span files in Simple.

use compiler.mir.mir_data.*
use compiler.backend.c_type_mapper.{CTypeMapper, CTypeMapper__create, CTypeMapper__create_for_target}
use compiler.backend.c_ir_builder.{CIRBuilder, CIRBuilder__create, escape_c_string}
use compiler.core.backend_types.{CodegenTarget, CompileOptions, CompiledModule}

# ============================================================================
# MirToC - Lower-level translation helpers (impl block continued from
# c_backend_translate.spl)
# ============================================================================

impl MirToC:

    me translate_container_call(func_name: text, dest: LocalId?, args: [MirOperand]) -> bool:
        """Intercept spl_array_*/spl_dict_* runtime calls and emit C++ method calls.
        Returns true if the call was handled, false otherwise."""
        var arg_vals: [text] = []
        for arg in args:
            arg_vals = arg_vals.push(self.translate_operand(arg))

        # Array operations
        if func_name == "spl_array_new":
            if dest.?:
                val dest_name = self.get_local(dest.unwrap().id)
                val ty = self.get_local_type(dest.unwrap().id)
                self.builder.emit_assign(dest_name, ty + r"()")
            return true
        elif func_name == "spl_array_push":
            if arg_vals.len() >= 2:
                self.builder.emit(arg_vals[0] + r".push(" + arg_vals[1] + r");")
            return true
        elif func_name == "spl_array_get":
            if dest.? and arg_vals.len() >= 2:
                val dest_name = self.get_local(dest.unwrap().id)
                self.builder.emit_assign(dest_name, arg_vals[0] + r".get(" + arg_vals[1] + r")")
            return true
        elif func_name == "spl_array_len":
            if dest.? and arg_vals.len() >= 1:
                val dest_name = self.get_local(dest.unwrap().id)
                self.builder.emit_assign(dest_name, arg_vals[0] + r".len()")
            return true
        elif func_name == "spl_array_pop":
            if dest.? and arg_vals.len() >= 1:
                val dest_name = self.get_local(dest.unwrap().id)
                self.builder.emit_assign(dest_name, arg_vals[0] + r".pop()")
            return true
        elif func_name == "spl_array_set":
            if arg_vals.len() >= 3:
                self.builder.emit(arg_vals[0] + r".set(" + arg_vals[1] + r", " + arg_vals[2] + r");")
            return true
        # Dict operations
        elif func_name == "spl_dict_new":
            if dest.?:
                val dest_name = self.get_local(dest.unwrap().id)
                val ty = self.get_local_type(dest.unwrap().id)
                self.builder.emit_assign(dest_name, ty + r"()")
            return true
        elif func_name == "spl_dict_set":
            if arg_vals.len() >= 3:
                self.builder.emit(arg_vals[0] + r".set(" + arg_vals[1] + r", " + arg_vals[2] + r");")
            return true
        elif func_name == "spl_dict_get":
            if dest.? and arg_vals.len() >= 2:
                val dest_name = self.get_local(dest.unwrap().id)
                self.builder.emit_assign(dest_name, arg_vals[0] + r".get(" + arg_vals[1] + r")")
            return true
        elif func_name == "spl_dict_contains":
            if dest.? and arg_vals.len() >= 2:
                val dest_name = self.get_local(dest.unwrap().id)
                self.builder.emit_assign(dest_name, arg_vals[0] + r".contains(" + arg_vals[1] + r")")
            return true
        elif func_name == "spl_dict_keys":
            if dest.? and arg_vals.len() >= 1:
                val dest_name = self.get_local(dest.unwrap().id)
                self.builder.emit_assign(dest_name, arg_vals[0] + r".keys()")
            return true
        elif func_name == "spl_dict_len":
            if dest.? and arg_vals.len() >= 1:
                val dest_name = self.get_local(dest.unwrap().id)
                self.builder.emit_assign(dest_name, arg_vals[0] + r".len()")
            return true
        elif func_name == "spl_dict_remove":
            if arg_vals.len() >= 2:
                self.builder.emit(arg_vals[0] + r".remove(" + arg_vals[1] + r");")
            return true

        false

    # === Binary Operations ===

    me translate_binop(dest: LocalId, op: MirBinOp, left: MirOperand, right: MirOperand):
        val dest_name = self.get_local(dest.id)
        val left_val = self.translate_operand(left)
        val right_val = self.translate_operand(right)
        val ty = self.get_local_type(dest.id)

        match op:
            case Add:
                self.builder.emit_binop(dest_name, ty, "+", left_val, right_val)
            case Sub:
                self.builder.emit_binop(dest_name, ty, "-", left_val, right_val)
            case Mul:
                self.builder.emit_binop(dest_name, ty, "*", left_val, right_val)
            case Div:
                self.builder.emit_binop(dest_name, ty, "/", left_val, right_val)
            case Rem:
                self.builder.emit_binop(dest_name, ty, "%", left_val, right_val)
            case Pow:
                self.builder.emit_comment("pow")
                self.builder.emit_assign(dest_name, r"(" + ty + r")__simple_pow(" + left_val + r", " + right_val + r")")

            case BitAnd:
                self.builder.emit_binop(dest_name, ty, "&", left_val, right_val)
            case BitOr:
                self.builder.emit_binop(dest_name, ty, "|", left_val, right_val)
            case BitXor:
                self.builder.emit_binop(dest_name, ty, "^", left_val, right_val)
            case Shl:
                self.builder.emit_binop(dest_name, ty, "<<", left_val, right_val)
            case Shr:
                self.builder.emit_binop(dest_name, ty, ">>", left_val, right_val)

            case Eq:
                self.builder.emit_cmp(dest_name, ty, "==", left_val, right_val)
            case Ne:
                self.builder.emit_cmp(dest_name, ty, "!=", left_val, right_val)
            case Lt:
                self.builder.emit_cmp(dest_name, ty, "<", left_val, right_val)
            case Le:
                self.builder.emit_cmp(dest_name, ty, "<=", left_val, right_val)
            case Gt:
                self.builder.emit_cmp(dest_name, ty, ">", left_val, right_val)
            case Ge:
                self.builder.emit_cmp(dest_name, ty, ">=", left_val, right_val)

            case MatMul:
                self.builder.emit_assign(dest_name, r"(void*)__simple_runtime_matmul((void*)" + left_val + r", (void*)" + right_val + r")")
            case BroadcastAdd:
                self.builder.emit_assign(dest_name, r"(void*)__simple_runtime_broadcast_add((void*)" + left_val + r", (void*)" + right_val + r")")
            case BroadcastSub:
                self.builder.emit_assign(dest_name, r"(void*)__simple_runtime_broadcast_sub((void*)" + left_val + r", (void*)" + right_val + r")")
            case BroadcastMul:
                self.builder.emit_assign(dest_name, r"(void*)__simple_runtime_broadcast_mul((void*)" + left_val + r", (void*)" + right_val + r")")
            case BroadcastDiv:
                self.builder.emit_assign(dest_name, r"(void*)__simple_runtime_broadcast_div((void*)" + left_val + r", (void*)" + right_val + r")")
            case BroadcastPow:
                self.builder.emit_assign(dest_name, r"(void*)__simple_runtime_broadcast_pow((void*)" + left_val + r", (void*)" + right_val + r")")

            case Offset:
                self.builder.emit_assign(dest_name, r"(int64_t)((char*)(intptr_t)" + left_val + r" + " + right_val + r")")

    # === Unary Operations ===

    me translate_unaryop(dest: LocalId, op: MirUnaryOp, operand: MirOperand):
        val dest_name = self.get_local(dest.id)
        val operand_val = self.translate_operand(operand)
        val ty = self.get_local_type(dest.id)

        match op:
            case Neg:
                self.builder.emit_unaryop(dest_name, ty, "-", operand_val)
            case Not:
                self.builder.emit_cmp(dest_name, ty, "==", operand_val, "0")
            case BitNot:
                self.builder.emit_unaryop(dest_name, ty, "~", operand_val)
            case Transpose:
                self.builder.emit_assign(dest_name, r"(void*)__simple_runtime_transpose((void*)" + operand_val + r")")

    # === Helpers ===

    me prepare_stack_slots(body: MirBody):
        self.stack_slots = {}
        self.stack_slot_sizes = {}
        for block in body.blocks:
            for inst in block.instructions:
                match inst.kind:
                    case Alloc(dest, type_):
                        self.ensure_stack_slot(dest.id, self.type_mapper.size_of(type_))
                    case Aggregate(dest, kind, operands):
                        self.ensure_stack_slot(dest.id, operands.len() * 8)
                    case GpuSharedAlloc(dest, type_, size):
                        self.ensure_stack_slot(dest.id, size)
                    case Const(dest, value, type_):
                        val sz = self.const_composite_size(value)
                        if sz > 0:
                            self.ensure_stack_slot(dest.id, sz)
                    case _:
                        pass_dn

    fn slot_name_for_local(local_id: i64) -> text:
        r"_slot_l" + local_id

    fn normalized_slot_size(size: i64) -> i64:
        if size <= 0: 1 else: size

    me ensure_stack_slot(local_id: i64, requested_size: i64) -> text:
        val required = self.normalized_slot_size(requested_size)
        match self.stack_slots.get(local_id):
            case Some(existing):
                val current = self.stack_slot_sizes[local_id]
                if required > current:
                    self.stack_slot_sizes[local_id] = required
                existing
            case nil:
                val slot_name = self.slot_name_for_local(local_id)
                self.stack_slots[local_id] = slot_name
                self.stack_slot_sizes[local_id] = required
                slot_name

    me emit_pointer_assign(dest_local_id: i64, ptr_expr: text):
        val dest_name = self.get_local(dest_local_id)
        val dest_ty = self.get_local_type(dest_local_id)
        if dest_ty == "void*":
            self.builder.emit_assign(dest_name, r"(void*)" + ptr_expr)
        else:
            self.builder.emit_assign(dest_name, r"(int64_t)(intptr_t)((void*)" + ptr_expr + r")")

    fn const_composite_size(value: MirConstValue) -> i64:
        match value:
            case Array(elements):
                if elements.len() == 0: 1 else: elements.len() * 8
            case Tuple(elements):
                if elements.len() == 0: 1 else: elements.len() * 8
            case Struct(fields):
                if fields.len() == 0: 1 else: fields.len() * 8
            case _:
                0

    me translate_composite_const(dest: LocalId, value: MirConstValue) -> bool:
        match value:
            case Array(elements):
                val slot_name = self.ensure_stack_slot(dest.id, self.const_composite_size(value))
                self.emit_pointer_assign(dest.id, slot_name)
                var idx = 0
                for elem in elements:
                    val elem_val = self.const_to_i64_expr(elem)
                    self.builder.emit(r"((int64_t*)(void*)" + slot_name + r")[" + idx + r"] = " + elem_val + r";")
                    idx = idx + 1
                true
            case Tuple(elements):
                val slot_name = self.ensure_stack_slot(dest.id, self.const_composite_size(value))
                self.emit_pointer_assign(dest.id, slot_name)
                var idx = 0
                for elem in elements:
                    val elem_val = self.const_to_i64_expr(elem)
                    self.builder.emit(r"((int64_t*)(void*)" + slot_name + r")[" + idx + r"] = " + elem_val + r";")
                    idx = idx + 1
                true
            case Struct(fields):
                val slot_name = self.ensure_stack_slot(dest.id, self.const_composite_size(value))
                self.emit_pointer_assign(dest.id, slot_name)
                var idx = 0
                for field_name, field_val in fields:
                    val elem_val = self.const_to_i64_expr(field_val)
                    self.builder.emit(r"((int64_t*)(void*)" + slot_name + r")[" + idx + r"] = " + elem_val + r";")
                    idx = idx + 1
                true
            case _:
                false

    me translate_operand(operand: MirOperand) -> text:
        match operand.kind:
            case Copy(local):
                self.get_local(local)
            case Move(local):
                self.get_local(local)
            case Const(value, type_):
                self.translate_const_value(value)

    me translate_const_value(value: MirConstValue) -> text:
        match value:
            case Int(val): r"" + val
            case Float(val): r"" + val
            case Bool(val): if val: "1" else: "0"
            case Str(val):
                val var_name = self.builder.add_string_literal(val)
                r"(const char*)" + var_name
            case Zero: "0"
            case Array(elements):
                if elements.len() == 0:
                    "0 /* empty array */"
                else:
                    var init_vals: [text] = []
                    for elem in elements:
                        init_vals = init_vals.push(self.const_to_i64_expr(elem))
                    r"([]() -> int64_t { static int64_t v[" + elements.len() + r"] = {" + init_vals.join(", ") + r"}; return (int64_t)(intptr_t)v; }())"
            case Tuple(elements):
                if elements.len() == 0:
                    "0 /* empty tuple */"
                else:
                    var init_vals: [text] = []
                    for elem in elements:
                        init_vals = init_vals.push(self.const_to_i64_expr(elem))
                    r"([]() -> int64_t { static int64_t v[" + elements.len() + r"] = {" + init_vals.join(", ") + r"}; return (int64_t)(intptr_t)v; }())"
            case Struct(fields):
                if fields.len() == 0:
                    "0 /* empty struct */"
                else:
                    var init_vals: [text] = []
                    for field_name, field_val in fields:
                        init_vals = init_vals.push(self.const_to_i64_expr(field_val))
                    r"([]() -> int64_t { static int64_t v[" + fields.len() + r"] = {" + init_vals.join(", ") + r"}; return (int64_t)(intptr_t)v; }())"

    me const_to_i64_expr(value: MirConstValue) -> text:
        match value:
            case Int(val):
                r"" + val
            case Float(val):
                r"(int64_t)(" + val + r")"
            case Bool(val):
                if val: "1" else: "0"
            case Str(_):
                val str_expr = self.translate_const_value(value)
                r"(int64_t)(intptr_t)(" + str_expr + r")"
            case Zero:
                "0"
            case _:
                val nested = self.translate_const_value(value)
                r"(int64_t)(intptr_t)(" + nested + r")"

    fn get_local(id: i64) -> text:
        r"_l" + id

    fn get_local_type(id: i64) -> text:
        match self.local_types.get(id):
            case Some(ty): ty
            case nil: "int64_t"

    fn get_local_type_from_body(body: MirBody, id: i64) -> text:
        if id < body.locals.len():
            self.type_mapper.map_type(body.locals[id].type_)
        else:
            "int64_t"

    fn get_operand_type(operand: MirOperand) -> text:
        match operand.kind:
            case Copy(local): self.get_local_type(local)
            case Move(local): self.get_local_type(local)
            case Const(value, type_): self.type_mapper.map_type(type_)

    fn zero_value(ty: text) -> text:
        if ty == "void*":
            "nullptr"
        elif ty == "double" or ty == "float":
            "0.0"
        elif ty == "const char*":
            "nullptr"
        else:
            "0"
