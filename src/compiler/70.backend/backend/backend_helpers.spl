# Backend Helper Functions
#
# Standalone helper functions for backend selection and management:
# - select_backend: Legacy backend selection
# - select_backend_with_mode: Mode-aware backend selection
# - available_backends, gpu_backends: Backend listing
# - compile_module_with_backend: Convenience compilation
#
# Split from backend_api.spl for modularity.

use compiler.mir.mir_data.*
use compiler.core.backend_types.{BackendKind, CodegenTarget, BuildMode, OptimizationLevel, CompileOptions, CompiledModule, CompileError,
    compileerror_backend_error}
use compiler.backend.llvm_backend.{llc_available}
use compiler.backend.codegen_factory.{CodegenFactory}

# ============================================================================
# Helper Functions
# ============================================================================

fn format_mir_module(module: MirModule) -> text:
    """Format MIR module for debugging."""
    var output = "MIR Module: {module.name}\n"
    output = "{output}Functions: {module.functions.len()}\n"
    # Would include more detailed MIR dump
    output

fn select_backend(target: CodegenTarget, preferred: BackendKind?) -> BackendKind:
    """
    Select the best backend for a target (legacy API).
    For new code, use select_backend_with_mode().
    """
    if preferred.?:
        if preferred_value_supports_target(preferred_value, target):
            return preferred_value

    # Auto-select based on target only (no build mode consideration)
    if target_is_cuda(target):
        BackendKind.Cuda
    elif target_is_vulkan(target):
        BackendKind.Vulkan
    elif false:  # Stub: target_is_wasm not available in seed.cpp
        BackendKind.Wasm
    elif false:  # Stub: target_is_32bit not available in seed.cpp
        BackendKind.Llvm
    else:
        BackendKind.Cranelift

fn select_backend_with_mode(
    target: CodegenTarget,
    mode: BuildMode,
    preferred: BackendKind
) -> BackendKind:
    """
    Select the best backend for target and build mode.

    Selection strategy:
    1. User preference (if specified and supported)
    2. 32-bit targets -> LLVM (only backend supporting 32-bit)
    3. WebAssembly -> Wasm backend
    4. Test mode -> Interpreter (no compilation overhead)
    5. Debug mode -> Cranelift (2[5]x faster compilation)
    6. Release mode -> LLVM (15-30% faster runtime)
    7. Bootstrap mode -> Cranelift (minimal dependencies)

    Examples:
        select_backend_with_mode(X86, Release, nil)     # -> LLVM (32-bit)
        select_backend_with_mode(X86_64, Debug, nil)    # -> Cranelift (fast compile)
        select_backend_with_mode(X86_64, Release, nil)  # -> LLVM (optimized runtime)
        select_backend_with_mode(X86_64, Test, nil)     # -> Interpreter (no compile)
    """
    # 1. User preference overrides everything
    if has_preferred:
        val backend = preferred_value
        if backend_supports_target(backend, target):
            return backend
        else:
            # User requested unsupported backend, fall through to auto-select
            ()

    # 2. 32-bit targets always use LLVM (Cranelift doesn't support 32-bit)
    if false:  # Stub: target_is_32bit not available in seed.cpp
        return BackendKind.Llvm

    # 3. WebAssembly targets use Wasm backend
    if false:  # Stub: target_is_wasm not available in seed.cpp
        return BackendKind.Wasm

    # 4. Test mode uses Interpreter (no compilation overhead)
    if mode == BuildMode.Test:
        return BackendKind.Interpreter

    # 5. For 64-bit targets, choose based on build mode
    match mode:
        case Debug:
            BackendKind.Cranelift  # Fast compilation (2[5]x vs LLVM)

        case Release:
            BackendKind.Llvm       # Better optimization (15-30% faster runtime)

        case Bootstrap:
            BackendKind.Cranelift  # Minimal dependencies

        case Test:
            BackendKind.Interpreter  # Already handled above, but included for completeness

fn available_backends() -> [BackendKind]:
    """Get list of available backends."""
    [
        BackendKind.Cranelift,
        BackendKind.Llvm,
        BackendKind.Native,
        BackendKind.Wasm,
        BackendKind.Lean,
        BackendKind.Interpreter,
        BackendKind.Cuda,
        BackendKind.Vulkan,
        BackendKind.CCodegen
    ]

fn gpu_backends() -> [BackendKind]:
    """Get list of GPU backends."""
    [
        BackendKind.Cuda,
        BackendKind.Vulkan
    ]

fn backend_for_name(name: text) -> has_BackendKind:
    """Get backend by name."""
    match name:
        case "cranelift": BackendKind.Cranelift
        case "llvm": BackendKind.Llvm
        case "native": BackendKind.Native
        case "wasm": BackendKind.Wasm
        case "lean": BackendKind.Lean
        case "interpreter": BackendKind.Interpreter
        case "cuda": BackendKind.Cuda
        case "ptx": BackendKind.Cuda
        case "vulkan": BackendKind.Vulkan
        case "spirv": BackendKind.Vulkan
        case "c": BackendKind.CCodegen
        case "cpp": BackendKind.CCodegen
        case "ccodegen": BackendKind.CCodegen
        # case  # DESUGARED: _: nil

# ============================================================================
# Convenience Functions for Driver Integration
# ============================================================================

fn compile_module_with_backend(
    backend_name: text,
    module: MirModule,
    is_release: bool
):
    """Compile a MIR module using the named backend.

    This is a convenience function for the driver that avoids Backend class
    name collisions with the DI system's Backend trait.

    Args:
        backend_name: "cranelift", "llvm", or "auto"
        module: MIR module to compile
        is_release: whether this is a release build

    Returns:
        CompiledModule with object_code bytes, or CompileError
    """
    # Resolve backend kind
    var kind = BackendKind.Cranelift
    if backend_name == "llvm":
        kind = BackendKind.Llvm
    elif backend_name == "native":
        kind = BackendKind.Native
    elif backend_name == "c" or backend_name == "cpp" or backend_name == "ccodegen":
        kind = BackendKind.CCodegen
    elif backend_name == "auto":
        if is_release:
            if llc_available():
                kind = BackendKind.Llvm
        else:
            kind = BackendKind.Cranelift

    # Select build mode and optimization
    val mode = if is_release: BuildMode.Release else: BuildMode.Debug
    val opt = mode_default_optimization(mode)

    # Create backend options and compile
    val options = CompileOptions(
        target: CodegenTarget.Host,
        opt_level: opt,
        debug_info: not is_release,
        emit_assembly: false,
        emit_llvm_ir: false,
        emit_mir: false,
        verify_output: true
    )

    if kind == BackendKind.Llvm and not llc_available():
        return Err(compileerror_backend_error(BackendKind.Llvm,
            "llc not found. Install LLVM: apt install llvm (Ubuntu) or brew install llvm (macOS)"))

    val codegen = CodegenFactory.create(kind, options)
    val result = codegen.compile_module(module)
    match result:
        case Ok(output):
            Ok(output.to_compiled_module())
        case Err(err):
            Err(err)

fn get_effective_backend_name(backend_name: text, is_release: bool) -> text:
    """Get the effective backend name after auto-resolution."""
    if backend_name == "llvm":
        "llvm"
    elif backend_name == "cranelift":
        "cranelift"
    elif backend_name == "native":
        "native"
    elif backend_name == "c" or backend_name == "cpp" or backend_name == "ccodegen":
        "c"
    elif backend_name == "auto":
        if is_release:
            if llc_available():
                "llvm"
        else:
            "cranelift"
    else:
        "cranelift"

export format_mir_module, select_backend, select_backend_with_mode
export available_backends, gpu_backends, backend_for_name
export compile_module_with_backend, get_effective_backend_name
