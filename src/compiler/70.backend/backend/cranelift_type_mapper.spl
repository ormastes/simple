# Cranelift Type Mapper - Cranelift-Specific Type Mapping Implementation
#
# Maps MIR types to Cranelift IR type strings.
# Implements TypeMapper trait for Cranelift backend.

use compiler.mir.mir_data.*
use compiler.backend.common.type_mapper.*

# ============================================================================
# Cranelift Type Mapper
# ============================================================================

class CraneliftTypeMapper:
    """
    Maps MIR types to Cranelift IR type representations.

    Cranelift uses value types:
    - Integers: I64, I32, I16, I8
    - Floats: F64, F32
    - References: R64 (64-bit reference)

    Note: Cranelift only supports 64-bit targets.
    For 32-bit, use LLVM backend instead.

    Example mappings:
        I64 → "I64"
        F64 → "F64"
        Ptr(_) → "R64"  (reference type)
        Bool → "I8"  (i8 with 0/1 values)
    """

    target_bits: i64  # 32 or 64 for pointer size (Cranelift supports 64-bit only)

    static fn create() -> CraneliftTypeMapper:
        """Create Cranelift type mapper (default 64-bit)."""
        CraneliftTypeMapper(target_bits: 64)

    static fn create_for_target(target: CodegenTarget) -> CraneliftTypeMapper:
        """
        Create mapper for specific target.
        Note: Cranelift only supports 64-bit targets. 32-bit will error.
        """
        if target.is_32bit():
            error("Cranelift does not support 32-bit targets. Use LLVM backend instead.")
        CraneliftTypeMapper(target_bits: 64)

impl TypeMapper for CraneliftTypeMapper:
    fn map_primitive(ty: PrimitiveType) -> text:
        """
        Map primitive types to Cranelift IR types.

        Cranelift primitives (uppercase):
        - Integers: I64, I32, I16, I8
        - Floats: F64, F32
        - Boolean: I8 (represented as 0/1 in i8)
        - Unit: (special handling, no direct type)
        """
        match ty:
            case I64: "I64"
            case I32: "I32"
            case I16: "I16"
            case I8: "I8"
            case F64: "F64"
            case F32: "F32"
            case Bool: "I8"  # Boolean as i8 (0 or 1)
            case Unit: "I64"  # Unit represented as dummy i64 (0)

    fn map_pointer(pointee: text, mutability: Mutability) -> text:
        """
        Map pointer types to Cranelift IR.

        Cranelift uses R64 (reference type) for all pointers.
        This is always 64-bit since Cranelift only supports 64-bit targets.

        Mutability is tracked at value level, not type level.
        """
        "R64"  # All pointers are R64 in Cranelift

    fn backend_name() -> text:
        "Cranelift"

impl CraneliftTypeMapper:
    # === Custom Cranelift-specific methods ===

    fn map_struct(fields: [(text, MirType)]) -> text:
        """
        Map struct type to Cranelift representation.

        Cranelift doesn't have first-class struct types.
        Structs are represented as memory blocks (referenced by R64).

        Returns: "R64" (pointer to struct in memory)
        """
        "R64"  # Struct as heap-allocated memory

    fn map_array(element: MirType, size: i64) -> text:
        """
        Map array type to Cranelift representation.

        Cranelift doesn't have first-class array types.
        Arrays are memory blocks referenced by R64.

        Returns: "R64" (pointer to array in memory)
        """
        "R64"  # Array as heap-allocated memory

    fn map_tuple(elements: [MirType]) -> text:
        """
        Map tuple type to Cranelift representation.

        Like structs, tuples are memory blocks.

        Returns: "R64" (pointer to tuple in memory)
        """
        "R64"  # Tuple as heap-allocated memory

    fn map_function(params: [MirType], ret: MirType) -> text:
        """
        Map function type to Cranelift function reference.

        All function pointers are R64 (reference type).

        Returns: "R64" (function pointer)
        """
        "R64"  # Function pointer

    fn map_function_signature(params: [MirType], ret: MirType) -> text:
        """
        Map function signature (for declarations).

        Cranelift signatures: (param_types...) -> ret_type

        Example:
            (I64, I64) -> I64 → "(I64, I64) -> I64"
        """
        val param_types = params.map(\p: self.map_type(p))
        val ret_type = self.map_type(ret)
        "({param_types.join(", ")}) -> {ret_type}"

    fn is_primitive(ty: MirType) -> bool:
        """
        Check if type is a Cranelift primitive (can be in SSA values).

        Primitives: I64, I32, I16, I8, F64, F32
        Non-primitives: Structs, arrays, tuples (must use R64)
        """
        match ty.kind:
            case I64 | I32 | I16 | I8 | F64 | F32 | Bool:
                true
            case _:
                false

    fn needs_memory(ty: MirType) -> bool:
        """
        Check if type needs heap allocation (vs stack/register).

        Memory types: Struct, Array, Tuple (size > threshold)
        Register types: Primitives, small tuples
        """
        match ty.kind:
            case Struct(_) | Array(_, _):
                true
            case Tuple(elements):
                # Small tuples (≤2 elements) can be in registers
                elements.length > 2
            case _:
                false

    # === Size and alignment (64-bit only) ===

    fn size_of(ty: MirType) -> i64:
        """
        Get size in bytes of a type (Cranelift 64-bit).

        All pointers are 8 bytes (64-bit only).
        """
        match ty.kind:
            case I64 | F64: 8
            case I32 | F32: 4
            case I16: 2
            case I8 | Bool: 1
            case Unit: 0
            case Ptr(_, _): 8  # Always 64-bit
            case Struct(fields):
                fields.map(\f: self.size_of(f.1)).sum()
            case Array(elem, size):
                self.size_of(elem) * size
            case Tuple(elements):
                elements.map(\e: self.size_of(e)).sum()
            case _:
                error("Cannot compute size of {ty}")

    fn align_of(ty: MirType) -> i64:
        """
        Get alignment in bytes of a type (Cranelift rules).

        Standard alignment:
        - 8-byte types: 8-byte alignment
        - 4-byte types: 4-byte alignment
        - Smaller: natural alignment
        """
        match ty.kind:
            case I64 | F64 | Ptr(_, _): 8
            case I32 | F32: 4
            case I16: 2
            case I8 | Bool: 1
            case Struct(fields):
                if fields.length == 0:
                    1
                else:
                    fields.map(\f: self.align_of(f.1)).max()
            case Array(elem, _):
                self.align_of(elem)
            case Tuple(elements):
                if elements.length == 0:
                    1
                else:
                    elements.map(\e: self.align_of(e)).max()
            case _:
                1

# ============================================================================
# Export
# ============================================================================

# Export desugared static method names
fn CraneliftTypeMapper__create() -> CraneliftTypeMapper:
    CraneliftTypeMapper.create()

fn CraneliftTypeMapper__create_for_target(target: CodegenTarget) -> CraneliftTypeMapper:
    CraneliftTypeMapper.create_for_target(target)

export CraneliftTypeMapper
export CraneliftTypeMapper__create, CraneliftTypeMapper__create_for_target
