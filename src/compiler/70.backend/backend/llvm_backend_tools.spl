# LLVM Backend Tools
#
# CLI tool finders (find_llc, find_opt, etc.), IR-to-object compilation,
# WASM support, and optimization level mapping.
# Split from llvm_backend.spl.

use compiler.core.backend_types.{CompiledSymbol, CompiledSymbolKind, CodegenTarget, OptimizationLevel}
use compiler.backend.llvm_target.{LlvmTargetConfig}
use compiler.mir_opt.mod.{OptLevel}
use compiler.interp.interpreter.llvm.tools (find_llc as llvm_find_llc, find_opt as llvm_find_opt, llc_available as llvm_llc_available, opt_available as llvm_opt_available, find_wasm_ld as llvm_find_wasm_ld, find_wasm_opt as llvm_find_wasm_opt, find_wasi_sysroot as llvm_find_wasi_sysroot)
use app.io.mod (shell, file_write, file_delete, file_exists, getpid, time_now_unix_micros)

# FFI for reading files (object code + optimized IR)
extern fn rt_file_read_bytes(path: text) -> [u8]
extern fn rt_file_read_text(path: text) -> text

# ============================================================================
# LLVM IR → Object Code Compilation (via llc CLI)
# ============================================================================

fn find_llc() -> text?:
    """
    Find llc binary with fallback chain: llc-18 → llc-17 → llc.

    Returns the command name if found, otherwise nil.
    Uses shared shared.llvm.tools implementation.
    """
    val tool = llvm_find_llc()
    if tool == "":
        nil
    else:
        Some(tool)

fn find_opt() -> text?:
    """
    Find LLVM opt binary with fallback chain: opt-18 → opt-17 → opt.

    Returns the command name if found, otherwise nil.
    Uses shared shared.llvm.tools implementation.
    """
    val tool = llvm_find_opt()
    if tool == "":
        nil
    else:
        Some(tool)

fn opt_available() -> bool:
    """Check if opt (LLVM optimizer) is available on PATH."""
    llvm_opt_available()

fn llc_available() -> bool:
    """Check if llc (LLVM static compiler) is available on PATH."""
    llvm_llc_available()

fn find_wasm_ld() -> text:
    """Find wasm-ld binary. Returns command name or empty string."""
    llvm_find_wasm_ld()

fn find_wasm_opt() -> text:
    """Find wasm-opt binary. Returns command name or empty string."""
    llvm_find_wasm_opt()

fn find_wasi_sysroot() -> text:
    """Find WASI sysroot directory. Returns path or empty string."""
    llvm_find_wasi_sysroot()

struct LlvmObjectCode:
    """Object code bytes with extracted symbol information."""
    bytes: [u8]
    symbols: [CompiledSymbol]

fn extract_symbols_nm(obj_path: text) -> [CompiledSymbol]:
    """Extract defined symbols from an object file using nm.

    Parses nm output to identify function, data, and constant symbols.
    Skips undefined (U) and weak (W/w) symbols.
    """
    val nm_result = shell("nm '{obj_path}' 2>/dev/null")
    if nm_result.exit_code != 0:
        return []

    var symbols: [CompiledSymbol] = []
    val lines = nm_result.stdout.split("\n")
    for line in lines:
        if line == "":
            continue
        # Filter empty parts from consecutive spaces
        val raw_parts = line.split(" ")
        var parts: [text] = []
        for p in raw_parts:
            if p != "":
                parts = parts + [p]
        val plen = parts.len()
        if plen < 2:
            continue

        # nm output: "address TYPE name" (3+ parts) or "TYPE name" (2 parts)
        var type_code = ""
        var sym_name = ""
        if plen >= 3:
            type_code = parts[plen - 2]
            sym_name = parts[plen - 1]
        else:
            type_code = parts[0]
            sym_name = parts[1]

        if sym_name == "":
            continue

        # Skip undefined and weak symbols
        if type_code == "U" or type_code == "u":
            continue
        if type_code == "W" or type_code == "w":
            continue
        if type_code == "V" or type_code == "v":
            continue

        # Map type code to CompiledSymbolKind
        var kind = CompiledSymbolKind.Function
        if type_code == "T" or type_code == "t":
            kind = CompiledSymbolKind.Function
        elif type_code == "D" or type_code == "d":
            kind = CompiledSymbolKind.Data
        elif type_code == "B" or type_code == "b":
            kind = CompiledSymbolKind.Data
        elif type_code == "R" or type_code == "r":
            kind = CompiledSymbolKind.Const
        else:
            continue

        val sym = CompiledSymbol(name: sym_name, kind: kind, address: 0, size: 0)
        symbols = symbols + [sym]

    symbols

fn compile_ir_to_object(llvm_ir: text, config: LlvmTargetConfig, opt_level: OptimizationLevel):
    """Compile LLVM IR text to object code bytes via llc CLI.

    Writes IR to a temp file, invokes llc, reads back the object bytes.
    Requires llc to be installed (apt install llvm / brew install llvm).

    Tries llc-18, llc-17, llc-16, llc in order (newer versions preferred).
    """
    # Find llc binary
    val llc_cmd = find_llc()
    if not llc_cmd.?:
        return Err(
            "llc not found. Please install LLVM:\n" +
            "  Ubuntu/Debian: apt install llvm\n" +
            "  macOS: brew install llvm\n" +
            "  Arch: pacman -S llvm\n" +
            "  Windows: choco install llvm"
        )

    val llc = llc_cmd.unwrap()
    val pid = getpid()
    val ir_path = "/tmp/simple_llvm_{pid}.ll"
    val obj_path = "/tmp/simple_llvm_{pid}.o"

    # Write IR to temp file
    if not file_write(ir_path, llvm_ir):
        return Err("Failed to write LLVM IR to {ir_path}")

    # Determine optimization flag
    var opt_flag = "-O0"
    if opt_level == OptimizationLevel.Size:
        opt_flag = "-Oz"
    elif opt_level == OptimizationLevel.Speed:
        opt_flag = "-O2"
    elif opt_level == OptimizationLevel.Aggressive:
        opt_flag = "-O3"
    elif opt_level == OptimizationLevel.Debug:
        opt_flag = "-O0"

    # Build llc command
    val triple = config.triple.to_text()
    val cpu = config.to_cpu_string()
    val cmd = "{llc} --filetype=obj --relocation-model=pic -mtriple={triple} -mcpu={cpu} {opt_flag} -o {obj_path} {ir_path} 2>&1"
    val result = shell(cmd)

    # Clean up IR file
    file_delete(ir_path)

    if result.exit_code != 0:
        file_delete(obj_path)
        return Err("llc failed (exit {result.exit_code}):\n{result.stdout}\n\nCommand: {cmd}")

    # Extract symbols before deleting the object file
    val symbols = extract_symbols_nm(obj_path)

    # Read object bytes
    val bytes = rt_file_read_bytes(obj_path)
    file_delete(obj_path)

    if bytes == nil:
        return Err("Failed to read compiled object file: {obj_path}")

    Ok(LlvmObjectCode(bytes: bytes, symbols: symbols))

# ============================================================================
# WASM Runtime Declarations
# ============================================================================

fn generate_wasm_runtime_declarations(target: CodegenTarget) -> text:
    """
    Generate LLVM IR declarations for WASM/WASI runtime functions.

    WASM uses i32 pointers and i32 size types. Runtime functions are
    imported from the host environment (WASI or JavaScript).
    """
    val ptr_ty = if target == CodegenTarget.Wasm32: "i32" else: "i64"
    val size_ty = if target == CodegenTarget.Wasm32: "i32" else: "i64"
    var decls = "; WASM Runtime function declarations\n"

    # Memory operations (provided by WASM runtime)
    decls = decls + "declare ptr @rt_alloc({size_ty})\n"
    decls = decls + "declare ptr @rt_realloc(ptr, {size_ty})\n"
    decls = decls + "declare void @rt_free(ptr)\n"

    # String operations
    decls = decls + "declare {size_ty} @rt_strlen(ptr)\n"
    decls = decls + "declare ptr @rt_strcat(ptr, ptr)\n"
    decls = decls + "declare ptr @rt_substr(ptr, {size_ty}, {size_ty})\n"
    decls = decls + "declare {size_ty} @rt_strfind(ptr, ptr)\n"
    decls = decls + "declare ptr @rt_strreplace(ptr, ptr, ptr)\n"
    decls = decls + "declare ptr @rt_strsplit(ptr, ptr)\n"
    decls = decls + "declare {size_ty} @rt_strcmp(ptr, ptr)\n"

    # Array/Collection operations
    decls = decls + "declare ptr @rt_array_new({size_ty})\n"
    decls = decls + "declare {size_ty} @rt_array_len(ptr)\n"
    decls = decls + "declare ptr @rt_array_get(ptr, {size_ty})\n"
    decls = decls + "declare void @rt_array_set(ptr, {size_ty}, ptr)\n"
    decls = decls + "declare ptr @rt_array_push(ptr, ptr)\n"
    decls = decls + "declare ptr @rt_array_pop(ptr)\n"

    # Dict/Map operations
    decls = decls + "declare ptr @rt_dict_new()\n"
    decls = decls + "declare ptr @rt_dict_get(ptr, ptr)\n"
    decls = decls + "declare void @rt_dict_set(ptr, ptr, ptr)\n"
    decls = decls + "declare i1 @rt_dict_contains(ptr, ptr)\n"
    decls = decls + "declare {size_ty} @rt_dict_len(ptr)\n"

    # I/O operations
    decls = decls + "declare void @rt_print(ptr)\n"
    decls = decls + "declare void @rt_println(ptr)\n"
    decls = decls + "declare ptr @rt_readline()\n"

    # Error handling
    decls = decls + "declare void @rt_panic(ptr)\n"

    # Math operations
    decls = decls + "declare double @rt_sin(double)\n"
    decls = decls + "declare double @rt_cos(double)\n"
    decls = decls + "declare double @rt_sqrt(double)\n"
    decls = decls + "declare double @rt_pow(double, double)\n"

    # LLVM intrinsics (i32 size type for wasm32)
    decls = decls + "declare void @llvm.memcpy.p0.p0.{size_ty}(ptr, ptr, {size_ty}, i1)\n"
    decls = decls + "declare void @llvm.memset.p0.{size_ty}(ptr, i8, {size_ty}, i1)\n"

    decls

# ============================================================================
# LLVM IR -> WASM Compilation (via llc + wasm-ld)
# ============================================================================

fn compile_ir_to_wasm(llvm_ir: text, config: LlvmTargetConfig, opt_level: OptimizationLevel, output_path: text) -> Result<text, text>:
    """Compile LLVM IR to a .wasm file via llc + wasm-ld.

    Pipeline:
    1. Write IR to temp .ll file
    2. Run llc to produce .o (wasm object)
    3. Run wasm-ld to produce .wasm
    4. Optionally run wasm-opt for optimization
    5. Return path to .wasm file
    """
    # Find required tools
    val llc_cmd = find_llc()
    if not llc_cmd.?:
        return Err("llc not found. Install LLVM for WASM compilation.")

    val wasm_ld_cmd = find_wasm_ld()
    if wasm_ld_cmd == "":
        return Err("wasm-ld not found. Install lld: apt install lld (Ubuntu) or brew install llvm (macOS)")

    val llc = llc_cmd.unwrap()
    val pid = getpid()
    val ts = time_now_unix_micros()
    val ir_path = "/tmp/simple_wasm_{pid}_{ts}.ll"
    val obj_path = "/tmp/simple_wasm_{pid}_{ts}.o"

    # Step 1: Write IR to temp file
    if not file_write(ir_path, llvm_ir):
        return Err("Failed to write LLVM IR to {ir_path}")

    # Step 2: Compile IR to wasm object via llc
    var opt_flag = "-O0"
    if opt_level == OptimizationLevel.Size:
        opt_flag = "-Oz"
    elif opt_level == OptimizationLevel.Speed:
        opt_flag = "-O2"
    elif opt_level == OptimizationLevel.Aggressive:
        opt_flag = "-O3"

    val triple = config.triple.to_text()
    val llc_cmd_str = "{llc} -mtriple={triple} -filetype=obj {opt_flag} -o {obj_path} {ir_path} 2>&1"
    val llc_result = shell(llc_cmd_str)

    file_delete(ir_path)

    if llc_result.exit_code != 0:
        file_delete(obj_path)
        return Err("llc WASM compilation failed:\n{llc_result.stdout}")

    # Step 3: Link with wasm-ld
    var ld_args = "{wasm_ld_cmd} --export=_start --stack-first"
    ld_args = ld_args + " -z stack-size=1048576"
    ld_args = ld_args + " --initial-memory=4194304"

    # Check for WASI sysroot
    val sysroot = find_wasi_sysroot()
    if sysroot != "":
        ld_args = ld_args + " -L{sysroot}/lib/wasm32-wasi -lc"
        ld_args = ld_args + " {sysroot}/lib/wasm32-wasi/crt1.o"
    else:
        # Standalone mode without libc
        ld_args = ld_args + " --no-entry --export-all"

    ld_args = ld_args + " -o {output_path} {obj_path} 2>&1"

    val ld_result = shell(ld_args)
    file_delete(obj_path)

    if ld_result.exit_code != 0:
        return Err("wasm-ld linking failed:\n{ld_result.stdout}")

    # Step 4: Optionally optimize with wasm-opt
    val wasm_opt_cmd = find_wasm_opt()
    if wasm_opt_cmd != "" and opt_level != OptimizationLevel.Debug:
        val wasm_opt_flag = if opt_level == OptimizationLevel.Size: "-Oz" else: "-O3"
        val opt_output = "{output_path}.opt"
        val opt_result = shell("{wasm_opt_cmd} {wasm_opt_flag} {output_path} -o {opt_output} 2>&1")
        if opt_result.exit_code == 0:
            # Replace original with optimized version
            file_delete(output_path)
            shell("mv {opt_output} {output_path}")
        else:
            # Optimization failed, keep unoptimized version
            file_delete(opt_output)

    Ok(output_path)

# ============================================================================
# Optimization Level Mapping
# ============================================================================

fn to_mir_opt_level(level: OptimizationLevel) -> OptLevel:
    """Convert backend OptimizationLevel to MIR OptLevel for pass dispatch."""
    match level:
        case Debug: OptLevel.NoOpt
        case Size: OptLevel.Size
        case Speed: OptLevel.Speed
        case Aggressive: OptLevel.Aggressive
        case _: OptLevel.NoOpt

# ============================================================================
# Exports
# ============================================================================

export LlvmObjectCode
export find_llc, find_opt, opt_available, llc_available
export find_wasm_ld, find_wasm_opt, find_wasi_sysroot
export extract_symbols_nm
export compile_ir_to_object, compile_ir_to_wasm
export generate_wasm_runtime_declarations
export to_mir_opt_level
