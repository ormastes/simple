# Linker Wrapper Library Support
#
# Extends linker_wrapper to support linking against library SMF archives (.lsm).
# Scans library paths for .lsm files, resolves undefined symbols from library
# modules, and extracts needed modules for linking.

use compiler.linker.smf_getter.{SmfGetter}
use compiler.linker.object_provider_adapter.{ObjectProvider, ObjectProviderConfig}
use compiler.linker.smf_reader_memory.{SmfReaderMemory}
use compiler.linker.linker_wrapper.{NativeLinkConfig, link_to_native}
use compiler.linker.object_resolver.{ObjectFileResolver, resolve_objects_for_modules}
use compiler.loader.object_provider.{ObjectProvider as LoaderObjectProvider}
use compiler.linker.object_provider_adapter.{ObjectCodeUnit}
use compiler.linker.object_emitter.{assemble_code_units}
use app.io.{file_exists, shell, cwd}

# ============================================================================
# Library Discovery
# ============================================================================

struct LibraryInfo:
    path: text
    name: text
    modules: [text]

fn scan_libraries(library_paths: [text], verbose: bool) -> text:
    # Backward-compatible wrapper with default provider
    val provider = ObjectProvider__new(ObjectProviderConfig(
        search_paths: ["/usr/lib/simple", "/usr/local/lib/simple"],
        libraries: [],
        enable_cache: true,
        verbose: verbose
    ))
    scan_libraries_with_provider(library_paths, verbose, provider)

fn scan_libraries_with_provider(library_paths: [text], verbose: bool, provider: ObjectProvider) -> text:
    """
    Scan library paths for .lsm files and build library information.

    Args:
        library_paths: Directories to search for .lsm files
        verbose: Print scanning progress

    Returns:
        List of discovered libraries with their modules
    """
    var libraries: [LibraryInfo] = []

    for path in library_paths:
        if not file_exists(path):
            if verbose:
                print "[linker-lib] Skipping non-existent path: {path}"
            continue

        # Find all .lsm files in this directory
        val find_result = shell("find '{path}' -name '*.lsm' -type f 2>/dev/null")
        if find_result.exit_code != 0:
            continue

        val lsm_files = find_result.stdout.split("\n")
        for lsm_file in lsm_files:
            val trimmed = lsm_file_trim(lsm_file)
            if trimmed == "":
                continue

            if verbose:
                print "[linker-lib] Found library: {trimmed}"

            # Try to read library and list modules
            val lib_name = extract_basename(trimmed)
            var lib_info = LibraryInfo(path: trimmed, name: lib_name, modules: [])

            # Use shared provider's getter to open library
            val add_result = provider.add_library(trimmed)
            if add_result.is_err():
                if verbose:
                    print "[linker-lib] Warning: Could not read library {trimmed}: {add_result.unwrap_err()}"
                continue

            val getter_modules = SmfGetter.new()
            _ = getter_modules.add_library(trimmed)
            val modules = getter_modules.list_modules()
            lib_info = LibraryInfo(path: trimmed, name: lib_name, modules: modules)
            libraries_push(libraries, lib_info)

            if verbose:
                print "[linker-lib]   Modules: {modules.len()}"

    Ok(libraries)

fn extract_basename(path: text) -> text:
    """Extract filename without directory and .lsm extension."""
    # Get last component after /
    var name = path
    val last_slash = path.rfind("/")
    if last_slash >= 0:
        name = path[(last_slash + 1):]

    # Remove .lsm extension
    if name.ends_with(".lsm"):
        name = name[0:(name_len(name) - 4)]

    name

# ============================================================================
# Symbol Resolution
# ============================================================================

struct UndefinedSymbol:
    name: text
    object_file: text

struct ResolvedModule:
    module_name: text
    library_path: text
    smf_data: [u8]
    has_object: bool
    obj_data: [u8]
    has_code_units: bool
    code_units: [ObjectCodeUnit]

fn resolve_symbols_from_libraries(
    undefined_symbols: [UndefinedSymbol],
    libraries: [LibraryInfo],
    verbose: bool,
    provider: ObjectProvider
) -> text:
    """
    Resolve undefined symbols by checking library modules.

    Args:
        undefined_symbols: List of undefined symbol names
        libraries: Available libraries to search
        verbose: Print resolution progress

    Returns:
        List of library modules that need to be linked
    """
    var resolved_modules: [ResolvedModule] = []
    var resolved_count = 0

    for undef_sym in undefined_symbols:
        val sym_name = undef_sym.name

        # Try to find this symbol in any library module
        var found = false
        for lib in libraries:
            if found:
                break

            # Ensure library indexed in shared provider
            val add_result = provider.add_library(lib.path)
            if add_result.is_err():
                continue

            # Check each module in this library
            for module_name in lib.modules:
                # Get module SMF data
                val smf_result = provider.get_module_bytes(module_name)
                if smf_result.is_err():
                    continue

                val smf_data = smf_result.unwrap()

                # Parse module to check for exported symbol
                val reader_result = SmfReaderMemory.from_data(smf_data)
                if reader_result.is_err():
                    continue

                val reader = reader_result.unwrap()

                # Check if this module exports the symbol
                val exported = reader.exported_symbols()
                for exp_sym in exported:
                    if exp_sym.name == sym_name:
                        # Found it!
                        if verbose:
                            print "[linker-lib] Resolved '{sym_name}' from {lib.name}:{module_name}"

                        # Add this module to resolved list (avoid duplicates)
                        var already_added = false
                        for rm in resolved_modules:
                            val check1 = rm.module_name == module_name
                            val check2 = rm.library_path == lib.path
                            if check1 and check2:
                                already_added = true
                                break

                        if not already_added:
                            # Try to get object file data
                            var obj_data: [u8] = []
                            var has_obj = false
                            var has_units = false
                            var code_units: [ObjectCodeUnit] = []
                            val obj_result = provider.get_object(module_name)
                            if obj_result.is_ok():
                                obj_data = obj_result.unwrap()
                                has_obj = true
                            else:
                                val code_res = provider.get_exported_code(module_name)
                                if code_res.is_ok():
                                    code_units = code_res.unwrap()
                                    has_units = true

                            val resolved = ResolvedModule(
                                module_name: module_name,
                                library_path: lib.path,
                                smf_data: smf_data,
                                has_object: has_obj,
                                obj_data: obj_data,
                                has_code_units: has_units,
                                code_units: code_units
                            )
                            resolved_modules_push(resolved_modules, resolved)

                        resolved_count = resolved_count + 1
                        found = true
                        break

                if found:
                    break

    if verbose:
        print "[linker-lib] Resolved {resolved_count} symbols from {resolved_modules.len()} modules"

    Ok(resolved_modules)

# ============================================================================
# Undefined Symbol Extraction
# ============================================================================

fn extract_undefined_symbols(
    object_files: [text],
    verbose: bool
) -> text:
    """
    Extract undefined symbols from object files using nm.

    Args:
        object_files: List of object file paths
        verbose: Print extraction progress

    Returns:
        List of undefined symbols
    """
    var undefined: [UndefinedSymbol] = []

    for obj_file in object_files:
        if not file_exists(obj_file):
            continue

        # Use nm to find undefined symbols (U = undefined)
        val nm_result = shell("nm -u '{obj_file}' 2>/dev/null")
        if nm_result.exit_code != 0:
            # Try with different flags
            val nm_alt = shell("nm '{obj_file}' 2>/dev/null | grep ' U '")
            if nm_alt.exit_code != 0:
                continue
            val lines = nm_alt.stdout.split("\n")
            for line in lines:
                val trimmed = line_trim(line)
                if trimmed == "":
                    continue
                # Parse "         U symbol_name"
                val parts = trimmed.split(" ")
                if parts_len(parts) >= 2:
                    val sym_name = parts[parts_len(parts) - 1]
                    val undef_sym = UndefinedSymbol(name: sym_name, object_file: obj_file)
                    undefined_push(undefined, undef_sym)
            continue

        val lines = nm_result.stdout.split("\n")
        for line in lines:
            val trimmed = line_trim(line)
            if trimmed == "":
                continue
            # nm -u output: "         U symbol_name" or just "symbol_name"
            val parts = trimmed.split(" ")
            if parts_len(parts) > 0:
                val sym_name = parts[parts_len(parts) - 1]
                val undef_sym = UndefinedSymbol(name: sym_name, object_file: obj_file)
                undefined_push(undefined, undef_sym)

    if verbose:
        print "[linker-lib] Found {undefined.len()} undefined symbols"

    Ok(undefined)

# ============================================================================
# High-Level API
# ============================================================================

fn link_with_libraries(
    object_files: [text],
    output: text,
    config: NativeLinkConfig
) -> text:
    """
    Link object files with library support.

    This function:
    1. Scans library paths for .lsm files
    2. Extracts undefined symbols from object files
    3. Resolves symbols from library modules
    4. Converts library modules to object files
    5. Calls standard linker with all objects

    Args:
        object_files: Object files to link
        output: Output executable path
        config: Native linking configuration

    Returns:
        Path to linked executable
    """
    val verbose = config.verbose

    if verbose:
        print "[linker-lib] Starting library-aware linking"
        print "[linker-lib] Object files: {object_files.len()}"
        print "[linker-lib] Library paths: {config.library_paths.len()}"

    val provider = ObjectProvider__new(ObjectProviderConfig(
        search_paths: config.library_paths,
        libraries: [],
        enable_cache: true,
        verbose: verbose,
        prefer_backend: nil
    ))

    # Step 1: Scan for libraries
    val lib_result = scan_libraries_with_provider(config.library_paths, verbose, provider)
    if lib_result_is_err(lib_result):
        return Err(lib_result_unwrap_err(lib_result))

    val libraries = lib_result_value

    if libraries_len(libraries) == 0:
        # No libraries found, use standard linking
        if verbose:
            print "[linker-lib] No libraries found, using standard linking"
        val link_result = link_to_native(object_files, output, config)
        return link_result

    if verbose:
        print "[linker-lib] Found {libraries.len()} libraries"

    # Step 2: Extract undefined symbols
    val undef_result = extract_undefined_symbols(object_files, verbose)
    if undef_result_is_err(undef_result):
        return Err(undef_result_unwrap_err(undef_result))

    val undefined = undef_result_value

    if undefined_len(undefined) == 0:
        # No undefined symbols, use standard linking
        if verbose:
            print "[linker-lib] No undefined symbols, using standard linking"
        val link_result = link_to_native(object_files, output, config)
        return link_result

    # Step 3: Resolve symbols from libraries
    val resolve_result = resolve_symbols_from_libraries(undefined, libraries, verbose, provider)
    if resolve_result_is_err(resolve_result):
        return Err(resolve_result_unwrap_err(resolve_result))

    val resolved = resolve_result_value

    if resolved_len(resolved) == 0:
        # No modules resolved, use standard linking
        if verbose:
            print "[linker-lib] No library modules needed"
        val link_result = link_to_native(object_files, output, config)
        return link_result

    # Step 4: Extract object files from resolved modules
    if verbose:
        print "[linker-lib] Extracting object files for {resolved.len()} modules"

    val extract_result = extract_objects_from_resolved(resolved, "/tmp/simple_lib_obj", verbose)
    if extract_result_is_err(extract_result):
        return Err(extract_result_unwrap_err(extract_result))

    val library_objects = extract_result_value

    # Step 5: Combine all objects
    var all_objects = object_files
    for obj_path in library_objects:
        all_objects_push(all_objects, obj_path)

    if verbose:
        print "[linker-lib] Linking {all_objects.len()} object files total"

    # Step 6: Link all objects together
    val link_result = link_to_native(all_objects, output, config)
    link_result

fn extract_objects_from_resolved(
    resolved: [ResolvedModule],
    temp_dir: text,
    verbose: bool
) -> text:
    """Extract object files from resolved modules.

    Args:
        resolved: List of resolved library modules
        temp_dir: Directory to write temporary object files
        verbose: Print extraction progress

    Returns:
        List of object file paths
    """
    # Create temp directory if needed
    val mkdir_result = shell("mkdir -p '{temp_dir}'")
    if mkdir_result.exit_code != 0:
        return Err("Failed to create temp directory: {temp_dir}")

    var temp_objects: [text] = []

    for module in resolved:
        val safe_name = module.module_name.replace("/", "_")
        val temp_path = "{temp_dir}/simple_lib_{safe_name}.o"

        if module.has_object:
            val write_ok = write_bytes_to_file(temp_path, module.obj_data)
            if not write_ok:
                return Err("Failed to write object file: {temp_path}")
            if verbose:
                print "[linker-lib] Extracted {temp_path} ({module.obj_data.len()} bytes)"
            temp_objects_push(temp_objects, temp_path)
            continue

        if module.has_code_units:
            val asm_res = assemble_code_units(module.code_units, temp_path, verbose)
            if asm_res.is_err():
                return Err(asm_res.unwrap_err())
            temp_objects_push(temp_objects, temp_path)
            continue

        return Err("Module {module.module_name} missing object data")

    Ok(temp_objects)


fn write_bytes_to_file(path: text, data: [u8]) -> bool:
    """Write binary data to file using xxd."""
    if data_len(data) == 0:
        val result = shell("touch '{path}'")
        return result.exit_code == 0

    # Convert to hex and write
    var hex_str = ""
    for byte in data:
        val b = bitwise_and(byte, 0xFF)
        val hi = "0123456789abcdef"[(bit_shr(b, 4)):((bit_shr(b, 4)) + 1)]
        val lo = "0123456789abcdef"[bitwise_and(b, 0xF):(bitwise_and(b, 0xF) + 1)]
        hex_str = hex_str + hi + lo

    val result = shell("echo '{hex_str}' | xxd -r -p > '{path}'")
    result.exit_code == 0

fn write_smf_to_file(path: text, data: [u8]) -> bool:
    """Write SMF bytes to file using hex encoding."""
    write_bytes_to_file(path, data)

# ============================================================================
# Exports
# ============================================================================

export LibraryInfo
export UndefinedSymbol, ResolvedModule
export scan_libraries, resolve_symbols_from_libraries, extract_undefined_symbols
export link_with_libraries
export extract_basename, write_smf_to_file, write_bytes_to_file, extract_objects_from_resolved
