# SMF Writer
#
# Simple Module Format writer for creating SMF files from compiled code.
# Handles sections, symbols, relocations, and string tables.
#
# Port of rust/compiler/src/linker/smf_writer.rs

export SmfSymbol, SmfRelocation, SmfSection, SmfWriter
export DataSectionKind, SmfWriteError, SymbolBinding, SymbolType
export SectionType, RelocationType

# ============================================================================
# Constants
# ============================================================================

val SMF_MAGIC: i64 = 0x534D4600      # "SMF\0"
val SMF_VERSION_MAJOR: i64 = 0
val SMF_VERSION_MINOR: i64 = 1
val SMF_FLAG_EXECUTABLE: i64 = 0x1

val SECTION_FLAG_READ: i64 = 0x1
val SECTION_FLAG_WRITE: i64 = 0x2
val SECTION_FLAG_EXEC: i64 = 0x4

# ============================================================================
# Enums
# ============================================================================

enum DataSectionKind:
    """Lean: inductive DataSectionKind | mutable | readonly"""
    Mutable
    ReadOnly

impl DataSectionKind:
    fn is_readonly() -> bool:
        match self: case ReadOnly: true; case _: false

    fn to_section_type() -> SectionType:
        match self:
            case Mutable: SectionType.Data
            case ReadOnly: SectionType.RoData

    fn to_flags() -> i64:
        match self:
            case ReadOnly: SECTION_FLAG_READ
            case Mutable: SECTION_FLAG_READ + SECTION_FLAG_WRITE

enum SectionType:
    Code
    Data
    RoData
    Bss
    SymTab
    StrTab
    RelTab
    Note
    Debug

impl SectionType:
    fn name() -> text:
        match self:
            case Code: ".text"
            case Data: ".data"
            case RoData: ".rodata"
            case Bss: ".bss"
            case SymTab: ".symtab"
            case StrTab: ".strtab"
            case RelTab: ".rela"
            case Note: ".note"
            case Debug: ".debug"

enum SymbolBinding:
    Local
    Global
    Weak

enum SymbolType:
    NoType
    Function
    Object
    Section

enum RelocationType:
    Abs64
    Rel32
    PltRel32
    GotRel32

enum SmfWriteError:
    IoError(text)
    InvalidData(text)

impl SmfWriteError:
    fn message() -> text:
        match self:
            case IoError(msg): "IO error: {msg}"
            case InvalidData(msg): "Invalid data: {msg}"

# ============================================================================
# Structs
# ============================================================================

struct SmfSymbol:
    name: text
    binding: SymbolBinding
    sym_type: SymbolType
    section_index: i64
    value: i64
    size: i64
    layout_phase: i64           # 0=startup, 1=first_frame, 2=steady, 3=cold
    is_event_loop_anchor: bool
    layout_pinned: bool

struct SmfRelocation:
    offset: i64
    symbol_index: i64
    reloc_type: RelocationType
    addend: i64

struct SmfSection:
    name: text
    section_type: SectionType
    flags: i64
    data: [i64]        # Byte array
    alignment: i64

# ============================================================================
# SMF Writer
# ============================================================================

class SmfWriter:
    """Creates SMF files from compiled code."""
    sections: [SmfSection]
    symbols: [SmfSymbol]
    relocations: [SmfRelocation]
    string_table: [i64]         # Byte array
    string_offsets: {text: i64}

impl SmfWriter:
    static fn create() -> SmfWriter:
        SmfWriter(sections: [], symbols: [], relocations: [],
                  string_table: [0], string_offsets: {})

    me add_string(s: text) -> i64:
        """Add a string to the string table, returning its offset."""
        if self.string_offsets.contains_key(s):
            return self.string_offsets[s]
        val offset = self.string_table.len()
        # Append bytes (simplified - actual impl uses FFI for encoding)
        self.string_table = self.string_table.push(offset)
        self.string_offsets[s] = offset
        offset

    me add_code_section(name: text, code: [i64]) -> i64:
        val section = SmfSection(name: name, section_type: SectionType.Code,
            flags: SECTION_FLAG_READ + SECTION_FLAG_EXEC,
            data: code, alignment: 16)
        self.sections = self.sections.push(section)
        self.sections.len() - 1

    me add_data_section(name: text, data: [i64], kind: DataSectionKind) -> i64:
        val section = SmfSection(name: name, section_type: kind.to_section_type(),
            flags: kind.to_flags(), data: data, alignment: 8)
        self.sections = self.sections.push(section)
        self.sections.len() - 1

    me add_bss_section(name: text, size: i64) -> i64:
        val zeroes: [i64] = []
        val section = SmfSection(name: name, section_type: SectionType.Bss,
            flags: SECTION_FLAG_READ + SECTION_FLAG_WRITE,
            data: zeroes, alignment: 8)
        self.sections = self.sections.push(section)
        self.sections.len() - 1

    me add_symbol(symbol: SmfSymbol) -> i64:
        self.symbols = self.symbols.push(symbol)
        self.symbols.len() - 1

    me add_relocation(reloc: SmfRelocation):
        self.relocations = self.relocations.push(reloc)

    me add_note_section(name: text, data: [i64]) -> i64:
        val section = SmfSection(name: name, section_type: SectionType.Note,
            flags: SECTION_FLAG_READ, data: data, alignment: 4)
        self.sections = self.sections.push(section)
        self.sections.len() - 1

    fn section_count() -> i64:
        self.sections.len()

    fn symbol_count() -> i64:
        self.symbols.len()

    me write() -> Result<[i64], SmfWriteError>:
        """Serialize to SMF binary format.

        Actual binary writing delegated to Rust FFI.
        This builds the logical structure.
        """
        if self.sections.len() == 0:
            return Err(SmfWriteError.InvalidData("No sections to write"))

        # Build logical output (actual binary encoding via FFI)
        extern fn rt_smf_write(sections_json: text, symbols_json: text,
                                relocations_json: text, strtab: text) -> Result<[i64], text>

        # For now, return placeholder - real impl uses FFI
        Ok([])
