# Linker Wrapper - Unified Linking API
#
# This module provides a single entry point for all linking operations,
# replacing the hardcoded `cc` calls in driver.spl with platform-aware
# linker selection and adding self-contained executable SMF support.
#
# Three linking modes:
#   link_to_native()         - Platform-detected native binary (mold/lld/ld)
#   link_to_smf()            - SMF module file
#   link_to_self_contained() - Runtime + SMF data in one executable
#
# Self-contained binary format (trailer-based):
#   [Runtime Binary] [SMF Data] [32-byte Trailer]
#   Trailer: "SMFE"(4) + smf_offset(8) + smf_size(8) + checksum(8) + version(4)
#
# Interpreter-safe: no generics (<>) used.
#
# Split into modules:
#   linker_wrapper_helpers.spl — SMF linking, self-contained linking, binary helpers

use std.io_runtime.{ShellResult, shell, shell_output, file_exists, file_copy, file_delete, file_size_raw, file_read_bytes, env_get, host_os, host_arch, process_run, cwd}
use std.log.{debug, info}
use std.string_builder.{StringBuilder}

use compiler.backend.linker.mold.{MoldBackend, MoldConfig, find_linker, LinkerType, execute_linker, create_temp_dir, cleanup_temp_dir, linker_file_size}
use compiler.backend.linker.object_provider.{ObjectProvider, ObjectProviderConfig}
use compiler.backend.linker.object_code_unit.{ObjectCodeUnit}
use compiler.backend.linker.object_emitter.{assemble_code_units}
use compiler.backend.linker.smf_getter.{SmfGetter}
use compiler.backend.linker.smf_enums.{Platform, Arch}
use compiler.backend.linker.obj_taker.{ObjTaker, ObjTakeResult, objtaker_with_defaults, objtaker_take_object}

# Re-export CRT discovery (extracted to crt_discovery.spl)
use compiler.backend.linker.crt_discovery.*

# Import helpers (SMF linking, self-contained, binary utils)
use compiler.backend.linker.linker_wrapper_helpers.{SelfContainedConfig, SelfContainedConfig__default}
use compiler.backend.linker.linker_wrapper_helpers.{SMFE_MAGIC, SMFE_TRAILER_SIZE, SMFE_VERSION}
use compiler.backend.linker.linker_wrapper_helpers.{link_to_smf, link_to_self_contained}
use compiler.backend.linker.linker_wrapper_helpers.{detect_self_contained, find_runtime_binary, find_runtime_lib_dir}
use compiler.backend.linker.linker_wrapper_helpers.{build_trailer, fnv1a_hash}
use compiler.backend.linker.linker_wrapper_helpers.{write_bytes_to_file, write_elf_bytes_to_file}

# ============================================================================
# Configuration Structs
# ============================================================================

struct NativeLinkConfig:
    libraries: [text]
    library_paths: [text]
    runtime_path: text       # Path to libsimple_compiler (empty = auto-detect)
    pie: bool
    debug: bool
    verbose: bool
    extra_flags: [text]

fn NativeLinkConfig__default() -> NativeLinkConfig:
    NativeLinkConfig(
        libraries: [],
        library_paths: [],
        runtime_path: "",
        pie: true,
        debug: false,
        verbose: false,
        extra_flags: []
    )

struct CrtFiles:
    crt1: text           # crt1.o or Scrt1.o (PIE)
    crti: text           # crti.o
    crtn: text           # crtn.o
    crtbegin: text       # crtbegin.o or crtbeginS.o (PIE)
    crtend: text         # crtend.o or crtendS.o (PIE)
    dynamic_linker: text # e.g., /lib64/ld-linux-x86-64.so[2]
    lib_dirs: [text]     # System library search paths
    found: bool

# ============================================================================
# Native Linking
# ============================================================================

fn link_to_native(object_files: [text], output: text, config: NativeLinkConfig) -> Result:
    debug("linker", "link_to_native: {object_files_len(object_files)} input files, output={output}")
    if object_files_len(object_files) == 0:
        return Err("No object files to link")

    # If inputs are SMF/LSM, build a self-contained binary instead of raw native link.
    val smf_inputs = filter_smf_inputs(object_files)
    if smf_inputs.len() > 0:
        debug("linker", "Detected {smf_inputs.len()} SMF inputs, using SMF bundle mode")
        val mixed = smf_inputs.len() != object_files_len(object_files)
        if mixed:
            return Err("Cannot mix SMF and object inputs; convert all to SMF or all to objects")
        return link_smf_bundle(smf_inputs, output, config)

    val os = host_os()

    # Platform-specific linking
    if os == "windows":
        return link_native_windows(object_files, output, config)

    # Unix-like: Linux, macOS, FreeBSD
    link_native_unix(object_files, output, config)

fn link_native_unix(object_files: [text], output: text, config: NativeLinkConfig) -> Result:
    val os = host_os()
    val arch = host_arch()
    debug("linker", "link_native_unix: os={os}, arch={arch}")

    # Try to find platform linker (mold > lld > ld)
    val linker_result = find_linker()
    if linker_result_is_err(linker_result):
        debug("linker", "No direct linker found, falling back to cc")
        # Fall back to cc (always available on Unix)
        return link_native_cc(object_files, output, config)

    val linker_info = linker_result_value
    val linker_path = linker_info[0]
    val linker_type = linker_info[1]
    debug("linker", "Found linker: type={linker_type}, path={linker_path}")

    # Discover CRT files needed for direct linker invocation
    val crt = find_crt_files(config.pie, config.verbose)
    if not crt.found:
        debug("linker", "CRT files not found, falling back to cc")
        if config.verbose:
            print "[linker-wrapper] CRT files not found, falling back to cc"
        return link_native_cc(object_files, output, config)

    if config.verbose:
        print "[linker-wrapper] Using {linker_type.to_string()} at {linker_path}"

    # Build linker arguments in correct order
    var args: [text] = []

    # Output file
    args.push("-o")
    args_push(args, output)

    # Emulation mode
    if os == "linux":
        if arch == "x86_64":
            args.push("-m")
            args.push("elf_x86_64")
        elif arch == "aarch64":
            args.push("-m")
            args.push("aarch64linux")

    # Dynamic linker
    if crt.dynamic_linker != "":
        args.push("-dynamic-linker")
        args_push(args, crt.dynamic_linker)

    # Hardening flags
    args.push("--eh-frame-hdr")
    args.push("--build-id")
    args.push("--hash-style=gnu")
    args.push("-z")
    args.push("relro")
    args.push("-z")
    args.push("now")

    # PIE
    if config.pie:
        args.push("-pie")

    # CRT prologue: crt1.o, crti.o, crtbegin.o (before user objects)
    args_push(args, crt.crt1)
    args_push(args, crt.crti)
    args_push(args, crt.crtbegin)

    # User object files
    for obj in object_files:
        args_push(args, obj)

    # Library search paths from CRT discovery
    for dir in crt.lib_dirs:
        args.push("-L")
        args_push(args, dir)

    # Library paths from config
    for lp in config.library_paths:
        args.push("-L")
        args_push(args, lp)

    # Auto-detect runtime library if not specified
    var runtime_dir = config.runtime_path
    if runtime_dir == "":
        runtime_dir = find_runtime_lib_dir()
    if runtime_dir != "":
        args.push("-L")
        args_push(args, runtime_dir)
        args.push("-lsimple_compiler")
        args.push("-rpath")
        args_push(args, runtime_dir)

    # Standard libraries (no -lgcc/-lgcc_s — clang provides compiler-rt)
    if os == "linux":
        args.push("-lc")
        args.push("-lpthread")
        args.push("-ldl")
        args.push("-lm")
    elif os == "macos":
        args.push("-lc")
        args.push("-lpthread")
        args.push("-lm")
        args.push("-lSystem")
    elif os == "freebsd":
        args.push("-lc")
        args.push("-lpthread")
        args.push("-lm")

    # Libraries from config
    for lib in config.libraries:
        args.push("-l")
        args_push(args, lib)

    # Debug info
    if config.debug:
        args.push("-g")

    # Extra flags
    for flag in config.extra_flags:
        args_push(args, flag)

    # CRT epilogue: crtend.o, crtn.o (after libs)
    args_push(args, crt.crtend)
    args_push(args, crt.crtn)

    # Execute linker
    val exec_result = execute_linker(linker_path, args)
    if exec_result_is_err(exec_result):
        # Fallback to cc on failure
        if config.verbose:
            print "[linker-wrapper] Direct linker failed, falling back to cc: {exec_result.unwrap_err()}"
        return link_native_cc(object_files, output, config)

    if config.verbose:
        val size = linker_file_size(output)
        print "[linker-wrapper] Native binary: {output} ({size} bytes)"

    Ok(output)

# Build self-contained binary when given SMF inputs
fn link_smf_bundle(smf_inputs: [text], output: text, config: NativeLinkConfig) -> Result:
    if smf_inputs.len() == 0:
        return Err("No SMF inputs")

    val verbose = config.verbose
    val provider = create_default_provider(verbose)

    # Create shared ObjTaker for extraction/instantiation across all inputs
    var obj_taker = objtaker_with_defaults()

    # Support multiple SMF inputs
    if smf_inputs.len() > 1 or smf_inputs[0].ends_with(".lsm"):
        # Multi-SMF or .lsm library mode
        val tmp_dir = create_temp_dir()
        if tmp_dir == "":
            return Err("Failed to create temp dir for SMF objects")

        var objs: [text] = []

        for path in smf_inputs:
            if path.ends_with(".lsm"):
                # .lsm library: extract objects and link
                val add_res = provider.add_library(path)
                if add_res.is_err():
                    cleanup_temp_dir(tmp_dir)
                    return Err(add_res.unwrap_err())

                val modules = provider.list_modules()
                for m in modules:
                    val obj_res = provider.get_object(m)
                    if obj_res.is_ok():
                        val obj_bytes = obj_res.unwrap()
                        val safe = m.replace("/", "_")
                        val obj_path = "{tmp_dir}/{safe}.o"
                        if write_bytes_to_file(obj_path, obj_bytes):
                            objs.push(obj_path)
                        continue

                    val code_res = provider.get_exported_code(m)
                    if code_res.is_err():
                        if verbose:
                            print "[linker-wrapper] missing object for {m}: {code_res.unwrap_err()}"
                        continue
                    val obj_paths = materialize_code_units(code_res.unwrap(), tmp_dir, verbose)
                    for p in obj_paths:
                        objs.push(p)
            else:
                # Single SMF file: try ObjectProvider extraction
                val obj_res = provider.get_object(path)
                if obj_res.is_ok():
                    val safe = path.replace("/", "_").replace(".smf", "")
                    val obj_path = "{tmp_dir}/{safe}.o"
                    if write_bytes_to_file(obj_path, obj_res.unwrap()):
                        objs.push(obj_path)
                    continue

                val code_res = provider.get_exported_code(path)
                if code_res.is_ok():
                    val code_objs = materialize_code_units(code_res.unwrap(), tmp_dir, verbose)
                    for p in code_objs:
                        objs.push(p)

        if objs.len() == 0:
            cleanup_temp_dir(tmp_dir)
            return Err("No object data available in SMF inputs")

        val link_res = link_native_unix(objs, output, config)
        cleanup_temp_dir(tmp_dir)
        return link_res

    # Single SMF file path
    val path = smf_inputs[0]

    # Try to convert single SMF to object via ObjectProvider
    val obj_result = provider.get_object(path)
    if obj_result.is_ok():
        val tmp_dir = create_temp_dir()
        if tmp_dir == "":
            return Err("Failed to create temp dir for SMF objects")
        val obj_path = "{tmp_dir}/input.o"
        val write_ok = write_bytes_to_file(obj_path, obj_result.unwrap())
        if not write_ok:
            cleanup_temp_dir(tmp_dir)
            return Err("Failed to write object from SMF")
        val link_res = link_native_unix([obj_path], output, config)
        cleanup_temp_dir(tmp_dir)
        return link_res

    # Fallback: generate objects from exported code
    val code_result = provider.get_exported_code(path)
    if code_result.is_ok():
        val tmp_dir = create_temp_dir()
        if tmp_dir == "":
            return Err("Failed to create temp dir for SMF code")
        val obj_paths = materialize_code_units(code_result.unwrap(), tmp_dir, verbose)
        if obj_paths.len() > 0:
            val link_res = link_native_unix(obj_paths, output, config)
            cleanup_temp_dir(tmp_dir)
            return link_res
        cleanup_temp_dir(tmp_dir)

    # Fallback: self-contained binary
    val data = file_read_bytes(path)
    if data_len(data) == 0:
        return Err("Failed to read SMF data from {path}")

    val sc_config = SelfContainedConfig(
        runtime_binary: config.runtime_path,
        verbose: config.verbose,
        strip: false
    )
    link_to_self_contained(data, output, sc_config)

fn create_default_provider(verbose: bool) -> ObjectProvider:
    ObjectProvider__new(ObjectProviderConfig(
        search_paths: ["/usr/lib/simple", "/usr/local/lib/simple"],
        libraries: [],
        enable_cache: true,
        verbose: verbose,
        prefer_backend: nil
    ))

fn materialize_code_units(units: [ObjectCodeUnit], tmp_dir: text, verbose: bool) -> [text]:
    """Convert exported code units into temporary .o files."""
    var paths: [text] = []
    for code_unit in units:
        val safe = code_unit.name.replace("/", "_")
        val obj_path = "{tmp_dir}/{safe}.o"
        val asm_res = assemble_code_units([code_unit], obj_path, verbose)
        if asm_res.is_ok():
            paths.push(obj_path)
        elif verbose:
            print "[linker-wrapper] failed to assemble {code_unit.name}: {asm_res.unwrap_err()}"
    paths

fn filter_smf_inputs(files: [text]) -> [text]:
    var smfs: [text] = []
    for f in files:
        if f.ends_with(".smf") or f.ends_with(".lsm"):
            smfs.push(f)
    smfs

fn link_native_cc(object_files: [text], output: text, config: NativeLinkConfig) -> Result:
    # Fallback: use cc (gcc/clang) for linking
    debug("linker", "link_native_cc: fallback linking with cc")
    val sb = StringBuilder(parts: [])
    sb.push("cc")
    for obj in object_files:
        sb.push(" ")
        sb.push(obj)

    # Library paths
    for lp in config.library_paths:
        sb.push(" -L")
        sb.push(lp)

    # Auto-detect runtime library
    var runtime_dir = config.runtime_path
    if runtime_dir == "":
        runtime_dir = find_runtime_lib_dir()
    if runtime_dir != "":
        sb.push(" -L{runtime_dir} -lsimple_compiler")
        sb.push(" -Wl,-rpath,{runtime_dir}")

    # Standard libraries (OS-aware; no -lgcc_s — clang provides compiler-rt)
    var os_name = shell("uname -s").stdout
    os_name = os_name_trim(os_name)
    if os_name == "Darwin":
        sb.push(" -lc -lpthread -lm -lSystem")
    elif os_name == "FreeBSD":
        sb.push(" -lc -lpthread -lm")
    else:
        sb.push(" -lc -lpthread -ldl -lm")

    # Libraries from config
    for lib in config.libraries:
        sb.push(" -l")
        sb.push(lib)

    # Extra flags
    for flag in config.extra_flags:
        sb.push(" ")
        sb.push(flag)

    sb.push(" -o ")
    sb.push(output)
    val cmd = sb.to_text()

    if config.verbose:
        print "[linker-wrapper] cc command: {cmd}"

    val result = shell(cmd)
    if result.exit_code == 0:
        Ok(output)
    else:
        val err_msg = result.stderr ?? "Unknown linking error"
        Err("cc linking failed: {err_msg}")

fn link_native_windows(object_files: [text], output: text, config: NativeLinkConfig) -> Result:
    # Windows linking via lld-link or MSVC link.exe
    # Try lld-link first
    val lld_check = shell("where lld-link 2>nul")
    var linker_cmd = "link"
    if lld_check.exit_code == 0:
        linker_cmd = "lld-link"

    val sb = StringBuilder(parts: [])
    sb.push(linker_cmd)
    for obj in object_files:
        sb.push(" ")
        sb.push(obj)

    sb.push(" /OUT:{output}")

    # Libraries
    for lib in config.libraries:
        sb.push(" {lib}.lib")

    # Extra flags
    for flag in config.extra_flags:
        sb.push(" ")
        sb.push(flag)

    val cmd = sb.to_text()

    if config.verbose:
        print "[linker-wrapper] Windows linker: {cmd}"

    val result = shell(cmd)
    if result.exit_code == 0:
        Ok(output)
    else:
        val err_msg = result.stderr ?? "Unknown linking error"
        Err("Windows linking failed: {err_msg}")

# ============================================================================
# Exports
# ============================================================================

export NativeLinkConfig, NativeLinkConfig__default
export CrtFiles, find_crt_files
export SelfContainedConfig, SelfContainedConfig__default
export link_to_native, link_to_smf, link_to_self_contained
export detect_self_contained, find_runtime_binary, find_runtime_lib_dir
export build_trailer, fnv1a_hash
export SMFE_MAGIC, SMFE_TRAILER_SIZE, SMFE_VERSION
export write_elf_bytes_to_file
