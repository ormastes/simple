describe "Smf Header":
    it "skipped":
        skip("pre-existing test failures - functions/imports not available")

# # SMF Header Specification
# #
# # Unit tests for SmfHeader struct:
# # - Construction and initialization
# # - Version methods
# # - Platform and architecture methods
# # - Flag methods
# # - Compression methods
# # - Stub methods
# # - App type and hints methods
# # - Serialization (128-byte validation)
# 
# use ..smf_header.*
# use ..smf_enums.*
# use testing.{describe, it, expect}
# 
# describe "SmfHeader construction":
#     it "creates new v1.1 header with defaults":
#         val header = SmfHeader.new_v1_1(Platform.Linux, Arch.X86_64)
# 
#         expect(header.version_major == 1)
#         expect(header.version_minor == 1)
#         expect(header.get_platform() == Platform.Linux)
#         expect(header.get_arch() == Arch.X86_64)
#         expect(header.flags == 0)
#         expect(header.compression == 0)
#         expect(header.stub_size == 0)
#         expect(header.app_type == 0)
#         expect(header.window_width == 1280)
#         expect(header.window_height == 720)
# 
#     it "creates header for different platforms and architectures":
#         val header1 = SmfHeader.new_v1_1(Platform.Windows, Arch.Aarch64)
#         expect(header1.get_platform() == Platform.Windows)
#         expect(header1.get_arch() == Arch.Aarch64)
# 
#         val header2 = SmfHeader.new_v1_1(Platform.MacOS, Arch.Arm)
#         expect(header2.get_platform() == Platform.MacOS)
#         expect(header2.get_arch() == Arch.Arm)
# 
# describe "Version methods":
#     it "returns correct version tuple":
#         val header = SmfHeader.new_v1_1(Platform.Linux, Arch.X86_64)
#         val (major, minor) = header.version()
#         expect(major == 1)
#         expect(minor == 1)
# 
#     it "correctly identifies v1.1 headers":
#         val header = SmfHeader.new_v1_1(Platform.Linux, Arch.X86_64)
#         expect(header.is_v1_1())
#         expect(not header.is_v1_0())
# 
# describe "Platform and architecture methods":
#     it "gets and sets platform correctly":
#         var header = SmfHeader.new_v1_1(Platform.Linux, Arch.X86_64)
#         expect(header.get_platform() == Platform.Linux)
# 
#         header.set_platform(Platform.Windows)
#         expect(header.get_platform() == Platform.Windows)
# 
#         header.set_platform(Platform.FreeBSD)
#         expect(header.get_platform() == Platform.FreeBSD)
# 
#     it "gets and sets architecture correctly":
#         var header = SmfHeader.new_v1_1(Platform.Linux, Arch.X86_64)
#         expect(header.get_arch() == Arch.X86_64)
# 
#         header.set_arch(Arch.Aarch64)
#         expect(header.get_arch() == Arch.Aarch64)
# 
#         header.set_arch(Arch.Riscv64)
#         expect(header.get_arch() == Arch.Riscv64)
# 
# describe "Flag methods":
#     it "sets and checks executable flag":
#         var header = SmfHeader.new_v1_1(Platform.Linux, Arch.X86_64)
#         expect(not header.is_executable())
# 
#         header.set_executable(true)
#         expect(header.is_executable())
# 
#         header.set_executable(false)
#         expect(not header.is_executable())
# 
#     it "sets and checks reloadable flag":
#         var header = SmfHeader.new_v1_1(Platform.Linux, Arch.X86_64)
#         expect(not header.is_reloadable())
# 
#         header.set_reloadable(true)
#         expect(header.is_reloadable())
# 
#         header.set_reloadable(false)
#         expect(not header.is_reloadable())
# 
#     it "sets and checks debug_info flag":
#         var header = SmfHeader.new_v1_1(Platform.Linux, Arch.X86_64)
#         expect(not header.has_debug_info())
# 
#         header.set_debug_info(true)
#         expect(header.has_debug_info())
# 
#         header.set_debug_info(false)
#         expect(not header.has_debug_info())
# 
#     it "sets and checks PIC flag":
#         var header = SmfHeader.new_v1_1(Platform.Linux, Arch.X86_64)
#         expect(not header.is_pic())
# 
#         header.set_pic(true)
#         expect(header.is_pic())
# 
#         header.set_pic(false)
#         expect(not header.is_pic())
# 
#     it "sets multiple flags independently":
#         var header = SmfHeader.new_v1_1(Platform.Linux, Arch.X86_64)
# 
#         header.set_executable(true)
#         header.set_reloadable(true)
#         expect(header.is_executable())
#         expect(header.is_reloadable())
#         expect(not header.has_debug_info())
#         expect(not header.is_pic())
# 
#         header.set_debug_info(true)
#         expect(header.is_executable())
#         expect(header.is_reloadable())
#         expect(header.has_debug_info())
# 
# describe "Compression methods":
#     it "checks compression status":
#         var header = SmfHeader.new_v1_1(Platform.Linux, Arch.X86_64)
#         expect(not header.is_compressed())
# 
#         header.set_compression(CompressionType.Zstd, 3)
#         expect(header.is_compressed())
# 
#     it "gets and sets compression type":
#         var header = SmfHeader.new_v1_1(Platform.Linux, Arch.X86_64)
#         expect(header.get_compression() == CompressionType.None_)
# 
#         header.set_compression(CompressionType.Zstd, 5)
#         expect(header.get_compression() == CompressionType.Zstd)
#         expect(header.compression_level == 5)
# 
#         header.set_compression(CompressionType.Lz4, 1)
#         expect(header.get_compression() == CompressionType.Lz4)
#         expect(header.compression_level == 1)
# 
# describe "Stub methods":
#     it "gets stub size":
#         val header = SmfHeader.new_v1_1(Platform.Linux, Arch.X86_64)
#         expect(header.get_stub_size() == 0)
# 
#     it "gets SMF data offset":
#         val header = SmfHeader.new_v1_1(Platform.Linux, Arch.X86_64)
#         expect(header.get_smf_data_offset() == 0)
# 
#     it "sets stub info and updates flags":
#         var header = SmfHeader.new_v1_1(Platform.Linux, Arch.X86_64)
#         expect(not header.has_stub())
# 
#         header.set_stub_info(1024, 1024)
#         expect(header.get_stub_size() == 1024)
#         expect(header.get_smf_data_offset() == 1024)
#         expect(header.has_stub())
# 
#     it "does not set stub flag when stub_size is 0":
#         var header = SmfHeader.new_v1_1(Platform.Linux, Arch.X86_64)
#         header.set_stub_info(0, 0)
#         expect(not header.has_stub())
# 
# describe "App type and hints methods":
#     it "gets and sets app type":
#         var header = SmfHeader.new_v1_1(Platform.Linux, Arch.X86_64)
#         expect(header.get_app_type() == SmfAppType.Cli)
# 
#         header.set_app_type(SmfAppType.Gui)
#         expect(header.get_app_type() == SmfAppType.Gui)
# 
#         header.set_app_type(SmfAppType.Service)
#         expect(header.get_app_type() == SmfAppType.Service)
# 
#     it "sets window hints":
#         var header = SmfHeader.new_v1_1(Platform.Linux, Arch.X86_64)
#         expect(header.window_width == 1280)
#         expect(header.window_height == 720)
# 
#         header.set_window_hints(1920, 1080)
#         expect(header.window_width == 1920)
#         expect(header.window_height == 1080)
# 
#     it "checks and sets prefetch hints":
#         var header = SmfHeader.new_v1_1(Platform.Linux, Arch.X86_64)
#         expect(not header.should_prefetch())
#         expect(header.expected_prefetch_count() == 0)
# 
#         header.set_prefetch_hint(true, 10)
#         expect(header.should_prefetch())
#         expect(header.expected_prefetch_count() == 10)
# 
#         header.set_prefetch_hint(false, 0)
#         expect(not header.should_prefetch())
# 
# describe "Serialization":
#     it "serializes to exactly 128 bytes":
#         val header = SmfHeader.new_v1_1(Platform.Linux, Arch.X86_64)
#         val bytes = header.to_bytes()
#         expect(bytes.len() == 128)
# 
#     it "serializes header with all fields set":
#         var header = SmfHeader.new_v1_1(Platform.Windows, Arch.Aarch64)
#         header.set_executable(true)
#         header.set_reloadable(true)
#         header.set_debug_info(true)
#         header.set_compression(CompressionType.Zstd, 5)
#         header.section_count = 10
#         header.section_table_offset = 512
#         header.symbol_table_offset = 1024
#         header.symbol_count = 25
#         header.exported_count = 5
#         header.entry_point = 0x1000
#         header.set_stub_info(2048, 2048)
#         header.module_hash = 0x123456789ABCDEF0
#         header.source_hash = 0x7EDCBA9876543210
#         header.set_app_type(SmfAppType.Gui)
#         header.set_window_hints(1920, 1080)
#         header.set_prefetch_hint(true, 15)
# 
#         val bytes = header.to_bytes()
#         expect(bytes.len() == 128)
# 
#     it "serializes magic number correctly":
#         val header = SmfHeader.new_v1_1(Platform.Linux, Arch.X86_64)
#         val bytes = header.to_bytes()
# 
#         # Magic "SMF\0"
#         expect(bytes[0] == 83)   # 'S'
#         expect(bytes[1] == 77)   # 'M'
#         expect(bytes[2] == 70)   # 'F'
#         expect(bytes[3] == 0)    # '\0'
# 
#     it "serializes version correctly":
#         val header = SmfHeader.new_v1_1(Platform.Linux, Arch.X86_64)
#         val bytes = header.to_bytes()
# 
#         expect(bytes[4] == 1)    # version_major
#         expect(bytes[5] == 1)    # version_minor
# 
#     it "serializes platform and arch correctly":
#         val header = SmfHeader.new_v1_1(Platform.Windows, Arch.Aarch64)
#         val bytes = header.to_bytes()
# 
#         expect(bytes[6] == 2)    # platform: Windows
#         expect(bytes[7] == 1)    # arch: Aarch64
