describe "Lib Smf Reader":
    it "skipped":
        skip("pre-existing test failures - functions/imports not available")

# # Library SMF Reader Tests
# #
# # Tests for LibSmfReader - reading modules and object files from library archives.
# 
# use std.spec
# use compiler.backend.linker.lib_smf_writer.{LibSmfBuilder}
# use compiler.backend.linker.lib_smf_reader.{LibSmfReader}
# use app.io.{file_write, shell}
# 
# describe "LibSmfReader - Opening Libraries":
#     it "should open valid library":
#         # Create test library
#         var builder = LibSmfBuilder__new()
#         val smf = "/tmp/open_test.smf"
#         file_write(smf, "TEST_DATA")
#         builder.add_module("test/module", smf)
# 
#         val lib_path = "/tmp/open_test.lsm"
#         builder.write(lib_path)
# 
#         # Open library
#         val result = LibSmfReader__open(lib_path)
#         expect(result.is_ok()).to_equal(true)
# 
#         val reader = result.unwrap()
#         expect(reader.module_count()).to_equal(1)
# 
#         # Clean up
#         reader.close()
#         shell("rm -f '{lib_path}'")
# 
#     it "should return error for missing file":
#         val result = LibSmfReader__open("/nonexistent/library.lsm")
#         expect(result.is_err()).to_equal(true)
# 
#     it "should return error for invalid library":
#         # Create invalid file
#         val bad_path = "/tmp/bad_lib.lsm"
#         file_write(bad_path, "NOT_A_LIBRARY")
# 
#         val result = LibSmfReader__open(bad_path)
#         expect(result.is_err()).to_equal(true)
# 
#         # Clean up
#         shell("rm -f '{bad_path}'")
# 
# describe "LibSmfReader - Module Listing":
#     it "should list all modules":
#         # Create library with multiple modules
#         var builder = LibSmfBuilder__new()
#         val smf1 = "/tmp/list1.smf"
#         val smf2 = "/tmp/list2.smf"
#         val smf3 = "/tmp/list3.smf"
#         file_write(smf1, "M1")
#         file_write(smf2, "M2")
#         file_write(smf3, "M3")
# 
#         builder.add_module("mod/one", smf1)
#         builder.add_module("mod/two", smf2)
#         builder.add_module("mod/three", smf3)
# 
#         val lib_path = "/tmp/list_test.lsm"
#         builder.write(lib_path)
# 
#         # Read library
#         val reader = LibSmfReader__open(lib_path).unwrap()
#         val modules = reader.list_modules()
# 
#         expect(modules.len()).to_equal(3)
#         expect(modules.contains("mod/one")).to_equal(true)
#         expect(modules.contains("mod/two")).to_equal(true)
#         expect(modules.contains("mod/three")).to_equal(true)
# 
#         # Clean up
#         reader.close()
#         shell("rm -f '{lib_path}'")
# 
#     it "should check if module exists":
#         var builder = LibSmfBuilder__new()
#         val smf = "/tmp/exists_test.smf"
#         file_write(smf, "DATA")
#         builder.add_module("exists/here", smf)
# 
#         val lib_path = "/tmp/exists_test.lsm"
#         builder.write(lib_path)
# 
#         val reader = LibSmfReader__open(lib_path).unwrap()
# 
#         expect(reader.has_module("exists/here")).to_equal(true)
#         expect(reader.has_module("not/there")).to_equal(false)
# 
#         reader.close()
#         shell("rm -f '{lib_path}'")
# 
# describe "LibSmfReader - Reading SMF Data":
#     it "should read module SMF data":
#         var builder = LibSmfBuilder__new()
#         val test_content = "UNIQUE_TEST_CONTENT_12345"
#         val smf = "/tmp/read_smf.smf"
#         file_write(smf, test_content)
#         builder.add_module("test/read", smf)
# 
#         val lib_path = "/tmp/read_smf.lsm"
#         builder.write(lib_path)
# 
#         val reader = LibSmfReader__open(lib_path).unwrap()
#         val result = reader.get_module("test/read")
# 
#         expect(result.is_ok()).to_equal(true)
#         val data = result.unwrap()
#         expect(data.len()).to_equal(test_content.len())
# 
#         reader.close()
#         shell("rm -f '{lib_path}'")
# 
#     it "should return error for missing module":
#         var builder = LibSmfBuilder__new()
#         val smf = "/tmp/missing.smf"
#         file_write(smf, "DATA")
#         builder.add_module("exists", smf)
# 
#         val lib_path = "/tmp/missing_test.lsm"
#         builder.write(lib_path)
# 
#         val reader = LibSmfReader__open(lib_path).unwrap()
#         val result = reader.get_module("does/not/exist")
# 
#         expect(result.is_err()).to_equal(true)
# 
#         reader.close()
#         shell("rm -f '{lib_path}'")
# 
# describe "LibSmfReader - Object File Support":
#     it "should detect modules with object files":
#         var builder = LibSmfBuilder__new()
# 
#         val smf1 = "/tmp/no_obj.smf"
#         val smf2 = "/tmp/has_obj.smf"
#         val obj2 = "/tmp/has_obj.o"
#         file_write(smf1, "SMF1")
#         file_write(smf2, "SMF2")
#         file_write(obj2, "OBJ2")
# 
#         builder.add_module("without/obj", smf1)
#         builder.add_module_with_object("with/obj", smf2, obj2)
# 
#         val lib_path = "/tmp/obj_detect.lsm"
#         builder.write(lib_path)
# 
#         val reader = LibSmfReader__open(lib_path).unwrap()
# 
#         expect(reader.has_object("without/obj")).to_equal(false)
#         expect(reader.has_object("with/obj")).to_equal(true)
# 
#         reader.close()
#         shell("rm -f '{lib_path}'")
# 
#     it "should read object file data":
#         var builder = LibSmfBuilder__new()
#         val test_obj_content = "OBJECT_CODE_12345"
#         val smf = "/tmp/read_obj.smf"
#         val obj = "/tmp/read_obj.o"
#         file_write(smf, "SMF_DATA")
#         file_write(obj, test_obj_content)
# 
#         builder.add_module_with_object("test/obj", smf, obj)
# 
#         val lib_path = "/tmp/read_obj.lsm"
#         builder.write(lib_path)
# 
#         val reader = LibSmfReader__open(lib_path).unwrap()
#         val result = reader.get_object("test/obj")
# 
#         expect(result.is_ok()).to_equal(true)
#         val data = result.unwrap()
#         expect(data.len()).to_equal(test_obj_content.len())
# 
#         reader.close()
#         shell("rm -f '{lib_path}'")
# 
#     it "should return error when reading object from SMF-only module":
#         var builder = LibSmfBuilder__new()
#         val smf = "/tmp/no_obj_error.smf"
#         file_write(smf, "SMF_ONLY")
#         builder.add_module("no/obj", smf)
# 
#         val lib_path = "/tmp/no_obj_error.lsm"
#         builder.write(lib_path)
# 
#         val reader = LibSmfReader__open(lib_path).unwrap()
#         val result = reader.get_object("no/obj")
# 
#         expect(result.is_err()).to_equal(true)
# 
#         reader.close()
#         shell("rm -f '{lib_path}'")
# 
# describe "LibSmfReader - Round-trip Testing":
#     it "should preserve SMF data through write and read":
#         var builder = LibSmfBuilder__new()
#         val original_data = "PRESERVE_THIS_EXACT_DATA"
#         val smf = "/tmp/roundtrip.smf"
#         file_write(smf, original_data)
#         builder.add_module("roundtrip/module", smf)
# 
#         val lib_path = "/tmp/roundtrip.lsm"
#         builder.write(lib_path)
# 
#         val reader = LibSmfReader__open(lib_path).unwrap()
#         val read_result = reader.get_module("roundtrip/module")
# 
#         expect(read_result.is_ok()).to_equal(true)
#         val data = read_result.unwrap()
# 
#         # Data length should match
#         expect(data.len()).to_equal(original_data.len())
# 
#         reader.close()
#         shell("rm -f '{lib_path}'")
# 
#     it "should preserve both SMF and object data":
#         var builder = LibSmfBuilder__new()
#         val smf_content = "SMF_ROUNDTRIP_DATA"
#         val obj_content = "OBJ_ROUNDTRIP_DATA"
# 
#         val smf = "/tmp/both_roundtrip.smf"
#         val obj = "/tmp/both_roundtrip.o"
#         file_write(smf, smf_content)
#         file_write(obj, obj_content)
# 
#         builder.add_module_with_object("both/data", smf, obj)
# 
#         val lib_path = "/tmp/both_roundtrip.lsm"
#         builder.write(lib_path)
# 
#         val reader = LibSmfReader__open(lib_path).unwrap()
# 
#         # Read SMF
#         val smf_result = reader.get_module("both/data")
#         expect(smf_result.is_ok()).to_equal(true)
#         expect(smf_result.unwrap().len()).to_equal(smf_content.len())
# 
#         # Read object
#         val obj_result = reader.get_object("both/data")
#         expect(obj_result.is_ok()).to_equal(true)
#         expect(obj_result.unwrap().len()).to_equal(obj_content.len())
# 
#         reader.close()
#         shell("rm -f '{lib_path}'")
