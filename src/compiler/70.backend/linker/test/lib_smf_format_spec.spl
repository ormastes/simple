describe "Lib Smf Format":
    it "skipped":
        skip("pre-existing test failures - functions/imports not available")

# # Library SMF Format Tests
# #
# # Tests for the extended library SMF format with object file support.
# # Covers ModuleIndexEntry serialization, deserialization, and backward compatibility.
# 
# use std.spec
# use compiler.backend.linker.lib_smf.{ModuleIndexEntry, LibSmfHeader, fnv1a_hash}
# 
# describe "ModuleIndexEntry":
#     it "should create entry without object file":
#         val entry = ModuleIndexEntry.new("test/module", 128, 1024, 12345)
# 
#         expect(entry.get_name()).to_equal("test/module")
#         expect(entry.offset as i64).to_equal(128)
#         expect(entry.size as i64).to_equal(1024)
#         expect(entry.hash as i64).to_equal(12345)
#         expect(entry.has_object()).to_equal(false)
#         expect(entry.obj_size as i64).to_equal(0)
# 
#     it "should create entry with object file":
#         val entry = ModuleIndexEntry.new_with_object(
#             "std/io/mod",
#             1000,      # SMF offset
#             2000,      # SMF size
#             111111,    # SMF hash
#             3000,      # Object offset
#             500,       # Object size
#             222222     # Object hash
#         )
# 
#         expect(entry.get_name()).to_equal("std/io/mod")
#         expect(entry.offset as i64).to_equal(1000)
#         expect(entry.size as i64).to_equal(2000)
#         expect(entry.hash as i64).to_equal(111111)
#         expect(entry.has_object()).to_equal(true)
#         expect(entry.obj_offset as i64).to_equal(3000)
#         expect(entry.obj_size as i64).to_equal(500)
#         expect(entry.obj_hash as i64).to_equal(222222)
# 
#     it "should serialize entry to exactly 128 bytes":
#         val entry = ModuleIndexEntry.new_with_object(
#             "test/module", 100, 200, 111, 300, 50, 222
#         )
#         val bytes = entry.to_bytes()
# 
#         expect(bytes.len()).to_equal(128)
# 
#     it "should serialize and deserialize entry without object":
#         val original = ModuleIndexEntry.new("my/module", 500, 1500, 99999)
#         val bytes = original.to_bytes()
#         val result = ModuleIndexEntry.from_bytes(bytes, 0)
# 
#         expect(result.is_ok()).to_equal(true)
#         val restored = result.unwrap()
# 
#         expect(restored.get_name()).to_equal("my/module")
#         expect(restored.offset as i64).to_equal(500)
#         expect(restored.size as i64).to_equal(1500)
#         expect(restored.hash as i64).to_equal(99999)
#         expect(restored.has_object()).to_equal(false)
# 
#     it "should serialize and deserialize entry with object":
#         val original = ModuleIndexEntry.new_with_object(
#             "std/string", 1000, 2000, 111, 3000, 500, 222
#         )
#         val bytes = original.to_bytes()
#         val result = ModuleIndexEntry.from_bytes(bytes, 0)
# 
#         expect(result.is_ok()).to_equal(true)
#         val restored = result.unwrap()
# 
#         expect(restored.get_name()).to_equal("std/string")
#         expect(restored.offset as i64).to_equal(1000)
#         expect(restored.size as i64).to_equal(2000)
#         expect(restored.hash as i64).to_equal(111)
#         expect(restored.has_object()).to_equal(true)
#         expect(restored.obj_offset as i64).to_equal(3000)
#         expect(restored.obj_size as i64).to_equal(500)
#         expect(restored.obj_hash as i64).to_equal(222)
# 
#     it "should handle module names up to 63 characters":
#         val long_name = "a/very/long/module/path/that/goes/on/and/on/and/reaches/limit"
#         val entry = ModuleIndexEntry.new(long_name, 100, 200, 12345)
#         val bytes = entry.to_bytes()
#         val result = ModuleIndexEntry.from_bytes(bytes, 0)
# 
#         expect(result.is_ok()).to_equal(true)
#         val restored = result.unwrap()
#         expect(restored.get_name()).to_equal(long_name)
# 
#     it "should return error for invalid entry size":
#         var short_bytes: [u8] = []
#         var i = 0
#         while i < 100:
#             short_bytes.push(0)
#             i = i + 1
# 
#         val result = ModuleIndexEntry.from_bytes(short_bytes, 0)
#         expect(result.is_err()).to_equal(true)
# 
# describe "LibSmfHeader":
#     it "should create valid default header":
#         val header = LibSmfHeader.new_default()
# 
#         expect(header.is_valid()).to_equal(true)
#         expect(header.module_count as i64).to_equal(0)
#         expect(header.index_offset as i64).to_equal(128)
# 
#     it "should serialize header to exactly 128 bytes":
#         val header = LibSmfHeader.new_default()
#         val bytes = header.to_bytes()
# 
#         expect(bytes.len()).to_equal(128)
# 
#     it "should serialize and deserialize header":
#         var header = LibSmfHeader.new_default()
#         header.module_count = 42
#         header.library_hash = 999999
# 
#         val bytes = header.to_bytes()
#         val result = LibSmfHeader.from_bytes(bytes)
# 
#         expect(result.is_ok()).to_equal(true)
#         val restored = result.unwrap()
# 
#         expect(restored.is_valid()).to_equal(true)
#         expect(restored.module_count as i64).to_equal(42)
#         expect(restored.library_hash as i64).to_equal(999999)
# 
#     it "should validate magic number":
#         var header = LibSmfHeader.new_default()
#         val bytes = header.to_bytes()
# 
#         # Corrupt magic
#         var bad_bytes = bytes
#         bad_bytes[0] = 99
# 
#         val result = LibSmfHeader.from_bytes(bad_bytes)
#         expect(result.is_err()).to_equal(true)
# 
#     it "should return error for too small header":
#         var small_bytes: [u8] = []
#         var i = 0
#         while i < 50:
#             small_bytes.push(0)
#             i = i + 1
# 
#         val result = LibSmfHeader.from_bytes(small_bytes)
#         expect(result.is_err()).to_equal(true)
# 
# describe "fnv1a_hash":
#     it "should produce consistent hashes":
#         val data1 = [1, 2, 3, 4, 5]
#         val data2 = [1, 2, 3, 4, 5]
# 
#         val hash1 = fnv1a_hash(data1)
#         val hash2 = fnv1a_hash(data2)
# 
#         expect(hash1).to_equal(hash2)
# 
#     it "should produce different hashes for different data":
#         val data1 = [1, 2, 3, 4, 5]
#         val data2 = [5, 4, 3, 2, 1]
# 
#         val hash1 = fnv1a_hash(data1)
#         val hash2 = fnv1a_hash(data2)
# 
#         expect(hash1 != hash2).to_equal(true)
# 
#     it "should handle empty data":
#         val empty: [u8] = []
#         val hash = fnv1a_hash(empty)
# 
#         # FNV-1a offset basis (non-zero for empty input)
#         expect(hash > 0).to_equal(true)
