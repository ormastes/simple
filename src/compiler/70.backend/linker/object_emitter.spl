# Object Emitter - Assembles code units into object files
#
# Converts raw machine code bytes into proper ELF .o files by delegating to
# the system assembler (llvm-mc, as) or by writing raw object data.

use std.io_runtime.{shell, shell_output, file_exists, file_write, file_delete}
use compiler.backend.linker.object_code_unit.{ObjectCodeUnit}

fn assemble_code_units(units: [ObjectCodeUnit], obj_path: text, verbose: bool) -> Result<text, text>:
    if units.len() == 0:
        return Err("No code units to assemble")

    # Merge all code unit bytes into a single buffer
    var all_bytes: [u8] = []
    for unit in units:
        all_bytes = all_bytes + unit.bytes

    if all_bytes.len() == 0:
        return Err("All code units are empty")

    # Write raw bytes to a temporary binary file
    val tmp_bin = "{obj_path}.raw"
    val write_ok = write_binary_file(tmp_bin, all_bytes)
    if not write_ok:
        return Err("Failed to write raw code to {tmp_bin}")

    # Strategy 1: Use objcopy to wrap raw binary into ELF .o
    val objcopy_result = try_objcopy(tmp_bin, obj_path, verbose)
    if objcopy_result.is_ok():
        file_delete(tmp_bin)
        return objcopy_result

    # Strategy 2: Use llvm-objcopy
    val llvm_objcopy_result = try_llvm_objcopy(tmp_bin, obj_path, verbose)
    if llvm_objcopy_result.is_ok():
        file_delete(tmp_bin)
        return llvm_objcopy_result

    # Strategy 3: Direct copy as raw .o (linker may handle it)
    val cp_result = shell("cp '{tmp_bin}' '{obj_path}'")
    file_delete(tmp_bin)
    if cp_result.exit_code == 0:
        if verbose:
            print "[object-emitter] Copied raw bytes as {obj_path} ({all_bytes.len()} bytes)"
        return Ok(obj_path)

    Err("Failed to assemble code units into object file")

fn try_objcopy(tmp_bin: text, obj_path: text, verbose: bool) -> Result<text, text>:
    # objcopy -I binary -O elf64-x86-64 -B i386:x86-64 input.raw output.o
    val cmd = "objcopy -I binary -O elf64-x86-64 -B i386:x86-64 '{tmp_bin}' '{obj_path}' 2>&1"
    val result = shell(cmd)
    if result.exit_code == 0:
        if verbose:
            print "[object-emitter] Assembled via objcopy: {obj_path}"
        Ok(obj_path)
    else:
        Err("objcopy failed: {result.stderr}")

fn try_llvm_objcopy(tmp_bin: text, obj_path: text, verbose: bool) -> Result<text, text>:
    # Try llvm-objcopy variants
    var tool = ""
    val check_18 = shell("which llvm-objcopy-18 2>/dev/null")
    if check_18.exit_code == 0:
        tool = "llvm-objcopy-18"
    else:
        val check_17 = shell("which llvm-objcopy-17 2>/dev/null")
        if check_17.exit_code == 0:
            tool = "llvm-objcopy-17"
        else:
            val check_plain = shell("which llvm-objcopy 2>/dev/null")
            if check_plain.exit_code == 0:
                tool = "llvm-objcopy"
            else:
                return Err("llvm-objcopy not found")

    val cmd = "{tool} -I binary -O elf64-x86-64 -B i386:x86-64 '{tmp_bin}' '{obj_path}' 2>&1"
    val result = shell(cmd)
    if result.exit_code == 0:
        if verbose:
            print "[object-emitter] Assembled via {tool}: {obj_path}"
        Ok(obj_path)
    else:
        Err("{tool} failed: {result.stderr}")

fn write_binary_file(path: text, data: [u8]) -> bool:
    if data.len() == 0:
        return false
    # Write bytes via hex encoding + xxd
    var hex_str = ""
    for byte in data:
        val b = byte & 0xFF
        val hi = "0123456789abcdef"[(b >> 4):((b >> 4) + 1)]
        val lo = "0123456789abcdef"[(b & 0xF):((b & 0xF) + 1)]
        hex_str = hex_str + hi + lo
    val result = shell("echo '{hex_str}' | xxd -r -p > '{path}'")
    result.exit_code == 0

export assemble_code_units
