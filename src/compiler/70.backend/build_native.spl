# Build Native - Compile Simple programs to native binaries.
#
# This module provides the build pipeline for creating native executables:
# 1. Compile source files to SMF
# 2. Link SMFs using Simple linker
# 3. Generate native binary via mold
#
# Usage:
#   build_native("src/app/cli/main.spl", "simple_new_native")
#
# This enables self-hosting: compiling the Simple CLI (written in Simple)
# to a native binary using the Simple linker.
#
# Split into modules:
#   build_native_types.spl    — LinkConfig, BuildConfig, BuildResult and related types
#   build_native_pipeline.spl — Core build pipeline: build_native, build_native_llvm, build_native_elf, helpers

use linker.*
use driver (compile_to_smf)
use compiler.backend.llvm_backend.{LlvmBackend, LlvmBackend__create, compile_ir_to_object, generate_runtime_declarations, LlvmTargetConfig__for_target}
use compiler.backend.mir_to_llvm.{MirToLlvm, MirToLlvm__create}
use compiler.core.backend_types.{CodegenTarget, OptimizationLevel}
use compiler.backend.entry_point.{generate_entry_point_ir}
use compiler.mir.mir_data.{MirModule}
use compiler.backend.linker.linker_wrapper.{link_to_native as lw_link_to_native, NativeLinkConfig, NativeLinkConfig__default}
use compiler.backend.linker.obj_taker.{ObjTaker, ObjTakerConfig, ObjTakeResult, objtaker_new, objtaker_with_defaults, objtakerconfig_default, objtaker_take_object}

# Import from split modules
use build_native_types.{OutputFormat, LinkConfig, LinkStats, LinkResult, LinkError, Linker, link_native, BuildConfig, BuildResult, BuildStats}
use build_native_pipeline.{build_native, build_native_llvm, build_native_elf, objtaker_verify_smfs}
use build_native_pipeline.{discover_dependencies, source_to_smf_path, source_to_obj_path, current_time_ms}

extern fn rt_time_now_unix_millis() -> i64
extern fn rt_file_exists(path: text) -> bool
extern fn rt_mkdir_p(path: text) -> bool

# ============================================================================
# Cache-Aware Build
# ============================================================================

fn build_native_from_cache(config: BuildConfig) -> BuildResult:
    """Build a native binary using pre-compiled SMF cache.

    Checks build/smf/ for cached SMF files first. On cache miss,
    compiles to SMF on demand. Then links via the standard pipeline.
    """
    val start_time = current_time_ms()
    val cache_dir = "build/smf"

    if config.verbose:
        print "[build-cache] Starting cache-aware native build"
        print "[build-cache] Cache dir: {cache_dir}"

    # 1. Collect all source files
    var source_files: [text] = [config.entry_point]
    source_files = source_files.concat(config.dependencies)
    source_files = discover_dependencies(source_files, config.verbose)

    # 2. Check cache and compile as needed
    var smf_files: [text] = []
    var cache_hits = 0
    var cache_misses = 0

    for source in source_files:
        # Check if cached SMF exists
        val base_no_ext = source.replace(".spl", "")
        val base = base_no_ext.replace("/", "_")
        val cache_path = "{cache_dir}/{base}.smf"

        if rt_file_exists(cache_path):
            cache_hits = cache_hits + 1
            smf_files = smf_files.push(cache_path)
            if config.verbose:
                print "[build-cache] Cache hit: {source} -> {cache_path}"
        else:
            cache_misses = cache_misses + 1
            # Compile on demand to standard artifacts location
            val smf_path = source_to_smf_path(source)
            if config.verbose:
                print "[build-cache] Cache miss: {source} -> {smf_path}"

            val compile_result = compile_to_smf(source, smf_path)
            if compile_result.is_err():
                return BuildResult.CompileError(
                    file: source,
                    message: compile_result.unwrap_err()
                )
            smf_files = smf_files.push(smf_path)

    val compile_time = current_time_ms() - start_time

    if config.verbose:
        print "[build-cache] Cache: {cache_hits} hits, {cache_misses} misses"

    # 3. Run ObjTaker verification
    val verify_result = objtaker_verify_smfs(smf_files, config.verbose)
    if verify_result.is_err():
        return BuildResult.Error(message: verify_result.unwrap_err())

    # 4. Link SMFs to native binary
    val link_start = current_time_ms()

    var target_flags: [text] = []
    if config.target_cpu.?:
        target_flags.push("-march={config.target_cpu.unwrap()}")
    for feature in config.target_features:
        target_flags.push("-m{feature}")

    val link_config = LinkConfig(
        output_format: OutputFormat.Native,
        output_path: config.output,
        libraries: config.libraries,
        library_paths: config.library_paths,
        pie: config.pie,
        debug: config.debug,
        verbose: config.verbose,
        allow_deferred: false,
        optimization_level: config.optimization,
        target_flags: target_flags,
        linker_flags: config.linker_flags
    )

    var linker = Linker.new(link_config)
    val link_result = linker.link(smf_files)

    match link_result:
        case Success(output_path, stats):
            val link_time = current_time_ms() - link_start

            if config.verbose:
                print "[build-cache] Link complete ({link_time}ms)"
                print "[build-cache] Output: {output_path}"

            BuildResult.Success(
                output: output_path,
                stats: BuildStats(
                    source_files: source_files.len() as i32,
                    smf_files: smf_files.len() as i32,
                    total_symbols: stats.symbol_count,
                    output_size: stats.output_size,
                    compile_time_ms: compile_time,
                    link_time_ms: link_time
                )
            )

        case Error(message, errors):
            val error_msgs = errors.map(\e: e.message).join("\n")
            BuildResult.LinkError(message: "{message}\n{error_msgs}")


# ============================================================================
# Convenience Functions
# ============================================================================

fn build_simple_cli() -> BuildResult:
    """Build the Simple CLI to native binary."""
    val config = BuildConfig.for_simple_cli()
    build_native(config)

fn build_file(source: text, output: text) -> BuildResult:
    """Build a single file to native binary."""
    val config = BuildConfig.default(source, output)
    build_native(config)

# ============================================================================
# CLI Integration
# ============================================================================

fn handle_build_command(args: [text]) -> i32:
    """Handle 'simple build' command.

    Usage:
      simple build <source.spl> [-o <output>] [--native] [--verbose] [--backend=llvm]
      simple build --self  # Build simple_new_native
    """
    if args.is_empty():
        print "Usage: simple build <source.spl> [-o <output>] [--native] [--verbose] [--backend=llvm]"
        print "       simple build --self  # Build simple_new_native"
        return 1

    # Check for --self flag (build simple_new)
    if args[0] == "--self":
        print "Building simple_new_native..."
        val result = build_simple_cli()
        match result:
            case Success(output, stats):
                print "Build successful!"
                print "  Output: {output}"
                print "  Size: {stats.output_size} bytes"
                print "  Source files: {stats.source_files}"
                print "  Compile time: {stats.compile_time_ms}ms"
                print "  Link time: {stats.link_time_ms}ms"
                return 0
            case CompileError(file, msg):
                print "Compile error in {file}:"
                print "  {msg}"
                return 1
            case LinkError(msg):
                print "Link error: {msg}"
                return 1
            case Error(msg):
                print "Build error: {msg}"
                return 1

    # Parse arguments
    var source = args[0]
    var output = source.replace(".spl", "")
    var verbose = false
    var backend_name: text? = nil

    var i = 1
    while i < args.len():
        val arg = args[i]
        if arg == "-o":
            if i + 1 < args.len():
                output = args[i + 1]
                i = i + 2
            else:
                print "Error: -o requires an argument"
                return 1
        elif arg == "--verbose":
            verbose = true
            i = i + 1
        elif arg == "--fixed-be":
            backend_name = Some("llvm")
            i = i + 1
        elif arg == "--native":
            # Default is native, this is a no-op
            i = i + 1
        elif arg == "--backend=llvm":
            backend_name = Some("llvm")
            i = i + 1
        elif arg == "--backend=smf":
            backend_name = nil
            i = i + 1
        elif arg.starts_with("--backend="):
            val be_name = arg[10..]
            print "Unknown backend: {be_name}. Use 'llvm' or 'smf'."
            return 1
        else:
            print "Unknown option: {arg}"
            return 1

    # Build
    var config = BuildConfig.default(source, output)
    config.verbose = verbose
    config.backend = backend_name

    # Dispatch to appropriate backend
    val result = if config.backend.? and config.backend.unwrap() == "llvm":
        if verbose:
            print "[build] Using LLVM backend"
        build_native_llvm(config)
    else:
        build_native(config)

    match result:
        case Success(out, stats):
            print "Build successful: {out}"
            return 0
        case CompileError(file, msg):
            print "Compile error in {file}: {msg}"
            return 1
        case LinkError(msg):
            print "Link error: {msg}"
            return 1
        case Error(msg):
            print "Build error: {msg}"
            return 1

# ============================================================================
# Exports
# ============================================================================

export BuildConfig
export BuildResult
export BuildStats
export build_native
export build_native_llvm
export build_native_elf
export build_native_from_cache
export build_simple_cli
export build_file
export handle_build_command
export objtaker_verify_smfs

# ============================================================================
# Entry Point
# ============================================================================

val args = sys_get_args()
# Skip the script path itself - args[0] is the script, rest are user args
var user_args: [text] = []
if args.len() > 1:
    for i in 1..args.len():
        user_args.push(args[i])

val exit_code = handle_build_command(user_args)
if exit_code != 0:
    exit(exit_code)
