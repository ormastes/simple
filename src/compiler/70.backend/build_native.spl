# Build Native - Compile Simple programs to native binaries.
#
# This module provides the build pipeline for creating native executables:
# 1. Compile source files to SMF
# 2. Link SMFs using Simple linker
# 3. Generate native binary via mold
#
# Usage:
#   build_native("src/app/cli/main.spl", "simple_new_native")
#
# This enables self-hosting: compiling the Simple CLI (written in Simple)
# to a native binary using the Simple linker.

use linker.*
use driver (compile_to_smf)
use compiler.backend.llvm_backend.{LlvmBackend, LlvmBackend__create, compile_ir_to_object, generate_runtime_declarations, LlvmTargetConfig__for_target}
use compiler.backend.mir_to_llvm.{MirToLlvm, MirToLlvm__create}
use compiler.core.backend_types.{CodegenTarget, OptimizationLevel}
use compiler.backend.entry_point.{generate_entry_point_ir}
use compiler.mir_data.{MirModule}
use compiler.linker.linker_wrapper.{link_to_native as lw_link_to_native, NativeLinkConfig, NativeLinkConfig__default, generate_runtime_stub}

# ============================================================================
# Link Pipeline Types (defined locally because linker/link.spl has deps
# that the bootstrap parser cannot handle)
# ============================================================================

enum OutputFormat:
    Smf
    Native

struct LinkConfig:
    output_format: OutputFormat
    output_path: text
    libraries: [text]
    library_paths: [text]
    pie: bool
    debug: bool
    verbose: bool
    allow_deferred: bool
    optimization_level: i32
    target_flags: [text]
    linker_flags: [text]

struct LinkStats:
    output_size: i64
    symbol_count: i32

enum LinkResult:
    Success(output_path: text, stats: LinkStats)
    Error(message: text, errors: [LinkError])

struct LinkError:
    message: text

struct Linker:
    config: LinkConfig

impl Linker:
    static fn new(config: LinkConfig) -> Linker:
        Linker(config: config)

    me link(smf_files: [text]) -> LinkResult:
        """Link SMF files to native binary using linker_wrapper."""
        if smf_files.is_empty():
            return LinkResult.Error(
                message: "No SMF files to link",
                errors: [LinkError(message: "empty input")]
            )

        # Use linker_wrapper to create native binary
        val output = self.config.output_path
        val verbose = self.config.verbose

        if verbose:
            print "[linker] Linking {smf_files.len()} files -> {output}"

        # Delegate to linker_wrapper's link_native function
        val result = link_native(smf_files, output, self.config)
        match result:
            case Ok(path):
                val stats = LinkStats(output_size: 0, symbol_count: 0)
                LinkResult.Success(output_path: path, stats: stats)
            case Err(msg):
                LinkResult.Error(
                    message: msg,
                    errors: [LinkError(message: msg)]
                )

fn link_native(smf_files: [text], output: text, config: LinkConfig) -> Result<text, text>:
    """Link SMF files to a native binary using linker_wrapper (SMF-aware)."""
    var native_cfg = NativeLinkConfig(
        libraries: config.libraries,
        library_paths: config.library_paths,
        runtime_path: "",
        pie: config.pie,
        debug: config.debug,
        verbose: config.verbose,
        extra_flags: config.linker_flags
    )

    val result = lw_link_to_native(smf_files, output, native_cfg)
    match result:
        case Ok(path): Ok(path)
        case Err(msg): Err(msg)

# ============================================================================
# Build Configuration
# ============================================================================

struct BuildConfig:
    """Configuration for native build."""
    entry_point: text
    output: text
    dependencies: [text]
    libraries: [text]
    library_paths: [text]
    optimization: i32
    debug: bool
    verbose: bool
    pie: bool
    target_cpu: text?           # Target CPU (e.g., "x86-64-v3", "haswell", "native")
    target_features: [text]     # Target features (e.g., ["+avx2", "+fma"])
    linker_flags: [text]        # Extra linker flags
    backend: text?              # Backend: nil/"smf" = SMF pipeline, "llvm" = LLVM pipeline

impl BuildConfig:
    static fn default(entry: text, output: text) -> BuildConfig:
        BuildConfig(
            entry_point: entry,
            output: output,
            dependencies: [],
            libraries: ["c"],
            library_paths: [],
            optimization: 0,
            debug: false,
            verbose: false,
            pie: true,
            target_cpu: nil,
            target_features: [],
            linker_flags: [],
            backend: nil
        )

    static fn for_simple_cli() -> BuildConfig:
        """Configuration for building simple_new native."""
        BuildConfig(
            entry_point: "src/app/cli/main.spl",
            output: "simple_new_native",
            dependencies: [
                "src/compiler/mod.spl",
                "src/std/src/mod.spl"
            ],
            libraries: ["c", "m", "pthread"],
            library_paths: [],
            optimization: 2,
            debug: false,
            verbose: true,
            pie: true,
            target_cpu: Some("x86-64-v3"),      # Default to modern CPUs
            target_features: [],
            linker_flags: [],
            backend: nil
        )

# ============================================================================
# Build Result
# ============================================================================

enum BuildResult:
    Success(output: text, stats: BuildStats)
    CompileError(file: text, message: text)
    LinkError(message: text)
    Error(message: text)

struct BuildStats:
    """Statistics from the build."""
    source_files: i32
    smf_files: i32
    total_symbols: i32
    output_size: i64
    compile_time_ms: i64
    link_time_ms: i64

impl BuildResult:
    fn is_success() -> bool:
        match self:
            case Success(_, _): true
            case _: false

# ============================================================================
# Build Pipeline
# ============================================================================

fn build_native(config: BuildConfig) -> BuildResult:
    """Build a native binary from Simple source files.

    Pipeline:
    1. Discover all source files (entry + dependencies)
    2. Compile each source file to SMF
    3. Link all SMFs with the Simple linker
    4. Generate native binary via mold
    """
    val start_time = current_time_ms()

    if config.verbose:
        print "[build] Starting native build"
        print "[build] Entry point: {config.entry_point}"
        print "[build] Output: {config.output}"

    # 1. Collect all source files
    var source_files: [text] = [config.entry_point]
    source_files = source_files.concat(config.dependencies)

    # Add implicit dependencies
    source_files = discover_dependencies(source_files, config.verbose)

    if config.verbose:
        print "[build] Compiling {source_files.len()} source files"

    # 2. Compile each source to SMF
    var smf_files: [text] = []
    for source in source_files:
        val smf_path = source_to_smf_path(source)

        if config.verbose:
            print "[build] Compiling: {source} -> {smf_path}"

        val compile_result = compile_to_smf(source, smf_path)
        if compile_result.is_err():
            return BuildResult.CompileError(
                file: source,
                message: compile_result.unwrap_err()
            )

        smf_files = smf_files.push(smf_path)

    val compile_time = current_time_ms() - start_time

    if config.verbose:
        print "[build] Compilation complete ({compile_time}ms)"
        print "[build] Linking {smf_files.len()} SMF files"

    # 3. Link SMFs to native binary
    val link_start = current_time_ms()

    # Build target flags from CPU and features
    var target_flags: [text] = []
    if config.target_cpu.?:
        target_flags.push("-march={config.target_cpu.unwrap()}")
    for feature in config.target_features:
        target_flags.push("-m{feature}")

    val link_config = LinkConfig(
        output_format: OutputFormat.Native,
        output_path: config.output,
        libraries: config.libraries,
        library_paths: config.library_paths,
        pie: config.pie,
        debug: config.debug,
        verbose: config.verbose,
        allow_deferred: false,
        optimization_level: config.optimization,
        target_flags: target_flags,
        linker_flags: config.linker_flags
    )

    var linker = Linker.new(link_config)
    val link_result = linker.link(smf_files)

    match link_result:
        case Success(output_path, stats):
            val link_time = current_time_ms() - link_start
            val total_time = current_time_ms() - start_time

            if config.verbose:
                print "[build] Link complete ({link_time}ms)"
                print "[build] Output: {output_path}"
                print "[build] Size: {stats.output_size} bytes"
                print "[build] Total time: {total_time}ms"

            BuildResult.Success(
                output: output_path,
                stats: BuildStats(
                    source_files: source_files.len() as i32,
                    smf_files: smf_files.len() as i32,
                    total_symbols: stats.symbol_count,
                    output_size: stats.output_size,
                    compile_time_ms: compile_time,
                    link_time_ms: link_time
                )
            )

        case Error(message, errors):
            val error_msgs = errors.map(\e: e.message).join("\n")
            BuildResult.LinkError(message: "{message}\n{error_msgs}")

# ============================================================================
# LLVM Build Pipeline
# ============================================================================

fn build_native_llvm(config: BuildConfig) -> BuildResult:
    """Build a native binary using the LLVM backend.

    Pipeline:
    1. Discover all source files (entry + dependencies)
    2. Compile each source to SMF (for MIR extraction)
    3. Translate MIR to LLVM IR via MirToLlvm
    4. Compile LLVM IR to .o object files via llc
    5. Generate entry point and runtime stub
    6. Link all .o files via linker_wrapper
    """
    val start_time = current_time_ms()

    if config.verbose:
        print "[build-llvm] Starting LLVM native build"
        print "[build-llvm] Entry point: {config.entry_point}"
        print "[build-llvm] Output: {config.output}"

    # 1. Collect all source files
    var source_files: [text] = [config.entry_point]
    source_files = source_files.concat(config.dependencies)
    source_files = discover_dependencies(source_files, config.verbose)

    if config.verbose:
        print "[build-llvm] Compiling {source_files.len()} source files"

    # Ensure .build directory exists
    extern fn rt_process_run_llvm(cmd: text, args: [text]) -> text
    rt_process_run_llvm("mkdir", ["-p", ".build"])

    # 2. Compile each source to SMF first (needed for MIR extraction)
    var smf_files: [text] = []
    for source in source_files:
        val smf_path = source_to_smf_path(source)

        if config.verbose:
            print "[build-llvm] Compiling to SMF: {source} -> {smf_path}"

        val compile_result = compile_to_smf(source, smf_path)
        if compile_result.is_err():
            return BuildResult.CompileError(
                file: source,
                message: compile_result.unwrap_err()
            )
        smf_files.push(smf_path)

    # 3. Create LLVM backend
    val target = CodegenTarget.Host
    val opt_level = match config.optimization:
        case 0: OptimizationLevel.Debug
        case 1: OptimizationLevel.Size
        case 2: OptimizationLevel.Speed
        case 3: OptimizationLevel.Aggressive
        case _: OptimizationLevel.Speed

    var backend = LlvmBackend__create(target, opt_level)

    # 4. For each source, translate to LLVM IR and compile to object code
    var object_files: [text] = []
    for source in source_files:
        val obj_path = source_to_obj_path(source)

        if config.verbose:
            print "[build-llvm] Translating to LLVM IR: {source}"

        # Create translator and generate IR
        var translator = MirToLlvm__create(source, target, config.target_cpu)
        val runtime_decls = generate_runtime_declarations()

        # Generate a module-level LLVM IR from the source
        # For now, compile via the backend's compile_module flow
        # which handles MIR translation + llc invocation
        val compile_result = backend.compile_module(
            MirModule(
                name: source,
                functions: {},
                statics: {},
                constants: {},
                types: {}
            )
        )

        if compile_result.is_err():
            return BuildResult.CompileError(
                file: source,
                message: "LLVM compilation failed: {compile_result.unwrap_err()}"
            )

        val llvm_result = compile_result.unwrap()
        if llvm_result.has_object_code():
            # Write object code to .build/ directory
            val obj_bytes = llvm_result.object_code.unwrap()
            val wrote = write_object_file(obj_path, obj_bytes)
            if not wrote:
                return BuildResult.Error(message: "Failed to write object file: {obj_path}")
            object_files.push(obj_path)

            if config.verbose:
                print "[build-llvm] Object file: {obj_path} ({obj_bytes.len()} bytes)"

    # 5. Generate entry point object file
    val entry_ir = generate_entry_point_ir(config.entry_point)
    val entry_obj_path = "build/artifacts/_entry_point.o"
    val entry_config = LlvmTargetConfig__for_target(target, config.target_cpu)
    val entry_result = compile_ir_to_object(entry_ir, entry_config, opt_level)
    if entry_result.is_ok():
        val entry_bytes = entry_result.unwrap()
        val wrote = write_object_file(entry_obj_path, entry_bytes)
        if wrote:
            object_files.push(entry_obj_path)
            if config.verbose:
                print "[build-llvm] Entry point object: {entry_obj_path}"

    # 6. Generate runtime stub
    val stub_result = generate_runtime_stub("build/artifacts/_runtime", config.verbose)
    if stub_result.is_ok():
        val stub_path = stub_result.unwrap()
        object_files.push(stub_path)

    val compile_time = current_time_ms() - start_time

    if config.verbose:
        print "[build-llvm] Compilation complete ({compile_time}ms)"
        print "[build-llvm] Linking {object_files.len()} object files"

    # 7. Link all object files to native binary
    val link_start = current_time_ms()

    val link_config = NativeLinkConfig(
        libraries: config.libraries,
        library_paths: config.library_paths,
        runtime_path: "",
        pie: config.pie,
        debug: config.debug,
        verbose: config.verbose,
        extra_flags: config.linker_flags
    )

    val link_result = lw_link_to_native(object_files, config.output, link_config)
    match link_result:
        case Ok(output_path):
            val link_time = current_time_ms() - link_start

            if config.verbose:
                print "[build-llvm] Link complete ({link_time}ms)"
                print "[build-llvm] Output: {output_path}"

            BuildResult.Success(
                output: output_path,
                stats: BuildStats(
                    source_files: source_files.len() as i32,
                    smf_files: smf_files.len() as i32,
                    total_symbols: 0,
                    output_size: 0,
                    compile_time_ms: compile_time,
                    link_time_ms: link_time
                )
            )

        case Err(msg):
            BuildResult.LinkError(message: msg)

# ============================================================================
# ELF Build Pipeline (SMF-based, alias for build_native)
# ============================================================================

fn build_native_elf(config: BuildConfig) -> BuildResult:
    """Build a native ELF binary using the SMF pipeline.

    This is an alias for build_native() - the existing SMF-to-native pipeline
    that compiles source to SMF format and links via mold.

    Pipeline:
    1. Compile source files to SMF
    2. Link SMFs using Simple linker
    3. Generate native binary via mold
    """
    build_native(config)

# ============================================================================
# Helper Functions
# ============================================================================

fn discover_dependencies(sources: [text], verbose: bool) -> [text]:
    """Discover all transitive dependencies."""
    var all_sources = sources
    var seen: {text: bool} = {}

    for source in sources:
        seen[source] = true

    # Implement import scanning (Phase 1B.5 - TODO #75 ✅)
    use app.io.{file_read}

    # Scan each source file for imports
    var to_scan = sources.copy()
    var scanned = sources.copy()  # Include initial sources in result

    while to_scan.len() > 0:
        var current = to_scan[0]
        to_scan = to_scan[1..]  # Remove first element

        if seen.contains_key(current):
            ()  # Already processed
        else:
            seen[current] = true
            scanned.push(current)

            # Read file and find imports
            if file_exists(current):
                val content = file_read(current)
                val imports = extract_imports(content)

                # Add new imports to scan queue
                for import_path in imports:
                    if not seen.contains_key(import_path):
                        to_scan.push(import_path)

    scanned

fn extract_imports(source_code: text) -> [text]:
    """Extract import statements from source code.

    Parses 'use' and 'import' statements to find module dependencies.
    Returns list of module paths (converted to file paths).

    Phase 1B.5 - TODO #75 ✅
    """
    var imports = []
    val lines = source_code.split("\n")

    for line in lines:
        val trimmed = line.trim()

        # Match 'use module.path' or 'import module.path'
        if trimmed.starts_with("use ") or trimmed.starts_with("import "):
            # Extract module path
            var module_path = ""

            if trimmed.starts_with("use "):
                module_path = trimmed[4..].trim()
            else:
                module_path = trimmed[7..].trim()

            # Remove curly braces if present (use foo.{bar, baz})
            if module_path.contains("{"):
                val parts = module_path.split("{")
                module_path = parts[0].trim()

            # Remove 'as' aliases
            if module_path.contains(" as "):
                val parts = module_path.split(" as ")
                module_path = parts[0].trim()

            # Convert module path to file path
            # e.g., "std.json" -> "src/std/json.spl"
            if module_path.len() > 0 and not module_path.contains("("):
                val file_path = module_to_file_path(module_path)
                imports.push(file_path)

    imports

fn module_to_file_path(module_path: text) -> text:
    """Convert module path to file path.

    Examples:
        std.json -> src/std/json.spl
        app.io.mod -> src/app/io/mod.spl
        compiler.lexer -> src/compiler/lexer.spl
    """
    val path = module_path.replace(".", "/")
    "src/{path}.spl"

fn file_exists(path: text) -> bool:
    """Check if file exists (helper for import scanning)."""
    use app.io.{file_exists as io_file_exists}
    io_file_exists(path)

fn source_to_smf_path(source: text) -> text:
    """Convert source path to SMF output path."""
    # Replace .spl with .smf, put in .build directory
    val base_no_ext = source.replace(".spl", "")
    val base = base_no_ext.replace("/", "_")
    "build/artifacts/{base}.smf"

fn source_to_obj_path(source: text) -> text:
    """Convert source path to object file output path (.o)."""
    val base_no_ext = source.replace(".spl", "")
    val base = base_no_ext.replace("/", "_")
    "build/artifacts/{base}.o"

fn write_object_file(path: text, data: [u8]) -> bool:
    """Write object code bytes to a file."""
    extern fn rt_file_write_bytes(path: text, data: [u8]) -> bool
    rt_file_write_bytes(path, data)

fn current_time_ms() -> i64:
    """Get current time in milliseconds."""
    # Note: rt_time_now_unix_millis not available in bootstrap binary
    0

# ============================================================================
# Convenience Functions
# ============================================================================

fn build_simple_cli() -> BuildResult:
    """Build the Simple CLI to native binary."""
    val config = BuildConfig.for_simple_cli()
    build_native(config)

fn build_file(source: text, output: text) -> BuildResult:
    """Build a single file to native binary."""
    val config = BuildConfig.default(source, output)
    build_native(config)

# ============================================================================
# CLI Integration
# ============================================================================

fn handle_build_command(args: [text]) -> i32:
    """Handle 'simple build' command.

    Usage:
      simple build <source.spl> [-o <output>] [--native] [--verbose] [--backend=llvm]
      simple build --self  # Build simple_new_native
    """
    if args.is_empty():
        print "Usage: simple build <source.spl> [-o <output>] [--native] [--verbose] [--backend=llvm]"
        print "       simple build --self  # Build simple_new_native"
        return 1

    # Check for --self flag (build simple_new)
    if args[0] == "--self":
        print "Building simple_new_native..."
        val result = build_simple_cli()
        match result:
            case Success(output, stats):
                print "Build successful!"
                print "  Output: {output}"
                print "  Size: {stats.output_size} bytes"
                print "  Source files: {stats.source_files}"
                print "  Compile time: {stats.compile_time_ms}ms"
                print "  Link time: {stats.link_time_ms}ms"
                return 0
            case CompileError(file, msg):
                print "Compile error in {file}:"
                print "  {msg}"
                return 1
            case LinkError(msg):
                print "Link error: {msg}"
                return 1
            case Error(msg):
                print "Build error: {msg}"
                return 1

    # Parse arguments
    var source = args[0]
    var output = source.replace(".spl", "")
    var verbose = false
    var backend_name: text? = nil

    var i = 1
    while i < args.len():
        val arg = args[i]
        if arg == "-o":
            if i + 1 < args.len():
                output = args[i + 1]
                i = i + 2
            else:
                print "Error: -o requires an argument"
                return 1
        elif arg == "--verbose":
            verbose = true
            i = i + 1
        elif arg == "--fixed-be":
            backend_name = Some("llvm")
            i = i + 1
        elif arg == "--native":
            # Default is native, this is a no-op
            i = i + 1
        elif arg == "--backend=llvm":
            backend_name = Some("llvm")
            i = i + 1
        elif arg == "--backend=smf":
            backend_name = nil
            i = i + 1
        elif arg.starts_with("--backend="):
            val be_name = arg[10..]
            print "Unknown backend: {be_name}. Use 'llvm' or 'smf'."
            return 1
        else:
            print "Unknown option: {arg}"
            return 1

    # Build
    var config = BuildConfig.default(source, output)
    config.verbose = verbose
    config.backend = backend_name

    # Dispatch to appropriate backend
    val result = if config.backend.? and config.backend.unwrap() == "llvm":
        if verbose:
            print "[build] Using LLVM backend"
        build_native_llvm(config)
    else:
        build_native(config)

    match result:
        case Success(out, stats):
            print "Build successful: {out}"
            return 0
        case CompileError(file, msg):
            print "Compile error in {file}: {msg}"
            return 1
        case LinkError(msg):
            print "Link error: {msg}"
            return 1
        case Error(msg):
            print "Build error: {msg}"
            return 1

# ============================================================================
# Exports
# ============================================================================

export BuildConfig
export BuildResult
export BuildStats
export build_native
export build_native_llvm
export build_native_elf
export build_simple_cli
export build_file
export handle_build_command

# ============================================================================
# Entry Point
# ============================================================================

val args = sys_get_args()
# Skip the script path itself - args[0] is the script, rest are user args
var user_args: [text] = []
if args.len() > 1:
    for i in 1..args.len():
        user_args.push(args[i])

val exit_code = handle_build_command(user_args)
if exit_code != 0:
    exit(exit_code)
