# String Table Assembly Code Generator
#
# Generates RISC-V assembly code for .smt section containing
# the full indexed string table.

use compiler.backend.baremetal.table_builder.{FullStringTable, FullStringEntry}

# Generate complete .smt section assembly
fn generate_smt_section(table: FullStringTable) -> text:
    var asm_text = ""

    # Section header
    asm_text = asm_text + "# Auto-generated string table section" + "\n"
    asm_text = asm_text + "# DO NOT EDIT - Generated by Simple compiler" + "\n"
    asm_text = asm_text + "\n"

    # Define .smt section (read-only, allocated)
    asm_text = asm_text + ".section .smt, \"a\"" + "\n"
    asm_text = asm_text + ".align 4" + "\n"
    asm_text = asm_text + "\n"

    # Global symbol for table start
    asm_text = asm_text + ".global __simple_string_table" + "\n"
    asm_text = asm_text + ".global __simple_string_table_end" + "\n"
    asm_text = asm_text + "\n"

    # Table start
    asm_text = asm_text + "__simple_string_table:" + "\n"

    # Table header: entry count
    asm_text = asm_text + "    .word {table.count()}           # Entry count" + "\n"
    asm_text = asm_text + "\n"

    # Generate entries
    for entry in table.entries:
        asm_text = asm_text + generate_entry_asm(entry)

    # Table end marker
    asm_text = asm_text + "\n"
    asm_text = asm_text + "__simple_string_table_end:" + "\n"

    # Add size constant
    asm_text = asm_text + "\n"
    asm_text = asm_text + "# Table size: {table.total_size} bytes" + "\n"
    asm_text = asm_text + ".global __simple_string_table_size" + "\n"
    asm_text = asm_text + ".set __simple_string_table_size, {table.total_size}" + "\n"

    asm_text

# Generate assembly for single entry
fn generate_entry_asm(entry: FullStringEntry) -> text:
    var asm_text = ""

    # Comment with entry info
    asm_text = asm_text + "    # Entry {entry.id}: \"{escape_for_comment(entry.text)}\" "
    asm_text = asm_text + "({entry.length} bytes, {entry.param_count} params)" + "\n"

    # Entry header (3 words = 12 bytes)
    asm_text = asm_text + "    .word {entry.id}                # ID" + "\n"
    asm_text = asm_text + "    .word {entry.length}            # Length (with null)" + "\n"
    asm_text = asm_text + "    .word {entry.param_count}       # Parameter count" + "\n"

    # String data (null-terminated)
    asm_text = asm_text + "    .ascii \"{escape_for_asm(entry.text)}\\0\"" + "\n"

    # Alignment padding
    asm_text = asm_text + "    .align 4" + "\n"
    asm_text = asm_text + "\n"

    asm_text

# Escape string for assembly .ascii directive
fn escape_for_asm(s: text) -> text:
    var chars: [text] = []
    var i = 0

    while i < s.len():
        val ch = s[i:i+1]

        if ch == "\n":
            chars = chars.push("\\n")
        elif ch == "\t":
            chars = chars.push("\\t")
        elif ch == "\r":
            chars = chars.push("\\r")
        elif ch == "\"":
            chars = chars.push("\\\"")
        elif ch == "\\":
            chars = chars.push("\\\\")
        else:
            chars = chars.push(ch)

        i = i + 1

    chars.join("")

# Escape string for comments (truncate long strings)
fn escape_for_comment(s: text) -> text:
    val max_len = 40
    var escaped = escape_for_asm(s)

    if escaped.len() > max_len:
        escaped = escaped[0:max_len] + "..."

    escaped

# Generate linker script fragment for .smt section
fn generate_linker_script_fragment() -> text:
    var script = ""

    script = script + "/* String table section */" + "\n"
    script = script + ".smt : {" + "\n"
    script = script + "    . = ALIGN(4);" + "\n"
    script = script + "    __simple_string_table = .;" + "\n"
    script = script + "    *(.smt)" + "\n"
    script = script + "    __simple_string_table_end = .;" + "\n"
    script = script + "    . = ALIGN(4);" + "\n"
    script = script + "} > RAM" + "\n"

    script

# Generate metadata file (for debugging/inspection)
fn generate_metadata_json(table: FullStringTable) -> text:
    var lines: [text] = []

    lines = lines.push("{")
    lines = lines.push("  \"version\": 1,")
    lines = lines.push("  \"format\": \"simple_string_table\",")
    lines = lines.push("  \"entry_count\": {table.count()},")
    lines = lines.push("  \"total_size\": {table.total_size},")
    lines = lines.push("  \"entries\": [")

    var first = true
    for entry in table.entries:
        if not first:
            lines = lines.push(",")
        first = false

        lines = lines.push("    {")
        lines = lines.push("      \"id\": {entry.id},")
        lines = lines.push("      \"text\": \"{escape_for_json(entry.text)}\",")
        lines = lines.push("      \"length\": {entry.length},")
        lines = lines.push("      \"param_count\": {entry.param_count},")
        lines = lines.push("      \"aligned_size\": {entry.aligned_size}")
        lines = lines.push("    }")

    lines = lines.push("  ]")
    lines = lines.push("}")

    lines.join("\n")

# Escape string for JSON
fn escape_for_json(s: text) -> text:
    var chars: [text] = []
    var i = 0

    while i < s.len():
        val ch = s[i:i+1]

        if ch == "\n":
            chars = chars.push("\\n")
        elif ch == "\t":
            chars = chars.push("\\t")
        elif ch == "\r":
            chars = chars.push("\\r")
        elif ch == "\"":
            chars = chars.push("\\\"")
        elif ch == "\\":
            chars = chars.push("\\\\")
        else:
            chars = chars.push(ch)

        i = i + 1

    chars.join("")

# Write assembly to file
fn write_asm_file(asm_text: text, output_path: text) -> bool:
    # Use FFI to write file
    file_write(output_path, asm_text)
    true

# Write metadata to file
fn write_metadata_file(table: FullStringTable, output_path: text) -> bool:
    val json = generate_metadata_json(table)
    file_write(output_path, json)
    true

# Helper: Write text to file
fn file_write(path: text, content: text) -> bool:
    # Import from app.io (Phase 1B.7 - TODO #65 âœ…)
    use app.io.{file_write as io_file_write}
    io_file_write(path, content)
    true

# Test function
fn test_codegen():
    # Parse and build table
    val metadata = parse_smf_file("hello_world.smf")
    val table = build_full_table(metadata)

    # Generate assembly
    val asm_text = generate_smt_section(table)

    print "Generated assembly:"
    print "===================="
    print asm_text
    print ""

    # Generate metadata
    val json = generate_metadata_json(table)
    print "Metadata JSON:"
    print "=============="
    print json

    # Write to files
    write_asm_file(asm_text, "string_table.s")
    write_metadata_file(table, "string_table.json")
