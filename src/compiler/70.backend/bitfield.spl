# Bitfield Compilation
# tier: full
#
# Compiles bitfield type definitions to efficient bit manipulation code.
#
# Syntax:
#   bitfield RegisterName(BackingType):
#       field1: u4         # 4 bits
#       field2: bool       # 1 bit
#       _: u3              # 3 bits reserved/padding
#       field3: MyEnum     # bits inferred from enum size
#
# Features:
# - Automatic bit offset calculation
# - Efficient getter/setter generation
# - Compile-time overflow checking
# - Support for enums (bits inferred)
# - Support for custom types implementing BitLayout

from hir_types import {HirType, SymbolId, HirModule}
from hir_definitions import {HirExpr, HirExprKind}
from lexer import {Span}

export Bitfield, BitfieldField, BitLayout, BitfieldError
export compile_bitfield, validate_bitfield

# Bit representation trait (for custom types in bitfields)
struct BitLayout:
    bit_width: i64          # Number of bits needed
    is_signed: bool         # Whether value is signed
    min_value: i64          # Minimum representable value
    max_value: i64          # Maximum representable value

impl BitLayout:
    # Create BitLayout for unsigned integer
    static fn unsigned(bits: i64) -> BitLayout:
        BitLayout(
            bit_width: bits,
            is_signed: false,
            min_value: 0,
            max_value: (1 << bits) - 1
        )

    # Create BitLayout for signed integer
    static fn signed(bits: i64) -> BitLayout:
        val max = (1 << (bits - 1)) - 1
        val min = -(1 << (bits - 1))
        BitLayout(
            bit_width: bits,
            is_signed: true,
            min_value: min,
            max_value: max
        )

    # Create BitLayout for bool (1 bit)
    static fn bool_repr() -> BitLayout:
        BitLayout(
            bit_width: 1,
            is_signed: false,
            min_value: 0,
            max_value: 1
        )

    # Create BitLayout for enum with N variants
    static fn enum_repr(num_variants: i64) -> BitLayout:
        val bits = bits_needed(num_variants)
        BitLayout(
            bit_width: bits,
            is_signed: false,
            min_value: 0,
            max_value: num_variants - 1
        )

    # Check if a value fits in this representation
    fn fits(value: i64) -> bool:
        value >= self.min_value and value <= self.max_value

    # Get mask for this bit width
    fn mask() -> i64:
        (1 << self.bit_width) - 1

# Calculate bits needed to represent N values
fn bits_needed(n: i64) -> i64:
    if n <= 1:
        return 1
    var bits: i64 = 0
    var value = n - 1
    while value > 0:
        bits = bits + 1
        value = value >> 1
    bits

# Bitfield field definition
struct BitfieldField:
    name: text              # Field name ("_" for reserved/padding)
    type_: HirType          # Field type
    repr: BitLayout           # Bit representation
    bit_offset: i64         # Offset from LSB (computed)
    span: Span

impl BitfieldField:
    fn is_reserved() -> bool:
        self.name == "_"

    fn bit_end() -> i64:
        self.bit_offset + self.repr.bit_width

    # Generate getter mask
    fn getter_mask() -> i64:
        self.repr.mask() << self.bit_offset

    # Generate setter mask (inverted)
    fn setter_mask() -> i64:
        ~self.getter_mask()

# Complete bitfield definition
struct Bitfield:
    name: text              # Type name
    backing_type: HirType   # Backing storage type (u8, u16, u32, u64)
    backing_bits: i64       # Total bits in backing type
    fields: [BitfieldField] # Fields in declaration order
    span: Span

impl Bitfield:
    # Get total bits used by fields
    fn used_bits() -> i64:
        var total: i64 = 0
        for field in self.fields:
            total = total + field.repr.bit_width
        total

    # Get unused bits (padding)
    fn unused_bits() -> i64:
        self.backing_bits - self.used_bits()

    # Check if bitfield is valid (no overflow)
    fn is_valid() -> bool:
        self.used_bits() <= self.backing_bits

    # Get field by name
    fn get_field(name: text) -> BitfieldField?:
        for field in self.fields:
            if field.name == name:
                return Some(field)
        nil

# Bitfield compilation error
enum BitfieldError:
    OverflowError(bitfield: text, used: i64, available: i64, span: Span)
    InvalidBackingType(type_name: text, span: Span)
    UnknownFieldType(field: text, type_name: text, span: Span)
    DuplicateField(field: text, span: Span)
    InvalidBitWidth(field: text, width: i64, span: Span)

impl BitfieldError:
    fn message() -> text:
        match self:
            case BitfieldError.OverflowError(bf, used, avail, _):
                "bitfield '{bf}' uses {used} bits but backing type only has {avail}"
            case BitfieldError.InvalidBackingType(t, _):
                "invalid backing type '{t}', must be u8, u16, u32, or u64"
            case BitfieldError.UnknownFieldType(f, t, _):
                "field '{f}' has unknown type '{t}' with no BitLayout"
            case BitfieldError.DuplicateField(f, _):
                "duplicate field name '{f}' in bitfield"
            case BitfieldError.InvalidBitWidth(f, w, _):
                "invalid bit width {w} for field '{f}'"

    fn span() -> Span:
        match self:
            case BitfieldError.OverflowError(_, _, _, s): s
            case BitfieldError.InvalidBackingType(_, s): s
            case BitfieldError.UnknownFieldType(_, _, s): s
            case BitfieldError.DuplicateField(_, s): s
            case BitfieldError.InvalidBitWidth(_, _, s): s

# Get bit width for a type
fn type_bit_width(type_: HirType) -> BitLayout?:
    val name = type_.to_text()

    # Check for explicit bit-width types (u4, i12, etc.)
    if name.starts_with("u") or name.starts_with("i"):
        val rest = name.substring(1)
        val width = rest.parse_int()
        if width.?:
            val w = width.unwrap()
            if w > 0 and w <= 64:
                if name.starts_with("i"):
                    return Some(BitLayout.signed(w))
                else:
                    return Some(BitLayout.unsigned(w))

    # Standard types
    match name:
        case "bool": Some(BitLayout.bool_repr())
        case "u8": Some(BitLayout.unsigned(8))
        case "u16": Some(BitLayout.unsigned(16))
        case "u32": Some(BitLayout.unsigned(32))
        case "u64": Some(BitLayout.unsigned(64))
        case "i8": Some(BitLayout.signed(8))
        case "i16": Some(BitLayout.signed(16))
        case "i32": Some(BitLayout.signed(32))
        case "i64": Some(BitLayout.signed(64))
        case _: nil

# Get backing type bit width
fn backing_type_bits(type_: HirType) -> i64?:
    val name = type_.to_text()
    match name:
        case "u8": Some(8)
        case "u16": Some(16)
        case "u32": Some(32)
        case "u64": Some(64)
        case _: nil

# Compile a bitfield definition
fn compile_bitfield(
    name: text,
    backing_type: HirType,
    fields: [(text, HirType, Span)],
    span: Span
) -> Result<Bitfield, BitfieldError>:
    # Validate backing type
    val bits = backing_type_bits(backing_type)
    if not bits.?:
        return Err(BitfieldError.InvalidBackingType(backing_type.to_text(), span))

    val backing_bits = bits.unwrap()
    var compiled_fields: [BitfieldField] = []
    var current_offset: i64 = 0
    var seen_names: Dict<text, bool> = {}

    # Process fields
    for (field_name, field_type, field_span) in fields:
        # Check for duplicates (except reserved "_")
        if field_name != "_":
            if seen_names.contains_key(field_name):
                return Err(BitfieldError.DuplicateField(field_name, field_span))
            seen_names[field_name] = true

        # Get bit representation
        val repr = type_bit_width(field_type)
        if not repr.?:
            return Err(BitfieldError.UnknownFieldType(field_name, field_type.to_text(), field_span))

        val field_repr = repr.unwrap()

        # Validate bit width
        if field_repr.bit_width <= 0 or field_repr.bit_width > 64:
            return Err(BitfieldError.InvalidBitWidth(field_name, field_repr.bit_width, field_span))

        compiled_fields.push(BitfieldField(
            name: field_name,
            type_: field_type,
            repr: field_repr,
            bit_offset: current_offset,
            span: field_span
        ))

        current_offset = current_offset + field_repr.bit_width

    # Check for overflow
    if current_offset > backing_bits:
        return Err(BitfieldError.OverflowError(name, current_offset, backing_bits, span))

    Ok(Bitfield(
        name: name,
        backing_type: backing_type,
        backing_bits: backing_bits,
        fields: compiled_fields,
        span: span
    ))

# Validate a compiled bitfield
fn validate_bitfield(bitfield: Bitfield) -> Result<(), BitfieldError>:
    if not bitfield.is_valid():
        return Err(BitfieldError.OverflowError(
            bitfield.name,
            bitfield.used_bits(),
            bitfield.backing_bits,
            bitfield.span
        ))
    Ok(())

# Generate getter expression for a field
fn generate_getter(bitfield: Bitfield, field_name: text, value_expr: text) -> text?:
    val field = bitfield.get_field(field_name)
    if not field.?:
        return nil

    val f = field.unwrap()
    val mask = f.repr.mask()
    val shift = f.bit_offset

    # (value >> shift) & mask
    if shift == 0:
        Some("({value_expr} & {mask})")
    else:
        Some("(({value_expr} >> {shift}) & {mask})")

# Generate setter expression for a field
fn generate_setter(bitfield: Bitfield, field_name: text, value_expr: text, new_value: text) -> text?:
    val field = bitfield.get_field(field_name)
    if not field.?:
        return nil

    val f = field.unwrap()
    val mask = f.repr.mask()
    val shift = f.bit_offset
    val clear_mask = ~(mask << shift)

    # (value & clear_mask) | ((new_value & mask) << shift)
    if shift == 0:
        Some("(({value_expr} & {clear_mask}) | ({new_value} & {mask}))")
    else:
        Some("(({value_expr} & {clear_mask}) | (({new_value} & {mask}) << {shift}))")
