"""
# Native Execution FFI Bridge

Provides FFI interface for compiling Simple code to native executables
using LLVM backend and executing them.

**Status:** Implementation Complete
**Phase:** Testing & Verification
"""

# FFI declarations for native compilation
extern fn rt_compile_to_native(source_path: text, output_path: text) -> (bool, text)
extern fn rt_execute_native(binary_path: text, args: List<text>, timeout_ms: i64) -> (text, text, i32)
extern fn rt_file_delete(path: text) -> bool

# Native compilation result
class NativeCompileResult:
    success: bool
    binary_path: text
    error_message: text
    compile_time_ms: i64

impl NativeCompileResult:
    fn is_ok() -> bool:
        self.success

    static fn success_result(binary_path: text, compile_time_ms: i64) -> NativeCompileResult:
        NativeCompileResult(
            success: true,
            binary_path: binary_path,
            error_message: "",
            compile_time_ms: compile_time_ms
        )

    static fn error_result(error: text) -> NativeCompileResult:
        NativeCompileResult(
            success: false,
            binary_path: "",
            error_message: error,
            compile_time_ms: 0
        )

# Native execution result
class NativeExecutionResult:
    stdout: text
    stderr: text
    exit_code: i32
    execution_time_ms: i64

impl NativeExecutionResult:
    fn is_success() -> bool:
        self.exit_code == 0

# Compile Simple source to native executable
fn compile_to_native(source_path: text, output_path: text) -> NativeCompileResult:
    """
    Compiles a Simple source file to a native executable using LLVM backend.

    Args:
        source_path: Path to .spl source file
        output_path: Path for output binary

    Returns:
        NativeCompileResult with success status and binary path or error
    """
    extern fn rt_time_now_unix_micros() -> i64

    val start = rt_time_now_unix_micros()
    val (success, error) = rt_compile_to_native(source_path, output_path)
    val end = rt_time_now_unix_micros()
    val compile_time_ms = (end - start) / 1000

    if success:
        NativeCompileResult.success_result(output_path, compile_time_ms)
    else:
        NativeCompileResult.error_result(error)

# Execute native binary
fn execute_native(binary_path: text, args: List<text>, timeout_ms: i64) -> NativeExecutionResult:
    """
    Executes a native binary with given arguments and timeout.

    Args:
        binary_path: Path to compiled binary
        args: Command-line arguments
        timeout_ms: Timeout in milliseconds

    Returns:
        NativeExecutionResult with stdout, stderr, exit code, and timing
    """
    extern fn rt_time_now_unix_micros() -> i64

    val start = rt_time_now_unix_micros()
    val (stdout, stderr, exit_code) = rt_execute_native(binary_path, args, timeout_ms)
    val end = rt_time_now_unix_micros()
    val execution_time_ms = (end - start) / 1000

    NativeExecutionResult(
        stdout: stdout,
        stderr: stderr,
        exit_code: exit_code,
        execution_time_ms: execution_time_ms
    )

# Clean up temporary native binary
fn cleanup_native_binary(binary_path: text):
    """Deletes a temporary compiled binary."""
    rt_file_delete(binary_path)

# Check if native compilation is available
fn is_native_available() -> bool:
    """
    Checks if LLVM backend is available for native compilation.
    Returns true if native compilation is supported.
    """
    # Try a simple compilation test
    val test_result = rt_compile_to_native("", "")
    # If FFI is not available, this will return (false, "not implemented")
    not test_result.1.contains("not implemented")

export NativeCompileResult, NativeExecutionResult
export compile_to_native, execute_native, cleanup_native_binary
export is_native_available
