# Interpreter Backend - Tree-walking interpreter
#
# This module implements the tree-walking interpreter backend
# that directly executes HIR expressions and statements.

use compiler.hir.*
use compiler.lexer.Span
use backend_types.*
use backend.env.{EvalContext, Environment}
use compiler.ffi_minimal as ffi  # FFI wrappers for RuntimeValue
use ffi.debug.{debug_is_active, debug_should_break, debug_wait_for_continue, debug_set_current_location}

# ============================================================================
# Interpreter Mode Configuration
# ============================================================================

enum InterpreterMode:
    Classic       # Interpreter-like: GC, debug hooks, FFI arithmetic
    Optimized     # Compiler-like: no GC, direct computation, no barriers

struct InterpreterConfig:
    mode: InterpreterMode
    enable_debug_hooks: bool
    enable_gc: bool
    use_ffi_arithmetic: bool

impl InterpreterConfig:
    static fn classic() -> InterpreterConfig:
        InterpreterConfig(mode: InterpreterMode.Classic, enable_debug_hooks: true,
            enable_gc: true, use_ffi_arithmetic: true)

    static fn optimized() -> InterpreterConfig:
        InterpreterConfig(mode: InterpreterMode.Optimized, enable_debug_hooks: false,
            enable_gc: false, use_ffi_arithmetic: false)

    me with_gc(enabled: bool) -> InterpreterConfig:
        self.enable_gc = enabled
        self

    me with_debug(enabled: bool) -> InterpreterConfig:
        self.enable_debug_hooks = enabled
        self

# ============================================================================
# Interpreter Backend Implementation
# ============================================================================

struct InterpreterBackendImpl:
    """Tree-walking interpreter backend."""
    config: InterpreterConfig

impl InterpreterBackendImpl:
    static fn new() -> InterpreterBackendImpl:
        InterpreterBackendImpl(config: InterpreterConfig.classic())

    static fn with_config(config: InterpreterConfig) -> InterpreterBackendImpl:
        InterpreterBackendImpl(config: config)

    static fn optimized() -> InterpreterBackendImpl:
        InterpreterBackendImpl(config: InterpreterConfig.optimized())

impl Backend for InterpreterBackendImpl:
    fn name() -> text:
        "interpreter"

    fn kind() -> BackendKind:
        BackendKind.Interpreter

    fn process_module(module: HirModule) -> Result<BackendResult, BackendError>:
        # Initialize GC for RuntimeValue FFI operations (only in classic mode)
        if self.config.enable_gc:
            ffi.gc_init()

        # Create evaluation context
        val env = Environment.new()
        val ctx = EvalContext(env: env, module: module, backend: self)

        # Iterate functions using .keys() which returns original key objects
        var main_fn: HirFunction? = nil
        for symbol in module.functions.keys():
            val fn_ = module.functions[symbol]
            ctx.env.define_global(symbol, Value.Function(FunctionValue(symbol: symbol, name: fn_.name)))
            if fn_.name == "main":
                main_fn = Some(fn_)

        # Also register builtins from symbol table
        for sym_id in module.symbols.symbols.keys():
            val sym = module.symbols.symbols[sym_id]
            ctx.env.define_global(sym.id, Value.Function(FunctionValue(symbol: sym.id, name: sym.name)))

        if main_fn.?:
            val result = self.call_hir_function(main_fn.unwrap(), [], ctx)?
            Ok(BackendResult.Value(result))
        else:
            Ok(BackendResult.Unit)

    fn process_function(fn_: HirFunction) -> Result<BackendResult, BackendError>:
        Ok(BackendResult.Unit)

    fn process_class(class_: HirClass) -> Result<BackendResult, BackendError>:
        Ok(BackendResult.Unit)

    fn process_struct(struct_: HirStruct) -> Result<BackendResult, BackendError>:
        Ok(BackendResult.Unit)

    fn process_enum(enum_: HirEnum) -> Result<BackendResult, BackendError>:
        Ok(BackendResult.Unit)

    fn process_trait(trait_: HirTrait) -> Result<BackendResult, BackendError>:
        Ok(BackendResult.Unit)

    fn process_impl(impl_: HirImpl) -> Result<BackendResult, BackendError>:
        Ok(BackendResult.Unit)

    fn eval_expr(expr: HirExpr, ctx: EvalContext) -> Result<Value, BackendError>:
        # Debug hooks for DAP integration (only in classic mode)
        if self.config.enable_debug_hooks and debug_is_active():
            val span = expr.span
            debug_set_current_location(span.file, span.line as i64, span.column as i64)
            if debug_should_break():
                debug_wait_for_continue()

        match expr.kind:
            case IntLit(value, _):
                Ok(Value.int(value))

            case FloatLit(value, _):
                Ok(Value.float(value))

            case StringLit(value, _):
                Ok(Value.string(value))

            case BoolLit(value):
                Ok(Value.bool(value))

            case NilLit:
                Ok(Value.make_nil())

            case UnitLit:
                Ok(Value.make_nil())

            case Var(symbol):
                val value = ctx.env.lookup(symbol)
                if value.?:
                    Ok(value.unwrap())
                else:
                    Err(BackendError.runtime_error("undefined variable", Some(expr.span)))

            case ArrayLit(elements, _):
                var values: [Value] = []
                for elem in elements:
                    val v = self.eval_expr(elem, ctx)?
                    values = values.push(v)
                Ok(Value.Array(values))

            case TupleLit(elements):
                var values: [Value] = []
                for elem in elements:
                    val v = self.eval_expr(elem, ctx)?
                    values = values.push(v)
                Ok(Value.Tuple(values))

            case DictLit(entries, _, _):
                var dict: Dict<text, Value> = {}
                for (key_expr, value_expr) in entries:
                    val key = self.eval_expr(key_expr, ctx)?
                    val value = self.eval_expr(value_expr, ctx)?
                    match key:
                        case String(k):
                            dict[k] = value
                        case _:
                            return Err(BackendError.type_error("dict key must be string", Some(expr.span)))
                Ok(Value.Dict(dict))

            case Binary(op, left, right):
                val lv = self.eval_expr(left, ctx)?
                val rv = self.eval_expr(right, ctx)?
                self.eval_binop(op, lv, rv, expr.span)

            case Unary(op, operand):
                val v = self.eval_expr(operand, ctx)?
                self.eval_unaryop(op, v, expr.span)

            case If(cond, then_, else_):
                val cv = self.eval_expr(cond, ctx)?
                if cv.is_truthy():
                    self.eval_block(then_, ctx)
                elif else_.?:
                    self.eval_block(else_.unwrap(), ctx)
                else:
                    Ok(Value.make_nil())

            case Call(callee, args, _):
                val fn_value = self.eval_expr(callee, ctx)?
                var arg_values: [Value] = []
                for arg in args:
                    val v = self.eval_expr(arg.value, ctx)?
                    arg_values = arg_values.push(v)
                self.call_function(fn_value, arg_values, ctx, expr.span)

            case MethodCall(receiver, method_name, args, resolution):
                match resolution:
                    case StaticMethod(_, method_id):
                        # Static method: ClassName.method(args) - no receiver needed
                        var arg_values: [Value] = []
                        for arg in args:
                            val v = self.eval_expr(arg.value, ctx)?
                            arg_values = arg_values.push(v)

                        # Look up method by symbol ID
                        self.call_function_by_id(method_id, arg_values, ctx, expr.span)

                    case InstanceMethod(_, method_id):
                        # Instance method: receiver.method(args)
                        val receiver_val = self.eval_expr(receiver, ctx)?

                        var arg_values: [Value] = []
                        arg_values = arg_values.push(receiver_val)  # Receiver as first arg
                        for arg in args:
                            val v = self.eval_expr(arg.value, ctx)?
                            arg_values = arg_values.push(v)

                        self.call_function_by_id(method_id, arg_values, ctx, expr.span)

                    case FreeFunction(func_id):
                        # UFCS: receiver.func(args) â†’ func(receiver, args)
                        val receiver_val = self.eval_expr(receiver, ctx)?

                        var arg_values: [Value] = []
                        arg_values = arg_values.push(receiver_val)
                        for arg in args:
                            val v = self.eval_expr(arg.value, ctx)?
                            arg_values = arg_values.push(v)

                        self.call_function_by_id(func_id, arg_values, ctx, expr.span)

                    case TraitMethod(_, _):
                        # Trait method - requires dynamic dispatch (not implemented yet)
                        Err(BackendError.not_implemented("trait method calls not yet supported"))

                    case Unresolved:
                        Err(BackendError.runtime_error("unresolved method call: {method_name}", Some(expr.span)))

            case StaticCall(type_, method_name, args, resolution):
                # Static call: Type.method(args) - similar to StaticMethod variant
                match resolution:
                    case StaticMethod(_, method_id):
                        var arg_values: [Value] = []
                        for arg in args:
                            val v = self.eval_expr(arg.value, ctx)?
                            arg_values = arg_values.push(v)

                        self.call_function_by_id(method_id, arg_values, ctx, expr.span)

                    case _:
                        Err(BackendError.runtime_error("invalid static call resolution", Some(expr.span)))

            case Lambda(params, body, _):
                # Capture free variables from current scope
                var captures: Dict<SymbolId, Value> = {}
                val free_vars = body.free_variables()
                for var_id in free_vars:
                    val value = ctx.lookup(var_id)
                    if value.?:
                        captures[var_id] = value.unwrap()
                Ok(Value.Closure(ClosureValue(
                    params: params,
                    body: body,
                    captures: captures
                )))

            case Block(block):
                self.eval_block(block, ctx)

            case _:
                Err(BackendError.not_implemented("expression kind not implemented"))

    fn exec_stmt(stmt: HirStmt, ctx: EvalContext) -> Result<(), BackendError>:
        match stmt.kind:
            case Expr(expr):
                self.eval_expr(expr, ctx)?
                Ok(())

            case Let(symbol, _, init):
                val value = self.eval_expr(init, ctx)?
                ctx.env.define(symbol, value)
                Ok(())

            case Assign(target, op, value):
                val new_value = self.eval_expr(value, ctx)?
                match target.kind:
                    case Var(symbol):
                        if op.?:
                            val old_value = ctx.env.lookup(symbol)
                            if old_value.is_none():
                                return Err(BackendError.runtime_error("undefined variable", Some(stmt.span)))
                            val combined = self.apply_assign_op(op.unwrap(), old_value.unwrap(), new_value, stmt.span)?
                            ctx.env.assign(symbol, combined)
                        else:
                            ctx.env.assign(symbol, new_value)
                        Ok(())
                    case _:
                        Err(BackendError.not_implemented("assignment target not implemented"))

            case Block(block):
                self.eval_block(block, ctx)?
                Ok(())

    fn is_allowed(expr: HirExpr) -> bool:
        # Interpreter allows all expressions
        true

    fn is_allowed_stmt(stmt: HirStmt) -> bool:
        # Interpreter allows all statements
        true

impl InterpreterBackendImpl:
    fn eval_block(block: HirBlock, ctx: EvalContext) -> Result<Value, BackendError>:
        ctx.env.push_scope()

        for stmt in block.stmts:
            self.exec_stmt(stmt, ctx)?

        val result = if block.value.?:
            self.eval_expr(block.value.unwrap(), ctx)?
        else:
            Value.make_nil()

        ctx.env.pop_scope()
        Ok(result)

    # Helper functions for comparison operators
    fn eval_gt(left: Value, right: Value, span: Span) -> Result<Value, BackendError>:
        match (left, right):
            case (Int(l), Int(r)):
                if self.config.use_ffi_arithmetic:
                    val left_ptr = self.value_to_runtime_ptr(left)
                    val right_ptr = self.value_to_runtime_ptr(right)
                    val result = ffi.value_lt(right_ptr, left_ptr)
                    Ok(Value.bool(result))
                else:
                    Ok(Value.bool(l > r))
            case (Float(l), Float(r)):
                if self.config.use_ffi_arithmetic:
                    val left_ptr = self.value_to_runtime_ptr(left)
                    val right_ptr = self.value_to_runtime_ptr(right)
                    val result = ffi.value_lt(right_ptr, left_ptr)
                    Ok(Value.bool(result))
                else:
                    Ok(Value.bool(l > r))
            case _:
                Err(BackendError.type_error("invalid operands for >", Some(span)))

    fn eval_gteq(left: Value, right: Value, span: Span) -> Result<Value, BackendError>:
        match (left, right):
            case (Int(l), Int(r)):
                if self.config.use_ffi_arithmetic:
                    val left_ptr = self.value_to_runtime_ptr(left)
                    val right_ptr = self.value_to_runtime_ptr(right)
                    val result = ffi.value_lt(left_ptr, right_ptr)
                    Ok(Value.bool(not result))
                else:
                    Ok(Value.bool(l >= r))
            case (Float(l), Float(r)):
                if self.config.use_ffi_arithmetic:
                    val left_ptr = self.value_to_runtime_ptr(left)
                    val right_ptr = self.value_to_runtime_ptr(right)
                    val result = ffi.value_lt(left_ptr, right_ptr)
                    Ok(Value.bool(not result))
                else:
                    Ok(Value.bool(l >= r))
            case _:
                Err(BackendError.type_error("invalid operands for >=", Some(span)))

    fn eval_binop(op: HirBinOp, left: Value, right: Value, span: Span) -> Result<Value, BackendError>:
        match op:
            case Add:
                match (left, right):
                    case (Int(l), Int(r)):
                        if self.config.use_ffi_arithmetic:
                            val left_ptr = self.value_to_runtime_ptr(left)
                            val right_ptr = self.value_to_runtime_ptr(right)
                            val result_ptr = ffi.value_add(left_ptr, right_ptr)
                            Ok(self.runtime_ptr_to_value(result_ptr))
                        else:
                            Ok(Value.int(l + r))
                    case (Float(l), Float(r)):
                        if self.config.use_ffi_arithmetic:
                            val left_ptr = self.value_to_runtime_ptr(left)
                            val right_ptr = self.value_to_runtime_ptr(right)
                            val result_ptr = ffi.value_add(left_ptr, right_ptr)
                            Ok(self.runtime_ptr_to_value(result_ptr))
                        else:
                            Ok(Value.float(l + r))
                    case (Int(l), Float(r)): Ok(Value.float(l.to_f64() + r))
                    case (Float(l), Int(r)): Ok(Value.float(l + r.to_f64()))
                    case (String(l), String(r)): Ok(Value.string(l + r))
                    case _: Err(BackendError.type_error("invalid operands for +", Some(span)))

            case Sub:
                match (left, right):
                    case (Int(l), Int(r)):
                        if self.config.use_ffi_arithmetic:
                            val left_ptr = self.value_to_runtime_ptr(left)
                            val right_ptr = self.value_to_runtime_ptr(right)
                            val result_ptr = ffi.value_sub(left_ptr, right_ptr)
                            Ok(self.runtime_ptr_to_value(result_ptr))
                        else:
                            Ok(Value.int(l - r))
                    case (Float(l), Float(r)):
                        if self.config.use_ffi_arithmetic:
                            val left_ptr = self.value_to_runtime_ptr(left)
                            val right_ptr = self.value_to_runtime_ptr(right)
                            val result_ptr = ffi.value_sub(left_ptr, right_ptr)
                            Ok(self.runtime_ptr_to_value(result_ptr))
                        else:
                            Ok(Value.float(l - r))
                    case _: Err(BackendError.type_error("invalid operands for -", Some(span)))

            case Mul:
                match (left, right):
                    case (Int(l), Int(r)):
                        if self.config.use_ffi_arithmetic:
                            val left_ptr = self.value_to_runtime_ptr(left)
                            val right_ptr = self.value_to_runtime_ptr(right)
                            val result_ptr = ffi.value_mul(left_ptr, right_ptr)
                            Ok(self.runtime_ptr_to_value(result_ptr))
                        else:
                            Ok(Value.int(l * r))
                    case (Float(l), Float(r)):
                        if self.config.use_ffi_arithmetic:
                            val left_ptr = self.value_to_runtime_ptr(left)
                            val right_ptr = self.value_to_runtime_ptr(right)
                            val result_ptr = ffi.value_mul(left_ptr, right_ptr)
                            Ok(self.runtime_ptr_to_value(result_ptr))
                        else:
                            Ok(Value.float(l * r))
                    case _: Err(BackendError.type_error("invalid operands for *", Some(span)))

            case Div:
                match (left, right):
                    case (Int(l), Int(r)):
                        if r == 0:
                            Err(BackendError.runtime_error("division by zero", Some(span)))
                        else:
                            if self.config.use_ffi_arithmetic:
                                val left_ptr = self.value_to_runtime_ptr(left)
                                val right_ptr = self.value_to_runtime_ptr(right)
                                val result_ptr = ffi.value_div(left_ptr, right_ptr)
                                Ok(self.runtime_ptr_to_value(result_ptr))
                            else:
                                Ok(Value.int(l / r))
                    case (Float(l), Float(r)):
                        if self.config.use_ffi_arithmetic:
                            val left_ptr = self.value_to_runtime_ptr(left)
                            val right_ptr = self.value_to_runtime_ptr(right)
                            val result_ptr = ffi.value_div(left_ptr, right_ptr)
                            Ok(self.runtime_ptr_to_value(result_ptr))
                        else:
                            Ok(Value.float(l / r))
                    case _: Err(BackendError.type_error("invalid operands for /", Some(span)))

            case Mod:
                match (left, right):
                    case (Int(l), Int(r)):
                        if r == 0:
                            Err(BackendError.runtime_error("modulo by zero", Some(span)))
                        else:
                            Ok(Value.int(l % r))
                    case _: Err(BackendError.type_error("invalid operands for %", Some(span)))

            case Eq:
                # Use FFI for equality comparison (Phase 3)
                match (left, right):
                    case (Int(l), Int(r)):
                        if self.config.use_ffi_arithmetic:
                            val left_ptr = self.value_to_runtime_ptr(left)
                            val right_ptr = self.value_to_runtime_ptr(right)
                            val result = ffi.value_eq(left_ptr, right_ptr)
                            Ok(Value.bool(result))
                        else:
                            Ok(Value.bool(l == r))
                    case (Float(l), Float(r)):
                        if self.config.use_ffi_arithmetic:
                            val left_ptr = self.value_to_runtime_ptr(left)
                            val right_ptr = self.value_to_runtime_ptr(right)
                            val result = ffi.value_eq(left_ptr, right_ptr)
                            Ok(Value.bool(result))
                        else:
                            Ok(Value.bool(l == r))
                    case _:
                        # Fallback to Simple comparison for complex types
                        Ok(Value.bool(self.values_equal(left, right)))

            case NotEq:
                # Use FFI for inequality
                match (left, right):
                    case (Int(l), Int(r)):
                        if self.config.use_ffi_arithmetic:
                            val left_ptr = self.value_to_runtime_ptr(left)
                            val right_ptr = self.value_to_runtime_ptr(right)
                            val result = ffi.value_eq(left_ptr, right_ptr)
                            Ok(Value.bool(not result))
                        else:
                            Ok(Value.bool(l != r))
                    case (Float(l), Float(r)):
                        if self.config.use_ffi_arithmetic:
                            val left_ptr = self.value_to_runtime_ptr(left)
                            val right_ptr = self.value_to_runtime_ptr(right)
                            val result = ffi.value_eq(left_ptr, right_ptr)
                            Ok(Value.bool(not result))
                        else:
                            Ok(Value.bool(l != r))
                    case _:
                        Ok(Value.bool(not self.values_equal(left, right)))

            case Lt:
                match (left, right):
                    case (Int(l), Int(r)):
                        if self.config.use_ffi_arithmetic:
                            val left_ptr = self.value_to_runtime_ptr(left)
                            val right_ptr = self.value_to_runtime_ptr(right)
                            val result = ffi.value_lt(left_ptr, right_ptr)
                            Ok(Value.bool(result))
                        else:
                            Ok(Value.bool(l < r))
                    case (Float(l), Float(r)):
                        if self.config.use_ffi_arithmetic:
                            val left_ptr = self.value_to_runtime_ptr(left)
                            val right_ptr = self.value_to_runtime_ptr(right)
                            val result = ffi.value_lt(left_ptr, right_ptr)
                            Ok(Value.bool(result))
                        else:
                            Ok(Value.bool(l < r))
                    case (String(l), String(r)): Ok(Value.bool(l < r))
                    case _: Err(BackendError.type_error("invalid operands for <", Some(span)))

            case LtEq:
                match (left, right):
                    case (Int(l), Int(r)):
                        if self.config.use_ffi_arithmetic:
                            val left_ptr = self.value_to_runtime_ptr(left)
                            val right_ptr = self.value_to_runtime_ptr(right)
                            val result = ffi.value_lt(right_ptr, left_ptr)  # b < a
                            Ok(Value.bool(not result))
                        else:
                            Ok(Value.bool(l <= r))
                    case (Float(l), Float(r)):
                        if self.config.use_ffi_arithmetic:
                            val left_ptr = self.value_to_runtime_ptr(left)
                            val right_ptr = self.value_to_runtime_ptr(right)
                            val result = ffi.value_lt(right_ptr, left_ptr)  # b < a
                            Ok(Value.bool(not result))
                        else:
                            Ok(Value.bool(l <= r))
                    case _: Err(BackendError.type_error("invalid operands for <=", Some(span)))

            case Gt:
                self.eval_gt(left, right, span)
            case GtEq:
                self.eval_gteq(left, right, span)

            case And:
                Ok(Value.bool(left.is_truthy() and right.is_truthy()))

            case Or:
                Ok(Value.bool(left.is_truthy() or right.is_truthy()))

            case _:
                Err(BackendError.not_implemented("binary operator not implemented"))

    fn eval_unaryop(op: HirUnaryOp, operand: Value, span: Span) -> Result<Value, BackendError>:
        match op:
            case Neg:
                match operand:
                    case Int(i): Ok(Value.int(-i))
                    case Float(f): Ok(Value.float(-f))
                    case _: Err(BackendError.type_error("invalid operand for -", Some(span)))

            case Not:
                Ok(Value.bool(not operand.is_truthy()))

            case _:
                Err(BackendError.not_implemented("unary operator not implemented"))

    fn values_equal(left: Value, right: Value) -> bool:
        match (left, right):
            case (Nil, Nil): true
            case (Bool(l), Bool(r)): l == r
            case (Int(l), Int(r)): l == r
            case (Float(l), Float(r)): l == r
            case (String(l), String(r)): l == r
            case _: false

    fn call_function(fn_value: Value, args: [Value], ctx: EvalContext, span: Span) -> Result<Value, BackendError>:
        match fn_value:
            case Function(f):
                # Check for builtin functions first
                val builtin_result = self.try_call_builtin(f.name, args)
                if builtin_result.?:
                    return builtin_result.unwrap()

                # Look up function in module
                if not ctx.module.functions.contains_key(f.symbol):
                    return Err(BackendError.runtime_error("function '{f.name}' not found", Some(span)))

                val fn_ = ctx.module.functions[f.symbol]
                self.call_hir_function(fn_, args, ctx)

            case Closure(c):
                self.call_closure(c, args, ctx)

            case _:
                Err(BackendError.type_error("value is not callable", Some(span)))

    fn call_hir_function(fn_: HirFunction, args: [Value], ctx: EvalContext) -> Result<Value, BackendError>:
        ctx.env.push_scope()

        # Bind parameters
        for i in 0..fn_.params.len():
            val param = fn_.params[i]
            val value = if i < args.len():
                args[i]
            elif param.default.?:
                self.eval_expr(param.default.unwrap(), ctx)?
            else:
                return Err(BackendError.runtime_error("missing argument for parameter {param.name}", Some(fn_.span)))

            ctx.env.define(param.symbol, value)

        # Execute body
        val result = self.eval_block(fn_.body, ctx)?

        ctx.env.pop_scope()
        Ok(result)

    fn call_function_by_id(method_id: SymbolId, args: [Value], ctx: EvalContext, span: Span) -> Result<Value, BackendError>:
        """Look up function by symbol ID and call it."""
        # Look up function definition in module
        if not ctx.module.functions.contains_key(method_id):
            return Err(BackendError.runtime_error("function not found by symbol ID", Some(span)))

        val fn_ = ctx.module.functions[method_id]
        self.call_hir_function(fn_, args, ctx)

    fn call_closure(closure: ClosureValue, args: [Value], ctx: EvalContext) -> Result<Value, BackendError>:
        ctx.env.push_scope()

        # Bind captured variables
        for symbol in closure.captures.keys():
            val value = closure.captures[symbol]
            ctx.env.define(symbol, value)

        # Bind parameters
        for i in 0..closure.params.len():
            val param = closure.params[i]
            val value = if i < args.len():
                args[i]
            else:
                return Err(BackendError.runtime_error("missing argument for parameter", nil))

            ctx.env.define(param.symbol, value)

        # Evaluate body
        val result = self.eval_expr(closure.body, ctx)?

        ctx.env.pop_scope()
        Ok(result)

    fn apply_assign_op(op: HirAssignOp, left: Value, right: Value, span: Span) -> Result<Value, BackendError>:
        match op:
            case Add: self.eval_binop(HirBinOp.Add, left, right, span)
            case Sub: self.eval_binop(HirBinOp.Sub, left, right, span)
            case Mul: self.eval_binop(HirBinOp.Mul, left, right, span)
            case Div: self.eval_binop(HirBinOp.Div, left, right, span)
            case Mod: self.eval_binop(HirBinOp.Mod, left, right, span)
            case _: Err(BackendError.not_implemented("assignment operator not implemented"))

    fn try_call_builtin(name: text, args: [Value]) -> Option<Result<Value, BackendError>>:
        """Try to call a builtin function. Returns None if not a builtin."""
        match name:
            case "print":
                if args.len() > 0:
                    # Try FFI printing for RuntimeValue types
                    val arg = args[0]
                    match arg:
                        case RuntimeValue(ptr):
                            ffi.value_print(ptr)
                        case Int(_), Float(_), Bool(_), Nil:
                            # Use FFI for primitive types
                            val ptr = self.value_to_runtime_ptr(arg)
                            ffi.value_print(ptr)
                        case _:
                            # Fallback to Simple printing for complex types
                            val msg = self.value_to_string(arg)
                            print msg
                else:
                    print ""
                Some(Ok(Value.Unit))
            case "println":
                if args.len() > 0:
                    # Try FFI printing for RuntimeValue types
                    val arg = args[0]
                    match arg:
                        case RuntimeValue(ptr):
                            ffi.value_println(ptr)
                        case Int(_), Float(_), Bool(_), Nil:
                            # Use FFI for primitive types
                            val ptr = self.value_to_runtime_ptr(arg)
                            ffi.value_println(ptr)
                        case _:
                            # Fallback to Simple printing for complex types
                            val msg = self.value_to_string(arg)
                            print msg
                else:
                    print ""
                Some(Ok(Value.Unit))
            case "to_string":
                if args.len() > 0:
                    Some(Ok(Value.string(self.value_to_string(args[0]))))
                else:
                    Some(Ok(Value.string("")))

            case "type_of":
                if args.len() > 0:
                    val arg = args[0]
                    match arg:
                        case RuntimeValue(ptr):
                            # Use FFI to get runtime type
                            val type_tag = ffi.value_type(ptr)
                            val type_name = match type_tag:
                                case ValueType.Nil: "nil"
                                case ValueType.Bool: "bool"
                                case ValueType.Int: "int"
                                case ValueType.Float: "float"
                                case ValueType.String: "string"
                                case ValueType.Array: "array"
                                case ValueType.Dict: "dict"
                                case ValueType.Object: "object"
                                case ValueType.Function: "function"
                                case _: "unknown"
                            Some(Ok(Value.string(type_name)))
                        case _:
                            # Use Simple type_name() method
                            Some(Ok(Value.string(arg.type_name())))
                else:
                    Some(Err(BackendError.runtime_error("type_of requires value argument", nil)))

            case "clone":
                if args.len() > 0:
                    val arg = args[0]
                    match arg:
                        case RuntimeValue(ptr):
                            # Use FFI to clone RuntimeValue
                            val cloned_ptr = ffi.value_clone(ptr)
                            Some(Ok(Value.RuntimeValue(cloned_ptr)))
                        case _:
                            # For Simple values, just return the value (they're immutable)
                            Some(Ok(arg))
                else:
                    Some(Err(BackendError.runtime_error("clone requires value argument", nil)))

            # Memory management operations (Phase 6)
            case "gc_collect":
                if self.config.enable_gc:
                    ffi.gc_collect()
                Some(Ok(Value.Unit))

            case "gc_malloc":
                if self.config.enable_gc:
                    if args.len() > 0:
                        match args[0]:
                            case Int(size):
                                val ptr = ffi.gc_malloc(size)
                                Some(Ok(Value.Int(ptr)))
                            case _:
                                Some(Err(BackendError.type_error("gc_malloc requires int size", nil)))
                    else:
                        Some(Err(BackendError.runtime_error("gc_malloc requires size argument", nil)))
                else:
                    Some(Err(BackendError.runtime_error("gc_malloc unavailable in optimized mode", nil)))

            # File I/O operations (Phase 4)
            case "file_exists":
                if args.len() > 0:
                    match args[0]:
                        case String(path):
                            # TODO: Proper string ptr+len conversion
                            # For now, use placeholder (requires FFI enhancement)
                            val result = ffi.file_exists_ptr(0, path.len())
                            Some(Ok(Value.bool(result)))
                        case _:
                            Some(Err(BackendError.type_error("file_exists requires string path", nil)))
                else:
                    Some(Err(BackendError.runtime_error("file_exists requires path argument", nil)))

            case "file_read":
                if args.len() > 0:
                    match args[0]:
                        case String(path):
                            # TODO: Proper string ptr+len conversion
                            # For now, use placeholder (requires FFI enhancement)
                            val ptr = ffi.file_read_text_ptr(0, path.len())
                            if ptr == 0:
                                Some(Ok(Value.string("")))
                            else:
                                # TODO: Convert ptr to Simple string
                                Some(Ok(Value.string("<file_content>")))
                        case _:
                            Some(Err(BackendError.type_error("file_read requires string path", nil)))
                else:
                    Some(Err(BackendError.runtime_error("file_read requires path argument", nil)))

            case "file_write":
                if args.len() >= 2:
                    match (args[0], args[1]):
                        case (String(path), String(content)):
                            # TODO: Proper string ptr+len conversion
                            val result = ffi.file_write_text_ptr(0, path.len(), 0, content.len())
                            Some(Ok(Value.bool(result)))
                        case _:
                            Some(Err(BackendError.type_error("file_write requires string path and content", nil)))
                else:
                    Some(Err(BackendError.runtime_error("file_write requires path and content arguments", nil)))

            case "file_delete":
                if args.len() > 0:
                    match args[0]:
                        case String(path):
                            # TODO: Proper string ptr+len conversion
                            val result = ffi.file_delete_ptr(0, path.len())
                            Some(Ok(Value.bool(result)))
                        case _:
                            Some(Err(BackendError.type_error("file_delete requires string path", nil)))
                else:
                    Some(Err(BackendError.runtime_error("file_delete requires path argument", nil)))

            # Environment variable operations (Phase 4)
            case "env_get":
                if args.len() > 0:
                    match args[0]:
                        case String(name):
                            # TODO: Proper string ptr+len conversion
                            val ptr = ffi.env_get_ptr(0, name.len())
                            if ptr == 0:
                                Some(Ok(Value.string("")))
                            else:
                                # TODO: Convert ptr to Simple string
                                Some(Ok(Value.string("<env_value>")))
                        case _:
                            Some(Err(BackendError.type_error("env_get requires string name", nil)))
                else:
                    Some(Err(BackendError.runtime_error("env_get requires name argument", nil)))

            case "env_set":
                if args.len() >= 2:
                    match (args[0], args[1]):
                        case (String(name), String(value)):
                            # TODO: Proper string ptr+len conversion
                            val result = ffi.env_set_ptr(0, name.len(), 0, value.len())
                            Some(Ok(Value.bool(result)))
                        case _:
                            Some(Err(BackendError.type_error("env_set requires string name and value", nil)))
                else:
                    Some(Err(BackendError.runtime_error("env_set requires name and value arguments", nil)))

            case _:
                nil

    # ========================================================================
    # FFI RuntimeValue Conversion Helpers
    # ========================================================================

    fn value_to_runtime_ptr(value: Value) -> i64:
        """Convert Simple Value to RuntimeValue pointer for FFI operations."""
        match value:
            case Int(i): ffi.value_int(i)
            case Float(f): ffi.value_float(f)
            case Bool(b): ffi.value_bool(b)
            case Nil: ffi.value_nil()
            case RuntimeValue(ptr): ptr  # Already a pointer
            case String(s):
                # TODO: Proper string conversion (ptr + len)
                ffi.value_string(0, 0)
            case _:
                # Complex types: keep as Simple Value for now
                # TODO: Implement full conversion for Array, Dict, etc.
                ffi.value_nil()

    fn runtime_ptr_to_value(ptr: i64) -> Value:
        """Convert RuntimeValue pointer to Simple Value."""
        if ffi.value_is_int(ptr):
            val i = ffi.value_as_int(ptr)
            Value.int(i)
        elif ffi.value_is_float(ptr):
            val f = ffi.value_as_float(ptr)
            Value.float(f)
        elif ffi.value_is_bool(ptr):
            val b = ffi.value_as_bool(ptr)
            Value.bool(b)
        elif ffi.value_is_nil(ptr):
            Value.Nil
        else:
            # Keep as opaque RuntimeValue for complex types
            Value.RuntimeValue(ptr)

    fn value_to_string(value: Value) -> text:
        """Convert a Value to its string representation."""
        match value:
            case Nil: "nil"
            case Unit: "()"
            case Bool(b): if b: "true" else: "false"
            case Int(i): "{i}"
            case Float(f): "{f}"
            case Char(c): "{c}"
            case String(s): s
            case Array(elements):
                var parts: [text] = []
                for elem in elements:
                    parts = parts.push(self.value_to_string(elem))
                "[{parts.join(\", \")}]"
            case RuntimeValue(_): "<runtime_value>"
            case _: "<{value.type_name()}>"

# ============================================================================
# Exports
# ============================================================================

export InterpreterMode, InterpreterConfig, InterpreterBackendImpl
