"""
# MIR Test Builder

Builder pattern for constructing MIR test cases with comprehensive instruction coverage.

**Category:** Testing Infrastructure
**Status:** Phase 2 Implementation

## Overview

Provides a fluent builder API for constructing MIR (Mid-level Intermediate Representation)
test cases to validate backend code generation.

## Usage

```simple
val builder = MirTestBuilder()
builder.add_const_int(0, 42)
builder.add_const_int(1, 10)
builder.add_binop(2, "add", 0, 1)
builder.add_ret(2)
val test_case = builder.build()
```
"""

# Represents a virtual register ID
class VReg:
    id: i32

# Represents a basic block ID
class BlockId:
    id: i32

# Backend target selection
enum BackendTarget:
    Cranelift
    LLVM
    Vulkan
    Interpreter

# MIR test case with metadata
class MirTestCase:
    name: text = ""
    instructions: [text] = []  # MIR instruction strings
    expected_backends: [BackendTarget] = []
    description: text = ""

    fn instruction_count() -> i64:
        self.instructions.len()

    fn is_supported(backend: BackendTarget) -> bool:
        self.expected_backends.contains(backend)

# Fluent builder for MIR test cases
class MirTestBuilder:
    instructions: [text] = []
    test_name: text = ""
    test_desc: text = ""
    backends: [BackendTarget] = []
    next_vreg: i32 = 0

    me add_const_int(dest: i32, value: i64):
        self.instructions.push("const_int v{dest} = {value}")
        if dest >= self.next_vreg:
            self.next_vreg = dest + 1

    me add_const_float(dest: i32, value: f64):
        self.instructions.push("const_float v{dest} = {value}")
        if dest >= self.next_vreg:
            self.next_vreg = dest + 1

    me add_const_bool(dest: i32, value: bool):
        self.instructions.push("const_bool v{dest} = {value}")
        if dest >= self.next_vreg:
            self.next_vreg = dest + 1

    me add_binop(dest: i32, op: text, left: i32, right: i32):
        self.instructions.push("v{dest} = {op} v{left}, v{right}")
        if dest >= self.next_vreg:
            self.next_vreg = dest + 1

    me add_ret(vreg: i32):
        self.instructions.push("ret v{vreg}")

    me add_ret_void():
        self.instructions.push("ret void")

    me add_branch(cond: i32, then_block: i32, else_block: i32):
        self.instructions.push("br v{cond}, bb{then_block}, bb{else_block}")

    me add_jump(block: i32):
        self.instructions.push("jmp bb{block}")

    me only_backend(backend: BackendTarget):
        self.backends = [backend]

    me only_backends(backend_list: [BackendTarget]):
        self.backends = backend_list

    fn build() -> MirTestCase:
        MirTestCase(
            name: self.test_name,
            instructions: self.instructions,
            expected_backends: self.backends,
            description: self.test_desc
        )

    # DEPRECATED: Use new_test_builder() or direct construction instead
    static fn new() -> MirTestBuilder:
        MirTestBuilder(
            instructions: [],
            test_name: "",
            test_desc: "",
            backends: [BackendTarget.Cranelift, BackendTarget.LLVM, BackendTarget.Interpreter],
            next_vreg: 0
        )

    # Helper methods for VReg/BlockId construction
    fn vreg(id: i32) -> VReg:
        VReg(id: id)

    fn block(id: i32) -> BlockId:
        BlockId(id: id)

    # Adapter methods matching test API
    me const_int(dest: VReg, value: i64):
        self.add_const_int(dest.id, value)

    me const_float(dest: VReg, value: f64):
        self.add_const_float(dest.id, value)

    me const_bool(dest: VReg, value: bool):
        self.add_const_bool(dest.id, value)

    me ret(vreg: VReg):
        self.add_ret(vreg.id)

    me ret_void():
        self.add_ret_void()

# Factory function
fn new_test_builder(name: text) -> MirTestBuilder:
    MirTestBuilder(
        instructions: [],
        test_name: name,
        test_desc: "",
        backends: [BackendTarget.Cranelift, BackendTarget.LLVM, BackendTarget.Interpreter],
        next_vreg: 0
    )

# Helper: Simple arithmetic test
fn simple_arithmetic_test() -> MirTestCase:
    val builder = new_test_builder("simple_arithmetic")
    builder.add_const_int(0, 10)
    builder.add_const_int(1, 20)
    builder.add_binop(2, "add", 0, 1)
    builder.add_ret(2)
    builder.build()

# Helper: Control flow test
fn control_flow_test() -> MirTestCase:
    val builder = new_test_builder("control_flow")
    builder.add_const_bool(0, true)
    builder.add_branch(0, 1, 2)
    builder.add_jump(3)
    builder.build()

export MirTestBuilder, VReg, BlockId, BackendTarget, MirTestCase
export new_test_builder, simple_arithmetic_test, control_flow_test
