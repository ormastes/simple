# Backend Type Definitions
#
# Core type definitions for the unified backend API:
# - BackendKind: Available compiler backends
# - CodegenTarget: Compilation targets (architectures)
# - BuildMode: Build mode (Debug/Release/Test/Bootstrap)
# - OptimizationLevel: Optimization levels (O0-O3)
# - CompileOptions: Compilation option set
# - CompiledModule/CompiledSymbol: Compilation results
# - CompileError: Compilation errors
#
# Split from backend_api.spl for modularity.

# ============================================================================
# Backend Kind
# ============================================================================

enum BackendKind:
    """Available compiler backends."""
    Cranelift   # JIT and AOT, 64-bit focused
    Llvm        # Full optimization, 32-bit support
    Native      # Direct machine code generation (no external tools)
    Wasm        # WebAssembly output
    Lean        # Lean 4 verification export
    Interpreter # Debug interpreter
    Cuda        # NVIDIA CUDA (PTX output)
    Vulkan      # Vulkan compute (SPIR-V output)

impl BackendKind:
    fn to_text() -> text:
        match self:
            case Cranelift: "cranelift"
            case Llvm: "llvm"
            case Native: "native"
            case Wasm: "wasm"
            case Lean: "lean"
            case Interpreter: "interpreter"
            case Cuda: "cuda"
            case Vulkan: "vulkan"

    fn supports_target(target: CodegenTarget) -> bool:
        """Check if this backend supports a target."""
        match self:
            case Cranelift:
                target.is_64bit()
            case Llvm:
                true  # LLVM supports most targets
            case Native:
                # Native backend supports x86_64, aarch64, riscv64
                match target:
                    case X86_64 | AArch64 | Riscv64: true
                    case Host: true
                    case _: false
            case Wasm:
                target == CodegenTarget.Wasm32 or target == CodegenTarget.Wasm64
            case Lean:
                true  # Lean export is target-independent
            case Interpreter:
                true  # Interpreter works for all
            case Cuda:
                target.is_gpu()  # CUDA only for GPU targets
            case Vulkan:
                target.is_gpu()  # Vulkan only for GPU targets

    fn supports_optimization(level: OptimizationLevel) -> bool:
        """Check if this backend supports an optimization level."""
        match self:
            case Cranelift:
                level != OptimizationLevel.Aggressive
            case Llvm:
                true  # LLVM supports all levels
            case Native:
                # Native backend: -O0 and -Og only (no advanced opts yet)
                level == OptimizationLevel.None or level == OptimizationLevel.Debug
            case Wasm:
                level != OptimizationLevel.Aggressive
            case Lean:
                level == OptimizationLevel.None  # No optimization for verification
            case Interpreter:
                true
            case Cuda:
                true  # CUDA supports all levels
            case Vulkan:
                true  # Vulkan supports all levels

    fn is_gpu_backend() -> bool:
        """Check if this is a GPU backend."""
        match self:
            case Cuda | Vulkan: true
            case _: false

    fn is_native_backend() -> bool:
        """Check if this is the native (direct machine code) backend."""
        match self:
            case Native: true
            case _: false

# ============================================================================
# Codegen Target
# ============================================================================

enum CodegenTarget:
    """Compilation targets."""
    # 64-bit targets
    X86_64
    AArch64
    Riscv64

    # 32-bit targets
    X86
    Arm
    Riscv32

    # WebAssembly
    Wasm32
    Wasm64

    # GPU targets
    CudaPtx(compute_cap: (i64, i64))    # NVIDIA CUDA (e.g., (8, 6) for SM 8.6)
    VulkanSpirv(version: (i64, i64))    # Vulkan SPIR-V (e.g., (1, 3) for Vulkan 1.3)

    # Host (detected at runtime)
    Host

impl CodegenTarget:
    fn to_text() -> text:
        match self:
            case X86_64: "x86_64"
            case AArch64: "aarch64"
            case Riscv64: "riscv64"
            case X86: "i686"
            case Arm: "armv7"
            case Riscv32: "riscv32"
            case Wasm32: "wasm32"
            case Wasm64: "wasm64"
            case CudaPtx(cap): "cuda-sm{cap.0}{cap.1}"
            case VulkanSpirv(ver): "vulkan-{ver.0}.{ver.1}"
            case Host: "host"

    fn is_64bit() -> bool:
        match self:
            case X86_64 | AArch64 | Riscv64 | Wasm64 | Host: true
            case _: false

    fn is_32bit() -> bool:
        match self:
            case X86 | Arm | Riscv32 | Wasm32: true
            case _: false

    fn is_wasm() -> bool:
        match self:
            case Wasm32 | Wasm64: true
            case _: false

    fn is_gpu() -> bool:
        """Check if this is a GPU target."""
        match self:
            case CudaPtx(_) | VulkanSpirv(_): true
            case _: false

    fn is_cuda() -> bool:
        """Check if this is a CUDA target."""
        match self:
            case CudaPtx(_): true
            case _: false

    fn is_vulkan() -> bool:
        """Check if this is a Vulkan target."""
        match self:
            case VulkanSpirv(_): true
            case _: false

    fn cuda_compute_capability() -> (i64, i64)?:
        """Get CUDA compute capability if this is a CUDA target."""
        match self:
            case CudaPtx(cap): Some(cap)
            case _: nil

    fn vulkan_version() -> (i64, i64)?:
        """Get Vulkan version if this is a Vulkan target."""
        match self:
            case VulkanSpirv(ver): Some(ver)
            case _: nil

    static fn from_text(s: text) -> CodegenTarget?:
        """Parse target from string."""
        match s:
            case "x86_64" | "x64": Some(CodegenTarget.X86_64)
            case "aarch64" | "arm64": Some(CodegenTarget.AArch64)
            case "riscv64": Some(CodegenTarget.Riscv64)
            case "i686" | "x86" | "i386": Some(CodegenTarget.X86)
            case "armv7" | "arm": Some(CodegenTarget.Arm)
            case "riscv32": Some(CodegenTarget.Riscv32)
            case "wasm32": Some(CodegenTarget.Wasm32)
            case "wasm64": Some(CodegenTarget.Wasm64)
            case "host": Some(CodegenTarget.Host)
            case "cuda" | "cuda-sm70": Some(CodegenTarget.CudaPtx((7, 0)))
            case "cuda-sm75": Some(CodegenTarget.CudaPtx((7, 5)))
            case "cuda-sm80": Some(CodegenTarget.CudaPtx((8, 0)))
            case "cuda-sm86": Some(CodegenTarget.CudaPtx((8, 6)))
            case "cuda-sm89": Some(CodegenTarget.CudaPtx((8, 9)))
            case "cuda-sm90": Some(CodegenTarget.CudaPtx((9, 0)))
            case "vulkan" | "vulkan-1.3": Some(CodegenTarget.VulkanSpirv((1, 3)))
            case "vulkan-1.2": Some(CodegenTarget.VulkanSpirv((1, 2)))
            case "vulkan-1.1": Some(CodegenTarget.VulkanSpirv((1, 1)))
            case "vulkan-1.0": Some(CodegenTarget.VulkanSpirv((1, 0)))
            case _: nil

    static fn cuda(major: i64, minor: i64) -> CodegenTarget:
        """Create CUDA target with specific compute capability."""
        CodegenTarget.CudaPtx((major, minor))

    static fn vulkan(major: i64, minor: i64) -> CodegenTarget:
        """Create Vulkan target with specific version."""
        CodegenTarget.VulkanSpirv((major, minor))

# ============================================================================
# Build Mode
# ============================================================================

enum BuildMode:
    """Build mode determines backend selection and optimization strategy."""
    Debug      # Debug builds: fast compilation (Cranelift), debug symbols
    Release    # Release builds: optimized runtime (LLVM), stripped
    Test       # Test mode: no compilation (Interpreter)
    Bootstrap  # Bootstrap builds: minimal dependencies (Cranelift)

impl BuildMode:
    fn to_text() -> text:
        match self:
            case Debug: "debug"
            case Release: "release"
            case Test: "test"
            case Bootstrap: "bootstrap"

    fn default_optimization() -> OptimizationLevel:
        """Get default optimization level for build mode."""
        match self:
            case Debug: OptimizationLevel.Debug
            case Release: OptimizationLevel.Speed
            case Test: OptimizationLevel.None
            case Bootstrap: OptimizationLevel.Size

    fn prefer_llvm() -> bool:
        """Whether this mode prefers LLVM over Cranelift."""
        match self:
            case Release: true  # LLVM for better optimization
            case _: false       # Cranelift for fast compilation

# ============================================================================
# Optimization Level
# ============================================================================

enum OptimizationLevel:
    """Optimization levels for code generation."""
    None        # -O0: No optimization, fast compile
    Debug       # -Og: Debug-friendly optimization
    Size        # -Os: Optimize for size
    Speed       # -O2: Standard optimization
    Aggressive  # -O3: Aggressive optimization

impl OptimizationLevel:
    fn to_text() -> text:
        match self:
            case None: "O0"
            case Debug: "Og"
            case Size: "Os"
            case Speed: "O2"
            case Aggressive: "O3"

    fn llvm_level() -> i64:
        """Get LLVM optimization level number."""
        match self:
            case None: 0
            case Debug: 1
            case Size: 2  # -Os maps to O2 with size preference
            case Speed: 2
            case Aggressive: 3

# ============================================================================
# Compilation Options
# ============================================================================

struct CompileOptions:
    """Options for compilation."""
    target: CodegenTarget
    opt_level: OptimizationLevel
    debug_info: bool
    emit_assembly: bool
    emit_llvm_ir: bool
    emit_mir: bool
    verify_output: bool

impl CompileOptions:
    static fn default_options() -> CompileOptions:
        CompileOptions(
            target: CodegenTarget.Host,
            opt_level: OptimizationLevel.Speed,
            debug_info: false,
            emit_assembly: false,
            emit_llvm_ir: false,
            emit_mir: false,
            verify_output: true
        )

    static fn debug_options() -> CompileOptions:
        CompileOptions(
            target: CodegenTarget.Host,
            opt_level: OptimizationLevel.Debug,
            debug_info: true,
            emit_assembly: false,
            emit_llvm_ir: false,
            emit_mir: true,
            verify_output: true
        )

    static fn release_options() -> CompileOptions:
        CompileOptions(
            target: CodegenTarget.Host,
            opt_level: OptimizationLevel.Speed,
            debug_info: false,
            emit_assembly: false,
            emit_llvm_ir: false,
            emit_mir: false,
            verify_output: true
        )

    fn with_target(target: CodegenTarget) -> CompileOptions:
        CompileOptions(
            target: target,
            opt_level: self.opt_level,
            debug_info: self.debug_info,
            emit_assembly: self.emit_assembly,
            emit_llvm_ir: self.emit_llvm_ir,
            emit_mir: self.emit_mir,
            verify_output: self.verify_output
        )

    fn with_optimization(opt_level: OptimizationLevel) -> CompileOptions:
        """Set optimization level."""
        CompileOptions(
            target: self.target,
            opt_level: opt_level,
            debug_info: self.debug_info,
            emit_assembly: self.emit_assembly,
            emit_llvm_ir: self.emit_llvm_ir,
            emit_mir: self.emit_mir,
            verify_output: self.verify_output
        )

# ============================================================================
# Compilation Result
# ============================================================================

struct CompiledModule:
    """Result of compiling a module."""
    name: text
    object_code: [u8]?
    assembly: text?
    llvm_ir: text?
    mir_dump: text?
    symbols: [CompiledSymbol]
    compile_time_ms: i64

struct CompiledSymbol:
    """A symbol in the compiled module."""
    name: text
    kind: SymbolKind
    address: i64
    size: i64

enum SymbolKind:
    Function
    Data
    Const

impl SymbolKind:
    fn to_text() -> text:
        match self:
            case Function: "function"
            case Data: "data"
            case Const: "const"

struct CompileError:
    """Error during compilation."""
    message: text
    phase: text
    location: text?

impl CompileError:
    static fn backend_error(backend: BackendKind, message: text) -> CompileError:
        CompileError(
            message: message,
            phase: "backend ({backend.to_text()})",
            location: nil
        )

    static fn target_unsupported(backend: BackendKind, target: CodegenTarget) -> CompileError:
        CompileError(
            message: "Backend {backend.to_text()} does not support target {target.to_text()}",
            phase: "target selection",
            location: nil
        )

    fn to_text() -> text:
        var result = "Compile error in {self.phase}: {self.message}"
        if self.location.?:
            result = "{result} at {self.location.unwrap()}"
        result

export BackendKind, CodegenTarget, OptimizationLevel, BuildMode
export CompileOptions, CompiledModule, CompiledSymbol, SymbolKind, CompileError
