# Lean Verification Backend
#
# Exports Simple programs to Lean 4 for formal verification.
# MIR-to-Lean translation functions are in lean_mir_translate.spl.
#
# Features:
# - Type translation to Lean types
# - Function export with contracts
# - Invariant generation
# - Proof obligation extraction
#
# Usage:
#   val backend = LeanBackend__create(VerificationLevel.Full)
#   val result = backend.export_module(mir_module)
#   result.write_to_file("module.lean")

use compiler.mir.mir_data.*
use compiler.backend.backend_api.*
use compiler.backend.codegen_types.{Codegen, CodegenOutput, CodegenOutputKind}
use compiler.backend.verification_codegen_types.{VerificationCodegen}
use compiler.backend.backend.lean_mir_translate.*

# ============================================================================
# Verification Level
# ============================================================================

enum VerificationLevel:
    """Level of verification detail to generate."""
    Minimal     # Just type signatures
    Contracts   # Pre/post conditions
    Full        # Full specifications with proofs
    Memory      # Memory safety proofs
    Effects     # Effect system verification

impl VerificationLevel:
    fn to_text() -> text:
        match self:
            case Minimal: "minimal"
            case Contracts: "contracts"
            case Full: "full"
            case Memory: "memory"
            case Effects: "effects"

    fn includes_contracts() -> bool:
        match self:
            case Minimal: false
            case _: true

    fn includes_proofs() -> bool:
        match self:
            case Full | Memory | Effects: true
            case _: false

# ============================================================================
# Lean Type Translation
# ============================================================================

fn mir_type_to_lean(ty: MirType) -> text:
    """Convert MIR type to Lean 4 type."""
    match ty.kind:
        case I64: "Int"
        case I32: "Int32"
        case I16: "UInt16"
        case I8: "UInt8"
        case F64: "Float"
        case F32: "Float"
        case Bool: "Bool"
        case Unit: "Unit"
        case Ptr(inner, _):
            "Ptr ({mir_type_to_lean(inner)})"
        case Array(elem, size):
            "Array ({mir_type_to_lean(elem)}) {size}"
        case Struct(id):
            "Struct{id}"
        case Tuple(elems):
            val elem_types = elems.map(\e: mir_type_to_lean(e)).join(" × ")
            "({elem_types})"
        case Option(inner):
            "Option ({mir_type_to_lean(inner)})"
        case Result(ok, err):
            "Except ({mir_type_to_lean(err)}) ({mir_type_to_lean(ok)})"
        case _: "Any"

# ============================================================================
# Lean Code Builder
# ============================================================================

class LeanBuilder:
    """Builds Lean 4 source code."""
    lines: [text]
    indent_level: i64
    imports: [text]

    static fn create() -> LeanBuilder:
        LeanBuilder(
            lines: [],
            indent_level: 0,
            imports: []
        )

    me add_import(module: text):
        """Add an import."""
        if not self.imports.contains(module):
            self.imports = self.imports.push(module)

    me emit(line: text):
        """Emit a line with current indentation."""
        val indent = "  ".repeat(self.indent_level)
        self.lines = self.lines.push("{indent}{line}")

    me emit_blank():
        """Emit a blank line."""
        self.lines = self.lines.push("")

    me indent():
        """Increase indentation."""
        self.indent_level = self.indent_level + 1

    me dedent():
        """Decrease indentation."""
        if self.indent_level > 0:
            self.indent_level = self.indent_level - 1

    me emit_comment(text: text):
        """Emit a comment."""
        self.emit("-- {text}")

    me emit_doc_comment(text: text):
        """Emit a documentation comment."""
        self.emit("/-- {text} -/")

    me begin_namespace(name: text):
        """Start a namespace."""
        self.emit("namespace {name}")
        self.emit_blank()

    me end_namespace(name: text):
        """End a namespace."""
        self.emit_blank()
        self.emit("end {name}")

    me emit_structure(name: text, fields: [(text, text)]):
        """Emit a structure definition."""
        self.emit("structure {name} where")
        self.indent()
        for (field_name, field_type) in fields:
            self.emit("{field_name} : {field_type}")
        self.dedent()

    me emit_inductive(name: text, variants: [(text, [text])]):
        """Emit an inductive type."""
        self.emit("inductive {name} where")
        self.indent()
        for (var_name, params) in variants:
            if params.is_empty():
                self.emit("| {var_name}")
            else:
                val param_str = params.join(" → ")
                self.emit("| {var_name} : {param_str} → {name}")
        self.dedent()

    me emit_def(name: text, params: [(text, text)], ret_type: text, body: text):
        """Emit a definition."""
        val param_str = params.map(\p: "({p.0} : {p.1})").join(" ")
        self.emit("def {name} {param_str} : {ret_type} :=")
        self.indent()
        self.emit(body)
        self.dedent()

    me emit_theorem(name: text, statement: text):
        """Emit a theorem statement with tactic-based proof."""
        self.emit("theorem {name} : {statement} := by")
        self.indent()
        val tactics = select_proof_tactics(statement)
        for tactic in tactics:
            self.emit(tactic)
        self.dedent()

    me emit_axiom(name: text, ty: text):
        """Emit an axiom (unproven assumption)."""
        self.emit("axiom {name} : {ty}")

    fn build() -> text:
        """Build final Lean code."""
        var output = ""

        # Add imports
        for import_mod in self.imports:
            output = "{output}import {import_mod}\n"
        if not self.imports.is_empty():
            output = "{output}\n"

        # Add lines
        output = "{output}{self.lines.join("\n")}"
        output

# ============================================================================
# Contract Extraction
# ============================================================================

struct FunctionContract:
    """Pre/post conditions for a function."""
    function_name: text
    preconditions: [text]
    postconditions: [text]
    invariants: [text]

impl FunctionContract:
    static fn empty(name: text) -> FunctionContract:
        FunctionContract(
            function_name: name,
            preconditions: [],
            postconditions: [],
            invariants: []
        )

    fn has_contracts() -> bool:
        not self.preconditions.is_empty() or not self.postconditions.is_empty()

    fn to_lean_spec(builder: LeanBuilder, params: [(text, text)], ret_type: text):
        """Generate Lean specification from contract."""
        if self.preconditions.is_empty() and self.postconditions.is_empty():
            return

        # Generate specification type
        var spec = ""

        if not self.preconditions.is_empty():
            val pre = self.preconditions.join(" ∧ ")
            spec = "{pre} → "

        val param_str = params.map(\p: p.0).join(" "
        spec = "{spec}∃ (result : {ret_type}), "

        if not self.postconditions.is_empty():
            val post = self.postconditions.join(" ∧ ")
            spec = "{spec}{post}"
        else:
            spec = "{spec}True"

        builder.emit_theorem("{self.function_name}_spec", spec)

# ============================================================================
# Proof Obligation
# ============================================================================

enum ProofObligation:
    """A proof obligation generated from code."""
    # Safety proofs
    BoundsCheck(array: text, index: text)
    NullCheck(pointer: text)
    DivisionByZero(divisor: text)

    # Memory proofs
    NoAliasing(ptr1: text, ptr2: text)
    ValidLifetime(ptr: text, scope: text)

    # Functional proofs
    LoopInvariant(invariant: text)
    Postcondition(condition: text)
    Termination(measure: text)

impl ProofObligation:
    fn to_lean() -> text:
        """Convert to Lean theorem statement."""
        match self:
            case BoundsCheck(arr, idx):
                "{idx} < {arr}.size"
            case NullCheck(ptr):
                "{ptr} ≠ null"
            case DivisionByZero(div):
                "{div} ≠ 0"
            case NoAliasing(p1, p2):
                "disjoint {p1} {p2}"
            case ValidLifetime(ptr, scope):
                "valid_in {ptr} {scope}"
            case LoopInvariant(inv):
                inv
            case Postcondition(cond):
                cond
            case Termination(measure):
                "∀ n, {measure} n < {measure} (n + 1)"

# ============================================================================
# Lean Backend
# ============================================================================

class LeanBackend:
    """Lean 4 verification export backend."""
    level: VerificationLevel
    generate_proofs: bool
    module_prefix: text

    static fn create(level: VerificationLevel) -> LeanBackend:
        LeanBackend(
            level: level,
            generate_proofs: level.includes_proofs(),
            module_prefix: "Simple"
        )

    static fn minimal() -> LeanBackend:
        LeanBackend__create(VerificationLevel.Minimal)

    static fn full() -> LeanBackend:
        LeanBackend__create(VerificationLevel.Full)

    fn with_prefix(prefix: text) -> LeanBackend:
        LeanBackend(
            level: self.level,
            generate_proofs: self.generate_proofs,
            module_prefix: prefix
        )

    fn export_module(module: MirModule) -> Result<LeanExportResult, CompileError>:
        """Export a MIR module to Lean 4."""
        var builder = LeanBuilder__create()

        # Add standard imports
        builder.add_import("Mathlib.Data.Int.Basic")
        builder.add_import("Mathlib.Data.Array.Basic")

        # Begin namespace
        builder.begin_namespace("{self.module_prefix}.{module.name}")

        # Export type definitions
        self.export_types(builder, module)

        # Export functions
        for name, body in module.functions:
            self.export_function(builder, name, body)

        # Generate proof obligations
        if self.generate_proofs:
            builder.emit_blank()
            builder.emit_comment("Proof Obligations")
            self.generate_proof_obligations(builder, module)

        builder.end_namespace("{self.module_prefix}.{module.name}")

        Ok(LeanExportResult(
            module_name: module.name,
            lean_code: builder.build(),
            proof_obligations: [],  # Would be populated
            export_time_ms: 0
        ))

    fn export_types(builder: LeanBuilder, module: MirModule):
        """Export type definitions."""
        builder.emit_comment("Type Definitions")
        builder.emit_blank()

        # Would iterate through module type definitions

    fn export_function(builder: LeanBuilder, name: text, body: MirBody):
        """Export a function definition."""
        builder.emit_blank()
        builder.emit_doc_comment("Function: {name}")

        # Build parameters
        var params: [(text, text)] = []
        for i in 0..body.arg_count:
            params = params.push(("arg{i}", "Int"))

        val ret_type = mir_type_to_lean(body.return_ty)

        # Generate function signature
        if self.level == VerificationLevel.Minimal:
            # Just emit axiom for function existence
            val param_types = params.map(\p: p.1).join(" → ")
            val full_type = if param_types.is_empty(): ret_type else: "{param_types} → {ret_type}"
            builder.emit_axiom(name, full_type)
        else:
            # Generate full definition by translating MIR body
            val lean_body = translate_mir_body(body)
            builder.emit_def(name, params, ret_type, lean_body)

        # Generate contracts if requested
        if self.level.includes_contracts():
            val contract = FunctionContract__empty(name)
            contract.to_lean_spec(builder, params, ret_type)

    fn generate_proof_obligations(builder: LeanBuilder, module: MirModule):
        """Generate proof obligations for the module."""
        # Would analyze MIR for potential safety issues
        # and generate corresponding proof obligations
        pass

struct LeanExportResult:
    """Result of Lean export."""
    module_name: text
    lean_code: text
    proof_obligations: [ProofObligation]
    export_time_ms: i64

impl LeanExportResult:
    fn write_to_file(path: text) -> Result<(), text>:
        """Write Lean code to file."""
        # Would write self.lean_code to path
        Ok(())

    fn has_unproven_obligations() -> bool:
        not self.proof_obligations.is_empty()

# ============================================================================
# Proof Tactic Selection
# ============================================================================

fn select_proof_tactics(statement: text) -> [text]:
    """Select appropriate Lean 4 tactics based on the theorem statement.

    Analyzes the structure of the proof obligation and returns a list of
    tactic invocations that should discharge the goal. Falls back to a
    general strategy when the statement doesn't match a known pattern.
    """
    # Trivial / tautology (True, or empty postcondition placeholder)
    if statement == "True" or statement.ends_with("True"):
        return ["trivial"]

    # Reflexivity: goals of the form `a = a`
    if statement.contains("= ") and is_reflexive_equality(statement):
        return ["rfl"]

    # Decidable propositions (Bool comparisons, finite checks)
    if statement.contains("decide") or statement.contains("Decidable"):
        return ["decide"]

    # Natural / integer arithmetic obligations
    if is_arithmetic_statement(statement):
        return ["omega"]

    # Bounds check: `idx < arr.size`
    if statement.contains("< ") and statement.contains(".size"):
        return ["simp [Array.size]", "omega"]

    # Null / non-zero check: `x != 0` or `x != null`
    if statement.contains("≠ 0") or statement.contains("≠ null"):
        return ["simp", "omega"]

    # Disjointness / non-aliasing
    if statement.contains("disjoint"):
        return ["simp [disjoint]", "decide"]

    # Existential goals (postcondition specs: ∃ result, ...)
    if statement.contains("∃"):
        return ["simp", "omega"]

    # Memory safety (valid_heap preservation)
    if statement.contains("valid_heap"):
        return ["intro heap h_valid", "simp [run, valid_heap] at *", "exact h_valid"]

    # Universally quantified goals
    if statement.contains("∀"):
        return ["intro n", "simp", "omega"]

    # Conjunction: try splitting then solving each side
    if statement.contains("∧"):
        return ["constructor <;> simp <;> omega"]

    # General fallback: simp with omega for arithmetic residuals
    return ["simp", "omega"]

fn is_reflexive_equality(statement: text) -> bool:
    """Check if a statement is of the form `expr = expr`."""
    val parts = statement.split(" = ")
    if parts.len() == 2:
        val lhs = parts[0].trim()
        val rhs = parts[1].trim()
        return lhs == rhs
    false

fn is_arithmetic_statement(statement: text) -> bool:
    """Check if a statement is purely arithmetic (solvable by omega)."""
    # omega handles linear integer arithmetic
    if statement.contains("+") or statement.contains("-") or statement.contains("*"):
        if statement.contains("<") or statement.contains("≤") or statement.contains("=") or statement.contains("≥") or statement.contains(">"):
            return true
    # Simple numeric equality / inequality
    if statement.contains("Nat") or statement.contains("Int"):
        if statement.contains("<") or statement.contains("="):
            return true
    false

# ============================================================================
# Verification Helpers
# ============================================================================

fn generate_memory_safety_spec(builder: LeanBuilder, func_name: text):
    """Generate memory safety specification."""
    builder.emit_theorem("{func_name}_memory_safe",
        "∀ heap : Heap, valid_heap heap → valid_heap (run {func_name} heap)")

fn generate_termination_proof(builder: LeanBuilder, func_name: text, measure: text):
    """Generate termination proof structure."""
    builder.emit("termination_by {func_name} => {measure}")

fn generate_refinement_type(base_type: text, predicate: text) -> text:
    """Generate a refinement type."""
    "{{ x : {base_type} // {predicate} }}"

# ============================================================================
# Single-Obligation Tactic Selection
# ============================================================================

fn select_tactic(obligation: text) -> text:
    """Select appropriate Lean 4 tactic for a single proof obligation.

    Unlike select_proof_tactics which returns a full tactic script,
    this returns the single best tactic for a given obligation kind.
    """
    if obligation.contains("arithmetic") or obligation.contains("add") or obligation.contains("mul"):
        "ring"
    elif obligation.contains("numeric") or obligation.contains("nat") or obligation.contains("int"):
        "omega"
    elif obligation.contains("norm"):
        "norm_num"
    elif obligation.contains("enum") or obligation.contains("match") or obligation.contains("inductive"):
        "cases"
    elif obligation.contains("search") or obligation.contains("auto"):
        "aesop"
    elif obligation.contains("simp") or obligation.contains("simple"):
        "simp"
    elif obligation.contains("refl") or obligation.contains("equal"):
        "rfl"
    else:
        "sorry"

# ============================================================================
# Codegen Trait Implementation
# ============================================================================

impl Codegen for LeanBackend:
    fn backend_kind() -> BackendKind: BackendKind.Lean
    fn backend_name() -> text: "lean"
    fn supports_target(target: CodegenTarget) -> bool: true
    fn output_kind() -> CodegenOutputKind: CodegenOutputKind.TextSource

    fn compile_module(module: MirModule) -> Result<CodegenOutput, CompileError>:
        val result = self.export_module(module)
        match result:
            case Ok(lean_result):
                Ok(CodegenOutput__text(module.name, lean_result.lean_code))
            case Err(e):
                Err(e)

# ============================================================================
# VerificationCodegen Trait Implementation
# ============================================================================

impl VerificationCodegen for LeanBackend:
    fn export_function(name: text, body: MirBody) -> text:
        translate_mir_body(body)

    fn generate_proof_obligations(module: MirModule) -> [text]:
        []

    fn verification_level() -> text:
        self.level.to_text()

# ============================================================================
# Exports
# ============================================================================


# Desugared static methods for bootstrap interpreter compatibility

fn LeanBuilder__create() -> LeanBuilder:
        LeanBuilder(
            lines: [],
            indent_level: 0,
            imports: []
        )

    me add_import(module: text):
        """Add an import."""
        if not self.imports.contains(module):
            self.imports = self.imports.push(module)

    me emit(line: text):
        """Emit a line with current indentation."""
        val indent = "  ".repeat(self.indent_level)
        self.lines = self.lines.push("{indent}{line}")

    me emit_blank():
        """Emit a blank line."""
        self.lines = self.lines.push("")

    me indent():
        """Increase indentation."""
        self.indent_level = self.indent_level + 1

    me dedent():
        """Decrease indentation."""
        if self.indent_level > 0:
            self.indent_level = self.indent_level - 1

    me emit_comment(text: text):
        """Emit a comment."""
        self.emit("-- {text}")

    me emit_doc_comment(text: text):
        """Emit a documentation comment."""
        self.emit("/-- {text} -/")

    me begin_namespace(name: text):
        """Start a namespace."""
        self.emit("namespace {name}")
        self.emit_blank()

    me end_namespace(name: text):
        """End a namespace."""
        self.emit_blank()
        self.emit("end {name}")

    me emit_structure(name: text, fields: [(text, text)]):
        """Emit a structure definition."""
        self.emit("structure {name} where")
        self.indent()
        for (field_name, field_type) in fields:
            self.emit("{field_name} : {field_type}")
        self.dedent()

    me emit_inductive(name: text, variants: [(text, [text])]):
        """Emit an inductive type."""
        self.emit("inductive {name} where")
        self.indent()
        for (var_name, params) in variants:
            if params.is_empty():
                self.emit("| {var_name}")
            else:
                val param_str = params.join(" → ")
                self.emit("| {var_name} : {param_str} → {name}")
        self.dedent()

    me emit_def(name: text, params: [(text, text)], ret_type: text, body: text):
        """Emit a definition."""
        val param_str = params.map(\p: "({p.0} : {p.1})").join(" ")
        self.emit("def {name} {param_str} : {ret_type} :=")
        self.indent()
        self.emit(body)
        self.dedent()

    me emit_theorem(name: text, statement: text):
        """Emit a theorem statement with tactic-based proof."""
        self.emit("theorem {name} : {statement} := by")
        self.indent()
        val tactics = select_proof_tactics(statement)
        for tactic in tactics:
            self.emit(tactic)
        self.dedent()

    me emit_axiom(name: text, ty: text):
        """Emit an axiom (unproven assumption)."""
        self.emit("axiom {name} : {ty}")

    fn build() -> text:
        """Build final Lean code."""
        var output = ""

        # Add imports
        for import_mod in self.imports:
            output = "{output}import {import_mod}\n"
        if not self.imports.is_empty():
            output = "{output}\n"

        # Add lines
        output = "{output}{self.lines.join("\n")}"
        output



fn LeanBackend__create(level: VerificationLevel) -> LeanBackend:
    LeanBackend(
        level: level,
        generate_proofs: level.includes_proofs(),
        module_prefix: "Simple"
    )



fn LeanBackend__minimal() -> LeanBackend:
    LeanBackend__create(VerificationLevel.Minimal)



fn None__full() -> LeanBackend:
        LeanBackend__create(VerificationLevel.Full)

    fn with_prefix(prefix: text) -> LeanBackend:
        LeanBackend(
            level: self.level,
            generate_proofs: self.generate_proofs,
            module_prefix: prefix
        )

    fn export_module(module: MirModule) -> Result<LeanExportResult, CompileError>:
        """Export a MIR module to Lean 4."""
        var builder = LeanBuilder__create()

        # Add standard imports
        builder.add_import("Mathlib.Data.Int.Basic")
        builder.add_import("Mathlib.Data.Array.Basic")

        # Begin namespace
        builder.begin_namespace("{self.module_prefix}.{module.name}")

        # Export type definitions
        self.export_types(builder, module)

        # Export functions
        for name, body in module.functions:
            self.export_function(builder, name, body)

        # Generate proof obligations
        if self.generate_proofs:
            builder.emit_blank()
            builder.emit_comment("Proof Obligations")
            self.generate_proof_obligations(builder, module)

        builder.end_namespace("{self.module_prefix}.{module.name}")

        Ok(LeanExportResult(
            module_name: module.name,
            lean_code: builder.build(),
            proof_obligations: [],  # Would be populated
            export_time_ms: 0
        ))

    fn export_types(builder: LeanBuilder, module: MirModule):
        """Export type definitions."""
        builder.emit_comment("Type Definitions")
        builder.emit_blank()

        # Would iterate through module type definitions

    fn export_function(builder: LeanBuilder, name: text, body: MirBody):
        """Export a function definition."""
        builder.emit_blank()
        builder.emit_doc_comment("Function: {name}")

        # Build parameters
        var params: [(text, text)] = []
        for i in 0..body.arg_count:
            params = params.push(("arg{i}", "Int"))

        val ret_type = mir_type_to_lean(body.return_ty)

        # Generate function signature
        if self.level == VerificationLevel.Minimal:
            # Just emit axiom for function existence
            val param_types = params.map(\p: p.1).join(" → ")
            val full_type = if param_types.is_empty(): ret_type else: "{param_types} → {ret_type}"
            builder.emit_axiom(name, full_type)
        else:
            # Generate full definition by translating MIR body
            val lean_body = translate_mir_body(body)
            builder.emit_def(name, params, ret_type, lean_body)

        # Generate contracts if requested
        if self.level.includes_contracts():
            val contract = FunctionContract__empty(name)
            contract.to_lean_spec(builder, params, ret_type)

    fn generate_proof_obligations(builder: LeanBuilder, module: MirModule):
        """Generate proof obligations for the module."""
        # Would analyze MIR for potential safety issues
        # and generate corresponding proof obligations
        pass

    """Result of Lean export."""
    module_name: text
    lean_code: text
    proof_obligations: [ProofObligation]
    export_time_ms: i64



# Auto-generated desugared static method wrappers
fn FunctionContract__empty(name: text) -> FunctionContract:
    FunctionContract(
        function_name: name,
        preconditions: [],
        postconditions: [],
        invariants: []
    )


export VerificationLevel, mir_type_to_lean
export LeanBuilder, FunctionContract, ProofObligation
export LeanBackend, LeanExportResult
export select_proof_tactics, is_reflexive_equality, is_arithmetic_statement
export select_tactic
export translate_mir_body, translate_mir_block, translate_mir_inst
export translate_mir_terminator, translate_operand, translate_const_value
export translate_binop, translate_unaryop
export generate_memory_safety_spec, generate_termination_proof
export generate_refinement_type
