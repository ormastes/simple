# WASM Memory Management - Linear memory layout and string constants
#
# Manages WebAssembly linear memory layout:
# - String constant table (data segments)
# - Bump allocator using __heap_ptr global
# - Memory layout: [string data | heap (grows up) | free | stack (grows down)]
#
# Usage:
#   var mem = WasmMemoryManager__create()
#   val offset = mem.add_string("hello")
#   mem.emit_data_sections(builder)

use compiler.backend.wasm_backend.{WatBuilder}

# ============================================================================
# String Table
# ============================================================================

struct StringEntry:
    """A string constant in the data segment."""
    content: text
    offset: i64
    byte_length: i64

# ============================================================================
# Memory Manager
# ============================================================================

class WasmMemoryManager:
    """Manages WASM linear memory layout.

    Memory layout (with --stack-first):
        [stack (grows down)] [data segment] [heap (grows up)]

    Without --stack-first (default for WAT backend):
        [data segment] [heap (grows up) ... free ... stack (grows down)]
    """
    strings: [StringEntry]
    next_data_offset: i64    # Next available offset in data segment
    heap_base: i64           # Start of heap (after data segment)
    initial_pages: i64       # Initial memory pages (64KB each)
    max_pages: i64           # Maximum memory pages (0 = unlimited)

    static fn create() -> WasmMemoryManager:
        """Create memory manager with default layout.

        Data segment starts at offset 1024 (skip first 1KB for null guard).
        """
        WasmMemoryManager(
            strings: [],
            next_data_offset: 1024,
            heap_base: 0,
            initial_pages: 64,   # 4 MB
            max_pages: 4096      # 256 MB
        )

    me add_string(content: text) -> i64:
        """Add a string constant to the data segment.

        Returns the memory offset where the string will be placed.
        Strings are null-terminated.
        """
        # Check if string already exists
        for entry in self.strings:
            if entry.content == content:
                return entry.offset

        val offset = self.next_data_offset
        val byte_len = content.len() + 1  # +1 for null terminator
        val entry = StringEntry(
            content: content,
            offset: offset,
            byte_length: byte_len
        )
        self.strings = self.strings.push(entry)

        # Align next offset to 4 bytes
        val aligned = ((offset + byte_len + 3) / 4) * 4
        self.next_data_offset = aligned

        offset

    me finalize():
        """Finalize memory layout. Call after all strings are added."""
        # Align heap base to 16 bytes
        self.heap_base = ((self.next_data_offset + 15) / 16) * 16

    fn emit_memory_declaration(builder: WatBuilder):
        """Emit memory declaration."""
        if self.max_pages > 0:
            builder.emit("(memory (export \"memory\") {self.initial_pages} {self.max_pages})")
        else:
            builder.emit("(memory (export \"memory\") {self.initial_pages})")

    fn emit_globals(builder: WatBuilder):
        """Emit memory management globals."""
        # Heap pointer (bump allocator)
        builder.emit("(global $__heap_ptr (mut i32) (i32.const {self.heap_base}))")

    fn emit_data_sections(builder: WatBuilder):
        """Emit data sections for string constants."""
        for entry in self.strings:
            val escaped = escape_wat_string(entry.content)
            builder.emit("(data (i32.const {entry.offset}) \"{escaped}\\00\")")

    fn emit_bump_alloc(builder: WatBuilder):
        """Emit a simple bump allocator function.

        fn __wasm_alloc(size: i32) -> i32:
            ptr = __heap_ptr
            __heap_ptr += align(size, 8)
            return ptr
        """
        builder.emit("(func $__wasm_alloc (param $size i32) (result i32)")
        builder.emit("  (local $ptr i32)")
        builder.emit("  (local.set $ptr (global.get $__heap_ptr))")
        # Align size to 8 bytes: (size + 7) & ~7
        builder.emit("  (global.set $__heap_ptr")
        builder.emit("    (i32.add")
        builder.emit("      (global.get $__heap_ptr)")
        builder.emit("      (i32.and")
        builder.emit("        (i32.add (local.get $size) (i32.const 7))")
        builder.emit("        (i32.const -8)")
        builder.emit("      )")
        builder.emit("    )")
        builder.emit("  )")
        builder.emit("  (local.get $ptr)")
        builder.emit(")")

# ============================================================================
# WAT String Escaping
# ============================================================================

fn escape_wat_string(content: text) -> text:
    """Escape a string for WAT data segment format.

    WAT uses \\xx hex escapes for non-printable characters.
    """
    var result = ""
    for i in 0..content.len():
        val ch = content[i:i + 1]
        if ch == "\\":
            result = result + "\\\\"
        elif ch == "\"":
            result = result + "\\\""
        elif ch == "\n":
            result = result + "\\0a"
        elif ch == "\r":
            result = result + "\\0d"
        elif ch == "\t":
            result = result + "\\09"
        else:
            result = result + ch
    result

# ============================================================================
# Desugared static methods
# ============================================================================

fn WasmMemoryManager__create() -> WasmMemoryManager:
    WasmMemoryManager__create()

# ============================================================================
# Exports
# ============================================================================

export StringEntry
export WasmMemoryManager, WasmMemoryManager__create
export escape_wat_string
