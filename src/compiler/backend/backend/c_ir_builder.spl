# C IR Builder - C++20 Source Code Builder
#
# Builds C++20 source strings from MIR structures.
# Follows the pattern of LlvmIRBuilder in llvm_ir_builder.spl.
# Generated code links against runtime.h (spl_ prefix functions).


# ============================================================================
# C IR Builder
# ============================================================================

class CIRBuilder:
    """Builds C++20 source code from MIR."""
    module_name: text
    lines: [text]
    indent_level: i64
    local_counter: i64
    string_literals: [text]
    string_counter: i64
    header_lines: [text]

    static fn create(name: text) -> CIRBuilder:
        CIRBuilder(
            module_name: name,
            lines: [],
            indent_level: 0,
            local_counter: 0,
            string_literals: [],
            string_counter: 0,
            header_lines: []
        )

    # === Indentation ===

    fn indent_str() -> text:
        var result = ""
        var i = 0
        while i < self.indent_level:
            result = result + "    "
            i = i + 1
        result

    me indent():
        self.indent_level = self.indent_level + 1

    me dedent():
        if self.indent_level > 0:
            self.indent_level = self.indent_level - 1

    # === Emission ===

    me emit(line: text):
        self.lines = self.lines.push(self.indent_str() + line)

    me emit_raw(line: text):
        self.lines = self.lines.push(line)

    me emit_blank():
        self.lines = self.lines.push("")

    me emit_header(line: text):
        self.header_lines = self.header_lines.push(self.indent_str() + line)

    me emit_header_raw(line: text):
        self.header_lines = self.header_lines.push(line)

    # === File Header ===

    me emit_file_header():
        self.emit_raw(r"// Generated by Simple compiler (C backend)")
        self.emit_raw(r"// Module: " + self.module_name)
        self.emit_raw(r"// Build (clang):    clang++ -std=c++20 -O2 <this>.cpp runtime.c -I runtime -o output")
        self.emit_raw(r"// Build (clang-cl): clang-cl /std:c++20 /EHsc /O2 <this>.cpp runtime.c /I runtime /Fe:output.exe")
        self.emit_raw(r"#include <cstdint>")
        self.emit_raw(r"#include <cstddef>")
        self.emit_raw(r"#include <cstdlib>")
        self.emit_raw(r"#include <cstring>")
        self.emit_raw("")
        self.emit_raw(r"extern " + "\"C\"" + r" {")
        self.emit_raw(r"#include " + "\"runtime.h\"")
        self.emit_raw(r"}")
        self.emit_raw("")
        self.emit_raw(r"// Portability macros")
        self.emit_raw(r"#if defined(_MSC_VER) && !defined(__clang__)")
        self.emit_raw(r"#define SPL_UNREACHABLE() __assume(0)")
        self.emit_raw(r"#else")
        self.emit_raw(r"#define SPL_UNREACHABLE() __builtin_unreachable()")
        self.emit_raw(r"#endif")
        self.emit_raw("")

    me emit_header_file_header():
        val guard = r"SPL_" + self.module_name.replace(".", "_").to_upper() + r"_H"
        self.emit_header_raw(r"// Generated by Simple compiler (C backend)")
        self.emit_header_raw(r"// Module: " + self.module_name + r" â€” Header")
        self.emit_header_raw(r"#ifndef " + guard)
        self.emit_header_raw(r"#define " + guard)
        self.emit_header_raw("")
        self.emit_header_raw(r"#include <cstdint>")
        self.emit_header_raw(r"#include <tuple>")
        self.emit_header_raw(r"#if defined(_WIN32) && defined(_MSC_VER) && defined(__clang__)")
        self.emit_header_raw(r"#define SPL_CLANG_CL 1")
        self.emit_header_raw(r"#else")
        self.emit_header_raw(r"#define SPL_CLANG_CL 0")
        self.emit_header_raw(r"#endif")
        self.emit_header_raw(r"#include " + "\"spl_containers.h\"")
        self.emit_header_raw("")

    me emit_impl_file_header():
        val header_name = self.module_name.replace(".", "/") + r".h"
        self.emit_raw(r"// Generated by Simple compiler (C backend)")
        self.emit_raw(r"// Module: " + self.module_name)
        self.emit_raw(r"#include " + "\"" + header_name + "\"")
        self.emit_raw("")
        self.emit_raw(r"#include <cstdint>")
        self.emit_raw(r"#include <cstddef>")
        self.emit_raw(r"#include <cstdlib>")
        self.emit_raw(r"#include <cstring>")
        self.emit_raw(r"#include <tuple>")
        self.emit_raw("")
        self.emit_raw(r"extern " + "\"C\"" + r" {")
        self.emit_raw(r"#include " + "\"runtime.h\"")
        self.emit_raw(r"}")
        self.emit_raw("")
        self.emit_raw(r"#include " + "\"spl_containers.h\"")
        self.emit_raw("")
        self.emit_raw(r"// Portability macros")
        self.emit_raw(r"#if defined(_WIN32) && defined(_MSC_VER) && defined(__clang__)")
        self.emit_raw(r"#define SPL_CLANG_CL 1")
        self.emit_raw(r"#else")
        self.emit_raw(r"#define SPL_CLANG_CL 0")
        self.emit_raw(r"#endif")
        self.emit_raw(r"#if SPL_CLANG_CL")
        self.emit_raw(r"#define SPL_UNREACHABLE() __builtin_unreachable()")
        self.emit_raw(r"#elif defined(_MSC_VER)")
        self.emit_raw(r"#define SPL_UNREACHABLE() __assume(0)")
        self.emit_raw(r"#else")
        self.emit_raw(r"#define SPL_UNREACHABLE() __builtin_unreachable()")
        self.emit_raw(r"#endif")
        self.emit_raw("")

    # === Cross-Module Includes ===

    me emit_dependency_include(dep_module_name: text):
        """Emit #include for a dependency module header."""
        val dep_header = dep_module_name.replace(".", "/") + r".h"
        self.emit_header_raw(r"#include " + "\"" + dep_header + "\"")

    # === Forward Declarations ===

    me emit_forward_decl(ret_ty: text, name: text, params: text):
        self.emit_raw(ret_ty + r" " + name + r"(" + params + r");")

    # === Function Definition ===

    me start_function(ret_ty: text, name: text, params: text):
        self.emit_raw(ret_ty + r" " + name + r"(" + params + r") {")
        self.indent()

    me end_function():
        self.dedent()
        self.emit_raw(r"}")
        self.emit_raw("")

    # === Variables ===

    me emit_local_decl(ty: text, name: text):
        self.emit(ty + r" " + name + r";")

    me emit_local_init(ty: text, name: text, value: text):
        self.emit(ty + r" " + name + r" = " + value + r";")

    me emit_assign(dest: text, value: text):
        self.emit(dest + r" = " + value + r";")

    # === Arithmetic ===

    me emit_binop(dest: text, ty: text, op: text, lhs: text, rhs: text):
        self.emit(dest + r" = (" + ty + r")(" + lhs + r" " + op + r" " + rhs + r");")

    me emit_unaryop(dest: text, ty: text, op: text, operand: text):
        self.emit(dest + r" = (" + ty + r")(" + op + operand + r");")

    # === Comparison ===

    me emit_cmp(dest: text, ty: text, op: text, lhs: text, rhs: text):
        self.emit(dest + r" = (" + ty + r")(" + lhs + r" " + op + r" " + rhs + r");")

    # === Memory ===

    me emit_alloca(dest: text, ty: text):
        self.emit(ty + r" " + dest + r";")

    me emit_load(dest: text, ty: text, ptr: text):
        self.emit(ty + r" " + dest + r" = *(" + ty + r"*)" + ptr + r";")

    me emit_store(ty: text, value: text, ptr: text):
        self.emit(r"*(" + ty + r"*)" + ptr + r" = " + value + r";")

    # === Function Calls ===

    me emit_call(dest: text?, ret_ty: text, func: text, args: text):
        if dest.?:
            self.emit(ret_ty + r" " + dest.unwrap() + r" = " + func + r"(" + args + r");")
        else:
            self.emit(func + r"(" + args + r");")

    me emit_call_indirect(dest: text?, ret_ty: text, func_ptr: text, args: text):
        if dest.?:
            self.emit(ret_ty + r" " + dest.unwrap() + r" = ((" + ret_ty + r"(*)(...))(" + func_ptr + r"))(" + args + r");")
        else:
            self.emit(r"((" + ret_ty + r"(*)(...))(" + func_ptr + r"))(" + args + r");")

    # === Control Flow ===

    me emit_return(value: text?):
        if value.?:
            self.emit(r"return " + value.unwrap() + r";")
        else:
            self.emit(r"return;")

    me emit_goto(label: text):
        self.emit(r"goto " + label + r";")

    me emit_label(name: text):
        self.dedent()
        self.emit_raw(name + r":;")
        self.indent()

    me emit_if(cond: text, then_label: text, else_label: text):
        self.emit(r"if (" + cond + r") goto " + then_label + r"; else goto " + else_label + r";")

    me emit_switch_start(value: text):
        self.emit(r"switch (" + value + r") {")
        self.indent()

    me emit_switch_case(value: text, label: text):
        self.emit(r"case " + value + r": goto " + label + r";")

    me emit_switch_default(label: text):
        self.emit(r"default: goto " + label + r";")

    me emit_switch_end():
        self.dedent()
        self.emit(r"}")

    # === Comments ===

    me emit_comment(comment: text):
        self.emit(r"// " + comment)

    # === String Literals ===

    me add_string_literal(value: text) -> text:
        val id = self.string_counter
        self.string_counter = self.string_counter + 1
        val var_name = r"_str_" + id
        self.string_literals = self.string_literals.push(
            r"static const char " + var_name + r"[] = " + "\"" + value + "\"" + r";"
        )
        var_name

    # === Fresh Local ===

    me fresh_local() -> text:
        val id = self.local_counter
        self.local_counter = self.local_counter + 1
        r"_t" + id

    # === Build Output ===

    fn build() -> text:
        var parts: [text] = []

        # String literals go near top
        if self.string_literals.len() > 0:
            parts = parts.push(r"// String constants")
            for lit in self.string_literals:
                parts = parts.push(lit)
            parts = parts.push("")

        # Main code
        for line in self.lines:
            parts = parts.push(line)

        parts.join("\n")

    fn build_header() -> text:
        var parts: [text] = []
        for line in self.header_lines:
            parts = parts.push(line)
        val guard = r"SPL_" + self.module_name.replace(".", "_").to_upper() + r"_H"
        parts = parts.push("")
        parts = parts.push(r"#endif // " + guard)
        parts.join("\n")

# ============================================================================
# Export
# ============================================================================

fn CIRBuilder__create(name: text) -> CIRBuilder:
    CIRBuilder.create(name)

export CIRBuilder
export CIRBuilder__create
