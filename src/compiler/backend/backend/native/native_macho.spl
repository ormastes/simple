# Native Backend - Mach-O Format Emission
#
# Mach-O object file emission for macOS (AArch64 and x86_64).
# Called by the main native backend dispatcher after ISel/RegAlloc/Encode.

use compiler.mir.mir_data.{MirModule}
use compiler.backend.native.mach_inst.{MachModule, EncodedFunction}
use compiler.backend.native.isel_x86_64.{isel_module}
use compiler.backend.native.isel_aarch64.{isel_module_aarch64}
use compiler.backend.native.regalloc.{regalloc_module}
use compiler.backend.native.encode_x86_64.{encode_module}
use compiler.backend.native.encode_aarch64.{encode_module_aarch64}
use compiler.backend.native.layout_solver.{solve_layout, LayoutPlan}
use compiler.backend.native.macho_writer.{MachOWriter, MachOSection, MachOReloc, MachOSymbol, macho_writer_aarch64, macho_writer_x86_64, macho_add_section, macho_add_symbol, new_macho_text_section, new_macho_const_section, new_macho_data_section, macho_section_add_reloc, new_macho_func_symbol, new_macho_extern_symbol, new_macho_local_symbol, macho_symbol_name, map_elf_reloc_to_macho_arm64, map_elf_reloc_to_macho_x86_64, write_macho64}
use compiler.backend.native.native_layout.{reorder_by_layout}

# ============================================================================
# Mach-O Compilation Entry Points
# ============================================================================

fn compile_native_macho_aarch64(module: MirModule) -> [i64]:
    # Reuse existing AArch64 pipeline: ISel -> RegAlloc -> Encode
    val mach_module = isel_module_aarch64(module)
    val allocated = regalloc_module(mach_module)
    val encoded_funcs = encode_module_aarch64(allocated)
    # Emit as Mach-O instead of ELF
    emit_macho_aarch64(encoded_funcs, allocated, module)

fn compile_native_macho_x86_64(module: MirModule) -> [i64]:
    # Reuse existing x86_64 pipeline: ISel -> RegAlloc -> Encode
    val mach_module = isel_module(module)
    val allocated = regalloc_module(mach_module)
    val encoded_funcs = encode_module(allocated)
    # Emit as Mach-O instead of ELF
    emit_macho_x86_64(encoded_funcs, allocated, module)

# ============================================================================
# Mach-O Emission - AArch64
# ============================================================================

fn emit_macho_aarch64(
    encoded_funcs: [EncodedFunction],
    module: MachModule,
    mir_module: MirModule
) -> [i64]:
    var writer = macho_writer_aarch64()

    # Layout: reorder functions
    val layout_plan = solve_layout(mir_module, nil)
    val ordered_funcs = reorder_by_layout(encoded_funcs, layout_plan)

    # Combine all function code into a single __text section
    var all_code: [i64] = []
    var func_offsets: Dict<text, i64> = {}
    var all_relocs: [MachOReloc] = []

    # Build symbol name -> index mapping
    var sym_names: [text] = []
    var sym_name_to_idx: Dict<text, i64> = {}

    # Collect data entry labels
    var rodata_offset_m = 0
    var data_label_offsets_m: Dict<text, i64> = {}
    for entry in module.data_sections:
        if entry.is_readonly:
            if not sym_name_to_idx.contains(entry.name):
                val idx = sym_names.len()
                sym_names = sym_names + [entry.name]
                sym_name_to_idx[entry.name] = idx
                data_label_offsets_m[entry.name] = rodata_offset_m
            rodata_offset_m = rodata_offset_m + entry.data.len()

    # Collect extern symbols
    for ext_sym in module.extern_symbols:
        if not sym_name_to_idx.contains(ext_sym):
            val idx = sym_names.len()
            sym_names = sym_names + [ext_sym]
            sym_name_to_idx[ext_sym] = idx

    # Collect function names
    for func in ordered_funcs:
        if not sym_name_to_idx.contains(func.name):
            val idx = sym_names.len()
            sym_names = sym_names + [func.name]
            sym_name_to_idx[func.name] = idx

    # Concatenate function code (AArch64: 4-byte instruction alignment)
    for func in ordered_funcs:
        var padding = all_code.len() % 4
        if padding != 0:
            padding = 4 - padding
        for i in 0..padding:
            all_code = all_code + [0x00]
        func_offsets[func.name] = all_code.len()

        val code_start = all_code.len()
        all_code = all_code + func.code

        # Convert relocations to Mach-O format
        for reloc in func.relocations:
            val macho_type = map_elf_reloc_to_macho_arm64(reloc.reloc_type)
            var is_pc_rel = false
            if macho_type == 2: is_pc_rel = true  # BRANCH26
            if macho_type == 3: is_pc_rel = true  # PAGE21

            var sym_idx = 0
            if sym_name_to_idx.contains(reloc.symbol_name):
                sym_idx = sym_name_to_idx[reloc.symbol_name]

            val macho_reloc = MachOReloc(
                offset: code_start + reloc.offset,
                symbol_index: sym_idx,
                reloc_type: macho_type,
                length: 2,  # 4 bytes (ARM64 instructions)
                is_pc_relative: is_pc_rel,
                is_extern: true
            )
            all_relocs = all_relocs + [macho_reloc]

    # Create __text section
    var text_section = new_macho_text_section(all_code)
    for reloc in all_relocs:
        text_section = macho_section_add_reloc(text_section, reloc)
    writer = macho_add_section(writer, text_section)

    # Section ordinal tracking (1-based)
    var next_ordinal = 2  # __text = 1

    # Create __const section for read-only data
    var rodata_bytes: [i64] = []
    for entry in module.data_sections:
        if entry.is_readonly:
            rodata_bytes = rodata_bytes + entry.data
    var const_ordinal = 0
    if rodata_bytes.len() > 0:
        writer = macho_add_section(writer, new_macho_const_section(rodata_bytes))
        const_ordinal = next_ordinal
        next_ordinal = next_ordinal + 1

    # Create __data section for mutable data
    var data_bytes: [i64] = []
    for entry in module.data_sections:
        if not entry.is_readonly:
            data_bytes = data_bytes + entry.data
    var data_ordinal = 0
    if data_bytes.len() > 0:
        writer = macho_add_section(writer, new_macho_data_section(data_bytes))
        data_ordinal = next_ordinal
        next_ordinal = next_ordinal + 1

    # Add data label symbols (local, in __const)
    for entry in module.data_sections:
        if entry.is_readonly:
            if data_label_offsets_m.contains(entry.name):
                val sym = new_macho_local_symbol(entry.name, const_ordinal, data_label_offsets_m[entry.name])
                writer = macho_add_symbol(writer, sym)

    # Add extern symbols (undefined)
    var added_extern: Dict<text, bool> = {}
    for ext_sym in module.extern_symbols:
        if not added_extern.contains(ext_sym):
            added_extern[ext_sym] = true
            writer = macho_add_symbol(writer, new_macho_extern_symbol(ext_sym))

    # Add function symbols (defined, global)
    for func in ordered_funcs:
        var offset = 0
        if func_offsets.contains(func.name):
            offset = func_offsets[func.name]
        writer = macho_add_symbol(writer, new_macho_func_symbol(func.name, 1, offset))

    write_macho64(writer)

# ============================================================================
# Mach-O Emission - x86_64
# ============================================================================

fn emit_macho_x86_64(
    encoded_funcs: [EncodedFunction],
    module: MachModule,
    mir_module: MirModule
) -> [i64]:
    var writer = macho_writer_x86_64()

    # Layout: reorder functions
    val layout_plan = solve_layout(mir_module, nil)
    val ordered_funcs = reorder_by_layout(encoded_funcs, layout_plan)

    # Combine all function code into a single __text section
    var all_code: [i64] = []
    var func_offsets: Dict<text, i64> = {}
    var all_relocs: [MachOReloc] = []

    # Build symbol name -> index mapping
    var sym_names: [text] = []
    var sym_name_to_idx: Dict<text, i64> = {}

    # Collect data entry labels
    var rodata_offset_mx = 0
    var data_label_offsets_mx: Dict<text, i64> = {}
    for entry in module.data_sections:
        if entry.is_readonly:
            if not sym_name_to_idx.contains(entry.name):
                val idx = sym_names.len()
                sym_names = sym_names + [entry.name]
                sym_name_to_idx[entry.name] = idx
                data_label_offsets_mx[entry.name] = rodata_offset_mx
            rodata_offset_mx = rodata_offset_mx + entry.data.len()

    # Collect extern symbols
    for ext_sym in module.extern_symbols:
        if not sym_name_to_idx.contains(ext_sym):
            val idx = sym_names.len()
            sym_names = sym_names + [ext_sym]
            sym_name_to_idx[ext_sym] = idx

    # Collect function names
    for func in ordered_funcs:
        if not sym_name_to_idx.contains(func.name):
            val idx = sym_names.len()
            sym_names = sym_names + [func.name]
            sym_name_to_idx[func.name] = idx

    # Concatenate function code (x86_64: 16-byte alignment)
    for func in ordered_funcs:
        var padding = all_code.len() % 16
        if padding != 0:
            padding = 16 - padding
        for i in 0..padding:
            all_code = all_code + [0xcc]  # int3 padding
        func_offsets[func.name] = all_code.len()

        val code_start = all_code.len()
        all_code = all_code + func.code

        # Convert relocations to Mach-O format
        for reloc in func.relocations:
            val macho_type = map_elf_reloc_to_macho_x86_64(reloc.reloc_type)
            var is_pc_rel = false
            if macho_type == 2: is_pc_rel = true  # BRANCH
            if macho_type == 1: is_pc_rel = true  # SIGNED

            var sym_idx = 0
            if sym_name_to_idx.contains(reloc.symbol_name):
                sym_idx = sym_name_to_idx[reloc.symbol_name]

            val macho_reloc = MachOReloc(
                offset: code_start + reloc.offset,
                symbol_index: sym_idx,
                reloc_type: macho_type,
                length: 2,  # 4 bytes
                is_pc_relative: is_pc_rel,
                is_extern: true
            )
            all_relocs = all_relocs + [macho_reloc]

    # Create __text section
    var text_section = new_macho_text_section(all_code)
    for reloc in all_relocs:
        text_section = macho_section_add_reloc(text_section, reloc)
    writer = macho_add_section(writer, text_section)

    # Section ordinal tracking (1-based)
    var next_ordinal_x = 2  # __text = 1

    # Create __const section for read-only data
    var rodata_bytes_x: [i64] = []
    for entry in module.data_sections:
        if entry.is_readonly:
            rodata_bytes_x = rodata_bytes_x + entry.data
    var const_ordinal_x = 0
    if rodata_bytes_x.len() > 0:
        writer = macho_add_section(writer, new_macho_const_section(rodata_bytes_x))
        const_ordinal_x = next_ordinal_x
        next_ordinal_x = next_ordinal_x + 1

    # Create __data section for mutable data
    var data_bytes_x: [i64] = []
    for entry in module.data_sections:
        if not entry.is_readonly:
            data_bytes_x = data_bytes_x + entry.data
    var data_ordinal_x = 0
    if data_bytes_x.len() > 0:
        writer = macho_add_section(writer, new_macho_data_section(data_bytes_x))
        data_ordinal_x = next_ordinal_x
        next_ordinal_x = next_ordinal_x + 1

    # Add data label symbols (local, in __const)
    for entry in module.data_sections:
        if entry.is_readonly:
            if data_label_offsets_mx.contains(entry.name):
                val sym = new_macho_local_symbol(entry.name, const_ordinal_x, data_label_offsets_mx[entry.name])
                writer = macho_add_symbol(writer, sym)

    # Add extern symbols (undefined)
    var added_extern_x: Dict<text, bool> = {}
    for ext_sym in module.extern_symbols:
        if not added_extern_x.contains(ext_sym):
            added_extern_x[ext_sym] = true
            writer = macho_add_symbol(writer, new_macho_extern_symbol(ext_sym))

    # Add function symbols (defined, global)
    for func in ordered_funcs:
        var offset = 0
        if func_offsets.contains(func.name):
            offset = func_offsets[func.name]
        writer = macho_add_symbol(writer, new_macho_func_symbol(func.name, 1, offset))

    write_macho64(writer)

# ============================================================================
# Exports
# ============================================================================

export compile_native_macho_aarch64, compile_native_macho_x86_64
export emit_macho_aarch64, emit_macho_x86_64
