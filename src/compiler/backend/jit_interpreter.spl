# JIT-Enabled Interpreter Backend - Hybrid Interpreter with JIT Compilation
#
# This module implements a hybrid interpreter that can:
# 1. Use JIT compilation (Cranelift/LLVM) for hot functions
# 2. Fall back to tree-walking for complex/dynamic code
# 3. Share backend infrastructure with the compiler
#
# Architecture:
# - Compile HIR → MIR → native code (via ExecutionManager)
# - Execute via JIT for performance
# - Fall back to tree-walking when needed

use compiler.hir.*
use compiler.mir.*
use backend_types.*
use backend.env.{EvalContext, Environment}
use backend.interpreter.InterpreterBackendImpl
use compiler.execution.mod.{LocalExecutionManager, get_jit_backend}
use compiler.mir_lowering.MirLowering

# ============================================================================
# JIT Interpreter Configuration
# ============================================================================

enum JitMode:
    """JIT compilation mode."""
    Auto                    # Auto-select (JIT when possible, interpret fallback)
    AlwaysJit              # Always use JIT (error if not possible)
    AlwaysInterpret        # Never use JIT (pure tree-walking)
    Hybrid                 # Smart hybrid (JIT hot paths, interpret cold)

struct JitInterpreterConfig:
    """Configuration for JIT-enabled interpreter."""
    mode: JitMode
    backend: text          # "auto", "cranelift", "llvm"
    jit_threshold: i32     # Function call count before JIT compilation
    verbose: bool

impl JitInterpreterConfig:
    static fn default() -> JitInterpreterConfig:
        """Create default configuration (auto mode, Cranelift backend)."""
        JitInterpreterConfig(
            mode: JitMode.Auto,
            backend: "auto",
            jit_threshold: 10,
            verbose: false
        )

    static fn auto_jit() -> JitInterpreterConfig:
        """Auto JIT mode - compile when possible, interpret otherwise."""
        JitInterpreterConfig(
            mode: JitMode.Auto,
            backend: "auto",
            jit_threshold: 1,
            verbose: false
        )

    static fn always_jit() -> JitInterpreterConfig:
        """Always JIT - error if compilation fails."""
        JitInterpreterConfig(
            mode: JitMode.AlwaysJit,
            backend: "auto",
            jit_threshold: 0,
            verbose: false
        )

    static fn interpret_only() -> JitInterpreterConfig:
        """Never JIT - pure tree-walking interpreter."""
        JitInterpreterConfig(
            mode: JitMode.AlwaysInterpret,
            backend: "auto",
            jit_threshold: 999999,
            verbose: false
        )

# ============================================================================
# JIT Interpreter Backend Implementation
# ============================================================================

struct JitInterpreterBackend:
    """Hybrid interpreter backend with JIT compilation.

    Strategy:
    1. Start with tree-walking interpretation
    2. Count function calls
    3. When threshold reached, JIT compile the function
    4. Subsequent calls use JIT-compiled code
    5. Fall back to interpretation if JIT fails
    """
    config: JitInterpreterConfig
    exec_manager: LocalExecutionManager?
    call_counts: Dict<text, i32>      # Function name → call count
    jit_compiled: Set<text>            # Functions that are JIT-compiled

impl JitInterpreterBackend:
    static fn new(config: JitInterpreterConfig) -> JitInterpreterBackend:
        """Create new JIT interpreter backend."""
        JitInterpreterBackend(
            config: config,
            exec_manager: nil,
            call_counts: {},
            jit_compiled: {}
        )

    static fn default() -> JitInterpreterBackend:
        """Create with default configuration."""
        JitInterpreterBackend.new(JitInterpreterConfig.default())

    me ensure_exec_manager() -> Result<LocalExecutionManager, BackendError>:
        """Ensure execution manager is initialized."""
        if self.exec_manager.?:
            Ok(self.exec_manager.unwrap())
        else:
            # Create execution manager based on backend config
            val em = match self.config.backend:
                case "cranelift": LocalExecutionManager.cranelift()
                case "llvm": LocalExecutionManager.llvm()
                case "auto": LocalExecutionManager.auto_select()
                case _: LocalExecutionManager.auto_select()

            self.exec_manager = Some(em)
            Ok(em)

    me should_jit_compile(fn_name: text) -> bool:
        """Check if function should be JIT-compiled."""
        match self.config.mode:
            case AlwaysInterpret:
                false
            case AlwaysJit:
                true
            case Auto, Hybrid:
                # Check call count threshold
                val count = self.call_counts[fn_name] ?? 0
                count >= self.config.jit_threshold

    me record_call(fn_name: text):
        """Record a function call for JIT threshold tracking."""
        val count = self.call_counts[fn_name] ?? 0
        self.call_counts[fn_name] = count + 1

        # Check if we should JIT compile now
        if self.should_jit_compile(fn_name) and not self.jit_compiled.contains(fn_name):
            if self.config.verbose:
                print "[jit] Function {fn_name} reached threshold, will JIT compile"

    me try_jit_compile(fn_: HirFunction, module: HirModule) -> Result<(), BackendError>:
        """Try to JIT compile a function.

        Full implementation requires:
        1. MIR lowering (✅ available via MirLowering)
        2. MIR serialization (⚠️ placeholder - needs implementation)
        3. ExecutionManager compilation (✅ available via SFFI)

        For now, this is a framework that will work once MIR serialization is added.
        """
        if self.jit_compiled.contains(fn_.name):
            return Ok(())  # Already compiled

        if not self.should_jit_compile(fn_.name):
            return Ok(())  # Not ready yet

        if self.config.verbose:
            print "[jit] Compiling function: {fn_.name}"

        # Step 1: Lower HIR to MIR
        var lowering = MirLowering.new(module.symbols)
        val mir_fn = lowering.lower_function(fn_)

        if lowering.errors.len() > 0:
            val err_msg = lowering.errors[0].message
            if self.config.mode == JitMode.AlwaysJit:
                return Err(BackendError.compile_error("MIR lowering failed: {err_msg}", Some(fn_.span)))
            else:
                if self.config.verbose:
                    print "[jit] MIR lowering failed for {fn_.name}, will interpret: {err_msg}"
                return Ok(())

        # Step 2: Serialize MIR to string
        # NOTE: This is the missing piece - MIR serialization
        # For now, we skip JIT compilation in Auto/Hybrid mode
        # TODO: Implement serialize_mir_to_json(mir_fn) or serialize_mir_to_binary(mir_fn)
        if self.config.mode == JitMode.AlwaysJit:
            return Err(BackendError.not_implemented(
                "MIR serialization not yet implemented - cannot JIT compile"
            ))
        else:
            if self.config.verbose:
                print "[jit] MIR serialization not yet implemented, will interpret: {fn_.name}"
            return Ok(())

        # Step 3: Get execution manager and compile
        # (This code is ready but unreachable until MIR serialization is implemented)
        # val mir_data = serialize_mir_to_json(mir_fn)  # TODO
        # val em = self.ensure_exec_manager()?
        # val compile_result = em.compile(mir_data)
        #
        # match compile_result:
        #     case Ok(_):
        #         self.jit_compiled = self.jit_compiled.insert(fn_.name)
        #         if self.config.verbose:
        #             print "[jit] Successfully compiled: {fn_.name}"
        #         Ok(())
        #     case Err(msg):
        #         if self.config.mode == JitMode.AlwaysJit:
        #             Err(BackendError.compile_error("JIT compilation failed: {msg}", Some(fn_.span)))
        #         else:
        #             # In Auto/Hybrid mode, just log and continue with interpretation
        #             if self.config.verbose:
        #                 print "[jit] Compilation failed for {fn_.name}, will interpret: {msg}"
        #             Ok(())

    me try_jit_execute(fn_name: text, args: [Value]) -> Result<Value, BackendError>?:
        """Try to execute via JIT. Returns None if not JIT-compiled.

        Full implementation requires:
        1. Type conversion Simple Value → FFI args (⚠️ partial - only i64)
        2. FFI execution (✅ available via ExecutionManager)
        3. Type conversion FFI result → Simple Value (⚠️ partial - only i64)

        Current limitation: Only supports i64 arguments and return values.
        TODO: Add support for all Simple types (structs, arrays, strings, etc.)
        """
        if not self.jit_compiled.contains(fn_name):
            return nil

        # Execution manager available?
        if not self.exec_manager.?:
            return nil

        val em = self.exec_manager.unwrap()

        if not em.has_function(fn_name):
            return nil

        # Convert args to i64 array
        # NOTE: This is a simplified implementation
        # TODO: Implement full type conversion for all Simple types
        var arg_vals: [i64] = []
        for arg in args:
            match arg:
                case Int(i):
                    arg_vals = arg_vals.push(i)
                case Float(f):
                    # TODO: Pass floats as i64 bit pattern
                    arg_vals = arg_vals.push(f.to_i64())
                case Bool(b):
                    arg_vals = arg_vals.push(if b: 1 else: 0)
                case _:
                    # Can't handle complex types via JIT yet
                    # Need to implement struct/array marshaling
                    return nil

        # Execute via JIT
        val exec_result = em.execute(fn_name, arg_vals)
        match exec_result:
            case Ok(result_val):
                # TODO: Determine actual return type from function signature
                # For now, assume i64
                Some(Ok(Value.int(result_val)))
            case Err(msg):
                Some(Err(BackendError.runtime_error("JIT execution failed: {msg}", nil)))

impl Backend for JitInterpreterBackend:
    fn name() -> text:
        "jit-interpreter"

    fn kind() -> BackendKind:
        match self.config.mode:
            case AlwaysJit: BackendKind.CraneliftJit
            case _: BackendKind.Interpreter

    fn process_module(module: HirModule) -> Result<BackendResult, BackendError>:
        # Create evaluation context
        val env = Environment.new()
        val ctx = EvalContext(env: env, module: module, backend: self)

        # Register functions
        var main_fn: HirFunction? = nil
        for symbol in module.functions.keys():
            val fn_ = module.functions[symbol]
            ctx.env.define_global(symbol, Value.Function(FunctionValue(symbol: symbol, name: fn_.name)))
            if fn_.name == "main":
                main_fn = Some(fn_)

        # Try to JIT compile main function if configured
        if main_fn.? and self.should_jit_compile("main"):
            self.try_jit_compile(main_fn.unwrap(), module)?

        # Execute main
        if main_fn.?:
            val result = self.call_hir_function(main_fn.unwrap(), [], ctx, module)?
            Ok(BackendResult.Value(result))
        else:
            Ok(BackendResult.Unit)

    fn process_function(fn_: HirFunction) -> Result<BackendResult, BackendError>:
        Ok(BackendResult.Unit)

    fn process_class(class_: HirClass) -> Result<BackendResult, BackendError>:
        Ok(BackendResult.Unit)

    fn process_struct(struct_: HirStruct) -> Result<BackendResult, BackendError>:
        Ok(BackendResult.Unit)

    fn process_enum(enum_: HirEnum) -> Result<BackendResult, BackendError>:
        Ok(BackendResult.Unit)

    fn process_trait(trait_: HirTrait) -> Result<BackendResult, BackendError>:
        Ok(BackendResult.Unit)

    fn process_impl(impl_: HirImpl) -> Result<BackendResult, BackendError>:
        Ok(BackendResult.Unit)

    fn eval_expr(expr: HirExpr, ctx: EvalContext) -> Result<Value, BackendError>:
        # Delegate to tree-walking interpreter for expressions
        # (JIT is used for function-level compilation)
        InterpreterBackendImpl().eval_expr(expr, ctx)

    fn exec_stmt(stmt: HirStmt, ctx: EvalContext) -> Result<(), BackendError>:
        # Delegate to tree-walking interpreter for statements
        InterpreterBackendImpl().exec_stmt(stmt, ctx)

    fn is_allowed(expr: HirExpr) -> bool:
        true

    fn is_allowed_stmt(stmt: HirStmt) -> bool:
        true

impl JitInterpreterBackend:
    me call_hir_function(fn_: HirFunction, args: [Value], ctx: EvalContext, module: HirModule) -> Result<Value, BackendError>:
        """Call a HIR function - try JIT first, fall back to interpretation."""
        # Record call for threshold tracking
        self.record_call(fn_.name)

        # Try JIT execution first
        val jit_result = self.try_jit_execute(fn_.name, args)
        if jit_result.?:
            return jit_result.unwrap()

        # Try to JIT compile if threshold reached
        if self.should_jit_compile(fn_.name):
            self.try_jit_compile(fn_, module)?

            # Try JIT execution again
            val jit_result2 = self.try_jit_execute(fn_.name, args)
            if jit_result2.?:
                return jit_result2.unwrap()

        # Fall back to tree-walking interpretation
        if self.config.verbose:
            print "[jit] Interpreting function: {fn_.name}"

        InterpreterBackendImpl().call_hir_function(fn_, args, ctx)

# ============================================================================
# Exports
# ============================================================================

export JitMode, JitInterpreterConfig, JitInterpreterBackend
