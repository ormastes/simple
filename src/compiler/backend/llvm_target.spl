# LLVM Target - Triple and Configuration
#
# Target triple specification and CPU configuration for LLVM compilation.
# Split from llvm_backend.spl for modularity.

use compiler.backend.backend_api.*

# ============================================================================
# LLVM Target Triple
# ============================================================================

struct LlvmTargetTriple:
    """LLVM target triple specification."""
    arch: text
    vendor: text
    os: text
    env: text?

impl LlvmTargetTriple:
    static fn from_target(target: CodegenTarget) -> LlvmTargetTriple:
        """Create target triple from codegen target (hosted mode with OS)."""
        LlvmTargetTriple__from_target_with_mode(target, bare_metal: false)

    static fn from_target_baremetal(target: CodegenTarget) -> LlvmTargetTriple:
        """Create target triple for bare-metal (no OS)."""
        LlvmTargetTriple__from_target_with_mode(target, bare_metal: true)

    static fn from_target_with_mode(target: CodegenTarget, bare_metal: bool) -> LlvmTargetTriple:
        """Create target triple with OS or bare-metal mode."""
        val os = if bare_metal: "none" else: "linux"
        val env = if bare_metal: nil else: Some("gnu")

        match target:
            case X86_64:
                LlvmTargetTriple(arch: "x86_64", vendor: "unknown", os: os, env: env)
            case AArch64:
                LlvmTargetTriple(arch: "aarch64", vendor: "unknown", os: os, env: env)
            case Riscv64:
                LlvmTargetTriple(arch: "riscv64", vendor: "unknown", os: os, env: env)
            case X86:
                LlvmTargetTriple(arch: "i686", vendor: "unknown", os: os, env: env)
            case Arm:
                val arm_env = if bare_metal: Some("eabi") else: Some("gnueabihf")
                LlvmTargetTriple(arch: "armv7", vendor: "unknown", os: os, env: arm_env)
            case Riscv32:
                LlvmTargetTriple(arch: "riscv32", vendor: "unknown", os: os, env: env)
            case Wasm32:
                LlvmTargetTriple(arch: "wasm32", vendor: "unknown", os: "wasi", env: nil)
            case Wasm64:
                LlvmTargetTriple(arch: "wasm64", vendor: "unknown", os: "wasi", env: nil)
            case Host:
                # Would detect host at runtime - assume hosted for now
                LlvmTargetTriple(arch: "x86_64", vendor: "unknown", os: os, env: env)

    fn to_text() -> text:
        var result = "{self.arch}-{self.vendor}-{self.os}"
        if self.env.?:
            result = "{result}-{self.env.unwrap()}"
        result

# ============================================================================
# LLVM Target Configuration (CPU + Features)
# ============================================================================

struct LlvmTargetConfig:
    """
    Complete LLVM target configuration including CPU model and features.

    The CPU model determines which instruction sets are available. For x86_64,
    we default to x86-64-v3 (Haswell, 2015+) which includes AVX2, FMA, BMI2
    for significantly better performance on modern CPUs.
    """
    triple: LlvmTargetTriple
    cpu: text              # Target CPU (e.g., "x86-64-v3", "haswell", "generic")
    features: [text]       # Additional features (e.g., ["+avx2", "+fma"])

impl LlvmTargetConfig:
    static fn for_target(target: CodegenTarget, cpu_override: text?) -> LlvmTargetConfig:
        """Create config for hosted target (with OS)."""
        LlvmTargetConfig__for_target_with_mode(target, cpu_override, bare_metal: false)

    static fn for_target_baremetal(target: CodegenTarget, cpu_override: text?) -> LlvmTargetConfig:
        """Create config for bare-metal target (no OS)."""
        LlvmTargetConfig__for_target_with_mode(target, cpu_override, bare_metal: true)

    static fn for_target_with_mode(target: CodegenTarget, cpu_override: text?, bare_metal: bool) -> LlvmTargetConfig:
        """
        Create target configuration with optimal CPU selection.

        Defaults:
        - x86_64: x86-64-v3 (Haswell 2015+) → AVX2, FMA, BMI2 for 2-3x SIMD speedup
        - AArch64: cortex-a53 (common baseline) → NEON support
        - RISC-V 64: generic-rv64 with IMAFDC extensions
        - i686: i686 with SSE2 (conservative 32-bit baseline)

        Override with cpu_override parameter for compatibility builds.

        Bare-metal mode uses -none OS (no stdlib, custom startup).
        """
        val triple = LlvmTargetTriple__from_target_with_mode(target, bare_metal)

        # Check for user override first
        if cpu_override.?:
            return LlvmTargetConfig(
                triple: triple,
                cpu: cpu_override.unwrap(),
                features: []  # Auto-detected from CPU
            )

        # Auto-select optimal CPU for target
        match target:
            case X86_64:
                LlvmTargetConfig(
                    triple: triple,
                    cpu: "x86-64-v3",
                    features: []
                )

            case AArch64:
                LlvmTargetConfig(
                    triple: triple,
                    cpu: "cortex-a53",
                    features: ["+neon", "+fp-armv8"]
                )

            case Riscv64:
                LlvmTargetConfig(
                    triple: triple,
                    cpu: "generic-rv64",
                    features: ["+m", "+a", "+f", "+d", "+c"]
                )

            case X86:  # i686 32-bit
                LlvmTargetConfig(
                    triple: triple,
                    cpu: "i686",
                    features: ["+sse2"]
                )

            case Arm:  # ARMv7 32-bit
                LlvmTargetConfig(
                    triple: triple,
                    cpu: "cortex-a7",
                    features: ["+neon", "+vfp4"]
                )

            case Riscv32:
                LlvmTargetConfig(
                    triple: triple,
                    cpu: "generic-rv32",
                    features: ["+m", "+a", "+f", "+d", "+c"]
                )

            case Wasm32 | Wasm64:
                LlvmTargetConfig(
                    triple: triple,
                    cpu: "generic",
                    features: []
                )

            case Host:
                LlvmTargetConfig(
                    triple: triple,
                    cpu: "x86-64-v3",
                    features: []
                )

    static fn compatibility_build(target: CodegenTarget) -> LlvmTargetConfig:
        """
        Create compatibility build configuration for older hardware.

        Use this for maximum compatibility at the cost of performance:
        - x86_64: x86-64 baseline (2003+, no AVX)
        - Others: Conservative baselines
        """
        match target:
            case X86_64:
                LlvmTargetConfig__for_target(target, Some("x86-64"))
            case AArch64:
                LlvmTargetConfig__for_target(target, Some("generic"))
            case _:
                LlvmTargetConfig__for_target(target, nil)

    fn to_cpu_string() -> text:
        """Get CPU string for LLVM target machine."""
        self.cpu

    fn to_feature_string() -> text:
        """Get feature string for LLVM target machine (e.g., '+avx2,+fma')."""
        if self.features.length == 0:
            ""
        else:
            self.features.join(",")

    fn supports_avx2() -> bool:
        """Check if this configuration supports AVX2 (256-bit SIMD)."""
        (self.cpu == "x86-64-v3" or
        self.cpu == "x86-64-v4" or
        self.cpu == "haswell" or
        self.cpu == "skylake" or
        self.features.contains("+avx2"))

    fn supports_fma() -> bool:
        """Check if this configuration supports FMA (fused multiply-add)."""
        (self.cpu == "x86-64-v3" or
        self.cpu == "x86-64-v4" or
        self.features.contains("+fma"))

# Desugared static methods
fn LlvmTargetTriple__from_target(target: CodegenTarget) -> LlvmTargetTriple:
    LlvmTargetTriple__from_target(target)

fn LlvmTargetTriple__from_target_baremetal(target: CodegenTarget) -> LlvmTargetTriple:
    LlvmTargetTriple__from_target_baremetal(target)

fn LlvmTargetTriple__from_target_with_mode(target: CodegenTarget, bare_metal: bool) -> LlvmTargetTriple:
    LlvmTargetTriple__from_target_with_mode(target, bare_metal)

fn LlvmTargetConfig__for_target(target: CodegenTarget, cpu_override: text?) -> LlvmTargetConfig:
    LlvmTargetConfig__for_target(target, cpu_override)

fn LlvmTargetConfig__for_target_baremetal(target: CodegenTarget, cpu_override: text?) -> LlvmTargetConfig:
    LlvmTargetConfig__for_target_baremetal(target, cpu_override)

fn LlvmTargetConfig__for_target_with_mode(target: CodegenTarget, cpu_override: text?, bare_metal: bool) -> LlvmTargetConfig:
    LlvmTargetConfig__for_target_with_mode(target, cpu_override, bare_metal)

fn LlvmTargetConfig__compatibility_build(target: CodegenTarget) -> LlvmTargetConfig:
    LlvmTargetConfig__compatibility_build(target)

export LlvmTargetTriple, LlvmTargetConfig
export LlvmTargetTriple__from_target, LlvmTargetTriple__from_target_baremetal, LlvmTargetTriple__from_target_with_mode
export LlvmTargetConfig__for_target, LlvmTargetConfig__for_target_baremetal, LlvmTargetConfig__for_target_with_mode
export LlvmTargetConfig__compatibility_build
