# WAT Code Generation - MIR to WebAssembly Text Format
#
# Translates MIR instructions to WAT (WebAssembly Text Format).
# Following the MirToLlvm pattern from llvm_ir_builder.spl.
#
# Each MIR LocalId maps to a WASM local variable ($lN).
# MIR basic blocks are translated to WASM structured control flow.
#
# Usage:
#   var codegen = MirToWat__create("my_module")
#   val wat = codegen.translate_module(mir_module)

use compiler.mir_data.*
use compiler.backend.wasm_backend.{WatBuilder, WasmType, WasmTarget, WatBuilder__create}
use compiler.backend.wasm_type_mapper.{WasmTypeMapper, WasmTypeMapper__create_wasm32}
use compiler.backend.wasm.wasm_memory.{WasmMemoryManager, WasmMemoryManager__create}
use compiler.backend.wasm.wasm_runtime.{emit_all_wasm_imports}
use compiler.backend.wasm.wasm_control_flow.{WasmControlFlow, WasmControlFlow__create}
use std.text.{NL}

# ============================================================================
# MIR to WAT Translator
# ============================================================================

class MirToWat:
    """Translates MIR modules to WAT (WebAssembly Text Format).

    Handles:
    - Function translation with local variable mapping
    - Instruction translation for all MIR instruction categories
    - String constant collection and data segment emission
    - Control flow structuring
    """
    module_name: text
    type_mapper: WasmTypeMapper
    memory: WasmMemoryManager
    control_flow: WasmControlFlow
    use_wasi: bool
    local_counter: i64

    static fn create(module_name: text) -> MirToWat:
        """Create translator for wasm32-wasi target."""
        MirToWat(
            module_name: module_name,
            type_mapper: WasmTypeMapper__create_wasm32(),
            memory: WasmMemoryManager__create(),
            control_flow: WasmControlFlow__create(),
            use_wasi: true,
            local_counter: 0
        )

    static fn create_standalone(module_name: text) -> MirToWat:
        """Create translator for standalone wasm32 (no WASI)."""
        MirToWat(
            module_name: module_name,
            type_mapper: WasmTypeMapper__create_wasm32(),
            memory: WasmMemoryManager__create(),
            control_flow: WasmControlFlow__create(),
            use_wasi: false,
            local_counter: 0
        )

    me translate_module(module: MirModule) -> text:
        """Translate a complete MIR module to WAT text."""
        var builder = WatBuilder__create()
        builder.begin_module(self.module_name)

        # Emit imports
        emit_all_wasm_imports(builder, self.use_wasi)

        # First pass: collect string constants from all functions
        for func in module.functions:
            self.collect_strings(func)

        # Finalize memory layout
        self.memory.finalize()

        # Emit memory and globals
        self.memory.emit_memory_declaration(builder)
        self.memory.emit_globals(builder)

        # Emit data sections (string constants)
        self.memory.emit_data_sections(builder)

        # Emit bump allocator helper
        self.memory.emit_bump_alloc(builder)

        # Translate functions
        for func in module.functions:
            if not func.is_extern:
                self.translate_function(builder, func)

        # Export _start if present
        for func in module.functions:
            if func.name == "_start" or func.name == "__simple_main":
                builder.emit("(export \"{func.name}\" (func ${func.name}))")

        builder.end_module()
        builder.build()

    me collect_strings(func: MirFunction):
        """Collect string constants from a function for data segments."""
        for block in func.body.blocks:
            for inst in block.instructions:
                match inst.kind:
                    case Const(dest, value, type_):
                        match value:
                            case Str(s):
                                self.memory.add_string(s)
                            case _:
                                ()
                    case _:
                        ()

    me translate_function(builder: WatBuilder, func: MirFunction):
        """Translate a single MIR function to WAT."""
        # Build parameter and result types
        var param_types: [WasmType] = []
        var param_names: [text] = []
        for local in func.body.locals:
            if local.kind == MirLocalKind.Arg:
                val wasm_ty = self.mir_type_to_wasm_type(local.ty)
                param_types = param_types.push(wasm_ty)
                param_names = param_names.push(local.name)

        var result_types: [WasmType] = []
        if func.body.return_ty.kind != MirTypeKind.Unit:
            result_types = result_types.push(self.mir_type_to_wasm_type(func.body.return_ty))

        # Emit function header
        var param_str = ""
        for i in 0..param_types.len():
            val name = param_names[i]
            val ty = param_types[i]
            param_str = param_str + " (param ${name} {ty.to_text()})"

        var result_str = ""
        for ty in result_types:
            result_str = result_str + " (result {ty.to_text()})"

        builder.emit("(func ${func.name}{param_str}{result_str}")
        builder.indent_level = builder.indent_level + 1

        # Emit local variables (non-arg locals)
        for local in func.body.locals:
            if local.kind != MirLocalKind.Arg:
                val wasm_ty = self.mir_type_to_wasm_type(local.ty)
                builder.emit("(local ${local.name} {wasm_ty.to_text()})")

        # Translate basic blocks
        for block in func.body.blocks:
            self.translate_block(builder, block)

        builder.indent_level = builder.indent_level - 1
        builder.emit(")")

    me translate_block(builder: WatBuilder, block: MirBlock):
        """Translate a basic block's instructions."""
        # Emit block label as comment
        if block.label.?:
            builder.emit(";; block: {block.label.unwrap()}")

        # Translate instructions
        for inst in block.instructions:
            self.translate_instruction(builder, inst)

        # Translate terminator
        self.translate_terminator(builder, block.terminator)

    me translate_instruction(builder: WatBuilder, inst: MirInst):
        """Translate a single MIR instruction to WAT."""
        match inst.kind:
            # Constants
            case Const(dest, value, type_):
                self.translate_const(builder, dest, value, type_)

            # Moves and copies
            case Copy(dest, src):
                builder.emit_local_named_get("_l{src.id}")
                builder.emit_local_named_set("_l{dest.id}")

            case Move(dest, src):
                builder.emit_local_named_get("_l{src.id}")
                builder.emit_local_named_set("_l{dest.id}")

            # Binary operations
            case BinOp(dest, op, left, right):
                self.translate_binop(builder, dest, op, left, right)

            # Unary operations
            case UnaryOp(dest, op, operand):
                self.translate_unaryop(builder, dest, op, operand)

            # Function calls
            case Call(dest, func_op, args):
                self.translate_call(builder, dest, func_op, args)

            # Memory operations
            case Alloc(dest, type_):
                val size = self.type_mapper.size_of(type_)
                builder.emit("i32.const {size}")
                builder.emit("call $__wasm_alloc")
                builder.emit_local_named_set("_l{dest.id}")

            case Load(dest, ptr):
                self.emit_operand(builder, ptr)
                builder.emit("i32.load offset=0 align=4")
                builder.emit_local_named_set("_l{dest.id}")

            case Store(ptr, value):
                self.emit_operand(builder, ptr)
                self.emit_operand(builder, value)
                builder.emit("i32.store offset=0 align=4")

            # Debug/Nop
            case Nop:
                builder.emit_nop()

            case DebugValue(local, name):
                builder.emit(";; debug: {name} = _l{local.id}")

            case _:
                builder.emit(";; TODO: unhandled instruction")

    me translate_const(builder: WatBuilder, dest: LocalId, value: MirConstValue, type_: MirType):
        """Translate a constant value."""
        match value:
            case Int(n):
                match type_.kind:
                    case I32:
                        builder.emit("i32.const {n}")
                    case _:
                        builder.emit("i64.const {n}")
                builder.emit_local_named_set("_l{dest.id}")

            case Float(f):
                builder.emit("f64.const {f}")
                builder.emit_local_named_set("_l{dest.id}")

            case Bool(b):
                val val_int = if b: 1 else: 0
                builder.emit("i32.const {val_int}")
                builder.emit_local_named_set("_l{dest.id}")

            case Str(s):
                val offset = self.memory.add_string(s)
                builder.emit("i32.const {offset}")
                builder.emit_local_named_set("_l{dest.id}")

            case Unit:
                ()  # No value to emit

            case Nil:
                builder.emit("i32.const 0")
                builder.emit_local_named_set("_l{dest.id}")

            case _:
                builder.emit(";; TODO: unhandled constant type")

    me translate_binop(builder: WatBuilder, dest: LocalId, op: MirBinOp, left: MirOperand, right: MirOperand):
        """Translate a binary operation."""
        self.emit_operand(builder, left)
        self.emit_operand(builder, right)

        match op:
            case Add: builder.emit("i64.add")
            case Sub: builder.emit("i64.sub")
            case Mul: builder.emit("i64.mul")
            case Div: builder.emit("i64.div_s")
            case Rem: builder.emit("i64.rem_s")
            case Eq: builder.emit("i64.eq")
            case Ne: builder.emit("i64.ne")
            case Lt: builder.emit("i64.lt_s")
            case Le: builder.emit("i64.le_s")
            case Gt: builder.emit("i64.gt_s")
            case Ge: builder.emit("i64.ge_s")
            case And: builder.emit("i32.and")
            case Or: builder.emit("i32.or")
            case Xor: builder.emit("i32.xor")
            case Shl: builder.emit("i64.shl")
            case Shr: builder.emit("i64.shr_s")
            case BitAnd: builder.emit("i64.and")
            case BitOr: builder.emit("i64.or")
            case BitXor: builder.emit("i64.xor")
            case FAdd: builder.emit("f64.add")
            case FSub: builder.emit("f64.sub")
            case FMul: builder.emit("f64.mul")
            case FDiv: builder.emit("f64.div")
            case FEq: builder.emit("f64.eq")
            case FNe: builder.emit("f64.ne")
            case FLt: builder.emit("f64.lt")
            case FLe: builder.emit("f64.le")
            case FGt: builder.emit("f64.gt")
            case FGe: builder.emit("f64.ge")
            case _:
                builder.emit(";; TODO: unhandled binop")

        builder.emit_local_named_set("_l{dest.id}")

    me translate_unaryop(builder: WatBuilder, dest: LocalId, op: MirUnaryOp, operand: MirOperand):
        """Translate a unary operation."""
        match op:
            case Neg:
                builder.emit("i64.const 0")
                self.emit_operand(builder, operand)
                builder.emit("i64.sub")
            case Not:
                self.emit_operand(builder, operand)
                builder.emit("i32.eqz")
            case FNeg:
                self.emit_operand(builder, operand)
                builder.emit("f64.neg")
            case BitNot:
                self.emit_operand(builder, operand)
                builder.emit("i64.const -1")
                builder.emit("i64.xor")
            case _:
                builder.emit(";; TODO: unhandled unaryop")

        builder.emit_local_named_set("_l{dest.id}")

    me translate_call(builder: WatBuilder, dest: LocalId?, func_op: MirOperand, args: [MirOperand]):
        """Translate a function call."""
        # Push arguments
        for arg in args:
            self.emit_operand(builder, arg)

        # Emit call
        match func_op:
            case Constant(name):
                builder.emit("call ${name}")
            case _:
                builder.emit(";; TODO: indirect call")

        # Store result if dest exists
        if dest.?:
            builder.emit_local_named_set("_l{dest.unwrap().id}")

    me translate_terminator(builder: WatBuilder, term: MirTerminator):
        """Translate a block terminator."""
        match term.kind:
            case Return(value):
                if value.?:
                    self.emit_operand(builder, value.unwrap())
                builder.emit_return()

            case Goto(target):
                builder.emit(";; goto block {target}")

            case CondBranch(cond, then_target, else_target):
                self.emit_operand(builder, cond)
                builder.emit(";; br_if then={then_target} else={else_target}")

            case Unreachable:
                builder.emit_unreachable()

            case _:
                builder.emit(";; TODO: unhandled terminator")

    me emit_operand(builder: WatBuilder, operand: MirOperand):
        """Emit a MIR operand (push value onto stack)."""
        match operand:
            case Use(local_id):
                builder.emit_local_named_get("_l{local_id.id}")
            case Constant(value):
                builder.emit(";; const operand: {value}")
            case _:
                builder.emit(";; TODO: unhandled operand")

    fn mir_type_to_wasm_type(ty: MirType) -> WasmType:
        """Map MIR type to WASM type."""
        val type_str = self.type_mapper.map_type(ty)
        match type_str:
            case "i64": WasmType.I64
            case "i32": WasmType.I32
            case "f64": WasmType.F64
            case "f32": WasmType.F32
            case _: WasmType.I32

# ============================================================================
# Desugared static methods
# ============================================================================

fn MirToWat__create(module_name: text) -> MirToWat:
    MirToWat.create(module_name)

fn MirToWat__create_standalone(module_name: text) -> MirToWat:
    MirToWat.create_standalone(module_name)

# ============================================================================
# Exports
# ============================================================================

export MirToWat, MirToWat__create, MirToWat__create_standalone
