# Lean Verification Backend
#
# Exports Simple programs to Lean 4 for formal verification.
# Enables proving properties about code correctness, memory safety,
# and functional equivalence.
#
# Features:
# - Type translation to Lean types
# - Function export with contracts
# - Invariant generation
# - Proof obligation extraction
#
# Usage:
#   val backend = LeanBackend.create(VerificationLevel.Full)
#   val result = backend.export_module(mir_module)
#   result.write_to_file("module.lean")

use compiler.mir_data.*
use compiler.backend.backend_api.*

# ============================================================================
# Verification Level
# ============================================================================

enum VerificationLevel:
    """Level of verification detail to generate."""
    Minimal     # Just type signatures
    Contracts   # Pre/post conditions
    Full        # Full specifications with proofs
    Memory      # Memory safety proofs
    Effects     # Effect system verification

impl VerificationLevel:
    fn to_text() -> text:
        match self:
            case Minimal: "minimal"
            case Contracts: "contracts"
            case Full: "full"
            case Memory: "memory"
            case Effects: "effects"

    fn includes_contracts() -> bool:
        match self:
            case Minimal: false
            case _: true

    fn includes_proofs() -> bool:
        match self:
            case Full | Memory | Effects: true
            case _: false

# ============================================================================
# Lean Type Translation
# ============================================================================

fn mir_type_to_lean(ty: MirType) -> text:
    """Convert MIR type to Lean 4 type."""
    match ty.kind:
        case I64: "Int"
        case I32: "Int32"
        case I16: "UInt16"
        case I8: "UInt8"
        case F64: "Float"
        case F32: "Float"
        case Bool: "Bool"
        case Unit: "Unit"
        case Ptr(inner, _):
            "Ptr ({mir_type_to_lean(inner)})"
        case Array(elem, size):
            "Array ({mir_type_to_lean(elem)}) {size}"
        case Struct(id):
            "Struct{id}"
        case Tuple(elems):
            val elem_types = elems.map(\e: mir_type_to_lean(e)).join(" × ")
            "({elem_types})"
        case Option(inner):
            "Option ({mir_type_to_lean(inner)})"
        case Result(ok, err):
            "Except ({mir_type_to_lean(err)}) ({mir_type_to_lean(ok)})"
        case _: "Any"

# ============================================================================
# Lean Code Builder
# ============================================================================

class LeanBuilder:
    """Builds Lean 4 source code."""
    lines: [text]
    indent_level: i64
    imports: [text]

    static fn create() -> LeanBuilder:
        LeanBuilder(
            lines: [],
            indent_level: 0,
            imports: []
        )

    me add_import(module: text):
        """Add an import."""
        if not self.imports.contains(module):
            self.imports = self.imports.push(module)

    me emit(line: text):
        """Emit a line with current indentation."""
        val indent = "  ".repeat(self.indent_level)
        self.lines = self.lines.push("{indent}{line}")

    me emit_blank():
        """Emit a blank line."""
        self.lines = self.lines.push("")

    me indent():
        """Increase indentation."""
        self.indent_level = self.indent_level + 1

    me dedent():
        """Decrease indentation."""
        if self.indent_level > 0:
            self.indent_level = self.indent_level - 1

    me emit_comment(text: text):
        """Emit a comment."""
        self.emit("-- {text}")

    me emit_doc_comment(text: text):
        """Emit a documentation comment."""
        self.emit("/-- {text} -/")

    me begin_namespace(name: text):
        """Start a namespace."""
        self.emit("namespace {name}")
        self.emit_blank()

    me end_namespace(name: text):
        """End a namespace."""
        self.emit_blank()
        self.emit("end {name}")

    me emit_structure(name: text, fields: [(text, text)]):
        """Emit a structure definition."""
        self.emit("structure {name} where")
        self.indent()
        for (field_name, field_type) in fields:
            self.emit("{field_name} : {field_type}")
        self.dedent()

    me emit_inductive(name: text, variants: [(text, [text])]):
        """Emit an inductive type."""
        self.emit("inductive {name} where")
        self.indent()
        for (var_name, params) in variants:
            if params.is_empty():
                self.emit("| {var_name}")
            else:
                val param_str = params.join(" → ")
                self.emit("| {var_name} : {param_str} → {name}")
        self.dedent()

    me emit_def(name: text, params: [(text, text)], ret_type: text, body: text):
        """Emit a definition."""
        val param_str = params.map(\p: "({p.0} : {p.1})").join(" ")
        self.emit("def {name} {param_str} : {ret_type} :=")
        self.indent()
        self.emit(body)
        self.dedent()

    me emit_theorem(name: text, statement: text):
        """Emit a theorem statement with tactic-based proof."""
        self.emit("theorem {name} : {statement} := by")
        self.indent()
        val tactics = select_proof_tactics(statement)
        for tactic in tactics:
            self.emit(tactic)
        self.dedent()

    me emit_axiom(name: text, ty: text):
        """Emit an axiom (unproven assumption)."""
        self.emit("axiom {name} : {ty}")

    fn build() -> text:
        """Build final Lean code."""
        var output = ""

        # Add imports
        for import_mod in self.imports:
            output = "{output}import {import_mod}\n"
        if not self.imports.is_empty():
            output = "{output}\n"

        # Add lines
        output = "{output}{self.lines.join(\"\n\")}"
        output

# ============================================================================
# Contract Extraction
# ============================================================================

struct FunctionContract:
    """Pre/post conditions for a function."""
    function_name: text
    preconditions: [text]
    postconditions: [text]
    invariants: [text]

impl FunctionContract:
    static fn empty(name: text) -> FunctionContract:
        FunctionContract(
            function_name: name,
            preconditions: [],
            postconditions: [],
            invariants: []
        )

    fn has_contracts() -> bool:
        not self.preconditions.is_empty() or not self.postconditions.is_empty()

    fn to_lean_spec(builder: LeanBuilder, params: [(text, text)], ret_type: text):
        """Generate Lean specification from contract."""
        if self.preconditions.is_empty() and self.postconditions.is_empty():
            return

        # Generate specification type
        var spec = ""

        if not self.preconditions.is_empty():
            val pre = self.preconditions.join(" ∧ ")
            spec = "{pre} → "

        val param_str = params.map(\p: p.0).join(" "
        spec = "{spec}∃ (result : {ret_type}), "

        if not self.postconditions.is_empty():
            val post = self.postconditions.join(" ∧ ")
            spec = "{spec}{post}"
        else:
            spec = "{spec}True"

        builder.emit_theorem("{self.function_name}_spec", spec)

# ============================================================================
# Proof Obligation
# ============================================================================

enum ProofObligation:
    """A proof obligation generated from code."""
    # Safety proofs
    BoundsCheck(array: text, index: text)
    NullCheck(pointer: text)
    DivisionByZero(divisor: text)

    # Memory proofs
    NoAliasing(ptr1: text, ptr2: text)
    ValidLifetime(ptr: text, scope: text)

    # Functional proofs
    LoopInvariant(invariant: text)
    Postcondition(condition: text)
    Termination(measure: text)

impl ProofObligation:
    fn to_lean() -> text:
        """Convert to Lean theorem statement."""
        match self:
            case BoundsCheck(arr, idx):
                "{idx} < {arr}.size"
            case NullCheck(ptr):
                "{ptr} ≠ null"
            case DivisionByZero(div):
                "{div} ≠ 0"
            case NoAliasing(p1, p2):
                "disjoint {p1} {p2}"
            case ValidLifetime(ptr, scope):
                "valid_in {ptr} {scope}"
            case LoopInvariant(inv):
                inv
            case Postcondition(cond):
                cond
            case Termination(measure):
                "∀ n, {measure} n < {measure} (n + 1)"

# ============================================================================
# MIR-to-Lean Body Translation
# ============================================================================

fn translate_mir_body(body: MirBody) -> text:
    """Translate a MIR function body to a Lean 4 term.

    Walks the basic blocks and instructions of the MIR body,
    producing a let-binding chain that represents the computation.
    The final value is the return expression.
    """
    if body.blocks.is_empty():
        return "sorry"

    # Translate the entry block and follow the control flow
    var lines: [text] = []
    for block in body.blocks:
        val block_lines = translate_mir_block(block, body)
        for line in block_lines:
            lines = lines.push(line)

    if lines.is_empty():
        return "()"

    lines.join("\n")

fn translate_mir_block(block: MirBlock, body: MirBody) -> [text]:
    """Translate a single MIR basic block to Lean let-bindings."""
    var lines: [text] = []

    # Add block label as a comment if present
    if block.label.?:
        lines = lines.push("-- block: {block.label.unwrap()}")

    # Translate each instruction
    for inst in block.instructions:
        val translated = translate_mir_inst(inst)
        if translated != "":
            lines = lines.push(translated)

    # Translate the terminator
    val term_line = translate_mir_terminator(block.terminator)
    if term_line != "":
        lines = lines.push(term_line)

    lines

fn translate_mir_inst(inst: MirInst) -> text:
    """Translate a single MIR instruction to a Lean let-binding."""
    match inst.kind:
        case Const(dest, value, type_):
            val lean_val = translate_const_value(value)
            "let _l{dest.id} := {lean_val}"

        case Copy(dest, src):
            "let _l{dest.id} := _l{src.id}"

        case Move(dest, src):
            "let _l{dest.id} := _l{src.id}"

        case BinOp(dest, op, left, right):
            val lean_op = translate_binop(op)
            val l = translate_operand(left)
            val r = translate_operand(right)
            "let _l{dest.id} := {l} {lean_op} {r}"

        case UnaryOp(dest, op, operand):
            val lean_op = translate_unaryop(op)
            val o = translate_operand(operand)
            "let _l{dest.id} := {lean_op}{o}"

        case CheckedBinOp(dest, op, left, right):
            val lean_op = translate_binop(op)
            val l = translate_operand(left)
            val r = translate_operand(right)
            "let _l{dest.id} := {l} {lean_op} {r}  -- checked"

        case Alloc(dest, type_):
            val lean_ty = mir_type_to_lean(type_)
            "let _l{dest.id} : Ptr ({lean_ty}) := Ptr.alloc"

        case Load(dest, ptr):
            val p = translate_operand(ptr)
            "let _l{dest.id} := Ptr.read {p}"

        case Store(ptr, value):
            val p = translate_operand(ptr)
            val v = translate_operand(value)
            "let _ := Ptr.write {p} {v}"

        case GetElementPtr(dest, base, indices):
            val b = translate_operand(base)
            val idx_strs = indices.map(\i: translate_operand(i))
            val idx_str = idx_strs.join(" "
            "let _l{dest.id} := Ptr.offset {b} {idx_str}"

        case Aggregate(dest, kind, operands):
            val ops = operands.map(\o: translate_operand(o))
            val ops_str = ops.join(", ")
            match kind:
                case Tuple:
                    "let _l{dest.id} := ({ops_str})"
                case Array(_):
                    "let _l{dest.id} := #[{ops_str}]"
                case Struct(sym):
                    "let _l{dest.id} := Struct.mk {ops_str}"
                case Enum(sym, variant):
                    "let _l{dest.id} := Enum.variant{variant} {ops_str}"

        case GetField(dest, base, field):
            val b = translate_operand(base)
            "let _l{dest.id} := {b}.{field}"

        case SetField(base, field, value):
            val b = translate_operand(base)
            val v = translate_operand(value)
            "let _ := set_field {b} {field} {v}"

        case Cast(dest, operand, target):
            val o = translate_operand(operand)
            val lean_ty = mir_type_to_lean(target)
            "let _l{dest.id} : {lean_ty} := cast {o}"

        case Call(dest, func, args):
            val f = translate_operand(func)
            val arg_strs = args.map(\a: translate_operand(a))
            val args_str = arg_strs.join(" ")
            if dest.?:
                val d = dest.unwrap()
                "let _l{d.id} := {f} {args_str}"
            else:
                "let _ := {f} {args_str}"

        case Intrinsic(dest, name, args):
            val arg_strs = args.map(\a: translate_operand(a))
            val args_str = arg_strs.join(" ")
            if dest.?:
                val d = dest.unwrap()
                "let _l{d.id} := intrinsic_{name} {args_str}"
            else:
                "let _ := intrinsic_{name} {args_str}"

        case DebugValue(local, name):
            "-- debug: {name} = _l{local.id}"

        case Nop:
            ""

        case _:
            "-- unsupported instruction"

fn translate_mir_terminator(term: MirTerminator) -> text:
    """Translate a MIR terminator to a Lean expression."""
    match term:
        case Return(value):
            if value.?:
                translate_operand(value.unwrap())
            else:
                "()"
        case Goto(target):
            "-- goto block{target.id}"
        case If(cond, then_, else_):
            val c = translate_operand(cond)
            "if {c} then goto_block{then_.id} else goto_block{else_.id}"
        case Switch(value, targets, default):
            val v = translate_operand(value)
            "-- switch {v} (default -> block{default.id})"
        case Unreachable:
            "absurd"
        case Abort(message):
            "panic \"{message}\""
        case CallTerminator(dest, func, args, normal, _):
            val f = translate_operand(func)
            val arg_strs = args.map(\a: translate_operand(a))
            val args_str = arg_strs.join(" ")
            if dest.?:
                val d = dest.unwrap()
                "let _l{d.id} := {f} {args_str}  -- continues at block{normal.id}"
            else:
                "let _ := {f} {args_str}  -- continues at block{normal.id}"

fn translate_operand(op: MirOperand) -> text:
    """Translate a MIR operand to a Lean term."""
    match op.kind:
        case Copy(local):
            "_l{local.id}"
        case Move(local):
            "_l{local.id}"
        case Const(value, _):
            translate_const_value(value)

fn translate_const_value(value: MirConstValue) -> text:
    """Translate a MIR constant value to a Lean literal."""
    match value:
        case Int(v):
            "{v}"
        case Float(v):
            "{v}"
        case Bool(v):
            if v: "true" else: "false"
        case Str(v):
            "\"{v}\""
        case Array(elements):
            val elems = elements.map(\e: translate_const_value(e))
            "#[{elems.join(\", \")}]"
        case Tuple(elements):
            val elems = elements.map(\e: translate_const_value(e))
            "({elems.join(\", \")})"
        case Struct(fields):
            "Struct.mk"
        case Zero:
            "0"

fn translate_binop(op: MirBinOp) -> text:
    """Translate a MIR binary operation to a Lean operator."""
    match op:
        case Add: "+"
        case Sub: "-"
        case Mul: "*"
        case Div: "/"
        case Rem: "%"
        case Pow: "^"
        case Eq: "=="
        case Ne: "!="
        case Lt: "<"
        case Le: "≤"
        case Gt: ">"
        case Ge: "≥"
        case BitAnd: "&&&"
        case BitOr: "|||"
        case BitXor: "^^^"
        case Shl: "<<<"
        case Shr: ">>>"
        case _: "+"

fn translate_unaryop(op: MirUnaryOp) -> text:
    """Translate a MIR unary operation to a Lean operator."""
    match op:
        case Neg: "-"
        case Not: "!"
        case BitNot: "~~~"
        case Transpose: "ᵀ"

# ============================================================================
# Lean Backend
# ============================================================================

class LeanBackend:
    """Lean 4 verification export backend."""
    level: VerificationLevel
    generate_proofs: bool
    module_prefix: text

    static fn create(level: VerificationLevel) -> LeanBackend:
        LeanBackend(
            level: level,
            generate_proofs: level.includes_proofs(),
            module_prefix: "Simple"
        )

    static fn minimal() -> LeanBackend:
        LeanBackend__create(VerificationLevel.Minimal)

    static fn full() -> LeanBackend:
        LeanBackend__create(VerificationLevel.Full)

    fn with_prefix(prefix: text) -> LeanBackend:
        LeanBackend(
            level: self.level,
            generate_proofs: self.generate_proofs,
            module_prefix: prefix
        )

    fn export_module(module: MirModule) -> Result<LeanExportResult, CompileError>:
        """Export a MIR module to Lean 4."""
        var builder = LeanBuilder__create()

        # Add standard imports
        builder.add_import("Mathlib.Data.Int.Basic")
        builder.add_import("Mathlib.Data.Array.Basic")

        # Begin namespace
        builder.begin_namespace("{self.module_prefix}.{module.name}")

        # Export type definitions
        self.export_types(builder, module)

        # Export functions
        for name, body in module.functions:
            self.export_function(builder, name, body)

        # Generate proof obligations
        if self.generate_proofs:
            builder.emit_blank()
            builder.emit_comment("Proof Obligations")
            self.generate_proof_obligations(builder, module)

        builder.end_namespace("{self.module_prefix}.{module.name}")

        Ok(LeanExportResult(
            module_name: module.name,
            lean_code: builder.build(),
            proof_obligations: [],  # Would be populated
            export_time_ms: 0
        ))

    fn export_types(builder: LeanBuilder, module: MirModule):
        """Export type definitions."""
        builder.emit_comment("Type Definitions")
        builder.emit_blank()

        # Would iterate through module type definitions

    fn export_function(builder: LeanBuilder, name: text, body: MirBody):
        """Export a function definition."""
        builder.emit_blank()
        builder.emit_doc_comment("Function: {name}")

        # Build parameters
        var params: [(text, text)] = []
        for i in 0..body.arg_count:
            params = params.push(("arg{i}", "Int"))

        val ret_type = mir_type_to_lean(body.return_ty)

        # Generate function signature
        if self.level == VerificationLevel.Minimal:
            # Just emit axiom for function existence
            val param_types = params.map(\p: p.1).join(" → ")
            val full_type = if param_types.is_empty(): ret_type else: "{param_types} → {ret_type}"
            builder.emit_axiom(name, full_type)
        else:
            # Generate full definition by translating MIR body
            val lean_body = translate_mir_body(body)
            builder.emit_def(name, params, ret_type, lean_body)

        # Generate contracts if requested
        if self.level.includes_contracts():
            val contract = FunctionContract__empty(name)
            contract.to_lean_spec(builder, params, ret_type)

    fn generate_proof_obligations(builder: LeanBuilder, module: MirModule):
        """Generate proof obligations for the module."""
        # Would analyze MIR for potential safety issues
        # and generate corresponding proof obligations
        pass

struct LeanExportResult:
    """Result of Lean export."""
    module_name: text
    lean_code: text
    proof_obligations: [ProofObligation]
    export_time_ms: i64

impl LeanExportResult:
    fn write_to_file(path: text) -> Result<(), text>:
        """Write Lean code to file."""
        # Would write self.lean_code to path
        Ok(())

    fn has_unproven_obligations() -> bool:
        not self.proof_obligations.is_empty()

# ============================================================================
# Proof Tactic Selection
# ============================================================================

fn select_proof_tactics(statement: text) -> [text]:
    """Select appropriate Lean 4 tactics based on the theorem statement.

    Analyzes the structure of the proof obligation and returns a list of
    tactic invocations that should discharge the goal. Falls back to a
    general strategy when the statement doesn't match a known pattern.
    """
    # Trivial / tautology (True, or empty postcondition placeholder)
    if statement == "True" or statement.ends_with("True"):
        return ["trivial"]

    # Reflexivity: goals of the form `a = a`
    if statement.contains("= ") and is_reflexive_equality(statement):
        return ["rfl"]

    # Decidable propositions (Bool comparisons, finite checks)
    if statement.contains("decide") or statement.contains("Decidable"):
        return ["decide"]

    # Natural / integer arithmetic obligations
    if is_arithmetic_statement(statement):
        return ["omega"]

    # Bounds check: `idx < arr.size`
    if statement.contains("< ") and statement.contains(".size"):
        return ["simp [Array.size]", "omega"]

    # Null / non-zero check: `x != 0` or `x != null`
    if statement.contains("≠ 0") or statement.contains("≠ null"):
        return ["simp", "omega"]

    # Disjointness / non-aliasing
    if statement.contains("disjoint"):
        return ["simp [disjoint]", "decide"]

    # Existential goals (postcondition specs: ∃ result, ...)
    if statement.contains("∃"):
        return ["simp", "omega"]

    # Memory safety (valid_heap preservation)
    if statement.contains("valid_heap"):
        return ["intro heap h_valid", "simp [run, valid_heap] at *", "exact h_valid"]

    # Universally quantified goals
    if statement.contains("∀"):
        return ["intro n", "simp", "omega"]

    # Conjunction: try splitting then solving each side
    if statement.contains("∧"):
        return ["constructor <;> simp <;> omega"]

    # General fallback: simp with omega for arithmetic residuals
    return ["simp", "omega"]

fn is_reflexive_equality(statement: text) -> bool:
    """Check if a statement is of the form `expr = expr`."""
    val parts = statement.split(" = ")
    if parts.len() == 2:
        val lhs = parts[0].trim()
        val rhs = parts[1].trim()
        return lhs == rhs
    false

fn is_arithmetic_statement(statement: text) -> bool:
    """Check if a statement is purely arithmetic (solvable by omega)."""
    # omega handles linear integer arithmetic
    if statement.contains("+") or statement.contains("-") or statement.contains("*"):
        if statement.contains("<") or statement.contains("≤") or statement.contains("=") or statement.contains("≥") or statement.contains(">"):
            return true
    # Simple numeric equality / inequality
    if statement.contains("Nat") or statement.contains("Int"):
        if statement.contains("<") or statement.contains("="):
            return true
    false

# ============================================================================
# Verification Helpers
# ============================================================================

fn generate_memory_safety_spec(builder: LeanBuilder, func_name: text):
    """Generate memory safety specification."""
    builder.emit_theorem("{func_name}_memory_safe",
        "∀ heap : Heap, valid_heap heap → valid_heap (run {func_name} heap)")

fn generate_termination_proof(builder: LeanBuilder, func_name: text, measure: text):
    """Generate termination proof structure."""
    builder.emit("termination_by {func_name} => {measure}")

fn generate_refinement_type(base_type: text, predicate: text) -> text:
    """Generate a refinement type."""
    "{{ x : {base_type} // {predicate} }}"

# ============================================================================
# Single-Obligation Tactic Selection
# ============================================================================

fn select_tactic(obligation: text) -> text:
    """Select appropriate Lean 4 tactic for a single proof obligation.

    Unlike select_proof_tactics which returns a full tactic script,
    this returns the single best tactic for a given obligation kind.
    """
    if obligation.contains("arithmetic") or obligation.contains("add") or obligation.contains("mul"):
        "ring"
    elif obligation.contains("numeric") or obligation.contains("nat") or obligation.contains("int"):
        "omega"
    elif obligation.contains("norm"):
        "norm_num"
    elif obligation.contains("enum") or obligation.contains("match") or obligation.contains("inductive"):
        "cases"
    elif obligation.contains("search") or obligation.contains("auto"):
        "aesop"
    elif obligation.contains("simp") or obligation.contains("simple"):
        "simp"
    elif obligation.contains("refl") or obligation.contains("equal"):
        "rfl"
    else:
        "sorry"

# ============================================================================
# Exports
# ============================================================================

export VerificationLevel, mir_type_to_lean
export LeanBuilder, FunctionContract, ProofObligation
export LeanBackend, LeanExportResult
export select_proof_tactics, is_reflexive_equality, is_arithmetic_statement
export select_tactic
export translate_mir_body, translate_mir_block, translate_mir_inst
export translate_mir_terminator, translate_operand, translate_const_value
export translate_binop, translate_unaryop
export generate_memory_safety_spec, generate_termination_proof
export generate_refinement_type
