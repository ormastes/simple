# VHDL Backend - VHDL-2008 Code Generation
#
# Compiles MIR to synthesizable VHDL-2008 source code.
# Produces .vhd files for entity/architecture and package declarations.

use compiler.mir_data.*
use compiler.backend.backend_api.*
use compiler.backend.vhdl_type_mapper.VhdlTypeMapper
use compiler.backend.vhdl.vhdl_builder.VhdlBuilder

# ============================================================================
# VHDL Backend
# ============================================================================

class VhdlBackend:
    """
    VHDL backend for hardware description generation.

    Compiles MIR modules to synthesizable VHDL-2008 source code.
    Produces entity/architecture pairs and package declarations.

    Features:
    - Entity/architecture generation
    - Package generation (records, enums, constants)
    - Process generation (combinational + clocked)
    - Signal/port mapping
    - Component instantiation
    - Verification assertions

    Usage:
        val backend = VhdlBackend__create()
        val result = backend.compile(mir_module)
    """

    type_mapper: VhdlTypeMapper
    options: CompileOptions
    use_resolved: bool

    static fn create(target: CodegenTarget, options: CompileOptions) -> VhdlBackend:
        """Create VHDL backend with default options (unresolved types)."""
        VhdlBackend(
            type_mapper: VhdlTypeMapper__create(),
            options: options,
            use_resolved: false
        )

    static fn create_resolved(target: CodegenTarget, options: CompileOptions) -> VhdlBackend:
        """Create VHDL backend using resolved std_logic types."""
        VhdlBackend(
            type_mapper: VhdlTypeMapper__create_resolved(),
            options: options,
            use_resolved: true
        )

    fn compile(module: MirModule) -> Result<VhdlCompiledModule, CompileError>:
        """Compile MIR module to VHDL."""
        val builder = VhdlBuilder__create(module.name)

        # Emit library header
        builder.emit_library_header()

        # Generate package for types/constants
        var pkg_vhdl = ""
        if module.types.len() > 0 or module.constants.len() > 0:
            val pkg_builder = VhdlBuilder__create(module.name)
            pkg_builder.emit_library_header()
            self.compile_package(pkg_builder, module)
            pkg_vhdl = pkg_builder.build()

        # Compile each function as an entity/architecture
        var entities: [VhdlEntity] = []
        for (symbol, func) in module.functions:
            val result = self.compile_function(builder, func)
            match result:
                case Ok(entity):
                    entities = entities.push(entity)
                case Err(e):
                    return Err(e)

        val vhdl_code = builder.build()

        Ok(VhdlCompiledModule(
            name: module.name,
            vhdl: vhdl_code,
            package_vhdl: if pkg_vhdl.len() > 0: Some(pkg_vhdl) else: nil,
            entities: entities
        ))

    fn compile_package(builder: VhdlBuilder, module: MirModule):
        """Compile type and constant definitions into a VHDL package."""
        builder.emit_package_begin(module.name)

        # Emit type definitions
        for (symbol, type_def) in module.types:
            match type_def.kind:
                case Struct(fields):
                    var field_pairs: [(text, text)] = []
                    for f in fields:
                        val mapped = self.mir_type_to_vhdl(f.type_)
                        field_pairs = field_pairs.push((f.name, mapped))
                    val record_def = self.type_mapper.map_record(field_pairs)
                    builder.emit_type_decl(type_def.name, record_def)

                case Enum(variants):
                    var names: [text] = []
                    for v in variants:
                        names = names.push(v.name)
                    val enum_def = self.type_mapper.map_enum_type(names)
                    builder.emit_type_decl(type_def.name, enum_def)

                case _:
                    builder.emit_comment("Unsupported type definition: {type_def.name}")

        # Emit constants
        for (symbol, constant) in module.constants:
            val vhdl_type = self.mir_type_to_vhdl(constant.type_)
            val vhdl_value = self.const_value_to_vhdl(constant.value)
            builder.emit_constant_decl(constant.name, vhdl_type, vhdl_value)

        builder.emit_package_end(module.name)

    fn compile_function(builder: VhdlBuilder, func: MirFunction) -> Result<VhdlEntity, CompileError>:
        """Compile a function as a VHDL entity/architecture pair."""
        val entity_name = func.name

        # Emit entity
        builder.emit_entity_begin(entity_name)
        builder.emit_port_begin()

        # Emit ports from function parameters
        var port_idx = 0
        val total_ports = func.signature.params.len() + 1  # +1 for return
        for local in func.locals:
            match local.kind:
                case Arg(idx):
                    val vhdl_type = self.mir_type_to_vhdl(local.type_)
                    val name = if local.name.?: local.name.unwrap() else: "p{idx}"
                    val is_last = port_idx == total_ports - 1
                    builder.emit_port(name, "in", vhdl_type, is_last)
                    port_idx = port_idx + 1
                case Return:
                    val vhdl_type = self.mir_type_to_vhdl(local.type_)
                    val is_last = port_idx == total_ports - 1
                    builder.emit_port("result_out", "out", vhdl_type, is_last)
                    port_idx = port_idx + 1
                case _:
                    ()

        builder.emit_port_end()
        builder.emit_entity_end(entity_name)

        # Emit architecture
        builder.emit_architecture_begin(entity_name, "rtl")

        # Declare internal signals for local variables
        for local in func.locals:
            match local.kind:
                case Var | Temp:
                    val vhdl_type = self.mir_type_to_vhdl(local.type_)
                    val name = if local.name.?: local.name.unwrap() else: "sig_{local.id.id}"
                    builder.emit_signal_decl(name, vhdl_type, nil)
                case _:
                    ()

        builder.emit_architecture_body_begin()

        # Compile basic blocks
        for block in func.blocks:
            builder.emit_comment("Block BB{block.id.id}")
            for inst in block.instructions:
                val result = self.compile_instruction(builder, inst)
                if result.is_err():
                    return Err(result.unwrap_err())

        builder.emit_architecture_end("rtl")

        Ok(VhdlEntity(
            name: entity_name,
            port_count: total_ports
        ))

    fn compile_instruction(builder: VhdlBuilder, inst: MirInst) -> Result<(), CompileError>:
        """Compile a single MIR instruction to VHDL."""
        match inst.kind:
            case Const(dest, value, ty):
                val dest_name = "sig_{dest.id}"
                val vhdl_value = self.const_value_to_vhdl(value)
                builder.emit_signal_assign(dest_name, vhdl_value)

            case Copy(dest, src) | Move(dest, src):
                val dest_name = "sig_{dest.id}"
                val src_name = "sig_{src.id}"
                builder.emit_signal_assign(dest_name, src_name)

            case BinOp(dest, op, left, right):
                val dest_name = "sig_{dest.id}"
                val left_name = self.operand_to_vhdl(left)
                val right_name = self.operand_to_vhdl(right)
                val expr = self.binop_to_vhdl(op, left_name, right_name)
                builder.emit_signal_assign(dest_name, expr)

            case UnaryOp(dest, op, operand):
                val dest_name = "sig_{dest.id}"
                val src_name = self.operand_to_vhdl(operand)
                val expr = self.unaryop_to_vhdl(op, src_name)
                builder.emit_signal_assign(dest_name, expr)

            # VHDL-specific instructions
            case VhdlProcess(kind, body_block):
                match kind:
                    case Combinational(sensitivity):
                        builder.emit_process_begin(nil, sensitivity)
                        builder.emit_process_body_begin()
                        builder.emit_comment("Process body (block {body_block.id})")
                        builder.emit_process_end(nil)
                    case Clocked(domain):
                        builder.emit_clocked_process_begin(nil, domain.clock_signal, domain.reset_signal)
                        builder.emit_process_body_begin()
                        match domain.edge:
                            case Rising:
                                builder.emit_rising_edge_check(domain.clock_signal)
                            case Falling:
                                builder.emit_falling_edge_check(domain.clock_signal)
                        builder.emit_comment("Clocked process body (block {body_block.id})")
                        builder.emit_if_end()
                        builder.emit_process_end(nil)
                    case AsyncReset(domain):
                        builder.emit_clocked_process_begin(nil, domain.clock_signal, domain.reset_signal)
                        builder.emit_process_body_begin()
                        if domain.reset_signal.?:
                            builder.emit_if_begin("{domain.reset_signal.unwrap()} = '1'")
                            builder.emit_comment("Reset logic")
                            builder.emit_else()
                            builder.emit_rising_edge_check(domain.clock_signal)
                            builder.emit_comment("Clocked logic")
                            builder.emit_if_end()
                            builder.emit_if_end()
                        builder.emit_process_end(nil)

            case VhdlSignalAssign(target, value, delay_ns):
                val target_name = self.operand_to_vhdl(target)
                val value_name = self.operand_to_vhdl(value)
                if delay_ns.?:
                    builder.emit_signal_assign_delay(target_name, value_name, delay_ns.unwrap())
                else:
                    builder.emit_signal_assign(target_name, value_name)

            case VhdlVarAssign(target, value):
                val target_name = self.operand_to_vhdl(target)
                val value_name = self.operand_to_vhdl(value)
                builder.emit_var_assign(target_name, value_name)

            case VhdlPortMap(entity, instance, connections):
                builder.emit_instance_begin(instance, entity)
                builder.emit_port_map_begin()
                var idx = 0
                for conn in connections:
                    val actual = self.operand_to_vhdl(conn.1)
                    val is_last = idx == connections.len() - 1
                    builder.emit_port_map_entry(conn.0, actual, is_last)
                    idx = idx + 1
                builder.emit_port_map_end()

            case VhdlResize(dest, operand, new_width, signed):
                val dest_name = "sig_{dest.id}"
                val src_name = self.operand_to_vhdl(operand)
                builder.emit_resize(dest_name, src_name, new_width, signed)

            case VhdlSlice(dest, signal, hi, lo):
                val dest_name = "sig_{dest.id}"
                val src_name = self.operand_to_vhdl(signal)
                builder.emit_slice(dest_name, src_name, hi, lo)

            case VhdlConcat(dest, parts):
                val dest_name = "sig_{dest.id}"
                var part_names: [text] = []
                for p in parts:
                    part_names = part_names.push(self.operand_to_vhdl(p))
                builder.emit_concat(dest_name, part_names)

            case Nop:
                ()

            case _:
                builder.emit_comment("Unsupported instruction: {inst.kind}")

        Ok(())

    fn mir_type_to_vhdl(ty: MirType) -> text:
        """Convert MIR type to VHDL type string."""
        match ty.kind:
            case I64: "signed(63 downto 0)"
            case I32: "signed(31 downto 0)"
            case I16: "signed(15 downto 0)"
            case I8: "signed(7 downto 0)"
            case U64: "unsigned(63 downto 0)"
            case U32: "unsigned(31 downto 0)"
            case U16: "unsigned(15 downto 0)"
            case U8: "unsigned(7 downto 0)"
            case Bool:
                if self.use_resolved: "std_logic" else: "bit"
            case Unit: "-- void"
            case Array(elem, size):
                val elem_type = self.mir_type_to_vhdl(elem)
                "array (0 to {size - 1}) of {elem_type}"
            case _: "-- unsupported type"

    fn const_value_to_vhdl(value: MirConstValue) -> text:
        """Convert a constant value to VHDL literal."""
        match value:
            case Int(v):
                "to_signed({v}, 64)"
            case Float(v):
                "-- ERROR: float {v} not synthesizable"
            case Bool(v):
                if self.use_resolved:
                    if v: "'1'" else: "'0'"
                else:
                    if v: "'1'" else: "'0'"
            case Str(v):
                "\"{v}\""
            case Zero:
                "(others => '0')"
            case _:
                "-- unsupported constant"

    fn operand_to_vhdl(operand: MirOperand) -> text:
        """Convert operand to VHDL signal/variable name."""
        match operand.kind:
            case Copy(local): "sig_{local.id}"
            case Move(local): "sig_{local.id}"
            case Const(value, ty):
                self.const_value_to_vhdl(value)

    fn binop_to_vhdl(op: MirBinOp, left: text, right: text) -> text:
        """Convert binary operation to VHDL expression."""
        match op:
            case Add: "{left} + {right}"
            case Sub: "{left} - {right}"
            case Mul: "{left} * {right}"
            case Div: "{left} / {right}"
            case Eq: "'{if ({left} = {right}) then '1' else '0'}'"
            case Ne: "'{if ({left} /= {right}) then '1' else '0'}'"
            case Lt: "'{if ({left} < {right}) then '1' else '0'}'"
            case Le: "'{if ({left} <= {right}) then '1' else '0'}'"
            case Gt: "'{if ({left} > {right}) then '1' else '0'}'"
            case Ge: "'{if ({left} >= {right}) then '1' else '0'}'"
            case BitAnd: "{left} and {right}"
            case BitOr: "{left} or {right}"
            case BitXor: "{left} xor {right}"
            case Shl: "shift_left({left}, to_integer({right}))"
            case Shr: "shift_right({left}, to_integer({right}))"
            case _: "-- unsupported binop"

    fn unaryop_to_vhdl(op: MirUnaryOp, operand: text) -> text:
        """Convert unary operation to VHDL expression."""
        match op:
            case Neg: "-{operand}"
            case Not: "not {operand}"
            case _: "-- unsupported unaryop"

# ============================================================================
# VHDL Compilation Results
# ============================================================================

struct VhdlCompiledModule:
    """Result of VHDL compilation."""
    name: text
    vhdl: text
    package_vhdl: text?
    entities: [VhdlEntity]

struct VhdlEntity:
    """Compiled VHDL entity."""
    name: text
    port_count: i64

# ============================================================================
# Export
# ============================================================================

export VhdlBackend
export VhdlCompiledModule, VhdlEntity

