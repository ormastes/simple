# Unified Backend API
#
# Provides a unified interface to all compiler backends.
# Supports automatic backend selection based on target,
# as well as explicit backend specification.
#
# Supported backends:
# - Cranelift: Default backend for 64-bit targets
# - LLVM: 32-bit support, advanced optimizations
# - WASM: WebAssembly for browser deployment
# - Lean: Verification export for formal proofs
#
# Usage:
#   val backend = Backend.for_target(CodegenTarget.X86_64)
#   val result = backend.compile(mir_module)

use compiler.mir_data.*

# ============================================================================
# Backend Kind
# ============================================================================

enum BackendKind:
    """Available compiler backends."""
    Cranelift   # JIT and AOT, 64-bit focused
    Llvm        # Full optimization, 32-bit support
    Wasm        # WebAssembly output
    Lean        # Lean 4 verification export
    Interpreter # Debug interpreter
    Cuda        # NVIDIA CUDA (PTX output)
    Vulkan      # Vulkan compute (SPIR-V output)

impl BackendKind:
    fn to_text() -> text:
        match self:
            case Cranelift: "cranelift"
            case Llvm: "llvm"
            case Wasm: "wasm"
            case Lean: "lean"
            case Interpreter: "interpreter"
            case Cuda: "cuda"
            case Vulkan: "vulkan"

    fn supports_target(target: CodegenTarget) -> bool:
        """Check if this backend supports a target."""
        match self:
            case Cranelift:
                target.is_64bit()
            case Llvm:
                true  # LLVM supports most targets
            case Wasm:
                target == CodegenTarget.Wasm32 or target == CodegenTarget.Wasm64
            case Lean:
                true  # Lean export is target-independent
            case Interpreter:
                true  # Interpreter works for all
            case Cuda:
                target.is_gpu()  # CUDA only for GPU targets
            case Vulkan:
                target.is_gpu()  # Vulkan only for GPU targets

    fn supports_optimization(level: OptimizationLevel) -> bool:
        """Check if this backend supports an optimization level."""
        match self:
            case Cranelift:
                level != OptimizationLevel.Aggressive
            case Llvm:
                true  # LLVM supports all levels
            case Wasm:
                level != OptimizationLevel.Aggressive
            case Lean:
                level == OptimizationLevel.None  # No optimization for verification
            case Interpreter:
                true
            case Cuda:
                true  # CUDA supports all levels
            case Vulkan:
                true  # Vulkan supports all levels

    fn is_gpu_backend() -> bool:
        """Check if this is a GPU backend."""
        match self:
            case Cuda | Vulkan: true
            case _: false

# ============================================================================
# Codegen Target
# ============================================================================

enum CodegenTarget:
    """Compilation targets."""
    # 64-bit targets
    X86_64
    AArch64
    Riscv64

    # 32-bit targets
    X86
    Arm
    Riscv32

    # WebAssembly
    Wasm32
    Wasm64

    # GPU targets
    CudaPtx(compute_cap: (i64, i64))    # NVIDIA CUDA (e.g., (8, 6) for SM 8.6)
    VulkanSpirv(version: (i64, i64))    # Vulkan SPIR-V (e.g., (1, 3) for Vulkan 1.3)

    # Host (detected at runtime)
    Host

impl CodegenTarget:
    fn to_text() -> text:
        match self:
            case X86_64: "x86_64"
            case AArch64: "aarch64"
            case Riscv64: "riscv64"
            case X86: "i686"
            case Arm: "armv7"
            case Riscv32: "riscv32"
            case Wasm32: "wasm32"
            case Wasm64: "wasm64"
            case CudaPtx(cap): "cuda-sm{cap.0}{cap.1}"
            case VulkanSpirv(ver): "vulkan-{ver.0}.{ver.1}"
            case Host: "host"

    fn is_64bit() -> bool:
        match self:
            case X86_64 | AArch64 | Riscv64 | Wasm64 | Host: true
            case _: false

    fn is_32bit() -> bool:
        match self:
            case X86 | Arm | Riscv32 | Wasm32: true
            case _: false

    fn is_wasm() -> bool:
        match self:
            case Wasm32 | Wasm64: true
            case _: false

    fn is_gpu() -> bool:
        """Check if this is a GPU target."""
        match self:
            case CudaPtx(_) | VulkanSpirv(_): true
            case _: false

    fn is_cuda() -> bool:
        """Check if this is a CUDA target."""
        match self:
            case CudaPtx(_): true
            case _: false

    fn is_vulkan() -> bool:
        """Check if this is a Vulkan target."""
        match self:
            case VulkanSpirv(_): true
            case _: false

    fn cuda_compute_capability() -> (i64, i64)?:
        """Get CUDA compute capability if this is a CUDA target."""
        match self:
            case CudaPtx(cap): Some(cap)
            case _: nil

    fn vulkan_version() -> (i64, i64)?:
        """Get Vulkan version if this is a Vulkan target."""
        match self:
            case VulkanSpirv(ver): Some(ver)
            case _: nil

    static fn from_text(s: text) -> CodegenTarget?:
        """Parse target from string."""
        match s:
            case "x86_64" | "x64": Some(CodegenTarget.X86_64)
            case "aarch64" | "arm64": Some(CodegenTarget.AArch64)
            case "riscv64": Some(CodegenTarget.Riscv64)
            case "i686" | "x86" | "i386": Some(CodegenTarget.X86)
            case "armv7" | "arm": Some(CodegenTarget.Arm)
            case "riscv32": Some(CodegenTarget.Riscv32)
            case "wasm32": Some(CodegenTarget.Wasm32)
            case "wasm64": Some(CodegenTarget.Wasm64)
            case "host": Some(CodegenTarget.Host)
            case "cuda" | "cuda-sm70": Some(CodegenTarget.CudaPtx((7, 0)))
            case "cuda-sm75": Some(CodegenTarget.CudaPtx((7, 5)))
            case "cuda-sm80": Some(CodegenTarget.CudaPtx((8, 0)))
            case "cuda-sm86": Some(CodegenTarget.CudaPtx((8, 6)))
            case "cuda-sm89": Some(CodegenTarget.CudaPtx((8, 9)))
            case "cuda-sm90": Some(CodegenTarget.CudaPtx((9, 0)))
            case "vulkan" | "vulkan-1.3": Some(CodegenTarget.VulkanSpirv((1, 3)))
            case "vulkan-1.2": Some(CodegenTarget.VulkanSpirv((1, 2)))
            case "vulkan-1.1": Some(CodegenTarget.VulkanSpirv((1, 1)))
            case "vulkan-1.0": Some(CodegenTarget.VulkanSpirv((1, 0)))
            case _: nil

    static fn cuda(major: i64, minor: i64) -> CodegenTarget:
        """Create CUDA target with specific compute capability."""
        CodegenTarget.CudaPtx((major, minor))

    static fn vulkan(major: i64, minor: i64) -> CodegenTarget:
        """Create Vulkan target with specific version."""
        CodegenTarget.VulkanSpirv((major, minor))

# ============================================================================
# Build Mode
# ============================================================================

enum BuildMode:
    """Build mode determines backend selection and optimization strategy."""
    Debug      # Debug builds: fast compilation (Cranelift), debug symbols
    Release    # Release builds: optimized runtime (LLVM), stripped
    Test       # Test mode: no compilation (Interpreter)
    Bootstrap  # Bootstrap builds: minimal dependencies (Cranelift)

impl BuildMode:
    fn to_text() -> text:
        match self:
            case Debug: "debug"
            case Release: "release"
            case Test: "test"
            case Bootstrap: "bootstrap"

    fn default_optimization() -> OptimizationLevel:
        """Get default optimization level for build mode."""
        match self:
            case Debug: OptimizationLevel.Debug
            case Release: OptimizationLevel.Speed
            case Test: OptimizationLevel.None
            case Bootstrap: OptimizationLevel.Size

    fn prefer_llvm() -> bool:
        """Whether this mode prefers LLVM over Cranelift."""
        match self:
            case Release: true  # LLVM for better optimization
            case _: false       # Cranelift for fast compilation

# ============================================================================
# Optimization Level
# ============================================================================

enum OptimizationLevel:
    """Optimization levels for code generation."""
    None        # -O0: No optimization, fast compile
    Debug       # -Og: Debug-friendly optimization
    Size        # -Os: Optimize for size
    Speed       # -O2: Standard optimization
    Aggressive  # -O3: Aggressive optimization

impl OptimizationLevel:
    fn to_text() -> text:
        match self:
            case None: "O0"
            case Debug: "Og"
            case Size: "Os"
            case Speed: "O2"
            case Aggressive: "O3"

    fn llvm_level() -> i64:
        """Get LLVM optimization level number."""
        match self:
            case None: 0
            case Debug: 1
            case Size: 2  # -Os maps to O2 with size preference
            case Speed: 2
            case Aggressive: 3

# ============================================================================
# Compilation Options
# ============================================================================

struct CompileOptions:
    """Options for compilation."""
    target: CodegenTarget
    opt_level: OptimizationLevel
    debug_info: bool
    emit_assembly: bool
    emit_llvm_ir: bool
    emit_mir: bool
    verify_output: bool

impl CompileOptions:
    static fn default_options() -> CompileOptions:
        CompileOptions(
            target: CodegenTarget.Host,
            opt_level: OptimizationLevel.Speed,
            debug_info: false,
            emit_assembly: false,
            emit_llvm_ir: false,
            emit_mir: false,
            verify_output: true
        )

    static fn debug_options() -> CompileOptions:
        CompileOptions(
            target: CodegenTarget.Host,
            opt_level: OptimizationLevel.Debug,
            debug_info: true,
            emit_assembly: false,
            emit_llvm_ir: false,
            emit_mir: true,
            verify_output: true
        )

    static fn release_options() -> CompileOptions:
        CompileOptions(
            target: CodegenTarget.Host,
            opt_level: OptimizationLevel.Speed,
            debug_info: false,
            emit_assembly: false,
            emit_llvm_ir: false,
            emit_mir: false,
            verify_output: true
        )

    fn with_target(target: CodegenTarget) -> CompileOptions:
        CompileOptions(
            target: target,
            opt_level: self.opt_level,
            debug_info: self.debug_info,
            emit_assembly: self.emit_assembly,
            emit_llvm_ir: self.emit_llvm_ir,
            emit_mir: self.emit_mir,
            verify_output: self.verify_output
        )

    fn with_optimization(opt_level: OptimizationLevel) -> CompileOptions:
        """Set optimization level."""
        CompileOptions(
            target: self.target,
            opt_level: opt_level,
            debug_info: self.debug_info,
            emit_assembly: self.emit_assembly,
            emit_llvm_ir: self.emit_llvm_ir,
            emit_mir: self.emit_mir,
            verify_output: self.verify_output
        )

# ============================================================================
# Compilation Result
# ============================================================================

struct CompiledModule:
    """Result of compiling a module."""
    name: text
    object_code: [u8]?
    assembly: text?
    llvm_ir: text?
    mir_dump: text?
    symbols: [CompiledSymbol]
    compile_time_ms: i64

struct CompiledSymbol:
    """A symbol in the compiled module."""
    name: text
    kind: SymbolKind
    address: i64
    size: i64

enum SymbolKind:
    Function
    Data
    Const

impl SymbolKind:
    fn to_text() -> text:
        match self:
            case Function: "function"
            case Data: "data"
            case Const: "const"

struct CompileError:
    """Error during compilation."""
    message: text
    phase: text
    location: text?

impl CompileError:
    static fn backend_error(backend: BackendKind, message: text) -> CompileError:
        CompileError(
            message: message,
            phase: "backend ({backend.to_text()})",
            location: nil
        )

    static fn target_unsupported(backend: BackendKind, target: CodegenTarget) -> CompileError:
        CompileError(
            message: "Backend {backend.to_text()} does not support target {target.to_text()}",
            phase: "target selection",
            location: nil
        )

    fn to_text() -> text:
        var result = "Compile error in {self.phase}: {self.message}"
        if self.location.?:
            result = "{result} at {self.location.unwrap()}"
        result

# ============================================================================
# Backend Interface
# ============================================================================

class Backend:
    """Unified backend interface."""
    kind: BackendKind
    options: CompileOptions

    static fn for_target(target: CodegenTarget) -> Backend:
        """
        Create backend for target with automatic backend selection (legacy API).

        For new code, prefer for_target_and_mode() which considers build mode.
        This method assumes Debug mode for backwards compatibility.
        """
        val kind = select_backend(target, nil)
        Backend(
            kind: kind,
            options: CompileOptions.default_options().with_target(target)
        )

    static fn for_target_and_mode(target: CodegenTarget, mode: BuildMode) -> Backend:
        """
        Create backend for target and build mode with automatic backend selection.

        This is the recommended way to create backends, as it considers both
        the target architecture and build mode for optimal backend selection.

        Examples:
            Backend.for_target_and_mode(X86_64, Debug)     # → Cranelift
            Backend.for_target_and_mode(X86_64, Release)   # → LLVM
            Backend.for_target_and_mode(X86_64, Test)      # → Interpreter
            Backend.for_target_and_mode(X86, Release)      # → LLVM (32-bit)
        """
        val kind = select_backend_with_mode(target, mode, nil)

        Backend(
            kind: kind,
            options: CompileOptions.default_options()
                .with_target(target)
                .with_optimization(mode.default_optimization())
        )

    static fn for_target_mode_and_backend(
        target: CodegenTarget,
        mode: BuildMode,
        backend: BackendKind
    ) -> Result<Backend, CompileError>:
        """
        Create backend with explicit backend selection.

        Validates that the backend supports the target. Use this when the user
        explicitly specifies a backend via --backend flag.

        Examples:
            Backend.for_target_mode_and_backend(X86_64, Release, Cranelift) # OK
            Backend.for_target_mode_and_backend(X86, Release, Cranelift)    # Error (32-bit)
        """
        if not backend.supports_target(target):
            return Err(CompileError.target_unsupported(backend, target))

        Ok(Backend(
            kind: backend,
            options: CompileOptions.default_options()
                .with_target(target)
                .with_optimization(mode.default_optimization())
        ))

    static fn create(kind: BackendKind, options: CompileOptions) -> Result<Backend, CompileError>:
        """Create backend with explicit backend kind."""
        if not kind.supports_target(options.target):
            return Err(CompileError.target_unsupported(kind, options.target))

        Ok(Backend(kind: kind, options: options))

    static fn cranelift() -> Backend:
        """Create Cranelift backend with default options."""
        Backend(kind: BackendKind.Cranelift, options: CompileOptions.default_options())

    static fn llvm() -> Backend:
        """Create LLVM backend with default options."""
        Backend(kind: BackendKind.Llvm, options: CompileOptions.default_options())

    static fn wasm() -> Backend:
        """Create WASM backend."""
        Backend(
            kind: BackendKind.Wasm,
            options: CompileOptions.default_options().with_target(CodegenTarget.Wasm32)
        )

    static fn lean() -> Backend:
        """Create Lean verification backend."""
        Backend(kind: BackendKind.Lean, options: CompileOptions.default_options())

    fn compile(module: MirModule) -> Result<CompiledModule, CompileError>:
        """Compile a MIR module."""
        match self.kind:
            case Cranelift:
                self.compile_cranelift(module)
            case Llvm:
                self.compile_llvm(module)
            case Wasm:
                self.compile_wasm(module)
            case Lean:
                self.compile_lean(module)
            case Interpreter:
                # Interpreter doesn't produce object code
                Ok(CompiledModule(
                    name: module.name,
                    object_code: nil,
                    assembly: nil,
                    llvm_ir: nil,
                    mir_dump: Some(format_mir_module(module)),
                    symbols: [],
                    compile_time_ms: 0
                ))

    fn compile_cranelift(module: MirModule) -> Result<CompiledModule, CompileError>:
        """Compile using Cranelift backend."""
        # This would call into Rust FFI
        # For now, return placeholder
        Ok(CompiledModule(
            name: module.name,
            object_code: nil,
            assembly: nil,
            llvm_ir: nil,
            mir_dump: if self.options.emit_mir: Some(format_mir_module(module)) else: nil,
            symbols: [],
            compile_time_ms: 0
        ))

    fn compile_llvm(module: MirModule) -> Result<CompiledModule, CompileError>:
        """Compile using LLVM backend."""
        # This would call into Rust FFI
        Ok(CompiledModule(
            name: module.name,
            object_code: nil,
            assembly: if self.options.emit_assembly: Some("# LLVM assembly") else: nil,
            llvm_ir: if self.options.emit_llvm_ir: Some("; LLVM IR") else: nil,
            mir_dump: if self.options.emit_mir: Some(format_mir_module(module)) else: nil,
            symbols: [],
            compile_time_ms: 0
        ))

    fn compile_wasm(module: MirModule) -> Result<CompiledModule, CompileError>:
        """Compile to WebAssembly."""
        # This would call into Rust FFI
        Ok(CompiledModule(
            name: module.name,
            object_code: nil,  # Would be WASM bytes
            assembly: if self.options.emit_assembly: Some("(module)") else: nil,
            llvm_ir: nil,
            mir_dump: if self.options.emit_mir: Some(format_mir_module(module)) else: nil,
            symbols: [],
            compile_time_ms: 0
        ))

    fn compile_lean(module: MirModule) -> Result<CompiledModule, CompileError>:
        """Export to Lean 4 for verification."""
        # This would generate Lean code
        Ok(CompiledModule(
            name: module.name,
            object_code: nil,
            assembly: Some("-- Lean 4 export"),
            llvm_ir: nil,
            mir_dump: if self.options.emit_mir: Some(format_mir_module(module)) else: nil,
            symbols: [],
            compile_time_ms: 0
        ))

# ============================================================================
# Helper Functions
# ============================================================================

fn format_mir_module(module: MirModule) -> text:
    """Format MIR module for debugging."""
    var output = "MIR Module: {module.name}\n"
    output = "{output}Functions: {module.functions.len()}\n"
    # Would include more detailed MIR dump
    output

fn select_backend(target: CodegenTarget, preferred: BackendKind?) -> BackendKind:
    """
    Select the best backend for a target (legacy API).
    For new code, use select_backend_with_mode().
    """
    if preferred.? and preferred.unwrap().supports_target(target):
        return preferred.unwrap()

    # Auto-select based on target only (no build mode consideration)
    if target.is_cuda():
        BackendKind.Cuda
    elif target.is_vulkan():
        BackendKind.Vulkan
    elif target.is_wasm():
        BackendKind.Wasm
    elif target.is_32bit():
        BackendKind.Llvm
    else:
        BackendKind.Cranelift

fn select_backend_with_mode(
    target: CodegenTarget,
    mode: BuildMode,
    preferred: BackendKind?
) -> BackendKind:
    """
    Select the best backend for target and build mode.

    Selection strategy:
    1. User preference (if specified and supported)
    2. 32-bit targets → LLVM (only backend supporting 32-bit)
    3. WebAssembly → Wasm backend
    4. Test mode → Interpreter (no compilation overhead)
    5. Debug mode → Cranelift (2.5x faster compilation)
    6. Release mode → LLVM (15-30% faster runtime)
    7. Bootstrap mode → Cranelift (minimal dependencies)

    Examples:
        select_backend_with_mode(X86, Release, nil)     # → LLVM (32-bit)
        select_backend_with_mode(X86_64, Debug, nil)    # → Cranelift (fast compile)
        select_backend_with_mode(X86_64, Release, nil)  # → LLVM (optimized runtime)
        select_backend_with_mode(X86_64, Test, nil)     # → Interpreter (no compile)
    """
    # 1. User preference overrides everything
    if preferred.?:
        val backend = preferred.unwrap()
        if backend.supports_target(target):
            return backend
        else:
            # User requested unsupported backend, fall through to auto-select
            ()

    # 2. 32-bit targets always use LLVM (Cranelift doesn't support 32-bit)
    if target.is_32bit():
        return BackendKind.Llvm

    # 3. WebAssembly targets use Wasm backend
    if target.is_wasm():
        return BackendKind.Wasm

    # 4. Test mode uses Interpreter (no compilation overhead)
    if mode == BuildMode.Test:
        return BackendKind.Interpreter

    # 5. For 64-bit targets, choose based on build mode
    match mode:
        case Debug:
            BackendKind.Cranelift  # Fast compilation (2.5x vs LLVM)

        case Release:
            BackendKind.Llvm       # Better optimization (15-30% faster runtime)

        case Bootstrap:
            BackendKind.Cranelift  # Minimal dependencies

        case Test:
            BackendKind.Interpreter  # Already handled above, but included for completeness

fn available_backends() -> [BackendKind]:
    """Get list of available backends."""
    [
        BackendKind.Cranelift,
        BackendKind.Llvm,
        BackendKind.Wasm,
        BackendKind.Lean,
        BackendKind.Interpreter,
        BackendKind.Cuda,
        BackendKind.Vulkan
    ]

fn gpu_backends() -> [BackendKind]:
    """Get list of GPU backends."""
    [
        BackendKind.Cuda,
        BackendKind.Vulkan
    ]

fn backend_for_name(name: text) -> BackendKind?:
    """Get backend by name."""
    match name:
        case "cranelift": Some(BackendKind.Cranelift)
        case "llvm": Some(BackendKind.Llvm)
        case "wasm": Some(BackendKind.Wasm)
        case "lean": Some(BackendKind.Lean)
        case "interpreter": Some(BackendKind.Interpreter)
        case "cuda" | "ptx": Some(BackendKind.Cuda)
        case "vulkan" | "spirv": Some(BackendKind.Vulkan)
        case _: nil

# ============================================================================
# Exports
# ============================================================================

export BackendKind, CodegenTarget, OptimizationLevel
export CompileOptions, CompiledModule, CompiledSymbol, SymbolKind
export CompileError, Backend
export format_mir_module, select_backend
export available_backends, gpu_backends, backend_for_name
