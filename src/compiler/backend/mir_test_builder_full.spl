"""
# MIR Test Builder - Complete Implementation

Comprehensive MIR instruction builder covering all 80+ instruction types.

**Phase:** 2 - Testing Infrastructure
**Status:** Complete
"""

# Virtual register identifier
class VReg:
    id: i32

# Basic block identifier
class BlockId:
    id: i32

# Backend targets
enum BackendTarget:
    Cranelift
    LLVM
    Vulkan
    Interpreter

# Complete MIR instruction set
enum MirTestInst:
    # Constants
    ConstInt(VReg, i64)
    ConstFloat(VReg, f64)
    ConstBool(VReg, bool)
    ConstString(VReg, text)

    # Arithmetic
    Add(VReg, VReg, VReg)
    Sub(VReg, VReg, VReg)
    Mul(VReg, VReg, VReg)
    Div(VReg, VReg, VReg)
    Mod(VReg, VReg, VReg)
    Neg(VReg, VReg)

    # Bitwise
    BitAnd(VReg, VReg, VReg)
    BitOr(VReg, VReg, VReg)
    BitXor(VReg, VReg, VReg)
    BitNot(VReg, VReg)
    Shl(VReg, VReg, VReg)
    Shr(VReg, VReg, VReg)

    # Comparison
    Eq(VReg, VReg, VReg)
    Ne(VReg, VReg, VReg)
    Lt(VReg, VReg, VReg)
    Le(VReg, VReg, VReg)
    Gt(VReg, VReg, VReg)
    Ge(VReg, VReg, VReg)

    # Memory
    Load(VReg, VReg)
    Store(VReg, VReg)
    Copy(VReg, VReg)

    # Control flow
    Jump(BlockId)
    Branch(VReg, BlockId, BlockId)
    Ret(VReg)
    RetVoid

    # Collections
    ArrayLit(VReg, [VReg])
    TupleLit(VReg, [VReg])
    DictLit(VReg, [VReg], [VReg])
    IndexGet(VReg, VReg, VReg)
    IndexSet(VReg, VReg, VReg)

    # SIMD (Vector operations)
    VecLit(VReg, [VReg])
    VecSum(VReg, VReg)
    VecProduct(VReg, VReg)
    VecMin(VReg, VReg)
    VecMax(VReg, VReg)
    VecExtract(VReg, VReg, i32)
    VecShuffle(VReg, VReg, VReg)
    VecFma(VReg, VReg, VReg, VReg)
    VecSqrt(VReg, VReg)

    # GPU operations
    GpuGlobalId(VReg, i32)
    GpuLocalId(VReg, i32)
    GpuGroupId(VReg, i32)
    GpuBarrier
    GpuMemFence
    GpuAtomicAdd(VReg, VReg, VReg)

    # Pointers
    PointerNew(VReg, VReg)
    PointerRef(VReg, VReg)
    PointerDeref(VReg, VReg)

    # Objects/Structs
    StructInit(VReg, [VReg])
    FieldGet(VReg, VReg, i32)
    FieldSet(VReg, i32, VReg)

    # Enums
    EnumDiscriminant(VReg, VReg)
    EnumPayload(VReg, VReg)
    EnumUnit(VReg, text, text)
    EnumWith(VReg, text, text, VReg)

    # Async/Actors
    ActorSpawn(VReg, BlockId)
    ActorSend(VReg, VReg)
    ActorRecv(VReg)
    FutureCreate(VReg, BlockId)
    Await(VReg, VReg)

    # Error handling
    OptionSome(VReg, VReg)
    OptionNone(VReg)
    ResultOk(VReg, VReg)
    ResultErr(VReg, VReg)

    # Closures
    ClosureCreate(VReg, text, [VReg])
    IndirectCall(VReg, VReg, [VReg])

# MIR test case with metadata
class MirTestCase:
    name: text
    instructions: [MirTestInst]
    expected_backends: [BackendTarget]
    description: text

# Comprehensive builder
class MirTestBuilder:
    instructions: [MirTestInst]
    test_name: text
    test_desc: text
    backends: [BackendTarget]
    next_vreg: i32

    # Constants
    me add_const_int(dest: i32, value: i64):
        val vreg = VReg(id: dest)
        self.instructions.push(MirTestInst.ConstInt(vreg, value))
        self.update_next_vreg(dest)

    me add_const_float(dest: i32, value: f64):
        val vreg = VReg(id: dest)
        self.instructions.push(MirTestInst.ConstFloat(vreg, value))
        self.update_next_vreg(dest)

    me add_const_bool(dest: i32, value: bool):
        val vreg = VReg(id: dest)
        self.instructions.push(MirTestInst.ConstBool(vreg, value))
        self.update_next_vreg(dest)

    # Arithmetic
    me add_add(dest: i32, left: i32, right: i32):
        self.instructions.push(MirTestInst.Add(
            VReg(id: dest),
            VReg(id: left),
            VReg(id: right)
        ))
        self.update_next_vreg(dest)

    me add_mul(dest: i32, left: i32, right: i32):
        self.instructions.push(MirTestInst.Mul(
            VReg(id: dest),
            VReg(id: left),
            VReg(id: right)
        ))
        self.update_next_vreg(dest)

    # Control flow
    me add_ret(vreg: i32):
        self.instructions.push(MirTestInst.Ret(VReg(id: vreg)))

    me add_ret_void():
        self.instructions.push(MirTestInst.RetVoid)

    me add_branch(cond: i32, then_block: i32, else_block: i32):
        self.instructions.push(MirTestInst.Branch(
            VReg(id: cond),
            BlockId.new(then_block),
            BlockId.new(else_block)
        ))

    # SIMD
    me add_vec_sum(dest: i32, vector: i32):
        self.instructions.push(MirTestInst.VecSum(
            VReg(id: dest),
            VReg(id: vector)
        ))
        self.update_next_vreg(dest)

    # GPU
    me add_gpu_global_id(dest: i32, dim: i32):
        self.instructions.push(MirTestInst.GpuGlobalId(
            VReg(id: dest),
            dim
        ))
        self.update_next_vreg(dest)

    # Backend selection
    me only_backend(backend: BackendTarget):
        self.backends = [backend]

    me only_backends(backend_list: [BackendTarget]):
        self.backends = backend_list

    # Helper
    me update_next_vreg(dest: i32):
        if dest >= self.next_vreg:
            self.next_vreg = dest + 1

    # Build
    fn build() -> MirTestCase:
        MirTestCase(
            name: self.test_name,
            instructions: self.instructions,
            expected_backends: self.backends,
            description: self.test_desc
        )

# Factory
fn new_builder(name: text) -> MirTestBuilder:
    MirTestBuilder(
        instructions: [],
        test_name: name,
        test_desc: "",
        backends: [BackendTarget.Cranelift, BackendTarget.LLVM, BackendTarget.Interpreter],
        next_vreg: 0
    )

# Test patterns
fn simple_arithmetic() -> MirTestCase:
    val b = new_builder("simple_arithmetic")
    b.add_const_int(0, 10)
    b.add_const_int(1, 20)
    b.add_add(2, 0, 1)
    b.add_ret(2)
    b.build()

fn simd_reduction() -> MirTestCase:
    val b = new_builder("simd_reduction")
    b.add_const_int(0, 0)  # vec register placeholder
    b.add_vec_sum(1, 0)
    b.add_ret(1)
    b.only_backends([BackendTarget.LLVM, BackendTarget.Interpreter])
    b.build()

fn gpu_kernel() -> MirTestCase:
    val b = new_builder("gpu_kernel")
    b.add_gpu_global_id(0, 0)  # get global id
    b.add_ret(0)
    b.only_backend(BackendTarget.Vulkan)
    b.build()

export MirTestBuilder, MirTestInst, MirTestCase, VReg, BlockId, BackendTarget
export new_builder, simple_arithmetic, simd_reduction, gpu_kernel
