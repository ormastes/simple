# Compiler Backend - Native code generation
#
# This module implements the compiler backend that generates
# native code from HIR via Cranelift JIT/AOT compilation.

use compiler.hir.*
use compiler.mir.*
use backend_types.*
use backend.env.EvalContext

# ============================================================================
# Compiler Backend Implementation
# ============================================================================

struct CompilerBackendImpl:
    """Compiling backend (HIR -> MIR -> codegen).

    Compiles HIR modules by:
    1. Lowering HIR to MIR
    2. Generating native code via Cranelift
    3. Either executing (JIT) or emitting object file (AOT)
    """
    mode: CodegenMode
    output_path: text?

impl CompilerBackendImpl:
    static fn jit() -> CompilerBackendImpl:
        """Create JIT compilation backend."""
        CompilerBackendImpl(mode: CodegenMode.Jit, output_path: nil)

    static fn aot(output: text) -> CompilerBackendImpl:
        """Create AOT compilation backend."""
        CompilerBackendImpl(mode: CodegenMode.Aot, output_path: Some(output))

impl Backend for CompilerBackendImpl:
    fn name() -> text:
        "compiler"

    fn kind() -> BackendKind:
        BackendKind.Compiler

    fn process_module(module: HirModule) -> Result<BackendResult, BackendError>:
        # 1. Lower HIR to MIR
        var lowering = MirLowering.new(module.symbols)
        val mir_module = lowering.lower_module(module)

        # Check for lowering errors
        if lowering.errors.len() > 0:
            val first_error = lowering.errors[0]
            return Err(BackendError.compile_error(first_error.message, first_error.span))

        # 2. Create codegen pipeline based on mode
        val pipeline = match self.mode:
            case Jit: CodegenPipeline.jit()
            case Aot: CodegenPipeline.aot(CodegenTarget.Native)

        # 3. Compile MIR to native code
        val compile_result = pipeline.compile_module(mir_module)
        match compile_result:
            case Ok(compiled):
                match self.mode:
                    case Jit:
                        # JIT: Execute main function and return result
                        val call_result = compiled.call("main", [])
                        match call_result:
                            case Ok(value):
                                compiled.cleanup()
                                Ok(BackendResult.Value(Value.int(value)))
                            case Err(e):
                                compiled.cleanup()
                                Err(BackendError.runtime_error(e.message, e.span))
                    case Aot:
                        # AOT: Emit object file
                        val path = self.output_path ?? "a.o"
                        val emit_result = compiled.emit_object(path)
                        match emit_result:
                            case Ok(_):
                                compiled.cleanup()
                                Ok(BackendResult.Unit)
                            case Err(e):
                                compiled.cleanup()
                                Err(BackendError.compile_error(e.message, e.span))
            case Err(e):
                Err(BackendError.compile_error(e.message, e.span))

    fn process_function(fn_: HirFunction) -> Result<BackendResult, BackendError>:
        Err(BackendError.not_implemented("compiler backend not yet implemented"))

    fn process_class(class_: HirClass) -> Result<BackendResult, BackendError>:
        Err(BackendError.not_implemented("compiler backend not yet implemented"))

    fn process_struct(struct_: HirStruct) -> Result<BackendResult, BackendError>:
        Err(BackendError.not_implemented("compiler backend not yet implemented"))

    fn process_enum(enum_: HirEnum) -> Result<BackendResult, BackendError>:
        Err(BackendError.not_implemented("compiler backend not yet implemented"))

    fn process_trait(trait_: HirTrait) -> Result<BackendResult, BackendError>:
        Err(BackendError.not_implemented("compiler backend not yet implemented"))

    fn process_impl(impl_: HirImpl) -> Result<BackendResult, BackendError>:
        Err(BackendError.not_implemented("compiler backend not yet implemented"))

    fn eval_expr(expr: HirExpr, ctx: EvalContext) -> Result<Value, BackendError>:
        Err(BackendError.not_implemented("compiler backend evaluates via generated code"))

    fn exec_stmt(stmt: HirStmt, ctx: EvalContext) -> Result<(), BackendError>:
        Err(BackendError.not_implemented("compiler backend executes via generated code"))

    fn is_allowed(expr: HirExpr) -> bool:
        true

    fn is_allowed_stmt(stmt: HirStmt) -> bool:
        true

# ============================================================================
# Exports
# ============================================================================

export CompilerBackendImpl
