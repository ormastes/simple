# VHDL Type Mapper - VHDL-Specific Type Mapping Implementation
#
# Maps MIR types to VHDL type strings.
# Follows IEEE 1076-2008 type conventions.

use compiler.mir_data.*
use compiler.backend.common.type_mapper.*
use compiler.hir_types.MemorySpace

# ============================================================================
# VHDL Type Mapper
# ============================================================================

class VhdlTypeMapper:
    """
    Maps MIR types to VHDL type representations.

    VHDL type mapping policy:
    - bool -> bit (unresolved) or std_logic (resolved)
    - i8/i16/i32/i64 -> signed(W-1 downto 0) from ieee.numeric_std
    - u8/u16/u32/u64 -> unsigned(W-1 downto 0) from ieee.numeric_std
    - [bool; N] -> bit_vector(N-1 downto 0) or std_logic_vector(N-1 downto 0)
    - struct -> record
    - enum -> type ... is (...)
    - f32/f64 -> error (not synthesizable)

    Example mappings:
        I64 -> "signed(63 downto 0)"
        U8  -> "unsigned(7 downto 0)"
        Bool -> "bit"
    """

    use_resolved: bool  # Use std_logic instead of bit

    static fn create() -> VhdlTypeMapper:
        """Create mapper with unresolved types (default)."""
        VhdlTypeMapper(use_resolved: false)

    static fn create_resolved() -> VhdlTypeMapper:
        """Create mapper with resolved std_logic types."""
        VhdlTypeMapper(use_resolved: true)

impl TypeMapper for VhdlTypeMapper:
    fn map_primitive(ty: PrimitiveType) -> text:
        """
        Map primitive types to VHDL types.

        VHDL uses ieee.numeric_std types for arithmetic:
        - signed(N-1 downto 0) for signed integers
        - unsigned(N-1 downto 0) for unsigned integers
        - bit or std_logic for booleans
        """
        match ty:
            case I64: "signed(63 downto 0)"
            case I32: "signed(31 downto 0)"
            case I16: "signed(15 downto 0)"
            case I8: "signed(7 downto 0)"
            case U64: "unsigned(63 downto 0)"
            case U32: "unsigned(31 downto 0)"
            case U16: "unsigned(15 downto 0)"
            case U8: "unsigned(7 downto 0)"
            case F64: "-- ERROR: f64 not synthesizable"
            case F32: "-- ERROR: f32 not synthesizable"
            case F16: "-- ERROR: f16 not synthesizable"
            case Bool:
                if self.use_resolved: "std_logic" else: "bit"
            case Unit: "-- void"

    fn map_pointer(pointee: text, mutability: Mutability) -> text:
        """
        VHDL does not have pointers.
        Pointers are not synthesizable; map to error comment.
        """
        "-- ERROR: pointers not synthesizable in VHDL"

    fn backend_name() -> text:
        "VHDL"

    fn map_memory_space(space: MemorySpace) -> text:
        """
        VHDL has no memory space qualifiers.
        Signals and variables have scope determined by declaration context.
        """
        ""  # No memory space qualifiers in VHDL

    fn map_vector_type(elem: text, width: i64) -> text:
        """
        Map vector type to VHDL array.
        """
        if self.use_resolved:
            "std_logic_vector({width - 1} downto 0)"
        else:
            "bit_vector({width - 1} downto 0)"

    fn supports_half_precision() -> bool:
        false  # VHDL does not support half precision natively

    fn supports_gpu() -> bool:
        false

impl VhdlTypeMapper:
    # === VHDL-specific methods ===

    fn map_signed(width: i64) -> text:
        """Map to signed type with specific width."""
        "signed({width - 1} downto 0)"

    fn map_unsigned(width: i64) -> text:
        """Map to unsigned type with specific width."""
        "unsigned({width - 1} downto 0)"

    fn map_integer_range(lo: i64, hi: i64) -> text:
        """Map to VHDL integer subtype with range constraint."""
        "integer range {lo} to {hi}"

    fn map_std_logic_vector(width: i64) -> text:
        """Map to std_logic_vector with specific width."""
        "std_logic_vector({width - 1} downto 0)"

    fn map_bit_vector(width: i64) -> text:
        """Map to bit_vector with specific width."""
        "bit_vector({width - 1} downto 0)"

    fn map_record(fields: [(text, text)]) -> text:
        """
        Map struct to VHDL record type.

        Example:
            record
                x : signed(31 downto 0);
                y : signed(31 downto 0);
            end record
        """
        var lines: [text] = ["record"]
        for field in fields:
            lines = lines.push("    {field.0} : {field.1};")
        lines = lines.push("end record")
        lines.join("\n")

    fn map_enum_type(variants: [text]) -> text:
        """
        Map enum to VHDL enumeration type.

        Example: (Idle, Running, Done)
        """
        "({variants.join(', ')})"

    fn map_array_type(element_type: text, size: i64) -> text:
        """
        Map fixed-size array to VHDL array type.
        """
        "array (0 to {size - 1}) of {element_type}"

    fn map_port_direction(dir: VhdlPortDirection) -> text:
        """Map port direction to VHDL keyword."""
        match dir:
            case In: "in"
            case Out: "out"
            case InOut: "inout"
            case Buffer: "buffer"

    fn bit_type() -> text:
        """Get the appropriate single-bit type."""
        if self.use_resolved: "std_logic" else: "bit"

    fn bit_vector_type(width: i64) -> text:
        """Get the appropriate bit vector type."""
        if self.use_resolved:
            "std_logic_vector({width - 1} downto 0)"
        else:
            "bit_vector({width - 1} downto 0)"

    fn width_of_type(ty: PrimitiveType) -> i64:
        """Get width in bits for a primitive type."""
        match ty:
            case I64 | U64: 64
            case I32 | U32: 32
            case I16 | U16: 16
            case I8 | U8: 8
            case Bool: 1
            case _: 0

    fn is_synthesizable(ty: PrimitiveType) -> bool:
        """Check if a type is synthesizable in VHDL."""
        match ty:
            case F16 | F32 | F64: false
            case _: true

    # === Size and alignment (VHDL-specific) ===

    fn size_of(ty: MirType) -> i64:
        """Get size in bits of a type (VHDL bit-level)."""
        match ty.kind:
            case I64, U64: 64
            case I32, U32: 32
            case I16, U16: 16
            case I8, U8: 8
            case Bool: 1
            case Unit: 0
            case Array(elem, size): self.size_of(elem) * size
            case _: 0

    fn align_of(ty: MirType) -> i64:
        """Get alignment in bits (always 1 for VHDL, bit-level)."""
        1

# ============================================================================
# Export
# ============================================================================

export VhdlTypeMapper

