# LLVM Backend
#
# LLVM-based code generation for the Simple compiler.
# Provides:
# - 32-bit architecture support (i686, armv7, riscv32)
# - Full optimization pipeline
# - Native code generation
# - Cross-compilation support
#
# Refactored: Split into submodules for modularity:
# - llvm_target.spl: Target triple and CPU configuration
# - llvm_ir_builder.spl: Optimization passes, IR builder, MIR→LLVM translation
#
# Usage:
#   val backend = LlvmBackend.create(target, opt_level)
#   val result = backend.compile_module(mir_module)

use compiler.mir_data.*
use compiler.backend.backend_api.*
use compiler.backend.backend_types.{CompiledModule, CompiledSymbol, CodegenTarget, OptimizationLevel}
use compiler.backend.llvm_target.{LlvmTargetTriple, LlvmTargetConfig, LlvmTargetTriple__from_target, LlvmTargetTriple__from_target_baremetal, LlvmTargetTriple__from_target_with_mode, LlvmTargetConfig__for_target, LlvmTargetConfig__for_target_baremetal, LlvmTargetConfig__for_target_with_mode, LlvmTargetConfig__compatibility_build}
use compiler.backend.llvm_ir_builder.{LlvmPass, passes_for_level, LlvmIRBuilder, MirToLlvm, LlvmIRBuilder__create, MirToLlvm__create, MirToLlvm__create_baremetal}
use app.io.mod (shell, file_write, file_delete, file_exists, getpid, time_now_unix_micros)

# FFI for reading binary files (object code)
extern fn rt_file_read_bytes(path: text) -> [u8]

# ============================================================================
# LLVM Backend
# ============================================================================

class LlvmBackend:
    """
    LLVM-based compilation backend with modern CPU defaults.

    Defaults to x86-64-v3 (Haswell, 2015+) for x86_64 targets, which enables:
    - AVX2 (256-bit SIMD) for 2-3x vectorization speedup
    - FMA (fused multiply-add) for better numerical code
    - BMI1/BMI2 (bit manipulation) for faster bit operations

    Use with_cpu_override() or compatibility_build() for older CPUs.
    Use create_baremetal() for bare-metal/embedded targets (no OS, no stdlib).
    """
    target: CodegenTarget
    opt_level: OptimizationLevel
    cpu_override: text?        # Override CPU (e.g., "x86-64" for compat)
    emit_llvm_ir: bool
    emit_assembly: bool
    debug_info: bool
    bare_metal: bool           # Bare-metal mode (no OS, no stdlib)

    static fn create(target: CodegenTarget, opt_level: OptimizationLevel) -> LlvmBackend:
        """Create backend with default CPU selection (x86-64-v3 for x86_64)."""
        LlvmBackend(
            target: target,
            opt_level: opt_level,
            cpu_override: nil,  # Auto-select based on target
            emit_llvm_ir: false,
            emit_assembly: false,
            debug_info: false,
            bare_metal: false
        )

    static fn create_baremetal(target: CodegenTarget, opt_level: OptimizationLevel) -> LlvmBackend:
        """
        Create backend for bare-metal/embedded targets.

        Bare-metal mode:
        - No OS (uses -none target triple)
        - No stdlib (no libc, no runtime)
        - Custom startup code (_start entry point)
        - Volatile operations for MMIO
        - Interrupt handlers supported

        Use for: embedded systems, kernels, bootloaders, firmware
        """
        LlvmBackend(
            target: target,
            opt_level: opt_level,
            cpu_override: nil,
            emit_llvm_ir: false,
            emit_assembly: false,
            debug_info: true,    # Enable debug info for bare-metal (helps with GDB)
            bare_metal: true
        )

    static fn compatibility_build(target: CodegenTarget, opt_level: OptimizationLevel) -> LlvmBackend:
        """
        Create backend for maximum compatibility (old CPUs).

        For x86_64, uses x86-64 baseline (2003+) instead of x86-64-v3 (2015+).
        Slower but works on older hardware.
        """
        val cpu_compat = match target:
            case CodegenTarget.X86_64: "x86-64"      # Baseline, no AVX
            case CodegenTarget.AArch64: "generic"     # Generic ARM
            case _: nil                               # Use default

        LlvmBackend(
            target: target,
            opt_level: opt_level,
            cpu_override: cpu_compat,
            emit_llvm_ir: false,
            emit_assembly: false,
            debug_info: false,
            bare_metal: false
        )

    static fn default_backend() -> LlvmBackend:
        """Default backend (Host target, Speed optimization, x86-64-v3 on x86_64)."""
        LlvmBackend__create(CodegenTarget.Host, OptimizationLevel.Speed)

    fn with_cpu_override(cpu: text) -> LlvmBackend:
        """Override target CPU (e.g., 'x86-64', 'haswell', 'skylake')."""
        LlvmBackend(
            target: self.target,
            opt_level: self.opt_level,
            cpu_override: Some(cpu),
            emit_llvm_ir: self.emit_llvm_ir,
            emit_assembly: self.emit_assembly,
            debug_info: self.debug_info
        )

    fn with_llvm_ir() -> LlvmBackend:
        """Enable LLVM IR output."""
        LlvmBackend(
            target: self.target,
            opt_level: self.opt_level,
            cpu_override: self.cpu_override,
            emit_llvm_ir: true,
            emit_assembly: self.emit_assembly,
            debug_info: self.debug_info
        )

    fn with_assembly() -> LlvmBackend:
        """Enable assembly output."""
        LlvmBackend(
            target: self.target,
            opt_level: self.opt_level,
            cpu_override: self.cpu_override,
            emit_llvm_ir: self.emit_llvm_ir,
            emit_assembly: true,
            debug_info: self.debug_info
        )

    fn with_debug_info() -> LlvmBackend:
        """Enable debug information (DWARF)."""
        LlvmBackend(
            target: self.target,
            opt_level: self.opt_level,
            cpu_override: self.cpu_override,
            emit_llvm_ir: self.emit_llvm_ir,
            emit_assembly: self.emit_assembly,
            debug_info: true
        )

    fn get_target_config() -> LlvmTargetConfig:
        """Get effective target configuration."""
        LlvmTargetConfig__for_target(self.target, self.cpu_override)

    fn compile_module(module: MirModule):
        """Compile a MIR module using LLVM."""
        val start_time = time_now_unix_micros()

        # Get target configuration (includes CPU selection)
        val config = if self.bare_metal:
            LlvmTargetConfig__for_target_baremetal(self.target, self.cpu_override)
        else:
            LlvmTargetConfig__for_target(self.target, self.cpu_override)

        # Translate MIR to LLVM IR
        var translator = if self.bare_metal:
            MirToLlvm__create_baremetal(module.name, self.target, self.cpu_override)
        else:
            MirToLlvm__create(module.name, self.target, self.cpu_override)

        # Add runtime FFI declarations
        val runtime_decls = generate_runtime_declarations()
        var llvm_ir = runtime_decls + "\n\n"
        llvm_ir = llvm_ir + translator.translate_module(module)

        # Compile IR to object code
        var object_code: [u8]? = nil
        if not self.emit_llvm_ir:  # Skip object generation if only IR requested
            val obj_result = compile_ir_to_object(llvm_ir, config, self.opt_level)
            if obj_result.is_err():
                return Err(obj_result.unwrap_err())
            object_code = Some(obj_result.unwrap())

        val end_time = time_now_unix_micros()
        val compile_time = (end_time - start_time) / 1000  # Convert to ms

        Ok(LlvmCompileResult(
            module_name: module.name,
            llvm_ir: if self.emit_llvm_ir: Some(llvm_ir) else: nil,
            assembly: if self.emit_assembly: Some("; LLVM generated assembly") else: nil,
            object_code: object_code,
            compile_time_ms: compile_time
        ))

struct LlvmCompileResult:
    """Result of LLVM compilation."""
    module_name: text
    llvm_ir: text?
    assembly: text?
    object_code: [u8]?
    compile_time_ms: i64

impl LlvmCompileResult:
    fn has_object_code() -> bool:
        self.object_code.?

    fn to_compiled_module() -> CompiledModule:
        """Convert LLVM compile result to standard CompiledModule format."""
        CompiledModule(
            name: self.module_name,
            object_code: self.object_code,
            assembly: self.assembly,
            llvm_ir: self.llvm_ir,
            mir_dump: nil,
            symbols: [],  # TODO: Extract symbols from object code
            compile_time_ms: self.compile_time_ms
        )

# ============================================================================
# Runtime FFI Declarations
# ============================================================================

fn generate_runtime_declarations() -> text:
    """
    Generate LLVM IR declarations for runtime functions.

    These declarations allow compiled code to call runtime functions
    for I/O, memory management, strings, collections, etc.
    """
    var decls = "; Runtime function declarations\n"

    # File I/O
    decls = decls + "declare ptr @rt_file_open(ptr, ptr)\n"
    decls = decls + "declare void @rt_file_close(ptr)\n"
    decls = decls + "declare ptr @rt_file_read_text(ptr)\n"
    decls = decls + "declare i1 @rt_file_write(ptr, ptr)\n"
    decls = decls + "declare ptr @rt_file_read_bytes(ptr)\n"
    decls = decls + "declare i1 @rt_file_write_bytes(ptr, ptr, i64)\n"
    decls = decls + "declare i1 @rt_file_exists(ptr)\n"
    decls = decls + "declare i1 @rt_file_delete(ptr)\n"
    decls = decls + "declare i1 @rt_file_copy(ptr, ptr)\n"
    decls = decls + "declare i1 @rt_file_move(ptr, ptr)\n"
    decls = decls + "declare i64 @rt_file_size(ptr)\n"
    decls = decls + "declare i1 @rt_file_lock(ptr)\n"
    decls = decls + "declare i1 @rt_file_unlock(ptr)\n"

    # Directory operations
    decls = decls + "declare i1 @rt_dir_create(ptr)\n"
    decls = decls + "declare i1 @rt_dir_delete(ptr)\n"
    decls = decls + "declare i1 @rt_dir_exists(ptr)\n"
    decls = decls + "declare ptr @rt_dir_list(ptr)\n"

    # Process operations
    decls = decls + "declare ptr @rt_process_spawn(ptr, ptr, i64)\n"
    decls = decls + "declare i64 @rt_process_wait(ptr)\n"
    decls = decls + "declare ptr @rt_getenv(ptr)\n"
    decls = decls + "declare i1 @rt_setenv(ptr, ptr)\n"
    decls = decls + "declare i64 @rt_getpid()\n"
    decls = decls + "declare void @rt_exit(i64)\n"

    # Memory operations
    decls = decls + "declare ptr @rt_alloc(i64)\n"
    decls = decls + "declare ptr @rt_realloc(ptr, i64)\n"
    decls = decls + "declare void @rt_free(ptr)\n"
    decls = decls + "declare ptr @rt_memcpy(ptr, ptr, i64)\n"
    decls = decls + "declare ptr @rt_memset(ptr, i8, i64)\n"
    decls = decls + "declare i64 @rt_memcmp(ptr, ptr, i64)\n"

    # String operations
    decls = decls + "declare i64 @rt_strlen(ptr)\n"
    decls = decls + "declare ptr @rt_strcat(ptr, ptr)\n"
    decls = decls + "declare ptr @rt_substr(ptr, i64, i64)\n"
    decls = decls + "declare i64 @rt_strfind(ptr, ptr)\n"
    decls = decls + "declare ptr @rt_strreplace(ptr, ptr, ptr)\n"
    decls = decls + "declare ptr @rt_strsplit(ptr, ptr)\n"
    decls = decls + "declare i64 @rt_strcmp(ptr, ptr)\n"

    # Array/Collection operations
    decls = decls + "declare ptr @rt_array_new(i64)\n"
    decls = decls + "declare i64 @rt_array_len(ptr)\n"
    decls = decls + "declare ptr @rt_array_get(ptr, i64)\n"
    decls = decls + "declare void @rt_array_set(ptr, i64, ptr)\n"
    decls = decls + "declare ptr @rt_array_push(ptr, ptr)\n"
    decls = decls + "declare ptr @rt_array_pop(ptr)\n"

    # Dict/Map operations
    decls = decls + "declare ptr @rt_dict_new()\n"
    decls = decls + "declare ptr @rt_dict_get(ptr, ptr)\n"
    decls = decls + "declare void @rt_dict_set(ptr, ptr, ptr)\n"
    decls = decls + "declare i1 @rt_dict_contains(ptr, ptr)\n"
    decls = decls + "declare i64 @rt_dict_len(ptr)\n"

    # I/O operations
    decls = decls + "declare void @rt_print(ptr)\n"
    decls = decls + "declare void @rt_println(ptr)\n"
    decls = decls + "declare ptr @rt_readline()\n"

    # Time operations
    decls = decls + "declare i64 @rt_time_now_unix()\n"
    decls = decls + "declare i64 @rt_time_now_unix_micros()\n"
    decls = decls + "declare void @rt_sleep_ms(i64)\n"

    # Error handling
    decls = decls + "declare void @rt_panic(ptr)\n"
    decls = decls + "declare void @abort()\n"

    # Math operations
    decls = decls + "declare double @rt_sin(double)\n"
    decls = decls + "declare double @rt_cos(double)\n"
    decls = decls + "declare double @rt_sqrt(double)\n"
    decls = decls + "declare double @rt_pow(double, double)\n"

    # LLVM intrinsics
    decls = decls + "declare void @llvm.memcpy.p0.p0.i64(ptr, ptr, i64, i1)\n"
    decls = decls + "declare void @llvm.memset.p0.i64(ptr, i8, i64, i1)\n"
    decls = decls + "declare i64 @llvm.powi.i64.i64(i64, i64)\n"

    decls

# ============================================================================
# LLVM IR → Object Code Compilation (via llc CLI)
# ============================================================================

fn find_llc() -> text?:
    """
    Find llc binary with fallback chain: llc-18 → llc-17 → llc.

    Returns the command name if found, otherwise nil.
    """
    val candidates = ["llc-18", "llc-17", "llc-16", "llc"]
    for candidate in candidates:
        val result = shell("command -v {candidate} >/dev/null 2>&1")
        if result.exit_code == 0:
            return Some(candidate)
    nil

fn llc_available() -> bool:
    """Check if llc (LLVM static compiler) is available on PATH."""
    find_llc().?

fn compile_ir_to_object(llvm_ir: text, config: LlvmTargetConfig, opt_level: OptimizationLevel):
    """Compile LLVM IR text to object code bytes via llc CLI.

    Writes IR to a temp file, invokes llc, reads back the object bytes.
    Requires llc to be installed (apt install llvm / brew install llvm).

    Tries llc-18, llc-17, llc-16, llc in order (newer versions preferred).
    """
    # Find llc binary
    val llc_cmd = find_llc()
    if not llc_cmd.?:
        return Err(
            "llc not found. Please install LLVM:\n" +
            "  Ubuntu/Debian: apt install llvm\n" +
            "  macOS: brew install llvm\n" +
            "  Arch: pacman -S llvm\n" +
            "  Windows: choco install llvm"
        )

    val llc = llc_cmd.unwrap()
    val pid = getpid()
    val ir_path = "/tmp/simple_llvm_{pid}.ll"
    val obj_path = "/tmp/simple_llvm_{pid}.o"

    # Write IR to temp file
    if not file_write(ir_path, llvm_ir):
        return Err("Failed to write LLVM IR to {ir_path}")

    # Determine optimization flag
    var opt_flag = "-O0"
    if opt_level == OptimizationLevel.Size:
        opt_flag = "-Oz"
    elif opt_level == OptimizationLevel.Speed:
        opt_flag = "-O2"
    elif opt_level == OptimizationLevel.Aggressive:
        opt_flag = "-O3"
    elif opt_level == OptimizationLevel.Debug:
        opt_flag = "-O0"

    # Build llc command
    val triple = config.triple.to_text()
    val cpu = config.to_cpu_string()
    val cmd = "{llc} --filetype=obj --relocation-model=pic -mtriple={triple} -mcpu={cpu} {opt_flag} -o {obj_path} {ir_path} 2>&1"
    val result = shell(cmd)

    # Clean up IR file
    file_delete(ir_path)

    if result.exit_code != 0:
        file_delete(obj_path)
        return Err("llc failed (exit {result.exit_code}):\n{result.stdout}\n\nCommand: {cmd}")

    # Read object bytes
    val bytes = rt_file_read_bytes(obj_path)
    file_delete(obj_path)

    if bytes == nil:
        return Err("Failed to read compiled object file: {obj_path}")

    Ok(bytes)

# ============================================================================
# Desugared static methods
# ============================================================================

fn LlvmBackend__create(target: CodegenTarget, opt_level: OptimizationLevel) -> LlvmBackend:
    LlvmBackend.create(target, opt_level)

fn LlvmBackend__create_baremetal(target: CodegenTarget, opt_level: OptimizationLevel) -> LlvmBackend:
    LlvmBackend.create_baremetal(target, opt_level)

fn LlvmBackend__compatibility_build(target: CodegenTarget, opt_level: OptimizationLevel) -> LlvmBackend:
    LlvmBackend.compatibility_build(target, opt_level)

fn LlvmBackend__default_backend() -> LlvmBackend:
    LlvmBackend.default_backend()

# ============================================================================
# Exports - includes re-exports from submodules for backward compatibility
# ============================================================================

# Re-export from llvm_target.spl
export LlvmTargetTriple, LlvmTargetConfig
export LlvmTargetTriple__from_target, LlvmTargetTriple__from_target_baremetal, LlvmTargetTriple__from_target_with_mode
export LlvmTargetConfig__for_target, LlvmTargetConfig__for_target_baremetal, LlvmTargetConfig__for_target_with_mode
export LlvmTargetConfig__compatibility_build

# Re-export from llvm_ir_builder.spl
export LlvmPass, passes_for_level
export LlvmIRBuilder, MirToLlvm
export LlvmIRBuilder__create
export MirToLlvm__create, MirToLlvm__create_baremetal

# This module's exports
export LlvmBackend, LlvmCompileResult
export compile_ir_to_object, llc_available, find_llc, generate_runtime_declarations
export LlvmBackend__create, LlvmBackend__create_baremetal, LlvmBackend__compatibility_build, LlvmBackend__default_backend
