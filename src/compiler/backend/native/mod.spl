# Native Backend - Direct Machine Code Generation
#
# Produces native object files (.o) directly from MIR without external toolchains.
# No gcc, clang, llc, or any external tool needed.
#
# Pipeline: MIR -> ISel -> RegAlloc -> Encode -> ELF
#
# Supported architectures:
# - x86_64 (Linux ELF)
# - AArch64 (Linux ELF) - Phase 8
# - RISC-V 64 (Linux ELF) - Phase 9

use compiler.mir_data.{MirModule, MirFunction}
use compiler.backend.backend_types.{CodegenTarget, CompiledModule, CompiledSymbol, CompiledSymbolKind, CompileError, BackendKind}
use compiler.backend.native.mach_inst.{MachModule, MachFunction, EncodedFunction, new_encoded_function}
use compiler.backend.native.isel_x86_64.{isel_module}
use compiler.backend.native.isel_aarch64.{isel_module_aarch64}
use compiler.backend.native.isel_riscv64.{isel_module_riscv64}
use compiler.backend.native.regalloc.{regalloc_module}
use compiler.backend.native.encode_x86_64.{encode_module}
use compiler.backend.native.encode_aarch64.{encode_module_aarch64}
use compiler.backend.native.encode_riscv64.{encode_module_riscv64}
use compiler.backend.native.elf_writer.{ElfWriter, ElfSection, ElfSectionKind, ElfSymbol, ElfSymbolBind, ElfSymbolType, ElfReloc, ElfRelocType, elf_writer_x86_64, elf_writer_aarch64, elf_writer_riscv64, elf_add_section, elf_add_symbol, new_text_section, new_data_section, new_rodata_section, section_add_reloc, new_func_symbol, new_extern_symbol, write_elf64}

# ============================================================================
# Native Backend Entry Point
# ============================================================================

fn compile_native(module: MirModule, target: CodegenTarget) -> [i64]:
    match target:
        case X86_64:
            compile_native_x86_64(module)
        case AArch64:
            compile_native_aarch64(module)
        case Riscv64:
            compile_native_riscv64(module)
        case _:
            compile_native_stub(module, "unsupported")

fn compile_native_x86_64(module: MirModule) -> [i64]:
    # Phase 1: Instruction Selection (MIR -> MachInst)
    val mach_module = isel_module(module)

    # Phase 2: Register Allocation (virtual -> physical regs)
    val allocated = regalloc_module(mach_module)

    # Phase 3: Instruction Encoding (MachInst -> bytes)
    val encoded_funcs = encode_module(allocated)

    # Phase 4: Emit ELF object file
    emit_elf_x86_64(encoded_funcs, allocated)

fn compile_native_aarch64(module: MirModule) -> [i64]:
    # Phase 1: Instruction Selection (MIR -> MachInst)
    val mach_module = isel_module_aarch64(module)

    # Phase 2: Register Allocation (virtual -> physical regs)
    val allocated = regalloc_module(mach_module)

    # Phase 3: Instruction Encoding (MachInst -> bytes)
    val encoded_funcs = encode_module_aarch64(allocated)

    # Phase 4: Emit ELF object file
    emit_elf_aarch64(encoded_funcs, allocated)

fn compile_native_riscv64(module: MirModule) -> [i64]:
    # Phase 1: Instruction Selection (MIR -> MachInst)
    val mach_module = isel_module_riscv64(module)

    # Phase 2: Register Allocation (virtual -> physical regs)
    val allocated = regalloc_module(mach_module)

    # Phase 3: Instruction Encoding (MachInst -> bytes)
    val encoded_funcs = encode_module_riscv64(allocated)

    # Phase 4: Emit ELF object file
    emit_elf_riscv64(encoded_funcs, allocated)

fn compile_native_stub(module: MirModule, arch: text) -> [i64]:
    # Stub for unsupported architectures - returns empty ELF
    var writer = elf_writer_x86_64()
    val text_section = new_text_section([0xc3])  # Just a ret
    writer = elf_add_section(writer, text_section)
    write_elf64(writer)

# ============================================================================
# ELF Emission
# ============================================================================

fn emit_elf_x86_64(encoded_funcs: [EncodedFunction], module: MachModule) -> [i64]:
    var writer = elf_writer_x86_64()

    # Combine all function code into a single .text section
    var all_code: [i64] = []
    var func_offsets: Dict<text, i64> = {}
    var all_relocs: [ElfReloc] = []

    # Build symbol name -> index mapping for relocations
    # Symbols are ordered: data labels, extern symbols, function names
    var sym_names: [text] = []
    var sym_name_to_idx: Dict<text, i64> = {}

    # First collect data entry labels (local symbols in rodata)
    var rodata_offset = 0
    var data_label_offsets: Dict<text, i64> = {}
    for entry in module.data_sections:
        if entry.is_readonly:
            if not sym_name_to_idx.contains(entry.name):
                val idx = sym_names.len()
                sym_names = sym_names + [entry.name]
                sym_name_to_idx[entry.name] = idx
                data_label_offsets[entry.name] = rodata_offset
            rodata_offset = rodata_offset + entry.data.len()

    # Then collect extern symbols
    for ext_sym in module.extern_symbols:
        if not sym_name_to_idx.contains(ext_sym):
            val idx = sym_names.len()
            sym_names = sym_names + [ext_sym]
            sym_name_to_idx[ext_sym] = idx

    # Then collect function names
    for func in encoded_funcs:
        if not sym_name_to_idx.contains(func.name):
            val idx = sym_names.len()
            sym_names = sym_names + [func.name]
            sym_name_to_idx[func.name] = idx

    # Count content sections for symbol index offset
    # ELF writer inserts section symbols: [0:null] [1..N:section syms] [N+1..:user syms]
    var num_content_sections = 1  # .text always present
    var has_rodata = false
    var has_data = false
    for entry in module.data_sections:
        if entry.is_readonly:
            has_rodata = true
        else:
            has_data = true
    if has_rodata:
        num_content_sections = num_content_sections + 1
    if has_data:
        num_content_sections = num_content_sections + 1
    val sym_base = 1 + num_content_sections

    # Concatenate function code and track offsets
    for func in encoded_funcs:
        # Align to 16 bytes
        var padding = all_code.len() % 16
        if padding != 0:
            padding = 16 - padding
        for i in 0..padding:
            all_code = all_code + [0xcc]  # int3 padding
        func_offsets[func.name] = all_code.len()

        val code_start = all_code.len()
        all_code = all_code + func.code

        # Adjust relocation offsets
        for reloc in func.relocations:
            var reloc_type = ElfRelocType.X86_64_PLT32
            if reloc.reloc_type == 2:
                reloc_type = ElfRelocType.X86_64_PC32
            elif reloc.reloc_type == 1:
                reloc_type = ElfRelocType.X86_64_64

            # Look up the symbol index
            var sym_idx = 0
            if sym_name_to_idx.contains(reloc.symbol_name):
                sym_idx = sym_name_to_idx[reloc.symbol_name]
            val elf_reloc = ElfReloc(
                offset: code_start + reloc.offset,
                reloc_type: reloc_type,
                symbol_index: sym_base + sym_idx,
                addend: reloc.addend
            )
            all_relocs = all_relocs + [elf_reloc]

    # Create .text section
    var text_section = new_text_section(all_code)
    for reloc in all_relocs:
        text_section = section_add_reloc(text_section, reloc)
    writer = elf_add_section(writer, text_section)

    # Create .rodata section for string constants
    var rodata_bytes: [i64] = []
    for entry in module.data_sections:
        if entry.is_readonly:
            rodata_bytes = rodata_bytes + entry.data
    if rodata_bytes.len() > 0:
        writer = elf_add_section(writer, new_rodata_section(rodata_bytes))

    # Create .data section for mutable data
    var data_bytes: [i64] = []
    for entry in module.data_sections:
        if not entry.is_readonly:
            data_bytes = data_bytes + entry.data
    if data_bytes.len() > 0:
        writer = elf_add_section(writer, new_data_section(data_bytes))

    # Add data label symbols (local, in rodata)
    for entry in module.data_sections:
        if entry.is_readonly:
            if data_label_offsets.contains(entry.name):
                val sym = ElfSymbol(
                    name: entry.name,
                    sym_bind: ElfSymbolBind.Local,
                    sym_type: ElfSymbolType.Object,
                    section_index: 2,
                    value: data_label_offsets[entry.name],
                    size: entry.data.len()
                )
                writer = elf_add_symbol(writer, sym)

    # Add extern symbols (undefined, global) â€” deduplicated
    var added_extern_syms: Dict<text, bool> = {}
    for ext_sym in module.extern_symbols:
        if not added_extern_syms.contains(ext_sym):
            added_extern_syms[ext_sym] = true
            writer = elf_add_symbol(writer, new_extern_symbol(ext_sym))

    # Add function symbols (defined, global)
    for func in encoded_funcs:
        var offset = 0
        if func_offsets.contains(func.name):
            offset = func_offsets[func.name]
        val sym = new_func_symbol(func.name, 1, offset, func.code.len())
        writer = elf_add_symbol(writer, sym)

    write_elf64(writer)

fn emit_elf_aarch64(encoded_funcs: [EncodedFunction], module: MachModule) -> [i64]:
    var writer = elf_writer_aarch64()

    # Combine all function code into a single .text section
    var all_code: [i64] = []
    var func_offsets: Dict<text, i64> = {}
    var all_relocs: [ElfReloc] = []
    var sym_names: [text] = []
    var sym_name_to_idx: Dict<text, i64> = {}

    # Collect data entry labels
    var rodata_offset_a = 0
    var data_label_offsets_a: Dict<text, i64> = {}
    for entry in module.data_sections:
        if entry.is_readonly:
            if not sym_name_to_idx.contains(entry.name):
                val idx = sym_names.len()
                sym_names = sym_names + [entry.name]
                sym_name_to_idx[entry.name] = idx
                data_label_offsets_a[entry.name] = rodata_offset_a
            rodata_offset_a = rodata_offset_a + entry.data.len()

    # Collect extern symbols
    for ext_sym in module.extern_symbols:
        if not sym_name_to_idx.contains(ext_sym):
            val idx = sym_names.len()
            sym_names = sym_names + [ext_sym]
            sym_name_to_idx[ext_sym] = idx

    # Collect function names
    for func in encoded_funcs:
        if not sym_name_to_idx.contains(func.name):
            val idx = sym_names.len()
            sym_names = sym_names + [func.name]
            sym_name_to_idx[func.name] = idx

    # Count content sections for symbol index offset
    var num_cs_a = 1
    var has_rodata_a = false
    var has_data_a = false
    for entry in module.data_sections:
        if entry.is_readonly:
            has_rodata_a = true
        else:
            has_data_a = true
    if has_rodata_a:
        num_cs_a = num_cs_a + 1
    if has_data_a:
        num_cs_a = num_cs_a + 1
    val sym_base_a = 1 + num_cs_a

    # Concatenate function code (AArch64: 4-byte instruction alignment)
    for func in encoded_funcs:
        var padding = all_code.len() % 4
        if padding != 0:
            padding = 4 - padding
        for i in 0..padding:
            all_code = all_code + [0x00]
        func_offsets[func.name] = all_code.len()

        val code_start = all_code.len()
        all_code = all_code + func.code

        # Adjust relocation offsets
        for reloc in func.relocations:
            var reloc_type = ElfRelocType.Aarch64_Call26
            if reloc.reloc_type == 2:
                reloc_type = ElfRelocType.Aarch64_AdrPrelPgHi21

            var sym_idx = 0
            if sym_name_to_idx.contains(reloc.symbol_name):
                sym_idx = sym_name_to_idx[reloc.symbol_name]
            val elf_reloc = ElfReloc(
                offset: code_start + reloc.offset,
                reloc_type: reloc_type,
                symbol_index: sym_base_a + sym_idx,
                addend: reloc.addend
            )
            all_relocs = all_relocs + [elf_reloc]

    # Create .text section
    var text_section = new_text_section(all_code)
    for reloc in all_relocs:
        text_section = section_add_reloc(text_section, reloc)
    writer = elf_add_section(writer, text_section)

    # Create .rodata section
    var rodata_bytes: [i64] = []
    for entry in module.data_sections:
        if entry.is_readonly:
            rodata_bytes = rodata_bytes + entry.data
    if rodata_bytes.len() > 0:
        writer = elf_add_section(writer, new_rodata_section(rodata_bytes))

    # Create .data section
    var data_bytes: [i64] = []
    for entry in module.data_sections:
        if not entry.is_readonly:
            data_bytes = data_bytes + entry.data
    if data_bytes.len() > 0:
        writer = elf_add_section(writer, new_data_section(data_bytes))

    # Add data label symbols (local, in rodata)
    for entry in module.data_sections:
        if entry.is_readonly:
            if data_label_offsets_a.contains(entry.name):
                val sym = ElfSymbol(
                    name: entry.name,
                    sym_bind: ElfSymbolBind.Local,
                    sym_type: ElfSymbolType.Object,
                    section_index: 2,
                    value: data_label_offsets_a[entry.name],
                    size: entry.data.len()
                )
                writer = elf_add_symbol(writer, sym)

    # Add symbols
    for ext_sym in module.extern_symbols:
        writer = elf_add_symbol(writer, new_extern_symbol(ext_sym))

    for func in encoded_funcs:
        var offset = 0
        if func_offsets.contains(func.name):
            offset = func_offsets[func.name]
        val sym = new_func_symbol(func.name, 1, offset, func.code.len())
        writer = elf_add_symbol(writer, sym)

    write_elf64(writer)

fn emit_elf_riscv64(encoded_funcs: [EncodedFunction], module: MachModule) -> [i64]:
    var writer = elf_writer_riscv64()

    # Combine all function code into a single .text section
    var all_code: [i64] = []
    var func_offsets: Dict<text, i64> = {}
    var all_relocs: [ElfReloc] = []
    var sym_names: [text] = []
    var sym_name_to_idx: Dict<text, i64> = {}

    # Collect data entry labels
    var rodata_offset_r = 0
    var data_label_offsets_r: Dict<text, i64> = {}
    for entry in module.data_sections:
        if entry.is_readonly:
            if not sym_name_to_idx.contains(entry.name):
                val idx = sym_names.len()
                sym_names = sym_names + [entry.name]
                sym_name_to_idx[entry.name] = idx
                data_label_offsets_r[entry.name] = rodata_offset_r
            rodata_offset_r = rodata_offset_r + entry.data.len()

    # Collect extern symbols
    for ext_sym in module.extern_symbols:
        if not sym_name_to_idx.contains(ext_sym):
            val idx = sym_names.len()
            sym_names = sym_names + [ext_sym]
            sym_name_to_idx[ext_sym] = idx

    # Collect function names
    for func in encoded_funcs:
        if not sym_name_to_idx.contains(func.name):
            val idx = sym_names.len()
            sym_names = sym_names + [func.name]
            sym_name_to_idx[func.name] = idx

    # Count content sections
    var num_cs_r = 1
    var has_rodata_r = false
    var has_data_r = false
    for entry in module.data_sections:
        if entry.is_readonly:
            has_rodata_r = true
        else:
            has_data_r = true
    if has_rodata_r:
        num_cs_r = num_cs_r + 1
    if has_data_r:
        num_cs_r = num_cs_r + 1
    val sym_base_r = 1 + num_cs_r

    # Concatenate function code (RISC-V: 4-byte instruction alignment)
    for func in encoded_funcs:
        var padding = all_code.len() % 4
        if padding != 0:
            padding = 4 - padding
        for i in 0..padding:
            all_code = all_code + [0x00]
        func_offsets[func.name] = all_code.len()

        val code_start = all_code.len()
        all_code = all_code + func.code

        # Adjust relocation offsets
        for reloc in func.relocations:
            var reloc_type = ElfRelocType.Riscv_CallPlt
            if reloc.reloc_type == 23:
                reloc_type = ElfRelocType.Riscv_PcrelHi20
            elif reloc.reloc_type == 24:
                reloc_type = ElfRelocType.Riscv_PcrelLo12I

            var sym_idx = 0
            if sym_name_to_idx.contains(reloc.symbol_name):
                sym_idx = sym_name_to_idx[reloc.symbol_name]
            val elf_reloc = ElfReloc(
                offset: code_start + reloc.offset,
                reloc_type: reloc_type,
                symbol_index: sym_base_r + sym_idx,
                addend: reloc.addend
            )
            all_relocs = all_relocs + [elf_reloc]

    # Create .text section
    var text_section = new_text_section(all_code)
    for reloc in all_relocs:
        text_section = section_add_reloc(text_section, reloc)
    writer = elf_add_section(writer, text_section)

    # Create .rodata section
    var rodata_bytes: [i64] = []
    for entry in module.data_sections:
        if entry.is_readonly:
            rodata_bytes = rodata_bytes + entry.data
    if rodata_bytes.len() > 0:
        writer = elf_add_section(writer, new_rodata_section(rodata_bytes))

    # Create .data section
    var data_bytes: [i64] = []
    for entry in module.data_sections:
        if not entry.is_readonly:
            data_bytes = data_bytes + entry.data
    if data_bytes.len() > 0:
        writer = elf_add_section(writer, new_data_section(data_bytes))

    # Add data label symbols (local, in rodata)
    for entry in module.data_sections:
        if entry.is_readonly:
            if data_label_offsets_r.contains(entry.name):
                val sym = ElfSymbol(
                    name: entry.name,
                    sym_bind: ElfSymbolBind.Local,
                    sym_type: ElfSymbolType.Object,
                    section_index: 2,
                    value: data_label_offsets_r[entry.name],
                    size: entry.data.len()
                )
                writer = elf_add_symbol(writer, sym)

    # Add symbols
    for ext_sym in module.extern_symbols:
        writer = elf_add_symbol(writer, new_extern_symbol(ext_sym))

    for func in encoded_funcs:
        var offset = 0
        if func_offsets.contains(func.name):
            offset = func_offsets[func.name]
        val sym = new_func_symbol(func.name, 1, offset, func.code.len())
        writer = elf_add_symbol(writer, sym)

    write_elf64(writer)

# ============================================================================
# High-Level API
# ============================================================================

fn native_compile_to_object(module: MirModule, target: CodegenTarget) -> [i64]:
    compile_native(module, target)

fn native_compile_result(module: MirModule, target: CodegenTarget) -> CompiledModule:
    val object_bytes = compile_native(module, target)
    CompiledModule(
        name: module.name,
        object_code: Some(object_bytes),
        assembly: nil,
        llvm_ir: nil,
        mir_dump: nil,
        symbols: [],
        compile_time_ms: 0
    )

# ============================================================================
# SMF Generation with Embedded Object Code
# ============================================================================
#
# Generates SMF v1.1 files with native ELF object code embedded.
# Self-contained: no dependency on smf_writer.spl or smf_header.spl
# (which can't load in interpreter due to triple-quoted strings/generics).
#
# SMF v1.1 layout (trailer-based, like ZIP):
#   [Object code bytes]   offset 0
#   [Section table]        1+ entries, 64 bytes each
#   [Symbol table]         1+ entries, 52 bytes each
#   [String table]         null-terminated names
#   [Header - 128 bytes]   trailer at EOF

fn compile_native_to_smf(module: MirModule, target: CodegenTarget) -> [i64]:
    val obj_bytes = compile_native(module, target)
    wrap_object_in_smf(obj_bytes, module.name, target)

fn wrap_object_in_smf(obj_bytes: [i64], module_name: text, target: CodegenTarget) -> [i64]:
    # Determine architecture byte for SMF header
    val arch_byte = target_to_arch_byte(target)
    val platform_byte = 1  # Linux

    # Layout calculation
    val obj_size = obj_bytes.len()
    val section_entry_size = 64
    val symbol_entry_size = 52
    val section_count = 1      # Just the code section
    val symbol_count = 1       # "main" symbol

    # Build string table: "main\0"
    val strtab: [i64] = [109, 97, 105, 110, 0]  # "main\0"

    # Calculate offsets
    val code_offset = 0
    val section_table_offset = obj_size
    val section_table_size = section_count * section_entry_size
    val symbol_table_offset = section_table_offset + section_table_size
    val symbol_table_size = symbol_count * symbol_entry_size
    val string_table_offset = symbol_table_offset + symbol_table_size

    # Build SMF bytes
    var smf: [i64] = []

    # 1. Object code at offset 0
    smf = smf + obj_bytes

    # 2. Section table - code section entry (64 bytes)
    smf = smf + [1]                              # section_type = Code
    smf = smf + [0, 0, 0]                        # padding
    smf = smf + smf_u32_bytes(5)                  # flags = READ|EXEC (0x05)
    smf = smf + smf_u64_bytes(code_offset)        # offset
    smf = smf + smf_u64_bytes(obj_size)           # size
    smf = smf + smf_u64_bytes(obj_size)           # virtual_size
    smf = smf + smf_u32_bytes(16)                 # alignment
    # Section name "code" (16 bytes, zero-padded)
    smf = smf + [99, 111, 100, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    # Pad to 64 bytes (36 + 16 = 52, need 12 more)
    smf = smf + [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

    # 3. Symbol table - "main" entry (52 bytes)
    smf = smf + smf_u32_bytes(0)                  # name_offset in string table
    smf = smf + smf_u64_bytes(smf_hash_name("main"))  # name_hash
    smf = smf + [1]                               # sym_type = Function
    smf = smf + [1]                               # binding = Global
    smf = smf + [0]                               # visibility
    smf = smf + [0]                               # flags
    smf = smf + smf_u64_bytes(0)                  # value (offset in code section)
    smf = smf + smf_u64_bytes(obj_size)           # size
    smf = smf + smf_u32_bytes(0)                  # type_id
    smf = smf + smf_u32_bytes(0)                  # version
    smf = smf + [0]                               # template_param_count
    smf = smf + [0, 0, 0]                         # reserved
    smf = smf + smf_u64_bytes(0)                  # template_offset

    # 4. String table
    smf = smf + strtab

    # 5. SMF Header (128 bytes) - trailer at end
    # Identification (8 bytes)
    smf = smf + [83, 77, 70, 0]                   # magic "SMF\0"
    smf = smf + [1]                               # version_major
    smf = smf + [1]                               # version_minor
    smf = smf + [platform_byte]                   # platform
    smf = smf + [arch_byte]                       # arch

    # Flags and counts (20 bytes)
    smf = smf + smf_u32_bytes(1)                  # flags = EXECUTABLE
    smf = smf + [0]                               # compression = none
    smf = smf + [0]                               # compression_level
    smf = smf + [0, 0]                            # reserved_compression
    smf = smf + smf_u32_bytes(section_count)      # section_count
    smf = smf + smf_u64_bytes(section_table_offset) # section_table_offset

    # Symbols (16 bytes)
    smf = smf + smf_u64_bytes(symbol_table_offset)  # symbol_table_offset
    smf = smf + smf_u32_bytes(symbol_count)       # symbol_count
    smf = smf + smf_u32_bytes(1)                  # exported_count

    # Execution (16 bytes)
    smf = smf + smf_u64_bytes(0)                  # entry_point
    smf = smf + smf_u32_bytes(0)                  # stub_size
    smf = smf + smf_u32_bytes(0)                  # smf_data_offset

    # Hashing (16 bytes)
    smf = smf + smf_u64_bytes(0)                  # module_hash
    smf = smf + smf_u64_bytes(0)                  # source_hash

    # Hints (12 bytes)
    smf = smf + [0]                               # app_type = CLI
    smf = smf + smf_u16_bytes(1280)               # window_width
    smf = smf + smf_u16_bytes(720)                # window_height
    smf = smf + [0]                               # prefetch_hint
    smf = smf + [0]                               # prefetch_file_count
    smf = smf + [0, 0, 0, 0, 0]                  # reserved_hints

    # Reserved (40 bytes)
    smf = smf + [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

    smf

# SMF binary helpers (self-contained, no imports needed)
# Uses % and / instead of bitwise and/shift (and/or/xor are boolean in interpreter)

fn smf_byte_of(value: i64, shift: i64) -> i64:
    # Extract byte at position 'shift' (0, 8, 16, 24, 32, 40, 48, 56)
    var v = value
    # Divide by 2^shift
    for i in 0..shift:
        v = v / 2
    v % 256

fn smf_u16_bytes(value: i64) -> [i64]:
    val b0 = value % 256
    val b1 = (value / 256) % 256
    [b0, b1]

fn smf_u32_bytes(value: i64) -> [i64]:
    val b0 = value % 256
    val b1 = (value / 256) % 256
    val b2 = (value / 65536) % 256
    val b3 = (value / 16777216) % 256
    [b0, b1, b2, b3]

fn smf_u64_bytes(value: i64) -> [i64]:
    val b0 = value % 256
    val b1 = (value / 256) % 256
    val b2 = (value / 65536) % 256
    val b3 = (value / 16777216) % 256
    val b4 = (value / 4294967296) % 256
    val b5 = (value / 1099511627776) % 256
    val b6 = (value / 281474976710656) % 256
    val b7 = (value / 72057594037927936) % 256
    [b0, b1, b2, b3, b4, b5, b6, b7]

fn smf_hash_name(name: text) -> i64:
    # Simple hash based on string length and character positions
    # (interpreter lacks .to_bytes() on str, so no byte-level access)
    # Returns 0 for empty strings - valid in SMF (disables hash-based lookup)
    var hash = 5381
    for i in 0..name.len():
        hash = hash * 33 + (i + 1) * 7
    hash = hash * 31 + name.len()
    hash

fn target_to_arch_byte(target: CodegenTarget) -> i64:
    match target:
        case X86_64: 1
        case AArch64: 2
        case Riscv64: 5
        case _: 1  # Default x86_64

# ============================================================================
# Exports
# ============================================================================

export compile_native, compile_native_x86_64, compile_native_aarch64, compile_native_riscv64
export emit_elf_x86_64, emit_elf_aarch64, emit_elf_riscv64
export native_compile_to_object, native_compile_result
export compile_native_to_smf, wrap_object_in_smf
export smf_u16_bytes, smf_u32_bytes, smf_u64_bytes, smf_hash_name, target_to_arch_byte
