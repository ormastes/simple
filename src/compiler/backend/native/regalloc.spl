# Linear Scan Register Allocator
#
# Assigns physical registers to virtual registers using a linear scan algorithm.
# Simple, fast, good enough for -O0/-O1.
#
# Algorithm:
# 1. Compute live intervals for each virtual register
# 2. Sort intervals by start position
# 3. Walk intervals in order, assign physical registers
# 4. When all registers used, spill longest-lived interval to stack
# 5. Insert spill/reload instructions

use compiler.backend.native.mach_inst.{MachReg, MachRegKind, virtual_reg, physical_reg, reg_is_virtual, reg_is_physical, reg_id, Operand, OperandKind, op_reg, op_phys, op_mem, MachInst, new_mach_inst, MachBlock, new_mach_block, mach_block_add_inst, MachFunction, new_mach_function, mach_func_add_block, mach_func_set_frame_size, MachModule, new_mach_module, mach_module_add_func, mach_module_add_data, mach_module_add_extern}
use compiler.backend.native.mach_inst.{X86_RAX, X86_RCX, X86_RDX, X86_RBX, X86_RSP, X86_RBP, X86_RSI, X86_RDI, X86_R8, X86_R9, X86_R10, X86_R11, X86_R12, X86_R13, X86_R14, X86_R15, X86_ALLOCATABLE, X86_CALLEE_SAVED}
use compiler.backend.native.mach_inst.{X86_OP_MOV_REG_REG, X86_OP_MOV_REG_MEM, X86_OP_MOV_MEM_REG, X86_OP_SUB_IMM}

# ============================================================================
# Live Intervals
# ============================================================================

struct LiveInterval:
    vreg_id: i64
    start_pos: i64
    end_pos: i64
    assigned_reg: i64
    spill_slot: i64
    is_spilled: bool

fn new_live_interval(vreg_id: i64) -> LiveInterval:
    LiveInterval(
        vreg_id: vreg_id,
        start_pos: 999999,
        end_pos: -1,
        assigned_reg: -1,
        spill_slot: -1,
        is_spilled: false
    )

fn interval_update_start(interval: LiveInterval, pos: i64) -> LiveInterval:
    var new_start = interval.start_pos
    if pos < new_start:
        new_start = pos
    LiveInterval(
        vreg_id: interval.vreg_id,
        start_pos: new_start,
        end_pos: interval.end_pos,
        assigned_reg: interval.assigned_reg,
        spill_slot: interval.spill_slot,
        is_spilled: interval.is_spilled
    )

fn interval_update_end(interval: LiveInterval, pos: i64) -> LiveInterval:
    var new_end = interval.end_pos
    if pos > new_end:
        new_end = pos
    LiveInterval(
        vreg_id: interval.vreg_id,
        start_pos: interval.start_pos,
        end_pos: new_end,
        assigned_reg: interval.assigned_reg,
        spill_slot: interval.spill_slot,
        is_spilled: interval.is_spilled
    )

fn interval_assign_reg(interval: LiveInterval, reg: i64) -> LiveInterval:
    LiveInterval(
        vreg_id: interval.vreg_id,
        start_pos: interval.start_pos,
        end_pos: interval.end_pos,
        assigned_reg: reg,
        spill_slot: interval.spill_slot,
        is_spilled: false
    )

fn interval_spill(interval: LiveInterval, slot: i64) -> LiveInterval:
    LiveInterval(
        vreg_id: interval.vreg_id,
        start_pos: interval.start_pos,
        end_pos: interval.end_pos,
        assigned_reg: -1,
        spill_slot: slot,
        is_spilled: true
    )

fn interval_length(interval: LiveInterval) -> i64:
    interval.end_pos - interval.start_pos

# ============================================================================
# Compute Live Intervals
# ============================================================================

fn is_jump_opcode(opcode: i64) -> bool:
    if opcode == 40: return true
    if opcode == 41: return true
    if opcode == 42: return true
    if opcode == 43: return true
    if opcode == 44: return true
    if opcode == 45: return true
    if opcode == 46: return true
    if opcode == 47: return true
    if opcode == 48: return true
    false

fn get_jump_label(inst: MachInst) -> i64:
    if inst.operands.len() > 0:
        match inst.operands[0].kind:
            case Label(id): return id
            case _: ()
    -999

fn compute_live_intervals(func: MachFunction) -> [LiveInterval]:
    var intervals: Dict<i64, LiveInterval> = {}
    var pos = 0

    # Track block start positions and end positions
    var block_start_pos: Dict<i64, i64> = {}
    var block_end_pos: Dict<i64, i64> = {}

    for block in func.blocks:
        block_start_pos[block.block_id] = pos
        for inst in block.insts:
            # Scan operands for virtual register uses/defs
            for operand in inst.operands:
                match operand.kind:
                    case Reg(reg):
                        match reg.kind:
                            case Virtual(id):
                                if not intervals.contains(id):
                                    intervals[id] = new_live_interval(id)
                                var iv = intervals[id]
                                iv = interval_update_start(iv, pos)
                                iv = interval_update_end(iv, pos)
                                intervals[id] = iv
                            case _: ()
                    case Mem(base, _):
                        match base.kind:
                            case Virtual(id):
                                if not intervals.contains(id):
                                    intervals[id] = new_live_interval(id)
                                var iv = intervals[id]
                                iv = interval_update_start(iv, pos)
                                iv = interval_update_end(iv, pos)
                                intervals[id] = iv
                            case _: ()
                    case _: ()
            pos = pos + 1
        block_end_pos[block.block_id] = pos

    # Detect back-edges and extend intervals for loops.
    # A back-edge is a jump from block B to an earlier block A (lower start_pos).
    # All intervals overlapping the loop body [A_start, B_end] must be extended
    # to cover the full range, so they stay live across loop iterations.
    for block in func.blocks:
        for inst in block.insts:
            if is_jump_opcode(inst.opcode):
                val target_id = get_jump_label(inst)
                if target_id != -999:
                    if block_start_pos.contains(target_id):
                        val target_start = block_start_pos[target_id]
                        val src_end = block_end_pos[block.block_id]
                        if target_start < block_start_pos[block.block_id]:
                            # Back-edge detected: target_start..src_end is the loop
                            val ikeys = intervals.keys()
                            for ik in ikeys:
                                var iv = intervals[ik]
                                # Only extend intervals that START before the loop header
                                # and are still alive at the header. This captures loop-carried
                                # variables (defined before loop, used inside) without extending
                                # loop-internal temps that are recalculated each iteration.
                                val needs_extension = iv.start_pos < target_start and iv.end_pos >= target_start
                                if needs_extension:
                                    if iv.start_pos > target_start:
                                        iv = interval_update_start(iv, target_start)
                                    if iv.end_pos < src_end:
                                        iv = interval_update_end(iv, src_end)
                                    intervals[ik] = iv

    # Collect intervals into a list
    var result: [LiveInterval] = []
    val keys = intervals.keys()
    for key in keys:
        result = result.push(intervals[key])
    result

# ============================================================================
# Sort Intervals by Start Position
# ============================================================================

fn sort_intervals(intervals: [LiveInterval]) -> [LiveInterval]:
    # Merge sort - O(n log n) for all cases
    if intervals.len() <= 1:
        return intervals
    val mid = intervals.len() / 2
    var left: [LiveInterval] = []
    for i in range(0, mid):
        left = left.push(intervals[i])
    var right: [LiveInterval] = []
    for i in range(mid, intervals.len()):
        right = right.push(intervals[i])
    val sorted_left = sort_intervals(left)
    val sorted_right = sort_intervals(right)
    merge_intervals_sorted(sorted_left, sorted_right)

fn merge_intervals_sorted(left: [LiveInterval], right: [LiveInterval]) -> [LiveInterval]:
    var result: [LiveInterval] = []
    var i = 0
    var j = 0
    while i < left.len() and j < right.len():
        if left[i].start_pos <= right[j].start_pos:
            result = result.push(left[i])
            i = i + 1
        else:
            result = result.push(right[j])
            j = j + 1
    for ri in range(i, left.len()):
        result = result.push(left[ri])
    for rj in range(j, right.len()):
        result = result.push(right[rj])
    result

# ============================================================================
# Linear Scan Algorithm
# ============================================================================

struct RegAllocResult:
    assignments: Dict<i64, i64>
    spills: Dict<i64, i64>
    frame_size_addition: i64
    used_callee_saved: [i64]

fn linear_scan_x86_64(intervals: [LiveInterval], allocatable: [i64]) -> RegAllocResult:
    val sorted = sort_intervals(intervals)
    var assignments: Dict<i64, i64> = {}
    var spills: Dict<i64, i64> = {}
    var active: [LiveInterval] = []
    var free_regs: [bool] = []
    var next_spill_slot = 0
    var used_callee_saved: [i64] = []

    # Initialize free register pool
    for i in 0..16:
        free_regs = free_regs.push(false)
    for reg in allocatable:
        free_regs[reg] = true

    for interval in sorted:
        # Expire old intervals
        var new_active: [LiveInterval] = []
        for act in active:
            if act.end_pos < interval.start_pos:
                # Interval expired, free its register
                if act.assigned_reg >= 0:
                    free_regs[act.assigned_reg] = true
            else:
                new_active = new_active.push(act)
        active = new_active

        # Try to find a free register
        var found_reg = -1
        for reg in allocatable:
            if free_regs[reg]:
                found_reg = reg
                break

        if found_reg >= 0:
            # Assign register
            free_regs[found_reg] = false
            val assigned = interval_assign_reg(interval, found_reg)
            assignments[interval.vreg_id] = found_reg
            active = active.push(assigned)

            # Track callee-saved usage
            var is_callee_saved = false
            for cs_reg in X86_CALLEE_SAVED:
                if found_reg == cs_reg:
                    is_callee_saved = true
            if is_callee_saved:
                var already_tracked = false
                for used in used_callee_saved:
                    if used == found_reg:
                        already_tracked = true
                if not already_tracked:
                    used_callee_saved = used_callee_saved.push(found_reg)
        else:
            # No free register - spill the longest-lived active interval
            var longest_idx = -1
            var longest_len = -1
            for i in 0..active.len():
                val len = interval_length(active[i])
                if len > longest_len:
                    longest_len = len
                    longest_idx = i

            if longest_idx >= 0:
                val longest_end = active[longest_idx].end_pos
                val interval_end = interval.end_pos
                if longest_end > interval_end:
                    # Spill the longer interval, use its register
                    val spill_vreg = active[longest_idx].vreg_id
                    val freed_reg = active[longest_idx].assigned_reg
                    spills[spill_vreg] = next_spill_slot
                    next_spill_slot = next_spill_slot + 1
                    # Remove from assignments
                    assignments[spill_vreg] = -1

                    # Assign freed register to current interval
                    assignments[interval.vreg_id] = freed_reg
                    val assigned = interval_assign_reg(interval, freed_reg)

                    # Replace spilled interval with current
                    var updated_active: [LiveInterval] = []
                    for i in 0..active.len():
                        if i != longest_idx:
                            updated_active = updated_active.push(active[i])
                    updated_active = updated_active.push(assigned)
                    active = updated_active
                else:
                    # Current interval is longer, spill it
                    spills[interval.vreg_id] = next_spill_slot
                    next_spill_slot = next_spill_slot + 1
            else:
                # No active intervals to spill, spill current
                spills[interval.vreg_id] = next_spill_slot
                next_spill_slot = next_spill_slot + 1

    val frame_addition = next_spill_slot * 8
    RegAllocResult(
        assignments: assignments,
        spills: spills,
        frame_size_addition: frame_addition,
        used_callee_saved: used_callee_saved
    )

# ============================================================================
# Helper: physical register ID extraction
# ============================================================================

fn get_phys_reg_id(op: Operand) -> i64:
    match op.kind:
        case Reg(reg):
            match reg.kind:
                case Physical(id): id
                case _: -1
        case _: -1

fn is_mov_rsp_rbp(inst: MachInst) -> bool:
    if inst.opcode != X86_OP_MOV_REG_REG:
        return false
    if inst.operands.len() < 2:
        return false
    if get_phys_reg_id(inst.operands[0]) != X86_RSP:
        return false
    if get_phys_reg_id(inst.operands[1]) != X86_RBP:
        return false
    true

fn function_has_calls(func: MachFunction) -> bool:
    for block in func.blocks:
        for inst in block.insts:
            if inst.opcode == X86_OP_CALL:
                return true
            if inst.opcode == X86_OP_CALL_INDIRECT:
                return true
    false

# ============================================================================
# Apply Register Allocation
# ============================================================================

fn regalloc_function(func: MachFunction) -> MachFunction:
    # Compute live intervals
    val intervals = compute_live_intervals(func)

    # For functions with calls, restrict to callee-saved registers only.
    # This ensures all allocated values survive across CALL instructions.
    # Functions without calls can use the full register set.
    var alloc_regs = X86_ALLOCATABLE
    if function_has_calls(func):
        alloc_regs = X86_CALLEE_SAVED

    # Run linear scan
    val result = linear_scan_x86_64(intervals, alloc_regs)

    # Calculate frame layout including callee-saved register storage
    val callee_save_count = result.used_callee_saved.len()
    val base_frame = func.frame_size + result.frame_size_addition
    val callee_save_size = callee_save_count * 8
    val total_frame = base_frame + callee_save_size
    var aligned_frame = total_frame
    if aligned_frame % 16 != 0:
        aligned_frame = aligned_frame + (16 - (aligned_frame % 16))

    # Apply assignments to all instructions
    var new_blocks: [MachBlock] = []
    for block in func.blocks:
        var new_block = new_mach_block(block.label, block.block_id)
        for inst in block.insts:
            val rewritten = rewrite_inst(inst, result)
            for ri in rewritten:
                new_block = mach_block_add_inst(new_block, ri)
        new_blocks = new_blocks.push(new_block)

    # Patch prologue: update SUB RSP frame size and save callee-saved registers
    if new_blocks.len() > 0:
        var prologue = new_blocks[0]
        var patched_insts: [MachInst] = []
        for inst in prologue.insts:
            var handled = false
            if inst.opcode == X86_OP_SUB_IMM:
                if inst.operands.len() >= 2:
                    if get_phys_reg_id(inst.operands[0]) == X86_RSP:
                        handled = true
                        # Patch frame size to include callee save area
                        patched_insts = patched_insts.push(new_mach_inst(X86_OP_SUB_IMM, [op_phys(X86_RSP), op_imm(aligned_frame)]))
                        # Save callee-saved registers to stack slots after SUB RSP
                        for i in 0..callee_save_count:
                            val cs_reg = result.used_callee_saved[i]
                            val offset = base_frame + (i + 1) * 8
                            patched_insts = patched_insts.push(new_mach_inst(X86_OP_MOV_MEM_REG, [op_mem(physical_reg(X86_RBP), 0 - offset), op_phys(cs_reg)]))
            if not handled:
                patched_insts = patched_insts.push(inst)
        var new_prologue = new_mach_block(prologue.label, prologue.block_id)
        for pi in patched_insts:
            new_prologue = mach_block_add_inst(new_prologue, pi)
        new_blocks[0] = new_prologue

    # Patch epilogues: restore callee-saved registers before MOV RSP, RBP
    for block_idx in 0..new_blocks.len():
        var block = new_blocks[block_idx]
        var has_epilogue = false
        for inst in block.insts:
            if is_mov_rsp_rbp(inst):
                has_epilogue = true
        if has_epilogue:
            var ep_insts: [MachInst] = []
            for inst in block.insts:
                if is_mov_rsp_rbp(inst):
                    # Restore callee-saved registers from stack before epilogue
                    for i in 0..callee_save_count:
                        val cs_reg = result.used_callee_saved[i]
                        val offset = base_frame + (i + 1) * 8
                        ep_insts = ep_insts.push(new_mach_inst(X86_OP_MOV_REG_MEM, [op_phys(cs_reg), op_mem(physical_reg(X86_RBP), 0 - offset)]))
                ep_insts = ep_insts.push(inst)
            var new_block = new_mach_block(block.label, block.block_id)
            for pi in ep_insts:
                new_block = mach_block_add_inst(new_block, pi)
            new_blocks[block_idx] = new_block

    var out_func = new_mach_function(func.name)
    for blk in new_blocks:
        out_func = mach_func_add_block(out_func, blk)
    out_func = mach_func_set_frame_size(out_func, aligned_frame)

    MachFunction(
        name: out_func.name,
        blocks: out_func.blocks,
        frame_size: aligned_frame,
        num_virtual_regs: func.num_virtual_regs,
        used_callee_saved: result.used_callee_saved
    )

fn rewrite_inst(inst: MachInst, result: RegAllocResult) -> [MachInst]:
    var new_operands: [Operand] = []
    var spill_loads: [MachInst] = []
    var spill_stores: [MachInst] = []
    # Use different scratch registers for different spilled operands
    # to avoid clobbering when two operands are both spilled.
    # First spilled operand → R11, second → R10.
    var scratch_idx = 0

    for operand in inst.operands:
        match operand.kind:
            case Reg(reg):
                match reg.kind:
                    case Virtual(id):
                        if result.assignments.contains(id):
                            val phys = result.assignments[id]
                            if phys >= 0:
                                new_operands = new_operands.push(op_phys(phys))
                            else:
                                # Spilled - load from stack
                                if result.spills.contains(id):
                                    val slot = result.spills[id]
                                    val offset = (slot + 1) * 8
                                    var scratch = X86_R11
                                    if scratch_idx > 0:
                                        scratch = X86_R10
                                    scratch_idx = scratch_idx + 1
                                    spill_loads = spill_loads.push(new_mach_inst(X86_OP_MOV_REG_MEM, [op_phys(scratch), op_mem(physical_reg(X86_RBP), 0 - offset)]))
                                    new_operands = new_operands.push(op_phys(scratch))
                                else:
                                    new_operands = new_operands.push(op_phys(X86_RAX))
                        elif result.spills.contains(id):
                            val slot = result.spills[id]
                            val offset = (slot + 1) * 8
                            var scratch = X86_R11
                            if scratch_idx > 0:
                                scratch = X86_R10
                            scratch_idx = scratch_idx + 1
                            spill_loads = spill_loads.push(new_mach_inst(X86_OP_MOV_REG_MEM, [op_phys(scratch), op_mem(physical_reg(X86_RBP), 0 - offset)]))
                            new_operands = new_operands.push(op_phys(scratch))
                        else:
                            new_operands = new_operands.push(op_phys(X86_RAX))
                    case Physical(_):
                        new_operands = new_operands.push(operand)
            case Mem(base, off):
                match base.kind:
                    case Virtual(id):
                        if result.assignments.contains(id):
                            val phys = result.assignments[id]
                            if phys >= 0:
                                new_operands = new_operands.push(op_mem(physical_reg(phys), off))
                            else:
                                new_operands = new_operands.push(op_mem(physical_reg(X86_RAX), off))
                        else:
                            new_operands = new_operands.push(op_mem(physical_reg(X86_RAX), off))
                    case Physical(_):
                        new_operands = new_operands.push(operand)
            case _:
                new_operands = new_operands.push(operand)

    val rewritten = MachInst(opcode: inst.opcode, operands: new_operands, size: inst.size)

    # Check if first operand is a def and needs spill store
    if inst.operands.len() > 0:
        match inst.operands[0].kind:
            case Reg(reg):
                match reg.kind:
                    case Virtual(id):
                        if result.spills.contains(id):
                            val slot = result.spills[id]
                            val offset = (slot + 1) * 8
                            spill_stores = spill_stores.push(new_mach_inst(X86_OP_MOV_MEM_REG, [op_mem(physical_reg(X86_RBP), 0 - offset), op_phys(X86_R11)]))
                    case _: ()
            case _: ()

    var all_insts: [MachInst] = []
    for sl in spill_loads:
        all_insts = all_insts.push(sl)
    all_insts = all_insts.push(rewritten)
    for ss in spill_stores:
        all_insts = all_insts.push(ss)
    all_insts

# ============================================================================
# Module-level Register Allocation
# ============================================================================

fn regalloc_module(module: MachModule) -> MachModule:
    var result = new_mach_module(module.name)
    for func in module.functions:
        val allocated = regalloc_function(func)
        result = mach_module_add_func(result, allocated)
    for entry in module.data_sections:
        result = mach_module_add_data(result, entry)
    for sym in module.extern_symbols:
        result = mach_module_add_extern(result, sym)
    result

# ============================================================================
# Exports
# ============================================================================

export LiveInterval, new_live_interval
export compute_live_intervals, sort_intervals
export RegAllocResult, linear_scan_x86_64
export get_phys_reg_id, is_mov_rsp_rbp, function_has_calls
export regalloc_function, regalloc_module
