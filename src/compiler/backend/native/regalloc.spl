# Linear Scan Register Allocator
#
# Assigns physical registers to virtual registers using a linear scan algorithm.
# Simple, fast, good enough for -O0/-O1.
#
# Algorithm:
# 1. Compute live intervals for each virtual register
# 2. Sort intervals by start position
# 3. Walk intervals in order, assign physical registers
# 4. When all registers used, spill longest-lived interval to stack
# 5. Insert spill/reload instructions

use compiler.backend.native.mach_inst.{MachReg, MachRegKind, virtual_reg, physical_reg, reg_is_virtual, reg_is_physical, reg_id, Operand, OperandKind, op_reg, op_phys, op_mem, MachInst, new_mach_inst, MachBlock, new_mach_block, mach_block_add_inst, MachFunction, new_mach_function, mach_func_add_block, mach_func_set_frame_size, MachModule, new_mach_module, mach_module_add_func, mach_module_add_data, mach_module_add_extern}
use compiler.backend.native.mach_inst.{X86_RAX, X86_RCX, X86_RDX, X86_RBX, X86_RSP, X86_RBP, X86_RSI, X86_RDI, X86_R8, X86_R9, X86_R10, X86_R11, X86_R12, X86_R13, X86_R14, X86_R15, X86_ALLOCATABLE, X86_CALLEE_SAVED}
use compiler.backend.native.mach_inst.{X86_OP_MOV_REG_REG, X86_OP_MOV_REG_MEM, X86_OP_MOV_MEM_REG, X86_OP_SUB_IMM}

# ============================================================================
# Live Intervals
# ============================================================================

struct LiveInterval:
    vreg_id: i64
    start_pos: i64
    end_pos: i64
    assigned_reg: i64
    spill_slot: i64
    is_spilled: bool

fn new_live_interval(vreg_id: i64) -> LiveInterval:
    LiveInterval(
        vreg_id: vreg_id,
        start_pos: 999999,
        end_pos: -1,
        assigned_reg: -1,
        spill_slot: -1,
        is_spilled: false
    )

fn interval_update_start(interval: LiveInterval, pos: i64) -> LiveInterval:
    var new_start = interval.start_pos
    if pos < new_start:
        new_start = pos
    LiveInterval(
        vreg_id: interval.vreg_id,
        start_pos: new_start,
        end_pos: interval.end_pos,
        assigned_reg: interval.assigned_reg,
        spill_slot: interval.spill_slot,
        is_spilled: interval.is_spilled
    )

fn interval_update_end(interval: LiveInterval, pos: i64) -> LiveInterval:
    var new_end = interval.end_pos
    if pos > new_end:
        new_end = pos
    LiveInterval(
        vreg_id: interval.vreg_id,
        start_pos: interval.start_pos,
        end_pos: new_end,
        assigned_reg: interval.assigned_reg,
        spill_slot: interval.spill_slot,
        is_spilled: interval.is_spilled
    )

fn interval_assign_reg(interval: LiveInterval, reg: i64) -> LiveInterval:
    LiveInterval(
        vreg_id: interval.vreg_id,
        start_pos: interval.start_pos,
        end_pos: interval.end_pos,
        assigned_reg: reg,
        spill_slot: interval.spill_slot,
        is_spilled: false
    )

fn interval_spill(interval: LiveInterval, slot: i64) -> LiveInterval:
    LiveInterval(
        vreg_id: interval.vreg_id,
        start_pos: interval.start_pos,
        end_pos: interval.end_pos,
        assigned_reg: -1,
        spill_slot: slot,
        is_spilled: true
    )

fn interval_length(interval: LiveInterval) -> i64:
    interval.end_pos - interval.start_pos

# ============================================================================
# Compute Live Intervals
# ============================================================================

fn compute_live_intervals(func: MachFunction) -> [LiveInterval]:
    var intervals: Dict<i64, LiveInterval> = {}
    var pos = 0

    for block in func.blocks:
        for inst in block.insts:
            # Scan operands for virtual register uses/defs
            for operand in inst.operands:
                match operand.kind:
                    case Reg(reg):
                        match reg.kind:
                            case Virtual(id):
                                if not intervals.contains(id):
                                    intervals[id] = new_live_interval(id)
                                var iv = intervals[id]
                                iv = interval_update_start(iv, pos)
                                iv = interval_update_end(iv, pos)
                                intervals[id] = iv
                            case _: ()
                    case Mem(base, _):
                        match base.kind:
                            case Virtual(id):
                                if not intervals.contains(id):
                                    intervals[id] = new_live_interval(id)
                                var iv = intervals[id]
                                iv = interval_update_start(iv, pos)
                                iv = interval_update_end(iv, pos)
                                intervals[id] = iv
                            case _: ()
                    case _: ()
            pos = pos + 1

    # Collect intervals into a list
    var result: [LiveInterval] = []
    val keys = intervals.keys()
    for key in keys:
        result = result + [intervals[key]]
    result

# ============================================================================
# Sort Intervals by Start Position
# ============================================================================

fn sort_intervals(intervals: [LiveInterval]) -> [LiveInterval]:
    # Simple insertion sort (good enough for typical function sizes)
    var sorted = intervals
    for i in 1..sorted.len():
        var j = i
        for k in 0..i:
            val rev_idx = i - 1 - k
            if rev_idx >= 0:
                val cond = sorted[rev_idx].start_pos > sorted[rev_idx + 1].start_pos
                if cond:
                    val tmp = sorted[rev_idx]
                    sorted[rev_idx] = sorted[rev_idx + 1]
                    sorted[rev_idx + 1] = tmp
    sorted

# ============================================================================
# Linear Scan Algorithm
# ============================================================================

struct RegAllocResult:
    assignments: Dict<i64, i64>
    spills: Dict<i64, i64>
    frame_size_addition: i64
    used_callee_saved: [i64]

fn linear_scan_x86_64(intervals: [LiveInterval]) -> RegAllocResult:
    val sorted = sort_intervals(intervals)
    var assignments: Dict<i64, i64> = {}
    var spills: Dict<i64, i64> = {}
    var active: [LiveInterval] = []
    var free_regs: [bool] = []
    var next_spill_slot = 0
    var used_callee_saved: [i64] = []

    # Initialize free register pool
    for i in 0..16:
        free_regs = free_regs + [false]
    for reg in X86_ALLOCATABLE:
        free_regs[reg] = true

    for interval in sorted:
        # Expire old intervals
        var new_active: [LiveInterval] = []
        for act in active:
            if act.end_pos < interval.start_pos:
                # Interval expired, free its register
                if act.assigned_reg >= 0:
                    free_regs[act.assigned_reg] = true
            else:
                new_active = new_active + [act]
        active = new_active

        # Try to find a free register
        var found_reg = -1
        for reg in X86_ALLOCATABLE:
            if free_regs[reg]:
                found_reg = reg
                break

        if found_reg >= 0:
            # Assign register
            free_regs[found_reg] = false
            val assigned = interval_assign_reg(interval, found_reg)
            assignments[interval.vreg_id] = found_reg
            active = active + [assigned]

            # Track callee-saved usage
            var is_callee_saved = false
            for cs_reg in X86_CALLEE_SAVED:
                if found_reg == cs_reg:
                    is_callee_saved = true
            if is_callee_saved:
                var already_tracked = false
                for used in used_callee_saved:
                    if used == found_reg:
                        already_tracked = true
                if not already_tracked:
                    used_callee_saved = used_callee_saved + [found_reg]
        else:
            # No free register - spill the longest-lived active interval
            var longest_idx = -1
            var longest_len = -1
            for i in 0..active.len():
                val len = interval_length(active[i])
                if len > longest_len:
                    longest_len = len
                    longest_idx = i

            if longest_idx >= 0:
                val longest_end = active[longest_idx].end_pos
                val interval_end = interval.end_pos
                if longest_end > interval_end:
                    # Spill the longer interval, use its register
                    val spill_vreg = active[longest_idx].vreg_id
                    val freed_reg = active[longest_idx].assigned_reg
                    spills[spill_vreg] = next_spill_slot
                    next_spill_slot = next_spill_slot + 1
                    # Remove from assignments
                    assignments[spill_vreg] = -1

                    # Assign freed register to current interval
                    assignments[interval.vreg_id] = freed_reg
                    val assigned = interval_assign_reg(interval, freed_reg)

                    # Replace spilled interval with current
                    var updated_active: [LiveInterval] = []
                    for i in 0..active.len():
                        if i != longest_idx:
                            updated_active = updated_active + [active[i]]
                    updated_active = updated_active + [assigned]
                    active = updated_active
                else:
                    # Current interval is longer, spill it
                    spills[interval.vreg_id] = next_spill_slot
                    next_spill_slot = next_spill_slot + 1
            else:
                # No active intervals to spill, spill current
                spills[interval.vreg_id] = next_spill_slot
                next_spill_slot = next_spill_slot + 1

    val frame_addition = next_spill_slot * 8
    RegAllocResult(
        assignments: assignments,
        spills: spills,
        frame_size_addition: frame_addition,
        used_callee_saved: used_callee_saved
    )

# ============================================================================
# Apply Register Allocation
# ============================================================================

fn regalloc_function(func: MachFunction) -> MachFunction:
    # Compute live intervals
    val intervals = compute_live_intervals(func)

    # Run linear scan
    val result = linear_scan_x86_64(intervals)

    # Apply assignments to all instructions
    var new_blocks: [MachBlock] = []
    for block in func.blocks:
        var new_block = new_mach_block(block.label, block.block_id)
        for inst in block.insts:
            val rewritten = rewrite_inst(inst, result)
            for ri in rewritten:
                new_block = mach_block_add_inst(new_block, ri)
        new_blocks = new_blocks + [new_block]

    # Calculate total frame size
    val total_frame = func.frame_size + result.frame_size_addition
    var aligned_frame = total_frame
    if aligned_frame % 16 != 0:
        aligned_frame = aligned_frame + (16 - (aligned_frame % 16))

    # Patch prologue SUB RSP instruction
    if new_blocks.len() > 0:
        var prologue = new_blocks[0]
        var patched_insts: [MachInst] = []
        for inst in prologue.insts:
            if inst.opcode == X86_OP_SUB_IMM:
                if inst.operands.len() >= 2:
                    match inst.operands[0].kind:
                        case Reg(reg):
                            match reg.kind:
                                case Physical(id):
                                    if id == X86_RSP:
                                        patched_insts = patched_insts + [new_mach_inst(X86_OP_SUB_IMM, [op_phys(X86_RSP), op_imm(aligned_frame)])]
                                    else:
                                        patched_insts = patched_insts + [inst]
                                case _:
                                    patched_insts = patched_insts + [inst]
                        case _:
                            patched_insts = patched_insts + [inst]
                else:
                    patched_insts = patched_insts + [inst]
            else:
                patched_insts = patched_insts + [inst]
        # Rebuild the prologue block
        var new_prologue = new_mach_block(prologue.label, prologue.block_id)
        # Add callee-saved register pushes
        for cs_reg in result.used_callee_saved:
            new_prologue = mach_block_add_inst(new_prologue, new_mach_inst(X86_OP_MOV_REG_REG, [op_phys(cs_reg), op_phys(cs_reg)]))
        for pi in patched_insts:
            new_prologue = mach_block_add_inst(new_prologue, pi)
        new_blocks[0] = new_prologue

    var out_func = new_mach_function(func.name)
    for blk in new_blocks:
        out_func = mach_func_add_block(out_func, blk)
    out_func = mach_func_set_frame_size(out_func, aligned_frame)

    MachFunction(
        name: out_func.name,
        blocks: out_func.blocks,
        frame_size: aligned_frame,
        num_virtual_regs: func.num_virtual_regs,
        used_callee_saved: result.used_callee_saved
    )

fn rewrite_inst(inst: MachInst, result: RegAllocResult) -> [MachInst]:
    var new_operands: [Operand] = []
    var spill_loads: [MachInst] = []
    var spill_stores: [MachInst] = []

    for operand in inst.operands:
        match operand.kind:
            case Reg(reg):
                match reg.kind:
                    case Virtual(id):
                        if result.assignments.contains(id):
                            val phys = result.assignments[id]
                            if phys >= 0:
                                new_operands = new_operands + [op_phys(phys)]
                            else:
                                # Spilled - load from stack
                                if result.spills.contains(id):
                                    val slot = result.spills[id]
                                    val offset = (slot + 1) * 8
                                    # Use R11 as scratch for spills
                                    spill_loads = spill_loads + [new_mach_inst(X86_OP_MOV_REG_MEM, [op_phys(X86_R11), op_mem(physical_reg(X86_RBP), 0 - offset)])]
                                    new_operands = new_operands + [op_phys(X86_R11)]
                                else:
                                    new_operands = new_operands + [op_phys(X86_RAX)]
                        elif result.spills.contains(id):
                            val slot = result.spills[id]
                            val offset = (slot + 1) * 8
                            spill_loads = spill_loads + [new_mach_inst(X86_OP_MOV_REG_MEM, [op_phys(X86_R11), op_mem(physical_reg(X86_RBP), 0 - offset)])]
                            new_operands = new_operands + [op_phys(X86_R11)]
                        else:
                            new_operands = new_operands + [op_phys(X86_RAX)]
                    case Physical(_):
                        new_operands = new_operands + [operand]
            case Mem(base, off):
                match base.kind:
                    case Virtual(id):
                        if result.assignments.contains(id):
                            val phys = result.assignments[id]
                            if phys >= 0:
                                new_operands = new_operands + [op_mem(physical_reg(phys), off)]
                            else:
                                new_operands = new_operands + [op_mem(physical_reg(X86_RAX), off)]
                        else:
                            new_operands = new_operands + [op_mem(physical_reg(X86_RAX), off)]
                    case Physical(_):
                        new_operands = new_operands + [operand]
            case _:
                new_operands = new_operands + [operand]

    val rewritten = MachInst(opcode: inst.opcode, operands: new_operands, size: inst.size)

    # Check if first operand is a def and needs spill store
    if inst.operands.len() > 0:
        match inst.operands[0].kind:
            case Reg(reg):
                match reg.kind:
                    case Virtual(id):
                        if result.spills.contains(id):
                            val slot = result.spills[id]
                            val offset = (slot + 1) * 8
                            spill_stores = spill_stores + [new_mach_inst(X86_OP_MOV_MEM_REG, [op_mem(physical_reg(X86_RBP), 0 - offset), op_phys(X86_R11)])]
                    case _: ()
            case _: ()

    var all_insts: [MachInst] = []
    all_insts = all_insts + spill_loads
    all_insts = all_insts + [rewritten]
    all_insts = all_insts + spill_stores
    all_insts

# ============================================================================
# Module-level Register Allocation
# ============================================================================

fn regalloc_module(module: MachModule) -> MachModule:
    var result = new_mach_module(module.name)
    for func in module.functions:
        val allocated = regalloc_function(func)
        result = mach_module_add_func(result, allocated)
    for entry in module.data_sections:
        result = mach_module_add_data(result, entry)
    for sym in module.extern_symbols:
        result = mach_module_add_extern(result, sym)
    result

# ============================================================================
# Exports
# ============================================================================

export LiveInterval, new_live_interval
export compute_live_intervals, sort_intervals
export RegAllocResult, linear_scan_x86_64
export regalloc_function, regalloc_module
