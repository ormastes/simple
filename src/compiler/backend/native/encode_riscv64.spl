# RISC-V 64-bit Instruction Encoder
#
# Encodes MachInst to raw bytes for RISC-V 64-bit (RV64IMFD) architecture.
# All RISC-V instructions are fixed-length: exactly 4 bytes (32-bit), little-endian.
#
# Instruction formats:
#   R-type: funct7[31:25] | rs2[24:20] | rs1[19:15] | funct3[14:12] | rd[11:7] | opcode[6:0]
#   I-type: imm[31:20]   | rs1[19:15] | funct3[14:12] | rd[11:7]    | opcode[6:0]
#   S-type: imm[31:25]   | rs2[24:20] | rs1[19:15] | funct3[14:12] | imm[11:7] | opcode[6:0]
#   B-type: imm[12|10:5] | rs2[24:20] | rs1[19:15] | funct3[14:12] | imm[4:1|11] | opcode[6:0]
#   U-type: imm[31:12]   | rd[11:7]   | opcode[6:0]
#   J-type: imm[20|10:1|11|19:12] | rd[11:7] | opcode[6:0]

use compiler.backend.native.mach_inst.{MachReg, MachRegKind, physical_reg, reg_id, Operand, OperandKind, MachInst, MachBlock, MachFunction, MachModule, EncodedReloc, EncodedFunction, new_encoded_function}
use compiler.backend.native.mach_inst.{RV_X0, RV_X1, RV_X2, RV_X3, RV_X4, RV_X5, RV_X6, RV_X7, RV_X8, RV_X9, RV_X10, RV_X11, RV_X12, RV_X13, RV_X14, RV_X15, RV_X16, RV_X17, RV_X18, RV_X19, RV_X20, RV_X21, RV_X22, RV_X23, RV_X24, RV_X25, RV_X26, RV_X27, RV_X28, RV_X29, RV_X30, RV_X31}
use compiler.backend.native.mach_inst.{RV_OP_ADD, RV_OP_SUB, RV_OP_MUL, RV_OP_DIV, RV_OP_REM, RV_OP_AND, RV_OP_OR, RV_OP_XOR, RV_OP_SLL, RV_OP_SRA, RV_OP_SRL, RV_OP_SLT, RV_OP_SLTU, RV_OP_ADDI, RV_OP_LUI, RV_OP_AUIPC, RV_OP_JAL, RV_OP_JALR, RV_OP_BEQ, RV_OP_BNE, RV_OP_BLT, RV_OP_BGE, RV_OP_LD, RV_OP_SD, RV_OP_LW, RV_OP_SW, RV_OP_MV, RV_OP_LI, RV_OP_NOP, RV_OP_RET, RV_OP_CALL, RV_OP_NEG, RV_OP_NOT, RV_OP_SEQZ, RV_OP_SNEZ}

# ============================================================================
# Encoding Helpers
# ============================================================================

# Emit a 32-bit instruction as 4 little-endian bytes.
# Uses division/modulo to avoid issues with negative bit operations.
fn emit_u32_le_riscv64(buf: [i64], instruction: i64) -> [i64]:
    var masked = instruction
    if masked < 0:
        masked = masked + 4294967296
    val b0 = masked % 256
    val b1 = (masked / 256) % 256
    val b2 = (masked / 65536) % 256
    val b3 = (masked / 16777216) % 256
    var result = buf
    result = result + [b0, b1, b2, b3]
    result

# ============================================================================
# Instruction Format Encoders
# ============================================================================

# R-type: funct7[31:25] | rs2[24:20] | rs1[19:15] | funct3[14:12] | rd[11:7] | opcode[6:0]
fn encode_r_type_riscv64(funct7: i64, rs2: i64, rs1: i64, funct3: i64, rd: i64, opcode: i64) -> i64:
    val f7 = (funct7 and 0x7F) << 25
    val r2 = (rs2 and 0x1F) << 20
    val r1 = (rs1 and 0x1F) << 15
    val f3 = (funct3 and 0x7) << 12
    val d = (rd and 0x1F) << 7
    val op = opcode and 0x7F
    f7 or r2 or r1 or f3 or d or op

# I-type: imm[31:20] | rs1[19:15] | funct3[14:12] | rd[11:7] | opcode[6:0]
fn encode_i_type_riscv64(imm12: i64, rs1: i64, funct3: i64, rd: i64, opcode: i64) -> i64:
    val im = (imm12 and 0xFFF) << 20
    val r1 = (rs1 and 0x1F) << 15
    val f3 = (funct3 and 0x7) << 12
    val d = (rd and 0x1F) << 7
    val op = opcode and 0x7F
    im or r1 or f3 or d or op

# S-type: imm[31:25] | rs2[24:20] | rs1[19:15] | funct3[14:12] | imm[11:7] | opcode[6:0]
fn encode_s_type_riscv64(imm12: i64, rs2: i64, rs1: i64, funct3: i64, opcode: i64) -> i64:
    val imm_val = imm12 and 0xFFF
    val imm_hi = (imm_val >> 5) and 0x7F
    val imm_lo = imm_val and 0x1F
    val hi = imm_hi << 25
    val r2 = (rs2 and 0x1F) << 20
    val r1 = (rs1 and 0x1F) << 15
    val f3 = (funct3 and 0x7) << 12
    val lo = imm_lo << 7
    val op = opcode and 0x7F
    hi or r2 or r1 or f3 or lo or op

# B-type: imm[12|10:5] | rs2[24:20] | rs1[19:15] | funct3[14:12] | imm[4:1|11] | opcode[6:0]
# imm is a byte offset (already divided by instruction words upstream if needed)
fn encode_b_type_riscv64(imm_offset: i64, rs2: i64, rs1: i64, funct3: i64, opcode: i64) -> i64:
    val imm = imm_offset and 0x1FFF
    # bit 12 -> bit 31
    val bit12 = (imm >> 12) and 0x1
    # bits 10:5 -> bits 30:25
    val bits_10_5 = (imm >> 5) and 0x3F
    # bits 4:1 -> bits 11:8
    val bits_4_1 = (imm >> 1) and 0xF
    # bit 11 -> bit 7
    val bit11 = (imm >> 11) and 0x1
    val hi = (bit12 << 31) or (bits_10_5 << 25)
    val r2 = (rs2 and 0x1F) << 20
    val r1 = (rs1 and 0x1F) << 15
    val f3 = (funct3 and 0x7) << 12
    val lo = (bits_4_1 << 8) or (bit11 << 7)
    val op = opcode and 0x7F
    hi or r2 or r1 or f3 or lo or op

# U-type: imm[31:12] | rd[11:7] | opcode[6:0]
fn encode_u_type_riscv64(imm20: i64, rd: i64, opcode: i64) -> i64:
    val im = (imm20 and 0xFFFFF) << 12
    val d = (rd and 0x1F) << 7
    val op = opcode and 0x7F
    im or d or op

# J-type: imm[20|10:1|11|19:12] | rd[11:7] | opcode[6:0]
# imm is a byte offset
fn encode_j_type_riscv64(imm_offset: i64, rd: i64, opcode: i64) -> i64:
    val imm = imm_offset and 0x1FFFFF
    # bit 20 -> bit 31
    val bit20 = (imm >> 20) and 0x1
    # bits 10:1 -> bits 30:21
    val bits_10_1 = (imm >> 1) and 0x3FF
    # bit 11 -> bit 20
    val bit11 = (imm >> 11) and 0x1
    # bits 19:12 -> bits 19:12
    val bits_19_12 = (imm >> 12) and 0xFF
    val hi = (bit20 << 31) or (bits_10_1 << 21) or (bit11 << 20) or (bits_19_12 << 12)
    val d = (rd and 0x1F) << 7
    val op = opcode and 0x7F
    hi or d or op

# ============================================================================
# Operand Extraction
# ============================================================================

fn get_phys_reg_id_rv(op: Operand) -> i64:
    match op.kind:
        case Reg(reg):
            match reg.kind:
                case Physical(id): id
                case Virtual(id): id
        case _: 0

fn get_mem_base_id_rv(op: Operand) -> i64:
    match op.kind:
        case Mem(base, _):
            match base.kind:
                case Physical(id): id
                case Virtual(id): id
        case _: 0

fn get_mem_offset_rv(op: Operand) -> i64:
    match op.kind:
        case Mem(_, offset): offset
        case _: 0

fn get_imm_value_rv(op: Operand) -> i64:
    match op.kind:
        case Imm(v): v
        case _: 0

fn get_label_id_rv(op: Operand) -> i64:
    match op.kind:
        case Label(id): id
        case _: 0

fn get_sym_name_rv(op: Operand) -> text:
    match op.kind:
        case Sym(name): name
        case _: ""

# ============================================================================
# Encode Context
# ============================================================================

struct EncodeContext:
    code: [i64]
    relocations: [EncodedReloc]
    block_offsets: Dict<i64, i64>
    pending_jumps: [PendingJump]

struct PendingJump:
    code_offset: i64
    target_block: i64
    jump_kind: i64

# Jump kinds
val JUMP_JAL = 0       # J-type (JAL)
val JUMP_BRANCH = 1    # B-type (BEQ/BNE/BLT/BGE)

fn new_encode_context() -> EncodeContext:
    EncodeContext(code: [], relocations: [], block_offsets: {}, pending_jumps: [])

# Relocation type for RISC-V CALL (AUIPC+JALR pair)
val R_RISCV_CALL_PLT = 19

# ============================================================================
# Load Immediate Helper
# ============================================================================

# Encode LI rd, imm - loads an arbitrary 64-bit immediate into rd.
# For small values (fits in 12-bit signed): ADDI rd, x0, imm
# For 32-bit values: LUI + ADDI
# For larger: LUI + ADDI + SLLI + ADDI sequences
fn encode_li_riscv64(code: [i64], rd: i64, imm: i64) -> [i64]:
    var result = code
    # Small immediate: fits in signed 12-bit [-2048, 2047]
    if imm >= -2048:
        if imm <= 2047:
            # ADDI rd, x0, imm
            val enc = encode_i_type_riscv64(imm and 0xFFF, RV_X0, 0, rd, 0x13)
            result = emit_u32_le_riscv64(result, enc)
            return result

    # 32-bit range: use LUI + ADDI
    # LUI loads imm[31:12], ADDI adds imm[11:0]
    # If bit 11 is set, LUI upper needs +1 to compensate for sign extension
    var upper = (imm >> 12) and 0xFFFFF
    val lower = imm and 0xFFF
    # Check if lower 12 bits are negative when sign-extended
    if lower >= 2048:
        upper = upper + 1
    val lui_enc = encode_u_type_riscv64(upper and 0xFFFFF, rd, 0x37)
    result = emit_u32_le_riscv64(result, lui_enc)
    # Only emit ADDI if lower bits are nonzero
    if lower != 0:
        val addi_enc = encode_i_type_riscv64(lower, rd, 0, rd, 0x13)
        result = emit_u32_le_riscv64(result, addi_enc)
    result

# ============================================================================
# R-type ALU Dispatch Helpers
# ============================================================================

# Get funct7 field for R-type ALU opcodes
fn rv_alu_funct7(opcode: i64) -> i64:
    if opcode == RV_OP_SUB: 0x20
    elif opcode == RV_OP_SRA: 0x20
    elif opcode == RV_OP_MUL: 0x01
    elif opcode == RV_OP_DIV: 0x01
    elif opcode == RV_OP_REM: 0x01
    else: 0x00

# Get funct3 field for R-type ALU opcodes
fn rv_alu_funct3(opcode: i64) -> i64:
    if opcode == RV_OP_ADD: 0
    elif opcode == RV_OP_SUB: 0
    elif opcode == RV_OP_MUL: 0
    elif opcode == RV_OP_DIV: 4
    elif opcode == RV_OP_REM: 6
    elif opcode == RV_OP_AND: 7
    elif opcode == RV_OP_OR: 6
    elif opcode == RV_OP_XOR: 4
    elif opcode == RV_OP_SLL: 1
    elif opcode == RV_OP_SRA: 5
    elif opcode == RV_OP_SRL: 5
    elif opcode == RV_OP_SLT: 2
    elif opcode == RV_OP_SLTU: 3
    else: 0

# Get funct3 for B-type branch opcodes
fn rv_branch_funct3(opcode: i64) -> i64:
    if opcode == RV_OP_BEQ: 0
    elif opcode == RV_OP_BNE: 1
    elif opcode == RV_OP_BLT: 4
    elif opcode == RV_OP_BGE: 5
    else: 0

# ============================================================================
# Instruction Encoding
# ============================================================================

fn encode_inst_riscv64(ectx: EncodeContext, inst: MachInst) -> EncodeContext:
    var code = ectx.code
    var relocs = ectx.relocations
    var pending = ectx.pending_jumps

    if inst.opcode == RV_OP_NOP:
        # NOP = ADDI x0, x0, 0 = 0x00000013
        code = emit_u32_le_riscv64(code, 0x00000013)

    elif inst.opcode == RV_OP_RET:
        # RET = JALR x0, x1, 0 = 0x00008067
        code = emit_u32_le_riscv64(code, 0x00008067)

    elif inst.opcode == RV_OP_MV:
        # MV rd, rs = ADDI rd, rs, 0
        val rd = get_phys_reg_id_rv(inst.operands[0])
        val rs = get_phys_reg_id_rv(inst.operands[1])
        val enc = encode_i_type_riscv64(0, rs, 0, rd, 0x13)
        code = emit_u32_le_riscv64(code, enc)

    elif inst.opcode == RV_OP_LI:
        # LI rd, imm (pseudo-instruction, variable length)
        val rd = get_phys_reg_id_rv(inst.operands[0])
        val imm = get_imm_value_rv(inst.operands[1])
        code = encode_li_riscv64(code, rd, imm)

    elif inst.opcode == RV_OP_ADD or inst.opcode == RV_OP_SUB or inst.opcode == RV_OP_MUL or inst.opcode == RV_OP_DIV or inst.opcode == RV_OP_REM or inst.opcode == RV_OP_AND or inst.opcode == RV_OP_OR or inst.opcode == RV_OP_XOR or inst.opcode == RV_OP_SLL or inst.opcode == RV_OP_SRA or inst.opcode == RV_OP_SRL or inst.opcode == RV_OP_SLT or inst.opcode == RV_OP_SLTU:
        # R-type ALU: rd, rs1, rs2 with varying funct7/funct3
        val rd = get_phys_reg_id_rv(inst.operands[0])
        val rs1 = get_phys_reg_id_rv(inst.operands[1])
        val rs2 = get_phys_reg_id_rv(inst.operands[2])
        val funct7 = rv_alu_funct7(inst.opcode)
        val funct3 = rv_alu_funct3(inst.opcode)
        val enc = encode_r_type_riscv64(funct7, rs2, rs1, funct3, rd, 0x33)
        code = emit_u32_le_riscv64(code, enc)

    elif inst.opcode == RV_OP_ADDI:
        # ADDI rd, rs1, imm12: I-type funct3=0x0, opcode=0x13
        val rd = get_phys_reg_id_rv(inst.operands[0])
        val rs1 = get_phys_reg_id_rv(inst.operands[1])
        val imm12 = get_imm_value_rv(inst.operands[2])
        val enc = encode_i_type_riscv64(imm12 and 0xFFF, rs1, 0, rd, 0x13)
        code = emit_u32_le_riscv64(code, enc)

    elif inst.opcode == RV_OP_NEG:
        # NEG rd, rs = SUB rd, x0, rs
        val rd = get_phys_reg_id_rv(inst.operands[0])
        val rs = get_phys_reg_id_rv(inst.operands[1])
        val enc = encode_r_type_riscv64(0x20, rs, RV_X0, 0, rd, 0x33)
        code = emit_u32_le_riscv64(code, enc)

    elif inst.opcode == RV_OP_NOT:
        # NOT rd, rs = XORI rd, rs, -1
        val rd = get_phys_reg_id_rv(inst.operands[0])
        val rs = get_phys_reg_id_rv(inst.operands[1])
        val enc = encode_i_type_riscv64(0xFFF, rs, 4, rd, 0x13)
        code = emit_u32_le_riscv64(code, enc)

    elif inst.opcode == RV_OP_SEQZ:
        # SEQZ rd, rs = SLTIU rd, rs, 1
        val rd = get_phys_reg_id_rv(inst.operands[0])
        val rs = get_phys_reg_id_rv(inst.operands[1])
        val enc = encode_i_type_riscv64(1, rs, 3, rd, 0x13)
        code = emit_u32_le_riscv64(code, enc)

    elif inst.opcode == RV_OP_SNEZ:
        # SNEZ rd, rs = SLTU rd, x0, rs
        val rd = get_phys_reg_id_rv(inst.operands[0])
        val rs = get_phys_reg_id_rv(inst.operands[1])
        val enc = encode_r_type_riscv64(0x00, rs, RV_X0, 3, rd, 0x33)
        code = emit_u32_le_riscv64(code, enc)

    elif inst.opcode == RV_OP_LUI:
        # LUI rd, imm20: U-type opcode=0x37
        val rd = get_phys_reg_id_rv(inst.operands[0])
        val imm20 = get_imm_value_rv(inst.operands[1])
        val enc = encode_u_type_riscv64(imm20, rd, 0x37)
        code = emit_u32_le_riscv64(code, enc)

    elif inst.opcode == RV_OP_AUIPC:
        # AUIPC rd, imm20: U-type opcode=0x17
        val rd = get_phys_reg_id_rv(inst.operands[0])
        match inst.operands[1].kind:
            case Sym(name):
                val reloc_offset = code.len()
                val enc = encode_u_type_riscv64(0, rd, 0x17)
                code = emit_u32_le_riscv64(code, enc)
                val reloc = EncodedReloc(
                    offset: reloc_offset,
                    symbol_name: name,
                    reloc_type: R_RISCV_CALL_PLT,
                    addend: 0
                )
                relocs = relocs + [reloc]
            case Imm(v):
                val enc = encode_u_type_riscv64(v, rd, 0x17)
                code = emit_u32_le_riscv64(code, enc)
            case _:
                val enc = encode_u_type_riscv64(0, rd, 0x17)
                code = emit_u32_le_riscv64(code, enc)

    elif inst.opcode == RV_OP_LD:
        # LD rd, offset(rs1): I-type funct3=0x3, opcode=0x03
        val rd = get_phys_reg_id_rv(inst.operands[0])
        val base = get_mem_base_id_rv(inst.operands[1])
        val offset = get_mem_offset_rv(inst.operands[1])
        val enc = encode_i_type_riscv64(offset and 0xFFF, base, 3, rd, 0x03)
        code = emit_u32_le_riscv64(code, enc)

    elif inst.opcode == RV_OP_SD:
        # SD rs2, offset(rs1): S-type funct3=0x3, opcode=0x23
        val rs2 = get_phys_reg_id_rv(inst.operands[0])
        val base = get_mem_base_id_rv(inst.operands[1])
        val offset = get_mem_offset_rv(inst.operands[1])
        val enc = encode_s_type_riscv64(offset and 0xFFF, rs2, base, 3, 0x23)
        code = emit_u32_le_riscv64(code, enc)

    elif inst.opcode == RV_OP_LW:
        # LW rd, offset(rs1): I-type funct3=0x2, opcode=0x03
        val rd = get_phys_reg_id_rv(inst.operands[0])
        val base = get_mem_base_id_rv(inst.operands[1])
        val offset = get_mem_offset_rv(inst.operands[1])
        val enc = encode_i_type_riscv64(offset and 0xFFF, base, 2, rd, 0x03)
        code = emit_u32_le_riscv64(code, enc)

    elif inst.opcode == RV_OP_SW:
        # SW rs2, offset(rs1): S-type funct3=0x2, opcode=0x23
        val rs2 = get_phys_reg_id_rv(inst.operands[0])
        val base = get_mem_base_id_rv(inst.operands[1])
        val offset = get_mem_offset_rv(inst.operands[1])
        val enc = encode_s_type_riscv64(offset and 0xFFF, rs2, base, 2, 0x23)
        code = emit_u32_le_riscv64(code, enc)

    elif inst.opcode == RV_OP_JAL:
        # JAL rd, offset: J-type opcode=0x6F
        val rd = get_phys_reg_id_rv(inst.operands[0])
        match inst.operands[1].kind:
            case Label(block_id):
                val jump_offset = code.len()
                val enc = encode_j_type_riscv64(0, rd, 0x6F)
                code = emit_u32_le_riscv64(code, enc)
                pending = pending + [PendingJump(code_offset: jump_offset, target_block: block_id, jump_kind: JUMP_JAL)]
            case Imm(v):
                val enc = encode_j_type_riscv64(v, rd, 0x6F)
                code = emit_u32_le_riscv64(code, enc)
            case _:
                val enc = encode_j_type_riscv64(0, rd, 0x6F)
                code = emit_u32_le_riscv64(code, enc)

    elif inst.opcode == RV_OP_JALR:
        # JALR rd, rs1, imm12: I-type funct3=0x0, opcode=0x67
        val rd = get_phys_reg_id_rv(inst.operands[0])
        val rs1 = get_phys_reg_id_rv(inst.operands[1])
        val imm12 = get_imm_value_rv(inst.operands[2])
        val enc = encode_i_type_riscv64(imm12 and 0xFFF, rs1, 0, rd, 0x67)
        code = emit_u32_le_riscv64(code, enc)

    elif inst.opcode == RV_OP_BEQ or inst.opcode == RV_OP_BNE or inst.opcode == RV_OP_BLT or inst.opcode == RV_OP_BGE:
        # B-type branches: BEQ(f3=0), BNE(f3=1), BLT(f3=4), BGE(f3=5)
        val rs1 = get_phys_reg_id_rv(inst.operands[0])
        val rs2 = get_phys_reg_id_rv(inst.operands[1])
        val funct3 = rv_branch_funct3(inst.opcode)
        match inst.operands[2].kind:
            case Label(block_id):
                val jump_offset = code.len()
                val enc = encode_b_type_riscv64(0, rs2, rs1, funct3, 0x63)
                code = emit_u32_le_riscv64(code, enc)
                pending = pending + [PendingJump(code_offset: jump_offset, target_block: block_id, jump_kind: JUMP_BRANCH)]
            case _:
                val enc = encode_b_type_riscv64(0, rs2, rs1, funct3, 0x63)
                code = emit_u32_le_riscv64(code, enc)

    elif inst.opcode == RV_OP_CALL:
        # CALL symbol (pseudo): AUIPC x1, offset_hi; JALR x1, x1, offset_lo
        # Emits 8 bytes (2 instructions), with R_RISCV_CALL_PLT relocation on the pair
        match inst.operands[0].kind:
            case Sym(name):
                val reloc_offset = code.len()
                # AUIPC x1(ra), 0 - placeholder upper
                val auipc_enc = encode_u_type_riscv64(0, RV_X1, 0x17)
                code = emit_u32_le_riscv64(code, auipc_enc)
                # JALR x1(ra), x1(ra), 0 - placeholder lower
                val jalr_enc = encode_i_type_riscv64(0, RV_X1, 0, RV_X1, 0x67)
                code = emit_u32_le_riscv64(code, jalr_enc)
                # Record relocation for the AUIPC+JALR pair
                val reloc = EncodedReloc(
                    offset: reloc_offset,
                    symbol_name: name,
                    reloc_type: R_RISCV_CALL_PLT,
                    addend: 0
                )
                relocs = relocs + [reloc]
            case Label(block_id):
                # Intra-function call via JAL x1, offset
                val jump_offset = code.len()
                val enc = encode_j_type_riscv64(0, RV_X1, 0x6F)
                code = emit_u32_le_riscv64(code, enc)
                pending = pending + [PendingJump(code_offset: jump_offset, target_block: block_id, jump_kind: JUMP_JAL)]
            case _:
                # Fallback: emit NOP pair
                code = emit_u32_le_riscv64(code, 0x00000013)
                code = emit_u32_le_riscv64(code, 0x00000013)

    else:
        # Unknown opcode - emit EBREAK (0x00100073) for debug
        code = emit_u32_le_riscv64(code, 0x00100073)

    EncodeContext(code: code, relocations: relocs, block_offsets: ectx.block_offsets, pending_jumps: pending)

# ============================================================================
# Jump Patching
# ============================================================================

# Patch a 32-bit instruction at byte_offset with a branch/jump displacement.
fn patch_jump_riscv64(code: [i64], byte_offset: i64, rel_offset: i64, kind: i64) -> [i64]:
    var patched = code
    # Read existing 4-byte LE instruction
    val b0 = patched[byte_offset]
    val b1 = patched[byte_offset + 1]
    val b2 = patched[byte_offset + 2]
    val b3 = patched[byte_offset + 3]
    val old_inst = b0 or (b1 << 8) or (b2 << 16) or (b3 << 24)

    var new_inst = old_inst
    if kind == JUMP_JAL:
        # J-type: re-encode with the displacement
        # Extract rd and opcode from existing instruction
        val rd = (old_inst >> 7) and 0x1F
        val opcode = old_inst and 0x7F
        new_inst = encode_j_type_riscv64(rel_offset, rd, opcode)
    elif kind == JUMP_BRANCH:
        # B-type: re-encode with the displacement
        # Extract rs1, rs2, funct3, opcode from existing instruction
        val rs1 = (old_inst >> 15) and 0x1F
        val rs2 = (old_inst >> 20) and 0x1F
        val funct3 = (old_inst >> 12) and 0x7
        val opcode = old_inst and 0x7F
        new_inst = encode_b_type_riscv64(rel_offset, rs2, rs1, funct3, opcode)

    # Handle negative instruction values before byte extraction
    var unsigned_inst = new_inst
    if unsigned_inst < 0:
        unsigned_inst = unsigned_inst + 4294967296

    # Write back as 4 LE bytes using division/modulo
    patched[byte_offset] = unsigned_inst % 256
    patched[byte_offset + 1] = (unsigned_inst / 256) % 256
    patched[byte_offset + 2] = (unsigned_inst / 65536) % 256
    patched[byte_offset + 3] = (unsigned_inst / 16777216) % 256
    patched

# ============================================================================
# Function Encoding (two-pass)
# ============================================================================

fn encode_function_riscv64(func: MachFunction) -> EncodedFunction:
    var ectx = new_encode_context()

    # Pass 1: encode all instructions, record block offsets and pending jumps
    for block in func.blocks:
        var offsets = ectx.block_offsets
        offsets[block.block_id] = ectx.code.len()
        ectx = EncodeContext(code: ectx.code, relocations: ectx.relocations, block_offsets: offsets, pending_jumps: ectx.pending_jumps)

        for inst in block.insts:
            ectx = encode_inst_riscv64(ectx, inst)

    # Pass 2: patch branch/jump targets
    var final_code = ectx.code
    for i in 0..ectx.pending_jumps.len():
        val pj = ectx.pending_jumps[i]
        val target_block = pj.target_block
        if ectx.block_offsets.contains(target_block):
            val target_offset = ectx.block_offsets[target_block]
            val rel_offset = target_offset - pj.code_offset
            final_code = patch_jump_riscv64(final_code, pj.code_offset, rel_offset, pj.jump_kind)

    EncodedFunction(name: func.name, code: final_code, relocations: ectx.relocations)

# ============================================================================
# Module Encoding
# ============================================================================

fn encode_module_riscv64(module: MachModule) -> [EncodedFunction]:
    var results: [EncodedFunction] = []
    for func in module.functions:
        val encoded = encode_function_riscv64(func)
        results = results + [encoded]
    results

# ============================================================================
# Exports
# ============================================================================

export EncodeContext, new_encode_context, PendingJump
export JUMP_JAL, JUMP_BRANCH, R_RISCV_CALL_PLT
export encode_function_riscv64, encode_inst_riscv64, encode_module_riscv64
