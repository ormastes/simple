# x86_64 Instruction Selection
#
# Translates MIR instructions to x86_64 MachInst sequences.
# Pattern-matches on MirInstKind to produce low-level machine instructions.
# Follows System V AMD64 ABI for function calls.
#
# Pipeline: MIR -> ISel (this module) -> RegAlloc -> Encode -> ELF

use compiler.mir_data.{MirModule, MirFunction, MirBlock, MirInst, MirInstKind, MirBinOp, MirUnaryOp, MirOperand, MirOperandKind, MirConstValue, MirTerminator, MirType, MirTypeKind, LocalId, LocalKind, BlockId, SwitchCase}
use compiler.backend.native.mach_inst.{MachReg, virtual_reg, physical_reg, reg_id, Operand, OperandKind, op_reg, op_phys, op_virt, op_imm, op_mem, op_label, op_sym, MachInst, new_mach_inst, MachBlock, new_mach_block, mach_block_add_inst, MachFunction, new_mach_function, mach_func_add_block, mach_func_set_frame_size, MachModule, DataEntry, new_mach_module, mach_module_add_func, mach_module_add_data, mach_module_add_extern}
use compiler.backend.native.mach_inst.{X86_RAX, X86_RCX, X86_RDX, X86_RBX, X86_RSP, X86_RBP, X86_RSI, X86_RDI, X86_R8, X86_R9, X86_R10, X86_R11, X86_R12, X86_R13, X86_R14, X86_R15}
use compiler.backend.native.mach_inst.{X86_ARG_REGS, X86_ARG_REG_COUNT, X86_CALLEE_SAVED}
use compiler.backend.native.mach_inst.{X86_OP_MOV_REG_REG, X86_OP_MOV_REG_IMM, X86_OP_MOV_REG_MEM, X86_OP_MOV_MEM_REG, X86_OP_ADD, X86_OP_SUB, X86_OP_IMUL, X86_OP_IDIV, X86_OP_AND, X86_OP_OR, X86_OP_XOR, X86_OP_SHL, X86_OP_SAR, X86_OP_SHR, X86_OP_NEG, X86_OP_NOT, X86_OP_CMP, X86_OP_TEST, X86_OP_SETE, X86_OP_SETNE, X86_OP_SETL, X86_OP_SETLE, X86_OP_SETG, X86_OP_SETGE, X86_OP_JMP, X86_OP_JE, X86_OP_JNE, X86_OP_JNZ, X86_OP_JZ, X86_OP_CALL, X86_OP_RET, X86_OP_PUSH, X86_OP_POP, X86_OP_LEA, X86_OP_MOVZX, X86_OP_CQO, X86_OP_NOP, X86_OP_ADD_IMM, X86_OP_SUB_IMM, X86_OP_CMP_IMM, X86_OP_MOV_REG_IMM32, X86_OP_CALL_INDIRECT}

# ============================================================================
# ISel Context
# ============================================================================

struct ISelContext:
    next_vreg: i64
    frame_slots: Dict<i64, i64>
    next_frame_offset: i64
    extern_symbols: [text]
    data_entries: [DataEntry]
    string_counter: i64

fn new_isel_context() -> ISelContext:
    ISelContext(
        next_vreg: 0,
        frame_slots: {},
        next_frame_offset: 0,
        extern_symbols: [],
        data_entries: [],
        string_counter: 0
    )

fn isel_alloc_vreg(ctx: ISelContext) -> ISelContext:
    ISelContext(
        next_vreg: ctx.next_vreg + 1,
        frame_slots: ctx.frame_slots,
        next_frame_offset: ctx.next_frame_offset,
        extern_symbols: ctx.extern_symbols,
        data_entries: ctx.data_entries,
        string_counter: ctx.string_counter
    )

fn isel_get_vreg(ctx: ISelContext) -> i64:
    ctx.next_vreg - 1

fn isel_alloc_frame_slot(ctx: ISelContext, local_id: i64, size: i64) -> ISelContext:
    val aligned_size = if size < 8: 8 else: size
    val offset = ctx.next_frame_offset + aligned_size
    var slots = ctx.frame_slots
    slots[local_id] = offset
    ISelContext(
        next_vreg: ctx.next_vreg,
        frame_slots: slots,
        next_frame_offset: offset,
        extern_symbols: ctx.extern_symbols,
        data_entries: ctx.data_entries,
        string_counter: ctx.string_counter
    )

fn isel_frame_offset(ctx: ISelContext, local_id: i64) -> i64:
    if ctx.frame_slots.contains(local_id):
        return ctx.frame_slots[local_id]
    0

fn isel_add_extern(ctx: ISelContext, name: text) -> ISelContext:
    # Check if already added (avoid duplicates that break symbol indexing)
    var already_added = false
    for existing in ctx.extern_symbols:
        if existing == name:
            already_added = true
    if already_added:
        return ctx
    var new_ext = ctx.extern_symbols
    new_ext = new_ext + [name]
    ISelContext(
        next_vreg: ctx.next_vreg,
        frame_slots: ctx.frame_slots,
        next_frame_offset: ctx.next_frame_offset,
        extern_symbols: new_ext,
        data_entries: ctx.data_entries,
        string_counter: ctx.string_counter
    )

fn isel_add_string_data(ctx: ISelContext, s: text) -> ISelContext:
    val label = ".LC{ctx.string_counter}"
    var str_bytes: [i64] = []
    for i in 0..s.len():
        val ch = s[i]
        var ascii = char_to_ascii(ch)
        str_bytes = str_bytes + [ascii]
    str_bytes = str_bytes + [0]
    val entry = DataEntry(name: label, data: str_bytes, is_readonly: true)
    var new_data = ctx.data_entries
    new_data = new_data + [entry]
    ISelContext(
        next_vreg: ctx.next_vreg,
        frame_slots: ctx.frame_slots,
        next_frame_offset: ctx.next_frame_offset,
        extern_symbols: ctx.extern_symbols,
        data_entries: new_data,
        string_counter: ctx.string_counter + 1
    )

fn isel_last_string_label(ctx: ISelContext) -> text:
    ".LC{ctx.string_counter - 1}"

fn char_to_ascii(ch: text) -> i64:
    if ch == "a": 97
    elif ch == "b": 98
    elif ch == "c": 99
    elif ch == "d": 100
    elif ch == "e": 101
    elif ch == "f": 102
    elif ch == "g": 103
    elif ch == "h": 104
    elif ch == "i": 105
    elif ch == "j": 106
    elif ch == "k": 107
    elif ch == "l": 108
    elif ch == "m": 109
    elif ch == "n": 110
    elif ch == "o": 111
    elif ch == "p": 112
    elif ch == "q": 113
    elif ch == "r": 114
    elif ch == "s": 115
    elif ch == "t": 116
    elif ch == "u": 117
    elif ch == "v": 118
    elif ch == "w": 119
    elif ch == "x": 120
    elif ch == "y": 121
    elif ch == "z": 122
    elif ch == "A": 65
    elif ch == "B": 66
    elif ch == "C": 67
    elif ch == "D": 68
    elif ch == "E": 69
    elif ch == "F": 70
    elif ch == "G": 71
    elif ch == "H": 72
    elif ch == "I": 73
    elif ch == "J": 74
    elif ch == "K": 75
    elif ch == "L": 76
    elif ch == "M": 77
    elif ch == "N": 78
    elif ch == "O": 79
    elif ch == "P": 80
    elif ch == "Q": 81
    elif ch == "R": 82
    elif ch == "S": 83
    elif ch == "T": 84
    elif ch == "U": 85
    elif ch == "V": 86
    elif ch == "W": 87
    elif ch == "X": 88
    elif ch == "Y": 89
    elif ch == "Z": 90
    elif ch == "0": 48
    elif ch == "1": 49
    elif ch == "2": 50
    elif ch == "3": 51
    elif ch == "4": 52
    elif ch == "5": 53
    elif ch == "6": 54
    elif ch == "7": 55
    elif ch == "8": 56
    elif ch == "9": 57
    elif ch == "_": 95
    elif ch == ".": 46
    elif ch == " ": 32
    elif ch == "\n": 10
    elif ch == "\t": 9
    elif ch == "-": 45
    elif ch == "+": 43
    elif ch == "*": 42
    elif ch == "/": 47
    elif ch == "=": 61
    elif ch == "(": 40
    elif ch == ")": 41
    elif ch == "[": 91
    elif ch == "]": 93
    elif ch == "{": 123
    elif ch == "}": 125
    elif ch == ":": 58
    elif ch == ";": 59
    elif ch == ",": 44
    elif ch == "!": 33
    elif ch == "?": 63
    elif ch == "@": 64
    elif ch == "#": 35
    elif ch == "$": 36
    elif ch == "%": 37
    elif ch == "&": 38
    elif ch == "|": 124
    elif ch == "\\": 92
    elif ch == "'": 39
    elif ch == "\"": 34
    elif ch == "<": 60
    elif ch == ">": 62
    elif ch == "~": 126
    elif ch == "^": 94
    elif ch == "`": 96
    else: 63

# ============================================================================
# Local to Virtual Register Mapping
# ============================================================================

fn local_to_vreg(local_id: i64) -> MachReg:
    virtual_reg(local_id)

fn local_vreg_op(local_id: i64) -> Operand:
    op_reg(virtual_reg(local_id))

# ============================================================================
# Operand Lowering
# ============================================================================

struct LoweredOperand:
    insts: [MachInst]
    result: Operand
    ctx: ISelContext

fn lower_operand(ctx: ISelContext, operand: MirOperand) -> LoweredOperand:
    match operand.kind:
        case Copy(local):
            LoweredOperand(insts: [], result: local_vreg_op(local.id), ctx: ctx)
        case Move(local):
            LoweredOperand(insts: [], result: local_vreg_op(local.id), ctx: ctx)
        case Const(value, type_):
            lower_const(ctx, value, type_)

fn lower_const(ctx: ISelContext, value: MirConstValue, type_: MirType) -> LoweredOperand:
    match value:
        case Int(v):
            var new_ctx = isel_alloc_vreg(ctx)
            val vreg = isel_get_vreg(new_ctx)
            val dest = op_reg(virtual_reg(vreg))
            val inst = new_mach_inst(X86_OP_MOV_REG_IMM, [dest, op_imm(v)])
            LoweredOperand(insts: [inst], result: dest, ctx: new_ctx)
        case Bool(v):
            var new_ctx = isel_alloc_vreg(ctx)
            val vreg = isel_get_vreg(new_ctx)
            val dest = op_reg(virtual_reg(vreg))
            val imm_val = if v: 1 else: 0
            val inst = new_mach_inst(X86_OP_MOV_REG_IMM, [dest, op_imm(imm_val)])
            LoweredOperand(insts: [inst], result: dest, ctx: new_ctx)
        case Str(s):
            var new_ctx = isel_add_string_data(ctx, s)
            val label = isel_last_string_label(new_ctx)
            new_ctx = isel_alloc_vreg(new_ctx)
            val vreg = isel_get_vreg(new_ctx)
            val dest = op_reg(virtual_reg(vreg))
            val inst = new_mach_inst(X86_OP_LEA, [dest, op_sym(label)])
            LoweredOperand(insts: [inst], result: dest, ctx: new_ctx)
        case Zero:
            var new_ctx = isel_alloc_vreg(ctx)
            val vreg = isel_get_vreg(new_ctx)
            val dest = op_reg(virtual_reg(vreg))
            val inst = new_mach_inst(X86_OP_XOR, [dest, dest])
            LoweredOperand(insts: [inst], result: dest, ctx: new_ctx)
        case _:
            var new_ctx = isel_alloc_vreg(ctx)
            val vreg = isel_get_vreg(new_ctx)
            val dest = op_reg(virtual_reg(vreg))
            val inst = new_mach_inst(X86_OP_MOV_REG_IMM, [dest, op_imm(0)])
            LoweredOperand(insts: [inst], result: dest, ctx: new_ctx)

# ============================================================================
# Instruction Selection - Core
# ============================================================================

fn isel_module(module: MirModule) -> MachModule:
    var mach_module = new_mach_module(module.name)
    var ctx = new_isel_context()

    val func_keys = module.functions.keys()
    for key in func_keys:
        val func = module.functions[key]
        var result = isel_function(ctx, func)
        ctx = result.ctx
        mach_module = mach_module_add_func(mach_module, result.func)

    # Add data entries from string constants
    for entry in ctx.data_entries:
        mach_module = mach_module_add_data(mach_module, entry)

    # Add extern symbols
    for sym in ctx.extern_symbols:
        mach_module = mach_module_add_extern(mach_module, sym)

    mach_module

struct ISelFuncResult:
    func: MachFunction
    ctx: ISelContext

fn isel_function(ctx: ISelContext, func: MirFunction) -> ISelFuncResult:
    var mach_func = new_mach_function(func.name)

    # Reset vreg counter - use local IDs directly, start high for temps
    var local_ctx = ISelContext(
        next_vreg: func.locals.len() + 100,
        frame_slots: ctx.frame_slots,
        next_frame_offset: 0,
        extern_symbols: ctx.extern_symbols,
        data_entries: ctx.data_entries,
        string_counter: ctx.string_counter
    )

    # Allocate frame slots for locals that need stack space
    for local in func.locals:
        val size = local.type_.size_bytes()
        local_ctx = isel_alloc_frame_slot(local_ctx, local.id.id, size)

    # Generate prologue block
    var prologue_block = new_mach_block("prologue", -1)
    prologue_block = mach_block_add_inst(prologue_block, new_mach_inst(X86_OP_PUSH, [op_phys(X86_RBP)]))
    prologue_block = mach_block_add_inst(prologue_block, new_mach_inst(X86_OP_MOV_REG_REG, [op_phys(X86_RBP), op_phys(X86_RSP)]))
    # Frame size placeholder - will be patched after we know total frame size
    prologue_block = mach_block_add_inst(prologue_block, new_mach_inst(X86_OP_SUB_IMM, [op_phys(X86_RSP), op_imm(0)]))

    # Move arguments from ABI registers to virtual registers
    var arg_idx = 0
    for local in func.locals:
        match local.kind:
            case Arg(index):
                if index < X86_ARG_REG_COUNT:
                    val arg_reg = X86_ARG_REGS[index]
                    prologue_block = mach_block_add_inst(prologue_block, new_mach_inst(X86_OP_MOV_REG_REG, [local_vreg_op(local.id.id), op_phys(arg_reg)]))
                arg_idx = arg_idx + 1
            case _: ()

    mach_func = mach_func_add_block(mach_func, prologue_block)

    # Translate each MIR block
    for block in func.blocks:
        var result = isel_block(local_ctx, block)
        local_ctx = result.ctx
        mach_func = mach_func_add_block(mach_func, result.block)

    # Set frame size (aligned to 16)
    var frame_size = local_ctx.next_frame_offset
    if frame_size % 16 != 0:
        frame_size = frame_size + (16 - (frame_size % 16))
    mach_func = mach_func_set_frame_size(mach_func, frame_size)

    # Propagate context back
    val out_ctx = ISelContext(
        next_vreg: ctx.next_vreg,
        frame_slots: ctx.frame_slots,
        next_frame_offset: ctx.next_frame_offset,
        extern_symbols: local_ctx.extern_symbols,
        data_entries: local_ctx.data_entries,
        string_counter: local_ctx.string_counter
    )

    ISelFuncResult(func: mach_func, ctx: out_ctx)

struct ISelBlockResult:
    block: MachBlock
    ctx: ISelContext

fn isel_block(ctx: ISelContext, block: MirBlock) -> ISelBlockResult:
    val label = if block.label.?: block.label.unwrap() else: "bb{block.id.id}"
    var mach_block = new_mach_block(label, block.id.id)
    var current_ctx = ctx

    # Lower instructions
    for inst in block.instructions:
        var result = isel_inst(current_ctx, inst)
        current_ctx = result.ctx
        for mi in result.insts:
            mach_block = mach_block_add_inst(mach_block, mi)

    # Lower terminator
    var term_result = isel_terminator(current_ctx, block.terminator)
    current_ctx = term_result.ctx
    for mi in term_result.insts:
        mach_block = mach_block_add_inst(mach_block, mi)

    ISelBlockResult(block: mach_block, ctx: current_ctx)

# ============================================================================
# Instruction Selection - Instructions
# ============================================================================

struct ISelInstResult:
    insts: [MachInst]
    ctx: ISelContext

fn isel_inst(ctx: ISelContext, inst: MirInst) -> ISelInstResult:
    match inst.kind:
        case Const(dest, value, type_):
            isel_const(ctx, dest, value, type_)
        case Copy(dest, src):
            isel_copy(ctx, dest, src)
        case Move(dest, src):
            isel_copy(ctx, dest, src)
        case BinOp(dest, op, left, right):
            isel_binop(ctx, dest, op, left, right)
        case UnaryOp(dest, op, operand):
            isel_unaryop(ctx, dest, op, operand)
        case Load(dest, ptr):
            isel_load(ctx, dest, ptr)
        case Store(ptr, value):
            isel_store(ctx, ptr, value)
        case Call(dest, func_op, args):
            isel_call(ctx, dest, func_op, args)
        case GetField(dest, base, field):
            isel_get_field(ctx, dest, base, field)
        case SetField(base, field, value):
            isel_set_field(ctx, base, field, value)
        case Alloc(dest, type_):
            isel_alloc(ctx, dest, type_)
        case Aggregate(dest, kind, operands):
            isel_aggregate(ctx, dest, operands)
        case Cast(dest, operand, target):
            isel_cast(ctx, dest, operand, target)
        case Nop:
            ISelInstResult(insts: [new_mach_inst(X86_OP_NOP, [])], ctx: ctx)
        case _:
            # Unsupported instruction - emit NOP
            ISelInstResult(insts: [new_mach_inst(X86_OP_NOP, [])], ctx: ctx)

fn isel_const(ctx: ISelContext, dest: LocalId, value: MirConstValue, type_: MirType) -> ISelInstResult:
    val lowered = lower_const(ctx, value, type_)
    val dest_op = local_vreg_op(dest.id)
    # Move the const result to the destination vreg
    var insts = lowered.insts
    insts = insts + [new_mach_inst(X86_OP_MOV_REG_REG, [dest_op, lowered.result])]
    ISelInstResult(insts: insts, ctx: lowered.ctx)

fn isel_copy(ctx: ISelContext, dest: LocalId, src: LocalId) -> ISelInstResult:
    val inst = new_mach_inst(X86_OP_MOV_REG_REG, [local_vreg_op(dest.id), local_vreg_op(src.id)])
    ISelInstResult(insts: [inst], ctx: ctx)

fn isel_binop(ctx: ISelContext, dest: LocalId, op: MirBinOp, left: MirOperand, right: MirOperand) -> ISelInstResult:
    val left_low = lower_operand(ctx, left)
    val right_low = lower_operand(left_low.ctx, right)
    var current_ctx = right_low.ctx
    val dest_op = local_vreg_op(dest.id)
    var insts: [MachInst] = []
    insts = insts + left_low.insts
    insts = insts + right_low.insts

    match op:
        case Add:
            insts = insts + [new_mach_inst(X86_OP_MOV_REG_REG, [dest_op, left_low.result])]
            insts = insts + [new_mach_inst(X86_OP_ADD, [dest_op, right_low.result])]
        case Sub:
            insts = insts + [new_mach_inst(X86_OP_MOV_REG_REG, [dest_op, left_low.result])]
            insts = insts + [new_mach_inst(X86_OP_SUB, [dest_op, right_low.result])]
        case Mul:
            insts = insts + [new_mach_inst(X86_OP_MOV_REG_REG, [dest_op, left_low.result])]
            insts = insts + [new_mach_inst(X86_OP_IMUL, [dest_op, right_low.result])]
        case Div:
            # idiv uses rax:rdx / operand -> quotient in rax
            insts = insts + [new_mach_inst(X86_OP_MOV_REG_REG, [op_phys(X86_RAX), left_low.result])]
            insts = insts + [new_mach_inst(X86_OP_CQO, [])]
            insts = insts + [new_mach_inst(X86_OP_IDIV, [right_low.result])]
            insts = insts + [new_mach_inst(X86_OP_MOV_REG_REG, [dest_op, op_phys(X86_RAX)])]
        case Rem:
            # idiv uses rax:rdx / operand -> remainder in rdx
            insts = insts + [new_mach_inst(X86_OP_MOV_REG_REG, [op_phys(X86_RAX), left_low.result])]
            insts = insts + [new_mach_inst(X86_OP_CQO, [])]
            insts = insts + [new_mach_inst(X86_OP_IDIV, [right_low.result])]
            insts = insts + [new_mach_inst(X86_OP_MOV_REG_REG, [dest_op, op_phys(X86_RDX)])]
        case BitAnd:
            insts = insts + [new_mach_inst(X86_OP_MOV_REG_REG, [dest_op, left_low.result])]
            insts = insts + [new_mach_inst(X86_OP_AND, [dest_op, right_low.result])]
        case BitOr:
            insts = insts + [new_mach_inst(X86_OP_MOV_REG_REG, [dest_op, left_low.result])]
            insts = insts + [new_mach_inst(X86_OP_OR, [dest_op, right_low.result])]
        case BitXor:
            insts = insts + [new_mach_inst(X86_OP_MOV_REG_REG, [dest_op, left_low.result])]
            insts = insts + [new_mach_inst(X86_OP_XOR, [dest_op, right_low.result])]
        case Shl:
            insts = insts + [new_mach_inst(X86_OP_MOV_REG_REG, [dest_op, left_low.result])]
            insts = insts + [new_mach_inst(X86_OP_MOV_REG_REG, [op_phys(X86_RCX), right_low.result])]
            insts = insts + [new_mach_inst(X86_OP_SHL, [dest_op])]
        case Shr:
            insts = insts + [new_mach_inst(X86_OP_MOV_REG_REG, [dest_op, left_low.result])]
            insts = insts + [new_mach_inst(X86_OP_MOV_REG_REG, [op_phys(X86_RCX), right_low.result])]
            insts = insts + [new_mach_inst(X86_OP_SHR, [dest_op])]
        case Eq:
            insts = insts + isel_comparison(dest_op, left_low.result, right_low.result, X86_OP_SETE)
        case Ne:
            insts = insts + isel_comparison(dest_op, left_low.result, right_low.result, X86_OP_SETNE)
        case Lt:
            insts = insts + isel_comparison(dest_op, left_low.result, right_low.result, X86_OP_SETL)
        case Le:
            insts = insts + isel_comparison(dest_op, left_low.result, right_low.result, X86_OP_SETLE)
        case Gt:
            insts = insts + isel_comparison(dest_op, left_low.result, right_low.result, X86_OP_SETG)
        case Ge:
            insts = insts + isel_comparison(dest_op, left_low.result, right_low.result, X86_OP_SETGE)
        case _:
            # Unsupported binop - zero result
            insts = insts + [new_mach_inst(X86_OP_XOR, [dest_op, dest_op])]

    ISelInstResult(insts: insts, ctx: current_ctx)

fn isel_comparison(dest: Operand, left: Operand, right: Operand, setcc_op: i64) -> [MachInst]:
    var insts: [MachInst] = []
    insts = insts + [new_mach_inst(X86_OP_CMP, [left, right])]
    insts = insts + [new_mach_inst(setcc_op, [dest])]
    insts = insts + [new_mach_inst(X86_OP_MOVZX, [dest, dest])]
    insts

fn isel_unaryop(ctx: ISelContext, dest: LocalId, op: MirUnaryOp, operand: MirOperand) -> ISelInstResult:
    val low = lower_operand(ctx, operand)
    val dest_op = local_vreg_op(dest.id)
    var insts = low.insts

    match op:
        case Neg:
            insts = insts + [new_mach_inst(X86_OP_MOV_REG_REG, [dest_op, low.result])]
            insts = insts + [new_mach_inst(X86_OP_NEG, [dest_op])]
        case Not:
            insts = insts + [new_mach_inst(X86_OP_MOV_REG_REG, [dest_op, low.result])]
            insts = insts + [new_mach_inst(X86_OP_NOT, [dest_op])]
        case BitNot:
            insts = insts + [new_mach_inst(X86_OP_MOV_REG_REG, [dest_op, low.result])]
            insts = insts + [new_mach_inst(X86_OP_NOT, [dest_op])]
        case _:
            insts = insts + [new_mach_inst(X86_OP_MOV_REG_REG, [dest_op, low.result])]

    ISelInstResult(insts: insts, ctx: low.ctx)

fn isel_load(ctx: ISelContext, dest: LocalId, ptr: MirOperand) -> ISelInstResult:
    val low = lower_operand(ctx, ptr)
    val dest_op = local_vreg_op(dest.id)
    var insts = low.insts
    insts = insts + [new_mach_inst(X86_OP_MOV_REG_MEM, [dest_op, op_mem(operand_get_reg(low.result), 0)])]
    ISelInstResult(insts: insts, ctx: low.ctx)

fn isel_store(ctx: ISelContext, ptr: MirOperand, value: MirOperand) -> ISelInstResult:
    val ptr_low = lower_operand(ctx, ptr)
    val val_low = lower_operand(ptr_low.ctx, value)
    var insts = ptr_low.insts
    insts = insts + val_low.insts
    insts = insts + [new_mach_inst(X86_OP_MOV_MEM_REG, [op_mem(operand_get_reg(ptr_low.result), 0), val_low.result])]
    ISelInstResult(insts: insts, ctx: val_low.ctx)

fn isel_call(ctx: ISelContext, dest: LocalId?, func_op: MirOperand, args: [MirOperand]) -> ISelInstResult:
    var insts: [MachInst] = []
    var current_ctx = ctx

    # Lower arguments into ABI registers
    for i in 0..args.len():
        val arg_low = lower_operand(current_ctx, args[i])
        current_ctx = arg_low.ctx
        insts = insts + arg_low.insts
        if i < X86_ARG_REG_COUNT:
            val arg_reg = X86_ARG_REGS[i]
            insts = insts + [new_mach_inst(X86_OP_MOV_REG_REG, [op_phys(arg_reg), arg_low.result])]
        else:
            # Stack argument
            insts = insts + [new_mach_inst(X86_OP_PUSH, [arg_low.result])]

    # Emit call
    match func_op.kind:
        case Const(MirConstValue.Str(name), _):
            # Direct call to named function
            current_ctx = isel_add_extern(current_ctx, name)
            insts = insts + [new_mach_inst(X86_OP_CALL, [op_sym(name)])]
        case Copy(local):
            # Indirect call through register
            insts = insts + [new_mach_inst(X86_OP_CALL_INDIRECT, [local_vreg_op(local.id)])]
        case Move(local):
            insts = insts + [new_mach_inst(X86_OP_CALL_INDIRECT, [local_vreg_op(local.id)])]
        case _:
            insts = insts + [new_mach_inst(X86_OP_NOP, [])]

    # Move return value from rax
    if dest.?:
        val d = dest.unwrap()
        insts = insts + [new_mach_inst(X86_OP_MOV_REG_REG, [local_vreg_op(d.id), op_phys(X86_RAX)])]

    # Clean up stack args
    val stack_args = if args.len() > X86_ARG_REG_COUNT: args.len() - X86_ARG_REG_COUNT else: 0
    if stack_args > 0:
        insts = insts + [new_mach_inst(X86_OP_ADD_IMM, [op_phys(X86_RSP), op_imm(stack_args * 8)])]

    ISelInstResult(insts: insts, ctx: current_ctx)

fn isel_get_field(ctx: ISelContext, dest: LocalId, base: MirOperand, field: i64) -> ISelInstResult:
    val base_low = lower_operand(ctx, base)
    val dest_op = local_vreg_op(dest.id)
    val offset = field * 8
    var insts = base_low.insts
    insts = insts + [new_mach_inst(X86_OP_MOV_REG_MEM, [dest_op, op_mem(operand_get_reg(base_low.result), offset)])]
    ISelInstResult(insts: insts, ctx: base_low.ctx)

fn isel_set_field(ctx: ISelContext, base: MirOperand, field: i64, value: MirOperand) -> ISelInstResult:
    val base_low = lower_operand(ctx, base)
    val val_low = lower_operand(base_low.ctx, value)
    val offset = field * 8
    var insts = base_low.insts
    insts = insts + val_low.insts
    insts = insts + [new_mach_inst(X86_OP_MOV_MEM_REG, [op_mem(operand_get_reg(base_low.result), offset), val_low.result])]
    ISelInstResult(insts: insts, ctx: val_low.ctx)

fn isel_alloc(ctx: ISelContext, dest: LocalId, type_: MirType) -> ISelInstResult:
    val size = type_.size_bytes()
    val aligned = if size < 8: 8 else: size
    val dest_op = local_vreg_op(dest.id)
    var insts: [MachInst] = []
    insts = insts + [new_mach_inst(X86_OP_SUB_IMM, [op_phys(X86_RSP), op_imm(aligned)])]
    insts = insts + [new_mach_inst(X86_OP_LEA, [dest_op, op_mem(physical_reg(X86_RSP), 0)])]
    ISelInstResult(insts: insts, ctx: ctx)

fn isel_aggregate(ctx: ISelContext, dest: LocalId, operands: [MirOperand]) -> ISelInstResult:
    var insts: [MachInst] = []
    var current_ctx = ctx

    # Calculate total size (each field is 8 bytes)
    val num_fields = operands.len()
    var total_size = num_fields * 8
    if total_size < 8:
        total_size = 8
    # Align to 16 bytes for stack alignment
    if total_size % 16 != 0:
        total_size = total_size + (16 - (total_size % 16))

    # Allocate stack space
    insts = insts + [new_mach_inst(X86_OP_SUB_IMM, [op_phys(X86_RSP), op_imm(total_size)])]

    # Get base address into destination vreg
    val dest_op = local_vreg_op(dest.id)
    val base_reg = virtual_reg(dest.id)
    insts = insts + [new_mach_inst(X86_OP_LEA, [dest_op, op_mem(physical_reg(X86_RSP), 0)])]

    # Store each operand at its field offset
    for i in 0..num_fields:
        val op_low = lower_operand(current_ctx, operands[i])
        current_ctx = op_low.ctx
        insts = insts + op_low.insts
        val offset = i * 8
        insts = insts + [new_mach_inst(X86_OP_MOV_MEM_REG, [op_mem(base_reg, offset), op_low.result])]

    ISelInstResult(insts: insts, ctx: current_ctx)

fn isel_cast(ctx: ISelContext, dest: LocalId, operand: MirOperand, target: MirType) -> ISelInstResult:
    val low = lower_operand(ctx, operand)
    val dest_op = local_vreg_op(dest.id)
    var insts = low.insts
    # Simple move - truncation/extension handled by encoder based on type
    insts = insts + [new_mach_inst(X86_OP_MOV_REG_REG, [dest_op, low.result])]
    ISelInstResult(insts: insts, ctx: low.ctx)

# ============================================================================
# Instruction Selection - Terminators
# ============================================================================

fn isel_terminator(ctx: ISelContext, term: MirTerminator) -> ISelInstResult:
    match term:
        case Goto(target):
            val inst = new_mach_inst(X86_OP_JMP, [op_label(target.id)])
            ISelInstResult(insts: [inst], ctx: ctx)
        case Return(value):
            var insts: [MachInst] = []
            if value.?:
                val v = value.unwrap()
                val low = lower_operand(ctx, v)
                insts = insts + low.insts
                insts = insts + [new_mach_inst(X86_OP_MOV_REG_REG, [op_phys(X86_RAX), low.result])]
            # Epilogue
            insts = insts + [new_mach_inst(X86_OP_MOV_REG_REG, [op_phys(X86_RSP), op_phys(X86_RBP)])]
            insts = insts + [new_mach_inst(X86_OP_POP, [op_phys(X86_RBP)])]
            insts = insts + [new_mach_inst(X86_OP_RET, [])]
            ISelInstResult(insts: insts, ctx: ctx)
        case If(cond, then_, else_):
            val cond_low = lower_operand(ctx, cond)
            var insts = cond_low.insts
            insts = insts + [new_mach_inst(X86_OP_TEST, [cond_low.result, cond_low.result])]
            insts = insts + [new_mach_inst(X86_OP_JNZ, [op_label(then_.id)])]
            insts = insts + [new_mach_inst(X86_OP_JMP, [op_label(else_.id)])]
            ISelInstResult(insts: insts, ctx: cond_low.ctx)
        case Switch(value, targets, default_target):
            val val_low = lower_operand(ctx, value)
            var insts = val_low.insts
            for target in targets:
                insts = insts + [new_mach_inst(X86_OP_CMP_IMM, [val_low.result, op_imm(target.value)])]
                insts = insts + [new_mach_inst(X86_OP_JE, [op_label(target.target.id)])]
            insts = insts + [new_mach_inst(X86_OP_JMP, [op_label(default_target.id)])]
            ISelInstResult(insts: insts, ctx: val_low.ctx)
        case Unreachable:
            ISelInstResult(insts: [new_mach_inst(X86_OP_NOP, [])], ctx: ctx)
        case _:
            ISelInstResult(insts: [new_mach_inst(X86_OP_NOP, [])], ctx: ctx)

# Helper to get MachReg from an Operand
fn operand_get_reg(op: Operand) -> MachReg:
    match op.kind:
        case Reg(r): r
        case _: virtual_reg(0)

# ============================================================================
# Exports
# ============================================================================

export ISelContext, new_isel_context
export isel_module
export LoweredOperand, ISelFuncResult, ISelBlockResult, ISelInstResult
