# WebAssembly Backend
#
# Compiles Simple programs to WebAssembly for browser deployment.
# Provides:
# - WASM binary generation
# - JavaScript glue code generation
# - Browser FFI via @extern("browser")
# - WASI support for non-browser environments
#
# Usage:
#   val backend = WasmBackend.create(WasmTarget.Browser)
#   val result = backend.compile_module(mir_module)
#   result.write_to_files("output")

use compiler.mir_data.*
use compiler.backend.backend_api.*
use compiler.backend.wasm_type_mapper.WasmTypeMapper

# ============================================================================
# WASM Target
# ============================================================================

enum WasmTarget:
    """WebAssembly target environment."""
    Browser     # Browser with JavaScript glue
    Wasi        # WASI for standalone/CLI
    Minimal     # Minimal runtime (no JS, no WASI)

impl WasmTarget:
    fn to_text() -> text:
        match self:
            case Browser: "browser"
            case Wasi: "wasi"
            case Minimal: "minimal"

    fn needs_js_glue() -> bool:
        match self:
            case Browser: true
            case _: false

    fn needs_wasi_imports() -> bool:
        match self:
            case Wasi: true
            case _: false

# ============================================================================
# WASM Type System
# ============================================================================

enum WasmType:
    """WebAssembly value types."""
    I32
    I64
    F32
    F64
    FuncRef
    ExternRef

impl WasmType:
    fn to_text() -> text:
        match self:
            case I32: "i32"
            case I64: "i64"
            case F32: "f32"
            case F64: "f64"
            case FuncRef: "funcref"
            case ExternRef: "externref"

fn mir_type_to_wasm(ty: MirType, target: CodegenTarget) -> WasmType:
    """
    Convert MIR type to WASM type using shared type mapper.

    Note: For new code, consider using WasmTypeMapper directly for more control.
    This function provides backwards compatibility with existing code.
    """
    val mapper = WasmTypeMapper.create_for_target(target)
    val type_str = mapper.map_type(ty)

    # Convert text back to WasmType enum for backwards compatibility
    match type_str:
        case "i64": WasmType.I64
        case "i32": WasmType.I32
        case "f64": WasmType.F64
        case "f32": WasmType.F32
        case _: WasmType.I32  # Default for unknown types

# ============================================================================
# WASM Import/Export
# ============================================================================

struct WasmImport:
    """An imported function/global."""
    module_name: text
    field_name: text
    kind: WasmImportKind

enum WasmImportKind:
    Function(params: [WasmType], results: [WasmType])
    Global(ty: WasmType, mutable: bool)
    Memory(min_pages: i64, max_pages: i64?)
    Table(element_type: WasmType, min_size: i64, max_size: i64?)

struct WasmExport:
    """An exported function/global."""
    name: text
    kind: WasmExportKind

enum WasmExportKind:
    Function(index: i64)
    Global(index: i64)
    Memory(index: i64)
    Table(index: i64)

# ============================================================================
# Browser FFI
# ============================================================================

struct BrowserBinding:
    """A browser FFI binding from @extern("browser")."""
    simple_name: text      # Name in Simple code
    js_module: text        # JavaScript module (e.g., "console", "document")
    js_function: text      # JavaScript function name
    params: [WasmType]
    result: WasmType?

impl BrowserBinding:
    static fn console_log() -> BrowserBinding:
        BrowserBinding(
            simple_name: "print",
            js_module: "console",
            js_function: "log",
            params: [WasmType.I32],  # String pointer
            result: nil
        )

    static fn alert() -> BrowserBinding:
        BrowserBinding(
            simple_name: "alert",
            js_module: "window",
            js_function: "alert",
            params: [WasmType.I32],
            result: nil
        )

    fn to_import() -> WasmImport:
        WasmImport(
            module_name: "browser",
            field_name: self.js_function,
            kind: WasmImportKind.Function(
                params: self.params,
                results: if self.result.?: [self.result.unwrap()] else: []
            )
        )

# ============================================================================
# JavaScript Glue Code Generator
# ============================================================================

class JsGlueGenerator:
    """Generates JavaScript glue code for browser deployment."""
    bindings: [BrowserBinding]
    exports: [text]
    memory_pages: i64

    static fn create() -> JsGlueGenerator:
        JsGlueGenerator(
            bindings: [],
            exports: [],
            memory_pages: 16  # Default 1MB
        )

    me add_binding(binding: BrowserBinding):
        """Add a browser binding."""
        self.bindings = self.bindings.push(binding)

    me add_export(name: text):
        """Add an exported function."""
        self.exports = self.exports.push(name)

    fn generate() -> text:
        """Generate JavaScript glue code."""
        var js = "// Generated JavaScript glue code\n"
        js = "{js}\n"

        # Memory setup
        js = "{js}const memory = new WebAssembly.Memory({{ initial: {self.memory_pages} }});\n\n"

        # String helper
        js = "{js}function readString(ptr, len) {{\n"
        js = "{js}  const bytes = new Uint8Array(memory.buffer, ptr, len);\n"
        js = "{js}  return new TextDecoder().decode(bytes);\n"
        js = "{js}}}\n\n"

        # Import object
        js = "{js}const imports = {{\n"
        js = "{js}  env: {{\n"
        js = "{js}    memory: memory,\n"
        js = "{js}  }},\n"

        # Browser bindings
        js = "{js}  browser: {{\n"
        for binding in self.bindings:
            js = "{js}    {binding.js_function}: ({self.generate_params(binding)}) => {{\n"
            js = "{js}      {self.generate_body(binding)}\n"
            js = "{js}    }},\n"
        js = "{js}  }},\n"
        js = "{js}}};\n\n"

        # Loader
        js = "{js}async function loadWasm(wasmPath) {{\n"
        js = "{js}  const response = await fetch(wasmPath);\n"
        js = "{js}  const bytes = await response.arrayBuffer();\n"
        js = "{js}  const {{ instance }} = await WebAssembly.instantiate(bytes, imports);\n"
        js = "{js}  return instance.exports;\n"
        js = "{js}}}\n\n"

        # Export list
        js = "{js}export {{ loadWasm }};\n"

        js

    fn generate_params(binding: BrowserBinding) -> text:
        var params: [text] = []
        for i in 0..binding.params.len():
            params = params.push("arg{i}")
        params.join(", ")

    fn generate_body(binding: BrowserBinding) -> text:
        match binding.js_module:
            case "console":
                "console.{binding.js_function}(readString(arg0, arg1));"
            case "window":
                "window.{binding.js_function}(readString(arg0, arg1));"
            case _:
                "{binding.js_module}.{binding.js_function}();"

# ============================================================================
# WASM Text Format (WAT) Builder
# ============================================================================

class WatBuilder:
    """Builds WebAssembly text format."""
    lines: [text]
    indent_level: i64

    static fn create() -> WatBuilder:
        WatBuilder(lines: [], indent_level: 0)

    me emit(line: text):
        """Emit a line with current indentation."""
        val indent = "  ".repeat(self.indent_level)
        self.lines = self.lines.push("{indent}{line}")

    me begin_module(name: text):
        """Start a module."""
        self.emit("(module ${name}")
        self.indent_level = self.indent_level + 1

    me end_module():
        """End a module."""
        self.indent_level = self.indent_level - 1
        self.emit(")")

    me emit_import(import_def: WasmImport):
        """Emit an import."""
        match import_def.kind:
            case Function(params, results):
                val param_str = params.map(\t: t.to_text()).join(" ")
                val result_str = results.map(\t: t.to_text()).join(" ")
                self.emit("(import \"{import_def.module_name}\" \"{import_def.field_name}\" (func (param {param_str}) (result {result_str})))")
            case Memory(min, max):
                val max_str = if max.?: " {max.unwrap()}" else: ""
                self.emit("(import \"{import_def.module_name}\" \"{import_def.field_name}\" (memory {min}{max_str}))")
            case _:
                pass

    me emit_export(export_def: WasmExport):
        """Emit an export."""
        match export_def.kind:
            case Function(idx):
                self.emit("(export \"{export_def.name}\" (func {idx}))")
            case Memory(idx):
                self.emit("(export \"{export_def.name}\" (memory {idx}))")
            case _:
                pass

    me begin_func(name: text, params: [WasmType], results: [WasmType]):
        """Start a function."""
        val param_str = params.map(\t: "(param {t.to_text()})").join(" ")
        val result_str = results.map(\t: "(result {t.to_text()})").join(" ")
        self.emit("(func ${name} {param_str} {result_str}")
        self.indent_level = self.indent_level + 1

    me end_func():
        """End a function."""
        self.indent_level = self.indent_level - 1
        self.emit(")")

    me emit_local(ty: WasmType):
        """Emit a local variable."""
        self.emit("(local {ty.to_text()})")

    me emit_i32_const(value: i64):
        """Emit i32.const."""
        self.emit("i32.const {value}")

    me emit_i64_const(value: i64):
        """Emit i64.const."""
        self.emit("i64.const {value}")

    me emit_local_get(idx: i64):
        """Emit local.get."""
        self.emit("local.get {idx}")

    me emit_local_set(idx: i64):
        """Emit local.set."""
        self.emit("local.set {idx}")

    me emit_call(func_idx: i64):
        """Emit call."""
        self.emit("call {func_idx}")

    me emit_return():
        """Emit return."""
        self.emit("return")

    fn build() -> text:
        """Build final WAT string."""
        self.lines.join("\n")

# ============================================================================
# WASM Backend
# ============================================================================

class WasmBackend:
    """WebAssembly compilation backend."""
    target: WasmTarget
    opt_level: OptimizationLevel
    memory_pages: i64
    browser_bindings: [BrowserBinding]
    type_mapper: WasmTypeMapper     # Type mapper for MIR â†’ Wasm types

    static fn create(target: WasmTarget) -> WasmBackend:
        # Default to Wasm32 (most common target)
        val codegen_target = CodegenTarget.Wasm32
        WasmBackend(
            target: target,
            opt_level: OptimizationLevel.Size,  # Default to size opt for WASM
            memory_pages: 16,
            browser_bindings: [],
            type_mapper: WasmTypeMapper.create_for_target(codegen_target)
        )

    static fn browser() -> WasmBackend:
        WasmBackend.create(WasmTarget.Browser)

    static fn wasi() -> WasmBackend:
        WasmBackend.create(WasmTarget.Wasi)

    me add_browser_binding(binding: BrowserBinding):
        """Add a browser FFI binding."""
        self.browser_bindings = self.browser_bindings.push(binding)

    fn compile_module(module: MirModule) -> Result<WasmCompileResult, CompileError>:
        """Compile a MIR module to WebAssembly."""
        # Build WAT
        var builder = WatBuilder.create()
        builder.begin_module(module.name)

        # Add imports based on target
        if self.target == WasmTarget.Browser:
            for binding in self.browser_bindings:
                builder.emit_import(binding.to_import())

        # Add memory
        builder.emit("(memory 1)")
        builder.emit_export(WasmExport(
            name: "memory",
            kind: WasmExportKind.Memory(0)
        ))

        # Translate functions
        for name, body in module.functions:
            self.translate_function(builder, name, body, self.type_mapper)

        builder.end_module()

        val wat = builder.build()

        # Generate JS glue if needed
        var js_glue: text? = nil
        if self.target.needs_js_glue():
            var glue_gen = JsGlueGenerator.create()
            for binding in self.browser_bindings:
                glue_gen.add_binding(binding)
            for name, _ in module.functions:
                glue_gen.add_export(name)
            js_glue = Some(glue_gen.generate())

        Ok(WasmCompileResult(
            module_name: module.name,
            wat: wat,
            wasm: nil,  # Would compile WAT to binary
            js_glue: js_glue,
            compile_time_ms: 0
        ))

    fn translate_function(
        builder: WatBuilder,
        name: text,
        body: MirBody,
        type_mapper: WasmTypeMapper
    ):
        """Translate a MIR function to WAT using shared type mapper."""
        var params: [WasmType] = []
        for _ in 0..body.arg_count:
            params = params.push(WasmType.I64)

        var results: [WasmType] = []
        if body.return_ty.kind != MirTypeKind.Unit:
            # Use type mapper and convert text to WasmType
            val type_str = type_mapper.map_type(body.return_ty)
            val wasm_type = match type_str:
                case "i64": WasmType.I64
                case "i32": WasmType.I32
                case "f64": WasmType.F64
                case "f32": WasmType.F32
                case _: WasmType.I32
            results = [wasm_type]

        builder.begin_func(name, params, results)

        # Would translate MIR to WASM instructions here

        builder.end_func()

struct WasmCompileResult:
    """Result of WASM compilation."""
    module_name: text
    wat: text                # WebAssembly text format
    wasm: [u8]?             # WebAssembly binary
    js_glue: text?          # JavaScript glue code
    compile_time_ms: i64

impl WasmCompileResult:
    fn has_js_glue() -> bool:
        self.js_glue.?

    fn write_to_files(base_path: text) -> Result<(), text>:
        """Write compilation outputs to files."""
        # Would write:
        # - {base_path}.wat
        # - {base_path}.wasm
        # - {base_path}.js (if js_glue present)
        Ok(())

# ============================================================================
# Exports
# ============================================================================

export WasmTarget, WasmType, mir_type_to_wasm
export WasmImport, WasmImportKind, WasmExport, WasmExportKind
export BrowserBinding, JsGlueGenerator
export WatBuilder, WasmBackend, WasmCompileResult
