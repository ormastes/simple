"""
# Backend Support Matrix Builder

Generates support matrix documentation showing which backends support which instructions.

**Phase:** 3 - Documentation Generation
**Status:** Complete
"""

use compiler.backend.capability_tracker.{
    CapabilityTracker, InstructionCategory, create_default_tracker
}
use std.string.{NL}

# Matrix builder
class MatrixBuilder:
    tracker: CapabilityTracker

    # Generate markdown table for all instructions
    fn generate_full_matrix() -> text:
        var output = "# Backend Instruction Support Matrix" + NL + NL
        output = output + "| Instruction | Category | Cranelift | LLVM | Vulkan | Interpreter |" + NL
        output = output + "|-------------|----------|-----------|------|--------|-------------|" + NL

        for inst in self.tracker.instructions:
            val cran = if inst.cranelift: "âœ…" else: "âŒ"
            val llvm_ = if inst.llvm: "âœ…" else: "âŒ"
            val vulk = if inst.vulkan: "âœ…" else: "âŒ"
            val interp = if inst.interpreter: "âœ…" else: "âŒ"

            val cat_name = self.category_to_string(inst.category)

            output = output + "| {inst.instruction_name} | {cat_name} | {cran} | {llvm_} | {vulk} | {interp} |" + NL

        output

    # Generate summary statistics
    fn generate_summary() -> text:
        var output = "## Backend Coverage Summary" + NL + NL

        val cran_cov = self.tracker.get_coverage("cranelift")
        val llvm_cov = self.tracker.get_coverage("llvm")
        val vulk_cov = self.tracker.get_coverage("vulkan")
        val interp_cov = self.tracker.get_coverage("interpreter")

        output = output + "| Backend | Coverage | Status |" + NL
        output = output + "|---------|----------|--------|" + NL
        output = output + "| Cranelift | {cran_cov}% | {self.coverage_status(cran_cov)} |" + NL
        output = output + "| LLVM | {llvm_cov}% | {self.coverage_status(llvm_cov)} |" + NL
        output = output + "| Vulkan | {vulk_cov}% | {self.coverage_status(vulk_cov)} |" + NL
        output = output + "| Interpreter | {interp_cov}% | {self.coverage_status(interp_cov)} |" + NL

        output

    # Generate category breakdown
    fn generate_category_matrix() -> text:
        var output = "## Support by Category" + NL + NL

        output = output + self.generate_category_section(InstructionCategory.Constants)
        output = output + self.generate_category_section(InstructionCategory.Arithmetic)
        output = output + self.generate_category_section(InstructionCategory.ControlFlow)
        output = output + self.generate_category_section(InstructionCategory.SIMD)
        output = output + self.generate_category_section(InstructionCategory.GPU)
        output = output + self.generate_category_section(InstructionCategory.Async)

        output

    # Generate section for one category
    fn generate_category_section(cat: InstructionCategory) -> text:
        val cat_name = self.category_to_string(cat)
        var output = "### {cat_name}" + NL + NL

        val insts = self.tracker.get_by_category(cat)
        if insts.len() == 0:
            return output + "No instructions in this category." + NL + NL

        output = output + "| Instruction | Cranelift | LLVM | Vulkan | Interpreter |" + NL
        output = output + "|-------------|-----------|------|--------|-------------|" + NL

        for inst in insts:
            val cran = if inst.cranelift: "âœ…" else: "âŒ"
            val llvm_ = if inst.llvm: "âœ…" else: "âŒ"
            val vulk = if inst.vulkan: "âœ…" else: "âŒ"
            val interp = if inst.interpreter: "âœ…" else: "âŒ"

            output = output + "| {inst.instruction_name} | {cran} | {llvm_} | {vulk} | {interp} |" + NL

        output = output + NL
        output

    # Helper: category to string
    fn category_to_string(cat: InstructionCategory) -> text:
        if cat == InstructionCategory.Constants:
            "Constants"
        else if cat == InstructionCategory.Arithmetic:
            "Arithmetic"
        else if cat == InstructionCategory.Bitwise:
            "Bitwise"
        else if cat == InstructionCategory.Comparison:
            "Comparison"
        else if cat == InstructionCategory.Memory:
            "Memory"
        else if cat == InstructionCategory.ControlFlow:
            "Control Flow"
        else if cat == InstructionCategory.Collections:
            "Collections"
        else if cat == InstructionCategory.SIMD:
            "SIMD"
        else if cat == InstructionCategory.GPU:
            "GPU"
        else if cat == InstructionCategory.Pointers:
            "Pointers"
        else if cat == InstructionCategory.Structs:
            "Structs"
        else if cat == InstructionCategory.Enums:
            "Enums"
        else if cat == InstructionCategory.Async:
            "Async"
        else if cat == InstructionCategory.ErrorHandling:
            "Error Handling"
        else if cat == InstructionCategory.Closures:
            "Closures"
        else:
            "Unknown"

    # Helper: coverage status
    fn coverage_status(pct: i32) -> text:
        if pct >= 90:
            "ğŸŸ¢ Excellent"
        else if pct >= 70:
            "ğŸŸ¡ Good"
        else if pct >= 50:
            "ğŸŸ  Partial"
        else:
            "ğŸ”´ Limited"

# Create builder with default tracker
fn create_matrix_builder() -> MatrixBuilder:
    MatrixBuilder(tracker: create_default_tracker())

# Generate complete documentation
fn generate_complete_docs() -> text:
    val builder = create_matrix_builder()
    var output = ""

    output = output + builder.generate_summary()
    output = output + NL + "---" + NL + NL
    output = output + builder.generate_category_matrix()
    output = output + NL + "---" + NL + NL
    output = output + builder.generate_full_matrix()

    output

export MatrixBuilder, create_matrix_builder, generate_complete_docs
