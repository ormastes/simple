# Backend Optimization Passes
#
# Defines optimization passes that can be selected and configured from Simple code.
# The actual pass execution happens in Rust (Cranelift), but selection is data-driven.

use compiler.backend_types.*

# ============================================================================
# Optimization Pass Types
# ============================================================================

enum OptimizationLevel:
    """Optimization level for code generation."""
    None_
    Speed
    Size
    Debug

struct OptimizationPass:
    """Configuration for a single optimization pass."""
    name: text
    enabled: bool
    priority: i64
    description: text

impl OptimizationPass:
    static fn new(name: text, enabled: bool, priority: i64, description: text) -> OptimizationPass:
        OptimizationPass(
            name: name,
            enabled: enabled,
            priority: priority,
            description: description
        )

# ============================================================================
# Pass Registry
# ============================================================================

struct PassRegistry:
    """Registry of available optimization passes."""
    passes: [OptimizationPass]
    level: OptimizationLevel

impl PassRegistry:
    static fn default() -> PassRegistry:
        """Create default pass registry with speed optimization."""
        PassRegistry.for_level(OptimizationLevel.Speed)

    static fn for_level(level: OptimizationLevel) -> PassRegistry:
        """Create pass registry for specific optimization level."""
        val passes = match level:
            case nil: disabled_passes()
            case Speed: speed_passes()
            case Size: size_passes()
            case Debug: debug_passes()

        PassRegistry(passes: passes, level: level)

    fn enabled_passes() -> [OptimizationPass]:
        """Get list of enabled passes."""
        self.passes.filter(\p: p.enabled)

    fn pass_names() -> [text]:
        """Get names of enabled passes."""
        self.enabled_passes().map(\p: p.name)

    me enable_pass(name: text) -> bool:
        """Enable a specific pass.

        Returns true if pass was found and enabled, false if not found.
        """
        for i in 0..self.passes.len():
            if self.passes[i].name == name:
                self.passes[i].enabled = true
                return true  # Early exit
        false  # Pass not found

    me disable_pass(name: text) -> bool:
        """Disable a specific pass.

        Returns true if pass was found and disabled, false if not found.
        """
        for i in 0..self.passes.len():
            if self.passes[i].name == name:
                self.passes[i].enabled = false
                return true  # Early exit
        false  # Pass not found

# ============================================================================
# Pass Definitions
# ============================================================================

fn disabled_passes() -> [OptimizationPass]:
    """No optimization passes."""
    []

fn speed_passes() -> [OptimizationPass]:
    """Optimization passes for speed."""
    [
        OptimizationPass.new("constant_folding", true, 10, "Fold constant expressions"),
        OptimizationPass.new("dead_code_elimination", true, 20, "Remove dead code"),
        OptimizationPass.new("inlining", true, 30, "Inline small functions"),
        OptimizationPass.new("loop_optimization", true, 40, "Optimize loops"),
        OptimizationPass.new("common_subexpression", true, 50, "Eliminate common subexpressions"),
        OptimizationPass.new("register_allocation", true, 60, "Optimize register usage"),
    ]

fn size_passes() -> [OptimizationPass]:
    """Optimization passes for code size."""
    [
        OptimizationPass.new("constant_folding", true, 10, "Fold constant expressions"),
        OptimizationPass.new("dead_code_elimination", true, 20, "Remove dead code"),
        OptimizationPass.new("inlining", false, 30, "Inline small functions (disabled for size)"),
        OptimizationPass.new("common_subexpression", true, 40, "Eliminate common subexpressions"),
    ]

fn debug_passes() -> [OptimizationPass]:
    """Minimal passes for debugging."""
    [
        OptimizationPass.new("dead_code_elimination", false, 10, "Remove dead code (disabled in debug)"),
    ]

# ============================================================================
# Pass Configuration
# ============================================================================

struct PassConfig:
    """Configuration for pass execution."""
    registry: PassRegistry
    verify_ir: bool
    print_ir: bool
    timing: bool

impl PassConfig:
    static fn default() -> PassConfig:
        """Default configuration."""
        PassConfig(
            registry: PassRegistry.default(),
            verify_ir: false,
            print_ir: false,
            timing: false
        )

    static fn for_level(level: OptimizationLevel) -> PassConfig:
        """Create configuration for optimization level."""
        PassConfig(
            registry: PassRegistry.for_level(level),
            verify_ir: level == OptimizationLevel.Debug,
            print_ir: false,
            timing: false
        )

    static fn debug() -> PassConfig:
        """Debug configuration with verification enabled."""
        PassConfig(
            registry: PassRegistry.for_level(OptimizationLevel.Debug),
            verify_ir: true,
            print_ir: true,
            timing: true
        )

# ============================================================================
# Exports
# ============================================================================

export OptimizationLevel, OptimizationPass, PassRegistry
export PassConfig
