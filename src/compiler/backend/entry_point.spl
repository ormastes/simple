# Entry Point Generation - LLVM IR for program entry points
#
# Generates LLVM IR for the program's entry point that bridges
# the OS-level entry (main or _start) to the Simple program's
# __simple_main function with proper runtime initialization.
#
# Two modes:
#   generate_entry_point_ir() - Standard hosted entry (main)
#   generate_start_ir()       - Bare-metal entry (_start)
#
# The generated IR calls:
#   1. __simple_runtime_init()     - Initialize runtime (GC, allocator, etc.)
#   2. __simple_main()             - User's main function (renamed by compiler)
#   3. __simple_runtime_shutdown() - Cleanup runtime
#
# Usage:
#   val ir = generate_entry_point_ir("my_program")
#   val baremetal_ir = generate_start_ir_for_target("my_kernel", CodegenTarget.AArch64)

use core.backend_types.CodegenTarget
use std.string.{NL}

# ============================================================================
# Hosted Entry Point (main)
# ============================================================================

fn generate_entry_point_ir(module_name: text) -> text:
    """Generate LLVM IR for a standard hosted entry point (main).

    Produces a `main(i32, ptr)` function that:
    1. Calls __simple_runtime_init()
    2. Calls __simple_main() and captures the i64 return value
    3. Calls __simple_runtime_shutdown()
    4. Truncates the i64 result to i32 and returns it as exit code
    """
    var ir = "; Entry point for Simple program: {module_name}{NL}"
    ir = ir + "; Generated by Simple compiler - do not edit{NL}"
    ir = ir + NL

    # Runtime function declarations
    ir = ir + "declare void @__simple_runtime_init(){NL}"
    ir = ir + "declare i64 @__simple_main(){NL}"
    ir = ir + "declare void @__simple_runtime_shutdown(){NL}"
    ir = ir + NL

    # main function definition
    ir = ir + "define i32 @main(i32 %argc, ptr %argv) {{{NL}"
    ir = ir + "entry:{NL}"
    ir = ir + "    call void @__simple_runtime_init(){NL}"
    ir = ir + "    %result = call i64 @__simple_main(){NL}"
    ir = ir + "    call void @__simple_runtime_shutdown(){NL}"
    ir = ir + "    %exit_code = trunc i64 %result to i32{NL}"
    ir = ir + "    ret i32 %exit_code{NL}"
    ir = ir + "}}{NL}"

    ir

# ============================================================================
# Bare-Metal Entry Point (_start)
# ============================================================================

fn generate_start_ir(module_name: text) -> text:
    """Generate LLVM IR for a bare-metal entry point (_start) with x86 hlt.

    Legacy API - uses hlt instruction. For other architectures, use
    generate_start_ir_for_target().
    """
    generate_start_ir_for_target(module_name, CodegenTarget.X86_64)

fn generate_start_ir_for_target(module_name: text, target: CodegenTarget) -> text:
    """Generate LLVM IR for a bare-metal entry point (_start).

    Produces a `_start()` function that:
    1. Calls __simple_runtime_init()
    2. Calls __simple_main()
    3. Calls __simple_runtime_shutdown()
    4. Enters an infinite halt loop (no OS to return to)

    Uses architecture-appropriate halt instruction:
    - x86/x86_64: hlt
    - arm/aarch64/riscv: wfi (wait for interrupt)
    """
    val halt_asm = halt_instruction_for_target(target)

    var ir = "; Bare-metal entry point for Simple program: {module_name}{NL}"
    ir = ir + "; Generated by Simple compiler - do not edit{NL}"
    ir = ir + NL

    # Runtime function declarations
    ir = ir + "declare void @__simple_runtime_init(){NL}"
    ir = ir + "declare i64 @__simple_main(){NL}"
    ir = ir + "declare void @__simple_runtime_shutdown(){NL}"
    ir = ir + NL

    # _start function definition (noreturn)
    ir = ir + "define void @_start() noreturn {{{NL}"
    ir = ir + "entry:{NL}"
    ir = ir + "    call void @__simple_runtime_init(){NL}"
    ir = ir + "    %result = call i64 @__simple_main(){NL}"
    ir = ir + "    call void @__simple_runtime_shutdown(){NL}"
    ir = ir + "    br label %halt{NL}"
    ir = ir + "halt:{NL}"
    ir = ir + "    call void asm sideeffect \"{halt_asm}\", \"\"(){NL}"
    ir = ir + "    br label %halt{NL}"
    ir = ir + "}}{NL}"

    ir

fn halt_instruction_for_target(target: CodegenTarget) -> text:
    """Return the appropriate halt/wait instruction for the given target."""
    match target:
        case X86_64 | X86: "hlt"
        case AArch64 | Arm: "wfi"
        case Riscv64 | Riscv32: "wfi"
        case _: "hlt"

# ============================================================================
# WASI Entry Point (_start)
# ============================================================================

fn generate_wasi_start_ir(module_name: text) -> text:
    """Generate LLVM IR for a WASI entry point (_start).

    Produces a `_start()` function that:
    1. Calls __simple_runtime_init()
    2. Calls __simple_main()
    3. Calls __simple_runtime_shutdown()
    4. Calls __wasi_proc_exit() with the return code

    This is the standard entry point for wasm32-wasi modules.
    """
    var ir = "; WASI entry point for Simple program: {module_name}{NL}"
    ir = ir + "; Generated by Simple compiler - do not edit{NL}"
    ir = ir + NL

    # Runtime function declarations
    ir = ir + "declare void @__simple_runtime_init(){NL}"
    ir = ir + "declare i64 @__simple_main(){NL}"
    ir = ir + "declare void @__simple_runtime_shutdown(){NL}"
    ir = ir + "declare void @__wasi_proc_exit(i32){NL}"
    ir = ir + NL

    # _start function definition (noreturn)
    ir = ir + "define void @_start() noreturn {{{NL}"
    ir = ir + "entry:{NL}"
    ir = ir + "    call void @__simple_runtime_init(){NL}"
    ir = ir + "    %result = call i64 @__simple_main(){NL}"
    ir = ir + "    call void @__simple_runtime_shutdown(){NL}"
    ir = ir + "    %exit_code = trunc i64 %result to i32{NL}"
    ir = ir + "    call void @__wasi_proc_exit(i32 %exit_code){NL}"
    ir = ir + "    unreachable{NL}"
    ir = ir + "}}{NL}"

    ir

# ============================================================================
# Combined Entry Point (for linking with user module)
# ============================================================================

fn generate_full_entry_ir(module_name: text, bare_metal: bool) -> text:
    """Generate the appropriate entry point IR based on mode.

    For hosted targets: generates main() entry
    For bare-metal targets: generates _start() entry (x86 default)
    """
    if bare_metal:
        generate_start_ir(module_name)
    else:
        generate_entry_point_ir(module_name)

fn generate_full_entry_ir_for_target(module_name: text, bare_metal: bool, target: CodegenTarget) -> text:
    """Generate the appropriate entry point IR based on mode and target.

    For WASI targets: generates _start() with __wasi_proc_exit
    For hosted targets: generates main() entry
    For bare-metal targets: generates _start() entry with arch-specific halt
    """
    match target:
        case Wasm32 | Wasm64:
            generate_wasi_start_ir(module_name)
        case _:
            if bare_metal:
                generate_start_ir_for_target(module_name, target)
            else:
                generate_entry_point_ir(module_name)

# ============================================================================
# Exports
# ============================================================================

export generate_entry_point_ir
export generate_start_ir, generate_start_ir_for_target
export generate_wasi_start_ir
export generate_full_entry_ir, generate_full_entry_ir_for_target
export halt_instruction_for_target
