# Entry Point Generation - LLVM IR for program entry points
#
# Generates LLVM IR for the program's entry point that bridges
# the OS-level entry (main or _start) to the Simple program's
# __simple_main function with proper runtime initialization.
#
# Two modes:
#   generate_entry_point_ir() - Standard hosted entry (main)
#   generate_start_ir()       - Bare-metal entry (_start)
#
# The generated IR calls:
#   1. __simple_runtime_init()     - Initialize runtime (GC, allocator, etc.)
#   2. __simple_main()             - User's main function (renamed by compiler)
#   3. __simple_runtime_shutdown() - Cleanup runtime
#
# Usage:
#   val ir = generate_entry_point_ir("my_program")
#   val baremetal_ir = generate_start_ir_for_target("my_kernel", CodegenTarget.AArch64)

use compiler.backend.backend_types.CodegenTarget

# ============================================================================
# Hosted Entry Point (main)
# ============================================================================

fn generate_entry_point_ir(module_name: text) -> text:
    """Generate LLVM IR for a standard hosted entry point (main).

    Produces a `main(i32, ptr)` function that:
    1. Calls __simple_runtime_init()
    2. Calls __simple_main() and captures the i64 return value
    3. Calls __simple_runtime_shutdown()
    4. Truncates the i64 result to i32 and returns it as exit code
    """
    var ir = "; Entry point for Simple program: {module_name}\n"
    ir = ir + "; Generated by Simple compiler - do not edit\n"
    ir = ir + "\n"

    # Runtime function declarations
    ir = ir + "declare void @__simple_runtime_init()\n"
    ir = ir + "declare i64 @__simple_main()\n"
    ir = ir + "declare void @__simple_runtime_shutdown()\n"
    ir = ir + "\n"

    # main function definition
    ir = ir + "define i32 @main(i32 %argc, ptr %argv) {\n"
    ir = ir + "entry:\n"
    ir = ir + "    call void @__simple_runtime_init()\n"
    ir = ir + "    %result = call i64 @__simple_main()\n"
    ir = ir + "    call void @__simple_runtime_shutdown()\n"
    ir = ir + "    %exit_code = trunc i64 %result to i32\n"
    ir = ir + "    ret i32 %exit_code\n"
    ir = ir + "}\n"

    ir

# ============================================================================
# Bare-Metal Entry Point (_start)
# ============================================================================

fn generate_start_ir(module_name: text) -> text:
    """Generate LLVM IR for a bare-metal entry point (_start) with x86 hlt.

    Legacy API - uses hlt instruction. For other architectures, use
    generate_start_ir_for_target().
    """
    generate_start_ir_for_target(module_name, CodegenTarget.X86_64)

fn generate_start_ir_for_target(module_name: text, target: CodegenTarget) -> text:
    """Generate LLVM IR for a bare-metal entry point (_start).

    Produces a `_start()` function that:
    1. Calls __simple_runtime_init()
    2. Calls __simple_main()
    3. Calls __simple_runtime_shutdown()
    4. Enters an infinite halt loop (no OS to return to)

    Uses architecture-appropriate halt instruction:
    - x86/x86_64: hlt
    - arm/aarch64/riscv: wfi (wait for interrupt)
    """
    val halt_asm = halt_instruction_for_target(target)

    var ir = "; Bare-metal entry point for Simple program: {module_name}\n"
    ir = ir + "; Generated by Simple compiler - do not edit\n"
    ir = ir + "\n"

    # Runtime function declarations
    ir = ir + "declare void @__simple_runtime_init()\n"
    ir = ir + "declare i64 @__simple_main()\n"
    ir = ir + "declare void @__simple_runtime_shutdown()\n"
    ir = ir + "\n"

    # _start function definition (noreturn)
    ir = ir + "define void @_start() noreturn {\n"
    ir = ir + "entry:\n"
    ir = ir + "    call void @__simple_runtime_init()\n"
    ir = ir + "    %result = call i64 @__simple_main()\n"
    ir = ir + "    call void @__simple_runtime_shutdown()\n"
    ir = ir + "    br label %halt\n"
    ir = ir + "halt:\n"
    ir = ir + "    call void asm sideeffect \"{halt_asm}\", \"\"()\n"
    ir = ir + "    br label %halt\n"
    ir = ir + "}\n"

    ir

fn halt_instruction_for_target(target: CodegenTarget) -> text:
    """Return the appropriate halt/wait instruction for the given target."""
    match target:
        case X86_64 | X86: "hlt"
        case AArch64 | Arm: "wfi"
        case Riscv64 | Riscv32: "wfi"
        case _: "hlt"

# ============================================================================
# Combined Entry Point (for linking with user module)
# ============================================================================

fn generate_full_entry_ir(module_name: text, bare_metal: bool) -> text:
    """Generate the appropriate entry point IR based on mode.

    For hosted targets: generates main() entry
    For bare-metal targets: generates _start() entry (x86 default)
    """
    if bare_metal:
        generate_start_ir(module_name)
    else:
        generate_entry_point_ir(module_name)

fn generate_full_entry_ir_for_target(module_name: text, bare_metal: bool, target: CodegenTarget) -> text:
    """Generate the appropriate entry point IR based on mode and target.

    For hosted targets: generates main() entry
    For bare-metal targets: generates _start() entry with arch-specific halt
    """
    if bare_metal:
        generate_start_ir_for_target(module_name, target)
    else:
        generate_entry_point_ir(module_name)

# ============================================================================
# Exports
# ============================================================================

export generate_entry_point_ir
export generate_start_ir, generate_start_ir_for_target
export generate_full_entry_ir, generate_full_entry_ir_for_target
export halt_instruction_for_target
