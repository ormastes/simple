# Backend Helper Functions
#
# Standalone helper functions for backend selection and management:
# - select_backend: Legacy backend selection
# - select_backend_with_mode: Mode-aware backend selection
# - available_backends, gpu_backends: Backend listing
# - compile_module_with_backend: Convenience compilation
#
# Split from backend_api.spl for modularity.

use compiler.mir_data.*
use core.backend_types.{BackendKind, CodegenTarget, BuildMode, OptimizationLevel, CompileOptions, CompiledModule, CompileError}
use compiler.backend.llvm_backend (MirToLlvm, LlvmTargetConfig, compile_ir_to_object, llc_available,
    MirToLlvm__create, LlvmTargetConfig__for_target)
use compiler.backend.native.mod.{native_compile_result}
use std.string.{NL}

# ============================================================================
# Helper Functions
# ============================================================================

fn format_mir_module(module: MirModule) -> text:
    """Format MIR module for debugging."""
    var output = "MIR Module: {module.name}{NL}"
    output = "{output}Functions: {module.functions.len()}{NL}"
    # Would include more detailed MIR dump
    output

fn select_backend(target: CodegenTarget, preferred: BackendKind?) -> BackendKind:
    """
    Select the best backend for a target (legacy API).
    For new code, use select_backend_with_mode().
    """
    if preferred.? and preferred.unwrap().supports_target(target):
        return preferred.unwrap()

    # Auto-select based on target only (no build mode consideration)
    if target.is_cuda():
        BackendKind.Cuda
    elif target.is_vulkan():
        BackendKind.Vulkan
    elif target.is_wasm():
        BackendKind.Wasm
    elif target.is_32bit():
        BackendKind.Llvm
    else:
        BackendKind.Cranelift

fn select_backend_with_mode(
    target: CodegenTarget,
    mode: BuildMode,
    preferred: BackendKind?
) -> BackendKind:
    """
    Select the best backend for target and build mode.

    Selection strategy:
    1. User preference (if specified and supported)
    2. 32-bit targets -> LLVM (only backend supporting 32-bit)
    3. WebAssembly -> Wasm backend
    4. Test mode -> Interpreter (no compilation overhead)
    5. Debug mode -> Cranelift (2.5x faster compilation)
    6. Release mode -> LLVM (15-30% faster runtime)
    7. Bootstrap mode -> Cranelift (minimal dependencies)

    Examples:
        select_backend_with_mode(X86, Release, nil)     # -> LLVM (32-bit)
        select_backend_with_mode(X86_64, Debug, nil)    # -> Cranelift (fast compile)
        select_backend_with_mode(X86_64, Release, nil)  # -> LLVM (optimized runtime)
        select_backend_with_mode(X86_64, Test, nil)     # -> Interpreter (no compile)
    """
    # 1. User preference overrides everything
    if preferred.?:
        val backend = preferred.unwrap()
        if backend.supports_target(target):
            return backend
        else:
            # User requested unsupported backend, fall through to auto-select
            ()

    # 2. 32-bit targets always use LLVM (Cranelift doesn't support 32-bit)
    if target.is_32bit():
        return BackendKind.Llvm

    # 3. WebAssembly targets use Wasm backend
    if target.is_wasm():
        return BackendKind.Wasm

    # 4. Test mode uses Interpreter (no compilation overhead)
    if mode == BuildMode.Test:
        return BackendKind.Interpreter

    # 5. For 64-bit targets, choose based on build mode
    match mode:
        case Debug:
            BackendKind.Cranelift  # Fast compilation (2.5x vs LLVM)

        case Release:
            BackendKind.Llvm       # Better optimization (15-30% faster runtime)

        case Bootstrap:
            BackendKind.Cranelift  # Minimal dependencies

        case Test:
            BackendKind.Interpreter  # Already handled above, but included for completeness

fn available_backends() -> [BackendKind]:
    """Get list of available backends."""
    [
        BackendKind.Cranelift,
        BackendKind.Llvm,
        BackendKind.Native,
        BackendKind.Wasm,
        BackendKind.Lean,
        BackendKind.Interpreter,
        BackendKind.Cuda,
        BackendKind.Vulkan,
        BackendKind.Vhdl
    ]

fn gpu_backends() -> [BackendKind]:
    """Get list of GPU backends."""
    [
        BackendKind.Cuda,
        BackendKind.Vulkan
    ]

fn backend_for_name(name: text) -> BackendKind?:
    """Get backend by name."""
    match name:
        case "cranelift": Some(BackendKind.Cranelift)
        case "llvm": Some(BackendKind.Llvm)
        case "native": Some(BackendKind.Native)
        case "wasm": Some(BackendKind.Wasm)
        case "lean": Some(BackendKind.Lean)
        case "interpreter": Some(BackendKind.Interpreter)
        case "cuda" | "ptx": Some(BackendKind.Cuda)
        case "vulkan" | "spirv": Some(BackendKind.Vulkan)
        case "vhdl": Some(BackendKind.Vhdl)
        case _: nil

# ============================================================================
# Convenience Functions for Driver Integration
# ============================================================================

fn compile_module_with_backend(
    backend_name: text,
    module: MirModule,
    is_release: bool
):
    """Compile a MIR module using the named backend.

    This is a convenience function for the driver that avoids Backend class
    name collisions with the DI system's Backend trait.

    Args:
        backend_name: "cranelift", "llvm", or "auto"
        module: MIR module to compile
        is_release: whether this is a release build

    Returns:
        CompiledModule with object_code bytes, or CompileError
    """
    # Resolve backend kind
    var kind = BackendKind.Cranelift
    if backend_name == "llvm":
        kind = BackendKind.Llvm
    elif backend_name == "native":
        kind = BackendKind.Native
    elif backend_name == "auto":
        if is_release and llc_available():
            kind = BackendKind.Llvm
        else:
            kind = BackendKind.Cranelift

    # Select build mode and optimization
    val mode = if is_release: BuildMode.Release else: BuildMode.Debug
    val opt = mode.default_optimization()

    # Create backend options and compile
    val options = CompileOptions(
        target: CodegenTarget.Host,
        opt_level: opt,
        debug_info: not is_release,
        emit_assembly: false,
        emit_llvm_ir: false,
        emit_mir: false,
        verify_output: true
    )

    # Compile based on backend kind
    match kind:
        case BackendKind.Llvm:
            # Check llc availability
            if not llc_available():
                return Err(CompileError.backend_error(BackendKind.Llvm,
                    "llc not found. Install LLVM: apt install llvm (Ubuntu) or brew install llvm (macOS)"))

            # Translate MIR to LLVM IR
            val config = LlvmTargetConfig__for_target(options.target, nil)
            var translator = MirToLlvm__create(module.name, options.target, nil)
            val llvm_ir = translator.translate_module(module)

            # Compile IR to object code via llc
            val result = compile_ir_to_object(llvm_ir, config, options.opt_level)
            if result.is_err():
                val err_msg = result.unwrap_err()
                return Err(CompileError.backend_error(BackendKind.Llvm, err_msg))

            val bytes = result.unwrap()
            Ok(CompiledModule(
                name: module.name,
                object_code: Some(bytes),
                assembly: nil,
                llvm_ir: nil,
                mir_dump: nil,
                symbols: [],
                compile_time_ms: 0
            ))

        case BackendKind.Native:
            # Native backend - direct machine code generation (no external tools)
            val compiled = native_compile_result(module, CodegenTarget.X86_64)
            Ok(compiled)

        case _:
            Err(CompileError.backend_error(kind,
                "Backend {kind.to_text()} requires compiled mode."))

fn get_effective_backend_name(backend_name: text, is_release: bool) -> text:
    """Get the effective backend name after auto-resolution."""
    if backend_name == "llvm":
        "llvm"
    elif backend_name == "cranelift":
        "cranelift"
    elif backend_name == "native":
        "native"
    elif backend_name == "auto":
        if is_release and llc_available():
            "llvm"
        else:
            "cranelift"
    else:
        "cranelift"

export format_mir_module, select_backend, select_backend_with_mode
export available_backends, gpu_backends, backend_for_name
export compile_module_with_backend, get_effective_backend_name
