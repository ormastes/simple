# MIR Contract Lowering and State Machine
#
# Contract mode, lowerer state machine, contract context, and loop context
# for MIR lowering. Explicit state to simplify formal verification.
#
# Port of rust/compiler/src/mir/lower_contract.rs (248 lines)

export ContractMode, LoopContext, ContractContext
export LowererState, BlockState, MirLowerError

# ============================================================================
# Contract Mode (CTR-040 to CTR-043)
# ============================================================================

enum ContractMode:
    """Controls when contract checks are emitted during compilation."""
    Off         # No contract checks (CTR-040)
    Boundary    # Only at public API boundaries (CTR-041)
    All         # Check all contracts (default) (CTR-042)
    Test        # All contracts + rich diagnostics (CTR-043)

impl ContractMode:
    static fn from_text(s: text) -> ContractMode?:
        match s.lower():
            case "off" | "none": Some(ContractMode.Off)
            case "boundary" | "public": Some(ContractMode.Boundary)
            case "all" | "on": Some(ContractMode.All)
            case "test" | "debug": Some(ContractMode.Test)
            case _: nil

    fn to_text() -> text:
        match self:
            case Off: "off"
            case Boundary: "boundary"
            case All: "all"
            case Test: "test"

    fn has_rich_diagnostics() -> bool:
        """Test mode includes function name, expression, source location, stack trace."""
        match self: case Test: true; case _: false

    fn checks_all() -> bool:
        match self: case All | Test: true; case _: false

    fn should_check(is_public: bool) -> bool:
        """Whether to emit contract checks for a function."""
        match self:
            case Off: false
            case Boundary: is_public
            case All | Test: true

# ============================================================================
# Loop Context (for break/continue)
# ============================================================================

struct LoopContext:
    continue_target: i64    # Block ID for continue
    break_target: i64       # Block ID for break

# ============================================================================
# Contract Context
# ============================================================================

struct ContractContext:
    """Context for contract lowering within a function."""
    old_captures: {i64: i64}    # index -> vreg holding captured value
    return_value: i64?          # VReg holding the return value
    func_name: text
    is_public: bool

impl ContractContext:
    static fn empty(func_name: text, is_public: bool) -> ContractContext:
        ContractContext(old_captures: {}, return_value: nil,
                        func_name: func_name, is_public: is_public)

    fn has_old_capture(index: i64) -> bool:
        self.old_captures.contains_key(index)

    fn get_old_capture(index: i64) -> i64?:
        if self.old_captures.contains_key(index):
            Some(self.old_captures[index])
        else:
            nil

# ============================================================================
# Lowerer State Machine
# ============================================================================

enum LowererState:
    """Explicit lowerer state for formal verification.

    Lean model:
      inductive LowererState
        | idle
        | lowering (func_name : text) (current_block : i64)
                   (loop_stack : List LoopContext)
    """
    Idle
    Lowering(func_name: text, current_block: i64,
             loop_stack: [LoopContext], contract_ctx: ContractContext)

impl LowererState:
    fn is_idle() -> bool:
        match self: case Idle: true; case _: false

    fn is_lowering() -> bool:
        match self: case Lowering(_, _, _, _): true; case _: false

    fn try_current_block() -> Result<i64, MirLowerError>:
        match self:
            case Lowering(_, block, _, _): Ok(block)
            case Idle: Err(MirLowerError.InvalidState(
                expected: "Lowering", found: "Idle"))

    fn try_loop_stack() -> Result<[LoopContext], MirLowerError>:
        match self:
            case Lowering(_, _, stack, _): Ok(stack)
            case Idle: Err(MirLowerError.InvalidState(
                expected: "Lowering", found: "Idle"))

    fn try_contract_ctx() -> Result<ContractContext, MirLowerError>:
        match self:
            case Lowering(_, _, _, ctx): Ok(ctx)
            case Idle: Err(MirLowerError.InvalidState(
                expected: "Lowering", found: "Idle"))

    fn loop_depth() -> i64:
        match self:
            case Lowering(_, _, stack, _): stack.len()
            case Idle: 0

# ============================================================================
# Block State
# ============================================================================

enum BlockState:
    """Makes terminator state explicit for verification."""
    Open        # Accepting instructions
    Sealed      # Has a terminator

impl BlockState:
    fn is_open() -> bool:
        match self: case Open: true; case _: false

    fn is_sealed() -> bool:
        match self: case Sealed: true; case _: false

# ============================================================================
# MIR Lowering Errors
# ============================================================================

enum MirLowerError:
    Unsupported(text)
    InvalidState(expected: text, found: text)
    BreakOutsideLoop
    ContinueOutsideLoop
    AopWeavingFailed(text)
    CircularDependency(text)

impl MirLowerError:
    fn message() -> text:
        match self:
            case Unsupported(msg): "Unsupported HIR construct: {msg}"
            case InvalidState(expected, found): "Invalid state: expected {expected}, found {found}"
            case BreakOutsideLoop: "Break outside loop"
            case ContinueOutsideLoop: "Continue outside loop"
            case AopWeavingFailed(msg): "AOP weaving failed: {msg}"
            case CircularDependency(msg): "Circular dependency in DI: {msg}"
