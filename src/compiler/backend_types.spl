# Backend Types - Backend Trait and Value Definitions
#
# This module contains backend type definitions:
# - BackendKind, BackendResult, BackendError: Backend interface types
# - CompiledUnit, CompiledSymbol: Compilation output types
# - SdnValue: SDN (data-only) value representation
# - Value: Runtime value representation
# - Environment: Execution environment for values
#
# Backend implementations are in backend.spl

use compiler.hir.*
use compiler.mir.*
use core.lexer.Span

enum BackendKind:
    Interpreter
    Compiler
    Sdn
    CraneliftJit
    LlvmJit
    AutoJit
    Custom(name: text)

# ============================================================================
# Backend Results and Errors
# ============================================================================

"""Result of backend processing."""
enum BackendResult:
    Value(value: Value)
    CompiledUnit(unit: CompiledUnit)
    SdnData(data: SdnValue)
    Unit

struct BackendError:
    """Error during backend processing."""
    message: text
    span: Span?
    kind: BackendErrorKind

"""Backend error kind."""
enum BackendErrorKind:
    NotAllowed          # Operation not allowed (SDN mode)
    TypeError           # Type mismatch
    RuntimeError        # Runtime error
    CompileError        # Compilation error
    NotImplemented      # Feature not implemented
    Internal            # Internal error

impl BackendError:
    static fn not_allowed(message: text, span: Span?) -> BackendError:
        BackendError(message: message, span: span, kind: BackendErrorKind.NotAllowed)

    static fn type_error(message: text, span: Span?) -> BackendError:
        BackendError(message: message, span: span, kind: BackendErrorKind.TypeError)

    static fn runtime_error(message: text, span: Span?) -> BackendError:
        BackendError(message: message, span: span, kind: BackendErrorKind.RuntimeError)

    static fn compile_error(message: text, span: Span?) -> BackendError:
        BackendError(message: message, span: span, kind: BackendErrorKind.CompileError)

    static fn not_implemented(message: text) -> BackendError:
        BackendError(message: message, span: nil, kind: BackendErrorKind.NotImplemented)

    static fn internal(message: text) -> BackendError:
        BackendError(message: message, span: nil, kind: BackendErrorKind.Internal)

# ============================================================================
# Compiled Unit (for Compiler Backend)
# ============================================================================

struct CompiledUnit:
    """Result of compilation."""
    name: text
    code: [u8]
    symbols: Dict<text, CompiledSymbol>
    entry_point: text?
    relocations: [Relocation]

struct CompiledSymbol:
    """Symbol in compiled unit."""
    name: text
    address: i64
    size: i64
    kind: CompiledSymbolKind

enum CompiledSymbolKind:
    Function
    Data
    External

struct Relocation:
    """Relocation entry."""
    offset: i64
    symbol: text
    kind: RelocKind

enum RelocKind:
    Absolute
    Relative
    PltRelative

# ============================================================================
# SDN Value (for SDN Backend)
# ============================================================================

struct SdnValue:
    """Data-only value from SDN parsing."""
    kind: SdnValueKind

"""SDN value kind."""
enum SdnValueKind:
    Nil
    Bool(value: bool)
    Int(value: i64)
    Float(value: f64)
    String(value: text)
    Array(elements: [SdnValue])
    Dict(entries: Dict<text, SdnValue>)
    Table(headers: [text], rows: [[SdnValue]])

impl SdnValue:
    static fn make_nil() -> SdnValue:
        SdnValue(kind: SdnValueKind.Nil)

    static fn bool(value: bool) -> SdnValue:
        SdnValue(kind: SdnValueKind.Bool(value))

    static fn int(value: i64) -> SdnValue:
        SdnValue(kind: SdnValueKind.Int(value))

    static fn float(value: f64) -> SdnValue:
        SdnValue(kind: SdnValueKind.Float(value))

    static fn string(value: text) -> SdnValue:
        SdnValue(kind: SdnValueKind.String(value))

    static fn array(elements: [SdnValue]) -> SdnValue:
        SdnValue(kind: SdnValueKind.Array(elements))

    static fn dict(entries: Dict<text, SdnValue>) -> SdnValue:
        SdnValue(kind: SdnValueKind.Dict(entries))

    static fn table(headers: [text], rows: [[SdnValue]]) -> SdnValue:
        SdnValue(kind: SdnValueKind.Table(headers, rows))

# ============================================================================
# Runtime Value (for Interpreter Backend)
# ============================================================================

"""Runtime value for interpreter."""
enum Value:
    Nil
    Unit
    Bool(value: bool)
    Int(value: i64)
    Float(value: f64)
    Char(value: char)
    String(value: text)
    Array(elements: [Value])
    Tuple(elements: [Value])
    Dict(entries: Dict<text, Value>)
    Struct(type_: text, fields: Dict<text, Value>)
    Enum(type_: text, variant: text, payload: EnumPayloadValue?)
    Function(fn_: FunctionValue)
    Closure(closure: ClosureValue)
    Object(obj: ObjectValue)
    Ref(target: Value, mutable: bool)
    Option(value: Value?)
    Result(ok: Value?, err: Value?)
    TraitType(trait_name: text)
    # NEW: FFI-backed RuntimeValue pointer
    RuntimeValue(ptr: i64)  # Opaque pointer to Rust RuntimeValue

enum EnumPayloadValue:
    Tuple(values: [Value])
    Struct(fields: Dict<text, Value>)

struct FunctionValue:
    """Function value."""
    symbol: SymbolId
    name: text

struct ClosureValue:
    """Closure value with captured environment."""
    params: [HirParam]
    body: HirExpr
    captures: Dict<SymbolId, Value>

struct ObjectValue:
    """Object instance."""
    class_: SymbolId
    fields: Dict<text, Value>

impl Value:
    static fn make_nil() -> Value:
        Value.Nil

    static fn bool(value: bool) -> Value:
        Value.Bool(value)

    static fn int(value: i64) -> Value:
        Value.Int(value)

    static fn float(value: f64) -> Value:
        Value.Float(value)

    static fn string(value: text) -> Value:
        Value.String(value)

    static fn some(value: Value) -> Value:
        Value.Option(Some(value))

    static fn none() -> Value:
        Value.Option(nil)

    static fn ok(value: Value) -> Value:
        Value.Result(Some(value), nil)

    static fn err(value: Value) -> Value:
        Value.Result(nil, Some(value))

    fn is_truthy() -> bool:
        match self:
            case Nil: false
            case Bool(b): b
            case Int(i): i != 0
            case Float(f): f != 0.0
            case String(s): not s.is_empty()
            case Array(a): not a.is_empty()
            case Option(v): v.?
            case _: true

    fn type_name() -> text:
        match self:
            case Nil: "nil"
            case Unit: "unit"
            case Bool(_): "bool"
            case Int(_): "i64"
            case Float(_): "f64"
            case Char(_): "char"
            case String(_): "text"
            case Array(_): "array"
            case Tuple(_): "tuple"
            case Dict(_): "dict"
            case Struct(t, _): t
            case Enum(t, _, _): t
            case Function(_): "function"
            case Closure(_): "closure"
            case Object(o): "object"
            case Ref(_, _): "ref"
            case Option(_): "option"
            case Result(_, _): "result"
            case TraitType(_): "trait_type"
            case RuntimeValue(_): "runtime_value"
            case _: "unknown"

    # Type checking methods
    fn is_nil() -> bool:
        match self:
            case Nil: true
            case _: false

    fn is_bool() -> bool:
        match self:
            case Bool(_): true
            case _: false

    fn is_int() -> bool:
        match self:
            case Int(_): true
            case _: false

    fn is_float() -> bool:
        match self:
            case Float(_): true
            case _: false

    fn is_char() -> bool:
        match self:
            case Char(_): true
            case _: false

    fn is_string() -> bool:
        match self:
            case String(_): true
            case _: false

    fn is_array() -> bool:
        match self:
            case Array(_): true
            case _: false

    fn is_tuple() -> bool:
        match self:
            case Tuple(_): true
            case _: false

    fn is_dict() -> bool:
        match self:
            case Dict(_): true
            case _: false

    # Accessor methods (unsafe - will panic if wrong type)
    fn as_bool() -> bool:
        match self:
            case Bool(b): b
            case _: panic("Value.as_bool: not a bool, got {self.type_name()}")

    fn as_int() -> i64:
        match self:
            case Int(i): i
            case _: panic("Value.as_int: not an int, got {self.type_name()}")

    fn as_float() -> f64:
        match self:
            case Float(f): f
            case _: panic("Value.as_float: not a float, got {self.type_name()}")

    fn as_char() -> char:
        match self:
            case Char(c): c
            case _: panic("Value.as_char: not a char, got {self.type_name()}")

    fn as_string() -> text:
        match self:
            case String(s): s
            case _: panic("Value.as_string: not a string, got {self.type_name()}")

    fn as_array() -> [Value]:
        match self:
            case Array(a): a
            case _: panic("Value.as_array: not an array, got {self.type_name()}")

    fn as_tuple() -> [Value]:
        match self:
            case Tuple(t): t
            case _: panic("Value.as_tuple: not a tuple, got {self.type_name()}")

    fn as_dict() -> Dict<text, Value>:
        match self:
            case Dict(d): d
            case _: panic("Value.as_dict: not a dict, got {self.type_name()}")

    fn get_type() -> MirType?:
        # For now, return nil - full type tracking not implemented
        nil

# ============================================================================
# Evaluation Context
# ============================================================================


# ============================================================================
# Exports
# ============================================================================

export BackendKind, BackendResult, BackendError, BackendErrorKind
export CompiledUnit, CompiledSymbol, CompiledSymbolKind
export Relocation, RelocKind
export SdnValue, SdnValueKind
export Value, EnumPayloadValue, FunctionValue, ClosureValue, ObjectValue
export EvalContext, Environment
