# Method Resolution Pass (UFCS Support)
#
# Resolves method calls using UFCS (Uniform Function Call Syntax) rules:
#   1. Instance method on receiver's type (highest priority)
#   2. Trait method implemented by receiver's type
#   3. Free function where receiver becomes first argument (UFCS)
#
# Example:
#   x.map()  -> InstanceMethod if x's class has map()
#   x.map()  -> TraitMethod if x implements trait with map()
#   x.map()  -> FreeFunction(map) if map(x) exists
#
# This pass runs after type inference to have full type information.

use hir.*
use lexer.Span

# ============================================================================
# Type Compatibility
# ============================================================================

struct TypeChecker:
    """Type compatibility checking for UFCS resolution."""

    fn is_compatible(a: HirType, b: HirType) -> bool:
        """Check if type `a` is compatible with type `b` for UFCS.

        For UFCS, we check if the receiver type can be passed as the
        first parameter of a function. This includes:
        - Exact type match
        - Reference compatibility (T matches &T, &mut T)
        - Subtype relationships
        """
        match (a.kind, b.kind):
            # Exact matches
            case (Int(bits_a, signed_a), Int(bits_b, signed_b)):
                bits_a == bits_b and signed_a == signed_b
            case (Float(bits_a), Float(bits_b)):
                bits_a == bits_b
            case (Bool, Bool): true
            case (Char, Char): true
            case (Str, Str): true
            case (Unit, Unit): true

            # Named types (classes, structs, enums)
            case (Named(sym_a, args_a), Named(sym_b, args_b)):
                if sym_a.id != sym_b.id:
                    false
                elif args_a.len() != args_b.len():
                    false
                else:
                    var compatible = true
                    var i = 0
                    while i < args_a.len() and compatible:
                        compatible = self.is_compatible(args_a[i], args_b[i])
                        i = i + 1
                    compatible

            # Reference types - T is compatible with &T and &mut T
            case (_, Ref(inner, _)):
                self.is_compatible(a, inner)

            # Array types
            case (Array(elem_a, _), Array(elem_b, _)):
                self.is_compatible(elem_a, elem_b)

            # Slice types
            case (Slice(elem_a), Slice(elem_b)):
                self.is_compatible(elem_a, elem_b)

            # Optional types
            case (Optional(inner_a), Optional(inner_b)):
                self.is_compatible(inner_a, inner_b)

            # Type parameters - compatible if same name
            case (TypeParam(name_a, _), TypeParam(name_b, _)):
                name_a == name_b

            # Inference variables - always compatible (will be unified)
            case (Infer(_, _), _): true
            case (_, Infer(_, _)): true

            # Default: not compatible
            case _: false

    fn get_type_symbol(ty: HirType) -> SymbolId?:
        """Get the symbol ID for a named type."""
        match ty.kind:
            case Named(sym, _): Some(sym)
            case _: nil

# ============================================================================
# Method Resolver
# ============================================================================

class MethodResolver:
    """Resolves method calls using UFCS rules.

    Walks the HIR and resolves each MethodCall expression by trying:
    1. Instance method on the receiver's type
    2. Trait method implemented by the receiver's type
    3. Free function where receiver becomes first argument

    The resolver modifies the `resolution` field of MethodCall expressions.
    """

    symbols: SymbolTable
    type_checker: TypeChecker
    errors: [ResolveError]
    # Track implemented traits for types (type_id -> [trait_id])
    trait_impls: Dict<i64, [SymbolId]>

    static fn new(symbols: SymbolTable) -> MethodResolver:
        MethodResolver(
            symbols: symbols,
            type_checker: TypeChecker(),
            errors: [],
            trait_impls: {}
        )

    # ========================================================================
    # Module Resolution
    # ========================================================================

    me resolve_module(module: HirModule) -> HirModule:
        """Resolve all method calls in a module."""
        # Build trait implementation map from impls
        self.build_trait_impls(module.impls)

        # Resolve functions
        var resolved_functions: Dict<SymbolId, HirFunction> = {}
        for key in module.functions.keys():
            val func = module.functions[key]
            resolved_functions[key] = self.resolve_function(func)

        # Resolve constants
        var resolved_constants: Dict<SymbolId, HirConst> = {}
        for key in module.constants.keys():
            val const_ = module.constants[key]
            resolved_constants[key] = HirConst(
                symbol: const_.symbol,
                name: const_.name,
                type_: const_.type_,
                value: self.resolve_expr(const_.value),
                is_mutable: const_.is_mutable,
                is_public: const_.is_public,
                span: const_.span
            )

        # Return resolved module
        HirModule(
            name: module.name,
            path: module.path,
            imports: module.imports,
            exports: module.exports,
            symbols: module.symbols,
            functions: resolved_functions,
            classes: module.classes,
            structs: module.structs,
            enums: module.enums,
            traits: module.traits,
            impls: module.impls,
            constants: resolved_constants
        )

    me build_trait_impls(impls: [HirImpl]):
        """Build a map of type -> implemented traits."""
        for impl_ in impls:
            if impl_.trait_.?:
                val type_sym = self.type_checker.get_type_symbol(impl_.type_)
                if type_sym.?:
                    val type_id = type_sym.unwrap().id
                    val trait_sym = self.type_checker.get_type_symbol(impl_.trait_.unwrap())
                    if trait_sym.?:
                        if not self.trait_impls[type_id].?:
                            self.trait_impls[type_id] = []
                        self.trait_impls[type_id] = self.trait_impls[type_id].push(trait_sym.unwrap())

    # ========================================================================
    # Function Resolution
    # ========================================================================

    me resolve_function(func: HirFunction) -> HirFunction:
        """Resolve method calls in a function body."""
        HirFunction(
            symbol: func.symbol,
            name: func.name,
            type_params: func.type_params,
            params: func.params,
            return_type: func.return_type,
            body: self.resolve_block(func.body),
            effects: func.effects,
            is_async: func.is_async,
            is_static: func.is_static,
            is_public: func.is_public,
            is_method: func.is_method,
            is_mutable: func.is_mutable,
            doc_comment: func.doc_comment,
            span: func.span
        )

    # ========================================================================
    # Block and Statement Resolution
    # ========================================================================

    me resolve_block(block: HirBlock) -> HirBlock:
        """Resolve method calls in a block."""
        var resolved_stmts: [HirStmt] = []
        for stmt in block.stmts:
            resolved_stmts = resolved_stmts.push(self.resolve_stmt(stmt))

        val resolved_value = if block.value.?:
            Some(self.resolve_expr(block.value.unwrap()))
        else:
            nil

        HirBlock(
            stmts: resolved_stmts,
            value: resolved_value,
            span: block.span
        )

    me resolve_stmt(stmt: HirStmt) -> HirStmt:
        """Resolve method calls in a statement."""
        val kind = match stmt.kind:
            case Expr(expr):
                HirStmtKind.Expr(self.resolve_expr(expr))

            case Let(symbol, type_, init):
                HirStmtKind.Let(symbol, type_, self.resolve_expr(init))

            case Assign(target, op, value):
                HirStmtKind.Assign(
                    self.resolve_expr(target),
                    op,
                    self.resolve_expr(value)
                )

            case Block(block):
                HirStmtKind.Block(self.resolve_block(block))

        HirStmt(kind: kind, span: stmt.span)

    # ========================================================================
    # Expression Resolution
    # ========================================================================

    me resolve_expr(expr: HirExpr) -> HirExpr:
        """Resolve method calls in an expression."""
        val kind = match expr.kind:
            # Method calls - the main target
            case MethodCall(receiver, method, args, resolution):
                val resolved_receiver = self.resolve_expr(receiver)
                val resolved_args = self.resolve_call_args(args)

                # Check if this is actually a static method call (Type.method())
                val is_static = self.is_static_method_call(resolved_receiver)

                # Only resolve if not already resolved
                val new_resolution = if resolution.is_resolved():
                    resolution
                elif is_static:
                    self.resolve_static_method(resolved_receiver, method, resolved_args)
                else:
                    self.resolve_method(resolved_receiver, method, resolved_args)

                HirExprKind.MethodCall(resolved_receiver, method, resolved_args, new_resolution)

            # Regular function calls - resolve arguments
            case Call(callee, args, type_args):
                HirExprKind.Call(
                    self.resolve_expr(callee),
                    self.resolve_call_args(args),
                    type_args
                )

            # Literals - no resolution needed
            case IntLit(_, _): expr.kind
            case FloatLit(_, _): expr.kind
            case StringLit(value, interps):
                if interps.?:
                    var resolved_interps: [HirInterpolation] = []
                    for interp in interps.unwrap():
                        resolved_interps = resolved_interps.push(HirInterpolation(
                            expr: self.resolve_expr(interp.expr),
                            format: interp.format,
                            span: interp.span
                        ))
                    HirExprKind.StringLit(value, Some(resolved_interps))
                else:
                    expr.kind
            case BoolLit(_): expr.kind
            case CharLit(_): expr.kind
            case UnitLit: expr.kind
            case NilLit: expr.kind

            # Variables
            case Var(_): expr.kind

            # Field access
            case Field(base, field, resolved):
                HirExprKind.Field(self.resolve_expr(base), field, resolved)

            # Index access
            case Index(base, index):
                HirExprKind.Index(self.resolve_expr(base), self.resolve_expr(index))

            case TupleIndex(base, index):
                HirExprKind.TupleIndex(self.resolve_expr(base), index)

            # Collections
            case ArrayLit(elements, type_):
                var resolved: [HirExpr] = []
                for e in elements:
                    resolved = resolved.push(self.resolve_expr(e))
                HirExprKind.ArrayLit(resolved, type_)

            case TupleLit(elements):
                var resolved: [HirExpr] = []
                for e in elements:
                    resolved = resolved.push(self.resolve_expr(e))
                HirExprKind.TupleLit(resolved)

            case DictLit(entries, key_type, value_type):
                var resolved: [(HirExpr, HirExpr)] = []
                for (k, v) in entries:
                    resolved = resolved.push((self.resolve_expr(k), self.resolve_expr(v)))
                HirExprKind.DictLit(resolved, key_type, value_type)

            # Optional operations
            case OptionalChain(base, field):
                HirExprKind.OptionalChain(self.resolve_expr(base), field)

            case NullCoalesce(left, right):
                HirExprKind.NullCoalesce(self.resolve_expr(left), self.resolve_expr(right))

            case ExistsCheck(base):
                HirExprKind.ExistsCheck(self.resolve_expr(base))

            case Unwrap(base):
                HirExprKind.Unwrap(self.resolve_expr(base))

            # Operators
            case Binary(op, left, right):
                HirExprKind.Binary(op, self.resolve_expr(left), self.resolve_expr(right))

            case Unary(op, operand):
                HirExprKind.Unary(op, self.resolve_expr(operand))

            # Control flow
            case If(cond, then_, else_):
                val resolved_else = if else_.?:
                    Some(self.resolve_block(else_.unwrap()))
                else:
                    nil
                HirExprKind.If(self.resolve_expr(cond), self.resolve_block(then_), resolved_else)

            case Match(scrutinee, arms):
                var resolved_arms: [HirMatchArm] = []
                for arm in arms:
                    val resolved_guard = if arm.guard.?:
                        Some(self.resolve_expr(arm.guard.unwrap()))
                    else:
                        nil
                    resolved_arms = resolved_arms.push(HirMatchArm(
                        pattern: arm.pattern,
                        guard: resolved_guard,
                        body: self.resolve_block(arm.body),
                        span: arm.span
                    ))
                HirExprKind.Match(self.resolve_expr(scrutinee), resolved_arms)

            case Loop(body, label):
                HirExprKind.Loop(self.resolve_block(body), label)

            case While(cond, body, label):
                HirExprKind.While(self.resolve_expr(cond), self.resolve_block(body), label)

            case For(var_, iter, body, label):
                HirExprKind.For(var_, self.resolve_expr(iter), self.resolve_block(body), label)

            # Closures
            case Lambda(params, body, captures):
                HirExprKind.Lambda(params, self.resolve_expr(body), captures)

            case Block(block):
                HirExprKind.Block(self.resolve_block(block))

            # Control transfer
            case Return(value):
                val resolved_value = if value.?: Some(self.resolve_expr(value.unwrap())) else: nil
                HirExprKind.Return(resolved_value)

            case Break(label, value):
                val resolved_value = if value.?: Some(self.resolve_expr(value.unwrap())) else: nil
                HirExprKind.Break(label, resolved_value)

            case Continue(label):
                HirExprKind.Continue(label)

            case Throw(value):
                HirExprKind.Throw(self.resolve_expr(value))

            case Try(e):
                HirExprKind.Try(self.resolve_expr(e))

            # Async
            case Await(e):
                HirExprKind.Await(self.resolve_expr(e))

            case Yield(value):
                val resolved_value = if value.?: Some(self.resolve_expr(value.unwrap())) else: nil
                HirExprKind.Yield(resolved_value)

            # Construction
            case StructLit(type_, fields):
                var resolved_fields: [(text, HirExpr)] = []
                for (name, value) in fields:
                    resolved_fields = resolved_fields.push((name, self.resolve_expr(value)))
                HirExprKind.StructLit(type_, resolved_fields)

            case EnumLit(type_, variant, payload):
                val resolved_payload = if payload.?:
                    match payload.unwrap():
                        case Tuple(values):
                            var resolved: [HirExpr] = []
                            for v in values:
                                resolved = resolved.push(self.resolve_expr(v))
                            Some(HirEnumPayload.Tuple(resolved))
                        case Struct(fields):
                            var resolved: [(text, HirExpr)] = []
                            for (name, value) in fields:
                                resolved = resolved.push((name, self.resolve_expr(value)))
                            Some(HirEnumPayload.Struct(resolved))
                else:
                    nil
                HirExprKind.EnumLit(type_, variant, resolved_payload)

            # Casts
            case Cast(e, target):
                HirExprKind.Cast(self.resolve_expr(e), target)

            case As(e, target):
                HirExprKind.As(self.resolve_expr(e), target)

            # Range
            case Range(start, end, inclusive, step):
                val resolved_start = if start.?: Some(self.resolve_expr(start.unwrap())) else: nil
                val resolved_end = if end.?: Some(self.resolve_expr(end.unwrap())) else: nil
                val resolved_step = if step.?: Some(self.resolve_expr(step.unwrap())) else: nil
                HirExprKind.Range(resolved_start, resolved_end, inclusive, resolved_step)

            # Comprehension
            case Comprehension(kind, e, clauses):
                var resolved_clauses: [HirCompClause] = []
                for clause in clauses:
                    resolved_clauses = resolved_clauses.push(self.resolve_comp_clause(clause))
                HirExprKind.Comprehension(kind, self.resolve_expr(e), resolved_clauses)

            # Custom blocks (pass through - no method resolution needed)
            case CustomBlock(kind, value):
                HirExprKind.CustomBlock(kind, value)

            # Math/DL blocks (resolve expressions in body)
            case LossBlock(body):
                HirExprKind.LossBlock(self.resolve_block(body))

            case NogradBlock(body):
                HirExprKind.NogradBlock(self.resolve_block(body))

            # Error
            case Error: expr.kind

        HirExpr(kind: kind, type_: expr.type_, span: expr.span)

    me resolve_call_args(args: [HirCallArg]) -> [HirCallArg]:
        """Resolve method calls in call arguments."""
        var resolved: [HirCallArg] = []
        for arg in args:
            resolved = resolved.push(HirCallArg(
                name: arg.name,
                value: self.resolve_expr(arg.value),
                span: arg.span
            ))
        resolved

    me resolve_comp_clause(clause: HirCompClause) -> HirCompClause:
        """Resolve method calls in comprehension clause."""
        val kind = match clause.kind:
            case For(var_, iter):
                HirCompClauseKind.For(var_, self.resolve_expr(iter))
            case If(cond):
                HirCompClauseKind.If(self.resolve_expr(cond))

        HirCompClause(kind: kind, span: clause.span)

    # ========================================================================
    # Method Resolution Logic (UFCS)
    # ========================================================================

    me resolve_method(receiver: HirExpr, method: text, args: [HirCallArg]) -> MethodResolution:
        """Resolve a method call using UFCS priority rules.

        Priority:
        1. Instance method on receiver's type
        2. Trait method implemented by receiver's type
        3. Free function where receiver becomes first argument
        """
        val receiver_type = receiver.type_

        # If no type information, cannot resolve
        if not receiver_type.?:
            self.add_error(
                "cannot resolve method '{method}': receiver type is unknown. " +
                "Ensure the receiver expression has a valid type.",
                receiver.span
            )
            return MethodResolution.Unresolved

        val ty = receiver_type.unwrap()
        val type_name = self.format_type(ty)

        # Priority 1: Instance method on receiver's type
        val instance_result = self.try_instance_method(ty, method)
        if instance_result.?:
            return instance_result.unwrap()

        # Priority 2: Trait method
        val trait_result = self.try_trait_method(ty, method)
        if trait_result.?:
            return trait_result.unwrap()

        # Priority 3: UFCS - Free function
        val ufcs_result = self.try_ufcs(ty, method, args)
        if ufcs_result.?:
            return ufcs_result.unwrap()

        # No resolution found - provide helpful error message
        val arg_count = args.len()
        val suggestions = self.get_method_suggestions(ty, method)

        var error_msg = "no method '{method}' found for type '{type_name}'"
        error_msg = error_msg + ". Tried: (1) instance method, (2) trait method, (3) free function '{method}({type_name}, ...)'"

        if suggestions.len() > 0:
            error_msg = error_msg + ". Did you mean: {suggestions.join(\", \")}"

        self.add_error(error_msg, receiver.span)
        MethodResolution.Unresolved

    fn format_type(ty: HirType) -> text:
        """Format a type for error messages."""
        match ty.kind:
            case Int(bits, signed):
                if signed:
                    "i{bits}"
                else:
                    "u{bits}"
            case Float(bits): "f{bits}"
            case Bool: "bool"
            case Char: "char"
            case Str: "text"
            case Unit: "()"
            case Named(sym, _):
                # Try to get symbol name
                val s = self.symbols.get(sym)
                if s.?:
                    s.unwrap().name
                else:
                    "<named type>"
            case Array(elem, _): "[{self.format_type(elem)}]"
            case Optional(inner): "{self.format_type(inner)}?"
            case Tuple(elems):
                var parts: [text] = []
                for e in elems:
                    parts = parts.push(self.format_type(e))
                "({parts.join(\", \")})"
            case _: "<unknown type>"

    me get_method_suggestions(ty: HirType, method: text) -> [text]:
        """Get suggestions for similar method names."""
        var suggestions: [text] = []

        # Get type symbol if named type
        val type_sym = self.type_checker.get_type_symbol(ty)
        if type_sym.?:
            val type_id = type_sym.unwrap()
            # Look for similar method names in the type
            val methods = self.symbols.get_methods_for_type(type_id)
            for m in methods:
                if self.is_similar(m, method):
                    suggestions = suggestions.push(m)

        # Look for similar function names
        val functions = self.symbols.get_all_functions()
        for f in functions:
            if self.is_similar(f, method):
                suggestions = suggestions.push("{f}()")

        suggestions

    fn is_similar(a: text, b: text) -> bool:
        """Check if two names are similar (for suggestions)."""
        # Simple heuristic: same prefix or suffix, or edit distance <= 2
        if not a.?:
            false
        elif not b.?:
            false
        elif a.len() < 2 or b.len() < 2:
            false
        elif a.starts_with(b[0:2]):
            true
        elif b.starts_with(a[0:2]):
            true
        elif a.ends_with(b[b.len()-2:]):
            true
        elif b.ends_with(a[a.len()-2:]):
            true
        else:
            false

    me try_instance_method(receiver_type: HirType, method: text) -> MethodResolution?:
        """Try to find an instance method on the receiver's type."""
        val type_sym = self.type_checker.get_type_symbol(receiver_type)
        if not type_sym.?:
            return None

        val type_id = type_sym.unwrap()
        val method_sym = self.symbols.lookup_method_in_type(type_id, method)

        if method_sym.?:
            Some(MethodResolution.InstanceMethod(type_id, method_sym.unwrap()))
        else:
            nil

    me try_trait_method(receiver_type: HirType, method: text) -> MethodResolution?:
        """Try to find a trait method implemented by the receiver's type."""
        val type_sym = self.type_checker.get_type_symbol(receiver_type)
        if not type_sym.?:
            return None

        val type_id = type_sym.unwrap().id

        # Get implemented traits for this type
        if not self.trait_impls[type_id].?:
            return None

        val traits = self.trait_impls[type_id]
        for trait_id in traits:
            val method_sym = self.symbols.lookup_trait_method(trait_id, method)
            if method_sym.?:
                return Some(MethodResolution.TraitMethod(trait_id, method_sym.unwrap()))

        nil

    me try_ufcs(receiver_type: HirType, method: text, args: [HirCallArg]) -> MethodResolution?:
        """Try to find a free function for UFCS resolution.

        For `x.method(a, b)` to resolve to `method(x, a, b)`:
        1. Find a function named `method`
        2. Check that its first parameter type is compatible with `x`'s type
        """
        val func_sym_id = self.symbols.lookup_function(method)
        if not func_sym_id.?:
            return None

        val func_sym = self.symbols.get(func_sym_id.unwrap())
        if not func_sym.?:
            return None

        # Check if the function's first parameter is compatible with receiver type
        val func = func_sym.unwrap()
        val func_type = func.type_
        if not func_type.?:
            return None

        match func_type.unwrap().kind:
            case Function(params, _, _):
                if params.len() == 0:
                    return None

                val first_param_type = params[0]
                if self.type_checker.is_compatible(receiver_type, first_param_type):
                    Some(MethodResolution.FreeFunction(func_sym_id.unwrap()))
                else:
                    nil
            case _:
                nil

    me is_static_method_call(receiver: HirExpr) -> bool:
        """Check if receiver is a type reference (making this a static method call).

        Static calls: Type.method() where receiver is a class/struct/enum name
        Instance calls: expr.method() where receiver is a value
        """
        match receiver.kind:
            case Var(symbol):
                # Check if this symbol is a type (Class, Struct, Enum)
                val sym = self.symbols.get(symbol)
                if sym.?:
                    match sym.unwrap().kind:
                        case Class | Struct | Enum: true
                        case _: false
                else:
                    false
            case _:
                false

    me resolve_static_method(receiver: HirExpr, method: text, args: [HirCallArg]) -> MethodResolution:
        """Resolve a static method call Type.method()"""

        # Get the type symbol from receiver (must be Var referring to a type)
        val type_sym_id = match receiver.kind:
            case Var(symbol): Some(symbol)
            case _: nil

        if not type_sym_id.?:
            self.add_error(
                "internal error: is_static_method_call returned true but receiver is not a type reference",
                receiver.span
            )
            return MethodResolution.Unresolved

        val type_id = type_sym_id.unwrap()

        # Look for static method in the type's definition
        val method_sym = self.symbols.lookup_static_method(type_id, method)

        if method_sym.?:
            MethodResolution.StaticMethod(type_id, method_sym.unwrap())
        else:
            # No static method found - provide helpful error
            val type_sym = self.symbols.get(type_id)
            val type_name = if type_sym.?: type_sym.unwrap().name else: "<unknown>"

            self.add_error(
                "no static method '{method}' found for type '{type_name}'",
                receiver.span
            )
            MethodResolution.Unresolved

    # ========================================================================
    # Error Handling
    # ========================================================================

    me add_error(message: text, span: Span):
        """Add a resolution error."""
        self.errors = self.errors.push(ResolveError(
            message: message,
            span: span
        ))

    fn has_errors() -> bool:
        """Check if there are any errors."""
        self.errors.len() > 0

    fn get_errors() -> [ResolveError]:
        """Get all errors."""
        self.errors

# ============================================================================
# Resolution Errors
# ============================================================================

struct ResolveError:
    """Error during method resolution."""
    message: text
    span: Span

impl ResolveError:
    fn to_string() -> text:
        "resolve error at {self.span}: {self.message}"

# ============================================================================
# Public API
# ============================================================================

fn resolve_methods(module: HirModule) -> (HirModule, [ResolveError]):
    """Resolve all method calls in a module.

    This is the main entry point for the resolution pass.
    Returns the resolved module and any errors encountered.
    """
    var resolver = MethodResolver.new(module.symbols)
    val resolved = resolver.resolve_module(module)
    (resolved, resolver.get_errors())
