# Extended SMF writer with template section support (v1.1)
#
# This module extends the basic SMF builder to include:
# - TemplateCode sections (serialized generic definitions)
# - TemplateMeta sections (monomorphization metadata)
# - ⭐ Trailer-based header design (like ZIP format)
# - Compression support (default: 0 = no compression)
# - Executable SMF support (stub fields)
#
# v1.1 Design: Header written at EOF-128 (trailer), not at offset 0.
# This enables directly executable SMF files (prepend shebang/stub).
#
# Enables .smf files to store both native code AND templates for deferred instantiation.

use monomorphize.partition (GenericTemplates)
use monomorphize.metadata (MonomorphizationMetadata)
use monomorphize.note_sdn (NoteSdnMetadata)
use ast (FunctionDef, StructDef, ClassDef, EnumDef, TraitDef)
use linker.smf_header (SmfHeader, SMF_FLAG_EXECUTABLE)
use linker.smf_enums (Platform, Arch)
use std.platform.{get_host_os, get_host_arch}

# Target platform information
struct Target:
    os: text        # "linux", "windows", "macos"
    arch: text      # "x86_64", "aarch64", "riscv64"

impl Target:
    static fn host() -> Target:
        # Platform detection using std.platform (Phase 2.1 - TODO #162 ✅)
        Target(os: get_host_os(), arch: get_host_arch())

    static fn x86_64_unknown_linux_gnu() -> Target:
        Target(os: "linux", arch: "x86_64")

    static fn aarch64_unknown_linux_gnu() -> Target:
        Target(os: "linux", arch: "aarch64")

# SMF build options - groups common parameters
struct SmfBuildOptions:
    templates: GenericTemplates?
    metadata: MonomorphizationMetadata?
    note_sdn: NoteSdnMetadata?
    target: Target

impl SmfBuildOptions:
    static fn create(target: Target) -> SmfBuildOptions:
        SmfBuildOptions(
            templates: nil,
            metadata: nil,
            note_sdn: nil,
            target: target
        )

    fn has_any_sections() -> bool:
        self.templates.? or self.metadata.? or self.note_sdn.?

# Generate SMF from object code with optional template sections
#
# If templates and metadata are provided, adds TemplateCode and TemplateMeta sections
# to enable deferred monomorphization.
fn generate_smf_with_templates(
    object_code: [u8],
    templates: GenericTemplates?,
    metadata: MonomorphizationMetadata?,
    target: Target
) -> [u8]:
    val options = SmfBuildOptions(
        templates: templates,
        metadata: metadata,
        note_sdn: nil,
        target: target
    )
    generate_smf_with_options(object_code, options)

# Generate SMF from object code with all optional sections
#
# Includes templates, metadata, and note.sdn for full instantiation tracking.
fn generate_smf_with_all_sections(
    object_code: [u8],
    templates: GenericTemplates?,
    metadata: MonomorphizationMetadata?,
    note_sdn: NoteSdnMetadata?,
    target: Target
) -> [u8]:
    val options = SmfBuildOptions(
        templates: templates,
        metadata: metadata,
        note_sdn: note_sdn,
        target: target
    )
    generate_smf_with_options(object_code, options)

# Generate SMF from object code with build options
fn generate_smf_with_options(object_code: [u8], options: SmfBuildOptions) -> [u8]:
    val code_bytes = extract_code_from_object(object_code)

    # If no templates, use simple builder
    if not options.has_any_sections():
        return build_smf_with_code_for_target(code_bytes, options.target)

    # Build SMF with template sections
    build_smf_with_templates_internal(code_bytes, options)

# Build an SMF module with code and optional template sections
# ⭐ v1.1: Uses TRAILER-BASED HEADER (like ZIP format)
fn build_smf_with_templates_internal(code_bytes: [u8], options: SmfBuildOptions) -> [u8]:
    var buf: [u8] = []

    # ⭐ NEW: No stub in this implementation (stub_size = 0)
    # Future: Add optional stub support for executable SMF
    val stub_size = 0
    val smf_data_offset = 0

    # 1. Write sections FIRST (before header)

    # Serialize templates if present
    val template_bytes = if options.templates.?:
        serialize_templates(options.templates.unwrap())
    else:
        []

    val metadata_bytes = if options.metadata.?:
        serialize_metadata(options.metadata.unwrap())
    else:
        []

    val note_sdn_bytes = if options.note_sdn.?:
        serialize_note_sdn(options.note_sdn.unwrap())
    else:
        []

    val has_templates = not template_bytes.is_empty()
    val has_metadata = not metadata_bytes.is_empty()
    val has_note_sdn = not note_sdn_bytes.is_empty()

    # Calculate section count
    var section_count = 1  # Code section
    if has_templates:
        section_count = section_count + 1
    if has_metadata:
        section_count = section_count + 1
    if has_note_sdn:
        section_count = section_count + 1  # note.sdn section

    # Calculate offsets (sections come FIRST now, not after header)
    val header_size = 128  # SmfHeader::SIZE (written at END)
    val section_entry_size = 64  # SmfSection size
    val code_offset = 0  # ⭐ Code starts at offset 0 (no header at start)
    val template_offset = code_offset + code_bytes.len()
    val metadata_offset = template_offset + template_bytes.len()
    val note_sdn_offset = metadata_offset + metadata_bytes.len()
    val section_table_offset = note_sdn_offset + note_sdn_bytes.len()
    val section_table_size = section_count * section_entry_size
    val symbol_table_offset = section_table_offset + section_table_size
    val string_table_offset = symbol_table_offset + 72  # One symbol
    val header_offset = string_table_offset + 5  # "main\0"

    # Write code section
    buf = buf.concat(code_bytes)

    # Write template section
    if has_templates:
        buf = buf.concat(template_bytes)

    # Write metadata section
    if has_metadata:
        buf = buf.concat(metadata_bytes)

    # Write note.sdn section
    if has_note_sdn:
        buf = buf.concat(note_sdn_bytes)

    # 2. Write section table

    # Code section
    buf = buf.concat(build_section_entry(
        section_type: 1,  # SectionType::Code
        flags: 0x05,  # READ | EXEC
        offset: code_offset,
        size: code_bytes.len(),
        name: "code"
    ))

    # Template code section
    if has_templates:
        buf = buf.concat(build_section_entry(
            section_type: 12,  # SectionType::TemplateCode
            flags: 0x01,  # READ
            offset: template_offset,
            size: template_bytes.len(),
            name: "template_code"
        ))

    # Template metadata section
    if has_metadata:
        buf = buf.concat(build_section_entry(
            section_type: 13,  # SectionType::TemplateMeta
            flags: 0x01,  # READ
            offset: metadata_offset,
            size: metadata_bytes.len(),
            name: "template_meta"
        ))

    # note.sdn section (zero-size trick: size=0 in section table)
    if has_note_sdn:
        buf = buf.concat(build_section_entry(
            section_type: 13,  # SectionType::TemplateMeta (reuse)
            flags: 0x01,  # READ
            offset: note_sdn_offset,
            size: 0,  # ⭐ Zero-size trick: actual size determined by scanning for terminator
            name: "note.sdn"
        ))

    # 3. Write symbol table
    buf = buf.concat(build_symbol_entry("main", 0, code_bytes.len()))

    # 4. Write string table
    buf = buf.concat("main\0".to_bytes())

    # 5. Write HEADER at END (TRAILER) ⭐ v1.1 design
    # This enables executable SMF files (prepend shebang/stub)

    # Create header using SmfHeader struct
    val platform = text_to_platform(options.target.os)
    val arch = text_to_arch(options.target.arch)
    var header = SmfHeader.new_v1_1(platform, arch)

    # Set flags
    header.set_executable(true)

    # Set counts and offsets
    header.section_count = section_count
    header.section_table_offset = section_table_offset
    header.symbol_table_offset = symbol_table_offset
    header.symbol_count = 1
    header.exported_count = 1
    header.entry_point = 0

    # Set stub info (no stub for now)
    header.set_stub_info(stub_size, smf_data_offset)

    # Serialize and append header
    buf = buf.concat(header.to_bytes())

    buf

# Build a section table entry
fn build_section_entry(
    section_type: i32,
    flags: i32,
    offset: i32,
    size: i32,
    name: text
) -> [u8]:
    var buf: [u8] = []

    # Section type (u8)
    buf = buf.push(section_type.to_u8())

    # Padding (3 bytes)
    buf = buf.concat([0, 0, 0])

    # Flags (u32)
    buf = buf.concat(u32_to_bytes(flags))

    # Offset (u64)
    buf = buf.concat(u64_to_bytes(offset))

    # Size (u64)
    buf = buf.concat(u64_to_bytes(size))

    # Virtual size (u64)
    buf = buf.concat(u64_to_bytes(size))

    # Alignment (u32)
    buf = buf.concat(u32_to_bytes(16))

    # Name (16 bytes)
    var name_bytes = name.to_bytes()
    if name_bytes.len() > 16:
        name_bytes = name_bytes[0:16]
    buf = buf.concat(name_bytes)
    while buf.len() % 64 != 0:
        buf = buf.push(0)

    buf

# Build a symbol table entry
fn build_symbol_entry(name: text, value: i32, size: i32) -> [u8]:
    var buf: [u8] = []

    # Name offset (u32)
    buf = buf.concat(u32_to_bytes(0))

    # Name hash (u64)
    buf = buf.concat(u64_to_bytes(hash_name(name)))

    # Symbol type (u8) - Function
    buf = buf.push(1)

    # Binding (u8) - Global
    buf = buf.push(1)

    # Visibility (u8)
    buf = buf.push(0)

    # Flags (u8)
    buf = buf.push(0)

    # Value (u64)
    buf = buf.concat(u64_to_bytes(value))

    # Size (u64)
    buf = buf.concat(u64_to_bytes(size))

    # Type ID (u32)
    buf = buf.concat(u32_to_bytes(0))

    # Version (u32)
    buf = buf.concat(u32_to_bytes(0))

    # Template param count (u8)
    buf = buf.push(0)

    # Reserved (3 bytes)
    buf = buf.concat([0, 0, 0])

    # Template offset (u64)
    buf = buf.concat(u64_to_bytes(0))

    buf

# Serialize generic templates to bytes
#
# Binary format:
# - Header: magic (u32), version (u16), template_count (u32)
# - For each template: kind (u8), serialized AST node
fn serialize_templates(templates: GenericTemplates) -> [u8]:
    var buf: [u8] = []

    # Header
    buf = buf.concat([0x47, 0x54, 0x50, 0x4C])  # "GTPL" magic
    buf = buf.concat([0x01, 0x00])  # version 1

    val total_count = (templates.functions.len() +
        templates.structs.len() +
        templates.classes.len() +
        templates.enums.len() +
        templates.traits.len())

    buf = buf.concat(u32_to_bytes(total_count))

    # Full AST serialization (Phase 6)
    # Writes complete AST nodes including body, params, fields, variants, methods, and bindings.

    # Functions
    for func in templates.functions:
        buf = buf.push(0)  # kind = Function
        buf = buf.concat(serialize_function_placeholder(func))

    # Structs
    for struct_def in templates.structs:
        buf = buf.push(1)  # kind = Struct
        buf = buf.concat(serialize_struct_placeholder(struct_def))

    # Classes
    for class_def in templates.classes:
        buf = buf.push(2)  # kind = Class
        buf = buf.concat(serialize_class_placeholder(class_def))

    # Enums
    for enum_def in templates.enums:
        buf = buf.push(3)  # kind = Enum
        buf = buf.concat(serialize_enum_placeholder(enum_def))

    # Traits
    for trait_def in templates.traits:
        buf = buf.push(4)  # kind = Trait
        buf = buf.concat(serialize_trait_placeholder(trait_def))

    buf

# Serialize monomorphization metadata to bytes
fn serialize_metadata(metadata: MonomorphizationMetadata) -> [u8]:
    var buf: [u8] = []

    # Header
    buf = buf.concat([0x4D, 0x45, 0x54, 0x41])  # "META" magic
    buf = buf.concat([0x01, 0x00])  # version 1

    # Count of each category
    buf = buf.concat(u32_to_bytes(metadata.functions.len()))
    buf = buf.concat(u32_to_bytes(metadata.structs.len()))
    buf = buf.concat(u32_to_bytes(metadata.enums.len()))
    buf = buf.concat(u32_to_bytes(metadata.traits.len()))

    # Metadata serialization (Phase 6)
    # Writes category counts and per-entry data (name, specialization count).

    # Serialize function metadata entries
    for (name, func_meta) in metadata.functions.items():
        val name_bytes = name.to_bytes()
        buf = buf.concat(u32_to_bytes(name_bytes.len()))
        buf = buf.concat(name_bytes)
        buf = buf.concat(u32_to_bytes(func_meta.specializations.len()))

    # Serialize struct metadata entries
    for (name, struct_meta) in metadata.structs.items():
        val name_bytes = name.to_bytes()
        buf = buf.concat(u32_to_bytes(name_bytes.len()))
        buf = buf.concat(name_bytes)
        buf = buf.concat(u32_to_bytes(struct_meta.specializations.len()))

    # Serialize enum metadata entries
    for (name, enum_meta) in metadata.enums.items():
        val name_bytes = name.to_bytes()
        buf = buf.concat(u32_to_bytes(name_bytes.len()))
        buf = buf.concat(name_bytes)
        buf = buf.concat(u32_to_bytes(enum_meta.specializations.len()))

    # Serialize trait metadata entries
    for (name, trait_meta) in metadata.traits.items():
        val name_bytes = name.to_bytes()
        buf = buf.concat(u32_to_bytes(name_bytes.len()))
        buf = buf.concat(name_bytes)
        buf = buf.concat(u32_to_bytes(trait_meta.impl_specializations.len()))

    buf

# Serialize note.sdn metadata to SDN format with terminator
#
# The terminator `\n# END_NOTE\n` allows dynamic size calculation at load time.
fn serialize_note_sdn(note_sdn: NoteSdnMetadata) -> [u8]:
    val sdn_content = note_sdn.to_sdn()
    sdn_content.to_bytes()

# Full AST serialization functions (Phase 6)

fn serialize_text_field(buf: [u8], value: text) -> [u8]:
    """Serialize a text field as length-prefixed bytes."""
    var out = buf
    val bytes = value.to_bytes()
    out = out.concat(u32_to_bytes(bytes.len()))
    out = out.concat(bytes)
    out

fn serialize_optional_text_field(buf: [u8], value: text?) -> [u8]:
    """Serialize an optional text field (0x01 + data or 0x00 for nil)."""
    var out = buf
    if value.?:
        out = out.push(0x01)
        out = serialize_text_field(out, value.unwrap())
    else:
        out = out.push(0x00)
    out

fn serialize_text_list(buf: [u8], items: [text]) -> [u8]:
    """Serialize a list of text items as count + length-prefixed strings."""
    var out = buf
    out = out.concat(u32_to_bytes(items.len()))
    for item in items:
        out = serialize_text_field(out, item)
    out

fn serialize_text_dict(buf: [u8], dict: {text: text}) -> [u8]:
    """Serialize a text-to-text dictionary as count + key-value pairs."""
    var out = buf
    out = out.concat(u32_to_bytes(dict.len()))
    for (key, value) in dict.items():
        out = serialize_text_field(out, key)
        out = serialize_text_field(out, value)
    out

fn serialize_function_placeholder(func: FunctionDef) -> [u8]:
    """Serialize a full FunctionDef including body, params, return type, and bindings."""
    var buf: [u8] = []

    # Name
    buf = serialize_text_field(buf, func.name)

    # Generic params
    buf = buf.push(func.generic_params.len().to_u8())
    for param in func.generic_params:
        buf = serialize_text_field(buf, param)

    # Params (list of text)
    buf = serialize_text_list(buf, func.params)

    # Return type (optional text)
    buf = serialize_optional_text_field(buf, func.return_type)

    # Body (list of text - serialized AST statements)
    buf = serialize_text_list(buf, func.body)

    # Flags
    buf = buf.push(if func.is_generic_template: 0x01 else: 0x00)

    # Specialization of (optional text)
    buf = serialize_optional_text_field(buf, func.specialization_of)

    # Type bindings
    buf = serialize_text_dict(buf, func.type_bindings)

    buf

fn serialize_struct_placeholder(struct_def: StructDef) -> [u8]:
    """Serialize a full StructDef including fields and bindings."""
    var buf: [u8] = []

    # Name
    buf = serialize_text_field(buf, struct_def.name)

    # Generic params
    buf = buf.push(struct_def.generic_params.len().to_u8())
    for param in struct_def.generic_params:
        buf = serialize_text_field(buf, param)

    # Fields (list of text)
    buf = serialize_text_list(buf, struct_def.fields)

    # Flags
    buf = buf.push(if struct_def.is_generic_template: 0x01 else: 0x00)

    # Specialization of (optional text)
    buf = serialize_optional_text_field(buf, struct_def.specialization_of)

    # Type bindings
    buf = serialize_text_dict(buf, struct_def.type_bindings)

    buf

fn serialize_class_placeholder(class_def: ClassDef) -> [u8]:
    """Serialize a full ClassDef including fields, methods, and bindings."""
    var buf: [u8] = []

    # Name
    buf = serialize_text_field(buf, class_def.name)

    # Generic params
    buf = buf.push(class_def.generic_params.len().to_u8())
    for param in class_def.generic_params:
        buf = serialize_text_field(buf, param)

    # Fields (list of text)
    buf = serialize_text_list(buf, class_def.fields)

    # Methods (list of text)
    buf = serialize_text_list(buf, class_def.methods)

    # Flags
    buf = buf.push(if class_def.is_generic_template: 0x01 else: 0x00)

    # Specialization of (optional text)
    buf = serialize_optional_text_field(buf, class_def.specialization_of)

    # Type bindings
    buf = serialize_text_dict(buf, class_def.type_bindings)

    buf

fn serialize_enum_placeholder(enum_def: EnumDef) -> [u8]:
    """Serialize a full EnumDef including variants and bindings."""
    var buf: [u8] = []

    # Name
    buf = serialize_text_field(buf, enum_def.name)

    # Generic params
    buf = buf.push(enum_def.generic_params.len().to_u8())
    for param in enum_def.generic_params:
        buf = serialize_text_field(buf, param)

    # Variants (list of text)
    buf = serialize_text_list(buf, enum_def.variants)

    # Flags
    buf = buf.push(if enum_def.is_generic_template: 0x01 else: 0x00)

    # Specialization of (optional text)
    buf = serialize_optional_text_field(buf, enum_def.specialization_of)

    # Type bindings
    buf = serialize_text_dict(buf, enum_def.type_bindings)

    buf

fn serialize_trait_placeholder(trait_def: TraitDef) -> [u8]:
    """Serialize a full TraitDef including methods."""
    var buf: [u8] = []

    # Name
    buf = serialize_text_field(buf, trait_def.name)

    # Generic params
    buf = buf.push(trait_def.generic_params.len().to_u8())
    for param in trait_def.generic_params:
        buf = serialize_text_field(buf, param)

    # Methods (list of text)
    buf = serialize_text_list(buf, trait_def.methods)

    # Flags
    buf = buf.push(if trait_def.is_generic_template: 0x01 else: 0x00)

    buf

# Build an SMF module with the given code bytes for a specific target architecture
fn build_smf_with_code_for_target(code_bytes: [u8], target: Target) -> [u8]:
    # Delegate to simple SMF builder
    val options = SmfBuildOptions(templates: nil, metadata: nil, note_sdn: nil, target: target)
    build_smf_with_templates_internal(code_bytes, options)

# Helper to convert code bytes to a minimal object format
fn code_bytes_to_object(code: [u8]) -> [u8]:
    # For now, just return the code as-is
    code

# Extract code section (.text) from ELF object file.
# Parses the ELF64 header, finds .text section via section header string table,
# and returns just the code bytes. Falls back to returning raw bytes if not ELF.
fn extract_code_from_object(object_code: [u8]) -> [u8]:
    # Check ELF magic: 0x7f 'E' 'L' 'F'
    if object_code.len() < 64:
        return object_code  # Too small for ELF, treat as raw
    val magic_ok_0 = object_code[0] == 0x7F
    val magic_ok_1 = object_code[1] == 0x45  # 'E'
    val magic_ok_2 = object_code[2] == 0x4C  # 'L'
    val magic_ok_3 = object_code[3] == 0x46  # 'F'
    if not (magic_ok_0 and magic_ok_1 and magic_ok_2 and magic_ok_3):
        return object_code  # Not ELF, return as raw code bytes

    # Check 64-bit (class 2)
    val elf_class = object_code[4]
    if elf_class != 2:
        return object_code  # Not ELF64, return as raw

    # Parse ELF64 header fields (little-endian assumed)
    # e_shoff: offset 40, 8 bytes - section header table offset
    val e_shoff = _read_u64_le(object_code, 40)
    # e_shentsize: offset 58, 2 bytes - section header entry size
    val e_shentsize = _read_u16_le(object_code, 58)
    # e_shnum: offset 60, 2 bytes - number of section headers
    val e_shnum = _read_u16_le(object_code, 60)
    # e_shstrndx: offset 62, 2 bytes - section name string table index
    val e_shstrndx = _read_u16_le(object_code, 62)

    if e_shoff == 0 or e_shnum == 0 or e_shentsize < 64:
        return object_code  # No section headers

    # Read section name string table section header
    val shstrtab_off = e_shoff + (e_shstrndx * e_shentsize)
    if shstrtab_off + 64 > object_code.len():
        return object_code
    val strtab_offset = _read_u64_le(object_code, shstrtab_off + 24)
    val strtab_size = _read_u64_le(object_code, shstrtab_off + 32)

    # Search for .text section
    var i = 0
    while i < e_shnum:
        val sh_off = e_shoff + (i * e_shentsize)
        if sh_off + 64 > object_code.len():
            i = i + 1
            continue

        # sh_name: index into string table
        val sh_name_idx = _read_u32_le(object_code, sh_off)
        # sh_type at offset 4 (4 bytes)
        val sh_type = _read_u32_le(object_code, sh_off + 4)
        # sh_offset at offset 24 (8 bytes)
        val sec_offset = _read_u64_le(object_code, sh_off + 24)
        # sh_size at offset 32 (8 bytes)
        val sec_size = _read_u64_le(object_code, sh_off + 32)

        # Check if section name is ".text" (SHT_PROGBITS = 1)
        if sh_type == 1:
            val name_off = strtab_offset + sh_name_idx
            if name_off + 5 <= object_code.len():
                val n0 = object_code[name_off]
                val n1 = object_code[name_off + 1]
                val n2 = object_code[name_off + 2]
                val n3 = object_code[name_off + 3]
                val n4 = object_code[name_off + 4]
                # ".text" = 0x2E 0x74 0x65 0x78 0x74
                val is_text_0 = n0 == 0x2E
                val is_text_1 = n1 == 0x74
                val is_text_2 = n2 == 0x65
                val is_text_3 = n3 == 0x78
                val is_text_4 = n4 == 0x74
                if is_text_0 and is_text_1 and is_text_2 and is_text_3 and is_text_4:
                    # Found .text section - extract bytes
                    val end_off = sec_offset + sec_size
                    if end_off <= object_code.len():
                        var code: [u8] = []
                        var j = sec_offset
                        while j < end_off:
                            code.push(object_code[j])
                            j = j + 1
                        return code
        i = i + 1

    # No .text section found, return raw bytes
    object_code

fn _read_u16_le(data: [u8], offset: i64) -> i64:
    val b0 = data[offset] as i64
    val b1 = data[offset + 1] as i64
    b0 | (b1 << 8)

fn _read_u32_le(data: [u8], offset: i64) -> i64:
    val b0 = data[offset] as i64
    val b1 = data[offset + 1] as i64
    val b2 = data[offset + 2] as i64
    val b3 = data[offset + 3] as i64
    b0 | (b1 << 8) | (b2 << 16) | (b3 << 24)

fn _read_u64_le(data: [u8], offset: i64) -> i64:
    val b0 = data[offset] as i64
    val b1 = data[offset + 1] as i64
    val b2 = data[offset + 2] as i64
    val b3 = data[offset + 3] as i64
    val b4 = data[offset + 4] as i64
    val b5 = data[offset + 5] as i64
    val b6 = data[offset + 6] as i64
    val b7 = data[offset + 7] as i64
    b0 | (b1 << 8) | (b2 << 16) | (b3 << 24) | (b4 << 32) | (b5 << 40) | (b6 << 48) | (b7 << 56)

# Binary format helpers

fn u32_to_bytes(value: i32) -> [u8]:
    [
        (value & 0xFF).to_u8(),
        ((value >> 8) & 0xFF).to_u8(),
        ((value >> 16) & 0xFF).to_u8(),
        ((value >> 24) & 0xFF).to_u8()
    ]

fn u64_to_bytes(value: i64) -> [u8]:
    [
        (value & 0xFF).to_u8(),
        ((value >> 8) & 0xFF).to_u8(),
        ((value >> 16) & 0xFF).to_u8(),
        ((value >> 24) & 0xFF).to_u8(),
        ((value >> 32) & 0xFF).to_u8(),
        ((value >> 40) & 0xFF).to_u8(),
        ((value >> 48) & 0xFF).to_u8(),
        ((value >> 56) & 0xFF).to_u8()
    ]

fn text_to_platform(os: text) -> Platform:
    match os:
        "linux": Platform.Linux
        "windows": Platform.Windows
        "macos": Platform.MacOS
        "freebsd": Platform.FreeBSD
        "none": Platform.None_
        _: Platform.Any

fn text_to_arch(arch: text) -> Arch:
    match arch:
        "x86_64": Arch.X86_64
        "aarch64": Arch.Aarch64
        "x86": Arch.X86
        "arm": Arch.Arm
        "riscv64": Arch.Riscv64
        "riscv32": Arch.Riscv32
        "wasm32": Arch.Wasm32
        "wasm64": Arch.Wasm64
        _: Arch.X86_64

fn hash_name(name: text) -> i32:
    # Simple FNV-1a hash
    var hash = 2166136261
    for byte in name.to_bytes():
        hash = hash xor byte.to_i32()
        hash = hash * 16777619
    hash

export generate_smf_with_templates, generate_smf_with_all_sections, generate_smf_with_options
export Target, SmfBuildOptions
export build_smf_with_code_for_target, extract_code_from_object
