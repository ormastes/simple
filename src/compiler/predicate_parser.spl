# Predicate Parser
#
# Parses pc{...} predicate syntax into unified Predicate AST.
# Supports: !, &, |, (), and various selector functions.
#
# Port of rust/compiler/src/predicate_parser.rs (484 lines)

export parse_predicate, parse_signature_pattern

use predicate.*

# ============================================================================
# Tokens
# ============================================================================

enum Token:
    Not
    And
    Or
    LParen
    RParen
    Comma
    Sel(text, [text])    # name, args

# ============================================================================
# Tokenizer
# ============================================================================

fn tokenize(input: text) -> Result<[Token], text>:
    var tokens: [Token] = []
    var i = 0
    val chars = input.chars()
    val len = chars.len()

    while i < len:
        val c = chars[i]
        if c == " " or c == "\t" or c == "\n":
            i = i + 1
        elif c == "!":
            tokens = tokens.push(Token.Not)
            i = i + 1
        elif c == "&":
            tokens = tokens.push(Token.And)
            i = i + 1
        elif c == "|":
            tokens = tokens.push(Token.Or)
            i = i + 1
        elif c == "(":
            tokens = tokens.push(Token.LParen)
            i = i + 1
        elif c == ")":
            tokens = tokens.push(Token.RParen)
            i = i + 1
        elif c == ",":
            tokens = tokens.push(Token.Comma)
            i = i + 1
        elif c.is_alpha() or c == "_":
            # Parse selector name
            var name_chars: [text] = []
            while i < len and (chars[i].is_alnum() or chars[i] == "_"):
                name_chars = name_chars.push(chars[i])
                i = i + 1
            val name = name_chars.join("")

            # Skip whitespace
            while i < len and chars[i] == " ":
                i = i + 1

            # Expect '('
            if i >= len or chars[i] != "(":
                return Err("expected '(' after selector '{name}'")
            i = i + 1

            # Parse args
            var args: [text] = []
            var arg_chars: [text] = []
            var depth = 0
            while i < len:
                if chars[i] == ")" and depth == 0:
                    val current = arg_chars.join("")
                    if current.trim().?:
                        args = args.push(current.trim())
                    i = i + 1
                    break
                elif chars[i] == "(":
                    depth = depth + 1
                    arg_chars = arg_chars.push("(")
                    i = i + 1
                elif chars[i] == ")":
                    depth = depth - 1
                    arg_chars = arg_chars.push(")")
                    i = i + 1
                elif chars[i] == "," and depth == 0:
                    val current = arg_chars.join("")
                    if current.trim().?:
                        args = args.push(current.trim())
                    arg_chars = []
                    i = i + 1
                else:
                    arg_chars = arg_chars.push(chars[i])
                    i = i + 1

            tokens = tokens.push(Token.Sel(name, args))
        else:
            return Err("unexpected character '{c}' in predicate")

    Ok(tokens)

# ============================================================================
# Parser (recursive descent)
# ============================================================================

fn parse_predicate(input: text) -> Result<Predicate, text>:
    """Parse a predicate expression from string."""
    val trimmed = input.trim()
    val inner = if trimmed.starts_with("pc{") and trimmed.ends_with("}"):
        trimmed[3:trimmed.len() - 1].trim()
    else:
        trimmed

    val tokens = tokenize(inner)?
    var pos = 0
    val result = parse_or(tokens, pos)
    match result:
        case Ok((pred, new_pos)):
            if new_pos < tokens.len():
                Err("unexpected trailing tokens in predicate")
            else:
                Ok(pred)
        case Err(e): Err(e)

fn parse_or(tokens: [Token], pos: i64) -> Result<(Predicate, i64), text>:
    var result = parse_and(tokens, pos)?
    var (expr, p) = result
    while p < tokens.len():
        match tokens[p]:
            case Or:
                val rhs = parse_and(tokens, p + 1)?
                expr = Predicate.Or(expr, rhs.0)
                p = rhs.1
            case _: break
    Ok((expr, p))

fn parse_and(tokens: [Token], pos: i64) -> Result<(Predicate, i64), text>:
    var result = parse_not(tokens, pos)?
    var (expr, p) = result
    while p < tokens.len():
        match tokens[p]:
            case And:
                val rhs = parse_not(tokens, p + 1)?
                expr = Predicate.And(expr, rhs.0)
                p = rhs.1
            case _: break
    Ok((expr, p))

fn parse_not(tokens: [Token], pos: i64) -> Result<(Predicate, i64), text>:
    if pos < tokens.len():
        match tokens[pos]:
            case Not:
                val inner = parse_not(tokens, pos + 1)?
                return Ok((Predicate.Not(inner.0), inner.1))
            case _: ()
    parse_primary(tokens, pos)

fn parse_primary(tokens: [Token], pos: i64) -> Result<(Predicate, i64), text>:
    if pos >= tokens.len():
        return Err("unexpected end of predicate expression")

    match tokens[pos]:
        case LParen:
            val inner = parse_or(tokens, pos + 1)?
            if inner.1 >= tokens.len():
                return Err("unclosed parenthesis in predicate")
            match tokens[inner.1]:
                case RParen: Ok((inner.0, inner.1 + 1))
                case _: Err("expected ')' in predicate")
        case Sel(name, args):
            val sel = make_selector(name, args)?
            Ok((Predicate.Sel(sel), pos + 1))
        case _:
            Err("unexpected token in predicate expression")

fn make_selector(name: text, args: [text]) -> Result<Selector, text>:
    """Convert a selector name and arguments into a Selector."""
    match name:
        case "execution":
            if args.len() < 1: Err("execution() requires an argument")
            else: Ok(Selector.Execution(parse_signature_pattern(args[0])))
        case "within":
            if args.len() < 1: Err("within() requires an argument")
            else: Ok(Selector.Within(args[0]))
        case "attr":
            if args.len() < 1: Err("attr() requires an argument")
            else: Ok(Selector.Attr(args[0]))
        case "effect":
            if args.len() < 1: Err("effect() requires an argument")
            else: Ok(Selector.Effect(args[0]))
        case "test":
            if args.len() < 1: Err("test() requires an argument")
            else: Ok(Selector.Test(args[0]))
        case "decision": Ok(Selector.Decision)
        case "condition": Ok(Selector.Condition)
        case "call":
            if args.len() < 1: Err("call() requires an argument")
            else: Ok(Selector.Call(parse_signature_pattern(args[0])))
        case "type":
            if args.len() < 1: Err("type() requires an argument")
            else: Ok(Selector.Type(args[0]))
        case "init":
            if args.len() < 1: Err("init() requires an argument")
            else: Ok(Selector.Init(args[0]))
        case "import":
            if args.len() < 2: Err("import() requires two arguments")
            else: Ok(Selector.Import(args[0], args[1]))
        case "depend":
            if args.len() < 2: Err("depend() requires two arguments")
            else: Ok(Selector.Depend(args[0], args[1]))
        case "use":
            if args.len() < 1: Err("use() requires an argument")
            else: Ok(Selector.Use(args[0]))
        case "export":
            if args.len() < 1: Err("export() requires an argument")
            else: Ok(Selector.Export(args[0]))
        case "config":
            if args.len() < 1: Err("config() requires an argument")
            else: Ok(Selector.Config(args[0]))
        case _: Err("unknown selector '{name}'")

fn parse_signature_pattern(input: text) -> SignaturePattern:
    """Parse a signature pattern like '* User.new(..)' or 'i64 *.calc(i64, i64)'."""
    val parts = input.trim().split(" ")
    if parts.len() < 2:
        return SignaturePattern(return_type: "*", qualified_name: input.trim(),
                                args: ArgPatterns.Any)

    val return_type = parts[0]
    val rest = parts[1:].join(" ")

    # Split name and args
    val paren_idx = rest.index_of("(")
    if not paren_idx.?:
        return SignaturePattern(return_type: return_type, qualified_name: rest,
                                args: ArgPatterns.Any)

    val qualified_name = rest[:paren_idx.unwrap()]
    val args_str = rest[paren_idx.unwrap() + 1:]
    val args_str = if args_str.ends_with(")"): args_str[:args_str.len() - 1] else: args_str

    val args = if args_str.trim() == "..":
        ArgPatterns.Any
    else:
        ArgPatterns.Specific(args_str.split(",").map(\a: a.trim()))

    SignaturePattern(return_type: return_type, qualified_name: qualified_name, args: args)
