# SHB Writer — Serialize ShbModuleInterface → .shb binary file
#
# Layout: [Header 64B] [SectionTable 64B] [Sections...] [StringTable]
# All integers little-endian.

use std.binary_io.{BinaryWriter, ByteOrder}

use compiler.shb.shb_types.{
    ShbModuleInterface, ShbHeader, ShbSectionTable, ShbFnEntry, ShbStructEntry,
    ShbClassEntry, ShbEnumEntry, ShbTraitEntry, ShbReexportEntry,
    ShbTypeLayoutEntry, ShbDependencyEntry, ShbParam, ShbFieldEntry,
    ShbMethodRef,
    SHB_HEADER_SIZE, SHB_SECTION_TABLE_SIZE, SHB_SECTION_COUNT,
    SHB_SECTION_FUNCTIONS, SHB_SECTION_STRUCTS, SHB_SECTION_CLASSES,
    SHB_SECTION_TYPE_LAYOUTS, SHB_SECTION_ENUMS, SHB_SECTION_TRAITS,
    SHB_SECTION_REEXPORTS, SHB_SECTION_DEPENDENCIES,
    SHB_MAGIC_0, SHB_MAGIC_1, SHB_MAGIC_2, SHB_MAGIC_3
}
use compiler.shb.shb_string_table.{ShbStringTable}

val LE = ByteOrder.LittleEndian

# --- Main write function ---

fn shb_write(iface: ShbModuleInterface, path: text) -> bool:
    var strtab = ShbStringTable.create()
    var sections = BinaryWriter.new()

    # Pre-register all strings
    shb_register_strings(iface, strtab)

    # Build section data and record offsets
    var section_offsets: [i64] = [0, 0, 0, 0, 0, 0, 0, 0]
    val data_base = SHB_HEADER_SIZE + SHB_SECTION_TABLE_SIZE

    # Functions
    section_offsets[SHB_SECTION_FUNCTIONS] = data_base + sections.len()
    shb_write_functions(iface.functions, strtab, sections)

    # Structs
    section_offsets[SHB_SECTION_STRUCTS] = data_base + sections.len()
    shb_write_structs(iface.structs, strtab, sections)

    # Classes
    section_offsets[SHB_SECTION_CLASSES] = data_base + sections.len()
    shb_write_classes(iface.classes, strtab, sections)

    # Type layouts
    section_offsets[SHB_SECTION_TYPE_LAYOUTS] = data_base + sections.len()
    shb_write_type_layouts(iface.type_layouts, strtab, sections)

    # Enums
    section_offsets[SHB_SECTION_ENUMS] = data_base + sections.len()
    shb_write_enums(iface.enums, strtab, sections)

    # Traits
    section_offsets[SHB_SECTION_TRAITS] = data_base + sections.len()
    shb_write_traits(iface.traits, strtab, sections)

    # Reexports
    section_offsets[SHB_SECTION_REEXPORTS] = data_base + sections.len()
    shb_write_reexports(iface.reexports, strtab, sections)

    # Dependencies
    section_offsets[SHB_SECTION_DEPENDENCIES] = data_base + sections.len()
    shb_write_dependencies(iface.dependencies, strtab, sections)

    # String table offset
    val strtab_offset = data_base + sections.len()
    val strtab_size = strtab.size()

    # Module name offset
    val mod_name_off = strtab.get_offset("")

    # Build final binary
    var out = BinaryWriter.new()

    # --- Header (64 bytes) ---
    out.write_u8(SHB_MAGIC_0)
    out.write_u8(SHB_MAGIC_1)
    out.write_u8(SHB_MAGIC_2)
    out.write_u8(SHB_MAGIC_3)
    out.write_u8(iface.header.version_major)
    out.write_u8(iface.header.version_minor)
    out.write_u8(iface.header.platform)
    out.write_u8(iface.header.arch)
    out.write_i64(iface.header.source_hash, LE)         # 8..16
    out.write_i64(iface.header.interface_hash, LE)       # 16..24
    out.write_i64(iface.header.write_timestamp, LE)      # 24..32
    out.write_u32(SHB_SECTION_COUNT, LE)                 # 32..36
    out.write_u32(strtab_offset, LE)                     # 36..40
    out.write_u32(strtab_size, LE)                       # 40..44
    out.write_u32(iface.header.flags, LE)                # 44..48
    out.write_i64(mod_name_off, LE)                      # 48..56
    # Reserved 8 bytes
    out.write_i64(0, LE)                                 # 56..64

    # --- Section offset table (64 bytes = 8 x 8) ---
    var si = 0
    while si < SHB_SECTION_COUNT:
        out.write_i64(section_offsets[si], LE)
        si = si + 1

    # --- Section data ---
    out.write_bytes(sections.to_bytes())

    # --- String table ---
    strtab.write_to(out)

    # --- Atomic write: temp + rename ---
    val tmp_path = path + ".tmp"
    rt_file_write_bytes(tmp_path, out.to_bytes())
    rt_file_move(tmp_path, path)
    true

# --- String registration (first pass) ---

fn shb_register_strings(iface: ShbModuleInterface, strtab: ShbStringTable):
    # Functions
    var fi = 0
    while fi < iface.functions.len():
        val f = iface.functions[fi]
        strtab.add(f.name)
        strtab.add(f.return_type)
        var pi = 0
        while pi < f.params.len():
            strtab.add(f.params[pi].name)
            strtab.add(f.params[pi].type_name)
            pi = pi + 1
        fi = fi + 1

    # Structs
    var si = 0
    while si < iface.structs.len():
        val s = iface.structs[si]
        strtab.add(s.name)
        var fli = 0
        while fli < s.fields.len():
            strtab.add(s.fields[fli].name)
            strtab.add(s.fields[fli].type_name)
            fli = fli + 1
        si = si + 1

    # Classes
    var ci = 0
    while ci < iface.classes.len():
        val c = iface.classes[ci]
        strtab.add(c.name)
        var fli = 0
        while fli < c.fields.len():
            strtab.add(c.fields[fli].name)
            strtab.add(c.fields[fli].type_name)
            fli = fli + 1
        var mi = 0
        while mi < c.methods.len():
            strtab.add(c.methods[mi].name)
            mi = mi + 1
        ci = ci + 1

    # Enums
    var ei = 0
    while ei < iface.enums.len():
        val e = iface.enums[ei]
        strtab.add(e.name)
        var vi = 0
        while vi < e.variants.len():
            strtab.add(e.variants[vi])
            vi = vi + 1
        ei = ei + 1

    # Traits
    var ti = 0
    while ti < iface.traits.len():
        val t = iface.traits[ti]
        strtab.add(t.name)
        var mi = 0
        while mi < t.methods.len():
            strtab.add(t.methods[mi])
            mi = mi + 1
        ti = ti + 1

    # Reexports
    var ri = 0
    while ri < iface.reexports.len():
        strtab.add(iface.reexports[ri].symbol_name)
        strtab.add(iface.reexports[ri].source_module)
        ri = ri + 1

    # Type layouts
    var tli = 0
    while tli < iface.type_layouts.len():
        strtab.add(iface.type_layouts[tli].type_name)
        tli = tli + 1

    # Dependencies
    var di = 0
    while di < iface.dependencies.len():
        strtab.add(iface.dependencies[di].module_path)
        di = di + 1

# --- Section writers ---

fn shb_write_functions(fns: [ShbFnEntry], strtab: ShbStringTable, w: BinaryWriter):
    w.write_u32(fns.len(), LE)
    var i = 0
    while i < fns.len():
        val f = fns[i]
        w.write_u32(strtab.get_offset(f.name), LE)
        w.write_u16(f.params.len(), LE)
        w.write_u32(strtab.get_offset(f.return_type), LE)
        w.write_u16(f.flags, LE)
        # Params
        var pi = 0
        while pi < f.params.len():
            w.write_u32(strtab.get_offset(f.params[pi].name), LE)
            w.write_u32(strtab.get_offset(f.params[pi].type_name), LE)
            pi = pi + 1
        i = i + 1

fn shb_write_structs(structs: [ShbStructEntry], strtab: ShbStringTable, w: BinaryWriter):
    w.write_u32(structs.len(), LE)
    var i = 0
    while i < structs.len():
        val s = structs[i]
        w.write_u32(strtab.get_offset(s.name), LE)
        w.write_u16(s.fields.len(), LE)
        w.write_u16(s.flags, LE)
        var fi = 0
        while fi < s.fields.len():
            w.write_u32(strtab.get_offset(s.fields[fi].name), LE)
            w.write_u32(strtab.get_offset(s.fields[fi].type_name), LE)
            w.write_u32(s.fields[fi].flags, LE)
            fi = fi + 1
        i = i + 1

fn shb_write_classes(classes: [ShbClassEntry], strtab: ShbStringTable, w: BinaryWriter):
    w.write_u32(classes.len(), LE)
    var i = 0
    while i < classes.len():
        val c = classes[i]
        w.write_u32(strtab.get_offset(c.name), LE)
        w.write_u16(c.fields.len(), LE)
        w.write_u16(c.flags, LE)
        var fi = 0
        while fi < c.fields.len():
            w.write_u32(strtab.get_offset(c.fields[fi].name), LE)
            w.write_u32(strtab.get_offset(c.fields[fi].type_name), LE)
            w.write_u32(c.fields[fi].flags, LE)
            fi = fi + 1
        w.write_u16(c.methods.len(), LE)
        var mi = 0
        while mi < c.methods.len():
            w.write_u32(strtab.get_offset(c.methods[mi].name), LE)
            mi = mi + 1
        i = i + 1

fn shb_write_enums(enums: [ShbEnumEntry], strtab: ShbStringTable, w: BinaryWriter):
    w.write_u32(enums.len(), LE)
    var i = 0
    while i < enums.len():
        val e = enums[i]
        w.write_u32(strtab.get_offset(e.name), LE)
        w.write_u16(e.variants.len(), LE)
        w.write_u16(e.flags, LE)
        var vi = 0
        while vi < e.variants.len():
            w.write_u32(strtab.get_offset(e.variants[vi]), LE)
            vi = vi + 1
        i = i + 1

fn shb_write_traits(traits: [ShbTraitEntry], strtab: ShbStringTable, w: BinaryWriter):
    w.write_u32(traits.len(), LE)
    var i = 0
    while i < traits.len():
        val t = traits[i]
        w.write_u32(strtab.get_offset(t.name), LE)
        w.write_u16(t.methods.len(), LE)
        w.write_u16(t.flags, LE)
        var mi = 0
        while mi < t.methods.len():
            w.write_u32(strtab.get_offset(t.methods[mi]), LE)
            mi = mi + 1
        i = i + 1

fn shb_write_reexports(reexports: [ShbReexportEntry], strtab: ShbStringTable, w: BinaryWriter):
    w.write_u32(reexports.len(), LE)
    var i = 0
    while i < reexports.len():
        w.write_u32(strtab.get_offset(reexports[i].symbol_name), LE)
        w.write_u32(strtab.get_offset(reexports[i].source_module), LE)
        i = i + 1

fn shb_write_type_layouts(layouts: [ShbTypeLayoutEntry], strtab: ShbStringTable, w: BinaryWriter):
    w.write_u32(layouts.len(), LE)
    var i = 0
    while i < layouts.len():
        val l = layouts[i]
        w.write_u32(strtab.get_offset(l.type_name), LE)
        w.write_u32(l.size, LE)
        w.write_u32(l.alignment, LE)
        w.write_u32(l.flags, LE)
        i = i + 1

fn shb_write_dependencies(deps: [ShbDependencyEntry], strtab: ShbStringTable, w: BinaryWriter):
    w.write_u32(deps.len(), LE)
    var i = 0
    while i < deps.len():
        w.write_u32(strtab.get_offset(deps[i].module_path), LE)
        w.write_i64(deps[i].interface_hash, LE)
        i = i + 1

# --- FFI ---

extern fn rt_file_write_bytes(path: text, data: [u8]) -> bool
extern fn rt_file_move(from: text, to: text) -> bool
