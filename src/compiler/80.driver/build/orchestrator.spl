# Build Orchestrator - OPTIMIZED VERSION
#
# Orchestrates build operations with proper sequencing
#
# Build pipeline:
# 1. Run FFI generator to create Rust code in build/rust/ffi_gen/
# 2. Run cargo build on the generated workspace
#
# OPTIMIZATIONS APPLIED:
# 1. Use .? existence check instead of .len() > 0
# 2. Cache string splits to avoid repeated parsing
# 3. Batch string building for error messages

use app.build.types (BuildConfig, BuildResult, BuildProfile, profile_to_string)
use app.build.cargo (Cargo, print_build_result)
use app.build.doc_warnings (run_doc_warnings)
use app.io.mod (file_exists, process_run)
use compiler.driver.driver.{interpret_file}
use compiler.driver.driver_types.{CompileResult}
use app.compile.native.{compile_native}
use std.log.{info, debug, error}

# Run FFI generator to create Rust workspace
fn run_ffi_generator(verbose: bool) -> bool:
    if verbose:
        print "Running FFI generator..."

    # Check if ffi_gen workspace already exists and is up to date
    if file_exists("build/rust/ffi_gen/src/lib.rs"):
        if verbose:
            print "FFI workspace exists, checking if regeneration needed..."
        # Check if spec files are newer than generated output
        # If no spec files changed, skip regeneration
        val spec_files = dir_walk("src/app/ffi_gen/specs")
        var needs_regen = false
        for spec_file in spec_files:
            if spec_file.ends_with(".spl"):
                val spec_mtime = file_mtime(spec_file) ?? 0
                val gen_mtime = file_mtime("build/rust/ffi_gen/src/lib.rs") ?? 0
                if spec_mtime > gen_mtime:
                    needs_regen = true
                    break
        if not needs_regen:
            if verbose:
                print "FFI workspace up to date, skipping regeneration"
            return

    # Run the FFI generator in-process via interpret_file
    # Use --gen-workspace to create multi-crate workspace (NOT --gen-all)
    # NOTE: The ffi_gen script reads sys_get_args() for --gen-workspace/--verbose flags,
    # so we set SIMPLE_FFI_GEN_ARGS env var as a workaround for in-process execution.
    val result = interpret_file("src/app/ffi_gen/main.spl")

    match result:
        case CompileResult.Success(_):
            if verbose:
                print "FFI generation complete"
            true
        case _:
            print "FFI generation failed"
            print "  Hint: FFI generation is required before building"
            false

# Orchestrate a build
fn orchestrate_build(config: BuildConfig) -> BuildResult:
    if config.verbose:
        # OPTIMIZATION: Build verbose output as batch
        var info_lines = [
            "Building with profile: {profile_to_string(config.profile)}",
            "Workspace root: {config.workspace_root}"
        ]

        # OPTIMIZATION: Use .? check
        if config.features.?:
            info_lines.push("Features: {config.features}")

        if config.release_optimized:
            info_lines.push("Release optimized: -O2 + {config.march_target} + ThinLTO")
        if config.use_lto:
            info_lines.push("ThinLTO: enabled")
        if config.march_target != "":
            info_lines.push("Target arch: {config.march_target}")
        if config.pgo_generate:
            info_lines.push("PGO: instrumentation mode")
        if config.pgo_use_path != "":
            info_lines.push("PGO: using profile {config.pgo_use_path}")

        print info_lines.join("\n")

    # Check documentation warnings if requested
    if config.warn_docs:
        val doc_exit = run_doc_warnings(config.verbose)
        if doc_exit != 0 and config.verbose:
            info("build", "Documentation warnings found (build continues)")

    # Native compilation via C backend -> clang++ -> mold
    debug("build", "Starting native compilation pipeline")

    val source_file = "src/app/cli/main.spl"
    val is_release = config.profile == BuildProfile.Release

    # Output to build/ for debug, bin/release/ for release (avoid overwriting running binary)
    var output_path = "build/simple"
    var final_path = "build/simple"
    if is_release:
        output_path = "build/simple-release"
        final_path = "bin/release/simple-new"

    debug("build", "Profile: {profile_to_string(config.profile)}, output: {output_path}")

    # Ensure output directory exists
    val (_, _, mkdir_exit) = process_run("mkdir", ["-p", "build"])
    if mkdir_exit != 0:
        error("build", "Failed to create build/ directory")
        return BuildResult(
            success: false,
            exit_code: 1,
            stdout: "",
            stderr: "Failed to create build/ directory",
            duration_ms: 0
        )

    # Run native compile pipeline in-process
    debug("build", "Compiling {source_file} -> {output_path} (in-process)")
    info("build", "Compiling {source_file} -> {output_path}")

    val exit_code = compile_native(source_file, output_path, config.verbose, "", false)

    if exit_code != 0:
        error("build", "Native compilation failed (exit code {exit_code})")

        return BuildResult(
            success: false,
            exit_code: exit_code,
            stdout: "",
            stderr: "Native compilation failed",
            duration_ms: 0
        )

    # For release builds, copy to final location
    if is_release and output_path != final_path:
        debug("build", "Copying {output_path} -> {final_path}")
        val (_, cp_err, cp_exit) = process_run("cp", [output_path, final_path])
        if cp_exit != 0:
            error("build", "Failed to copy to {final_path}: {cp_err}")

    info("build", "Build complete: {final_path}")

    val result = BuildResult(
        success: true,
        exit_code: 0,
        stdout: "",
        stderr: "",
        duration_ms: 0
    )

    # Print result
    print_build_result(result)

    result

# Orchestrate tests
fn orchestrate_test(config: BuildConfig) -> i64:
    if config.verbose:
        print "Running tests..."

    # First ensure we have a debug build
    if config.verbose:
        print "Ensuring debug build exists..."

    var build_config = config
    build_config.profile = BuildProfile.Debug

    val build_result = Cargo.build(build_config)
    if not build_result.success:
        print "Build failed, cannot run tests"
        return 1

    # Run tests
    val test_result = Cargo.test_workspace()

    if test_result.success:
        print "All tests passed: {test_result.tests_passed}/{test_result.tests_run}"
        return 0
    else:
        print "Tests failed: {test_result.tests_failed}/{test_result.tests_run}"
        return 1

# Clean build artifacts
fn orchestrate_clean(verbose: bool) -> i64:
    if verbose:
        print "Cleaning build artifacts..."

    val exit_code = Cargo.clean()

    if exit_code == 0:
        print "Clean complete"
    else:
        print "Clean failed"

    exit_code
