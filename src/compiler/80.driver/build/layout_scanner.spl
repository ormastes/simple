# @no_alloc
# Source-text scanner for @repr and @volatile struct layout annotations
# Scans comment annotations to build StructLayoutInfo metadata

use std.unsafe.layout.{StructLayoutInfo, layout_info_new}

export scan_layout_annotations, get_layout_for_struct, layout_scanner_reset

# Module-level storage (parallel arrays)
var _struct_names: [text] = []
var _struct_layouts: [StructLayoutInfo] = []

fn layout_scanner_reset():
    _struct_names = []
    _struct_layouts = []

fn get_layout_for_struct(struct_name: text) -> StructLayoutInfo:
    var idx = 0
    for name in _struct_names:
        if name == struct_name:
            return _struct_layouts[idx]
        idx = idx + 1
    nil

# Main scan function — call with full source text of a .spl file
fn scan_layout_annotations(source_text: text):
    layout_scanner_reset()
    val lines = source_text.split("\n")
    var pending_reprs: [text] = []
    var pending_volatile = false
    var in_struct = false
    var current_name = ""
    var current_reprs: [text] = []
    var current_volatiles: [text] = []

    for line in lines:
        val stripped = _strip_leading(line)

        if stripped.starts_with("# @repr("):
            val args = _extract_repr_args(stripped)
            pending_reprs = pending_reprs + args

        elif stripped.starts_with("# @volatile"):
            pending_volatile = true

        elif stripped.starts_with("struct ") and stripped.ends_with(":"):
            # Save previous struct
            if current_name.len() > 0:
                _save_struct(current_name, current_reprs, current_volatiles)
            # Start new struct
            current_name = _extract_struct_name(stripped)
            current_reprs = pending_reprs
            current_volatiles = []
            pending_reprs = []
            pending_volatile = false
            in_struct = true

        elif in_struct and line.starts_with("    ") and stripped.contains(":") and not stripped.starts_with("#"):
            # This is a field line
            if pending_volatile:
                val field = _extract_field_name(stripped)
                if field.len() > 0:
                    current_volatiles = current_volatiles + [field]
                pending_volatile = false
            pending_reprs = []

        elif stripped.len() == 0:
            pass_do_nothing   # blank lines: keep pending_volatile, reset reprs

        else:
            # Non-field non-struct line: if dedented, end struct
            if in_struct and not line.starts_with("    ") and not stripped.starts_with("#"):
                if current_name.len() > 0:
                    _save_struct(current_name, current_reprs, current_volatiles)
                current_name = ""
                current_reprs = []
                current_volatiles = []
                in_struct = false
            pending_reprs = []
            pending_volatile = false

    # Save last struct
    if current_name.len() > 0:
        _save_struct(current_name, current_reprs, current_volatiles)

fn _save_struct(name: text, reprs: [text], volatiles: [text]):
    _struct_names = _struct_names + [name]
    _struct_layouts = _struct_layouts + [layout_info_new(name, reprs, volatiles)]

# Extract struct name: "struct DmaDescriptor:" → "DmaDescriptor"
fn _extract_struct_name(line: text) -> text:
    # line is like "struct Foo:" or "struct Foo<T>:"
    # skip "struct " (7 chars)
    var name = ""
    val n = line.len()
    for idx in 0..n:
        if idx >= 7:
            val ch = line[idx:idx + 1]
            if ch == ":" or ch == "<" or ch == " ":
                break
            name = name + ch
    name

# Extract field name: "status: u32" → "status"
fn _extract_field_name(stripped: text) -> text:
    # Find the colon position by scanning
    var colon_idx = -1
    val n = stripped.len()
    for idx in 0..n:
        val ch = stripped[idx:idx + 1]
        if ch == ":":
            colon_idx = idx
            break
    if colon_idx <= 0:
        return ""
    stripped[0:colon_idx]

# Extract repr args: "# @repr(C, packed)" → ["C", "packed"]
fn _extract_repr_args(line: text) -> [text]:
    # Find open paren
    var open_idx = -1
    var close_idx = -1
    val n = line.len()
    for idx in 0..n:
        val ch = line[idx:idx + 1]
        if ch == "(" and open_idx == -1:
            open_idx = idx
        elif ch == ")":
            close_idx = idx
    if open_idx < 0 or close_idx < 0 or close_idx <= open_idx:
        return []
    val inner = line[open_idx + 1:close_idx]
    val parts = inner.split(",")
    var result: [text] = []
    for p in parts:
        val trimmed = p.trim()
        if trimmed.len() > 0:
            result = result + [trimmed]
    result

# Strip leading whitespace from a line
fn _strip_leading(line: text) -> text:
    var i = 0
    val n = line.len()
    for idx in 0..n:
        val ch = line[idx:idx + 1]
        if ch == " " or ch == "\t":
            i = idx + 1
        else:
            break
    line[i:n]
