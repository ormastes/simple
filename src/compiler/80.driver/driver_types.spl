# Driver Types - Compiler Driver Type Definitions
#
# This module contains compiler driver type definitions:
# - CompileMode: Compilation mode (interpret, JIT, AOT, check)
# - OutputFormat: Output format options
# - CompileOptions: Compilation configuration
# - CompileResult: Compilation result types
# - SourceFile: Source file representation
# - Helper factory functions
#
# The compiler driver implementation is in driver.spl

use compiler.hir.*
use compiler.mir.*
use compiler.core.lexer.*
use compiler.core.parser.*
use compiler.treesitter.*
use compiler.blocks.*
use config.*
use compiler.backend_port.{BackendPort}
use compiler.backend_types.{BackendResult, BackendError}
use compiler.backend.*
use compiler.compiler_services.{CompilerServices, create_default_services}

# FFI declarations used by SourceFile.load and CompileContext
extern fn rt_file_read_text(path: text) -> text

fn create_config() -> Config:
    Config(values: {})

# Helper function to create a BlockResolver (avoids static method calls)
fn create_block_resolver() -> BlockResolver:
    BlockResolver(
        registry: block_registry(),
        diagnostics: [],
        file_path: nil,
        module_name: nil
    )

# Helper function to create a SymbolTable (avoids static method calls)
fn create_symbol_table() -> SymbolTable:
    var table = SymbolTable(
        symbols: {},
        scopes: {},
        current_scope: ScopeId(id: 0),
        next_symbol_id: 0,
        next_scope_id: 1
    )
    # Create root scope (direct mutation avoids copy-modify-reassign bug)
    table.scopes[0] = Scope(
        id: ScopeId(id: 0),
        parent: nil,
        kind: ScopeKind.Module,
        symbols: {}
    )
    table

# Helper function to create HirLowering (avoids static method calls)
fn create_hir_lowering() -> HirLowering:
    HirLowering(
        symbols: create_symbol_table(),
        errors: [],
        current_function: nil,
        loop_depth: 0
    )

# ------------------------------------------------------------------------------
# Compilation Mode
# ------------------------------------------------------------------------------

enum CompileMode:
    Interpret       # Tree-walking interpreter
    Jit             # JIT compile and run
    Aot             # Ahead-of-time compile to executable
    Check           # Type check only, no execution
    Sdn             # SDN data parsing mode (no code execution)

impl CompileMode:
    fn to_text() -> text:
        match self:
            case CompileMode.Interpret: "interpret"
            case CompileMode.Jit: "jit"
            case CompileMode.Aot: "aot"
            case CompileMode.Check: "check"
            case CompileMode.Sdn: "sdn"
            case _: "unknown"

    static fn from_text(s: text) -> CompileMode?:
        match s:
            case "interpret" | "i": Some(CompileMode.Interpret)
            case "jit" | "j": Some(CompileMode.Jit)
            case "aot" | "a" | "compile" | "c": Some(CompileMode.Aot)
            case "check" | "k": Some(CompileMode.Check)
            case "sdn" | "s" | "data": Some(CompileMode.Sdn)
            case _: nil

# Manually desugared static method for bootstrap runtime compatibility
fn CompileMode__from_text(s: text) -> CompileMode?:
    match s:
        case "interpret" | "i": Some(CompileMode.Interpret)
        case "jit" | "j": Some(CompileMode.Jit)
        case "aot" | "a" | "compile" | "c": Some(CompileMode.Aot)
        case "check" | "k": Some(CompileMode.Check)
        case "sdn" | "s" | "data": Some(CompileMode.Sdn)
        case _: nil

# ------------------------------------------------------------------------------
# Output Format (for AOT compilation)
# ------------------------------------------------------------------------------

enum OutputFormat:
    Native          # Emit native executable (default)
    Smf             # Emit .smf module file
    Both            # Emit both native executable and .smf
    SelfContained   # Emit self-contained binary (runtime + SMF in one file)

impl OutputFormat:
    fn to_text() -> text:
        match self:
            case OutputFormat.Native: "native"
            case OutputFormat.Smf: "smf"
            case OutputFormat.Both: "both"
            case OutputFormat.SelfContained: "self-contained"
            case _: "native"

    static fn from_text(s: text) -> OutputFormat:
        match s:
            case "smf": OutputFormat.Smf
            case "both": OutputFormat.Both
            case "self-contained" | "sc": OutputFormat.SelfContained
            case _: OutputFormat.Native

# Manually desugared static method for bootstrap runtime compatibility
fn OutputFormat__from_text(s: text) -> OutputFormat:
    match s:
        case "smf": OutputFormat.Smf
        case "both": OutputFormat.Both
        case "self-contained" | "sc": OutputFormat.SelfContained
        case _: OutputFormat.Native

# ------------------------------------------------------------------------------
# Compilation Options
# ------------------------------------------------------------------------------

struct CompileOptions:
    mode: CompileMode
    input_files: [text]
    output_file: text?
    output_format: OutputFormat
    optimize: bool
    opt_level: i64?         # 0=none, 1=size, 2=speed, 3=aggressive
    release: bool           # Release build (enables optimization)
    debug_info: bool
    verbose: bool
    log_level: i64
    profile: text           # dev, test, prod
    no_borrow_check: bool   # Skip borrow checking
    backend: text           # "auto", "cranelift", "llvm" - backend selection
    interpreter_mode: text  # "optimized" (default), "classic" (legacy)
    gc_off: bool            # Disable garbage collection

    static fn default() -> CompileOptions:
        CompileOptions(
            mode: CompileMode.Interpret,
            input_files: [],
            output_file: nil,
            output_format: OutputFormat.Native,
            optimize: false,
            opt_level: nil,
            release: false,
            debug_info: true,
            verbose: false,
            log_level: 4,       # Info
            profile: "dev",
            no_borrow_check: false,
            backend: "auto",
            interpreter_mode: "optimized",
            gc_off: false
        )

# Manually desugared static method for bootstrap runtime compatibility
fn CompileOptions__default() -> CompileOptions:
    CompileOptions(
        mode: CompileMode.Interpret,
        input_files: [],
        output_file: nil,
        output_format: OutputFormat.Native,
        optimize: false,
        opt_level: nil,
        release: false,
        debug_info: true,
        verbose: false,
        log_level: 4,       # Info
        profile: "dev",
        no_borrow_check: false,
        backend: "auto",
        interpreter_mode: "optimized",
        gc_off: false
    )

# ------------------------------------------------------------------------------
# Compilation Result
# ------------------------------------------------------------------------------

enum CompileResult:
    Success(Any?)
    TypeError([text])
    ParseError([text])
    BlockError([text])     # Block resolution errors
    ResolveError([text])
    BorrowError([text])    # Borrow checking errors
    CodegenError(text)
    RuntimeError(text)

    fn is_success(self) -> bool:
        match self:
            case CompileResult.Success(_): true
            case _: false

    fn get_value(self) -> Any?:
        match self:
            case CompileResult.Success(v): v
            case _: nil

    fn get_errors(self) -> [text]:
        match self:
            case CompileResult.Success(_): []
            case CompileResult.TypeError(e): e
            case CompileResult.ParseError(e): e
            case CompileResult.BlockError(e): e
            case CompileResult.ResolveError(e): e
            case CompileResult.BorrowError(e): e
            case CompileResult.CodegenError(m): [m]
            case CompileResult.RuntimeError(m): [m]
            case _: []

# ------------------------------------------------------------------------------
# Source File
# ------------------------------------------------------------------------------

struct SourceFile:
    path: text
    content: text
    module_name: text

    static fn load(path: text) -> Result<SourceFile, text>:
        val content_opt = rt_file_read_text(path)
        # rt_file_read_text returns Option<text>
        if content_opt.is_none():
            return Err("Failed to read file: {path}")
        val content = content_opt.unwrap()

        # Extract module name from path
        val name = path.split("/").last() ?? "main"
        val name_no_spl = name.replace(".spl", "")
        val module_name = name_no_spl.replace(".sdn", "")

        Ok(SourceFile(
            path: path,
            content: content,
            module_name: module_name
        ))

# ------------------------------------------------------------------------------
# Compilation Context
# ------------------------------------------------------------------------------

class CompileContext:
    options: CompileOptions
    config: Dict<text, text>  # Using dict instead of Config to avoid interpreter issues
    backend: BackendPort       # Typed port: visible contract, replaces extensions.resolve("Backend")
    extensions: DiContainer    # Dynamic extension point for plugins (Feature 5)
    aop: AopWeaver
    logger: Logger
    sources: [SourceFile]
    modules: Dict<text, Module>
    hir_modules: Dict<text, HirModule>
    mir_modules: Dict<text, MirModule>
    errors: [text]
    warnings: [text]
    visibility_warnings: [text]  # Visibility warnings (W0401)

    static fn create(options: CompileOptions) -> CompileContext:
        # Load config
        val config = {}  # Simple dict for now

        # Build typed BackendPort from concrete implementation based on mode
        val backend = match options.mode:
            case CompileMode.Interpret:
                val interp_impl = InterpreterBackendImpl.new()
                BackendPort(
                    name: "interpreter",
                    run_fn: fn(m): interp_impl.process_module(m),
                    supports_jit_fn: fn(): false,
                    target_triple_fn: fn(): "interpreter"
                )
            case CompileMode.Jit:
                val jit_impl = CompilerBackendImpl.jit()
                BackendPort(
                    name: "jit",
                    run_fn: fn(m): jit_impl.process_module(m),
                    supports_jit_fn: fn(): true,
                    target_triple_fn: fn(): "native-jit"
                )
            case CompileMode.Aot:
                val output = options.output_file ?? "a.out"
                val aot_impl = CompilerBackendImpl.aot(output)
                BackendPort(
                    name: "aot",
                    run_fn: fn(m): aot_impl.process_module(m),
                    supports_jit_fn: fn(): false,
                    target_triple_fn: fn(): "native-aot"
                )
            case CompileMode.Sdn:
                val sdn_impl = SdnBackendImpl()
                BackendPort(
                    name: "sdn",
                    run_fn: fn(m): sdn_impl.process_module(m),
                    supports_jit_fn: fn(): false,
                    target_triple_fn: fn(): "sdn"
                )
            case CompileMode.Check:
                # Check mode: no-op backend (validate only, no execution)
                BackendPort(
                    name: "check",
                    run_fn: fn(m): Ok(BackendResult.Unit),
                    supports_jit_fn: fn(): false,
                    target_triple_fn: fn(): "check"
                )

        # Setup extensions container for plugin/extension use (Feature 5)
        val extensions = DiContainer(bindings: {}, singletons: {}, profile: options.profile, all_bindings: [], locked: false)

        # Setup logger from env var (SIMPLE_LOG=debug|trace|info|warn|error)
        val logger = if options.verbose:
            Logger(level: 10)  # verbose flag forces debug level
        else:
            Logger.from_env()

        # Setup AOP
        var aop = AopWeaver(aspects: [], logger: logger)
        if options.verbose:
            aop.add_aspect(LogAspect(level: 6, logger: aop.logger))

        CompileContext(
            options: options,
            config: config,
            backend: backend,
            extensions: extensions,
            aop: aop,
            logger: logger,
            sources: [],
            modules: {},
            hir_modules: {},
            mir_modules: {},
            errors: [],
            warnings: [],
            visibility_warnings: []
        )

    me add_error(message: text):
        self.errors.push(message)

    me add_warning(message: text):
        self.warnings.push(message)

    me add_visibility_warning(message: text):
        self.visibility_warnings.push(message)

    fn has_errors() -> bool:
        self.errors.len() > 0

    fn get_extension(name: text) -> Any:
        # Resolve a named extension, returning nil if not registered
        self.extensions.resolve_or(name, nil)

    me register_extension(name: text, value: Any):
        # Register a named extension instance for plugin use
        self.extensions.bind_instance(name, value)

# ------------------------------------------------------------------------------
# Check Backend (Type Check Only)
# ------------------------------------------------------------------------------

# ------------------------------------------------------------------------------
# Factory: create_compile_context
#
# Creates a CompileContext wired through CompilerServices.
#
# Calls create_default_services() to obtain a typed CompilerServices container,
# then replaces the noop backend with the real mode-specific backend determined
# from options.mode. All other service ports come from the services container
# and can be replaced incrementally as the MDSoC migration progresses.
#
# This makes the dependency wiring visible: open CompilerServices to see every
# service the compiler pipeline needs, each with a typed port contract.
# ------------------------------------------------------------------------------

fn create_compile_context(options: CompileOptions) -> CompileContext:
    """Create a CompileContext wired through the CompilerServices container.

    Uses create_default_services() from compiler_services.spl to obtain
    a CompilerServices struct with typed port contracts for each pipeline stage.
    The backend port is then replaced with the real mode-specific implementation
    based on options.mode.

    This establishes the typed service wiring. As the MDSoC migration progresses,
    additional pipeline stages can be wired from services into CompileContext fields.
    """
    # Step 1: Get the typed service container with noop stubs for all ports
    val services = create_default_services()

    # Step 2: Build the real mode-specific backend port (overrides services.backend noop)
    val real_backend = match options.mode:
        case CompileMode.Interpret:
            val interp_impl = InterpreterBackendImpl.new()
            BackendPort(
                name: "interpreter",
                run_fn: fn(m): interp_impl.process_module(m),
                supports_jit_fn: fn(): false,
                target_triple_fn: fn(): "interpreter"
            )
        case CompileMode.Jit:
            val jit_impl = CompilerBackendImpl.jit()
            BackendPort(
                name: "jit",
                run_fn: fn(m): jit_impl.process_module(m),
                supports_jit_fn: fn(): true,
                target_triple_fn: fn(): "native-jit"
            )
        case CompileMode.Aot:
            val output = options.output_file ?? "a.out"
            val aot_impl = CompilerBackendImpl.aot(output)
            BackendPort(
                name: "aot",
                run_fn: fn(m): aot_impl.process_module(m),
                supports_jit_fn: fn(): false,
                target_triple_fn: fn(): "native-aot"
            )
        case CompileMode.Sdn:
            val sdn_impl = SdnBackendImpl()
            BackendPort(
                name: "sdn",
                run_fn: fn(m): sdn_impl.process_module(m),
                supports_jit_fn: fn(): false,
                target_triple_fn: fn(): "sdn"
            )
        case CompileMode.Check:
            BackendPort(
                name: "check",
                run_fn: fn(m): Ok(BackendResult.Unit),
                supports_jit_fn: fn(): false,
                target_triple_fn: fn(): "check"
            )

    # Step 3: Build the remaining services (logger, extensions, aop) from options
    # as done in CompileContext.create; these will migrate to services ports in future phases
    val config = {}
    val extensions = DiContainer(bindings: {}, singletons: {}, profile: options.profile, all_bindings: [], locked: false)
    val logger = if options.verbose:
        Logger(level: 10)
    else:
        Logger.from_env()
    var aop = AopWeaver(aspects: [], logger: logger)
    if options.verbose:
        aop.add_aspect(LogAspect(level: 6, logger: aop.logger))

    # Step 4: Construct CompileContext - backend comes from services wiring (step 2),
    # other CompilerServices ports (lexer, parser, desugarer, etc.) are available
    # at services.lexer, services.parser, etc. for future incremental migration
    CompileContext(
        options: options,
        config: config,
        backend: real_backend,
        extensions: extensions,
        aop: aop,
        logger: logger,
        sources: [],
        modules: {},
        hir_modules: {},
        mir_modules: {},
        errors: [],
        warnings: [],
        visibility_warnings: []
    )

# ============================================================================
# Exports
# ============================================================================

export create_config, create_block_resolver, create_symbol_table, create_hir_lowering
export CompileMode, CompileMode__from_text, OutputFormat, OutputFormat__from_text
export CompileOptions, CompileOptions__default, CompileResult, SourceFile, CompileContext
export BackendPort
export CompilerServices, create_default_services, create_compile_context
