# Driver - Compiler Driver Implementation
#
# This module contains the main compiler driver implementation:
# - CheckBackendImpl: Backend for type checking only
# - CompilerDriver: Main compiler orchestration
# - Utility functions for file compilation
#
# Type definitions are in driver_types.spl
# AOT output methods are in driver_aot_output.spl

use compiler.hir.hir.*
use compiler.mir.mir.*
use compiler.frontend.frontend.{parse_full_frontend}
use compiler.backend.backend.*
use compiler.types.type_infer.*
use compiler.backend.ffi.*
use compiler.mono.monomorphize_integration.*
use compiler.mir_opt.mir_opt_integration.{OptimizationConfig, optimize_mir_module}
use compiler.tools.async_integration.{AsyncIntegration, AsyncStateMachine, process_async_mir}
use compiler.borrow.borrow_check.*
use compiler.common.visibility_integration.{check_module_visibility}
use compiler.semantics.const_eval.{eval_static_assert, ConstEvalError}
use compiler.common.config.*
use compiler.types.type_system.effect_pass.{run_effect_pass}
use driver_types.*
use compiler.backend.linker.linker_wrapper.{link_to_native, link_to_smf, link_to_self_contained, NativeLinkConfig, NativeLinkConfig__default, SelfContainedConfig, SelfContainedConfig__default, write_elf_bytes_to_file}
use compiler.driver.smf_writer.{generate_smf_with_templates, Target}
use compiler.backend.backend.cmake_gen.{generate_cmake_for_modules}
use compiler.driver.driver_aot_output.*

extern fn rt_dir_exists(path: text) -> bool
extern fn rt_dir_list(path: text) -> [text]
extern fn rt_file_exists(path: text) -> bool

# Lightweight logging helpers to avoid bootstrap method lookups
fn log_debug(msg: text): ()
fn log_trace(msg: text): ()
fn log_info(msg: text): ()
fn log_warn(msg: text): print "[WARN] {msg}"
fn log_error(msg: text): print "[ERROR] {msg}"

class CheckBackendImpl(Backend):
    fn name() -> text:
        "check"

    fn is_allowed(op: text) -> bool:
        # Allow everything for type checking
        true

    fn process_module(module: HirModule) -> Result<Any, text>:
        # Just validate, don't execute
        Ok(nil)

    fn eval_expr(expr: HirExpr, env: Environment) -> Result<Value, text>:
        # Don't evaluate, just return unit
        Ok(Value.Unit)

    fn exec_stmt(stmt: HirStmt, env: Environment) -> Result<Value, text>:
        Ok(Value.Unit)

# ------------------------------------------------------------------------------
# Compiler Driver
# ------------------------------------------------------------------------------

class CompilerDriver:
    ctx: CompileContext

    static fn create(options: CompileOptions) -> CompilerDriver:
        val ctx = CompileContext__create(options)
        CompilerDriver(ctx: ctx)

    # --------------------------------------------------------------------------
    # Main compilation entry point
    # --------------------------------------------------------------------------

    me compile() -> CompileResult:
        val log = self.ctx.logger

        # Phase 1: Load source files
        log_debug("phase 1: loading sources...")
        if not self.load_sources_impl():
            log_error("phase 1 FAILED")
            return CompileResult.ParseError(self.ctx.errors)
        log_debug("phase 1 done, {self.ctx.sources.len()} sources loaded")

        # Phase 2: Parse all sources
        log_debug("phase 2: parsing...")
        if not self.parse_all_impl():
            log_error("phase 2 FAILED")
            return CompileResult.ParseError(self.ctx.errors)
        log_debug("phase 2 done")

        # Phase 3: Lower to HIR, resolve methods, and type check (combined loop)
        log_debug("phase 3: lowering and checking...")
        log_trace("BEFORE phase 3: hir_modules count = {self.ctx.hir_modules.keys().len()}")
        val analyze_ok = self.lower_and_check_impl()
        log_trace("AFTER phase 3: hir_modules count = {self.ctx.hir_modules.keys().len()}")
        if not analyze_ok:
            log_error("phase 3 FAILED")
            # Determine error type from first error
            if self.ctx.errors.len() > 0:
                val first_error = self.ctx.errors[0]
                if first_error.contains("Method resolution"):
                    return CompileResult.ResolveError(self.ctx.errors)
            return CompileResult.TypeError(self.ctx.errors)
        log_debug("phase 3 done")

        # Phase 4: Monomorphization (specialize generic functions)
        log_debug("phase 4: monomorphization...")
        val mono_ok = self.monomorphize_impl()
        if not mono_ok:
            log_error("phase 4 FAILED")
            return CompileResult.TypeError(self.ctx.errors)
        log_debug("phase 4 done")

        # Phase 5: Mode-specific processing
        log_debug("phase 5: mode-specific processing...")
        match self.ctx.options.mode:
            case CompileMode.Check:
                log_debug("check mode")
                return CompileResult.Success(nil)

            case CompileMode.Sdn:
                log_debug("sdn mode")
                return self.process_sdn()

            case CompileMode.Interpret:
                log_debug("interpret mode")
                return self.interpret()

            case CompileMode.Jit:
                log_debug("jit mode")
                return self.jit_compile_and_run()

            case CompileMode.Aot:
                log_debug("aot mode")
                return self.aot_compile()

        log_warn("no mode matched, falling through")
        CompileResult.Success(nil)

    # --------------------------------------------------------------------------
    # Phase 1: Load sources
    # --------------------------------------------------------------------------

    me load_sources_impl() -> bool:
        val log = self.ctx.logger
        log_debug("input_files count={self.ctx.options.input_files.len()}")

        # Directories to skip (tests/docs/examples slow or fail in bootstrap)
        val skip_dirs = ["test", "tests", "doc", "docs", "examples", "verification", "resources", "scripts", "build"]

        fn should_skip_dir(name: text) -> bool:
            var i = 0
            while i < skip_dirs.len():
                if name == skip_dirs[i]:
                    return true
                i = i + 1
            false

        fn load_path(p: text):
            if rt_dir_exists(p):
                # Depth-first traversal with pruning
                val entries = rt_dir_list(p)
                var idx = 0
                while idx < entries.len():
                    val child = entries[idx]
                    val child_path = "{p}/{child}"
                    if should_skip_dir(child):
                        idx = idx + 1
                        continue
                    load_path(child_path)
                    idx = idx + 1
            else:
                if not p.ends_with(".spl"):
                    return
                if p.ends_with("/check.spl") or p.ends_with("\\check.spl"):
                    return
                if p.contains("/test/") or p.contains("/tests/") or p.contains("/doc/") or p.contains("/examples/") or p.contains("/verification/"):
                    return
                log_trace("loading file: {p}")
                match SourceFile.load(p):
                    case Ok(source):
                        log_trace("loaded OK: {source.path}")
                        self.ctx.sources.push(source)
                    case Err(e):
                        log_error("load error: {e}")
                        self.ctx.add_error(e)

        # Start with user-provided roots
        var i = 0
        while i < self.ctx.options.input_files.len():
            load_path(self.ctx.options.input_files[i])
            i = i + 1

        # Add core source roots needed for CLI + compiler
        load_path("src/app")
        load_path("src/lib")
        load_path("src/compiler")
        load_path("src/runtime")

        log_debug("sources stored, count={self.ctx.sources.len()}")
        not self.ctx.has_errors()

    # --------------------------------------------------------------------------
    # Phase 2: Parse
    # --------------------------------------------------------------------------

    me parse_all_impl() -> bool:
        val log = self.ctx.logger
        val sources = self.ctx.sources
        log_debug("parsing {sources.len()} sources")
        var src_idx = 0
        while src_idx < sources.len():
            val source = sources[src_idx]
            log_trace("parsing: {source.path} (module={source.module_name}, len={source.content.len()})")
            val module = self.parse_source(source)
            self.ctx.modules[source.module_name] = module
            log_trace("stored module, total={self.ctx.modules.keys().len()}")
            src_idx = src_idx + 1

        log_debug("parsing done, modules={self.ctx.modules.keys().len()}")
        not self.ctx.has_errors()

    fn parse_source(source: SourceFile) -> Module:
        parse_full_frontend(source.content, source.path, source.module_name, self.ctx.logger)

    # --------------------------------------------------------------------------
    # Phase 3: Combined HIR Lowering + Method Resolution + Type Checking
    # --------------------------------------------------------------------------
    #
    # This combined implementation processes each module through all three
    # phases in a single loop, avoiding redundant iterations and improving
    # performance on large codebases.

    me lower_and_check_impl() -> bool:
        val log = self.ctx.logger
        var lowering = create_hir_lowering()

        val module_names = self.ctx.modules.keys()
        log_debug("lowering {module_names.len()} modules to HIR")
        for name in module_names:
            log_trace("processing module: {name}")
            val module = self.ctx.modules[name]
            if module == nil:
                log_error("module is nil for key {name}")
                continue

            # Step 1: Lower to HIR
            val hir_module = lowering.lower_module(module)
            log_trace("HIR lowered for {name}")

            # Step 2: Method resolution (UFCS)
            val (resolved_module, resolve_errors) = resolve_methods(hir_module)
            log_trace("methods resolved, errors={resolve_errors.len()}")

            # Collect method resolution errors
            var err_idx = 0
            while err_idx < resolve_errors.len():
                val err = resolve_errors[err_idx]
                self.ctx.add_error("Method resolution error in {name}: {err.message}")
                err_idx = err_idx + 1

            # Step 2b: Visibility checking (cross-module access validation)
            val vis_warnings = check_module_visibility(resolved_module, name)
            log_trace("visibility checked, warnings={vis_warnings.len()}")
            for warning in vis_warnings:
                self.ctx.add_visibility_warning(warning.format())

            # Step 2c: Evaluate static assertions
            for static_assert in resolved_module.static_asserts:
                val result = eval_static_assert(resolved_module, static_assert)
                match result:
                    case Err(err):
                        val msg = match err:
                            case ConstEvalError.NotConstant(expr, _):
                                "static assert condition is not constant: {expr}"
                            case ConstEvalError.TypeError(expected, got, _):
                                "static assert condition must be bool, got {got}"
                            case ConstEvalError.AssertionFailed(message, _):
                                if message.?:
                                    "static assertion failed: {message}"
                                else:
                                    "static assertion failed"
                            case _:
                                "static assert evaluation error"
                        self.ctx.add_error("Error in {name}: {msg}")
                    case _:
                        pass
            log_trace("static assertions evaluated")

            # Step 3: Type checking (HM inference) - skipped for bootstrap
            # Store final module directly (avoids copy-modify-reassign bug in compiled mode)
            self.ctx.hir_modules[name] = resolved_module
            log_trace("stored HIR module '{name}', total={self.ctx.hir_modules.keys().len()}")

        # Step 2d: Effect inference pass (infer async effects across all modules)
        log_debug("running effect inference pass...")
        val (effect_modules, effect_warnings) = run_effect_pass(self.ctx.hir_modules)
        self.ctx.hir_modules = effect_modules
        for warning in effect_warnings:
            log_warn("effect: {warning}")
        log_debug("effect inference done, {effect_warnings.len()} warnings")

        log_debug("HIR lowering complete: {self.ctx.hir_modules.keys().len()} modules")
        not self.ctx.has_errors()

    # --------------------------------------------------------------------------
    # Phase 3a: Lower to HIR (standalone, kept for compatibility)
    # --------------------------------------------------------------------------

    fn lower_to_hir_impl() -> (CompileContext, bool):
        var lowering = create_hir_lowering()
        var ctx = self.ctx

        val module_names = ctx.modules.keys()
        for name in module_names:
            val module = ctx.modules[name]
            val hir_module = lowering.lower_module(module)
            ctx.hir_modules[name] = hir_module
        (ctx, ctx.errors.len() == 0)

    # --------------------------------------------------------------------------
    # Phase 3b: Method Resolution (standalone, kept for compatibility)
    # --------------------------------------------------------------------------

    fn resolve_methods_impl() -> (CompileContext, bool):
        var ctx = self.ctx

        for name in ctx.hir_modules.keys():
            val hir_module = ctx.hir_modules[name]
            val (resolved_module, resolve_errors) = resolve_methods(hir_module)

            # Update the module with resolved method calls (direct mutation)
            ctx.hir_modules[name] = resolved_module

            # Collect errors
            for err in resolve_errors:
                ctx.errors.push("Method resolution error in {name}: {err.message}")

        (ctx, ctx.errors.len() == 0)

    # --------------------------------------------------------------------------
    # Phase 3c: Type Checking (standalone, kept for compatibility)
    # --------------------------------------------------------------------------

    fn type_check_impl() -> (CompileContext, bool):
        var ctx = self.ctx

        # Type inference disabled for bootstrap compatibility
        # for name in ctx.hir_modules.keys():
        #     val hir_module = ctx.hir_modules[name]
        #     var infer_ctx = HmInferContext.with_builtins()
        #     infer_ctx.infer_module(hir_module)
        #     for err in infer_ctx.errors:
        #         var errors = ctx.errors
        #         errors.push("Type error in {name}: {err.message()}")
        #         ctx.errors = errors

        (ctx, ctx.errors.len() == 0)

    # --------------------------------------------------------------------------
    # Phase 4: Monomorphization
    # --------------------------------------------------------------------------

    me monomorphize_impl() -> bool:
        """Run monomorphization pass on all HIR modules.

        This creates specialized versions of generic functions, structs, and
        classes by substituting concrete type arguments. Call sites are
        rewritten to use the mangled names of specialized definitions.
        """
        val log = self.ctx.logger
        log_debug("running monomorphization on {self.ctx.hir_modules.keys().len()} modules")

        # Run the monomorphization pass
        val (updated_modules, stats) = run_monomorphization(self.ctx.hir_modules)

        # Update context with modified modules
        self.ctx.hir_modules = updated_modules

        # Log statistics
        log_debug("monomorphization stats:")
        log_debug("  generic functions: {stats.generic_functions_found}")
        log_debug("  generic structs: {stats.generic_structs_found}")
        log_debug("  generic classes: {stats.generic_classes_found}")
        log_debug("  call sites: {stats.call_sites_found}")
        log_debug("  specializations created: {stats.specializations_created}")

        not self.ctx.has_errors()

    # --------------------------------------------------------------------------
    # Mode: SDN (Data only)
    # --------------------------------------------------------------------------

    fn process_sdn() -> CompileResult:
        val backend_port = self.ctx.backend
        val results: Dict<text, Any> = {}

        for name in self.ctx.hir_modules.keys():
            val hir_module = self.ctx.hir_modules[name]
            match backend_port.run_fn(hir_module):
                case Ok(value):
                    results[name] = value
                case Err(e):
                    return CompileResult.RuntimeError("SDN error in {name}: {e.message}")

        CompileResult.Success(results)

    # --------------------------------------------------------------------------
    # Mode: Interpret
    # --------------------------------------------------------------------------

    fn interpret() -> CompileResult:
        self.interpret_pipeline()

    fn interpret_pipeline() -> CompileResult:
        val log = self.ctx.logger
        val backend_port = self.ctx.backend
        var last_result: Any = BackendResult.Unit
        var has_result = false

        if self.ctx.sources.len() == 0:
            return CompileResult.RuntimeError("No source file specified for interpret mode")

        log_debug("interpret: running {self.ctx.sources.len()} modules through compiler frontend output")

        var src_idx = 0
        while src_idx < self.ctx.sources.len():
            val source = self.ctx.sources[src_idx]
            val name = source.module_name
            val hir_module = self.ctx.hir_modules[name]
            if hir_module == nil:
                src_idx = src_idx + 1
                continue

            match backend_port.run_fn(hir_module):
                case Ok(value):
                    last_result = value
                    has_result = true
                case Err(e):
                    return CompileResult.RuntimeError("Interpret error in {name}: {e.message}")
            src_idx = src_idx + 1

        if has_result:
            return CompileResult.Success(last_result)
        CompileResult.Success(BackendResult.Unit)

    fn run_module(backend: Backend, module: HirModule) -> CompileResult:
        match backend.process_module(module):
            case Ok(value): CompileResult.Success(value)
            case Err(e): CompileResult.RuntimeError(e)

    # --------------------------------------------------------------------------
    # Mode: JIT Compile and Run
    # --------------------------------------------------------------------------

    me jit_compile_and_run() -> CompileResult:
        # Lower to MIR
        if not self.lower_to_mir():
            return CompileResult.CodegenError(self.ctx.errors.first() ?? "MIR lowering failed")

        # Borrow checking
        if not self.borrow_check():
            return CompileResult.BorrowError(self.ctx.errors)

        # Process async functions (generate state machines for await/yield)
        val _async_state_machines = self.process_async()

        # Optimize MIR (speed optimization for JIT)
        self.optimize_mir(OptimizationConfig__speed())

        # JIT compile
        var pipeline = CodegenPipeline()

        for name in self.ctx.mir_modules.keys():
            val mir_module = self.ctx.mir_modules[name]
            match pipeline.jit_compile(mir_module):
                case Ok(_): pass
                case Err(e):
                    return CompileResult.CodegenError("JIT compile error in {name}: {e}")

        # Find and call main
        val main_fn = pipeline.get_function("main")
        if main_fn == nil:
            return CompileResult.RuntimeError("No main function found")

        match pipeline.call_function("main", []):
            case Ok(result): CompileResult.Success(result)
            case Err(e): CompileResult.RuntimeError(e)

    # --------------------------------------------------------------------------
    # Mode: AOT Compile
    # --------------------------------------------------------------------------

    me aot_compile() -> CompileResult:
        val log = self.ctx.logger

        # Lower to MIR
        log_debug("AOT: lowering to MIR ({self.ctx.hir_modules.keys().len()} HIR modules)")
        if not self.lower_to_mir():
            for err in self.ctx.errors:
                log_error("MIR error: {err}")
            return CompileResult.CodegenError(self.ctx.errors.first() ?? "MIR lowering failed")
        log_debug("MIR done, {self.ctx.mir_modules.keys().len()} modules")

        # Borrow checking
        log_debug("AOT: running borrow check...")
        if not self.borrow_check():
            for err in self.ctx.errors:
                log_error("Borrow error: {err}")
            return CompileResult.BorrowError(self.ctx.errors)
        log_debug("borrow check done")

        # Process async functions (generate state machines for await/yield)
        log_debug("AOT: processing async functions")
        val async_state_machines = self.process_async()
        log_debug("async processing done, {async_state_machines.keys().len()} state machines")

        # Optimize MIR (use optimization level from options)
        val opt_config = self.get_optimization_config()
        log_debug("AOT: optimizing MIR (level: {opt_config.level})")
        self.optimize_mir(opt_config)
        log_debug("MIR optimization done")

        # Determine output file
        val output = self.ctx.options.output_file ?? "a.out"

        # If backend is C, write C++ source instead of compiling to native
        val backend_name = self.ctx.options.backend
        if backend_name == "c" or backend_name == "cpp" or backend_name == "ccodegen":
            return self.compile_to_c(output)

        # Dispatch based on output format
        val format = self.ctx.options.output_format
        match format:
            case OutputFormat.Smf:
                return self.compile_to_smf(output)
            case OutputFormat.SelfContained:
                return self.compile_to_self_contained(output)
            case OutputFormat.Both:
                # Compile native first, then SMF
                val native_result = self.compile_to_native(output)
                if not native_result.is_success():
                    return native_result
                val smf_result = self.compile_to_smf("{output}.smf")
                if not smf_result.is_success():
                    return smf_result
                return CompileResult.Success(output)
            case _:
                # Native (default)
                return self.compile_to_native(output)

    # --------------------------------------------------------------------------
    # MIR Lowering
    # --------------------------------------------------------------------------

    me lower_to_mir() -> bool:
        var lowering = MirLowering__new(create_symbol_table())

        val hir_keys = self.ctx.hir_modules.keys()
        for name in hir_keys:
            val hir_module = self.ctx.hir_modules[name]
            var mir_module = lowering.lower_module(hir_module)
            # Ensure module name is set
            mir_module.name = name
            # Direct mutation (avoids copy-modify-reassign bug in compiled mode)
            self.ctx.mir_modules[name] = mir_module

        not self.ctx.has_errors()

    # --------------------------------------------------------------------------
    # Borrow Checking
    # --------------------------------------------------------------------------

    me borrow_check() -> bool:
        """Run borrow checking on all MIR modules."""
        val log = self.ctx.logger

        if self.ctx.options.no_borrow_check:
            log_debug("borrow checking disabled")
            return true

        log_debug("borrow checking {self.ctx.mir_modules.keys().len()} modules")

        var checker = BorrowChecker__create()
        var has_errors = false

        for name in self.ctx.mir_modules.keys():
            val mir_module = self.ctx.mir_modules[name]

            for fn_symbol in mir_module.functions.keys():
                val mir_fn = mir_module.functions[fn_symbol]
                val body = MirBody__from_function(mir_fn)
                match checker.check_function(body):
                    case Errors(errors):
                        for err in errors:
                            self.ctx.add_error(self.format_borrow_error(err))
                        has_errors = true
                    case Ok:
                        pass

        not has_errors

    fn format_borrow_error(err: NLLError) -> text:
        """Format a borrow error for display."""
        var msg = "error[E0502]: {err.message}"
        if err.help.?:
            msg = "{msg}" + "\n" + "  = help: {err.help.unwrap()}"
        msg

    # --------------------------------------------------------------------------
    # Async Processing
    # --------------------------------------------------------------------------

    me process_async() -> Dict<text, AsyncStateMachine>:
        """Process async functions and generate state machines.

        This is called after MIR lowering to analyze and transform async functions.
        State machines are used by codegen for async execution.
        """
        val log = self.ctx.logger
        log_debug("processing async functions in {self.ctx.mir_modules.keys().len()} modules")

        val state_machines = process_async_mir(self.ctx.mir_modules)

        log_debug("generated {state_machines.keys().len()} async state machines")
        state_machines

    # --------------------------------------------------------------------------
    # MIR Optimization
    # --------------------------------------------------------------------------

    me optimize_mir(config: OptimizationConfig):
        """Apply MIR optimization passes to all modules."""
        val log = self.ctx.logger
        log_debug("optimizing {self.ctx.mir_modules.keys().len()} MIR modules")

        for name in self.ctx.mir_modules.keys():
            val mir_module = self.ctx.mir_modules[name]
            val optimized = optimize_mir_module(mir_module, config)
            # Direct mutation (avoids copy-modify-reassign bug in compiled mode)
            self.ctx.mir_modules[name] = optimized

    fn get_optimization_config() -> OptimizationConfig:
        """Get optimization config from compiler options."""
        # Check for explicit optimization level
        if self.ctx.options.opt_level.?:
            val level = self.ctx.options.opt_level.unwrap()
            if level == 0:
                return OptimizationConfig__debug()
            elif level == 1:
                return OptimizationConfig__size()
            elif level == 2:
                return OptimizationConfig__speed()
            elif level >= 3:
                return OptimizationConfig__aggressive()

        # Check for release mode or optimize flag
        if self.ctx.options.release or self.ctx.options.optimize:
            OptimizationConfig__speed()
        else:
            OptimizationConfig__debug()

# ------------------------------------------------------------------------------
# Runtime Library Discovery
# ------------------------------------------------------------------------------

fn find_runtime_lib_dir() -> text:
    # Check env var first
    val env_path = rt_env_get("SIMPLE_RUNTIME_PATH")
    if env_path.? and env_path != "":
        return env_path
    # Default to rust/target/debug
    if rt_file_exists("rust/target/debug/libsimple_compiler.so"):
        return "rust/target/debug"
    if rt_file_exists("rust/target/release/libsimple_compiler.so"):
        return "rust/target/release"
    "rust/target/debug"

# ------------------------------------------------------------------------------
# Convenience Functions
# ------------------------------------------------------------------------------

fn compile_file(path: text) -> CompileResult:
    val options = CompileOptions__default()
    options.input_files = [path]
    val driver = CompilerDriver__create(options)
    driver.compile()

fn compile_files(paths: [text], mode: CompileMode) -> CompileResult:
    val options = CompileOptions__default()
    options.input_files = paths
    options.mode = mode
    val driver = CompilerDriver__create(options)
    driver.compile()

fn interpret_file(path: text) -> CompileResult:
    compile_files([path], CompileMode.Interpret)

fn jit_file(path: text) -> CompileResult:
    compile_files([path], CompileMode.Jit)

fn aot_file(path: text, output: text) -> CompileResult:
    val options = CompileOptions__default()
    options.input_files = [path]
    options.mode = CompileMode.Aot
    options.output_file = Some(output)
    val driver = CompilerDriver__create(options)
    driver.compile()

fn aot_c_file(path: text, output: text) -> CompileResult:
    """Compile a source file to C++20 output using the MIR C backend."""
    val options = CompileOptions__default()
    options.input_files = [path]
    options.mode = CompileMode.Aot
    options.output_file = Some(output)
    options.backend = "c"
    val driver = CompilerDriver__create(options)
    driver.compile()

fn check_file(path: text) -> CompileResult:
    compile_files([path], CompileMode.Check)

fn parse_sdn_file(path: text) -> CompileResult:
    compile_files([path], CompileMode.Sdn)

extern fn rt_process_run(cmd: text, args: [text]) -> text

fn compile_to_smf(path: text, output: text) -> Result<text, text>:
    """Compile a source file to SMF format using Pure Simple compiler.

    Uses the Pure Simple compiler implementation directly, which works
    in interpreter mode without requiring Rust FFI.
    Returns Ok(output_path) on success or Err(message) on failure.
    """
    val options = CompileOptions__default()
    options.input_files = [path]
    options.output_file = output
    options.mode = CompileMode.Aot
    options.output_format = OutputFormat.Smf

    val driver = CompilerDriver__create(options)
    val result = CompilerDriver__run_compile(driver)

    match result:
        case CompileResult.Success(_):
            Ok(output)
        case _:
            val errors = result.get_errors()
            val error_msg = if errors.len() > 0:
                errors.join("\n")
            else:
                "Compilation failed"
            Err(error_msg)

# Manual ctor wrappers for bootstrap symbol availability
fn CompileContext__create(options: CompileOptions) -> CompileContext:
    # Manual inline construction to avoid missing import table entries for static ctors
    val backend = match options.mode:
        case CompileMode.Interpret:
            val interp_impl = InterpreterBackendImpl.new()
            BackendPort(
                name: "interpreter",
                run_fn: fn(m): interp_impl.process_module(m),
                supports_jit_fn: fn(): false,
                target_triple_fn: fn(): "interpreter"
            )
        case CompileMode.Jit:
            val jit_impl = CompilerBackendImpl__jit()
            BackendPort(
                name: "jit",
                run_fn: fn(m): jit_impl.process_module(m),
                supports_jit_fn: fn(): true,
                target_triple_fn: fn(): "native-jit"
            )
        case CompileMode.Aot:
            val output = options.output_file ?? "a.out"
            val aot_impl = CompilerBackendImpl__aot(output)
            BackendPort(
                name: "aot",
                run_fn: fn(m): aot_impl.process_module(m),
                supports_jit_fn: fn(): false,
                target_triple_fn: fn(): "native-aot"
            )
        case CompileMode.Sdn:
            val sdn_impl = SdnBackendImpl()
            BackendPort(
                name: "sdn",
                run_fn: fn(m): sdn_impl.process_module(m),
                supports_jit_fn: fn(): false,
                target_triple_fn: fn(): "sdn"
            )
        case CompileMode.Check:
            BackendPort(
                name: "check",
                run_fn: fn(m): Ok(BackendResult.Unit),
                supports_jit_fn: fn(): false,
                target_triple_fn: fn(): "check"
            )

    val config = {}
    val extensions = nil  # minimize bootstrap dependencies
    val logger = if options.verbose:
        Logger(level: 10)
    else:
        Logger(level: 0)  # avoid env lookup during bootstrap
    val aop = nil

    CompileContext(
        options: options,
        config: config,
        backend: backend,
        extensions: extensions,
        aop: aop,
        logger: logger,
        sources: [],
        modules: {},
        hir_modules: {},
        mir_modules: {},
        errors: [],
        warnings: [],
        visibility_warnings: []
    )

fn CompilerDriver__create(options: CompileOptions) -> CompilerDriver:
    val ctx = CompileContext__create(options)
    CompilerDriver(ctx: ctx)

# Simple top-level wrapper to invoke the instance compile method without cross-module method resolution
fn CompilerDriver__run_compile(driver: CompilerDriver) -> CompileResult:
    driver.compile()

# ------------------------------------------------------------------------------
# FFI Declarations (driver-specific only)
# ------------------------------------------------------------------------------

extern fn sys_get_args() -> [text]
extern fn rt_env_get(name: text) -> text
extern fn rt_file_exists(path: text) -> bool
extern fn rt_file_write_text(path: text, content: text) -> bool
extern fn rt_dir_create(path: text, recursive: bool) -> bool
extern fn rt_path_join(a: text, b: text) -> text
extern fn rt_path_parent(path: text) -> text

# ============================================================================
# Exports
# ============================================================================

export CheckBackendImpl, CompilerDriver
export find_runtime_lib_dir
export compile_file, compile_files, interpret_file, jit_file, aot_file, aot_c_file, check_file, parse_sdn_file, compile_to_smf
export CompileContext__create, CompilerDriver__create
export CompilerDriver__run_compile

# Re-export types from driver_types for convenience
export use driver_types.{CompileMode, CompileMode__from_text, CompileOptions, CompileOptions__default, CompileResult, SourceFile, CompileContext, OutputFormat, OutputFormat__from_text}
