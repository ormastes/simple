# Incremental Compilation
#
# Hash-based change detection and dependency-aware recompilation.
# Tracks content hashes, modification times, and dependency edges
# to minimize recompilation work.
#
# Port of rust/compiler/src/incremental.rs (410 lines)

export FileHash, IncrementalState, IncrementalConfig

# ============================================================================
# Types
# ============================================================================

struct FileHash:
    path: text
    content_hash: i64
    mtime_ms: i64

struct IncrementalConfig:
    """Configuration for incremental compilation."""
    enabled: bool
    cache_dir: text?
    max_staleness_ms: i64   # Max age before forcing recompile

impl IncrementalConfig:
    static fn default_config() -> IncrementalConfig:
        IncrementalConfig(enabled: true, cache_dir: nil, max_staleness_ms: 3600000)

    static fn disabled() -> IncrementalConfig:
        IncrementalConfig(enabled: false, cache_dir: nil, max_staleness_ms: 0)

# ============================================================================
# Incremental State
# ============================================================================

class IncrementalState:
    """Tracks file hashes and dependencies for change detection."""
    file_hashes: {text: FileHash}
    dependencies: {text: [text]}    # file -> files it depends on
    dependents: {text: [text]}      # file -> files that depend on it
    dirty_files: [text]
    interface_hashes: {text: i64}   # file -> SHB interface hash (for two-level invalidation)

impl IncrementalState:
    static fn create() -> IncrementalState:
        IncrementalState(file_hashes: {}, dependencies: {},
                         dependents: {}, dirty_files: [],
                         interface_hashes: {})

    me register_file(path: text, content: text):
        extern fn rt_hash_text(t: text) -> i64
        extern fn rt_time_millis() -> i64
        val hash = FileHash(path: path, content_hash: rt_hash_text(content),
                            mtime_ms: rt_time_millis())
        # Check if content changed
        if self.file_hashes.contains_key(path):
            val old = self.file_hashes[path]
            if old.content_hash != hash.content_hash:
                self.mark_dirty(path)
        self.file_hashes[path] = hash

    me add_dependency(from_file: text, to_file: text):
        """Record that from_file depends on to_file."""
        if not self.dependencies.contains_key(from_file):
            self.dependencies[from_file] = []
        val deps = self.dependencies[from_file]
        if not deps.contains(to_file):
            self.dependencies[from_file] = deps.push(to_file)

        # Track reverse dependency
        if not self.dependents.contains_key(to_file):
            self.dependents[to_file] = []
        val rev_deps = self.dependents[to_file]
        if not rev_deps.contains(from_file):
            self.dependents[to_file] = rev_deps.push(from_file)

    me mark_dirty(path: text):
        """Mark a file and its transitive dependents as dirty."""
        if self.dirty_files.contains(path):
            return
        self.dirty_files = self.dirty_files.push(path)

        # Cascade to dependents
        if self.dependents.contains_key(path):
            for dep in self.dependents[path]:
                self.mark_dirty(dep)

    fn is_dirty(path: text) -> bool:
        self.dirty_files.contains(path)

    fn get_dirty_files() -> [text]:
        self.dirty_files

    me clear_dirty():
        self.dirty_files = []

    fn needs_recompile(path: text) -> bool:
        """Check if a file needs recompilation."""
        if not self.file_hashes.contains_key(path):
            return true
        self.dirty_files.contains(path)

    # Update the interface hash for a file.
    # Returns true if the hash changed (meaning dependents need recompilation).
    me update_interface_hash(path: text, hash: i64) -> bool:
        if self.interface_hashes.contains_key(path):
            val old_hash = self.interface_hashes[path]
            self.interface_hashes[path] = hash
            if old_hash != hash:
                # Interface changed â€” cascade dirty to dependents
                if self.dependents.contains_key(path):
                    for dep in self.dependents[path]:
                        self.mark_dirty(dep)
                return true
            return false
        self.interface_hashes[path] = hash
        true

    fn get_interface_hash(path: text) -> i64:
        if self.interface_hashes.contains_key(path):
            return self.interface_hashes[path]
        0

    me reset():
        self.file_hashes = {}
        self.dependencies = {}
        self.dependents = {}
        self.dirty_files = []
        self.interface_hashes = {}
