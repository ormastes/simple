# Effect Inference System
#
# Automatic async/sync effect detection based on function body analysis.
# Maps to Lean 4 model in verification/type_inference_compile/src/AsyncEffectInference.lean
#
# Properties (Formally Verified):
# 1. Effect Determinism: Each function has exactly one inferred effect
# 2. Effect Propagation: Calling async function makes caller async
# 3. Suspension Detection: ~=, if~, while~, for~ operators indicate async
# 4. Sync Safety: sync-annotated functions cannot contain suspension
#
# Port of rust/type/src/effects.rs

# ============================================================================
# Core Types
# ============================================================================

enum Effect:
    """Effect annotation for functions."""
    Sync   # Non-suspending, returns T directly
    Async  # May suspend, returns Promise<T>

impl Effect:
    fn is_async() -> bool:
        match self:
            case Async: true
            case _: false

    fn is_sync() -> bool:
        not self.is_async()

    fn to_text() -> text:
        match self:
            case Sync: "sync"
            case Async: "async"

# Effect environment: function name -> inferred effect
# Using Dict<text, Effect> as EffectEnv

# ============================================================================
# Return Wrap Mode (Phase 5: Promise Wrapping)
# ============================================================================

enum ReturnWrapMode:
    """How a return statement should be wrapped."""
    None      # No wrapping (sync function)
    Resolved  # Wrap with Promise.resolved(value)
    Rejected  # Wrap with Promise.rejected(error)

# ============================================================================
# Await Mode (Phase 6: Await Inference)
# ============================================================================

enum AwaitMode:
    """Marker for expressions that need automatic await insertion."""
    None      # No await needed
    Implicit  # Async function call in async-by-default mode
    Explicit  # Explicit suspension (~= operator)

enum TypedAwaitMode:
    """Extended await mode with type information."""
    None           # No await needed
    ImplicitAwait  # Target expects unwrapped type T
    KeepPromise    # Target expects Promise<T>
    ExplicitAwait  # Explicit await (~= operator)

# ============================================================================
# Promise Type Info (Phase 5)
# ============================================================================

struct PromiseTypeInfo:
    """Information about Promise type wrapping for a function."""
    inner_type: text?    # Inner type T in Promise<T>
    is_wrapped: bool     # Whether return type should be Promise-wrapped
    original_type: text? # Original return type before transformation

impl PromiseTypeInfo:
    static fn sync_function(return_type: text?) -> PromiseTypeInfo:
        PromiseTypeInfo(inner_type: return_type, is_wrapped: false, original_type: return_type)

    static fn async_function(return_type: text?) -> PromiseTypeInfo:
        PromiseTypeInfo(inner_type: return_type, is_wrapped: true, original_type: return_type)

# ============================================================================
# Suspension Detection
# ============================================================================

# These functions work on AST node handles (i64 IDs from Rust FFI).
# In pure-Simple mode, they work on Simple AST representations.

struct FunctionInfo:
    """Lightweight function descriptor for effect inference."""
    name: text
    is_sync: bool
    has_async_annotation: bool
    contains_suspension: bool
    called_functions: [text]

fn infer_function_effect(func: FunctionInfo, env: Dict<text, Effect>) -> Effect:
    """Infer the effect of a function based on its body."""
    # Explicit sync annotation
    if func.is_sync:
        return Effect.Sync

    # @async annotation
    if func.has_async_annotation:
        return Effect.Async

    # Suspension operators in body
    if func.contains_suspension:
        return Effect.Async

    # Calls any async function
    for callee in func.called_functions:
        val callee_effect = env.get(callee)
        if callee_effect.? and callee_effect.unwrap().is_async():
            return Effect.Async

    Effect.Sync

# ============================================================================
# Effect Environment Building
# ============================================================================

fn build_effect_env(functions: [FunctionInfo]) -> Dict<text, Effect>:
    """Build initial effect environment with fixed-point iteration."""
    var env: Dict<text, Effect> = {}

    # First pass: explicit annotations
    for func in functions:
        if func.is_sync:
            env[func.name] = Effect.Sync
        elif func.has_async_annotation:
            env[func.name] = Effect.Async

    # Fixed-point iteration for transitive propagation
    infer_mutual_effects(functions, env)

fn infer_mutual_effects(functions: [FunctionInfo], env: mut Dict<text, Effect>) -> Dict<text, Effect>:
    """Fixed-point iteration for mutually recursive functions."""
    val max_iterations = 100
    var iteration = 0

    while iteration < max_iterations:
        var changed = false

        for func in functions:
            if env.contains(func.name):
                continue

            val inferred = infer_function_effect(func, env)
            val old = env.get(func.name)

            if not old.? or old.unwrap() != inferred:
                env[func.name] = inferred
                changed = true

        if not changed:
            break
        iteration = iteration + 1

    env

# ============================================================================
# SCC-Based Effect Propagation (Tarjan)
# ============================================================================

fn propagate_effects_transitive(functions: [FunctionInfo]) -> Dict<text, Effect>:
    """Build effect environment with SCC analysis for mutual recursion.

    1. Find strongly connected components
    2. Process in reverse topological order
    3. All functions in an SCC share same effect (conservatively async if any is)
    """
    var env: Dict<text, Effect> = {}

    # First pass: explicit annotations
    for func in functions:
        if func.is_sync:
            env[func.name] = Effect.Sync
        elif func.has_async_annotation:
            env[func.name] = Effect.Async

    # Build call graph
    val func_names: Dict<text, bool> = {}
    for func in functions:
        func_names[func.name] = true

    var call_graph: Dict<text, [text]> = {}
    for func in functions:
        var callees: [text] = []
        for callee in func.called_functions:
            if func_names.contains(callee):
                callees = callees.push(callee)
        call_graph[func.name] = callees

    # Find SCCs using Tarjan's algorithm
    val sccs = tarjan_scc(call_graph)

    # Build function lookup
    var func_map: Dict<text, FunctionInfo> = {}
    for func in functions:
        func_map[func.name] = func

    # Process SCCs
    for scc in sccs:
        val any_explicit_async = scc.any(\name: env.get(name)?.is_async() ?? false)

        val any_suspension = scc.any(\name:
            val f = func_map.get(name)
            if f.?:
                val func = f.unwrap()
                not func.is_sync and func.contains_suspension
            else:
                false
        )

        val any_calls_async = scc.any(\name:
            val callees = call_graph.get(name) ?? []
            callees.any(\callee:
                not scc.contains(callee) and (env.get(callee)?.is_async() ?? false)
            )
        )

        val scc_effect = if any_explicit_async or any_suspension or any_calls_async:
            Effect.Async
        else:
            Effect.Sync

        for name in scc:
            if not env.contains(name):
                env[name] = scc_effect

    env

# Tarjan SCC (reusable algorithm)
fn tarjan_scc(graph: Dict<text, [text]>) -> [[text]]:
    """Find strongly connected components using Tarjan's algorithm."""
    var index_counter = 0
    var stack: [text] = []
    var on_stack: Dict<text, bool> = {}
    var indices: Dict<text, i64> = {}
    var lowlinks: Dict<text, i64> = {}
    var result: [[text]] = []

    for node in graph.keys():
        if not indices.contains(node):
            tarjan_dfs(node, graph, index_counter, stack, on_stack,
                       indices, lowlinks, result)

    result

fn tarjan_dfs(v: text, graph: Dict<text, [text]>,
              index_counter: mut i64, stack: mut [text],
              on_stack: mut Dict<text, bool>,
              indices: mut Dict<text, i64>, lowlinks: mut Dict<text, i64>,
              result: mut [[text]]):
    indices[v] = index_counter
    lowlinks[v] = index_counter
    index_counter = index_counter + 1
    stack.push(v)
    on_stack[v] = true

    val successors = graph.get(v) ?? []
    for w in successors:
        if not indices.contains(w):
            tarjan_dfs(w, graph, index_counter, stack, on_stack,
                       indices, lowlinks, result)
            val w_low = lowlinks[w]
            if w_low < lowlinks[v]:
                lowlinks[v] = w_low
        elif on_stack.get(w) ?? false:
            val w_idx = indices[w]
            if w_idx < lowlinks[v]:
                lowlinks[v] = w_idx

    if lowlinks[v] == indices[v]:
        var scc: [text] = []
        while true:
            val w = stack.pop()
            on_stack[w] = false
            scc = scc.push(w)
            if w == v:
                break
        result = result.push(scc)

# ============================================================================
# Validation
# ============================================================================

fn validate_sync_constraint(func: FunctionInfo) -> Result<(), text>:
    """Validate that a sync function doesn't contain suspension operators."""
    if func.is_sync and func.contains_suspension:
        return Err("Sync function '{func.name}' cannot contain suspension operators (~=, await, etc.)")
    Ok(())

fn validate_suspension_context(func: FunctionInfo, env: Dict<text, Effect>) -> Result<(), text>:
    """Validate that suspension operators are only used in async contexts."""
    val effect = infer_function_effect(func, env)
    if effect.is_sync() and func.contains_suspension:
        return Err("Sync function '{func.name}' cannot use suspension operators (~=, if~, while~, for~)")
    Ok(())

# ============================================================================
# Promise Type Operations
# ============================================================================

fn needs_promise_wrapping(func: FunctionInfo, env: Dict<text, Effect>) -> bool:
    """Check if function's return type needs Promise wrapping."""
    infer_function_effect(func, env).is_async()

fn get_return_wrap_mode(func: FunctionInfo, env: Dict<text, Effect>) -> ReturnWrapMode:
    """Determine how a return statement should be wrapped."""
    if needs_promise_wrapping(func, env):
        ReturnWrapMode.Resolved
    else:
        ReturnWrapMode.None

fn is_promise_type(type_name: text) -> bool:
    """Check if a type name represents a Promise type."""
    type_name.starts_with("Promise<") or type_name == "Promise"

fn wrap_in_promise(type_name: text) -> text:
    """Wrap a type in Promise<T> if not already wrapped."""
    if is_promise_type(type_name):
        type_name
    else:
        "Promise<{type_name}>"

fn unwrap_promise(type_name: text) -> text?:
    """Extract inner type from Promise<T>."""
    if type_name.starts_with("Promise<") and type_name.ends_with(">"):
        Some(type_name[8:type_name.len() - 1])
    else:
        nil

# ============================================================================
# Await Inference
# ============================================================================

fn needs_await(callee_name: text, env: Dict<text, Effect>) -> AwaitMode:
    """Check if calling a function needs automatic await insertion."""
    val effect = env.get(callee_name)
    if effect.? and effect.unwrap().is_async():
        AwaitMode.Implicit
    else:
        AwaitMode.None

fn needs_await_typed(callee_name: text, env: Dict<text, Effect>, expected_type: text?) -> TypedAwaitMode:
    """Check if expression needs await based on target type."""
    val effect = env.get(callee_name)
    if not effect.? or effect.unwrap().is_sync():
        return TypedAwaitMode.None

    # Expression is async call - check expected type
    match expected_type:
        case Some(expected):
            if is_promise_type(expected):
                TypedAwaitMode.KeepPromise
            else:
                TypedAwaitMode.ImplicitAwait
        case _:
            TypedAwaitMode.ImplicitAwait

fn infer_promise_type_info(func: FunctionInfo, env: Dict<text, Effect>) -> PromiseTypeInfo:
    """Infer Promise type information for a function."""
    val effect = infer_function_effect(func, env)
    match effect:
        case Sync: PromiseTypeInfo.sync_function(nil)
        case Async: PromiseTypeInfo.async_function(nil)

export Effect, ReturnWrapMode, AwaitMode, TypedAwaitMode
export PromiseTypeInfo, FunctionInfo
export infer_function_effect, build_effect_env, infer_mutual_effects
export propagate_effects_transitive, tarjan_scc
export validate_sync_constraint, validate_suspension_context
export needs_promise_wrapping, get_return_wrap_mode
export is_promise_type, wrap_in_promise, unwrap_promise
export needs_await, needs_await_typed, infer_promise_type_info
