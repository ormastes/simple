# Bidirectional Type Checking
#
# Extends expression inference with expected type propagation.
# Implements bidirectional type checking for improved inference and error messages.
#
# Based on "Complete and Easy Bidirectional Typechecking for Higher-Rank Polymorphism"
# (Dunfield & Krishnaswami, 2013)
#
# Two modes:
# - Synthesize: Infer type from expression (bottom-up)
# - Check: Verify expression against expected type (top-down)

from inference.types import {Type, TypeVarId, UnifyError}
from inference.infer import {InferenceEngine}
from ast import {Expr, BinOp, UnaryOp, Argument, LambdaParam, Pattern, Block}
from compiler.type_system.checker import {TypeError}
from compiler.type_system.expr_infer import {infer_expr as synthesize_expr}
from compiler.type_system.module_check import {ast_type_to_inference_type_engine}

# ============================================================================
# Inference Mode
# ============================================================================

enum InferMode:
    """Type inference mode for bidirectional checking.

    - Synthesize: Infer type from expression (normal inference)
    - Check: Check expression against expected type (propagate downward)
    """
    Synthesize
    Check(expected: Type)

impl InferMode:
    fn is_synthesize() -> bool:
        match self:
            case Synthesize: true
            case Check(_): false

    fn is_check() -> bool:
        match self:
            case Synthesize: false
            case Check(_): true

    fn expected_type() -> Type?:
        match self:
            case Synthesize: nil
            case Check(ty): Some(ty)

# ============================================================================
# Bidirectional Expression Inference
# ============================================================================

fn infer_expr_bidir(engine: InferenceEngine, expr: Expr, env: Dict<text, Type>,
                    mode: InferMode) -> Result<Type, TypeError>:
    """Infer type of expression with bidirectional type checking.

    - In Synthesize mode: Infer type bottom-up (normal inference)
    - In Check mode: Verify against expected type top-down
    """

    match mode:
        case Synthesize:
            # No expected type - use normal inference
            synthesize_expr(engine, expr, env)

        case Check(expected):
            # Expected type available - propagate downward
            check_expr(engine, expr, expected, env)

# ============================================================================
# Check Mode (Top-Down Propagation)
# ============================================================================

fn check_expr(engine: InferenceEngine, expr: Expr, expected: Type,
              env: Dict<text, Type>) -> Result<Type, TypeError>:
    """Check expression against expected type (top-down).

    Propagates expected type to subexpressions for better inference.
    """

    match expr:
        # ====================================================================
        # Literals with Expected Types
        # ====================================================================
        case Integer(n):
            # Use expected type for integer literal if it's an integer type
            match expected:
                case Int(bits, signed):
                    # Check if literal fits in expected type
                    # For now, assume it fits
                    Ok(expected)
                case Var(_):
                    # Expected is type variable - unify with i64
                    val inferred = Type.Int(bits: 64, signed: true)
                    engine.unify(inferred, expected)?
                    Ok(expected)
                case _:
                    # Expected is not an integer type - synthesize and check
                    val inferred = synthesize_expr(engine, expr, env)?
                    engine.unify(inferred, expected)?
                    Ok(expected)

        case Float(f):
            # Use expected type for float literal
            match expected:
                case Float(bits):
                    Ok(expected)
                case Var(_):
                    val inferred = Type.Float(bits: 64)
                    engine.unify(inferred, expected)?
                    Ok(expected)
                case _:
                    val inferred = synthesize_expr(engine, expr, env)?
                    engine.unify(inferred, expected)?
                    Ok(expected)

        # ====================================================================
        # Lambda with Expected Function Type
        # ====================================================================
        case Lambda(params, body, move_mode, capture_all):
            # Extract parameter types from expected function type
            match expected:
                case Function(expected_params, expected_ret):
                    # Use expected parameter types
                    check_lambda(engine, params, body, expected_params, expected_ret, env)

                case Var(_):
                    # Expected is type variable - create function type and unify
                    val lambda_ty = synthesize_lambda(engine, params, body, env)?
                    engine.unify(lambda_ty, expected)?
                    Ok(expected)

                case _:
                    # Expected is not a function - synthesize and check
                    val lambda_ty = synthesize_lambda(engine, params, body, env)?
                    engine.unify(lambda_ty, expected)?
                    Ok(expected)

        # ====================================================================
        # If Expression with Expected Type
        # ====================================================================
        case IfExpr(let_pattern, condition, then_branch, else_branch):
            # Check condition is bool
            val cond_ty = synthesize_expr(engine, condition, env)?
            engine.unify(cond_ty, Type.Bool)?

            # Check both branches against expected type
            val then_ty = check_expr(engine, then_branch, expected, env)?

            if else_branch.?:
                val else_ty = check_expr(engine, else_branch.unwrap(), expected, env)?
                engine.unify(then_ty, else_ty)?

            Ok(expected)

        # ====================================================================
        # Match Expression with Expected Type
        # ====================================================================
        case MatchCase(subject, arms):
            # Synthesize subject type
            val subject_ty = synthesize_expr(engine, subject, env)?

            # Check each arm against expected type
            for arm in arms:
                # TODO: Check pattern, bind variables
                # Check arm body against expected
                # Need to convert Block to Expr or handle differently
                pass

            Ok(expected)

        # ====================================================================
        # Array Literal with Expected Type
        # ====================================================================
        case Array(elements):
            # Extract element type from expected array type
            match expected:
                case Array(elem_ty, _):
                    # Check each element against expected element type
                    for elem in elements:
                        val _ = check_expr(engine, elem, elem_ty, env)?
                    Ok(expected)

                case Var(_):
                    # Expected is type variable - synthesize and unify
                    val arr_ty = synthesize_array(engine, elements, env)?
                    engine.unify(arr_ty, expected)?
                    Ok(expected)

                case _:
                    # Expected is not an array - synthesize and check
                    val arr_ty = synthesize_array(engine, elements, env)?
                    engine.unify(arr_ty, expected)?
                    Ok(expected)

        # ====================================================================
        # Tuple Literal with Expected Type
        # ====================================================================
        case Tuple(elements):
            match expected:
                case Tuple(expected_elems):
                    # Check each element against expected type
                    if elements.len() != expected_elems.len():
                        return Err(TypeError.Other(
                            "tuple arity mismatch: expected {expected_elems.len()}, got {elements.len()}"
                        ))

                    var i = 0
                    while i < elements.len():
                        val _ = check_expr(engine, elements[i], expected_elems[i], env)?
                        i = i + 1

                    Ok(expected)

                case Var(_):
                    val tup_ty = synthesize_tuple(engine, elements, env)?
                    engine.unify(tup_ty, expected)?
                    Ok(expected)

                case _:
                    val tup_ty = synthesize_tuple(engine, elements, env)?
                    engine.unify(tup_ty, expected)?
                    Ok(expected)

        # ====================================================================
        # Dict Literal with Expected Type
        # ====================================================================
        case Dict(pairs):
            match expected:
                case Dict(expected_key, expected_value):
                    # Check each key-value pair
                    for (k, v) in pairs:
                        val _ = check_expr(engine, k, expected_key, env)?
                        val _ = check_expr(engine, v, expected_value, env)?

                    Ok(expected)

                case Var(_):
                    val dict_ty = synthesize_dict(engine, pairs, env)?
                    engine.unify(dict_ty, expected)?
                    Ok(expected)

                case _:
                    val dict_ty = synthesize_dict(engine, pairs, env)?
                    engine.unify(dict_ty, expected)?
                    Ok(expected)

        # ====================================================================
        # Function Call with Expected Return Type
        # ====================================================================
        case Call(callee, args):
            # Synthesize function type
            val callee_ty = synthesize_expr(engine, callee, env)?

            # Create expected function type with expected return
            var param_types: [Type] = []
            for arg in args:
                param_types = param_types.push(engine.fresh_var())

            val expected_fn_ty = Type.Function(params: param_types, ret: expected)

            # Unify with callee type
            engine.unify(callee_ty, expected_fn_ty)?

            # Check arguments against inferred parameter types
            var i = 0
            while i < args.len():
                val _ = check_expr(engine, args[i].value, param_types[i], env)?
                i = i + 1

            Ok(expected)

        # ====================================================================
        # Default: Synthesize and Check
        # ====================================================================
        case _:
            # For other expressions, synthesize type and check compatibility
            val inferred = synthesize_expr(engine, expr, env)?
            engine.unify(inferred, expected)?
            Ok(expected)

# ============================================================================
# Helper Functions for Synthesis
# ============================================================================

fn synthesize_lambda(engine: InferenceEngine, params: [LambdaParam], body: Expr,
                     env: Dict<text, Type>) -> Result<Type, TypeError>:
    """Synthesize lambda type without expected type."""
    # Create fresh variables for parameters
    var param_types: [Type] = []
    var new_env = env

    for param in params:
        val param_ty = if param.ty.?:
            ast_type_to_inference_type_engine(param.ty.unwrap(), engine)
        else:
            engine.fresh_var()

        param_types = param_types.push(param_ty)
        new_env[param.name] = param_ty

    # Synthesize body type
    val body_ty = synthesize_expr(engine, body, new_env)?

    Ok(Type.Function(params: param_types, ret: body_ty))

fn check_lambda(engine: InferenceEngine, params: [LambdaParam], body: Expr,
                expected_params: [Type], expected_ret: Type,
                env: Dict<text, Type>) -> Result<Type, TypeError>:
    """Check lambda against expected function type."""

    # Check parameter count
    if params.len() != expected_params.len():
        return Err(TypeError.Other(
            "lambda parameter count mismatch: expected {expected_params.len()}, got {params.len()}"
        ))

    # Bind parameters with expected types
    var new_env = env
    var i = 0
    while i < params.len():
        new_env[params[i].name] = expected_params[i]
        i = i + 1

    # Check body against expected return type
    val body_ty = check_expr(engine, body, expected_ret, new_env)?

    Ok(Type.Function(params: expected_params, ret: expected_ret))

fn synthesize_array(engine: InferenceEngine, elements: [Expr],
                    env: Dict<text, Type>) -> Result<Type, TypeError>:
    """Synthesize array type without expected type."""
    if not elements.?:
        val elem_ty = engine.fresh_var()
        return Ok(Type.Array(elem: elem_ty, size: nil))

    # Infer first element type
    val first_ty = synthesize_expr(engine, elements[0], env)?

    # Unify all other elements
    var i = 1
    while i < elements.len():
        val elem_ty = synthesize_expr(engine, elements[i], env)?
        engine.unify(first_ty, elem_ty)?
        i = i + 1

    Ok(Type.Array(elem: engine.resolve(first_ty), size: nil))

fn synthesize_tuple(engine: InferenceEngine, elements: [Expr],
                    env: Dict<text, Type>) -> Result<Type, TypeError>:
    """Synthesize tuple type without expected type."""
    var elem_types: [Type] = []

    for elem in elements:
        elem_types = elem_types.push(synthesize_expr(engine, elem, env)?)

    Ok(Type.Tuple(elements: elem_types))

fn synthesize_dict(engine: InferenceEngine, pairs: [(Expr, Expr)],
                   env: Dict<text, Type>) -> Result<Type, TypeError>:
    """Synthesize dict type without expected type."""
    if not pairs.?:
        val key_ty = engine.fresh_var()
        val value_ty = engine.fresh_var()
        return Ok(Type.Dict(key: key_ty, value: value_ty))

    # Infer first pair types
    val (first_key, first_value) = pairs[0]
    val key_ty = synthesize_expr(engine, first_key, env)?
    val value_ty = synthesize_expr(engine, first_value, env)?

    # Unify all other pairs
    var i = 1
    while i < pairs.len():
        val (k, v) = pairs[i]
        val k_ty = synthesize_expr(engine, k, env)?
        val v_ty = synthesize_expr(engine, v, env)?
        engine.unify(key_ty, k_ty)?
        engine.unify(value_ty, v_ty)?
        i = i + 1

    Ok(Type.Dict(key: engine.resolve(key_ty), value: engine.resolve(value_ty)))

# ============================================================================
# Bidirectional Statement Checking
# ============================================================================

fn check_stmt_bidir(engine: InferenceEngine, stmt: Node, env: Dict<text, Type>,
                    current_fn_ret_type: Type?) -> Result<Dict<text, Type>, TypeError>:
    """Type check statement with bidirectional inference.

    Uses expected types where available (e.g., type annotations).
    """
    # For now, delegate to regular statement checking
    # TODO: Implement bidirectional variants for let bindings, etc.
    compiler.type_system.stmt_check.check_stmt(engine, stmt, env, current_fn_ret_type)

# ============================================================================
# Public API
# ============================================================================

fn infer_with_expected(engine: InferenceEngine, expr: Expr,
                       expected: Type?, env: Dict<text, Type>) -> Result<Type, TypeError>:
    """Convenience function for bidirectional inference.

    If expected type is provided, use Check mode.
    Otherwise, use Synthesize mode.
    """
    val mode = if expected.?:
        InferMode.Check(expected.unwrap())
    else:
        InferMode.Synthesize

    infer_expr_bidir(engine, expr, env, mode)

# ============================================================================
# Exports
# ============================================================================

export InferMode
export infer_expr_bidir, check_expr
export synthesize_lambda, check_lambda
export synthesize_array, synthesize_tuple, synthesize_dict
export check_stmt_bidir
export infer_with_expected
