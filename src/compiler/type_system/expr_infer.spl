# Expression Type Inference
#
# Implements expression-level type inference using Hindley-Milner algorithm.
# Port of rust/type/src/checker_infer.rs::infer_expr()
#
# This module extends TypeChecker with expression inference capabilities.

from inference.types import {Type, TypeVarId, UnifyError, InferError}
from inference.infer import {InferenceEngine}
from ast import {Expr, BinOp, UnaryOp, FStringPart, MacroArg}
from compiler.type_system.checker import {TypeError}

# ============================================================================
# Expression Inference (Extension to TypeChecker)
# ============================================================================

# NOTE: These methods should be added to the TypeChecker class in checker.spl
# For now, we define them as standalone functions that can be integrated.

fn infer_expr(engine: InferenceEngine, expr: Expr, env: Dict<text, Type>) -> Result<Type, TypeError>:
    """Infer type of an expression using Hindley-Milner algorithm.

    Port of rust/type/src/checker_infer.rs::infer_expr()
    """
    match expr:
        # ====================================================================
        # Literals
        # ====================================================================
        case Integer(_):
            Ok(Type.Int(bits: 64, signed: true))

        case Float(_):
            Ok(Type.Float(bits: 64))

        case TypedInteger(_, suffix):
            # Use type suffix to determine exact integer type
            # suffix encoding: bits + signed flag
            Ok(Type.Int(bits: 64, signed: true))  # TODO: Decode suffix

        case TypedFloat(_, suffix):
            # Use type suffix to determine exact float type
            Ok(Type.Float(bits: 64))  # TODO: Decode suffix

        case String(_):
            Ok(Type.Str)

        case TypedString(_, _):
            Ok(Type.Str)

        case Bool(_):
            Ok(Type.Bool)

        case Nil:
            Ok(Type.Nil)

        case Symbol(_):
            # Symbol literals have a fresh type
            Ok(engine.fresh_var())

        # ====================================================================
        # FString (interpolated strings)
        # ====================================================================
        case FString(parts):
            # Infer each interpolated expression
            # Allow undefined identifiers in placeholders (for template.with pattern)
            for part in parts:
                match part:
                    case ExprPart(e):
                        val result = infer_expr(engine, e, env)
                        match result:
                            case Ok(_):
                                pass  # Continue checking
                            case Err(TypeError.Undefined(_)):
                                # Ignore undefined in FString placeholders
                                # They'll be provided via .with method
                                pass
                            case Err(other_err):
                                return Err(other_err)
                    case Literal(_):
                        pass  # No type checking needed for literals

            Ok(Type.Str)

        # ====================================================================
        # Identifiers
        # ====================================================================
        case Identifier(name):
            # Handle FFI calls: @rt_function_name - strip @ prefix for lookup
            val lookup_name = if name.starts_with("@"):
                name[1:]
            else:
                name

            if env.contains(lookup_name):
                Ok(env[lookup_name])
            else:
                Err(TypeError.Undefined("undefined identifier: {name}"))

        case Path(segments):
            # Multi-segment path (e.g., module::Type)
            # For now, return fresh var - full resolution needs module system
            Ok(engine.fresh_var())

        # ====================================================================
        # Binary Operators
        # ====================================================================
        case Binary(op, left, right):
            infer_binary(engine, op, left, right, env)

        # ====================================================================
        # Unary Operators
        # ====================================================================
        case Unary(op, operand):
            infer_unary(engine, op, operand, env)

        # ====================================================================
        # Function Calls
        # ====================================================================
        case Call(callee, args):
            infer_call(engine, callee, args, env)

        case MethodCall(receiver, method, args):
            infer_method_call(engine, receiver, method, args, env)

        # ====================================================================
        # Lambdas
        # ====================================================================
        case Lambda(params, body, move_mode, capture_all):
            infer_lambda(engine, params, body, env)

        # ====================================================================
        # Control Flow
        # ====================================================================
        case IfExpr(let_pattern, condition, then_branch, else_branch):
            infer_if(engine, condition, then_branch, else_branch, env)

        case MatchCase(subject, arms):
            infer_match(engine, subject, arms, env)

        # ====================================================================
        # Collections
        # ====================================================================
        case Array(elements):
            infer_array(engine, elements, env)

        case ArrayRepeat(value, count):
            val value_ty = infer_expr(engine, value, env)?
            val count_ty = infer_expr(engine, count, env)?
            engine.unify(count_ty, Type.Int(bits: 64, signed: true))?
            Ok(Type.Array(elem: value_ty, size: nil))

        case VecLiteral(elements):
            # Same as array for type inference purposes
            infer_array(engine, elements, env)

        case Tuple(elements):
            infer_tuple(engine, elements, env)

        case Dict(pairs):
            infer_dict(engine, pairs, env)

        # ====================================================================
        # Field and Index Access
        # ====================================================================
        case FieldAccess(receiver, field):
            infer_field_access(engine, receiver, field, env)

        case Index(receiver, index):
            infer_index_access(engine, receiver, index, env)

        case TupleIndex(receiver, index):
            # Tuple indexing with literal index
            val recv_ty = infer_expr(engine, receiver, env)?
            match engine.resolve(recv_ty):
                case Tuple(elems):
                    if index >= 0 and index < elems.len():
                        Ok(elems[index])
                    else:
                        Err(TypeError.Other("tuple index out of bounds"))
                case _:
                    # Not a tuple - return fresh var
                    Ok(engine.fresh_var())

        case Slice(receiver, start, end, step):
            # Slicing returns same type as receiver (for arrays/strings)
            val recv_ty = infer_expr(engine, receiver, env)?

            # Check slice indices are integers
            if start.?:
                val start_ty = infer_expr(engine, start.unwrap(), env)?
                engine.unify(start_ty, Type.Int(bits: 64, signed: true))?
            if end.?:
                val end_ty = infer_expr(engine, end.unwrap(), env)?
                engine.unify(end_ty, Type.Int(bits: 64, signed: true))?
            if step.?:
                val step_ty = infer_expr(engine, step.unwrap(), env)?
                engine.unify(step_ty, Type.Int(bits: 64, signed: true))?

            Ok(recv_ty)

        # ====================================================================
        # Ranges
        # ====================================================================
        case Range(start, end, bound):
            # Infer range bounds
            if start.?:
                val _ = infer_expr(engine, start.unwrap(), env)?
            if end.?:
                val _ = infer_expr(engine, end.unwrap(), env)?

            # Range type is a fresh variable for now
            # Full implementation needs Range<T> type
            Ok(engine.fresh_var())

        # ====================================================================
        # List/Dict Comprehensions
        # ====================================================================
        case ListComprehension(expr, pattern, iterable, condition):
            # Infer iterable type
            val _ = infer_expr(engine, iterable, env)?

            # TODO: Bind pattern variables

            # Infer condition
            if condition.?:
                val cond_ty = infer_expr(engine, condition.unwrap(), env)?
                engine.unify(cond_ty, Type.Bool)?

            # Infer element expression
            val elem_ty = infer_expr(engine, expr, env)?

            Ok(Type.Array(elem: elem_ty, size: nil))

        case DictComprehension(key, value, pattern, iterable, condition):
            # Similar to list comprehension but returns dict
            val _ = infer_expr(engine, iterable, env)?

            if condition.?:
                val cond_ty = infer_expr(engine, condition.unwrap(), env)?
                engine.unify(cond_ty, Type.Bool)?

            val key_ty = infer_expr(engine, key, env)?
            val value_ty = infer_expr(engine, value, env)?

            Ok(Type.Dict(key: key_ty, value: value_ty))

        # ====================================================================
        # Struct Initialization
        # ====================================================================
        case StructInit(name, fields):
            # Infer each field expression
            for (field_name, field_expr) in fields:
                val _ = infer_expr(engine, field_expr, env)?

            # Return named type - full resolution needs struct definition
            Ok(Type.Named(name))

        # ====================================================================
        # Concurrency
        # ====================================================================
        case Spawn(expr):
            # Spawn returns a future/thread handle
            val expr_ty = infer_expr(engine, expr, env)?
            # Return Future<T> or similar
            Ok(Type.Generic(base: "Future", args: [expr_ty]))

        case Go(args, params, body):
            # Go block returns fresh var for now
            Ok(engine.fresh_var())

        case Await(expr):
            # Await unwraps Future<T> to T
            val expr_ty = infer_expr(engine, expr, env)?
            match engine.resolve(expr_ty):
                case Generic(base, args):
                    if base == "Future" and args.?:
                        Ok(args[0])
                    else:
                        Ok(engine.fresh_var())
                case _:
                    Ok(engine.fresh_var())

        case Yield(value):
            if value.?:
                infer_expr(engine, value.unwrap(), env)
            else:
                Ok(Type.Unit)

        # ====================================================================
        # Memory Operations
        # ====================================================================
        case New(kind, expr):
            val expr_ty = infer_expr(engine, expr, env)?
            # New creates a pointer to the type
            match kind:
                case Borrow:
                    Ok(Type.Borrow(inner: expr_ty))
                case BorrowMut:
                    Ok(Type.BorrowMut(inner: expr_ty))
                case _:
                    # Other pointer kinds - return generic pointer for now
                    Ok(engine.fresh_var())

        # ====================================================================
        # Type Casts
        # ====================================================================
        case Cast(expr, target_type):
            # Type annotation - just return the target type
            val _ = infer_expr(engine, expr, env)?
            # TODO: Convert AST Type to inference Type
            Ok(engine.fresh_var())

        # ====================================================================
        # Optional/Result Operations
        # ====================================================================
        case Try(expr):
            # Try operator (?) unwraps Result<T, E> to T
            val expr_ty = infer_expr(engine, expr, env)?
            match engine.resolve(expr_ty):
                case Result(ok, err):
                    Ok(ok)
                case Optional(inner):
                    Ok(inner)
                case _:
                    # Not a Result/Optional - return fresh var
                    Ok(engine.fresh_var())

        case ExistsCheck(expr):
            # .? operator always returns bool
            val _ = infer_expr(engine, expr, env)?
            Ok(Type.Bool)

        case UnwrapOr(expr, default):
            # expr ?? default - returns T from Option<T> or default
            val expr_ty = infer_expr(engine, expr, env)?
            val default_ty = infer_expr(engine, default, env)?

            # Unify with default type
            engine.unify(expr_ty, default_ty)?

            Ok(engine.resolve(expr_ty))

        case UnwrapElse(expr, fallback_fn):
            # Similar to UnwrapOr but with function
            val expr_ty = infer_expr(engine, expr, env)?
            val _ = infer_expr(engine, fallback_fn, env)?

            match engine.resolve(expr_ty):
                case Optional(inner):
                    Ok(inner)
                case _:
                    Ok(engine.fresh_var())

        case UnwrapOrReturn(expr):
            # Unwrap or early return
            val expr_ty = infer_expr(engine, expr, env)?
            match engine.resolve(expr_ty):
                case Optional(inner):
                    Ok(inner)
                case Result(ok, _):
                    Ok(ok)
                case _:
                    Ok(engine.fresh_var())

        case Coalesce(expr, default):
            # Same as UnwrapOr
            val expr_ty = infer_expr(engine, expr, env)?
            val default_ty = infer_expr(engine, default, env)?
            engine.unify(expr_ty, default_ty)?
            Ok(engine.resolve(expr_ty))

        case OptionalChain(expr, field):
            # expr?.field returns Option<FieldType>
            val _ = infer_expr(engine, expr, env)?
            # Field type lookup needs struct definitions
            val field_ty = engine.fresh_var()
            Ok(Type.Optional(inner: field_ty))

        case OptionalMethodCall(receiver, method, args):
            # receiver?.method() returns Option<ReturnType>
            val _ = infer_expr(engine, receiver, env)?
            for arg in args:
                val _ = infer_expr(engine, arg.value, env)?

            val ret_ty = engine.fresh_var()
            Ok(Type.Optional(inner: ret_ty))

        # ====================================================================
        # Cast Operations
        # ====================================================================
        case CastOr(expr, target_type, default):
            # Cast with default value
            val _ = infer_expr(engine, expr, env)?
            val _ = infer_expr(engine, default, env)?
            # TODO: Convert target_type from AST
            Ok(engine.fresh_var())

        case CastElse(expr, target_type, fallback_fn):
            val _ = infer_expr(engine, expr, env)?
            val _ = infer_expr(engine, fallback_fn, env)?
            Ok(engine.fresh_var())

        case CastOrReturn(expr, target_type):
            val _ = infer_expr(engine, expr, env)?
            Ok(engine.fresh_var())

        # ====================================================================
        # Macros
        # ====================================================================
        case MacroInvocation(name, args):
            infer_macro(engine, name, args, env)

        # ====================================================================
        # Spread Operators
        # ====================================================================
        case Spread(expr):
            # Spread preserves the array type
            infer_expr(engine, expr, env)

        case DictSpread(expr):
            # Dict spread preserves the dict type
            infer_expr(engine, expr, env)

        # ====================================================================
        # Functional Update
        # ====================================================================
        case FunctionalUpdate(target, method, args):
            # Returns same type as target
            val target_ty = infer_expr(engine, target, env)?
            for arg in args:
                val _ = infer_expr(engine, arg.value, env)?
            Ok(target_ty)

        # ====================================================================
        # Contract/Verification Expressions
        # ====================================================================
        case ContractResult:
            # Result placeholder in contracts
            Ok(engine.fresh_var())

        case ContractOld(expr):
            # Old value in postconditions - same type as expr
            infer_expr(engine, expr, env)

        case Forall(pattern, range, predicate):
            val _ = infer_expr(engine, range, env)?
            val pred_ty = infer_expr(engine, predicate, env)?
            engine.unify(pred_ty, Type.Bool)?
            Ok(Type.Bool)

        case Exists(pattern, range, predicate):
            val _ = infer_expr(engine, range, env)?
            val pred_ty = infer_expr(engine, predicate, env)?
            engine.unify(pred_ty, Type.Bool)?
            Ok(Type.Bool)

        # ====================================================================
        # Block Expressions
        # ====================================================================
        case DoBlock(stmts):
            # Do block returns type of last statement
            # For now, return fresh var (needs statement inference)
            Ok(engine.fresh_var())

        # ====================================================================
        # Math/ML Extensions
        # ====================================================================
        case GridLiteral(rows, device):
            # Grid literal is a 2D array/tensor
            # Infer element type from first element
            if rows.? and rows[0].?:
                val first_elem_ty = infer_expr(engine, rows[0][0], env)?
                Ok(Type.Array(elem: Type.Array(elem: first_elem_ty, size: nil), size: nil))
            else:
                Ok(engine.fresh_var())

        case TensorLiteral(dtype, dims, mode, device):
            # Tensor type - use dtype and dimensions
            # For now, return generic Tensor type
            Ok(Type.Named("Tensor"))

        case BlockExpr(kind, payload):
            # Math blocks and other special blocks
            Ok(engine.fresh_var())

        # ====================================================================
        # I18n
        # ====================================================================
        case I18nString(_, _):
            Ok(Type.Str)

        case I18nTemplate(_, _, _):
            Ok(Type.Str)

        case I18nRef(_):
            Ok(Type.Str)

        # ====================================================================
        # Fallback
        # ====================================================================
        case _:
            # Unsupported expression type - return fresh variable
            Ok(engine.fresh_var())

# ============================================================================
# Binary Operators
# ============================================================================

fn infer_binary(engine: InferenceEngine, op: BinOp, left: Expr, right: Expr,
                env: Dict<text, Type>) -> Result<Type, TypeError>:
    """Infer type of binary operation."""
    val left_ty = infer_expr(engine, left, env)?
    val right_ty = infer_expr(engine, right, env)?

    match op:
        # Arithmetic operators: unify operands, return numeric type
        case Add | Sub | Mul | Div | Mod | Pow | MatMul:
            engine.unify(left_ty, right_ty)?
            Ok(engine.resolve(left_ty))

        # Comparison operators: unify operands, return bool
        case Eq | NotEq | Lt | Gt | LtEq | GtEq:
            engine.unify(left_ty, right_ty)?
            Ok(Type.Bool)

        # Logical operators: both operands bool, return bool
        case And | Or | AndSuspend | OrSuspend:
            engine.unify(left_ty, Type.Bool)?
            engine.unify(right_ty, Type.Bool)?
            Ok(Type.Bool)

        # Bitwise operators: both operands int, return int
        case BitAnd | BitOr | BitXor | ShiftLeft | ShiftRight:
            engine.unify(left_ty, Type.Int(bits: 64, signed: true))?
            engine.unify(right_ty, Type.Int(bits: 64, signed: true))?
            Ok(Type.Int(bits: 64, signed: true))

        # Is and In operators: return bool
        case Is | In | NotIn:
            Ok(Type.Bool)

        # Pipe forward: x |> f - return function result type
        case PipeForward:
            match engine.resolve(right_ty):
                case Function(params, ret):
                    Ok(ret)
                case _:
                    # Not a function - return fresh var
                    Ok(engine.fresh_var())

        # Parallel operator: returns tuple of both results
        case Parallel:
            Ok(Type.Tuple(elements: [left_ty, right_ty]))

        case _:
            # Unknown operator - return fresh var
            Ok(engine.fresh_var())

# ============================================================================
# Unary Operators
# ============================================================================

fn infer_unary(engine: InferenceEngine, op: UnaryOp, operand: Expr,
               env: Dict<text, Type>) -> Result<Type, TypeError>:
    """Infer type of unary operation."""
    val operand_ty = infer_expr(engine, operand, env)?

    match op:
        case Neg:
            # Negation: operand must be numeric
            engine.unify(operand_ty, Type.Int(bits: 64, signed: true))?
            Ok(Type.Int(bits: 64, signed: true))

        case Not:
            # Logical not: returns bool
            Ok(Type.Bool)

        case BitNot:
            # Bitwise not: operand must be int
            engine.unify(operand_ty, Type.Int(bits: 64, signed: true))?
            Ok(Type.Int(bits: 64, signed: true))

        case Ref:
            # Borrow: &T
            Ok(Type.Borrow(inner: operand_ty))

        case RefMut:
            # Mutable borrow: &mut T
            Ok(Type.BorrowMut(inner: operand_ty))

        case Deref:
            # Dereference: *T -> T
            match engine.resolve(operand_ty):
                case Borrow(inner):
                    Ok(inner)
                case BorrowMut(inner):
                    Ok(inner)
                case _:
                    # Not a reference - pass through
                    Ok(operand_ty)

        case ChannelRecv:
            # Channel receive: <-chan extracts T from Channel<T>
            match engine.resolve(operand_ty):
                case Generic(base, args):
                    if base == "Channel" and args.?:
                        Ok(args[0])
                    else:
                        Ok(engine.fresh_var())
                case Named(name):
                    if name == "Channel":
                        Ok(engine.fresh_var())
                    else:
                        Ok(engine.fresh_var())
                case Var(_):
                    # Create constraint: must be Channel<T>
                    val inner = engine.fresh_var()
                    val channel_ty = Type.Generic(base: "Channel", args: [inner])
                    engine.unify(operand_ty, channel_ty)?
                    Ok(inner)
                case _:
                    Ok(engine.fresh_var())

        case Move:
            # Move is a semantic marker - type unchanged
            Ok(operand_ty)

        case _:
            # Unknown operator
            Ok(engine.fresh_var())

# ============================================================================
# Function Calls
# ============================================================================

fn infer_call(engine: InferenceEngine, callee: Expr, args: [Argument],
              env: Dict<text, Type>) -> Result<Type, TypeError>:
    """Infer type of function call."""
    val callee_ty = infer_expr(engine, callee, env)?

    # Infer argument types
    var arg_types: [Type] = []
    for arg in args:
        arg_types = arg_types.push(infer_expr(engine, arg.value, env)?)

    # Create result type variable
    val result_ty = engine.fresh_var()

    # Check if callee is a function
    match engine.resolve(callee_ty):
        case Function(params, ret):
            # Unify argument types with parameter types
            var i = 0
            while i < arg_types.len() and i < params.len():
                engine.unify(arg_types[i], params[i])?
                i = i + 1

            Ok(ret)

        case _:
            # Not a function type - return fresh var
            Ok(result_ty)

fn infer_method_call(engine: InferenceEngine, receiver: Expr, method: text,
                     args: [Argument], env: Dict<text, Type>) -> Result<Type, TypeError>:
    """Infer type of method call."""
    val receiver_ty = infer_expr(engine, receiver, env)?

    # Infer argument types
    for arg in args:
        val _ = infer_expr(engine, arg.value, env)?

    # Special handling for .with method (FString template instantiation)
    if method == "with":
        # TODO: Get FString keys and validate dict argument
        return Ok(Type.Str)

    # General method call - return fresh var
    # Full implementation needs method lookup
    Ok(engine.fresh_var())

# ============================================================================
# Lambdas
# ============================================================================

fn infer_lambda(engine: InferenceEngine, params: [LambdaParam], body: Expr,
                env: Dict<text, Type>) -> Result<Type, TypeError>:
    """Infer type of lambda expression."""
    # Create fresh variables for parameters
    var param_types: [Type] = []
    var new_env = env

    for param in params:
        val param_ty = if param.ty.?:
            # TODO: Convert AST type to inference type
            engine.fresh_var()
        else:
            engine.fresh_var()

        param_types = param_types.push(param_ty)
        new_env[param.name] = param_ty

    # Infer body type with extended environment
    val body_ty = infer_expr(engine, body, new_env)?

    # Construct function type
    Ok(Type.Function(params: param_types, ret: body_ty))

# ============================================================================
# Control Flow
# ============================================================================

fn infer_if(engine: InferenceEngine, condition: Expr, then_branch: Expr,
            else_branch: Expr?, env: Dict<text, Type>) -> Result<Type, TypeError>:
    """Infer type of if expression."""
    # Condition must be bool
    val cond_ty = infer_expr(engine, condition, env)?
    engine.unify(cond_ty, Type.Bool)?

    # Infer then branch
    val then_ty = infer_expr(engine, then_branch, env)?

    # If there's an else branch, unify with then
    if else_branch.?:
        val else_ty = infer_expr(engine, else_branch.unwrap(), env)?
        engine.unify(then_ty, else_ty)?
        Ok(engine.resolve(then_ty))
    else:
        # No else branch - type is Unit
        Ok(Type.Unit)

fn infer_match(engine: InferenceEngine, subject: Expr, arms: [MatchArm],
               env: Dict<text, Type>) -> Result<Type, TypeError>:
    """Infer type of match expression."""
    # Infer subject type
    val subject_ty = infer_expr(engine, subject, env)?

    # Create result type variable
    val result_ty = engine.fresh_var()

    # Check each arm
    for arm in arms:
        # TODO: Check pattern against subject type
        # TODO: Bind pattern variables

        # Infer arm body - for now, just check it type checks
        # Full implementation needs block inference
        pass

    Ok(result_ty)

# ============================================================================
# Collections
# ============================================================================

fn infer_array(engine: InferenceEngine, elements: [Expr],
               env: Dict<text, Type>) -> Result<Type, TypeError>:
    """Infer type of array literal."""
    if not elements.?:
        # Empty array - element type unknown
        val elem_ty = engine.fresh_var()
        return Ok(Type.Array(elem: elem_ty, size: nil))

    # Infer first element type
    val first_ty = infer_expr(engine, elements[0], env)?

    # Unify all other elements with first
    var i = 1
    while i < elements.len():
        val elem_ty = infer_expr(engine, elements[i], env)?
        engine.unify(first_ty, elem_ty)?
        i = i + 1

    Ok(Type.Array(elem: engine.resolve(first_ty), size: nil))

fn infer_tuple(engine: InferenceEngine, elements: [Expr],
               env: Dict<text, Type>) -> Result<Type, TypeError>:
    """Infer type of tuple literal."""
    var elem_types: [Type] = []

    for elem in elements:
        elem_types = elem_types.push(infer_expr(engine, elem, env)?)

    Ok(Type.Tuple(elements: elem_types))

fn infer_dict(engine: InferenceEngine, pairs: [(Expr, Expr)],
              env: Dict<text, Type>) -> Result<Type, TypeError>:
    """Infer type of dictionary literal."""
    if not pairs.?:
        # Empty dict - key and value types unknown
        val key_ty = engine.fresh_var()
        val value_ty = engine.fresh_var()
        return Ok(Type.Dict(key: key_ty, value: value_ty))

    # Infer first pair types
    val (first_key, first_value) = pairs[0]
    val key_ty = infer_expr(engine, first_key, env)?
    val value_ty = infer_expr(engine, first_value, env)?

    # Unify all other pairs
    var i = 1
    while i < pairs.len():
        val (k, v) = pairs[i]
        val k_ty = infer_expr(engine, k, env)?
        val v_ty = infer_expr(engine, v, env)?
        engine.unify(key_ty, k_ty)?
        engine.unify(value_ty, v_ty)?
        i = i + 1

    Ok(Type.Dict(key: engine.resolve(key_ty), value: engine.resolve(value_ty)))

# ============================================================================
# Field and Index Access
# ============================================================================

fn infer_field_access(engine: InferenceEngine, receiver: Expr, field: text,
                      env: Dict<text, Type>) -> Result<Type, TypeError>:
    """Infer type of field access."""
    val receiver_ty = infer_expr(engine, receiver, env)?

    # Field type lookup needs struct/class definitions
    # For now, return fresh var
    Ok(engine.fresh_var())

fn infer_index_access(engine: InferenceEngine, receiver: Expr, index: Expr,
                      env: Dict<text, Type>) -> Result<Type, TypeError>:
    """Infer type of index access."""
    val receiver_ty = infer_expr(engine, receiver, env)?
    val index_ty = infer_expr(engine, index, env)?

    # Index should be Int for arrays
    engine.unify(index_ty, Type.Int(bits: 64, signed: true))?

    # Result type depends on receiver
    match engine.resolve(receiver_ty):
        case Array(elem, _):
            Ok(elem)

        case Str:
            # String indexing returns string
            Ok(Type.Str)

        case Dict(key, value):
            # Dict indexing returns value type
            Ok(value)

        case Tuple(elems):
            # Tuple indexing - return fresh var (need literal index)
            Ok(engine.fresh_var())

        case _:
            # Unknown type - return fresh var
            Ok(engine.fresh_var())

# ============================================================================
# Macros
# ============================================================================

fn infer_macro(engine: InferenceEngine, name: text, args: [MacroArg],
               env: Dict<text, Type>) -> Result<Type, TypeError>:
    """Infer type of macro invocation."""
    # Infer argument types
    for arg in args:
        match arg:
            case Expr(e):
                val _ = infer_expr(engine, e, env)?

    # Macro return type depends on macro definition
    # For now, return fresh var
    Ok(engine.fresh_var())

# ============================================================================
# Exports
# ============================================================================

export infer_expr, infer_binary, infer_unary, infer_call, infer_method_call
export infer_lambda, infer_if, infer_match
export infer_array, infer_tuple, infer_dict
export infer_field_access, infer_index_access, infer_macro
