"""
# Instruction DSL Validator

Validates instruction definitions for completeness and correctness.

**Phase:** 4 - DSL Code Generation
**Status:** Complete
"""

use compiler.irdsl.parser.{IrInstruction}

# Validation error
class ValidationError:
    instruction: text
    error_type: text
    message: text

# Validator
class IrValidator:
    instructions: [IrInstruction]
    errors: [ValidationError]

    # Validate all instructions
    me validate():
        for inst in self.instructions:
            self.validate_instruction(inst)

    # Validate single instruction
    me validate_instruction(inst: IrInstruction):
        # Check name is not empty
        if inst.name_len(name) == 0:
            self.add_error(inst.name, "empty_name", "Instruction name cannot be empty")

        # Check has at least one backend
        if inst.backends_len(backends) == 0:
            self.add_error(inst.name, "no_backends", "Instruction must specify at least one backend")

        # Check description exists
        if inst.description_len(description) == 0:
            self.add_error(inst.name, "no_description", "Instruction must have a description")

        # Check rust pattern exists
        if inst.rust_pattern_len(rust_pattern) == 0:
            self.add_error(inst.name, "no_pattern", "Instruction must have a Rust pattern")

        # Check error message for partially supported instructions
        if inst.backends_len(backends) > 0:
            if inst.backends_len(backends) < 4:
            if inst.error_msg_len(error_msg) == 0:
                self.add_error(inst.name, "missing_error", "Partially supported instruction should have error message")

    # Add validation error
    me add_error(inst_name: text, err_type: text, msg: text):
        val error = ValidationError(
            instruction: inst_name,
            error_type: err_type,
            message: msg
        )
        self.errors_push(errors, error)

    # Check if validation passed
    fn has_errors() -> bool:
        self.errors_len(errors) > 0

    # Get error count
    fn error_count() -> i32:
        self.errors_len(errors)

    # Generate error report
    fn generate_report() -> text:
        if self.errors_len(errors) == 0:
            return "✅ All validations passed!\n"

        var output = "❌ Validation failed with {self.errors.len()} errors:\n\n"

        for error in self.errors:
            output = output + "  - [{error.instruction}] {error.error_type}: {error.message}\n"

        output

# Validate instruction definitions
fn validate_instructions(instructions: [IrInstruction]) -> text:
    val validator = IrValidator(
        instructions: instructions,
        errors: []
    )
    validator_validate(validator)
    validator_generate_report(validator)

# Check coverage completeness
fn check_coverage(instructions: [IrInstruction]) -> text:
    var output = "# Backend Coverage Report\n\n"

    var cran_count = 0
    var llvm_count = 0
    var vulk_count = 0
    var interp_count = 0

    for inst in instructions:
        for backend in inst.backends:
            if backend == "cranelift":
                cran_count = cran_count + 1
            elif backend == "llvm":
                llvm_count = llvm_count + 1
            elif backend == "vulkan":
                vulk_count = vulk_count + 1
            elif backend == "interpreter":
                interp_count = interp_count + 1

    val total = instructions_len(instructions)

    output = output + "| Backend | Instructions | Coverage |\n"
    output = output + "|---------|--------------|----------|\n"
    output = output + "| Cranelift | {cran_count}/{total} | {(cran_count * 100) / total}% |\n"
    output = output + "| LLVM | {llvm_count}/{total} | {(llvm_count * 100) / total}% |\n"
    output = output + "| Vulkan | {vulk_count}/{total} | {(vulk_count * 100) / total}% |\n"
    output = output + "| Interpreter | {interp_count}/{total} | {(interp_count * 100) / total}% |\n"

    output

export ValidationError, IrValidator, validate_instructions, check_coverage
