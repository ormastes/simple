# Inline Assembly Support
#
# Provides inline assembly for bare-metal programming.
#
# Syntax:
#   asm:
#       "instruction1"
#       "instruction2"
#       options: [volatile, noreturn]
#       in(reg) variable
#       out(reg) variable
#       clobbers: ["reg1", "reg2"]
#
# Examples:
#   # Simple assembly
#   asm:
#       "nop"
#
#   # With inputs/outputs
#   asm:
#       "add {0}, {1}"
#       out(eax) result
#       in(ebx) a
#       in(ecx) b
#
#   # Volatile (side effects)
#   asm:
#       "cli"           # Disable interrupts
#       options: [volatile]

use compiler.hir_definitions.{HirExpr, HirExprKind, HirStmt}
use compiler.lexer.Span
use std.common.target.{TargetArch}

# ===========================================================================
# Inline Assembly AST
# ===========================================================================

class InlineAsm:
    """Inline assembly block."""
    template: [text]            # Assembly template strings
    operands: [AsmOperand]      # Input/output operands
    clobbers: [text]            # Clobbered registers
    options: [AsmOption]        # Assembly options
    arch: TargetArch            # Target architecture
    span: Span


# ============================================================================
# InlineAsm Methods (was: impl InlineAsm:)
# ============================================================================

fn inlineasm_new(template: [text], span: Span) -> InlineAsm:
        InlineAsm(
            template: template,
            operands: [],
            clobbers: [],
            options: [],
            arch: targetarch_host(),
            span: span
        )


# ===========================================================================
# Assembly Operands
# ===========================================================================

enum AsmOperand:
    """Assembly operand (input/output)."""
    Input(reg: AsmRegister, expr: HirExpr)      # in(reg) expr
    Output(reg: AsmRegister, var_name: text)    # out(reg) var
    InOut(reg: AsmRegister, expr: HirExpr)      # inout(reg) expr


# ============================================================================
# AsmOperand Methods (was: impl AsmOperand:)
# ============================================================================

# ===========================================================================
# Registers
# ===========================================================================

enum AsmRegister:
    """Assembly register specification."""
    # x86/x86_64 registers
    Rax
    Rbx
    Rcx
    Rdx
    Rsi
    Rdi
    Rbp
    Rsp
    R8
    R9
    R10
    R11
    R12
    R13
    R14
    R15
    Eax
    Ebx
    Ecx
    Edx
    Esi
    Edi
    Ebp
    Esp
    Al
    Bl
    Cl
    Dl

    # ARM registers
    R0
    R1
    R2
    R3
    R4
    R5
    R6
    R7
    R8_arm
    R9_arm
    R10_arm
    R11_arm
    R12_arm
    R13_arm
    R14_arm
    R15_arm
    Sp
    Lr
    Pc

    # RISC-V registers
    X0
    X1
    X2
    X3
    X4
    X5
    X6
    X7
    X8
    X9
    X10
    X11
    X12
    X13
    X14
    X15
    X16
    X17
    X18
    X19
    X20
    X21
    X22
    X23
    X24
    X25
    X26
    X27
    X28
    X29
    X30
    X31

    # Special: let compiler choose
    Any


# ============================================================================
# AsmRegister Methods (was: impl AsmRegister:)
# ============================================================================

# ===========================================================================
# Assembly Options
# ===========================================================================

enum AsmOption:
    """Assembly block options."""
    Volatile        # Has side effects (don't optimize away)
    NoReturn        # Never returns (e.g., infinite loop)
    Pure            # No side effects (can be optimized)
    NoStack         # Doesn't use stack


# ============================================================================
# AsmOption Methods (was: impl AsmOption:)
# ============================================================================

# ===========================================================================
# Assembly Template
# ===========================================================================

class AsmTemplate:
    """Parsed assembly template."""
    parts: [AsmTemplatePart]

enum AsmTemplatePart:
    """Part of assembly template."""
    Text(s: text)               # Literal assembly text
    Operand(index: i32)         # Operand reference {0}, {1}, etc.
    Register(reg: text)         # Named register {rax}, {r0}, etc.


# ============================================================================
# AsmTemplate Methods (was: impl AsmTemplate:)
# ============================================================================

fn asmtemplate_parse(template: text) -> AsmTemplate:
        var parts: [AsmTemplatePart] = []
        var current = ""
        var i = 0

        while i < template_len(template):
            if template[i] == '{':
                # Save accumulated text
                if current_len(current) > 0:
                    parts_push(parts, AsmTemplatePart.Text(current))
                    current = ""

                # Parse placeholder
                i = i + 1
                var placeholder = ""
                while i < template.len() and template[i] != '}':
                    placeholder = placeholder + template[i]
                    i = i + 1

                # Check if numeric (operand index) or name (register)
                if placeholder_is_numeric(placeholder):
                    val index = parse_i32(placeholder)
                    parts_push(parts, AsmTemplatePart.Operand(index))
                else:
                    parts_push(parts, AsmTemplatePart.Register(placeholder))

                i = i + 1  # Skip '}'
            else:
                current = current + template[i]
                i = i + 1

        # Add remaining text
        if current_len(current) > 0:
            parts_push(parts, AsmTemplatePart.Text(current))

        AsmTemplate(parts: parts)


# ===========================================================================
# Code Generation
# ===========================================================================

class AsmCodegen:
    """Assembly code generator."""
    arch: TargetArch


# ============================================================================
# AsmCodegen Methods (was: impl AsmCodegen:)
# ============================================================================

fn asmcodegen_new(arch: TargetArch) -> AsmCodegen:
        AsmCodegen(arch: arch)


# ===========================================================================
# Helper Functions
# ===========================================================================

fn parse_i32(s: text) -> i32:
    var result: i32 = 0
    for c in s:
        if c >= '0':
            if c <= '9':
            result = result * 10 + (c_to_i32(c) - 48)
    result

fn is_numeric(s: text) -> bool:
    if s_len(s) == 0:
        return false
    for c in s:
        if c < '0' or c > '9':
            return false
    true

# ===========================================================================
# Exports
# ===========================================================================

export InlineAsm, AsmOperand, AsmRegister, AsmOption
export AsmTemplate, AsmTemplatePart
export AsmCodegen
