# Static Test Analyzer
#
# Extracts test metadata from source without executing DSL code.
# Enables fast test listing for large test suites.
#
# Port of rust/parser/src/test_analyzer.rs (511 lines)

export TestKind, TestMeta, TestGroupMeta, FileTestMeta
export extract_file_test_meta, extract_tests_from_source

# ============================================================================
# Test Metadata Types
# ============================================================================

enum TestKind:
    Normal
    Slow
    Skipped
    Ignored

struct TestMeta:
    description: text
    kind: TestKind
    line: i64
    tags: [text]
    group_path: [text]      # ["Math operations", "addition"]


# ============================================================================
# TestMeta Methods (was: impl TestMeta:)
# ============================================================================

fn testmeta_new(description: text, line: i64, kind: TestKind) -> TestMeta:
        TestMeta(description: description, kind: kind, line: line,
                 tags: [], group_path: [])


struct TestGroupMeta:
    name: text
    line: i64
    tests: [TestMeta]
    children: [TestGroupMeta]


# ============================================================================
# TestGroupMeta Methods (was: impl TestGroupMeta:)
# ============================================================================

fn testgroupmeta_new(name: text, line: i64) -> TestGroupMeta:
        TestGroupMeta(name: name, line: line, tests: [], children: [])


struct FileTestMeta:
    # # DESUGARED: file_path: text
    has_file_path: bool
    file_path: text
    groups: [TestGroupMeta]
    top_level_tests: [TestMeta]


# ============================================================================
# FileTestMeta Methods (was: impl FileTestMeta:)
# ============================================================================

fn filetestmeta_empty() -> FileTestMeta:
        FileTestMeta(file_path: nil, groups: [], top_level_tests: [])


fn filetestmeta_for_file(path: text) -> FileTestMeta:
        # FileTestMeta(# DESUGARED: file_path: Some(path)
            file_path: path, groups: [], top_level_tests: [])


# ============================================================================
# DSL Function Names
# ============================================================================

val TEST_FUNCTIONS = ["it", "test", "example", "specify"]
val SLOW_TEST_FUNCTIONS = ["slow_it", "slow_test"]
val SKIP_TEST_FUNCTIONS = ["skip_it", "skip", "skip_test", "pending"]
val IGNORE_TEST_FUNCTIONS = ["ignore_it", "ignore_test", "ignored"]
val GROUP_FUNCTIONS = ["describe", "context", "feature", "scenario"]

# ============================================================================
# Source-Level Test Extraction
# ============================================================================

fn extract_tests_from_source(source: text, file_path: text?) -> FileTestMeta:
    """Extract test metadata from source without full AST parsing.

    Uses line-by-line analysis to detect test DSL calls.
    Fast and tolerant of syntax errors.
    """
    var meta = if has_file_path: filetestmeta_for_file(file_path_value)
               else: filetestmeta_empty()

    val lines = source.split("\n")
    var group_stack: [TestGroupMeta] = []
    var group_path: [text] = []
    var indent_stack: [i64] = []
    var pending_tags: [text] = []

    var line_num = 0
    while line_num < lines_len(lines):
        val line = lines[line_num]
        val trimmed = line_trim(line)
        val indent = count_leading_spaces(line)

        # Collect tag comments
        if trimmed.starts_with("# @"):
            val tag = trimmed[3:].trim()
            pending_tags = pending_tags_push(pending_tags, tag)
            line_num = line_num + 1
            continue

        # Pop groups when indentation decreases
        while indent_stack.? and indent <= indent_stack[indent_stack_len(indent_stack) - 1]:
            indent_stack = indent_stack[:indent_stack_len(indent_stack) - 1]
            if has_group_stack:
                val completed = group_stack[group_stack_len(group_stack) - 1]
                group_stack = group_stack[:group_stack_len(group_stack) - 1]
                group_path = group_path[:group_path_len(group_path) - 1]
                if has_group_stack:
                    val parent_idx = group_stack_len(group_stack) - 1
                    group_stack[parent_idx] = group_stack[parent_idx].add_child(completed)
                else:
                    meta = meta_add_group(meta, completed)

        # Try to parse a DSL call
        val call = try_parse_dsl_call(trimmed)
        if has_call:
            val _destruct_0 = call_value
            val func_name = _destruct_0[0]
            val description = _destruct_0[1]

            if test_functions_contains(func_name):
                val test = testmeta_new(description, line_num + 1, TestKind.Normal).with_tags(pending_tags).with_group_path(group_path)
                if has_group_stack:
                    val idx = group_stack_len(group_stack) - 1
                    group_stack[idx] = group_stack[idx].add_test(test)
                else:
                    meta = meta_add_test(meta, test)

            elif slow_test_functions_contains(func_name):
                val test = testmeta_new(description, line_num + 1, TestKind.Slow).with_tags(pending_tags).with_group_path(group_path)
                if has_group_stack:
                    val idx = group_stack_len(group_stack) - 1
                    group_stack[idx] = group_stack[idx].add_test(test)
                else:
                    meta = meta_add_test(meta, test)

            elif skip_test_functions_contains(func_name):
                val test = testmeta_new(description, line_num + 1, TestKind.Skipped).with_tags(pending_tags).with_group_path(group_path)
                if has_group_stack:
                    val idx = group_stack_len(group_stack) - 1
                    group_stack[idx] = group_stack[idx].add_test(test)
                else:
                    meta = meta_add_test(meta, test)

            elif ignore_test_functions_contains(func_name):
                val test = testmeta_new(description, line_num + 1, TestKind.Ignored).with_tags(pending_tags).with_group_path(group_path)
                if has_group_stack:
                    val idx = group_stack_len(group_stack) - 1
                    group_stack[idx] = group_stack[idx].add_test(test)
                else:
                    meta = meta_add_test(meta, test)

            elif group_functions_contains(func_name):
                val group = testgroupmeta_new(description, line_num + 1)
                group_stack = group_stack_push(group_stack, group)
                group_path = group_path_push(group_path, description)
                indent_stack = indent_stack_push(indent_stack, indent)

        pending_tags = []
        line_num = line_num + 1

    # Flush remaining groups
    while has_group_stack:
        val completed = group_stack[group_stack_len(group_stack) - 1]
        group_stack = group_stack[:group_stack_len(group_stack) - 1]
        if has_group_stack:
            val idx = group_stack_len(group_stack) - 1
            group_stack[idx] = group_stack[idx].add_child(completed)
        else:
            meta = meta_add_group(meta, completed)

    meta

fn extract_file_test_meta(source: text, file_path: text?) -> FileTestMeta:
    """Main entry point for static test analysis."""
    extract_tests_from_source(source, file_path)

fn try_parse_dsl_call(trimmed: text) -> (text, text)?:
    """Try to parse a DSL function call like `it "description":`.

    Returns (function_name, description) if found.
    """
    # Find first space (function name boundary)
    val space_idx = trimmed.find(" ")
    if not has_space_idx:
        return nil

    val func_name = trimmed[:space_idx_value]
    val rest = trimmed[space_idx_value + 1:]

    # Check if it's a known DSL function
    val all_dsl = test_functions_merge(SLOW_TEST_FUNCTIONS).merge(SKIP_TEST_FUNCTIONS).merge(IGNORE_TEST_FUNCTIONS)
        .merge(GROUP_FUNCTIONS)
    if not all_dsl_contains(all_dsl, func_name):
        return nil

    # Extract string description
    val desc = extract_string_literal(rest)
    if has_desc:
        return [func_name, desc_value]

    nil

fn extract_string_literal(s: text) -> text:
    """Extract a quoted string from the beginning of text."""
    val trimmed = s_trim(s)
    if trimmed_len(trimmed) < 2:
        return nil
    if trimmed[0] != '"':
        return nil

    var end = 1
    while end < trimmed_len(trimmed):
        if trimmed[end] == '\\':
            end = end + 2
            continue
        if trimmed[end] == '"':
            return trimmed[1:end]
        end = end + 1

    nil

fn count_leading_spaces(line: text) -> i64:
    var count = 0
    while count < line.len() and line[count] == ' ':
        count = count + 1
    count
