# Core Simple â€” AST Cloning for Monomorphization
#
# Deep copies AST nodes (expressions, statements, declarations) to create
# specialized versions of generic functions at runtime.
#
# Each clone gets new indices in the arena pools but preserves structure.

use compiler_core.ast.{expr_count, expr_alloc, expr_get}
use compiler_core.ast.{stmt_count, stmt_alloc, stmt_get}
use compiler_core.ast.{decl_count, decl_alloc, decl_get}
use compiler_core.ast.{EXPR_INT_LIT, EXPR_FLOAT_LIT, EXPR_STRING_LIT, EXPR_BOOL_LIT}
use compiler_core.ast.{EXPR_NIL_LIT, EXPR_IDENT, EXPR_BINARY, EXPR_UNARY, EXPR_CALL}
use compiler_core.ast.{EXPR_INDEX, EXPR_FIELD_ACCESS, EXPR_METHOD_CALL, EXPR_ARRAY_LIT}
use compiler_core.ast.{EXPR_IF, EXPR_MATCH, EXPR_FOR, EXPR_WHILE, EXPR_BLOCK}
use compiler_core.ast.{EXPR_RETURN, EXPR_BREAK, EXPR_CONTINUE, EXPR_RANGE}
use compiler_core.ast.{EXPR_ASSIGN, EXPR_COMPOUND_ASSIGN, EXPR_DICT_LIT, EXPR_LAMBDA}
use compiler_core.ast.{EXPR_STRUCT_LIT, EXPR_TUPLE, EXPR_SLICE, EXPR_NULL_COALESCE}
use compiler_core.ast.{EXPR_OPTIONAL_CHAIN, EXPR_CAST, EXPR_UNIT, EXPR_INTERPOLATED_STRING}
use compiler_core.ast.{EXPR_PASS, EXPR_PASS_TODO, EXPR_PASS_DO_NOTHING, EXPR_PASS_DN}
use compiler_core.ast.{EXPR_SUFFIXED_LIT, EXPR_AWAIT, EXPR_YIELD, EXPR_SPAWN, EXPR_ASYNC_BLOCK}
use compiler_core.ast.{STMT_EXPR, STMT_VAL_BINDING, STMT_VAR_BINDING, STMT_ASSIGN}
use compiler_core.ast.{STMT_COMPOUND_ASSIGN, STMT_FOR, STMT_WHILE, STMT_IF}
use compiler_core.ast.{STMT_MATCH, STMT_RETURN, STMT_BREAK, STMT_CONTINUE}
use compiler_core.ast.{DECL_FN, DECL_EXTERN_FN, DECL_STRUCT, DECL_ENUM}
use compiler_core.ast.{DECL_VAL_BINDING, DECL_VAR_BINDING, DECL_USE, DECL_EXPORT}

# ===== Expression Cloning =====

fn ast_clone_expr(source_eid: i64) -> i64:
    """Clone an expression node recursively

    Creates a new expression in the arena with all child nodes cloned.
    Returns the new expression index.
    """
    if source_eid < 0:
        return -1

    val src = expr_get(source_eid)
    val tag = src.tag
    val new_eid = expr_alloc(tag, src.span)

    # Get mutable access to set fields
    val dst = expr_get(new_eid)
    dst.i_val = src.i_val
    dst.f_val = src.f_val
    dst.s_val = src.s_val

    # Clone child expressions
    dst.left = ast_clone_expr(src.left)
    dst.right = ast_clone_expr(src.right)
    dst.extra = ast_clone_expr(src.extra)

    # Clone argument lists
    var new_args: [i64] = []
    for arg_eid in src.args:
        new_args.push(ast_clone_expr(arg_eid))
    dst.args = new_args

    # Clone statement lists
    var new_stmts: [i64] = []
    for stmt_id in src.stmts:
        new_stmts.push(ast_clone_stmt(stmt_id))
    dst.stmts = new_stmts

    new_eid

fn ast_clone_expr_list(source_eids: [i64]) -> [i64]:
    """Clone a list of expressions"""
    var result: [i64] = []
    for eid in source_eids:
        result.push(ast_clone_expr(eid))
    result

# ===== Statement Cloning =====

fn ast_clone_stmt(source_sid: i64) -> i64:
    """Clone a statement node recursively

    Creates a new statement in the arena with all child nodes cloned.
    Returns the new statement index.
    """
    if source_sid < 0:
        return -1

    val src = stmt_get(source_sid)
    val tag = src.tag
    val new_sid = stmt_alloc(tag, src.span)

    val dst = stmt_get(new_sid)
    dst.name = src.name
    dst.type_tag = src.type_tag
    dst.op = src.op

    # Clone child expressions
    dst.target = ast_clone_expr(src.target)
    dst.value = ast_clone_expr(src.value)
    dst.condition = ast_clone_expr(src.condition)
    dst.iterator = ast_clone_expr(src.iterator)
    dst.iterable = ast_clone_expr(src.iterable)

    # Clone statement body lists
    var new_body: [i64] = []
    for stmt_id in src.body:
        new_body.push(ast_clone_stmt(stmt_id))
    dst.body = new_body

    var new_else_body: [i64] = []
    for stmt_id in src.else_body:
        new_else_body.push(ast_clone_stmt(stmt_id))
    dst.else_body = new_else_body

    # Clone elif branches
    var new_elif_conds: [i64] = []
    for cond_eid in src.elif_conds:
        new_elif_conds.push(ast_clone_expr(cond_eid))
    dst.elif_conds = new_elif_conds

    var new_elif_bodies: [[i64]] = []
    for body_stmts in src.elif_bodies:
        var new_branch: [i64] = []
        for stmt_id in body_stmts:
            new_branch.push(ast_clone_stmt(stmt_id))
        new_elif_bodies.push(new_branch)
    dst.elif_bodies = new_elif_bodies

    new_sid

fn ast_clone_stmt_list(source_sids: [i64]) -> [i64]:
    """Clone a list of statements"""
    var result: [i64] = []
    for sid in source_sids:
        result.push(ast_clone_stmt(sid))
    result

# ===== Declaration Cloning =====

fn ast_clone_decl(source_did: i64) -> i64:
    """Clone a declaration node recursively

    Creates a new declaration in the arena with all child nodes cloned.
    Used for monomorphizing generic functions.
    Returns the new declaration index.
    """
    if source_did < 0:
        return -1

    val src = decl_get(source_did)
    val tag = src.tag
    val new_did = decl_alloc(tag, src.span)

    val dst = decl_get(new_did)
    dst.name = src.name
    dst.ret_type = src.ret_type
    dst.is_pub = src.is_pub
    dst.is_async = src.is_async

    # Clone parameter lists (don't clone param types - will be substituted)
    var new_param_names: [text] = []
    for pname in src.param_names:
        new_param_names.push(pname)
    dst.param_names = new_param_names

    var new_param_types: [i64] = []
    for ptype in src.param_types:
        new_param_types.push(ptype)
    dst.param_types = new_param_types

    # Clone field lists (for structs)
    var new_field_names: [text] = []
    for fname in src.field_names:
        new_field_names.push(fname)
    dst.field_names = new_field_names

    var new_field_types: [i64] = []
    for ftype in src.field_types:
        new_field_types.push(ftype)
    dst.field_types = new_field_types

    # Clone body statements
    var new_body: [i64] = []
    for stmt_id in src.body_stmts:
        new_body.push(ast_clone_stmt(stmt_id))
    dst.body_stmts = new_body

    # Clone imports
    var new_imports: [text] = []
    for imp in src.imports:
        new_imports.push(imp)
    dst.imports = new_imports

    # Type params NOT cloned - will be cleared for specialized version
    dst.type_params = []

    new_did

# ===== Accessor Helpers =====

fn ast_clone_get_type_params(decl_id: i64) -> [text]:
    """Get type parameters from a declaration"""
    if decl_id < 0:
        return []
    val d = decl_get(decl_id)
    d.type_params

fn ast_clone_is_generic(decl_id: i64) -> bool:
    """Check if a declaration has type parameters"""
    val tparams = ast_clone_get_type_params(decl_id)
    tparams.len() > 0

export ast_clone_expr, ast_clone_expr_list
export ast_clone_stmt, ast_clone_stmt_list
export ast_clone_decl
export ast_clone_get_type_params, ast_clone_is_generic
