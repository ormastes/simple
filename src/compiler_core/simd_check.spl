# SIMD Type Checking and Auto-Vectorization
#
# Provides compile-time verification of SIMD operations and
# automatic vectorization of compatible loops.
#
# Features:
# - SIMD type validation (lane count, element types)
# - Vector operation type checking
# - Auto-vectorization analysis
# - Backend capability verification
#
# Supported vector types:
# - i8x16, i16x8, i32x4, i64x2
# - f32x4, f64x2
# - Custom widths based on target

use compiler.mir_data.*

# ============================================================================
# SIMD Element Type
# ============================================================================

enum SimdElementType:
    """Element type in a SIMD vector."""
    I8
    I16
    I32
    I64
    F32
    F64


# ============================================================================
# SimdElementType Methods (was: impl SimdElementType:)
# ============================================================================

# ============================================================================
# SIMD Vector Type
# ============================================================================

struct SimdVectorType:
    """A SIMD vector type."""
    element_type: SimdElementType
    lane_count: i64


# ============================================================================
# SimdVectorType Methods (was: impl SimdVectorType:)
# ============================================================================

fn simdvectortype_create(element: SimdElementType, lanes: i64) -> SimdVectorType:
        SimdVectorType(element_type: element, lane_count: lanes)


fn simdvectortype_i8x16() -> SimdVectorType:
        simdvectortype_create(SimdElementType.I8, 16)


fn simdvectortype_i16x8() -> SimdVectorType:
        simdvectortype_create(SimdElementType.I16, 8)


fn simdvectortype_i32x4() -> SimdVectorType:
        simdvectortype_create(SimdElementType.I32, 4)


fn simdvectortype_i64x2() -> SimdVectorType:
        simdvectortype_create(SimdElementType.I64, 2)


fn simdvectortype_f32x4() -> SimdVectorType:
        simdvectortype_create(SimdElementType.F32, 4)


fn simdvectortype_f64x2() -> SimdVectorType:
        simdvectortype_create(SimdElementType.F64, 2)


# ============================================================================
# SIMD Operation
# ============================================================================

enum SimdOperation:
    """A SIMD operation type."""
    # Arithmetic
    Add
    Sub
    Mul
    Div

    # Bitwise
    And
    Or
    Xor
    Not

    # Comparison
    Eq
    Ne
    Lt
    Le
    Gt
    Ge

    # Reduction
    ReduceAdd
    ReduceMul
    ReduceMin
    ReduceMax

    # Shuffle/Permute
    Shuffle
    Splat
    Extract
    Insert

    # Conversion
    Widen
    Narrow
    Convert


# ============================================================================
# SimdOperation Methods (was: impl SimdOperation:)
# ============================================================================

# ============================================================================
# SIMD Check Error
# ============================================================================

enum SimdCheckError:
    """Error in SIMD type checking."""
    InvalidLaneCount(expected: i64, actual: i64)
    IncompatibleTypes(lhs: SimdVectorType, rhs: SimdVectorType)
    InvalidVectorWidth(bits: i64)
    UnsupportedOperation(op: SimdOperation, element_type: SimdElementType)
    LaneIndexOutOfBounds(index: i64, max_lanes: i64)
    ShuffleMaskInvalid(mask_len: i64, expected: i64)


# ============================================================================
# SimdCheckError Methods (was: impl SimdCheckError:)
# ============================================================================

# ============================================================================
# SIMD Type Checker
# ============================================================================

class SimdTypeChecker:
    """Type checker for SIMD operations."""
    errors: [SimdCheckError]
    target_max_width: i64  # Maximum vector width for target (128, 256, 512)

    static fn create(max_width: i64) -> SimdTypeChecker:
        SimdTypeChecker(errors: [], target_max_width: max_width)

    static fn for_sse() -> SimdTypeChecker:
        simdtypechecker_create(128)

    static fn for_avx() -> SimdTypeChecker:
        simdtypechecker_create(256)

    static fn for_avx512() -> SimdTypeChecker:
        simdtypechecker_create(512)

    me check_vector_type(ty: SimdVectorType) -> bool:
        """Check if a vector type is valid for the target."""
        if not ty_is_valid_width(ty):
            self.errors = self.errors_push(errors, SimdCheckError.InvalidVectorWidth(ty.total_bits()))
            return false

        if ty_total_bits(ty) > self.target_max_width:
            self.errors = self.errors_push(errors, SimdCheckError.InvalidVectorWidth(ty.total_bits()))
            return false

        true

    me check_binary_op(op: SimdOperation, lhs: SimdVectorType, rhs: SimdVectorType) -> bool:
        """Check a binary SIMD operation."""
        # Check types are compatible
        if not lhs_is_compatible_with(lhs, rhs):
            self.errors = self.errors_push(errors, SimdCheckError.IncompatibleTypes(lhs, rhs))
            return false

        # Check operation supports element type
        if lhs.element_type_is_float(element_type) and not op_supports_float(op):
            self.errors = self.errors_push(errors, SimdCheckError.UnsupportedOperation(op, lhs.element_type))
            return false

        true

    me check_lane_access(ty: SimdVectorType, lane_index: i64) -> bool:
        """Check a lane access is in bounds."""
        if lane_index < 0 or lane_index >= ty.lane_count:
            self.errors = self.errors.push(SimdCheckError.LaneIndexOutOfBounds(
                lane_index, ty.lane_count
            ))
            return false
        true

    me check_shuffle(ty: SimdVectorType, mask: [i64]) -> bool:
        """Check a shuffle operation."""
        if mask_len(mask) != ty.lane_count:
            self.errors = self.errors.push(SimdCheckError.ShuffleMaskInvalid(
                mask_len(mask), ty.lane_count
            ))
            return false

        # Check each mask index is valid
        for idx in mask:
            if idx < 0 or idx >= ty.lane_count * 2:  # Can reference either source
                self.errors = self.errors.push(SimdCheckError.LaneIndexOutOfBounds(
                    idx, ty.lane_count * 2
                ))
                return false

        true

    fn get_errors() -> [SimdCheckError]:
        self.errors

    fn has_errors() -> bool:
        not self.errors_is_empty(errors)

# ============================================================================
# Auto-Vectorization Analysis
# ============================================================================

enum VectorizationStatus:
    """Result of vectorization analysis."""
    Vectorizable(factor: i64)       # Can vectorize with given factor
    NotVectorizable(reason: text)   # Cannot vectorize, with reason
    PartiallyVectorizable(factor: i64, remainder: i64)


# ============================================================================
# VectorizationStatus Methods (was: impl VectorizationStatus:)
# ============================================================================

struct LoopInfo:
    """Information about a loop for vectorization."""
    # DESUGARED: iteration_count: i64?
    has_iteration_count: bool
    iteration_count_value: i64
    has_dependencies: bool
    has_function_calls: bool
    has_side_effects: bool
    stride: i64


# ============================================================================
# LoopInfo Methods (was: impl LoopInfo:)
# ============================================================================

fn loopinfo_simple_loop(iterations: i64) -> LoopInfo:
        LoopInfo(
            # DESUGARED: iteration_count: Some(iterations)
            has_iteration_count: true,
            iteration_count_value: iterations,
            has_dependencies: false,
            has_function_calls: false,
            has_side_effects: false,
            stride: 1
        )


class AutoVectorizer:
    """Analyzes loops for auto-vectorization."""
    target_vector_width: i64  # In bits
    min_trip_count: i64       # Minimum iterations to vectorize

    static fn create(vector_width: i64) -> AutoVectorizer:
        AutoVectorizer(
            target_vector_width: vector_width,
            min_trip_count: 4
        )

    fn analyze_loop(info: LoopInfo, element_bits: i64) -> VectorizationStatus:
        """Analyze a loop for vectorization potential."""
        # Check basic requirements
        if not info_is_vectorization_candidate(info):
            if info.has_dependencies:
                return VectorizationStatus.NotVectorizable("loop has data dependencies")
            if info.has_function_calls:
                return VectorizationStatus.NotVectorizable("loop contains function calls")
            return VectorizationStatus.NotVectorizable("loop has side effects")

        # Calculate vectorization factor
        val factor = self.target_vector_width / element_bits

        # Check iteration count
        match info.iteration_count:
            case has_field = true, field_value = count:
                if count < self.min_trip_count:
                    return VectorizationStatus.NotVectorizable("trip count too low")

                val remainder = count % factor
                if remainder == 0:
                    vectorizationstatus_Vectorizable(factor)
                else:
                    vectorizationstatus_PartiallyVectorizable(factor, remainder)

            case nil:
                # Unknown trip count - can still vectorize with runtime check
                vectorizationstatus_Vectorizable(factor)

    fn suggest_vector_type(element_type: SimdElementType) -> SimdVectorType:
        """Suggest vector type for element type based on target."""
        val elem_bits = element_type_bit_width(element_type)
        val lanes = self.target_vector_width / elem_bits
        simdvectortype_create(element_type, lanes)

# ============================================================================
# SIMD Instruction Info
# ============================================================================

struct SimdInstructionInfo:
    """Information about a SIMD instruction."""
    operation: SimdOperation
    result_type: SimdVectorType
    operand_types: [SimdVectorType]
    latency: i64        # CPU cycles
    throughput: f64     # Instructions per cycle


# ============================================================================
# SimdInstructionInfo Methods (was: impl SimdInstructionInfo:)
# ============================================================================

fn simdinstructioninfo_binary(op: SimdOperation, ty: SimdVectorType) -> SimdInstructionInfo:
        SimdInstructionInfo(
            operation: op,
            result_type: ty,
            operand_types: [ty, ty],
            latency: 1,
            throughput: 1.0
        )


fn simdinstructioninfo_unary(op: SimdOperation, ty: SimdVectorType) -> SimdInstructionInfo:
        SimdInstructionInfo(
            operation: op,
            result_type: ty,
            operand_types: [ty],
            latency: 1,
            throughput: 1.0
        )


# ============================================================================
# Backend SIMD Capability
# ============================================================================

struct SimdCapability:
    """SIMD capabilities of a target backend."""
    max_vector_width: i64
    supported_types: [SimdVectorType]
    supported_ops: [SimdOperation]
    has_fma: bool       # Fused multiply-add
    has_gather: bool    # Gather loads
    has_scatter: bool   # Scatter stores


# ============================================================================
# SimdCapability Methods (was: impl SimdCapability:)
# ============================================================================

fn simdcapability_sse2() -> SimdCapability:
        SimdCapability(
            max_vector_width: 128,
            supported_types: [
                simdvectortype_i8x16(),
                simdvectortype_i16x8(),
                simdvectortype_i32x4(),
                simdvectortype_i64x2(),
                simdvectortype_f32x4(),
                simdvectortype_f64x2()
            ],
            supported_ops: [
                SimdOperation.Add,
                SimdOperation.Sub,
                SimdOperation.Mul,
                SimdOperation.And,
                SimdOperation.Or,
                SimdOperation.Xor
            ],
            has_fma: false,
            has_gather: false,
            has_scatter: false
        )


fn simdcapability_avx2() -> SimdCapability:
        SimdCapability(
            max_vector_width: 256,
            supported_types: [
                simdvectortype_create(SimdElementType.I32, 8),
                simdvectortype_create(SimdElementType.F32, 8),
                simdvectortype_create(SimdElementType.F64, 4)
            ],
            supported_ops: [
                SimdOperation.Add,
                SimdOperation.Sub,
                SimdOperation.Mul,
                SimdOperation.Div,
                SimdOperation.And,
                SimdOperation.Or,
                SimdOperation.Xor,
                SimdOperation.Shuffle
            ],
            has_fma: true,
            has_gather: true,
            has_scatter: false
        )


# ============================================================================
# Convenience Functions
# ============================================================================

fn check_simd_binary(op: SimdOperation, lhs: SimdVectorType, rhs: SimdVectorType) -> Result<(), SimdCheckError>:
    """Check a binary SIMD operation."""
    var checker = simdtypechecker_for_avx()
    if checker_check_binary_op(checker, op, lhs, rhs):
        Ok(())
    else:
        Err(checker_get_errors(checker)[0])

fn can_vectorize_loop(iterations: i64, element_bits: i64) -> bool:
    """Check if a loop can be vectorized."""
    val info = loopinfo_simple_loop(iterations)
    val vectorizer = autovectorizer_create(128)
    vectorizer_analyze_loop(vectorizer, info, element_bits).can_vectorize()

fn get_vector_type_for_scalar(scalar_type: text) -> has_SimdVectorType:
    """Get appropriate vector type for a scalar type."""
    match scalar_type:
        case "i8": has_field = true, field_value = SimdVectorType.i8x16()
        case "i16": has_field = true, field_value = SimdVectorType.i16x8()
        case "i32": has_field = true, field_value = SimdVectorType.i32x4()
        case "i64": has_field = true, field_value = SimdVectorType.i64x2()
        case "f32": has_field = true, field_value = SimdVectorType.f32x4()
        case "f64": has_field = true, field_value = SimdVectorType.f64x2()
        case has__: false,  # DESUGARED: _: nil

# ============================================================================
# Exports
# ============================================================================

export SimdElementType, SimdVectorType, SimdOperation
export SimdCheckError, SimdTypeChecker
export VectorizationStatus, LoopInfo, AutoVectorizer
export SimdInstructionInfo, SimdCapability
export check_simd_binary, can_vectorize_loop, get_vector_type_for_scalar
