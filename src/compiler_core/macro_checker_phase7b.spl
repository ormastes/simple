"""
Macro Type Checking - Phase 7B: Macro Call Type Checking

Implements type checking for macro calls (argument validation).

Status: Phase 7B In Progress
"""

type Symbol = text

# ============================================================================
# Import from Phase 7A
# ============================================================================

# Type system
enum HirType:
    Int
    Str
    Bool
    Unit
    TypeParam(id: i64)
    Arrow(from: HirType, to: HirType)
    Generic(name: Symbol, args: [HirType])
    List(elem: HirType)


# ============================================================================
# HirType Methods (was: impl HirType:)
# ============================================================================

# Expression
enum Expr:
    IntLit(value: i64)
    StrLit(value: text)
    BoolLit(value: bool)
    Var(name: Symbol)
    Call(func: Expr, args: [Expr])
    If(cond: Expr, then_branch: Expr, else_branch: Expr)
    Block(stmts: [Expr])


# ============================================================================
# Expr Methods (was: impl Expr:)
# ============================================================================

# MacroParam
class MacroParam:
    name: Symbol
    ty: HirType
    is_variadic: bool


# ============================================================================
# MacroParam Methods (was: impl MacroParam:)
# ============================================================================

fn macroparam_regular(name: Symbol, ty: HirType) -> MacroParam:
        MacroParam(name: name, ty: ty, is_variadic: false)


fn macroparam_variadic(name: Symbol, elem_ty: HirType) -> MacroParam:
        MacroParam(name: name, ty: hirtype_List(elem: elem_ty), is_variadic: true)


# MacroDef
class MacroDef:
    name: Symbol
    params: [MacroParam]
    body: Expr
    expansion_ty: HirType
    hygiene_scope: i64


# ============================================================================
# MacroDef Methods (was: impl MacroDef:)
# ============================================================================

# MacroRegistry
class MacroRegistry:
    macros: text  # Dict<Symbol, MacroDef>
    next_hygiene_scope: i64


# ============================================================================
# MacroRegistry Methods (was: impl MacroRegistry:)
# ============================================================================

fn macroregistry_empty() -> MacroRegistry:
        MacroRegistry(macros: {}, next_hygiene_scope: 1)


# ============================================================================
# Macro Call
# ============================================================================

class MacroCall:
    """
    Macro call site

    Examples:
        @assert(x > 0, "x must be positive")
        @log("INFO", "message1", "message2")
    """
    name: Symbol
    args: [Expr]


# ============================================================================
# MacroCall Methods (was: impl MacroCall:)
# ============================================================================

fn macrocall_new_call(name: Symbol, args: [Expr]) -> MacroCall:
        MacroCall(name: name, args: args)


# ============================================================================
# Type Environment (Simplified)
# ============================================================================

class TypeEnv:
    """
    Type environment for inferring expression types

    Simplified: only handles literals and variables
    """
    vars: text  # Dict<Symbol, HirType>


# ============================================================================
# TypeEnv Methods (was: impl TypeEnv:)
# ============================================================================

fn typeenv_empty() -> TypeEnv:
        TypeEnv(vars: {})


# ============================================================================
# Macro Type Checker
# ============================================================================

class MacroTypeChecker:
    """
    Type checker for macro calls

    Validates:
    - Macro exists
    - Correct number of arguments
    - Argument types match parameters
    """
    registry: MacroRegistry
    type_env: TypeEnv


# ============================================================================
# MacroTypeChecker Methods (was: impl MacroTypeChecker:)
# ============================================================================

fn macrotypechecker_new_checker(registry: MacroRegistry) -> MacroTypeChecker:
        MacroTypeChecker(
            registry: registry,
            type_env: typeenv_empty()
        )


# ============================================================================
# Error Reporting
# ============================================================================

class MacroTypeError:
    """Macro type error"""
    message: text


# ============================================================================
# MacroTypeError Methods (was: impl MacroTypeError:)
# ============================================================================

fn macrotypeerror_macro_not_found(name: Symbol) -> MacroTypeError:
        MacroTypeError(message: "Macro '{name}' not found")


fn macrotypeerror_wrong_arity(name: Symbol, expected: i64, actual: i64) -> MacroTypeError:
        MacroTypeError(
            message: "Macro '{name}': expected {expected} arguments, got {actual}"
        )


fn macrotypeerror_type_mismatch(name: Symbol, arg_idx: i64, expected: HirType, actual: HirType) -> MacroTypeError:
        MacroTypeError(
            message: "Macro '{name}': argument {arg_idx} has type {actual.to_string()}, expected {expected.to_string()}"
        )


# ============================================================================
# Tests
# ============================================================================

fn test_macro_call():
    """Test macro call creation"""
    val args = [
        expr_BoolLit(value: true),
        Expr.StrLit(value: "msg")
    ]
    val call = MacroCall.new_call("assert", args)

    assert call.name == "assert", "Call name"
    assert call.arg_count() == 2, "Two arguments"

    print "âœ… Macro call creation"

fn test_type_env():
    """Test type environment"""
    val env = typeenv_empty()

    env.bind_var("x", HirType.Int)

    val ty = env.infer_expr(Expr.Var(name: "x"))
    assert ty.to_string() == "i32", "Variable type"

    val lit_ty = env_infer_expr(env, Expr.IntLit(value: 42))
    assert lit_ty.to_string() == "i32", "Literal type"

    print "âœ… Type environment"

fn test_check_valid_call():
    """Test valid macro call"""
    val registry = macroregistry_empty()

    # Register macro: assert(cond: bool, msg: text)
    val params = [
        MacroParam.regular("cond", HirType.Bool),
        MacroParam.regular("msg", HirType.Str)
    ]
    val macro_def = MacroDef.new_macro(
        "assert",
        params,
        expr_Block(stmts: []),
        HirType.Unit
    )
    registry_register_macro(registry, macro_def)

    # Create checker
    val checker = macrotypechecker_new_checker(registry)

    # Valid call: @assert(true, "message")
    val args = [
        expr_BoolLit(value: true),
        Expr.StrLit(value: "message")
    ]
    val call = MacroCall.new_call("assert", args)

    assert checker.check_macro_call(call), "Valid call"

    print "âœ… Valid macro call"

fn test_check_type_mismatch():
    """Test type mismatch error"""
    val registry = macroregistry_empty()

    # Register macro: assert(cond: bool, msg: text)
    val params = [
        MacroParam.regular("cond", HirType.Bool),
        MacroParam.regular("msg", HirType.Str)
    ]
    val macro_def = MacroDef.new_macro(
        "assert",
        params,
        expr_Block(stmts: []),
        HirType.Unit
    )
    registry_register_macro(registry, macro_def)

    val checker = macrotypechecker_new_checker(registry)

    # Invalid call: @assert(42, "message") - first arg is i32, not bool
    val args = [
        expr_IntLit(value: 42),
        Expr.StrLit(value: "message")
    ]
    val call = MacroCall.new_call("assert", args)

    assert not checker.check_macro_call(call), "Type mismatch detected"

    print "âœ… Type mismatch detection"

fn test_check_wrong_arity():
    """Test wrong arity error"""
    val registry = macroregistry_empty()

    # Register macro: assert(cond: bool, msg: text)
    val params = [
        MacroParam.regular("cond", HirType.Bool),
        MacroParam.regular("msg", HirType.Str)
    ]
    val macro_def = MacroDef.new_macro(
        "assert",
        params,
        expr_Block(stmts: []),
        HirType.Unit
    )
    registry_register_macro(registry, macro_def)

    val checker = macrotypechecker_new_checker(registry)

    # Invalid call: @assert(true) - missing second argument
    val args = [expr_BoolLit(value: true)]
    val call = MacroCall.new_call("assert", args)

    assert not checker.check_macro_call(call), "Wrong arity detected"

    print "âœ… Wrong arity detection"

fn test_check_variadic_call():
    """Test variadic macro call"""
    val registry = macroregistry_empty()

    # Register macro: log(...msgs: [text])
    val params = [
        MacroParam.variadic("msgs", HirType.Str)
    ]
    val macro_def = MacroDef.new_macro(
        "log",
        params,
        expr_Block(stmts: []),
        HirType.Unit
    )
    registry_register_macro(registry, macro_def)

    val checker = macrotypechecker_new_checker(registry)

    # Valid call: @log("a", "b", "c")
    val args = [
        Expr.StrLit(value: "a"),
        Expr.StrLit(value: "b"),
        Expr.StrLit(value: "c")
    ]
    val call = MacroCall.new_call("log", args)

    assert checker.check_macro_call(call), "Variadic call valid"

    # Valid call: @log() - zero arguments OK for variadic
    val empty_call = MacroCall.new_call("log", [])
    assert checker.check_macro_call(empty_call), "Empty variadic call valid"

    print "âœ… Variadic macro call"

fn test_macro_not_found():
    """Test macro not found error"""
    val registry = macroregistry_empty()
    val checker = macrotypechecker_new_checker(registry)

    val call = MacroCall.new_call("unknown", [])

    assert not checker.check_macro_call(call), "Macro not found detected"

    print "âœ… Macro not found detection"

fn test_get_expansion_type():
    """Test getting expansion type"""
    val registry = macroregistry_empty()

    # Register macro with i32 expansion type
    val macro_def = MacroDef.new_macro(
        "double",
        [MacroParam.regular("x", HirType.Int)],
        Expr.Var(name: "x"),
        HirType.Int
    )
    registry_register_macro(registry, macro_def)

    val checker = macrotypechecker_new_checker(registry)

    val call = MacroCall.new_call("double", [Expr.IntLit(value: 5)])
    val exp_ty = checker_get_expansion_type(checker, call)

    assert exp_ty.to_string() == "i32", "Expansion type"

    print "âœ… Get expansion type"

fn test_error_messages():
    """Test error message generation"""
    val err1 = MacroTypeError.macro_not_found("unknown")
    assert err1.to_string().len() > 0, "Macro not found message"

    val err2 = MacroTypeError.wrong_arity("test", 2, 1)
    assert err2.to_string().len() > 0, "Wrong arity message"

    val err3 = MacroTypeError.type_mismatch("test", 0, HirType.Bool, HirType.Int)
    assert err3.to_string().len() > 0, "Type mismatch message"

    print "âœ… Error messages"

fn main():
    print ""
    print "Macro Type Checking Phase 7B Tests"
    print "==================================="

    test_macro_call()
    test_type_env()
    test_check_valid_call()
    test_check_type_mismatch()
    test_check_wrong_arity()
    test_check_variadic_call()
    test_macro_not_found()
    test_get_expansion_type()
    test_error_messages()

    print ""
    print "ðŸŽ‰ Phase 7B Complete!"
    print ""
    print "Implemented:"
    print "  âœ… MacroCall - macro call site representation"
    print "  âœ… MacroTypeChecker - call validation"
    print "  âœ… TypeEnv - type inference for expressions"
    print "  âœ… Arity checking (regular + variadic)"
    print "  âœ… Type matching for arguments"
    print "  âœ… Expansion type inference"
    print "  âœ… MacroTypeError - error messages"
    print ""
    print "Progress: 7/15 hours (47% of Phase 7)"
    print "Next: Phase 7C - Macro Expansion Type Inference (5h)"
