"""
Associated Types - Phase 4A: Associated Type Definitions

Extends the trait system with associated types.

Status: Phase 4A In Progress
"""

type Symbol = text

# ============================================================================
# Type System (Simplified)
# ============================================================================

enum HirType:
    Int
    Str
    Bool
    Named(name: Symbol)
    Generic(name: Symbol, args: [HirType])
    Projection(base: HirType, assoc_name: Symbol)  # NEW: T.Item
    Error  # NEW: For unresolved projections


# ============================================================================
# HirType Methods (was: impl HirType:)
# ============================================================================

# ============================================================================
# Trait Reference (from Phase 2)
# ============================================================================

class TraitRef:
    name: text


# ============================================================================
# TraitRef Methods (was: impl TraitRef:)
# ============================================================================

fn traitref_new(name: Symbol) -> TraitRef:
        TraitRef(name: name)


# ============================================================================
# Associated Type Definition
# ============================================================================

class AssocTypeDef:
    """
    Associated type definition in a trait

    Example:
        trait Iterator:
            type Item           # No bounds, no default
            type Error: Display # With bound
            type Index = i64    # With default
    """
    name: text
    bounds: text       # Placeholder for [TraitRef]
    default_type: text # Placeholder for Option<HirType>


# ============================================================================
# AssocTypeDef Methods (was: impl AssocTypeDef:)
# ============================================================================

fn assoctypedef_new(name: Symbol) -> AssocTypeDef:
        AssocTypeDef(
            name: name,
            bounds: "[]",
            default_type: "None"
        )


fn assoctypedef_with_bounds(name: Symbol, bounds: [TraitRef]) -> AssocTypeDef:
        val assoc_type = assoctypedef_new(name)
        val bounds_dict = {}
        for bound in bounds:
            bounds_dict[bound.name] = bound
        val new_assoc = AssocTypeDef(
            name: name,
            bounds: bounds_dict,
            default_type: "None"
        )
        new_assoc


fn assoctypedef_with_default(name: Symbol, default_type: HirType) -> AssocTypeDef:
        val assoc_type = assoctypedef_new(name)
        val new_assoc = AssocTypeDef(
            name: name,
            bounds: "[]",
            default_type: default_type
        )
        new_assoc


# ============================================================================
# Extended Trait Definition
# ============================================================================

class TraitDefEx:
    """
    Extended trait definition with associated types

    Example:
        trait Iterator:
            type Item           # Associated type
            fn next() -> Item  # Method using associated type
    """
    name: text
    methods: text      # Placeholder for [MethodSig]
    supertraits: text  # Placeholder for [Symbol]
    assoc_types: text  # Dict<Symbol, AssocTypeDef>


# ============================================================================
# TraitDefEx Methods (was: impl TraitDefEx:)
# ============================================================================

fn traitdefex_new(name: Symbol) -> TraitDefEx:
        TraitDefEx(
            name: name,
            methods: "[]",
            supertraits: "[]",
            assoc_types: {}
        )


# ============================================================================
# Extended Trait Registry
# ============================================================================

class TraitRegistryEx:
    """
    Extended trait registry supporting associated types
    """
    traits: text  # Dict<Symbol, TraitDefEx>


# ============================================================================
# TraitRegistryEx Methods (was: impl TraitRegistryEx:)
# ============================================================================

fn traitregistryex_new() -> TraitRegistryEx:
        val registry_data = {
            "traits": {}
        }
        TraitRegistryEx(traits: registry_data)


fn traitregistryex_register_trait(self: TraitRegistryEx, trait_def: TraitDefEx) -> bool:
        """Register a trait definition"""
        val traits = self.traits["traits"]

        if traits.contains(trait_def.name):
            return false  # Already registered

        traits[trait_def.name] = trait_def
        true


# ============================================================================
# Tests
# ============================================================================

fn test_assoc_type_basic():
    """Test basic associated type definition"""
    val item_type = AssocTypeDef.new("Item")

    assert item_type.name == "Item"  # Name is Item
    # TODO: assert not item_type.has_bounds(), "No bounds")
    # TODO: assert not item_type.has_default(), "No default")
    # TODO: assert item_type.to_string() == "type Item", "String representation")

    print "âœ… Basic associated type"

fn test_multiple_assoc_types():
    """Test trait with multiple associated types"""
    val trait_def = TraitDefEx.new("Collection")

    val item_type = AssocTypeDef.new("Item")
    val index_type = AssocTypeDef.new("Index")

    trait_def_add_assoc_type(trait_def, item_type)
    trait_def_add_assoc_type(trait_def, index_type)

    # TODO: assert trait_def.assoc_type_count() == 2, "Two associated types")
    # TODO: assert trait_def.has_assoc_type("Item"), "Has Item")
    # TODO: assert trait_def.has_assoc_type("Index"), "Has Index")
    # TODO: assert not trait_def.has_assoc_type("Unknown"), "No Unknown")

    print "âœ… Multiple associated types"

fn test_assoc_type_with_bounds():
    """Test associated type with trait bounds"""
    val display_ref = TraitRef.new("Display")
    val node_type = AssocTypeDef.with_bounds("Node", [display_ref])

    assert node_type.name == "Node"  # Name is Node
    # TODO: assert node_type.has_bounds(), "Has bounds")
    # TODO: assert not node_type.has_default(), "No default")

    print "âœ… Associated type with bounds"

fn test_default_assoc_type():
    """Test associated type with default"""
    val index_type = AssocTypeDef.with_default("Index", HirType.Int)

    assert index_type.name == "Index"  # Name is Index
    # TODO: assert not index_type.has_bounds(), "No bounds")
    # TODO: assert index_type.has_default(), "Has default")

    print "âœ… Default associated type"

fn test_builtin_iterator_trait():
    """Test built-in Iterator trait"""
    val registry = traitregistryex_new()
    registry_define_builtin_traits(registry)

    # TODO: assert registry.has_trait("Iterator"), "Has Iterator trait")

    val iterator = registry.get_trait("Iterator")
    # TODO: assert iterator.assoc_type_count() == 1, "Iterator has 1 assoc type")
    # TODO: assert iterator.has_assoc_type("Item"), "Iterator has Item")

    val item = iterator.get_assoc_type("Item")
    assert item.name == "Item"  # Item assoc type

    print "âœ… Built-in Iterator trait"

fn test_trait_registry_ex():
    """Test extended trait registry"""
    val registry = traitregistryex_new()

    # TODO: assert registry.count_traits() == 0, "Empty initially")

    # Register Iterator trait
    val iterator = TraitDefEx.new("Iterator")
    val item = AssocTypeDef.new("Item")
    iterator_add_assoc_type(iterator, item)

    val registered = registry_register_trait(registry, iterator)
    assert registered  # Registered
    # TODO: assert registry.count_traits() == 1, "One trait")

    # Lookup
    val found = registry.get_trait("Iterator")
    assert found.name == "Iterator"  # Found Iterator
    # TODO: assert found.has_assoc_type("Item"), "Has Item")

    print "âœ… Extended trait registry"

fn test_projection_type():
    """Test projection type representation"""
    val base = HirType.Named(name: "T")
    val projection = HirType.Projection(base: base, assoc_name: "Item")

    # TODO: assert projection.to_string() == "T.Item", "Projection string")
    # TODO: assert projection.type_name() == "T", "Base type name")

    print "âœ… Projection type"

fn test_builtin_collection():
    """Test Collection trait with default Index"""
    val registry = traitregistryex_new()
    registry_define_builtin_traits(registry)

    val collection = registry.get_trait("Collection")
    # TODO: assert collection.assoc_type_count() == 2, "Two assoc types")
    # TODO: assert collection.has_assoc_type("Item"), "Has Item")
    # TODO: assert collection.has_assoc_type("Index"), "Has Index")

    val index = collection.get_assoc_type("Index")
    # TODO: assert index.has_default(), "Index has default")

    print "âœ… Collection with default Index"

fn main():
    print ""
    print "Associated Types Phase 4A Tests"
    print "================================"

    test_assoc_type_basic()
    test_multiple_assoc_types()
    test_assoc_type_with_bounds()
    test_default_assoc_type()
    test_builtin_iterator_trait()
    test_trait_registry_ex()
    test_projection_type()
    test_builtin_collection()

    print ""
    print "ðŸŽ‰ Phase 4A Complete!"
    print ""
    print "Implemented:"
    print "  âœ… AssocTypeDef - associated type definitions"
    print "  âœ… TraitDefEx - extended trait with associated types"
    print "  âœ… TraitRegistryEx - registry with assoc type support"
    print "  âœ… Built-in Iterator trait with Item"
    print "  âœ… Built-in Collection trait with Item and Index"
    print "  âœ… HirType.Projection for T.Item syntax"
    print "  âœ… Associated type bounds and defaults"
    print ""
    print "Progress: 2/8 hours (25% of Phase 4)"
    print "Next: Phase 4B - Associated Type Implementations (2h)"
