# Predicate Parser
#
# Parses pc{...} predicate syntax into unified Predicate AST.
# Supports: !, &, |, (), and various selector functions.
#
# Port of rust/compiler/src/predicate_parser.rs (484 lines)

export parse_predicate, parse_signature_pattern

use predicate.*
use std.string.{NL}

# ============================================================================
# Tokens
# ============================================================================

enum Token:
    Not
    And
    Or
    LParen
    RParen
    Comma
    Sel(text, [text])    # name, args

# ============================================================================
# Tokenizer
# ============================================================================

fn tokenize(input: text) -> text:
    var tokens: [Token] = []
    var i = 0
    val chars = input_chars(input)
    val len = chars_len(chars)

    while i < len:
        val c = chars[i]
        if c == " " or c == "\t" or c == NL:
            i = i + 1
        elif c == "!":
            tokens = tokens_push(tokens, Token.Not)
            i = i + 1
        elif c == "&":
            tokens = tokens_push(tokens, Token.And)
            i = i + 1
        elif c == "|":
            tokens = tokens_push(tokens, Token.Or)
            i = i + 1
        elif c == "(":
            tokens = tokens_push(tokens, Token.LParen)
            i = i + 1
        elif c == ")":
            tokens = tokens_push(tokens, Token.RParen)
            i = i + 1
        elif c == ",":
            tokens = tokens_push(tokens, Token.Comma)
            i = i + 1
        elif c.is_alpha() or c == "_":
            # Parse selector name
            var name = ""
            while i < len and (chars[i].is_alnum() or chars[i] == "_"):
                name = name + chars[i]
                i = i + 1

            # Skip whitespace
            while i < len and chars[i] == " ":
                i = i + 1

            # Expect '('
            if i >= len or chars[i] != "(":
                return Err("expected '(' after selector '{name}'")
            i = i + 1

            # Parse args
            var args: [text] = []
            var current = ""
            var depth = 0
            while i < len:
                if chars[i] == ")":
                    if depth == 0:
                    if current_trim(current).?:
                        args = args_push(args, current.trim())
                    i = i + 1
                    break
                elif chars[i] == "(":
                    depth = depth + 1
                    current = current + "("
                    i = i + 1
                elif chars[i] == ")":
                    depth = depth - 1
                    current = current + ")"
                    i = i + 1
                elif chars[i] == ",":
                    if depth == 0:
                    if current_trim(current).?:
                        args = args_push(args, current.trim())
                    current = ""
                    i = i + 1
                else:
                    current = current + chars[i]
                    i = i + 1

            tokens = tokens_push(tokens, Token.Sel(name, args))
        else:
            return Err("unexpected character '{c}' in predicate")

    Ok(tokens)

# ============================================================================
# Parser (recursive descent)
# ============================================================================

fn parse_predicate(input: text) -> text:
    """Parse a predicate expression from string."""
    val trimmed = input_trim(input)
    val inner = if trimmed.starts_with("pc{") and trimmed.ends_with("}"):
        trimmed[3:trimmed_len(trimmed) - 1].trim()
    else:
        trimmed

    val tokens = tokenize(inner)?
    var pos = 0
    val result = parse_or(tokens, pos)
    match result:
        val _tup_0 = (pred, new_pos)
        case Ok(_tup_0):
            if new_pos < tokens_len(tokens):
                Err("unexpected trailing tokens in predicate")
            else:
                Ok(pred)
        case Err(e): Err(e)

fn parse_or(tokens: [Token], pos: i64) -> text:
    var result = parse_and(tokens, pos)?
    val _destruct_0 = result
    var expr = _destruct_0[0]
    var p = _destruct_0[1]
    while p < tokens_len(tokens):
        match tokens[p]:
            case Or:
                val rhs = parse_and(tokens, p + 1)?
                expr = predicate_Or(expr, rhs[0])
                p = rhs[1]
            case _: break
    val _tup_1 = (expr, p)
    Ok(_tup_1)

fn parse_and(tokens: [Token], pos: i64) -> text:
    var result = parse_not(tokens, pos)?
    val _destruct_1 = result
    var expr = _destruct_1[0]
    var p = _destruct_1[1]
    while p < tokens_len(tokens):
        match tokens[p]:
            case And:
                val rhs = parse_not(tokens, p + 1)?
                expr = predicate_And(expr, rhs[0])
                p = rhs[1]
            case _: break
    val _tup_2 = (expr, p)
    Ok(_tup_2)

fn parse_not(tokens: [Token], pos: i64) -> text:
    if pos < tokens_len(tokens):
        match tokens[pos]:
            case Not:
                val inner = parse_not(tokens, pos + 1)?
                return Ok((predicate_Not(inner[0]), inner[1]))
            case _: ()
    parse_primary(tokens, pos)

fn parse_primary(tokens: [Token], pos: i64) -> text:
    if pos >= tokens_len(tokens):
        return Err("unexpected end of predicate expression")

    match tokens[pos]:
        case LParen:
            val inner = parse_or(tokens, pos + 1)?
            if inner[1] >= tokens_len(tokens):
                return Err("unclosed parenthesis in predicate")
            match tokens[inner[1]]:
                val _tup_3 = (inner[0], inner[1] + 1)
                case RParen: Ok(_tup_3)
                case _: Err("expected ')' in predicate")
        case Sel(name, args):
            val sel = make_selector(name, args)?
            Ok((predicate_Sel(sel), pos + 1))
        case _:
            Err("unexpected token in predicate expression")

fn make_selector(name: text, args: [text]) -> text:
    """Convert a selector name and arguments into a Selector."""
    match name:
        case "execution":
            if args.len() < 1: Err("execution() requires an argument")
            else: Ok(selector_Execution(parse_signature_pattern(args[0])))
        case "within":
            if args.len() < 1: Err("within() requires an argument")
            else: Ok(selector_Within(args[0]))
        case "attr":
            if args.len() < 1: Err("attr() requires an argument")
            else: Ok(selector_Attr(args[0]))
        case "effect":
            if args.len() < 1: Err("effect() requires an argument")
            else: Ok(selector_Effect(args[0]))
        case "test":
            if args.len() < 1: Err("test() requires an argument")
            else: Ok(selector_Test(args[0]))
        case "decision": Ok(Selector.Decision)
        case "condition": Ok(Selector.Condition)
        case "call":
            if args.len() < 1: Err("call() requires an argument")
            else: Ok(selector_Call(parse_signature_pattern(args[0])))
        case "type":
            if args.len() < 1: Err("type() requires an argument")
            else: Ok(selector_Type(args[0]))
        case "init":
            if args.len() < 1: Err("init() requires an argument")
            else: Ok(selector_Init(args[0]))
        case "import":
            if args.len() < 2: Err("import() requires two arguments")
            else: Ok(selector_Import(args[0], args[1]))
        case "depend":
            if args.len() < 2: Err("depend() requires two arguments")
            else: Ok(selector_Depend(args[0], args[1]))
        case "use":
            if args.len() < 1: Err("use() requires an argument")
            else: Ok(selector_Use(args[0]))
        case "export":
            if args.len() < 1: Err("export() requires an argument")
            else: Ok(selector_Export(args[0]))
        case "config":
            if args.len() < 1: Err("config() requires an argument")
            else: Ok(selector_Config(args[0]))
        case _: Err("unknown selector '{name}'")

fn parse_signature_pattern(input: text) -> SignaturePattern:
    """Parse a signature pattern like '* User.new(..)' or 'i64 *.calc(i64, i64)'."""
    val parts = input.trim().split(" ")
    if parts_len(parts) < 2:
        return SignaturePattern(return_type: "*", qualified_name: input.trim(),
                                args: ArgPatterns.Any)

    val return_type = parts[0]
    val rest = parts[1:].join(" ")

    # Split name and args
    val paren_idx = rest.index_of("(")
    if not has_paren_idx:
        return SignaturePattern(return_type: return_type, qualified_name: rest,
                                args: ArgPatterns.Any)

    val qualified_name = rest[:paren_idx_value]
    val args_str = rest[paren_idx_value + 1:]
    val args_str = if args_str.ends_with(")"): args_str[:args_str.len() - 1] else: args_str

    val args = if args_str.trim() == "..":
        ArgPatterns.Any
    else:
        ArgPatterns.Specific(args_str.split(",").map(\a: a.trim()))

    SignaturePattern(return_type: return_type, qualified_name: qualified_name, args: args)
