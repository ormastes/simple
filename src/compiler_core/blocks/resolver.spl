# Block Resolver
#
# Resolves blocks from outline to typed values.
# This is a phase between TreeSitter (outline) and Parser (full AST).

use blocks.registry.{BlockRegistry, block_registry}
use blocks.definition.{BlockDefinition}
use blocks.context.{BlockContext, BlockError, Diagnostic, DiagnosticLevel}
use blocks.value.{BlockValue, ResolvedBlock}
use blocks.modes.{Span, PreLexInfo}
use treesitter.{OutlineModule, BlockOutline}

# ============================================================================
# Resolved Module
# ============================================================================

struct ResolvedModule:
    """Module outline with resolved blocks.

    Contains the original outline plus all blocks that have been
    parsed and resolved to typed values.
    """
    outline: OutlineModule
    blocks: [ResolvedBlock]
    block_map: Dict<Span, ResolvedBlock>  # Lookup by span for parser


# ============================================================================
# ResolvedModule Methods (was: impl ResolvedModule:)
# ============================================================================

fn resolvedmodule_new(outline: OutlineModule, blocks: [ResolvedBlock]) -> ResolvedModule:
        # Build span -> block map for efficient lookup
        var block_map: Dict<Span, ResolvedBlock> = {}
        for block in blocks:
            block_map = block_map_insert(block_map, block.span, block)

        ResolvedModule(
            outline: outline,
            blocks: blocks,
            block_map: block_map
        )


# ============================================================================
# Block Resolver
# ============================================================================

struct BlockResolver:
    """Resolves blocks from outline to typed values.

    Takes block outlines captured by TreeSitter and calls the appropriate
    block handlers to parse their payloads.

    Usage:
        val ts = treesitter_new(source)
        val outline = ts_parse_outline(ts)

        val _destruct_0 = blockresolver_resolve_module(outline)
        val resolved = _destruct_0[0]
        val diagnostics = _destruct_0[1]
        if diagnostics_has_errors(diagnostics):
            return Err(diagnostics)

        val parser = parser_new(source, resolved)
    """
    registry: BlockRegistry
    diagnostics: [Diagnostic]
    # # DESUGARED: file_path: text
    has_file_path: bool
    file_path: text
    # # DESUGARED: module_name: text
    has_module_name: bool
    module_name: text


# ============================================================================
# BlockResolver Methods (was: impl BlockResolver:)
# ============================================================================

fn blockresolver_new() -> BlockResolver:
        BlockResolver(
            registry: block_registry(),
            diagnostics: []
            #  # DESUGARED: file_path: nil
            ## DESUGARED: module_name: nil
        )


fn blockresolver_with_registry(registry: BlockRegistry) -> BlockResolver:
        BlockResolver(
            registry: registry,
            diagnostics: []
            #  # DESUGARED: file_path: nil
            ## DESUGARED: module_name: nil
        )


fn blockresolver_with_file(self: BlockResolver, path: text) -> BlockResolver:
        self.file_path = path
        self


fn blockresolver_with_module(self: BlockResolver, name: text) -> BlockResolver:
        self.module_name = name
        self


fn blockresolver_make_context(self: BlockResolver, block: BlockOutline) -> BlockContext:
        """Build a BlockContext for a block outline."""
        var ctx = BlockContext.new(
            block.payload,
            block.payload_span,
            block.span
        )

        if self.has_file_path:
            ctx = ctx_with_file(ctx, self.file_path_value)

        if self.has_module_name:
            ctx = ctx_with_module(ctx, self.module_name_value)

        if block.has_parent_context:
            ctx = ctx_inside_block(ctx, block.parent_context_value)

        if block.has_pre_lex_info:
            ctx = ctx_with_pre_lex(ctx, block.pre_lex_info_value)

        ctx


# ============================================================================
# Resolution Result Helpers
# ============================================================================

struct ResolutionResult:
    """Result of block resolution with convenient accessors."""
    module: ResolvedModule
    diagnostics: [Diagnostic]


# ============================================================================
# ResolutionResult Methods (was: impl ResolutionResult:)
# ============================================================================

# ============================================================================
# Convenience Functions
# ============================================================================

fn make_block_resolver() -> BlockResolver:
    """Create a new BlockResolver with default settings."""
    BlockResolver(
        registry: block_registry(),
        diagnostics: []
        #  # DESUGARED: file_path: nil
        ## DESUGARED: module_name: nil
    )

fn resolve_blocks(outline: OutlineModule) -> (ResolvedModule, [Diagnostic]):
    """Resolve all blocks in an outline module.

    Convenience function using the global block registry.
    """
    var resolver = make_block_resolver()
    resolver_resolve(resolver, outline)

fn resolve_blocks_with_registry(
    outline: OutlineModule,
    registry: BlockRegistry
) -> (ResolvedModule, [Diagnostic]):
    """Resolve all blocks using a custom registry."""
    var resolver = BlockResolver(
        registry: registry,
        diagnostics: [],
        file_path: nil,
        module_name: nil
    )
    resolver_resolve(resolver, outline)

# ============================================================================
# Exports
# ============================================================================

export BlockResolver, ResolvedModule, ResolutionResult
export resolve_blocks, resolve_blocks_with_registry, make_block_resolver
