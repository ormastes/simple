# Block Registry
#
# Central registry for block definitions.

use blocks.definition.{BlockDefinition}
use blocks.modes.{LexerMode, SyntaxFeatures}
use blocks.builtin.{MathBlockDef, LossBlockDef, NogradBlockDef, ShellBlockDef, SqlBlockDef, RegexBlockDef, JsonBlockDef, MarkdownBlockDef}

# ============================================================================
# Block Registry
# ============================================================================

struct BlockRegistry:
    """Central registry for block definitions.

    The registry maps block keywords to their definitions.
    Use `BlockRegistry__default()` to get a registry with built-in blocks.

    Example:
    ```simple
    val registry = BlockRegistry__default()

    # Check if a keyword is a block
    if registry.is_block_keyword("sql"):
        val blk = registry.lookup("sql").unwrap()
        val mode = blk_lexer_mode(blk)
    ```
    """
    blocks: Dict<text, BlockDefinition>


# ============================================================================
# BlockRegistry Methods (was: impl BlockRegistry:)
# ============================================================================

fn blockregistry_new() -> BlockRegistry:
        """Create an empty registry."""
        BlockRegistry(blocks: {})


fn blockregistry_default() -> BlockRegistry:
        """Create a registry with all built-in blocks.

        Built-in blocks:
        - Math/ML: m, loss, nograd
        - DSL: sh, sql, re, json, md

        Built-in blocks are registered in simple/compiler/blocks/builtin.spl.
        """
        var reg = BlockRegistry__new()

        # Register built-in blocks (imported at module level)
        # Math/ML blocks
        reg_register(reg, MathBlockDef())
        reg_register(reg, LossBlockDef())
        reg_register(reg, NogradBlockDef())

        # DSL blocks
        reg_register(reg, ShellBlockDef())
        reg_register(reg, SqlBlockDef())
        reg_register(reg, RegexBlockDef())
        reg_register(reg, JsonBlockDef())
        reg_register(reg, MarkdownBlockDef())

        reg


fn blockregistry_unregister(self: BlockRegistry, kind: text) -> bool:
        """Unregister a block by keyword.

        Returns true if the block was found and removed.
        """
        if self.blocks_contains_key(blocks, kind):
            self.blocks = self.blocks_remove(blocks, kind)
            true
        else:
            false


# ============================================================================
# Global Registry
# ============================================================================

# Global registry instance for convenience
# Use `block_registry()` to access
var _global_registry: BlockRegistry? = nil

fn block_registry() -> BlockRegistry:
    """Get the global block registry.

    Initializes with default blocks on first access.
    """
    if not has__global_registry:
        _global_registry = has_field = true, field_value = BlockRegistry__default()
    _global_registry_value

fn register_block(block_def: BlockDefinition):
    """Register a block in the global registry."""
    var reg = block_registry()
    reg_register(reg, block_def)

fn unregister_block(kind: text) -> bool:
    """Unregister a block from the global registry."""
    var reg = block_registry()
    reg_unregister(reg, kind)

fn is_block(kind: text) -> bool:
    """Check if a keyword is a registered block."""
    block_registry().is_block_keyword(kind)

fn get_block(kind: text):
    """Get a block definition from the global registry.

    Args:
        kind: Block keyword

    Returns:
        BlockDefinition if found, nil otherwise

    Example:
    ```simple
    if val has_field = true, field_value = blk = get_block("sql"):
        val mode = blk_lexer_mode(blk)
    ```
    """
    block_registry().lookup(kind)

fn list_blocks() -> [text]:
    """List all registered block keywords.

    Returns:
        Array of block keywords

    Example:
    ```simple
    val blocks = list_blocks()
    print "Registered blocks: {blocks.join(", ")}"
    ```
    """
    block_registry().all_keywords()

fn is_block_registered(kind: text) -> bool:
    """Check if a block is registered (alias for is_block).

    Args:
        kind: Block keyword

    Returns:
        true if registered, false otherwise
    """
    is_block(kind)

fn with_block(block_def, body):
    """Execute body with a temporarily registered block.

    The block is automatically unregistered after body completes.

    Args:
        block_def: Block definition to register temporarily
        body: Function to execute with block registered

    Returns:
        Result of body()

    Example:
    ```simple
    # Register block for test scope only
    val result = with_block(my_test_block, \:
        val value = myblock{ test content }
        assert(value == expected)
        value
    )
    # Block automatically unregistered here
    ```
    """
    val kind = block_def_kind(block_def)

    # Register temporary block
    register_block(block_def)

    # Execute body
    val result = body()

    # Cleanup: unregister
    unregister_block(kind)

    result

# ============================================================================
# Registry Builder (for configuration)
# ============================================================================

struct RegistryBuilder:
    """Builder for creating a custom BlockRegistry.

    Example:
    ```simple
    val registry = RegistryBuilder__new()
        .with_builtin()
        .register(MyBlockDef())
        .without("nograd")
        .build()
    ```
    """
    registry: BlockRegistry
    include_builtin: bool


# ============================================================================
# RegistryBuilder Methods (was: impl RegistryBuilder:)
# ============================================================================

fn registrybuilder_new() -> RegistryBuilder:
        RegistryBuilder(
            registry: BlockRegistry__new(),
            include_builtin: false
        )


fn registrybuilder_with_builtin(self: RegistryBuilder) -> RegistryBuilder:
        """Include built-in blocks (m, loss, nograd, sh, sql, re, json, md)."""
        self.include_builtin = true
        self


fn registrybuilder_register(self: RegistryBuilder, block_def: BlockDefinition) -> RegistryBuilder:
        """Register a block definition."""
        self.registry_register(registry, block_def)
        self


fn registrybuilder_without(self: RegistryBuilder, kind: text) -> RegistryBuilder:
        """Exclude a block (useful after with_builtin)."""
        self.registry_unregister(registry, kind)
        self


# ============================================================================
# Exports
# ============================================================================

export BlockRegistry, RegistryBuilder
export block_registry, register_block, unregister_block, is_block
export get_block, list_blocks, is_block_registered, with_block
