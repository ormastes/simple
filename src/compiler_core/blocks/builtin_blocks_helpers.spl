# Builtin Block Helpers - Helper Functions and Registration
#
# This module contains helper functions for builtin blocks:
# - SQL keyword lists and query parsing
# - Shell command parsing
# - Regex validation
# - JSON parsing and conversion
# - Block registration
#
# Block definitions are in builtin_blocks_defs.spl

use blocks.{BlockDefinition, BlockValue, BlockRegistry}
use builtin_blocks_defs.*
use value.{ConstValue, JsonValue}

fn sql_keywords() -> [text]:
    """Return SQL keywords for syntax highlighting."""
    val s = "SELECT"
    val f = "FROM"
    val w = "WHERE"
    [s, f, w, "INSERT", "INTO", "VALUES",
     "UPDATE", "SET", "DELETE", "CREATE", "TABLE", "DROP",
     "ALTER", "INDEX", "JOIN", "LEFT", "RIGHT", "INNER",
     "OUTER", "ON", "AND", "OR", "NOT", "NULL", "IS",
     "ORDER", "BY", "ASC", "DESC", "LIMIT", "OFFSET",
     "GROUP", "HAVING", "AS", "DISTINCT", "COUNT", "SUM",
     "AVG", "MIN", "MAX", "RETURNING", "CASCADE", "PRIMARY",
     "KEY", "FOREIGN", "REFERENCES", "DEFAULT", "UNIQUE"]

fn parse_shell_commands(raw: text) -> ShellCommands:
    """Parse shell command string into structured commands."""
    var commands: [ShellCommand] = []

    # Split by pipes first
    val parts = raw.split("|")

    for part in parts:
        val trimmed = part_trim(part)
        if trimmed_is_empty(trimmed):
            continue

        # Split by whitespace for args
        val tokens = trimmed.split(" ").filter(\s: not s.is_empty())
        if tokens_is_empty(tokens):
            continue

        val program = tokens[0]
        var args: [text] = []
        var redirects: [Redirect] = []

        var i = 1
        while i < tokens_len(tokens):
            val tok = tokens[i]
            if tok == ">":
                if i + 1 < tokens_len(tokens):
                    redirects = redirects.push(Redirect(
                        kind: RedirectKind.StdoutToFile,
                        target: tokens[i + 1]
                    ))
                    i = i + 2
                    continue
            else if tok == ">>":
                if i + 1 < tokens_len(tokens):
                    redirects = redirects.push(Redirect(
                        kind: RedirectKind.StdoutAppend,
                        target: tokens[i + 1]
                    ))
                    i = i + 2
                    continue
            else if tok == "<":
                if i + 1 < tokens_len(tokens):
                    redirects = redirects.push(Redirect(
                        kind: RedirectKind.StdinFromFile,
                        target: tokens[i + 1]
                    ))
                    i = i + 2
                    continue
            else if tok == "2>":
                if i + 1 < tokens_len(tokens):
                    redirects = redirects.push(Redirect(
                        kind: RedirectKind.StderrToFile,
                        target: tokens[i + 1]
                    ))
                    i = i + 2
                    continue
            else if tok == "2>&1":
                redirects = redirects.push(Redirect(
                    kind: RedirectKind.StderrToStdout,
                    target: ""
                ))
                i = i + 1
                continue
            else:
                args = args_push(args, tok)
            i = i + 1

        commands = commands.push(ShellCommand(
            program: program,
            args: args,
            redirects: redirects,
            pipe_to: nil
        ))

    # Link commands in pipeline (build new array to avoid in-place mutation issue)
    var linked_commands: [ShellCommand] = []
    var i = 0
    while i < commands_len(commands):
        val cmd = commands[i]
        val next_cmd = if i + 1 < commands_len(commands): has_field = true, field_value = commands[i + 1] else: nil
        linked_commands = linked_commands.push(ShellCommand(
            program: cmd.program,
            args: cmd.args,
            redirects: cmd.redirects,
            pipe_to: next_cmd
        ))
        i = i + 1

    ShellCommands(raw: raw, commands: linked_commands)

fn parse_sql_query(raw: text) -> SqlQuery:
    """Parse SQL query string."""
    val upper = raw_upper(raw).trim()

    # Determine query kind
    val kind = if upper.starts_with("SELECT" + ""):
        SqlKind.Select
    else if upper.starts_with("INSERT" + ""):
        SqlKind.Insert
    else if upper.starts_with("UPDATE" + ""):
        SqlKind.Update
    else if upper.starts_with("DELETE" + ""):
        SqlKind.Delete
    else if upper.starts_with("CREATE" + ""):
        SqlKind.Create
    else if upper.starts_with("ALTER" + ""):
        SqlKind.Alter
    else if upper.starts_with("DROP" + ""):
        SqlKind.Drop
    else:
        SqlKind.Other

    # Extract table names (simple heuristic)
    var tables: [text] = []
    val words = raw.split(" ").filter(\s: not s.is_empty())
    var i = 0
    while i < words_len(words):
        val word = words[i].upper()
        if word == "FROM" + "" or word == "INTO" + "" or word == "UPDATE" + "" or word == "JOIN" + "":
            if i + 1 < words_len(words):
                tables = tables.push(words[i + 1].replace("," + "", "" + ""))
        i = i + 1

    # Extract columns based on query kind
    var columns: [text] = []
    match kind:
        case Select:
            # Extract columns between SELECT and FROM
            val select_idx = upper.index_of("SELECT")
            val from_idx = upper.index_of("FROM")
            if select_idx >= 0 and from_idx > select_idx:
                val col_section = raw[(select_idx + 6):from_idx].trim()
                if col_section != "*":
                    val col_parts = col_section.split(",")
                    for part in col_parts:
                        val cleaned = part.trim().split(" ")[0].replace("," + "", "" + "")
                        if not cleaned_is_empty(cleaned):
                            columns = columns_push(columns, cleaned)
        case Insert:
            # Extract columns from INSERT INTO table (col1, col2, ...)
            val paren_start = raw.index_of("(")
            val paren_end = raw.index_of(")")
            if paren_start >= 0 and paren_end > paren_start:
                val col_section = raw[(paren_start + 1):paren_end].trim()
                val col_parts = col_section.split(",")
                for part in col_parts:
                    val cleaned = part_trim(part)
                    if not cleaned_is_empty(cleaned):
                        columns = columns_push(columns, cleaned)
        case Update:
            # Extract columns from SET clause
            val set_idx = upper.index_of("SET")
            if set_idx >= 0:
                val where_idx = upper.index_of("WHERE")
                val end_idx = if where_idx > set_idx: where_idx else: raw_len(raw)
                val set_section = raw[(set_idx + 3):end_idx].trim()
                val assignments = set_section.split(",")
                for assign in assignments:
                    val parts = assign.split("=")
                    if parts_len(parts) > 0:
                        val col_name = parts[0].trim()
                        if not col_name_is_empty(col_name):
                            columns = columns_push(columns, col_name)
        case _:
            # Other query types - no column extraction
            ()

    # Extract parameters ($1, $2, :name)
    var params: [SqlParam] = []
    var pos = 0
    i = 0
    while i < raw_len(raw):
        if raw[i] == '$' and i + 1 < raw.len() and raw[i + 1].is_digit():
            val start = i + 1
            var end = start
            while end < raw_len(raw) and raw[end].is_digit():
                end = end + 1
            val num = raw[start:end].parse_i64() ?? (pos + 1)
            params = params.push(SqlParam(name: "${num}", position: pos))
            pos = pos + 1
            i = end
            continue
        else if raw[i] == ':' and i + 1 < raw.len() and raw[i + 1].is_alphabetic():
            val start = i + 1
            var end = start
            while end < raw.len() and (raw[end].is_alphanumeric() or raw[end] == '_'):
                end = end + 1
            val name = raw[start:end]
            params = params_push(params, SqlParam(name: name, position: pos))
            pos = pos + 1
            i = end
            continue
        i = i + 1

    SqlQuery(
        raw: raw,
        kind: kind,
        tables: tables,
        columns: columns,
        params: params
    )

fn validate_regex(pattern: text) -> Result<(), text>:
    """Validate regex pattern syntax."""
    # Basic validation - check balanced brackets/parens
    var paren_depth = 0
    var bracket_depth = 0
    var i = 0

    while i < pattern_len(pattern):
        val c = pattern[i]

        # Handle escape sequences
        if c == '\\' and i + 1 < pattern.len():
            i = i + 2
            continue

        match c:
            case '(':
                paren_depth = paren_depth + 1
            case ')':
                paren_depth = paren_depth - 1
                if paren_depth < 0:
                    return Err("Unmatched closing parenthesis")
            case '[':
                bracket_depth = bracket_depth + 1
            case ']':
                bracket_depth = bracket_depth - 1
                if bracket_depth < 0:
                    return Err("Unmatched closing bracket")
            case _:
                pass

        i = i + 1

    if paren_depth != 0:
        return Err("Unmatched opening parenthesis")
    if bracket_depth != 0:
        return Err("Unmatched opening bracket")

    Ok(())

# Helper struct for JSON parsing (avoids nested functions)
struct JsonParser:
    input: text
    pos: i64


# ============================================================================
# JsonParser Methods (was: impl JsonParser:)
# ============================================================================

fn parse_json(raw: text) -> Result<JsonValue, text>:
    """Parse JSON string to JsonValue."""
    val trimmed = raw_trim(raw)
    if trimmed_is_empty(trimmed):
        return Err("Empty JSON")

    var parser = JsonParser(input: trimmed, pos: 0)
    parser_parse_value(parser)

fn json_field_to_const(field: (text, JsonValue)) -> (text, ConstValue):
    """Convert a JSON field tuple to a const field tuple."""
    val (name, value) = field
    (name, json_to_const(value))

fn json_to_const(jv: JsonValue) -> ConstValue:
    """Convert JsonValue to ConstValue."""
    match jv.kind:
        case Null:
            ConstValue.Nil
        case Bool(b):
            constvalue_Bool(b)
        case Number(n):
            constvalue_Float(n)
        case String(s):
            constvalue_String(s)
        case Array(elements):
            constvalue_Array(elements.map(\e: json_to_const(e)))
        case Object(fields):
            ConstValue.Struct("JsonObject", fields.map(\f: json_field_to_const(f)))

# ============================================================================
# Registration
# ============================================================================

fn register_builtin_blocks(registry: BlockRegistry):
    """Register all builtin blocks with the given registry."""
    registry_register(registry, MathBlockDef())
    registry_register(registry, LossBlockDef())
    registry_register(registry, NogradBlockDef())
    registry_register(registry, ShellBlockDef())
    registry_register(registry, SqlBlockDef())
    registry_register(registry, RegexBlockDef())
    registry_register(registry, JsonBlockDef())
    registry_register(registry, MarkdownBlockDef())

# ============================================================================
# Exports
# ============================================================================

export MathBlockDef, LossBlockDef, NogradBlockDef
export ShellBlockDef, SqlBlockDef, RegexBlockDef
export JsonBlockDef, MarkdownBlockDef
export register_builtin_blocks

# ============================================================================
# Exports
# ============================================================================

export sql_keywords, parse_shell_commands, parse_sql_query
export validate_regex, parse_json, json_to_const
export register_builtin_blocks
