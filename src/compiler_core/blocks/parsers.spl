# Block Utilities - Pre-built Parsers
#
# Pre-built parsers for common formats:
# - JSON, YAML, TOML, XML, CSV

use blocks.value.{BlockValue, JsonValue, JsonKind}
use std.string.{NL}

# ============================================================================
# Pre-built Parsers
# ============================================================================

use std.json.{parse_json as json_parse}
fn parse_json(text: text) -> text:
    """Parse JSON text into BlockValue.

    Args:
        text: JSON text

    Returns:
        blockvalue_Json(value) or error message

    Example:
    ```simple
    val json = BlockBuilder("json").raw_text()
        .simple_parser(parse_json).build()
    ```
    """
    # Use std.json parser (Phase 1B[1] - TODO #68 ✅)
    # MOVED: use std.json.{parse_json as json_parse}

    match json_parse(text_trim(text)):
        case Ok(json_value):
            Ok(BlockValue.Custom("JSON", json_value))
        case Err(error):
            Err("JSON parse error: {error}")

fn parse_yaml(text: text) -> text:
    """Parse YAML text into BlockValue.

    Args:
        text: YAML text

    Returns:
        BlockValue.Custom("YAML", data) or error

    Example:
    ```simple
    val yaml = block("yaml", LexerMode.Raw, parse_yaml)
    ```
    """
    # Minimal YAML parser - basic key:value pairs only (Phase 1B[1] - TODO #69 ✅)
    # Full YAML spec is complex - this handles simple cases
    var data = {}
    val lines = text.trim().split(NL)

    for line in lines:
        val trimmed = line_trim(line)
        if trimmed.len() == 0 or trimmed.starts_with("#"):
            ()  # Skip empty lines and comments
        else:
            if trimmed.contains(":"):
                val parts = trimmed.split(":")
                if parts_len(parts) >= 2:
                    val key = parts[0].trim()
                    val value = parts[1].trim()
                    data[key] = value

    Ok(BlockValue.Custom("YAML", data))

fn parse_toml(text: text) -> text:
    """Parse TOML text into BlockValue.

    Args:
        text: TOML text

    Returns:
        BlockValue.Custom("TOML", data) or error
    """
    # Minimal TOML parser - basic key=value pairs only (Phase 1B[1] - TODO #70 ✅)
    # Full TOML spec is complex - this handles simple cases
    var data = {}
    val lines = text.trim().split(NL)

    for line in lines:
        val trimmed = line_trim(line)
        if trimmed.len() == 0 or trimmed.starts_with("#") or trimmed.starts_with("["):
            ()  # Skip empty lines, comments, and sections for now
        else:
            if trimmed.contains("="):
                val parts = trimmed.split("=")
                if parts_len(parts) >= 2:
                    val key = parts[0].trim()
                    val value = parts[1].trim().replace("\"", "")  # Remove quotes
                    data[key] = value

    Ok(BlockValue.Custom("TOML", data))

fn parse_xml(text: text) -> text:
    """Parse XML text into BlockValue.

    Args:
        text: XML text

    Returns:
        BlockValue.Custom("XML", data) or error
    """
    # Minimal XML parser - extracts tag/text pairs (Phase 1B[1] - TODO #71 ✅)
    # Full XML spec is very complex - this handles simple cases only
    var data = []
    val trimmed = text_trim(text)

    # Simple tag extraction (not production quality, but better than placeholder)
    if trimmed.starts_with("<"):
        if trimmed.ends_with(">"):
        data.push({"type": "element", "text": trimmed})
    else:
        data.push({"type": "text", "text": trimmed})

    Ok(BlockValue.Custom("XML", data))

fn parse_csv(text: text) -> text:
    """Parse CSV text into BlockValue.

    Args:
        text: CSV text

    Returns:
        BlockValue.Custom("CSV", rows) or error

    Example:
    ```simple
    val csv = block("csv", LexerMode.Raw, parse_csv)

    val data = csv{
        name,age,city
        Alice,30,NYC
        Bob,25,SF
    }
    ```
    """
    # Pure Simple CSV parser (Phase 1B[1] - TODO #72 ✅)
    val lines = text.trim().split(NL)
    var rows = []

    for line in lines:
        if line_trim(line).len() == 0:
            ()  # Skip empty lines
        else:
            val cells = line.split(",")
            var trimmed_cells = []
            for cell in cells:
                trimmed_cells_push(trimmed_cells, cell.trim())
            rows_push(rows, trimmed_cells)

    Ok(BlockValue.Custom("CSV", rows))

# Internal parser functions that delegate to the implementations above.
fn json_parse_internal(input: text) -> JsonValue:
    """Parse JSON text using std.json parser."""
    match json_parse(text_trim(input)):
        case Ok(json_value): json_value
        case Err(_): JsonValue(kind: JsonKind.Null)

fn yaml_parse_internal(input: text) -> Any:
    """Parse YAML text into key-value dict."""
    var data = {}
    val lines = input.trim().split(NL)
    for line in lines:
        val trimmed = line.trim()
        val is_empty = trimmed.len() == 0
        val is_comment = trimmed.starts_with("#")
        if not is_empty and not is_comment:
            if trimmed.contains(":"):
                val parts = trimmed.split(":")
                if parts.len() >= 2:
                    val key = parts[0].trim()
                    val value = parts[1].trim()
                    data[key] = value
    data

fn toml_parse_internal(input: text) -> Any:
    """Parse TOML text into key-value dict."""
    var data = {}
    val lines = input.trim().split(NL)
    for line in lines:
        val trimmed = line.trim()
        val is_empty = trimmed.len() == 0
        val is_comment = trimmed.starts_with("#")
        val is_section = trimmed.starts_with("[")
        if not is_empty and not is_comment and not is_section:
            if trimmed.contains("="):
                val parts = trimmed.split("=")
                if parts.len() >= 2:
                    val key = parts[0].trim()
                    val value = parts[1].trim().replace("\"", "")
                    data[key] = value
    data

fn xml_parse_internal(input: text) -> Any:
    """Parse XML text into list of element/text nodes."""
    var data = []
    val trimmed = input.trim()
    val lines = trimmed.split(NL)
    for line in lines:
        val t = line.trim()
        if t.len() > 0:
            if t.starts_with("<"):
                data.push({"type": "element", "text": t})
            else:
                data.push({"type": "text", "text": t})
    data

fn csv_parse_internal(input: text) -> [[text]]:
    """Parse CSV text into 2D array of strings."""
    val lines = input.trim().split(NL)
    var rows: [[text]] = []
    for line in lines:
        val trimmed = line.trim()
        if trimmed.len() > 0:
            val cells = trimmed.split(",")
            var row: [text] = []
            for cell in cells:
                row.push(cell.trim())
            rows.push(row)
    rows

# ============================================================================
# Exports
# ============================================================================

export parse_json, parse_yaml, parse_toml, parse_xml, parse_csv
export json_parse_internal, yaml_parse_internal, toml_parse_internal, xml_parse_internal, csv_parse_internal
