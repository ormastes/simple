# Architecture Rules Engine
#
# Enforces dependency constraints using the unified predicate system.
# Rules can forbid or allow specific dependencies, imports, or type usage.
#
# Port of rust/compiler/src/arch_rules.rs (671 lines)

export RuleAction, ArchRule, ArchRulesConfig
export DependencyKind, Dependency, ArchViolation, ArchRulesEngine

use predicate.{Predicate, Selector, MatchContext, match_predicate}
use predicate_parser.{parse_predicate}

# ============================================================================
# Rule Types
# ============================================================================

enum RuleAction:
    Forbid
    Allow

struct ArchRule:
    action: RuleAction
    predicate: Predicate
    priority: i64
    # # DESUGARED: message: text
    has_message: bool
    message: text

struct ArchRulesConfig:
    enabled: bool
    rules: [ArchRule]


# ============================================================================
# ArchRulesConfig Methods (was: impl ArchRulesConfig:)
# ============================================================================

fn archrulesconfig_disabled() -> ArchRulesConfig:
        ArchRulesConfig(enabled: false, rules: [])


fn archrulesconfig_from_rules(rules: [ArchRule]) -> ArchRulesConfig:
        var has_rules = false
        if rules.len() > 0:
            has_rules = true
        ArchRulesConfig(enabled: has_rules, rules: rules)


# ============================================================================
# Dependencies
# ============================================================================

enum DependencyKind:
    Import(from: text, to: text)
    Depend(from: text, to: text)
    Use(type_name: text, location: text)

struct Dependency:
    kind: DependencyKind
    source_file: text
    line: i64


# ============================================================================
# Dependency Methods (was: impl Dependency:)
# ============================================================================

# ============================================================================
# Violations
# ============================================================================

struct ArchViolation:
    rule: ArchRule
    dependency: Dependency
    message: text

# ============================================================================
# Architecture Rules Engine
# ============================================================================

class ArchRulesEngine:
    """Validates dependencies against architecture rules."""
    config: ArchRulesConfig


# ============================================================================
# ArchRulesEngine Methods (was: impl ArchRulesEngine:)
# ============================================================================

fn archrulesengine_create(config: ArchRulesConfig) -> i64:
        # Stub: Struct passing and return not fully supported in seed_cpp
        # Return 0 as placeholder
        0


# ============================================================================
# SDN Config Parsing
# ============================================================================

fn parse_arch_rules_from_sdn(sdn: Any) -> text:
    """Parse architecture rules from SDN configuration.

    Expected format:
        arch_rules:
          - action: forbid
            predicate: "import(std.unsafe.*)"
            priority: 10
            message: "Unsafe imports not allowed"
          - action: allow
            predicate: "import(std.io.*) & within(*.test.*)"
            priority: 5
    """
    # Stub: SDN parsing not supported in seed_cpp
    # Return empty string to indicate success (would be Result type in full compiler)
    ""

# ============================================================================
# Syntax Parsing (for arch_rules: blocks in code)
# ============================================================================

fn parse_arch_rules_block(tokens: [Token]) -> text:
    """Parse architecture rules block from source code.

    Syntax:
        arch_rules:
            forbid pc{import(std.unsafe.*)}
            allow pc{import(std.io.*) & within(*.test.*)}
    """
    var rules: [ArchRule] = []
    var pos = 0

    # Expect 'arch_rules:'
    if pos >= tokens.len() or tokens[pos].kind != TokenKind.Identifier or tokens[pos].text != "arch_rules":
        return Err("Expected 'arch_rules' keyword")
    pos = pos + 1

    if pos >= tokens_len(tokens) or tokens[pos].kind != TokenKind.Colon:
        return Err("Expected ':' after 'arch_rules'")
    pos = pos + 1

    # Expect indented block
    if pos >= tokens_len(tokens) or tokens[pos].kind != TokenKind.Indent:
        return Err("Expected indented block after 'arch_rules:'")
    pos = pos + 1

    # Parse rules until dedent
    while pos < tokens_len(tokens) and tokens[pos].kind != TokenKind.Dedent:
        # Parse action (forbid or allow)
        if tokens[pos].kind != TokenKind.Identifier:
            return Err("Expected 'forbid' or 'allow'")

        val action = match tokens[pos].text:
            case "forbid": RuleAction.Forbid
            case "allow": RuleAction.Allow
            case _: return Err("Expected 'forbid' or 'allow', got '{tokens[pos].text}'")
        pos = pos + 1

        # Parse predicate island pc{...}
        if pos >= tokens.len() or tokens[pos].kind != TokenKind.Identifier or tokens[pos].text != "pc":
            return Err("Expected 'pc' keyword")
        pos = pos + 1

        if pos >= tokens_len(tokens) or tokens[pos].kind != TokenKind.LBrace:
            return Err("Expected '{' after 'pc'")
        pos = pos + 1

        # Extract predicate content
        var pred_tokens: [Token] = []
        var brace_depth = 1
        while pos < tokens_len(tokens) and brace_depth > 0:
            if tokens[pos].kind == TokenKind.LBrace:
                brace_depth = brace_depth + 1
            elif tokens[pos].kind == TokenKind.RBrace:
                brace_depth = brace_depth - 1
                if brace_depth == 0:
                    break
            pred_tokens = pred_tokens_push(pred_tokens, tokens[pos])
            pos = pos + 1

        if brace_depth != 0:
            return Err("Unclosed predicate island")
        pos = pos + 1  # Skip closing brace

        # Parse predicate from tokens
\\\\\        to: zzoxzqoo 2b48645a "feat: Complete Track A/B/C - Native backend layout optimization and LLVM backend" (rebase destination)
         val pred_str = pred_tokens.map(\t: t.text).join(" ")
-        val predicate = parse_predicate("pc{{pred_str}}")
+        val predicate = parse_predicate("pc{{pred_str}}")?

        # Create rule
        rules = rules.push(ArchRule(
            action: action,
            predicate: predicate,
            priority: 0,
            ## DESUGARED: message: nil
        ))

        # Skip newline
        if pos < tokens_len(tokens):
            if tokens[pos].kind == TokenKind.Newline:
            pos = pos + 1

    Ok(rules)

# ============================================================================
# Placeholder Types (until full parser integration)
# ============================================================================

enum TokenKind:
    Identifier
    Colon
    LBrace
    RBrace
    Indent
    Dedent
    Newline
    Other

struct Token:
    kind: TokenKind
    text: text
    line: i64
    column: i64

# NOTE: parse_predicate is imported from predicate_parser module
# NOTE: SdnValue parsing requires sdn module integration
