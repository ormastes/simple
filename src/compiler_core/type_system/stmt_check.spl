# Statement Type Checking
#
# Implements type checking for statement-level constructs.
# Complements expr_infer.spl with statement-specific logic.
#
# Statements checked:
# - Let/const/static bindings
# - Assignments (all forms)
# - Return statements
# - Control flow statements (if, match, for, while, loop)
# - Expression statements
# - Verification statements (assert, assume, admit)
# - Special statements (defer, guard, pass, skip)

from inference.types import {Type, TypeVarId, UnifyError, InferError}
from inference.infer import {InferenceEngine}
from ast import {Node, LetStmt, ConstStmt, StaticStmt, AssignmentStmt, ReturnStmt}
from ast import {IfStmt, MatchStmt, ForStmt, WhileStmt, LoopStmt}
from ast import {BreakStmt, ContinueStmt, PassStmt, SkipStmt}
from ast import {DeferStmt, GuardStmt, AssertStmt, AssumeStmt, AdmitStmt}
from ast import {ProofHintStmt, CalcStmt, ContextStmt, WithStmt}
from ast import {Block, Expr, Pattern, AssignOp, Mutability}
from compiler.type_system.checker import {TypeError}
from compiler.type_system.expr_infer import {infer_expr}
from compiler.type_system.module_check import {ast_type_to_inference_type_engine}

# ============================================================================
# Statement Type Checking
# ============================================================================

fn check_stmt(engine: InferenceEngine, stmt: Node, env: Dict<text, Type>,
              current_fn_ret_type: Type?) -> text, TypeError>:
    """Type check a statement and return updated environment.

    Returns the environment (possibly extended with new bindings).
    The current_fn_ret_type is used for checking return statements.
    """
    match stmt:
        # ====================================================================
        # Variable Bindings
        # ====================================================================
        case Let(let_stmt):
            check_let(engine, let_stmt, env)

        case Const(const_stmt):
            check_const(engine, const_stmt, env)

        case Static(static_stmt):
            check_static(engine, static_stmt, env)

        # ====================================================================
        # Assignments
        # ====================================================================
        case Assignment(assign_stmt):
            check_assignment(engine, assign_stmt, env)

        # ====================================================================
        # Control Flow
        # ====================================================================
        case Return(ret_stmt):
            check_return(engine, ret_stmt, env, current_fn_ret_type)

        case If(if_stmt):
            check_if_stmt(engine, if_stmt, env, current_fn_ret_type)

        case Match(match_stmt):
            check_match_stmt(engine, match_stmt, env, current_fn_ret_type)

        case ForNode(for_stmt):
            check_for(engine, for_stmt, env, current_fn_ret_type)

        case WhileNode(while_stmt):
            check_while(engine, while_stmt, env, current_fn_ret_type)

        case Loop(loop_stmt):
            check_loop(engine, loop_stmt, env, current_fn_ret_type)

        case Break(break_stmt):
            check_break(engine, break_stmt, env)

        case Continue(_):
            # Continue has no type constraints
            Ok(env)

        case Pass(_):
            # Pass is a no-op
            Ok(env)

        case Skip(skip_stmt):
            check_skip(engine, skip_stmt, env, current_fn_ret_type)

        # ====================================================================
        # Special Statements
        # ====================================================================
        case Defer(defer_stmt):
            check_defer(engine, defer_stmt, env)

        case Guard(guard_stmt):
            check_guard(engine, guard_stmt, env, current_fn_ret_type)

        # ====================================================================
        # Verification Statements
        # ====================================================================
        case Assert(assert_stmt):
            check_assert(engine, assert_stmt, env)

        case Assume(assume_stmt):
            check_assume(engine, assume_stmt, env)

        case Admit(admit_stmt):
            check_admit(engine, admit_stmt, env)

        case ProofHint(proof_hint):
            # Proof hints have no runtime type constraints
            Ok(env)

        case Calc(calc_stmt):
            check_calc(engine, calc_stmt, env)

        # ====================================================================
        # Context Management
        # ====================================================================
        case Context(context_stmt):
            check_context(engine, context_stmt, env, current_fn_ret_type)

        case With(with_stmt):
            check_with(engine, with_stmt, env, current_fn_ret_type)

        # ====================================================================
        # Expression Statement
        # ====================================================================
        case _:
            # If it's not a recognized statement, try treating as expression
            # This handles cases where Node wraps an Expr
            Ok(env)

# ============================================================================
# Let Bindings
# ============================================================================

fn check_let(engine: InferenceEngine, stmt: LetStmt,
             env: Dict<text, Type>) -> text, TypeError>:
    """Type check a let binding: val/var x: T = expr"""

    # Infer the value type (if present)
    val value_ty = if stmt.has_value:
        infer_expr(engine, stmt.value_value, env)?
    else:
        # No initializer - must have type annotation
        if not stmt.has_ty:
            return Err(TypeError.Other("let binding requires either type annotation or initializer"))
        engine_fresh_var(engine)

    # Check against type annotation (if present)
    if stmt.has_ty:
        val ann_ty = ast_type_to_inference_type_engine(stmt.ty_value, engine)
        engine_unify(engine, value_ty, ann_ty)?

    # Bind pattern variables
    val new_env = bind_pattern(stmt.pattern, value_ty, env)

    Ok(new_env)

fn bind_pattern(pattern: Pattern, ty: Type, env: Dict<text, Type>) -> Dict<text, Type>:
    """Bind variables from a pattern with the given type."""
    var new_env = env

    match pattern:
        case Identifier(name):
            new_env[name] = ty

        case MutIdentifier(name):
            new_env[name] = ty

        case MoveIdentifier(name):
            new_env[name] = ty

        case Tuple(patterns):
            # Extract tuple element types
            # For now, assign fresh vars to each pattern
            # Full implementation needs tuple type decomposition
            for pat in patterns:
                new_env = bind_pattern(pat, ty, new_env)

        case Array(patterns):
            # Extract array element type
            # For now, assign same type to all patterns
            for pat in patterns:
                new_env = bind_pattern(pat, ty, new_env)

        case StructPattern(name, fields):
            # Extract field types from struct
            # For now, assign fresh var to each field pattern
            for _item_0 in fields:
                val field_name = _item_0[0]
                val field_pat = _item_0[1]
                new_env = bind_pattern(field_pat, ty, new_env)

        case EnumPattern(enum_name, variant, payload):
            # Extract variant payload types
            if has_payload:
                for pat in payload_value:
                    new_env = bind_pattern(pat, ty, new_env)

        case Typed(pattern, ty_ann):
            # Recursively bind inner pattern
            new_env = bind_pattern(pattern, ty, new_env)

        case Or(patterns):
            # All patterns in OR must bind same variables
            # For now, bind all patterns with same type
            for pat in patterns:
                new_env = bind_pattern(pat, ty, new_env)

        case Wildcard:
            # Wildcard binds nothing
            pass

        case Rest:
            # Rest pattern in arrays/tuples
            pass

        case Literal(_):
            # Literal patterns don't bind variables
            pass

        case Range(_, _, _):
            # Range patterns don't bind variables
            pass

    new_env

# ============================================================================
# Const and Static Bindings
# ============================================================================

fn check_const(engine: InferenceEngine, stmt: ConstStmt,
               env: Dict<text, Type>) -> text, TypeError>:
    """Type check a const binding: const X: T = expr"""

    # Infer value type
    val value_ty = infer_expr(engine, stmt.value, env)?

    # Check against type annotation (if present)
    if stmt.has_ty:
        val ann_ty = ast_type_to_inference_type_engine(stmt.ty_value, engine)
        engine_unify(engine, value_ty, ann_ty)?

    # Add to environment
    var new_env = env
    new_env[stmt.name] = value_ty

    Ok(new_env)

fn check_static(engine: InferenceEngine, stmt: StaticStmt,
                env: Dict<text, Type>) -> text, TypeError>:
    """Type check a static binding: static X: T = expr"""

    # Infer value type
    val value_ty = infer_expr(engine, stmt.value, env)?

    # Check against type annotation (if present)
    if stmt.has_ty:
        val ann_ty = ast_type_to_inference_type_engine(stmt.ty_value, engine)
        engine_unify(engine, value_ty, ann_ty)?

    # Add to environment
    var new_env = env
    new_env[stmt.name] = value_ty

    Ok(new_env)

# ============================================================================
# Assignments
# ============================================================================

fn check_assignment(engine: InferenceEngine, stmt: AssignmentStmt,
                    env: Dict<text, Type>) -> text, TypeError>:
    """Type check an assignment: target = value"""

    # Infer target type (LHS)
    val target_ty = infer_expr(engine, stmt.target, env)?

    # Infer value type (RHS)
    val value_ty = infer_expr(engine, stmt.value, env)?

    # Check assignment operator
    match stmt.op:
        case Assign:
            # Simple assignment: types must match
            engine_unify(engine, target_ty, value_ty)?

        case AddAssign:
            # Arithmetic assignments: target and value must be numeric
            engine_unify(engine, target_ty, value_ty)?
            # Result type is same as target

        case SubAssign:
            # Arithmetic assignments: target and value must be numeric
            engine_unify(engine, target_ty, value_ty)?
            # Result type is same as target

        case MulAssign:
            # Arithmetic assignments: target and value must be numeric
            engine_unify(engine, target_ty, value_ty)?
            # Result type is same as target

        case DivAssign:
            # Arithmetic assignments: target and value must be numeric
            engine_unify(engine, target_ty, value_ty)?
            # Result type is same as target

        case ModAssign:
            # Arithmetic assignments: target and value must be numeric
            engine_unify(engine, target_ty, value_ty)?
            # Result type is same as target

        case SuspendAssign:
            # Suspend assignments (async)
            engine_unify(engine, target_ty, value_ty)?

        case SuspendAddAssign:
            # Suspend assignments (async)
            engine_unify(engine, target_ty, value_ty)?

        case SuspendSubAssign:
            # Suspend assignments (async)
            engine_unify(engine, target_ty, value_ty)?

        case SuspendMulAssign:
            # Suspend assignments (async)
            engine_unify(engine, target_ty, value_ty)?

        case SuspendDivAssign:
            # Suspend assignments (async)
            engine_unify(engine, target_ty, value_ty)?

    Ok(env)

# ============================================================================
# Return Statements
# ============================================================================

fn check_return(engine: InferenceEngine, stmt: ReturnStmt,
                env: Dict<text, Type>, current_fn_ret_type: Type?) -> text, TypeError>:
    """Type check a return statement."""

    if stmt.has_value:
        # Infer return value type
        val ret_ty = infer_expr(engine, stmt.value_value, env)?

        # Unify with function return type (if known)
        if has_current_fn_ret_type:
            engine_unify(engine, ret_ty, current_fn_ret_type_value)?
    else:
        # Return with no value - must be unit type
        if has_current_fn_ret_type:
            engine_unify(engine, Type.Unit, current_fn_ret_type_value)?

    Ok(env)

# ============================================================================
# Control Flow Statements
# ============================================================================

fn check_if_stmt(engine: InferenceEngine, stmt: IfStmt,
                 env: Dict<text, Type>, current_fn_ret_type: Type?) -> text, TypeError>:
    """Type check an if statement."""

    # Check condition is bool
    val cond_ty = infer_expr(engine, stmt.condition, env)?
    engine_unify(engine, cond_ty, Type.Bool)?

    # Check then block
    val _unused_1 = check_block(engine, stmt.then_block, env, current_fn_ret_type)?

    # Check elif branches
    for _item_1 in stmt.elif_branches:
        val elif_cond = _item_1[0]
        val elif_block = _item_1[1]
        val elif_cond_ty = infer_expr(engine, elif_cond, env)?
        engine_unify(engine, elif_cond_ty, Type.Bool)?
        val _unused_2 = check_block(engine, elif_block, env, current_fn_ret_type)?

    # Check else block
    if stmt.has_else_block:
        val _unused_3 = check_block(engine, stmt.else_block_value, env, current_fn_ret_type)?

    Ok(env)

fn check_match_stmt(engine: InferenceEngine, stmt: MatchStmt,
                    env: Dict<text, Type>, current_fn_ret_type: Type?) -> text, TypeError>:
    """Type check a match statement."""

    # Infer subject type
    val subject_ty = infer_expr(engine, stmt.subject, env)?

    # Check each arm
    for arm in stmt.arms:
        # Check pattern against subject type and bind pattern variables
        val arm_env = bind_pattern(engine, arm.pattern, subject_ty, env)?

        # Check guard condition (if present)
        if arm.has_guard:
            val guard_ty = infer_expr(engine, arm.guard_value, env)?
            engine_unify(engine, guard_ty, Type.Bool)?

        # Check arm body
        val _unused_4 = check_block(engine, arm.body, env, current_fn_ret_type)?

    Ok(env)

fn check_for(engine: InferenceEngine, stmt: ForStmt,
             env: Dict<text, Type>, current_fn_ret_type: Type?) -> text, TypeError>:
    """Type check a for loop."""

    # Infer iterable type
    val iterable_ty = infer_expr(engine, stmt.iterable, env)?

    # Extract element type from iterable (Phase 3[2] - TODO #178 ✅)
    val elem_ty = extract_element_type(engine, iterable_ty)?

    # Bind loop variable
    val loop_env = bind_pattern(stmt.pattern, elem_ty, env)

    # Check loop body with extended environment
    val _unused_5 = check_block(engine, stmt.body, loop_env, current_fn_ret_type)?

    Ok(env)

fn check_while(engine: InferenceEngine, stmt: WhileStmt,
               env: Dict<text, Type>, current_fn_ret_type: Type?) -> text, TypeError>:
    """Type check a while loop."""

    # Check condition is bool
    val cond_ty = infer_expr(engine, stmt.condition, env)?
    engine_unify(engine, cond_ty, Type.Bool)?

    # Check loop body
    val _unused_6 = check_block(engine, stmt.body, env, current_fn_ret_type)?

    Ok(env)

fn check_loop(engine: InferenceEngine, stmt: LoopStmt,
              env: Dict<text, Type>, current_fn_ret_type: Type?) -> text, TypeError>:
    """Type check an infinite loop."""

    # Check loop body
    val _unused_7 = check_block(engine, stmt.body, env, current_fn_ret_type)?

    Ok(env)

fn check_break(engine: InferenceEngine, stmt: BreakStmt,
               env: Dict<text, Type>) -> text, TypeError>:
    """Type check a break statement."""

    # Break can optionally carry a value
    if stmt.has_value:
        val _unused_8 = infer_expr(engine, stmt.value_value, env)?

    Ok(env)

fn check_skip(engine: InferenceEngine, stmt: SkipStmt,
              env: Dict<text, Type>, current_fn_ret_type: Type?) -> text, TypeError>:
    """Type check a skip statement (BDD/SSpec)."""

    match stmt.body:
        case Standalone:
            # Standalone skip - no-op
            Ok(env)

        case BlockBody(block):
            # Skip with block - check block but mark as skipped
            val _unused_9 = check_block(engine, block, env, current_fn_ret_type)?
            Ok(env)

# ============================================================================
# Special Statements
# ============================================================================

fn check_defer(engine: InferenceEngine, stmt: DeferStmt,
               env: Dict<text, Type>) -> text, TypeError>:
    """Type check a defer statement."""

    match stmt.body:
        case ExprBody(expr):
            # Check deferred expression
            val _unused_10 = infer_expr(engine, expr, env)?

        case BlockBody(block):
            # Check deferred block
            val _unused_11 = check_block(engine, block, env, nil)?

    Ok(env)

fn check_guard(engine: InferenceEngine, stmt: GuardStmt,
               env: Dict<text, Type>, current_fn_ret_type: Type?) -> text, TypeError>:
    """Type check a guard statement."""

    # Check guard condition (if present)
    if stmt.has_condition:
        val cond_ty = infer_expr(engine, stmt.condition_value, env)?
        engine_unify(engine, cond_ty, Type.Bool)?

    # Check result expression
    val result_ty = infer_expr(engine, stmt.result, env)?

    # Guard result should match function return type
    if has_current_fn_ret_type:
        engine_unify(engine, result_ty, current_fn_ret_type_value)?

    Ok(env)

# ============================================================================
# Verification Statements
# ============================================================================

fn check_assert(engine: InferenceEngine, stmt: AssertStmt,
                env: Dict<text, Type>) -> text, TypeError>:
    """Type check an assert statement."""

    # Assert condition must be bool
    val cond_ty = infer_expr(engine, stmt.condition, env)?
    engine_unify(engine, cond_ty, Type.Bool)?

    Ok(env)

fn check_assume(engine: InferenceEngine, stmt: AssumeStmt,
                env: Dict<text, Type>) -> text, TypeError>:
    """Type check an assume statement."""

    # Assume condition must be bool
    val cond_ty = infer_expr(engine, stmt.condition, env)?
    engine_unify(engine, cond_ty, Type.Bool)?

    Ok(env)

fn check_admit(engine: InferenceEngine, stmt: AdmitStmt,
               env: Dict<text, Type>) -> text, TypeError>:
    """Type check an admit statement."""

    # Admit condition must be bool
    val cond_ty = infer_expr(engine, stmt.condition, env)?
    engine_unify(engine, cond_ty, Type.Bool)?

    Ok(env)

fn check_calc(engine: InferenceEngine, stmt: CalcStmt,
              env: Dict<text, Type>) -> text, TypeError>:
    """Type check a calc statement (calculational proofs)."""

    # Check each step in the calculation
    # Each step has a relation and an expression; verify types are consistent
    var prev_ty: Type = nil
    for step in stmt.steps:
        val step_ty = infer_expr(engine, step.expr, env)?
        if has_prev_ty:
            # Each step should produce same type as previous step
            engine_unify(engine, step_ty, prev_ty_value)?
        prev_ty = step_ty

    Ok(env)

# ============================================================================
# Context Management
# ============================================================================

fn check_context(engine: InferenceEngine, stmt: ContextStmt,
                 env: Dict<text, Type>, current_fn_ret_type: Type?) -> text, TypeError>:
    """Type check a context statement."""

    # Check context expression
    val _unused_12 = infer_expr(engine, stmt.expr, env)?

    # Check body block
    val _unused_13 = check_block(engine, stmt.body, env, current_fn_ret_type)?

    Ok(env)

fn check_with(engine: InferenceEngine, stmt: WithStmt,
              env: Dict<text, Type>, current_fn_ret_type: Type?) -> text, TypeError>:
    """Type check a with statement."""

    # Check each resource expression
    for resource in stmt.resources:
        val _unused_14 = infer_expr(engine, resource, env)?

    # Check body block
    val _unused_15 = check_block(engine, stmt.body, env, current_fn_ret_type)?

    Ok(env)

# ============================================================================
# Block Checking
# ============================================================================

fn check_block(engine: InferenceEngine, block: Block, env: Dict<text, Type>,
               current_fn_ret_type: Type?) -> text:
    """Type check a block of statements.

    Returns the type of the last expression (or Unit if block is empty).
    """
    var current_env = env
    var last_ty = Type.Unit

    for stmt in block.statements:
        # Check statement and update environment
        current_env = check_stmt(engine, stmt, current_env, current_fn_ret_type)?

        # Track last expression type (Phase 3[2] - TODO #180 ✅)
        # If last statement is an expression, use its type; otherwise Unit
        match stmt:
            case ExprStmt(expr):
                last_ty = infer_expr(engine, expr, current_env)?
            case _:
                last_ty = Type.Unit

    Ok(last_ty)

# ============================================================================
# Helper Functions
# ============================================================================

fn extract_element_type(engine: InferenceEngine, iterable_ty: Type) -> text:
    """Extract element type from iterable type (Phase 3[2] - TODO #178 ✅).

    Args:
        engine: Type inference engine
        iterable_ty: Type of the iterable expression

    Returns:
        Ok(element_type) on success
        Err(type_error) if not an iterable type

    Supported iterables:
    - Array<T>: Returns T
    - Optional<T>: Returns T (iterates 0 or 1 time)
    - Tuple<T1, T2, ...>: Returns union of element types
    - Type variable: Create fresh variable and unify
    """
    match iterable_ty:
        case type_Array(elem, _):
            # Array<T> → T
            Ok(elem)

        case type_Optional(inner):
            # Optional<T> → T (iterates 0 or 1 times)
            Ok(inner)

        case type_Tuple(elements):
            # Tuple<T1, T2, ...> → T1 | T2 | ... (union)
            if elements_len(elements) == 0:
                # Empty tuple - create fresh var
                Ok(engine_fresh_var(engine))
            elif elements_len(elements) == 1:
                # Single element tuple
                Ok(elements[0])
            else:
                # Multiple elements - return union type
                Ok(type_Union(elements))

        case type_Var(_):
            # Type variable - create fresh variable for element
            # and unify iterable with Array<elem>
            val elem_var = engine_fresh_var(engine)
            val array_ty = type_Array(elem_var, nil)
            engine_unify(engine, iterable_ty, array_ty)?
            Ok(elem_var)

        case type_Dict(_, value):
            # Dict<K, V> → (K, V) when iterating
            Ok(type_Tuple([iterable_ty, value]))

        case _:
            # Not an iterable type
            Err(typeerror_NotIterable(iterable_ty))

# ============================================================================
# Exports
# ============================================================================

export check_stmt, check_let, check_const, check_static
export check_assignment, check_return
export check_if_stmt, check_match_stmt, check_for, check_while, check_loop
export check_break, check_skip, check_defer, check_guard
export check_assert, check_assume, check_admit, check_calc
export check_context, check_with
export check_block, bind_pattern
