# Type Checker
#
# Two-pass type checking for AST nodes:
# 1. Register all names (functions, classes, structs, enums, traits, etc.)
# 2. Type check all nodes in order
#
# Includes trait coherence checking, pattern binding, and FString key validation.
#
# Port of rust/type/src/checker_check.rs + checker_infer.rs + checker_builtins.rs

from inference.types import {Type, TypeVarId, Constraint, UnifyError}
from inference.unify import {Unifier}
from inference.infer import {InferenceEngine}
from compiler.type_system.expr_infer import {infer_expr}
from compiler.type_system.stmt_check import {check_stmt, check_block}
from compiler.type_system.module_check import {check_module as module_check_impl}
from compiler.type_system.bidirectional import {infer_with_expected, InferMode}
from ast import {Module, Node, Expr}

# ============================================================================
# Type Checker Error
# ============================================================================

enum TypeError:
    """Type checking error."""
    Undefined(text)
    TypeMismatch(expected: text, found: text)
    ConstKeyNotFound(key: text, expected_keys: [text])
    ConstKeyMissing(key: text, provided_keys: [text])
    CoherenceError(text)
    Other(text)


# ============================================================================
# TypeError Methods (was: impl TypeError:)
# ============================================================================

# ============================================================================
# Trait Impl Registry
# ============================================================================

struct TraitImplRegistry:
    """Tracks implementations of a trait for coherence checking."""
    specific_impls: Dict<text, bool>
    blanket_impl: bool
    default_blanket_impl: bool


# ============================================================================
# TraitImplRegistry Methods (was: impl TraitImplRegistry:)
# ============================================================================

fn traitimplregistry_empty() -> TraitImplRegistry:
        TraitImplRegistry(specific_impls: {}, blanket_impl: false, default_blanket_impl: false)


# ============================================================================
# Mixin Info
# ============================================================================

struct MixinInfo:
    """Metadata for a mixin definition (Feature #2200)."""
    name: text
    type_params: [text]
    fields: [(text, Type)]
    methods: [(text, Type)]
    required_traits: [text]
    required_mixins: [text]

# ============================================================================
# Type Checker
# ============================================================================

class TypeChecker:
    """Main type checker with two-pass checking."""
    env: Dict<text, Type>
    next_var: i64
    unifier: Unifier
    trait_impls: Dict<text, TraitImplRegistry>
    mixins: Dict<text, MixinInfo>
    interface_bindings: Dict<text, Type>
    fstring_keys: Dict<text, [text]>
    errors: [TypeError]


# ============================================================================
# TypeChecker Methods (was: impl TypeChecker:)
# ============================================================================

fn typechecker_create() -> TypeChecker:
        var tc = TypeChecker(
            env: {},
            next_var: 0,
            unifier: Unifier(substitutions: {}, next_var: 0),
            trait_impls: {},
            mixins: {},
            interface_bindings: {},
            fstring_keys: {},
            errors: []
        )
        tc_add_builtins(tc)
        tc


fn typechecker_fresh_var(self: TypeChecker) -> Type:
        val id = self.next_var
        self.next_var = self.next_var + 1
        type_Var(TypeVarId(id: id))


export TypeError, TraitImplRegistry, MixinInfo, TypeChecker
