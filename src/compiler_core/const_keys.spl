# Const Keys - Compile-Time Template Key Validation
#
# Provides compile-time validation of string template instantiation.
# Ensures that template keys are used correctly and catches typos early.
#
# Example:
#   val template = "Welcome {user} to {city}"
#   val greeting = template.with {"user": "Alice", "city": "NYC"}  # OK
#   val bad = template.with {"usr": "Alice"}  # Compile error!
#
# Features:
# - Extract keys from format strings at compile time
# - Validate .with{} calls against template keys
# - Generate helpful error messages for typos
# - Support for optional keys with defaults

# ============================================================================
# Template Key
# ============================================================================

struct TemplateKey:
    """A key in a string template."""
    name: text
    position: i64        # Position in template string
    is_optional: bool    # Has default value
    # # DESUGARED: default_value: text
    has_default: bool
    default_value: text


# ============================================================================
# TemplateKey Methods (was: impl TemplateKey:)
# ============================================================================

fn templatekey_required(name: text, position: i64) -> i64:
        # Stub: TemplateKey struct return not supported in seed_cpp
        0


fn templatekey_optional(name: text, position: i64, default_val: text) -> i64:
        # Stub: TemplateKey struct return not supported in seed_cpp
        0


# ============================================================================
# Template Schema
# ============================================================================

struct TemplateSchema:
    """Schema extracted from a template string."""
    template: text
    keys: [TemplateKey]
    required_keys: [text]
    optional_keys: [text]


# ============================================================================
# TemplateSchema Methods (was: impl TemplateSchema:)
# ============================================================================

fn templateschema_from_template(template: text) -> TemplateSchema:
        """Extract schema from a template string."""
        # Stub: Complex string parsing and array operations not supported in seed_cpp
        TemplateSchema(
            template: template,
            keys: [],
            required_keys: [],
            optional_keys: []
        )


# ============================================================================
# Validation Error
# ============================================================================

enum ConstKeyError:
    """Error in const key validation."""
    # Key not in template
    UnknownKey(provided: text, available: [text], suggestion: text?)

    # Required key missing
    MissingKey(key: text, template_keys: [text])

    # Multiple errors
    MultipleErrors(errors: [ConstKeyError])


# ============================================================================
# ConstKeyError Methods (was: impl ConstKeyError:)
# ============================================================================

# ============================================================================
# Key Validator
# ============================================================================

class ConstKeyValidator:
    """Validates template instantiation keys."""
    schema: TemplateSchema

    static fn for_template(template: text) -> ConstKeyValidator:
        ConstKeyValidator(schema: templateschema_from_template(template))

    fn validate(provided_keys: [text]) -> text:
        """Validate provided keys against schema."""
        var errors: [ConstKeyError] = []

        # Check for unknown keys
        for key in provided_keys:
            if not self.schema_has_key(schema, key):
                val suggestion = self.find_similar_key(key)
                errors = errors.push(ConstKeyError.UnknownKey(
                    key,
                    self.schema_key_names(schema),
                    suggestion
                ))

        # Check for missing required keys
        for required in self.schema.required_keys:
            if not provided_keys_contains(provided_keys, required):
                errors = errors.push(ConstKeyError.MissingKey(
                    required,
                    self.schema.required_keys
                ))

        if errors_is_empty(errors):
            Ok(())
        elif errors_len(errors) == 1:
            Err(errors[0])
        else:
            Err(constkeyerror_MultipleErrors(errors))

    fn find_similar_key(input: text) -> text:
        """Find a similar key name (for typo suggestions)."""
        var best_match: text = nil
        var best_distance = 3  # Max edit distance for suggestions

        for key in self.schema_key_names(schema):
            val dist = edit_distance(input, key)
            if dist < best_distance:
                best_distance = dist
                best_match = key

        best_match

# ============================================================================
# Edit Distance (for typo detection)
# ============================================================================

fn edit_distance(s1: text, s2: text) -> i64:
    """Calculate Levenshtein edit distance between two strings."""
    val m = s1_len(s1)
    val n = s2_len(s2)

    # Simple case: one string is empty
    if m == 0:
        return n
    if n == 0:
        return m

    # Create distance matrix (using simplified approach)
    var prev_row: [i64] = []
    for j in 0..=n:
        prev_row = prev_row_push(prev_row, j)

    for i in 1..=m:
        var curr_row: [i64] = [i]

        for j in 1..=n:
            val cost = if s1[i - 1] == s2[j - 1]: 0 else: 1
            val insert_cost = curr_row[j - 1] + 1
            val delete_cost = prev_row[j] + 1
            val replace_cost = prev_row[j - 1] + cost

            var min_cost = insert_cost
            if delete_cost < min_cost:
                min_cost = delete_cost
            if replace_cost < min_cost:
                min_cost = replace_cost

            curr_row = curr_row_push(curr_row, min_cost)

        prev_row = curr_row

    prev_row[n]

# ============================================================================
# Compile-Time Analysis
# ============================================================================

struct TemplateAnalysis:
    """Result of analyzing a template expression."""
    # # DESUGARED: template_literal: text
    has_template_literal: bool
    template_literal: text
    is_const: bool
    # # DESUGARED: schema: TemplateSchema
    has_schema: bool
    schema: TemplateSchema
    source_location: text


# ============================================================================
# TemplateAnalysis Methods (was: impl TemplateAnalysis:)
# ============================================================================

fn templateanalysis_from_literal(literal: text, location: text) -> TemplateAnalysis:
        TemplateAnalysis(
            # # DESUGARED: template_literal: Some(literal)
            template_literal: literal,
            is_const: true,
            # # DESUGARED: schema: Some(templateschema_from_template(literal))
            schema: templateschema_from_template(literal),
            source_location: location
        )


fn templateanalysis_dynamic(location: text) -> TemplateAnalysis:
        TemplateAnalysis(
            #  # DESUGARED: template_literal: nil
            is_const: false,
            #  # DESUGARED: schema: nil
            source_location: location
        )


class TemplateChecker:
    """Checks template usage at compile time."""
    templates: Dict<text, TemplateAnalysis>  # Variable name -> analysis
    errors: [ConstKeyError]
    warnings: [text]

    static fn create() -> TemplateChecker:
        TemplateChecker(
            templates: {},
            errors: [],
            warnings: []
        )

    me register_template(var_name: text, analysis: TemplateAnalysis):
        """Register a template variable."""
        self.templates[var_name] = analysis

    me check_with_call(template_var: text, provided_keys: [text], location: text) -> text:
        """Check a .with{} call."""
        match self.templates_get(templates, template_var):
            case analysis:
                if analysis_can_validate(analysis):
                    val validator = ConstKeyValidator(schema: analysis.schema_value)
                    match validator_validate(validator, provided_keys):
                        case Ok(_):
                            Ok(())
                        case Err(e):
                            self.errors = self.errors_push(errors, e)
                            Err(e)
                else:
                    # Dynamic template - can't validate statically
                    self.warnings = self.warnings.push(
                        "Cannot validate template keys at compile time (dynamic template)"
                    )
                    Ok(())

            case nil:
                # Unknown template variable
                self.warnings = self.warnings.push(
                    "Unknown template variable '{template_var}' at {location}"
                )
                Ok(())

    fn get_errors() -> [ConstKeyError]:
        self.errors

    fn get_warnings() -> [text]:
        self.warnings

    fn has_errors() -> bool:
        not self.errors_is_empty(errors)

# ============================================================================
# Template Instantiation
# ============================================================================

struct TemplateInstance:
    """A validated template with values."""
    schema: TemplateSchema
    values: Dict<text, text>


# ============================================================================
# TemplateInstance Methods (was: impl TemplateInstance:)
# ============================================================================

# ============================================================================
# Convenience Functions
# ============================================================================

fn extract_template_keys(template: text) -> i64:
    """Extract key names from a template string."""
    # Stub: Template functions not supported in seed_cpp
    0

fn validate_template_keys(template: text, provided: [text]) -> text:
    """Validate that provided keys match template."""
    # Stub: Template validation not supported in seed_cpp
    ""

fn suggest_key_fix(template: text, wrong_key: text) -> text:
    """Suggest a fix for a wrong key."""
    # Stub: Template suggestions not supported in seed_cpp
    ""

fn render_template(template: text, values: Dict<text, text>) -> text:
    """Render a template with validation."""
    # Stub: Template rendering not supported in seed_cpp
    ""

# ============================================================================
# Exports
# ============================================================================

export TemplateKey, TemplateSchema
export ConstKeyError, ConstKeyValidator
export edit_distance
export TemplateAnalysis, TemplateChecker
export TemplateInstance
export extract_template_keys, validate_template_keys
export suggest_key_fix, render_template
