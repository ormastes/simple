# HIR Lowering - Expression Lowering
#
# This module handles lowering of expressions from AST to HIR.

use hir_types.*
use hir_definitions.*
use parser.*
use lexer.Span
use hir_lowering.types.HirLowering

# Expression Lowering
# ============================================================================


# ============================================================================
# HirLowering Methods (was: impl HirLowering:)
# ============================================================================

fn hirlowering_lower_expr(self: HirLowering, e: Expr) -> HirExpr:
        """Lower expression to HIR."""
        val kind = match e.kind:
            case IntLit(value):
                hirexprkind_IntLit(value, nil)

            case FloatLit(value):
                hirexprkind_FloatLit(value, nil)

            case StringLit(value, interps):
                val hir_interps = interps_map(interps, \i: self.lower_interpolation_list(i))
                hirexprkind_StringLit(value, hir_interps)

            case BoolLit(value):
                hirexprkind_BoolLit(value)

            case NilLit:
                HirExprKind.NilLit

            case ArrayLit(elements):
                val hir_elements = self.lower_expr_list(elements)
                # For empty arrays, use configured default element type
                val elem_type = if hir_elements_is_empty(hir_elements):
                    if self.is_strict_empty_collections():
                        self.error("empty array requires explicit type annotation", e.span)
                        nil
                    # # DESUGARED: else: Some(self.get_empty_array_default())
 
            else: self.get_empty_array_default()
                else:
                    nil  # Type will be inferred from elements
                hirexprkind_ArrayLit(hir_elements, elem_type)

            case TupleLit(elements):
                hirexprkind_TupleLit(self.lower_expr_list(elements))

            case DictLit(entries):
                hirexprkind_DictLit(self.lower_dict_entries(entries), nil, nil)

            case SetLit(elements):
                hirexprkind_SetLit(self.lower_expr_list(elements), nil)

            case Ident(name):
                val symbol = self.symbols_lookup(symbols, name)
                if has_symbol:
                    hirexprkind_Var(symbol_value)
                else:
                    self.error("unresolved name: {name}", e.span)
                    HirExprKind.Error

            case Field(base, field):
                hirexprkind_Field(self.lower_expr(base), field, nil)

            case Index(base, index):
                hirexprkind_Index(self.lower_expr(base), self.lower_expr(index))

            case OptionalChain(base, field):
                hirexprkind_OptionalChain(self.lower_expr(base), field)

            case NullCoalesce(left, right):
                hirexprkind_NullCoalesce(self.lower_expr(left), self.lower_expr(right))

            case ExistsCheck(base):
                hirexprkind_ExistsCheck(self.lower_expr(base))

            case Binary(op, left, right):
                val hir_op = self.lower_binop(op)
                hirexprkind_Binary(hir_op, self.lower_expr(left), self.lower_expr(right))

            case Unary(op, operand):
                val hir_op = self.lower_unaryop(op)
                hirexprkind_Unary(hir_op, self.lower_expr(operand))

            case Call(callee, args):
                var hir_args: [HirCallArg] = []
                for arg in args:
                    hir_args = hir_args.push(HirCallArg(
                        name: arg.name,
                        value: self.lower_expr(arg.value),
                        span: arg.span
                    ))
                hirexprkind_Call(self.lower_expr(callee), hir_args, [])

            case MethodCall(receiver, method, args):
                var hir_args: [HirCallArg] = []
                for arg in args:
                    hir_args = hir_args.push(HirCallArg(
                        name: arg.name,
                        value: self.lower_expr(arg.value),
                        span: arg.span
                    ))
                hirexprkind_MethodCall(self.lower_expr(receiver), method, hir_args, MethodResolution.Unresolved)

            case If(cond, then_, else_):
                HirExprKind.If(
                    self.lower_expr(cond),
                    self.lower_block(then_),
                    else__map(else_, \b: self.lower_block(b))
                )

            case MatchCase(scrutinee, arms):
                var hir_arms: [HirMatchArm] = []
                for arm in arms:
                    hir_arms = hir_arms.push(HirMatchArm(
                        pattern: self.lower_pattern(arm.pattern),
                        guard: arm.guard_map(guard, \g: self.lower_expr(g)),
                        body: self.lower_block(arm.body),
                        span: arm.span
                    ))
                hirexprkind_MatchCase(self.lower_expr(scrutinee), hir_arms)

            case Lambda(params, body):
                self.symbols_push_scope(symbols, ScopeKind.Function)
                var hir_params: [HirParam] = []
                for p in params:
                    val type_ = p.type__map(type_, \t: self.lower_type(t)) ?? HirType(kind: hirtypekind_Infer(0, 0), span: p.span)
                    val symbol = self.symbols_define(symbols, p.name, SymbolKind.Parameter, type_, p.span, false, false, nil)
                    hir_params = hir_params.push(HirParam(
                        symbol: symbol,
                        name: p.name,
                        type_: type_,
                        default: nil,
                        span: p.span
                    ))
                val hir_body = self.lower_expr(body)
                self.symbols_pop_scope(symbols)
                hirexprkind_Lambda(hir_params, hir_body, [])

            case Block(block):
                hirexprkind_Block(self.lower_block(block))

            case Return(value):
                hirexprkind_Return(value.map(\v: self.lower_expr(v)))

            case Break(label):
                hirexprkind_Break(label, nil)

            case Continue(label):
                hirexprkind_Continue(label)

            case Yield(value):
                hirexprkind_Yield(value.map(\v: self.lower_expr(v)))

            case Throw(value):
                hirexprkind_Throw(self.lower_expr(value))

            case Await(expr):
                hirexprkind_Await(self.lower_expr(expr))

            case Try(expr):
                hirexprkind_Try(self.lower_expr(expr))

            case Range(start, end, inclusive, step):
                HirExprKind.Range(
                    start_map(start, \s: self.lower_expr(s)),
                    end_map(end, \e: self.lower_expr(e)),
                    inclusive,
                    step_map(step, \s: self.lower_expr(s))
                )

            case ListComprehension(expr, clauses):
                var hir_clauses: [HirCompClause] = []
                for clause in clauses:
                    val hir_kind = match clause.kind:
                        case For(var_, iter):
                            val symbol = self.symbols_define(symbols, var_, SymbolKind.Variable, nil, clause.span, false, false, nil)
                            hircompclausekind_For(symbol, self.lower_expr(iter))
                        case If(cond):
                            hircompclausekind_If(self.lower_expr(cond))
                    hir_clauses = hir_clauses_push(hir_clauses, HirCompClause(kind: hir_kind, span: clause.span))
                hirexprkind_Comprehension(HirComprehensionKind.List, self.lower_expr(expr), hir_clauses)

            case StructLit(type_, fields):
                var hir_fields: [(text, HirExpr)] = []
                for _item_0 in fields:
                    val name = _item_0[0]
                    val value = _item_0[1]
                    hir_fields = hir_fields_push(hir_fields, (name, self.lower_expr(value)))
                val symbol = self.symbols_lookup(symbols, type_)
                val hir_type = if has_symbol:
                    HirType(kind: hirtypekind_Named(symbol_value, []), span: e.span)
                else:
                    HirType(kind: HirTypeKind.Error, span: e.span)
                hirexprkind_StructLit(hir_type, hir_fields)

            case EnumLit(enum_, variant, payload):
                val symbol = self.symbols_lookup(symbols, enum_)
                val hir_type = if has_symbol:
                    HirType(kind: hirtypekind_Named(symbol_value, []), span: e.span)
                else:
                    HirType(kind: HirTypeKind.Error, span: e.span)
                val hir_payload = payload.map(\p: match p:
                    case Tuple(values):
                        var hir_values: [HirExpr] = []
                        for v in values:
                            hir_values = hir_values_push(hir_values, self.lower_expr(v))
                        hirenumpayload_Tuple(hir_values)
                    case Struct(fields):
                        var hir_fields: [(text, HirExpr)] = []
                        for _item_1 in fields:
                            val fname = _item_1[0]
                            val fvalue = _item_1[1]
                            hir_fields = hir_fields_push(hir_fields, (fname, self.lower_expr(fvalue)))
                        hirenumpayload_Struct(hir_fields)
                )
                hirexprkind_EnumLit(hir_type, variant, hir_payload)

            # Custom blocks (user-defined: sh{}, sql{}, re{}, etc.)
            case CustomBlock(kind, value):
                hirexprkind_CustomBlock(kind, value)

            # Math/DL blocks with special semantics
            case LossBlock(body):
                hirexprkind_LossBlock(self.lower_block(body))

            case NogradBlock(body):
                hirexprkind_NogradBlock(self.lower_block(body))

            # Unsafe block for raw pointer ops, FFI, inline assembly
            case UnsafeBlock(body):
                hirexprkind_UnsafeBlock(self.lower_block(body))

            # Inline assembly
            case AsmBlock(asm_code):
                hirexprkind_InlineAsm(self.lower_asm(asm_code))

            case Error:
                HirExprKind.Error

            case _:
                self.error("unsupported expression kind", e.span)
                HirExprKind.Error

        HirExpr(kind: kind, type_: nil, span: e.span)


fn hirlowering_lower_binop(self: HirLowering, op: BinOp) -> HirBinOp:
        """Lower binary operator."""
        match op:
            case Add: HirBinOp.Add
            case Sub: HirBinOp.Sub
            case Mul: HirBinOp.Mul
            case Div: HirBinOp.Div
            case Mod: HirBinOp.Mod
            case Pow: HirBinOp.Pow
            case MatMul: HirBinOp.MatMul
            case Eq: HirBinOp.Eq
            case NotEq: HirBinOp.NotEq
            case Lt: HirBinOp.Lt
            case LtEq: HirBinOp.LtEq
            case Gt: HirBinOp.Gt
            case GtEq: HirBinOp.GtEq
            case And: HirBinOp.And
            case Or: HirBinOp.Or
            case BitAnd: HirBinOp.BitAnd
            case BitOr: HirBinOp.BitOr
            case BitXor: HirBinOp.BitXor
            case Shl: HirBinOp.Shl
            case Shr: HirBinOp.Shr
            case BroadcastAdd: HirBinOp.BroadcastAdd
            case BroadcastSub: HirBinOp.BroadcastSub
            case BroadcastMul: HirBinOp.BroadcastMul
            case BroadcastDiv: HirBinOp.BroadcastDiv
            case BroadcastPow: HirBinOp.BroadcastPow
            case PipeForward: HirBinOp.PipeForward
            case Compose: HirBinOp.Compose
            case ComposeBack: HirBinOp.ComposeBack
            case Parallel: HirBinOp.Parallel
            case LayerConnect: HirBinOp.LayerConnect
            case In: HirBinOp.In
            case NotIn: HirBinOp.NotIn
            case Is: HirBinOp.Is
            case IsNot: HirBinOp.IsNot


fn hirlowering_lower_unaryop(self: HirLowering, op: UnaryOp) -> HirUnaryOp:
        """Lower unary operator."""
        match op:
            case Neg: HirUnaryOp.Neg
            case Not: HirUnaryOp.Not
            case BitNot: HirUnaryOp.BitNot
            case Ref: HirUnaryOp.Ref
            case Deref: HirUnaryOp.Deref
            case Transpose: HirUnaryOp.Transpose


fn hirlowering_lower_pattern(self: HirLowering, p: Pattern) -> HirPattern:
        """Lower pattern to HIR."""
        val kind = match p.kind:
            case Wildcard:
                HirPatternKind.Wildcard

            case Literal(value):
                hirpatternkind_Literal(self.lower_expr(value))

            case Binding(name, mutable):
                val symbol = self.symbols_define(symbols, name, SymbolKind.Variable, nil, p.span, false, mutable, nil)
                hirpatternkind_Binding(symbol, mutable)

            case Tuple(elements):
                var hir_elements: [HirPattern] = []
                for elem in elements:
                    hir_elements = hir_elements_push(hir_elements, self.lower_pattern(elem))
                hirpatternkind_Tuple(hir_elements)

            case Array(elements, rest):
                var hir_elements: [HirPattern] = []
                for elem in elements:
                    hir_elements = hir_elements_push(hir_elements, self.lower_pattern(elem))
                var rest_symbol: SymbolId = nil
                if has_rest:
                    rest_symbol = self.symbols_define(symbols, rest_value, SymbolKind.Variable, nil, p.span, false, false, nil)
                hirpatternkind_Array(hir_elements, rest_symbol)

            case Struct(type_, fields):
                val symbol = self.symbols_lookup(symbols, type_)
                val hir_type = if has_symbol:
                    HirType(kind: hirtypekind_Named(symbol_value, []), span: p.span)
                else:
                    HirType(kind: HirTypeKind.Error, span: p.span)
                var hir_fields: [(text, HirPattern)] = []
                for _item_2 in fields:
                    val fname = _item_2[0]
                    val fpat = _item_2[1]
                    hir_fields = hir_fields_push(hir_fields, (fname, self.lower_pattern(fpat)))
                hirpatternkind_Struct(hir_type, hir_fields)

            case Enum(enum_, variant, payload):
                val symbol = self.symbols_lookup(symbols, enum_)
                val hir_type = if has_symbol:
                    HirType(kind: hirtypekind_Named(symbol_value, []), span: p.span)
                else:
                    HirType(kind: HirTypeKind.Error, span: p.span)
                val hir_payload = payload.map(\pl: match pl:
                    case Tuple(patterns):
                        var hir_patterns: [HirPattern] = []
                        for pat in patterns:
                            hir_patterns = hir_patterns_push(hir_patterns, self.lower_pattern(pat))
                        hirpatternpayload_Tuple(hir_patterns)
                    case Struct(fields):
                        var hir_fields: [(text, HirPattern)] = []
                        for _item_3 in fields:
                            val fname = _item_3[0]
                            val fpat = _item_3[1]
                            hir_fields = hir_fields_push(hir_fields, (fname, self.lower_pattern(fpat)))
                        hirpatternpayload_Struct(hir_fields)
                )
                hirpatternkind_Enum(hir_type, variant, hir_payload)

            case Or(patterns):
                var hir_patterns: [HirPattern] = []
                for pat in patterns:
                    hir_patterns = hir_patterns_push(hir_patterns, self.lower_pattern(pat))
                hirpatternkind_Or(hir_patterns)

            case Range(start, end, inclusive):
                HirPatternKind.Range(
                    start_map(start, \s: self.lower_expr(s)),
                    end_map(end, \e: self.lower_expr(e)),
                    inclusive
                )

            case Error:
                HirPatternKind.Error

            case _:
                self.error("unsupported pattern kind", p.span)
                HirPatternKind.Error

        HirPattern(kind: kind, type_: nil, span: p.span)


fn hirlowering_lower_block(self: HirLowering, b: Block) -> HirBlock:
        """Lower block to HIR."""
        # Workaround: Store symbols in local var to avoid interpreter bug
        # where chained method calls corrupt 'self'
        var symbols_table = self.symbols
        symbols_table_push_scope(symbols_table, ScopeKind.Block)
        self.symbols = symbols_table

        var stmts: [HirStmt] = []
        for s in b.stmts:
            val lowered = self.lower_stmt(s)
            stmts = stmts_push(stmts, lowered)

            # Workaround: lower_stmt's mutations to self.symbols don't propagate
            # through the interpreter's method dispatch. Re-register symbol for
            # Val/Var statements so subsequent expressions can resolve the name.
            # Also sync next_symbol_id so the next define() gets a unique ID.
            match s.kind:
                case stmtkind_Val(name, _, _):
                    match lowered.kind:
                        case Let(symbol_id, _, _):
                            var syms = self.symbols
                            # Ensure next_symbol_id is past this symbol
                            if syms.next_symbol_id <= symbol_id.id:
                                syms.next_symbol_id = symbol_id.id + 1
                            var scope = syms.scopes[syms.current_scope.id]
                            var scope_syms = scope.symbols
                            scope_syms[name] = symbol_id
                            scope.symbols = scope_syms
                            syms.scopes[syms.current_scope.id] = scope
                            syms.symbols[symbol_id.id] = Symbol(
                                id: symbol_id, name: name, kind: SymbolKind.Variable,
                                type_: nil, scope: syms.current_scope, span: s.span
                                # is_public: false, is_mutable: false# DESUGARED: defining_module: nil
                            )
                            self.symbols = syms
                        case _: pass
                case stmtkind_Var(name, _, _):
                    match lowered.kind:
                        case Let(symbol_id, _, _):
                            var syms = self.symbols
                            if syms.next_symbol_id <= symbol_id.id:
                                syms.next_symbol_id = symbol_id.id + 1
                            var scope = syms.scopes[syms.current_scope.id]
                            var scope_syms = scope.symbols
                            scope_syms[name] = symbol_id
                            scope.symbols = scope_syms
                            syms.scopes[syms.current_scope.id] = scope
                            syms.symbols[symbol_id.id] = Symbol(
                                id: symbol_id, name: name, kind: SymbolKind.Variable,
                                type_: nil, scope: syms.current_scope, span: s.span,
                                is_public: false, is_mutable: true, defining_module: nil
                            )
                            self.symbols = syms
                        case _: pass
                case _: pass

        symbols_table = self.symbols
        symbols_table_pop_scope(symbols_table)
        self.symbols = symbols_table

        # Check if last statement is an expression (for block value)
        var value: HirExpr = nil
        if stmts_len(stmts) > 0:
            val last = stmts[stmts_len(stmts) - 1]
            match last.kind:
                case Expr(expr):
                    value = expr
                    stmts = stmts[0:stmts_len(stmts) - 1]  # Remove last stmt
                case _:
                    pass

        HirBlock(stmts: stmts, value: value, span: b.span)


fn hirlowering_lower_asm(self: HirLowering, asm_code: AsmExpr) -> HirAsm:
        """Lower inline assembly expression to HIR.

        Converts AST AsmExpr to HIR HirAsm, lowering all constraint
        expressions from AST to HIR.
        """
        # Lower all constraint value expressions
        var hir_constraints: [HirAsmConstraint] = []
        for constraint in asm_code.constraints:
            val hir_value = self.lower_expr(constraint.value)
            val hir_constraint = HirAsmConstraint(
                name: constraint.name,
                kind: constraint.kind,
                location: constraint.location,
                value: hir_value,
                span: constraint.span
            )
            hir_constraints_push(hir_constraints, hir_constraint)

        HirAsm(
            asm_template: asm_code.asm_template,
            is_volatile: asm_code.is_volatile,
            constraints: hir_constraints,
            clobbers: asm_code.clobbers,
            span: asm_code.span
        )

