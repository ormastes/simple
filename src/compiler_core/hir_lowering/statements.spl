# HIR Lowering - Statement Lowering
#
# This module handles lowering of statements from AST to HIR.

use hir_types.*
use hir_definitions.*
use parser.*
use lexer.Span
use hir_lowering.types.HirLowering

# Statement Lowering
# ============================================================================


# ============================================================================
# HirLowering Methods (was: impl HirLowering:)
# ============================================================================

fn hirlowering_lower_stmt(self: HirLowering, s: Stmt) -> HirStmt:
        """Lower statement to HIR."""
        # Workaround: Capture self reference to ensure it's available in match arms
        val lowerer = self
        val kind = match s.kind:
            case stmtkind_Expr(expr):
                hirstmtkind_Expr(self.lower_expr(expr))

            case stmtkind_Val(name, type_, init):
                val hir_type = type__map(type_, \t: self.lower_type(t))
                val hir_init = self.lower_expr(init)
                # Workaround: Store symbols in local var to avoid interpreter bug
                var symbols_table = self.symbols
                val symbol = symbols_table_define(symbols_table, name, SymbolKind.Variable, hir_type, s.span, false, false, nil)
                self.symbols = symbols_table
                hirstmtkind_Let(symbol, hir_type, hir_init)

            case stmtkind_Var(name, type_, init):
                val hir_type = type__map(type_, \t: self.lower_type(t))
                val hir_init = init_map(init, \i: self.lower_expr(i)) ?? HirExpr(kind: HirExprKind.NilLit, type_: nil, span: s.span)
                # Workaround: Store symbols in local var to avoid interpreter bug
                var symbols_table = self.symbols
                val symbol = symbols_table_define(symbols_table, name, SymbolKind.Variable, hir_type, s.span, false, true, nil)
                self.symbols = symbols_table
                hirstmtkind_Let(symbol, hir_type, hir_init)

            case stmtkind_Assign(target, op, value):
                val hir_op = op.map(\o: match o:
                    case AssignOp.Add: HirAssignOp.Add
                    case AssignOp.Sub: HirAssignOp.Sub
                    case AssignOp.Mul: HirAssignOp.Mul
                    case AssignOp.Div: HirAssignOp.Div
                    case AssignOp.Mod: HirAssignOp.Mod
                )
                hirstmtkind_Assign(self.lower_expr(target), hir_op, self.lower_expr(value))

            case stmtkind_For(var_, iter, body):
                # Workaround: Store symbols in local var to avoid interpreter bug
                var symbols_table = self.symbols
                symbols_table_push_scope(symbols_table, ScopeKind.Loop)
                self.symbols = symbols_table
                self.loop_depth = self.loop_depth + 1
                symbols_table = self.symbols
                val symbol = symbols_table_define(symbols_table, var_, SymbolKind.Variable, nil, s.span, false, false, nil)
                self.symbols = symbols_table
                val hir_iter = self.lower_expr(iter)
                val hir_body = self.lower_block(body)
                self.loop_depth = self.loop_depth - 1
                symbols_table = self.symbols
                symbols_table_pop_scope(symbols_table)
                self.symbols = symbols_table
                # Desugar to loop
                HirStmtKind.Expr(HirExpr(
                    kind: hirexprkind_For(symbol, hir_iter, hir_body, nil),
                    type_: nil,
                    span: s.span
                ))

            case stmtkind_While(cond, body):
                self.loop_depth = self.loop_depth + 1
                val hir_cond = self.lower_expr(cond)
                val hir_body = self.lower_block(body)
                self.loop_depth = self.loop_depth - 1
                HirStmtKind.Expr(HirExpr(
                    kind: hirexprkind_While(hir_cond, hir_body, nil),
                    type_: nil,
                    span: s.span
                ))

            case stmtkind_Loop(body):
                self.loop_depth = self.loop_depth + 1
                val hir_body = self.lower_block(body)
                self.loop_depth = self.loop_depth - 1
                HirStmtKind.Expr(HirExpr(
                    kind: hirexprkind_Loop(hir_body, nil),
                    type_: nil,
                    span: s.span
                ))

            case stmtkind_Return(value):
                HirStmtKind.Expr(HirExpr(
                    kind: hirexprkind_Return(value.map(\v: self.lower_expr(v))),
                    type_: nil,
                    span: s.span
                ))

            case stmtkind_Break(label):
                HirStmtKind.Expr(HirExpr(
                    kind: hirexprkind_Break(label, nil),
                    type_: nil,
                    span: s.span
                ))

            case stmtkind_Continue(label):
                HirStmtKind.Expr(HirExpr(
                    kind: hirexprkind_Continue(label),
                    type_: nil,
                    span: s.span
                ))

            case stmtkind_Yield(value):
                HirStmtKind.Expr(HirExpr(
                    kind: hirexprkind_Yield(value.map(\v: self.lower_expr(v))),
                    type_: nil,
                    span: s.span
                ))

            case stmtkind_Throw(value):
                HirStmtKind.Expr(HirExpr(
                    kind: hirexprkind_Throw(self.lower_expr(value)),
                    type_: nil,
                    span: s.span
                ))

            case stmtkind_With(items, body):
                # Lower with items
                var hir_items: [HirWithItem] = []
                for item in items:
                    # Lower context expression
                    val hir_context = self.lower_expr(item.context_expr)

                    # Handle optional variable binding
                    var hir_target: SymbolId? = nil
                    if item.has_target:
                        # Define symbol for the bound variable
                        var symbols_table = self.symbols
                        val symbol = symbols_table.define(item.target ?? "", SymbolKind.Variable, nil, item.span, false, false, nil)
                        self.symbols = symbols_table
                        hir_target = symbol

                    # Create HIR with item
                    val hir_item = HirWithItem(
                        context_expr: hir_context,
                        target: hir_target,
                        span: item.span
                    )
                    hir_items = hir_items_push(hir_items, hir_item)

                # Lower body
                val hir_body = self.lower_block(body)

                # Create With expression
                HirStmtKind.Expr(HirExpr(
                    kind: hirexprkind_With(hir_items, hir_body),
                    type_: nil,
                    span: s.span
                ))

            case _:
                self.error("unsupported statement kind", s.span)
                HirStmtKind.Expr(HirExpr(
                    kind: HirExprKind.Error,
                    type_: nil,
                    span: s.span
                ))

        HirStmt(kind: kind, span: s.span)

