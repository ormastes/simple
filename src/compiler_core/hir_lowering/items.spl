# HIR Lowering - Item Lowering
#
# This module handles lowering of top-level items (functions, classes, structs, enums, traits, impls) from AST to HIR.

use hir_types.*
use hir_definitions.*
use parser.*
use lexer.Span
use hir_lowering.types.HirLowering
use attributes.{parse_layout_attrs, parse_function_attrs, FunctionAttr}
use type_layout.{LayoutAttr, LayoutKind}

# Item Lowering (Functions, Classes, Structs, Enums, Traits, Impls)
# ============================================================================


# ============================================================================
# HirLowering Methods (was: impl HirLowering:)
# ============================================================================

fn hirlowering_lower_module(self: HirLowering, module: Module) -> HirModule:
        """Lower a parsed module to HIR."""
        # First pass: declare all top-level symbols
        self.declare_module_symbols(module)

        # Second pass: lower definitions
        var functions: Dict<SymbolId, HirFunction> = {}
        var classes: Dict<SymbolId, HirClass> = {}
        var structs: Dict<SymbolId, HirStruct> = {}
        var enums: Dict<SymbolId, HirEnum> = {}
        var bitfields: Dict<SymbolId, HirBitfield> = {}
        var traits: Dict<SymbolId, HirTrait> = {}
        var impls: [HirImpl] = []
        var constants: Dict<SymbolId, HirConst> = {}

        for name in module.functions_keys(functions):
            val fn_ = module.functions[name]
            val hir_fn = self.lower_function(fn_)
            functions[hir_fn.symbol] = hir_fn

        for name in module.classes_keys(classes):
            val class_ = module.classes[name]
            val hir_class = self.lower_class(class_)
            classes[hir_class.symbol] = hir_class

        for name in module.structs_keys(structs):
            val struct_ = module.structs[name]
            val hir_struct = self.lower_struct(struct_)
            structs[hir_struct.symbol] = hir_struct

        for name in module.enums_keys(enums):
            val enum_ = module.enums[name]
            val hir_enum = self.lower_enum(enum_)
            enums[hir_enum.symbol] = hir_enum

        for name in module.bitfields_keys(bitfields):
            val bf = module.bitfields[name]
            val hir_bf = self.lower_bitfield(bf)
            bitfields[hir_bf.symbol] = hir_bf

        for name in module.traits_keys(traits):
            val trait_ = module.traits[name]
            val hir_trait = self.lower_trait(trait_)
            traits[hir_trait.symbol] = hir_trait

        for impl_ in module.impls:
            impls = impls_push(impls, self.lower_impl(impl_))

        for name in module.constants_keys(constants):
            val const_ = module.constants[name]
            val hir_const = self.lower_const(const_)
            constants[hir_const.symbol] = hir_const

        # Lower static assertions
        var static_asserts: [HirStaticAssert] = []
        for assert_ in module.static_asserts:
            static_asserts = static_asserts_push(static_asserts, self.lower_static_assert(assert_))

        # Lower imports
        var imports: [HirImport] = []
        for imp in module.imports:
            imports = imports_push(imports, self.lower_import(imp))

        # Collect exports
        var exports: [text] = []
        for exp in module.exports:
            for item in exp.items:
                exports = exports_push(exports, item)

        HirModule(
            name: module.name,
            path: "",
            imports: imports,
            exports: exports,
            symbols: self.symbols,
            functions: functions,
            classes: classes,
            structs: structs,
            enums: enums,
            bitfields: bitfields,
            traits: traits,
            impls: impls,
            constants: constants,
            static_asserts: static_asserts
        )


fn hirlowering_lower_import(self: HirLowering, imp: Import) -> HirImport:
        """Lower import declaration."""
        var items: [HirImportItem] = []
        for item in imp.items:
            items = items.push(HirImportItem(
                name: item.name,
                alias: item.alias,
                resolved: nil
            ))

        HirImport(
            module_path: imp.module,
            items: items,
            span: imp.span
        )


fn hirlowering_lower_function(self: HirLowering, fn_: Function) -> HirFunction:
        """Lower function to HIR."""
        # Workaround: Store symbols in local var first to avoid interpreter bug
        # where chained method calls corrupt 'self'
        var symbols_table = self.symbols
        val fn_symbol_id = symbols_table_lookup(symbols_table, fn_.name).unwrap()

        # Workaround: Create the Some value separately to avoid interpreter bug
        val opt_fn_id: SymbolId = fn_symbol_id
        self.current_function = opt_fn_id

        # Re-get symbols from self after field modification
        symbols_table = self.symbols
        symbols_table_push_scope(symbols_table, ScopeKind.Function)
        self.symbols = symbols_table

        # Lower type parameters
        var type_params: [HirTypeParam] = []
        for tp in fn_.type_params:
            type_params = type_params_push(type_params, self.lower_type_param(tp))

        # Lower parameters
        var params: [HirParam] = []
        for p in fn_.params:
            params = params_push(params, self.lower_param(p))

        # Lower return type â€” use explicit check instead of .map() ?? default
        # to avoid crash with null coalescing on Option.map result
        var return_type = HirType(kind: HirTypeKind.Unit, span: fn_.span)
        if fn_.has_return_type:
            val mapped = fn_.return_type_map(return_type, \t: self.lower_type(t))
            if has_mapped:
                return_type = mapped_value

        # Lower body
        val body = self.lower_block(fn_.body)

        # Workaround: Store symbols in local var to avoid interpreter bug
        symbols_table = self.symbols
        symbols_table_pop_scope(symbols_table)
        self.symbols = symbols_table
        self.current_function = nil

        # Compute effective visibility using filename matching
        val effective_public = self.compute_visibility(fn_.name, fn_.is_public)

        # Parse function attributes (@entry, @naked, @noreturn, @section, @interrupt)
        val fa = parse_function_attrs(fn_.attributes)
        val has_func_attr = fa.is_entry or fa.is_naked or fa.is_noreturn or fa.has_section or fa.is_interrupt
        val func_attr_opt: FunctionAttr? = if has_func_attr:
            Some(fa)
        else:
            nil

        val hir_func = HirFunction(
            symbol: fn_symbol_id,
            name: fn_.name,
            type_params: type_params,
            params: params,
            return_type: return_type,
            body: body,
            effects: [],
            is_async: fn_.is_async,
            is_static: fn_.is_static,
            is_public: effective_public,
            is_method: fn_.is_method,
            is_mutable: fn_.is_mutable,
            is_const: fn_.is_const,
            is_extern: fn_.is_extern,
            func_attr: func_attr_opt,
            doc_comment: fn_.doc_comment,
            span: fn_.span
        )

        # Validate async functions
        if fn_.is_async:
            self.validate_async_function(hir_func)

        hir_func


fn hirlowering_lower_param(self: HirLowering, p: Param) -> HirParam:
        """Lower function parameter."""
        val type_ = p.type__map(type_, \t: self.lower_type(t)) ?? HirType(kind: hirtypekind_Infer(0, 0), span: p.span)
        # Workaround: Store symbols in local var to avoid interpreter bug
        var symbols_table = self.symbols
        val symbol = symbols_table_define(symbols_table, p.name, SymbolKind.Parameter, type_, p.span, false, false, nil)
        self.symbols = symbols_table

        HirParam(
            symbol: symbol,
            name: p.name,
            type_: type_,
            default: p.default_map(default, \e: self.lower_expr(e)),
            span: p.span
        )


fn hirlowering_lower_class(self: HirLowering, class_: Class) -> HirClass:
        """Lower class to HIR."""
        # Workaround: Store symbols in local var to avoid interpreter bug
        var symbols_table = self.symbols
        val symbol = symbols_table_lookup(symbols_table, class_.name).unwrap()

        symbols_table_push_scope(symbols_table, ScopeKind.Class)
        self.symbols = symbols_table

        var type_params: [HirTypeParam] = []
        for tp in class_.type_params:
            type_params = type_params_push(type_params, self.lower_type_param(tp))

        var fields: [HirField] = []
        for f in class_.fields:
            fields = fields_push(fields, self.lower_field(f))

        var methods: Dict<text, SymbolId> = {}
        for name in class_.methods_keys(methods):
            val fn_ = class_.methods[name]
            val hir_fn = self.lower_function(fn_)
            methods[name] = hir_fn.symbol

        symbols_table = self.symbols
        symbols_table_pop_scope(symbols_table)
        self.symbols = symbols_table

        # Compute effective visibility using filename matching
        val effective_public = self.compute_visibility(class_.name, class_.is_public)

        # Parse layout attributes (@repr, @packed, @align)
        val layout = parse_layout_attrs(class_.attributes)
        # val layout_opt: LayoutAttr = if layout.layout_kind != LayoutKind.Simple or layout.explicit_align.? or layout.# DESUGARED: is_packed: Some(layout)
            is_packed: layout
        else:
            nil

        HirClass(
            symbol: symbol,
            name: class_.name,
            type_params: type_params,
            fields: fields,
            methods: methods,
            is_public: effective_public,
            doc_comment: class_.doc_comment,
            span: class_.span,
            layout_attr: layout_opt,
            is_generic_template: false,
            #  # DESUGARED: specialization_of: nil
            type_bindings: {}
        )


fn hirlowering_lower_struct(self: HirLowering, struct_: Struct) -> HirStruct:
        """Lower struct to HIR."""
        # Workaround: Store symbols in local var to avoid interpreter bug
        var symbols_table = self.symbols
        val symbol = symbols_table_lookup(symbols_table, struct_.name).unwrap()
        self.symbols = symbols_table

        var type_params: [HirTypeParam] = []
        for tp in struct_.type_params:
            type_params = type_params_push(type_params, self.lower_type_param(tp))

        var fields: [HirField] = []
        for f in struct_.fields:
            fields = fields_push(fields, self.lower_field(f))

        # Compute effective visibility using filename matching
        val effective_public = self.compute_visibility(struct_.name, struct_.is_public)

        # Parse layout attributes (@repr, @packed, @align)
        val layout = parse_layout_attrs(struct_.attributes)
        # val layout_opt: LayoutAttr = if layout.layout_kind != LayoutKind.Simple or layout.explicit_align.? or layout.# DESUGARED: is_packed: Some(layout)
            is_packed: layout
        else:
            nil

        HirStruct(
            symbol: symbol,
            name: struct_.name,
            type_params: type_params,
            fields: fields,
            is_public: effective_public,
            doc_comment: struct_.doc_comment,
            span: struct_.span,
            layout_attr: layout_opt,
            is_generic_template: false,
            #  # DESUGARED: specialization_of: nil
            type_bindings: {}
        )


fn hirlowering_lower_field(self: HirLowering, f: Field) -> HirField:
        """Lower field to HIR."""
        val type_ = self.lower_type(f.type_)
        # Workaround: Store symbols in local var to avoid interpreter bug
        var symbols_table = self.symbols
        val symbol = symbols_table_define(symbols_table, f.name, SymbolKind.Field, type_, f.span, f.is_public, false, nil)
        self.symbols = symbols_table

        HirField(
            symbol: symbol,
            name: f.name,
            type_: type_,
            default: f.default_map(default, \e: self.lower_expr(e)),
            is_public: f.is_public,
            is_volatile: f.is_volatile,
            fixed_address: f.fixed_address,
            span: f.span
        )


fn hirlowering_lower_enum(self: HirLowering, enum_: Enum) -> HirEnum:
        """Lower enum to HIR."""
        val symbol = self.symbols_lookup(symbols, enum_.name).unwrap()

        var type_params: [HirTypeParam] = []
        for tp in enum_.type_params:
            type_params = type_params_push(type_params, self.lower_type_param(tp))

        var variants: [HirVariant] = []
        for v in enum_.variants:
            variants = variants_push(variants, self.lower_variant(v))

        # Compute effective visibility using filename matching
        val effective_public = self.compute_visibility(enum_.name, enum_.is_public)

        HirEnum(
            symbol: symbol,
            name: enum_.name,
            type_params: type_params,
            variants: variants,
            is_public: effective_public,
            doc_comment: enum_.doc_comment,
            span: enum_.span,
            is_generic_template: false,
            #  # DESUGARED: specialization_of: nil
            type_bindings: {}
        )


fn hirlowering_lower_variant(self: HirLowering, v: Variant) -> HirVariant:
        """Lower enum variant."""
        val symbol = self.symbols_define(symbols, v.name, SymbolKind.EnumVariant, nil, v.span, true, false, nil)

        val kind = match v.kind:
            case Unit:
                HirVariantKind.Unit
            case Tuple(types):
                var hir_types: [HirType] = []
                for t in types:
                    hir_types = hir_types_push(hir_types, self.lower_type(t))
                hirvariantkind_Tuple(hir_types)
            case Struct(fields):
                var hir_fields: [HirField] = []
                for f in fields:
                    hir_fields = hir_fields_push(hir_fields, self.lower_field(f))
                hirvariantkind_Struct(hir_fields)

        HirVariant(
            symbol: symbol,
            name: v.name,
            kind: kind,
            span: v.span
        )


fn hirlowering_lower_bitfield(self: HirLowering, bf: Bitfield) -> HirBitfield:
        """Lower bitfield to HIR."""
        val symbol = self.symbols_lookup(symbols, bf.name).unwrap()

        val backing = self.lower_type(bf.backing_type)

        # Lower fields and compute bit offsets
        var fields: [HirBitfieldField] = []
        var bit_offset: i64 = 0
        for f in bf.fields:
            val hir_field = self.lower_bitfield_field(f, bit_offset)
            fields = fields_push(fields, hir_field)
            bit_offset = bit_offset + hir_field.bit_width

        # Compute effective visibility using filename matching
        val effective_public = self.compute_visibility(bf.name, bf.is_public)

        HirBitfield(
            symbol: symbol,
            name: bf.name,
            backing_type: backing,
            fields: fields,
            total_bits: bit_offset,
            is_public: effective_public,
            doc_comment: bf.doc_comment,
            span: bf.span
        )


fn hirlowering_lower_bitfield_field(self: HirLowering, f: BitfieldField, offset: i64) -> HirBitfieldField:
        """Lower bitfield field to HIR."""
        val symbol = self.symbols_define(symbols, f.name, SymbolKind.Field, nil, f.span, false, false, nil)

        # Determine bit width:
        # 1. Explicit @bits(N) takes precedence
        # 2. For reserved fields, use explicit bits
        # 3. For typed fields, infer from type
        val bit_width = if f.has_bits:
            f.bits_value
        elif f.is_reserved:
            0  # Reserved without explicit bits = 0
        else:
            # Infer from type (use default primitive widths)
            self.infer_bit_width(f.type_)

        HirBitfieldField(
            symbol: symbol,
            name: f.name,
            type_: f.type__map(type_, \t: self.lower_type(t)),
            bit_width: bit_width,
            bit_offset: offset,
            is_reserved: f.is_reserved,
            span: f.span
        )


fn hirlowering_lower_trait(self: HirLowering, trait_: Trait) -> HirTrait:
        """Lower trait to HIR."""
        val symbol = self.symbols_lookup(symbols, trait_.name).unwrap()

        self.symbols_push_scope(symbols, ScopeKind.Class)

        var type_params: [HirTypeParam] = []
        for tp in trait_.type_params:
            type_params = type_params_push(type_params, self.lower_type_param(tp))

        # Lower supertraits
        var supertraits: [HirType] = []
        for st in trait_.super_traits:
            supertraits = supertraits_push(supertraits, self.lower_type(st))

        # Lower where clause
        var where_clause: [HirTraitBound] = []
        for bound in trait_.where_clause:
            where_clause = where_clause_push(where_clause, self.lower_trait_bound(bound))

        # Separate methods into abstract (no body) and defaults (with body)
        var abstract_methods: [HirFunction] = []
        var defaults: [HirFunction] = []
        for m in trait_.methods:
            val hir_fn = self.lower_function(m)
            # Check if method has a body (default implementation)
            # Function.body is a Block, check if it has statements
            if m.body.stmts_is_empty(stmts):
                if m.body.value_is_none(value):
                abstract_methods = abstract_methods_push(abstract_methods, hir_fn)
            else:
                defaults = defaults_push(defaults, hir_fn)

        self.symbols_pop_scope(symbols)

        # Compute effective visibility using filename matching
        val effective_public = self.compute_visibility(trait_.name, trait_.is_public)

        HirTrait(
            symbol: symbol,
            name: trait_.name,
            type_params: type_params,
            methods: abstract_methods,
            supertraits: supertraits,
            defaults: defaults,
            where_clause: where_clause,
            is_public: effective_public,
            doc_comment: trait_.doc_comment,
            span: trait_.span,
            is_generic_template: false,
            #  # DESUGARED: specialization_of: nil
            type_bindings: {}
        )


fn hirlowering_lower_impl(self: HirLowering, impl_: Impl) -> HirImpl:
        """Lower impl block to HIR."""
        self.symbols_push_scope(symbols, ScopeKind.Impl)

        # Lower generic type parameters
        var type_params: [HirTypeParam] = []
        for tp in impl_.type_params:
            type_params = type_params_push(type_params, self.lower_type_param(tp))

        # Lower where clause
        var where_clause: [HirTraitBound] = []
        for bound in impl_.where_clause:
            where_clause = where_clause_push(where_clause, self.lower_trait_bound(bound))

        val type_ = self.lower_type(impl_.type_)
        val trait_ = impl_.trait__map(trait_, \t: self.lower_type(t))

        var methods: Dict<text, SymbolId> = {}
        for name in impl_.methods_keys(methods):
            val fn_ = impl_.methods[name]
            val hir_fn = self.lower_function(fn_)
            methods[name] = hir_fn.symbol

        self.symbols_pop_scope(symbols)

        HirImpl(
            type_: type_,
            trait_: trait_,
            type_params: type_params,
            where_clause: where_clause,
            methods: methods,
            span: impl_.span
        )


fn hirlowering_lower_const(self: HirLowering, const_: Const) -> HirConst:
        """Lower constant to HIR."""
        val symbol = self.symbols_lookup(symbols, const_.name).unwrap()
        val type_ = const_.type__map(type_, \t: self.lower_type(t)) ?? HirType(kind: hirtypekind_Infer(0, 0), span: const_.span)
        val value = self.lower_expr(const_.value)

        # Compute effective visibility using filename matching
        val effective_public = self.compute_visibility(const_.name, const_.is_public)

        HirConst(
            symbol: symbol,
            name: const_.name,
            type_: type_,
            value: value,
            is_mutable: const_.is_mutable,
            is_public: effective_public,
            is_volatile: const_.is_volatile,
            fixed_address: const_.fixed_address,
            span: const_.span
        )


fn hirlowering_lower_static_assert(self: HirLowering, assert_: StaticAssert) -> HirStaticAssert:
        """Lower static assertion to HIR."""
        val condition = self.lower_expr(assert_.condition)

        HirStaticAssert(
            condition: condition,
            message: assert_.message,
            span: assert_.span
        )

