# MIR Lowering - HIR to MIR Transformation
#
# This module handles lowering from HIR (High-level IR) to MIR (Mid-level IR).
# It converts:
# - Nested expressions to SSA form
# - Control flow to basic blocks
# - Memory operations to explicit loads/stores
# - Type system from HIR to MIR representation

use mir_data.*
use hir.*
use lexer.Span
use blocks.value.BlockValue

# ============================================================================
# HIR to MIR Lowering
# ============================================================================

struct MirLowering:
    """Lowers HIR to MIR."""
    builder: MirBuilder
    symbols: SymbolTable
    local_map: Dict<SymbolId, LocalId>
    loop_stack: [(BlockId, BlockId)]  # (continue_block, break_block)
    errors: [MirError]

struct MirError:
    """MIR lowering error."""
    message: text
    # DESUGARED: span: Span?
    has_span: bool
    span_value: Span


# ============================================================================
# MirLowering Methods (was: impl MirLowering:)
# ============================================================================

fn mirlowering_new(symbols: SymbolTable) -> MirLowering:
        MirLowering(
            builder: mirbuilder_new(),
            symbols: symbols,
            local_map: {},
            loop_stack: [],
            errors: []
        )


fn mirlowering_lower_module(self: MirLowering, module: HirModule) -> MirModule:
        """Lower HIR module to MIR."""
        # Copy-modify-reassign: nested field mutations don't propagate in interpreter
        var builder = self.builder
        var builder_module = builder.module
        builder_module.name = module.name
        builder.module = builder_module
        self.builder = builder

        # Lower functions (skip extern declarations - they have no body)
        for fn_ in module.functions_values(functions):
            var fn_is_extern = false
            if fn_.has_is_extern:
                fn_is_extern = fn_.is_extern
            if fn_is_extern:
                continue
            val mir_fn = self.lower_function(fn_)
            # Copy-modify-reassign: self.builder.add_function() won't propagate
            var bldr = self.builder
            bldr_add_function(bldr, mir_fn)
            self.builder = bldr

        # Lower constants
        for const_ in module.constants_values(constants):
            self.lower_const(const_)

        self.builder.module


fn mirlowering_lower_function(self: MirLowering, fn_: HirFunction) -> MirFunction:
        """Lower HIR function to MIR."""
        self.local_map = {}

        # Build signature
        var params: [MirType] = []
        for p in fn_.params:
            params = params_push(params, self.lower_type(p.type_))

        val return_type = self.lower_type(fn_.return_type)
        val signature = MirSignature(
            params: params,
            return_type: return_type,
            is_variadic: false
        )

        # Begin function (copy-modify-reassign for interpreter)
        var bldr = self.builder
        bldr_begin_function(bldr, fn_.symbol, fn_.name, signature, fn_.span)
        self.builder = bldr

        # Map parameters to locals
        for i in 0..fn_.params_len(params):
            val param = fn_.params[i]
            val local = LocalId(id: i + 1)  # +1 for return slot
            self.local_map[param.symbol] = local

        # Lower body
        val result = self.lower_block(fn_.body)

        # Return result (copy-modify-reassign for interpreter)
        var bldr2 = self.builder
        if has_result:
            bldr2_terminate_return(bldr2, has_field = true, field_value = mir_operand_copy(result_value))
        else:
            bldr2_terminate_return(bldr2, nil)
        self.builder = bldr2

        var bldr3 = self.builder
        val fn_result = bldr3_end_function(bldr3)
        self.builder = bldr3
        fn_result


fn mirlowering_lower_type(self: MirLowering, type_: HirType) -> MirType:
        """Lower HIR type to MIR type."""
        match type_.kind:
            case Int(bits, signed):
                if signed:
                    match bits:
                        case 8: MirType(kind: MirTypeKind.I8)
                        case 16: MirType(kind: MirTypeKind.I16)
                        case 32: MirType(kind: MirTypeKind.I32)
                        case _: MirType(kind: MirTypeKind.I64)
                else:
                    match bits:
                        case 8: MirType(kind: MirTypeKind.U8)
                        case 16: MirType(kind: MirTypeKind.U16)
                        case 32: MirType(kind: MirTypeKind.U32)
                        case _: MirType(kind: MirTypeKind.U64)
            case Float(bits):
                match bits:
                    case 32: MirType(kind: MirTypeKind.F32)
                    case _: MirType(kind: MirTypeKind.F64)
            case Bool:
                MirType(kind: MirTypeKind.Bool)
            case Char:
                MirType(kind: MirTypeKind.Char)
            case Str:
                # String is a fat pointer (ptr, len)
                MirType(kind: MirTypeKind.Tuple([
                    MirType(kind: mirtypekind_Ptr(MirType(kind: MirTypeKind.U8), false)),
                    MirType(kind: MirTypeKind.U64)
                ]))
            case Unit:
                MirType(kind: MirTypeKind.Unit)
            case Tuple(elements):
                var mir_elements: [MirType] = []
                for e in elements:
                    mir_elements = mir_elements_push(mir_elements, self.lower_type(e))
                MirType(kind: mirtypekind_Tuple(mir_elements))
            case Array(element, size):
                MirType(kind: mirtypekind_Array(self.lower_type(element), size ?? 0))
            case Ref(inner, mutable):
                MirType(kind: mirtypekind_Ref(self.lower_type(inner), mutable))
            case Optional(inner):
                # Optional is enum { nil, has_field = true, field_value = T }
                MirType(kind: MirTypeKind.Tuple([
                    MirType(kind: MirTypeKind.Bool),  # has_value
                    self.lower_type(inner)
                ]))
            case Named(symbol, _):
                MirType(kind: mirtypekind_Struct(symbol))
            case Never:
                MirType(kind: MirTypeKind.Never)
            case _:
                self.error("unsupported MIR type kind: {type_.kind}", nil)
                MirType(kind: MirTypeKind.I64)


fn mirlowering_lower_assign_op(self: MirLowering, op: HirAssignOp) -> MirBinOp:
        """Convert assignment op to binary op."""
        match op:
            case Add: MirBinOp.Add
            case Sub: MirBinOp.Sub
            case Mul: MirBinOp.Mul
            case Div: MirBinOp.Div
            case Mod: MirBinOp.Rem
            case _: MirBinOp.Add


fn mirlowering_lower_expr(self: MirLowering, expr: HirExpr) -> LocalId:
        """Lower HIR expression to MIR, return result local."""
        match expr.kind:
            case IntLit(value, _):
                var b = self.builder
                val result = b_emit_const_int(b, value)
                self.builder = b
                result

            case FloatLit(value, _):
                var b = self.builder
                val result = b_emit_const_float(b, value)
                self.builder = b
                result

            case BoolLit(value):
                var b = self.builder
                val result = b_emit_const_bool(b, value)
                self.builder = b
                result

            case StringLit(value, _):
                # Store string as constant; runtime resolves pointer
                var b = self.builder
                val dest = b.new_temp(MirType(kind: MirTypeKind.Opaque("str")))
                b.emit_const(dest, MirConstValue.Str(value), MirType(kind: MirTypeKind.Opaque("str")))
                self.builder = b
                dest

            case NilLit | UnitLit:
                var b = self.builder
                val result = b_new_temp(b, MirType.unit())
                self.builder = b
                result

            case Var(symbol):
                # Look up variable in local_map using contains_key first
                if self.local_map_contains_key(local_map, symbol):
                    self.local_map[symbol]
                else:
                    self.error("undefined variable", has_field = true, field_value = expr.span)
                    var b_err = self.builder
                    val err_tmp = b_err_new_temp(b_err, MirType.i64())
                    self.builder = b_err
                    err_tmp

            case Binary(op, left, right):
                # Check if this is a special pipeline operator first
                val special_result = self.lower_binop_special(op, left, right)
                if has_special_result:
                    special_result_value
                else:
                    # Normal binary operation
                    val left_local = self.lower_expr(left)
                    val right_local = self.lower_expr(right)
                    val mir_op = self.lower_binop(op)
                    val result_type = self.infer_binop_type(op)
                    var b = self.builder
                    val binop_result = b_emit_binop(b, mir_op, mir_operand_copy(left_local), mir_operand_copy(right_local), result_type)
                    self.builder = b
                    binop_result

            case Unary(op, operand):
                val operand_local = self.lower_expr(operand)
                val mir_op = self.lower_unaryop(op)
                var b = self.builder
                val unary_result = b_emit_unary(b, mir_op, mir_operand_copy(operand_local), mirtype_i64())
                self.builder = b
                unary_result

            case If(cond, then_, else_):
                self.lower_if(cond, then_, else_)

            case Call(callee, args, _):
                self.lower_call(callee, args)

            case MethodCall(receiver, method, args, resolution):
                self.lower_method_call(receiver, method, args, resolution)

            case ArrayLit(elements, _):
                self.lower_array_lit(elements)

            case Index(base, index):
                # Array indexing: arr[i] -> GEP + Load
                val base_local = self.lower_expr(base)
                val index_local = self.lower_expr(index)
                var b = self.builder
                val ptr = b.emit_gep(
                    mir_operand_copy(base_local),
                    [mir_operand_copy(index_local)],
                    mirtype_ptr(MirType.i64(), false)
                )
                val loaded = b_emit_load(b, mir_operand_copy(ptr), mirtype_i64())
                self.builder = b
                loaded

            case SetLit(elements, _):
                self.lower_set_lit(elements)

            case TupleLit(elements):
                self.lower_tuple_lit(elements)

            case Block(block):
                val result = self.lower_block(block)
                if has_result:
                    result_value
                else:
                    var b = self.builder
                    val temp = b_new_temp(b, MirType.unit())
                    self.builder = b
                    temp

            case Loop(body, _):
                self.lower_loop(body)

            case While(cond, body, _):
                self.lower_while(cond, body)

            case For(var_, iter, body, _):
                self.lower_for(var_, iter, body)

            case Return(value):
                var br = self.builder
                if has_value:
                    val result = self.lower_expr(value_value)
                    br = self.builder
                    br_terminate_return(br, has_field = true, field_value = mir_operand_copy(result))
                else:
                    br_terminate_return(br, nil)
                self.builder = br
                var br2 = self.builder
                val ret_temp = br2_new_temp(br2, MirType.unit())
                self.builder = br2
                ret_temp

            case Break(break_label, break_value):
                if self.loop_stack_len(loop_stack) > 0:
                    val (loop_continue_block, break_block) = self.loop_stack[self.loop_stack_len(loop_stack) - 1]
                    var b = self.builder
                    b_terminate_goto(b, break_block)
                    self.builder = b
                var b = self.builder
                val break_temp = b_new_temp(b, MirType.unit())
                self.builder = b
                break_temp

            case Continue(cont_label):
                if self.loop_stack_len(loop_stack) > 0:
                    val (continue_block, loop_break_block) = self.loop_stack[self.loop_stack_len(loop_stack) - 1]
                    var b = self.builder
                    b_terminate_goto(b, continue_block)
                    self.builder = b
                var b = self.builder
                val cont_temp = b_new_temp(b, MirType.unit())
                self.builder = b
                cont_temp

            # Custom blocks (user-defined: sh{}, sql{}, re{}, etc.)
            case CustomBlock(kind, value):
                self.lower_custom_block(kind, value, expr.span)

            # Math/DL blocks with special semantics
            case LossBlock(body):
                self.lower_loss_block(body)

            case NogradBlock(body):
                self.lower_nograd_block(body)

            case Range(start, end, inclusive, step):
                self.lower_range(start, end, inclusive, step)

            # Async/Await expressions
            case Await(future_expr):
                self.lower_await(future_expr)

            case Yield(value):
                self.lower_yield(value)

            # Unsafe block - lower the body, no special handling
            case UnsafeBlock(body):
                self.lower_block(body) ?? self.builder_new_temp(builder, MirType.unit())

            # Inline assembly
            case InlineAsm(asm):
                self.lower_inline_asm(asm)

            case _:
                self.error("unsupported MIR expression: {expr.kind}", nil)
                nil


fn mirlowering_lower_binop(self: MirLowering, op: HirBinOp) -> MirBinOp:
        """Convert HIR binary op to MIR binary op."""
        match op:
            case Add: MirBinOp.Add
            case Sub: MirBinOp.Sub
            case Mul: MirBinOp.Mul
            case Div: MirBinOp.Div
            case Mod: MirBinOp.Rem
            case Pow: MirBinOp.Pow
            case MatMul: MirBinOp.MatMul
            case BitAnd: MirBinOp.BitAnd
            case BitOr: MirBinOp.BitOr
            case BitXor: MirBinOp.BitXor
            case Shl: MirBinOp.Shl
            case Shr: MirBinOp.Shr
            case Eq: MirBinOp.Eq
            case NotEq: MirBinOp.Ne
            case Lt: MirBinOp.Lt
            case LtEq: MirBinOp.Le
            case Gt: MirBinOp.Gt
            case GtEq: MirBinOp.Ge
            case BroadcastAdd: MirBinOp.BroadcastAdd
            case BroadcastSub: MirBinOp.BroadcastSub
            case BroadcastMul: MirBinOp.BroadcastMul
            case BroadcastDiv: MirBinOp.BroadcastDiv
            case BroadcastPow: MirBinOp.BroadcastPow
            case _: MirBinOp.Add


fn mirlowering_lower_unaryop(self: MirLowering, op: HirUnaryOp) -> MirUnaryOp:
        """Convert HIR unary op to MIR unary op."""
        match op:
            case Neg: MirUnaryOp.Neg
            case Not: MirUnaryOp.Not
            case BitNot: MirUnaryOp.BitNot
            case Transpose: MirUnaryOp.Transpose
            case _: MirUnaryOp.Neg


fn mirlowering_infer_binop_type(self: MirLowering, op: HirBinOp) -> MirType:
        """Infer result type of binary operation."""
        match op:
            case Eq | NotEq | Lt | LtEq | Gt | GtEq:
                mirtype_bool()
            case _:
                mirtype_i64()  # Default to i64


fn mirlowering_lower_if(self: MirLowering, cond: HirExpr, then_: HirBlock, else_: HirBlock?) -> LocalId:
        """Lower if expression."""
        val cond_local = self.lower_expr(cond)

        var b = self.builder
        val then_block = b.new_block(has_field = true, field_value = "then")
        val else_block = b.new_block(has_field = true, field_value = "else")
        val merge_block = b.new_block(has_field = true, field_value = "merge")
        val result = b_new_temp(b, MirType.i64())
        b_terminate_if(b, mir_operand_copy(cond_local), then_block, else_block)
        self.builder = b

        # Then block
        var b2 = self.builder
        b2_switch_to_block(b2, then_block)
        self.builder = b2
        val then_result = self.lower_block(then_)
        var b3 = self.builder
        if has_then_result:
            b3_emit_copy(b3, result, then_result_value)
        b3_terminate_goto(b3, merge_block)
        self.builder = b3

        # Else block
        var b4 = self.builder
        b4_switch_to_block(b4, else_block)
        self.builder = b4
        if has_else_:
            val else_result = self.lower_block(else__value)
            var b5 = self.builder
            if has_else_result:
                b5_emit_copy(b5, result, else_result_value)
            b5_terminate_goto(b5, merge_block)
            self.builder = b5
        else:
            var b5 = self.builder
            b5_terminate_goto(b5, merge_block)
            self.builder = b5

        # Merge block
        var b6 = self.builder
        b6_switch_to_block(b6, merge_block)
        self.builder = b6

        result


fn mirlowering_lower_loop(self: MirLowering, body: HirBlock) -> LocalId:
        """Lower loop expression."""
        var b = self.builder
        val loop_block = b.new_block(has_field = true, field_value = "loop")
        val exit_block = b.new_block(has_field = true, field_value = "loop_exit")
        self.builder = b

        self.loop_stack = self.loop_stack_push(loop_stack, (loop_block, exit_block))

        var b2 = self.builder
        b2_terminate_goto(b2, loop_block)
        b2_switch_to_block(b2, loop_block)
        self.builder = b2

        self.lower_block(body)

        var b3 = self.builder
        b3_terminate_goto(b3, loop_block)
        self.builder = b3

        self.loop_stack = self.loop_stack[0:self.loop_stack_len(loop_stack) - 1]

        var b4 = self.builder
        b4_switch_to_block(b4, exit_block)
        val loop_result = b4_new_temp(b4, MirType.unit())
        self.builder = b4
        loop_result


fn mirlowering_lower_while(self: MirLowering, cond: HirExpr, body: HirBlock) -> LocalId:
        """Lower while expression."""
        var b = self.builder
        val cond_block = b.new_block(has_field = true, field_value = "while_cond")
        val body_block = b.new_block(has_field = true, field_value = "while_body")
        val exit_block = b.new_block(has_field = true, field_value = "while_exit")
        self.builder = b

        self.loop_stack = self.loop_stack_push(loop_stack, (cond_block, exit_block))

        var b2 = self.builder
        b2_terminate_goto(b2, cond_block)
        b2_switch_to_block(b2, cond_block)
        self.builder = b2

        val cond_local = self.lower_expr(cond)
        var b3 = self.builder
        b3_terminate_if(b3, mir_operand_copy(cond_local), body_block, exit_block)
        b3_switch_to_block(b3, body_block)
        self.builder = b3

        self.lower_block(body)

        var b4 = self.builder
        b4_terminate_goto(b4, cond_block)
        self.builder = b4

        self.loop_stack = self.loop_stack[0:self.loop_stack_len(loop_stack) - 1]

        var b5 = self.builder
        b5_switch_to_block(b5, exit_block)
        val while_result = b5_new_temp(b5, MirType.unit())
        self.builder = b5
        while_result


fn mirlowering_lower_for(self: MirLowering, var_: SymbolId, iter: HirExpr, body: HirBlock) -> LocalId:
        """Lower for expression using the iterator protocol.

        Lowers:
            for x in collection:
                body

        Into:
            val _iter = collection_iter(collection)
            while _iter_has_next(_iter):
                val x = _iter_next(_iter)
                body
        """
        # Step 1: Lower the iterable expression
        val collection_local = self.lower_expr(iter)

        # Step 2: Call iter() on the collection to get an iterator
        val iter_func_operand = MirOperand(kind: MirOperandKind.Const(
            mirconstvalue_Int(0),
            MirType(kind: mirtypekind_FuncPtr(MirSignature(params: [], return_type: MirType.i64(), is_variadic: false)))
        ))
        var b = self.builder
        val iter_result = b_emit_call(b, iter_func_operand, [mir_operand_copy(collection_local)], mirtype_i64())
        val iter_local = if has_iter_result:
            self.builder = b
            iter_result_value
        else:
            val temp = b_new_temp(b, MirType.i64())
            self.builder = b
            temp

        # Step 3: Create loop blocks
        var b2 = self.builder
        val cond_block = b2.new_block(has_field = true, field_value = "for_cond")
        val body_block = b2.new_block(has_field = true, field_value = "for_body")
        val exit_block = b2.new_block(has_field = true, field_value = "for_exit")
        self.builder = b2

        self.loop_stack = self.loop_stack_push(loop_stack, (cond_block, exit_block))

        # Jump to condition check
        var b3 = self.builder
        b3_terminate_goto(b3, cond_block)
        b3_switch_to_block(b3, cond_block)
        self.builder = b3

        # Step 4: Condition block - call has_next() on iterator
        val has_next_func_operand = MirOperand(kind: MirOperandKind.Const(
            mirconstvalue_Int(0),
            MirType(kind: mirtypekind_FuncPtr(MirSignature(params: [], return_type: MirType.bool(), is_variadic: false)))
        ))
        var b4 = self.builder
        val has_next_result = b4_emit_call(b4, has_next_func_operand, [mir_operand_copy(iter_local)], mirtype_bool())
        val has_next_local = if has_has_next_result:
            self.builder = b4
            has_next_result_value
        else:
            val temp = b4_emit_const_bool(b4, false)
            self.builder = b4
            temp
        var b5 = self.builder
        b5_terminate_if(b5, mir_operand_copy(has_next_local), body_block, exit_block)
        b5_switch_to_block(b5, body_block)
        self.builder = b5

        # Step 5: Body block - call next() to get element, bind to loop variable
        val next_func_operand = MirOperand(kind: MirOperandKind.Const(
            mirconstvalue_Int(0),
            MirType(kind: mirtypekind_FuncPtr(MirSignature(params: [], return_type: MirType.i64(), is_variadic: false)))
        ))
        var b6 = self.builder
        val next_result = b6_emit_call(b6, next_func_operand, [mir_operand_copy(iter_local)], mirtype_i64())
        val next_local = if has_next_result:
            self.builder = b6
            next_result_value
        else:
            val temp = b6_new_temp(b6, MirType.i64())
            self.builder = b6
            temp

        # Bind the loop variable to the next() result
        var b7 = self.builder
        val loop_var = b7_new_local(b7, nil, MirType.i64(), LocalKind.Var)
        b7_emit_copy(b7, loop_var, next_local)
        self.builder = b7
        self.local_map[var_] = loop_var

        # Lower the loop body
        self.lower_block(body)

        # Jump back to condition
        var b8 = self.builder
        b8_terminate_goto(b8, cond_block)
        self.builder = b8

        # Step 6: Exit block
        self.loop_stack = self.loop_stack[0:self.loop_stack_len(loop_stack) - 1]
        var b9 = self.builder
        b9_switch_to_block(b9, exit_block)
        val for_result = b9_new_temp(b9, MirType.unit())
        self.builder = b9
        for_result


fn mirlowering_lower_call(self: MirLowering, callee: HirExpr, args: [HirCallArg]) -> LocalId:
        """Lower function call.

        Handles both direct calls (Var) and indirect calls (closures, function pointers).
        """
        var arg_operands: [MirOperand] = []
        for arg in args:
            val arg_local = self.lower_expr(arg.value)
            arg_operands = arg_operands_push(arg_operands, mir_operand_copy(arg_local))

        # Check if this is a direct call (Var) or indirect call
        match callee.kind:
            case Var(symbol):
                # Direct call - use Call instruction
                val func_operand = self.symbol_to_operand(symbol)
                var b = self.builder
                val result = b_emit_call(b, func_operand, arg_operands, MirType.i64())
                if has_result:
                    self.builder = b
                    result_value
                else:
                    val temp = b_new_temp(b, MirType.unit())
                    self.builder = b
                    temp

            case _:
                # Indirect call - lower callee expression and use CallIndirect
                val callee_local = self.lower_expr(callee)
                # Infer parameter types from arguments
                var param_types: [MirType] = []
                for arg_op in arg_operands:
                    param_types_push(param_types, MirType.i64())
                # Infer return type from callee's type annotation if available
                val ret_type = if callee.has_type_:
                    self.lower_type(callee.type__value)
                else:
                    mirtype_i64()
                val sig = MirSignature(
                    params: param_types,
                    return_type: ret_type,
                    is_variadic: false
                )
                var b = self.builder
                val result = b_emit_call_indirect(b, mir_operand_copy(callee_local), arg_operands, sig, mirtype_i64())
                if has_result:
                    self.builder = b
                    result_value
                else:
                    val temp = b_new_temp(b, MirType.unit())
                    self.builder = b
                    temp


fn mirlowering_lower_method_call(self: MirLowering, receiver: HirExpr, method: text, args: [HirCallArg], resolution: MethodResolution) -> LocalId:
        """Lower method call based on resolution.

        UFCS: For FreeFunction resolution, receiver becomes first argument.
        """
        match resolution:
            case InstanceMethod(type_id, method_id):
                # Direct method call on type
                val arg_operands = self.lower_receiver_and_args(receiver, args)
                val method_operand = self.symbol_to_operand(method_id)
                var b = self.builder
                val result = b_emit_call(b, method_operand, arg_operands, MirType.i64())
                if has_result:
                    self.builder = b
                    result_value
                else:
                    val temp = b_new_temp(b, MirType.unit())
                    self.builder = b
                    temp

            case TraitMethod(trait_id, method_id):
                val arg_operands = self.lower_receiver_and_args(receiver, args)
                val method_operand = self.symbol_to_operand(method_id)
                var b = self.builder
                val result = b_emit_call(b, method_operand, arg_operands, MirType.i64())
                if has_result:
                    self.builder = b
                    result_value
                else:
                    val temp = b_new_temp(b, MirType.unit())
                    self.builder = b
                    temp

            case FreeFunction(func_id):
                val arg_operands = self.lower_receiver_and_args(receiver, args)
                val func_operand = self.symbol_to_operand(func_id)
                var b = self.builder
                val result = b_emit_call(b, func_operand, arg_operands, MirType.i64())
                if has_result:
                    self.builder = b
                    result_value
                else:
                    val temp = b_new_temp(b, MirType.unit())
                    self.builder = b
                    temp

            case StaticMethod(type_id, method_id):
                var arg_operands: [MirOperand] = []
                for arg in args:
                    val arg_local = self.lower_expr(arg.value)
                    arg_operands = arg_operands_push(arg_operands, mir_operand_copy(arg_local))

                val method_operand = self.symbol_to_operand(method_id)
                var b = self.builder
                val result = b_emit_call(b, method_operand, arg_operands, MirType.i64())
                if has_result:
                    self.builder = b
                    result_value
                else:
                    val temp = b_new_temp(b, MirType.unit())
                    self.builder = b
                    temp

            case Unresolved:
                self.error("unresolved method call: {method}", nil)
                var b = self.builder
                val temp = b_new_temp(b, MirType.unit())
                self.builder = b
                temp


fn mirlowering_symbol_to_operand(self: MirLowering, symbol: SymbolId) -> MirOperand:
        """Convert a symbol to a function pointer operand."""
        # Look up function name from symbol table for direct calls
        val sym = self.symbols_get(symbols, symbol)
        val name = if has_sym: sym.name else: "unknown_{symbol.id}"
        MirOperand(kind: MirOperandKind.Const(
            mirconstvalue_Str(name),
            MirType(kind: mirtypekind_FuncPtr(MirSignature(params: [], return_type: MirType.i64(), is_variadic: false)))
        ))


fn mirlowering_lower_array_lit(self: MirLowering, elements: [HirExpr]) -> LocalId:
        """Lower array literal."""
        var operands: [MirOperand] = []
        for elem in elements:
            val local = self.lower_expr(elem)
            operands = operands_push(operands, mir_operand_copy(local))

        val elem_type = if elements_len(elements) > 0 and elements[0].has_type_:
            self.lower_type(elements[0].type__value)
        else:
            mirtype_i64()
        val array_type = MirType(kind: mirtypekind_Array(elem_type, elements.len()))

        self.builder.emit_aggregate(
            aggregatekind_Array(elem_type),
            operands,
            array_type
        )


fn mirlowering_lower_tuple_lit(self: MirLowering, elements: [HirExpr]) -> LocalId:
        """Lower tuple literal."""
        var operands: [MirOperand] = []
        var types: [MirType] = []
        for elem in elements:
            val local = self.lower_expr(elem)
            operands = operands_push(operands, mir_operand_copy(local))
            val elem_ty = if elem.has_type_:
                self.lower_type(elem.type__value)
            else:
                mirtype_i64()
            types = types_push(types, elem_ty)

        val tuple_type = MirType(kind: mirtypekind_Tuple(types))
        self.builder_emit_aggregate(builder, AggregateKind.Tuple, operands, tuple_type)


fn mirlowering_lower_set_lit(self: MirLowering, elements: [HirExpr]) -> LocalId:
        """Lower set literal to Set.from() call.

        Transforms: s{1, 2, 3}
        Into: set_from([1, 2, 3])

        This is simpler than set_new() + insert() and works with current runtime.
        Future optimization: emit direct set_new() + insert() calls.
        """
        # Infer element type from first element, or default to i64
        val elem_type = if elements_len(elements) > 0 and elements[0].has_type_:
            self.lower_type(elements[0].type__value)
        else:
            mirtype_i64()

        # Lower elements to array literal
        var elem_operands: [MirOperand] = []
        for elem in elements:
            val elem_local = self.lower_expr(elem)
            elem_operands = elem_operands_push(elem_operands, mir_operand_copy(elem_local))

        # Create array from elements
        val array_type = MirType(kind: mirtypekind_Array(elem_type, elements.len()))
        val array_local = self.builder.emit_aggregate(
            aggregatekind_Array(elem_type),
            elem_operands,
            array_type
        )

        # Call Set.from(array) - using runtime function placeholder
        # In a real implementation, this would resolve Set.from symbol from symbol table
        # For now, create a function operand that will be resolved by codegen
        val set_from_operand = MirOperand(kind: MirOperandKind.Const(
            MirConstValue.Int(0),  # Placeholder - codegen will resolve "Set.from"
            MirType(kind: MirTypeKind.FuncPtr(MirSignature(
                params: [array_type],
                return_type: MirType(kind: MirTypeKind.Named("Set", [elem_type])),
                is_variadic: false
            )))
        ))

        val set_type = MirType(kind: MirTypeKind.Named("Set", [elem_type]))
        val result = self.builder.emit_call(
            set_from_operand,
            [mir_operand_copy(array_local)],
            set_type
        )

        result ?? self.builder_new_temp(builder, set_type)


fn mirlowering_lower_custom_block(self: MirLowering, kind: text, value: BlockValue, span: Span) -> LocalId:
        """Lower custom block to MIR.

        Custom blocks are lowered by calling a runtime handler function
        that processes the block value and returns a result.
        """
        # Create a local to hold the block kind as a constant
        # Strings in MIR are lowered as (ptr, len) tuples
        val str_type = MirType(kind: MirTypeKind.Tuple([
            MirType(kind: mirtypekind_Ptr(MirType(kind: MirTypeKind.U8), false)),
            MirType(kind: MirTypeKind.U64)
        ]))
        val kind_dest = self.builder_new_temp(builder, str_type)
        self.builder_emit_const(builder, kind_dest, MirConstValue.Str(kind), str_type)
        val kind_local = kind_dest

        # Emit call to runtime block handler
        # rt_eval_block(kind: text, value: BlockValue) -> Any
        val result = self.builder_new_temp(builder, MirType.i64())

        # For now, blocks that produce values just return unit
        # The actual evaluation happens at runtime via the interpreter
        # This is a placeholder for when we add full codegen support
        result


fn mirlowering_lower_loss_block(self: MirLowering, body: HirBlock) -> LocalId:
        """Lower loss block to MIR.

        Loss blocks:
        1. Enable gradient tracking
        2. Evaluate the body
        3. Call backward() on the result
        4. Restore gradient tracking state
        """
        # Emit call to enable autograd
        # rt_autograd_push(enabled: bool)
        val _push_result = self.builder_new_temp(builder, MirType.unit())

        # Lower the body
        val body_result = self.lower_block(body)

        # Emit call to backward
        # rt_backward(value: Tensor)
        if has_body_result:
            pass  # Would emit: rt_backward(body_result_value)

        # Emit call to restore autograd state
        # rt_autograd_pop()
        val _pop_result = self.builder_new_temp(builder, MirType.unit())

        body_result ?? self.builder_new_temp(builder, MirType.unit())


fn mirlowering_lower_nograd_block(self: MirLowering, body: HirBlock) -> LocalId:
        """Lower nograd block to MIR.

        Nograd blocks:
        1. Disable gradient tracking
        2. Evaluate the body
        3. Restore gradient tracking state
        """
        # Emit call to disable autograd
        # rt_autograd_push(enabled: false)
        val _push_result = self.builder_new_temp(builder, MirType.unit())

        # Lower the body
        val body_result = self.lower_block(body)

        # Emit call to restore autograd state
        # rt_autograd_pop()
        val _pop_result = self.builder_new_temp(builder, MirType.unit())

        body_result ?? self.builder_new_temp(builder, MirType.unit())


fn mirlowering_lower_await(self: MirLowering, future_expr: HirExpr) -> LocalId:
        """Lower await expression to MIR.

        await expr:
        1. Lower the future/promise expression
        2. Emit Await instruction that suspends until promise resolves
        3. Return the resolved value
        """
        # Lower the future expression to get a Promise<T>
        val promise_local = self.lower_expr(future_expr)

        # Create destination for the awaited result
        # The result type should be the inner type of Promise<T>
        # For now, use i64 as placeholder (proper type inference in future)
        val result_type = mirtype_i64()
        val dest = self.builder_new_temp(builder, result_type)

        # Emit Await instruction
        self.builder.emit(MirInst(
            kind: mirinstkind_Await(dest: dest, promise: mir_operand_copy(promise_local)),
            has_span: false,  # DESUGARED: span: nil
        ))

        dest


fn mirlowering_lower_yield(self: MirLowering, value: HirExpr?) -> LocalId:
        """Lower yield expression to MIR.

        yield expr:
        1. Lower the optional value expression
        2. Emit Yield instruction that suspends the generator
        3. Return unit (yield is a statement-like expression)
        """
        # Lower the optional value
        val value_operand = if has_value:
            val value_local = self.lower_expr(value_value)
            has_field = true, field_value = mir_operand_copy(value_local)
        else:
            nil

        # Emit Yield instruction
        self.builder.emit(MirInst(
            kind: mirinstkind_Yield(value: value_operand),
            span: nil
        ))

        # Yield returns unit
        self.builder_new_temp(builder, MirType.unit())


fn mirlowering_lower_spawn(self: MirLowering, handler: HirExpr, args: [HirExpr]) -> LocalId:
        """Lower spawn expression to MIR.

        spawn handler(args):
        1. Lower the handler expression (async function)
        2. Lower all argument expressions
        3. Emit Spawn instruction
        4. Return the spawned task/actor handle
        """
        # Lower handler
        val handler_local = self.lower_expr(handler)

        # Lower arguments
        var arg_operands: [MirOperand] = []
        for arg in args:
            val arg_local = self.lower_expr(arg)
            arg_operands = arg_operands_push(arg_operands, mir_operand_copy(arg_local))

        # Create destination for the task handle
        val dest = self.builder_new_temp(builder, MirType.i64())  # Task handle type

        # Emit Spawn instruction
        self.builder.emit(MirInst(
            kind: mirinstkind_Spawn(dest: dest, handler: mir_operand_copy(handler_local), args: arg_operands),
            span: nil
        ))

        dest


fn mirlowering_lower_send(self: MirLowering, target_expr: HirExpr, message: HirExpr) -> LocalId:
        """Lower send expression to MIR.

        target <- message:
        1. Lower the target expression
        2. Lower the message expression
        3. Emit Send instruction
        4. Return unit
        """
        # Lower target and message
        val target_local = self.lower_expr(target_expr)
        val message_local = self.lower_expr(message)

        # Emit Send instruction
        self.builder.emit(MirInst(
            kind: mirinstkind_Send(target: mir_operand_copy(target_local), message: mir_operand_copy(message_local)),
            span: nil
        ))

        # Send returns unit
        self.builder_new_temp(builder, MirType.unit())


fn mirlowering_lower_receive(self: MirLowering, timeout: HirExpr?) -> LocalId:
        """Lower receive expression to MIR.

        receive or receive(timeout):
        1. Lower optional timeout expression
        2. Emit Receive instruction
        3. Return the received message
        """
        # Lower optional timeout
        val timeout_operand = if has_timeout:
            val timeout_local = self.lower_expr(timeout_value)
            has_field = true, field_value = mir_operand_copy(timeout_local)
        else:
            nil

        # Create destination for received message
        val dest = self.builder_new_temp(builder, MirType.i64())  # Message type

        # Emit Receive instruction
        self.builder.emit(MirInst(
            kind: mirinstkind_Receive(dest: dest, timeout: timeout_operand),
            span: nil
        ))

        dest


fn mirlowering_lower_range(self: MirLowering, start: HirExpr?, end: HirExpr?, inclusive: bool, step: HirExpr?) -> LocalId:
        """Lower range expression to runtime call.

        Generates call to rt_range(start, end) or rt_range_inclusive(start, end).
        Step parameter is currently ignored (TODO: support step in runtime).
        """
        # Lower start and end to locals
        val start_local = if has_start: self.lower_expr(start_value) else: self.builder_emit_const_int(builder, 0)
        val end_local = if has_end: self.lower_expr(end_value) else: self.builder_emit_const_int(builder, 0)

        # Create function operand for rt_range or rt_range_inclusive
        val func_operand = MirOperand(kind: MirOperandKind.Const(
            mirconstvalue_Int(0),  # Function symbol (will be resolved in codegen)
            MirType(kind: mirtypekind_FuncPtr(MirSignature(params: [], return_type: MirType.i64(), is_variadic: false)))
        ))

        # Emit call: rt_range(start, end) or rt_range_inclusive(start, end)
        val result = self.builder.emit_call(func_operand, [
            mir_operand_copy(start_local),
            mir_operand_copy(end_local)
        ], mirtype_i64())

        result ?? self.builder_new_temp(builder, MirType.i64())


fn mirlowering_lower_inline_asm(self: MirLowering, asm: HirAsm) -> LocalId:
        """Lower inline assembly from HIR to MIR.

        Converts HIR inline assembly constraints to MIR operands.
        """
        # Lower all constraint value expressions to MIR operands
        var inputs: [MirAsmOperand] = []
        var outputs: [MirAsmOperand] = []

        for constraint in asm.constraints:
            # Lower the HIR expression to a local
            val value_local = self.lower_expr(constraint.value)
            val mir_operand = mir_operand_copy(value_local)

            val asm_operand = MirAsmOperand(
                name: constraint.name,
                kind: constraint.kind,
                location: constraint.location,
                operand: mir_operand
            )

            # Categorize as input or output
            match constraint.kind:
                case In:
                    inputs_push(inputs, asm_operand)
                case Out | LateOut:
                    outputs_push(outputs, asm_operand)
                case InOut:
                    # InOut constraints appear in both lists
                    inputs_push(inputs, asm_operand)
                    outputs_push(outputs, asm_operand)

        # Emit inline assembly instruction
        self.builder.emit(MirInst(
            kind: MirInstKind.InlineAsm(
                asm_template: asm.asm_template,
                is_volatile: asm.is_volatile,
                inputs: inputs,
                outputs: outputs,
                clobbers: asm.clobbers
            ),
            # DESUGARED: span: Some(asm.span)
            has_span: true,
            span_value: asm.span
        ))

        # Return a unit value (inline asm doesn't produce a value directly)
        self.builder_new_temp(builder, MirType.unit())


# ============================================================================
# Exports
# ============================================================================

export MirLowering, MirError
