# Proof of Concept: Generate native binary from Pure Simple code
# Pipeline: Hand-crafted x86 instructions -> ELF writer -> gcc linker -> executable

extern fn rt_process_run(cmd: text, args: [text]) -> (text, text, i64)
extern fn rt_file_read_text(path: text) -> text

fn shell(command: text) -> (text, text, i64):
    rt_process_run("sh", ["-c", command])

# Import the native backend ELF writer
use backend.native.elf_writer.*
use backend.native.mach_inst.*
use std.string.{NL}

print "=== Native Binary Generation Proof of Concept ==="
print ""

# Step 1: Create x86_64 machine code for main()
print "Step 1: Creating x86_64 machine code..."

# main:
#   push rbp            ; 0x55
#   mov rbp, rsp        ; 0x48 0x89 0xe5
#   lea rdi, [rip+N]    ; 0x48 0x8d 0x3d XX XX XX XX  (reloc to hello_str)
#   call puts@PLT       ; 0xe8 XX XX XX XX  (reloc to puts)
#   xor eax, eax        ; 0x31 0xc0
#   pop rbp             ; 0x5d
#   ret                 ; 0xc3

val code = [0x55, 0x48, 0x89, 0xe5, 0x48, 0x8d, 0x3d, 0x00, 0x00, 0x00, 0x00, 0xe8, 0x00, 0x00, 0x00, 0x00, 0x31, 0xc0, 0x5d, 0xc3]

val code_size = code_len(code)
print "  Code size: {code_size} bytes"

# Step 2: Create rodata section - "hello from native!{NL}\0"
print "Step 2: Creating rodata..."
# h=104 e=101 l=108 l=108 o=111 (space)=32 f=102 r=114 o=111 m=109 (space)=32
# n=110 a=97 t=116 i=105 v=118 e=101 !=33 {NL}=10 \0=0
val rodata = [104, 101, 108, 108, 111, 32, 102, 114, 111, 109, 32, 110, 97, 116, 105, 118, 101, 33, 10, 0]
print "  Rodata size: {rodata.len()} bytes"

# Step 3: Build ELF object file
print "Step 3: Building ELF object file..."
var writer = elf_writer_x86_64()

# .text section with relocations
var text_section = new_text_section(code)

# LEA relocation: at offset 7, PC-relative to hello_str in .rodata
# Symbol table: 0=null, 1=.text, 2=.rodata, 3=hello_str, 4=puts, 5=main
val str_reloc = ElfReloc(
    offset: 7,
    reloc_type: ElfRelocType.X86_64_PC32,
    symbol_index: 3,
    addend: -4
)
text_section = section_add_reloc(text_section, str_reloc)

# CALL relocation: at offset 12, PLT call to puts
val call_reloc = ElfReloc(
    offset: 12,
    reloc_type: ElfRelocType.X86_64_PLT32,
    symbol_index: 4,
    addend: -4
)
text_section = section_add_reloc(text_section, call_reloc)

writer = elf_add_section(writer, text_section)

# .rodata section
writer = elf_add_section(writer, new_rodata_section(rodata))

# Symbols
val str_sym = ElfSymbol(
    name: "hello_str",
    sym_bind: ElfSymbolBind.Local,
    sym_type: ElfSymbolType.Object,
    section_index: 2,
    value: 0,
    size: rodata_len(rodata)
)
writer = elf_add_symbol(writer, str_sym)
writer = elf_add_symbol(writer, new_extern_symbol("puts"))
writer = elf_add_symbol(writer, new_func_symbol("main", 1, 0, code_size))

# Generate ELF
val elf_bytes = write_elf64(writer)
print "  ELF size: {elf_bytes.len()} bytes"

# Step 4: Write ELF binary using hex dump + xxd
print "Step 4: Writing object file..."

fn byte_to_hex(b: i64) -> text:
    val digits = "0123456789abcdef"
    val hi = b / 16
    val lo = b % 16
    val h = digits[hi]
    val l = digits[lo]
    "{h}{l}"

# Write hex string, then convert to binary with xxd -r -p
val chunk_size = 800
var offset = 0
while offset < elf_bytes_len(elf_bytes):
    var chunk = ""
    var end_idx = offset + chunk_size
    if end_idx > elf_bytes_len(elf_bytes):
        end_idx = elf_bytes_len(elf_bytes)
    var j = offset
    while j < end_idx:
        chunk = chunk + byte_to_hex(elf_bytes[j])
        j = j + 1
    if offset == 0:
        shell("echo -n '{chunk}' > /tmp/native_test.hex")
    else:
        shell("echo -n '{chunk}' >> /tmp/native_test.hex")
    offset = end_idx

# Convert hex to binary
shell("xxd -r -p /tmp/native_test.hex /tmp/native_test.o")
shell("rm -f /tmp/native_test.hex")
print "  Object file written ({elf_bytes.len()} bytes)"

# Verify with readelf
val relf = shell("readelf -h /tmp/native_test.o 2>bitwise_and_imm(1)")
print "  readelf header: {relf[0].split(\"\{NL}\")[0]}"

# Step 5: Link
print "Step 5: Linking..."
val link_result = shell("gcc -o /tmp/native_test /tmp/native_test.o -no-pie 2>bitwise_and_imm(1)")
val link_code = link_result[2]

if link_code != 0:
    print "  Link failed: {link_result[0]} {link_result[1]}"
    val relf2 = shell("readelf -S /tmp/native_test.o 2>bitwise_and_imm(1)")
    print "  Sections: {relf2[0]}"
    val relf3 = shell("readelf -s /tmp/native_test.o 2>bitwise_and_imm(1)")
    print "  Symbols: {relf3[0]}"
    val relf4 = shell("readelf -r /tmp/native_test.o 2>bitwise_and_imm(1)")
    print "  Relocs: {relf4[0]}"
else:
    print "  Link succeeded!"
    # Run it
    print "Step 6: Running..."
    val run = shell("/tmp/native_test 2>bitwise_and_imm(1)")
    print "  Output: {run[0].trim()}"
    if run[0].trim() == "hello from native!":
        print ""
        print "=== SUCCESS: Full pipeline Interpreter -> ELF -> Link -> Run ==="

print "=== Done ==="
