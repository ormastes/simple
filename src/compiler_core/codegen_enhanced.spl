# Enhanced Codegen - Intelligence in Simple Layer
#
# Full codegen logic implemented in Simple, using FFI as thin translation layer.
# This module adds:
# - Type analysis and tracking
# - Constant folding and propagation
# - Dead code elimination
# - Instruction validation
# - Better error messages
#
# Architecture:
#   MIR -> Optimization (Simple) -> Validation (Simple) -> FFI (thin IR emit)

use mir_data.*
use hir.SymbolId
use lexer.Span

export CodegenEnhanced, CodegenStats, OptimizationPass

# ============================================================================
# Enhanced Codegen State
# ============================================================================

class CodegenEnhanced:
    """
    Enhanced code generator with optimization in Simple.

    FFI layer is used ONLY for IR emission - all logic here.
    """
    # Cranelift state (from FFI)
    module_handle: i64
    current_ctx: i64

    # Simple-side intelligence
    type_map: {i64: MirType}          # LocalId -> inferred type
    const_map: {i64: MirConstValue}   # LocalId -> known constant
    use_count: {i64: i64}             # LocalId -> number of uses
    dead_locals: [i64]                # Dead code locals

    # Value tracking (FFI handles)
    local_values: {i64: i64}          # LocalId -> Cranelift value
    block_map: {i64: i64}             # BlockId -> Cranelift block
    function_map: {text: i64}         # name -> function id
    symbol_map: {i64: text}           # SymbolId -> function name

    # Optimization state
    optimizations_enabled: bool
    opt_stats: CodegenStats

    # Error tracking
    errors: [CodegenError]

struct CodegenStats:
    """Statistics from optimization passes."""
    constants_folded: i64
    dead_code_removed: i64
    instructions_simplified: i64
    type_casts_eliminated: i64

struct CodegenError:
    """Enhanced error with context."""
    message: text
    # # DESUGARED: instruction: text
    has_instruction: bool
    instruction: text
    # # DESUGARED: local_id: i64
    has_local_id: bool
    local_id: i64
    # # DESUGARED: span: Span
    has_span: bool
    span: Span


# ============================================================================
# CodegenEnhanced Methods (was: impl CodegenEnhanced:)
# ============================================================================

fn codegenenhanced_create(enable_opts: bool) -> CodegenEnhanced:
        """Create enhanced codegen with optimization control."""
        CodegenEnhanced(
            module_handle: 0,
            current_ctx: 0,
            type_map: {},
            const_map: {},
            use_count: {},
            dead_locals: [],
            local_values: {},
            block_map: {},
            function_map: {},
            symbol_map: {},
            optimizations_enabled: enable_opts,
            opt_stats: CodegenStats(
                constants_folded: 0,
                dead_code_removed: 0,
                instructions_simplified: 0,
                type_casts_eliminated: 0
            ),
            errors: []
        )


fn codegenenhanced_emit_const_ffi(self: CodegenEnhanced, value: MirConstValue, type_: MirType) -> i64:
        """Emit constant via FFI - THIN WRAPPER."""
        match value:
            case Int(v):
                val cl_type = self.mir_type_to_cl(type_)
                cranelift_iconst(self.current_ctx, cl_type, v)
            case Float(v):
                val cl_type = self.mir_type_to_cl(type_)
                cranelift_fconst(self.current_ctx, cl_type, v)
            case Bool(v):
                cranelift_bconst(self.current_ctx, v)
            case _:
                cranelift_iconst(self.current_ctx, CL_TYPE_I64, 0)


fn codegenenhanced_emit_binop_ffi(self: CodegenEnhanced, op: MirBinOp, left: i64, right: i64) -> i64:
        """Emit binop via FFI - THIN WRAPPER."""
        match op:
            case Add: cranelift_iadd(self.current_ctx, left, right)
            case Sub: cranelift_isub(self.current_ctx, left, right)
            case Mul: cranelift_imul(self.current_ctx, left, right)
            case Div: cranelift_sdiv(self.current_ctx, left, right)
            case Rem: cranelift_srem(self.current_ctx, left, right)
            case BitAnd: cranelift_band(self.current_ctx, left, right)
            case BitOr: cranelift_bor(self.current_ctx, left, right)
            case BitXor: cranelift_bxor(self.current_ctx, left, right)
            case Shl: cranelift_ishl(self.current_ctx, left, right)
            case Shr: cranelift_sshr(self.current_ctx, left, right)
            case Eq: cranelift_icmp(self.current_ctx, CL_CMP_EQ, left, right)
            case Ne: cranelift_icmp(self.current_ctx, CL_CMP_NE, left, right)
            case Lt: cranelift_icmp(self.current_ctx, CL_CMP_SLT, left, right)
            case Le: cranelift_icmp(self.current_ctx, CL_CMP_SLE, left, right)
            case Gt: cranelift_icmp(self.current_ctx, CL_CMP_SGT, left, right)
            case Ge: cranelift_icmp(self.current_ctx, CL_CMP_SGE, left, right)
            case _: 0


fn codegenenhanced_emit_unaryop_ffi(self: CodegenEnhanced, op: MirUnaryOp, operand: i64) -> i64:
        """Emit unaryop via FFI - THIN WRAPPER."""
        match op:
            case Neg:
                val zero = cranelift_iconst(self.current_ctx, CL_TYPE_I64, 0)
                cranelift_isub(self.current_ctx, zero, operand)
            case Not:
                val one = cranelift_iconst(self.current_ctx, CL_TYPE_I64, 1)
                cranelift_bxor(self.current_ctx, operand, one)
            case BitNot:
                cranelift_bnot(self.current_ctx, operand)
            case _:
                0


fn codegenenhanced_emit_cast_ffi(self: CodegenEnhanced, value: i64, target: MirType) -> i64:
        """Emit cast via FFI - THIN WRAPPER."""
        val cl_target = self.mir_type_to_cl(target)
        cranelift_bitcast(self.current_ctx, cl_target, value)


fn codegenenhanced_compile_operand_ffi(self: CodegenEnhanced, operand: MirOperand) -> i64:
        """Compile operand via FFI - THIN WRAPPER."""
        # Stub: Pattern matching with data extraction not supported in seed_cpp
        0


# ============================================================================
# Optimization Pass Enumeration
# ============================================================================

enum OptimizationPass:
    """Available optimization passes."""
    ConstantFolding
    DeadCodeElimination
    TypeCastElimination
    InstructionSimplification

# ============================================================================
# Constants (Cranelift Type IDs)
# ============================================================================

val CL_TYPE_I8: i64 = 1
val CL_TYPE_I16: i64 = 2
val CL_TYPE_I32: i64 = 3
val CL_TYPE_I64: i64 = 4
val CL_TYPE_F32: i64 = 5
val CL_TYPE_F64: i64 = 6
val CL_TYPE_B1: i64 = 7
val CL_TYPE_PTR: i64 = 8

val CL_CMP_EQ: i64 = 0
val CL_CMP_NE: i64 = 1
val CL_CMP_SLT: i64 = 2
val CL_CMP_SLE: i64 = 3
val CL_CMP_SGT: i64 = 4
val CL_CMP_SGE: i64 = 5

# ============================================================================
# FFI Declarations (Thin Layer)
# ============================================================================

extern fn cranelift_iconst(ctx: i64, type_: i64, value: i64) -> i64
extern fn cranelift_fconst(ctx: i64, type_: i64, value: f64) -> i64
extern fn cranelift_bconst(ctx: i64, value: bool) -> i64

extern fn cranelift_iadd(ctx: i64, left: i64, right: i64) -> i64
extern fn cranelift_isub(ctx: i64, left: i64, right: i64) -> i64
extern fn cranelift_imul(ctx: i64, left: i64, right: i64) -> i64
extern fn cranelift_sdiv(ctx: i64, left: i64, right: i64) -> i64
extern fn cranelift_srem(ctx: i64, left: i64, right: i64) -> i64

extern fn cranelift_band(ctx: i64, left: i64, right: i64) -> i64
extern fn cranelift_bor(ctx: i64, left: i64, right: i64) -> i64
extern fn cranelift_bxor(ctx: i64, left: i64, right: i64) -> i64
extern fn cranelift_bnot(ctx: i64, value: i64) -> i64

extern fn cranelift_ishl(ctx: i64, left: i64, right: i64) -> i64
extern fn cranelift_sshr(ctx: i64, left: i64, right: i64) -> i64

extern fn cranelift_icmp(ctx: i64, cond: i64, left: i64, right: i64) -> i64
extern fn cranelift_bitcast(ctx: i64, target_type: i64, value: i64) -> i64
