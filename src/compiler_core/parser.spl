# Parser - Simple Language Parser
#
# Parses Simple source code into an Abstract Syntax Tree (AST).
# Uses tree-sitter for outline parsing, then detailed token-based parsing.
#
# AST type definitions are in parser_types.spl

use lexer.*
use treesitter.*
use blocks.*
use parser_types.*


# ============================================================================
# Parser Methods (was: impl Parser:)
# ============================================================================

fn parser_new(source: text) -> Parser:
        var p = Parser(
            source: source,
            lexer: lexer_new(source),
            current: token_eof(0, 1),
            previous: token_eof(0, 1),
            errors: [],
            outline: nil,
            resolved_blocks: nil
        )
        p_advance(p)
        p


fn parser_with_resolved_blocks(source: text, resolved: ResolvedModule) -> Parser:
        """Create parser with pre-resolved blocks."""
        var p = Parser(
            source: source,
            lexer: lexer_new(source),
            current: token_eof(0, 1),
            previous: token_eof(0, 1),
            errors: [],
            # # DESUGARED: outline: Some(resolved.outline)
            outline: resolved.outline,
            # # DESUGARED: resolved_blocks: Some(resolved)
            resolved_blocks: resolved
        )
        p_advance(p)
        p


fn parser_parse(self: Parser) -> Module:
        """Parse source into a full Module."""
        # Pass 1: Get outline (reuse from resolved_blocks if available)
        if not self.has_outline:
            val ts = treesitter_new(self.source)
            self.outline = ts_parse_outline(ts)

        # Pass 2: Fill in bodies
        self.parse_full()


fn parser_parse_full(self: Parser) -> Module:
        """Parse full module using outline."""
        val outline = self.outline_value

        var module = Module(
            name: outline.name,
            imports: [],
            exports: [],
            functions: {},
            classes: {},
            actors: {},
            structs: {},
            enums: {},
            bitfields: {},
            traits: {},
            impls: [],
            type_aliases: {},
            constants: {},
            static_asserts: []
        )

        # Convert imports
        for imp in outline.imports:
            module.imports = module.imports_push(imports, self.convert_import(imp))

        # Convert exports
        for exp in outline.exports:
            module.exports = module.exports.push(Export(
                items: exp.items,
                span: exp.span
            ))

        # Parse function bodies
        var fn_idx = 0
        while fn_idx < outline.functions_len(functions):
            val fn_outline = outline.functions[fn_idx]
            val fn_ = self.parse_function_body(fn_outline)
            var fns = module.functions
            fns[fn_.name] = fn_
            module.functions = fns
            fn_idx = fn_idx + 1

        # Parse class bodies
        for class_outline in outline.classes:
            val class_ = self.parse_class_body(class_outline)
            module.classes[class_.name] = class_

        # Parse actor bodies (guard against nil from TreeSitter)
        if outline.has_actors:
            for actor_outline in outline.actors:
                val actor_decl = self.parse_actor_body(actor_outline)
                module.actors[actor_decl.name] = actor_decl

        # Parse struct bodies
        for struct_outline in outline.structs:
            val struct_ = self.convert_struct(struct_outline)
            module.structs[struct_.name] = struct_

        # Parse enum bodies
        for enum_outline in outline.enums:
            val enum_ = self.convert_enum(enum_outline)
            module.enums[enum_.name] = enum_

        # Convert bitfields
        for bf_outline in outline.bitfields:
            val bf = self.convert_bitfield(bf_outline)
            module.bitfields[bf.name] = bf

        # Parse trait bodies
        for trait_outline in outline.traits:
            val trait_ = self.parse_trait_body(trait_outline)
            module.traits[trait_.name] = trait_

        # Parse impl bodies
        for impl_outline in outline.impls:
            val impl_ = self.parse_impl_body(impl_outline)
            module.impls = module.impls_push(impls, impl_)

        # Convert type aliases
        for alias_outline in outline.type_aliases:
            val alias = self.convert_type_alias(alias_outline)
            module.type_aliases[alias.name] = alias

        # Parse constant values
        for const_outline in outline.constants:
            val const_ = self.parse_const_body(const_outline)
            module.constants[const_.name] = const_

        # Parse static assertions
        for assert_outline in outline.static_asserts:
            val assert_ = self.parse_static_assert_body(assert_outline)
            module.static_asserts = module.static_asserts_push(static_asserts, assert_)

        module


fn parser_advance(self: Parser) -> Token:
        self.previous = self.current
        # Copy-modify-reassign: nested field mutations don't propagate in interpreter
        var lexer = self.lexer
        self.current = lexer_next_token(lexer)
        self.lexer = lexer
        self.previous


fn parser_peek(self: Parser) -> TokenKind:
        self.current.kind


fn parser_check(self: Parser, kind: TokenKind) -> bool:
        self.current.kind == kind


fn parser_match_token(self: Parser, kind: TokenKind) -> bool:
        if self.check(kind):
            self.advance()
            true
        else:
            false


fn parser_expect(self: Parser, kind: TokenKind, message: text) -> bool:
        if self.check(kind):
            self.advance()
            true
        else:
            self.error(message)
            false


fn parser_is_at_end(self: Parser) -> bool:
        # Handle nil token as end of input
        if not self.current.has_kind:
            return true
        self.current.kind == TokenKind.Eof


fn parser_convert_attribute(self: Parser, outline: AttributeOutline) -> Attribute:
        """Convert attribute outline to full attribute AST.

        Parses the args_span if present to extract attribute arguments.
        """
        var args: [Expr] = []
        if outline.has_args_span:
            args = self.parse_attr_args_at_span(outline.args_span_value)

        Attribute(
            name: outline.name,
            args: args,
            span: outline.span
        )


fn parser_convert_import(self: Parser, outline: ImportOutline) -> Import:
        var items: [ImportItem] = []
        for item in outline.items:
            items = items_push(items, ImportItem(name: item, alias: nil))

        # Warn if "/" is used in import path (should use "." or relative paths)
        if outline.module.contains("/"):
            val suggestion = outline.module.replace("/", ".")
            self.warning(
                "Import path should not use '.' - use '.' for module paths or './' for relative paths (suggestion: use {suggestion})",
                outline.span
            )

        Import(
            module: outline.module,
            items: items,
            span: outline.span
        )


fn parser_convert_type(self: Parser, outline: TypeOutline) -> Type:
        val kind = match outline.kind:
            case Named(name, args):
                typekind_Named(name, self.convert_type_list(args))
            case Tuple(elements):
                typekind_Tuple(self.convert_type_list(elements))
            case Array(element):
                typekind_Array(self.convert_type(element), nil)
            case Function(params, ret):
                typekind_Function(self.convert_type_list(params), self.convert_type(ret))
            case Optional(inner):
                typekind_Optional(self.convert_type(inner))
            case Reference(inner, mutable):
                typekind_Reference(self.convert_type(inner), mutable)
            case Atomic(inner):
                typekind_Atomic(self.convert_type(inner))
            case Isolated(inner):
                typekind_Isolated(self.convert_type(inner))
            case Infer:
                TypeKind.Infer

        Type(kind: kind, span: outline.span)


fn parser_convert_type_param(self: Parser, outline: TypeParamOutline) -> TypeParam:
        var bounds: [Type] = []
        for b in outline.bounds:
            bounds = bounds_push(bounds, self.convert_type(b))

        TypeParam(
            name: outline.name,
            bounds: bounds,
            default: outline.default_map(default, \t: self.convert_type(t)),
            span: outline.span
        )


fn parser_convert_param(self: Parser, outline: ParamOutline) -> Param:
        var default_expr: Expr = nil
        if outline.has_default_span:
            default_expr = self.parse_expr_at_span(outline.default_span_value)

        val type_result = outline.type__map(type_, \t: self.convert_type(t))
        Param(
            name: outline.name,
            type_: type_result,
            default: default_expr,
            span: outline.span
        )


fn parser_convert_field(self: Parser, outline: FieldOutline) -> Field:
        var default_expr: Expr = nil
        if outline.has_default_span:
            default_expr = self.parse_expr_at_span(outline.default_span_value)

        # Parse fixed address if present
        var fixed_address: i64 = nil
        if outline.has_address_span:
            val addr_expr = self.parse_expr_at_span(outline.address_span_value)
            fixed_address = self.extract_address(addr_expr)

        Field(
            name: outline.name,
            type_: self.convert_type(outline.type_),
            default: default_expr,
            is_public: outline.is_public,
            is_volatile: outline.is_volatile,
            fixed_address: fixed_address,
            span: outline.span
        )


fn parser_convert_struct(self: Parser, outline: StructOutline) -> Struct:
        var type_params: [TypeParam] = []
        for tp in outline.type_params:
            type_params = type_params_push(type_params, self.convert_type_param(tp))

        var fields: [Field] = []
        for f in outline.fields:
            fields = fields_push(fields, self.convert_field(f))

        Struct(
            name: outline.name,
            type_params: type_params,
            fields: fields,
            is_public: outline.is_public,
            doc_comment: outline.doc_comment,
            attributes: self.convert_attributes(outline.attributes),
            span: outline.span
        )


fn parser_convert_enum(self: Parser, outline: EnumOutline) -> Enum:
        var type_params: [TypeParam] = []
        for tp in outline.type_params:
            type_params = type_params_push(type_params, self.convert_type_param(tp))

        var variants: [Variant] = []
        for v in outline.variants:
            val kind = match v.payload:
                case nil:
                    VariantKind.Unit
                case Tuple(types):
                    variantkind_Tuple(self.convert_type_list(types))
                case Struct(fields):
                    variantkind_Struct(self.convert_field_list(fields))

            variants = variants.push(Variant(
                name: v.name,
                kind: kind,
                span: v.span
            ))

        Enum(
            name: outline.name,
            type_params: type_params,
            variants: variants,
            is_public: outline.is_public,
            doc_comment: outline.doc_comment,
            span: outline.span
        )


fn parser_convert_type_alias(self: Parser, outline: TypeAliasOutline) -> TypeAlias:
        var type_params: [TypeParam] = []
        for tp in outline.type_params:
            type_params = type_params_push(type_params, self.convert_type_param(tp))

        TypeAlias(
            name: outline.name,
            type_params: type_params,
            type_: self.convert_type(outline.type_),
            is_public: outline.is_public,
            span: outline.span
        )


fn parser_convert_bitfield(self: Parser, outline: BitfieldOutline) -> Bitfield:
        """Convert bitfield outline to bitfield AST."""
        var fields: [BitfieldField] = []
        for f in outline.fields:
            fields = fields_push(fields, self.convert_bitfield_field(f))

        Bitfield(
            name: outline.name,
            backing_type: self.convert_type(outline.backing_type),
            fields: fields,
            is_public: outline.is_public,
            doc_comment: outline.doc_comment,
            attributes: self.convert_attributes(outline.attributes),
            span: outline.span
        )


fn parser_convert_bitfield_field(self: Parser, outline: BitfieldFieldOutline) -> BitfieldField:
        """Convert bitfield field outline to AST."""
        BitfieldField(
            name: outline.name,
            type_: outline.type__map(type_, \t: self.convert_type(t)),
            bits: outline.bits,
            is_reserved: outline.is_reserved,
            span: outline.span
        )


fn parser_parse_function_body(self: Parser, outline: FunctionOutline) -> Function:
        """Parse function body from outline."""
        var type_params: [TypeParam] = []

        var params: [Param] = []
        var pi = 0
        while pi < outline.params_len(params):
            val p = outline.params[pi]
            params = params_push(params, self.convert_param(p))
            pi = pi + 1

        var body = Block(stmts: [], span: outline.body_span)
        if outline.body_span_len(body_span) > 0:
            body = self.parse_block_at_span(outline.body_span)

        Function(
            name: outline.name,
            type_params: type_params,
            params: params,
            return_type: outline.return_type_map(return_type, \t: self.convert_type(t)),
            body: body,
            is_async: outline.is_async,
            is_static: outline.is_static,
            is_public: outline.is_public,
            is_method: outline.is_method,
            is_mutable: outline.is_mutable,
            is_const: outline.is_const,
            is_kernel: outline.is_kernel,
            is_extern: outline.is_extern,
            doc_comment: outline.doc_comment,
            span: outline.span
        )


fn parser_parse_class_body(self: Parser, outline: ClassOutline) -> Class:
        var type_params: [TypeParam] = []
        for tp in outline.type_params:
            type_params = type_params_push(type_params, self.convert_type_param(tp))

        var fields: [Field] = []
        for f in outline.fields:
            fields = fields_push(fields, self.convert_field(f))

        var methods: Dict<text, Function> = {}
        for m in outline.methods:
            val fn_ = self.parse_function_body(m)
            methods[fn_.name] = fn_

        Class(
            name: outline.name,
            type_params: type_params,
            fields: fields,
            methods: methods,
            is_public: outline.is_public,
            doc_comment: outline.doc_comment,
            attributes: self.convert_attributes(outline.attributes),
            span: outline.span
        )


fn parser_parse_actor_body(self: Parser, outline: ActorOutline) -> ActorDef:
        """Parse actor from outline (same structure as class)."""
        var type_params: [TypeParam] = []
        for tp in outline.type_params:
            type_params = type_params_push(type_params, self.convert_type_param(tp))

        var fields: [Field] = []
        for f in outline.fields:
            fields = fields_push(fields, self.convert_field(f))

        var methods: Dict<text, Function> = {}
        for m in outline.methods:
            val fn_ = self.parse_function_body(m)
            methods[fn_.name] = fn_

        ActorDef(
            name: outline.name,
            type_params: type_params,
            fields: fields,
            methods: methods,
            is_public: outline.is_public,
            doc_comment: outline.doc_comment,
            attributes: self.convert_attributes(outline.attributes),
            span: outline.span
        )


fn parser_parse_trait_body(self: Parser, outline: TraitOutline) -> Trait:
        var type_params: [TypeParam] = []
        for tp in outline.type_params:
            type_params = type_params_push(type_params, self.convert_type_param(tp))

        var methods: [Function] = []
        for m in outline.methods:
            val fn_ = self.parse_function_body(m)
            methods = methods_push(methods, fn_)

        Trait(
            name: outline.name,
            type_params: type_params,
            methods: methods,
            is_public: outline.is_public,
            doc_comment: outline.doc_comment,
            span: outline.span
        )


fn parser_parse_impl_body(self: Parser, outline: ImplOutline) -> Impl:
        var methods: Dict<text, Function> = {}
        for m in outline.methods:
            val fn_ = self.parse_function_body(m)
            methods[fn_.name] = fn_

        Impl(
            type_: self.convert_type(outline.type_),
            trait_: outline.trait__map(trait_, \t: self.convert_type(t)),
            methods: methods,
            span: outline.span
        )


fn parser_parse_const_body(self: Parser, outline: ConstOutline) -> Const:
        val value = self.parse_expr_at_span(outline.value_span)

        # Parse fixed address if present
        var fixed_address: i64 = nil
        if outline.has_address_span:
            val addr_expr = self.parse_expr_at_span(outline.address_span_value)
            fixed_address = self.extract_address(addr_expr)

        Const(
            name: outline.name,
            type_: outline.type__map(type_, \t: self.convert_type(t)),
            value: value,
            is_mutable: outline.is_mutable,
            is_public: outline.is_public,
            is_volatile: outline.is_volatile,
            fixed_address: fixed_address,
            span: outline.span
        )


fn parser_parse_static_assert_body(self: Parser, outline: StaticAssertOutline) -> StaticAssert:
        """Parse a static assertion from its outline."""
        val condition = self.parse_expr_at_span(outline.condition_span)

        StaticAssert(
            condition: condition,
            message: outline.message,
            span: outline.span
        )


fn parser_parse_expr_at_span(self: Parser, span: Span) -> Expr:
        """Parse an expression at a specific span."""
        self.reset_to_span(span)
        self.parse_expr()


fn parser_parse_block_at_span(self: Parser, span: Span) -> Block:
        """Parse a block at a specific span."""
        self.reset_to_span(span)
        self.parse_block()


fn parser_parse_expr(self: Parser) -> Expr:
        """Parse an expression."""
        self.parse_pipeline_expr()


fn parser_parse_pipeline_expr(self: Parser) -> Expr:
        """Parse pipeline expression (|>, ~>).

        Pipeline operators have lowest precedence and are left-associative.
        - |> : Forward pipe, passes left value as first argument to right function
        - ~> : Layer connect, composes neural network layers with dimension checking
        """
        var left = self.parse_parallel_expr()

        while true:
            if self.match_token(TokenKind.PipeForward):
                val right = self.parse_parallel_expr()
                left = Expr(
                    kind: exprkind_Binary(BinOp.PipeForward, left, right),
                    span: left.span_merge(span, right.span)
                )
            elif self.match_token(TokenKind.LayerConnect):
                val right = self.parse_parallel_expr()
                left = Expr(
                    kind: exprkind_Binary(BinOp.LayerConnect, left, right),
                    span: left.span_merge(span, right.span)
                )
            else:
                break

        left


fn parser_parse_parallel_expr(self: Parser) -> Expr:
        """Parse parallel expression (//).

        Parallel operator combines branches for concurrent/parallel execution.
        Left-associative.
        """
        var left = self.parse_composition_expr()

        while self.match_token(TokenKind.Parallel):
            val right = self.parse_composition_expr()
            left = Expr(
                kind: exprkind_Binary(BinOp.Parallel, left, right),
                span: left.span_merge(span, right.span)
            )

        left


fn parser_parse_composition_expr(self: Parser) -> Expr:
        """Parse composition expression (>>, <<).

        Composition operators are right-associative (like Haskell's . operator).
        - >> : Forward compose, bit_shr(f, g) means g(f(x))
        - << : Backward compose, bit_shl(f, g) means f(g(x))
        """
        val left = self.parse_or_expr()

        if self.match_token(TokenKind.Compose):
            val right = self.parse_composition_expr()  # Right-associative
            return Expr(
                kind: exprkind_Binary(BinOp.Compose, left, right),
                span: left.span_merge(span, right.span)
            )

        if self.match_token(TokenKind.ComposeBack):
            val right = self.parse_composition_expr()  # Right-associative
            return Expr(
                kind: exprkind_Binary(BinOp.ComposeBack, left, right),
                span: left.span_merge(span, right.span)
            )

        left


fn parser_parse_or_expr(self: Parser) -> Expr:
        """Parse logical or expression."""
        var left = self.parse_xor_expr()

        while self.match_token(TokenKind.KwOr) or self.match_token(TokenKind.PipePipe):
            val right = self.parse_xor_expr()
            left = Expr(
                kind: exprkind_Binary(BinOp.Or, left, right),
                span: left.span_merge(span, right.span)
            )

        left


fn parser_parse_xor_expr(self: Parser) -> Expr:
        """Parse bitwise xor expression."""
        var left = self.parse_and_expr()

        while self.match_token(TokenKind.KwXor):
            val right = self.parse_and_expr()
            left = Expr(
                kind: exprkind_Binary(BinOp.BitXor, left, right),
                span: left.span_merge(span, right.span)
            )

        left


fn parser_parse_and_expr(self: Parser) -> Expr:
        """Parse logical and expression."""
        var left = self.parse_equality_expr()

        while self.match_token(TokenKind.KwAnd) or self.match_token(TokenKind.AmpAmp):
            val right = self.parse_equality_expr()
            left = Expr(
                kind: exprkind_Binary(BinOp.And, left, right),
                span: left.span_merge(span, right.span)
            )

        left


fn parser_parse_equality_expr(self: Parser) -> Expr:
        """Parse equality expression."""
        var left = self.parse_comparison_expr()

        while true:
            if self.match_token(TokenKind.Eq):
                val right = self.parse_comparison_expr()
                left = Expr(
                    kind: exprkind_Binary(BinOp.Eq, left, right),
                    span: left.span_merge(span, right.span)
                )
            elif self.match_token(TokenKind.NotEq):
                val right = self.parse_comparison_expr()
                left = Expr(
                    kind: exprkind_Binary(BinOp.NotEq, left, right),
                    span: left.span_merge(span, right.span)
                )
            else:
                break

        left


fn parser_parse_comparison_expr(self: Parser) -> Expr:
        """Parse comparison expression."""
        var left = self.parse_range_expr()

        while true:
            if self.match_token(TokenKind.Lt):
                val right = self.parse_range_expr()
                left = Expr(
                    kind: exprkind_Binary(BinOp.Lt, left, right),
                    span: left.span_merge(span, right.span)
                )
            elif self.match_token(TokenKind.LtEq):
                val right = self.parse_range_expr()
                left = Expr(
                    kind: exprkind_Binary(BinOp.LtEq, left, right),
                    span: left.span_merge(span, right.span)
                )
            elif self.match_token(TokenKind.Gt):
                val right = self.parse_range_expr()
                left = Expr(
                    kind: exprkind_Binary(BinOp.Gt, left, right),
                    span: left.span_merge(span, right.span)
                )
            elif self.match_token(TokenKind.GtEq):
                val right = self.parse_range_expr()
                left = Expr(
                    kind: exprkind_Binary(BinOp.GtEq, left, right),
                    span: left.span_merge(span, right.span)
                )
            elif self.match_token(TokenKind.KwIn):
                val right = self.parse_range_expr()
                left = Expr(
                    kind: exprkind_Binary(BinOp.In, left, right),
                    span: left.span_merge(span, right.span)
                )
            elif self.match_token(TokenKind.KwIs):
                val right = self.parse_range_expr()
                left = Expr(
                    kind: exprkind_Binary(BinOp.Is, left, right),
                    span: left.span_merge(span, right.span)
                )
            else:
                break

        left


fn parser_parse_range_expr(self: Parser) -> Expr:
        """Parse range expression."""
        val left = self.parse_additive_expr()

        if self.match_token(TokenKind.DotDot):
            var inclusive = false
            if self.match_token(TokenKind.Assign):  # ..=
                inclusive = true
            val right = self.parse_additive_expr()
            return Expr(
                kind: exprkind_Range(left, right, inclusive, nil),
                span: left.span_merge(span, right.span)
            )

        left


fn parser_parse_additive_expr(self: Parser) -> Expr:
        """Parse additive expression (including broadcast .+ and .-)."""
        var left = self.parse_matmul_expr()

        while true:
            if self.match_token(TokenKind.Plus):
                val right = self.parse_matmul_expr()
                left = Expr(
                    kind: exprkind_Binary(BinOp.Add, left, right),
                    span: left.span_merge(span, right.span)
                )
            elif self.match_token(TokenKind.Minus):
                val right = self.parse_matmul_expr()
                left = Expr(
                    kind: exprkind_Binary(BinOp.Sub, left, right),
                    span: left.span_merge(span, right.span)
                )
            elif self.match_token(TokenKind.DotPlus):
                val right = self.parse_matmul_expr()
                left = Expr(
                    kind: exprkind_Binary(BinOp.BroadcastAdd, left, right),
                    span: left.span_merge(span, right.span)
                )
            elif self.match_token(TokenKind.DotMinus):
                val right = self.parse_matmul_expr()
                left = Expr(
                    kind: exprkind_Binary(BinOp.BroadcastSub, left, right),
                    span: left.span_merge(span, right.span)
                )
            else:
                break

        left


fn parser_parse_matmul_expr(self: Parser) -> Expr:
        """Parse matrix multiplication expression (@)."""
        var left = self.parse_multiplicative_expr()

        while self.match_token(TokenKind.At):
            val right = self.parse_multiplicative_expr()
            left = Expr(
                kind: exprkind_Binary(BinOp.MatMul, left, right),
                span: left.span_merge(span, right.span)
            )

        left


fn parser_parse_multiplicative_expr(self: Parser) -> Expr:
        """Parse multiplicative expression (including broadcast .* and ./)."""
        var left = self.parse_power_expr()

        while true:
            if self.match_token(TokenKind.Star):
                val right = self.parse_power_expr()
                left = Expr(
                    kind: exprkind_Binary(BinOp.Mul, left, right),
                    span: left.span_merge(span, right.span)
                )
            elif self.match_token(TokenKind.Slash):
                val right = self.parse_power_expr()
                left = Expr(
                    kind: exprkind_Binary(BinOp.Div, left, right),
                    span: left.span_merge(span, right.span)
                )
            elif self.match_token(TokenKind.Percent):
                val right = self.parse_power_expr()
                left = Expr(
                    kind: exprkind_Binary(BinOp.Mod, left, right),
                    span: left.span_merge(span, right.span)
                )
            elif self.match_token(TokenKind.DotStar):
                val right = self.parse_power_expr()
                left = Expr(
                    kind: exprkind_Binary(BinOp.BroadcastMul, left, right),
                    span: left.span_merge(span, right.span)
                )
            elif self.match_token(TokenKind.DotSlash):
                val right = self.parse_power_expr()
                left = Expr(
                    kind: exprkind_Binary(BinOp.BroadcastDiv, left, right),
                    span: left.span_merge(span, right.span)
                )
            elif self.match_token(TokenKind.ImplicitMul):
                # Implicit multiplication (m{} only): 2x, 2(x+1), (a)(b)
                val right = self.parse_power_expr()
                left = Expr(
                    kind: exprkind_Binary(BinOp.Mul, left, right),
                    span: left.span_merge(span, right.span)
                )
            else:
                break

        left


fn parser_parse_power_expr(self: Parser) -> Expr:
        """Parse power expression (right-associative, including .^ broadcast)."""
        val left = self.parse_unary_expr()

        if self.match_token(TokenKind.StarStar):
            val right = self.parse_power_expr()  # Right-associative
            return Expr(
                kind: exprkind_Binary(BinOp.Pow, left, right),
                span: left.span_merge(span, right.span)
            )

        if self.match_token(TokenKind.DotCaret):
            val right = self.parse_power_expr()  # Right-associative
            return Expr(
                kind: exprkind_Binary(BinOp.BroadcastPow, left, right),
                span: left.span_merge(span, right.span)
            )

        if self.match_token(TokenKind.Caret):
            val right = self.parse_power_expr()  # Right-associative (inside m{})
            return Expr(
                kind: exprkind_Binary(BinOp.Pow, left, right),
                span: left.span_merge(span, right.span)
            )

        left


fn parser_parse_unary_expr(self: Parser) -> Expr:
        """Parse unary expression."""
        val start = self.current.span

        if self.match_token(TokenKind.Minus):
            val operand = self.parse_unary_expr()
            return Expr(
                kind: exprkind_Unary(UnaryOp.Neg, operand),
                span: start_merge(start, operand.span)
            )

        if self.match_token(TokenKind.KwNot) or self.match_token(TokenKind.Bang):
            val operand = self.parse_unary_expr()
            return Expr(
                kind: exprkind_Unary(UnaryOp.Not, operand),
                span: start_merge(start, operand.span)
            )

        if self.match_token(TokenKind.Tilde):
            val operand = self.parse_unary_expr()
            return Expr(
                kind: exprkind_Unary(UnaryOp.BitNot, operand),
                span: start_merge(start, operand.span)
            )

        if self.match_token(TokenKind.Ampersand):
            val operand = self.parse_unary_expr()
            return Expr(
                kind: exprkind_Unary(UnaryOp.Ref, operand),
                span: start_merge(start, operand.span)
            )

        if self.match_token(TokenKind.KwAwait):
            val operand = self.parse_unary_expr()
            return Expr(
                kind: exprkind_Await(operand),
                span: start_merge(start, operand.span)
            )

        self.parse_postfix_expr()


fn parser_parse_postfix_expr(self: Parser) -> Expr:
        """Parse postfix expression (calls, indexing, field access)."""
        var expr = self.parse_primary_expr()

        while true:
            if self.match_token(TokenKind.TripleLess):
                # Kernel launch: kernel<<<grid, block>>>(args)
                val grid_dim = self.parse_expr()
                self.expect(TokenKind.Comma, "expected ',' between grid and block dimensions")
                val block_dim = self.parse_expr()
                self.expect(TokenKind.TripleGreater, "expected '>>>' after launch config")
                self.expect(TokenKind.LParen, "expected '(' for kernel arguments")
                val args = self.parse_call_args()
                self.expect(TokenKind.RParen, "expected ')' after kernel arguments")
                expr = Expr(
                    kind: exprkind_KernelLaunch(expr, grid_dim, block_dim, args),
                    span: expr.span_merge(span, self.previous.span)
                )
            elif self.match_token(TokenKind.LParen):
                # Function call
                val args = self.parse_call_args()
                self.expect(TokenKind.RParen, "expected ')' after arguments")
                expr = Expr(
                    kind: exprkind_Call(expr, args),
                    span: expr.span_merge(span, self.previous.span)
                )
            elif self.match_token(TokenKind.LBracket):
                # Index
                val index = self.parse_expr()
                self.expect(TokenKind.RBracket, "expected ']' after index")
                expr = Expr(
                    kind: exprkind_Index(expr, index),
                    span: expr.span_merge(span, self.previous.span)
                )
            elif self.match_token(TokenKind.Dot):
                # Field access or method call
                val field = self.parse_identifier()
                if self.match_token(TokenKind.LParen):
                    val args = self.parse_call_args()
                    self.expect(TokenKind.RParen, "expected ')' after arguments")
                    expr = Expr(
                        kind: exprkind_MethodCall(expr, field, args),
                        span: expr.span_merge(span, self.previous.span)
                    )
                else:
                    expr = Expr(
                        kind: exprkind_Field(expr, field),
                        span: expr.span_merge(span, self.previous.span)
                    )
            elif self.match_token(TokenKind.QuestionDot):
                # Optional chaining
                val field = self.parse_identifier()
                expr = Expr(
                    kind: exprkind_OptionalChain(expr, field),
                    span: expr.span_merge(span, self.previous.span)
                )
            elif self.match_token(TokenKind.DotQuestion):
                # Exists check
                expr = Expr(
                    kind: exprkind_ExistsCheck(expr),
                    span: expr.span_merge(span, self.previous.span)
                )
            elif self.match_token(TokenKind.Question):
                # Try operator
                expr = Expr(
                    kind: exprkind_Try(expr),
                    span: expr.span_merge(span, self.previous.span)
                )
            elif self.match_token(TokenKind.QuestionQuestion):
                # Null coalesce - allow return/break/continue as RHS
                if self.check(TokenKind.KwReturn) or self.check(TokenKind.KwBreak) or self.check(TokenKind.KwContinue):
                    val right = self.parse_primary_expr()
                    expr = Expr(
                        kind: exprkind_NullCoalesce(expr, right),
                        span: expr.span_merge(span, right.span)
                    )
                else:
                    val right = self.parse_unary_expr()
                    expr = Expr(
                        kind: exprkind_NullCoalesce(expr, right),
                        span: expr.span_merge(span, right.span)
                    )
            elif self.match_token(TokenKind.Transpose):
                # Postfix transpose (m{} only)
                expr = Expr(
                    kind: exprkind_Unary(UnaryOp.Transpose, expr),
                    span: expr.span_merge(span, self.previous.span)
                )
            else:
                break

        expr


fn parser_parse_primary_expr(self: Parser) -> Expr:
        """Parse primary expression."""
        val start = self.current.span

        match self.peek():
            case IntLit:
                val text = self.current.text
                self.advance()
                val value = parse_int_literal(text)
                Expr(kind: exprkind_IntLit(value), span: start)

            case FloatLit:
                val text = self.current.text
                self.advance()
                val value = parse_float_literal(text)
                Expr(kind: exprkind_FloatLit(value), span: start)

            case StringLit:
                self.parse_string_literal()

            case BoolLit:
                val value = self.current.text == "true"
                self.advance()
                Expr(kind: exprkind_BoolLit(value), span: start)

            case NilLit:
                self.advance()
                Expr(kind: ExprKind.NilLit, span: start)

            case Ident:
                val name = self.current.text
                self.advance()

                # Check for set literal: s{...}
                if name == "s":
                    if self.check(TokenKind.LBrace):
                    self.parse_set_literal_after_s(start)
                else:
                    Expr(kind: exprkind_Ident(name), span: start)

            case LParen:
                self.advance()
                if self.check(TokenKind.RParen):
                    # Unit tuple ()
                    self.advance()
                    Expr(kind: exprkind_TupleLit([]), span: start_merge(start, self.previous.span))
                else:
                    val expr = self.parse_expr()
                    if self.match_token(TokenKind.Comma):
                        # Tuple literal
                        var elements = [expr]
                        if not self.check(TokenKind.RParen):
                            elements = elements_push(elements, self.parse_expr())
                            while self.match_token(TokenKind.Comma):
                                if self.check(TokenKind.RParen):
                                    break
                                elements = elements_push(elements, self.parse_expr())
                        self.expect(TokenKind.RParen, "expected ')' after tuple")
                        Expr(kind: exprkind_TupleLit(elements), span: start_merge(start, self.previous.span))
                    else:
                        # Grouped expression
                        self.expect(TokenKind.RParen, "expected ')'")
                        expr

            case LBracket:
                self.parse_array_or_comprehension()

            case LBrace:
                self.parse_dict_literal()

            case BlockStart:
                # BlockStart could be a block (m{, loss{) or a set literal (s{)
                # Check the text field to distinguish
                if self.current.text == "s":
                    self.parse_set_literal()
                else:
                    # Regular block - handle it (TODO: implement block parsing in expr context)
                    self.error("blocks in expression context not yet supported")
                    Expr(kind: ExprKind.Error, span: self.current.span)

            case Backslash:
                self.parse_lambda()

            case KwIf:
                self.parse_if_expr()

            case KwMatch:
                self.parse_match_expr()

            case KwReturn:
                self.advance()
                var value: Expr = nil
                if not self.check(TokenKind.Newline):
                    if not self.check(TokenKind.Dedent):
                    value = self.parse_expr()
                Expr(kind: exprkind_Return(value), span: start_merge(start, self.previous.span))

            case KwBreak:
                self.advance()
                Expr(kind: exprkind_Break(nil), span: start)

            case KwContinue:
                self.advance()
                Expr(kind: exprkind_Continue(nil), span: start)

            case KwYield:
                self.advance()
                var value: Expr = nil
                if not self.check(TokenKind.Newline):
                    if not self.check(TokenKind.Dedent):
                    value = self.parse_expr()
                Expr(kind: exprkind_Yield(value), span: start_merge(start, self.previous.span))

            case KwAwait:
                self.advance()
                val awaited_expr = self.parse_primary_expr()
                Expr(kind: exprkind_Await(awaited_expr), span: start_merge(start, awaited_expr.span))

            case KwSpawn:
                self.advance()
                val spawned_expr = self.parse_primary_expr()
                Expr(kind: exprkind_Spawn(spawned_expr), span: start_merge(start, spawned_expr.span))

            case KwThrow:
                self.advance()
                val value = self.parse_expr()
                Expr(kind: exprkind_Throw(value), span: start_merge(start, value.span))

            case KwLoss:
                self.parse_loss_block()

            case KwNograd:
                self.parse_nograd_block()

            case KwUnsafe:
                self.parse_unsafe_block()

            case KwAsm:
                self.parse_asm_expr()

            case BlockStart:
                # Custom block (sh{}, sql{}, re{}, etc.)
                val kind = self.current.text
                self.parse_resolved_block(kind)

            case _:
                self.error("expected expression")
                self.advance()
                Expr(kind: ExprKind.Error, span: start)


fn parser_parse_string_literal(self: Parser) -> Expr:
        """Parse string literal with interpolation."""
        val start = self.current.span
        val text = self.current.text
        self.advance()

        # For bootstrap: plain string literals only (no interpolation scanning)
        # TODO: Add interpolation support when needed for self-hosting
        Expr(kind: exprkind_StringLit(text, nil), span: start)


fn parser_parse_array_or_comprehension(self: Parser) -> Expr:
        """Parse array literal or list comprehension.

        Handles suffix notation for tensor types:
        - [1, 2, 3]f32        - f32 array
        - [1, 2, 3]_f32_gpu   - f32 tensor on GPU
        - [1, 2, 3]f32_tr_cuda - trainable f32 tensor on CUDA
        """
        val start = self.current.span
        self.advance()  # Consume '['

        # Check for empty array: [] or []f32
        if self.check(TokenKind.RBracket):
            self.advance()
            return Expr(kind: exprkind_ArrayLit([]), span: start_merge(start, self.previous.span))
        if self.check(TokenKind.ArraySuffix):
            val suffix_text = self.current.text
            self.advance()
            val suffix = tensorsuffix_from_string(suffix_text)
            return Expr(
                kind: exprkind_ArrayLitSuffix([], suffix),
                span: start_merge(start, self.previous.span)
            )

        # Check for comprehension
        if self.check(TokenKind.KwFor):
            return self.parse_list_comprehension(start)

        # Array literal
        var elements: [Expr] = []
        elements = elements_push(elements, self.parse_expr())

        while self.match_token(TokenKind.Comma):
            if self.check(TokenKind.RBracket) or self.check(TokenKind.ArraySuffix):
                break
            elements = elements_push(elements, self.parse_expr())

        # Check for suffix (ArraySuffix token includes the ] and suffix)
        if self.check(TokenKind.ArraySuffix):
            val suffix_text = self.current.text
            self.advance()
            val suffix = tensorsuffix_from_string(suffix_text)
            return Expr(
                kind: exprkind_ArrayLitSuffix(elements, suffix),
                span: start_merge(start, self.previous.span)
            )

        # Regular array, expect RBracket
        self.expect(TokenKind.RBracket, "expected ']' after array elements")
        Expr(kind: exprkind_ArrayLit(elements), span: start_merge(start, self.previous.span))


fn parser_parse_list_comprehension(self: Parser, start: Span) -> Expr:
        """Parse list comprehension [for x in y if cond: expr]."""
        var clauses: [ComprehensionClause] = []

        while self.match_token(TokenKind.KwFor):
            val var_start = self.current.span
            val var_ = self.parse_identifier()
            self.expect(TokenKind.KwIn, "expected 'in' in comprehension")
            val iter = self.parse_expr()
            clauses = clauses.push(ComprehensionClause(
                kind: comprehensionkind_For(var_, iter),
                span: var_start_merge(var_start, iter.span)
            ))

            while self.match_token(TokenKind.KwIf):
                val cond_start = self.previous.span
                val cond = self.parse_expr()
                clauses = clauses.push(ComprehensionClause(
                    kind: comprehensionkind_If(cond),
                    span: cond_start_merge(cond_start, cond.span)
                ))

        self.expect(TokenKind.Colon, "expected ':' in comprehension")
        val expr = self.parse_expr()
        self.expect(TokenKind.RBracket, "expected ']' after comprehension")

        Expr(kind: exprkind_ListComprehension(expr, clauses), span: start_merge(start, self.previous.span))


fn parser_parse_dict_literal(self: Parser) -> Expr:
        """Parse dict literal {key: value, ...}."""
        val start = self.current.span
        self.advance()  # Consume '{'

        if self.check(TokenKind.RBrace):
            self.advance()
            return Expr(kind: exprkind_DictLit([]), span: start_merge(start, self.previous.span))

        var entries: [(Expr, Expr)] = []
        val key = self.parse_expr()
        self.expect(TokenKind.Colon, "expected ':' after dict key")
        val value = self.parse_expr()
        entries = entries_push(entries, (key, value))

        while self.match_token(TokenKind.Comma):
            if self.check(TokenKind.RBrace):
                break
            val k = self.parse_expr()
            self.expect(TokenKind.Colon, "expected ':' after dict key")
            val v = self.parse_expr()
            entries = entries_push(entries, (k, v))

        self.expect(TokenKind.RBrace, "expected '}' after dict entries")
        Expr(kind: exprkind_DictLit(entries), span: start_merge(start, self.previous.span))


fn parser_parse_set_literal(self: Parser) -> Expr:
        """Parse set literal s{elem1, elem2, ...}.

        Called from BlockStart case (for lexer-based approach).
        """
        val start = self.current.span
        self.advance()  # Consume BlockStart token

        # Check for empty set: s{}
        if self.check(TokenKind.RBrace):
            self.advance()
            return Expr(kind: exprkind_SetLit([]), span: start_merge(start, self.previous.span))

        # Parse elements (comma-separated expressions)
        var elements: [Expr] = []
        elements = elements_push(elements, self.parse_expr())

        while self.match_token(TokenKind.Comma):
            if self.check(TokenKind.RBrace):
                break  # Trailing comma
            elements = elements_push(elements, self.parse_expr())

        self.expect(TokenKind.RBrace, "expected '}' after set elements")
        Expr(kind: exprkind_SetLit(elements), span: start_merge(start, self.previous.span))


fn parser_parse_set_literal_after_s(self: Parser, start: Span) -> Expr:
        """Parse set literal after seeing 's' identifier.

        The 's' has been consumed, now we expect {elem1, elem2, ...}
        This is the parser-only approach that works with existing tokens.
        """
        self.advance()  # Consume LBrace

        # Check for empty set: s{}
        if self.check(TokenKind.RBrace):
            self.advance()
            return Expr(kind: exprkind_SetLit([]), span: start_merge(start, self.previous.span))

        # Parse elements (comma-separated expressions)
        var elements: [Expr] = []
        elements = elements_push(elements, self.parse_expr())

        while self.match_token(TokenKind.Comma):
            if self.check(TokenKind.RBrace):
                break  # Trailing comma
            elements = elements_push(elements, self.parse_expr())

        self.expect(TokenKind.RBrace, "expected '}' after set elements")
        Expr(kind: exprkind_SetLit(elements), span: start_merge(start, self.previous.span))


fn parser_parse_lambda(self: Parser) -> Expr:
        """Parse lambda expression \x, y: expr."""
        val start = self.current.span
        self.advance()  # Consume '\'

        var params: [LambdaParam] = []

        if not self.check(TokenKind.Colon):
            params = params_push(params, self.parse_lambda_param())
            while self.match_token(TokenKind.Comma):
                params = params_push(params, self.parse_lambda_param())

        self.expect(TokenKind.Colon, "expected ':' after lambda parameters")
        val body = self.parse_expr()

        Expr(kind: exprkind_Lambda(params, body), span: start_merge(start, body.span))


fn parser_parse_lambda_param(self: Parser) -> LambdaParam:
        """Parse lambda parameter."""
        val start = self.current.span
        val name = self.parse_identifier()

        var type_: Type = nil
        if self.match_token(TokenKind.Colon):
            type_ = self.parse_type()

        LambdaParam(name: name, type_: type_, span: start_merge(start, self.previous.span))


fn parser_parse_if_expr(self: Parser) -> Expr:
        """Parse if expression."""
        val start = self.current.span
        self.advance()  # Consume 'if'

        val cond = self.parse_expr()
        self.expect(TokenKind.Colon, "expected ':' after if condition")
        val then_ = self.parse_block()

        var else_: Block = nil
        if self.match_token(TokenKind.KwElse):
            self.expect(TokenKind.Colon, "expected ':' after else")
            else_ = self.parse_block()
        elif self.match_token(TokenKind.KwElif):
            # elif is sugar for else if
            val elif_expr = self.parse_if_expr()
            else_ = Block(stmts: [Stmt(kind: stmtkind_Expr(elif_expr), span: elif_expr.span)], span: elif_expr.span)

        Expr(kind: exprkind_If(cond, then_, else_), span: start_merge(start, self.previous.span))


fn parser_parse_match_expr(self: Parser) -> Expr:
        """Parse match expression."""
        val start = self.current.span
        self.advance()  # Consume 'match'

        val scrutinee = self.parse_expr()
        self.expect(TokenKind.Colon, "expected ':' after match scrutinee")
        self.skip_newlines()
        self.expect(TokenKind.Indent, "expected indented match arms")

        var arms: [MatchArm] = []

        while not self.check(TokenKind.Dedent) and not self.is_at_end():
            self.skip_newlines()
            if self.check(TokenKind.Dedent):
                break

            # Support both syntaxes:
            # - `case pattern:` (traditional)
            # - `| pattern ->` (Erlang-style, preferred)
            val is_pipe_syntax = self.check(TokenKind.Pipe)
            if is_pipe_syntax:
                self.advance()  # consume `|`
            elif self.check(TokenKind.KwCase):
                self.advance()  # consume `case`
            else:
                self.error("expected 'case' or '|' in match arm")

            val pattern = self.parse_pattern()

            var guard: Expr = nil
            if self.match_token(TokenKind.KwIf):
                guard = self.parse_expr()

            # For `| pattern ->` syntax, expect `->`
            # For `case pattern:` syntax, accept `:` or `->`
            if is_pipe_syntax:
                self.expect(TokenKind.Arrow, "expected '->' after pattern in | syntax")
            elif self.check(TokenKind.Arrow):
                self.advance()
            else:
                self.expect(TokenKind.Colon, "expected ':' or '->' after pattern")

            val body = self.parse_block()

            arms = arms.push(MatchArm(
                pattern: pattern,
                guard: guard,
                body: body,
                span: pattern.span_merge(span, body.span)
            ))

        self.match_token(TokenKind.Dedent)

        Expr(kind: exprkind_MatchCase(scrutinee, arms), span: start_merge(start, self.previous.span))


fn parser_parse_loss_block(self: Parser) -> Expr:
        """Parse loss{ ... } block.

        Loss blocks enable gradient tracking and auto-backward.
        They inherit m{} math block features (^, ', implicit mul).
        """
        val start = self.current.span
        self.advance()  # Consume 'loss' (math mode already enabled by lexer)
        self.expect(TokenKind.LBrace, "expected '{' after 'loss'")
        val body = self.parse_block()
        self.expect(TokenKind.RBrace, "expected '}' after loss block")
        Expr(kind: exprkind_LossBlock(body), span: start_merge(start, self.previous.span))


fn parser_parse_nograd_block(self: Parser) -> Expr:
        """Parse nograd{ ... } block.

        Nograd blocks disable gradient tracking for faster inference.
        They inherit m{} math block features (^, ', implicit mul).
        """
        val start = self.current.span
        self.advance()  # Consume 'nograd' (math mode already enabled by lexer)
        self.expect(TokenKind.LBrace, "expected '{' after 'nograd'")
        val body = self.parse_block()
        self.expect(TokenKind.RBrace, "expected '}' after nograd block")
        Expr(kind: exprkind_NogradBlock(body), span: start_merge(start, self.previous.span))


fn parser_parse_unsafe_block(self: Parser) -> Expr:
        """Parse unsafe: block.

        Unsafe blocks allow raw pointer operations, FFI calls,
        inline assembly, and other operations that bypass safety checks.

        Syntax:
            unsafe:
                val ptr = 0x1000 as *u32
                val value = *ptr
        """
        val start = self.current.span
        self.advance()  # Consume 'unsafe'
        self.expect(TokenKind.Colon, "expected ':' after 'unsafe'")
        val body = self.parse_block()
        Expr(kind: exprkind_UnsafeBlock(body), span: start_merge(start, self.previous.span))


fn parser_parse_asm_expr(self: Parser) -> Expr:
        """Parse inline assembly expression.

        Supports two syntaxes:
        1. Simple: asm "mov eax, ebx"
        2. Full: asm volatile("mov r0, {op}", op = in(reg) value, clobber_abi("C"))

        Must be within unsafe block (enforced during type checking).
        """
        val start = self.current.span
        self.advance()  # Consume 'asm'

        # Check for 'volatile' keyword
        val is_volatile = if self.current.kind == TokenKind.Ident and self.current.text == "volatile":
            self.advance()
            true
        else:
            false

        # Expect opening paren (for both simple and full syntax)
        if not self.check(TokenKind.LParen):
            self.error("expected '(' after 'asm'")
            return Expr(kind: ExprKind.Error, span: start)

        self.advance()  # Consume '('

        # Parse assembly template string
        if self.current.kind != TokenKind.StringLit:
            self.error("expected assembly template string")
            return Expr(kind: ExprKind.Error, span: start)

        val asm_template = self.current.text
        self.advance()

        # Parse optional constraints
        var constraints: [AsmConstraint] = []
        var clobbers: [text] = []

        # If we see a comma, parse constraints
        while self.current.kind == TokenKind.Comma:
            self.advance()  # Consume ','

            # Check for clobber_abi("C") special case
            if self.current.kind == TokenKind.Ident:
                if self.current.text == "clobber_abi":
                self.advance()  # Consume 'clobber_abi'
                self.expect(TokenKind.LParen, "expected '(' after 'clobber_abi'")
                if self.current.kind == TokenKind.StringLit:
                    # Just consume and ignore for now - we'll add proper handling later
                    self.advance()
                else:
                    self.error("expected ABI string")
                self.expect(TokenKind.RParen, "expected ')' after ABI")
                continue

            # Parse constraint: name = kind(location) value
            if self.current.kind != TokenKind.Ident:
                self.error("expected constraint name")
                break

            val constraint_name = self.current.text
            self.advance()

            self.expect(TokenKind.Assign, "expected '=' after constraint name")

            # Parse constraint kind: in, out, inout, lateout
            if self.current.kind != TokenKind.Ident:
                self.error("expected constraint kind (in, out, inout, lateout)")
                break

            val kind_str = self.current.text
            val kind = match kind_str:
                case "in": AsmConstraintKind.In
                case "out": AsmConstraintKind.Out
                case "inout": AsmConstraintKind.InOut
                case "lateout": AsmConstraintKind.LateOut
                case _:
                    self.error("invalid constraint kind: {kind_str}")
                    AsmConstraintKind.In

            self.advance()

            # Parse location: (reg) or (mem) or (imm)
            self.expect(TokenKind.LParen, "expected '(' after constraint kind")

            if self.current.kind != TokenKind.Ident:
                self.error("expected location specifier (reg, mem, imm)")
                break

            val location_str = self.current.text
            val location = match location_str:
                case "reg": AsmLocation.Reg
                case "mem": AsmLocation.Mem
                case "imm": AsmLocation.Imm
                case _:
                    # Specific register like "eax", "r0"
                    asmlocation_RegSpec(location_str)

            self.advance()
            self.expect(TokenKind.RParen, "expected ')' after location")

            # Parse value expression
            val value = self.parse_expression()

            val constraint = AsmConstraint(
                name: constraint_name,
                kind: kind,
                location: location,
                value: value,
                span: start_merge(start, self.previous.span)
            )
            constraints_push(constraints, constraint)

        # Expect closing paren
        self.expect(TokenKind.RParen, "expected ')' after assembly expression")

        val asm_expr = AsmExpr(
            asm_template: asm_template,
            is_volatile: is_volatile,
            constraints: constraints,
            clobbers: clobbers,
            span: start_merge(start, self.previous.span)
        )

        Expr(kind: exprkind_AsmBlock(asm_expr), span: start_merge(start, self.previous.span))


fn parser_parse_resolved_block(self: Parser, kind: text) -> Expr:
        """Parse a custom block using pre-resolved value.

        Called when a BlockStart token is encountered. Looks up the
        pre-resolved value and skips the payload tokens.

        Args:
            kind: The block kind (e.g., "sh", "sql", "re")
        """
        val start = self.current.span
        self.advance()  # Consume BlockStart

        # Look up pre-resolved value
        if self.has_resolved_blocks:
            val resolved = self.resolved_blocks_value
            val block = resolved_lookup(resolved, start)

            if block != nil:
                # Skip payload tokens (already processed by BlockResolver)
                self.skip_to_block_end()

                # Consume the closing brace/BlockEnd
                if self.check(TokenKind.BlockEnd):
                    self.advance()
                elif self.check(TokenKind.RBrace):
                    self.advance()

                return Expr(
                    kind: exprkind_CustomBlock(block.kind, block.value),
                    span: start_merge(start, self.previous.span)
                )

        # Fallback: inline parsing (block not pre-resolved)
        self.parse_block_inline(kind, start)


fn parser_parse_block_inline(self: Parser, kind: text, start: Span) -> Expr:
        """Parse a block inline when not pre-resolved.

        This is a fallback for when blocks are parsed without going
        through the BlockResolver phase.
        """
        # Expect opening brace
        self.expect(TokenKind.LBrace, "expected '{{' after block keyword '{kind}'")

        # For inline parsing, we treat it as a raw block
        # Skip until matching closing brace
        var brace_depth = 1
        val payload_start = self.current.span.start

        while brace_depth > 0 and not self.is_at_end():
            match self.peek():
                case LBrace:
                    brace_depth = brace_depth + 1
                    self.advance()
                case RBrace:
                    brace_depth = brace_depth - 1
                    if brace_depth > 0:
                        self.advance()
                case BlockEnd:
                    brace_depth = brace_depth - 1
                    if brace_depth > 0:
                        self.advance()
                case _:
                    self.advance()

        val payload_end = self.previous.span.end
        val payload = self.source[payload_start:payload_end]

        # Consume closing brace
        if self.check(TokenKind.RBrace) or self.check(TokenKind.BlockEnd):
            self.advance()

        # Create a Raw block value for inline parsing
        Expr(
            kind: exprkind_CustomBlock(kind, BlockValue.Raw(payload)),
            span: start_merge(start, self.previous.span)
        )


fn parser_parse_call_arg(self: Parser) -> CallArg:
        """Parse single call argument."""
        val start = self.current.span

        # Check for named argument using 2-token lookahead (copy parser to peek)
        if self.check(TokenKind.Ident):
            var lookahead = self
            lookahead_advance(lookahead)
            if lookahead_check(lookahead, TokenKind.Colon):
                # Confirmed named argument: ident ':' expr
                val name = self.current.text
                self.advance()  # consume ident
                self.advance()  # consume colon
                val value = self.parse_expr()
                # return CallArg(# DESUGARED: name: Some(name)
            name: name, value: value, span: start_merge(start, value.span))

        # Not a named argument, parse as full expression
        val value = self.parse_expr()
        CallArg(name: nil, value: value, span: start_merge(start, value.span))


fn parser_parse_identifier(self: Parser) -> text:
        if self.check(TokenKind.Ident):
            val name = self.current.text
            self.advance()
            name
        else:
            self.error("expected identifier")
            "<error>"


fn parser_parse_type(self: Parser) -> Type:
        """Parse a type expression (reuses outline type parsing logic)."""
        # Create temporary TreeSitter to parse type
        var ts = treesitter_new(self.source)
        var ts_lexer = ts.lexer
        ts_lexer.pos = self.lexer.pos
        ts.lexer = ts_lexer
        ts.current = self.current
        ts.previous = self.previous

        val outline = ts_parse_type_outline(ts)
        self.current = ts.current
        self.previous = ts.previous
        var my_lexer = self.lexer
        my_lexer.pos = ts.lexer.pos
        self.lexer = my_lexer

        self.convert_type(outline)


fn parser_parse_pattern(self: Parser) -> Pattern:
        """Parse a pattern."""
        val start = self.current.span

        match self.peek():
            case Underscore:
                self.advance()
                Pattern(kind: PatternKind.Wildcard, span: start)

            case IntLit:
                val expr = self.parse_primary_expr()
                Pattern(kind: patternkind_Literal(expr), span: start_merge(start, expr.span))

            case FloatLit:
                val expr = self.parse_primary_expr()
                Pattern(kind: patternkind_Literal(expr), span: start_merge(start, expr.span))

            case StringLit:
                val expr = self.parse_primary_expr()
                Pattern(kind: patternkind_Literal(expr), span: start_merge(start, expr.span))

            case BoolLit:
                val expr = self.parse_primary_expr()
                Pattern(kind: patternkind_Literal(expr), span: start_merge(start, expr.span))

            case NilLit:
                val expr = self.parse_primary_expr()
                Pattern(kind: patternkind_Literal(expr), span: start_merge(start, expr.span))

            case Ident:
                val name = self.current.text
                self.advance()

                if self.match_token(TokenKind.LParen):
                    # Enum pattern
                    self.parse_enum_pattern(name, start)
                elif self.match_token(TokenKind.LBrace):
                    # Struct pattern
                    self.parse_struct_pattern(name, start)
                else:
                    # Binding pattern
                    Pattern(kind: patternkind_Binding(name, false), span: start)

            case KwVar:
                self.advance()
                val name = self.parse_identifier()
                Pattern(kind: patternkind_Binding(name, true), span: start_merge(start, self.previous.span))

            case LParen:
                self.advance()
                if self.check(TokenKind.RParen):
                    self.advance()
                    Pattern(kind: patternkind_Tuple([]), span: start_merge(start, self.previous.span))
                else:
                    var elements: [Pattern] = []
                    elements = elements_push(elements, self.parse_pattern())
                    while self.match_token(TokenKind.Comma):
                        if self.check(TokenKind.RParen):
                            break
                        elements = elements_push(elements, self.parse_pattern())
                    self.expect(TokenKind.RParen, "expected ')' after tuple pattern")
                    Pattern(kind: patternkind_Tuple(elements), span: start_merge(start, self.previous.span))

            case LBracket:
                self.parse_array_pattern(start)

            case _:
                self.error("expected pattern")
                self.advance()
                Pattern(kind: PatternKind.Error, span: start)


fn parser_parse_enum_pattern(self: Parser, enum_name: text, start: Span) -> Pattern:
        """Parse enum pattern Enum.Variant(...)."""
        var variant = enum_name
        var enum_ = ""

        # Check for Enum.Variant form
        if self.previous.kind == TokenKind.Dot:
            enum_ = enum_name
            variant = self.parse_identifier()

        var payload: EnumPatternPayload = nil

        if not self.check(TokenKind.RParen):
            var patterns: [Pattern] = []
            patterns = patterns_push(patterns, self.parse_pattern())
            while self.match_token(TokenKind.Comma):
                if self.check(TokenKind.RParen):
                    break
                patterns = patterns_push(patterns, self.parse_pattern())
            payload = enumpatternpayload_Tuple(patterns)

        self.expect(TokenKind.RParen, "expected ')' after enum pattern")

        Pattern(
            kind: patternkind_Enum(enum_, variant, payload),
            span: start_merge(start, self.previous.span)
        )


fn parser_parse_struct_pattern(self: Parser, type_name: text, start: Span) -> Pattern:
        """Parse struct pattern Type { field, field: pattern }."""
        var fields: [(text, Pattern)] = []

        if not self.check(TokenKind.RBrace):
            val field = self.parse_identifier()
            val pattern = if self.match_token(TokenKind.Colon):
                self.parse_pattern()
            else:
\\\\\        to: zzoxzqoo 2b48645a "feat: Complete Track A/B/C - Native backend layout optimization and LLVM backend" (rebase destination)
                 pattern = Pattern(kind: patternkind_Binding(field, false), span: self.previous.span)
-            fields = fields_push(fields, [field, pattern])
+            fields = fields_push(fields, (field, pattern))

            while self.match_token(TokenKind.Comma):
                if self.check(TokenKind.RBrace):
                    break
                val f = self.parse_identifier()
                val p = if self.match_token(TokenKind.Colon):
                    self.parse_pattern()
                else:
\\\\\        to: zzoxzqoo 2b48645a "feat: Complete Track A/B/C - Native backend layout optimization and LLVM backend" (rebase destination)
                     p = Pattern(kind: patternkind_Binding(f, false), span: self.previous.span)
-                fields = fields_push(fields, [f, p])
+                fields = fields_push(fields, (f, p))

        self.expect(TokenKind.RBrace, "expected '}' after struct pattern")

        Pattern(
            kind: patternkind_Struct(type_name, fields),
            span: start_merge(start, self.previous.span)
        )


fn parser_parse_array_pattern(self: Parser, start: Span) -> Pattern:
        """Parse array pattern [a, b, ..rest]."""
        self.advance()  # Consume '['

        var elements: [Pattern] = []
        var rest: text = nil

        if not self.check(TokenKind.RBracket):
            if self.match_token(TokenKind.DotDot):
                rest = self.parse_identifier()
            else:
                elements = elements_push(elements, self.parse_pattern())

            while self.match_token(TokenKind.Comma):
                if self.check(TokenKind.RBracket):
                    break
                if self.match_token(TokenKind.DotDot):
                    rest = self.parse_identifier()
                    break
                elements = elements_push(elements, self.parse_pattern())

        self.expect(TokenKind.RBracket, "expected ']' after array pattern")

        Pattern(
            kind: patternkind_Array(elements, rest),
            span: start_merge(start, self.previous.span)
        )


fn parser_parse_block(self: Parser) -> Block:
        """Parse a block of statements."""
        val start = self.current.span
        var stmts: [Stmt] = []

        self.skip_newlines()

        if self.match_token(TokenKind.Indent):
            while not self.check(TokenKind.Dedent) and not self.is_at_end():
                self.skip_newlines()
                if self.check(TokenKind.Dedent):
                    break
                stmts = stmts_push(stmts, self.parse_stmt())
            self.match_token(TokenKind.Dedent)
        else:
            # Single-line block
            stmts = stmts_push(stmts, self.parse_stmt())

        Block(stmts: stmts, span: start_merge(start, self.previous.span))


fn parser_parse_stmt(self: Parser) -> Stmt:
        """Parse a statement."""
        # Guard against nil token
        if not self.current.has_kind:
            val empty_span = Span(start: 0, end: 0, line: 1, col: 1)
            val empty_expr = Expr(kind: ExprKind.Error("unexpected nil token"), span: empty_span)
            return Stmt(kind: stmtkind_Expr(empty_expr), span: empty_span)

        val start = self.current.span

        match self.peek():
            case KwVal:
                self.parse_val_stmt()
            case KwVar:
                self.parse_var_stmt()
            case KwShared:
                self.parse_shared_stmt()
            case KwFor:
                self.parse_for_stmt()
            case KwWhile:
                self.parse_while_stmt()
            case KwLoop:
                self.parse_loop_stmt()
            case KwReturn:
                self.advance()
                var value: Expr = nil
                if not self.check(TokenKind.Newline):
                    if not self.check(TokenKind.Dedent):
                    value = self.parse_expr()
                self.skip_newlines()
                Stmt(kind: stmtkind_Return(value), span: start_merge(start, self.previous.span))
            case KwBreak:
                self.advance()
                self.skip_newlines()
                Stmt(kind: stmtkind_Break(nil), span: start)
            case KwContinue:
                self.advance()
                self.skip_newlines()
                Stmt(kind: stmtkind_Continue(nil), span: start)
            case KwYield:
                self.advance()
                var value: Expr = nil
                if not self.check(TokenKind.Newline):
                    if not self.check(TokenKind.Dedent):
                    value = self.parse_expr()
                self.skip_newlines()
                Stmt(kind: stmtkind_Yield(value), span: start_merge(start, self.previous.span))
            case KwThrow:
                self.advance()
                val value = self.parse_expr()
                self.skip_newlines()
                Stmt(kind: stmtkind_Throw(value), span: start_merge(start, value.span))
            case KwWith:
                self.parse_with_stmt()
            case _:
                self.parse_expr_or_assign_stmt()


fn parser_parse_val_stmt(self: Parser) -> Stmt:
        """Parse val statement.
        Supports continuation on next line: val x = \n    expr
        """
        val start = self.current.span
        self.advance()  # Consume 'val'

        val name = self.parse_identifier()

        var type_: Type = nil
        if self.match_token(TokenKind.Colon):
            type_ = self.parse_type()

        self.expect(TokenKind.Assign, "expected '=' in val declaration")
        # Skip newlines after = to allow continuation on next line
        self.skip_newlines()
        # Track if we consumed an indent (need to consume matching dedent)
        var consumed_indent = false
        if self.match_token(TokenKind.Indent):
            consumed_indent = true
        val init = self.parse_expr()
        # Consume matching dedent if we consumed an indent
        if consumed_indent:
            self.skip_newlines()
            self.match_token(TokenKind.Dedent)
        self.skip_newlines()

        Stmt(kind: stmtkind_Val(name, type_, init), span: start_merge(start, init.span))


fn parser_parse_var_stmt(self: Parser) -> Stmt:
        """Parse var statement.
        Supports continuation on next line: var x = \n    expr
        """
        val start = self.current.span
        self.advance()  # Consume 'var'

        val name = self.parse_identifier()

        var type_: Type = nil
        if self.match_token(TokenKind.Colon):
            type_ = self.parse_type()

        var init: Expr = nil
        if self.match_token(TokenKind.Assign):
            # Skip newlines after = to allow continuation on next line
            self.skip_newlines()
            # Track if we consumed an indent (need to consume matching dedent)
            var consumed_indent = false
            if self.match_token(TokenKind.Indent):
                consumed_indent = true
            init = self.parse_expr()
            # Consume matching dedent if we consumed an indent
            if consumed_indent:
                self.skip_newlines()
                self.match_token(TokenKind.Dedent)

        self.skip_newlines()

        Stmt(kind: stmtkind_Var(name, type_, init), span: start_merge(start, self.previous.span))


fn parser_parse_shared_stmt(self: Parser) -> Stmt:
        """Parse shared memory declaration.

        Syntax:
            shared val name: Type
            shared val name: [Type; size]
            shared var name: Type
            shared var name: [Type; size]

        Used for GPU shared memory in kernel functions.
        """
        val start = self.current.span
        self.advance()  # Consume 'shared'

        val is_mutable = self.check(TokenKind.KwVar)
        if not self.check(TokenKind.KwVal):
            if not self.check(TokenKind.KwVar):
            self.error("expected 'val' or 'var' after 'shared'")
            return Stmt(
                kind: StmtKind.Expr(Expr(kind: ExprKind.Error("expected val/var after shared"), span: start)),
                span: start
            )
        self.advance()  # Consume 'val' or 'var'

        val name = self.parse_identifier()

        # Type is required for shared memory
        self.expect(TokenKind.Colon, "expected ':' after shared variable name")
        val type_ = self.parse_type()

        # Optional size expression for arrays: [Type; size]
        var size: Expr = nil
        if self.match_token(TokenKind.Semicolon):
            size = self.parse_expr()

        self.skip_newlines()

        if is_mutable:
            Stmt(kind: stmtkind_SharedVar(name, type_, size), span: start_merge(start, self.previous.span))
        else:
            Stmt(kind: stmtkind_SharedVal(name, type_, size), span: start_merge(start, self.previous.span))


fn parser_parse_for_stmt(self: Parser) -> Stmt:
        """Parse for statement."""
        val start = self.current.span
        self.advance()  # Consume 'for'

        val var_ = self.parse_identifier()
        self.expect(TokenKind.KwIn, "expected 'in' in for loop")
        val iter = self.parse_expr()
        self.expect(TokenKind.Colon, "expected ':' after for header")
        val body = self.parse_block()

        Stmt(kind: stmtkind_For(var_, iter, body), span: start_merge(start, body.span))


fn parser_parse_while_stmt(self: Parser) -> Stmt:
        """Parse while statement."""
        val start = self.current.span
        self.advance()  # Consume 'while'

        val cond = self.parse_expr()
        self.expect(TokenKind.Colon, "expected ':' after while condition")
        val body = self.parse_block()

        Stmt(kind: stmtkind_While(cond, body), span: start_merge(start, body.span))


fn parser_parse_loop_stmt(self: Parser) -> Stmt:
        """Parse loop statement."""
        val start = self.current.span
        self.advance()  # Consume 'loop'

        self.expect(TokenKind.Colon, "expected ':' after loop")
        val body = self.parse_block()

        Stmt(kind: stmtkind_Loop(body), span: start_merge(start, body.span))


fn parser_parse_with_stmt(self: Parser) -> Stmt:
        """Parse with statement.

        Syntax:
            with expr as var:
                body
            with expr1 as var1, expr2 as var2:
                body
            with expr:
                body
        """
        val start = self.current.span
        self.advance()  # Consume 'with'

        var items: [WithItem] = []

        # Parse one or more context manager items
        var continue_parsing = true
        while continue_parsing:
            # Parse context expression
            val context_expr = self.parse_expr()

            # Check for optional 'as' binding
            var target: text = nil
            if self.match_token(TokenKind.KwAs):
                target = self.parse_identifier()

            # Create WithItem
            val item = WithItem(
                context_expr: context_expr,
                target: target,
                span: start_merge(start, self.previous.span)
            )
            items = items_push(items, item)

            # Check for comma (multiple context managers)
            if self.check(TokenKind.Comma):
                self.advance()
                continue_parsing = true
            else:
                continue_parsing = false

        # Expect ':' before body
        self.expect(TokenKind.Colon, "expected ':' after with statement")

        # Parse block body
        val body = self.parse_block()

        Stmt(kind: stmtkind_With(items, body), span: start_merge(start, body.span))


fn parser_parse_expr_or_assign_stmt(self: Parser) -> Stmt:
        """Parse expression or assignment statement."""
        val start = self.current.span
        val expr = self.parse_expr()

        # Check for assignment
        if self.check(TokenKind.Assign):
            self.advance()
            val value = self.parse_expr()
            self.skip_newlines()
            return Stmt(kind: stmtkind_Assign(expr, nil, value), span: start_merge(start, value.span))

        if self.check(TokenKind.PlusEq):
            self.advance()
            val value = self.parse_expr()
            self.skip_newlines()
            return Stmt(kind: stmtkind_Assign(expr, AssignOp.Add, value), span: start_merge(start, value.span))

        if self.check(TokenKind.MinusEq):
            self.advance()
            val value = self.parse_expr()
            self.skip_newlines()
            return Stmt(kind: stmtkind_Assign(expr, AssignOp.Sub, value), span: start_merge(start, value.span))

        if self.check(TokenKind.StarEq):
            self.advance()
            val value = self.parse_expr()
            self.skip_newlines()
            return Stmt(kind: stmtkind_Assign(expr, AssignOp.Mul, value), span: start_merge(start, value.span))

        if self.check(TokenKind.SlashEq):
            self.advance()
            val value = self.parse_expr()
            self.skip_newlines()
            return Stmt(kind: stmtkind_Assign(expr, AssignOp.Div, value), span: start_merge(start, value.span))

        if self.check(TokenKind.PercentEq):
            self.advance()
            val value = self.parse_expr()
            self.skip_newlines()
            return Stmt(kind: stmtkind_Assign(expr, AssignOp.Mod, value), span: start_merge(start, value.span))

        self.skip_newlines()
        Stmt(kind: stmtkind_Expr(expr), span: expr.span)


# ============================================================================
# Helper Functions
# ============================================================================

# Span merge helpers
fn var_start_merge(start: Span, end: Span) -> Span:
    """Merge start and end spans for variable comprehensions."""
    start_merge(start, end)

fn cond_start_merge(start: Span, end: Span) -> Span:
    """Merge start and end spans for conditional comprehensions."""
    start_merge(start, end)

# Collection builder helpers
fn entries_push(entries: [(Expr, Expr)], entry: (Expr, Expr)) -> [(Expr, Expr)]:
    """Push entry to entries list."""
    var new_entries = entries
    new_entries.push(entry)
    new_entries

fn elements_push(elements: [Expr], element: Expr) -> [Expr]:
    """Push element to elements list."""
    var new_elements = elements
    new_elements.push(element)
    new_elements

fn clauses_push(clauses: [MatchClause], clause: MatchClause) -> [MatchClause]:
    """Push clause to clauses list."""
    var new_clauses = clauses
    new_clauses.push(clause)
    new_clauses

fn constraints_push(constraints: [AsmConstraint], constraint: AsmConstraint) -> [AsmConstraint]:
    """Push constraint to constraints list."""
    var new_constraints = constraints
    new_constraints.push(constraint)
    new_constraints

# Lookahead helpers
fn lookahead_advance(parser: Parser):
    """Advance lookahead parser."""
    p_advance(parser)

fn lookahead_check(parser: Parser, kind: TokenKind) -> bool:
    """Check if lookahead parser current token matches kind."""
    parser.current.kind == kind

# Block resolution helpers
fn resolved_lookup(resolved: ResolvedModule, span: Span) -> Block:
    """Look up resolved block by span."""
    # TODO: Implement actual lookup in resolved blocks dictionary
    # For now, return nil to indicate not found
    nil

fn skip_to_block_end(parser: Parser):
    """Skip tokens until block end or dedent."""
    while not parser_at_end(parser) and parser.current.kind != TokenKind.Dedent:
        if parser.current.kind == TokenKind.BlockEnd or parser.current.kind == TokenKind.RBrace:
            break
        p_advance(parser)

fn parse_int_literal(text: text) -> i64:
    """Parse integer literal."""
    # Handle different bases
    if text.starts_with("0x") or text.starts_with("0X"):
        # Hex
        parse_int_base(text[2:], 16)
    elif text.starts_with("0b") or text.starts_with("0B"):
        # Binary
        parse_int_base(text[2:], 2)
    elif text.starts_with("0o") or text.starts_with("0O"):
        # Octal
        parse_int_base(text[2:], 8)
    else:
        # Decimal
        parse_int_base(text, 10)

fn parse_int_base(text: text, base: i64) -> i64:
    """Parse integer in given base."""
    var result: i64 = 0
    for ch in text:
        if ch == '_':
            pass  # Skip underscores (numeric separators)
        else:
            val digit = char_to_digit(ch, base)
            if digit < 0:
                return result  # Stop on invalid character
            result = result * base + digit
    result

fn char_to_digit(ch: text, base: i64) -> i64:
    """Convert a single character to its digit value in the given base."""
    val code = ch_ord(ch)
    val digit = if code >= 48 and code <= 57:
        code - 48  # '0'-'9'
    elif code >= 65:
        if code <= 70:
        code - 55  # 'A'-'F' -> 10-15
    elif code >= 97:
        if code <= 102:
        code - 87  # 'a'-'f' -> 10-15
    else:
        -1
    if digit >= base:
        -1
    else:
        digit


# ============================================================================
# Factory functions (standalone, for interpreter compatibility)
# ============================================================================

fn create_parser(src: text) -> Parser:
    """Create a Parser from source text. Standalone function for interpreter compatibility.
    Use this instead of Parser.new() when running in interpreter mode."""
    var p = Parser(
        source: src,
        lexer: create_lexer(src),
        current: create_token_eof(0, 1),
        previous: create_token_eof(0, 1),
        errors: []
        #  # DESUGARED: outline: nil
        ## DESUGARED: resolved_blocks: nil
    )
    p_advance(p)
    p

# ============================================================================
# Exports
# ============================================================================

export Parser, create_parser
