# Test: MIR -> Native Backend -> ELF -> Link -> Run
#
# Constructs a MirModule manually, runs the x86_64 pipeline
# (ISel -> RegAlloc -> Encode -> ELF), writes the ELF, links, and runs.
# Bypasses mod.spl to avoid loading aarch64/riscv64 modules.

extern fn rt_process_run(cmd: text, args: [text]) -> (text, text, i64)

fn shell(command: text) -> (text, text, i64):
    rt_process_run("sh", ["-c", command])

# Import MIR data types
use compiler.mir_data.*

# Import x86_64 pipeline directly (bypass mod.spl to avoid aarch64/riscv64 load errors)
use compiler.backend.native.isel_x86_64.{isel_module}
use compiler.backend.native.regalloc.{regalloc_module}
use compiler.backend.native.encode_x86_64.{encode_module}
use compiler.backend.native.mach_inst.{MachModule, EncodedFunction}
use compiler.backend.native.elf_writer.{ElfWriter, ElfReloc, ElfRelocType, elf_writer_x86_64, elf_add_section, elf_add_symbol, new_text_section, new_data_section, new_rodata_section, section_add_reloc, new_func_symbol, new_extern_symbol, write_elf64}

print "=== MIR -> Native Backend Test ==="
print ""

# Step 1: Construct MirModule manually
print "Step 1: Constructing MirModule..."

val i64_type = MirType(kind: MirTypeKind.I64)

# Function signature: main() -> i64
val main_sig = MirSignature(
    params: [],
    return_type: i64_type,
    is_variadic: false
)

# Locals:
# 0: _return (i64, Return)
# 1: str_ptr (temp) - string address from ISel
# 2: ret_val (temp) - return value 0
val local_return = MirLocal(
    id: LocalId(id: 0),
    # # DESUGARED: name: Some("_return")
            name: "_return",
    type_: i64_type,
    kind: LocalKind.Return
)
val local_str = MirLocal(
    id: LocalId(id: 1),
    # # DESUGARED: name: Some("str_ptr")
            name: "str_ptr",
    type_: i64_type,
    kind: LocalKind.Temp
)
val local_ret = MirLocal(
    id: LocalId(id: 2),
    # # DESUGARED: name: Some("ret_val")
            name: "ret_val",
    type_: i64_type,
    kind: LocalKind.Temp
)

# Instructions:
# Const(dest=1, Str("hello from MIR!"), i64) - ISel will create rodata + LEA
# Call(dest=nil, func=Str("puts"), args=[Copy(1)]) - ISel will emit CALL puts
# Const(dest=2, Int(0), i64) - return 0
val inst_str = MirInst(
    kind: MirInstKind.Const(
        LocalId(id: 1),
        MirConstValue.Str("hello from MIR!"),
        i64_type
    ),
    span: nil
)

val inst_call = MirInst(
    kind: MirInstKind.Call(
        nil,
        MirOperand(kind: MirOperandKind.Const(
            MirConstValue.Str("puts"),
            i64_type
        )),
        [MirOperand(kind: miroperandkind_Copy(LocalId(id: 1)))]
    ),
    span: nil
)

val inst_zero = MirInst(
    kind: MirInstKind.Const(
        LocalId(id: 2),
        mirconstvalue_Int(0),
        i64_type
    ),
    span: nil
)

val entry_block = MirBlock(
    id: blockid_new(0),
    # # DESUGARED: label: Some("entry")
            label: "entry",
    instructions: [inst_str, inst_call, inst_zero],
    terminator: MirTerminator.Return(
        MirOperand(kind: miroperandkind_Copy(LocalId(id: 2)))
    )
)

val dummy_span = Span(start: 0, end: 0, line: 0, col: 0)

val main_func = MirFunction(
    symbol: symbolid_new(0),
    name: "main",
    signature: main_sig,
    locals: [local_return, local_str, local_ret],
    blocks: [entry_block],
    entry_block: blockid_new(0),
    span: dummy_span,
    generic_params: [],
    is_generic_template: false,
    specialization_of: nil,
    type_bindings: {}
)

var functions: Dict<SymbolId, MirFunction> = {}
functions[symbolid_new(0)] = main_func

val module = MirModule(
    name: "hello_mir",
    functions: functions,
    statics: {},
    constants: {},
    types: {}
)

print "  Module: {module.name}, Functions: 1 (main)"

# Step 2: Run x86_64 pipeline
print "Step 2: ISel (MIR -> MachInst)..."
val mach_module = isel_module(module)
print "  ISel done. Functions: {mach_module.functions.len()}, Externs: {mach_module.extern_symbols.len()}, Data: {mach_module.data_sections.len()}"

print "Step 3: RegAlloc (virtual -> physical regs)..."
val allocated = regalloc_module(mach_module)
print "  RegAlloc done."

print "Step 4: Encode (MachInst -> bytes)..."
val encoded_funcs = encode_module(allocated)
print "  Encode done. {encoded_funcs.len()} function(s)"
for ef in encoded_funcs:
    print "    {ef.name}: {ef.code.len()} bytes, {ef.relocations.len()} reloc(s)"

# Step 5: Emit ELF (inline emit_elf_x86_64 from mod.spl)
print "Step 5: Emitting ELF..."

fn emit_elf(encoded: [EncodedFunction], mach_mod: MachModule) -> [i64]:
    var writer = elf_writer_x86_64()
    var all_code: [i64] = []
    var func_offsets: Dict<text, i64> = {}
    var all_relocs: [ElfReloc] = []

    # Track user symbols in order they'll appear in symbol table
    # ELF writer inserts section symbols before user symbols:
    # [0: null] [1..N: section syms] [N+1..: user symbols]
    var sym_names: [text] = []
    var sym_name_to_idx: Dict<text, i64> = {}

    # 1. Data entry labels (local symbols in rodata)
    var rodata_offset = 0
    var data_label_offsets: Dict<text, i64> = {}
    for entry in mach_mod.data_sections:
        if entry.is_readonly:
            if not sym_name_to_idx_contains(sym_name_to_idx, entry.name):
                val idx = sym_names_len(sym_names)
                sym_names = sym_names + [entry.name]
                sym_name_to_idx[entry.name] = idx
                data_label_offsets[entry.name] = rodata_offset
            rodata_offset = rodata_offset + entry.data_len(data)

    # 2. Extern symbols
    for ext_sym in mach_mod.extern_symbols:
        if not sym_name_to_idx_contains(sym_name_to_idx, ext_sym):
            val idx = sym_names_len(sym_names)
            sym_names = sym_names + [ext_sym]
            sym_name_to_idx[ext_sym] = idx

    # 3. Function names
    for func in encoded:
        if not sym_name_to_idx_contains(sym_name_to_idx, func.name):
            val idx = sym_names_len(sym_names)
            sym_names = sym_names + [func.name]
            sym_name_to_idx[func.name] = idx

    # Count content sections for symbol index offset
    # .text is always present = 1
    var num_content_sections = 1
    var has_rodata = false
    var has_data = false
    for entry in mach_mod.data_sections:
        if entry.is_readonly:
            has_rodata = true
        else:
            has_data = true
    if has_rodata:
        num_content_sections = num_content_sections + 1
    if has_data:
        num_content_sections = num_content_sections + 1

    # Symbol index base = 1 (null) + num_content_sections (section syms)
    val sym_base = 1 + num_content_sections

    # Concatenate function code
    for func in encoded:
        var padding = all_code_len(all_code) % 16
        if padding != 0:
            padding = 16 - padding
        var pi = 0
        while pi < padding:
            all_code = all_code + [0xcc]
            pi = pi + 1
        func_offsets[func.name] = all_code_len(all_code)

        val code_start = all_code_len(all_code)
        all_code = all_code + func.code

        for reloc in func.relocations:
            var reloc_type = ElfRelocType.X86_64_PLT32
            if reloc.reloc_type == 2:
                reloc_type = ElfRelocType.X86_64_PC32
            elif reloc.reloc_type == 1:
                reloc_type = ElfRelocType.X86_64_64

            var sym_idx = 0
            if sym_name_to_idx_contains(sym_name_to_idx, reloc.symbol_name):
                sym_idx = sym_name_to_idx[reloc.symbol_name]
            val elf_reloc = ElfReloc(
                offset: code_start + reloc.offset,
                reloc_type: reloc_type,
                symbol_index: sym_base + sym_idx,
                addend: reloc.addend
            )
            all_relocs = all_relocs + [elf_reloc]

    # Create .text section with relocations
    var text_section = new_text_section(all_code)
    for reloc in all_relocs:
        text_section = section_add_reloc(text_section, reloc)
    writer = elf_add_section(writer, text_section)

    # Create .rodata section
    var rodata_bytes: [i64] = []
    for entry in mach_mod.data_sections:
        if entry.is_readonly:
            rodata_bytes = rodata_bytes + entry.data
    if rodata_bytes_len(rodata_bytes) > 0:
        writer = elf_add_section(writer, new_rodata_section(rodata_bytes))

    # Create .data section
    var data_bytes: [i64] = []
    for entry in mach_mod.data_sections:
        if not entry.is_readonly:
            data_bytes = data_bytes + entry.data
    if data_bytes_len(data_bytes) > 0:
        writer = elf_add_section(writer, new_data_section(data_bytes))

    # Add data label symbols (local, in rodata section)
    # rodata is section index 2 (after .text=1)
    for entry in mach_mod.data_sections:
        if entry.is_readonly:
            if data_label_offsets_contains(data_label_offsets, entry.name):
                val sym = ElfSymbol(
                    name: entry.name,
                    sym_bind: ElfSymbolBind.Local,
                    sym_type: ElfSymbolType.Object,
                    section_index: 2,
                    value: data_label_offsets[entry.name],
                    size: entry.data_len(data)
                )
                writer = elf_add_symbol(writer, sym)

    # Add extern symbols
    for ext_sym in mach_mod.extern_symbols:
        writer = elf_add_symbol(writer, new_extern_symbol(ext_sym))

    # Add function symbols
    for func in encoded:
        var foffset = 0
        if func_offsets_contains(func_offsets, func.name):
            foffset = func_offsets[func.name]
        val sym = new_func_symbol(func.name, 1, foffset, func.code_len(code))
        writer = elf_add_symbol(writer, sym)

    write_elf64(writer)

val elf_bytes = emit_elf(encoded_funcs, allocated)
print "  ELF size: {elf_bytes.len()} bytes"

# Step 6: Write to disk
print "Step 6: Writing object file..."

fn byte_to_hex(b: i64) -> text:
    val digits = "0123456789abcdef"
    val hi = b / 16
    val lo = b % 16
    "{digits[hi]}{digits[lo]}"

val chunk_size = 800
var offset = 0
while offset < elf_bytes_len(elf_bytes):
    var chunk = ""
    var end_idx = offset + chunk_size
    if end_idx > elf_bytes_len(elf_bytes):
        end_idx = elf_bytes_len(elf_bytes)
    var j = offset
    while j < end_idx:
        chunk = chunk + byte_to_hex(elf_bytes[j])
        j = j + 1
    if offset == 0:
        shell("echo -n '{chunk}' > /tmp/mir_test.hex")
    else:
        shell("echo -n '{chunk}' >> /tmp/mir_test.hex")
    offset = end_idx

shell("xxd -r -p /tmp/mir_test.hex /tmp/mir_test.o")
shell("rm -f /tmp/mir_test.hex")
print "  Written: /tmp/mir_test.o ({elf_bytes.len()} bytes)"

# Step 7: Link & Run
print "Step 7: Linking..."
val link_r = rt_process_run("cc", ["-o", "/tmp/mir_test", "/tmp/mir_test.o", "-no-pie"])
val link_code = link_r[2]

if link_code != 0:
    print "  Link FAILED (code {link_code})"
    print "  {link_r[1]}"
else:
    print "  Link succeeded!"

    # Step 8: Run
    print "Step 8: Running..."
    val run_r = rt_process_run("/tmp/mir_test", [])
    val run_out = run_r[0]
    val run_code = run_r[2]
    print "  Output: '{run_out.trim()}'"
    print "  Exit code: {run_code}"

    if run_out.trim() == "hello from MIR!":
        print ""
        print "=== SUCCESS: Full MIR -> ISel -> RegAlloc -> Encode -> ELF -> Link -> Run ==="
    else:
        print ""
        print "=== PARTIAL: Binary ran but output mismatch ==="

print "=== Done ==="
