# Core Simple — AST Type Structs
#
# Struct-based AST node types for the shared core library.
# Used by ast.spl (struct pools) instead of parallel arrays.
#
# Compiled by seed (Core Simple subset): no generics, no closures,
# no lambdas, no enum payloads.

# ===== Expression Node =====
# Fields mirror the parallel arrays in the original arena design:
#   tag     — EXPR_* kind constant
#   span_id — index into span pool
#   i_val   — integer value (int/bool literals, operator kind)
#   f_val   — float value stored as text (for seed compat)
#   s_val   — string value (string literals, identifiers, field names)
#   left    — left child expression index (-1 = none)
#   right   — right child expression index (-1 = none)
#   extra   — extra expression index (else branch, etc.) (-1 = none)
#   args    — argument list (indices into expr pool)
#   stmts   — statement list (indices into stmt pool)

struct CoreExpr:
    tag: i64
    span_id: i64
    i_val: i64
    f_val: text
    s_val: text
    left: i64
    right: i64
    extra: i64
    args: [i64]
    stmts: [i64]

fn make_core_expr(tag: i64, span_id: i64) -> CoreExpr:
    CoreExpr(tag: tag, span_id: span_id, i_val: 0, f_val: "", s_val: "", left: -1, right: -1, extra: -1, args: [], stmts: [])

# ===== Statement Node =====
# Fields mirror the stmt_* parallel arrays:
#   tag      — STMT_* kind constant
#   span_id  — index into span pool
#   expr_idx — expression index (-1 = none)
#   name     — variable name for val/var/for declarations
#   type_tag — type annotation tag
#   body     — body statements (for if/for/while/match/block)

struct CoreStmt:
    tag: i64
    span_id: i64
    expr_idx: i64
    name: text
    type_tag: i64
    body: [i64]

fn make_core_stmt(tag: i64, span_id: i64) -> CoreStmt:
    CoreStmt(tag: tag, span_id: span_id, expr_idx: -1, name: "", type_tag: 0, body: [])

# ===== Declaration Node =====
# Fields mirror the decl_* parallel arrays:
#   tag             — DECL_* kind constant
#   span_id         — index into span pool
#   name            — declaration name
#   param_names     — function parameter names
#   param_types     — function parameter type tags
#   ret_type        — function return type tag
#   body_stmts      — function body / init expression (as [i64])
#   field_names     — struct field names / enum variant names
#   field_types     — struct field type tags
#   field_defaults  — struct field default expression ids (-1 = no default)
#   imports         — use import names / export names
#   is_pub          — 1 if public, 0 otherwise

struct CoreDecl:
    tag: i64
    span_id: i64
    name: text
    param_names: [text]
    param_types: [i64]
    ret_type: i64
    body_stmts: [i64]
    field_names: [text]
    field_types: [i64]
    field_defaults: [i64]
    imports: [text]
    is_pub: i64
    type_params: [text]

fn make_core_decl(tag: i64, span_id: i64) -> CoreDecl:
    CoreDecl(tag: tag, span_id: span_id, name: "", param_names: [], param_types: [], ret_type: 0, body_stmts: [], field_names: [], field_types: [], field_defaults: [], imports: [], is_pub: 0, type_params: [])

# ===== Match Arm =====
# A match arm is (pattern_expr, guard_expr, body_stmts)

struct CoreMatchArm:
    pattern: i64
    guard: i64
    body: [i64]

fn make_core_arm(pattern: i64, guard: i64, body: [i64]) -> CoreMatchArm:
    CoreMatchArm(pattern: pattern, guard: guard, body: body)

# ===== Elif Chain =====
# For elif chains: (cond_expr, then_stmts, else_stmts)

struct CoreElif:
    cond: i64
    body: [i64]
    else_body: [i64]

fn make_core_elif(cond: i64, body: [i64], else_body: [i64]) -> CoreElif:
    CoreElif(cond: cond, body: body, else_body: else_body)

export CoreExpr, make_core_expr
export CoreStmt, make_core_stmt
export CoreDecl, make_core_decl
export CoreMatchArm, make_core_arm
export CoreElif, make_core_elif
