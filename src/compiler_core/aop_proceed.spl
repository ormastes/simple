# AOP Proceed Enforcement
#
# Runtime verification for `around` advice to ensure `proceed()` is called exactly once.
# This prevents common errors like:
# - Forgetting to call proceed() (blocks execution)
# - Calling proceed() multiple times (duplicate execution)

export ProceedError, ProceedContext, AroundAdviceContext, ConditionalProceedContext
export verify_proceed_called, create_proceed_context, create_proceed_context_internal
export create_around_advice_context, create_conditional_proceed_context

# ============================================================================
# Error Types
# ============================================================================

enum ProceedError:
    """Errors related to proceed() calls in around advice."""
    NeverCalled(advice_name: text)
    CalledMultipleTimes(advice_name: text, count: i64)
    CalledAfterError(advice_name: text)


# ============================================================================
# ProceedError Methods (was: impl ProceedError:)
# ============================================================================

# ============================================================================
# Proceed Context
# ============================================================================

class ProceedContext:
    """Tracks proceed() calls within an around advice execution."""
    advice_name: text
    proceed_count: i64
    has_error: bool
    allow_multiple: bool    # For special cases (usually false)

fn create_proceed_context_internal(advice_name: text) -> ProceedContext:
    """Create a new proceed context for advice execution."""
    ProceedContext(
        advice_name: advice_name,
        proceed_count: 0,
        has_error: false,
        allow_multiple: false
    )


# ============================================================================
# ProceedContext Methods (was: impl ProceedContext:)
# ============================================================================

# ============================================================================
# Around Advice Context
# ============================================================================

class AroundAdviceContext:
    """Context for executing around advice with proceed tracking.

    This wraps the execution of around advice and tracks proceed() calls.
    """
    proceed_ctx: ProceedContext
    target_fn: Any  # Function: () -> Any
    before_proceed: Any?
    after_proceed: Any?

fn create_around_advice_context(advice_name: text, target_fn: fn() -> Any) -> AroundAdviceContext:
    """Create context for around advice execution."""
    AroundAdviceContext(
        proceed_ctx: create_proceed_context_internal(advice_name),
        target_fn: target_fn,
        has_before_proceed: false,  # DESUGARED: before_proceed: nil
        has_after_proceed: false,  # DESUGARED: after_proceed: nil
    )


# ============================================================================
# AroundAdviceContext Methods (was: impl AroundAdviceContext:)
# ============================================================================

fn aroundadvicecontext_proceed(self: AroundAdviceContext) -> Any:
        """Call the original function (wrapped join point).

        This should be called exactly once by the around advice.
        """
        # Mark proceed as called
        self.proceed_ctx_mark_proceed_called(proceed_ctx)

        # Execute hooks (commented out - needs lambda support)
        # if self.has_before_proceed:
        #     self.before_proceed_value()

        # Call target function
        val result = self.target_fn()

        # Execute hooks (commented out - needs lambda support)
        # if self.has_after_proceed:
        #     self.after_proceed_value()

        result


# ============================================================================
# Verification Functions
# ============================================================================

fn verify_proceed_called(ctx: AroundAdviceContext) -> Result<(), text>:
    """Verify that proceed() was called exactly once.

    Returns Err with formatted message if verification fails.
    """
    match ctx_verify(ctx):
        case Ok(()):
            Ok(())
        case Err(error):
            Err(error_format(error))

fn create_proceed_context(advice_name: text, target_fn: fn() -> Any) -> AroundAdviceContext:
    """Create a proceed context for around advice execution."""
    create_around_advice_context(advice_name, target_fn)

# ============================================================================
# Runtime Integration Example
# ============================================================================

# Example usage in AOP runtime:
#
# fn execute_around_advice(advice: Advice, target_fn: fn() -> Any) -> Any:
#     # Create proceed context
#     val ctx = create_proceed_context(advice.name, target_fn)
#
#     # Execute advice with proceed callback
#     val result = advice.handler(ctx.proceed)
#
#     # Verify proceed was called
#     match verify_proceed_called(ctx):
#         case Err(error):
#             panic(error)  # Or emit diagnostic
#         case Ok(()):
#             result

# ============================================================================
# Advanced: Conditional Proceed
# ============================================================================

class ConditionalProceedContext:
    """Context for around advice with conditional proceed.

    Allows proceed() to be called 0 or 1 times based on runtime conditions.
    Used for conditional execution patterns like:
    - Circuit breaker: Skip proceed if too many failures
    - Rate limiting: Skip proceed if rate exceeded
    - Authorization: Skip proceed if not authorized
    """
    base_ctx: AroundAdviceContext
    condition_fn: Any  # Function: () -> bool
    fallback_fn: Any   # Function: () -> Any

fn create_conditional_proceed_context(advice_name: text, target_fn: fn() -> Any,
                                     condition_fn: fn() -> bool,
                                     fallback_fn: fn() -> Any) -> ConditionalProceedContext:
    ConditionalProceedContext(
        base_ctx: create_around_advice_context(advice_name, target_fn),
        condition_fn: condition_fn,
        fallback_fn: fallback_fn
    )


# ============================================================================
# ConditionalProceedContext Methods (was: impl ConditionalProceedContext:)
# ============================================================================

fn conditionalproceedcontext_proceed_if_allowed(self: ConditionalProceedContext) -> Any:
        """Call proceed() only if condition is true, otherwise use fallback."""
        if self.condition_fn():
            self.base_ctx_proceed(base_ctx)
        else:
            self.fallback_fn()


# ============================================================================
# Testing Utilities
# ============================================================================

fn test_proceed_enforcement():
    """Test proceed enforcement."""

    # Test 1: Valid proceed (called once)
    var target_called = false
    val target = \: { target_called = true; 42 }
    val ctx1 = create_proceed_context("test_advice", target)
    val result1 = ctx1_proceed(ctx1)
    assert(result1 == 42)
    assert(target_called)
    assert(ctx1_verify(ctx1).is_ok())

    # Test 2: Never called proceed
    val ctx2 = create_proceed_context("test_advice", target)
    # Don't call proceed
    assert(ctx2_verify(ctx2).is_err())
    match ctx2_verify(ctx2):
        case Err(proceederror_NeverCalled(name)):
            assert(name == "test_advice")
        case _:
            panic("Expected NeverCalled error")

    # Test 3: Multiple proceed calls
    val ctx3 = create_proceed_context("test_advice", target)
    ctx3_proceed(ctx3)
    ctx3_proceed(ctx3)  # Called twice!
    assert(ctx3_verify(ctx3).is_err())
    match ctx3_verify(ctx3):
        case Err(proceederror_CalledMultipleTimes(name, count)):
            assert(name == "test_advice")
            assert(count == 2)
        case _:
            panic("Expected CalledMultipleTimes error")

# ============================================================================
# Integration Points
# ============================================================================

# This module integrates with:
# 1. src/compiler/aop.spl - AOP weaver
# 2. rust/compiler/src/interpreter_call/core/aop_advice.rs - Runtime advice execution
# 3. Runtime value system - For proceed() callback handling
#
# When implementing around advice:
# 1. Create AroundAdviceContext with target function
# 2. Pass ctx.proceed as callback to advice handler
# 3. After advice completes, call ctx.verify()
# 4. Emit error if verification fails
