# Object File Resolution for Library Linking
#
# Resolves object files for modules extracted from libraries.
# Uses a companion file strategy: for each SMF module, looks for a
# corresponding .o file in standard locations.
#
# Strategy:
# 1. When a module is needed from a library, check for companion .o file
# 2. Look in standard object file directories (build/obj/, .build/cache/)
# 3. If found, use existing object file
# 4. If not found, attempt to compile SMF to object (future)
# 5. If compilation not available, report error with helpful message

use app.io.{file_exists, shell, cwd}

# ============================================================================
# Object File Resolution
# ============================================================================

struct ObjectFileResolver:
    """Resolves object files for library modules."""
    search_paths: [text]
    cache: Dict<text, text>    # module_name -> object_path
    verbose: bool


# ============================================================================
# ObjectFileResolver Methods (was: impl ObjectFileResolver:)
# ============================================================================

fn objectfileresolver_new(verbose: bool) -> ObjectFileResolver:
        var paths = default_object_search_paths()
        ObjectFileResolver(
            search_paths: paths,
            cache: {},
            verbose: verbose
        )


"""Resolve an object file for a module name.

Searches through all configured search paths for candidate object files.
Results are cached so subsequent lookups for the same module are fast.

Args:
    resolver: The resolver instance (mutated for cache)
    module_name: Module name to resolve (e.g. "std/io/mod")

Returns:
    Ok(path) with the resolved object file path, or Err with a message.
"""
fn resolver_resolve(resolver: ObjectFileResolver, module_name: text) -> Result<text, text>:
    # Check cache first
    if resolver.cache.contains_key(module_name):
        return Ok(resolver.cache[module_name])

    # Generate candidate filenames for this module
    val candidates = generate_object_candidates(module_name)

    # Search each path + candidate combination
    for search_dir in resolver.search_paths:
        for candidate in candidates:
            val full_path = "{search_dir}/{candidate}"
            if file_exists(full_path):
                # Cache the result
                resolver.cache[module_name] = full_path
                if resolver.verbose:
                    print "[object-resolver] Found {module_name} at {full_path}"
                return Ok(full_path)

    # Also try absolute path based on working directory
    val work_dir = cwd()
    for candidate in candidates:
        val abs_path = "{work_dir}/{candidate}"
        if file_exists(abs_path):
            resolver.cache[module_name] = abs_path
            if resolver.verbose:
                print "[object-resolver] Found {module_name} at {abs_path}"
            return Ok(abs_path)

    # Build helpful error message with searched locations
    var searched: [text] = []
    for search_dir in resolver.search_paths:
        for candidate in candidates:
            searched.push("{search_dir}/{candidate}")

    val searched_str = searched.join(", ")
    Err("Object file not found for module '{module_name}'. Searched: {searched_str}")

# ============================================================================
# Helper Functions
# ============================================================================

"""Get default object file search paths."""
fn default_object_search_paths() -> [text]:
    [
        "build/obj",           # Standard build output
        "build/artifacts/cache/obj",    # Build system cache
        "obj",                 # Local objects
        ".",                   # Current directory
        "build/lib/obj"        # Library object cache
    ]

"""Generate object file candidates for a module name."""
fn generate_object_candidates(module_name: text) -> [text]:
    var candidates: [text] = []

    # Full path variant: std/io/mod → std/io/mod.o
    candidates.push("{module_name}.o")

    # Underscore variant: std/io/mod → std_io_mod.o
    val underscored = module_name.replace("/", "_")
    candidates.push("{underscored}.o")

    # Last component only: std/io/mod → mod.o
    val last_slash = module_name.rfind("/")
    if last_slash >= 0:
        val last_component = module_name[(last_slash + 1):]
        candidates.push("{last_component}.o")

    # With src prefix: std/io/mod → src/std/io/mod.o
    candidates.push("src/{module_name}.o")

    candidates

"""Check if we can compile SMF to object.
Looks for the smf-to-object tool or the Simple compiler with codegen support."""
fn can_compile_smf_to_object() -> bool:
    # Check if 'simple' compiler binary exists and supports codegen
    val (stdout, stderr, code) = shell("which simple 2>/dev/null")
    if code == 0:
        val compiler_path = stdout.trim()
        if compiler_path.len() > 0:
            return file_exists(compiler_path)
    # Check for smf-to-object tool
    val (stdout2, stderr2, code2) = shell("which smf-to-object 2>/dev/null")
    code2 == 0

"""Attempt to compile SMF module to object file (future)."""
fn compile_smf_to_object(
    smf_data: [u8],
    output_path: text
) -> text:
    # SMF to object compilation not yet implemented
    # This would:
    # 1. Parse SMF
    # 2. Extract or reconstruct MIR
    # 3. Run codegen pipeline
    # 4. Emit object file
    eprint("Warning: SMF to object compilation not yet implemented; cannot compile to {output_path}")
    Err("SMF to object compilation not yet implemented")

# ============================================================================
# Integration with Linker Wrapper
# ============================================================================

"""Resolve object files for resolved modules."""
fn resolve_objects_for_modules(
    resolved_modules: [ResolvedModule],
    verbose: bool
) -> text:
    var resolver = objectfileresolver_new(verbose)
    var object_paths: [text] = []

    for module in resolved_modules:
        val result = resolver_resolve(resolver, module.module_name)

        match result:
            case Ok(obj_path):
                object_paths.push(obj_path)
                if verbose:
                    print "[object-resolver] Resolved {module.module_name} → {obj_path}"
            case Err(e):
                return Err(e)

    Ok(object_paths)

# ResolvedModule struct (should be imported from linker_wrapper_lib_support)
# Defining here to avoid circular dependency issues
struct ResolvedModule:
    module_name: text
    library_path: text
    smf_data: [u8]

# ============================================================================
# Exports
# ============================================================================

export ObjectFileResolver
export resolve_objects_for_modules
export resolver_resolve
export generate_object_candidates
export default_object_search_paths
export can_compile_smf_to_object
export compile_smf_to_object
