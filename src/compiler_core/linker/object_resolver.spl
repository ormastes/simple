# Object File Resolution for Library Linking
#
# Resolves object files for modules extracted from libraries.
# Uses a companion file strategy: for each SMF module, looks for a
# corresponding .o file in standard locations.
#
# Strategy:
# 1. When a module is needed from a library, check for companion .o file
# 2. Look in standard object file directories (build/obj/, .build/cache/)
# 3. If found, use existing object file
# 4. If not found, attempt to compile SMF to object (future)
# 5. If compilation not available, report error with helpful message

use app.io.{file_exists, shell, cwd}

# ============================================================================
# Object File Resolution
# ============================================================================

struct ObjectFileResolver:
    """Resolves object files for library modules."""
    search_paths: [text]
    cache: Dict<text, text>    # module_name -> object_path
    verbose: bool


# ============================================================================
# ObjectFileResolver Methods (was: impl ObjectFileResolver:)
# ============================================================================

fn objectfileresolver_new(verbose: bool) -> ObjectFileResolver:
        var paths = default_object_search_paths()
        ObjectFileResolver(
            search_paths: paths,
            cache: {},
            verbose: verbose
        )


# ============================================================================
# Helper Functions
# ============================================================================

"""Get default object file search paths."""
fn default_object_search_paths() -> [text]:
    [
        "build/obj",           # Standard build output
        ".build/cache/obj",    # Build system cache
        "obj",                 # Local objects
        ".",                   # Current directory
        "build/lib/obj"        # Library object cache
    ]

"""Generate object file candidates for a module name."""
fn generate_object_candidates(module_name: text) -> [text]:
    var candidates: [text] = []

    # Full path variant: std/io/mod → std/io/mod.o
    candidates.push("{module_name}.o")

    # Underscore variant: std/io/mod → std_io_mod.o
    val underscored = module_name.replace("/", "_")
    candidates.push("{underscored}.o")

    # Last component only: std/io/mod → mod.o
    val last_slash = module_name.rfind("/")
    if last_slash >= 0:
        val last_component = module_name[(last_slash + 1):]
        candidates.push("{last_component}.o")

    # With src prefix: std/io/mod → src/std/io/mod.o
    candidates.push("src/{module_name}.o")

    candidates

"""Check if we can compile SMF to object."""
fn can_compile_smf_to_object() -> bool:
    # Check if smf-to-object tool is available
    # For now, return false (not yet implemented)
    false

"""Attempt to compile SMF module to object file (future)."""
fn compile_smf_to_object(
    smf_data: [u8],
    output_path: text
) -> Result<(), text>:
    # SMF to object compilation not yet implemented
    # This would:
    # 1. Parse SMF
    # 2. Extract or reconstruct MIR
    # 3. Run codegen pipeline
    # 4. Emit object file
    eprint("Warning: SMF to object compilation not yet implemented; cannot compile to {output_path}")
    Err("SMF to object compilation not yet implemented")

# ============================================================================
# Integration with Linker Wrapper
# ============================================================================

"""Resolve object files for resolved modules."""
fn resolve_objects_for_modules(
    resolved_modules: [ResolvedModule],
    verbose: bool
) -> Result<[text], text>:
    var resolver = objectfileresolver_new(verbose)
    var object_paths: [text] = []

    for module in resolved_modules:
        val result = resolver_resolve(resolver, module.module_name)

        match result:
            case Ok(obj_path):
                object_paths_push(object_paths, obj_path)
                if verbose:
                    print "[object-resolver] Resolved {module.module_name} → {obj_path}"
            case Err(e):
                return Err(e)

    Ok(object_paths)

# ResolvedModule struct (should be imported from linker_wrapper_lib_support)
# Defining here to avoid circular dependency issues
struct ResolvedModule:
    module_name: text
    library_path: text
    smf_data: [u8]

# ============================================================================
# Exports
# ============================================================================

export ObjectFileResolver
export resolve_objects_for_modules
export generate_object_candidates
export default_object_search_paths
export can_compile_smf_to_object
export compile_smf_to_object
