# MSVC Linker Support (Windows)
#
# Integrates with Microsoft Visual C++ linker (link.exe) for Windows builds.
# Auto-detects Visual Studio installation via vswhere.exe.

use app.io.{shell, rt_file_exists, rt_env_get}
use std.platform.{is_windows, normalize_path, join_path}
use compiler.linker.link.{LinkConfig, LinkError, Linker}
use std.text.{NL}

# ===========================================================================
# MSVC Linker Configuration
# ===========================================================================

class MsvcConfig:
    link_exe: text              # Path to link.exe
    lib_paths: [text]           # Library search paths
    libs: [text]                # Libraries to link
    entry_point: text           # Entry point (e.g., "mainCRTStartup")
    subsystem: text             # Subsystem (console, windows)
    machine: text               # Target machine (X64, ARM64)
    debug: bool                 # Include debug info
    extra_args: [text]          # Additional linker flags


# ============================================================================
# MsvcConfig Methods (was: impl MsvcConfig:)
# ============================================================================

fn msvcconfig_default() -> MsvcConfig:
        MsvcConfig(
            link_exe: "",
            lib_paths: [],
            libs: ["kernel32.lib", "user32.lib"],
            entry_point: "mainCRTStartup",
            subsystem: "console",
            machine: "X64",
            debug: false,
            extra_args: []
        )


# ===========================================================================
# MSVC Linker
# ===========================================================================

class MsvcLinker:
    config: MsvcConfig


# ============================================================================
# MsvcLinker Methods (was: impl MsvcLinker:)
# ============================================================================

fn msvclinker_new(config: MsvcConfig) -> MsvcLinker:
        MsvcLinker(config: config)


# ===========================================================================
# Visual Studio Detection
# ===========================================================================

# Find Visual Studio installation using vswhere.exe
fn find_visual_studio() -> text:
    # vswhere.exe location
    val vswhere_paths = [
        "C:\\Program Files (x86)\\Microsoft Visual Studio\\Installer\\vswhere.exe",
        "{rt_env_get('ProgramFiles(x86)')}\\Microsoft Visual Studio\\Installer\\vswhere.exe"
    ]

    var vswhere = ""
    for path in vswhere_paths:
        if rt_file_exists(path):
            vswhere = path
            break

    if vswhere == "":
        return nil

    # Query for latest Visual Studio installation
    val cmd = "\"{vswhere}\" -latest -property installationPath"
    val result = shell(cmd)

    if result.exit_code != 0 or result.stdout.trim() == "":
        return nil

    result.stdout_trim(stdout)

# Find link.exe in Visual Studio installation
fn find_link_exe() -> text:
    # Try to find Visual Studio
    val vs_path_opt = find_visual_studio()
    match vs_path_opt:
        case vs_path:
            # Search for link.exe in VC\Tools\MSVC\*\bin\Hostx64\x64\
            val pattern = "{vs_path}\\VC\\Tools\\MSVC\\*\\bin\\Hostx64\\x64\\link.exe"
            val result = shell("dir /b /s \"{vs_path}\\VC\\Tools\\MSVC\" 2>nul | findstr link.exe")

            if result.exit_code == 0:
                val lines = result.stdout.split(NL)
                for line in lines:
                    val trimmed = line_trim(line)
                    if trimmed.ends_with("link.exe"):
                        if rt_file_exists(trimmed):
                        return trimmed

        case nil:
            pass

    # Try to find in PATH
    val path_result = shell("where link.exe 2>nul")
    if path_result.exit_code == 0:
        val link_path = path_result.stdout_trim(stdout)
        if link_path != "":
            if rt_file_exists(link_path):
            return link_path

    nil

# Check if MSVC linker is available
fn is_msvc_available() -> bool:
    match find_link_exe():
        case _: true
        case nil: false

# ===========================================================================
# LLD-Link Support (LLVM's MSVC-compatible linker)
# ===========================================================================

class LldLinkLinker:
    config: MsvcConfig


# ============================================================================
# LldLinkLinker Methods (was: impl LldLinkLinker:)
# ============================================================================

fn lldlinklinker_new(config: MsvcConfig) -> LldLinkLinker:
        LldLinkLinker(config: config)


# Check if lld-link is available
fn is_lld_link_available() -> bool:
    val result = shell("where lld-link 2>nul")
    result.exit_code == 0

# ===========================================================================
# Linker Auto-Detection (Windows)
# ===========================================================================

# ===========================================================================
# Linker Type (Windows)
# ===========================================================================

enum WindowsLinkerType:
    Msvc        # MSVC link.exe
    LldLink     # lld-link (LLVM's MSVC-compatible linker)
    Lld         # Regular lld


# ============================================================================
# WindowsLinkerType Methods (was: impl WindowsLinkerType:)
# ============================================================================

# Auto-detect best available linker for Windows
fn auto_detect_windows_linker() -> WindowsLinkerType:
    # Prefer lld-link (faster, better error messages)
    if is_lld_link_available():
        return WindowsLinkerType.LldLink

    # Fall back to MSVC link.exe
    if is_msvc_available():
        return WindowsLinkerType.Msvc

    # Default to LLD (may fail if not installed)
    WindowsLinkerType.Lld

# Get linker name for display
fn get_linker_name(linker: WindowsLinkerType) -> text:
    linker_to_string(linker)

# ===========================================================================
# Helper Functions
# ===========================================================================

# Convert Unix-style library name to Windows
fn convert_library_name(lib: text) -> text:
    # -lfoo → foo.lib
    if lib.starts_with("-l"):
        return lib.substring(2) + ".lib"

    # libfoo.a → foo.lib
    if lib.starts_with("lib"):
        if lib.ends_with(".a"):
        val name = lib_substring(lib, 3, lib.len() - 2)
        return "{name}.lib"

    # foo.a → foo.lib
    if lib.ends_with(".a"):
        return lib.substring(0, lib.len() - 2) + ".lib"

    # Already .lib or other
    lib

# ===========================================================================
# Exports
# ===========================================================================

export MsvcConfig
export MsvcLinker
export LldLinkLinker
export WindowsLinkerType
export find_visual_studio
export find_link_exe
export is_msvc_available
export is_lld_link_available
export auto_detect_windows_linker
export get_linker_name
export convert_library_name
