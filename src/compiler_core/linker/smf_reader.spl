# SMF Reader - Simple Module Format file reading.
#
# This module provides SMF file reading capabilities using:
# - Rust FFI for binary parsing (performance-critical)
# - Simple for high-level logic and metadata interpretation
#
# The SmfReader implements the SmfReader trait from obj_taker.spl.

# note_sdn import removed - causes parse errors in runtime due to generics/multi-line fns
# Stub NoteSdnMetadata locally for type compatibility
use .obj_taker (SmfSymbol, SymbolType, SymbolBinding)
use .smf_enums (Platform, Arch, CompressionType)

# Stub for NoteSdnMetadata (real impl in monomorphize.note_sdn, compiled-only)
struct NoteSdnMetadata:
    empty: bool

fn stub_new_note_sdn() -> NoteSdnMetadata:
    NoteSdnMetadata(empty: true)

# ============================================================================
# Rust FFI Declarations
# ============================================================================
#
# These extern functions are implemented in src/rust/loader/src/smf/ffi.rs
# They handle low-level binary parsing for performance.

# SmfReaderFfi - Rust FFI handle for SMF file reading.
# extern class not parseable by runtime (generics in signatures).
# Stubs provided for runtime compatibility.
extern fn rt_smf_reader_open(path: text) -> i64
extern fn rt_smf_reader_read_header(handle: i64) -> i64
extern fn rt_smf_reader_read_section(handle: i64, index: i32) -> i64
extern fn rt_smf_reader_read_symbol_table(handle: i64) -> i64
extern fn rt_smf_reader_read_string_table(handle: i64) -> i64
extern fn rt_smf_reader_close(handle: i64) -> i64

# ============================================================================
# Raw Structures (from FFI)
# ============================================================================

struct SmfHeaderRaw:
    # Raw SMF header as returned from Rust FFI.
    magic: [u8]           # "SMF\0"
    version_major: u8
    version_minor: u8
    platform: u8
    arch: u8
    flags: u32
    compression: u8
    section_count: u32
    section_table_offset: u64
    symbol_table_offset: u64
    symbol_count: u32
    exported_count: u32
    entry_point: u64
    stub_size: u32
    smf_data_offset: u32
    module_hash: u64
    source_hash: u64
    app_type: u8

struct SmfSymbolRaw:
    # Raw symbol as returned from Rust FFI.
    name_offset: u32
    name_hash: u32
    sym_type: u8
    binding: u8
    visibility: u8
    flags: u8
    value: u64
    size: u64
    type_id: u32
    version: u32
    template_param_count: u8
    template_offset: u64

struct SmfSectionRaw:
    # Raw section as returned from Rust FFI.
    section_type: u8
    flags: u8
    offset: u64
    size: u64
    name: [u8]

# ============================================================================
# High-Level Structures
# ============================================================================

struct SmfHeader:
    # Parsed SMF header.
    val _tv_0 = [u8, u8]
    version: _tv_0     # (major, minor)
    platform: Platform
    arch: Arch
    flags: SmfFlags
    section_count: i32
    symbol_count: i32
    entry_point: i64
    has_templates: bool
    has_note_sdn: bool
    compression: CompressionType

struct SmfFlags:
    executable: bool
    reloadable: bool
    debug_info: bool
    pic: bool
    has_stub: bool


# ============================================================================
# SmfHeader Methods (was: impl SmfHeader:)
# ============================================================================

fn smfheader_from_raw(raw: SmfHeaderRaw) -> SmfHeader:
        # Convert raw header to parsed header.
        val has_tpl = (raw.flags and 0x10) != 0
        val has_sdn = (raw.flags and 0x20) != 0
        SmfHeader(
            val _tv_1 = [raw.version_major, raw.version_minor]
            version: _tv_1,
            platform: parse_platform(raw.platform),
            arch: parse_arch(raw.arch),
            flags: parse_flags(raw.flags),
            val _as_0 = raw.section_count as i32
            section_count: _as_0,
            val _as_1 = raw.symbol_count as i32
            symbol_count: _as_1,
            val _as_2 = raw.entry_point as i64
            entry_point: _as_2,
            has_templates: has_tpl,
            has_note_sdn: has_sdn,
            compression: parse_compression(raw.compression)
        )


# ============================================================================
# SMF Reader Implementation
# ============================================================================

struct SmfReaderImpl:
    # High-level SMF reader that implements SmfReader trait.
    ffi: SmfReaderFfi
    file_path: text
    header: SmfHeader
    symbols: Dict<text, SmfSymbol>
    string_table: [u8]
    sections: [SmfSectionRaw]
    # # DESUGARED: note_sdn_cache: NoteSdnMetadata
    has_note_sdn_cache: bool
    note_sdn_cache: NoteSdnMetadata


# ============================================================================
# SmfReaderImpl Methods (was: impl SmfReaderImpl:)
# ============================================================================

# ============================================================================
# Helper Functions
# ============================================================================

fn parse_platform(p: u8) -> Platform:
    platform_from_u8(p)

fn parse_arch(a: u8) -> Arch:
    arch_from_u8(a)

fn parse_compression(c: u8) -> CompressionType:
    compressiontype_from_u8(c)

fn parse_flags(f: u32) -> SmfFlags:
    val is_exec = (f and 0x01) != 0
    val is_reload = (f and 0x02) != 0
    val is_debug = (f and 0x04) != 0
    val is_pic = (f and 0x08) != 0
    val is_stub = (f and 0x10) != 0
    SmfFlags(
        executable: is_exec,
        reloadable: is_reload,
        debug_info: is_debug,
        pic: is_pic,
        has_stub: is_stub
    )

fn derive_section_index(sym_type: u8) -> i32:
    # Derive section index from symbol type.
    # Functions go in code section (0), data/constants in data section (1).
    match sym_type:
        case 0: 0  # Function -> code section
        case 1: 1  # Data -> data section
        case 5: 1  # Constant -> data section
        case _: 0  # Default to code section

fn parse_symbol_type(t: u8) -> SymbolType:
    match t:
        case 0: SymbolType.Function
        case 1: SymbolType.Data
        case 2: SymbolType.Type
        case 3: SymbolType.Trait
        case 4: SymbolType.ActorSymbol
        case 5: SymbolType.Constant
        case _: SymbolType.Unknown

fn parse_symbol_binding(b: u8) -> SymbolBinding:
    match b:
        case 0: SymbolBinding.Local
        case 1: SymbolBinding.Global
        case 2: SymbolBinding.Weak
        case _: SymbolBinding.Local

fn read_string_from_table(table: [u8], offset: u32) -> text:
    # Read null-terminated string from string table.
    var chars = []
    for i in (offset, )..table_len(table):
        if table[i] == 0:
            return chars.join("")
        chars_push(chars, char_from_byte(table[i]))
    chars.join("")

fn char_from_byte(b: u8) -> text:
    # Convert byte to single-character string using ASCII mapping
    val ascii_table = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
    val idx = (b, ) - 32
    if idx >= 0:
        if idx < ascii_table_len(ascii_table):
        ascii_table[idx:idx + 1]
    else:
        "?"  # Non-printable character

fn bytes_to_string(bytes: [u8]) -> text:
    # Convert byte array to string.
    var chars = []
    for b in bytes:
        if b == 0:
            return chars.join("")
        chars_push(chars, char_from_byte(b))
    chars.join("")

fn parse_note_sdn(sdn_text: text) -> NoteSdnMetadata:
    # Stub: returns empty metadata (real impl in compiled mode)
    stub_new_note_sdn()

# ============================================================================
# Exports
# ============================================================================

export SmfReaderImpl
export SmfReaderFfi
export SmfHeader
export SmfHeaderRaw
export SmfSymbolRaw
export SmfSectionRaw
export Platform
export Arch
export CompressionType
export SmfFlags
