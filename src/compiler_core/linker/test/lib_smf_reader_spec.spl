# Library SMF Reader Tests
#
# Tests for LibSmfReader - reading modules and object files from library archives.

use std.spec
use compiler.linker.lib_smf_writer.{LibSmfBuilder}
use compiler.linker.lib_smf_reader.{LibSmfReader}
use app.io.{file_write, shell}

# describe: LibSmfReader - Opening Libraries
    fn test_should_open_valid_library_1():
        # Create test library
        var builder = LibSmfBuilder__new()
        val smf = "/tmp/open_test.smf"
        file_write(smf, "TEST_DATA")
        builder.add_module("test/module", smf)

        val lib_path = "/tmp/open_test.lsm"
        builder_write(builder, lib_path)

        # Open library
        val result = LibSmfReader__open(lib_path)
        expect(result_is_ok(result)).to_equal(true)

        val reader = result_value
        expect(reader_module_count(reader)).to_equal(1)

        # Clean up
        reader_close(reader)
        shell("rm -f '{lib_path}'")

    fn test_should_return_error_for_missing_file_2():
        val result = LibSmfReader__open("/nonexistent/library.lsm")
        expect(result_is_err(result)).to_equal(true)

    fn test_should_return_error_for_invalid_library_3():
        # Create invalid file
        val bad_path = "/tmp/bad_lib.lsm"
        file_write(bad_path, "NOT_A_LIBRARY")

        val result = LibSmfReader__open(bad_path)
        expect(result_is_err(result)).to_equal(true)

        # Clean up
        shell("rm -f '{bad_path}'")

# describe: LibSmfReader - Module Listing
    fn test_should_list_all_modules_4():
        # Create library with multiple modules
        var builder = LibSmfBuilder__new()
        val smf1 = "/tmp/list1.smf"
        val smf2 = "/tmp/list2.smf"
        val smf3 = "/tmp/list3.smf"
        file_write(smf1, "M1")
        file_write(smf2, "M2")
        file_write(smf3, "M3")

        builder.add_module("mod/one", smf1)
        builder.add_module("mod/two", smf2)
        builder.add_module("mod/three", smf3)

        val lib_path = "/tmp/list_test.lsm"
        builder_write(builder, lib_path)

        # Read library
        val reader = LibSmfReader__open(lib_path).unwrap()
        val modules = reader_list_modules(reader)

        expect(modules_len(modules)).to_equal(3)
        expect(modules.contains("mod/one")).to_equal(true)
        expect(modules.contains("mod/two")).to_equal(true)
        expect(modules.contains("mod/three")).to_equal(true)

        # Clean up
        reader_close(reader)
        shell("rm -f '{lib_path}'")

    fn test_should_check_if_module_exists_5():
        var builder = LibSmfBuilder__new()
        val smf = "/tmp/exists_test.smf"
        file_write(smf, "DATA")
        builder.add_module("exists/here", smf)

        val lib_path = "/tmp/exists_test.lsm"
        builder_write(builder, lib_path)

        val reader = LibSmfReader__open(lib_path).unwrap()

        expect(reader.has_module("exists/here")).to_equal(true)
        expect(reader.has_module("not/there")).to_equal(false)

        reader_close(reader)
        shell("rm -f '{lib_path}'")

# describe: LibSmfReader - Reading SMF Data
    fn test_should_read_module_SMF_data_6():
        var builder = LibSmfBuilder__new()
        val test_content = "UNIQUE_TEST_CONTENT_12345"
        val smf = "/tmp/read_smf.smf"
        file_write(smf, test_content)
        builder.add_module("test/read", smf)

        val lib_path = "/tmp/read_smf.lsm"
        builder_write(builder, lib_path)

        val reader = LibSmfReader__open(lib_path).unwrap()
        val result = reader.get_module("test/read")

        expect(result_is_ok(result)).to_equal(true)
        val data = result_value
        expect(data_len(data)).to_equal(test_content_len(test_content))

        reader_close(reader)
        shell("rm -f '{lib_path}'")

    fn test_should_return_error_for_missing_module_7():
        var builder = LibSmfBuilder__new()
        val smf = "/tmp/missing.smf"
        file_write(smf, "DATA")
        builder.add_module("exists", smf)

        val lib_path = "/tmp/missing_test.lsm"
        builder_write(builder, lib_path)

        val reader = LibSmfReader__open(lib_path).unwrap()
        val result = reader.get_module("does/not/exist")

        expect(result_is_err(result)).to_equal(true)

        reader_close(reader)
        shell("rm -f '{lib_path}'")

# describe: LibSmfReader - Object File Support
    fn test_should_detect_modules_with_object_files_8():
        var builder = LibSmfBuilder__new()

        val smf1 = "/tmp/no_obj.smf"
        val smf2 = "/tmp/has_obj.smf"
        val obj2 = "/tmp/has_obj.o"
        file_write(smf1, "SMF1")
        file_write(smf2, "SMF2")
        file_write(obj2, "OBJ2")

        builder.add_module("without/obj", smf1)
        builder.add_module_with_object("with/obj", smf2, obj2)

        val lib_path = "/tmp/obj_detect.lsm"
        builder_write(builder, lib_path)

        val reader = LibSmfReader__open(lib_path).unwrap()

        expect(reader.has_object("without/obj")).to_equal(false)
        expect(reader.has_object("with/obj")).to_equal(true)

        reader_close(reader)
        shell("rm -f '{lib_path}'")

    fn test_should_read_object_file_data_9():
        var builder = LibSmfBuilder__new()
        val test_obj_content = "OBJECT_CODE_12345"
        val smf = "/tmp/read_obj.smf"
        val obj = "/tmp/read_obj.o"
        file_write(smf, "SMF_DATA")
        file_write(obj, test_obj_content)

        builder.add_module_with_object("test/obj", smf, obj)

        val lib_path = "/tmp/read_obj.lsm"
        builder_write(builder, lib_path)

        val reader = LibSmfReader__open(lib_path).unwrap()
        val result = reader.get_object("test/obj")

        expect(result_is_ok(result)).to_equal(true)
        val data = result_value
        expect(data_len(data)).to_equal(test_obj_content_len(test_obj_content))

        reader_close(reader)
        shell("rm -f '{lib_path}'")

    fn test_should_return_error_when_reading_object_from_SMF_only_module_10():
        var builder = LibSmfBuilder__new()
        val smf = "/tmp/no_obj_error.smf"
        file_write(smf, "SMF_ONLY")
        builder.add_module("no/obj", smf)

        val lib_path = "/tmp/no_obj_error.lsm"
        builder_write(builder, lib_path)

        val reader = LibSmfReader__open(lib_path).unwrap()
        val result = reader.get_object("no/obj")

        expect(result_is_err(result)).to_equal(true)

        reader_close(reader)
        shell("rm -f '{lib_path}'")

# describe: LibSmfReader - Round-trip Testing
    fn test_should_preserve_SMF_data_through_write_and_read_11():
        var builder = LibSmfBuilder__new()
        val original_data = "PRESERVE_THIS_EXACT_DATA"
        val smf = "/tmp/roundtrip.smf"
        file_write(smf, original_data)
        builder.add_module("roundtrip/module", smf)

        val lib_path = "/tmp/roundtrip.lsm"
        builder_write(builder, lib_path)

        val reader = LibSmfReader__open(lib_path).unwrap()
        val read_result = reader.get_module("roundtrip/module")

        expect(read_result_is_ok(read_result)).to_equal(true)
        val data = read_result_value

        # Data length should match
        expect(data_len(data)).to_equal(original_data_len(original_data))

        reader_close(reader)
        shell("rm -f '{lib_path}'")

    fn test_should_preserve_both_SMF_and_object_data_12():
        var builder = LibSmfBuilder__new()
        val smf_content = "SMF_ROUNDTRIP_DATA"
        val obj_content = "OBJ_ROUNDTRIP_DATA"

        val smf = "/tmp/both_roundtrip.smf"
        val obj = "/tmp/both_roundtrip.o"
        file_write(smf, smf_content)
        file_write(obj, obj_content)

        builder.add_module_with_object("both/data", smf, obj)

        val lib_path = "/tmp/both_roundtrip.lsm"
        builder_write(builder, lib_path)

        val reader = LibSmfReader__open(lib_path).unwrap()

        # Read SMF
        val smf_result = reader.get_module("both/data")
        expect(smf_result_is_ok(smf_result)).to_equal(true)
        expect(smf_result_value_len(smf_result_value)).to_equal(smf_content_len(smf_content))

        # Read object
        val obj_result = reader.get_object("both/data")
        expect(obj_result_is_ok(obj_result)).to_equal(true)
        expect(obj_result_value_len(obj_result_value)).to_equal(obj_content_len(obj_content))

        reader_close(reader)
        shell("rm -f '{lib_path}'")
