# Library SMF Format Tests
#
# Tests for the extended library SMF format with object file support.
# Covers ModuleIndexEntry serialization, deserialization, and backward compatibility.

use std.spec
use compiler.linker.lib_smf.{ModuleIndexEntry, LibSmfHeader, fnv1a_hash}

# describe: ModuleIndexEntry
    fn test_should_create_entry_without_object_file_1():
        val entry = ModuleIndexEntry.new("test/module", 128, 1024, 12345)

        expect(entry.get_name()).to_equal("test/module")
        val _asv_0 = entry.offset as i64
        expect(_asv_0).to_equal(128)
        val _asv_1 = entry.size as i64
        expect(_asv_1).to_equal(1024)
        val _asv_2 = entry.hash as i64
        expect(_asv_2).to_equal(12345)
        expect(entry_has_object(entry)).to_equal(false)
        val _asv_3 = entry.obj_size as i64
        expect(_asv_3).to_equal(0)

    fn test_should_create_entry_with_object_file_2():
        val entry = ModuleIndexEntry.new_with_object(
            "std/io/mod",
            1000,      # SMF offset
            2000,      # SMF size
            111111,    # SMF hash
            3000,      # Object offset
            500,       # Object size
            222222     # Object hash
        )

        expect(entry.get_name()).to_equal("std/io/mod")
        val _asv_4 = entry.offset as i64
        expect(_asv_4).to_equal(1000)
        val _asv_5 = entry.size as i64
        expect(_asv_5).to_equal(2000)
        val _asv_6 = entry.hash as i64
        expect(_asv_6).to_equal(111111)
        expect(entry_has_object(entry)).to_equal(true)
        val _asv_7 = entry.obj_offset as i64
        expect(_asv_7).to_equal(3000)
        val _asv_8 = entry.obj_size as i64
        expect(_asv_8).to_equal(500)
        val _asv_9 = entry.obj_hash as i64
        expect(_asv_9).to_equal(222222)

    fn test_should_serialize_entry_to_exactly_128_bytes_3():
        val entry = ModuleIndexEntry.new_with_object(
            "test/module", 100, 200, 111, 300, 50, 222
        )
        val bytes = entry_to_bytes(entry)

        expect(bytes_len(bytes)).to_equal(128)

    fn test_should_serialize_and_deserialize_entry_without_object_4():
        val original = ModuleIndexEntry.new("my/module", 500, 1500, 99999)
        val bytes = original_to_bytes(original)
        val result = moduleindexentry_from_bytes(bytes, 0)

        expect(result_is_ok(result)).to_equal(true)
        val restored = result_value

        expect(restored.get_name()).to_equal("my/module")
        val _asv_10 = restored.offset as i64
        expect(_asv_10).to_equal(500)
        val _asv_11 = restored.size as i64
        expect(_asv_11).to_equal(1500)
        val _asv_12 = restored.hash as i64
        expect(_asv_12).to_equal(99999)
        expect(restored_has_object(restored)).to_equal(false)

    fn test_should_serialize_and_deserialize_entry_with_object_5():
        val original = ModuleIndexEntry.new_with_object(
            "std/string", 1000, 2000, 111, 3000, 500, 222
        )
        val bytes = original_to_bytes(original)
        val result = moduleindexentry_from_bytes(bytes, 0)

        expect(result_is_ok(result)).to_equal(true)
        val restored = result_value

        expect(restored.get_name()).to_equal("std/string")
        val _asv_13 = restored.offset as i64
        expect(_asv_13).to_equal(1000)
        val _asv_14 = restored.size as i64
        expect(_asv_14).to_equal(2000)
        val _asv_15 = restored.hash as i64
        expect(_asv_15).to_equal(111)
        expect(restored_has_object(restored)).to_equal(true)
        val _asv_16 = restored.obj_offset as i64
        expect(_asv_16).to_equal(3000)
        val _asv_17 = restored.obj_size as i64
        expect(_asv_17).to_equal(500)
        val _asv_18 = restored.obj_hash as i64
        expect(_asv_18).to_equal(222)

    fn test_should_handle_module_names_up_to_63_characters_6():
        val long_name = "a/very/long/module/path/that/goes/on/and/on/and/reaches/limit"
        val entry = moduleindexentry_new(long_name, 100, 200, 12345)
        val bytes = entry_to_bytes(entry)
        val result = moduleindexentry_from_bytes(bytes, 0)

        expect(result_is_ok(result)).to_equal(true)
        val restored = result_value
        expect(restored_get_name(restored)).to_equal(long_name)

    fn test_should_return_error_for_invalid_entry_size_7():
        var short_bytes: [u8] = []
        var i = 0
        while i < 100:
            short_bytes_push(short_bytes, 0)
            i = i + 1

        val result = moduleindexentry_from_bytes(short_bytes, 0)
        expect(result_is_err(result)).to_equal(true)

# describe: LibSmfHeader
    fn test_should_create_valid_default_header_8():
        val header = libsmfheader_new_default()

        expect(header_is_valid(header)).to_equal(true)
        val _asv_19 = header.module_count as i64
        expect(_asv_19).to_equal(0)
        val _asv_20 = header.index_offset as i64
        expect(_asv_20).to_equal(128)

    fn test_should_serialize_header_to_exactly_128_bytes_9():
        val header = libsmfheader_new_default()
        val bytes = header_to_bytes(header)

        expect(bytes_len(bytes)).to_equal(128)

    fn test_should_serialize_and_deserialize_header_10():
        var header = libsmfheader_new_default()
        header.module_count = 42
        header.library_hash = 999999

        val bytes = header_to_bytes(header)
        val result = libsmfheader_from_bytes(bytes)

        expect(result_is_ok(result)).to_equal(true)
        val restored = result_value

        expect(restored_is_valid(restored)).to_equal(true)
        val _asv_21 = restored.module_count as i64
        expect(_asv_21).to_equal(42)
        val _asv_22 = restored.library_hash as i64
        expect(_asv_22).to_equal(999999)

    fn test_should_validate_magic_number_11():
        var header = libsmfheader_new_default()
        val bytes = header_to_bytes(header)

        # Corrupt magic
        var bad_bytes = bytes
        bad_bytes[0] = 99

        val result = libsmfheader_from_bytes(bad_bytes)
        expect(result_is_err(result)).to_equal(true)

    fn test_should_return_error_for_too_small_header_12():
        var small_bytes: [u8] = []
        var i = 0
        while i < 50:
            small_bytes_push(small_bytes, 0)
            i = i + 1

        val result = libsmfheader_from_bytes(small_bytes)
        expect(result_is_err(result)).to_equal(true)

# describe: fnv1a_hash
    fn test_should_produce_consistent_hashes_13():
        val data1 = [1, 2, 3, 4, 5]
        val data2 = [1, 2, 3, 4, 5]

        val hash1 = fnv1a_hash(data1)
        val hash2 = fnv1a_hash(data2)

        expect(hash1).to_equal(hash2)

    fn test_should_produce_different_hashes_for_different_data_14():
        val data1 = [1, 2, 3, 4, 5]
        val data2 = [5, 4, 3, 2, 1]

        val hash1 = fnv1a_hash(data1)
        val hash2 = fnv1a_hash(data2)

        expect(hash1 != hash2).to_equal(true)

    fn test_should_handle_empty_data_15():
        val empty: [u8] = []
        val hash = fnv1a_hash(empty)

        # FNV-1a offset basis (non-zero for empty input)
        expect(hash > 0).to_equal(true)
