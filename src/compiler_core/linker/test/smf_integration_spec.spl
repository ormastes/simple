# SMF Integration Specification
#
# Integration tests for SMF components:
# - Round-trip serialization/deserialization
# - Enum preservation through serialization
# - Byte layout verification

use ..smf_header.*
use ..smf_enums.*
use testing.{describe, it, expect}

describe "SMF round-trip serialization":
    it "preserves all header fields through serialization":
        # Create a header with various settings
        var header1 = smfheader_new_v1_1(Platform.Linux, Arch.X86_64)
        header1_set_executable(header1, true)
        header1_set_reloadable(header1, true)
        header1.section_count = 5
        header1.section_table_offset = 256
        header1.symbol_table_offset = 512
        header1.symbol_count = 10
        header1.exported_count = 3
        header1.entry_point = 0x1000
        header1_set_compression(header1, CompressionType.Zstd, 3)
        header1_set_stub_info(header1, 1024, 1024)
        header1.module_hash = 0x123456789ABCDEF0
        header1.source_hash = 0x7EDCBA9876543210
        header1_set_app_type(header1, SmfAppType.Tui)
        header1_set_window_hints(header1, 1024, 768)
        header1_set_prefetch_hint(header1, true, 8)

        # Serialize to bytes
        val bytes = header1_to_bytes(header1)
        expect(bytes_len(bytes) == 128)

        # For now, we can at least verify the serialization produces
        # the correct size and magic number
        expect(bytes[0] == 83)   # 'S'
        expect(bytes[1] == 77)   # 'M'
        expect(bytes[2] == 70)   # 'F'
        expect(bytes[3] == 0)    # '\0'

describe "Enum preservation":
    it "preserves Platform enum through u8 conversion":
        val platforms = [
            Platform.Any,
            Platform.Linux,
            Platform.Windows,
            Platform.MacOS,
            Platform.FreeBSD,
            Platform.None_
        ]

        for platform in platforms:
            val u8_val = platform_to_u8(platform)
            val restored = platform_from_u8(u8_val)
            expect(restored == platform)

    it "preserves Arch enum through u8 conversion":
        val arches = [
            Arch.X86_64,
            Arch.Aarch64,
            Arch.X86,
            Arch.Arm,
            Arch.Riscv64,
            Arch.Riscv32,
            Arch.Wasm32,
            Arch.Wasm64
        ]

        for arch in arches:
            val u8_val = arch_to_u8(arch)
            val restored = arch_from_u8(u8_val)
            expect(restored == arch)

    it "preserves CompressionType enum through u8 conversion":
        val compressions = [
            CompressionType.None_,
            CompressionType.Zstd,
            CompressionType.Lz4
        ]

        for compression in compressions:
            val u8_val = compression_to_u8(compression)
            val restored = compressiontype_from_u8(u8_val)
            expect(restored == compression)

    it "preserves SmfAppType enum through u8 conversion":
        val app_types = [
            SmfAppType.Cli,
            SmfAppType.Tui,
            SmfAppType.Gui,
            SmfAppType.Service,
            SmfAppType.Repl
        ]

        for app_type in app_types:
            val u8_val = app_type_to_u8(app_type)
            val restored = smfapptype_from_u8(u8_val)
            expect(restored == app_type)

describe "Byte layout verification":
    it "verifies header structure is exactly 128 bytes":
        val header = smfheader_new_v1_1(Platform.Linux, Arch.X86_64)
        val bytes = header_to_bytes(header)

        # Total must be exactly 128 bytes
        expect(bytes_len(bytes) == SMF_HEADER_SIZE)

    it "verifies magic number is at correct position":
        val header = smfheader_new_v1_1(Platform.Linux, Arch.X86_64)
        val bytes = header_to_bytes(header)

        # Magic at bytes 0-3
        expect(bytes[0] == 83)   # 'S'
        expect(bytes[1] == 77)   # 'M'
        expect(bytes[2] == 70)   # 'F'
        expect(bytes[3] == 0)    # '\0'

    it "verifies version fields are at correct positions":
        val header = smfheader_new_v1_1(Platform.Linux, Arch.X86_64)
        val bytes = header_to_bytes(header)

        # Version at bytes 4-5
        expect(bytes[4] == 1)    # major
        expect(bytes[5] == 1)    # minor

    it "verifies platform and arch are at correct positions":
        val header = smfheader_new_v1_1(Platform.Windows, Arch.Aarch64)
        val bytes = header_to_bytes(header)

        # Platform at byte 6, arch at byte 7
        expect(bytes[6] == Platform.windows_to_u8())
        expect(bytes[7] == Arch.aarch64_to_u8())

describe "Header with different configurations":
    it "creates minimal header (no flags, no compression)":
        val header = smfheader_new_v1_1(Platform.Any, Arch.X86_64)
        val bytes = header_to_bytes(header)

        expect(bytes_len(bytes) == 128)
        expect(not header_is_executable(header))
        expect(not header_is_compressed(header))
        expect(not header_has_stub(header))

    it "creates full-featured header":
        var header = smfheader_new_v1_1(Platform.Linux, Arch.X86_64)
        header_set_executable(header, true)
        header_set_reloadable(header, true)
        header_set_debug_info(header, true)
        header_set_pic(header, true)
        header_set_compression(header, CompressionType.Zstd, 5)
        header_set_stub_info(header, 4096, 4096)
        header_set_app_type(header, SmfAppType.Gui)
        header_set_window_hints(header, 1920, 1080)
        header_set_prefetch_hint(header, true, 20)

        val bytes = header_to_bytes(header)
        expect(bytes_len(bytes) == 128)
        expect(header_is_executable(header))
        expect(header_is_reloadable(header))
        expect(header_has_debug_info(header))
        expect(header_is_pic(header))
        expect(header_is_compressed(header))
        expect(header_has_stub(header))
