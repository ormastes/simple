# SMF Integration Specification
#
# Integration tests for SMF components:
# - Round-trip serialization/deserialization
# - Enum preservation through serialization
# - Byte layout verification

use ..smf_header.*
use ..smf_enums.*
use testing.{describe, it, expect}

# describe: SMF round-trip serialization
    fn test_preserves_all_header_fields_through_serialization_1():
        # Create a header with various settings
        var header1 = smfheader_new_v1_1(Platform.Linux, Arch.X86_64)
        header1_set_executable(header1, true)
        header1_set_reloadable(header1, true)
        header1.section_count = 5
        header1.section_table_offset = 256
        header1.symbol_table_offset = 512
        header1.symbol_count = 10
        header1.exported_count = 3
        header1.entry_point = 0x1000
        header1_set_compression(header1, CompressionType.Zstd, 3)
        header1_set_stub_info(header1, 1024, 1024)
        header1.module_hash = 0x123456789ABCDEF0
        header1.source_hash = 0x7EDCBA9876543210
        header1_set_app_type(header1, SmfAppType.Tui)
        header1_set_window_hints(header1, 1024, 768)
        header1_set_prefetch_hint(header1, true, 8)

        # Serialize to bytes
        val bytes = header1_to_bytes(header1)
        expect(bytes_len(bytes) == 128)

        # For now, we can at least verify the serialization produces
        # the correct size and magic number
        expect(bytes[0] == 83)   # 'S'
        expect(bytes[1] == 77)   # 'M'
        expect(bytes[2] == 70)   # 'F'
        expect(bytes[3] == 0)    # '\0'

# describe: Enum preservation
    fn test_preserves_Platform_enum_through_u8_conversion_2():
        val platforms = [
            Platform.Any,
            Platform.Linux,
            Platform.Windows,
            Platform.MacOS,
            Platform.FreeBSD,
            Platform.None_
        ]

        for platform in platforms:
            val u8_val = platform_to_u8(platform)
            val restored = platform_from_u8(u8_val)
            expect(restored == platform)

    fn test_preserves_Arch_enum_through_u8_conversion_3():
        val arches = [
            Arch.X86_64,
            Arch.Aarch64,
            Arch.X86,
            Arch.Arm,
            Arch.Riscv64,
            Arch.Riscv32,
            Arch.Wasm32,
            Arch.Wasm64
        ]

        for arch in arches:
            val u8_val = arch_to_u8(arch)
            val restored = arch_from_u8(u8_val)
            expect(restored == arch)

    fn test_preserves_CompressionType_enum_through_u8_conversion_4():
        val compressions = [
            CompressionType.None_,
            CompressionType.Zstd,
            CompressionType.Lz4
        ]

        for compression in compressions:
            val u8_val = compression_to_u8(compression)
            val restored = compressiontype_from_u8(u8_val)
            expect(restored == compression)

    fn test_preserves_SmfAppType_enum_through_u8_conversion_5():
        val app_types = [
            SmfAppType.Cli,
            SmfAppType.Tui,
            SmfAppType.Gui,
            SmfAppType.Service,
            SmfAppType.Repl
        ]

        for app_type in app_types:
            val u8_val = app_type_to_u8(app_type)
            val restored = smfapptype_from_u8(u8_val)
            expect(restored == app_type)

# describe: Byte layout verification
    fn test_verifies_header_structure_is_exactly_128_bytes_6():
        val header = smfheader_new_v1_1(Platform.Linux, Arch.X86_64)
        val bytes = header_to_bytes(header)

        # Total must be exactly 128 bytes
        expect(bytes_len(bytes) == SMF_HEADER_SIZE)

    fn test_verifies_magic_number_is_at_correct_position_7():
        val header = smfheader_new_v1_1(Platform.Linux, Arch.X86_64)
        val bytes = header_to_bytes(header)

        # Magic at bytes 0-3
        expect(bytes[0] == 83)   # 'S'
        expect(bytes[1] == 77)   # 'M'
        expect(bytes[2] == 70)   # 'F'
        expect(bytes[3] == 0)    # '\0'

    fn test_verifies_version_fields_are_at_correct_positions_8():
        val header = smfheader_new_v1_1(Platform.Linux, Arch.X86_64)
        val bytes = header_to_bytes(header)

        # Version at bytes 4-5
        expect(bytes[4] == 1)    # major
        expect(bytes[5] == 1)    # minor

    fn test_verifies_platform_and_arch_are_at_correct_positions_9():
        val header = smfheader_new_v1_1(Platform.Windows, Arch.Aarch64)
        val bytes = header_to_bytes(header)

        # Platform at byte 6, arch at byte 7
        expect(bytes[6] == Platform.windows_to_u8())
        expect(bytes[7] == Arch.aarch64_to_u8())

# describe: Header with different configurations
    fn test_creates_minimal_header__no_flags__no_compression__10():
        val header = smfheader_new_v1_1(Platform.Any, Arch.X86_64)
        val bytes = header_to_bytes(header)

        expect(bytes_len(bytes) == 128)
        expect(not header_is_executable(header))
        expect(not header_is_compressed(header))
        expect(not header_has_stub(header))

    fn test_creates_full_featured_header_11():
        var header = smfheader_new_v1_1(Platform.Linux, Arch.X86_64)
        header_set_executable(header, true)
        header_set_reloadable(header, true)
        header_set_debug_info(header, true)
        header_set_pic(header, true)
        header_set_compression(header, CompressionType.Zstd, 5)
        header_set_stub_info(header, 4096, 4096)
        header_set_app_type(header, SmfAppType.Gui)
        header_set_window_hints(header, 1920, 1080)
        header_set_prefetch_hint(header, true, 20)

        val bytes = header_to_bytes(header)
        expect(bytes_len(bytes) == 128)
        expect(header_is_executable(header))
        expect(header_is_reloadable(header))
        expect(header_has_debug_info(header))
        expect(header_is_pic(header))
        expect(header_is_compressed(header))
        expect(header_has_stub(header))
