# Lazy instantiation at link-time.
#
# This module handles on-demand instantiation of generic templates
# when resolving missing symbols during linking.
#
# Phase 4: Link-Time Lazy Instantiation

use ..monomorphize.note_sdn.*
use ..compilation_context.{GenericTemplate, ConcreteType}
use ..instantiation.{TemplateInstantiator, mangle}
use linker_context.LinkerCompilationContext

# ============================================================================
# Result Types
# ============================================================================

enum LazyInstantiationResult:
    """Result of lazy instantiation attempt."""
    Success(code: [u8], symbol: text, metadata: NoteSdnMetadata)
    NotFound(symbol: text)
    CircularDependency(cycle: [text])
    Deferred(symbol: text)
    Error(message: text)


# ============================================================================
# LazyInstantiationResult Methods (was: impl LazyInstantiationResult:)
# ============================================================================

# ============================================================================
# Configuration
# ============================================================================

struct LazyInstantiatorConfig:
    """Configuration for lazy instantiation."""
    allow_defer: bool
    max_depth: i32
    verbose: bool


# ============================================================================
# LazyInstantiatorConfig Methods (was: impl LazyInstantiatorConfig:)
# ============================================================================

fn lazyinstantiatorconfig_default() -> LazyInstantiatorConfig:
        LazyInstantiatorConfig(
            allow_defer: true,
            max_depth: 100,
            verbose: false
        )


# ============================================================================
# Lazy Instantiator
# ============================================================================

struct LazyInstantiator:
    """Lazy instantiator for link-time instantiation."""
    config: LazyInstantiatorConfig
    input_metadata: Dict<text, NoteSdnMetadata>
    output_metadata: NoteSdnMetadata
    in_progress: Set<text>
    depth: i32
    instantiated: Dict<text, [u8]>


# ============================================================================
# LazyInstantiator Methods (was: impl LazyInstantiator:)
# ============================================================================

fn lazyinstantiator_new(config: LazyInstantiatorConfig) -> LazyInstantiator:
        """Create a new lazy instantiator."""
        LazyInstantiator(
            config: config,
            input_metadata: {},
            output_metadata: notesdnmetadata_new(),
            in_progress: {},
            depth: 0,
            instantiated: {}
        )


fn lazyinstantiator_try_instantiate(self: LazyInstantiator, symbol: text) -> LazyInstantiationResult:
        """Try to instantiate a missing symbol."""
        # Check depth limit
        if self.depth >= self.config.max_depth:
            return LazyInstantiationResult.Error(
                "Maximum instantiation depth ({self.config.max_depth}) exceeded"
            )

        # Check if already instantiated
        if self.instantiated_contains_key(instantiated, symbol):
            return LazyInstantiationResult.Success(
                code: self.instantiated[symbol],
                symbol: symbol,
                metadata: self.output_metadata
            )

        # Check for cycle
        if self.in_progress_contains(in_progress, symbol):
            val cycle = self.in_progress_to_list(in_progress)
            return lazyinstantiationresult_CircularDependency(cycle)

        # Find possible entry
        val found = self.find_possible(symbol)
        if not has_found:
            return lazyinstantiationresult_NotFound(symbol)

        val (source_path, entry) = found_value

        # Check if can defer
        if entry.can_defer and self.config.allow_defer:
            return lazyinstantiationresult_Deferred(symbol)

        # Start instantiation
        self.in_progress = self.in_progress_insert(in_progress, symbol)
        self.depth = self.depth + 1

        if self.config.verbose:
            print "[lazy-inst] Instantiating {symbol} from {source_path}"

        # Perform instantiation
        val result = self.do_instantiate(entry, source_path)

        # Cleanup
        self.in_progress = self.in_progress_remove(in_progress, symbol)
        self.depth = self.depth - 1

        result


fn lazyinstantiator_do_instantiate(self: LazyInstantiator, entry: PossibleInstantiationEntry, source_path: text) -> LazyInstantiationResult:
        """Perform the actual instantiation through unified CompilationContext pipeline."""
        # Create instantiation entry for metadata tracking
        val inst_entry = InstantiationEntry(
            template_name: entry.template_name,
            type_args: entry.type_args,
            mangled_name: entry.mangled_name,
            from_file: source_path,
            from_loc: "{source_path}:0:0",
            to_obj: "link_output.o",
            status: InstantiationStatus.Compiled
        )

        # Add to output metadata
        self.output_metadata = self.output_metadata_add_instantiation(output_metadata, inst_entry)

        # Add dependency edge
        val dep = DependencyEdge(
            from_inst: entry.required_by,
            to_inst: entry.mangled_name,
            dep_kind: DependencyKind.TypeParam
        )
        self.output_metadata = self.output_metadata_add_dependency(output_metadata, dep)

        # Build linker compilation context from input metadata
        # Loading actual templates from input SMF TemplateCode sections not yet implemented
        # Stub: construct a placeholder template from metadata
        eprint("Warning: loading templates from SMF TemplateCode sections not yet implemented; using placeholder for {entry.template_name}")
        var object_templates: Dict<text, GenericTemplate> = {}
        object_templates[entry.template_name] = GenericTemplate(
            name: entry.template_name,
            type_params: entry.type_args.split(",").map(\s: s.trim()),
            has_ast_data: false,  # DESUGARED: ast_data: nil
        )

        val linker_ctx = linkercompilationcontext_from_objects(object_templates, nil, nil)
        var instantiator = TemplateInstantiator(
            context: linker_ctx,
            in_progress: {},
            cache: {}
        )

        # Parse type args from the entry
        val type_args = entry.type_args.split(",").map(\s: ConcreteType(name: s.trim()))

        # Compile through unified pipeline
        match instantiator_instantiate(instantiator, entry.template_name, type_args):
            case Ok(unit):
                val compiled_code = unit.code
                self.instantiated[entry.mangled_name] = compiled_code

                LazyInstantiationResult.Success(
                    code: compiled_code,
                    symbol: entry.mangled_name,
                    metadata: self.output_metadata
                )

            case Err(msg):
                lazyinstantiationresult_Error(msg)


# ============================================================================
# Statistics
# ============================================================================

struct LazyInstantiationStats:
    """Statistics from lazy instantiation."""
    instantiated: i32
    deferred: i32
    not_found: i32
    errors: i32


# ============================================================================
# LazyInstantiationStats Methods (was: impl LazyInstantiationStats:)
# ============================================================================

fn lazyinstantiationstats_default() -> LazyInstantiationStats:
        LazyInstantiationStats(
            instantiated: 0,
            deferred: 0,
            not_found: 0,
            errors: 0
        )


fn lazyinstantiationstats_from_results(results: [LazyInstantiationResult]) -> LazyInstantiationStats:
        var stats = lazyinstantiationstats_default()

        for result in results:
            match result:
                case Success(_, _, _):
                    stats.instantiated = stats.instantiated + 1
                case Deferred(_):
                    stats.deferred = stats.deferred + 1
                case NotFound(_):
                    stats.not_found = stats.not_found + 1
                case Error(_):
                    stats.errors = stats.errors + 1
                case CircularDependency(_):
                    stats.errors = stats.errors + 1

        stats


# ============================================================================
# Exports
# ============================================================================

export LazyInstantiationResult
export LazyInstantiatorConfig
export LazyInstantiator
export LazyInstantiationStats
