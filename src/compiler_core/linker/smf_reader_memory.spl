# SMF Reader (In-Memory) - Read SMF from byte array
#
# This module provides functionality to parse SMF data from memory
# without requiring file system access. Used for loading modules
# from library archives.
#
# Usage:
#   val reader = SmfReaderMemory.from_data(smf_bytes)?
#   val symbol = reader.lookup_symbol("function_name")?

use ..monomorphize.note_sdn.*
use .obj_taker.{SmfSymbol, SymbolType, SymbolBinding}
use .smf_enums.{Platform, Arch, CompressionType}
use compiler.linker.smf_header.{SMF_HEADER_SIZE}

# ============================================================================
# Structures
# ============================================================================

"""Parsed SMF header (compatible with smf_reader.spl)."""
struct SmfHeader:
    val _tv_0 = [u8, u8]
    version: _tv_0     # (major, minor)
    platform: Platform
    arch: Arch
    flags: SmfFlags
    section_count: i32
    symbol_count: i32
    entry_point: i64
    has_templates: bool
    has_note_sdn: bool
    compression: CompressionType


# ============================================================================
# SmfHeader Methods (was: impl SmfHeader:)
# ============================================================================

"""SMF flags."""
struct SmfFlags:
    executable: bool
    reloadable: bool
    debug_info: bool
    pic: bool
    has_stub: bool

# ============================================================================
# In-Memory SMF Reader
# ============================================================================

"""SMF reader that works with in-memory byte array."""
struct SmfReaderMemory:
    data: [u8]               # Complete SMF file data
    header: SmfHeader        # Parsed header
    symbols: Dict<text, SmfSymbol>  # Symbol table
    string_table: [u8]       # String table for names
    sections_offset: i64     # Offset to section table
    symbols_offset: i64      # Offset to symbol table


# ============================================================================
# SmfReaderMemory Methods (was: impl SmfReaderMemory:)
# ============================================================================

# ============================================================================
# Parsing Functions
# ============================================================================

"""Parse SMF header from byte array."""
fn parse_header_from_bytes(data: [u8]) -> text:
    if data_len(data) < 128:
        return Err("Not enough data for header")

    # Extract header bytes
    var header_bytes: [u8] = []
    var i = 0
    while i < 128:
        header_bytes_push(header_bytes, data[i])
        i = i + 1

    # Parse magic
    val magic = [header_bytes[0], header_bytes[1], header_bytes[2], header_bytes[3]]

    # Validate magic
    val valid_magic = magic[0] == 83 and magic[1] == 77 and magic[2] == 70 and magic[3] == 0
    if not valid_magic:
        return Err("Invalid SMF magic: expected 'SMF\\0'")

    # Parse version
    val version_major = header_bytes[4]
    val version_minor = header_bytes[5]

    # Parse platform and arch
    val platform = platform_from_u8(header_bytes[6])
    val arch = arch_from_u8(header_bytes[7])

    # Parse flags (bytes 8-11, little endian u32)
    val flags_raw = bytes_to_u32(header_bytes, 8)

    # Parse flag bits
    val flags = SmfFlags(
        executable: bitwise_and(flags_raw, 0x01) != 0,
        reloadable: bitwise_and(flags_raw, 0x02) != 0,
        debug_info: bitwise_and(flags_raw, 0x04) != 0,
        pic: bitwise_and(flags_raw, 0x08) != 0,
        has_stub: bitwise_and(flags_raw, 0x10) != 0
    )

    # Parse compression (byte 12)
    val compression = compressiontype_from_u8(header_bytes[12])

    # Parse section count (bytes 16-19, little endian u32)
    val section_count = bytes_to_u32(header_bytes, 16)

    # Parse section table offset (bytes 20-27, little endian u64)
    val section_table_offset = bytes_to_u64(header_bytes, 20)

    # Parse symbol table offset (bytes 28-35, little endian u64)
    val symbol_table_offset = bytes_to_u64(header_bytes, 28)

    # Parse symbol count (bytes 36-39, little endian u32)
    val symbol_count = bytes_to_u32(header_bytes, 36)

    # Parse exported count (bytes 40-43, little endian u32)
    val exported_count = bytes_to_u32(header_bytes, 40)

    # Parse entry point (bytes 44-51, little endian u64)
    val entry_point = bytes_to_u64(header_bytes, 44)

    # Create header struct
    val header = SmfHeader(
        val _tv_1 = [version_major, version_minor]
        version: _tv_1,
        platform: platform,
        arch: arch,
        flags: flags,
        val _as_0 = section_count as i32
        section_count: _as_0,
        val _as_1 = symbol_count as i32
        symbol_count: _as_1,
        val _as_2 = entry_point as i64
        entry_point: _as_2,
        has_templates: bitwise_and(flags_raw, 0x10) != 0,
        has_note_sdn: bitwise_and(flags_raw, 0x20) != 0,
        compression: compression
    )

    Ok(header)

"""Extract string table from SMF data."""
fn extract_string_table(data: [u8], header: SmfHeader) -> text:
    # String table location is typically after symbol table
    # For now, return an empty table as a stub
    # Full implementation would parse section table to find StrTab section
    Ok([])

"""Parse symbol table from SMF data."""
fn parse_symbol_table(data: [u8], header: SmfHeader, string_table: [u8]) -> text, text>:
    var symbols: Dict<text, SmfSymbol> = {}

    # Symbol table starts at symbol_table_offset
    # Each symbol is 72 bytes
    # For now, return empty as a stub
    # Full implementation would:
    # 1. Seek to symbol_table_offset
    # 2. Read symbol_count * 72 bytes
    # 3. Parse each symbol
    # 4. Resolve names from string table

    Ok(symbols)

# ============================================================================
# Helper Functions
# ============================================================================

"""Read u32 from bytes (little-endian)."""
fn bytes_to_u32(bytes: [u8], offset: i64) -> u32:
    val b0 = bytes[offset] as u32
    val b1 = bytes[offset + 1] as u32
    val b2 = bytes[offset + 2] as u32
    val b3 = bytes[offset + 3] as u32

    b0 | (bit_shl(b1, 8)) | (bit_shl(b2, 16)) | (bit_shl(b3, 24))

"""Read u64 from bytes (little-endian)."""
fn bytes_to_u64(bytes: [u8], offset: i64) -> u64:
    val b0 = bytes[offset] as u64
    val b1 = bytes[offset + 1] as u64
    val b2 = bytes[offset + 2] as u64
    val b3 = bytes[offset + 3] as u64
    val b4 = bytes[offset + 4] as u64
    val b5 = bytes[offset + 5] as u64
    val b6 = bytes[offset + 6] as u64
    val b7 = bytes[offset + 7] as u64

    b0 | (bit_shl(b1, 8)) | (bit_shl(b2, 16)) | (bit_shl(b3, 24)) | (bit_shl(b4, 32)) | (bit_shl(b5, 40)) | (bit_shl(b6, 48)) | (bit_shl(b7, 56))

# ============================================================================
# Exports
# ============================================================================

export SmfReaderMemory
