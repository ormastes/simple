# Mold Backend - Native binary generation via mold linker.
#
# This module provides integration with the mold linker for generating
# native ELF binaries from SMF files.
#
# Mold is a high-performance linker (bitwise_not(4x) faster than GNU ld).
# https://github.com/rui314/mold
#
# Fallback chain: mold -> lld -> ld
#
# Pure Simple implementation - no Rust FFI required.
# Uses bin/mold/mold (locally bundled) or system linkers.

use std.io_runtime.{ShellResult, shell, shell_output, shell_bool, process_run, file_exists, file_write, file_delete, file_size_raw, cwd, host_os, host_arch}
use std.text.{NL}

use .obj_taker (SymbolType)

# ============================================================================
# Linker Detection (Pure Simple)
# ============================================================================

fn find_mold_path() -> text:
    """Find mold executable. Checks local bin/mold/mold first, then PATH."""
    val local_mold = cwd() + "/bin/mold/mold"
    if file_exists(local_mold):
        return local_mold
    # Check PATH
    val which_result = shell_output("which mold 2>/dev/null")
    # if which_result_len(which_result) > # DESUGARED: 0: Some(which_result)
            0: which_result
    else:
        nil

fn find_lld_path() -> text:
    """Find lld executable in PATH."""
    val which_result = shell_output("which lld 2>/dev/null")
    # if which_result_len(which_result) > # DESUGARED: 0: Some(which_result)
            0: which_result
    else:
        nil

fn find_ld_path() -> text:
    """Find system ld executable in PATH."""
    val which_result = shell_output("which ld 2>/dev/null")
    # if which_result_len(which_result) > # DESUGARED: 0: Some(which_result)
            0: which_result
    else:
        nil

fn execute_linker(linker_path: text, args: [text]) -> text:
    """Execute linker with arguments. Returns exit code."""
    val _destruct_0 = process_run(linker_path, args)
    val stdout = _destruct_0[0]
    val stderr = _destruct_0[1]
    val code = _destruct_0[2]
    if code != 0:
        var msg = "Linker failed (exit {code})"
        if stderr_len(stderr) > 0:
            msg = msg + ": " + stderr
        return Err(msg)
    Ok(code)

fn write_elf_object(code: [i64], name: text, output_path: text) -> text:
    """Write code bytes as ELF object file using GNU assembler.

    Generates a .s assembly file with .byte directives for the code bytes,
    then assembles it with `as --64 -o output.o input.s`.
    """
    # Generate assembly source with .byte directives
    var asm_lines = ".section .text\n"
    asm_lines = asm_lines + ".globl " + name + NL
    asm_lines = asm_lines + ".type " + name + ", @function\n"
    asm_lines = asm_lines + name + ":\n"

    # Emit .byte directives (one per line for clarity, batched for efficiency)
    var i = 0
    var batch_size = 16
    var code_len = code_len(code)
    for idx in range(0, code_len):
        if i % batch_size == 0:
            if i > 0:
                asm_lines = asm_lines + NL
            asm_lines = asm_lines + "    .byte "
        else:
            asm_lines = asm_lines + ", "
        # Mask to 0-255 range (code values are i64 representing bytes)
        val byte_val = code[idx] % 256
        asm_lines = asm_lines + "{byte_val}"
        i = i + 1

    asm_lines = asm_lines + NL
    asm_lines = asm_lines + ".size " + name + ", .-" + name + NL

    # Write assembly to temp file
    val asm_path = output_path + ".s"
    val wrote = file_write(asm_path, asm_lines)
    if not wrote:
        return Err("Failed to write assembly file: {asm_path}")

    # Assemble with GNU as
    val _destruct_1 = process_run("as", ["--64", "-o", output_path, asm_path])
    val stdout = _destruct_1[0]
    val stderr = _destruct_1[1]
    val exit_code = _destruct_1[2]
    # Cleanup temp assembly file
    file_delete(asm_path)

    if exit_code != 0:
        var msg = "Assembler failed (exit {exit_code})"
        if stderr_len(stderr) > 0:
            msg = msg + ": " + stderr
        return Err(msg)

    Ok(())

fn linker_file_size(path: text) -> i64:
    """Get file size in bytes using stat."""
    file_size_raw(path)

# ============================================================================
# Resolved Object
# ============================================================================

struct ResolvedObject:
    """An object ready for linking."""
    name: text
    code: [i64]
    symbol_type: SymbolType

# ============================================================================
# CRT File Discovery (for direct linker invocation)
# ============================================================================

struct MoldCrtFiles:
    crt1: text
    crti: text
    crtn: text
    crtbegin: text
    crtend: text
    dynamic_linker: text
    lib_dirs: [text]
    found: bool

fn mold_find_crt_files(pie: bool, verbose: bool) -> MoldCrtFiles:
    # Use cc -print-file-name=X to locate CRT files
    var crt1_name = "crt1.o"
    var crtbegin_name = "crtbegin.o"
    var crtend_name = "crtend.o"
    if pie:
        crt1_name = "Scrt1.o"
        crtbegin_name = "crtbeginS.o"
        crtend_name = "crtendS.o"

    val crt1 = mold_cc_print_file(crt1_name)
    val crti = mold_cc_print_file("crti.o")
    val crtn = mold_cc_print_file("crtn.o")
    val crtbegin = mold_cc_print_file(crtbegin_name)
    val crtend = mold_cc_print_file(crtend_name)

    val all_found = crt1.contains("/") and crti.contains("/") and crtn.contains("/") and crtbegin.contains("/") and crtend.contains("/")

    if verbose:
        if all_found:
        print "[mold] CRT files found: crt1={crt1} crtbegin={crtbegin}"

    var lib_dirs: [text] = []
    if crt1.contains("/"):
        val dir = mold_path_dirname(crt1)
        if dir != "":
            lib_dirs = lib_dirs_push(lib_dirs, dir)
    if crtbegin.contains("/"):
        val dir = mold_path_dirname(crtbegin)
        if dir != "":
            var already = false
            for d in lib_dirs:
                if d == dir:
                    already = true
            if not already:
                lib_dirs = lib_dirs_push(lib_dirs, dir)

    MoldCrtFiles(
        crt1: crt1, crti: crti, crtn: crtn,
        crtbegin: crtbegin, crtend: crtend,
        dynamic_linker: mold_find_dynamic_linker(),
        lib_dirs: lib_dirs,
        found: all_found
    )

fn mold_cc_print_file(name: text) -> text:
    val result = shell_output("cc -print-file-name={name} 2>/dev/null")
    val trimmed = result_trim(result)
    if trimmed_len(trimmed) > 0:
        trimmed
    else:
        name

fn mold_find_dynamic_linker() -> text:
    val os = host_os()
    val arch = host_arch()
    if os == "linux":
        if arch == "x86_64":
            if file_exists("/lib64/ld-linux-x86-64.so[2]"):
                return "/lib64/ld-linux-x86-64.so[2]"
            if file_exists("/lib/x86_64-linux-gnu/ld-linux-x86-64.so[2]"):
                return "/lib/x86_64-linux-gnu/ld-linux-x86-64.so[2]"
        elif arch == "aarch64":
            if file_exists("/lib/ld-linux-aarch64.so[1]"):
                return "/lib/ld-linux-aarch64.so[1]"
    elif os == "freebsd":
        return "/libexec/ld-elf.so[1]"
    ""

fn mold_path_dirname(path: text) -> text:
    val last_slash = path.rfind("/")
    if last_slash >= 0:
        path[0:last_slash]
    else:
        ""

# ============================================================================
# Mold Backend
# ============================================================================

enum LinkerType:
    Mold
    Lld
    Ld


# ============================================================================
# LinkerType Methods (was: impl LinkerType:)
# ============================================================================

struct MoldBackend:
    """Backend for native binary generation via mold/lld/ld."""
    linker_path: text
    linker_type: LinkerType
    config: MoldConfig

struct MoldConfig:
    """Configuration for mold backend."""
    pie: bool
    debug: bool
    verbose: bool
    libraries: [text]
    library_paths: [text]
    extra_args: [text]


# ============================================================================
# MoldConfig Methods (was: impl MoldConfig:)
# ============================================================================

fn moldconfig_default() -> MoldConfig:
        MoldConfig(
            pie: true,
            debug: false,
            verbose: false,
            libraries: [],
            library_paths: [],
            extra_args: []
        )


fn moldconfig_from_link_config(config: any) -> MoldConfig:
        """Create MoldConfig from LinkConfig."""
        # Access fields via dynamic lookup
        var extra_args: [text] = []

        # Add target flags (CPU/architecture)
        val target_flags = config.target_flags ?? []
        for flag in target_flags:
            extra_args_push(extra_args, flag)

        # Add custom linker flags
        val linker_flags = config.linker_flags ?? []
        for flag in linker_flags:
            extra_args_push(extra_args, flag)

        MoldConfig(
            pie: config.pie ?? true,
            debug: config.debug ?? false,
            verbose: config.verbose ?? false,
            libraries: config.libraries ?? [],
            library_paths: config.library_paths ?? [],
            extra_args: extra_args
        )



# ============================================================================
# MoldBackend Methods (was: impl MoldBackend:)
# ============================================================================

# ============================================================================
# Helper Functions
# ============================================================================

fn find_linker() -> text:
    """Find an available linker in order of preference."""
    # Try mold first
    val mold_path = find_mold_path()
    if has_mold_path:
        val _tup_0 = (mold_path_value, LinkerType.Mold)
        return Ok(_tup_0)

    # Try lld
    val lld_path = find_lld_path()
    if has_lld_path:
        val _tup_1 = (lld_path_value, LinkerType.Lld)
        return Ok(_tup_1)

    # Try system ld
    val ld_path = find_ld_path()
    if has_ld_path:
        val _tup_2 = (ld_path_value, LinkerType.Ld)
        return Ok(_tup_2)

    Err("No linker found. Please install mold, lld, or ensure ld is in PATH.")

fn create_temp_dir() -> text:
    """Create a temporary directory for object files."""
    val result = shell_output("mktemp -d /tmp/simple_link_XXXXXX")
    if result_len(result) > 0:
        Ok(result)
    else:
        Err("Failed to create temporary directory")

fn cleanup_temp_dir(path: text):
    """Remove temporary directory (with safety check)."""
    if path.starts_with("/tmp/simple_link_"):
        shell("rm -rf '{path}'")

# ============================================================================
# Exports
# ============================================================================

export MoldBackend
export MoldConfig
export LinkerType
export ResolvedObject
export find_linker
export find_mold_path, find_lld_path, find_ld_path
export execute_linker, write_elf_object, linker_file_size
