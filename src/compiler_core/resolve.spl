# Method Resolution Pass (UFCS Support)
#
# Resolves method calls using UFCS (Uniform Function Call Syntax) rules:
#   1. Instance method on receiver's type (highest priority)
#   2. Trait method implemented by receiver's type
#   3. Free function where receiver becomes first argument (UFCS)
#
# Example:
#   x.map()  -> InstanceMethod if x's class has map()
#   x.map()  -> TraitMethod if x implements trait with map()
#   x.map()  -> FreeFunction(map) if map(x) exists
#
# This pass runs after type inference to have full type information.

use hir.*
use lexer.Span
use compiler.traits.*

# ============================================================================
# Type Compatibility
# ============================================================================

struct TypeChecker:
    """Type compatibility checking for UFCS resolution."""

    fn is_compatible(a: HirType, b: HirType) -> bool:
        """Check if type `a` is compatible with type `b` for UFCS.

        For UFCS, we check if the receiver type can be passed as the
        first parameter of a function. This includes:
        - Exact type match
        - Reference compatibility (T matches &T, &mut T)
        - Subtype relationships
        """
        match (a.kind, b.kind):
            # Exact matches
            case (Int(bits_a, signed_a), Int(bits_b, signed_b)):
                bits_a == bits_b and signed_a == signed_b
            case (Float(bits_a), Float(bits_b)):
                bits_a == bits_b
            case [Bool, Bool]: true
            case [Char, Char]: true
            case [Str, Str]: true
            case [Unit, Unit]: true

            # Named types (classes, structs, enums)
            case (Named(sym_a, args_a), Named(sym_b, args_b)):
                if sym_a.id != sym_b.id:
                    false
                elif args_a_len(args_a) != args_b_len(args_b):
                    false
                else:
                    var compatible = true
                    var i = 0
                    while i < args_a_len(args_a) and compatible:
                        compatible = self.is_compatible(args_a[i], args_b[i])
                        i = i + 1
                    compatible

            # Reference types - T is compatible with &T and &mut T
            case (_, Ref(inner, _)):
                self.is_compatible(a, inner)

            # Array types
            case (Array(elem_a, _), Array(elem_b, _)):
                self.is_compatible(elem_a, elem_b)

            # Slice types
            case (Slice(elem_a), Slice(elem_b)):
                self.is_compatible(elem_a, elem_b)

            # Optional types
            case (Optional(inner_a), Optional(inner_b)):
                self.is_compatible(inner_a, inner_b)

            # Type parameters - compatible if same name
            case (TypeParam(name_a, _), TypeParam(name_b, _)):
                name_a == name_b

            # Inference variables - always compatible (will be unified)
            case (Infer(_, _), _): true
            case (_, Infer(_, _)): true

            # Default: not compatible
            case _: false

    fn get_type_symbol(ty: HirType) -> has_SymbolId:
        """Get the symbol ID for a named type."""
        match ty.kind:
            case Named(sym, _): sym
            case _: nil

# ============================================================================
# Method Resolver
# ============================================================================

class MethodResolver:
    """Resolves method calls using UFCS rules.

    Walks the HIR and resolves each MethodCall expression by trying:
    1. Instance method on the receiver's type
    2. Trait method implemented by the receiver's type
    3. Free function where receiver becomes first argument

    The resolver modifies the `resolution` field of MethodCall expressions.
    """

    symbols: SymbolTable
    type_checker: TypeChecker
    errors: [ResolveError]
    # Track implemented traits for types (type_id -> [trait_id])
    trait_impls: Dict<i64, [SymbolId]>
    # Enhanced trait solver with generic matching, coherence checking, supertrait resolution
    trait_solver: TraitSolver

    static fn new(symbols: SymbolTable) -> MethodResolver:
        MethodResolver(
            symbols: symbols,
            type_checker: TypeChecker(),
            errors: [],
            trait_impls: {},
            trait_solver: traitsolver_new()
        )

    static fn with_trait_solver(symbols: SymbolTable, solver: TraitSolver) -> MethodResolver:
        """Create a MethodResolver with an existing TraitSolver (for integration with type inference)."""
        MethodResolver(
            symbols: symbols,
            type_checker: TypeChecker(),
            errors: [],
            trait_impls: {},
            trait_solver: solver
        )

    # ========================================================================
    # Module Resolution
    # ========================================================================

    me resolve_module(module: HirModule) -> HirModule:
        """Resolve all method calls in a module."""
        # Build trait implementation map from impls
        self.build_trait_impls(module.impls)

        # Resolve functions
        var resolved_functions: Dict<SymbolId, HirFunction> = {}
        for key in module.functions_keys(functions):
            val func = module.functions[key]
            resolved_functions[key] = self.resolve_function(func)

        # Resolve constants
        var resolved_constants: Dict<SymbolId, HirConst> = {}
        for key in module.constants_keys(constants):
            val const_ = module.constants[key]
            resolved_constants[key] = HirConst(
                symbol: const_.symbol,
                name: const_.name,
                type_: const_.type_,
                value: self.resolve_expr(const_.value),
                is_mutable: const_.is_mutable,
                is_public: const_.is_public,
                span: const_.span
            )

        # Return resolved module
        HirModule(
            name: module.name,
            path: module.path,
            imports: module.imports,
            exports: module.exports,
            symbols: module.symbols,
            functions: resolved_functions,
            classes: module.classes,
            structs: module.structs,
            enums: module.enums,
            traits: module.traits,
            impls: module.impls,
            constants: resolved_constants
        )

    me build_trait_impls(impls: [HirImpl]):
        """Build a map of type -> implemented traits."""
        for impl_ in impls:
            if impl_.has_trait_:
                val type_sym = self.type_checker_get_type_symbol(type_checker, impl_.type_)
                if has_type_sym:
                    val type_id = type_sym_value.id
                    val trait_sym = self.type_checker_get_type_symbol(type_checker, impl_.trait__value)
                    if has_trait_sym:
                        if not self.trait_impls[type_id].?:
                            self.trait_impls[type_id] = []
                        self.trait_impls[type_id] = self.trait_impls[type_id].push(trait_sym_value)

    # ========================================================================
    # Function Resolution
    # ========================================================================

    me resolve_function(func: HirFunction) -> HirFunction:
        """Resolve method calls in a function body."""
        HirFunction(
            symbol: func.symbol,
            name: func.name,
            type_params: func.type_params,
            params: func.params,
            return_type: func.return_type,
            body: self.resolve_block(func.body),
            effects: func.effects,
            is_async: func.is_async,
            is_static: func.is_static,
            is_public: func.is_public,
            is_method: func.is_method,
            is_mutable: func.is_mutable,
            doc_comment: func.doc_comment,
            span: func.span
        )

    # ========================================================================
    # Block and Statement Resolution
    # ========================================================================

    me resolve_block(block: HirBlock) -> HirBlock:
        """Resolve method calls in a block."""
        var resolved_stmts: [HirStmt] = []
        for stmt in block.stmts:
            resolved_stmts = resolved_stmts_push(resolved_stmts, self.resolve_stmt(stmt))

        # val resolved_value = if block.# DESUGARED: has_value: Some(self.resolve_expr(block.value_value))
            has_value: self.resolve_expr(block.value_value)
        else:
            nil

        HirBlock(
            stmts: resolved_stmts,
            value: resolved_value,
            span: block.span
        )

    me resolve_stmt(stmt: HirStmt) -> HirStmt:
        """Resolve method calls in a statement."""
        val kind = match stmt.kind:
            case Expr(expr):
                hirstmtkind_Expr(self.resolve_expr(expr))

            case Let(symbol, type_, init):
                hirstmtkind_Let(symbol, type_, self.resolve_expr(init))

            case Assign(target, op, value):
                HirStmtKind.Assign(
                    self.resolve_expr(target),
                    op,
                    self.resolve_expr(value)
                )

            case Block(block):
                hirstmtkind_Block(self.resolve_block(block))

        HirStmt(kind: kind, span: stmt.span)

    # ========================================================================
    # Expression Resolution
    # ========================================================================

    me resolve_expr(expr: HirExpr) -> HirExpr:
        """Resolve method calls in an expression."""
        val kind = match expr.kind:
            # Method calls - the main target
            case MethodCall(receiver, method, args, resolution):
                val resolved_receiver = self.resolve_expr(receiver)
                val resolved_args = self.resolve_call_args(args)

                # Check if this is actually a static method call (Type.method())
                val is_static = self.is_static_method_call(resolved_receiver)

                # Only resolve if not already resolved
                val new_resolution = if resolution_is_resolved(resolution):
                    resolution
                elif is_static:
                    self.resolve_static_method(resolved_receiver, method, resolved_args)
                else:
                    self.resolve_method(resolved_receiver, method, resolved_args)

                hirexprkind_MethodCall(resolved_receiver, method, resolved_args, new_resolution)

            # Regular function calls - resolve arguments
            case Call(callee, args, type_args):
                HirExprKind.Call(
                    self.resolve_expr(callee),
                    self.resolve_call_args(args),
                    type_args
                )

            # Literals - no resolution needed
            case IntLit(_, _): expr.kind
            case FloatLit(_, _): expr.kind
            case StringLit(value, interps):
                if has_interps:
                    var resolved_interps: [HirInterpolation] = []
                    for interp in interps_value:
                        resolved_interps = resolved_interps.push(HirInterpolation(
                            expr: self.resolve_expr(interp.expr),
                            format: interp.format,
                            span: interp.span
                        ))
                    hirexprkind_StringLit(value, resolved_interps)
                else:
                    expr.kind
            case BoolLit(_): expr.kind
            case CharLit(_): expr.kind
            case UnitLit: expr.kind
            case NilLit: expr.kind

            # Variables
            case Var(_): expr.kind

            # Field access
            case Field(base, field, resolved):
                hirexprkind_Field(self.resolve_expr(base), field, resolved)

            # Index access
            case Index(base, index):
                hirexprkind_Index(self.resolve_expr(base), self.resolve_expr(index))

            case TupleIndex(base, index):
                hirexprkind_TupleIndex(self.resolve_expr(base), index)

            # Collections
            case ArrayLit(elements, type_):
                var resolved: [HirExpr] = []
                for e in elements:
                    resolved = resolved_push(resolved, self.resolve_expr(e))
                hirexprkind_ArrayLit(resolved, type_)

            case TupleLit(elements):
                var resolved: [HirExpr] = []
                for e in elements:
                    resolved = resolved_push(resolved, self.resolve_expr(e))
                hirexprkind_TupleLit(resolved)

            case DictLit(entries, key_type, value_type):
                var resolved: [(HirExpr, HirExpr)] = []
                for _item_0 in entries:
                    val k = _item_0[0]
                    val v = _item_0[1]
                    resolved = resolved_push(resolved, (self.resolve_expr(k), self.resolve_expr(v)))
                hirexprkind_DictLit(resolved, key_type, value_type)

            # Optional operations
            case OptionalChain(base, field):
                hirexprkind_OptionalChain(self.resolve_expr(base), field)

            case NullCoalesce(left, right):
                hirexprkind_NullCoalesce(self.resolve_expr(left), self.resolve_expr(right))

            case ExistsCheck(base):
                hirexprkind_ExistsCheck(self.resolve_expr(base))

            case Unwrap(base):
                hirexprkind_Unwrap(self.resolve_expr(base))

            # Operators
            case Binary(op, left, right):
                hirexprkind_Binary(op, self.resolve_expr(left), self.resolve_expr(right))

            case Unary(op, operand):
                hirexprkind_Unary(op, self.resolve_expr(operand))

            # Control flow
            case If(cond, then_, else_):
                # # val resolved_else = if # DESUGARED: has_else_: Some(self.resolve_block(else__value))
            has_else_: self.resolve_block(else__value)
                else:
                    nil
                hirexprkind_If(self.resolve_expr(cond), self.resolve_block(then_), resolved_else)

            case MatchCase(scrutinee, arms):
                var resolved_arms: [HirMatchArm] = []
                for arm in arms:
                    # val resolved_guard = if arm.# DESUGARED: has_guard: Some(self.resolve_expr(arm.guard_value))
            has_guard: self.resolve_expr(arm.guard_value)
                    else:
                        nil
                    resolved_arms = resolved_arms.push(HirMatchArm(
                        pattern: arm.pattern,
                        guard: resolved_guard,
                        body: self.resolve_block(arm.body),
                        span: arm.span
                    ))
                hirexprkind_MatchCase(self.resolve_expr(scrutinee), resolved_arms)

            case Loop(body, label):
                hirexprkind_Loop(self.resolve_block(body), label)

            case While(cond, body, label):
                hirexprkind_While(self.resolve_expr(cond), self.resolve_block(body), label)

            case For(var_, iter, body, label):
                hirexprkind_For(var_, self.resolve_expr(iter), self.resolve_block(body), label)

            # Closures
            case Lambda(params, body, captures):
                hirexprkind_Lambda(params, self.resolve_expr(body), captures)

            case Block(block):
                hirexprkind_Block(self.resolve_block(block))

            # Control transfer
            case Return(value):
                # # val resolved_value = if # DESUGARED: has_value: Some(self.resolve_expr(value_value) else: nil)
            has_value: self.resolve_expr(value_value) else: nil
                hirexprkind_Return(resolved_value)

            case Break(label, value):
                # # val resolved_value = if # DESUGARED: has_value: Some(self.resolve_expr(value_value) else: nil)
            has_value: self.resolve_expr(value_value) else: nil
                hirexprkind_Break(label, resolved_value)

            case Continue(label):
                hirexprkind_Continue(label)

            case Throw(value):
                hirexprkind_Throw(self.resolve_expr(value))

            case Try(e):
                hirexprkind_Try(self.resolve_expr(e))

            # Async
            case Await(e):
                hirexprkind_Await(self.resolve_expr(e))

            case Yield(value):
                # # val resolved_value = if # DESUGARED: has_value: Some(self.resolve_expr(value_value) else: nil)
            has_value: self.resolve_expr(value_value) else: nil
                hirexprkind_Yield(resolved_value)

            # Construction
            case StructLit(type_, fields):
                var resolved_fields: [(text, HirExpr)] = []
                for _item_1 in fields:
                    val name = _item_1[0]
                    val value = _item_1[1]
                    resolved_fields = resolved_fields_push(resolved_fields, (name, self.resolve_expr(value)))
                hirexprkind_StructLit(type_, resolved_fields)

            case EnumLit(type_, variant, payload):
                val resolved_payload = if has_payload:
                    match payload_value:
                        case Tuple(values):
                            var resolved: [HirExpr] = []
                            for v in values:
                                resolved = resolved_push(resolved, self.resolve_expr(v))
                            hirenumpayload_Tuple(resolved)
                        case Struct(fields):
                            var resolved: [(text, HirExpr)] = []
                            for _item_2 in fields:
                                val name = _item_2[0]
                                val value = _item_2[1]
                                resolved = resolved_push(resolved, (name, self.resolve_expr(value)))
                            hirenumpayload_Struct(resolved)
                else:
                    nil
                hirexprkind_EnumLit(type_, variant, resolved_payload)

            # Casts
            case Cast(e, target):
                hirexprkind_Cast(self.resolve_expr(e), target)

            case As(e, target):
                hirexprkind_As(self.resolve_expr(e), target)

            # Range
            case Range(start, end, inclusive, step):
                # # val resolved_start = if # DESUGARED: has_start: Some(self.resolve_expr(start_value) else: nil)
            has_start: self.resolve_expr(start_value) else: nil
                # # val resolved_end = if # DESUGARED: has_end: Some(self.resolve_expr(end_value) else: nil)
            has_end: self.resolve_expr(end_value) else: nil
                # # val resolved_step = if # DESUGARED: has_step: Some(self.resolve_expr(step_value) else: nil)
            has_step: self.resolve_expr(step_value) else: nil
                hirexprkind_Range(resolved_start, resolved_end, inclusive, resolved_step)

            # Comprehension
            case Comprehension(kind, e, clauses):
                var resolved_clauses: [HirCompClause] = []
                for clause in clauses:
                    resolved_clauses = resolved_clauses_push(resolved_clauses, self.resolve_comp_clause(clause))
                hirexprkind_Comprehension(kind, self.resolve_expr(e), resolved_clauses)

            # Custom blocks (pass through - no method resolution needed)
            case CustomBlock(kind, value):
                hirexprkind_CustomBlock(kind, value)

            # Math/DL blocks (resolve expressions in body)
            case LossBlock(body):
                hirexprkind_LossBlock(self.resolve_block(body))

            case NogradBlock(body):
                hirexprkind_NogradBlock(self.resolve_block(body))

            # Error
            case Error: expr.kind

        HirExpr(kind: kind, type_: expr.type_, span: expr.span)

    me resolve_call_args(args: [HirCallArg]) -> [HirCallArg]:
        """Resolve method calls in call arguments."""
        var resolved: [HirCallArg] = []
        for arg in args:
            resolved = resolved.push(HirCallArg(
                name: arg.name,
                value: self.resolve_expr(arg.value),
                span: arg.span
            ))
        resolved

    me resolve_comp_clause(clause: HirCompClause) -> HirCompClause:
        """Resolve method calls in comprehension clause."""
        val kind = match clause.kind:
            case For(var_, iter):
                hircompclausekind_For(var_, self.resolve_expr(iter))
            case If(cond):
                hircompclausekind_If(self.resolve_expr(cond))

        HirCompClause(kind: kind, span: clause.span)

    # ========================================================================
    # Method Resolution Logic (UFCS)
    # ========================================================================

    me resolve_method(receiver: HirExpr, method: text, args: [HirCallArg]) -> MethodResolution:
        """Resolve a method call using UFCS priority rules.

        Priority:
        1. Instance method on receiver's type
        2. Trait method implemented by receiver's type
        3. Free function where receiver becomes first argument
        """
        val receiver_type = receiver.type_

        # If no type information, cannot resolve
        if not has_receiver_type:
            self.add_error(
                ("cannot resolve method '{method}': receiver type is unknown. " +
                "Ensure the receiver expression has a valid type."),
                receiver.span
            )
            return MethodResolution.Unresolved

        val ty = receiver_type_value
        val type_name = self.format_type(ty)

        # Priority 1: Instance method on receiver's type
        val instance_result = self.try_instance_method(ty, method)
        if has_instance_result:
            return instance_result_value

        # Priority 2: Trait method
        val trait_result = self.try_trait_method(ty, method)
        if has_trait_result:
            return trait_result_value

        # Priority 3: UFCS - Free function
        val ufcs_result = self.try_ufcs(ty, method, args)
        if has_ufcs_result:
            return ufcs_result_value

        # No resolution found - provide helpful error message
        val arg_count = args_len(args)
        val suggestions = self.get_method_suggestions(ty, method)

        var error_msg = "no method '{method}' found for type '{type_name}'"
        error_msg = error_msg + ". Tried: (1) instance method, (2) trait method, (3) free function '{method}({type_name}, ...)'"

        if suggestions_len(suggestions) > 0:
            error_msg = error_msg + ". Did you mean: {suggestions.join(\", \")}"

        self.add_error(error_msg, receiver.span)
        MethodResolution.Unresolved

    fn format_type(ty: HirType) -> text:
        """Format a type for error messages."""
        match ty.kind:
            case Int(bits, signed):
                if signed:
                    "i{bits}"
                else:
                    "u{bits}"
            case Float(bits): "f{bits}"
            case Bool: "bool"
            case Char: "char"
            case Str: "text"
            case Unit: "()"
            case Named(sym, _):
                # Try to get symbol name
                val s = self.symbols_get(symbols, sym)
                if has_s:
                    s_value.name
                else:
                    "<named type>"
            case Array(elem, _): "[{self.format_type(elem)}]"
            case Optional(inner): "{self.format_type(inner)}?"
            case Tuple(elems):
                var parts: [text] = []
                for e in elems:
                    parts = parts_push(parts, self.format_type(e))
                "({parts.join(\", \")})"
            case _: "<unknown type>"

    me get_method_suggestions(ty: HirType, method: text) -> [text]:
        """Get suggestions for similar method names."""
        var suggestions: [text] = []

        # Get type symbol if named type
        val type_sym = self.type_checker_get_type_symbol(type_checker, ty)
        if has_type_sym:
            val type_id = type_sym_value
            # Look for similar method names in the type
            val methods = self.symbols_get_methods_for_type(symbols, type_id)
            for m in methods:
                if self.is_similar(m, method):
                    suggestions = suggestions_push(suggestions, m)

        # Look for similar function names
        val functions = self.symbols_get_all_functions(symbols)
        for f in functions:
            if self.is_similar(f, method):
                suggestions = suggestions.push("{f}()")

        suggestions

    fn is_similar(a: text, b: text) -> bool:
        """Check if two names are similar (for suggestions)."""
        # Simple heuristic: same prefix or suffix, or edit distance <= 2
        if not has_a:
            false
        elif not has_b:
            false
        elif a_len(a) < 2 or b_len(b) < 2:
            false
        elif a_starts_with(a, b[0:2]):
            true
        elif b_starts_with(b, a[0:2]):
            true
        elif a_ends_with(a, b[b.len()-2:]):
            true
        elif b_ends_with(b, a[a.len()-2:]):
            true
        else:
            false

    me try_instance_method(receiver_type: HirType, method: text) -> has_MethodResolution:
        """Try to find an instance method on the receiver's type."""
        val type_sym = self.type_checker_get_type_symbol(type_checker, receiver_type)
        if not has_type_sym:
            return nil

        val type_id = type_sym_value
        val method_sym = self.symbols_lookup_method_in_type(symbols, type_id, method)

        # # if # DESUGARED: has_method_sym: Some(methodresolution_InstanceMethod(type_id)
            has_method_sym: methodresolution_InstanceMethod(type_id, method_sym_value)
        else:
            nil

    me try_trait_method(receiver_type: HirType, method: text) -> has_MethodResolution:
        """Try to find a trait method implemented by the receiver's type.

        Uses enhanced TraitSolver for:
        - Generic type matching (impl<T> Trait for Vec<T> matches Vec<i64>)
        - Supertrait resolution (Ord requires Eq)
        - Coherence checking (no overlapping impls)
        """
        val type_sym = self.type_checker_get_type_symbol(type_checker, receiver_type)
        if not has_type_sym:
            return nil

        val type_id = type_sym_value.id

        # LEGACY PATH: Use simple trait_impls map as fallback
        # This handles impls that were registered before TraitSolver integration
        if not self.trait_impls[type_id].?:
            # Try enhanced TraitSolver path for generic impls
            return self.try_trait_method_with_solver(receiver_type, method)

        val traits = self.trait_impls[type_id]
        for trait_id in traits:
            val method_sym = self.symbols_lookup_trait_method(symbols, trait_id, method)
            if has_method_sym:
                return methodresolution_TraitMethod(trait_id, method_sym_value)

        # If legacy lookup failed, try enhanced solver
        self.try_trait_method_with_solver(receiver_type, method)

    me try_trait_method_with_solver(receiver_type: HirType, method: text) -> has_MethodResolution:
        """Enhanced trait method resolution using TraitSolver.

        This path handles:
        - Generic impls: impl<T> Display for Vec<T>
        - Where clauses: impl<T: Clone> Trait for Foo<T>
        - Supertrait resolution: impl Ord for Point (requires Eq)

        TODO: Currently a placeholder. Full implementation requires:
        1. SymbolTable method to find all traits with a given method name
        2. Iteration over trait_solver.impls to find matching generic impls
        3. Obligation checking for where clauses

        For now, the legacy path (trait_impls map) handles most cases.
        Generic impl support will be added in a future enhancement.
        """
        # Enhanced trait method resolution using TraitSolver
        # Iterate over all registered traits to find one with this method
        for trait_entry in self.trait_solver.trait_methods_entries(trait_methods):
            val trait_name = trait_entry.key
            val methods = trait_entry.value
            # Check if this trait has the method we're looking for
            if methods_contains(methods, method):
                # Check if receiver_type implements this trait
                val impl_result = self.trait_solver_find_impl(trait_solver, receiver_type, trait_name)
                if has_impl_result:
                    val impl_block = impl_result_value
                    # Found a matching impl - resolve the method
                    return MethodResolution(
                        trait_name: Some(trait_name,
                        # # DESUGARED: impl_block: Some(impl_block)
            impl_block: impl_block,
                        method_name: method,
                        is_generic: impl_block.type_params_len(type_params) > 0
                    ))

        # No trait method found via solver, fall back to legacy path
        nil

    me try_ufcs(receiver_type: HirType, method: text, args: [HirCallArg]) -> has_MethodResolution:
        """Try to find a free function for UFCS resolution.

        For `x_method(x, a, b)` to resolve to `method(x, a, b)`:
        1. Find a function named `method`
        2. Check that its first parameter type is compatible with `x`'s type
        """
        val func_sym_id = self.symbols_lookup_function(symbols, method)
        if not has_func_sym_id:
            return nil

        val func_sym = self.symbols_get(symbols, func_sym_id_value)
        if not has_func_sym:
            return nil

        # Check if the function's first parameter is compatible with receiver type
        val func = func_sym_value
        val func_type = func.type_
        if not has_func_type:
            return nil

        match func_type_value.kind:
            case Function(params, _, _):
                if params_len(params) == 0:
                    return nil

                val first_param_type = params[0]
                if self.type_checker_is_compatible(type_checker, receiver_type, first_param_type):
                    methodresolution_FreeFunction(func_sym_id_value)
                else:
                    nil
            case _:
                nil

    me is_static_method_call(receiver: HirExpr) -> bool:
        """Check if receiver is a type reference (making this a static method call).

        Static calls: type_method() where receiver is a class/struct/enum name
        Instance calls: expr_method(expr) where receiver is a value
        """
        match receiver.kind:
            case Var(symbol):
                # Check if this symbol is a type (Struct, Class, Enum, or imported type)
                val sym = self.symbols_get(symbols, symbol)
                if has_sym:
                    match sym_value.kind:
                        case Class: true
                        case Struct: true
                        case Enum: true
                        case Import: true
                        case _: false
                else:
                    false
            case _:
                false

    me resolve_static_method(receiver: HirExpr, method: text, args: [HirCallArg]) -> MethodResolution:
        """Resolve a static method call Type.method()"""

        # Get the type symbol from receiver (must be Var referring to a type)
        val type_sym_id = match receiver.kind:
            case Var(symbol): symbol
            case _: nil

        if not has_type_sym_id:
            self.add_error(
                "internal error: is_static_method_call returned true but receiver is not a type reference",
                receiver.span
            )
            return MethodResolution.Unresolved

        val type_id = type_sym_id_value

        # Look for static method in the type's definition
        val method_sym = self.symbols_lookup_static_method(symbols, type_id, method)

        if has_method_sym:
            methodresolution_StaticMethod(type_id, method_sym_value)
        else:
            # No static method found - provide helpful error
            val type_sym = self.symbols_get(symbols, type_id)
            val type_name = if has_type_sym: type_sym_value.name else: "<unknown>"

            self.add_error(
                "no static method '{method}' found for type '{type_name}'",
                receiver.span
            )
            MethodResolution.Unresolved

    # ========================================================================
    # Error Handling
    # ========================================================================

    me add_error(message: text, span: Span):
        """Add a resolution error."""
        self.errors = self.errors.push(ResolveError(
            message: message,
            span: span
        ))

    fn has_errors() -> bool:
        """Check if there are any errors."""
        self.errors_len(errors) > 0

    fn get_errors() -> [ResolveError]:
        """Get all errors."""
        self.errors

# ============================================================================
# Resolution Errors
# ============================================================================

struct ResolveError:
    """Error during method resolution."""
    message: text
    span: Span


# ============================================================================
# ResolveError Methods (was: impl ResolveError:)
# ============================================================================

# ============================================================================
# Public API
# ============================================================================

fn resolve_methods(module: HirModule) -> (HirModule, [ResolveError]):
    """Resolve all method calls in a module.

    This is the main entry point for the resolution pass.
    Returns the resolved module and any errors encountered.
    """
    var resolver = methodresolver_new(module.symbols)
    val resolved = resolver_resolve_module(resolver, module)
    [resolved, resolver_get_errors(resolver)]

fn resolve_methods_with_solver(module: HirModule, solver: TraitSolver) -> (HirModule, [ResolveError]):
    """Resolve all method calls in a module using an existing TraitSolver.

    This variant allows integration with type inference, where the TraitSolver
    has already been populated with trait definitions, impl blocks, and has
    checked trait obligations.

    Use this when:
    - Type inference has already run and created a TraitSolver
    - You want to use enhanced generic type matching for method resolution
    - You need trait bound checking during method resolution
    """
    var resolver = methodresolver_with_trait_solver(module.symbols, solver)
    val resolved = resolver_resolve_module(resolver, module)
    [resolved, resolver_get_errors(resolver)]
