# HIR Types - Core Types and Symbol Table
#
# This module contains:
# - HIR module structure and imports
# - Symbol table with name resolution and UFCS support
# - HIR type system (primitives, composites, references, user-defined)
# - Dimension types for compile-time tensor checking
# - Effect system

use parser.*
use lexer.Span

# ============================================================================
# HIR Module Structure
# ============================================================================

struct HirModule:
    """Complete HIR module."""
    name: text
    path: text
    imports: [HirImport]
    exports: [text]
    symbols: SymbolTable
    functions: Dict<SymbolId, HirFunction>
    classes: Dict<SymbolId, HirClass>
    structs: Dict<SymbolId, HirStruct>
    enums: Dict<SymbolId, HirEnum>
    bitfields: Dict<SymbolId, HirBitfield>
    traits: Dict<SymbolId, HirTrait>
    impls: [HirImpl]
    constants: Dict<SymbolId, HirConst>
    static_asserts: [HirStaticAssert]   # Static assertions evaluated at compile time

struct HirImport:
    """Import declaration."""
    module_path: text
    items: [HirImportItem]
    span: Span

struct HirImportItem:
    """Single imported item."""
    name: text
    # # DESUGARED: alias: text
    has_alias: bool
    alias: text
    # # DESUGARED: resolved: SymbolId
    has_resolved: bool
    resolved: SymbolId

# ============================================================================
# Symbol Table
# ============================================================================

struct SymbolId:
    """Unique identifier for a symbol."""
    id: i64


# ============================================================================
# SymbolId Methods (was: impl SymbolId:)
# ============================================================================

fn symbolid_new(id: i64) -> SymbolId:
        SymbolId(id: id)


struct Symbol:
    """Symbol table entry."""
    id: SymbolId
    name: text
    kind: SymbolKind
    # # DESUGARED: type_: HirType
    has_type_: bool
    type_: HirType
    scope: ScopeId
    span: Span
    is_public: bool
    is_mutable: bool
    # # DESUGARED: defining_module: text
    has_defining_module: bool
    defining_module: text

"""Kind of symbol."""
enum SymbolKind:
    Function
    Method
    Variable
    Parameter
    Field
    Class
    Struct
    Enum
    EnumVariant
    Trait
    TypeAlias
    TypeParam
    Const
    Module
    Import

# ============================================================================
# Method Resolution (UFCS Support)
# ============================================================================

"""How a method call was resolved.

Supports UFCS (Uniform Function Call Syntax) where `x_method(x)` can resolve to:
1. Instance method on x's type (highest priority)
2. Trait method implemented by x's type
3. Free function `method(x)` where first param matches x's type (UFCS)

Examples:
    x.map()  ->  InstanceMethod if x's class has map()
    x_map(x)  ->  TraitMethod if x implements trait with map()
    x_map(x)  ->  FreeFunction(map) if map(x) exists and first param matches
"""
enum MethodResolution:
    # Direct method on the receiver's type
    InstanceMethod(type_id: SymbolId, method_id: SymbolId)

    # Method from an implemented trait
    TraitMethod(trait_id: SymbolId, method_id: SymbolId)

    # UFCS: Free function where receiver becomes first argument
    # x.method(a, b) -> method(x, a, b)
    FreeFunction(func_id: SymbolId)

    # Static method on a type (no receiver)
    # Type.method(a, b) - no self parameter
    StaticMethod(type_id: SymbolId, method_id: SymbolId)

    # Not yet resolved (before resolution pass)
    Unresolved


# ============================================================================
# MethodResolution Methods (was: impl MethodResolution:)
# ============================================================================

struct ScopeId:
    """Unique identifier for a scope."""
    id: i64

struct Scope:
    """Lexical scope."""
    id: ScopeId
    # # DESUGARED: parent: ScopeId
    has_parent: bool
    parent: ScopeId
    kind: ScopeKind
    symbols: Dict<text, SymbolId>

"""Kind of scope."""
enum ScopeKind:
    Module
    Function
    Block
    Loop
    Match
    Class
    Impl

class SymbolTable:
    """Symbol table for name resolution."""
    symbols: Dict<i64, Symbol>
    scopes: Dict<i64, Scope>
    current_scope: ScopeId
    next_symbol_id: i64
    next_scope_id: i64


# ============================================================================
# SymbolTable Methods (was: impl SymbolTable:)
# ============================================================================

fn symboltable_new() -> SymbolTable:
        var table = SymbolTable(
            symbols: {},
            scopes: {},
            current_scope: ScopeId(id: 0),
            next_symbol_id: 0,
            next_scope_id: 1
        )
        # Create root scope (direct mutation avoids copy-modify-reassign bug)
        table.scopes[0] = Scope(
            id: ScopeId(id: 0),
            parent: nil,
            kind: ScopeKind.Module,
            symbols: {}
        )
        table


fn symboltable_define(self: SymbolTable, name: text, kind: SymbolKind, type_: HirType, span: Span, is_public: bool, is_mutable: bool, defining_module: text?) -> SymbolId:
        """Define a new symbol in current scope."""
        val id = symbolid_new(self.next_symbol_id)
        self.next_symbol_id = self.next_symbol_id + 1

        val symbol = Symbol(
            id: id,
            name: name,
            kind: kind,
            type_: type_,
            scope: self.current_scope,
            span: span,
            is_public: is_public,
            is_mutable: is_mutable,
            defining_module: defining_module
        )

        self.symbols[id.id] = symbol

        # Copy-modify-reassign for interpreter compatibility
        var scope = self.scopes[self.current_scope.id]
        var scope_syms = scope.symbols
        scope_syms[name] = id
        scope.symbols = scope_syms
        self.scopes[self.current_scope.id] = scope

        id


fn symboltable_push_scope(self: SymbolTable, kind: ScopeKind) -> ScopeId:
        """Push a new scope."""
        val id = ScopeId(id: self.next_scope_id)
        self.next_scope_id = self.next_scope_id + 1

        self.scopes[id.id] = Scope(
            id: id,
            # # DESUGARED: parent: Some(self.current_scope)
            parent: self.current_scope,
            kind: kind,
            symbols: {}
        )

        self.current_scope = id
        id


# ============================================================================
# HIR Types
# ============================================================================

struct HirType:
    """Type in HIR."""
    kind: HirTypeKind
    span: Span

"""Type kind."""
enum HirTypeKind:
    # Primitive types
    Int(bits: i64, signed: bool)    # i8, i16, i32, i64, u8, u16, u32, u64
    Float(bits: i64)                 # f32, f64
    Bool
    Char
    Str
    Unit                             # ()

    # Composite types
    Tuple(elements: [HirType])
    Array(element: HirType, size: i64?)
    Slice(element: HirType)
    Dict(key: HirType, value: HirType)

    # Reference types
    Ref(inner: HirType, mutable: bool)
    Ptr(inner: HirType, mutable: bool)
    Optional(inner: HirType)
    Result(ok: HirType, err: HirType)

    # User-defined types
    Named(symbol: SymbolId, args: [HirType])
    TypeParam(name: text, bounds: [HirType])

    # Trait types
    DynTrait(trait_: SymbolId)       # dyn Trait (trait object for dynamic dispatch)

    # Function types
    Function(params: [HirType], ret: HirType, effects: [Effect])

    # Special
    # Type inference variable with level for HM generalization
    # - id: unique identifier for the variable
    # - level: scope level at which the variable was created
    #   Higher level = more recently introduced, can be generalized
    Infer(id: i64, level: i64)
    Error
    Never                            # ! type (never returns)
    Any                              # Any type (top type, type erasure)

    # Tensor and Layer types (for dimension checking)
    Tensor(element: HirType, dims: [DimExpr], device: DeviceType?)
    Layer(input: [DimExpr], output: [DimExpr])

# ============================================================================
# Dimension Types (for compile-time dimension checking)
# ============================================================================

struct DimExpr:
    """Dimension expression for tensor shape checking."""
    kind: DimExprKind
    span: Span

"""Dimension expression kind."""
enum DimExprKind:
    Literal(value: i64)                     # 784
    Named(name: text, lo: i64, hi: i64?)   # batch: 1..128
    Var(id: i64)                            # Inference variable
    Dynamic                                  # Runtime only
    Broadcast                                # Broadcasting dimension
    ConstParam(name: text)                  # Reference to const generic
    # Arithmetic operations
    Add(left: DimExpr, right: DimExpr)
    Mul(left: DimExpr, right: DimExpr)
    Div(left: DimExpr, right: DimExpr)


# ============================================================================
# DimExpr Methods (was: impl DimExpr:)
# ============================================================================

fn dimexpr_literal(value: i64, span: Span) -> DimExpr:
        DimExpr(kind: dimexprkind_Literal(value), span: span)


fn dimexpr_named(name: text, span: Span) -> DimExpr:
        DimExpr(kind: dimexprkind_Named(name, nil, nil), span: span)


fn dimexpr_named_range(name: text, lo: i64, hi: i64, span: Span) -> DimExpr:
        DimExpr(kind: dimexprkind_Named(name, lo, hi), span: span)


fn dimexpr_var(id: i64, span: Span) -> DimExpr:
        DimExpr(kind: dimexprkind_Var(id), span: span)


fn dimexpr_dynamic(span: Span) -> DimExpr:
        DimExpr(kind: DimExprKind.Dynamic, span: span)


"""Device type for tensors."""
enum DeviceType:
    CPU
    CUDA(id: i64)
    Vulkan(id: i64)

"""Memory space for GPU memory allocation."""
enum MemorySpace:
    Global      # Device global memory (accessible from host)
    Shared      # Workgroup shared memory (fast, limited size)
    Local       # Thread-local memory (registers/private)
    Constant    # Read-only constant memory (cached)
    Uniform     # Vulkan uniform buffer (read-only, broadcast)

struct LayerType:
    """Type for neural network layers with input/output shapes."""
    input_shape: [DimExpr]
    output_shape: [DimExpr]
    params: [ParamShape]
    # # DESUGARED: device: DeviceType
    has_device: bool
    device: DeviceType

struct ParamShape:
    """Shape of a trainable parameter in a layer."""
    name: text
    shape: [DimExpr]
    trainable: bool


# ============================================================================
# LayerType Methods (was: impl LayerType:)
# ============================================================================

fn layertype_new(input: [DimExpr], output: [DimExpr]) -> LayerType:
        LayerType(
            input_shape: input,
            output_shape: output,
            params: []
            ## DESUGARED: device: nil
        )


fn layertype_with_device_of(layer: LayerType, device: DeviceType) -> LayerType:
        LayerType(
            input_shape: layer.input_shape,
            output_shape: layer.output_shape,
            params: layer.params,
            # # DESUGARED: device: Some(device)
            device: device
        )


struct Effect:
    """Effect annotation."""
    kind: EffectKind
    span: Span

"""Effect kind."""
enum EffectKind:
    Pure            # No side effects
    IO              # I/O operations
    Async           # Async operations
    Throws(type_: HirType)  # Can throw error
    Mutates         # Mutates state
    Allocates       # Heap allocation
    Custom(name: text)

# ============================================================================
# Exports
# ============================================================================

export HirModule, HirImport, HirImportItem
export SymbolId, Symbol, SymbolKind, ScopeId, Scope, ScopeKind, SymbolTable
export MethodResolution
export HirType, HirTypeKind
export DimExpr, DimExprKind, DeviceType, MemorySpace, LayerType, ParamShape
export Effect, EffectKind
