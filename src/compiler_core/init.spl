# Compiler Initialization
#
# Sets up the complete compilation environment:
# 1. Load configuration (file -> env -> args)
# 2. Initialize DI container with profile bindings
# 3. Initialize AOP with logging aspects
# 4. Register compiler-specific services

use std_lib.config.AppConfig
use std_lib.config.load_full_config
use std_lib.config.quick_config
use std_lib.di.Container
use std_lib.di.init_container
use std_lib.di.get_container
use std_lib.di.Backend
use std_lib.di.InterpreterBackend
use std_lib.di.CompilerBackend
use std_lib.di.SdnBackend
use std_lib.aop.init_aop
use std_lib.aop.get_registry
use std_lib.aop.Aspect

# ============================================================================
# Compiler Context
# ============================================================================

struct CompilerContext:
    """Complete compiler context with all services."""
    config: AppConfig
    container: Container
    mode: CompilerMode

"""Compiler execution mode."""
enum CompilerMode:
    Interpret           # Tree-walking interpreter
    Jit                 # JIT compilation
    Aot                 # Ahead-of-time compilation
    Sdn                 # SDN parsing (data only)
    Check               # Type check only


# ============================================================================
# CompilerMode Methods (was: impl CompilerMode:)
# ============================================================================

fn compilermode_from_text(mode: text) -> CompilerMode:
        match mode:
            case "interpret": CompilerMode.Interpret
            case "jit": CompilerMode.Jit
            case "aot": CompilerMode.Aot
            case "sdn": CompilerMode.Sdn
            case "check": CompilerMode.Check
            case _: CompilerMode.Interpret


# ============================================================================
# Initialization Functions
# ============================================================================

var global_context: CompilerContext = nil

fn init_compiler() -> text:
    """Initialize compiler with default configuration."""
    init_compiler_with_config(quick_config())

fn init_compiler_with_file(config_path: text) -> text:
    """Initialize compiler with configuration from file."""
    val config = load_full_config(config_path)?
    init_compiler_with_config(config)

fn init_compiler_with_config(config: AppConfig) -> text:
    """Initialize compiler with provided configuration."""

    # Step 1: Determine mode
    val mode = compilermode_from_text(config.execution.mode)

    # Step 2: Initialize DI container with profile
    val profile = mode_to_profile(mode)
    init_container(profile)
    val container = get_container()

    # Step 3: Initialize AOP
    init_aop(config.aop)

    # Step 4: Register compiler-specific services
    register_compiler_services(container, mode)

    # Step 5: Create context
    val ctx = CompilerContext(
        config: config,
        container: container,
        mode: mode
    )

    global_context = ctx
    Ok(ctx)

fn register_compiler_services(container: Container, mode: CompilerMode):
    """Register compiler-specific services based on mode."""
    match mode:
        case Interpret:
            # Interpreter mode: use interpreter backend
            container.bind("ExecutionEngine", \: InterpreterExecutionEngine(), true)
        case Jit:
            # JIT mode: use interpreter with JIT caching
            container.bind("ExecutionEngine", \: JitExecutionEngine(), true)
        case Aot:
            # AOT mode: use compiler backend
            container.bind("ExecutionEngine", \: AotExecutionEngine(), true)
        case Sdn:
            # SDN mode: no execution engine
            container.bind("ExecutionEngine", \: NoOpExecutionEngine(), true)
        case Check:
            # Check mode: no execution, just type checking
            container.bind("ExecutionEngine", \: NoOpExecutionEngine(), true)

# ============================================================================
# Execution Engines (Mode-specific)
# ============================================================================

trait ExecutionEngine:
    """Interface for code execution."""
    fn execute(source: text) -> text:
\\\\\        to: zzoxzqoo 2b48645a "feat: Complete Track A/B/C - Native backend layout optimization and LLVM backend" (rebase destination)
-        _dummy: i64
    fn execute_file(path: text) -> text:
\\\\\        to: zzoxzqoo 2b48645a "feat: Complete Track A/B/C - Native backend layout optimization and LLVM backend" (rebase destination)
-        _dummy: i64
    fn compile(source: text) -> text:
\\\\\        to: zzoxzqoo 2b48645a "feat: Complete Track A/B/C - Native backend layout optimization and LLVM backend" (rebase destination)
-        _dummy: i64
    fn name() -> text:
\\\\\        to: zzoxzqoo 2b48645a "feat: Complete Track A/B/C - Native backend layout optimization and LLVM backend" (rebase destination)
-        _dummy: i64

"""Result of execution."""
enum ExecutionResult:
    Value(Any)
    ExitCode(i64)
    None_

struct CompiledUnit:
    """Result of compilation."""
    bytes: [u8]
    symbols: Dict<text, i64>
    # # DESUGARED: entry_point: text
    has_entry_point: bool
    entry_point: text

struct InterpreterExecutionEngine:
    """Interpreter-based execution engine."""

# REMOVED: impl ExecutionEngine for InterpreterExecutionEngine:
# (Trait implementations not supported in Core Simple)
    # fn execute(source: text) -> text:
        # # Parse source and evaluate via interpreter
        # val ast = parse_source(source)?
        # val result = interpret_ast(ast)?
        # Ok(result)

    # fn execute_file(path: text) -> text:
        # # Read file, parse, and interpret
        # val source = file_read(path)
        # if source == "":
            # return Err("Failed to read file: {path}")
        # self.execute(source)

    # fn compile(source: text) -> text:
        # Err("Interpreter mode does not support compilation")

    # fn name() -> text:
        # "InterpreterExecutionEngine"

struct JitExecutionEngine:
    """JIT compilation engine."""
    cache: Dict<text, CompiledUnit>

# REMOVED: impl ExecutionEngine for JitExecutionEngine:
# (Trait implementations not supported in Core Simple)
    # fn execute(source: text) -> text:
        # # JIT compile and execute
        # val compiled = self.compile(source)?
        # if compiled.has_entry_point:
            # val entry = compiled.entry_point_value
            # Ok(execute_compiled(compiled, entry))
        # else:
            # Err("No entry point found in compiled unit")

    # fn execute_file(path: text) -> text:
        # # Read file, JIT compile, and execute
        # val source = file_read(path)
        # if source == "":
            # return Err("Failed to read file: {path}")
        # # Check cache
        # if self.cache_contains_key(cache, path):
            # val cached = self.cache[path]
            # if cached.has_entry_point:
                # return Ok(execute_compiled(cached, cached.entry_point_value))
        # val result = self.execute(source)
        # result

    # fn compile(source: text) -> text:
        # # Parse, lower to MIR, optimize, and compile to native code
        # val ast = parse_source(source)?
        # val mir = lower_to_mir(ast)?
        # val optimized = optimize_mir(mir)?
        # val code = codegen(optimized)?
        # Ok(code)

    # fn name() -> text:
        # "JitExecutionEngine"

struct AotExecutionEngine:
    """Ahead-of-time compilation engine."""

# REMOVED: impl ExecutionEngine for AotExecutionEngine:
# (Trait implementations not supported in Core Simple)
    # fn execute(source: text) -> text:
        # Err("AOT mode requires compilation first")

    # fn execute_file(path: text) -> text:
        # Err("AOT mode requires compilation first")

    # fn compile(source: text) -> text:
        # # Parse, lower to MIR, optimize, and compile to object file
        # val ast = parse_source(source)?
        # val mir = lower_to_mir(ast)?
        # val optimized = optimize_mir(mir)?
        # val code = codegen_to_object(optimized)?
        # Ok(code)

    # fn name() -> text:
        # "AotExecutionEngine"

struct NoOpExecutionEngine:
    """No-operation execution engine for SDN and check modes."""

# REMOVED: impl ExecutionEngine for NoOpExecutionEngine:
# (Trait implementations not supported in Core Simple)
    # fn execute(source: text) -> text:
        # Err("Execution not available in this mode")

    # fn execute_file(path: text) -> text:
        # Err("Execution not available in this mode")

    # fn compile(source: text) -> text:
        # Err("Compilation not available in this mode")

    # fn name() -> text:
        # "NoOpExecutionEngine"

# ============================================================================
# Global Context Access
# ============================================================================

fn get_context() -> text:
    """Get the global compiler context."""
    if global_context_is_none(global_context):
        return Err("Compiler not initialized. Call init_compiler() first.")
    Ok(global_context_value)

fn get_engine() -> text:
    """Get the execution engine from global context."""
    val ctx = get_context()?
    # Resolve as Any and cast (avoid generic method call for bootstrap)
    val resolved = ctx.container.resolve_any("ExecutionEngine")
    if resolved_is_err(resolved):
        return Err(resolved_unwrap_err(resolved))
    Ok(resolved_value, )

# ============================================================================
# Convenience Functions
# ============================================================================

fn run(source: text) -> text:
    """Run Simple code with current context."""
    val engine = get_engine()?
    engine_execute(engine, source)

fn run_file(path: text) -> text:
    """Run Simple file with current context."""
    val engine = get_engine()?
    engine_execute_file(engine, path)

fn compile(source: text) -> text:
    """Compile Simple code with current context."""
    val engine = get_engine()?
    engine_compile(engine, source)

# ============================================================================
# SDN-Safe Parsing
# ============================================================================

fn parse_sdn_safe(source: text) -> text:
    """Parse SDN with guaranteed no code execution.

    Uses SdnBackend which blocks all execution instructions.
    Safe for untrusted input.
    """
    # Create SDN-mode container
    val container = container_for_sdn()
    # Resolve as Any and cast (avoid generic method call for bootstrap)
    val backend_result = container.resolve_any("Backend")
    if backend_result_is_err(backend_result):
        return Err(backend_result_unwrap_err(backend_result))
    val backend = backend_result_value as Backend

    # Parse SDN key=value pairs from source
    var data: Dict<text, Any> = {}
    val lines = source.split("\n")
    for line in lines:
        val trimmed = line_trim(line)
        # Skip empty lines and comments
        if trimmed.len() == 0 or trimmed.starts_with("#"):
            pass
        elif trimmed.contains("="):
            val parts = trimmed.split("=")
            if parts_len(parts) >= 2:
                val key = parts[0].trim()
                var rest_parts: [text] = []
                var i = 1
                while i < parts_len(parts):
                    rest_parts.push(parts[i])
                    i = i + 1
                val value = rest_parts.join("=").trim()
                data = data_set(data, key, value)
        elif trimmed.ends_with(":"):
            # Section header (key:) - store as nested marker
            val key = trimmed[0..trimmed_len(trimmed)-1].trim()
            data = data_set(data, key, {})

    Ok(SdnValue(data: data))

# Placeholder type
struct SdnValue:
    data: Dict<text, Any>


# ============================================================================
# SdnValue Methods (was: impl SdnValue:)
# ============================================================================

fn sdnvalue_empty() -> SdnValue:
        SdnValue(data: {})


# ============================================================================
# Exports
# ============================================================================

export CompilerContext, CompilerMode
export init_compiler, init_compiler_with_file, init_compiler_with_config
export get_context, get_engine
export run, run_file, compile, parse_sdn_safe
export ExecutionEngine, ExecutionResult, CompiledUnit
export InterpreterExecutionEngine, JitExecutionEngine, AotExecutionEngine, NoOpExecutionEngine
