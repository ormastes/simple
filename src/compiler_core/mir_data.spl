# MIR - Mid-level Intermediate Representation (Data Structures)
#
# Lower-level IR between HIR and native code generation.
# Features:
# - Explicit control flow (basic blocks, terminators)
# - Explicit memory operations (load, store, alloc)
# - SSA form (each value defined once)
# - Type-annotated values
# - Ready for optimization and codegen
#
# This module contains:
# - MIR module structure and function definitions
# - MIR type system
# - Basic block and instruction definitions
# - MIR builder API for constructing MIR

use hir.SymbolId
use lexer.Span
use blocks.value.BlockValue

# ============================================================================
# MIR Module Structure
# ============================================================================

struct MirModule:
    """Complete MIR module."""
    name: text
    functions: Dict<SymbolId, MirFunction>
    statics: Dict<SymbolId, MirStatic>
    constants: Dict<SymbolId, MirConstant>
    types: Dict<SymbolId, MirTypeDef>

struct MirFunction:
    """Function in MIR."""
    symbol: SymbolId
    name: text
    signature: MirSignature
    locals: [MirLocal]
    blocks: [MirBlock]
    entry_block: BlockId
    span: Span

    # Generic template metadata for .smf template storage
    generic_params: [text]
    is_generic_template: bool
    # # DESUGARED: specialization_of: text
    has_specialization_of: bool
    specialization_of: text
    type_bindings: Dict<text, HirType>

struct MirSignature:
    """Function signature."""
    params: [MirType]
    return_type: MirType
    is_variadic: bool

struct MirLocal:
    """Local variable slot."""
    id: LocalId
    # # DESUGARED: name: text
    has_name: bool
    name: text
    type_: MirType
    kind: LocalKind

struct LocalId:
    """Local variable identifier."""
    id: i64

"""Kind of local variable."""
enum LocalKind:
    Arg(index: i64)     # Function argument
    Var                  # Regular variable
    Temp                 # Temporary (SSA)
    Return               # Return slot

struct MirStatic:
    """Static/global variable."""
    symbol: SymbolId
    name: text
    type_: MirType
    # # DESUGARED: init: MirConstant
    has_init: bool
    init: MirConstant
    is_mutable: bool

struct MirConstant:
    """Compile-time constant."""
    symbol: SymbolId
    name: text
    type_: MirType
    value: MirConstValue

"""Constant value."""
enum MirConstValue:
    Int(value: i64)
    Float(value: f64)
    Bool(value: bool)
    Str(value: text)
    Array(elements: [MirConstValue])
    Tuple(elements: [MirConstValue])
    Struct(fields: Dict<text, MirConstValue>)
    Zero                 # Zero-initialized

struct MirTypeDef:
    """Type definition."""
    symbol: SymbolId
    name: text
    kind: MirTypeDefKind

"""Type definition kind."""
enum MirTypeDefKind:
    Struct(fields: [MirFieldDef])
    Enum(variants: [MirVariantDef])
    Union(variants: [MirType])

struct MirFieldDef:
    """Struct field definition."""
    name: text
    type_: MirType
    offset: i64

struct MirVariantDef:
    """Enum variant definition."""
    name: text
    discriminant: i64
    # # DESUGARED: payload: MirType
    has_payload: bool
    payload: MirType

# ============================================================================
# MIR Types
# ============================================================================

struct MirType:
    """MIR type."""
    kind: MirTypeKind

"""MIR type kind."""
enum MirTypeKind:
    # Primitives
    I8
    I16
    I32
    I64
    U8
    U16
    U32
    U64
    F32
    F64
    Bool
    Char
    Unit

    # Pointers and references
    Ptr(pointee: MirType, mutable: bool)
    Ref(referent: MirType, mutable: bool)
    FuncPtr(signature: MirSignature)

    # Aggregates
    Array(element: MirType, size: i64)
    Slice(element: MirType)
    Tuple(elements: [MirType])
    Struct(symbol: SymbolId)
    Enum(symbol: SymbolId)

    # Special
    Never              # !
    Opaque(name: text) # Foreign type

    # Async types
    Promise(inner: MirType)    # Promise<T> - async computation result
    Generator(yield_: MirType, return_: MirType)  # Generator yielding and returning types
    ActorType(message: MirType)    # Actor handling message type


# ============================================================================
# MirType Methods (was: impl MirType:)
# ============================================================================

fn mirtype_i64() -> MirType:
        MirType(kind: MirTypeKind.I64)


fn mirtype_f64() -> MirType:
        MirType(kind: MirTypeKind.F64)


fn mirtype_bool() -> MirType:
        MirType(kind: MirTypeKind.Bool)


fn mirtype_unit() -> MirType:
        MirType(kind: MirTypeKind.Unit)


fn mirtype_ptr(pointee: MirType, mutable: bool) -> MirType:
        MirType(kind: mirtypekind_Ptr(pointee, mutable))


fn mirtype_promise(inner: MirType) -> MirType:
        """Create Promise<T> type for async computations."""
        MirType(kind: mirtypekind_Promise(inner))


fn mirtype_generator(yield_ty: MirType, return_ty: MirType) -> MirType:
        """Create Generator<Y, R> type for generators."""
        MirType(kind: mirtypekind_Generator(yield_ty, return_ty))


fn mirtype_actor_type(message_ty: MirType) -> MirType:
        """Create ActorType<M> type for actors."""
        MirType(kind: mirtypekind_ActorType(message_ty))


# ============================================================================
# MIR Basic Blocks
# ============================================================================

struct BlockId:
    """Basic block identifier."""
    id: i64


# ============================================================================
# BlockId Methods (was: impl BlockId:)
# ============================================================================

fn blockid_new(id: i64) -> BlockId:
        BlockId(id: id)


fn blockid_entry() -> BlockId:
        blockid_new(0)


struct MirBlock:
    """Basic block."""
    id: BlockId
    # # DESUGARED: label: text
    has_label: bool
    label: text
    instructions: [MirInst]
    terminator: MirTerminator

# ============================================================================
# MIR Instructions
# ============================================================================

struct MirInst:
    """MIR instruction."""
    kind: MirInstKind
    # # DESUGARED: span: Span
    has_span: bool
    span: Span

"""MIR instruction kind."""
enum MirInstKind:
    # Constants
    Const(dest: LocalId, value: MirConstValue, type_: MirType)

    # Moves and copies
    Copy(dest: LocalId, src: LocalId)
    Move(dest: LocalId, src: LocalId)

    # Arithmetic
    BinOp(dest: LocalId, op: MirBinOp, left: MirOperand, right: MirOperand)
    UnaryOp(dest: LocalId, op: MirUnaryOp, operand: MirOperand)
    CheckedBinOp(dest: LocalId, op: MirBinOp, left: MirOperand, right: MirOperand)

    # Memory
    Alloc(dest: LocalId, type_: MirType)
    Load(dest: LocalId, ptr: MirOperand)
    Store(ptr: MirOperand, value: MirOperand)
    GetElementPtr(dest: LocalId, base: MirOperand, indices: [MirOperand])

    # Aggregates
    Aggregate(dest: LocalId, kind: AggregateKind, operands: [MirOperand])
    GetField(dest: LocalId, base: MirOperand, field: i64)
    SetField(base: MirOperand, field: i64, value: MirOperand)

    # Casts
    Cast(dest: LocalId, operand: MirOperand, target: MirType)
    Bitcast(dest: LocalId, operand: MirOperand, target: MirType)

    # Function calls
    Call(dest: LocalId, func: MirOperand, args: [MirOperand])
    CallIndirect(dest: LocalId, ptr: MirOperand, args: [MirOperand], sig: MirSignature)

    # Intrinsics
    Intrinsic(dest: LocalId, name: text, args: [MirOperand])

    # Inline assembly (must be in unsafe block)
    InlineAsm(
        asm_template: text,              # Assembly template with {operand} placeholders
        is_volatile: bool,               # Prevent optimization
        inputs: [MirAsmOperand],         # Input operands
        outputs: [MirAsmOperand],        # Output operands
        clobbers: [text]                 # Clobbered registers
    )

    # Pipeline operators (require runtime function dispatch)
    PipeForward(dest: LocalId, value: MirOperand, func: MirOperand)
    Compose(dest: LocalId, f: MirOperand, g: MirOperand, forward: bool)
    Parallel(dest: LocalId, funcs: [MirOperand])
    LayerConnect(dest: LocalId, layer1: MirOperand, layer2: MirOperand)

    # Debug
    DebugValue(local: LocalId, name: text)
    Nop

    # Async/Await Operations
    # Creates a Promise<T> from an async expression body
    CreatePromise(dest: LocalId, body: LocalId, result_type: MirType)
    # Awaits a Promise, suspending until resolved
    Await(dest: LocalId, promise: MirOperand)
    # Yields a value from a generator, suspending execution
    Yield(value: MirOperand?)
    # Spawns an async task/actor
    Spawn(dest: LocalId, handler: MirOperand, args: [MirOperand])
    # Sends a message to an actor
    Send(target: MirOperand, message: MirOperand)
    # Receives a message from mailbox (blocking with optional timeout)
    Receive(dest: LocalId, timeout: MirOperand?)

    # Borrow checking instructions
    Ref(dest: LocalId, borrow_kind: MirBorrowKind, place: MirPlace)

    # GPU Instructions
    # Kernel definition - wraps a function body as a GPU kernel
    # WORKAROUND: Parser bug with multiple params of same custom type
    # GpuKernelDef(name: text, params: [MirLocal], body_block: BlockId)
    # GpuLaunch(kernel: MirOperand, grid_dim: MirOperand, block_dim: MirOperand, args: [MirOperand])
    GpuKernelDef(name: text)
    GpuLaunch(args: [text])
    # Thread ID accessors (dim: 0=x, 1=y, 2=z)
    GpuGlobalId(dest: LocalId, dim: i64)    # Global thread ID
    GpuLocalId(dest: LocalId, dim: i64)     # Local thread ID within block
    GpuBlockId(dest: LocalId, dim: i64)     # Block/workgroup ID
    GpuBlockDim(dest: LocalId, dim: i64)    # Block dimensions
    GpuGridDim(dest: LocalId, dim: i64)     # Grid dimensions
    # Synchronization
    GpuBarrier(scope: GpuBarrierScope)      # Thread synchronization barrier
    GpuMemFence(scope: GpuMemoryScope)      # Memory fence
    # Shared memory
    GpuSharedAlloc(dest: LocalId, type_: MirType, size: i64)  # Allocate shared memory
    # Atomic operations
    GpuAtomicOp(dest: LocalId, op: GpuAtomicOpKind, ptr: MirOperand, value: MirOperand)

# ============================================================================
# GPU Support Types
# ============================================================================

"""Barrier scope for GPU synchronization."""
enum GpuBarrierScope:
    Workgroup   # Synchronize threads within workgroup/block
    Device      # Synchronize all threads on device (expensive)
    Subgroup    # Synchronize threads within subgroup/warp

"""Memory scope for GPU memory fences."""
enum GpuMemoryScope:
    Workgroup   # Workgroup-level memory visibility
    Device      # Device-level memory visibility
    QueueFamily # Vulkan queue family scope
    All         # All memory (host + device)

"""Atomic operation kinds for GPU."""
enum GpuAtomicOpKind:
    Add         # Atomic add
    Sub         # Atomic subtract
    And         # Atomic bitwise and
    Or          # Atomic bitwise or
    Xor         # Atomic bitwise xor
    Min         # Atomic min
    Max         # Atomic max
    Exchange    # Atomic exchange
    CompareExchange  # Compare and exchange

# ============================================================================
# Borrow Checking Support Types
# ============================================================================

"""Borrow kind for borrow checking."""
enum MirBorrowKind:
    Shared      # &T - immutable borrow
    Mutable     # &mut T - exclusive mutable borrow

"""Place projection for borrow checking."""
enum MirProjection:
    Deref               # *place
    Field(idx: i64)     # place.field_idx
    Index(local: LocalId) # place[idx_local]
    Downcast(variant: i64) # place as Variant

"""Memory place for borrow checking."""
struct MirPlace:
    local: LocalId
    projection: [MirProjection]


# ============================================================================
# MirPlace Methods (was: impl MirPlace:)
# ============================================================================

fn mirplace_local_place(id: LocalId) -> MirPlace:
        """Create a place referring to a local variable."""
        MirPlace(local: id, projection: [])


"""Function body wrapper for borrow checking."""
struct MirBody:
    name: text
    blocks: [MirBlock]
    locals: [MirLocal]
    arg_count: i64
    return_ty: MirType


# ============================================================================
# MirBody Methods (was: impl MirBody:)
# ============================================================================

fn mirbody_from_function(func: MirFunction) -> MirBody:
        """Create MirBody from MirFunction for borrow checking."""
        MirBody(
            name: func.name,
            blocks: func.blocks,
            locals: func.locals,
            arg_count: func.signature.params_len(params),
            return_ty: func.signature.return_type
        )


"""Binary operation."""
enum MirBinOp:
    # Arithmetic
    Add
    Sub
    Mul
    Div
    Rem
    Pow                         # **
    # Matrix operations
    MatMul                      # @
    # Bitwise
    BitAnd
    BitOr
    BitXor
    Shl
    Shr
    # Comparison
    Eq
    Ne
    Lt
    Le
    Gt
    Ge
    # Broadcast operations (dotted operators)
    BroadcastAdd                # .+
    BroadcastSub                # .-
    BroadcastMul                # .*
    BroadcastDiv                # ./
    BroadcastPow                # .^
    # Offset
    Offset  # Pointer arithmetic

"""Unary operation."""
enum MirUnaryOp:
    Neg
    Not
    BitNot
    Transpose   # ' (postfix, m{} only)

"""Aggregate construction kind."""
enum AggregateKind:
    Array(type_: MirType)
    Tuple
    Struct(symbol: SymbolId)
    Enum(symbol: SymbolId, variant: i64)

struct MirOperand:
    """Instruction operand."""
    kind: MirOperandKind

"""Operand kind."""
enum MirOperandKind:
    Copy(local: LocalId)
    Move(local: LocalId)
    Const(value: MirConstValue, type_: MirType)

# Helper: Copy MirFunction with new blocks (workaround for no struct spread syntax)
fn copy_mir_function_with_blocks(func: MirFunction, new_blocks: [MirBlock]) -> MirFunction:
    """Create a copy of MirFunction with modified blocks field.

    Common pattern in optimization passes that transform blocks but preserve
    all other function metadata.
    """
    MirFunction(
        symbol: func.symbol,
        name: func.name,
        signature: func.signature,
        locals: func.locals,
        blocks: new_blocks,
        entry_block: func.entry_block,
        span: func.span,
        generic_params: func.generic_params,
        is_generic_template: func.is_generic_template,
        specialization_of: func.specialization_of,
        type_bindings: func.type_bindings
    )

# Free functions for MirOperand construction (workaround for bootstrap)
fn mir_operand_copy(local: LocalId) -> MirOperand:
    MirOperand(kind: miroperandkind_Copy(local))

fn mir_operand_move(local: LocalId) -> MirOperand:
    MirOperand(kind: miroperandkind_Move(local))

fn mir_operand_const_int(value: i64) -> MirOperand:
    MirOperand(kind: miroperandkind_Const(MirConstValue.Int(value), mirtype_i64()))

fn mir_operand_const_float(value: f64) -> MirOperand:
    MirOperand(kind: miroperandkind_Const(MirConstValue.Float(value), mirtype_f64()))

fn mir_operand_const_bool(value: bool) -> MirOperand:
    MirOperand(kind: miroperandkind_Const(MirConstValue.Bool(value), mirtype_bool()))


# ============================================================================
# MirOperand Methods (was: impl MirOperand:)
# ============================================================================

fn miroperand_copy(local: LocalId) -> MirOperand:
        mir_operand_copy(local)


fn miroperand_move(local: LocalId) -> MirOperand:
        mir_operand_move(local)


fn miroperand_const_int(value: i64) -> MirOperand:
        mir_operand_const_int(value)


fn miroperand_const_float(value: f64) -> MirOperand:
        mir_operand_const_float(value)


fn miroperand_const_bool(value: bool) -> MirOperand:
        mir_operand_const_bool(value)


# ============================================================================
# MIR Terminators
# ============================================================================

"""Switch case mapping a constant value to a target block."""
struct SwitchCase:
    value: i64
    target: BlockId

"""Inline assembly operand."""
struct MirAsmOperand:
    """Assembly operand (input/output) with constraint information."""
    name: text                  # Operand name (e.g., "op", "result")
    kind: AsmConstraintKind     # in, out, inout, lateout
    location: AsmLocation       # reg, mem, imm, specific register
    operand: MirOperand         # MIR operand for the value

"""Block terminator."""
enum MirTerminator:
    # Unconditional
    Goto(target: BlockId)
    Return(value: MirOperand?)

    # Conditional
    If(cond: MirOperand, then_: BlockId, else_: BlockId)
    Switch(value: MirOperand, targets: [SwitchCase], default: BlockId)

    # Exceptional
    Unreachable
    Abort(message: text)

    # Call terminators (for unwinding)
    CallTerminator(
        dest: LocalId,
        func: MirOperand,
        args: [MirOperand],
        normal: BlockId,
        unwind: BlockId
    )

# ============================================================================
# MIR Builder
# ============================================================================

struct MirBuilder:
    """Builder for constructing MIR."""
    module: MirModule
    # # DESUGARED: current_function: MirFunction
    has_current_function: bool
    current_function: MirFunction
    current_block: BlockId
    next_local_id: i64
    next_block_id: i64
    locals: [MirLocal]
    blocks: [MirBlock]
    instructions: [MirInst]


# ============================================================================
# MirBuilder Methods (was: impl MirBuilder:)
# ============================================================================

fn mirbuilder_new() -> MirBuilder:
        MirBuilder(
            module: MirModule(
                name: "",
                functions: {},
                statics: {},
                constants: {},
                types: {}
            ),
            current_function: nil,
            current_block: blockid_entry(),
            next_local_id: 0,
            next_block_id: 1,
            locals: [],
            blocks: [],
            instructions: []
        )


fn mirbuilder_end_function(self: MirBuilder) -> MirFunction:
        """Finish building current function and return it."""
        # Finalize current block
        self.finalize_block()

        var fn_ = self.current_function_value
        fn_.locals = self.locals
        fn_.blocks = self.blocks
        self.current_function = nil
        fn_


fn mirbuilder_new_local(self: MirBuilder, name: text, type_: MirType, kind: LocalKind) -> LocalId:
        """Create a new local variable."""
        val id = LocalId(id: self.next_local_id)
        self.next_local_id = self.next_local_id + 1

        self.locals = self.locals.push(MirLocal(
            id: id,
            name: name,
            type_: type_,
            kind: kind
        ))

        id


fn mirbuilder_new_temp(self: MirBuilder, type_: MirType) -> LocalId:
        """Create a new temporary."""
        self.new_local(nil, type_, LocalKind.Temp)


fn mirbuilder_new_block(self: MirBuilder, label: text?) -> BlockId:
        """Create a new basic block."""
        val id = blockid_new(self.next_block_id)
        self.next_block_id = self.next_block_id + 1

        self.blocks = self.blocks.push(MirBlock(
            id: id,
            label: label,
            instructions: [],
            terminator: MirTerminator.Unreachable  # Placeholder
        ))

        id


fn mirbuilder_emit_const_int(self: MirBuilder, value: i64) -> LocalId:
        """Emit an integer constant and return its local."""
        val dest = self.new_temp(MirType.i64())
        self.emit_const(dest, MirConstValue.Int(value), mirtype_i64())
        dest


fn mirbuilder_emit_const_float(self: MirBuilder, value: f64) -> LocalId:
        """Emit a float constant and return its local."""
        val dest = self.new_temp(MirType.f64())
        self.emit_const(dest, MirConstValue.Float(value), mirtype_f64())
        dest


fn mirbuilder_emit_const_bool(self: MirBuilder, value: bool) -> LocalId:
        """Emit a boolean constant and return its local."""
        val dest = self.new_temp(MirType.bool())
        self.emit_const(dest, MirConstValue.Bool(value), mirtype_bool())
        dest


fn mirbuilder_emit_binop(self: MirBuilder, op: MirBinOp, left: MirOperand, right: MirOperand, type_: MirType) -> LocalId:
        """Emit a binary operation and return result local."""
        val dest = self.new_temp(type_)
        self.emit(MirInst(
            kind: mirinstkind_BinOp(dest, op, left, right),
            span: nil
        ))
        dest


fn mirbuilder_emit_unary(self: MirBuilder, op: MirUnaryOp, operand: MirOperand, type_: MirType) -> LocalId:
        """Emit a unary operation and return result local."""
        val dest = self.new_temp(type_)
        self.emit(MirInst(
            kind: mirinstkind_UnaryOp(dest, op, operand),
            span: nil
        ))
        dest


fn mirbuilder_emit_load(self: MirBuilder, ptr: MirOperand, type_: MirType) -> LocalId:
        """Emit a load instruction."""
        val dest = self.new_temp(type_)
        self.emit(MirInst(
            kind: mirinstkind_Load(dest, ptr),
            span: nil
        ))
        dest


fn mirbuilder_emit_alloc(self: MirBuilder, type_: MirType) -> LocalId:
        """Emit an allocation."""
        val dest = self.new_temp(MirType.ptr(type_, true))
        self.emit(MirInst(
            kind: mirinstkind_Alloc(dest, type_),
            span: nil
        ))
        dest


fn mirbuilder_emit_cast(self: MirBuilder, operand: MirOperand, target: MirType) -> LocalId:
        """Emit a type cast."""
        val dest = self.new_temp(target)
        self.emit(MirInst(
            kind: mirinstkind_Cast(dest, operand, target),
            span: nil
        ))
        dest


fn mirbuilder_emit_aggregate(self: MirBuilder, kind: AggregateKind, operands: [MirOperand], type_: MirType) -> LocalId:
        """Emit aggregate construction."""
        val dest = self.new_temp(type_)
        self.emit(MirInst(
            kind: mirinstkind_Aggregate(dest, kind, operands),
            span: nil
        ))
        dest


fn mirbuilder_emit_get_field(self: MirBuilder, base: MirOperand, field: i64, type_: MirType) -> LocalId:
        """Emit field access."""
        val dest = self.new_temp(type_)
        self.emit(MirInst(
            kind: mirinstkind_GetField(dest, base, field),
            span: nil
        ))
        dest


fn mirbuilder_emit_gep(self: MirBuilder, base: MirOperand, indices: [MirOperand], type_: MirType) -> LocalId:
        """Emit GetElementPtr instruction."""
        val dest = self.new_temp(type_)
        self.emit(MirInst(
            kind: mirinstkind_GetElementPtr(dest, base, indices),
            span: nil
        ))
        dest


# ============================================================================
# Exports
# ============================================================================

export MirModule, MirFunction, MirSignature, MirLocal, LocalId, LocalKind
export MirStatic, MirConstant, MirConstValue
export MirTypeDef, MirTypeDefKind, MirFieldDef, MirVariantDef
export MirType, MirTypeKind
export BlockId, MirBlock
export MirInst, MirInstKind, MirBinOp, MirUnaryOp, AggregateKind
export MirOperand, MirOperandKind
export MirAsmOperand
export MirTerminator
export MirBuilder
export copy_mir_function_with_blocks
export mir_operand_copy, mir_operand_move, mir_operand_const_int, mir_operand_const_float, mir_operand_const_bool

# Borrow checking support types
export MirBorrowKind, MirPlace, MirProjection, MirBody

# GPU support types
export GpuBarrierScope, GpuMemoryScope, GpuAtomicOpKind
