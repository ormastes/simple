# String Extractor for Baremetal Compilation
#
# Walks AST and extracts all print/semihosting strings for string interning.
# Generates SMF subset file (metadata only) for later table building.

use app.parser.ast

# Metadata for a single extracted string
class StringMetadata:
    id: i32
    text: text
    param_count: i32
    param_names: [text]      # NEW: Variable names from {name} patterns
    format_types: [i32]
    source_file: text
    source_line: i32


# ============================================================================
# StringMetadata Methods (was: impl StringMetadata:)
# ============================================================================

fn stringmetadata_create(id: i32, text: text, params: i32) -> StringMetadata:
        StringMetadata(
            id: id,
            text: text,
            param_count: params,
            param_names: [],     # NEW: Empty by default
            format_types: [],
            source_file: "",
            source_line: 0
        )


# String extraction result
class StringExtractionResult:
    strings: [StringMetadata]
    count: i32


# ============================================================================
# StringExtractionResult Methods (was: impl StringExtractionResult:)
# ============================================================================

fn stringextractionresult_empty() -> StringExtractionResult:
        StringExtractionResult(strings: [], count: 0)


# Main extractor class
class StringExtractor:
    next_id: i32
    result: StringExtractionResult


# ============================================================================
# StringExtractor Methods (was: impl StringExtractor:)
# ============================================================================

fn stringextractor_create() -> StringExtractor:
        StringExtractor(
            next_id: 1,
            result: stringextractionresult_empty()
        )


# Generate SMF subset file from extraction result
fn generate_smf_subset(
    result: StringExtractionResult,
    output_path: text,
    source_file: text,
    target: text
) -> bool:
    var sdn = ""

    # Header
    sdn = sdn + "# String Metadata Subset (SMF format)\n"
    sdn = sdn + "# Generated by Simple compiler for baremetal target\n"
    sdn = sdn + "\n"

    # Metadata section
    sdn = sdn + "metadata:\n"
    sdn = sdn + "  version: 1\n"
    sdn = sdn + "  format: \"smf_subset\"\n"
    sdn = sdn + "  target: \"{target}\"\n"
    sdn = sdn + "  source: \"{source_file}\"\n"
    sdn = sdn + "  string_count: {result.count}\n"
    sdn = sdn + "\n"

    # Strings section
    sdn = sdn + "strings:\n"

    for string in result.strings:
        sdn = sdn + "  - id: {string.id}\n"
        sdn = sdn + "    text: \"{escape_string(string.text)}\"\n"
        sdn = sdn + "    params: {string.param_count}\n"

        # Add parameter names if any
        if string.param_names_len(param_names) > 0:
            sdn = sdn + "    param_names: ["
            var first = true
            for name in string.param_names:
                if not first:
                    sdn = sdn + ", "
                if name_len(name) > 0:
                    sdn = sdn + "\"{name}\""
                else:
                    sdn = sdn + "\"\""  # Empty string for positional {}
                first = false
            sdn = sdn + "]\n"

        sdn = sdn + "    format_types: []\n"

        if string.source_file_len(source_file) > 0:
            sdn = sdn + "    source_file: \"{string.source_file}\"\n"
            sdn = sdn + "    source_line: {string.source_line}\n"

        sdn = sdn + "\n"

    # Write to file
    file_write(output_path, sdn)

# Escape string for SDN format
fn escape_string(s: text) -> text:
    var result = ""
    var i = 0

    while i < s_len(s):
        val ch = s[i:i+1]

        if ch == "\n":
            result = result + "\\n"
        elif ch == "\t":
            result = result + "\\t"
        elif ch == "\"":
            result = result + "\\\""
        elif ch == "\\":
            result = result + "\\\\"
        else:
            result = result + ch

        i = i + 1

    result

# Helper function - writes text to file
fn file_write(path: text, content: text) -> bool:
    # Import from app.io (Phase 1B.7 - TODO #64 âœ…)
    use app.io.{file_write as io_file_write}
    io_file_write(path, content)
    true
