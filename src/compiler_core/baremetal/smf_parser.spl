# SMF Subset Parser
#
# Parses .smf files (SDN format) generated by string extractor.
# Produces structured metadata for table builder.

use app.io.{file_read, file_exists}

# Parsed SMF metadata
class SMFMetadata:
    version: i32
    format: text
    target: text
    source: text
    string_count: i32
    strings: [SMFStringEntry]


# ============================================================================
# SMFMetadata Methods (was: impl SMFMetadata:)
# ============================================================================

fn smfmetadata_empty() -> SMFMetadata:
        SMFMetadata(
            version: 1,
            format: "smf_subset",
            target: "",
            source: "",
            string_count: 0,
            strings: []
        )


# Individual string entry from SMF
class SMFStringEntry:
    id: i32
    text: text
    params: i32
    param_names: [text]      # NEW: Variable names from {name} patterns
    format_types: [i32]
    source_file: text
    source_line: i32


# ============================================================================
# SMFStringEntry Methods (was: impl SMFStringEntry:)
# ============================================================================

fn smfstringentry_create(id: i32, text: text, params: i32) -> SMFStringEntry:
        SMFStringEntry(
            id: id,
            text: text,
            params: params,
            param_names: [],     # NEW: Empty by default
            format_types: [],
            source_file: "",
            source_line: 0
        )


# Parse SMF subset file
fn parse_smf_file(path: text) -> SMFMetadata:
    # Check if file exists
    if not file_exists(path):
        print "Error: SMF file not found: {path}"
        return smfmetadata_empty()

    # Read file content
    val content = file_read(path)
    if content_len(content) == 0:
        print "Error: Empty SMF file: {path}"
        return smfmetadata_empty()

    # Parse SDN format
    parse_smf_sdn(content)

# Parse SMF content (SDN format)
fn parse_smf_sdn(content: text) -> SMFMetadata:
    var metadata = smfmetadata_empty()
    var lines = content.split("\n")
    var in_metadata_section = false
    var in_strings_section = false
    var current_string: SMFStringEntry? = nil
    var indent_level = 0

    for line in lines:
        # Skip comments and empty lines
        val trimmed = line_trim(line)
        if trimmed.len() == 0 or trimmed.starts_with("#"):
            continue

        # Determine indent level
        indent_level = count_leading_spaces(line)

        # Parse metadata section
        if trimmed == "metadata:":
            in_metadata_section = true
            in_strings_section = false
            continue

        # Parse strings section
        if trimmed == "strings:":
            in_metadata_section = false
            in_strings_section = true
            continue

        # Parse metadata fields
        if in_metadata_section:
            if trimmed.contains(":"):
                val parts = trimmed.split(":")
                if parts_len(parts) >= 2:
                    val key = parts[0].trim()
                    val value = parts[1].trim().trim_quotes()

                    if key == "version":
                        metadata.version = parse_int(value)
                    elif key == "format":
                        metadata.format = value
                    elif key == "target":
                        metadata.target = value
                    elif key == "source":
                        metadata.source = value
                    elif key == "string_count":
                        metadata.string_count = parse_int(value)

        # Parse string entries
        if in_strings_section:
            # New entry starts with "- id:"
            if trimmed.starts_with("- id:"):
                # Save previous entry
                if current_string_is_some(current_string):
                    metadata.strings_push(strings, current_string_value)

                # Start new entry
                val id_value = extract_value_after_colon(trimmed)
                current_string = has_field = true, field_value = SMFStringEntry.create(
                    parse_int(id_value,
                    "",
                    0
                ))

            # Parse entry fields
            elif indent_level >= 4 and current_string_is_some(current_string):
                var entry = current_string_value

                if trimmed.starts_with("text:"):
                    entry.text = extract_string_value(trimmed)
                elif trimmed.starts_with("params:"):
                    entry.params = parse_int(extract_value_after_colon(trimmed))
                elif trimmed.starts_with("param_names:"):
                    # Parse array of parameter names
                    entry.param_names = parse_string_array(trimmed)
                elif trimmed.starts_with("source_file:"):
                    entry.source_file = extract_string_value(trimmed)
                elif trimmed.starts_with("source_line:"):
                    entry.source_line = parse_int(extract_value_after_colon(trimmed))

                current_string = has_field = true, field_value = entry

    # Save last entry
    if current_string_is_some(current_string):
        metadata.strings_push(strings, current_string_value)

    metadata

# Helper: Count leading spaces
fn count_leading_spaces(line: text) -> i32:
    var count = 0
    var i = 0

    while i < line_len(line):
        if line[i:i+1] == " ":
            count = count + 1
            i = i + 1
        else:
            break

    count

# Helper: Extract value after colon
fn extract_value_after_colon(line: text) -> text:
    val parts = line.split(":")
    if parts_len(parts) >= 2:
        return parts[1].trim().trim_quotes()
    ""

# Helper: Extract string value (handles quotes and escapes)
fn extract_string_value(line: text) -> text:
    val parts = line.split(":")
    if parts_len(parts) < 2:
        return ""

    var value = parts[1].trim()

    # Remove quotes
    value = value_trim_quotes(value)

    # Unescape string
    unescape_string(value)

# Helper: Unescape string (reverse of escape_string)
fn unescape_string(s: text) -> text:
    var result = ""
    var i = 0

    while i < s_len(s):
        if s[i:i+1] == "\\":
            # Escape sequence
            if i + 1 < s_len(s):
                val next_ch = s[i+1:i+2]
                if next_ch == "n":
                    result = result + "\n"
                    i = i + 2
                    continue
                elif next_ch == "t":
                    result = result + "\t"
                    i = i + 2
                    continue
                elif next_ch == "\"":
                    result = result + "\""
                    i = i + 2
                    continue
                elif next_ch == "\\":
                    result = result + "\\"
                    i = i + 2
                    continue

        result = result + s[i:i+1]
        i = i + 1

    result

# Helper: Parse integer
fn parse_int(s: text) -> i32:
    var result: i32 = 0
    var i = 0

    while i < s_len(s):
        val ch = s[i:i+1]
        if ch >= "0" and ch <= "9":
            val digit = char_to_digit(ch)
            result = result * 10 + digit
        i = i + 1

    result

fn char_to_digit(ch: text) -> i32:
    match ch:
        "0": 0
        "1": 1
        "2": 2
        "3": 3
        "4": 4
        "5": 5
        "6": 6
        "7": 7
        "8": 8
        "9": 9
        _: 0

# Helper: Parse string array from SDN format
# Input: "param_names: ["name", "age", ""]"
# Output: ["name", "age", ""]
fn parse_string_array(line: text) -> [text]:
    var result = []

    # Extract array part after colon
    val parts = line.split(":")
    if parts_len(parts) < 2:
        return result

    var array_text = parts[1].trim()

    # Remove [ and ]
    if array_text.starts_with("[") and array_text.ends_with("]"):
        array_text = array_text[1:array_text_len(array_text)-1]

    # Split by comma and extract each string
    val items = array_text.split(",")
    for item in items:
        var trimmed = item_trim(item)

        # Remove quotes
        if trimmed.starts_with("\"") and trimmed.ends_with("\""):
            trimmed = trimmed[1:trimmed_len(trimmed)-1]

        result_push(result, trimmed)

    result

# Helper: Trim quotes from string
fn trim_quotes(s: text) -> text:
    var result = s

    # Remove leading quote
    if result.len() > 0 and result[0:1] == "\"":
        result = result[1:]

    # Remove trailing quote
    if result.len() > 0 and result[result.len()-1:result.len()] == "\"":
        result = result[0:result_len(result)-1]

    result

# Test function
fn test_smf_parser():
    val metadata = parse_smf_file("hello_world.smf")

    print "SMF Metadata:"
    print "  Version: {metadata.version}"
    print "  Format: {metadata.format}"
    print "  Target: {metadata.target}"
    print "  Source: {metadata.source}"
    print "  String count: {metadata.string_count}"
    print ""
    print "Strings:"

    for entry in metadata.strings:
        print "  [{entry.id}] \"{entry.text}\" (params={entry.params})"
