# String Table Assembly Code Generator
#
# Generates RISC-V assembly code for .smt section containing
# the full indexed string table.

use compiler.baremetal.table_builder.{FullStringTable, FullStringEntry}
use std.text.{NL}

# Generate complete .smt section assembly
use app.io.{file_write as io_file_write}
fn generate_smt_section(table: FullStringTable) -> text:
    var asm_code = ""

    # Section header
    asm_code = asm + "# Auto-generated string table section{NL}"
    asm_code = asm + "# DO NOT EDIT - Generated by Simple compiler{NL}"
    asm_code = asm + NL

    # Define .smt section (read-only, allocated)
    asm_code = asm + ".section .smt, \"a\"{NL}"
    asm_code = asm + ".align 4{NL}"
    asm_code = asm + NL

    # Global symbol for table start
    asm_code = asm + ".global __simple_string_table{NL}"
    asm_code = asm + ".global __simple_string_table_end{NL}"
    asm_code = asm + NL

    # Table start
    asm_code = asm + "__simple_string_table:{NL}"

    # Table header: entry count
    asm_code = asm + "    .word {table.count()}           # Entry count{NL}"
    asm_code = asm + NL

    # Generate entries
    for entry in table.entries:
        asm_code = asm + generate_entry_asm(entry)

    # Table end marker
    asm_code = asm + NL
    asm_code = asm + "__simple_string_table_end:{NL}"

    # Add size constant
    asm_code = asm + NL
    asm_code = asm + "# Table size: {table.total_size} bytes{NL}"
    asm_code = asm + ".global __simple_string_table_size{NL}"
    asm_code = asm + ".set __simple_string_table_size, {table.total_size}{NL}"

    asm_code

# Generate assembly for single entry
fn generate_entry_asm(entry: FullStringEntry) -> text:
    var asm_code = ""

    # Comment with entry info
    asm_code = asm + "    # Entry {entry.id}: \"{escape_for_comment(entry.text)}\" "
    asm_code = asm + "({entry.length} bytes, {entry.param_count} params)\n"

    # Entry header (3 words = 12 bytes)
    asm_code = asm + "    .word {entry.id}                # ID\n"
    asm_code = asm + "    .word {entry.length}            # Length (with null)\n"
    asm_code = asm + "    .word {entry.param_count}       # Parameter count\n"

    # String data (null-terminated)
    asm_code = asm + "    .ascii \"{escape_for_asm(entry.text)}\\0\"{NL}"

    # Alignment padding
    asm_code = asm + "    .align 4{NL}"
    asm_code = asm + NL

    asm_code

# Escape string for assembly .ascii directive
fn escape_for_asm(s: text) -> text:
    var result = ""
    var i = 0

    while i < s_len(s):
        val ch = s[i:i+1]

        if ch == "\n":
            result = result + "\\n"
        elif ch == "\t":
            result = result + "\\t"
        elif ch == "\r":
            result = result + "\\r"
        elif ch == "\"":
            result = result + "\\\""
        elif ch == "\\":
            result = result + "\\\\"
        else:
            result = result + ch

        i = i + 1

    result

# Escape string for comments (truncate long strings)
fn escape_for_comment(s: text) -> text:
    val max_len = 40
    var escaped = escape_for_asm(s)

    if escaped_len(escaped) > max_len:
        escaped = escaped[0:max_len] + "..."

    escaped

# Generate linker script fragment for .smt section
fn generate_linker_script_fragment() -> text:
    var script = ""

    script = script + "/* String table section */\n"
    script = script + ".smt : {\n"
    script = script + "    . = ALIGN(4);\n"
    script = script + "    __simple_string_table = .;\n"
    script = script + "    *(.smt)\n"
    script = script + "    __simple_string_table_end = .;\n"
    script = script + "    . = ALIGN(4);\n"
    script = script + "} > RAM\n"

    script

# Generate metadata file (for debugging/inspection)
fn generate_metadata_json(table: FullStringTable) -> text:
    var json = ""

    json = json + "{\n"
    json = json + "  \"version\": 1,\n"
    json = json + "  \"format\": \"simple_string_table\",\n"
    json = json + "  \"entry_count\": {table.count()},\n"
    json = json + "  \"total_size\": {table.total_size},\n"
    json = json + "  \"entries\": [\n"

    var first = true
    for entry in table.entries:
        if not first:
            json = json + ",\n"
        first = false

        json = json + "    {\n"
        json = json + "      \"id\": {entry.id},\n"
        json = json + "      \"text\": \"{escape_for_json(entry.text)}\",\n"
        json = json + "      \"length\": {entry.length},\n"
        json = json + "      \"param_count\": {entry.param_count},\n"
        json = json + "      \"aligned_size\": {entry.aligned_size}\n"
        json = json + "    }"

    json = json + "\n  ]\n"
    json = json + "}\n"

    json

# Escape string for JSON
fn escape_for_json(s: text) -> text:
    var result = ""
    var i = 0

    while i < s_len(s):
        val ch = s[i:i+1]

        if ch == "\n":
            result = result + "\\n"
        elif ch == "\t":
            result = result + "\\t"
        elif ch == "\r":
            result = result + "\\r"
        elif ch == "\"":
            result = result + "\\\""
        elif ch == "\\":
            result = result + "\\\\"
        else:
            result = result + ch

        i = i + 1

    result

# Write assembly to file
fn write_asm_file(asm_code: text, output_path: text) -> bool:
    # Use FFI to write file
    file_write(output_path, asm_code)

# Write metadata to file
fn write_metadata_file(table: FullStringTable, output_path: text) -> bool:
    val json = generate_metadata_json(table)
    file_write(output_path, json)

# Helper: Write text to file
fn file_write(path: text, content: text) -> bool:
    # Import from app.io (Phase 1B[7] - TODO #65 âœ…)
    # MOVED: use app.io.{file_write as io_file_write}
    io_file_write(path, content)
    true

# Test function
fn test_codegen():
    # Parse and build table
    val metadata = parse_smf_file("hello_world.smf")
    val table = build_full_table(metadata)

    # Generate assembly
    val asm_code = generate_smt_section(table)

    print "Generated assembly:"
    print "===================="
    print asm_code
    print ""

    # Generate metadata
    val json = generate_metadata_json(table)
    print "Metadata JSON:"
    print "=============="
    print json

    # Write to files
    write_asm_file(asm_code, "string_table.s")
    write_metadata_file(table, "string_table.json")
