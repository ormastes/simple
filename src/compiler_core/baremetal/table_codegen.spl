# String Table Assembly Code Generator
#
# Generates RISC-V assembly code for .smt section containing
# the full indexed string table.

use compiler.baremetal.table_builder.{FullStringTable, FullStringEntry}

# Generate complete .smt section assembly
fn generate_smt_section(table: FullStringTable) -> text:
    var asm = ""

    # Section header
    asm = asm + "# Auto-generated string table section\n"
    asm = asm + "# DO NOT EDIT - Generated by Simple compiler\n"
    asm = asm + "\n"

    # Define .smt section (read-only, allocated)
    asm = asm + ".section .smt, \"a\"\n"
    asm = asm + ".align 4\n"
    asm = asm + "\n"

    # Global symbol for table start
    asm = asm + ".global __simple_string_table\n"
    asm = asm + ".global __simple_string_table_end\n"
    asm = asm + "\n"

    # Table start
    asm = asm + "__simple_string_table:\n"

    # Table header: entry count
    asm = asm + "    .word {table.count()}           # Entry count\n"
    asm = asm + "\n"

    # Generate entries
    for entry in table.entries:
        asm = asm + generate_entry_asm(entry)

    # Table end marker
    asm = asm + "\n"
    asm = asm + "__simple_string_table_end:\n"

    # Add size constant
    asm = asm + "\n"
    asm = asm + "# Table size: {table.total_size} bytes\n"
    asm = asm + ".global __simple_string_table_size\n"
    asm = asm + ".set __simple_string_table_size, {table.total_size}\n"

    asm

# Generate assembly for single entry
fn generate_entry_asm(entry: FullStringEntry) -> text:
    var asm = ""

    # Comment with entry info
    asm = asm + "    # Entry {entry.id}: \"{escape_for_comment(entry.text)}\" "
    asm = asm + "({entry.length} bytes, {entry.param_count} params)\n"

    # Entry header (3 words = 12 bytes)
    asm = asm + "    .word {entry.id}                # ID\n"
    asm = asm + "    .word {entry.length}            # Length (with null)\n"
    asm = asm + "    .word {entry.param_count}       # Parameter count\n"

    # String data (null-terminated)
    asm = asm + "    .ascii \"{escape_for_asm(entry.text)}\\0\"\n"

    # Alignment padding
    asm = asm + "    .align 4\n"
    asm = asm + "\n"

    asm

# Escape string for assembly .ascii directive
fn escape_for_asm(s: text) -> text:
    var result = ""
    var i = 0

    while i < s_len(s):
        val ch = s[i:i+1]

        if ch == "\n":
            result = result + "\\n"
        elif ch == "\t":
            result = result + "\\t"
        elif ch == "\r":
            result = result + "\\r"
        elif ch == "\"":
            result = result + "\\\""
        elif ch == "\\":
            result = result + "\\\\"
        else:
            result = result + ch

        i = i + 1

    result

# Escape string for comments (truncate long strings)
fn escape_for_comment(s: text) -> text:
    val max_len = 40
    var escaped = escape_for_asm(s)

    if escaped_len(escaped) > max_len:
        escaped = escaped[0:max_len] + "..."

    escaped

# Generate linker script fragment for .smt section
fn generate_linker_script_fragment() -> text:
    var script = ""

    script = script + "/* String table section */\n"
    script = script + ".smt : {\n"
    script = script + "    . = ALIGN(4);\n"
    script = script + "    __simple_string_table = .;\n"
    script = script + "    *(.smt)\n"
    script = script + "    __simple_string_table_end = .;\n"
    script = script + "    . = ALIGN(4);\n"
    script = script + "} > RAM\n"

    script

# Generate metadata file (for debugging/inspection)
fn generate_metadata_json(table: FullStringTable) -> text:
    var json = ""

    json = json + "{\n"
    json = json + "  \"version\": 1,\n"
    json = json + "  \"format\": \"simple_string_table\",\n"
    json = json + "  \"entry_count\": {table.count()},\n"
    json = json + "  \"total_size\": {table.total_size},\n"
    json = json + "  \"entries\": [\n"

    var first = true
    for entry in table.entries:
        if not first:
            json = json + ",\n"
        first = false

        json = json + "    {\n"
        json = json + "      \"id\": {entry.id},\n"
        json = json + "      \"text\": \"{escape_for_json(entry.text)}\",\n"
        json = json + "      \"length\": {entry.length},\n"
        json = json + "      \"param_count\": {entry.param_count},\n"
        json = json + "      \"aligned_size\": {entry.aligned_size}\n"
        json = json + "    }"

    json = json + "\n  ]\n"
    json = json + "}\n"

    json

# Escape string for JSON
fn escape_for_json(s: text) -> text:
    var result = ""
    var i = 0

    while i < s_len(s):
        val ch = s[i:i+1]

        if ch == "\n":
            result = result + "\\n"
        elif ch == "\t":
            result = result + "\\t"
        elif ch == "\r":
            result = result + "\\r"
        elif ch == "\"":
            result = result + "\\\""
        elif ch == "\\":
            result = result + "\\\\"
        else:
            result = result + ch

        i = i + 1

    result

# Write assembly to file
fn write_asm_file(asm: text, output_path: text) -> bool:
    # Use FFI to write file
    file_write(output_path, asm)

# Write metadata to file
fn write_metadata_file(table: FullStringTable, output_path: text) -> bool:
    val json = generate_metadata_json(table)
    file_write(output_path, json)

# Helper: Write text to file
fn file_write(path: text, content: text) -> bool:
    # Import from app.io (Phase 1B.7 - TODO #65 âœ…)
    use app.io.{file_write as io_file_write}
    io_file_write(path, content)
    true

# Test function
fn test_codegen():
    # Parse and build table
    val metadata = parse_smf_file("hello_world.smf")
    val table = build_full_table(metadata)

    # Generate assembly
    val asm = generate_smt_section(table)

    print "Generated assembly:"
    print "===================="
    print asm
    print ""

    # Generate metadata
    val json = generate_metadata_json(table)
    print "Metadata JSON:"
    print "=============="
    print json

    # Write to files
    write_asm_file(asm, "string_table.s")
    write_metadata_file(table, "string_table.json")
