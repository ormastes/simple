# Unified Compilation Context
#
# Shared trait for compiler, JIT, and linker so all three paths
# apply AOP, DI, contracts, and codegen through the same interface.
#
# Enhanced from 104 lines to include: CompiledUnit, Test contract mode,
# coverage integration, weaving pipeline, DI container, instantiation records.

# Note: backend_types, di, aop, monomorphize.note_sdn are used by
# implementations but not needed for the trait definition itself.

# ============================================================================
# Enums
# ============================================================================

enum InstantiationMode:
    """When instantiation occurs."""
    CompileTime
    LinkTime
    JitTime


# ============================================================================
# InstantiationMode Methods (was: impl InstantiationMode:)
# ============================================================================

enum ContractMode:
    """How much contract checking to apply."""
    Off        # No contracts (CTR-040)
    Boundary   # Only at module boundaries (CTR-041)
    All        # All contracts (CTR-042)
    Test       # All contracts + rich diagnostics (CTR-043)


# ============================================================================
# ContractMode Methods (was: impl ContractMode:)
# ============================================================================

# ============================================================================
# GenericTemplate
# ============================================================================

struct GenericTemplate:
    """A generic template loaded from AST cache or SMF."""
    name: text
    type_params: [text]
    ast_data: Any

struct ConcreteType:
    """A concrete type used for instantiation."""
    name: text


# ============================================================================
# ConcreteType Methods (was: impl ConcreteType:)
# ============================================================================

# ============================================================================
# TypeRegistry
# ============================================================================

struct TypeRegistry:
    """Registry of known types."""
    types: Dict<text, Any>


# ============================================================================
# TypeRegistry Methods (was: impl TypeRegistry:)
# ============================================================================

# ============================================================================
# CompiledUnit (output of compilation)
# ============================================================================

struct CompiledUnit:
    """Output of compiling a template or module."""
    name: text
    symbols: [text]             # Exported symbols
    code: Any                   # Generated code (backend-specific)
    effects: [text]             # Detected effects
    instantiation_mode: InstantiationMode


# ============================================================================
# CompiledUnit Methods (was: impl CompiledUnit:)
# ============================================================================

fn compiledunit_empty(name: text, mode: InstantiationMode) -> i64:
        # Stub: CompiledUnit struct return not supported in seed_cpp
        0


# ============================================================================
# Instantiation Record (tracking)
# ============================================================================

struct InstantiationRecord:
    """Records a generic instantiation for debugging and optimization."""
    template_name: text
    type_args: [text]
    mode: InstantiationMode
    # # DESUGARED: source_module: text
    has_source_module: bool
    source_module: text

# ============================================================================
# CompilationContext Trait
# ============================================================================

trait CompilationContext:
    """Unified compilation interface for compiler, JIT, and linker.

    All three paths use this to ensure AOP/DI/contracts are applied
    consistently. The pipeline is:
      1. Load template
      2. Apply DI bindings
      3. Lower to HIR â†’ MIR
      4. Weave AOP advice at MIR level
      5. Insert contract checks
      6. Codegen
    """

    # Template management (source differs per context)
    fn load_template(name: text) -> GenericTemplate:
    fn has_template(name: text) -> bool:

    # Type system
    fn type_registry() -> TypeRegistry:

    # Pipeline configuration
    fn contract_mode() -> ContractMode:
        pass
    fn di_container() -> Any:
        pass
    fn aop_weaver() -> Any:
        pass
    fn coverage_enabled() -> bool:
        pass

    # Full pipeline: template -> compiled code
    fn compile_template(tmpl: GenericTemplate, type_args: [ConcreteType]) -> text:

    # Metadata tracking
    fn instantiation_mode() -> InstantiationMode:
    me record_instantiation(entry: InstantiationRecord):

    # Query recorded instantiations
    fn instantiation_count() -> i64:

# ============================================================================
# Exports
# ============================================================================

export CompilationContext
export InstantiationMode, ContractMode
export GenericTemplate, ConcreteType, TypeRegistry
export CompiledUnit, InstantiationRecord
