# Compiler Error Types
#
# Comprehensive error handling for the Simple compiler.
# Port of rust/compiler/src/error.rs (1789 lines)
#
# Provides error types, diagnostic context, and error factory functions.

use error_codes.*
from parser_types import {Span}

export CompileError, ErrorContext, Severity
export error_factory  # Module containing all factory functions

# ============================================================================
# Error Severity
# ============================================================================

enum Severity:
    Error
    Warning
    Note
    Help


# ============================================================================
# Severity Methods (was: impl Severity:)
# ============================================================================

# ============================================================================
# Error Context
# ============================================================================

class ErrorContext:
    """Rich diagnostic context for errors with spans, labels, and suggestions."""

    span: Span
    secondary_spans: [(Span, text)]
    file: text
    source: text
    code: text
    notes: [text]
    help: [text]


# ============================================================================
# ErrorContext Methods (was: impl ErrorContext:)
# ============================================================================

fn errorcontext_empty() -> ErrorContext:
        """Create a new empty error context."""
        ErrorContext(
            #  # DESUGARED: span: nil
            secondary_spans: [],
            #  # DESUGARED: file: nil
            #  # DESUGARED: source: nil
            #  # DESUGARED: code: nil
            notes: [],
            help: []
        )


# ============================================================================
# Compile Error Enum
# ============================================================================

enum CompileError:
    """Compilation errors with optional rich context."""

    # Simple variants (message only)
    Io(text)
    Parse(text)
    Semantic(text)
    Codegen(text)
    Lint(text)
    Runtime(text)

    # Special variants
    TryError(Value)                              # Error from ? operator
    InterruptedByUser                            # Ctrl-C
    GhostError(text)                             # Ghost code verification

    # Execution limit variants
    ExecutionLimitExceeded(limit: i64, message: text)
    StackOverflow(depth: i64, limit: i64, function_name: text)
    TimeoutExceeded(timeout_secs: i64)

    # Rich variants with context
    IoWithContext(message: text, context: ErrorContext)
    ParseWithContext(message: text, context: ErrorContext)
    SemanticWithContext(message: text, context: ErrorContext)
    CodegenWithContext(message: text, context: ErrorContext)
    LintWithContext(message: text, context: ErrorContext)
    RuntimeWithContext(message: text, context: ErrorContext)


# ============================================================================
# CompileError Methods (was: impl CompileError:)
# ============================================================================

fn compileerror_io(message: text) -> CompileError:
        """Create an I/O error with just a message."""
        compileerror_Io(message)


fn compileerror_parse(message: text) -> CompileError:
        """Create a parse error with just a message."""
        compileerror_Parse(message)


fn compileerror_semantic(message: text) -> CompileError:
        """Create a semantic error with just a message."""
        compileerror_Semantic(message)


fn compileerror_codegen(message: text) -> CompileError:
        """Create a codegen error with just a message."""
        compileerror_Codegen(message)


fn compileerror_lint(message: text) -> CompileError:
        """Create a lint error with just a message."""
        compileerror_Lint(message)


fn compileerror_runtime(message: text) -> CompileError:
        """Create a runtime error with just a message."""
        compileerror_Runtime(message)


fn compileerror_io_with_context(message: text, context: ErrorContext) -> CompileError:
        """Create an I/O error with rich context."""
        compileerror_IoWithContext(message, context)


fn compileerror_parse_with_context(message: text, context: ErrorContext) -> CompileError:
        """Create a parse error with rich context."""
        compileerror_ParseWithContext(message, context)


fn compileerror_semantic_with_context(message: text, context: ErrorContext) -> CompileError:
        """Create a semantic error with rich context."""
        compileerror_SemanticWithContext(message, context)


fn compileerror_codegen_with_context(message: text, context: ErrorContext) -> CompileError:
        """Create a codegen error with rich context."""
        compileerror_CodegenWithContext(message, context)


fn compileerror_lint_with_context(message: text, context: ErrorContext) -> CompileError:
        """Create a lint error with rich context."""
        compileerror_LintWithContext(message, context)


fn compileerror_runtime_with_context(message: text, context: ErrorContext) -> CompileError:
        """Create a runtime error with rich context."""
        compileerror_RuntimeWithContext(message, context)


fn compileerror_contract_violation(message: text) -> CompileError:
        """Create a contract violation error."""
        val ctx = errorcontext_empty().with_code(CONTRACT_PRECONDITION_FAILED)
        compileerror_RuntimeWithContext(message, ctx)


fn compileerror_execution_limit_exceeded(limit: i64, message: text) -> CompileError:
        """Create an execution limit exceeded error."""
        compileerror_ExecutionLimitExceeded(limit, message)


fn compileerror_stack_overflow(depth: i64, limit: i64, function_name: text) -> CompileError:
        """Create a stack overflow error."""
        compileerror_StackOverflow(depth, limit, function_name)


fn compileerror_timeout_exceeded(timeout_secs: i64) -> CompileError:
        """Create a timeout exceeded error."""
        compileerror_TimeoutExceeded(timeout_secs)


fn compileerror_interrupted_by_user() -> CompileError:
        """Create an interrupted by user error (Ctrl-C)."""
        CompileError.InterruptedByUser


fn compileerror_try_error(value: Value) -> CompileError:
        """Create a try error (? operator propagation)."""
        compileerror_TryError(value)


fn compileerror_ghost_error(message: text) -> CompileError:
        """Create a ghost code verification error."""
        compileerror_GhostError(message)


# ============================================================================
# Error Factory Module
# ============================================================================

# module error_factory
    """Factory functions for creating common error types."""

    # ========================================================================
    # Module/Import Errors
    # ========================================================================

    fn module_not_found(module_name: text) -> CompileError:
        """Error when a module cannot be found."""
        val ctx = errorcontext_empty().with_code(MODULE_NOT_FOUND)
        CompileError.semantic_with_context("Module '{module_name}' not found", ctx)

    fn module_not_found_with_paths(module_name: text, paths: [text]) -> CompileError:
        """Error when a module cannot be found, with search paths."""
        val paths_str = paths.map(\p: "  - {p}").join("\n")
        CompileError.semantic("Module '{module_name}' not found. Searched paths:\n{paths_str}")

    fn failed_to_read_file(path: text, error: text) -> CompileError:
        """Error when a file cannot be read."""
        CompileError.semantic("failed to read {path}: {error}")

    fn failed_to_parse_file(filename: text, error: text) -> CompileError:
        """Error when a file fails to parse."""
        CompileError.semantic("failed to parse {filename}: {error}")

    fn capability_violation(module_name: text, child_caps: text, parent_caps: text) -> CompileError:
        """Error when module capabilities are not a subset of parent capabilities."""
        CompileError.semantic("module '{module_name}' declares capabilities [{child_caps}] which are not a subset of parent capabilities [{parent_caps}]")

    # ========================================================================
    # Argument/Type Errors
    # ========================================================================

    fn argument_type_mismatch(index: i64, expected: text, found: text) -> CompileError:
        """Error when a function argument has an unexpected type."""
        CompileError.semantic("argument {index} must be {expected}, found {found}")

    fn argument_count_mismatch(expected: i64, found: i64) -> CompileError:
        """Error when a function receives the wrong number of arguments."""
        val ctx = errorcontext_empty().with_code(ARGUMENT_COUNT_MISMATCH)
        CompileError.semantic_with_context("expected {expected} argument(s), found {found}", ctx)

    fn func_expects_args(func_name: text, expected: i64, found: i64) -> CompileError:
        """Error when a function expects a specific number of arguments."""
        CompileError.semantic("{func_name} expects {expected} argument(s), got {found}")

    fn func_expects_at_least(func_name: text, min: i64, found: i64) -> CompileError:
        """Error when a function expects at least N arguments."""
        CompileError.semantic("{func_name} expects at least {min} argument(s), got {found}")

    fn func_expects_type_at(func_name: text, expected_type: text, index: i64) -> CompileError:
        """Error when a function argument has the wrong type (with func name)."""
        CompileError.semantic("{func_name} expects {expected_type} argument at position {index}")

    fn missing_argument(name: text) -> CompileError:
        """Error when a required argument is missing."""
        CompileError.semantic("missing required argument: {name}")

    fn argument_must_be(index: i64, expected_type: text) -> CompileError:
        """Error when an argument must be a specific type."""
        CompileError.semantic("argument {index} must be {expected_type}")

    fn expects_lambda(operation: text) -> CompileError:
        """Error when an operation expects a lambda argument."""
        CompileError.semantic("{operation} expects lambda argument")

    fn const_binding_wrong_type(name: text, expected: text, found: text) -> CompileError:
        """Error when a const binding has wrong type."""
        CompileError.semantic("Const binding '{name}' is not {expected}: {found}")

    fn const_binding_not_found(name: text) -> CompileError:
        """Error when a const binding is not found."""
        CompileError.semantic("Const binding '{name}' not found")

    # ========================================================================
    # Macro Errors
    # ========================================================================

    fn unknown_macro(name: text) -> CompileError:
        """Error when an unknown macro is invoked."""
        CompileError.semantic("unknown macro: {name}!")

    fn macro_used_before_definition(name: text) -> CompileError:
        """Error when a macro is used before its definition."""
        CompileError.semantic("macro '{name}' used before definition")

    fn macro_invocation_failed(name: text, reason: text) -> CompileError:
        """Error when a macro invocation fails."""
        CompileError.semantic("macro '{name}' invocation failed: {reason}")

    fn panic_macro(message: text) -> CompileError:
        """Error when a panic! macro is invoked."""
        CompileError.semantic("panic: {message}")

    fn assertion_failed(left: text, right: text) -> CompileError:
        """Error when an assertion fails."""
        CompileError.semantic("assertion failed: {left} != {right}")

    fn unit_assertion_failed(error: text) -> CompileError:
        """Error when a unit assertion fails."""
        CompileError.semantic("unit assertion failed: {error}")

    fn invalid_unit_type(type_name: text) -> CompileError:
        """Error when a type is not a valid unit type."""
        CompileError.semantic("assert_unit: '{type_name}' is not a registered unit type (family or compound unit)")

    # ========================================================================
    # Type/Name Resolution Errors
    # ========================================================================

    fn type_not_found(type_name: text) -> CompileError:
        """Error when a type is not found."""
        val ctx = errorcontext_empty().with_code(UNDEFINED_TYPE)
        CompileError.semantic_with_context("type '{type_name}' not found in this scope", ctx)

    fn variable_not_found(var_name: text) -> CompileError:
        """Error when a variable is not found."""
        val ctx = errorcontext_empty().with_code(UNDEFINED_VARIABLE)
        CompileError.semantic_with_context("cannot find variable '{var_name}' in this scope", ctx)

    fn function_not_found(func_name: text) -> CompileError:
        """Error when a function is not found."""
        val ctx = errorcontext_empty().with_code(UNDEFINED_FUNCTION)
        CompileError.semantic_with_context("cannot find function '{func_name}' in this scope", ctx)

    fn method_not_found(method_name: text, type_name: text) -> CompileError:
        """Error when a method is not found on a type."""
        val ctx = errorcontext_empty().with_code(UNKNOWN_METHOD)
        CompileError.semantic_with_context("no method named '{method_name}' found for type '{type_name}'", ctx)

    fn field_not_found(field_name: text, type_name: text) -> CompileError:
        """Error when a field is not found on a struct/class."""
        val ctx = errorcontext_empty().with_code(UNDEFINED_FIELD)
        CompileError.semantic_with_context("no field named '{field_name}' found on type '{type_name}'", ctx)

    # ========================================================================
    # Type Errors
    # ========================================================================

    fn type_mismatch(expected: text, found: text) -> CompileError:
        """Error when types don't match."""
        val ctx = errorcontext_empty().with_code(TYPE_MISMATCH)
        CompileError.semantic_with_context("expected type {expected}, found {found}", ctx)

    fn invalid_operation(op: text, type_name: text) -> CompileError:
        """Error when an operation is invalid for a type."""
        val ctx = errorcontext_empty().with_code(INVALID_OPERATION)
        CompileError.semantic_with_context("cannot apply operator '{op}' to type '{type_name}'", ctx)

    fn not_callable(type_name: text) -> CompileError:
        """Error when trying to call a non-callable type."""
        val ctx = errorcontext_empty().with_code(NOT_CALLABLE)
        CompileError.semantic_with_context("type '{type_name}' is not callable", ctx)

    # ========================================================================
    # Control Flow Errors
    # ========================================================================

    fn break_outside_loop() -> CompileError:
        """Error when break is used outside a loop."""
        val ctx = errorcontext_empty().with_code(BREAK_OUTSIDE_LOOP)
        CompileError.semantic_with_context("'break' outside of a loop", ctx)

    fn continue_outside_loop() -> CompileError:
        """Error when continue is used outside a loop."""
        val ctx = errorcontext_empty().with_code(CONTINUE_OUTSIDE_LOOP)
        CompileError.semantic_with_context("'continue' outside of a loop", ctx)

    fn return_outside_function() -> CompileError:
        """Error when return is used outside a function."""
        val ctx = errorcontext_empty().with_code(RETURN_OUTSIDE_FUNCTION)
        CompileError.semantic_with_context("'return' outside of a function", ctx)

    fn yield_outside_generator() -> CompileError:
        """Error when yield is used outside a generator."""
        val ctx = errorcontext_empty().with_code(YIELD_OUTSIDE_GENERATOR)
        CompileError.semantic_with_context("'yield' outside of a generator", ctx)

    # ========================================================================
    # Pattern Errors
    # ========================================================================

    fn invalid_pattern(pattern_str: text, reason: text) -> CompileError:
        """Error when a pattern is invalid."""
        val ctx = errorcontext_empty().with_code(INVALID_PATTERN)
        CompileError.semantic_with_context("invalid pattern {pattern_str}: {reason}", ctx)

    fn inconsistent_bindings(pattern_str: text) -> CompileError:
        """Error when pattern bindings are inconsistent."""
        val ctx = errorcontext_empty().with_code(INCONSISTENT_BINDINGS)
        CompileError.semantic_with_context("inconsistent bindings in pattern {pattern_str}", ctx)

    # ========================================================================
    # Trait/Impl Errors
    # ========================================================================

    fn missing_trait_method(trait_name: text, method_name: text) -> CompileError:
        """Error when a required trait method is missing."""
        val ctx = errorcontext_empty().with_code(MISSING_TRAIT_METHOD)
        CompileError.semantic_with_context("missing required method '{method_name}' for trait '{trait_name}'", ctx)

    fn duplicate_method(method_name: text, type_name: text) -> CompileError:
        """Error when a method is defined multiple times."""
        val ctx = errorcontext_empty().with_code(DUPLICATE_METHOD)
        CompileError.semantic_with_context("duplicate definition of method '{method_name}' for type '{type_name}'", ctx)

    fn conflicting_trait_bounds(type_param: text) -> CompileError:
        """Error when trait bounds conflict."""
        val ctx = errorcontext_empty().with_code(CONFLICTING_TRAIT_BOUNDS)
        CompileError.semantic_with_context("conflicting trait bounds for type parameter '{type_param}'", ctx)

    # ========================================================================
    # Codegen Errors
    # ========================================================================

    fn unsupported_feature(feature: text) -> CompileError:
        """Error when a language feature is not yet supported in codegen."""
        val ctx = errorcontext_empty().with_code(UNSUPPORTED_FEATURE)
        CompileError.codegen_with_context("unsupported feature: {feature}", ctx)

    fn ffi_error(message: text) -> CompileError:
        """Error in FFI operations."""
        val ctx = errorcontext_empty().with_code(FFI_ERROR)
        CompileError.codegen_with_context("FFI error: {message}", ctx)

    # ========================================================================
    # Runtime Errors
    # ========================================================================

    fn division_by_zero() -> CompileError:
        """Error when dividing by zero."""
        val ctx = errorcontext_empty().with_code(DIVIDE_BY_ZERO)
        CompileError.runtime_with_context("division by zero", ctx)

    fn index_out_of_bounds(index: i64, length: i64) -> CompileError:
        """Error when array index is out of bounds."""
        val ctx = errorcontext_empty().with_code(INDEX_OUT_OF_BOUNDS)
        CompileError.runtime_with_context("index {index} out of bounds for length {length}", ctx)

    fn null_pointer_dereference() -> CompileError:
        """Error when dereferencing a null pointer."""
        val ctx = errorcontext_empty().with_code(NULL_DEREFERENCE)
        CompileError.runtime_with_context("null pointer dereference", ctx)
