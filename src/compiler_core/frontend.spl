# Core Frontend Runner
#
# Shared parse entrypoints used by core compiler and core interpreter flows.
# Keeps the core frontend orchestration (parse/reset/append/isolated) in one place.

use compiler_core.parser.{parse_module, parse_module_file, parser_has_errors, par_had_error}

fn core_frontend_parse(
    source: text,
    path: text,
    append_mode: bool,
    preserve_error_state: bool
) -> bool:
    val saved_had_error = par_had_error

    if append_mode:
        parse_module_file(source, path)
    else:
        parse_module(source, path)

    val parse_ok = not parser_has_errors()
    if preserve_error_state:
        par_had_error = saved_had_error

    parse_ok

fn core_frontend_parse_reset(source: text, path: text) -> bool:
    """Parse a standalone module, resetting parser/AST state."""
    core_frontend_parse(source, path, false, false)

fn core_frontend_parse_append(source: text, path: text) -> bool:
    """Parse and append to current module arena (multi-file compile path)."""
    core_frontend_parse(source, path, true, false)

fn core_frontend_parse_isolated(source: text, path: text) -> bool:
    """Parse in isolated mode and restore prior parser error flag."""
    core_frontend_parse(source, path, false, true)

export core_frontend_parse
export core_frontend_parse_reset, core_frontend_parse_append, core_frontend_parse_isolated
