# Test: Complex MIR -> Native Backend
#
# Tests arithmetic, control flow (if/else), and multiple function calls
# through the ISel -> RegAlloc -> Encode -> ELF pipeline.
#
# Equivalent C program:
#   #include <stdio.h>
#   int main() {
#       int a = 10;
#       int b = 32;
#       int c = a + b;  // 42
#       if (c == 42) {
#           printf("42{NL}");
#       } else {
#           printf("wrong{NL}");
#       }
#       return 0;
#   }

extern fn rt_process_run(cmd: text, args: [text]) -> (text, text, i64)

fn shell(command: text) -> (text, text, i64):
    rt_process_run("sh", ["-c", command])

use compiler.mir_data.*
use compiler.backend.native.isel_x86_64.{isel_module}
use compiler.backend.native.regalloc.{regalloc_module}
use compiler.backend.native.encode_x86_64.{encode_module}
use compiler.backend.native.mach_inst.{MachModule, EncodedFunction}
use compiler.backend.native.elf_writer.{ElfWriter, ElfReloc, ElfRelocType, ElfSymbol, ElfSymbolBind, ElfSymbolType, elf_writer_x86_64, elf_add_section, elf_add_symbol, new_text_section, new_rodata_section, section_add_reloc, new_func_symbol, new_extern_symbol, write_elf64}
use std.string.{NL}

print "=== Complex MIR -> Native Backend Test ==="

val i64_type = MirType(kind: MirTypeKind.I64)
val bool_type = MirType(kind: MirTypeKind.Bool)

val main_sig = MirSignature(params: [], return_type: i64_type, is_variadic: false)

# Locals:
# 0: _return (i64, Return)
# 1: a (i64, Temp)  = 10
# 2: b (i64, Temp)  = 32
# 3: c (i64, Temp)  = a + b
# 4: cond (bool, Temp) = c == 42
# 5: str_ptr (i64, Temp) - for puts arg
# 6: ret_val (i64, Temp) = 0
val locals = [
    # MirLocal(id: LocalId(id: 0), # DESUGARED: name: Some("_return")
            name: "_return", type_: i64_type, kind: LocalKind.Return),
    # MirLocal(id: LocalId(id: 1), # DESUGARED: name: Some("a")
            name: "a", type_: i64_type, kind: LocalKind.Temp),
    # MirLocal(id: LocalId(id: 2), # DESUGARED: name: Some("b")
            name: "b", type_: i64_type, kind: LocalKind.Temp),
    # MirLocal(id: LocalId(id: 3), # DESUGARED: name: Some("c")
            name: "c", type_: i64_type, kind: LocalKind.Temp),
    # MirLocal(id: LocalId(id: 4), # DESUGARED: name: Some("cond")
            name: "cond", type_: bool_type, kind: LocalKind.Temp),
    # MirLocal(id: LocalId(id: 5), # DESUGARED: name: Some("str_ptr")
            name: "str_ptr", type_: i64_type, kind: LocalKind.Temp),
    # MirLocal(id: LocalId(id: 6), # DESUGARED: name: Some("ret_val")
            name: "ret_val", type_: i64_type, kind: LocalKind.Temp)
]

# Block 0 (entry): compute a+b, compare, branch
val entry_block = MirBlock(
    id: blockid_new(0),
    # # DESUGARED: label: Some("entry")
            label: "entry",
    instructions: [
        # a = 10
        MirInst(kind: mirinstkind_Const(LocalId(id: 1), mirconstvalue_Int(10), i64_type), span: nil),
        # b = 32
        MirInst(kind: mirinstkind_Const(LocalId(id: 2), mirconstvalue_Int(32), i64_type), span: nil),
        # c = a + b
        MirInst(kind: MirInstKind.BinOp(
            LocalId(id: 3),
            MirBinOp.Add,
            MirOperand(kind: miroperandkind_Copy(LocalId(id: 1))),
            MirOperand(kind: miroperandkind_Copy(LocalId(id: 2)))
        ), span: nil),
        # cond = (c == 42)
        MirInst(kind: MirInstKind.BinOp(
            LocalId(id: 4),
            MirBinOp.Eq,
            MirOperand(kind: miroperandkind_Copy(LocalId(id: 3))),
            MirOperand(kind: miroperandkind_Const(MirConstValue.Int(42), i64_type))
        ), span: nil)
    ],
    terminator: MirTerminator.If(
        MirOperand(kind: miroperandkind_Copy(LocalId(id: 4))),
        blockid_new(1),  # then
        blockid_new(2)   # else
    )
)

# Block 1 (then): print "42" and jump to exit
val then_block = MirBlock(
    id: blockid_new(1),
    # # DESUGARED: label: Some("then")
            label: "then",
    instructions: [
        MirInst(kind: MirInstKind.Const(LocalId(id: 5), MirConstValue.Str("42"), i64_type), span: nil),
        MirInst(kind: MirInstKind.Call(
            nil,
            MirOperand(kind: MirOperandKind.Const(MirConstValue.Str("puts"), i64_type)),
            [MirOperand(kind: miroperandkind_Copy(LocalId(id: 5)))]
        ), span: nil)
    ],
    terminator: mirterminator_Goto(BlockId.new(3))
)

# Block 2 (else): print "wrong" and jump to exit
val else_block = MirBlock(
    id: blockid_new(2),
    # # DESUGARED: label: Some("else")
            label: "else",
    instructions: [
        MirInst(kind: MirInstKind.Const(LocalId(id: 5), MirConstValue.Str("wrong"), i64_type), span: nil),
        MirInst(kind: MirInstKind.Call(
            nil,
            MirOperand(kind: MirOperandKind.Const(MirConstValue.Str("puts"), i64_type)),
            [MirOperand(kind: miroperandkind_Copy(LocalId(id: 5)))]
        ), span: nil)
    ],
    terminator: mirterminator_Goto(BlockId.new(3))
)

# Block 3 (exit): return 0
val exit_block = MirBlock(
    id: blockid_new(3),
    # # DESUGARED: label: Some("exit")
            label: "exit",
    instructions: [
        MirInst(kind: mirinstkind_Const(LocalId(id: 6), mirconstvalue_Int(0), i64_type), span: nil)
    ],
    terminator: MirTerminator.Return(
        MirOperand(kind: miroperandkind_Copy(LocalId(id: 6)))
    )
)

val dummy_span = Span(start: 0, end: 0, line: 0, col: 0)

val main_func = MirFunction(
    symbol: symbolid_new(0),
    name: "main",
    signature: main_sig,
    locals: locals,
    blocks: [entry_block, then_block, else_block, exit_block],
    entry_block: blockid_new(0),
    span: dummy_span,
    generic_params: [],
    is_generic_template: false,
    specialization_of: nil,
    type_bindings: {}
)

var functions: Dict<SymbolId, MirFunction> = {}
functions[symbolid_new(0)] = main_func

val module = MirModule(
    name: "complex_test",
    functions: functions,
    statics: {},
    constants: {},
    types: {}
)

# Run pipeline
print "  ISel..."
val mach_module = isel_module(module)
print "  RegAlloc..."
val allocated = regalloc_module(mach_module)
print "  Encode..."
val encoded_funcs = encode_module(allocated)
for ef in encoded_funcs:
    print "    {ef.name}: {ef.code.len()} bytes, {ef.relocations.len()} reloc(s)"

# Emit ELF (reuse the fixed emit_elf from test_mir_native)
fn emit_elf(encoded: [EncodedFunction], mach_mod: MachModule) -> [i64]:
    var writer = elf_writer_x86_64()
    var all_code: [i64] = []
    var func_offsets: Dict<text, i64> = {}
    var all_relocs: [ElfReloc] = []
    var sym_names: [text] = []
    var sym_name_to_idx: Dict<text, i64> = {}

    var rodata_off = 0
    var data_label_off: Dict<text, i64> = {}
    for entry in mach_mod.data_sections:
        if entry.is_readonly:
            if not sym_name_to_idx_contains(sym_name_to_idx, entry.name):
                val idx = sym_names_len(sym_names)
                sym_names = sym_names + [entry.name]
                sym_name_to_idx[entry.name] = idx
                data_label_off[entry.name] = rodata_off
            rodata_off = rodata_off + entry.data_len(data)

    for ext_sym in mach_mod.extern_symbols:
        if not sym_name_to_idx_contains(sym_name_to_idx, ext_sym):
            val idx = sym_names_len(sym_names)
            sym_names = sym_names + [ext_sym]
            sym_name_to_idx[ext_sym] = idx

    for func in encoded:
        if not sym_name_to_idx_contains(sym_name_to_idx, func.name):
            val idx = sym_names_len(sym_names)
            sym_names = sym_names + [func.name]
            sym_name_to_idx[func.name] = idx

    var num_cs = 1
    var has_ro = false
    for entry in mach_mod.data_sections:
        if entry.is_readonly:
            has_ro = true
    if has_ro:
        num_cs = num_cs + 1
    val sym_base = 1 + num_cs

    for func in encoded:
        var padding = all_code_len(all_code) % 16
        if padding != 0:
            padding = 16 - padding
        var pi = 0
        while pi < padding:
            all_code = all_code + [0xcc]
            pi = pi + 1
        func_offsets[func.name] = all_code_len(all_code)
        val code_start = all_code_len(all_code)
        all_code = all_code + func.code
        for reloc in func.relocations:
            var reloc_type = ElfRelocType.X86_64_PLT32
            if reloc.reloc_type == 2:
                reloc_type = ElfRelocType.X86_64_PC32
            elif reloc.reloc_type == 1:
                reloc_type = ElfRelocType.X86_64_64
            var sym_idx = 0
            if sym_name_to_idx_contains(sym_name_to_idx, reloc.symbol_name):
                sym_idx = sym_name_to_idx[reloc.symbol_name]
            all_relocs = all_relocs + [ElfReloc(
                offset: code_start + reloc.offset,
                reloc_type: reloc_type,
                symbol_index: sym_base + sym_idx,
                addend: reloc.addend
            )]

    var text_section = new_text_section(all_code)
    for reloc in all_relocs:
        text_section = section_add_reloc(text_section, reloc)
    writer = elf_add_section(writer, text_section)

    var rodata_bytes: [i64] = []
    for entry in mach_mod.data_sections:
        if entry.is_readonly:
            rodata_bytes = rodata_bytes + entry.data
    if rodata_bytes_len(rodata_bytes) > 0:
        writer = elf_add_section(writer, new_rodata_section(rodata_bytes))

    for entry in mach_mod.data_sections:
        if entry.is_readonly:
            if data_label_off_contains(data_label_off, entry.name):
                writer = elf_add_symbol(writer, ElfSymbol(
                    name: entry.name,
                    sym_bind: ElfSymbolBind.Local,
                    sym_type: ElfSymbolType.Object,
                    section_index: 2,
                    value: data_label_off[entry.name],
                    size: entry.data_len(data)
                ))

    for ext_sym in mach_mod.extern_symbols:
        writer = elf_add_symbol(writer, new_extern_symbol(ext_sym))
    for func in encoded:
        var fo = 0
        if func_offsets_contains(func_offsets, func.name):
            fo = func_offsets[func.name]
        writer = elf_add_symbol(writer, new_func_symbol(func.name, 1, fo, func.code_len(code)))
    write_elf64(writer)

print "  ELF..."
val elf_bytes = emit_elf(encoded_funcs, allocated)
print "  ELF size: {elf_bytes.len()} bytes"

# Write to disk
fn byte_to_hex(b: i64) -> text:
    val digits = "0123456789abcdef"
    "{digits[b / 16]}{digits[b % 16]}"

var offset = 0
while offset < elf_bytes_len(elf_bytes):
    var chunk = ""
    var end_idx = offset + 800
    if end_idx > elf_bytes_len(elf_bytes):
        end_idx = elf_bytes_len(elf_bytes)
    var j = offset
    while j < end_idx:
        chunk = chunk + byte_to_hex(elf_bytes[j])
        j = j + 1
    if offset == 0:
        shell("echo -n '{chunk}' > /tmp/mir_complex.hex")
    else:
        shell("echo -n '{chunk}' >> /tmp/mir_complex.hex")
    offset = end_idx

shell("xxd -r -p /tmp/mir_complex.hex /tmp/mir_complex.o")
shell("rm -f /tmp/mir_complex.hex")

# Link and run
val link_r = rt_process_run("cc", ["-o", "/tmp/mir_complex", "/tmp/mir_complex.o", "-no-pie"])
if link_r[2] != 0:
    print "  Link FAILED: {link_r[1]}"
else:
    print "  Linked!"
    val run_r = rt_process_run("/tmp/mir_complex", [])
    val output = run_r[0].trim()
    print "  Output: '{output}'"
    print "  Exit: {run_r[2]}"
    if output == "42":
        print ""
        print "=== SUCCESS: Arithmetic + Control Flow + Function Calls ==="
    else:
        print "=== PARTIAL: output mismatch ==="

print "=== Done ==="
