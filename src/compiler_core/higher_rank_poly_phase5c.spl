"""
Higher-Rank Polymorphism - Phase 5C: Instantiation & Skolemization

Implements the core algorithms for handling forall quantifiers.

Status: Phase 5C In Progress
"""

type Symbol = text

# ============================================================================
# Kind System (from Phase 5A)
# ============================================================================

enum Kind:
    Star
    Arrow(from: Kind, to: Kind)


# ============================================================================
# Kind Methods (was: impl Kind:)
# ============================================================================

# ============================================================================
# Type Variable (from Phase 5A)
# ============================================================================

class TypeVar:
    id: i64
    name: text
    kind: text


# ============================================================================
# TypeVar Methods (was: impl TypeVar:)
# ============================================================================

# ============================================================================
# Type System (from Phase 5A)
# ============================================================================

enum HirType:
    Int
    Str
    Bool
    Named(name: Symbol)
    Arrow(from: HirType, to: HirType)
    TypeVariable(id: i64)
    Forall(quantifiers: [TypeVar], body: HirType)
    Skolem(id: i64)
    Error


# ============================================================================
# HirType Methods (was: impl HirType:)
# ============================================================================

# ============================================================================
# Quantifier Context (from Phase 5B)
# ============================================================================

class QuantifierContext:
    bound_vars: text
    skolem_counter: i64
    scope_level: i64
    inference_counter: i64  # NEW: for generating inference variables


# ============================================================================
# QuantifierContext Methods (was: impl QuantifierContext:)
# ============================================================================

fn quantifiercontext_new() -> QuantifierContext:
        QuantifierContext(
            bound_vars: {},
            skolem_counter: 0,
            scope_level: 0,
            inference_counter: 0
        )


fn quantifiercontext_fresh_skolem(self: QuantifierContext) -> i64:
        val id = self.skolem_counter
        self.skolem_counter = self.skolem_counter + 1
        id


fn quantifiercontext_fresh_inference_var(self: QuantifierContext) -> i64:
        """Generate a fresh inference variable"""
        val id = self.inference_counter
        self.inference_counter = self.inference_counter + 1
        id


# ============================================================================
# Type Substitution
# ============================================================================

class Substitution:
    """
    Type variable substitution

    Maps type variable ids to types
    """
    mapping: text  # Dict<i64, HirType>


# ============================================================================
# Substitution Methods (was: impl Substitution:)
# ============================================================================

fn substitution_new() -> Substitution:
        Substitution(mapping: {})


# ============================================================================
# Higher-Rank Unifier
# ============================================================================

class HigherRankUnifier:
    """
    Core algorithms for higher-rank polymorphism

    Instantiation: forall T. Ï„ ~> Ï„[T := ?Î±]
    - Replace quantified variables with fresh inference variables
    - Used when checking function arguments

    Skolemization: forall T. Ï„ ~> Ï„[T := sk_i]
    - Replace quantified variables with rigid constants
    - Used when checking expected types
    """
    ctx: text  # QuantifierContext


# ============================================================================
# HigherRankUnifier Methods (was: impl HigherRankUnifier:)
# ============================================================================

fn higherrankunifier_new(ctx: QuantifierContext) -> HigherRankUnifier:
        HigherRankUnifier(ctx: ctx)


fn higherrankunifier_instantiate(self: HigherRankUnifier, ty: HirType) -> HirType:
        """
        Instantiate quantifiers with fresh inference variables

        Example:
            forall T. T -> T
            ~> ?0 -> ?0
        """
        match ty:
            case Forall(quantifiers, body):
                # Create substitution for quantified variables
                val subst = substitution_new()

                for type_var in quantifiers:
                    val fresh_var = self.ctx_fresh_inference_var(ctx)
                    subst_add(subst, type_var.id, HirType.TypeVariable(id: fresh_var))

                # Apply substitution to body
                subst_apply(subst, body)

            case _:
                # Not a forall - return as is
                ty


fn higherrankunifier_skolemize(self: HigherRankUnifier, ty: HirType) -> HirType:
        """
        Skolemize quantifiers with rigid constants

        Example:
            forall T. T -> T
            ~> sk_0 -> sk_0
        """
        match ty:
            case Forall(quantifiers, body):
                # Create substitution for quantified variables
                val subst = substitution_new()

                for type_var in quantifiers:
                    val skolem_id = self.ctx_fresh_skolem(ctx)
                    subst_add(subst, type_var.id, HirType.Skolem(id: skolem_id))

                # Apply substitution to body
                subst_apply(subst, body)

            case _:
                # Not a forall - return as is
                ty


fn higherrankunifier_deep_skolemize(self: HigherRankUnifier, ty: HirType) -> HirType:
        """
        Deep skolemization for rank-2+ types

        Skolemizes foralls in negative (contravariant) positions

        Example:
            (forall T. T -> T) -> i32
            ~> (sk_0 -> sk_0) -> i32
        """
        match ty:
            case Arrow(from, to):
                # from is contravariant (negative position)
                # to is covariant (positive position)
                val from_skolem = self.deep_skolemize(from)
                val to_inst = self.deep_instantiate(to)
                hirtype_Arrow(from: from_skolem, to: to_inst)

            case Forall(quantifiers, body):
                # Forall in negative position - skolemize
                self.skolemize(ty)

            case _:
                ty


fn higherrankunifier_deep_instantiate(self: HigherRankUnifier, ty: HirType) -> HirType:
        """
        Deep instantiation for rank-2+ types

        Instantiates foralls in positive (covariant) positions
        """
        match ty:
            case Arrow(from, to):
                # from is contravariant
                # to is covariant
                val from_skolem = self.deep_skolemize(from)
                val to_inst = self.deep_instantiate(to)
                hirtype_Arrow(from: from_skolem, to: to_inst)

            case Forall(quantifiers, body):
                # Forall in positive position - instantiate
                self.instantiate(ty)

            case _:
                ty


# ============================================================================
# Tests
# ============================================================================

fn test_instantiate_basic():
    """Test basic instantiation"""
    val ctx = quantifiercontext_new()
    val unifier = higherrankunifier_new(ctx)

    # forall T. T -> T
    val t_var = TypeVar(id: 0, name: "T", kind: Kind.Star)
    val forall_type = HirType.Forall(
        quantifiers: [t_var],
        body: HirType.Arrow(
            from: hirtype_TypeVariable(id: 0),
            to: hirtype_TypeVariable(id: 0)
        )
    )

    val inst = unifier_instantiate(unifier, forall_type)

    # Should be: ?0 -> ?0
    match inst:
        case Arrow(from, to):
            match from:
                case TypeVariable(from_id):
                    match to:
                        case TypeVariable(to_id):
                            assert from_id == to_id, "Same inference variable"
                        case _:
                            assert false, "to should be TypeVariable"
                case _:
                    assert false, "from should be TypeVariable"
        case _:
            assert false, "Should be Arrow"

    print "âœ… Basic instantiation"

fn test_instantiate_multiple():
    """Test instantiation with multiple quantifiers"""
    val ctx = quantifiercontext_new()
    val unifier = higherrankunifier_new(ctx)

    # forall T, U. T -> U
    val t_var = TypeVar(id: 0, name: "T", kind: Kind.Star)
    val u_var = TypeVar(id: 1, name: "U", kind: Kind.Star)

    val forall_type = HirType.Forall(
        quantifiers: [t_var, u_var],
        body: HirType.Arrow(
            from: hirtype_TypeVariable(id: 0),
            to: hirtype_TypeVariable(id: 1)
        )
    )

    val inst = unifier_instantiate(unifier, forall_type)

    # Should be: ?0 -> ?1
    match inst:
        case Arrow(from, to):
            match from:
                case TypeVariable(from_id):
                    match to:
                        case TypeVariable(to_id):
                            assert from_id != to_id, "Different inference variables"
                        case _:
                            assert false, "to should be TypeVariable"
                case _:
                    assert false, "from should be TypeVariable"
        case _:
            assert false, "Should be Arrow"

    print "âœ… Multiple quantifier instantiation"

fn test_skolemize_basic():
    """Test basic skolemization"""
    val ctx = quantifiercontext_new()
    val unifier = higherrankunifier_new(ctx)

    # forall T. T -> T
    val t_var = TypeVar(id: 0, name: "T", kind: Kind.Star)
    val forall_type = HirType.Forall(
        quantifiers: [t_var],
        body: HirType.Arrow(
            from: hirtype_TypeVariable(id: 0),
            to: hirtype_TypeVariable(id: 0)
        )
    )

    val skolem = unifier_skolemize(unifier, forall_type)

    # Should be: sk_0 -> sk_0
    match skolem:
        case Arrow(from, to):
            match from:
                case Skolem(from_id):
                    match to:
                        case Skolem(to_id):
                            assert from_id == to_id, "Same skolem"
                        case _:
                            assert false, "to should be Skolem"
                case _:
                    assert false, "from should be Skolem"
        case _:
            assert false, "Should be Arrow"

    print "âœ… Basic skolemization"

fn test_skolemize_rigidity():
    """Test that skolems are rigid (have unique ids)"""
    val ctx = quantifiercontext_new()
    val unifier = higherrankunifier_new(ctx)

    # forall T. T -> T
    val t_var = TypeVar(id: 0, name: "T", kind: Kind.Star)
    val forall_type = HirType.Forall(
        quantifiers: [t_var],
        body: HirType.Arrow(
            from: hirtype_TypeVariable(id: 0),
            to: hirtype_TypeVariable(id: 0)
        )
    )

    # Skolemize twice
    val skolem1 = unifier_skolemize(unifier, forall_type)
    val skolem2 = unifier_skolemize(unifier, forall_type)

    # Extract skolem ids
    var sk1_id = -1
    var sk2_id = -1

    match skolem1:
        case Arrow(from, _):
            match from:
                case Skolem(id):
                    sk1_id = id
                case _:
                    pass
        case _:
            pass

    match skolem2:
        case Arrow(from, _):
            match from:
                case Skolem(id):
                    sk2_id = id
                case _:
                    pass
        case _:
            pass

    assert sk1_id != sk2_id, "Different skolems"
    assert sk1_id == 0, "First is sk_0"
    assert sk2_id == 1, "Second is sk_1"

    print "âœ… Skolem rigidity"

fn test_deep_skolemize_rank2():
    """Test deep skolemization for rank-2 type"""
    val ctx = quantifiercontext_new()
    val unifier = higherrankunifier_new(ctx)

    # (forall T. T -> T) -> i32
    val t_var = TypeVar(id: 0, name: "T", kind: Kind.Star)
    val inner_forall = HirType.Forall(
        quantifiers: [t_var],
        body: HirType.Arrow(
            from: hirtype_TypeVariable(id: 0),
            to: hirtype_TypeVariable(id: 0)
        )
    )

    val rank2_type = HirType.Arrow(
        from: inner_forall,
        to: HirType.Int
    )

    val result = unifier_deep_skolemize(unifier, rank2_type)

    # Should be: (sk_0 -> sk_0) -> i32
    match result:
        case Arrow(from, to):
            match from:
                case Arrow(inner_from, inner_to):
                    match inner_from:
                        case Skolem(_):
                            match inner_to:
                                case Skolem(_):
                                    pass
                                case _:
                                    assert false, "inner_to should be Skolem"
                        case _:
                            assert false, "inner_from should be Skolem"
                case _:
                    assert false, "from should be Arrow"
            match to:
                case Int:
                    pass
                case _:
                    assert false, "to should be Int"
        case _:
            assert false, "Should be Arrow"

    print "âœ… Deep skolemization rank-2"

fn test_deep_skolemize_nested():
    """Test deep skolemization with nested foralls"""
    val ctx = quantifiercontext_new()
    val unifier = higherrankunifier_new(ctx)

    # Create a complex nested type
    # (forall T. T) -> (forall U. U)

    val t_var = TypeVar(id: 0, name: "T", kind: Kind.Star)
    val u_var = TypeVar(id: 1, name: "U", kind: Kind.Star)

    val forall_t = HirType.Forall(
        quantifiers: [t_var],
        body: hirtype_TypeVariable(id: 0)
    )

    val forall_u = HirType.Forall(
        quantifiers: [u_var],
        body: hirtype_TypeVariable(id: 1)
    )

    val nested_type = HirType.Arrow(
        from: forall_t,
        to: forall_u
    )

    val result = unifier_deep_skolemize(unifier, nested_type)

    # Should be: sk_0 -> ?0
    # (forall in negative position skolemized, forall in positive position instantiated)
    match result:
        case Arrow(from, to):
            match from:
                case Skolem(_):
                    pass
                case _:
                    assert false, "from should be Skolem"
            match to:
                case TypeVariable(_):
                    pass
                case _:
                    assert false, "to should be TypeVariable (instantiated)"
        case _:
            assert false, "Should be Arrow"

    print "âœ… Deep skolemization nested"

fn test_contravariance():
    """Test contravariance in function arguments"""
    val ctx = quantifiercontext_new()
    val unifier = higherrankunifier_new(ctx)

    # Test that function arguments (contravariant position) are skolemized
    # while return types (covariant position) are instantiated

    # forall T. T -> (forall U. U)
    val t_var = TypeVar(id: 0, name: "T", kind: Kind.Star)
    val u_var = TypeVar(id: 1, name: "U", kind: Kind.Star)

    val forall_u = HirType.Forall(
        quantifiers: [u_var],
        body: hirtype_TypeVariable(id: 1)
    )

    val body = HirType.Arrow(
        from: hirtype_TypeVariable(id: 0),
        to: forall_u
    )

    val outer_forall = HirType.Forall(
        quantifiers: [t_var],
        body: body
    )

    # Instantiate outer forall first
    val inst = unifier_instantiate(unifier, outer_forall)

    # Then deep process
    val result = unifier_deep_skolemize(unifier, inst)

    # Result should have inference var for T, inference var for U (both positive)
    match result:
        case Arrow(from, to):
            match from:
                case TypeVariable(_):
                    pass
                case _:
                    assert false, "from should be TypeVariable"
            match to:
                case TypeVariable(_):
                    pass
                case _:
                    assert false, "to should be TypeVariable"
        case _:
            assert false, "Should be Arrow"

    print "âœ… Contravariance"

fn main():
    print ""
    print "Higher-Rank Polymorphism Phase 5C Tests"
    print "========================================"

    test_instantiate_basic()
    test_instantiate_multiple()
    test_skolemize_basic()
    test_skolemize_rigidity()
    test_deep_skolemize_rank2()
    test_deep_skolemize_nested()
    test_contravariance()

    print ""
    print "ðŸŽ‰ Phase 5C Complete!"
    print ""
    print "Implemented:"
    print "  âœ… Substitution - type variable substitution"
    print "  âœ… HigherRankUnifier - core algorithms"
    print "  âœ… Instantiation (forall T. Ï„ â†’ Ï„[T := ?Î±])"
    print "  âœ… Skolemization (forall T. Ï„ â†’ Ï„[T := sk_i])"
    print "  âœ… Deep skolemization (rank-2+ types)"
    print "  âœ… Deep instantiation (positive positions)"
    print "  âœ… Contravariance handling (negative positions)"
    print ""
    print "Progress: 10/12 hours (83% of Phase 5)"
    print "Next: Phase 5D - Higher-Rank Unification (2h)"
