# Lexer Types - Token and Span Definitions
#
# This module contains core lexer type definitions:
# - TokenKind: All token types (keywords, operators, literals, etc.)
# - Span: Source location tracking
# - Token: Token with kind and span
#
# The lexer implementation is in lexer.spl

use std.text.{NL}

enum TokenKind:
    # Literals
    IntLit          # 42, 0x2A, 0b101010, 0o52
    FloatLit        # 3[14], 1e10, 2[5]e-3
    StringLit       # "hello", 'hello', """multiline"""
    RawStringLit    # r"raw\nstring"
    BoolLit         # true, false
    NilLit          # nil

    # Identifiers and Keywords
    Ident           # foo, bar, _private

    # Keywords - Declarations
    KwFn            # fn
    KwVal           # val
    KwVar           # var
    KwStruct        # struct
    KwClass         # class
    KwEnum          # enum
    KwTrait         # trait
    KwImpl          # impl
    KwType          # type
    KwMod           # mod
    KwPub           # pub
    KwPri           # pri (private)
    KwStatic        # static
    KwMe            # me (mutable self method)
    KwExtern        # extern
    KwConst         # const (for const fn)
    KwBitfield      # bitfield (packed bit struct)
    KwKernel        # kernel (GPU kernel function)
    KwShared        # shared (GPU shared memory)
    KwUnsafe        # unsafe (unsafe block for raw operations)
    KwAsm           # asm (inline assembly)

    # Keywords - Control Flow
    KwIf            # if
    KwElse          # else
    KwElif          # elif
    KwMatch         # match
    KwCase          # case
    KwFor           # for
    KwWhile         # while
    KwLoop          # loop
    KwBreak         # break
    KwContinue      # continue
    KwReturn        # return
    KwYield         # yield
    KwAwait         # await
    KwAsync         # async
    KwSpawn         # spawn (actor creation)
    KwActor         # actor (actor definition)

    # Keywords - Expressions
    KwIn            # in
    KwIs            # is
    KwAs            # as
    KwNot           # not
    KwAnd           # and
    KwOr            # or
    KwXor           # xor (bitwise XOR)
    KwTry           # try
    KwCatch         # catch
    KwThrow         # throw
    KwWith          # with

    # Keywords - Imports
    KwImport        # import
    KwExport        # export
    KwFrom          # from

    # Keywords - Special
    KwSelf          # self
    KwSuper         # super
    KwNone          # nil
    KwSome          # Some
    KwOk            # Ok
    KwErr           # Err
    KwLoss          # loss (enters math mode)
    KwNograd        # nograd (enters math mode)

    # Operators - Arithmetic
    Plus            # +
    Minus           # -
    Star            # *
    Slash           # /
    Percent         # %
    StarStar        # **

    # Operators - Comparison
    Eq              # ==
    NotEq           # !=
    Lt              # <
    Gt              # >
    LtEq            # <=
    GtEq            # >=

    # Operators - Assignment
    Assign          # =
    PlusEq          # +=
    MinusEq         # -=
    StarEq          # *=
    SlashEq         # /=
    PercentEq       # %=

    # Operators - Logical (symbols)
    Ampersand       # &
    Pipe            # |
    Caret           # ^
    Tilde           # ~
    AmpAmp          # &&
    PipePipe        # ||

    # Operators - Special
    Question        # ?
    QuestionDot     # ?.
    QuestionQuestion # ??
    DotQuestion     # 
    Bang            # !
    At              # @
    Hash            # #
    HashLBracket    # #[ (attribute start)
    Dollar          # $
    Backslash       # \
    Transpose       # ' (postfix transpose in m{} only)

    # Pipeline/Composition Operators
    PipeForward     # |>
    Compose         # >>
    ComposeBack     # <<
    Parallel        # //
    LayerConnect    # ~>

    # GPU Kernel Launch Operators
    TripleLess      # <<< (kernel launch start)
    TripleGreater   # >>> (kernel launch end)

    # Delimiters
    LParen          # (
    RParen          # )
    LBrace          # {
    RBrace          # }
    LBracket        # [
    RBracket        # ]

    # Punctuation
    Comma           # ,
    Colon           # :
    ColonColon      # ::
    Semicolon       # ;
    Dot             # .
    DotDot          # ..
    DotDotEq        # ..=
    DotPlus         # .+ (broadcast add)
    DotMinus        # .- (broadcast sub)
    DotStar         # .* (broadcast mul)
    DotSlash        # ./ (broadcast div)
    DotCaret        # .^ (broadcast pow)
    Ellipsis        # ... (axis slicing)
    Arrow           # ->
    FatArrow        # =>
    Underscore      # _

    # Indentation
    Newline         # End of line
    Indent          # Increase in indentation
    Dedent          # Decrease in indentation

    # Special
    Eof             # End of file
    Error           # Lexer error
    ImplicitMul     # Implicit multiplication (m{} only, e.g., 2x, Ax)
    ArraySuffix     # Suffix after ]: ]f32, ]_f32_gpu, ]f32_tr_gpu

    # Block Tokens (for user-definable blocks)
    BlockStart      # Block keyword detected (e.g., "m", "loss", "sh", "sql")
    BlockPayload    # Raw payload text (for Raw mode blocks)
    BlockEnd        # Closing brace of block

    # Literal Tokens (for collection literals)
    SetLitStart     # s{ - set literal prefix
    LiteralStart(text)  # Generic literal prefix (for custom types)

# ============================================================================
# Source Position
# ============================================================================

struct SourcePosition:
    """Position in source code."""
    offset: i64    # Byte offset
    line: i64      # Line number (1-based)
    col: i64       # Column number (1-based)


# ============================================================================
# SourcePosition Methods
# ============================================================================

fn sourceposition_new(offset: i64, line: i64, col: i64) -> SourcePosition:
    """Create a new source position."""
    SourcePosition(offset: offset, line: line, col: col)


fn sourceposition_advance(self: SourcePosition, char: text) -> SourcePosition:
    """Advance position by one character."""
    if char == NL:
        SourcePosition(offset: self.offset + 1, line: self.line + 1, col: 1)
    else:
        SourcePosition(offset: self.offset + 1, line: self.line, col: self.col + 1)


fn SourcePosition__start() -> SourcePosition:
    """Create a position at the start of a file."""
    SourcePosition(offset: 0, line: 1, col: 1)


# ============================================================================
# Span
# ============================================================================

struct Span:
    """Source location span."""
    start: i64      # Start offset
    end: i64        # End offset (exclusive)
    line: i64       # Line number (1-based)
    col: i64        # Column number (1-based)


# ============================================================================
# Span Methods (was: impl Span:)
# ============================================================================

fn span_new(start: i64, end: i64, line: i64, col: i64) -> Span:
        Span(start: start, end: end, line: line, col: col)


fn span_empty() -> Span:
        Span(start: 0, end: 0, line: 0, col: 0)


# Manually desugared static methods for bootstrap runtime compatibility
fn Span__new(start: i64, end: i64, line: i64, col: i64) -> Span:
    Span(start: start, end: end, line: line, col: col)

fn Span__empty() -> Span:
    Span(start: 0, end: 0, line: 0, col: 0)

fn span_from_position(pos: SourcePosition) -> Span:
    """Create zero-length span at position."""
    Span(start: pos.offset, end: pos.offset, line: pos.line, col: pos.col)

fn span_from_range(start: SourcePosition, end: SourcePosition) -> Span:
    """Create span from start to end position."""
    Span(start: start.offset, end: end.offset, line: start.line, col: start.col)

fn span_extend(self: Span, end: SourcePosition) -> Span:
    """Extend span to new end position."""
    Span(start: self.start, end: end.offset, line: self.line, col: self.col)

struct Token:
    """A token with its kind, span, and text."""
    kind: TokenKind
    span: Span
    text: text


# ============================================================================
# Token Methods (was: impl Token:)
# ============================================================================

fn token_new(kind: TokenKind, span: Span, text: text) -> Token:
        Token(kind: kind, span: span, text: text)


fn token_eof(pos: i64, line: i64) -> Token:
        """DEPRECATED: Use token_eof_at(position) instead."""
        Token(
            kind: TokenKind.Eof,
            span: span_new(pos, pos, line, 0),
            text: ""
        )

fn token_eof_at(position: SourcePosition) -> Token:
        """Create EOF token at given position."""
        Token(
            kind: TokenKind.Eof,
            span: span_from_position(position),
            text: ""
        )


# Manually desugared static methods for Token (bootstrap runtime compatibility)
fn Token__new(kind: TokenKind, span: Span, text: text) -> Token:
    Token(kind: kind, span: span, text: text)

fn Token__eof(pos: i64, line: i64) -> Token:
    """DEPRECATED: Use Token__eof_at(position) instead."""
    Token(
        kind: TokenKind.Eof,
        span: Span__new(pos, pos, line, 0),
        text: ""
    )

fn Token__eof_at(position: SourcePosition) -> Token:
    """Create EOF token at given position (static method style)."""
    Token(
        kind: TokenKind.Eof,
        span: span_from_position(position),
        text: ""
    )

# ============================================================================
# Lexer
# ============================================================================


# ============================================================================
# Exports
# ============================================================================

export TokenKind, Span, Span__new, Span__empty, Token, Token__new, Token__eof, Token__eof_at
export SourcePosition, SourcePosition__start
export sourceposition_new, sourceposition_advance
export span_from_position, span_from_range, span_extend
export token_eof_at
