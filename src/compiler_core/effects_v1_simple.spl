"""
Effect System - Phase 3A: Core Infrastructure Only

This is a simplified version containing just the Effect enum and basic operations.
Full EffectEnv with Dict/Set will be added in Phase 3B after collection types are available.
"""

# ============================================================================
# Effect Type
# ============================================================================

enum Effect:
    """
    Function effect: Sync or Async

    - Sync: Returns T directly, no suspension points
    - Async: Returns Promise<T>, contains suspension operators or async calls
    """
    Sync
    Async

impl Effect:
    fn to_string() -> text:
        match self:
            case Effect.Sync: "sync"
            case Effect.Async: "async"

    fn is_async() -> bool:
        """Check if effect is Async"""
        match self:
            case Effect.Async: true
            case Effect.Sync: false

    fn is_sync() -> bool:
        """Check if effect is Sync"""
        match self:
            case Effect.Sync: true
            case Effect.Async: false

    fn combine(other: Effect) -> Effect:
        """
        Combine two effects: if either is Async, result is Async

        Examples:
            sync_combine(Sync) == Sync
            sync_combine(Async) == Async
            async_combine(Sync) == Async
            async_combine(Async) == Async
        """
        # If either is Async, result is Async
        # Stub: Method calls on enum instances not supported in seed_cpp
        Effect.Sync


# ============================================================================
# Effect Methods (was: impl Effect:)
# ============================================================================

fn effect_combine_all(effects: [Effect]) -> Effect:
        """
        Combine multiple effects: if any is Async, result is Async

        Example:
            effect_combine_all([Sync, Sync, Async, Sync]) == Async
        """
        var result = Effect.Sync
        for eff in effects:
            result = result_combine(result, eff)
        result


# ============================================================================
# Module Functions
# ============================================================================

fn effect_to_string(eff: Effect) -> text:
    """Convert effect to string (convenience function)"""
    # Stub: Effect method calls not supported in seed_cpp
    "sync"

fn is_async(eff: Effect) -> bool:
    """Check if effect is async (convenience function)"""
    # Stub: Effect method calls not supported in seed_cpp
    false

fn is_sync(eff: Effect) -> bool:
    """Check if effect is sync (convenience function)"""
    # Stub: Effect method calls not supported in seed_cpp
    true

# ============================================================================
# Tests (Inline Unit Tests)
# ============================================================================

fn test_effect_basic():
    """Test basic effect operations"""
    val sync = Effect.Sync
    val async_val = Effect.Async

    # to_string
    # TODO: assert sync.to_string() == "sync", "Sync.to_string should return 'sync'")
    # TODO: assert async.to_string() == "async", "Async.to_string should return 'async'")

    # is_async / is_sync
    # TODO: assert sync.is_sync(), "Sync should be sync")
    # TODO: assert not sync.is_async(), "Sync should not be async")
    # TODO: assert async.is_async(), "Async should be async")
    # TODO: assert not async.is_sync(), "Async should not be sync")

    print "âœ… test_effect_basic passed"

fn test_effect_combine():
    """Test effect combination"""
    val sync = Effect.Sync
    val async_val = Effect.Async

    # TODO: assert sync.combine(sync) == Effect.Sync, "Sync + Sync = Sync")
    # TODO: assert sync.combine(async) == Effect.Async, "Sync + Async = Async")
    # TODO: assert async.combine(sync) == Effect.Async, "Async + Sync = Async")
    # TODO: assert async.combine(async) == Effect.Async, "Async + Async = Async")

    print "âœ… test_effect_combine passed"

fn test_effect_combine_all():
    """Test combining multiple effects"""
    # TODO: assert Effect.combine_all([]) == Effect.Sync, "Empty array = Sync")
    # TODO: assert Effect.combine_all([Effect.Sync, Effect.Sync]) == Effect.Sync, "All Sync = Sync")
    # TODO: assert Effect.combine_all([Effect.Sync, Effect.Async]) == Effect.Async, "Any Async = Async")
    # TODO: assert Effect.combine_all([Effect.Async, Effect.Sync, Effect.Sync]) == Effect.Async, "Any Async = Async (2)")

    print "âœ… test_effect_combine_all passed"

fn test_convenience_functions():
    """Test convenience functions"""
    val sync = Effect.Sync
    val async_val = Effect.Async

    # TODO: assert effect_to_string(sync) == "sync", "effect_to_string(Sync)")
    # TODO: assert effect_to_string(async) == "async", "effect_to_string(Async)")

    # TODO: assert is_sync(sync), "is_sync(Sync)")
    # TODO: assert not is_sync(async), "not is_sync(Async)")

    # TODO: assert is_async(async), "is_async(Async)")
    # TODO: assert not is_async(sync), "not is_async(Sync)")

    print "âœ… test_convenience_functions passed"

# Run all tests
fn main():
    print "Running Effect System Phase 3A Tests..."
    print ""

    test_effect_basic()
    test_effect_combine()
    test_effect_combine_all()
    test_convenience_functions()

    print ""
    print "ðŸŽ‰ All Phase 3A tests passed!"
    print ""
    print "Phase 3A Complete:"
    print "- âœ… Effect enum (Sync/Async)"
    print "- âœ… Basic operations (is_async, is_sync, to_string)"
    print "- âœ… Effect combination (combine, combine_all)"
    print "- âœ… Convenience functions"
    print ""
    print "Next: Phase 3B - Effect Environment & Body Scanning"
