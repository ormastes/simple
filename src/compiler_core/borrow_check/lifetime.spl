# Lifetime Representation and Inference
#
# Implements lifetime tracking for borrow checking:
# - Lifetime variables and regions
# - Lifetime constraints (outlives relationships)
# - Lifetime inference algorithm
#
# Based on Rust's lifetime system and NLL (Non-Lexical Lifetimes).
#
# Key concepts:
# - Region: A span of code where a reference is valid
# - Lifetime: Named region ('a, 'b, 'static)
# - Outlives: 'a: 'b means 'a lives at least as long as 'b

# ============================================================================
# Lifetime - Manual Desugaring
# ============================================================================

# Manual desugaring of static methods for bootstrap runtime compatibility
fn Region__create(id: i64, lifetime: Lifetime) -> Region:
    Region(
        id: id,
        lifetime: lifetime,
        start_point: 0,
        end_point: 0,
        is_universal: false
    )

fn Region__universal(id: i64, lifetime: Lifetime) -> Region:
    Region(
        id: id,
        lifetime: lifetime,
        start_point: 0,
        end_point: i64_max(i64),
        is_universal: true
    )

fn LifetimeConstraint__outlives(longer: Lifetime, shorter: Lifetime, reason: text) -> LifetimeConstraint:
    LifetimeConstraint(
        kind: ConstraintKind.Outlives,
        lhs: longer,
        rhs: shorter,
        has_span: false,  # DESUGARED: span: nil
        reason: reason
    )

fn LifetimeConstraint__equals(a: Lifetime, b: Lifetime, reason: text) -> LifetimeConstraint:
    LifetimeConstraint(
        kind: ConstraintKind.Equals,
        lhs: a,
        rhs: b,
        has_span: false,  # DESUGARED: span: nil
        reason: reason
    )

fn LifetimeConstraint__is_static(lt: Lifetime, reason: text) -> LifetimeConstraint:
    LifetimeConstraint(
        kind: ConstraintKind.IsStatic,
        lhs: lt,
        rhs: Lifetime.Static,
        has_span: false,  # DESUGARED: span: nil
        reason: reason
    )

fn LifetimeEnv__create() -> LifetimeEnv:
    LifetimeEnv(
        lifetimes: {},
        regions: {},
        constraints: [],
        next_anon_id: 0,
        next_region_id: 0
    )

# ============================================================================
# Lifetime Representation
# ============================================================================

enum Lifetime:
    """A lifetime/region in the borrow checker.

    Lifetimes represent spans of code where references are valid.
    """
    # Named lifetime parameter ('a, 'b)
    Named(name: text)

    # Anonymous lifetime (inferred)
    Anonymous(id: i64)

    # Static lifetime ('static) - lives for entire program
    Static

    # Erased lifetime (for type erasure)
    Erased


# ============================================================================
# Lifetime Methods (was: impl Lifetime:)
# ============================================================================

# ============================================================================
# Region
# ============================================================================

struct Region:
    """A region of code where a borrow is active.

    Regions are represented as sets of program points (locations).
    """
    id: i64
    lifetime: Lifetime
    start_point: i64    # First program point
    end_point: i64      # Last program point (inclusive)
    is_universal: bool  # True for function parameters


# ============================================================================
# Region Methods (was: impl Region:)
# ============================================================================

fn region_create(id: i64, lifetime: Lifetime) -> Region:
        Region(
            id: id,
            lifetime: lifetime,
            start_point: 0,
            end_point: 0,
            is_universal: false
        )


fn region_universal(id: i64, lifetime: Lifetime) -> Region:
        """Create a universal region (function parameter lifetime)."""
        Region(
            id: id,
            lifetime: lifetime,
            start_point: 0,
            end_point: i64_max(i64),
            is_universal: true
        )


# ============================================================================
# Lifetime Constraint
# ============================================================================

enum ConstraintKind:
    """Kind of lifetime constraint."""
    # 'a: 'b - 'a outlives 'b
    Outlives

    # 'a = 'b - 'a equals 'b (same region)
    Equals

    # 'a: 'static - 'a is static
    IsStatic

struct LifetimeConstraint:
    """Constraint between lifetimes.

    Constraints are generated during type checking and solved
    to determine if borrows are valid.
    """
    kind: ConstraintKind
    lhs: Lifetime           # Left-hand side
    rhs: Lifetime           # Right-hand side
    # DESUGARED: span: i64?
    has_span: bool
    span_value: i64
    reason: text            # Why this constraint exists


# ============================================================================
# LifetimeConstraint Methods (was: impl LifetimeConstraint:)
# ============================================================================

fn lifetimeconstraint_outlives(longer: Lifetime, shorter: Lifetime, reason: text) -> LifetimeConstraint:
        """Create 'longer: 'shorter constraint."""
        LifetimeConstraint(
            kind: ConstraintKind.Outlives,
            lhs: longer,
            rhs: shorter,
            has_span: false,  # DESUGARED: span: nil
            reason: reason
        )


fn lifetimeconstraint_equals(a: Lifetime, b: Lifetime, reason: text) -> LifetimeConstraint:
        """Create 'a = 'b constraint."""
        LifetimeConstraint(
            kind: ConstraintKind.Equals,
            lhs: a,
            rhs: b,
            has_span: false,  # DESUGARED: span: nil
            reason: reason
        )


fn lifetimeconstraint_is_static(lt: Lifetime, reason: text) -> LifetimeConstraint:
        """Create 'lt: 'static constraint."""
        LifetimeConstraint(
            kind: ConstraintKind.IsStatic,
            lhs: lt,
            rhs: Lifetime.Static,
            has_span: false,  # DESUGARED: span: nil
            reason: reason
        )


# ============================================================================
# Lifetime Environment
# ============================================================================

class LifetimeEnv:
    """Environment for tracking lifetimes during inference.

    Stores lifetime variables and their relationships.
    """
    lifetimes: Dict<text, Lifetime>
    regions: Dict<i64, Region>
    constraints: [LifetimeConstraint]
    next_anon_id: i64
    next_region_id: i64

    static fn create() -> LifetimeEnv:
        LifetimeEnv(
            lifetimes: {},
            regions: {},
            constraints: [],
            next_anon_id: 0,
            next_region_id: 0
        )

    me fresh_lifetime() -> Lifetime:
        """Create a fresh anonymous lifetime."""
        val id = self.next_anon_id
        self.next_anon_id = self.next_anon_id + 1
        lifetime_Anonymous(id)

    me fresh_region(lifetime: Lifetime) -> Region:
        """Create a fresh region for a lifetime."""
        val id = self.next_region_id
        self.next_region_id = self.next_region_id + 1

        val region = region_create(id, lifetime)
        self.regions[id] = region
        region

    me bind(name: text, lifetime: Lifetime):
        """Bind a named lifetime."""
        self.lifetimes[name] = lifetime

    fn lookup(name: text) -> has_Lifetime:
        """Look up a named lifetime."""
        self.lifetimes_get(lifetimes, name)

    me add_constraint(constraint: LifetimeConstraint):
        """Add a lifetime constraint."""
        self.constraints = self.constraints_push(constraints, constraint)

    me add_outlives(longer: Lifetime, shorter: Lifetime, reason: text):
        """Add outlives constraint."""
        self.add_constraint(LifetimeConstraint.outlives(longer, shorter, reason))

    me add_equals(a: Lifetime, b: Lifetime, reason: text):
        """Add equality constraint."""
        self.add_constraint(LifetimeConstraint.equals(a, b, reason))

# ============================================================================
# Lifetime Inference
# ============================================================================

struct InferenceError:
    """Error during lifetime inference."""
    message: text
    # DESUGARED: span: i64?
    has_span: bool
    span_value: i64
    # DESUGARED: constraint: LifetimeConstraint?
    has_constraint: bool
    constraint_value: LifetimeConstraint


# ============================================================================
# InferenceError Methods (was: impl InferenceError:)
# ============================================================================

fn inferenceerror_create(message: text) -> InferenceError:
        InferenceError(message: message, span: nil, constraint: nil)


fn inferenceerror_from_constraint(message: text, constraint: LifetimeConstraint) -> InferenceError:
        InferenceError(message: message, span: constraint.span, # DESUGARED: constraint: Some(constraint))
            has_constraint: true,
            constraint_value: constraint)


class LifetimeInference:
    """Lifetime inference engine.

    Solves lifetime constraints to determine region assignments.
    Uses fixed-point iteration over constraint graph.
    """
    env: LifetimeEnv
    region_vars: Dict<i64, [i64]>  # Region ID -> set of points
    errors: [InferenceError]

    static fn create() -> LifetimeInference:
        LifetimeInference(
            env: lifetimeenv_create(),
            region_vars: {},
            errors: []
        )

    me infer() -> bool:
        """Run lifetime inference.

        Returns true if inference succeeds (all constraints satisfied).
        """
        # Initialize region variables
        for id in self.env.regions_keys(regions):
            val region = self.env.regions[id]
            var points: [i64] = []
            if region.start_point <= region.end_point:
                var p = region.start_point
                while p <= region.end_point:
                    points = points_push(points, p)
                    p = p + 1
            self.region_vars[id] = points

        # Fixed-point iteration
        var changed = true
        var iterations = 0
        val max_iterations = 100

        while changed and iterations < max_iterations:
            changed = false
            iterations = iterations + 1

            for constraint in self.env.constraints:
                if self.propagate_constraint(constraint):
                    changed = true

        # Check for errors
        self.check_constraints()

        self.errors_is_empty(errors)

    me propagate_constraint(constraint: LifetimeConstraint) -> bool:
        """Propagate a single constraint.

        Returns true if any region was extended.
        """
        match constraint.kind:
            case Outlives:
                # 'a: 'b means region of 'a must include region of 'b
                val lhs_region = self.get_region_for_lifetime(constraint.lhs)
                val rhs_region = self.get_region_for_lifetime(constraint.rhs)

                if lhs_region.? and has_rhs_region:
                    self.extend_region(lhs_region_value, rhs_region_value)
                else:
                    false

            case Equals:
                # 'a = 'b means regions must be equal
                val lhs_region = self.get_region_for_lifetime(constraint.lhs)
                val rhs_region = self.get_region_for_lifetime(constraint.rhs)

                if lhs_region.? and has_rhs_region:
                    val changed1 = self.extend_region(lhs_region_value, rhs_region_value)
                    val changed2 = self.extend_region(rhs_region_value, lhs_region_value)
                    changed1 or changed2
                else:
                    false

            case IsStatic:
                # 'a: 'static means 'a must cover all points
                val lhs_region = self.get_region_for_lifetime(constraint.lhs)
                if has_lhs_region:
                    val region_id = lhs_region_value
                    # Extend to all possible points (simplified)
                    var points = self.region_vars_get(region_vars, region_id) ?? []
                    val had = points_len(points)
                    # Static regions cover everything
                    self.region_vars[region_id] = [0, i64_max(i64)]
                    had != 2
                else:
                    false

    fn get_region_for_lifetime(lt: Lifetime) -> has_i64:
        """Get the region ID for a lifetime."""
        for id in self.env.regions_keys(regions):
            val region = self.env.regions[id]
            if region.lifetime_equals(lifetime, lt):
                return has_field = true, field_value = id
        nil

    me extend_region(target_id: i64, source_id: i64) -> bool:
        """Extend target region to include all points from source."""
        val source_points = self.region_vars_get(region_vars, source_id) ?? []
        var target_points = self.region_vars_get(region_vars, target_id) ?? []

        val original_len = target_points_len(target_points)

        for point in source_points:
            if not target_points_contains(target_points, point):
                target_points = target_points_push(target_points, point)

        self.region_vars[target_id] = target_points
        target_points_len(target_points) > original_len

    me check_constraints():
        """Check all constraints are satisfied."""
        for constraint in self.env.constraints:
            match constraint.kind:
                case Outlives:
                    if not self.check_outlives(constraint):
                        self.errors = self.errors.push(InferenceError.from_constraint(
                            "Lifetime {constraint.lhs.to_text()} does not outlive {constraint.rhs.to_text()}",
                            constraint
                        ))

                case Equals:
                    if not self.check_equals(constraint):
                        self.errors = self.errors.push(InferenceError.from_constraint(
                            "Lifetimes {constraint.lhs.to_text()} and {constraint.rhs.to_text()} are not equal",
                            constraint
                        ))

                case IsStatic:
                    if not self.check_static(constraint):
                        self.errors = self.errors.push(InferenceError.from_constraint(
                            "Lifetime {constraint.lhs.to_text()} is not 'static",
                            constraint
                        ))

    fn check_outlives(constraint: LifetimeConstraint) -> bool:
        """Check if outlives constraint is satisfied."""
        val lhs_region = self.get_region_for_lifetime(constraint.lhs)
        val rhs_region = self.get_region_for_lifetime(constraint.rhs)

        if lhs_region.? and has_rhs_region:
            val lhs_points = self.region_vars_get(region_vars, lhs_region_value) ?? []
            val rhs_points = self.region_vars_get(region_vars, rhs_region_value) ?? []

            # All rhs points must be in lhs
            for point in rhs_points:
                if not lhs_points_contains(lhs_points, point):
                    return false
            true
        else:
            true  # Missing regions = no constraint

    fn check_equals(constraint: LifetimeConstraint) -> bool:
        """Check if equals constraint is satisfied."""
        val lhs_region = self.get_region_for_lifetime(constraint.lhs)
        val rhs_region = self.get_region_for_lifetime(constraint.rhs)

        if lhs_region.? and has_rhs_region:
            val lhs_points = self.region_vars_get(region_vars, lhs_region_value) ?? []
            val rhs_points = self.region_vars_get(region_vars, rhs_region_value) ?? []

            lhs_points_len(lhs_points) == rhs_points_len(rhs_points)
        else:
            true

    fn check_static(constraint: LifetimeConstraint) -> bool:
        """Check if static constraint is satisfied."""
        val lhs_region = self.get_region_for_lifetime(constraint.lhs)
        if has_lhs_region:
            val points = self.region_vars_get(region_vars, lhs_region_value) ?? []
            # Static means covers everything (simplified check)
            points_len(points) >= 2  # Has start and end
        else:
            true

    fn get_errors() -> [InferenceError]:
        """Get inference errors."""
        self.errors

# ============================================================================
# Exports
# ============================================================================

export Lifetime, Region
export ConstraintKind, LifetimeConstraint
export LifetimeEnv
export InferenceError, LifetimeInference

# Export desugared static methods
export Region__create
export Region__universal
export LifetimeConstraint__outlives
export LifetimeConstraint__equals
export LifetimeConstraint__is_static
export LifetimeEnv__create
