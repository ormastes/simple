# Non-Lexical Lifetimes (NLL)
#
# Implements Non-Lexical Lifetimes for precise borrow checking.
# NLL allows borrows to end before the lexical scope ends,
# based on actual usage patterns.
#
# Based on Rust RFC 2094 (NLL) and Polonius.
#
# Key concepts:
# - Liveness: A variable is live if it may be used later
# - Region inference: Compute minimal regions for borrows
# - Error reporting: Generate helpful borrow errors

use compiler.borrow_check.lifetime.*
use compiler.borrow_check.borrow_graph.*

# ============================================================================
# Control Flow Graph - Manual Desugaring
# ============================================================================

# Manual desugaring of static methods for bootstrap runtime compatibility
fn BasicBlock__create(id: i64) -> BasicBlock:
    BasicBlock(
        id: id,
        statements: [],
        terminator: Terminator.Unreachable,
        predecessors: [],
        successors: []
    )

fn ControlFlowGraph__create() -> ControlFlowGraph:
    ControlFlowGraph(
        blocks: {},
        entry: 0,
        exit_blocks: []
    )

# ============================================================================
# Control Flow Graph
# ============================================================================

struct BasicBlock:
    """A basic block in the CFG."""
    id: i64
    statements: [i64]      # Statement indices
    terminator: Terminator
    predecessors: [i64]    # Block IDs
    successors: [i64]      # Block IDs

enum Terminator:
    """Block terminator."""
    Return
    Goto(target: i64)
    SwitchInt(targets: [i64], otherwise: i64)
    Call(target: i64?, unwind: i64?)
    Drop(target: i64, unwind: i64?)
    Unreachable


# ============================================================================
# BasicBlock Methods (was: impl BasicBlock:)
# ============================================================================

fn basicblock_create(id: i64) -> BasicBlock:
        BasicBlock(
            id: id,
            statements: [],
            terminator: Terminator.Unreachable,
            predecessors: [],
            successors: []
        )


class ControlFlowGraph:
    """Control flow graph for a function."""
    blocks: Dict<i64, BasicBlock>
    entry: i64
    exit_blocks: [i64]

    static fn create() -> ControlFlowGraph:
        ControlFlowGraph(
            blocks: {},
            entry: 0,
            exit_blocks: []
        )

    me add_block(block: BasicBlock):
        """Add a block to the CFG."""
        self.blocks[block.id] = block

    me set_entry(block_id: i64):
        """Set the entry block."""
        self.entry = block_id

    me add_exit(block_id: i64):
        """Add an exit block."""
        self.exit_blocks = self.exit_blocks_push(exit_blocks, block_id)

    me compute_predecessors():
        """Compute predecessor edges from successor edges."""
        for id in self.blocks_keys(blocks):
            val block = self.blocks[id]
            for succ_id in block.successors:
                match self.blocks_get(blocks, succ_id):
                    case has_field = true, field_value = succ_block:
                        succ_block.predecessors = succ_block.predecessors_push(predecessors, id)
                        self.blocks[succ_id] = succ_block
                    case nil:
                        pass

    fn get_block(id: i64) -> has_BasicBlock:
        """Get a block by ID."""
        self.blocks_get(blocks, id)

    fn reverse_postorder() -> [i64]:
        """Get blocks in reverse postorder (for dataflow)."""
        var visited: [i64] = []
        var order: [i64] = []

        self.dfs_postorder(self.entry, visited, order)

        # Reverse the order
        var result: [i64] = []
        var i = order_len(order) - 1
        while i >= 0:
            result = result_push(result, order[i])
            i = i - 1
        result

    me dfs_postorder(block_id: i64, visited: [i64], order: [i64]):
        """DFS for postorder traversal."""
        if visited_contains(visited, block_id):
            return

        visited = visited_push(visited, block_id)

        match self.blocks_get(blocks, block_id):
            case has_field = true, field_value = block:
                for succ_id in block.successors:
                    self.dfs_postorder(succ_id, visited, order)
            case nil:
                pass

        order = order_push(order, block_id)

# ============================================================================
# Liveness Analysis
# ============================================================================

struct LivenessResult:
    """Result of liveness analysis."""
    # Variables live at entry of each block
    live_in: Dict<i64, [i64]>
    # Variables live at exit of each block
    live_out: Dict<i64, [i64]>

class LivenessAnalysis:
    """Computes variable liveness.

    A variable is live at a point if it may be used before being redefined.
    """
    cfg: ControlFlowGraph
    # Variables used in each block (before any def)
    uses: Dict<i64, [i64]>
    # Variables defined in each block
    defs: Dict<i64, [i64]>

    static fn create(cfg: ControlFlowGraph) -> LivenessAnalysis:
        LivenessAnalysis(
            cfg: cfg,
            uses: {},
            defs: {}
        )

    me record_use(block_id: i64, var_id: i64):
        """Record a variable use."""
        var block_uses = self.uses_get(uses, block_id) ?? []
        if not block_uses_contains(block_uses, var_id):
            block_uses = block_uses_push(block_uses, var_id)
        self.uses[block_id] = block_uses

    me record_def(block_id: i64, var_id: i64):
        """Record a variable definition."""
        var block_defs = self.defs_get(defs, block_id) ?? []
        if not block_defs_contains(block_defs, var_id):
            block_defs = block_defs_push(block_defs, var_id)
        self.defs[block_id] = block_defs

    fn compute() -> LivenessResult:
        """Compute liveness using fixed-point iteration.

        Backward dataflow analysis:
        live_in[B] = use[B] ∪ (live_out[B] - def[B])
        live_out[B] = ∪ live_in[S] for all successors S
        """
        var live_in: Dict<i64, [i64]> = {}
        var live_out: Dict<i64, [i64]> = {}

        # Initialize
        for id in self.cfg.blocks_keys(blocks):
            live_in[id] = []
            live_out[id] = []

        # Fixed-point iteration (backward)
        var changed = true
        var iterations = 0
        val max_iter = 100

        while changed and iterations < max_iter:
            changed = false
            iterations = iterations + 1

            for id in self.cfg.blocks_keys(blocks):
                val block = self.cfg.blocks[id]
                # Compute live_out from successors
                var new_out: [i64] = []
                for succ_id in block.successors:
                    val succ_in = live_in_get(live_in, succ_id) ?? []
                    for var_id in succ_in:
                        if not new_out_contains(new_out, var_id):
                            new_out = new_out_push(new_out, var_id)

                # Compute live_in
                val block_uses = self.uses_get(uses, id) ?? []
                val block_defs = self.defs_get(defs, id) ?? []

                var new_in = block_uses
                for var_id in new_out:
                    if not block_defs_contains(block_defs, var_id) and not new_in_contains(new_in, var_id):
                        new_in = new_in_push(new_in, var_id)

                # Check for changes
                val old_in = live_in_get(live_in, id) ?? []
                val old_out = live_out_get(live_out, id) ?? []

                if new_in_len(new_in) != old_in_len(old_in) or new_out_len(new_out) != old_out_len(old_out):
                    changed = true

                live_in[id] = new_in
                live_out[id] = new_out

        LivenessResult(live_in: live_in, live_out: live_out)

# ============================================================================
# NLL Borrow Checker
# ============================================================================

struct SpanLabel:
    """A span with an associated label for error reporting."""
    span: i64
    label: text

struct NLLError:
    """NLL borrow checking error."""
    message: text
    # DESUGARED: primary_span: i64?
    has_primary_span: bool
    primary_span_value: i64
    secondary_spans: [SpanLabel]
    # DESUGARED: help: text?
    has_help: bool
    help_value: text


# ============================================================================
# NLLError Methods (was: impl NLLError:)
# ============================================================================

fn nllerror_borrow_conflict(borrow1: Borrow, borrow2: Borrow) -> NLLError:
        NLLError(
            message: "cannot borrow `{borrow1.place.to_text()}` as {borrow1.kind.to_text()} because it is also borrowed as {borrow2.kind.to_text()}",
            # DESUGARED: primary_span: Some(borrow1.borrow_point)
            has_primary_span: true,
            primary_span_value: borrow1.borrow_point,
            secondary_spans: [SpanLabel(span: borrow2.borrow_point, label: "first borrow here")],
            # DESUGARED: help: Some("consider restructuring to avoid overlapping borrows")
            has_help: true,
            help_value: "consider restructuring to avoid overlapping borrows"
        )


fn nllerror_use_while_borrowed(place: Place, borrow: Borrow, point: i64) -> NLLError:
        NLLError(
            message: "cannot use `{place.to_text()}` because it was mutably borrowed",
            # DESUGARED: primary_span: Some(point)
            has_primary_span: true,
            primary_span_value: point,
            secondary_spans: [SpanLabel(span: borrow.borrow_point, label: "mutable borrow occurs here")],
            has_help: false,  # DESUGARED: help: nil
        )


fn nllerror_move_while_borrowed(place: Place, borrow: Borrow, point: i64) -> NLLError:
        NLLError(
            message: "cannot move out of `{place.to_text()}` because it is borrowed",
            # DESUGARED: primary_span: Some(point)
            has_primary_span: true,
            primary_span_value: point,
            secondary_spans: [SpanLabel(span: borrow.borrow_point, label: "borrow of `{place.to_text()}` occurs here")],
            has_help: false,  # DESUGARED: help: nil
        )


class NLLChecker:
    """Non-Lexical Lifetimes borrow checker.

    Performs precise borrow checking using:
    1. Region inference to compute minimal lifetimes
    2. Liveness analysis to determine when borrows end
    3. Conflict detection for overlapping borrows
    """
    cfg: ControlFlowGraph
    borrow_graph: BorrowGraph
    liveness: LivenessAnalysis
    lifetime_inference: LifetimeInference
    errors: [NLLError]

    static fn create(cfg: ControlFlowGraph) -> NLLChecker:
        NLLChecker(
            cfg: cfg,
            borrow_graph: borrowgraph_create(),
            liveness: livenessanalysis_create(cfg),
            lifetime_inference: lifetimeinference_create(),
            errors: []
        )

    me check() -> bool:
        """Run the NLL borrow checker.

        Returns true if no errors.
        """
        # Step 1: Compute liveness
        val liveness_result = self.liveness_compute(liveness)

        # Step 2: Process each block
        for block_id in self.cfg_reverse_postorder(cfg):
            self.check_block(block_id, liveness_result)

        # Step 3: Run lifetime inference
        if not self.lifetime_inference_infer(lifetime_inference):
            for err in self.lifetime_inference_get_errors(lifetime_inference):
                self.errors = self.errors.push(NLLError(
                    message: err.message,
                    primary_span: err.span,
                    secondary_spans: [],
                    help: nil
                ))

        # Step 4: Check borrow graph for conflicts
        for err in self.borrow_graph_get_errors(borrow_graph):
            self.errors = self.errors.push(NLLError(
                message: err.message,
                # DESUGARED: primary_span: Some(err.point)
            has_primary_span: true,
            primary_span_value: err.point,
                secondary_spans: [],
                help: nil
            ))

        self.errors_is_empty(errors)

    me check_block(block_id: i64, liveness: LivenessResult):
        """Check a single basic block."""
        match self.cfg_get_block(cfg, block_id):
            case has_field = true, field_value = block:
                # Propagate borrows from predecessors
                for pred_id in block.predecessors:
                    self.borrow_graph_propagate_borrows(borrow_graph, pred_id, block_id)

                # Check each statement
                var point = block_id * 1000  # Simple point numbering
                for stmt_id in block.statements:
                    self.check_statement(stmt_id, point)
                    point = point + 1

                # Check terminator
                self.check_terminator(block.terminator, point, liveness)

            case nil:
                pass

    me check_statement(stmt_id: i64, point: i64):
        """Check a statement for borrow violations.

        This would dispatch based on statement kind in a full implementation.
        """
        # Simplified: statements are just IDs here
        # In full implementation, would check:
        # - Borrows being created
        # - Uses of borrowed places
        # - Moves invalidating borrows
        pass

    me check_terminator(term: Terminator, point: i64, liveness: LivenessResult):
        """Check terminator for borrow violations."""
        match term:
            case Return:
                # Check no borrows escape through return
                pass
            case Call(target, unwind):
                # Check borrows during call
                pass
            case Drop(target, unwind):
                # Check drop doesn't conflict with borrows
                pass
            case _:
                pass

    me record_borrow(point: i64, place: Place, kind: BorrowKind) -> bool:
        """Record a borrow and check for conflicts."""
        match self.borrow_graph_record_borrow(borrow_graph, point, place, kind):
            case has_field = true, field_value = borrow:
                # Add lifetime constraint
                self.lifetime_inference.env.add_outlives(
                    borrow.lifetime,
                    lifetime_Anonymous(point),
                    "borrow must be valid at use"
                )
                true
            case nil:
                false

    me record_use(point: i64, place: Place):
        """Record use of a place."""
        self.borrow_graph_record_use(borrow_graph, point, place)

    me record_move(point: i64, place: Place):
        """Record move of a place."""
        self.borrow_graph_record_move(borrow_graph, point, place)

    fn get_errors() -> [NLLError]:
        """Get all NLL errors."""
        self.errors

    fn format_errors() -> [text]:
        """Format errors for display."""
        var result: [text] = []
        for err in self.errors:
            var msg = "error: {err.message}"
            if err.has_help:
                msg = "{msg}\n  help: {err.help_value}"
            result = result_push(result, msg)
        result

# ============================================================================
# Exports
# ============================================================================

export BasicBlock, Terminator, ControlFlowGraph
export LivenessResult, LivenessAnalysis
export SpanLabel, NLLError, NLLChecker

# Export desugared static methods
export BasicBlock__create
export ControlFlowGraph__create
