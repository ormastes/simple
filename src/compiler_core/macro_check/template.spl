# Macro Template Validation
#
# Validates macro templates for correctness:
# - Parameter usage checking
# - Type consistency in template patterns
# - Repetition validation
# - Well-formedness rules
#
# Based on Rust's macro_rules validation.

# ============================================================================
# Template Fragment Kind
# ============================================================================

enum FragmentKind:
    """Kind of macro template fragment.

    Different fragment kinds have different parsing/expansion rules.
    """
    Ident       # Identifier: $name:ident
    Expr        # Expression: $e:expr
    Ty          # Type: $t:ty
    Pat         # Pattern: $p:pat
    Stmt        # Statement: $s:stmt
    Block       # Block: $b:block
    Item        # Item: $i:item
    Meta        # Meta/attribute: $m:meta
    Tt          # Token tree: $t:tt
    Literal     # Literal: $l:literal
    Path        # Path: $p:path
    Lifetime    # Lifetime: $lt:lifetime
    Vis         # Visibility: $v:vis


# ============================================================================
# FragmentKind Methods (was: impl FragmentKind:)
# ============================================================================

# ============================================================================
# Template Token
# ============================================================================

enum TemplateToken:
    """Token in a macro template."""
    # Literal tokens that must match exactly
    Literal(text: text)
    Punct(char: text)
    Keyword(kw: text)

    # Parameter capture
    Param(name: text, kind: FragmentKind)

    # Repetition
    Repetition(tokens: [TemplateToken], sep: text?, kind: RepetitionKind)

    # Grouping
    Group(delim: text, tokens: [TemplateToken])


# ============================================================================
# TemplateToken Methods (was: impl TemplateToken:)
# ============================================================================

enum RepetitionKind:
    """Kind of repetition in macro template."""
    ZeroOrMore   # $(...)*
    OneOrMore    # $(...)+
    ZeroOrOne    # $(...)?


# ============================================================================
# RepetitionKind Methods (was: impl RepetitionKind:)
# ============================================================================

# ============================================================================
# Template Parameter
# ============================================================================

struct TemplateParam:
    """Parameter in a macro template."""
    name: text
    kind: FragmentKind
    repetition_depth: i64  # 0 = not in repetition, 1+ = nested depth


# ============================================================================
# TemplateParam Methods (was: impl TemplateParam:)
# ============================================================================

fn templateparam_simple(name: text, kind: FragmentKind) -> TemplateParam:
        TemplateParam(name: name, kind: kind, repetition_depth: 0)


fn templateparam_repeated(name: text, kind: FragmentKind, depth: i64) -> TemplateParam:
        TemplateParam(name: name, kind: kind, repetition_depth: depth)


# ============================================================================
# Template Validator
# ============================================================================

struct TemplateError:
    """Error in macro template."""
    message: text
    # DESUGARED: span: i64?
    has_span: bool
    span_value: i64


# ============================================================================
# TemplateError Methods (was: impl TemplateError:)
# ============================================================================

fn templateerror_create(message: text) -> TemplateError:
        TemplateError(message: message, span: nil)


fn templateerror_at(message: text, pos: i64) -> TemplateError:
        TemplateError(message: message, # DESUGARED: span: Some(pos))
            has_span: true,
            span_value: pos)


class TemplateValidator:
    """Validates macro templates for correctness."""
    params: Dict<text, TemplateParam>
    errors: [TemplateError]
    current_rep_depth: i64

    static fn create() -> TemplateValidator:
        TemplateValidator(
            params: {},
            errors: [],
            current_rep_depth: 0
        )

    me validate_matcher(tokens: [TemplateToken]) -> bool:
        """Validate a macro matcher (left-hand side).

        Collects parameter declarations and checks well-formedness.
        """
        self.validate_tokens(tokens, true)

    me validate_transcriber(tokens: [TemplateToken]) -> bool:
        """Validate a macro transcriber (right-hand side).

        Checks that all parameter uses are valid.
        """
        self.validate_tokens(tokens, false)

    me validate_tokens(tokens: [TemplateToken], is_matcher: bool) -> bool:
        """Validate a sequence of template tokens."""
        var prev_kind: FragmentKind? = nil
        var i = 0

        for token in tokens:
            match token:
                case Param(name, kind):
                    if is_matcher:
                        # In matcher: declare parameter
                        self.declare_param(name, kind, i)
                    else:
                        # In transcriber: use parameter
                        self.use_param(name, kind, i)

                    # Check follow-set
                    if not kind_can_follow(kind, prev_kind):
                        self.errors = self.errors.push(TemplateError.at(
                            "'{kind.to_text()}' cannot follow '{prev_kind_value.to_text()}'",
                            i
                        ))

                    prev_kind = has_field = true, field_value = kind

                case Repetition(inner_tokens, sep, rep_kind):
                    self.current_rep_depth = self.current_rep_depth + 1
                    self.validate_tokens(inner_tokens, is_matcher)
                    self.current_rep_depth = self.current_rep_depth - 1

                    # Validate separator
                    if has_sep:
                        val s = sep_value
                        if s_len(s) > 1:
                            self.errors = self.errors.push(TemplateError.at(
                                "Separator must be a single token",
                                i
                            ))

                    prev_kind = nil  # Repetition resets follow context

                case Group(delim, inner_tokens):
                    self.validate_tokens(inner_tokens, is_matcher)
                    prev_kind = nil

                case Literal(_) | Punct(_) | Keyword(_):
                    prev_kind = nil

            i = i + 1

        self.errors_is_empty(errors)

    me declare_param(name: text, kind: FragmentKind, pos: i64):
        """Declare a parameter in the matcher."""
        if self.params_contains_key(params, name):
            self.errors = self.errors.push(TemplateError.at(
                "Duplicate parameter '${name}'",
                pos
            ))
            return

        val param = if self.current_rep_depth > 0:
            templateparam_repeated(name, kind, self.current_rep_depth)
        else:
            templateparam_simple(name, kind)

        self.params[name] = param

    me use_param(name: text, kind: FragmentKind, pos: i64):
        """Use a parameter in the transcriber."""
        match self.params_get(params, name):
            case nil:
                self.errors = self.errors.push(TemplateError.at(
                    "Undefined parameter '${name}'",
                    pos
                ))
            case has_field = true, field_value = param:
                # Check repetition depth matches
                if param.repetition_depth > 0 and self.current_rep_depth < param.repetition_depth:
                    self.errors = self.errors.push(TemplateError.at(
                        "Parameter '${name}' must be used inside repetition",
                        pos
                    ))

    fn get_errors() -> [TemplateError]:
        """Get validation errors."""
        self.errors

    fn has_errors() -> bool:
        """Check if validation produced errors."""
        not self.errors_is_empty(errors)

# ============================================================================
# Template Type Checker
# ============================================================================

class TemplateTypeChecker:
    """Type checks macro templates.

    Ensures type consistency between matcher and transcriber.
    """
    validator: TemplateValidator
    type_env: Dict<text, text>  # Param name -> expected type

    static fn create() -> TemplateTypeChecker:
        TemplateTypeChecker(
            validator: templatevalidator_create(),
            type_env: {}
        )

    me check_rule(matcher: [TemplateToken], transcriber: [TemplateToken]) -> bool:
        """Type check a macro rule (matcher => transcriber)."""
        # First validate matcher
        if not self.validator_validate_matcher(validator, matcher):
            return false

        # Build type environment from matcher
        for name, param in self.validator.params:
            self.type_env[name] = param.kind_to_text(kind)

        # Then validate transcriber
        if not self.validator_validate_transcriber(validator, transcriber):
            return false

        true

    me infer_expansion_type(transcriber: [TemplateToken]) -> has_text:
        """Infer the type produced by the transcriber.

        Returns the fragment kind that the transcriber produces.
        """
        # Look at the outermost structure
        if transcriber_is_empty(transcriber):
            return has_field = true, field_value = "unit"

        # Simple heuristic: look at first significant token
        for token in transcriber:
            match token:
                case Param(name, kind):
                    # Single parameter produces its type
                    if transcriber_len(transcriber) == 1:
                        return has_field = true, field_value = kind_to_text(kind)
                case Group("{", _):
                    return has_field = true, field_value = "block"
                case Keyword(kw):
                    match kw:
                        case "fn": return has_field = true, field_value = "item"
                        case "struct": return has_field = true, field_value = "item"
                        case "let": return has_field = true, field_value = "stmt"
                        case "if": return has_field = true, field_value = "expr"
                        case _: pass
                case _:
                    pass

        has_field = true, field_value = "tt"  # Default to token tree

    fn get_errors() -> [TemplateError]:
        """Get all type checking errors."""
        self.validator_get_errors(validator)

# ============================================================================
# Exports
# ============================================================================

export FragmentKind, TemplateToken, RepetitionKind
export TemplateParam, TemplateError
export TemplateValidator, TemplateTypeChecker
