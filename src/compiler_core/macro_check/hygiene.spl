# Macro Hygiene
#
# Implements hygienic macro expansion to prevent accidental name capture.
# Based on "Macros That Work Together" (Flatt et al., 2012).
#
# Key concepts:
# - Syntax Mark: Unique identifier added during expansion
# - Scope: Binding context where names are introduced
# - Rename: Resolution of marked identifiers
#
# Example of hygiene problem:
#   macro_rules! define_x {
#       () => { let x = 1; x }
#   }
#   let x = 0;
#   define_x!()  // Should NOT capture outer x

# ============================================================================
# Syntax Mark
# ============================================================================

struct SyntaxMark:
    """Unique mark added during macro expansion.

    Each macro expansion adds a unique mark to identifiers in its body.
    This prevents accidental capture of names from the expansion context.
    """
    id: i64
    expansion_id: i64  # Which expansion created this mark


# ============================================================================
# SyntaxMark Methods (was: impl SyntaxMark:)
# ============================================================================

fn syntaxmark_create(expansion_id: i64) -> SyntaxMark:
        # Use expansion_id as mark id (simple scheme)
        SyntaxMark(id: expansion_id, expansion_id: expansion_id)


# ============================================================================
# Marked Identifier
# ============================================================================

struct MarkedIdent:
    """Identifier with hygiene marks.

    Each identifier carries a list of marks from expansions it passed through.
    Two identifiers are equal only if they have the same name AND marks.
    """
    name: text
    marks: [SyntaxMark]


# ============================================================================
# MarkedIdent Methods (was: impl MarkedIdent:)
# ============================================================================

fn markedident_from_name(name: text) -> MarkedIdent:
        """Create unmarked identifier."""
        MarkedIdent(name: name, marks: [])


fn markedident_add_mark(self: MarkedIdent, mark: SyntaxMark) -> MarkedIdent:
        """Add a mark during expansion."""
        MarkedIdent(name: self.name, marks: self.marks_push(marks, mark))


fn markedident_remove_mark(self: MarkedIdent, mark: SyntaxMark) -> MarkedIdent:
        """Remove a mark (for unhygienic escapes)."""
        var new_marks: [SyntaxMark] = []
        for m in self.marks:
            if m.id != mark.id:
                new_marks = new_marks_push(new_marks, m)
        MarkedIdent(name: self.name, marks: new_marks)


# ============================================================================
# Hygiene Scope
# ============================================================================

enum ScopeKind:
    """Kind of binding scope."""
    Module          # Top-level module scope
    Function        # Function parameter scope
    Block           # Local block scope
    MacroExpansion  # Macro expansion scope
    Pattern         # Pattern binding scope

struct HygieneScope:
    """Binding scope with hygiene information.

    Tracks which names are bound in this scope and their marks.
    """
    id: i64
    kind: ScopeKind
    # DESUGARED: parent: i64?
    has_parent: bool
    parent_value: i64
    bindings: Dict<text, MarkedIdent>  # Name -> marked binding
    # DESUGARED: expansion_mark: SyntaxMark?
    has_expansion_mark: bool
    expansion_mark_value: SyntaxMark


# ============================================================================
# HygieneScope Methods (was: impl HygieneScope:)
# ============================================================================

fn hygienescope_root() -> HygieneScope:
        """Create root module scope."""
        HygieneScope(
            id: 0,
            kind: ScopeKind.Module,
            has_parent: false,  # DESUGARED: parent: nil
            bindings: {},
            has_expansion_mark: false,  # DESUGARED: expansion_mark: nil
        )


fn hygienescope_child(parent_id: i64, kind: ScopeKind, scope_id: i64) -> HygieneScope:
        """Create child scope."""
        HygieneScope(
            id: scope_id,
            kind: kind,
            # DESUGARED: parent: Some(parent_id)
            has_parent: true,
            parent_value: parent_id,
            bindings: {},
            has_expansion_mark: false,  # DESUGARED: expansion_mark: nil
        )


fn hygienescope_expansion(parent_id: i64, mark: SyntaxMark, scope_id: i64) -> HygieneScope:
        """Create macro expansion scope with mark."""
        HygieneScope(
            id: scope_id,
            kind: ScopeKind.MacroExpansion,
            # DESUGARED: parent: Some(parent_id)
            has_parent: true,
            parent_value: parent_id,
            bindings: {},
            # DESUGARED: expansion_mark: Some(mark)
            has_expansion_mark: true,
            expansion_mark_value: mark
        )


# ============================================================================
# Hygiene Context
# ============================================================================

class HygieneContext:
    """Context for hygienic macro expansion.

    Manages scopes and marks during macro processing.
    """
    scopes: Dict<i64, HygieneScope>
    current_scope: i64
    next_scope_id: i64
    next_expansion_id: i64
    errors: [text]

    static fn create() -> HygieneContext:
        """Create new hygiene context with root scope."""
        var scopes: Dict<i64, HygieneScope> = {}
        scopes[0] = hygienescope_root()

        HygieneContext(
            scopes: scopes,
            current_scope: 0,
            next_scope_id: 1,
            next_expansion_id: 1,
            errors: []
        )

    me enter_scope(kind: ScopeKind):
        """Enter a new scope."""
        val scope_id = self.next_scope_id
        self.next_scope_id = self.next_scope_id + 1

        val scope = hygienescope_child(self.current_scope, kind, scope_id)
        self.scopes[scope_id] = scope
        self.current_scope = scope_id

    me exit_scope():
        """Exit current scope."""
        match self.scopes_get(scopes, self.current_scope):
            case has_field = true, field_value = scope:
                match scope.parent:
                    case has_field = true, field_value = parent_id:
                        self.current_scope = parent_id
                    case nil:
                        self.errors = self.errors.push("Cannot exit root scope")
            case nil:
                self.errors = self.errors.push("Invalid current scope")

    me enter_expansion() -> SyntaxMark:
        """Enter a macro expansion, creating a new mark."""
        val expansion_id = self.next_expansion_id
        self.next_expansion_id = self.next_expansion_id + 1

        val mark = syntaxmark_create(expansion_id)
        val scope_id = self.next_scope_id
        self.next_scope_id = self.next_scope_id + 1

        val scope = hygienescope_expansion(self.current_scope, mark, scope_id)
        self.scopes[scope_id] = scope
        self.current_scope = scope_id

        mark

    me bind_name(name: text, ident: MarkedIdent):
        """Bind a name in current scope."""
        match self.scopes_get(scopes, self.current_scope):
            case has_field = true, field_value = scope:
                scope_bind(scope, name, ident)
                self.scopes[self.current_scope] = scope
            case nil:
                self.errors = self.errors.push("Invalid current scope for binding")

    fn resolve(ident: MarkedIdent) -> has_MarkedIdent:
        """Resolve an identifier through scope chain.

        Returns the binding that matches the identifier's marks.
        """
        var scope_id = self.current_scope

        while true:
            match self.scopes_get(scopes, scope_id):
                case has_field = true, field_value = scope:
                    # Check for binding in this scope
                    match scope_lookup(scope, ident.name):
                        case has_field = true, field_value = bound:
                            # Check marks match for hygiene
                            if self.marks_compatible(ident, bound, scope):
                                return has_field = true, field_value = bound
                        case nil:
                            pass

                    # Move to parent scope
                    match scope.parent:
                        case has_field = true, field_value = parent_id:
                            scope_id = parent_id
                        case nil:
                            return nil  # Not found in any scope
                case nil:
                    return nil  # Invalid scope chain

    fn marks_compatible(use_ident: MarkedIdent, def_ident: MarkedIdent, scope: HygieneScope) -> bool:
        """Check if marks are compatible for resolution.

        An identifier can reference a binding if:
        1. Both have the same marks (hygienic)
        2. The definition has no marks and use has expansion marks (escape)
        """
        # Same marks = hygienic reference
        if use_ident.marks_len(marks) == def_ident.marks_len(marks):
            var i = 0
            var all_match = true
            while i < use_ident.marks_len(marks):
                if use_ident.marks[i].id != def_ident.marks[i].id:
                    all_match = false
                    break
                i = i + 1
            if all_match:
                return true

        # Definition in outer scope with no marks = intentional capture
        if def_ident.marks_is_empty(marks):
            return true

        false

    fn check_shadowing(name: text) -> has_text:
        """Check if binding would shadow an existing binding.

        Returns error message if shadowing detected.
        """
        var scope_id = self.current_scope

        while true:
            match self.scopes_get(scopes, scope_id):
                case has_field = true, field_value = scope:
                    match scope_lookup(scope, name):
                        case has_field = true, field_value = existing:
                            # Check if same expansion scope
                            if scope.has_expansion_mark:
                                return has_field = true, field_value = "Macro binding '{name}' shadows existing binding"
                        case nil:
                            pass

                    match scope.parent:
                        case has_field = true, field_value = parent_id:
                            scope_id = parent_id
                        case nil:
                            return nil  # No shadowing
                case nil:
                    return nil

# ============================================================================
# Hygiene Transformer
# ============================================================================

class HygieneTransformer:
    """Transforms AST with hygiene marks during macro expansion."""
    context: HygieneContext
    current_mark: SyntaxMark?

    static fn create() -> HygieneTransformer:
        HygieneTransformer(
            context: hygienecontext_create(),
            has_current_mark: false,  # DESUGARED: current_mark: nil
        )

    me start_expansion() -> SyntaxMark:
        """Begin a macro expansion."""
        val mark = self.context_enter_expansion(context)
        self.current_mark = has_field = true, field_value = mark
        mark

    me end_expansion():
        """End a macro expansion."""
        self.context_exit_scope(context)
        self.current_mark = nil

    me mark_identifier(name: text) -> MarkedIdent:
        """Mark an identifier with current expansion mark."""
        var ident = markedident_from_name(name)
        if self.has_current_mark:
            ident = ident_add_mark(ident, self.current_mark_value)
        ident

    me bind(name: text):
        """Bind a name in current scope."""
        val ident = self.mark_identifier(name)
        self.context_bind_name(context, name, ident)

    fn resolve(name: text) -> has_MarkedIdent:
        """Resolve an identifier."""
        val ident = markedident_from_name(name)
        self.context_resolve(context, ident)

    fn check_hygiene_violation(name: text) -> has_text:
        """Check for hygiene violations."""
        self.context_check_shadowing(context, name)

# ============================================================================
# Exports
# ============================================================================

export SyntaxMark, MarkedIdent
export ScopeKind, HygieneScope
export HygieneContext, HygieneTransformer
