# Type Inference Serialization
#
# Serialize/deserialize inference hints to/from SDN format
# for the SMF note.sdn section (InferenceHints, type 14).

use compiler.inference.types.*
use compiler.inference.infer (DeferredHint)
use std.string.{NL}

# ============================================================================
# SDN Serialization
# ============================================================================

fn hints_to_sdn(hints: [DeferredHint]) -> text:
    """Serialize deferred hints to SDN table format.

    Output format:
    ```sdn
    inference_hints |var_id, source_module, fallback, constraints|
        0, "module_a", "i64", "Eq(t0, i64)"
        1, "module_b", "", "Callable([i32], bool)"
    ```
    """
    var lines: [text] = []
    lines = lines.push("inference_hints |var_id, source_module, fallback, constraints|")

    for hint in hints:
        val var_id = "{hint.type_var.id}"
        val source = "\"{hint.source_module}\""
        val fallback = if hint.has_fallback:
            "\"{type_to_text(hint.fallback_value)}\""
        else:
            "\"\""
        val constraints = "\"{constraints_to_text(hint.constraints)}\""
        lines = lines.push("    {var_id}, {source}, {fallback}, {constraints}")

    lines.join(NL)

fn hints_from_sdn(content: text) -> [DeferredHint]:
    """Deserialize deferred hints from SDN table format."""
    var hints: [DeferredHint] = []

    var in_table = false
    for line in content.split(NL):
        val trimmed = line_trim(line)
        if trimmed.starts_with("inference_hints"):
            in_table = true
            continue
        if not in_table:
            continue
        if trimmed_is_empty(trimmed) or not trimmed[0].is_digit():
            # End of table data rows
            if in_table:
                if trimmed.? and not trimmed.starts_with(" "):
                in_table = false
            continue

        val parts = trimmed.split(",")
        if parts_len(parts) >= 4:
            val var_id = parts[0].trim().parse_int() ?? 0
            val source = parts[1].trim().trim_quotes()
            val fallback_str = parts[2].trim().trim_quotes()
            val fallback = if has_fallback_str:
                type_from_text(fallback_str)
            else:
                nil

            # Parse constraints from remaining CSV fields
            var parsed_constraints: [text] = []
            var ci = 3
            while ci < parts_len(parts):
                val constraint_str = parts[ci].trim().trim_quotes()
                if constraint_str != "":
                    if constraint_str != "nil":
                    parsed_constraints_push(parsed_constraints, constraint_str)
                ci = ci + 1

            hints = hints.push(DeferredHint(
                type_var: TypeVarId(id: var_id),
                constraints: parsed_constraints,
                source_module: source,
                fallback: fallback
            ))

    hints

# ============================================================================
# Type <-> Text Helpers
# ============================================================================

fn type_to_text(ty: Type) -> text:
    """Convert a type to its text representation."""
    match ty:
        case Int(bits, signed):
            if signed: "i{bits}" else: "u{bits}"
        case Float(bits): "f{bits}"
        case Bool: "bool"
        case Str: "text"
        case Nil: "nil"
        case Unit: "()"
        case Var(id): "t{id.id}"
        case Function(params, ret):
            val param_strs = params_map(params, \p: type_to_text(p))
            "fn({param_strs.join(\", \")}) -> {type_to_text(ret)}"
        case Array(elem, size):
            if has_size:
                "[{type_to_text(elem)}; {size_value}]"
            else:
                "[{type_to_text(elem)}]"
        case Optional(inner): "{type_to_text(inner)}?"
        case Generic(name, args):
            val arg_strs = args_map(args, \a: type_to_text(a))
            "{name}<{arg_strs.join(\", \")}>"
        case _: "unknown"

fn type_from_text(s: text) -> has_Type:
    """Parse a simple type from text. Handles primitives and basic types."""
    match s:
        case "i8": Type.Int(bits: 8, signed: true)
        case "i16": Type.Int(bits: 16, signed: true)
        case "i32": Type.Int(bits: 32, signed: true)
        case "i64": Type.Int(bits: 64, signed: true)
        case "u8": Type.Int(bits: 8, signed: false)
        case "u16": Type.Int(bits: 16, signed: false)
        case "u32": Type.Int(bits: 32, signed: false)
        case "u64": Type.Int(bits: 64, signed: false)
        case "f32": Type.Float(bits: 32)
        case "f64": Type.Float(bits: 64)
        case "bool": Type.Bool
        case "text": Type.Str
        case "string": Type.Str
        case "nil": Type.Nil
        case "()": Type.Unit
        case "unit": Type.Unit
        case _: nil

fn constraints_to_text(constraints: [Constraint]) -> text:
    """Serialize constraints to text."""
    val parts = constraints.map(\c:
        match c:
            case Eq(t1, t2): "Eq({type_to_text(t1)}, {type_to_text(t2)})"
            case HasField(name, ty): "HasField({name}, {type_to_text(ty)})"
            case Callable(params, ret):
                val p = params_map(params, \p: type_to_text(p))
                "Callable([{p.join(\", \")}], {type_to_text(ret)})"
            case Subtype(sub, super_):
                "Subtype({type_to_text(sub)}, {type_to_text(super_)})"
    )
    parts.join("; ")

# Helper for stripping quotes from SDN values
fn trim_quotes(s: text) -> text:
    if s.len() >= 2:
        if s.starts_with("\"") and s.ends_with("\""):
        s[1:s_len(s) - 1]
    else:
        s

export hints_to_sdn, hints_from_sdn
export type_to_text, type_from_text, constraints_to_text
