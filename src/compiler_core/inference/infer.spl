# Shared Inference Engine
#
# Used by compiler (compile-time), loader (load-time), and linker (link-time).
# Each context creates an InferenceEngine with its own environment,
# but the core algorithm is identical.

use compiler.inference.types.*
use compiler.inference.unify (Unifier)

# ============================================================================
# Deferred Hint (for link-time resolution)
# ============================================================================

struct DeferredHint:
    """A hint about a deferred type for cross-module resolution.

    Written to SMF note.sdn section (InferenceHints, type 14).
    """
    type_var: TypeVarId
    constraints: [Constraint]
    source_module: text
    # DESUGARED: fallback: Type?
    has_fallback: bool
    fallback_value: Type

# ============================================================================
# InferenceEngine
# ============================================================================

class InferenceEngine:
    """Shared type inference engine.

    The same engine is used by:
    - Compiler: infers types at compile-time, emits DeferredHints for generics
    - Loader: resolves DeferredHints when loading modules at JIT time
    - Linker: resolves cross-module DeferredHints at link time
    """
    unifier: Unifier
    env: TypeEnv
    deferred: [DeferredHint]
    errors: [InferError]


# ============================================================================
# InferenceEngine Methods (was: impl InferenceEngine:)
# ============================================================================

fn inferenceengine_create() -> InferenceEngine:
        InferenceEngine(
            unifier: unifier_empty(),
            env: typeenv_empty(),
            deferred: [],
            errors: []
        )


fn inferenceengine_fresh_var(self: InferenceEngine) -> Type:
        """Create a fresh type variable."""
        self.unifier_fresh_var(unifier)


fn inferenceengine_instantiate(self: InferenceEngine, scheme: TypeScheme) -> Type:
        """Instantiate a polymorphic scheme with fresh variables."""
        if scheme_is_mono(scheme):
            return scheme.ty

        var subst: Dict<i64, Type> = {}
        for var_id in scheme.vars:
            subst[var_id.id] = self.unifier_fresh_var(unifier)

        self.substitute_type(scheme.ty, subst)


fn inferenceengine_generalize(self: InferenceEngine, ty: Type) -> TypeScheme:
        """Generalize a type into a polymorphic scheme.

        Collects all free type variables not bound in the environment.
        """
        val resolved = self.resolve(ty)
        val free_vars = self.free_vars(resolved)
        if free_vars_is_empty(free_vars):
            typescheme_mono(resolved)
        else:
            typescheme_poly(free_vars, resolved)


fn inferenceengine_try_unify(self: InferenceEngine, t1: Type, t2: Type) -> bool:
        """Try to unify, recording error on failure but continuing.
        Returns true if unification succeeded."""
        val result = self.unifier_unify(unifier, t1, t2)
        match result:
            case Ok(_): true
            case Err(e):
                self.errors = self.errors_push(errors, InferError.UnifyError(e))
                false


export InferenceEngine, DeferredHint
