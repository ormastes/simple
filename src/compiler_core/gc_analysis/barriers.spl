# Write Barrier Analysis
#
# Analyzes write barriers for incremental/generational GC.
# Write barriers are needed when storing a reference into an object
# to maintain GC invariants.
#
# Types of write barriers:
# - Pre-write (Dijkstra): Record old value before overwrite
# - Post-write (Steele): Record new value after write
# - Card marking: Mark memory regions as dirty
#
# This ensures:
# 1. No pointers from old to young generation are lost
# 2. Incremental GC maintains tri-color invariant
# 3. All writes to reference fields are tracked

# ============================================================================
# Barrier Kind
# ============================================================================

enum BarrierKind:
    """Kind of write barrier."""
    # Pre-write barrier (snapshot-at-beginning)
    PreWrite
    # Post-write barrier (incremental update)
    PostWrite
    # Card marking barrier
    CardMark
    # Generational barrier (old->young)
    Generational
    # No barrier needed
    None_


# ============================================================================
# BarrierKind Methods (was: impl BarrierKind:)
# ============================================================================

# ============================================================================
# Write Site
# ============================================================================

struct WriteSite:
    """A location where a reference write occurs."""
    program_point: i64
    target_type: i64       # Type being written to
    # DESUGARED: field_index: i64?
    has_field_index: bool
    field_index_value: i64
    is_array_element: bool # Is array element write
    source_type: i64       # Type of value being written
    required_barrier: BarrierKind


# ============================================================================
# WriteSite Methods (was: impl WriteSite:)
# ============================================================================

fn writesite_field_write(point: i64, target_type: i64, field_idx: i64, source_type: i64) -> WriteSite:
        WriteSite(
            program_point: point,
            target_type: target_type,
            # DESUGARED: field_index: Some(field_idx)
            has_field_index: true,
            field_index_value: field_idx,
            is_array_element: false,
            source_type: source_type,
            required_barrier: BarrierKind.None_  # Determined by analysis
        )


fn writesite_array_write(point: i64, target_type: i64, source_type: i64) -> WriteSite:
        WriteSite(
            program_point: point,
            target_type: target_type,
            has_field_index: false,  # DESUGARED: field_index: nil
            is_array_element: true,
            source_type: source_type,
            required_barrier: BarrierKind.None_
        )


# ============================================================================
# Barrier Requirement
# ============================================================================

struct BarrierRequirement:
    """A required write barrier at a location."""
    write_site: WriteSite
    barrier_kind: BarrierKind
    reason: text


# ============================================================================
# BarrierRequirement Methods (was: impl BarrierRequirement:)
# ============================================================================

fn barrierrequirement_create(site: WriteSite, kind: BarrierKind, reason: text) -> BarrierRequirement:
        BarrierRequirement(
            write_site: site,
            barrier_kind: kind,
            reason: reason
        )


# ============================================================================
# Barrier Error
# ============================================================================

struct BarrierError:
    """Error in barrier analysis."""
    message: text
    write_site: WriteSite
    missing_barrier: BarrierKind


# ============================================================================
# BarrierError Methods (was: impl BarrierError:)
# ============================================================================

fn barriererror_missing(site: WriteSite, kind: BarrierKind) -> BarrierError:
        BarrierError(
            message: "Missing {kind.to_text()} barrier at write site",
            write_site: site,
            missing_barrier: kind
        )


# ============================================================================
# Barrier Analysis
# ============================================================================

enum GcMode:
    """GC mode determines barrier requirements."""
    StopTheWorld      # No barriers needed
    Incremental       # Pre-write or post-write barriers
    Generational      # Generational barriers for old->young
    Concurrent        # All barriers needed

class BarrierAnalysis:
    """Analyzes write barrier requirements.

    Determines which writes need barriers and what kind.
    """
    gc_mode: GcMode
    write_sites: [WriteSite]
    requirements: [BarrierRequirement]
    errors: [BarrierError]
    is_gc_type: fn(i64) -> bool
    is_young_gen: fn(i64) -> bool?  # For generational GC

    static fn create(gc_mode: GcMode, is_gc_type: fn(i64) -> bool) -> BarrierAnalysis:
        BarrierAnalysis(
            gc_mode: gc_mode,
            write_sites: [],
            requirements: [],
            errors: [],
            is_gc_type: is_gc_type,
            has_is_young_gen: false,  # DESUGARED: is_young_gen: nil
        )

    me record_write(site: WriteSite):
        """Record a write site."""
        self.write_sites = self.write_sites_push(write_sites, site)

    me analyze() -> bool:
        """Analyze all write sites for barrier requirements."""
        for site in self.write_sites:
            self.analyze_write(site)

        self.errors_is_empty(errors)

    me analyze_write(site: WriteSite):
        """Analyze a single write site."""
        # Check if target or source are GC types
        val target_is_gc = (self.is_gc_type)(site.target_type)
        val source_is_gc = (self.is_gc_type)(site.source_type)

        # Non-GC types don't need barriers
        if not target_is_gc and not source_is_gc:
            return

        # Determine required barrier based on GC mode
        val required = match self.gc_mode:
            case StopTheWorld:
                BarrierKind.None_

            case Incremental:
                if source_is_gc:
                    BarrierKind.PostWrite  # Track new reference
                else:
                    BarrierKind.None_

            case Generational:
                if target_is_gc and source_is_gc:
                    BarrierKind.Generational  # May be old->young
                else:
                    BarrierKind.None_

            case Concurrent:
                if source_is_gc:
                    BarrierKind.PreWrite  # Snapshot-at-beginning
                else:
                    BarrierKind.None_

        # Record requirement
        if required != BarrierKind.None_:
            val reason = match required:
                case PostWrite: "Incremental GC requires tracking new references"
                case PreWrite: "Concurrent GC requires snapshot-at-beginning"
                case Generational: "May create old-to-young pointer"
                case CardMark: "Card marking for dirty region tracking"
                case _: "Write barrier required"

            self.requirements = self.requirements.push(
                barrierrequirement_create(site, required, reason)
            )

    me verify_barriers(emitted_barriers: Dict<i64, BarrierKind>) -> bool:
        """Verify that required barriers are emitted."""
        for req in self.requirements:
            val point = req.write_site.program_point
            match emitted_barriers_get(emitted_barriers, point):
                case nil:
                    self.errors = self.errors.push(BarrierError.missing(
                        req.write_site,
                        req.barrier_kind
                    ))
                case has_field = true, field_value = emitted:
                    if emitted != req.barrier_kind:
                        self.errors = self.errors.push(BarrierError(
                            message: "Wrong barrier kind: expected {req.barrier_kind.to_text()}, got {emitted.to_text()}",
                            write_site: req.write_site,
                            missing_barrier: req.barrier_kind
                        ))

        self.errors_is_empty(errors)

    fn get_requirements() -> [BarrierRequirement]:
        """Get all barrier requirements."""
        self.requirements

    fn get_errors() -> [BarrierError]:
        """Get analysis errors."""
        self.errors

    fn needs_barrier(point: i64) -> BarrierKind:
        """Check if a program point needs a barrier."""
        for req in self.requirements:
            if req.write_site.program_point == point:
                return req.barrier_kind
        BarrierKind.None_

# ============================================================================
# Exports
# ============================================================================

export BarrierKind, WriteSite, BarrierRequirement
export BarrierError, GcMode, BarrierAnalysis
