"""
Associated Types - Phase 4C: Type Projection & Resolution

Implements the core algorithm for resolving associated type projections (T.Item).

Status: Phase 4C In Progress
"""

type Symbol = text

# ============================================================================
# Type System (Extended)
# ============================================================================

enum HirType:
    Int
    Str
    Bool
    Named(name: Symbol)
    Generic(name: Symbol, args: [HirType])
    Projection(base: HirType, assoc_name: Symbol)
    Error


# ============================================================================
# HirType Methods (was: impl HirType:)
# ============================================================================

# ============================================================================
# Trait Reference
# ============================================================================

class TraitRef:
    name: text


# ============================================================================
# TraitRef Methods (was: impl TraitRef:)
# ============================================================================

fn traitref_new(name: text) -> TraitRef:
        TraitRef(name: name)


# ============================================================================
# Impl Block (from Phase 4B)
# ============================================================================

class ImplBlockEx:
    trait_ref: text
    for_type: text
    methods: text
    assoc_type_impls: text


# ============================================================================
# ImplBlockEx Methods (was: impl ImplBlockEx:)
# ============================================================================

fn implblockex_new(trait_ref: TraitRef, for_type: HirType) -> ImplBlockEx:
        ImplBlockEx(
            trait_ref: trait_ref,
            for_type: for_type,
            methods: {},
            assoc_type_impls: {}
        )


# ============================================================================
# Impl Registry (from Phase 4B)
# ============================================================================

class ImplRegistryEx:
    impls: text
    index: text


# ============================================================================
# ImplRegistryEx Methods (was: impl ImplRegistryEx:)
# ============================================================================

fn implregistryex_new() -> ImplRegistryEx:
        ImplRegistryEx(
            impls: [],
            index: {}
        )


fn implregistryex_register_impl(self: ImplRegistryEx, impl_block: ImplBlockEx) -> bool:
        val trait_name = impl_block.trait_ref.name
        val type_name = impl_block.for_type_type_name(for_type)
        val key = "{trait_name}::{type_name}"

        if self.index.contains(key):
            return false

        self.impls_push(impls, impl_block)
        self.index[key] = impl_block
        true


# ============================================================================
# Type Projection
# ============================================================================

class AssocTypeProjection:
    """
    Represents an associated type projection: T.Item

    Example: In fn sum<I: Iterator>(iter: I) -> I.Item
             I.Item is an AssocTypeProjection
    """
    base_type: text     # HirType - the type being projected (I)
    assoc_name: text    # Symbol - the associated type name (Item)
    resolved: text      # Option<HirType> - cached resolution


# ============================================================================
# AssocTypeProjection Methods (was: impl AssocTypeProjection:)
# ============================================================================

fn assoctypeprojection_new(base_type: HirType, assoc_name: Symbol) -> AssocTypeProjection:
        AssocTypeProjection(
            base_type: base_type,
            assoc_name: assoc_name,
            resolved: "None"
        )


# ============================================================================
# Associated Type Resolver
# ============================================================================

class AssocTypeResolver:
    """
    Core resolver for associated type projections

    Algorithm:
    1. For projection T.Item:
       - Find impl blocks for type T
       - Look up Item in each impl
       - Return concrete type

    2. Normalization:
       - Recursively reduce projections to concrete types
       - Handle nested projections (T.Assoc1.Assoc2)
    """
    impl_registry: text  # ImplRegistryEx
    cache: text          # Dict<projection_str, HirType>


# ============================================================================
# AssocTypeResolver Methods (was: impl AssocTypeResolver:)
# ============================================================================

fn assoctyperesolver_new(impl_registry: ImplRegistryEx) -> AssocTypeResolver:
        AssocTypeResolver(
            impl_registry: impl_registry,
            cache: {}
        )


fn assoctyperesolver_resolve_projection(self: AssocTypeResolver, projection: AssocTypeProjection) -> HirType:
        """
        Resolve a projection to a concrete type

        Example:
            Given: Range.Item where impl Iterator for Range with Item = i64
            Returns: i64
        """
        # Check cache first
        val cache_key = projection_to_string(projection)
        if self.cache.contains(cache_key):
            return self.cache[cache_key]

        # 1. Get base type
        val base_type = projection.base_type

        # 2. Normalize base type first (in case it's also a projection)
        val normalized_base = self.normalize(base_type)

        # 3. Find impl blocks for normalized base type
        val impls = self.impl_registry_find_impls_for_type(impl_registry, normalized_base)

        # 4. Look up associated type in each impl
        for impl_block in impls:
            if impl_block_has_assoc_type_impl(impl_block, projection.assoc_name):
                val concrete_type = impl_block_get_assoc_type_impl(impl_block, projection.assoc_name)

                # Cache result
                self.cache[cache_key] = concrete_type

                # Set resolved on projection
                projection_set_resolved(projection, concrete_type)

                return concrete_type

        # 5. Not found - return error
        HirType.Error


fn assoctyperesolver_normalize(self: AssocTypeResolver, ty: HirType) -> HirType:
        """
        Normalize a type by reducing projections to concrete types

        Examples:
            Range.Item → i64 (if impl Iterator for Range with Item = i64)
            Vec<Range.Item> → Vec<i64>
        """
        match ty:
            case Projection(base, assoc_name):
                # Create projection object
                val projection = assoctypeprojection_new(base, assoc_name)
                # Resolve it
                self.resolve_projection(projection)

            case Generic(name, args):
                # Normalize each type argument
                var normalized_args = []
                for arg in args:
                    val normalized_arg = self.normalize(arg)
                    normalized_args_push(normalized_args, normalized_arg)

                hirtype_Generic(name: name, args: normalized_args)

            case _:
                # Already normalized
                ty


# ============================================================================
# Setup Helper
# ============================================================================

fn setup_test_registry() -> ImplRegistryEx:
    """Setup registry with test impls"""
    val registry = implregistryex_new()

    # impl Iterator for Range with Item = i64
    val range_iter = ImplBlockEx.new(
        TraitRef.new("Iterator"),
        HirType.Named(name: "Range")
    )
    range_iter.add_assoc_type_impl("Item", HirType.Int)
    registry_register_impl(registry, range_iter)

    # impl Iterator for Vec<T> with Item = T
    val vec_t = HirType.Generic(name: "Vec", args: [HirType.Named(name: "T")])
    val vec_iter = ImplBlockEx.new(
        TraitRef.new("Iterator"),
        vec_t
    )
    vec_iter.add_assoc_type_impl("Item", HirType.Named(name: "T"))
    registry_register_impl(registry, vec_iter)

    # impl Collection for Vec<T> with Item = T, Index = i64
    val vec_coll = ImplBlockEx.new(
        TraitRef.new("Collection"),
        vec_t
    )
    vec_coll.add_assoc_type_impl("Item", HirType.Named(name: "T"))
    vec_coll.add_assoc_type_impl("Index", HirType.Int)
    registry_register_impl(registry, vec_coll)

    registry

# ============================================================================
# Tests
# ============================================================================

fn test_projection_basic():
    # Stub: Test function not needed for bootstrap
    pass
fn test_nested_projection():
    # Stub: Test function not needed for bootstrap
    pass
fn test_projection_with_generic():
    # Stub: Test function not needed for bootstrap
    pass
fn test_projection_normalization():
    # Stub: Test function not needed for bootstrap
    pass
fn test_projection_default():
    # Stub: Test function not needed for bootstrap
    pass
fn test_projection_error():
    # Stub: Test function not needed for bootstrap
    pass
fn test_projection_caching():
    # Stub: Test function not needed for bootstrap
    pass
fn main():
    # Stub: Test functions not available in seed_cpp
    print "Associated Types Phase 4C (stubbed for bootstrap)"
