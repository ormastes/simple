# Type Substitution
#
# Performs type parameter substitution during monomorphization.
# Takes a mapping from type parameter names to HirTypes and recursively
# rewrites types throughout the HIR tree.
#
# Example:
#   fn identity<T>(x: T) -> T
#   With substitution {T -> Int}
#   Becomes: fn identity$Int(x: Int) -> Int

export TypeSubstitution, substitute_type, substitute_expr, substitute_function

use hir_types.*
use hir_definitions.*
use monomorphize.engine.ConcreteType
use lexer.Span

# ============================================================================
# Type Substitution Map
# ============================================================================

class TypeSubstitution:
    """Maps type parameter names to concrete HirTypes."""
    mapping: Dict<text, HirType>


# ============================================================================
# TypeSubstitution Methods (was: impl TypeSubstitution:)
# ============================================================================

fn typesubstitution_empty() -> TypeSubstitution:
        TypeSubstitution(mapping: {})


fn typesubstitution_from_params(type_params: [HirTypeParam], type_args: [HirType]) -> TypeSubstitution:
        """Create substitution from type parameters and their concrete arguments."""
        var map: Dict<text, HirType> = {}
        var i = 0
        for param in type_params:
            if i < type_args_len(type_args):
                map[param.name] = type_args[i]
            i = i + 1
        TypeSubstitution(mapping: map)


fn typesubstitution_from_concrete(type_params: [HirTypeParam], type_args: [ConcreteType]) -> TypeSubstitution:
        """Create substitution from type parameters and ConcreteType arguments."""
        var map: Dict<text, HirType> = {}
        var i = 0
        for param in type_params:
            if i < type_args_len(type_args):
                map[param.name] = concrete_to_hir_type(type_args[i], param.span)
            i = i + 1
        TypeSubstitution(mapping: map)


# ============================================================================
# Convert ConcreteType to HirType
# ============================================================================

fn concrete_to_hir_type(ct: ConcreteType, span: Span) -> HirType:
    """Convert a ConcreteType to HirType."""
    val kind = match ct:
        case Int: hirtypekind_Int(64, true)
        case Float: hirtypekind_Float(64)
        case Bool: HirTypeKind.Bool
        case String: HirTypeKind.Str
        case Nil: HirTypeKind.Unit
        case Named(name):
            hirtypekind_Named(SymbolId(id: -1), [])  # Placeholder symbol
        case Array(elem):
            hirtypekind_Array(concrete_to_hir_type(elem, span), nil)
        case Tuple(elems):
            hirtypekind_Tuple(elems.map(\e: concrete_to_hir_type(e, span)))
        case Dict(k, v):
            hirtypekind_Dict(concrete_to_hir_type(k, span), concrete_to_hir_type(v, span))
        case Function(params, ret):
            val p_types = params_map(params, \p: concrete_to_hir_type(p, span))
            hirtypekind_Function(p_types, concrete_to_hir_type(ret, span), [])
        case Optional(inner):
            hirtypekind_Optional(concrete_to_hir_type(inner, span))
        case Specialized(name, args):
            val hir_args = args_map(args, \a: concrete_to_hir_type(a, span))
            hirtypekind_Named(SymbolId(id: -1), hir_args)
    HirType(kind: kind, span: span)

# ============================================================================
# Type Substitution
# ============================================================================

fn substitute_type(ty: HirType, subst: TypeSubstitution) -> HirType:
    """Recursively substitute type parameters in a type."""
    val new_kind = match ty.kind:
        # Type parameter - look up in substitution
        case TypeParam(name, bounds):
            val replacement = subst_get(subst, name)
            if has_replacement:
                return replacement_value
            else:
                ty.kind  # Keep as-is if not in substitution

        # Primitives - no change
        case Int(_, _): ty.kind
        case Float(_): ty.kind
        case Bool: ty.kind
        case Char: ty.kind
        case Str: ty.kind
        case Unit: ty.kind
        case Never: ty.kind
        case Error: ty.kind

        # Composite types - recurse into components
        case Tuple(elements):
            hirtypekind_Tuple(elements.map(\e: substitute_type(e, subst)))

        case Array(element, size):
            hirtypekind_Array(substitute_type(element, subst), size)

        case Slice(element):
            hirtypekind_Slice(substitute_type(element, subst))

        case Dict(key, value):
            hirtypekind_Dict(substitute_type(key, subst), substitute_type(value, subst))

        # Reference types
        case Ref(inner, mutable):
            hirtypekind_Ref(substitute_type(inner, subst), mutable)

        case Ptr(inner, mutable):
            hirtypekind_Ptr(substitute_type(inner, subst), mutable)

        case Optional(inner):
            hirtypekind_Optional(substitute_type(inner, subst))

        case Result(ok, err):
            hirtypekind_Result(substitute_type(ok, subst), substitute_type(err, subst))

        # Named types - substitute type arguments
        case Named(symbol, args):
            val new_args = args_map(args, \a: substitute_type(a, subst))
            hirtypekind_Named(symbol, new_args)

        # Function types
        case Function(params, ret, effects):
            val new_params = params_map(params, \p: substitute_type(p, subst))
            val new_ret = substitute_type(ret, subst)
            hirtypekind_Function(new_params, new_ret, effects)

        # Trait types
        case DynTrait(trait_):
            ty.kind  # Keep as-is

        # Inference variables (should be resolved before monomorphization)
        case Infer(_, _):
            ty.kind

        # Tensor types
        case Tensor(element, dims, device):
            hirtypekind_Tensor(substitute_type(element, subst), dims, device)

        case Layer(input, output):
            ty.kind  # Dimensions don't change

    HirType(kind: new_kind, span: ty.span)

# ============================================================================
# Expression Substitution
# ============================================================================

fn substitute_expr(expr: HirExpr, subst: TypeSubstitution) -> HirExpr:
    """Recursively substitute type parameters in an expression."""
    # First substitute the expression's type annotation if present
    # val new_type = if expr.# DESUGARED: has_type_: Some(substitute_type(expr.type__value)
            has_type_: substitute_type(expr.type__value, subst)
    else:
        nil

    val new_kind = match expr.kind:
        # Literals - substitute type annotations
        case IntLit(value, suffix): expr.kind
        case FloatLit(value, suffix): expr.kind
        case StringLit(value, interps): expr.kind
        case BoolLit(value): expr.kind
        case CharLit(value): expr.kind
        case UnitLit: expr.kind
        case NilLit: expr.kind

        # Collections
        case ArrayLit(elements, ty):
            val new_elems = elements_map(elements, \e: substitute_expr(e, subst))
            # # val new_ty = if # DESUGARED: has_ty: Some(substitute_type(ty_value)
            # # has_ty_value: substitute_type(ty_value, subst)  # DESUGARED: else: nil
            hirexprkind_ArrayLit(new_elems, new_ty)

        case TupleLit(elements):
            hirexprkind_TupleLit(elements.map(\e: substitute_expr(e, subst)))

        case DictLit(entries, key_ty, val_ty):
            val new_entries = entries_map(entries, \kv: (substitute_expr(kv[0], subst), substitute_expr(kv[1], subst)))
            # # val new_key_ty = if # DESUGARED: has_key_ty: Some(substitute_type(key_ty_value)
            # # has_key_ty_value: substitute_type(key_ty_value, subst)  # DESUGARED: else: nil
            # # val new_val_ty = if # DESUGARED: has_val_ty: Some(substitute_type(val_ty_value)
            # # has_val_ty_value: substitute_type(val_ty_value, subst)  # DESUGARED: else: nil
            hirexprkind_DictLit(new_entries, new_key_ty, new_val_ty)

        # Variables and access
        case Var(_): expr.kind

        case Field(base, field, resolved):
            hirexprkind_Field(substitute_expr(base, subst), field, resolved)

        case Index(base, index):
            hirexprkind_Index(substitute_expr(base, subst), substitute_expr(index, subst))

        case TupleIndex(base, index):
            hirexprkind_TupleIndex(substitute_expr(base, subst), index)

        # Optional operations
        case OptionalChain(base, field):
            hirexprkind_OptionalChain(substitute_expr(base, subst), field)

        case NullCoalesce(left, right):
            hirexprkind_NullCoalesce(substitute_expr(left, subst), substitute_expr(right, subst))

        case ExistsCheck(base):
            hirexprkind_ExistsCheck(substitute_expr(base, subst))

        case Unwrap(base):
            hirexprkind_Unwrap(substitute_expr(base, subst))

        # Operators
        case Binary(op, left, right):
            hirexprkind_Binary(op, substitute_expr(left, subst), substitute_expr(right, subst))

        case Unary(op, operand):
            hirexprkind_Unary(op, substitute_expr(operand, subst))

        # Calls - substitute type arguments
        case Call(callee, args, type_args):
            val new_callee = substitute_expr(callee, subst)
            val new_args = args_map(args, \a: substitute_call_arg(a, subst))
            val new_type_args = type_args_map(type_args, \t: substitute_type(t, subst))
            hirexprkind_Call(new_callee, new_args, new_type_args)

        case MethodCall(receiver, method, args, resolution):
            val new_recv = substitute_expr(receiver, subst)
            val new_args = args_map(args, \a: substitute_call_arg(a, subst))
            hirexprkind_MethodCall(new_recv, method, new_args, resolution)

        case StaticCall(ty, method, args, resolution):
            val new_ty = substitute_type(ty, subst)
            val new_args = args_map(args, \a: substitute_call_arg(a, subst))
            hirexprkind_StaticCall(new_ty, method, new_args, resolution)

        # Control flow
        case If(cond, then_, else_):
            val new_cond = substitute_expr(cond, subst)
            val new_then = substitute_block(then_, subst)
            # # val new_else = if # DESUGARED: has_else_: Some(substitute_block(else__value)
            # # has_else__value: substitute_block(else__value, subst)  # DESUGARED: else: nil
            hirexprkind_If(new_cond, new_then, new_else)

        case MatchCase(scrutinee, arms):
            val new_scrut = substitute_expr(scrutinee, subst)
            val new_arms = arms_map(arms, \a: substitute_match_arm(a, subst))
            hirexprkind_MatchCase(new_scrut, new_arms)

        case Loop(body, label):
            hirexprkind_Loop(substitute_block(body, subst), label)

        case While(cond, body, label):
            hirexprkind_While(substitute_expr(cond, subst), substitute_block(body, subst), label)

        case For(var_, iter, body, label):
            hirexprkind_For(var_, substitute_expr(iter, subst), substitute_block(body, subst), label)

        # Closures
        case Lambda(params, body, captures):
            val new_params = params_map(params, \p: substitute_param(p, subst))
            val new_body = substitute_expr(body, subst)
            hirexprkind_Lambda(new_params, new_body, captures)

        case Block(block):
            hirexprkind_Block(substitute_block(block, subst))

        # Control transfer
        case Return(value):
            # # val new_val = if # DESUGARED: has_value: Some(substitute_expr(value_value)
            # # has_value_value: substitute_expr(value_value, subst)  # DESUGARED: else: nil
            hirexprkind_Return(new_val)

        case Break(label, value):
            # # val new_val = if # DESUGARED: has_value: Some(substitute_expr(value_value)
            # # has_value_value: substitute_expr(value_value, subst)  # DESUGARED: else: nil
            hirexprkind_Break(label, new_val)

        case Continue(label): expr.kind

        case Throw(value):
            hirexprkind_Throw(substitute_expr(value, subst))

        case Try(e):
            hirexprkind_Try(substitute_expr(e, subst))

        # Async
        case Await(e):
            hirexprkind_Await(substitute_expr(e, subst))

        case Yield(value):
            # # val new_val = if # DESUGARED: has_value: Some(substitute_expr(value_value)
            # # has_value_value: substitute_expr(value_value, subst)  # DESUGARED: else: nil
            hirexprkind_Yield(new_val)

        # Construction
        case StructLit(ty, fields):
            val new_ty = substitute_type(ty, subst)
            val new_fields = fields_map(fields, \f: (f[0], substitute_expr(f[1], subst)))
            hirexprkind_StructLit(new_ty, new_fields)

        case EnumLit(ty, variant, payload):
            val new_ty = substitute_type(ty, subst)
            # # val new_payload = if # DESUGARED: has_payload: Some(substitute_enum_payload(payload_value)
            # # has_payload_value: substitute_enum_payload(payload_value, subst)  # DESUGARED: else: nil
            hirexprkind_EnumLit(new_ty, variant, new_payload)

        # Casts
        case Cast(e, target):
            hirexprkind_Cast(substitute_expr(e, subst), substitute_type(target, subst))

        case As(e, target):
            hirexprkind_As(substitute_expr(e, subst), substitute_type(target, subst))

        # Range
        case Range(start, end, inclusive, step):
            # # val new_start = if # DESUGARED: has_start: Some(substitute_expr(start_value)
            # # has_start_value: substitute_expr(start_value, subst)  # DESUGARED: else: nil
            # # val new_end = if # DESUGARED: has_end: Some(substitute_expr(end_value)
            # # has_end_value: substitute_expr(end_value, subst)  # DESUGARED: else: nil
            # # val new_step = if # DESUGARED: has_step: Some(substitute_expr(step_value)
            # # has_step_value: substitute_expr(step_value, subst)  # DESUGARED: else: nil
            hirexprkind_Range(new_start, new_end, inclusive, new_step)

        # Comprehension
        case Comprehension(kind, e, clauses):
            val new_e = substitute_expr(e, subst)
            val new_clauses = clauses_map(clauses, \c: substitute_comp_clause(c, subst))
            hirexprkind_Comprehension(kind, new_e, new_clauses)

        # Custom blocks
        case CustomBlock(_, _): expr.kind
        case LossBlock(body):
            hirexprkind_LossBlock(substitute_block(body, subst))
        case NogradBlock(body):
            hirexprkind_NogradBlock(substitute_block(body, subst))

        case Error: expr.kind

    HirExpr(kind: new_kind, type_: new_type, span: expr.span)

# ============================================================================
# Helper Substitution Functions
# ============================================================================

fn substitute_call_arg(arg: HirCallArg, subst: TypeSubstitution) -> HirCallArg:
    HirCallArg(name: arg.name, value: substitute_expr(arg.value, subst), span: arg.span)

fn substitute_match_arm(arm: HirMatchArm, subst: TypeSubstitution) -> HirMatchArm:
    val new_pattern = substitute_pattern(arm.pattern, subst)
    # val new_guard = if arm.# DESUGARED: has_guard: Some(substitute_expr(arm.guard_value)
            # # has_guard_value: substitute_expr(arm.guard_value, subst)  # DESUGARED: else: nil
    val new_body = substitute_block(arm.body, subst)
    HirMatchArm(pattern: new_pattern, guard: new_guard, body: new_body, span: arm.span)

fn substitute_pattern(pat: HirPattern, subst: TypeSubstitution) -> HirPattern:
    # val new_type = if pat.# DESUGARED: has_type_: Some(substitute_type(pat.type__value)
            # # has_type__value: substitute_type(pat.type__value, subst)  # DESUGARED: else: nil
    val new_kind = match pat.kind:
        case Wildcard: pat.kind
        case Literal(value): hirpatternkind_Literal(substitute_expr(value, subst))
        case Binding(_, _): pat.kind
        case Tuple(elements):
            hirpatternkind_Tuple(elements.map(\e: substitute_pattern(e, subst)))
        case Array(elements, rest):
            hirpatternkind_Array(elements.map(\e: substitute_pattern(e, subst)), rest)
        case Struct(ty, fields):
            val new_ty = substitute_type(ty, subst)
            val new_fields = fields_map(fields, \f: (f[0], substitute_pattern(f[1], subst)))
            hirpatternkind_Struct(new_ty, new_fields)
        case Enum(ty, variant, payload):
            val new_ty = substitute_type(ty, subst)
            # # val new_payload = if # DESUGARED: has_payload: Some(substitute_pattern_payload(payload_value)
            # # has_payload_value: substitute_pattern_payload(payload_value, subst)  # DESUGARED: else: nil
            hirpatternkind_Enum(new_ty, variant, new_payload)
        case Or(patterns):
            hirpatternkind_Or(patterns.map(\p: substitute_pattern(p, subst)))
        case Range(start, end, inclusive):
            # # val new_start = if # DESUGARED: has_start: Some(substitute_expr(start_value)
            # # has_start_value: substitute_expr(start_value, subst)  # DESUGARED: else: nil
            # # val new_end = if # DESUGARED: has_end: Some(substitute_expr(end_value)
            # # has_end_value: substitute_expr(end_value, subst)  # DESUGARED: else: nil
            hirpatternkind_Range(new_start, new_end, inclusive)
        case Error: pat.kind
    HirPattern(kind: new_kind, type_: new_type, span: pat.span)

fn substitute_pattern_payload(payload: HirPatternPayload, subst: TypeSubstitution) -> HirPatternPayload:
    match payload:
        case Tuple(patterns):
            hirpatternpayload_Tuple(patterns.map(\p: substitute_pattern(p, subst)))
        case Struct(fields):
            hirpatternpayload_Struct(fields.map(\f: (f[0], substitute_pattern(f[1], subst))))

fn substitute_enum_payload(payload: HirEnumPayload, subst: TypeSubstitution) -> HirEnumPayload:
    match payload:
        case Tuple(values):
            hirenumpayload_Tuple(values.map(\v: substitute_expr(v, subst)))
        case Struct(fields):
            hirenumpayload_Struct(fields.map(\f: (f[0], substitute_expr(f[1], subst))))

fn substitute_comp_clause(clause: HirCompClause, subst: TypeSubstitution) -> HirCompClause:
    val new_kind = match clause.kind:
        case For(var_, iter):
            hircompclausekind_For(var_, substitute_expr(iter, subst))
        case If(cond):
            hircompclausekind_If(substitute_expr(cond, subst))
    HirCompClause(kind: new_kind, span: clause.span)

fn substitute_block(block: HirBlock, subst: TypeSubstitution) -> HirBlock:
    val new_stmts = block.stmts_map(stmts, \s: substitute_stmt(s, subst))
    # val new_value = if block.# DESUGARED: has_value: Some(substitute_expr(block.value_value)
            # # has_value_value: substitute_expr(block.value_value, subst)  # DESUGARED: else: nil
    HirBlock(stmts: new_stmts, value: new_value, span: block.span)

fn substitute_stmt(stmt: HirStmt, subst: TypeSubstitution) -> HirStmt:
    val new_kind = match stmt.kind:
        case Expr(e):
            hirstmtkind_Expr(substitute_expr(e, subst))
        case Let(symbol, ty, init):
            # # val new_ty = if # DESUGARED: has_ty: Some(substitute_type(ty_value)
            # # has_ty_value: substitute_type(ty_value, subst)  # DESUGARED: else: nil
            hirstmtkind_Let(symbol, new_ty, substitute_expr(init, subst))
        case Assign(target, op, value):
            hirstmtkind_Assign(substitute_expr(target, subst), op, substitute_expr(value, subst))
        case Block(b):
            hirstmtkind_Block(substitute_block(b, subst))
    HirStmt(kind: new_kind, span: stmt.span)

fn substitute_param(param: HirParam, subst: TypeSubstitution) -> HirParam:
    val new_type = substitute_type(param.type_, subst)
    # val new_default = if param.# DESUGARED: has_default: Some(substitute_expr(param.default_value)
            # # has_default_value: substitute_expr(param.default_value, subst)  # DESUGARED: else: nil
    HirParam(symbol: param.symbol, name: param.name, type_: new_type, default: new_default, span: param.span)

# ============================================================================
# Function Substitution
# ============================================================================

fn substitute_function(func: HirFunction, subst: TypeSubstitution, mangled_name: text) -> HirFunction:
    """Create a specialized version of a function with type substitution applied."""
    # Substitute parameter types
    val new_params = func.params_map(params, \p: substitute_param(p, subst))

    # Substitute return type
    val new_return_type = substitute_type(func.return_type, subst)

    # Substitute body
    val new_body = substitute_block(func.body, subst)

    # Create specialized function (no type parameters after specialization)
    HirFunction(
        symbol: func.symbol,  # Keep original symbol for now
        name: mangled_name,
        type_params: [],  # Specialized - no type params
        params: new_params,
        return_type: new_return_type,
        body: new_body,
        effects: func.effects,
        is_async: func.is_async,
        is_static: func.is_static,
        is_public: func.is_public,
        is_method: func.is_method,
        is_mutable: func.is_mutable,
        doc_comment: func.doc_comment,
        span: func.span
    )
