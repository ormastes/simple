"""
# Monomorphization Module - Generic type instantiation

Instantiates generic functions and types with concrete type parameters.
Implements lazy monomorphization with caching, cycle detection, and
hot-reload support for development.

## Features

- Lazy instantiation: Only monomorphize what's actually used
- Caching: Reuse instantiations across compilation units
- Cycle detection: Detect infinite generic recursion
- Hot reload: Update monomorphized code without full recompilation
- Metadata tracking: Record instantiation relationships

## Quick Start

```simple
# Example 1: Monomorphize generic function
use compiler_core.monomorphize.{monomorphize_module}

val source = "fn identity<T>(x: T) -> T: x"
val result = monomorphize_module(source, types: ["i64", "text"])
print "Instantiated: {result.functions.len()} functions"
# Output: Instantiated: 2 functions
```

```simple
# Example 2: Create mono engine
use compiler_core.monomorphize.{MonoEngine}

val engine = MonoEngine()
val instance = engine.instantiate("Option<T>", type_args: ["i64"])
print "Created: {instance.name}"
# Output: Created: Option__i64
```

```simple
# Example 3: Check instantiation cache
use compiler_core.monomorphize.{MonoTable}

val table = MonoTable()
table.add("identity", ["i64"], func_body)
val exists = table.contains("identity", ["i64"])
# Output: exists = true
```

## Public API

- `use compiler_core.monomorphize.engine.{monomorphize_module, MonoEngine}`
- `use compiler_core.monomorphize.types.{MonoInstance, InstantiationKey}`
- `use compiler_core.monomorphize.table.{MonoTable}`

## Pipeline

1. Analysis: Identify generic usages (analyzer.spl)
2. Instantiation: Create concrete versions (engine.spl, rewriter.spl)
3. Specialization: Apply type-specific optimizations (binding_specializer.spl)
4. Caching: Store for reuse (cache.spl, table.spl)

@tag:compiler
@tag:generics
"""

# Monomorphization Module
#
# Instantiates generic functions and types with concrete type parameters.
# Implements lazy monomorphization with caching, cycle detection, and
# hot-reload support for development.
#
# Features:
#   - Lazy instantiation: Only monomorphize what's actually used
#   - Caching: Reuse instantiations across compilation units
#   - Cycle detection: Detect infinite generic recursion
#   - Hot reload: Update monomorphized code without full recompilation
#   - Metadata tracking: Record instantiation relationships
#
# Public API:
#   - use compiler_core.monomorphize.engine.{monomorphize_module, MonoEngine}
#   - use compiler_core.monomorphize.types.{MonoInstance, InstantiationKey}
#   - use compiler_core.monomorphize.table.{MonoTable}
#
# Pipeline:
#   1. Analysis: Identify generic usages (analyzer.spl)
#   2. Instantiation: Create concrete versions (engine.spl, rewriter.spl)
#   3. Specialization: Apply type-specific optimizations (binding_specializer.spl)
#   4. Caching: Store for reuse (cache.spl, table.spl)
#
# All submodules are automatically available through the module system.
