use compiler.test_common.*
use compiler.hir_lowering.*
use compiler.mir_lowering.*
use compiler.mir_data.*
use std.string.{NL}

val source = "fn main() -> i64:{NL}    0{NL}"
var parser = parser_new(source)
val ast_module = parser_parse(parser)
print "AST: {ast_module.functions.keys()}"

var hir_lowering = hirlowering_new()
val hir_module = hir_lowering_lower_module(hir_lowering, ast_module)
print "HIR functions: {hir_module.functions.keys()}"

# Check HIR function body
for key in hir_module.functions_keys(functions):
    val fn_ = hir_module.functions[key]
    print "HIR fn: {fn_.name}"
    print "  Return type: {fn_.return_type}"
    print "  Body: {fn_.body}"
    print "  Body.value: {fn_.body.value}"
    if fn_.body.has_value:
        val val_expr = fn_.body.value_value
        print "  Body expr kind: {val_expr.kind}"

var mir_ctx = mirlowering_new(hir_lowering.symbols)

# Debug: check builder state before
print "Builder before: locals={mir_ctx.builder.locals.len()}, blocks={mir_ctx.builder.blocks.len()}"

val mir_module = mir_ctx_lower_module(mir_ctx, hir_module)
print "MIR functions: {mir_module.functions.keys().len()}"
for key in mir_module.functions_keys(functions):
    val fn_ = mir_module.functions[key]
    print "MIR fn: {fn_.name}, blocks={fn_.blocks.len()}, locals={fn_.locals.len()}"
    for blk in fn_.blocks:
        print "  Block {blk.id.id}: insts={blk.instructions.len()}, term={blk.terminator}"
        for inst in blk.instructions:
            print "    Inst: {inst.kind}"
