# Test: Pipeline with multiple program variants

extern fn rt_process_run(cmd: text, args: [text]) -> (text, text, i64)

fn shell(command: text) -> (text, text, i64):
    rt_process_run("sh", ["-c", command])

use compiler.test_common.*
use compiler.hir_lowering.*
use compiler.mir_lowering.*
use compiler.mir_data.*
use compiler.backend.native.mod.{compile_native}
use compiler.backend.backend_types.{CodegenTarget}
use std.string.{NL}

fn byte_to_hex(b: i64) -> text:
    val digits = "0123456789abcdef"
    "{digits[b / 16]}{digits[b % 16]}"

fn compile_and_run(label: text, source: text, expected_exit: i64) -> bool:
    print "--- {label} ---"
    print "  Source: {source}"

    # Parse
    var parser = parser_new(source)
    val ast_module = parser_parse(parser)
    if parser.errors_len(errors) > 0:
        print "  Parse ERRORS: {parser.errors.len()}"
        for e in parser.errors:
            print "    {e.message}"
        return false

    # HIR
    var hir_lowering = hirlowering_new()
    val hir_module = hir_lowering_lower_module(hir_lowering, ast_module)

    # MIR
    var mir_ctx = mirlowering_new(hir_lowering.symbols)
    val mir_module = mir_ctx_lower_module(mir_ctx, hir_module)

    # Debug: print MIR
    for key in mir_module.functions_keys(functions):
        val fn_ = mir_module.functions[key]
        print "  MIR fn: {fn_.name}, return: {fn_.signature.return_type}"
        print "    locals: {fn_.locals.len()}, blocks: {fn_.blocks.len()}"
        for blk in fn_.blocks:
            print "    block {blk.id.id}: {blk.instructions.len()} insts, term: {blk.terminator}"

    # Native backend
    val elf_bytes = compile_native(mir_module, CodegenTarget.X86_64)
    print "  ELF: {elf_bytes.len()} bytes"

    # Write to disk
    var off = 0
    while off < elf_bytes_len(elf_bytes):
        var chunk = ""
        var end_ = off + 800
        if end_ > elf_bytes_len(elf_bytes):
            end_ = elf_bytes_len(elf_bytes)
        var j = off
        while j < end_:
            chunk = chunk + byte_to_hex(elf_bytes[j])
            j = j + 1
        if off == 0:
            shell("echo -n '{chunk}' > /tmp/pipeline_multi.hex")
        else:
            shell("echo -n '{chunk}' >> /tmp/pipeline_multi.hex")
        off = end_

    shell("xxd -r -p /tmp/pipeline_multi.hex /tmp/pipeline_multi.o")
    shell("rm -f /tmp/pipeline_multi.hex")

    val link_r = rt_process_run("cc", ["-o", "/tmp/pipeline_multi", "/tmp/pipeline_multi.o", "-no-pie"])
    if link_r[2] != 0:
        print "  Link FAILED: {link_r[1]}"
        return false

    val run_r = rt_process_run("/tmp/pipeline_multi", [])
    print "  Exit code: {run_r[2]} (expected: {expected_exit})"
    if run_r[2] == expected_exit:
        print "  PASS"
        return true
    else:
        print "  FAIL"
        return false

fn compile_and_run_output(label: text, source: text, expected_exit: i64, expected_stdout: text) -> bool:
    print "--- {label} ---"
    print "  Source: {source}"

    # Parse
    var parser = parser_new(source)
    val ast_module = parser_parse(parser)
    if parser.errors_len(errors) > 0:
        print "  Parse ERRORS: {parser.errors.len()}"
        for e in parser.errors:
            print "    {e.message} at {e.span}"
        return false

    # HIR
    var hir_lowering = hirlowering_new()
    val hir_module = hir_lowering_lower_module(hir_lowering, ast_module)

    # MIR
    var mir_ctx = mirlowering_new(hir_lowering.symbols)
    val mir_module = mir_ctx_lower_module(mir_ctx, hir_module)

    # Debug: print MIR
    for key in mir_module.functions_keys(functions):
        val fn_ = mir_module.functions[key]
        print "  MIR fn: {fn_.name}, return: {fn_.signature.return_type}"
        print "    locals: {fn_.locals.len()}, blocks: {fn_.blocks.len()}"
        for blk in fn_.blocks:
            print "    block {blk.id.id}: {blk.instructions.len()} insts, term: {blk.terminator}"

    # Native backend
    val elf_bytes = compile_native(mir_module, CodegenTarget.X86_64)
    print "  ELF: {elf_bytes.len()} bytes"

    # Write to disk
    var off = 0
    while off < elf_bytes_len(elf_bytes):
        var chunk = ""
        var end_ = off + 800
        if end_ > elf_bytes_len(elf_bytes):
            end_ = elf_bytes_len(elf_bytes)
        var j = off
        while j < end_:
            chunk = chunk + byte_to_hex(elf_bytes[j])
            j = j + 1
        if off == 0:
            shell("echo -n '{chunk}' > /tmp/pipeline_multi.hex")
        else:
            shell("echo -n '{chunk}' >> /tmp/pipeline_multi.hex")
        off = end_

    shell("xxd -r -p /tmp/pipeline_multi.hex /tmp/pipeline_multi.o")
    shell("rm -f /tmp/pipeline_multi.hex")

    val link_r = rt_process_run("cc", ["-o", "/tmp/pipeline_multi", "/tmp/pipeline_multi.o", "-no-pie"])
    if link_r[2] != 0:
        print "  Link exit: {link_r[2]}"
        print "  Link stdout: {link_r[0]}"
        print "  Link stderr: {link_r[1]}"
        return false

    val run_r = rt_process_run("/tmp/pipeline_multi", [])
    val stdout_text = run_r[0]
    print "  Exit code: {run_r[2]} (expected: {expected_exit})"
    print "  Stdout: '{stdout_text}' (expected: '{expected_stdout}')"
    var exit_ok = run_r[2] == expected_exit
    var stdout_ok = stdout_text == expected_stdout
    if exit_ok:
        if stdout_ok:
        print "  PASS"
        return true
    else:
        if not exit_ok:
            print "  FAIL (exit code mismatch)"
        if not stdout_ok:
            print "  FAIL (stdout mismatch)"
        return false

print "=== Pipeline Multi-Test ==="

# Test 1: Simple return 0
val t1 = compile_and_run("Return 0", "fn main():{NL}    0{NL}", 0)

# Test 2: Return 42
val t2 = compile_and_run("Return 42", "fn main():{NL}    42{NL}", 42)

# Test 3: Return with explicit return
val t3 = compile_and_run("Explicit return", "fn main():{NL}    return 0{NL}", 0)

# Test 4: Simple arithmetic
val t4 = compile_and_run("Arithmetic", "fn main():{NL}    1 + 2{NL}", 3)

# Test 5: Nested arithmetic
val t5 = compile_and_run("Nested arith", "fn main():{NL}    (10 + 20) * 2{NL}", 60)

# Test 6: Variable declaration
val t6 = compile_and_run("Variable", "fn main():{NL}    val x = 5{NL}    x + 3{NL}", 8)

# Test 7: If expression
val t7 = compile_and_run("If-else", "fn main():{NL}    val x = 10{NL}    if x > 5:{NL}        1{NL}    else:{NL}        0{NL}", 1)

# Test 8: While loop
val t8 = compile_and_run("While loop", "fn main():{NL}    var x = 0{NL}    while x < 10:{NL}        x = x + 1{NL}    x{NL}", 10)

# Test 9: Multiple variables
val t9 = compile_and_run("Multi vars", "fn main():{NL}    val a = 10{NL}    val b = 20{NL}    val c = a + b{NL}    c{NL}", 30)

# Test 10: Nested if-else
val t10 = compile_and_run("Nested if", "fn main():{NL}    val x = 15{NL}    if x > 20:{NL}        3{NL}    else:{NL}        if x > 10:{NL}            2{NL}        else:{NL}            1{NL}", 2)

# Test 11: Complex while - compute factorial of 5
val t11 = compile_and_run("Factorial 5", "fn main():{NL}    var n = 5{NL}    var result = 1{NL}    while n > 0:{NL}        result = result * n{NL}        n = n - 1{NL}    result{NL}", 120)

# Test 12: Subtraction and negative results (exit code wraps to 256-x)
val t12 = compile_and_run("Subtraction", "fn main():{NL}    val x = 100{NL}    val y = 58{NL}    x - y{NL}", 42)

# Test 13: Var mutation in while (var decrements)
val t13 = compile_and_run("Var decrement", "fn main():{NL}    var x = 50{NL}    while x > 10:{NL}        x = x - 5{NL}    x{NL}", 10)

# Test 14: Multiple while iterations with <= operator
val t14 = compile_and_run("Sum 1..5", "fn main():{NL}    var sum = 0{NL}    var i = 1{NL}    while i <= 5:{NL}        sum = sum + i{NL}        i = i + 1{NL}    sum{NL}", 15)

# Test 15: >= operator
val t15 = compile_and_run("GtEq op", "fn main():{NL}    val x = 10{NL}    if x >= 10:{NL}        1{NL}    else:{NL}        0{NL}", 1)

# Test 16: == operator (equality)
val t16 = compile_and_run("Equality", "fn main():{NL}    val x = 5{NL}    if x == 5:{NL}        42{NL}    else:{NL}        0{NL}", 42)

# Test 17: != operator (inequality)
val t17 = compile_and_run("Inequality", "fn main():{NL}    val x = 5{NL}    if x != 3:{NL}        1{NL}    else:{NL}        0{NL}", 1)

# Test 18: Function call
val t18 = compile_and_run("Fn call", "fn add(a: i64, b: i64) -> i64:{NL}    a + b{NL}{NL}fn main():{NL}    add(10, 20){NL}", 30)

# Test 19: Nested function calls
val t19 = compile_and_run("Nested fn", "fn double(x: i64) -> i64:{NL}    x * 2{NL}{NL}fn main():{NL}    double(double(5)){NL}", 20)

# Test 20: Recursive function (fibonacci-ish: fib(6) = 8)
val t20 = compile_and_run("Recursion", "fn fib(n: i64) -> i64:{NL}    if n <= 1:{NL}        n{NL}    else:{NL}        fib(n - 1) + fib(n - 2){NL}{NL}fn main():{NL}    fib(6){NL}", 8)

# Test 21: Multiple functions calling each other
val t21 = compile_and_run("Multi fn", "fn square(x: i64) -> i64:{NL}    x * x{NL}{NL}fn add_squares(a: i64, b: i64) -> i64:{NL}    square(a) + square(b){NL}{NL}fn main():{NL}    add_squares(3, 4){NL}", 25)

# Test 22: Division (integer)
val t22 = compile_and_run("Division", "fn main():{NL}    val x = 100{NL}    val y = 4{NL}    x / y{NL}", 25)

# Test 23: Modulo
val t23 = compile_and_run("Modulo", "fn main():{NL}    val x = 17{NL}    val y = 5{NL}    x % y{NL}", 2)

# Test 24: Deeply nested recursion (fib(10) = 55)
val t24 = compile_and_run("Deep recursion", "fn fib(n: i64) -> i64:{NL}    if n <= 1:{NL}        n{NL}    else:{NL}        fib(n - 1) + fib(n - 2){NL}{NL}fn main():{NL}    fib(10){NL}", 55)

# Test 25: Multiple args (>2)
val t25 = compile_and_run("3 args", "fn add3(a: i64, b: i64, c: i64) -> i64:{NL}    a + b + c{NL}{NL}fn main():{NL}    add3(10, 20, 30){NL}", 60)

# Test 26: Chain of function calls
val t26 = compile_and_run("Call chain", "fn inc(x: i64) -> i64:{NL}    x + 1{NL}{NL}fn main():{NL}    inc(inc(inc(inc(0)))){NL}", 4)

# Test 27: GCD (Euclidean algorithm)
val t27 = compile_and_run("GCD", "fn gcd(a: i64, b: i64) -> i64:{NL}    if b == 0:{NL}        a{NL}    else:{NL}        gcd(b, a % b){NL}{NL}fn main():{NL}    gcd(48, 18){NL}", 6)

# Test 28: Countdown with var mutation (power of 2)
val t28 = compile_and_run("Power of 2", "fn main():{NL}    var result = 1{NL}    var i = 0{NL}    while i < 7:{NL}        result = result * 2{NL}        i = i + 1{NL}    result{NL}", 128)

# Test 29: Many values live across calls (stress register pressure)
val t29 = compile_and_run("Reg pressure", "fn identity(x: i64) -> i64:{NL}    x{NL}{NL}fn main():{NL}    val a = 1{NL}    val b = 2{NL}    val c = 3{NL}    val d = 4{NL}    val e = 5{NL}    val f = identity(10){NL}    val g = identity(20){NL}    a + b + c + d + e + f + g{NL}", 45)

# Test 30: 4-arg function
val t30 = compile_and_run("4 args", "fn sum4(a: i64, b: i64, c: i64, d: i64) -> i64:{NL}    a + b + c + d{NL}{NL}fn main():{NL}    sum4(10, 20, 30, 40){NL}", 100)

# Test 31: >5 values live across multiple calls (forces spilling with callee-only)
val t31 = compile_and_run("Spill across calls", "fn id(x: i64) -> i64:{NL}    x{NL}{NL}fn main():{NL}    val a = 1{NL}    val b = 2{NL}    val c = 3{NL}    val d = 4{NL}    val e = 5{NL}    val f = 6{NL}    val g = 7{NL}    val h = id(a + b){NL}    a + b + c + d + e + f + g + h{NL}", 31)

# Test 32: Mutual recursion (is_even/is_odd)
val t32 = compile_and_run("Mutual recursion", "fn is_even(n: i64) -> i64:{NL}    if n == 0:{NL}        1{NL}    else:{NL}        is_odd(n - 1){NL}{NL}fn is_odd(n: i64) -> i64:{NL}    if n == 0:{NL}        0{NL}    else:{NL}        is_even(n - 1){NL}{NL}fn main():{NL}    is_even(10){NL}", 1)

# Test 33: Complex expression (Collatz step count for 6 = 8 steps)
val t33 = compile_and_run("Collatz", "fn collatz_steps(n: i64) -> i64:{NL}    var steps = 0{NL}    var x = n{NL}    while x != 1:{NL}        if x % 2 == 0:{NL}            x = x / 2{NL}        else:{NL}            x = x * 3 + 1{NL}        steps = steps + 1{NL}    steps{NL}{NL}fn main():{NL}    collatz_steps(6){NL}", 8)

# Test 34: 5-arg function
val t34 = compile_and_run("5 args", "fn sum5(a: i64, b: i64, c: i64, d: i64, e: i64) -> i64:{NL}    a + b + c + d + e{NL}{NL}fn main():{NL}    sum5(1, 2, 3, 4, 5){NL}", 15)

# Test 35: Nested while loops (multiplication via nested loops)
val t35 = compile_and_run("Nested while", "fn main():{NL}    var total = 0{NL}    var i = 0{NL}    while i < 3:{NL}        var j = 0{NL}        while j < 4:{NL}            total = total + 1{NL}            j = j + 1{NL}        i = i + 1{NL}    total{NL}", 12)

# Test 36: Boolean logic - chained comparisons
val t36 = compile_and_run("Bool chain", "fn in_range(x: i64, lo: i64, hi: i64) -> i64:{NL}    if x >= lo:{NL}        if x <= hi:{NL}            1{NL}        else:{NL}            0{NL}    else:{NL}        0{NL}{NL}fn main():{NL}    in_range(5, 3, 10) + in_range(15, 3, 10) + in_range(3, 3, 10){NL}", 2)

# Test 37: Ackermann-like function (bounded)
val t37 = compile_and_run("Ackermann", "fn ack(m: i64, n: i64) -> i64:{NL}    if m == 0:{NL}        n + 1{NL}    else:{NL}        if n == 0:{NL}            ack(m - 1, 1){NL}        else:{NL}            ack(m - 1, ack(m, n - 1)){NL}{NL}fn main():{NL}    ack(2, 3){NL}", 9)

# ==========================================================================
# Step 1: String Output Tests (extern calls with string constants)
# ==========================================================================

# Test 38: Simple puts call - verify string constant + extern call
val t38 = compile_and_run_output("puts Hello", "extern fn puts(s: text) -> i64{NL}{NL}fn main():{NL}    puts(\"Hello\"){NL}    0{NL}", 0, "Hello{NL}")

# Test 39: Multiple puts calls - verify multi-string output
val t39 = compile_and_run_output("Multi puts", "extern fn puts(s: text) -> i64{NL}{NL}fn main():{NL}    puts(\"foo\"){NL}    puts(\"bar\"){NL}    0{NL}", 0, "foo{NL}bar{NL}")

# Test 40: String constant + return value combined
val t40 = compile_and_run_output("puts + retval", "extern fn puts(s: text) -> i64{NL}{NL}fn main():{NL}    puts(\"done\"){NL}    42{NL}", 42, "done{NL}")

# ==========================================================================
# Step 3: Multi-arg extern calls (printf, write)
# ==========================================================================

# Test 41: printf with format string + int arg (2 args)
# Note: escape sequences in string literals not yet supported by self-hosting lexer in runtime
# Using puts for newline; printf output has no trailing newline
val t41 = compile_and_run_output("printf 2 args", "extern fn printf(fmt: text, n: i64) -> i64{NL}extern fn puts(s: text) -> i64{NL}{NL}fn main():{NL}    printf(\"%d\", 42){NL}    puts(\"\"){NL}    0{NL}", 0, "42{NL}")

# Test 42: printf with format string + 2 int args (3 args)
val t42 = compile_and_run_output("printf 3 args", "extern fn printf(fmt: text, a: i64, b: i64) -> i64{NL}extern fn puts(s: text) -> i64{NL}{NL}fn main():{NL}    printf(\"%d+%d\", 10, 20){NL}    puts(\"\"){NL}    0{NL}", 0, "10+20{NL}")

# Test 43: puts with computed value after call
val t43 = compile_and_run_output("call + compute", "extern fn puts(s: text) -> i64{NL}{NL}fn add(a: i64, b: i64) -> i64:{NL}    a + b{NL}{NL}fn main():{NL}    puts(\"calc\"){NL}    add(3, 4){NL}", 7, "calc{NL}")

# ==========================================================================
# Step 2b: Array construction + GetElementPtr + Load (index access)
# ==========================================================================

# Test 44: Array literal + index access: [10, 20, 30][1] -> 20
val t44 = compile_and_run("array index [1]", "fn main():{NL}    val arr = [10, 20, 30]{NL}    arr[1]{NL}", 20)

# Test 45: Array literal + index 0 and 2
val t45 = compile_and_run("array index [0]+[2]", "fn main():{NL}    val arr = [5, 10, 15]{NL}    arr[0] + arr[2]{NL}", 20)

# Test 46: Array with computed index
val t46 = compile_and_run("array computed idx", "fn main():{NL}    val arr = [3, 7, 11, 13]{NL}    val i = 1 + 1{NL}    arr[i]{NL}", 11)

# ==========================================================================
# Step 4: Mutable variables, heap allocation, combined features
# ==========================================================================

# Test 47: Mutable variable reassignment
val t47 = compile_and_run("mutable var", "fn main():{NL}    var x = 5{NL}    x = x + 3{NL}    x{NL}", 8)

# Test 48: Mutable variable in loop-like pattern (multiple reassignments)
val t48 = compile_and_run("var multi reassign", "fn main():{NL}    var x = 1{NL}    x = x + x{NL}    x = x + x{NL}    x = x + x{NL}    x{NL}", 8)

# Test 49: Mutable variable with compound assign
val t49 = compile_and_run("var compound", "fn main():{NL}    var x = 10{NL}    x = x - 3{NL}    x = x * 2{NL}    x{NL}", 14)

# Test 50: malloc + store + load (heap allocation)
val t50 = compile_and_run("malloc heap", "extern fn malloc(size: i64) -> i64{NL}extern fn free(ptr: i64) -> i64{NL}{NL}fn main():{NL}    val ptr = malloc(8){NL}    0{NL}", 0)

# Test 51: Array element sum via function
val t51 = compile_and_run("array sum fn", "fn sum3(a: i64, b: i64, c: i64) -> i64:{NL}    a + b + c{NL}{NL}fn main():{NL}    val arr = [10, 20, 30]{NL}    sum3(arr[0], arr[1], arr[2]){NL}", 60)

var passed = 0
var total = 51
if t1: passed = passed + 1
if t2: passed = passed + 1
if t3: passed = passed + 1
if t4: passed = passed + 1
if t5: passed = passed + 1
if t6: passed = passed + 1
if t7: passed = passed + 1
if t8: passed = passed + 1
if t9: passed = passed + 1
if t10: passed = passed + 1
if t11: passed = passed + 1
if t12: passed = passed + 1
if t13: passed = passed + 1
if t14: passed = passed + 1
if t15: passed = passed + 1
if t16: passed = passed + 1
if t17: passed = passed + 1
if t18: passed = passed + 1
if t19: passed = passed + 1
if t20: passed = passed + 1
if t21: passed = passed + 1
if t22: passed = passed + 1
if t23: passed = passed + 1
if t24: passed = passed + 1
if t25: passed = passed + 1
if t26: passed = passed + 1
if t27: passed = passed + 1
if t28: passed = passed + 1
if t29: passed = passed + 1
if t30: passed = passed + 1
if t31: passed = passed + 1
if t32: passed = passed + 1
if t33: passed = passed + 1
if t34: passed = passed + 1
if t35: passed = passed + 1
if t36: passed = passed + 1
if t37: passed = passed + 1
if t38: passed = passed + 1
if t39: passed = passed + 1
if t40: passed = passed + 1
if t41: passed = passed + 1
if t42: passed = passed + 1
if t43: passed = passed + 1
if t44: passed = passed + 1
if t45: passed = passed + 1
if t46: passed = passed + 1
if t47: passed = passed + 1
if t48: passed = passed + 1
if t49: passed = passed + 1
if t50: passed = passed + 1
if t51: passed = passed + 1

print ""
print "=== Results: {passed}/{total} passed ==="
