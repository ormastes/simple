# Codegen - Native Code Generation
#
# Generates native machine code from MIR using Cranelift backend (via FFI).
# Supports:
# - x86_64, aarch64, riscv64 targets
# - JIT compilation (immediate execution)
# - AOT compilation (object file generation)
#
# Architecture:
#   MIR -> Codegen -> Cranelift IR -> Native Code

use mir.*
use hir.SymbolId
use lexer.Span
use ffi.codegen*

# ============================================================================
# Cranelift Type Constants
# ============================================================================

val CL_TYPE_I8: i64 = 1
val CL_TYPE_I16: i64 = 2
val CL_TYPE_I32: i64 = 3
val CL_TYPE_I64: i64 = 4
val CL_TYPE_F32: i64 = 5
val CL_TYPE_F64: i64 = 6
val CL_TYPE_B1: i64 = 7    # Boolean
val CL_TYPE_PTR: i64 = 8

val CL_CC_SYSTEM_V: i64 = 0
val CL_CC_WINDOWS_FASTCALL: i64 = 1
val CL_CC_FAST: i64 = 2

val CL_CMP_EQ: i64 = 0
val CL_CMP_NE: i64 = 1
val CL_CMP_SLT: i64 = 2
val CL_CMP_SLE: i64 = 3
val CL_CMP_SGT: i64 = 4
val CL_CMP_SGE: i64 = 5
val CL_CMP_ULT: i64 = 6
val CL_CMP_ULE: i64 = 7
val CL_CMP_UGT: i64 = 8
val CL_CMP_UGE: i64 = 9

val CL_FCMP_EQ: i64 = 0
val CL_FCMP_NE: i64 = 1
val CL_FCMP_LT: i64 = 2
val CL_FCMP_LE: i64 = 3
val CL_FCMP_GT: i64 = 4
val CL_FCMP_GE: i64 = 5

val CL_TARGET_X86_64: i64 = 0
val CL_TARGET_AARCH64: i64 = 1
val CL_TARGET_RISCV64: i64 = 2

# ============================================================================
# Codegen State
# ============================================================================

struct Codegen:
    """Code generator state."""
    module_handle: i64
    current_ctx: i64
    target: CodegenTarget
    mode: CodegenMode
    local_values: Dict<i64, i64>    # LocalId -> Cranelift value
    block_map: Dict<i64, i64>       # BlockId -> Cranelift block
    function_map: Dict<text, i64>   # name -> function id
    symbol_map: Dict<i64, text>     # SymbolId -> function name
    errors: [CodegenError]

"""Target architecture."""
enum CodegenTarget:
    X86_64
    Aarch64
    Riscv64
    Native      # Detect at runtime

"""Compilation mode."""
enum CodegenMode:
    Jit         # Immediate execution
    Aot         # Object file generation

struct CodegenError:
    """Codegen error."""
    message: text
    # # DESUGARED: span: Span
    has_span: bool
    span: Span


# ============================================================================
# Codegen Methods (was: impl Codegen:)
# ============================================================================

fn codegen_new(target: CodegenTarget, mode: CodegenMode) -> Codegen:
        Codegen(
            module_handle: 0,
            current_ctx: 0,
            target: target,
            mode: mode,
            local_values: {},
            block_map: {},
            function_map: {},
            symbol_map: {},
            errors: []
        )


fn codegen_init_module(self: Codegen, name: text) -> bool:
        """Initialize a new module."""
        val target_code = match self.target:
            case X86_64: CL_TARGET_X86_64
            case Aarch64: CL_TARGET_AARCH64
            case Riscv64: CL_TARGET_RISCV64
            case Native: CL_TARGET_X86_64  # Default to x86_64

        # Use different FFI function based on compilation mode
        self.module_handle = match self.mode:
            case Aot: cranelift_new_aot_module(name_ptr(name), name_len(name), target_code)
            case Jit: cranelift_new_module(name_ptr(name), name_len(name), target_code)
        self.module_handle != 0


fn codegen_finalize_module(self: Codegen) -> bool:
        """Finalize the module after all functions are defined."""
        if self.module_handle == 0:
            return false
        cranelift_finalize_module(self.module_handle) != 0


fn codegen_compile_function(self: Codegen, fn_: MirFunction) -> bool:
        """Compile a MIR function to native code."""
        self.local_values = {}
        self.block_map = {}

        # Build signature
        val sig = self.build_signature(fn_.signature)
        if sig == 0:
            self.error("failed to build signature", fn_.span)
            return false

        # Begin function
        self.current_ctx = cranelift_begin_function(
            self.module_handle,
            fn_.name_ptr(name),
            fn_.name_len(name),
            sig
        )
        if self.current_ctx == 0:
            self.error("failed to begin function", fn_.span)
            return false

        # Create blocks
        for block in fn_.blocks:
            val cl_block = cranelift_create_block(self.current_ctx)
            self.block_map[block.id.id] = cl_block

        # Switch to entry block
        val entry_block = self.block_map[fn_.entry_block.id]
        cranelift_switch_to_block(self.current_ctx, entry_block)

        # Create locals for parameters
        for i in 0..fn_.signature.params_len(params):
            val param_value = cranelift_block_param(self.current_ctx, entry_block, i)
            # Parameter locals start at 1 (0 is return slot if non-void)
            val local_id = if fn_.signature.return_type.kind != MirTypeKind.Unit:
                i + 1
            else:
                i
            self.local_values[local_id] = param_value

        # Compile blocks
        for block in fn_.blocks:
            self.compile_block(block)

        # Seal all blocks
        cranelift_seal_all_blocks(self.current_ctx)

        # End function
        val func_id = cranelift_end_function(self.current_ctx)
        if func_id == 0:
            self.error("failed to end function", fn_.span)
            return false

        # Define function in module
        if not cranelift_define_function(self.module_handle, func_id, self.current_ctx):
            self.error("failed to define function", fn_.span)
            return false

        self.function_map[fn_.name] = func_id
        self.symbol_map[fn_.symbol.id] = fn_.name
        true


fn codegen_build_signature(self: Codegen, sig: MirSignature) -> i64:
        """Build Cranelift signature."""
        val cl_sig = cranelift_new_signature(CL_CC_SYSTEM_V)
        if cl_sig == 0:
            return 0

        # Add parameters
        for param in sig.params:
            val cl_type = self.mir_type_to_cl(param)
            cranelift_sig_add_param(cl_sig, cl_type)

        # Set return type
        if sig.return_type.kind != MirTypeKind.Unit:
            val cl_ret = self.mir_type_to_cl(sig.return_type)
            cranelift_sig_set_return(cl_sig, cl_ret)

        cl_sig


fn codegen_mir_type_to_cl(self: Codegen, type_: MirType) -> i64:
        """Convert MIR type to Cranelift type."""
        match type_.kind:
            case I8: CL_TYPE_I8
            case I16: CL_TYPE_I16
            case I32: CL_TYPE_I32
            case I64: CL_TYPE_I64
            case U8: CL_TYPE_I8
            case U16: CL_TYPE_I16
            case U32: CL_TYPE_I32
            case U64: CL_TYPE_I64
            case F32: CL_TYPE_F32
            case F64: CL_TYPE_F64
            case Bool: CL_TYPE_B1
            case Ptr(_, _): CL_TYPE_PTR
            case Ref(_, _): CL_TYPE_PTR
            case FuncPtr(_): CL_TYPE_PTR
            case _: CL_TYPE_I64  # Default to i64


fn codegen_compile_const(self: Codegen, value: MirConstValue, type_: MirType) -> i64:
        """Compile a constant value."""
        match value:
            case Int(v):
                val cl_type = self.mir_type_to_cl(type_)
                cranelift_iconst(self.current_ctx, cl_type, v)

            case Float(v):
                val cl_type = self.mir_type_to_cl(type_)
                cranelift_fconst(self.current_ctx, cl_type, v)

            case Bool(v):
                cranelift_bconst(self.current_ctx, v)

            case Zero:
                val cl_type = self.mir_type_to_cl(type_)
                cranelift_iconst(self.current_ctx, cl_type, 0)

            case _:
                cranelift_iconst(self.current_ctx, CL_TYPE_I64, 0)


fn codegen_compile_operand(self: Codegen, operand: MirOperand) -> i64:
        """Compile an operand to a Cranelift value."""
        match operand.kind:
            case Copy(local):
                self.get_local(local)
            case Move(local):
                self.get_local(local)
            case Const(value, type_):
                # Check if this is a function pointer (symbol ID encoded as int)
                match type_.kind:
                    case FuncPtr(_):
                        # Extract symbol ID and resolve to function
                        match value:
                            case Int(symbol_id):
                                self.resolve_function_symbol(symbol_id)
                            case _:
                                self.compile_const(value, type_)
                    case _:
                        self.compile_const(value, type_)


fn codegen_get_local(self: Codegen, local: LocalId) -> i64:
        """Get Cranelift value for a local."""
        self.local_values[local.id] ?? 0


fn codegen_compile_binop(self: Codegen, op: MirBinOp, left: i64, right: i64) -> i64:
        """Compile binary operation."""
        match op:
            case Add:
                cranelift_iadd(self.current_ctx, left, right)
            case Sub:
                cranelift_isub(self.current_ctx, left, right)
            case Mul:
                cranelift_imul(self.current_ctx, left, right)
            case Div:
                cranelift_sdiv(self.current_ctx, left, right)
            case Rem:
                cranelift_srem(self.current_ctx, left, right)
            case BitAnd:
                cranelift_band(self.current_ctx, left, right)
            case BitOr:
                cranelift_bor(self.current_ctx, left, right)
            case BitXor:
                cranelift_bxor(self.current_ctx, left, right)
            case Shl:
                cranelift_ishl(self.current_ctx, left, right)
            case Shr:
                cranelift_sshr(self.current_ctx, left, right)
            case Eq:
                cranelift_icmp(self.current_ctx, CL_CMP_EQ, left, right)
            case Ne:
                cranelift_icmp(self.current_ctx, CL_CMP_NE, left, right)
            case Lt:
                cranelift_icmp(self.current_ctx, CL_CMP_SLT, left, right)
            case Le:
                cranelift_icmp(self.current_ctx, CL_CMP_SLE, left, right)
            case Gt:
                cranelift_icmp(self.current_ctx, CL_CMP_SGT, left, right)
            case Ge:
                cranelift_icmp(self.current_ctx, CL_CMP_SGE, left, right)
            case _:
                self.error("unsupported codegen binary operator: {op}", nil)
                0


fn codegen_compile_unaryop(self: Codegen, op: MirUnaryOp, operand: i64) -> i64:
        """Compile unary operation."""
        match op:
            case Neg:
                val zero = cranelift_iconst(self.current_ctx, CL_TYPE_I64, 0)
                cranelift_isub(self.current_ctx, zero, operand)
            case Not:
                val one = cranelift_iconst(self.current_ctx, CL_TYPE_I64, 1)
                cranelift_bxor(self.current_ctx, operand, one)
            case BitNot:
                cranelift_bnot(self.current_ctx, operand)


fn codegen_resolve_function_symbol(self: Codegen, symbol_id: i64) -> i64:
        """Resolve a function symbol to a Cranelift function ID."""
        val func_name = self.symbol_map[symbol_id]
        if has_func_name:
            val func_id = self.function_map[func_name_value]
            func_id ?? 0
        else:
            self.error("unresolved function symbol: {symbol_id}", nil)
            0


fn codegen_aggregate_type(self: Codegen, kind: AggregateKind) -> MirType:
        """Get type for aggregate kind."""
        match kind:
            case Array(type_): type_
            case Tuple: MirType(kind: MirTypeKind.I64)
            case Struct(_): MirType(kind: MirTypeKind.I64)
            case Enum(_, _): MirType(kind: MirTypeKind.I64)


fn codegen_get_function_ptr(self: Codegen, name: text) -> i64:
        """Get pointer to compiled function."""
        cranelift_get_function_ptr(self.module_handle, name_ptr(name), name_len(name))


fn codegen_call_function(self: Codegen, name: text, args: [i64]) -> i64:
        """Call a compiled function."""
        # Stub: Cranelift function call not supported in seed_cpp
        0


fn codegen_emit_object(self: Codegen, path: text) -> bool:
        """Emit object file for AOT compilation."""
        # Stub: Cranelift object emission not supported in seed_cpp
        false


# ============================================================================
# High-Level API
# ============================================================================

struct CodegenPipeline:
    """High-level code generation pipeline."""
    target: CodegenTarget
    mode: CodegenMode
    optimize: bool


# ============================================================================
# CodegenPipeline Methods (was: impl CodegenPipeline:)
# ============================================================================

fn codegenpipeline_jit() -> i64:
        """Create JIT compilation pipeline."""
        # Stub: CodegenPipeline struct return not supported in seed_cpp
        0


fn codegenpipeline_aot(target: CodegenTarget) -> i64:
        """Create AOT compilation pipeline."""
        # Stub: CodegenPipeline struct return not supported in seed_cpp
        0


struct CompiledModule:
    """Compiled module ready for execution or output."""
    name: text
    codegen: Codegen
    mode: CodegenMode


# ============================================================================
# CompiledModule Methods (was: impl CompiledModule:)
# ============================================================================

# ============================================================================
# Convenience Functions
# ============================================================================

fn jit_compile(mir: MirModule) -> text:
    """JIT compile a MIR module."""
    val pipeline = codegenpipeline_jit()
    pipeline_compile_module(pipeline, mir)

fn aot_compile(mir: MirModule, target: CodegenTarget) -> text:
    """AOT compile a MIR module."""
    val pipeline = codegenpipeline_aot(target)
    pipeline_compile_module(pipeline, mir)

fn compile_and_run(mir: MirModule, entry: text, args: [i64]) -> text:
    """Compile and immediately run a function."""
    val module = jit_compile(mir)?
    val result = module_call(module, entry, args)?
    module_cleanup(module)
    Ok(result)

fn aot_compile_to_bytes(mir: MirModule) -> text:
    """AOT compile a MIR module and return object code bytes.

    This is a convenience function for backend integration. It compiles the module
    using Cranelift, emits to a temp file, reads the bytes, and cleans up.
    """
    val pipeline = codegenpipeline_aot(CodegenTarget.Native)
    val compiled = pipeline_compile_module(pipeline, mir)
    if compiled_is_err(compiled):
        val err = compiled_unwrap_err(compiled)
        return Err("Cranelift compile error: {err.message}")

    val module = compiled_value
    val tmp_path = "/tmp/simple_cl_{mir.name}.o"
    val emit_result = module_emit_object(module, tmp_path)
    if emit_result_is_err(emit_result):
        val err = emit_result_unwrap_err(emit_result)
        return Err("Cranelift emit error: {err.message}")

    val bytes = rt_file_read_bytes(tmp_path)
    rt_file_delete(tmp_path)
    module_cleanup(module)

    if bytes == nil:
        return Err("Failed to read Cranelift object file: {tmp_path}")

    Ok(bytes)

# ============================================================================
# Exports
# ============================================================================

export Codegen, CodegenTarget, CodegenMode, CodegenError
export CodegenPipeline, CompiledModule
export jit_compile, aot_compile, compile_and_run, aot_compile_to_bytes
