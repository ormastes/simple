# Parser Factory - Interpreter-compatible factory functions
#
# The interpreter cannot call static methods (like Parser.new()) from external
# modules. These standalone functions provide the same functionality using
# direct struct construction within this module.

use lexer.*
use parser_types.*
use parser.*
use blocks.modes.{LexerMode}

fn create_parser(src: text) -> Parser:
    """Create a Parser from source text.
    Use this instead of Parser.new() when running in interpreter mode."""
    var p = Parser(
        source: src,
        lexer: Lexer(
            source: src,
            pos: 0,
            line: 1,
            col: 1,
            indent_stack: [0],
            pending_dedents: 0,
            at_line_start: true,
            paren_depth: 0,
            in_math_block: false,
            math_brace_depth: 0,
            prev_token_kind: TokenKind.Eof,
            # DESUGARED: pending_token: nil
            has_pending_token: false,
            generic_depth: 0,
            # DESUGARED: block_registry: nil
            has_block_registry: false,
            # DESUGARED: current_block_kind: nil
            has_current_block_kind: false,
            current_lexer_mode: LexerMode.Normal,
            in_raw_block: false,
            raw_block_start: 0,
            block_brace_depth: 0,
            # DESUGARED: unified_registry: nil
            has_unified_registry: false,
        ),
        current: Token(kind: TokenKind.Eof, span: Span(start: 0, end: 0, line: 1, col: 0), text: ""),
        previous: Token(kind: TokenKind.Eof, span: Span(start: 0, end: 0, line: 1, col: 0), text: ""),
        errors: [],
        outline: nil,
        resolved_blocks: nil
    )
    p_advance(p)
    p

export create_parser
