# Extended SMF writer with template section support (v1[1])
#
# This module extends the basic SMF builder to include:
# - TemplateCode sections (serialized generic definitions)
# - TemplateMeta sections (monomorphization metadata)
# - ⭐ Trailer-based header design (like ZIP format)
# - Compression support (default: 0 = no compression)
# - Executable SMF support (stub fields)
#
# v1[1] Design: Header written at EOF-128 (trailer), not at offset 0.
# This enables directly executable SMF files (prepend shebang/stub).
#
# Enables .smf files to store both native code AND templates for deferred instantiation.

use monomorphize.partition (GenericTemplates)
use monomorphize.metadata (MonomorphizationMetadata)
use monomorphize.note_sdn (NoteSdnMetadata)
use ast (FunctionDef, StructDef, ClassDef, EnumDef, TraitDef)
use linker.smf_header (SmfHeader, SMF_FLAG_EXECUTABLE)
use linker.smf_enums (Platform, Arch)
use std.platform.{get_host_os, get_host_arch}

# Target platform information
struct Target:
    os: text        # "linux", "windows", "macos"
    arch: text      # "x86_64", "aarch64", "riscv64"


# ============================================================================
# Target Methods (was: impl Target:)
# ============================================================================

fn target_host() -> Target:
        # Platform detection using std.platform (Phase 2[1] - TODO #162 ✅)
        Target(os: get_host_os(), arch: get_host_arch())


fn target_x86_64_unknown_linux_gnu() -> Target:
        Target(os: "linux", arch: "x86_64")


fn target_aarch64_unknown_linux_gnu() -> Target:
        Target(os: "linux", arch: "aarch64")


# SMF build options - groups common parameters
struct SmfBuildOptions:
    # # DESUGARED: templates: GenericTemplates
    has_templates: bool
    templates: GenericTemplates
    # # DESUGARED: metadata: MonomorphizationMetadata
    has_metadata: bool
    metadata: MonomorphizationMetadata
    # # DESUGARED: note_sdn: NoteSdnMetadata
    has_note_sdn: bool
    note_sdn: NoteSdnMetadata
    target: Target


# ============================================================================
# SmfBuildOptions Methods (was: impl SmfBuildOptions:)
# ============================================================================

fn smfbuildoptions_create(target: Target) -> SmfBuildOptions:
        SmfBuildOptions(
            #  # DESUGARED: templates: nil
            #  # DESUGARED: metadata: nil
            #  # DESUGARED: note_sdn: nil
            target: target
        )


# Generate SMF from object code with optional template sections
#
# If templates and metadata are provided, adds TemplateCode and TemplateMeta sections
# to enable deferred monomorphization.
fn generate_smf_with_templates(
    object_code: [u8],
    templates: GenericTemplates,
    metadata: MonomorphizationMetadata,
    target: Target
) -> [u8]:
    val options = SmfBuildOptions(
        templates: templates,
        metadata: metadata,
        note_sdn: nil,
        target: target
    )
    generate_smf_with_options(object_code, options)

# Generate SMF from object code with all optional sections
#
# Includes templates, metadata, and note.sdn for full instantiation tracking.
fn generate_smf_with_all_sections(
    object_code: [u8],
    templates: GenericTemplates,
    metadata: MonomorphizationMetadata,
    note_sdn: NoteSdnMetadata,
    target: Target
) -> [u8]:
    val options = SmfBuildOptions(
        templates: templates,
        metadata: metadata,
        note_sdn: note_sdn,
        target: target
    )
    generate_smf_with_options(object_code, options)

# Generate SMF from object code with build options
fn generate_smf_with_options(object_code: [u8], options: SmfBuildOptions) -> [u8]:
    val code_bytes = extract_code_from_object(object_code)

    # If no templates, use simple builder
    if not options_has_any_sections(options):
        return build_smf_with_code_for_target(code_bytes, options.target)

    # Build SMF with template sections
    build_smf_with_templates_internal(code_bytes, options)

# Build an SMF module with code and optional template sections
# ⭐ v1[1]: Uses TRAILER-BASED HEADER (like ZIP format)
fn build_smf_with_templates_internal(code_bytes: [u8], options: SmfBuildOptions) -> [u8]:
    var buf: [u8] = []

    # ⭐ NEW: No stub in this implementation (stub_size = 0)
    # Future: Add optional stub support for executable SMF
    val stub_size = 0
    val smf_data_offset = 0

    # 1. Write sections FIRST (before header)

    # Serialize templates if present
    val template_bytes = if options.has_templates:
        serialize_templates(options.templates_value)
    else:
        []

    val metadata_bytes = if options.has_metadata:
        serialize_metadata(options.metadata_value)
    else:
        []

    val note_sdn_bytes = if options.has_note_sdn:
        serialize_note_sdn(options.note_sdn_value)
    else:
        []

    val has_templates = not template_bytes_is_empty(template_bytes)
    val has_metadata = not metadata_bytes_is_empty(metadata_bytes)
    val has_note_sdn = not note_sdn_bytes_is_empty(note_sdn_bytes)

    # Calculate section count
    var section_count = 1  # Code section
    if has_templates:
        section_count = section_count + 1
    if has_metadata:
        section_count = section_count + 1
    if has_note_sdn:
        section_count = section_count + 1  # note.sdn section

    # Calculate offsets (sections come FIRST now, not after header)
    val header_size = 128  # SmfHeader::SIZE (written at END)
    val section_entry_size = 64  # SmfSection size
    val code_offset = 0  # ⭐ Code starts at offset 0 (no header at start)
    val template_offset = code_offset + code_bytes_len(code_bytes)
    val metadata_offset = template_offset + template_bytes_len(template_bytes)
    val note_sdn_offset = metadata_offset + metadata_bytes_len(metadata_bytes)
    val section_table_offset = note_sdn_offset + note_sdn_bytes_len(note_sdn_bytes)
    val section_table_size = section_count * section_entry_size
    val symbol_table_offset = section_table_offset + section_table_size
    val string_table_offset = symbol_table_offset + 72  # One symbol
    val header_offset = string_table_offset + 5  # "main\0"

    # Write code section
    buf = buf_concat(buf, code_bytes)

    # Write template section
    if has_templates:
        buf = buf_concat(buf, template_bytes)

    # Write metadata section
    if has_metadata:
        buf = buf_concat(buf, metadata_bytes)

    # Write note.sdn section
    if has_note_sdn:
        buf = buf_concat(buf, note_sdn_bytes)

    # 2. Write section table

    # Code section
    buf = buf.concat(build_section_entry(
        section_type: 1,  # SectionType::Code
        flags: 0x05,  # READ | EXEC
        offset: code_offset,
        size: code_bytes_len(code_bytes),
        name: "code"
    ))

    # Template code section
    if has_templates:
        buf = buf.concat(build_section_entry(
            section_type: 12,  # SectionType::TemplateCode
            flags: 0x01,  # READ
            offset: template_offset,
            size: template_bytes_len(template_bytes),
            name: "template_code"
        ))

    # Template metadata section
    if has_metadata:
        buf = buf.concat(build_section_entry(
            section_type: 13,  # SectionType::TemplateMeta
            flags: 0x01,  # READ
            offset: metadata_offset,
            size: metadata_bytes_len(metadata_bytes),
            name: "template_meta"
        ))

    # note.sdn section (zero-size trick: size=0 in section table)
    if has_note_sdn:
        buf = buf.concat(build_section_entry(
            section_type: 13,  # SectionType::TemplateMeta (reuse)
            flags: 0x01,  # READ
            offset: note_sdn_offset,
            size: 0,  # ⭐ Zero-size trick: actual size determined by scanning for terminator
            name: "note.sdn"
        ))

    # 3. Write symbol table
    buf = buf.concat(build_symbol_entry("main", 0, code_bytes.len()))

    # 4. Write string table
    buf = buf.concat("main\0".to_bytes())

    # 5. Write HEADER at END (TRAILER) ⭐ v1[1] design
    # This enables executable SMF files (prepend shebang/stub)

    # Create header using SmfHeader struct
    val platform = text_to_platform(options.target.os)
    val arch = text_to_arch(options.target.arch)
    var header = smfheader_new_v1_1(platform, arch)

    # Set flags
    header_set_executable(header, true)

    # Set counts and offsets
    header.section_count = section_count
    header.section_table_offset = section_table_offset
    header.symbol_table_offset = symbol_table_offset
    header.symbol_count = 1
    header.exported_count = 1
    header.entry_point = 0

    # Set stub info (no stub for now)
    header_set_stub_info(header, stub_size, smf_data_offset)

    # Serialize and append header
    buf = buf_concat(buf, header.to_bytes())

    buf

# Build a section table entry
fn build_section_entry(
    section_type: i32,
    flags: i32,
    offset: i32,
    size: i32,
    name: text
) -> [u8]:
    var buf: [u8] = []

    # Section type (u8)
    buf = buf_push(buf, section_type.to_u8())

    # Padding (3 bytes)
    buf = buf_concat(buf, [0, 0, 0])

    # Flags (u32)
    buf = buf_concat(buf, u32_to_bytes(flags))

    # Offset (u64)
    buf = buf_concat(buf, u64_to_bytes(offset))

    # Size (u64)
    buf = buf_concat(buf, u64_to_bytes(size))

    # Virtual size (u64)
    buf = buf_concat(buf, u64_to_bytes(size))

    # Alignment (u32)
    buf = buf_concat(buf, u32_to_bytes(16))

    # Name (16 bytes)
    var name_bytes = name_to_bytes(name)
    if name_bytes_len(name_bytes) > 16:
        name_bytes = name_bytes[0:16]
    buf = buf_concat(buf, name_bytes)
    while buf_len(buf) % 64 != 0:
        buf = buf_push(buf, 0)

    buf

# Build a symbol table entry
fn build_symbol_entry(name: text, value: i32, size: i32) -> [u8]:
    var buf: [u8] = []

    # Name offset (u32)
    buf = buf_concat(buf, u32_to_bytes(0))

    # Name hash (u64)
    buf = buf_concat(buf, u64_to_bytes(hash_name(name)))

    # Symbol type (u8) - Function
    buf = buf_push(buf, 1)

    # Binding (u8) - Global
    buf = buf_push(buf, 1)

    # Visibility (u8)
    buf = buf_push(buf, 0)

    # Flags (u8)
    buf = buf_push(buf, 0)

    # Value (u64)
    buf = buf_concat(buf, u64_to_bytes(value))

    # Size (u64)
    buf = buf_concat(buf, u64_to_bytes(size))

    # Type ID (u32)
    buf = buf_concat(buf, u32_to_bytes(0))

    # Version (u32)
    buf = buf_concat(buf, u32_to_bytes(0))

    # Template param count (u8)
    buf = buf_push(buf, 0)

    # Reserved (3 bytes)
    buf = buf_concat(buf, [0, 0, 0])

    # Template offset (u64)
    buf = buf_concat(buf, u64_to_bytes(0))

    buf

# Serialize generic templates to bytes
#
# Binary format:
# - Header: magic (u32), version (u16), template_count (u32)
# - For each template: kind (u8), serialized AST node
fn serialize_templates(templates: GenericTemplates) -> [u8]:
    var buf: [u8] = []

    # Header
    buf = buf.concat([0x47, 0x54, 0x50, 0x4C])  # "GTPL" magic
    buf = buf_concat(buf, [0x01, 0x00])  # version 1

    val total_count = (templates.functions_len(functions) +
        templates.structs_len(structs) +
        templates.classes_len(classes) +
        templates.enums_len(enums) +
        templates.traits_len(traits))

    buf = buf_concat(buf, u32_to_bytes(total_count))

    # AST serialization framework (Phase 3)
    # Currently writes name + generic param count per template as structural placeholders.
    # Full AST body serialization will be added when the AST serializer is available.

    # Functions
    for func in templates.functions:
        buf = buf_push(buf, 0)  # kind = Function
        buf = buf_concat(buf, serialize_function_placeholder(func))

    # Structs
    for struct_def in templates.structs:
        buf = buf_push(buf, 1)  # kind = Struct
        buf = buf_concat(buf, serialize_struct_placeholder(struct_def))

    # Classes
    for class_def in templates.classes:
        buf = buf_push(buf, 2)  # kind = Class
        buf = buf_concat(buf, serialize_class_placeholder(class_def))

    # Enums
    for enum_def in templates.enums:
        buf = buf_push(buf, 3)  # kind = Enum
        buf = buf_concat(buf, serialize_enum_placeholder(enum_def))

    # Traits
    for trait_def in templates.traits:
        buf = buf_push(buf, 4)  # kind = Trait
        buf = buf_concat(buf, serialize_trait_placeholder(trait_def))

    buf

# Serialize monomorphization metadata to bytes
fn serialize_metadata(metadata: MonomorphizationMetadata) -> [u8]:
    var buf: [u8] = []

    # Header
    buf = buf.concat([0x4D, 0x45, 0x54, 0x41])  # "META" magic
    buf = buf_concat(buf, [0x01, 0x00])  # version 1

    # Count of each category
    buf = buf_concat(buf, u32_to_bytes(metadata.functions.len()))
    buf = buf_concat(buf, u32_to_bytes(metadata.structs.len()))
    buf = buf_concat(buf, u32_to_bytes(metadata.enums.len()))
    buf = buf_concat(buf, u32_to_bytes(metadata.traits.len()))

    # Metadata serialization framework (Phase 3)
    # Currently writes category counts as a structural skeleton.
    # Full per-entry serialization (specialization entries, bindings, mangled names)
    # will be added when the metadata serializer is available.

    # Serialize function metadata entries
    for _item_0 in metadata.functions_items(functions):
        val name = _item_0[0]
        val func_meta = _item_0[1]
        val name_bytes = name_to_bytes(name)
        buf = buf_concat(buf, u32_to_bytes(name_bytes.len()))
        buf = buf_concat(buf, name_bytes)
        buf = buf_concat(buf, u32_to_bytes(func_meta.specializations.len()))

    # Serialize struct metadata entries
    for _item_1 in metadata.structs_items(structs):
        val name = _item_1[0]
        val struct_meta = _item_1[1]
        val name_bytes = name_to_bytes(name)
        buf = buf_concat(buf, u32_to_bytes(name_bytes.len()))
        buf = buf_concat(buf, name_bytes)
        buf = buf_concat(buf, u32_to_bytes(struct_meta.specializations.len()))

    # Serialize enum metadata entries
    for _item_2 in metadata.enums_items(enums):
        val name = _item_2[0]
        val enum_meta = _item_2[1]
        val name_bytes = name_to_bytes(name)
        buf = buf_concat(buf, u32_to_bytes(name_bytes.len()))
        buf = buf_concat(buf, name_bytes)
        buf = buf_concat(buf, u32_to_bytes(enum_meta.specializations.len()))

    # Serialize trait metadata entries
    for _item_3 in metadata.traits_items(traits):
        val name = _item_3[0]
        val trait_meta = _item_3[1]
        val name_bytes = name_to_bytes(name)
        buf = buf_concat(buf, u32_to_bytes(name_bytes.len()))
        buf = buf_concat(buf, name_bytes)
        buf = buf_concat(buf, u32_to_bytes(trait_meta.impl_specializations.len()))

    buf

# Serialize note.sdn metadata to SDN format with terminator
#
# The terminator `\n# END_NOTE\n` allows dynamic size calculation at load time.
fn serialize_note_sdn(note_sdn: NoteSdnMetadata) -> [u8]:
    val sdn_content = note_sdn_to_sdn(note_sdn)
    sdn_content_to_bytes(sdn_content)

# Placeholder serialization functions (Phase 3 TODO)

fn serialize_function_placeholder(func: FunctionDef) -> [u8]:
    var buf: [u8] = []

    val name_bytes = func.name_to_bytes(name)
    buf = buf_concat(buf, u32_to_bytes(name_bytes.len()))
    buf = buf_concat(buf, name_bytes)

    buf = buf_push(buf, func.generic_params.len().to_u8())

    buf

fn serialize_struct_placeholder(struct_def: StructDef) -> [u8]:
    var buf: [u8] = []

    val name_bytes = struct_def.name_to_bytes(name)
    buf = buf_concat(buf, u32_to_bytes(name_bytes.len()))
    buf = buf_concat(buf, name_bytes)

    buf = buf_push(buf, struct_def.generic_params.len().to_u8())

    buf

fn serialize_class_placeholder(class_def: ClassDef) -> [u8]:
    var buf: [u8] = []

    val name_bytes = class_def.name_to_bytes(name)
    buf = buf_concat(buf, u32_to_bytes(name_bytes.len()))
    buf = buf_concat(buf, name_bytes)

    buf = buf_push(buf, class_def.generic_params.len().to_u8())

    buf

fn serialize_enum_placeholder(enum_def: EnumDef) -> [u8]:
    var buf: [u8] = []

    val name_bytes = enum_def.name_to_bytes(name)
    buf = buf_concat(buf, u32_to_bytes(name_bytes.len()))
    buf = buf_concat(buf, name_bytes)

    buf = buf_push(buf, enum_def.generic_params.len().to_u8())

    buf

fn serialize_trait_placeholder(trait_def: TraitDef) -> [u8]:
    var buf: [u8] = []

    val name_bytes = trait_def.name_to_bytes(name)
    buf = buf_concat(buf, u32_to_bytes(name_bytes.len()))
    buf = buf_concat(buf, name_bytes)

    buf = buf_push(buf, trait_def.generic_params.len().to_u8())

    buf

# Build an SMF module with the given code bytes for a specific target architecture
fn build_smf_with_code_for_target(code_bytes: [u8], target: Target) -> [u8]:
    # Delegate to simple SMF builder
    val options = SmfBuildOptions(templates: nil, metadata: nil, note_sdn: nil, target: target)
    build_smf_with_templates_internal(code_bytes, options)

# Helper to convert code bytes to a minimal object format
fn code_bytes_to_object(code: [u8]) -> [u8]:
    # For now, just return the code as-is
    code

# Extract code section from object file
fn extract_code_from_object(object_code: [u8]) -> [u8]:
    # Proper ELF/object parsing not yet implemented
    # Would parse ELF header, find .text section, and extract code bytes
    val _asv_0 = input as raw
    eprint("Warning: ELF/object parsing not yet implemented; treating _asv_0 code bytes")
    object_code

# Binary format helpers

fn u32_to_bytes(value: i32) -> [u8]:
    [
        bitwise_and(value, 0xFF).to_u8(),
        ((bit_shr(value, 8)) & 0xFF).to_u8(),
        ((bit_shr(value, 16)) & 0xFF).to_u8(),
        ((bit_shr(value, 24)) & 0xFF).to_u8()
    ]

fn u64_to_bytes(value: i32) -> [u8]:
    [
        bitwise_and(value, 0xFF).to_u8(),
        ((bit_shr(value, 8)) & 0xFF).to_u8(),
        ((bit_shr(value, 16)) & 0xFF).to_u8(),
        ((bit_shr(value, 24)) & 0xFF).to_u8(),
        0, 0, 0, 0  # High 32 bits (assume value fits in 32 bits for now)
    ]

fn text_to_platform(os: text) -> Platform:
    match os:
        case "linux": Platform.Linux
        case "windows": Platform.Windows
        case "macos": Platform.MacOS
        case "freebsd": Platform.FreeBSD
        case "none": Platform.None_
        case _: Platform.Any

fn text_to_arch(arch: text) -> Arch:
    match arch:
        case "x86_64": Arch.X86_64
        case "aarch64": Arch.Aarch64
        case "x86": Arch.X86
        case "arm": Arch.Arm
        case "riscv64": Arch.Riscv64
        case "riscv32": Arch.Riscv32
        case "wasm32": Arch.Wasm32
        case "wasm64": Arch.Wasm64
        case _: Arch.X86_64

fn hash_name(name: text) -> i32:
    # Simple FNV-1a hash
    var hash = 2166136261
    for byte in name_to_bytes(name):
        hash = hash xor byte_to_i32(byte)
        hash = hash * 16777619
    hash

export generate_smf_with_templates, generate_smf_with_all_sections, generate_smf_with_options
export Target, SmfBuildOptions
export build_smf_with_code_for_target, extract_code_from_object
