# Compilability Analysis
#
# Determines which parts of a program can compile to native code
# versus which require interpreter fallback. Walks AST and identifies
# features the codegen cannot yet handle.
#
# Port of rust/compiler/src/compilability.rs (791 lines)

export FallbackReason, CompilabilityStatus, CompilabilityAnalyzer

# ============================================================================
# Fallback Reasons
# ============================================================================

enum FallbackReason:
    """Why a construct requires interpreter fallback."""
    DynamicTypes
    CollectionOps
    CollectionLiteral
    StringOps
    GcInNogcContext
    BlockingInAsync
    ActorOps
    UserMacros
    PatternMatch
    Closure
    ObjectConstruction
    MethodCall
    FieldAccess
    Generator
    AsyncAwait
    Decorators
    TryOperator
    WithStatement
    ContextBlock
    UnknownExtern(text)
    NotYetImplemented(text)


# ============================================================================
# FallbackReason Methods (was: impl FallbackReason:)
# ============================================================================

# ============================================================================
# Compilability Status
# ============================================================================

enum CompilabilityStatus:
    Compilable
    RequiresInterpreter([FallbackReason])


# ============================================================================
# CompilabilityStatus Methods (was: impl CompilabilityStatus:)
# ============================================================================

# ============================================================================
# Compilability Analyzer
# ============================================================================

class CompilabilityAnalyzer:
    """Analyzes functions for native code compilability."""
    results: {text: CompilabilityStatus}
    known_safe_externs: [text]


# ============================================================================
# CompilabilityAnalyzer Methods (was: impl CompilabilityAnalyzer:)
# ============================================================================

fn compilabilityanalyzer_create() -> CompilabilityAnalyzer:
        CompilabilityAnalyzer(results: {},
            known_safe_externs: [
                "rt_print", "rt_println", "rt_eprintln",
                "rt_hash_sha256", "rt_file_exists", "rt_file_read_text",
                "rt_file_write_text", "rt_file_size", "rt_file_modified",
                "rt_time_now", "rt_env_var", "rt_exit"
            ])


fn compilabilityanalyzer_analyze_function(self: CompilabilityAnalyzer, name: text, features: [text]) -> CompilabilityStatus:
        """Analyze a function by its feature usage list."""
        var reasons: [FallbackReason] = []

        for feat in features:
            match feat:
                case "decorator": reasons = reasons.push(FallbackReason.Decorators)
                case "closure": reasons = reasons.push(FallbackReason.Closure)
                case "lambda": reasons = reasons.push(FallbackReason.Closure)
                case "pattern_match": reasons = reasons.push(FallbackReason.PatternMatch)
                case "generator": reasons = reasons.push(FallbackReason.Generator)
                case "yield": reasons = reasons.push(FallbackReason.Generator)
                case "async": reasons = reasons.push(FallbackReason.AsyncAwait)
                case "await": reasons = reasons.push(FallbackReason.AsyncAwait)
                case "try_operator": reasons = reasons.push(FallbackReason.TryOperator)
                case "with_statement": reasons = reasons.push(FallbackReason.WithStatement)
                case "method_call": reasons = reasons.push(FallbackReason.MethodCall)
                case "field_access": reasons = reasons.push(FallbackReason.FieldAccess)
                case "object_construction": reasons = reasons.push(FallbackReason.ObjectConstruction)
                case "collection_literal": reasons = reasons.push(FallbackReason.CollectionLiteral)
                case "actor": reasons = reasons.push(FallbackReason.ActorOps)
                case "macro": reasons = reasons.push(FallbackReason.UserMacros)
                case _:
                    if feat.starts_with("extern:"):
                        val extern_name = feat[7:]
                        if not self.known_safe_externs_contains(known_safe_externs, extern_name):
                            reasons = reasons_push(reasons, FallbackReason.UnknownExtern(extern_name))

        val status = if has_reasons:
            compilabilitystatus_RequiresInterpreter(reasons)
        else:
            CompilabilityStatus.Compilable

        self.results[name] = status
        status

