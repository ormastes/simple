# Bitfield Compilation
#
# Compiles bitfield type definitions to efficient bit manipulation code.
#
# Syntax:
#   bitfield RegisterName(BackingType):
#       field1: u4         # 4 bits
#       field2: bool       # 1 bit
#       _: u3              # 3 bits reserved/padding
#       field3: MyEnum     # bits inferred from enum size
#
# Features:
# - Automatic bit offset calculation
# - Efficient getter/setter generation
# - Compile-time overflow checking
# - Support for enums (bits inferred)
# - Support for custom types implementing BitLayout

from hir_types import {HirType, SymbolId, HirModule}
from hir_definitions import {HirExpr, HirExprKind}
from lexer import {Span}

export Bitfield, BitfieldField, BitLayout, BitfieldError
export compile_bitfield, validate_bitfield

# Workaround for core3 parser: ~ operator not supported
fn bitwise_not_i64(n: i64) -> i64:
    # Two's complement bitwise NOT: -n - 1
    0 - n - 1

# Bit representation trait (for custom types in bitfields)
struct BitLayout:
    bit_width: i64          # Number of bits needed
    is_signed: bool         # Whether value is signed
    min: i64          # Minimum representable value
    max: i64          # Maximum representable value


# ============================================================================
# BitLayout Methods (was: impl BitLayout:)
# ============================================================================

fn bitlayout_unsigned(bits: i64) -> BitLayout:
        BitLayout(
            bit_width: bits,
            is_signed: false,
            min: 0,
            max: (bit_shl(1, bits)) - 1
        )


fn bitlayout_signed(bits: i64) -> BitLayout:
        val max = bit_shl(1, bits - 1) - 1
        val min = 0 - bit_shl(1, bits - 1)
        BitLayout(
            bit_width: bits,
            is_signed: true,
            min: min,
            max: max
        )


fn bitlayout_bool_repr() -> BitLayout:
        BitLayout(
            bit_width: 1,
            is_signed: false,
            min: 0,
            max: 1
        )


fn bitlayout_enum_repr(num_variants: i64) -> BitLayout:
        val bits = bits_needed(num_variants)
        BitLayout(
            bit_width: bits,
            is_signed: false,
            min: 0,
            max: num_variants - 1
        )


# Calculate bits needed to represent N values
fn bits_needed(n: i64) -> i64:
    if n <= 1:
        return 1
    var bits: i64 = 0
    var value = n - 1
    while value > 0:
        bits = bits + 1
        value = bit_shr(value, 1)
    bits

# Bitfield field definition
struct BitfieldField:
    name: text              # Field name ("_" for reserved/padding)
    type_: HirType          # Field type
    repr: BitLayout           # Bit representation
    bit_offset: i64         # Offset from LSB (computed)
    span: Span


# ============================================================================
# BitfieldField Methods (was: impl BitfieldField:)
# ============================================================================

# Complete bitfield definition
struct Bitfield:
    name: text              # Type name
    backing_type: HirType   # Backing storage type (u8, u16, u32, u64)
    backing_bits: i64       # Total bits in backing type
    fields: [BitfieldField] # Fields in declaration order
    span: Span


# ============================================================================
# Bitfield Methods (was: impl Bitfield:)
# ============================================================================

# Bitfield compilation error
enum BitfieldError:
    OverflowError(bitfield: text, used: i64, available: i64, span: Span)
    InvalidBackingType(type_name: text, span: Span)
    UnknownFieldType(field: text, type_name: text, span: Span)
    DuplicateField(field: text, span: Span)
    InvalidBitWidth(field: text, width: i64, span: Span)


# ============================================================================
# BitfieldError Methods (was: impl BitfieldError:)
# ============================================================================

# Get bit width for a type
fn type_bit_width(type_: HirType) -> has_BitLayout:
    val name = type__to_text(type_)

    # Check for explicit bit-width types (u4, i12, etc.)
    if name.starts_with("u") or name.starts_with("i"):
        val rest = name_substring(name, 1)
        val width = rest_parse_int(rest)
        if has_width:
            val w = width_value
            if w > 0:
                if w <= 64:
                if name.starts_with("i"):
                    return bitlayout_signed(w)
                else:
                    return bitlayout_unsigned(w)

    # Standard types
    match name:
        case "bool": BitLayout.bool_repr()
        case "u8": BitLayout.unsigned(8)
        case "u16": BitLayout.unsigned(16)
        case "u32": BitLayout.unsigned(32)
        case "u64": BitLayout.unsigned(64)
        case "i8": BitLayout.signed(8)
        case "i16": BitLayout.signed(16)
        case "i32": BitLayout.signed(32)
        case "i64": BitLayout.signed(64)
        # case  # DESUGARED: _: nil

# Get backing type bit width
fn backing_type_bits(type_: HirType) -> has_i64:
    val name = type__to_text(type_)
    match name:
        case "u8": 8
        case "u16": 16
        case "u32": 32
        case "u64": 64
        # case  # DESUGARED: _: nil

# Compile a bitfield definition
fn compile_bitfield(
    name: text,
    backing_type: HirType,
    fields: [(text, HirType, Span)],
    span: Span
) -> text:
    # Validate backing type
    val bits = backing_type_bits(backing_type)
    if not has_bits:
        return Err(bitfielderror_InvalidBackingType(backing_type.to_text(), span))

    val backing_bits = bits_value
    var compiled_fields: [BitfieldField] = []
    var current_offset: i64 = 0
    var seen_names: Dict<text, bool> = {}

    # Process fields
    for _item_0 in fields:
        val field_name = _item_0[0]
        val field_type = _item_0[1]
        val field_span = _item_0[2]
        # Check for duplicates (except reserved "_")
        if field_name != "_":
            if seen_names_contains_key(seen_names, field_name):
                return Err(bitfielderror_DuplicateField(field_name, field_span))
            seen_names[field_name] = true

        # Get bit representation
        val repr = type_bit_width(field_type)
        if not has_repr:
            return Err(bitfielderror_UnknownFieldType(field_name, field_type.to_text(), field_span))

        val field_repr = repr_value

        # Validate bit width
        if field_repr.bit_width <= 0 or field_repr.bit_width > 64:
            return Err(bitfielderror_InvalidBitWidth(field_name, field_repr.bit_width, field_span))

        compiled_fields.push(BitfieldField(
            name: field_name,
            type_: field_type,
            repr: field_repr,
            bit_offset: current_offset,
            span: field_span
        ))

        current_offset = current_offset + field_repr.bit_width

    # Check for overflow
    if current_offset > backing_bits:
        return Err(bitfielderror_OverflowError(name, current_offset, backing_bits, span))

    Ok(Bitfield(
        name: name,
        backing_type: backing_type,
        backing_bits: backing_bits,
        fields: compiled_fields,
        span: span
    ))

# Validate a compiled bitfield
fn validate_bitfield(bitfield: Bitfield) -> text:
    if not bitfield_is_valid(bitfield):
        return Err(BitfieldError.OverflowError(
            bitfield.name,
            bitfield_used_bits(bitfield),
            bitfield.backing_bits,
            bitfield.span
        ))
    Ok(())

# Generate getter expression for a field
fn generate_getter(bitfield: Bitfield, field_name: text, value_expr: text) -> text:
    val field = bitfield_get_field(bitfield, field_name)
    if not has_field:
        return nil

    val f = field_value
    val mask = f.repr_mask(repr)
    val shift = f.bit_offset

    # (bit_shr(value, shift)) & mask
\\\\\        to: zzoxzqoo 2b48645a "feat: Complete Track A/B/C - Native backend layout optimization and LLVM backend" (rebase destination)
-    # # if shift == # DESUGARED: 0: Some("({value_expr} & {mask}"))
-    # 0: "({value_expr} & {mask}")
-    pass
+    # if shift == # DESUGARED: 0: Some("({value_expr} & {mask}"))
+            0: "({value_expr} & {mask}")
     # # DESUGARED: else: Some("(({value_expr} >> {shift} & {mask})"))
  
             else: "(({value_expr} >> {shift} & {mask})")

# Generate setter expression for a field
fn generate_setter(bitfield: Bitfield, field_name: text, value_expr: text, new_value: text) -> text:
    val field = bitfield_get_field(bitfield, field_name)
    if not has_field:
        return nil

    val f = field_value
    val mask = f.repr_mask(repr)
    val shift = f.bit_offset
    val clear_mask = bitwise_not_i64(bit_shl(mask, shift))

    # (value & clear_mask) | ((new_value & mask) << shift)
\\\\\        to: zzoxzqoo 2b48645a "feat: Complete Track A/B/C - Native backend layout optimization and LLVM backend" (rebase destination)
-    # # if shift == # DESUGARED: 0: Some("(({value_expr} & {clear_mask} | ({new_value} & {mask}))"))
-    # 0: "(({value_expr} & {clear_mask} | ({new_value} & {mask}))")
-    pass
+    # if shift == # DESUGARED: 0: Some("(({value_expr} & {clear_mask} | ({new_value} & {mask}))"))
+            0: "(({value_expr} & {clear_mask} | ({new_value} & {mask}))")
     # # DESUGARED: else: Some("(({value_expr} & {clear_mask} | (({new_value} & {mask}) << {shift}))"))
  
             else: "(({value_expr} & {clear_mask} | (({new_value} & {mask}) << {shift}))")
