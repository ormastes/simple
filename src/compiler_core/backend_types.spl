# Backend Types - Backend Trait and Value Definitions
#
# This module contains backend type definitions:
# - BackendKind, BackendResult, BackendError: Backend interface types
# - CompiledUnit, CompiledSymbol: Compilation output types
# - SdnValue: SDN (data-only) value representation
# - Value: Runtime value representation
# - Environment: Execution environment for values
#
# Backend implementations are in backend.spl

use compiler.hir.*
use compiler.mir.*
use compiler.lexer.Span

enum BackendKind:
    Cranelift
    Llvm
    Native
    Wasm
    Lean
    Interpreter
    Cuda
    Vulkan

# ============================================================================
# BackendKind Methods
# ============================================================================

fn backendkind_from_text(s: text) -> has_BackendKind:
    """Parse backend name from text.

    Supports:
    - "cranelift", "clif" → Cranelift
    - "llvm" → Llvm
    - "native", "c" → Native
    - "wasm" → Wasm
    - "interpreter", "interp", "i" → Interpreter
    - "auto" → nil (use auto-selection)
    """
    match s:
        case "cranelift": BackendKind.Cranelift
        case "clif": BackendKind.Cranelift
        case "llvm": BackendKind.Llvm
        case "native": BackendKind.Native
        case "c": BackendKind.Native
        case "wasm": BackendKind.Wasm
        case "interpreter": BackendKind.Interpreter
        case "interp": BackendKind.Interpreter
        case "i": BackendKind.Interpreter
        case "lean": BackendKind.Lean
        case "cuda": BackendKind.Cuda
        case "vulkan": BackendKind.Vulkan
        case "auto": nil
        case _: nil

fn backendkind_to_text(kind: BackendKind) -> text:
    """Convert backend kind to string."""
    match kind:
        case Cranelift: "cranelift"
        case Llvm: "llvm"
        case Native: "native"
        case Wasm: "wasm"
        case Lean: "lean"
        case Interpreter: "interpreter"
        case Cuda: "cuda"
        case Vulkan: "vulkan"

# ============================================================================
# Backend Results and Errors
# ============================================================================

"""Result of backend processing."""
enum BackendResult:
    Value(value: Value)
    CompiledUnit(unit: CompiledUnit)
    SdnData(data: SdnValue)
    Unit

struct BackendError:
    """Error during backend processing."""
    message: text
    # # DESUGARED: span: Span
    has_span: bool
    span: Span
    kind: BackendErrorKind

"""Backend error kind."""
enum BackendErrorKind:
    NotAllowed          # Operation not allowed (SDN mode)
    TypeError           # Type mismatch
    RuntimeError        # Runtime error
    CompileError        # Compilation error
    NotImplemented      # Feature not implemented
    Internal            # Internal error


# ============================================================================
# BackendError Methods (was: impl BackendError:)
# ============================================================================

fn backenderror_not_allowed(message: text, span: Span?) -> i64:
        # Stub: Option fields and struct return not fully supported in seed_cpp
        0


fn backenderror_type_error(message: text, span: Span?) -> i64:
        # Stub: Option fields and struct return not fully supported in seed_cpp
        0


fn backenderror_runtime_error(message: text, span: Span?) -> i64:
        # Stub: Option fields and struct return not fully supported in seed_cpp
        0


fn backenderror_compile_error(message: text, span: Span?) -> i64:
        # Stub: Option fields and struct return not fully supported in seed_cpp
        0


fn backenderror_not_implemented(message: text) -> i64:
        # Stub: Option fields and struct return not fully supported in seed_cpp
        0


fn backenderror_internal(message: text) -> i64:
        # Stub: Option fields and struct return not fully supported in seed_cpp
        0


# ============================================================================
# Compiled Unit (for Compiler Backend)
# ============================================================================

struct CompiledUnit:
    """Result of compilation."""
    name: text
    code: [u8]
    symbols: Dict<text, CompiledSymbol>
    # # DESUGARED: entry_point: text
    has_entry_point: bool
    entry_point: text
    relocations: [Relocation]

struct CompiledSymbol:
    """Symbol in compiled unit."""
    name: text
    address: i64
    size: i64
    kind: CompiledSymbolKind

enum CompiledSymbolKind:
    Function
    Data
    External

struct Relocation:
    """Relocation entry."""
    offset: i64
    symbol: text
    kind: RelocKind

enum RelocKind:
    Absolute
    Relative
    PltRelative

# ============================================================================
# SDN Value (for SDN Backend)
# ============================================================================

struct SdnValue:
    """Data-only value from SDN parsing."""
    kind: SdnValueKind

"""SDN value kind."""
enum SdnValueKind:
    Nil
    Bool(value: bool)
    Int(value: i64)
    Float(value: f64)
    String(value: text)
    Array(elements: [SdnValue])
    Dict(entries: Dict<text, SdnValue>)
    Table(headers: [text], rows: [[SdnValue]])


# ============================================================================
# SdnValue Methods (was: impl SdnValue:)
# ============================================================================

fn sdnvalue_make_nil() -> SdnValue:
        SdnValue(kind: SdnValueKind.Nil)


fn sdnvalue_bool(value: bool) -> SdnValue:
        # Stub: Enum variant construction with data not supported in seed_cpp
        SdnValue(kind: SdnValueKind.Nil)


fn sdnvalue_int(value: i64) -> SdnValue:
        # Stub: Enum variant construction with data not supported in seed_cpp
        SdnValue(kind: SdnValueKind.Nil)


fn sdnvalue_float(value: f64) -> SdnValue:
        # Stub: Enum variant construction with data not supported in seed_cpp
        SdnValue(kind: SdnValueKind.Nil)


fn sdnvalue_string(value: text) -> SdnValue:
        # Stub: Enum variant construction with data not supported in seed_cpp
        SdnValue(kind: SdnValueKind.Nil)


fn sdnvalue_array(elements: [SdnValue]) -> SdnValue:
        # Stub: Enum variant construction with data not supported in seed_cpp
        SdnValue(kind: SdnValueKind.Nil)


fn sdnvalue_dict(entries: Dict<text, SdnValue>) -> SdnValue:
        # Stub: Enum variant construction with data not supported in seed_cpp
        SdnValue(kind: SdnValueKind.Nil)


fn sdnvalue_table(headers: [text], rows: [[SdnValue]]) -> SdnValue:
        # Stub: Enum variant construction with data not supported in seed_cpp
        SdnValue(kind: SdnValueKind.Nil)


# ============================================================================
# Runtime Value (for Interpreter Backend)
# ============================================================================

"""Runtime value for interpreter."""
enum Value:
    Nil
    Unit
    Bool(value: bool)
    Int(value: i64)
    Float(value: f64)
    Char(value: char)
    String(value: text)
    Array(elements: [Value])
    Tuple(elements: [Value])
    Dict(entries: Dict<text, Value>)
    Struct(type_: text, fields: Dict<text, Value>)
    Enum(type_: text, variant: text, payload: EnumPayloadValue?)
    Function(fn_: FunctionValue)
    Closure(closure: ClosureValue)
    Object(obj: ObjectValue)
    Ref(target: Value, mutable: bool)
    Option(value: Value?)
    Result(ok: Value, err: Value?)
    TraitType(trait_name: text)
    # NEW: FFI-backed RuntimeValue pointer
    RuntimeValue(ptr: i64)  # Opaque pointer to Rust RuntimeValue

enum EnumPayloadValue:
    Tuple(values: [Value])
    Struct(fields: Dict<text, Value>)

struct FunctionValue:
    """Function value."""
    symbol: SymbolId
    name: text

struct ClosureValue:
    """Closure value with captured environment."""
    params: [HirParam]
    body: HirExpr
    captures: Dict<SymbolId, Value>

struct ObjectValue:
    """Object instance."""
    class_: SymbolId
    fields: Dict<text, Value>


# ============================================================================
# Value Methods (was: impl Value:)
# ============================================================================

fn value_make_nil() -> Value:
        Value.Nil


fn value_bool(value: bool) -> Value:
        value_bool(value)


fn value_int(value: i64) -> Value:
        value_int(value)


fn value_float(value: f64) -> Value:
        value_float(value)


fn value_string(value: text) -> Value:
        value_string(value)


fn value_some(value: Value) -> Value:
        # Stub: Enum variant construction with data not supported in seed_cpp
        Value.Nil


fn value_none() -> Value:
        # Stub: Enum variant construction with data not supported in seed_cpp
        Value.Nil


fn value_ok(value: Value) -> Value:
        # Stub: Enum variant construction with data not supported in seed_cpp
        Value.Nil


fn value_err(value: Value) -> Value:
        # Stub: Enum variant construction with data not supported in seed_cpp
        Value.Nil


# ============================================================================
# Evaluation Context
# ============================================================================


# ============================================================================
# Exports
# ============================================================================

export BackendKind, BackendResult, BackendError, BackendErrorKind
export CompiledUnit, CompiledSymbol, CompiledSymbolKind
export Relocation, RelocKind
export SdnValue, SdnValueKind
export Value, EnumPayloadValue, FunctionValue, ClosureValue, ObjectValue
export EvalContext, Environment
