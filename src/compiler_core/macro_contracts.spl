# Macro Contract Processing
#
# Processes macro contracts: intro (symbol introduction), inject (code injection),
# and returns (return type declaration). Enables IDE autocomplete without expansion.
#
# Port of rust/compiler/src/macro_contracts.rs (535 lines)

export MacroContractResult, MacroAnchor, MacroIntroKind
export process_macro_contract

# ============================================================================
# Types
# ============================================================================

enum MacroAnchor:
    """Where injected code is placed."""
    Head        # Before any statements
    Tail        # After all statements
    Here        # At the callsite

enum MacroIntroKind:
    """Kind of symbol introduced by a macro."""
    Function
    Class
    TypeAlias
    Field
    Variable

struct IntroducedSymbol:
    name: text
    kind: MacroIntroKind
    # DESUGARED: type_annotation: text?
    has_type_annotation: bool
    type_annotation_value: text
    is_const: bool

struct InjectionSpec:
    anchor: MacroAnchor
    # DESUGARED: label: text?
    has_label: bool
    label_value: text

# ============================================================================
# Contract Result
# ============================================================================

struct MacroContractResult:
    """Result of processing macro contract items."""
    introduced_functions: {text: Any}
    introduced_classes: {text: Any}
    introduced_types: {text: text}
    introduced_fields: [IntroducedSymbol]
    introduced_vars: [(text, text, bool)]   # (name, type, is_const)
    injections: {text: [Any]}               # anchor_name -> blocks
    inject_labels: {text: MacroAnchor}
    intro_function_labels: {text: text}     # label -> public name
    # DESUGARED: return_type: text?
    has_return_type: bool
    return_type_value: text
    # DESUGARED: return_label: text?
    has_return_label: bool
    return_label_value: text


# ============================================================================
# MacroContractResult Methods (was: impl MacroContractResult:)
# ============================================================================

fn macrocontractresult_empty() -> MacroContractResult:
        MacroContractResult(
            introduced_functions: {}, introduced_classes: {},
            introduced_types: {}, introduced_fields: [],
            introduced_vars: [], injections: {},
            inject_labels: {}, intro_function_labels: {},
            return_type: nil, return_label: nil)


# ============================================================================
# Contract Processing
# ============================================================================

fn process_macro_contract(contract_items: [MacroContractItem],
                          const_bindings: {text: text},
                          existing_symbols: SymbolScope) -> Result<MacroContractResult, text>:
    """Process all contract items in a macro definition."""
    var result = macrocontractresult_empty()
    var introduced_names: [text] = []

    for item in contract_items:
        match item.kind:
            case "returns":
                if item.has_type_name:
                    result = MacroContractResult(
                        introduced_functions: result.introduced_functions,
                        introduced_classes: result.introduced_classes,
                        introduced_types: result.introduced_types,
                        introduced_fields: result.introduced_fields,
                        introduced_vars: result.introduced_vars,
                        injections: result.injections,
                        inject_labels: result.inject_labels,
                        intro_function_labels: result.intro_function_labels,
                        return_type: item.type_name,
                        return_label: item.label)
            case "intro":
                # Check for shadowing
                if item.name.? and existing_symbols_contains(existing_symbols, item.name_value):
                    return Err("macro intro '{item.name_value}' shadows existing symbol")
                if item.name.? and introduced_names_contains(introduced_names, item.name_value):
                    return Err("macro intro '{item.name_value}' already introduced")
                if item.has_name:
                    introduced_names = introduced_names_push(introduced_names, item.name_value)
            case "inject":
                if item.anchor.? and item.has_label:
                    val anchor = match item.anchor_value:
                        case "head": MacroAnchor.Head
                        case "tail": MacroAnchor.Tail
                        case _: MacroAnchor.Here
                    result = MacroContractResult(
                        introduced_functions: result.introduced_functions,
                        introduced_classes: result.introduced_classes,
                        introduced_types: result.introduced_types,
                        introduced_fields: result.introduced_fields,
                        introduced_vars: result.introduced_vars,
                        injections: result.injections,
                        inject_labels: result.inject_labels,
                        intro_function_labels: result.intro_function_labels,
                        return_type: result.return_type,
                        return_label: result.return_label)
            case _: ()

    Ok(result)

# ============================================================================
# Support Types
# ============================================================================

struct MacroContractItem:
    kind: text          # "returns", "intro", "inject"
    # DESUGARED: name: text?
    has_name: bool
    name_value: text
    # DESUGARED: type_name: text?
    has_type_name: bool
    type_name_value: text
    # DESUGARED: label: text?
    has_label: bool
    label_value: text
    # DESUGARED: anchor: text?
    has_anchor: bool
    anchor_value: text

struct SymbolScope:
    functions: [text]
    classes: [text]
    variables: [text]
    types: [text]


# ============================================================================
# SymbolScope Methods (was: impl SymbolScope:)
# ============================================================================

fn symbolscope_empty() -> SymbolScope:
        SymbolScope(functions: [], classes: [], variables: [], types: [])

