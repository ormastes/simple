# Core Simple â€” Closure Variable Capture Analysis
#
# Detects when closures modify outer variables, which is a known
# runtime limitation. Emits helpful warnings with workarounds.
#
# Known limitation: Closures can READ outer vars but CANNOT MODIFY them.
# Changes made inside nested functions don't persist to outer scope.
#
# Example problem:
#   var count = 0
#   fn increment(): count = count + 1
#   increment()
#   print count  # Prints 0, not 1!

use compiler_core.ast.{DECL_FN, STMT_VAR_DECL, STMT_ASSIGN, EXPR_ASSIGN}
use compiler_core.ast.{EXPR_IDENT, EXPR_COMPOUND_ASSIGN}
use compiler_core.ast.{decl_count, decl_get_tag, decl_get_name, decl_get_param_names, decl_get_body}
use compiler_core.ast.{stmt_get_tag, stmt_get_name, stmt_get_expr, stmt_get_body}
use compiler_core.ast.{expr_get_tag, expr_get_str, expr_get_left, expr_get_right, expr_get_extra}
use compiler_core.ast.{expr_get_args, expr_get_stmts}

# Warning messages collected during analysis
var closure_warnings: [text] = []

fn closure_warnings_clear():
    closure_warnings = []

fn closure_warnings_get() -> [text]:
    closure_warnings

fn closure_warnings_has() -> bool:
    closure_warnings.len() > 0

# ===== Scope Tracking =====
# Track variable declarations and their scope depth
# scope_vars[scope_depth] = list of var names declared at that depth
# var_depth_map: Dict for O(1) lookup of variable name -> scope depth

var scope_depth: i64 = 0
var scope_vars: [[text]] = []
var var_depth_map = {}

fn scope_enter():
    scope_vars.push([])
    scope_depth = scope_depth + 1

fn scope_exit():
    if scope_depth > 0:
        # Remove vars declared in the exiting scope from the depth map
        val idx = scope_vars.len() - 1
        val exiting_vars = scope_vars[idx]
        for var_name in exiting_vars:
            var_depth_map[var_name] = -1
        scope_depth = scope_depth - 1
        # O(1) slice instead of O(n) array reconstruction
        scope_vars = scope_vars[0:scope_vars.len() - 1]

fn scope_add_var(name: text):
    if scope_vars.len() > 0:
        var idx = scope_vars.len() - 1
        var current_scope = scope_vars[idx]
        current_scope.push(name)
        scope_vars[idx] = current_scope
        var_depth_map[name] = idx

fn scope_find_var_depth(name: text) -> i64:
    # O(1) lookup via Dict instead of nested scope x vars iteration
    if var_depth_map.contains_key(name):
        val depth = var_depth_map[name]
        if depth >= 0:
            return depth
    return -1

fn scope_is_outer_var(name: text) -> bool:
    # Check if variable is declared in an outer scope
    val depth = scope_find_var_depth(name)
    if depth < 0:
        return false
    # Current scope is at scope_vars.len() - 1
    # If var is declared at a smaller index, it's outer
    return depth < (scope_vars.len() - 1)

# ===== AST Analysis =====

fn analyze_closure_capture():
    # Entry point: analyze all functions in the AST
    closure_warnings_clear()
    scope_depth = 0
    scope_vars = []
    var_depth_map = {}

    # Module-level scope
    scope_enter()

    # Analyze all declarations
    for decl_idx in range(0, decl_count()):
        val tag = decl_get_tag(decl_idx)
        if tag == DECL_FN:
            analyze_function_decl(decl_idx)

fn analyze_function_decl(decl_idx: i64):
    val fn_name = decl_get_name(decl_idx)
    val param_names = decl_get_param_names(decl_idx)
    val body_stmts = decl_get_body(decl_idx)

    # Enter function scope
    scope_enter()

    # Add parameters to current scope
    for param_name in param_names:
        scope_add_var(param_name)

    # Analyze function body
    for stmt_idx in body_stmts:
        analyze_stmt(stmt_idx, fn_name)

    scope_exit()

fn analyze_stmt(stmt_idx: i64, containing_fn: text):
    val tag = stmt_get_tag(stmt_idx)
    val name = stmt_get_name(stmt_idx)
    val expr_idx = stmt_get_expr(stmt_idx)
    val body = stmt_get_body(stmt_idx)

    # Track var declarations
    if tag == STMT_VAR_DECL:
        scope_add_var(name)

    # Check assignments
    if tag == STMT_ASSIGN:
        if expr_idx >= 0:
            analyze_expr_for_capture(expr_idx, containing_fn)

    # Analyze nested statements in body
    for nested_stmt_idx in body:
        analyze_stmt(nested_stmt_idx, containing_fn)

fn analyze_expr_for_capture(expr_idx: i64, containing_fn: text):
    val tag = expr_get_tag(expr_idx)
    val left = expr_get_left(expr_idx)
    val right = expr_get_right(expr_idx)
    val extra = expr_get_extra(expr_idx)
    val args = expr_get_args(expr_idx)
    val stmts = expr_get_stmts(expr_idx)

    # Check for assignment expressions
    if tag == EXPR_ASSIGN:
        # Left side should be an identifier
        if left >= 0:
            val left_tag = expr_get_tag(left)
            if left_tag == EXPR_IDENT:
                val var_name = expr_get_str(left)
                if scope_is_outer_var(var_name):
                    emit_closure_warning(var_name, containing_fn)

    if tag == EXPR_COMPOUND_ASSIGN:
        # Left side should be an identifier
        if left >= 0:
            val left_tag = expr_get_tag(left)
            if left_tag == EXPR_IDENT:
                val var_name = expr_get_str(left)
                if scope_is_outer_var(var_name):
                    emit_closure_warning(var_name, containing_fn)

    # Recursively analyze child expressions
    if left >= 0:
        analyze_expr_for_capture(left, containing_fn)
    if right >= 0:
        analyze_expr_for_capture(right, containing_fn)
    if extra >= 0:
        analyze_expr_for_capture(extra, containing_fn)

    for arg_idx in args:
        analyze_expr_for_capture(arg_idx, containing_fn)

    # Analyze statements in expression (for blocks, lambdas, etc.)
    for stmt_idx in stmts:
        analyze_stmt(stmt_idx, containing_fn)

fn emit_closure_warning(var_name: text, fn_name: text):
    val msg1 = "WARN: Closure in '" + fn_name + "' modifies outer variable '" + var_name + "'"
    val msg2 = "      Changes won't persist - use return value or class state instead"
    closure_warnings.push(msg1)
    closure_warnings.push(msg2)

# ===== Exports =====

export analyze_closure_capture
export closure_warnings_get, closure_warnings_has, closure_warnings_clear
export scope_enter, scope_exit, scope_add_var
