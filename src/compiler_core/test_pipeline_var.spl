# Test: Variable declaration debugging

extern fn rt_process_run(cmd: text, args: [text]) -> (text, text, i64)

use compiler.test_common.*
use compiler.hir_lowering.*
use compiler.mir_lowering.*
use compiler.mir_data.*
use std.text.{NL}

val source = "fn main():{NL}    var total = 0{NL}    var i = 0{NL}    while i < 3:{NL}        var j = 0{NL}        while j < 4:{NL}            total = total + 1{NL}            j = j + 1{NL}        i = i + 1{NL}    total{NL}"
print "Source: {source}"

var parser = parser_new(source)
val ast_module = parser_parse(parser)
print "Parse errors: {parser.errors.len()}"

# Print AST
for name in ast_module.functions_keys(functions):
    val fn_ = ast_module.functions[name]
    print "AST fn: {fn_.name}"
    for stmt in fn_.body.stmts:
        print "  stmt kind: {stmt.kind}"

# HIR
print "HIR lowering..."
var hir_lowering = hirlowering_new()
val hir_module = hir_lowering_lower_module(hir_lowering, ast_module)
print "HIR: done, functions: {hir_module.functions.len()}"

for key in hir_module.functions_keys(functions):
    val fn_ = hir_module.functions[key]
    print "  HIR fn: {fn_.name}"
    for stmt in fn_.body.stmts:
        print "    stmt: {stmt.kind}"
    if fn_.body.has_value:
        print "  body value: {fn_.body.value_value.kind}"

# MIR
print "MIR lowering..."
var mir_ctx = mirlowering_new(hir_lowering.symbols)
val mir_module = mir_ctx_lower_module(mir_ctx, hir_module)
print "MIR: done"

for key in mir_module.functions_keys(functions):
    val fn_ = mir_module.functions[key]
    print "  MIR fn: {fn_.name}"
    for blk in fn_.blocks:
        print "    block {blk.id.id}: {blk.instructions.len()} insts"
        for inst in blk.instructions:
            print "      {inst.kind}"
        print "      term: {blk.terminator}"

print "Done!"
