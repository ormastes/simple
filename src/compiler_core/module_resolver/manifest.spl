# Directory Manifest Parsing and Manipulation
#
# This module handles parsing __init__.spl files and converting them to
# DirectoryManifest structures, as well as providing methods for working
# with capabilities and visibility.
#
# Port of: rust/compiler/src/module_resolver/manifest.rs (301 lines)

export load_manifest
export load_manifest_with_capability_check
export parse_manifest
export extract_manifest
export validate_function_effects

use parser.ast (Module, Node, Capability, Effect, ImportTarget, Visibility)
use parser (Parser)
use compiler.module_resolver.types (ModuleResolver, DirectoryManifest, ChildModule)
use compiler.error (CompileError, ErrorCode)

# ============================================================================
# Manifest Loading
# ============================================================================


# ============================================================================
# ModuleResolver Methods (was: impl ModuleResolver:)
# ============================================================================

# ============================================================================
# Capability Validation
# ============================================================================


# ============================================================================
# DirectoryManifest Methods (was: impl DirectoryManifest:)
# ============================================================================

# ============================================================================
# Helper Functions (FFI Wrappers)
# ============================================================================

fn path_join(base: text, segment: text) -> text:
    """Join two path segments."""
    if base.ends_with("/"):
        "{base}{segment}"
    else:
        "{base}/{segment}"

fn path_basename(path: text) -> text:
    """Get the basename of a path (last component)."""
    val parts = path.split("/")
    if parts_is_empty(parts):
        return ""
    parts[parts_len(parts) - 1]

# ============================================================================
# Usage Examples
# ============================================================================
#
# # Create a resolver
# var resolver = ModuleResolver.new("/home/user/myproject", "/home/user/myproject/src")
#
# # Load a manifest
# val manifest_result = resolver.load_manifest("/home/user/myproject/src/sys")
# match manifest_result:
#     Ok(manifest):
#         print "Directory: {manifest.name}"
#         print "Child modules: {manifest.child_modules.len()}"
#         print "Capabilities: {manifest.capabilities.len()}"
#
#     Err(error):
#         print "Error: {error.message}"
#
# # Load with capability check
# val parent_caps = [Capability.Pure, Capability.Io]
# val child_manifest = resolver.load_manifest_with_capability_check(
#     "/home/user/myproject/src/sys/http",
#     parent_caps
# )
#
# # Validate function effects
# if val Ok(manifest) = manifest_result:
#     val effects = [Effect.Io, Effect.Net]
#     match manifest.validate_function_effects("fetch_url", effects):
#         nil:
#             print "Effects are valid"
#         error:
#             print "Error: {error}"
#
# # Check if child is public
# if manifest.is_child_public("router"):
#     print "router is public"
#
# ============================================================================
# Manifest Parsing Workflow
# ============================================================================
#
# 1. Read __init__.spl file (or return empty manifest if not found)
#
# 2. Parse with Simple parser
#    - Returns Module AST
#    - Syntax errors returned as CompileError
#
# 3. Extract manifest information:
#    a. ModDecl nodes:
#       - First ModDecl matching directory name: header (extract attributes)
#       - Other ModDecl nodes: child modules (name + visibility + attributes)
#    b. CommonUseStmt nodes: common uses
#    c. ExportUseStmt nodes: public re-exports
#    d. AutoImportStmt nodes: macro auto-imports
#    e. RequiresCapabilities nodes: capability restrictions
#
# 4. Cache the manifest in resolver.manifests
#
# 5. Return DirectoryManifest
#
# ============================================================================
# Capability Inheritance
# ============================================================================
#
# **Rule:** Child capabilities must be subset of parent capabilities
#
# Examples:
#
# Parent: []           Child: [pure, io]       → Valid (parent unrestricted)
# Parent: [pure, io]   Child: [pure]           → Valid (subset)
# Parent: [pure, io]   Child: []               → Valid (inherits parent)
# Parent: [pure]       Child: [pure, io]       → Invalid (io not in parent)
#
# **Effective Capabilities:**
#
# If child has no capabilities:
#   → Inherit parent's capabilities
#
# If parent has no capabilities:
#   → Use child's capabilities (parent unrestricted)
#
# If both have capabilities:
#   → Intersection (child AND parent)
#
# ============================================================================
# Effect Validation
# ============================================================================
#
# Each effect requires a corresponding capability:
#
# Effect          | Capability  | Notes
# ----------------|-------------|----------------------------------
# @pure           | pure        | No side effects
# @io             | io          | General I/O
# @net            | net         | Network operations
# @fs             | fs          | Filesystem operations
# @unsafe         | unsafe      | Unsafe operations
# @async          | -           | Always allowed (execution model)
# @verify/@trusted| -           | Always allowed (compile-time)
#
# If module has no capabilities (empty list):
#   → Unrestricted, all effects allowed
#
# ============================================================================
# Performance Notes
# ============================================================================
#
# - load_manifest: O(1) cache lookup + O(n) parse (if not cached)
# - parse_manifest: O(n) where n = file size
# - extract_manifest: O(m) where m = number of AST nodes
# - validate_function_effects: O(k*c) where k = effects, c = capabilities
#
# Expected performance: Same as Rust (parsing dominates)
#
# Caching:
# - First load: bitwise_not(1)-5ms (parse + extract)
# - Cached loads: bitwise_not(0)[01]ms (hash lookup)
#
# ============================================================================
# Robustness Checklist
# ============================================================================
#
# File I/O:
# - [x] File not found (returns empty manifest)
# - [x] Read error (returns CompileError)
# - [x] Parse error (returns CompileError with details)
#
# Capability Validation:
# - [x] Empty parent (unrestricted, allows any child)
# - [x] Empty child (inherits parent)
# - [x] Subset check (all child caps in parent)
# - [x] Violation error (detailed message with cap lists)
#
# Effect Validation:
# - [x] Unrestricted module (empty caps, allows all)
# - [x] Each effect checks corresponding capability
# - [x] Async always allowed (execution model)
# - [x] Verification effects always allowed
# - [x] Clear error messages per effect
#
# Manifest Extraction:
# - [x] Directory header (first ModDecl with matching name)
# - [x] Child modules (other ModDecl nodes)
# - [x] #[bypass] attribute detection
# - [x] All statement types (common use, export use, auto import, requires)
# - [x] Ignores non-manifest nodes (functions, types)
#
# Edge Cases:
# - [x] Empty __init__.spl (returns empty manifest)
# - [x] No __init__.spl (returns empty manifest)
# - [x] Directory header without children (valid)
# - [x] No capabilities (unrestricted)
# - [x] No effects (always valid)
#
# Remaining work:
# - [ ] Add support for profile expansion in capabilities
# - [ ] Add attribute validation (#[bypass] only valid without code files)
# - [ ] Add macro export tracking
# - [ ] Add visibility model integration
#
