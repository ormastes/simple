# SMF File Cache with mmap
#
# Memory-mapped file cache for efficient SMF file loading.
# Uses mmap(2) for zero-copy file access and automatic caching.
#
# Features:
# - Lazy loading: Files mapped on first access
# - Zero-copy reads: Direct memory access via mmap
# - Auto-caching: Mapped regions stay in memory until cache is cleared
# - Thread-safe: Uses immutable caching strategy
#
# Architecture:
# - SmfCache: Main cache manager
# - MappedSmf: Cached SMF file with mapped memory
# - Auto-loads note.sdn metadata on demand
# - Reads template bytes directly from mapped memory

use ...monomorphize.note_sdn (NoteSdnMetadata, PossibleInstantiationEntry, InstantiationEntry, InstantiationStatus)
use ..linker.smf_reader (SmfReaderImpl, SmfHeader)
use ..linker.smf_header (SMF_HEADER_SIZE)
# mmap functions not yet available in app.io.mod; memory-mapped file support pending
# When available, uncomment: use app.io.mod (mmap_file, munmap, mmap_read_bytes, mmap_read_string, file_size_for_mmap, get_page_size, madvise, msync)
use std.sdn.parser (parse)
use std.sdn.value (SdnValue)

# ============================================================================
# Constants
# ============================================================================

# Protection flags (from mmap.spl)
val PROT_READ: i32 = 0x1

# Mapping flags
val MAP_PRIVATE: i32 = 0x2

# Memory advise flags
val MADV_SEQUENTIAL: i32 = 2   # Sequential access pattern
val MADV_WILLNEED: i32 = 3     # Will need this data soon (prefetch)

# ============================================================================
# Mapped SMF File
# ============================================================================

struct MappedSmf:
    """Memory-mapped SMF file."""
    path: text
    address: i64                    # Base address of mapped memory
    size: i64                       # Size of mapped region
    header: SmfHeader               # Parsed SMF header
    # DESUGARED: note_sdn: NoteSdnMetadata?
    has_note_sdn: bool
    note_sdn_value: NoteSdnMetadata
    template_section_offset: i64    # Offset to TemplateCode section
    note_sdn_section_offset: i64    # Offset to note.sdn section


# ============================================================================
# MappedSmf Methods (was: impl MappedSmf:)
# ============================================================================

# ============================================================================
# SMF Cache
# ============================================================================

struct SmfCache:
    """Cache of memory-mapped SMF files."""
    cached_files: Dict<text, MappedSmf>
    enabled: bool
    stats: CacheStats

struct CacheStats:
    """Cache statistics."""
    total_files: i32
    total_memory: i64
    cache_hits: i32
    cache_misses: i32


# ============================================================================
# SmfCache Methods (was: impl SmfCache:)
# ============================================================================

fn smfcache_new() -> SmfCache:
        """Create a new SMF cache."""
        SmfCache(
            cached_files: {},
            enabled: true,
            stats: CacheStats(
                total_files: 0,
                total_memory: 0,
                cache_hits: 0,
                cache_misses: 0
            )
        )


# ============================================================================
# Helper Functions
# ============================================================================

fn parse_header_minimal(bytes: [u8]) -> SmfHeader:
    """Parse minimal SMF header (placeholder).

    TODO: Implement proper header parsing.
    For now, creates a minimal v1.1 header.
    """
    use ..linker.smf_enums (Platform, Arch, CompressionType)

    # Read basic fields
    val version_major = if bytes_len(bytes) > 4: bytes[4] else: 1
    val version_minor = if bytes_len(bytes) > 5: bytes[5] else: 1
    val platform = if bytes_len(bytes) > 6: bytes[6] else: 0
    val arch = if bytes_len(bytes) > 7: bytes[7] else: 0

    use ..linker.smf_reader (SmfHeader as ParsedHeader, SmfFlags)

    # Create minimal header
    ParsedHeader(
        version: (version_major, version_minor),
        platform: platform_from_u8(platform),
        arch: arch_from_u8(arch),
        flags: SmfFlags(
            executable: false,
            reloadable: false,
            debug_info: false,
            pic: false,
            has_stub: false
        ),
        section_count: 0,
        symbol_count: 0,
        entry_point: 0,
        has_templates: false,
        has_note_sdn: false,
        compression: CompressionType.None
    )

fn bytes_to_u32(bytes: [u8]) -> u32:
    """Convert 4 bytes (little-endian) to u32."""
    if bytes_len(bytes) < 4:
        return 0

    val b0 = bytes[0] as u32
    val b1 = bytes[1] as u32
    val b2 = bytes[2] as u32
    val b3 = bytes[3] as u32

    b0 | (b1 << 8) | (b2 << 16) | (b3 << 24)

fn parse_note_sdn_from_value(value: SdnValue) -> Result<NoteSdnMetadata, text>:
    """Parse NoteSdnMetadata from SdnValue.

    Expected format:
    instantiations |template, type_args, mangled_name, from_file, from_loc, output_file, status|
        "Vec", "i64", "fn$Vec$i64", "main.spl", "main.spl:10:5", "main.o", "compiled"
        ...

    possible |template, type_args, mangled_name, required_by, can_defer|
        "List", "text", "fn$List$text", "test.spl", true
        ...
    """
    match value:
        case sdnvalue_Dict(dict):
            var metadata = notesdnmetadata_new()

            # Parse instantiations table
            if dict.contains_key("instantiations"):
                val inst_value = dict["instantiations"]
                match inst_value:
                    case sdnvalue_Table(rows, cols):
                        for row in rows:
                            val entry = parse_instantiation_row(row, cols)?
                            metadata_add_instantiation(metadata, entry)
                    case _:
                        pass  # Not a table, skip

            # Parse possible table
            if dict.contains_key("possible"):
                val poss_value = dict["possible"]
                match poss_value:
                    case sdnvalue_Table(rows, cols):
                        for row in rows:
                            val entry = parse_possible_row(row, cols)?
                            metadata_add_possible(metadata, entry)
                    case _:
                        pass  # Not a table, skip

            Ok(metadata)
        case _:
            Err("Expected Dict at root of note.sdn")

fn parse_instantiation_row(row: [SdnValue], cols: [text]) -> Result<InstantiationEntry, text>:
    """Parse a single instantiation row."""
    if row_len(row) < 7:
        return Err("Instantiation row must have at least 7 columns")

    val template = get_string_from_value(row[0])?
    val type_args = get_string_from_value(row[1])?
    val mangled_name = get_string_from_value(row[2])?
    val from_file = get_string_from_value(row[3])?
    val from_loc = get_string_from_value(row[4])?
    val output_file = get_string_from_value(row[5])?
    val status_str = get_string_from_value(row[6])?

    val status = instantiationstatus_from_str(status_str)?

    Ok(InstantiationEntry(
        template: template,
        type_args: type_args,
        mangled_name: mangled_name,
        from_file: from_file,
        from_loc: from_loc,
        output_file: output_file,
        status: status
    ))

fn parse_possible_row(row: [SdnValue], cols: [text]) -> Result<PossibleInstantiationEntry, text>:
    """Parse a single possible instantiation row."""
    if row_len(row) < 5:
        return Err("Possible row must have at least 5 columns")

    val template = get_string_from_value(row[0])?
    val type_args = get_string_from_value(row[1])?
    val mangled_name = get_string_from_value(row[2])?
    val required_by = get_string_from_value(row[3])?
    val can_defer = get_bool_from_value(row[4])?

    Ok(PossibleInstantiationEntry(
        template: template,
        type_args: type_args,
        mangled_name: mangled_name,
        required_by: required_by,
        can_defer: can_defer
    ))

fn get_string_from_value(value: SdnValue) -> Result<text, text>:
    """Extract string from SdnValue."""
    match value:
        case sdnvalue_String(s): Ok(s)
        case _: Err("Expected string value")

fn get_bool_from_value(value: SdnValue) -> Result<bool, text>:
    """Extract boolean from SdnValue."""
    match value:
        case sdnvalue_Bool(b): Ok(b)
        case sdnvalue_String(s):
            match s:
                case "true": Ok(true)
                case "false": Ok(false)
                case _: Err("Invalid boolean string: {s}")
        case _: Err("Expected boolean value")

# ============================================================================
# Exports
# ============================================================================

export SmfCache
export MappedSmf
export CacheStats
