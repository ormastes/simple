"""
# Loader Module - Runtime Module Loading

Loads compiled SMF modules at runtime for JIT compilation and REPL support.
Provides module caching, lazy loading, and FFI integration.

## Features

- Dynamic module loading at runtime
- Module caching for performance
- Lazy loading of dependencies
- FFI integration for native libraries
- REPL support

## Quick Start

```simple
# Example 1: Load module at runtime
use compiler_core.loader.{load_module}

val module = load_module("std.math")
print "Loaded: {module.name}"
# Output: Loaded: std.math
```

```simple
# Example 2: JIT context setup
use compiler_core.loader.{JitContext}

val ctx = JitContext()
ctx.add_search_path("/usr/lib/simple")
val func = ctx.load_function("std.string", "concat")
```

```simple
# Example 3: SMF cache usage
use compiler_core.loader.{SmfCache}

val cache = SmfCache()
cache.add_module("std.array", module_data)
val cached = cache.get("std.array")
```

## Public API

- `use compiler_core.loader.module_loader.{load_module, ModuleLoader}`
- `use compiler_core.loader.jit_context.{JitContext}`
- `use compiler_core.loader.smf_cache.{SmfCache}`

@tag:compiler
@tag:runtime
"""

# Loader Module - Runtime Module Loading
#
# Loads compiled SMF modules at runtime for JIT compilation and REPL support.
# Provides module caching, lazy loading, and FFI integration.
#
# Public API:
#   - use compiler_core.loader.module_loader.{load_module, ModuleLoader}
#   - use compiler_core.loader.jit_context.{JitContext}
#   - use compiler_core.loader.smf_cache.{SmfCache}
#
# All submodules are automatically available.
