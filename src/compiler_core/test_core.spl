# Core Simple — Self-Contained Integration Test
#
# Tests the arena pattern used by types.spl, tokens.spl, ast.spl, mir.spl.
# Uses module-level code (not functions) for arena tests to avoid
# the closure variable capture bug (.push() from functions doesn't persist).
#
# Note: The check_* functions print FAIL lines but can't track counters
# due to closure bug. If no FAIL lines appear, all tests passed.
#
# Run: bin/release/simple src/core/test_core.spl

# Import only pure functions (no module-level var state)
use compiler_core.tokens.{tok_kind_name, keyword_lookup, tok_precedence}
use compiler_core.tokens.{TOK_KW_FN, TOK_KW_ASM, TOK_IDENT, TOK_PLUS, TOK_STAR, TOK_EQ}
use compiler_core.tokens.{TOK_INT_LIT, TOK_STRING_LIT}
use compiler_core.tokens.{tok_is_literal, tok_is_comparison, tok_is_assignment}
use compiler_core.types.{TYPE_I64, TYPE_TEXT, TYPE_BOOL, TYPE_VOID}
use compiler_core.types.{type_tag_name, type_tag_to_c}
use compiler_core.types.{SYM_VAL, SYM_VAR, SYM_FN}
use compiler_core.ast.{EXPR_INT_LIT, EXPR_IDENT, EXPR_BINARY, EXPR_CALL}
use compiler_core.ast.{STMT_VAL_DECL, STMT_RETURN}
use compiler_core.ast.{DECL_FN, DECL_STRUCT}
use compiler_core.ast.{expr_kind_name}
use compiler_core.mir.{MIR_ADD, MIR_CONST_INT, MIR_CALL, TERM_RETURN}
use compiler_core.mir.{mir_inst_kind_name}

# Simple check functions — only print on failure
fn check_eq_int(label: text, actual: i64, expected: i64):
    if actual != expected:
        print "FAIL: {label} - expected {expected}, got {actual}"

fn check_eq_str(label: text, actual: text, expected: text):
    if actual != expected:
        print "FAIL: {label} - expected '{expected}', got '{actual}'"

fn check_true(label: text, condition: bool):
    if not condition:
        print "FAIL: {label}"

# ===== Test 1: Token Types (pure functions, no module state) =====
print "--- Token Types ---"

check_eq_str("tok name fn", tok_kind_name(TOK_KW_FN), "fn")
check_eq_str("tok name ident", tok_kind_name(TOK_IDENT), "Ident")
check_eq_str("tok name +", tok_kind_name(TOK_PLUS), "+")
check_eq_str("tok name ==", tok_kind_name(TOK_EQ), "==")
check_eq_str("tok name asm", tok_kind_name(TOK_KW_ASM), "asm")
check_eq_int("keyword fn", keyword_lookup("fn"), TOK_KW_FN)
check_eq_int("keyword val", keyword_lookup("val"), 21)
check_eq_int("keyword xyz", keyword_lookup("xyz"), TOK_IDENT)
check_eq_int("keyword nil", keyword_lookup("nil"), 5)
check_eq_int("keyword asm", keyword_lookup("asm"), TOK_KW_ASM)
check_eq_int("prec +", tok_precedence(TOK_PLUS), 10)
check_eq_int("prec *", tok_precedence(TOK_STAR), 11)
check_eq_int("prec ==", tok_precedence(TOK_EQ), 7)
check_true("is_literal int", tok_is_literal(TOK_INT_LIT))
check_true("is_literal str", tok_is_literal(TOK_STRING_LIT))
check_true("not literal ident", not tok_is_literal(TOK_IDENT))
check_true("is_comparison ==", tok_is_comparison(TOK_EQ))
check_true("not comparison +", not tok_is_comparison(TOK_PLUS))

# ===== Test 2: Type Tags (pure functions) =====
print "--- Type Tags ---"

check_eq_str("type i64", type_tag_name(TYPE_I64), "i64")
check_eq_str("type text", type_tag_name(TYPE_TEXT), "text")
check_eq_str("type bool", type_tag_name(TYPE_BOOL), "bool")
check_eq_str("type void", type_tag_name(TYPE_VOID), "void")
check_eq_str("C i64", type_tag_to_c(TYPE_I64), "int64_t")
check_eq_str("C text", type_tag_to_c(TYPE_TEXT), "const char*")
check_eq_str("C bool", type_tag_to_c(TYPE_BOOL), "int")
check_eq_str("C void", type_tag_to_c(TYPE_VOID), "void")

# ===== Test 3: AST Kind Names (pure functions) =====
print "--- AST Kind Names ---"

check_eq_str("expr IntLit", expr_kind_name(EXPR_INT_LIT), "IntLit")
check_eq_str("expr Ident", expr_kind_name(EXPR_IDENT), "Ident")
check_eq_str("expr Binary", expr_kind_name(EXPR_BINARY), "Binary")
check_eq_str("expr Call", expr_kind_name(EXPR_CALL), "Call")

# ===== Test 4: MIR Kind Names (pure functions) =====
print "--- MIR Kind Names ---"

check_eq_str("mir Add", mir_inst_kind_name(MIR_ADD), "Add")
check_eq_str("mir ConstInt", mir_inst_kind_name(MIR_CONST_INT), "ConstInt")
check_eq_str("mir Call", mir_inst_kind_name(MIR_CALL), "Call")

# ===== Test 5: Arena Pattern (module-level, no functions) =====
print "--- Arena Pattern (module-level) ---"

var span_starts: [i64] = []
var span_ends: [i64] = []
var span_lines: [i64] = []

span_starts.push(0)
span_ends.push(5)
span_lines.push(1)

span_starts.push(6)
span_ends.push(10)
span_lines.push(2)

check_eq_int("span count", span_starts.len(), 2)
check_eq_int("span 0 start", span_starts[0], 0)
check_eq_int("span 0 end", span_ends[0], 5)
check_eq_int("span 1 start", span_starts[1], 6)
check_eq_int("span 1 line", span_lines[1], 2)

# ===== Test 6: Expression Arena (module-level) =====
print "--- Expression Arena (module-level) ---"

var e_tags: [i64] = []
var e_ints: [i64] = []
var e_names: [text] = []
var e_lefts: [i64] = []
var e_rights: [i64] = []

# Expr 0: IntLit(1)
e_tags.push(EXPR_INT_LIT)
e_ints.push(1)
e_names.push("")
e_lefts.push(-1)
e_rights.push(-1)

# Expr 1: Ident("x")
e_tags.push(EXPR_IDENT)
e_ints.push(0)
e_names.push("x")
e_lefts.push(-1)
e_rights.push(-1)

# Expr 2: Binary(+, 0, 1) => 1 + x
e_tags.push(EXPR_BINARY)
e_ints.push(TOK_PLUS)
e_names.push("")
e_lefts.push(0)
e_rights.push(1)

check_eq_int("expr count", e_tags.len(), 3)
check_eq_int("e0 tag", e_tags[0], EXPR_INT_LIT)
check_eq_int("e0 val", e_ints[0], 1)
check_eq_int("e1 tag", e_tags[1], EXPR_IDENT)
check_eq_str("e1 name", e_names[1], "x")
check_eq_int("e2 tag", e_tags[2], EXPR_BINARY)
check_eq_int("e2 op", e_ints[2], TOK_PLUS)
check_eq_int("e2 left", e_lefts[2], 0)
check_eq_int("e2 right", e_rights[2], 1)

# ===== Test 7: MIR Instruction Arena (module-level) =====
print "--- MIR Instruction Arena (module-level) ---"

var i_kinds: [i64] = []
var i_dests: [i64] = []
var i_src1s: [i64] = []
var i_src2s: [i64] = []
var i_strs: [text] = []

i_kinds.push(MIR_ADD)
i_dests.push(2)
i_src1s.push(0)
i_src2s.push(1)
i_strs.push("")

i_kinds.push(MIR_CALL)
i_dests.push(3)
i_src1s.push(-1)
i_src2s.push(-1)
i_strs.push("add")

check_eq_int("inst count", i_kinds.len(), 2)
check_eq_int("i0 kind", i_kinds[0], MIR_ADD)
check_eq_int("i0 dest", i_dests[0], 2)
check_eq_int("i0 src1", i_src1s[0], 0)
check_eq_int("i0 src2", i_src2s[0], 1)
check_eq_int("i1 kind", i_kinds[1], MIR_CALL)
check_eq_int("i1 dest", i_dests[1], 3)
check_eq_str("i1 name", i_strs[1], "add")

# ===== Test 8: Basic Block Simulation (module-level) =====
print "--- Basic Block (module-level) ---"

var bb_names: [text] = []
var bb_terms: [i64] = []

bb_names.push("entry")
bb_terms.push(0)

bb_names.push("exit_bb")
bb_terms.push(1)

check_eq_str("bb0 name", bb_names[0], "entry")
check_eq_int("bb0 term", bb_terms[0], 0)
check_eq_str("bb1 name", bb_names[1], "exit_bb")
check_eq_int("bb1 term", bb_terms[1], 1)
check_eq_int("bb count", bb_names.len(), 2)

# ===== Test 9: Symbol Constants =====
print "--- Symbol Constants ---"

check_eq_int("SYM_VAL", SYM_VAL, 2)
check_eq_int("SYM_VAR", SYM_VAR, 1)
check_eq_int("SYM_FN", SYM_FN, 3)

# ===== Test 10: Declaration Constants =====
print "--- Declaration Constants ---"

check_eq_int("DECL_FN", DECL_FN, 1)
check_eq_int("DECL_STRUCT", DECL_STRUCT, 3)

# ===== Test 11: Statement Constants =====
print "--- Statement Constants ---"

check_eq_int("STMT_VAL_DECL", STMT_VAL_DECL, 2)
check_eq_int("STMT_RETURN", STMT_RETURN, 5)

# ===== Test 12: MIR Terminator Constants =====
print "--- MIR Terminator Constants ---"

check_eq_int("TERM_RETURN", TERM_RETURN, 2)

# ===== Results =====
print ""
print "=== Core Simple Test ==="
print "If no FAIL lines above, all tests passed."
