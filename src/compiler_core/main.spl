# Simple Compiler - Main Entry Point
#
# Self-hosting compiler for the Simple programming language.
# This is the entry point when running the compiler as a standalone tool.
#
# Usage:
#   simple-compiler [options] <files...>
#   simple-compiler --mode=jit script.spl
#   simple-compiler --mode=aot -o output src/*.spl
#   simple-compiler --check src/
#   simple-compiler --sdn config.sdn

use std.string.{NL}
use driver.*
use app.io.mod (rt_debug_stack_trace_lines)

fn format_runtime_error_message(msg: text) -> text:
    var message = "Runtime error: {msg}"
    val frames = rt_debug_stack_trace_lines()
    if frames_len(frames) > 0:
        message = message + NL + "Call stack:"
        for frame in frames:
            message = message + NL + "  " + frame
    message

# ------------------------------------------------------------------------------
# Command Line Interface
# ------------------------------------------------------------------------------

struct CliArgs:
    mode: CompileMode
    input_files: [text]
    # # DESUGARED: output_file: text
    has_output_file: bool
    output_file: text
    optimize: bool
    debug_info: bool
    verbose: bool
    log_level: i64
    profile: text
    help: bool
    version: bool

    static fn default() -> CliArgs:
        CliArgs(
            mode: CompileMode.Interpret,
            input_files: [],
            #  # DESUGARED: output_file: nil
            optimize: false,
            debug_info: true,
            verbose: false,
            log_level: 4,
            profile: "dev",
            help: false,
            version: false
        )

    fn to_options() -> CompileOptions:
        CompileOptions(
            mode: self.mode,
            input_files: self.input_files,
            output_file: self.output_file,
            optimize: self.optimize,
            debug_info: self.debug_info,
            verbose: self.verbose,
            log_level: self.log_level,
            profile: self.profile
        )

# ------------------------------------------------------------------------------
# Argument Parser
# ------------------------------------------------------------------------------

class ArgParser:
    args: [text]
    pos: i64

    static fn create(args: [text]) -> ArgParser:
        ArgParser(args: args, pos: 0)

    fn has_next() -> bool:
        self.pos < self.args.len()

    me next() -> text:
        if self.pos >= self.args.len():
            return nil
        val arg = self.args[self.pos]
        self.pos = self.pos + 1
        arg

    me peek() -> text:
        if self.pos >= self.args.len():
            return nil
        self.args[self.pos]

    me parse() -> text:
        var result = cliargs_default()

        while self.has_next():
            val arg = self.next().unwrap()

            if arg == "--":
                # End of options marker - rest are positional args
                while self.has_next():
                    val file = self.next().unwrap()
                    var files = result.input_files
                    files_push(files, file)
                    result.input_files = files
            elif arg.starts_with("--"):
                # Long option
                match self.parse_long_option(arg, result):
                    case Ok(r): result = r
                    case Err(e): return Err(e)
            elif arg.starts_with("-"):
                # Short option
                match self.parse_short_option(arg, result):
                    case Ok(r): result = r
                    case Err(e): return Err(e)
            else:
                # Input file
                var files = result.input_files
                files_push(files, arg)
                result.input_files = files

        Ok(result)

    me parse_long_option(arg: text, result: CliArgs) -> text:
        val opt = arg_slice(arg, 2, arg.len())

        # Options with values (--option=value or --option value)
        if opt.contains("="):
            val parts = opt.split("=")
            val name = parts[0]
            val value = parts[1]
            return self.apply_option(name, value, result)

        # Boolean flags
        match opt:
            case "help":
                result.help = true
                return Ok(result)
            case "h":
                result.help = true
                return Ok(result)
            case "version":
                result.version = true
                return Ok(result)
            case "V":
                result.version = true
                return Ok(result)
            case "optimize":
                result.optimize = true
                return Ok(result)
            case "O":
                result.optimize = true
                return Ok(result)
            case "debug":
                result.debug_info = true
                return Ok(result)
            case "g":
                result.debug_info = true
                return Ok(result)
            case "no-debug":
                result.debug_info = false
                return Ok(result)
            case "verbose":
                result.verbose = true
                return Ok(result)
            case "v":
                result.verbose = true
                return Ok(result)
            case "check":
                result.mode = CompileMode.Check
                return Ok(result)
            case "sdn":
                result.mode = CompileMode.Sdn
                return Ok(result)
            case "interpret":
                result.mode = CompileMode.Interpret
                return Ok(result)
            case "jit":
                result.mode = CompileMode.Jit
                return Ok(result)
            case "aot":
                result.mode = CompileMode.Aot
                return Ok(result)
            case "compile":
                result.mode = CompileMode.Aot
                return Ok(result)
            case "native":
                result.mode = CompileMode.Aot
                return Ok(result)
            case _:
                pass

        # Options requiring a value
        val value = self.next()
        if value_is_none(value):
            return Err("Option --{opt} requires a value")

        self.apply_option(opt, value_value, result)

    fn apply_option(name: text, value: text, result: CliArgs) -> text:
        match name:
            case "mode":
                val mode = CompileMode__from_text(value)
                if mode_is_none(mode):
                    return Err("Unknown mode: {value}")
                result.mode = mode_value

            case "m":
                val mode = CompileMode__from_text(value)
                if mode_is_none(mode):
                    return Err("Unknown mode: {value}")
                result.mode = mode_value

            case "output":
                result.output_file = value

            case "o":
                result.output_file = value

            case "log-level":
                val level = value_parse_int(value)
                if level_is_none(level):
                    return Err("Invalid log level: {value}")
                result.log_level = level_value

            case "l":
                val level = value_parse_int(value)
                if level_is_none(level):
                    return Err("Invalid log level: {value}")
                result.log_level = level_value

            case "profile":
                result.profile = value

            case "p":
                result.profile = value

            case _:
                return Err("Unknown option: --{name}")

        Ok(result)

    me parse_short_option(arg: text, result: CliArgs) -> text:
        val opts = arg_slice(arg, 1, arg.len())
        var i = 0
        while i < opts_len(opts):
            val c = opts_char_at(opts, i)
            match c:
                case 'h':
                    result.help = true
                case 'V':
                    result.version = true
                case 'O':
                    result.optimize = true
                case 'g':
                    result.debug_info = true
                case 'v':
                    result.verbose = true
                case 'c':
                    result.mode = CompileMode.Aot
                case 'i':
                    result.mode = CompileMode.Interpret
                case 'j':
                    result.mode = CompileMode.Jit
                case 'k':
                    result.mode = CompileMode.Check
                case 's':
                    result.mode = CompileMode.Sdn
                case 'o':
                    # -o requires a value (rest of arg or next arg)
                    if i + 1 < opts_len(opts):
                        result.output_file = opts_slice(opts, i + 1, opts.len())
                        return Ok(result)
                    else:
                        match self.next():
                            case v:
                                result.output_file = v
                                return Ok(result)
                            case nil:
                                return Err("Option -o requires a value")
                case 'm':
                    # -m requires a value
                    val value = self.next()
                    if value_is_none(value):
                        return Err("Option -m requires a value")
                    val mode = CompileMode__from_text(value_value)
                    if mode_is_none(mode):
                        return Err("Unknown mode: {value_value}")
                    result.mode = mode_value
                    return Ok(result)
                case 'l':
                    # -l requires a value
                    val value = self.next()
                    if value_is_none(value):
                        return Err("Option -l requires a value")
                    val level = value_value_parse_int(value_value)
                    if level_is_none(level):
                        return Err("Invalid log level")
                    result.log_level = level_value
                    return Ok(result)
                case _:
                    return Err("Unknown option: -{c}")
            i = i + 1

        Ok(result)

# ------------------------------------------------------------------------------
# Help and Version
# ------------------------------------------------------------------------------

fn print_help():
    var help = "Simple Compiler v0[3].0" + NL
    help = help + NL
    help = help + "Usage: simple-compiler [options] <files...>" + NL
    help = help + NL
    help = help + "Modes:" + NL
    help = help + "  -i, --interpret     Interpret (default)" + NL
    help = help + "  -j, --jit           JIT compile and run" + NL
    help = help + "  -c, --aot           Compile to executable" + NL
    help = help + "  -k, --check         Type check only" + NL
    help = help + "  -s, --sdn           Parse as SDN data" + NL
    help = help + "  -m, --mode=MODE     Set mode explicitly" + NL
    help = help + NL
    help = help + "Options:" + NL
    help = help + "  -o, --output=FILE   Output file (for --aot)" + NL
    help = help + "  -O, --optimize      Enable optimizations" + NL
    help = help + "  -g, --debug         Include debug info (default)" + NL
    help = help + "  --no-debug          Exclude debug info" + NL
    help = help + "  -v, --verbose       Verbose output" + NL
    help = help + "  -l, --log-level=N   Log level 0-10 (default: 4)" + NL
    help = help + "  -p, --profile=NAME  Profile: dev, test, prod" + NL
    help = help + NL
    help = help + "  -h, --help          Show this help" + NL
    help = help + "  -V, --version       Show version" + NL
    help = help + "  --bootstrap-test    Run bootstrap self-compile test" + NL
    help = help + NL
    help = help + "Examples:" + NL
    help = help + "  simple-compiler script.spl           # Interpret" + NL
    help = help + "  simple-compiler -j script.spl        # JIT compile" + NL
    help = help + "  simple-compiler -c -o out src/*.spl  # AOT compile" + NL
    help = help + "  simple-compiler -k src/              # Type check" + NL
    help = help + "  simple-compiler -s config.sdn        # Parse SDN" + NL
    print help

fn print_version():
    var version = "simple-compiler 0[3].0 (2026-01)" + NL
    version = version + "Self-hosting compiler for the Simple programming language" + NL
    version = version + NL
    version = version + "Backends:" + NL
    version = version + "  - Interpreter (tree-walking)" + NL
    version = version + "  - JIT (Cranelift)" + NL
    version = version + "  - AOT (Cranelift)" + NL
    version = version + NL
    version = version + "Features:" + NL
    version = version + "  - Indentation-based syntax" + NL
    version = version + "  - Pattern matching" + NL
    version = version + "  - Effect system" + NL
    version = version + "  - Reference capabilities" + NL
    version = version + "  - Algebraic data types" + NL
    print version

# ------------------------------------------------------------------------------
# Main Entry Point
# ------------------------------------------------------------------------------

fn main() -> i32:
    val args = sys_get_args()
    # Skip program name
    var program_args = args[1:args.len()]

    # Skip "compile" subcommand if present (compatibility with simple_old invocation)
    if program_args.len() > 0:
        if program_args[0] == "compile":
            program_args = program_args[1:program_args.len()]

    # Fast path: default interpret mode delegates to simple_old
    # The self-hosted interpreter has struct field access issues
    if args.len() >= 2:
        val last_arg = args[args.len() - 1]
        val last4 = last_arg[last_arg.len() - 4:]
        if last4 == ".spl":
            # Check no mode flags present
            var has_mode = false
            var i = 1
            while i < args.len() - 1:
                val a = args[i]
                if a == "-j" or a == "-c" or a == "-k" or a == "-s":
                    has_mode = true
                if a == "--jit" or a == "--aot" or a == "--check" or a == "--sdn":
                    has_mode = true
                i = i + 1
            if not has_mode:
                val exit_code = rt_exec("./target/debug/simple_old {last_arg}")
                return exit_code

    # Parse arguments
    var parser = argparser_create(program_args)
    val parsed = parser_parse(parser)

    match parsed:
        case Err(e):
            print "Error: {e}"
            print "Try 'simple-compiler --help' for usage"
            return 1

        case Ok(cli_args):
            # Handle help/version
            if cli_args.help:
                print_help()
                return 0

            if cli_args.version:
                print_version()
                return 0

            # Check for input files
            if cli_args.input_files_is_empty(input_files):
                print "Error: No input files"
                print "Try 'simple-compiler --help' for usage"
                return 1

            # Run compilation
            print "[main] input_files={cli_args.input_files.len()}"
            for f in cli_args.input_files:
                print "[main]   file: {f}"

            val options = cli_args_to_options(cli_args)
            var driver = compilerdriver_create(options)
            val result = driver_compile(driver)

            match result:
                case compileresult_Success(value):
                    if cli_args.verbose:
                        if value_is_some(value):
                            print "Result: {value_value}"
                        else:
                            print "Compilation successful"
                    return 0

                case compileresult_ParseError(errors):
                    print "Parse errors:"
                    for e in errors:
                        print "  {e}"
                    return 1

                case compileresult_TypeError(errors):
                    print "Type errors:"
                    for e in errors:
                        print "  {e}"
                    return 1

                case compileresult_CodegenError(msg):
                    print "Codegen error: {msg}"
                    return 1

                case compileresult_RuntimeError(msg):
                    print format_runtime_error_message(msg)
                    return 1

# ------------------------------------------------------------------------------
# Bootstrap Self-Compile Test
# ------------------------------------------------------------------------------

## Bootstrap test function
## Verifies the compiler can compile itself
fn bootstrap_test() -> bool:
    print "=== Bootstrap Self-Compile Test ==="
    print ""

    # Step 1: Compile the compiler itself
    print "Step 1: Compiling simple/compiler/ to simple-compiler-v1..."
    val step1 = aot_file("src/compiler/main.spl", "simple-compiler-v1")
    if not step1_is_success(step1):
        print "  FAILED: {step1.get_errors()}"
        return false
    print "  OK"

    # Step 2: Use v1 to compile itself
    print "Step 2: Using v1 to compile to simple-compiler-v2..."
    val step2_result = rt_exec("./simple-compiler-v1 -c -o simple-compiler-v2 simple/compiler/main.spl")
    if step2_result != 0:
        print "  FAILED: v1 could not compile itself"
        return false
    print "  OK"

    # Step 3: Use v2 to compile itself
    print "Step 3: Using v2 to compile to simple-compiler-v3..."
    val step3_result = rt_exec("./simple-compiler-v2 -c -o simple-compiler-v3 simple/compiler/main.spl")
    if step3_result != 0:
        print "  FAILED: v2 could not compile itself"
        return false
    print "  OK"

    # Step 4: Verify v2 == v3
    print "Step 4: Verifying v2 and v3 are identical..."
    val v2_hash = rt_file_hash("simple-compiler-v2")
    val v3_hash = rt_file_hash("simple-compiler-v3")

    if v2_hash != v3_hash:
        print "  FAILED: v2 and v3 differ"
        print "    v2 hash: {v2_hash}"
        print "    v3 hash: {v3_hash}"
        return false

    print "  OK (hash: {v2_hash})"
    print ""
    print "=== Bootstrap Test PASSED ==="
    print "The Simple compiler can compile itself!"
    true

# FFI for main entry
extern fn sys_get_args() -> [text]
