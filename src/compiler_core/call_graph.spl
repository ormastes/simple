# Core Simple â€” Call Graph Analysis
#
# Detects direct self-recursion (R1) and mutual/circular recursion (R2).
# Both are banned in @safe context for baremetal targets.
#
# R1 example:
#   fn factorial(n: i64) -> i64:
#       if n <= 1: return 1
#       n * factorial(n - 1)   # WARN: direct self-recursion
#
# R2 example:
#   fn is_even(n: i64) -> bool:
#       if n == 0: return true
#       is_odd(n - 1)
#   fn is_odd(n: i64) -> bool:
#       if n == 0: return false
#       is_even(n - 1)          # WARN: circular call cycle

use compiler_core.ast.{DECL_FN, EXPR_CALL, EXPR_IDENT, EXPR_LAMBDA}
use compiler_core.ast.{STMT_EXPR, STMT_VAL_DECL, STMT_VAR_DECL, STMT_ASSIGN, STMT_RETURN}
use compiler_core.ast.{STMT_IF, STMT_FOR, STMT_WHILE, STMT_MATCH, STMT_BLOCK, STMT_COMPOUND_ASSIGN}
use compiler_core.ast.{decl_count, decl_get_tag, decl_get_name, decl_get_body}
use compiler_core.ast.{stmt_get_tag, stmt_get_expr, stmt_get_body, stmt_get_type}
use compiler_core.ast.{expr_get_tag, expr_get_str, expr_get_left, expr_get_right, expr_get_extra}
use compiler_core.ast.{expr_get_args, expr_get_stmts}
use compiler_core.ast.{elif_get_cond, elif_get_body, elif_get_else}
use compiler_core.ast.{arm_get_body}

# ===== Module State =====

var cg_warnings: [text] = []
var cg_fn_names: [text] = []
var cg_fn_count: i64 = 0
var cg_callees: [[text]] = []
# DFS colors: 0=white, 1=gray, 2=black
var cg_visited: [i64] = []
# Dict for O(1) fn name -> index lookup
var cg_fn_index = {}

# ===== Public API =====

fn call_graph_warnings_get() -> [text]:
    cg_warnings

fn call_graph_warnings_has() -> bool:
    cg_warnings.len() > 0

fn call_graph_warnings_clear():
    cg_warnings = []

# ===== Entry Point =====

fn call_graph_analyze():
    # Reset state
    cg_warnings = []
    cg_fn_names = []
    cg_fn_count = 0
    cg_callees = []
    cg_visited = []
    cg_fn_index = {}

    # Phase 1: Register all functions
    register_functions()

    # Phase 2: Extract call edges
    extract_call_edges()

    # Phase 3: Detect self-recursion (R1)
    detect_self_recursion()

    # Phase 4: Detect circular call cycles (R2)
    detect_cycles()

# ===== Phase 1: Register Functions =====

fn register_functions():
    val total = decl_count()
    for i in range(0, total):
        val tag = decl_get_tag(i)
        if tag == DECL_FN:
            val name = decl_get_name(i)
            cg_fn_index[name] = cg_fn_count
            cg_fn_names.push(name)
            cg_callees.push([])
            cg_visited.push(0)
            cg_fn_count = cg_fn_count + 1

# ===== Phase 2: Extract Call Edges =====

fn extract_call_edges():
    var fn_idx = 0
    val total = decl_count()
    for i in range(0, total):
        val tag = decl_get_tag(i)
        if tag == DECL_FN:
            val body = decl_get_body(i)
            for stmt_idx in body:
                collect_calls_from_stmt(stmt_idx, fn_idx)
            fn_idx = fn_idx + 1

fn add_callee(fn_idx: i64, callee_name: text):
    # Deduplicate edges
    val existing = cg_callees[fn_idx]
    for name in existing:
        if name == callee_name:
            return
    var updated = cg_callees[fn_idx]
    updated.push(callee_name)
    cg_callees[fn_idx] = updated

fn collect_calls_from_stmt(stmt_idx: i64, fn_idx: i64):
    val tag = stmt_get_tag(stmt_idx)
    val expr_idx = stmt_get_expr(stmt_idx)
    val body = stmt_get_body(stmt_idx)

    # Analyze expression in this statement
    if expr_idx >= 0:
        collect_calls_from_expr(expr_idx, fn_idx)

    # Recurse into body statements
    for nested in body:
        collect_calls_from_stmt(nested, fn_idx)

    # Handle if-stmt elif chain
    if tag == STMT_IF:
        val elif_idx = stmt_get_elif(stmt_idx)
        if elif_idx >= 0:
            collect_calls_from_elif(elif_idx, fn_idx)

fn stmt_get_elif(stmt_idx: i64) -> i64:
    # elif index is stored in type field for if-stmts
    stmt_get_type(stmt_idx)

fn collect_calls_from_elif(elif_idx: i64, fn_idx: i64):
    if elif_idx < 0:
        return
    val cond = elif_get_cond(elif_idx)
    if cond >= 0:
        collect_calls_from_expr(cond, fn_idx)
    val body = elif_get_body(elif_idx)
    for stmt_idx in body:
        collect_calls_from_stmt(stmt_idx, fn_idx)
    val else_body = elif_get_else(elif_idx)
    for stmt_idx in else_body:
        collect_calls_from_stmt(stmt_idx, fn_idx)

fn collect_calls_from_expr(expr_idx: i64, fn_idx: i64):
    if expr_idx < 0:
        return
    val tag = expr_get_tag(expr_idx)

    # Direct function call: callee(args...)
    if tag == EXPR_CALL:
        val callee = expr_get_left(expr_idx)
        if callee >= 0:
            val callee_tag = expr_get_tag(callee)
            if callee_tag == EXPR_IDENT:
                val callee_name = expr_get_str(callee)
                add_callee(fn_idx, callee_name)

    # Recurse into child expressions
    val left = expr_get_left(expr_idx)
    val right = expr_get_right(expr_idx)
    val extra = expr_get_extra(expr_idx)
    val args = expr_get_args(expr_idx)
    val stmts = expr_get_stmts(expr_idx)

    if left >= 0:
        collect_calls_from_expr(left, fn_idx)
    if right >= 0:
        collect_calls_from_expr(right, fn_idx)
    if extra >= 0:
        collect_calls_from_expr(extra, fn_idx)
    for arg_idx in args:
        collect_calls_from_expr(arg_idx, fn_idx)
    # Analyze statements in expressions (blocks, lambdas)
    for stmt_idx in stmts:
        collect_calls_from_stmt(stmt_idx, fn_idx)

# ===== Phase 3: Detect Self-Recursion (R1) =====

fn detect_self_recursion():
    for i in range(0, cg_fn_count):
        val fn_name = cg_fn_names[i]
        val callees = cg_callees[i]
        for callee in callees:
            if callee == fn_name:
                val msg1 = "WARN: Function '" + fn_name + "' calls itself (direct recursion)"
                val msg2 = "      Direct recursion is banned in @safe context - use iteration instead"
                cg_warnings.push(msg1)
                cg_warnings.push(msg2)

# ===== Phase 4: Detect Cycles (R2) =====

fn fn_index_of(name: text) -> i64:
    if cg_fn_index.contains_key(name):
        return cg_fn_index[name]
    return -1

fn detect_cycles():
    # Reset visited
    for i in range(0, cg_fn_count):
        cg_visited[i] = 0

    # DFS from each unvisited node
    for i in range(0, cg_fn_count):
        if cg_visited[i] == 0:
            dfs_detect_cycle(i)

fn dfs_detect_cycle(start: i64):
    # Iterative DFS using explicit stack
    # Stack entries: (node_index, callee_position)
    var stack_nodes: [i64] = []
    var stack_positions: [i64] = []

    stack_nodes.push(start)
    stack_positions.push(0)
    cg_visited[start] = 1  # gray

    var done = false
    for _iter in range(0, 100000):
        if done:
            break
        if stack_nodes.len() == 0:
            done = true
            break

        val depth = stack_nodes.len() - 1
        val node = stack_nodes[depth]
        val pos = stack_positions[depth]
        val callees = cg_callees[node]

        if pos >= callees.len():
            # Done with this node
            cg_visited[node] = 2  # black
            # Pop
            var new_nodes: [i64] = []
            var new_positions: [i64] = []
            for j in range(0, depth):
                new_nodes.push(stack_nodes[j])
                new_positions.push(stack_positions[j])
            stack_nodes = new_nodes
            stack_positions = new_positions
        else:
            # Advance position
            stack_positions[depth] = pos + 1

            val callee_name = callees[pos]
            val callee_idx = fn_index_of(callee_name)
            if callee_idx < 0:
                # External function, skip
                continue

            if cg_visited[callee_idx] == 1:
                # Back edge = cycle (gray -> gray)
                # Skip self-loops (already handled by R1)
                if callee_idx != node:
                    emit_cycle_warning(stack_nodes, callee_idx)
            elif cg_visited[callee_idx] == 0:
                # Unvisited, push
                cg_visited[callee_idx] = 1  # gray
                stack_nodes.push(callee_idx)
                stack_positions.push(0)

fn emit_cycle_warning(stack_nodes: [i64], back_to: i64):
    # Extract cycle path from stack
    # Find where back_to appears in the stack
    var cycle_start = -1
    for i in range(0, stack_nodes.len()):
        if stack_nodes[i] == back_to:
            cycle_start = i
            break

    if cycle_start < 0:
        return

    # Build cycle path string
    var path = ""
    for i in range(cycle_start, stack_nodes.len()):
        if path != "":
            path = path + " -> "
        path = path + cg_fn_names[stack_nodes[i]]
    # Close the cycle
    path = path + " -> " + cg_fn_names[back_to]

    # Check for duplicate warnings
    val expected_prefix = "WARN: Circular call cycle detected: "
    for existing in cg_warnings:
        if existing.contains(path):
            return

    val msg1 = "WARN: Circular call cycle detected: " + path
    val msg2 = "      Mutual recursion is banned in @safe context - refactor to break the cycle"
    cg_warnings.push(msg1)
    cg_warnings.push(msg2)

# ===== Exports =====

export call_graph_analyze
export call_graph_warnings_get, call_graph_warnings_has, call_graph_warnings_clear
