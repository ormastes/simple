"""
# Native Execution FFI Bridge

Provides FFI interface for compiling Simple code to native executables
using LLVM backend and executing them.

**Status:** Implementation Complete
**Phase:** Testing & Verification
"""

use ffi.cli (compile_to_native, )
use ffi.system (execute_native, time_now_unix_micros)
use ffi.io (file_delete, )

# Native compilation result
class NativeCompileResult:
    success: bool
    binary_path: text
    error_message: text
    compile_time_ms: i64


# ============================================================================
# NativeCompileResult Methods (was: impl NativeCompileResult:)
# ============================================================================

fn nativecompileresult_success_result(binary_path: text, compile_time_ms: i64) -> NativeCompileResult:
        NativeCompileResult(
            success: true,
            binary_path: binary_path,
            error_message: "",
            compile_time_ms: compile_time_ms
        )


fn nativecompileresult_error_result(error: text) -> NativeCompileResult:
        NativeCompileResult(
            success: false,
            binary_path: "",
            error_message: error,
            compile_time_ms: 0
        )


# Native execution result
class NativeExecutionResult:
    stdout: text
    stderr: text
    exit_code: i32
    execution_time_ms: i64


# ============================================================================
# NativeExecutionResult Methods (was: impl NativeExecutionResult:)
# ============================================================================

# Compile Simple source to native executable
fn compile_to_native(source_path: text, output_path: text) -> NativeCompileResult:
    """
    Compiles a Simple source file to a native executable using LLVM backend.

    Args:
        source_path: Path to .spl source file
        output_path: Path for output binary

    Returns:
        NativeCompileResult with success status and binary path or error
    """
    val start = ffi_time_now_unix_micros()
    val _destruct_0 = ffi_compile_to_native(source_path, output_path)
    val success = _destruct_0[0]
    val error = _destruct_0[1]
    val end = ffi_time_now_unix_micros()
    val compile_time_ms = (end - start) / 1000

    if success:
        nativecompileresult_success_result(output_path, compile_time_ms)
    else:
        nativecompileresult_error_result(error)

# Execute native binary
fn execute_native(binary_path: text, args: [text], timeout_ms: i64) -> NativeExecutionResult:
    """
    Executes a native binary with given arguments and timeout.

    Args:
        binary_path: Path to compiled binary
        args: Command-line arguments
        timeout_ms: Timeout in milliseconds

    Returns:
        NativeExecutionResult with stdout, stderr, exit code, and timing
    """
    val start = ffi_time_now_unix_micros()
    val _destruct_1 = ffi_execute_native(binary_path, args, timeout_ms)
    val stdout = _destruct_1[0]
    val stderr = _destruct_1[1]
    val exit_code = _destruct_1[2]
    val end = ffi_time_now_unix_micros()
    val execution_time_ms = (end - start) / 1000

    NativeExecutionResult(
        stdout: stdout,
        stderr: stderr,
        exit_code: exit_code,
        execution_time_ms: execution_time_ms
    )

# Clean up temporary native binary
fn cleanup_native_binary(binary_path: text):
    """Deletes a temporary compiled binary."""
    ffi_file_delete(binary_path)

# Check if native compilation is available
fn is_native_available() -> bool:
    """
    Checks if LLVM backend is available for native compilation.
    Returns true if native compilation is supported.
    """
    # Try a simple compilation test
    val test_result = ffi_compile_to_native("", "")
    # If FFI is not available, this will return (false, "not implemented")
    not test_result[1].contains("not implemented")

export NativeCompileResult, NativeExecutionResult
export compile_to_native, execute_native, cleanup_native_binary
export is_native_available
