# JIT-Enabled Interpreter Backend - Hybrid Interpreter with JIT Compilation
# (COMPILED-ONLY — requires generics, traits, Result<>)
#
# This module implements a hybrid interpreter that can:
# 1. Use JIT compilation (Cranelift/LLVM) for hot functions
# 2. Fall back to tree-walking for complex/dynamic code
# 3. Share backend infrastructure with the compiler
#
# Architecture:
# - Hot path: Compile HIR → MIR → native code (via ExecutionManager)
# - Cold path: Tree-walking via InterpreterBackendImpl (delegates to core)
# - For runtime (interpreter mode), use core.interpreter.jit instead

use compiler.hir.*
use compiler.mir.*
use backend_types.*
use backend.env.{EvalContext, Environment}
use backend.interpreter.InterpreterBackendImpl
use compiler.execution.mod.{LocalExecutionManager, get_jit_backend}
use compiler.mir_lowering.MirLowering
use compiler.mir_serialization.serialize_mir_function

# ============================================================================
# JIT Interpreter Configuration
# ============================================================================

enum JitMode:
    """JIT compilation mode."""
    Auto                    # Auto-select (JIT when possible, interpret fallback)
    AlwaysJit              # Always use JIT (error if not possible)
    AlwaysInterpret        # Never use JIT (pure tree-walking)
    Hybrid                 # Smart hybrid (JIT hot paths, interpret cold)

struct JitInterpreterConfig:
    """Configuration for JIT-enabled interpreter."""
    mode: JitMode
    backend: text          # "auto", "cranelift", "llvm"
    jit_threshold: i32     # Function call count before JIT compilation
    verbose: bool


# ============================================================================
# JitInterpreterConfig Methods (was: impl JitInterpreterConfig:)
# ============================================================================

fn jitinterpreterconfig_default() -> JitInterpreterConfig:
        """Create default configuration (auto mode, Cranelift backend)."""
        JitInterpreterConfig(
            mode: JitMode.Auto,
            backend: "auto",
            jit_threshold: 10,
            verbose: false
        )


fn jitinterpreterconfig_auto_jit() -> JitInterpreterConfig:
        """Auto JIT mode - compile when possible, interpret otherwise."""
        JitInterpreterConfig(
            mode: JitMode.Auto,
            backend: "auto",
            jit_threshold: 1,
            verbose: false
        )


fn jitinterpreterconfig_always_jit() -> i64:
        # Stub: Struct return not fully supported in seed_cpp
        0


fn jitinterpreterconfig_interpret_only() -> JitInterpreterConfig:
        """Never JIT - pure tree-walking interpreter."""
        JitInterpreterConfig(
            mode: JitMode.AlwaysInterpret,
            backend: "auto",
            jit_threshold: 999999,
            verbose: false
        )


# ============================================================================
# JIT Interpreter Backend Implementation
# ============================================================================

struct JitInterpreterBackend:
    """Hybrid interpreter backend with JIT compilation.

    Strategy:
    1. Start with tree-walking interpretation
    2. Count function calls
    3. When threshold reached, JIT compile the function
    4. Subsequent calls use JIT-compiled code
    5. Fall back to interpretation if JIT fails
    """
    config: JitInterpreterConfig
    # # DESUGARED: exec_manager: LocalExecutionManager
    has_exec_manager: bool
    exec_manager: LocalExecutionManager
    call_counts: Dict<text, i32>      # Function name → call count
    jit_compiled: Set<text>            # Functions that are JIT-compiled


# ============================================================================
# JitInterpreterBackend Methods (was: impl JitInterpreterBackend:)
# ============================================================================

fn jitinterpreterbackend_new(config: JitInterpreterConfig) -> JitInterpreterBackend:
        """Create new JIT interpreter backend."""
        JitInterpreterBackend(
            config: config,
            #  # DESUGARED: exec_manager: nil
            call_counts: {},
            jit_compiled: {}
        )


fn jitinterpreterbackend_default() -> JitInterpreterBackend:
        """Create with default configuration."""
        JitInterpreterBackend__new(JitInterpreterConfig__default())


fn jitinterpreterbackend_should_jit_compile(self: JitInterpreterBackend, fn_name: text) -> bool:
        """Check if function should be JIT-compiled."""
        match self.config.mode:
            case AlwaysInterpret:
                false
            case AlwaysJit:
                true
            case Auto:
                # Check call count threshold
                val count = self.call_counts[fn_name] ?? 0
                count >= self.config.jit_threshold


            case Hybrid:
                # Check call count threshold
                val count = self.call_counts[fn_name] ?? 0
                count >= self.config.jit_threshold


# REMOVED: impl Backend for JitInterpreterBackend:
# (Trait implementations not supported in Core Simple)
    # fn name() -> text:
        # "jit-interpreter"

    # fn kind() -> BackendKind:
        # match self.config.mode:
            # case AlwaysJit: BackendKind.CraneliftJit
            # case _: BackendKind.Interpreter

    # fn process_module(module: HirModule) -> text:
        # # Create evaluation context
        # val env = Environment__new()
        # val ctx = EvalContext(env: env, module: module, backend: self)

        # # Register functions
        # var main_fn: HirFunction = nil
        # for symbol in module.functions_keys(functions):
            # val fn_ = module.functions[symbol]
            # ctx.env_define_global(env, symbol, Value.Function(FunctionValue(symbol: symbol, name: fn_.name)))
            # if fn_.name == "main":
                # main_fn = fn_

        # # Try to JIT compile main function if configured
        # if main_fn.? and self.should_jit_compile("main"):
            # self.try_jit_compile(main_fn_value, module)?

        # # Execute main
        # if has_main_fn:
            # val result = self.call_hir_function(main_fn_value, [], ctx, module)?
            # Ok(backendresult_Value(result))
        # else:
            # Ok(BackendResult.Unit)

    # fn process_function(fn_: HirFunction) -> text:
        # Ok(BackendResult.Unit)

    # fn process_class(class_: HirClass) -> text:
        # Ok(BackendResult.Unit)

    # fn process_struct(struct_: HirStruct) -> text:
        # Ok(BackendResult.Unit)

    # fn process_enum(enum_: HirEnum) -> text:
        # Ok(BackendResult.Unit)

    # fn process_trait(trait_: HirTrait) -> text:
        # Ok(BackendResult.Unit)

    # fn process_impl(impl_: HirImpl) -> text:
        # Ok(BackendResult.Unit)

    # fn eval_expr(expr: HirExpr, ctx: EvalContext) -> text:
        # # Delegate to tree-walking interpreter for expressions
        # # (JIT is used for function-level compilation)
        # interpreterbackendimpl_new().eval_expr(expr, ctx)

    # fn exec_stmt(stmt: HirStmt, ctx: EvalContext) -> text:
        # # Delegate to tree-walking interpreter for statements
        # interpreterbackendimpl_new().exec_stmt(stmt, ctx)

    # fn is_allowed(expr: HirExpr) -> bool:
        # true

    # fn is_allowed_stmt(stmt: HirStmt) -> bool:
        # true


# ============================================================================
# JitInterpreterBackend Methods (was: impl JitInterpreterBackend:)
# ============================================================================

# ============================================================================
# Exports
# ============================================================================

export JitMode, JitInterpreterConfig, JitInterpreterBackend
export jitinterpreterbackend_new, jitinterpreterbackend_default
export jitinterpreterconfig_always_jit, jitinterpreterconfig_interpret_only
