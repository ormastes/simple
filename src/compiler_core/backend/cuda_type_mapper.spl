# CUDA Type Mapper - CUDA/PTX-Specific Type Mapping Implementation
#
# Maps MIR types to CUDA/PTX type strings.
# Implements TypeMapper trait for CUDA backend.

use compiler.mir_data.*
use compiler.backend.common.type_mapper.*
use compiler.hir_types.MemorySpace

# ============================================================================
# CUDA Type Mapper
# ============================================================================

class CudaTypeMapper:
    """
    Maps MIR types to CUDA/PTX type representations.

    CUDA uses C-like types with memory space qualifiers:
    - Integers: long long, int, short, char (signed)
    - Unsigned: unsigned long long, unsigned int, etc.
    - Floats: double, float, half (f16)
    - Pointers: type* with __global__, __shared__, __constant__ qualifiers

    Example mappings:
        I64 → "long long"
        F64 → "double"
        F32 → "float"
        F16 → "half"
        Bool → "bool"
        Ptr(_) with Global → "__global__ type*"
    """

    val _tv_0 = [i64, i64]
    compute_capability: _tv_0  # e.g., (8, 6) for SM 8[6]

    static fn create() -> CudaTypeMapper:
        """Create mapper for default compute capability (SM 7[0])."""
        val _tup_0 = [7, 0]
        CudaTypeMapper(compute_capability: _tup_0)

    static fn create_sm(major: i64, minor: i64) -> CudaTypeMapper:
        """Create mapper for specific compute capability."""
        val _tv_1 = [major, minor]
        CudaTypeMapper(compute_capability: _tv_1)

# REMOVED: impl TypeMapper for CudaTypeMapper:
# (Trait implementations not supported in Core Simple)
    # fn map_primitive(ty: PrimitiveType) -> text:
        # """
        # Map primitive types to CUDA/C types.

        # CUDA primitives (C-style):
        # - Integers: long long (64), int (32), short (16), char (8)
        # - Unsigned: unsigned variants
        # - Floats: double (64), float (32), half (16)
        # - Boolean: bool
        # """
        # match ty:
            # case I64: "long long"
            # case I32: "int"
            # case I16: "short"
            # case I8: "signed char"
            # case U64: "unsigned long long"
            # case U32: "unsigned int"
            # case U16: "unsigned short"
            # case U8: "unsigned char"
            # case F64: "double"
            # case F32: "float"
            # case F16: "half"
            # case Bool: "bool"
            # case Unit: "void"

    # fn map_pointer(pointee: text, mutability: Mutability) -> text:
        # """
        # Map pointer types to CUDA representation.

        # CUDA pointers are C-style with optional const qualifier.
        # Memory space qualifiers are added separately.
        # """
        # match mutability:
            # case Mutable: "{pointee}*"
            # case Immutable: "const {pointee}*"

    # fn backend_name() -> text:
        # "CUDA"

    # fn map_memory_space(space: MemorySpace) -> text:
        # """
        # Map GPU memory space to CUDA qualifier.

        # CUDA memory qualifiers:
        # - __global__: Device global memory
        # - __shared__: Block shared memory
        # - __constant__: Constant memory (cached)
        # - (no qualifier): Thread-local/register
        # """
        # match space:
            # case Global: "__global__"
            # case Shared: "__shared__"
            # case Local: ""  # Thread-local is default
            # case Constant: "__constant__"
            # case Uniform: "__constant__"  # CUDA uses constant for uniform-like access

    # fn map_vector_type(elem: text, width: i64) -> text:
        # """
        # Map SIMD/vector type to CUDA vector type.

        # CUDA vector types: float2, float4, int2, int4, etc.
        # """
        # if width == 1:
            # elem
        # elif width == 2 or width == 4:
            # "{elem}{width}"
        # else:
            # # Fallback to array for non-standard widths
            # "{elem}[{width}]"

    # fn supports_half_precision() -> bool:
        # """
        # Check if compute capability supports half precision.
        # Half precision requires SM 5[3]+ for full support.
        # """
        # val (major, minor) = self.compute_capability
        # major > 5 or (major == 5 and minor >= 3)

    # fn supports_gpu() -> bool:
        # true


# ============================================================================
# CudaTypeMapper Methods (was: impl CudaTypeMapper:)
# ============================================================================

# ============================================================================
# Export
# ============================================================================

export CudaTypeMapper
