# RISC-V Inline Assembly Backend
#
# Generates RISC-V assembly from inline asm blocks.

use compiler.inline_asm.{InlineAsm, AsmOperand, AsmRegister, AsmOption}
use std.common.target.{TargetArch}

# ===========================================================================
# RISC-V Register Allocation
# ===========================================================================

class RiscVRegisterAllocator:
    """Allocates RISC-V registers for inline assembly."""
    arch: TargetArch
    used_regs: Dict<text, bool>


# ============================================================================
# RiscVRegisterAllocator Methods (was: impl RiscVRegisterAllocator:)
# ============================================================================

fn riscvregisterallocator_new(arch: TargetArch) -> RiscVRegisterAllocator:
        RiscVRegisterAllocator(
            arch: arch,
            used_regs: {}
        )


# ===========================================================================
# RISC-V Assembly Generator
# ===========================================================================

class RiscVAsmGenerator:
    """Generates RISC-V assembly."""
    arch: TargetArch
    allocator: RiscVRegisterAllocator


# ============================================================================
# RiscVAsmGenerator Methods (was: impl RiscVAsmGenerator:)
# ============================================================================

fn riscvasmgenerator_new(arch: TargetArch) -> RiscVAsmGenerator:
        RiscVAsmGenerator(
            arch: arch,
            allocator: riscvregisterallocator_new(arch)
        )


# ===========================================================================
# RISC-V-Specific Instructions
# ===========================================================================

fn csrr(csr: text) -> InlineAsm:
    """Read CSR (Control and Status Register)."""
    var asm_code = InlineAsm.new(["csrr a0, {csr}"], Span.empty())
    asm_add_option(asm_code, AsmOption.Volatile)
    asm_code

fn csrw(csr: text, value: i64) -> InlineAsm:
    """Write CSR."""
    var asm_code = InlineAsm.new(["csrw {csr}, a0"], Span.empty())
    asm_add_option(asm_code, AsmOption.Volatile)
    asm_code

fn csrs(csr: text, mask: i64) -> InlineAsm:
    """Set bits in CSR."""
    var asm_code = InlineAsm.new(["csrs {csr}, a0"], Span.empty())
    asm_add_option(asm_code, AsmOption.Volatile)
    asm_code

fn csrc(csr: text, mask: i64) -> InlineAsm:
    """Clear bits in CSR."""
    var asm_code = InlineAsm.new(["csrc {csr}, a0"], Span.empty())
    asm_add_option(asm_code, AsmOption.Volatile)
    asm_code

fn wfi_riscv() -> InlineAsm:
    """Wait for interrupt."""
    var asm_code = InlineAsm.new(["wfi"], Span.empty())
    asm_add_option(asm_code, AsmOption.Volatile)
    asm_code

fn nop_riscv() -> InlineAsm:
    """No operation."""
    InlineAsm.new(["nop"], Span.empty())

fn fence() -> InlineAsm:
    """Memory fence."""
    InlineAsm.new(["fence"], Span.empty())

fn fence_i() -> InlineAsm:
    """Instruction fence."""
    InlineAsm.new(["fence.i"], Span.empty())

fn ecall() -> InlineAsm:
    """Environment call (syscall)."""
    var asm_code = InlineAsm.new(["ecall"], Span.empty())
    asm_add_option(asm_code, AsmOption.Volatile)
    asm_code

fn ebreak() -> InlineAsm:
    """Breakpoint."""
    var asm_code = InlineAsm.new(["ebreak"], Span.empty())
    asm_add_option(asm_code, AsmOption.Volatile)
    asm_code

fn mret() -> InlineAsm:
    """Machine-mode return."""
    var asm_code = InlineAsm.new(["mret"], Span.empty())
    asm_add_option(asm_code, AsmOption.Volatile)
    asm_add_option(asm_code, AsmOption.NoReturn)
    asm_code

fn sret() -> InlineAsm:
    """Supervisor-mode return."""
    var asm_code = InlineAsm.new(["sret"], Span.empty())
    asm_add_option(asm_code, AsmOption.Volatile)
    asm_add_option(asm_code, AsmOption.NoReturn)
    asm_code

# Atomic operations
fn lr_w(addr: text) -> InlineAsm:
    """Load-reserved word."""
    var asm_code = InlineAsm.new(["lr.w a0, (a1)"], Span.empty())
    asm_add_option(asm_code, AsmOption.Volatile)
    asm_code

fn sc_w(addr: text, value: i32) -> InlineAsm:
    """Store-conditional word."""
    var asm_code = InlineAsm.new(["sc.w a0, a1, (a2)"], Span.empty())
    asm_add_option(asm_code, AsmOption.Volatile)
    asm_code

fn amoswap_w(addr: text, value: i32) -> InlineAsm:
    """Atomic swap word."""
    var asm_code = InlineAsm.new(["amoswap.w a0, a1, (a2)"], Span.empty())
    asm_add_option(asm_code, AsmOption.Volatile)
    asm_code

fn amoadd_w(addr: text, value: i32) -> InlineAsm:
    """Atomic add word."""
    var asm_code = InlineAsm.new(["amoadd.w a0, a1, (a2)"], Span.empty())
    asm_add_option(asm_code, AsmOption.Volatile)
    asm_code

# CSR addresses (common ones)
fn CSR_MSTATUS() -> text: "mstatus"
fn CSR_MIE() -> text: "mie"
fn CSR_MTVEC() -> text: "mtvec"
fn CSR_MSCRATCH() -> text: "mscratch"
fn CSR_MEPC() -> text: "mepc"
fn CSR_MCAUSE() -> text: "mcause"
fn CSR_MTVAL() -> text: "mtval"
fn CSR_MIP() -> text: "mip"

# ===========================================================================
# Exports
# ===========================================================================

export RiscVRegisterAllocator, RiscVAsmGenerator
export csrr, csrw, csrs, csrc
export wfi_riscv, nop_riscv, fence, fence_i
export ecall, ebreak, mret, sret
export lr_w, sc_w, amoswap_w, amoadd_w
export CSR_MSTATUS, CSR_MIE, CSR_MTVEC, CSR_MSCRATCH
export CSR_MEPC, CSR_MCAUSE, CSR_MTVAL, CSR_MIP
