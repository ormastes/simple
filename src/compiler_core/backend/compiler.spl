# Compiler Backend - Native code generation
#
# This module implements the compiler backend that generates
# native code from HIR via Cranelift JIT/AOT compilation.

use compiler.hir.*
use compiler.mir.*
use backend_types.*
use backend.env.EvalContext

# ============================================================================
# Compiler Backend Implementation
# ============================================================================

struct CompilerBackendImpl:
    """Compiling backend (HIR -> MIR -> codegen).

    Compiles HIR modules by:
    1. Lowering HIR to MIR
    2. Generating native code via Cranelift
    3. Either executing (JIT) or emitting object file (AOT)
    """
    mode: CodegenMode
    # # DESUGARED: output_path: text
    has_output_path: bool
    output_path: text


# ============================================================================
# CompilerBackendImpl Methods (was: impl CompilerBackendImpl:)
# ============================================================================

fn compilerbackendimpl_jit() -> CompilerBackendImpl:
        """Create JIT compilation backend."""
        CompilerBackendImpl(mode: CodegenMode.Jit, output_path: nil)


fn compilerbackendimpl_aot(output: text) -> CompilerBackendImpl:
        """Create AOT compilation backend."""
        # CompilerBackendImpl(mode: CodegenMode.Aot, # DESUGARED: output_path: Some(output))
            output_path: output)


# REMOVED: impl Backend for CompilerBackendImpl:
# (Trait implementations not supported in Core Simple)
    # fn name() -> text:
        # "compiler"

    # fn kind() -> BackendKind:
        # BackendKind.Compiler

    # fn process_module(module: HirModule) -> text:
        # # 1. Lower HIR to MIR
        # var lowering = mirlowering_new(module.symbols)
        # val mir_module = lowering_lower_module(lowering, module)

        # # Check for lowering errors
        # if lowering.errors_len(errors) > 0:
            # val first_error = lowering.errors[0]
            # return Err(backenderror_compile_error(first_error.message, first_error.span))

        # # 2. Create codegen pipeline based on mode
        # val pipeline = match self.mode:
            # case Jit: codegenpipeline_jit()
            # case Aot: codegenpipeline_aot(CodegenTarget.Native)

        # # 3. Compile MIR to native code
        # val compile_result = pipeline_compile_module(pipeline, mir_module)
        # match compile_result:
            # case Ok(compiled):
                # match self.mode:
                    # case Jit:
                        # # JIT: Execute main function and return result
                        # val call_result = compiled.call("main", [])
                        # match call_result:
                            # case Ok(value):
                                # compiled_cleanup(compiled)
                                # Ok(backendresult_Value(Value.int(value)))
                            # case Err(e):
                                # compiled_cleanup(compiled)
                                # Err(backenderror_runtime_error(e.message, e.span))
                    # case Aot:
                        # # AOT: Emit object file
                        # val path = self.output_path ?? "a.o"
                        # val emit_result = compiled_emit_object(compiled, path)
                        # match emit_result:
                            # case Ok(_):
                                # compiled_cleanup(compiled)
                                # Ok(BackendResult.Unit)
                            # case Err(e):
                                # compiled_cleanup(compiled)
                                # Err(backenderror_compile_error(e.message, e.span))
            # case Err(e):
                # Err(backenderror_compile_error(e.message, e.span))

    # fn process_function(fn_: HirFunction) -> text:
        # Err(BackendError.not_implemented("compiler backend not yet implemented"))

    # fn process_class(class_: HirClass) -> text:
        # Err(BackendError.not_implemented("compiler backend not yet implemented"))

    # fn process_struct(struct_: HirStruct) -> text:
        # Err(BackendError.not_implemented("compiler backend not yet implemented"))

    # fn process_enum(enum_: HirEnum) -> text:
        # Err(BackendError.not_implemented("compiler backend not yet implemented"))

    # fn process_trait(trait_: HirTrait) -> text:
        # Err(BackendError.not_implemented("compiler backend not yet implemented"))

    # fn process_impl(impl_: HirImpl) -> text:
        # Err(BackendError.not_implemented("compiler backend not yet implemented"))

    # fn eval_expr(expr: HirExpr, ctx: EvalContext) -> text:
        # Err(BackendError.not_implemented("compiler backend evaluates via generated code"))

    # fn exec_stmt(stmt: HirStmt, ctx: EvalContext) -> text:
        # Err(BackendError.not_implemented("compiler backend executes via generated code"))

    # fn is_allowed(expr: HirExpr) -> bool:
        # true

    # fn is_allowed_stmt(stmt: HirStmt) -> bool:
        # true

# ============================================================================
# Exports
# ============================================================================

export CompilerBackendImpl
