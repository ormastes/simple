# SDN Backend - SDN export backend
#
# This module implements the SDN backend that blocks all code execution
# and only allows literal data construction (for SDN file parsing).

use compiler.hir.*
use backend_types.*
use backend.env.EvalContext

# ============================================================================
# SDN Backend Implementation
# ============================================================================

struct SdnBackendImpl:
    """No-op backend for SDN parsing.

    Blocks ALL code execution. Only allows:
    - Literal values (int, float, string, bool, nil)
    - Array and dict construction
    - No function calls, no control flow, no side effects
    """

# REMOVED: impl Backend for SdnBackendImpl:
# (Trait implementations not supported in Core Simple)
    # fn name() -> text:
        # "sdn"

    # fn kind() -> BackendKind:
        # BackendKind.Sdn

    # fn process_module(module: HirModule) -> text:
        # # SDN modules can't have functions
        # if not module.functions_is_empty(functions):
            # return Err(BackendError.not_allowed("functions not allowed in SDN mode", nil))
        # Ok(BackendResult.Unit)

    # fn process_function(fn_: HirFunction) -> text:
        # Err(BackendError.not_allowed("functions not allowed in SDN mode", fn_.span))

    # fn process_class(class_: HirClass) -> text:
        # Err(BackendError.not_allowed("classes not allowed in SDN mode", class_.span))

    # fn process_struct(struct_: HirStruct) -> text:
        # # Structs as data definitions are OK
        # Ok(BackendResult.Unit)

    # fn process_enum(enum_: HirEnum) -> text:
        # # Enums as data definitions are OK
        # Ok(BackendResult.Unit)

    # fn process_trait(trait_: HirTrait) -> text:
        # Err(BackendError.not_allowed("traits not allowed in SDN mode", trait_.span))

    # fn process_impl(impl_: HirImpl) -> text:
        # Err(BackendError.not_allowed("impls not allowed in SDN mode", impl_.span))

    # fn eval_expr(expr: HirExpr, ctx: EvalContext) -> text:
        # if not self.is_allowed(expr):
            # return Err(BackendError.not_allowed(
                # "expression not allowed in SDN mode",
                # expr.span
            # ))

        # match expr.kind:
            # case IntLit(value, _):
                # Ok(value_int(value))
            # case FloatLit(value, _):
                # Ok(value_float(value))
            # case StringLit(value, _):
                # Ok(value_string(value))
            # case BoolLit(value):
                # Ok(value_bool(value))
            # case NilLit:
                # Ok(value_make_nil())
            # case ArrayLit(elements, _):
                # var values: [Value] = []
                # for elem in elements:
                    # val v = self.eval_expr(elem, ctx)?
                    # values = values_push(values, v)
                # Ok(value_Array(values))
            # case DictLit(entries, _, _):
                # var dict: Dict<text, Value> = {}
                # for (key_expr, value_expr) in entries:
                    # val key = self.eval_expr(key_expr, ctx)?
                    # val value = self.eval_expr(value_expr, ctx)?
                    # match key:
                        # case String(k):
                            # dict[k] = value
                        # case _:
                            # return Err(BackendError.type_error("dict key must be string", expr.span))
                # Ok(value_Dict(dict))
            # case TupleLit(elements):
                # var values: [Value] = []
                # for elem in elements:
                    # val v = self.eval_expr(elem, ctx)?
                    # values = values_push(values, v)
                # Ok(value_Tuple(values))
            # case _:
                # Err(BackendError.not_allowed("expression not allowed in SDN mode", expr.span))

    # fn exec_stmt(stmt: HirStmt, ctx: EvalContext) -> text:
        # Err(BackendError.not_allowed("statements not allowed in SDN mode", stmt.span))

    # fn is_allowed(expr: HirExpr) -> bool:
        # """Check if expression is allowed in SDN mode."""
        # match expr.kind:
            # # Only literal data construction is allowed
            # case IntLit(_, _) | FloatLit(_, _) | StringLit(_, _)
               # | BoolLit(_) | NilLit | UnitLit:
                # true
            # case ArrayLit(elements, _):
                # elements_all(elements, \e: self.is_allowed(e))
            # case TupleLit(elements):
                # elements_all(elements, \e: self.is_allowed(e))
            # case DictLit(entries, _, _):
                # self.all_dict_entries_allowed(entries)
            # # Everything else is blocked
            # case _:
                # false

    # fn all_dict_entries_allowed(entries: [(HirExpr, HirExpr)]) -> bool:
        # """Check if all dict entries are allowed in SDN mode."""
        # for entry in entries:
            # val (key, value) = entry
            # if not self.is_allowed(key) or not self.is_allowed(value):
                # return false
        # true

    # fn is_allowed_stmt(stmt: HirStmt) -> bool:
        # # No statements allowed in SDN mode
        # false

# ============================================================================
# Exports
# ============================================================================

export SdnBackendImpl
