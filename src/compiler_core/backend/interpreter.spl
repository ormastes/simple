# Interpreter Backend - Tree-walking interpreter (COMPILED-ONLY, LEGACY)
#
# DEPRECATED: This is the legacy tree-walking interpreter backend.
# For runtime (interpreter mode), use core.interpreter instead.
# For compiled mode, prefer JitInterpreterBackend from jit_interpreter.spl.
#
# This module implements the tree-walking interpreter backend
# that directly executes HIR expressions and statements.
# Requires compiled pipeline (uses generics, traits, Result<>).

use compiler.hir.*
use compiler.lexer.Span
use backend_types.*
use backend.env.{EvalContext, Environment}
use compiler.ffi_minimal as ffi  # FFI wrappers for RuntimeValue
use ffi.debug.{debug_is_active, debug_should_break, debug_wait_for_continue, debug_set_current_location}

# ============================================================================
# Interpreter Mode Configuration
# ============================================================================

enum InterpreterMode:
    Classic       # Interpreter-like: GC, debug hooks, FFI arithmetic
    Optimized     # Compiler-like: no GC, direct computation, no barriers

struct InterpreterConfig:
    mode: InterpreterMode
    enable_debug_hooks: bool
    enable_gc: bool
    use_ffi_arithmetic: bool


# ============================================================================
# InterpreterConfig Methods (was: impl InterpreterConfig:)
# ============================================================================

fn interpreterconfig_classic() -> InterpreterConfig:
        InterpreterConfig(mode: InterpreterMode.Classic, enable_debug_hooks: true,
            enable_gc: true, use_ffi_arithmetic: true)


fn interpreterconfig_optimized() -> InterpreterConfig:
        InterpreterConfig(mode: InterpreterMode.Optimized, enable_debug_hooks: false,
            enable_gc: false, use_ffi_arithmetic: false)


fn interpreterconfig_with_gc(self: InterpreterConfig, enabled: bool) -> InterpreterConfig:
        self.enable_gc = enabled
        self


fn interpreterconfig_with_debug(self: InterpreterConfig, enabled: bool) -> InterpreterConfig:
        self.enable_debug_hooks = enabled
        self


# ============================================================================
# Interpreter Backend Implementation
# ============================================================================

struct InterpreterBackendImpl:
    """Tree-walking interpreter backend."""
    config: InterpreterConfig


# ============================================================================
# InterpreterBackendImpl Methods (was: impl InterpreterBackendImpl:)
# ============================================================================

fn interpreterbackendimpl_new() -> InterpreterBackendImpl:
        InterpreterBackendImpl(config: interpreterconfig_classic())


fn interpreterbackendimpl_with_config(config: InterpreterConfig) -> InterpreterBackendImpl:
        InterpreterBackendImpl(config: config)


fn interpreterbackendimpl_optimized() -> InterpreterBackendImpl:
        InterpreterBackendImpl(config: interpreterconfig_optimized())


# REMOVED: impl Backend for InterpreterBackendImpl:
# (Trait implementations not supported in Core Simple)
    # fn name() -> text:
        # "interpreter"

    # fn kind() -> BackendKind:
        # BackendKind.Interpreter

    # fn process_module(module: HirModule) -> text:
        # # Initialize GC for RuntimeValue FFI operations (only in classic mode)
        # if self.config.enable_gc:
            # ffi_gc_init(ffi)

        # # Create evaluation context
        # val env = environment_new()
        # val ctx = EvalContext(env: env, module: module, backend: self)

        # # Iterate functions using .keys() which returns original key objects
        # var main_fn: HirFunction = nil
        # for symbol in module.functions_keys(functions):
            # val fn_ = module.functions[symbol]
            # ctx.env_define_global(env, symbol, Value.Function(FunctionValue(symbol: symbol, name: fn_.name)))
            # if fn_.name == "main":
                # main_fn = fn_

        # # Also register builtins from symbol table
        # for sym_id in module.symbols.symbols_keys(symbols):
            # val sym = module.symbols.symbols[sym_id]
            # ctx.env_define_global(env, sym.id, Value.Function(FunctionValue(symbol: sym.id, name: sym.name)))

        # if has_main_fn:
            # val result = self.call_hir_function(main_fn_value, [], ctx)?
            # Ok(backendresult_Value(result))
        # else:
            # Ok(BackendResult.Unit)

    # fn process_function(fn_: HirFunction) -> text:
        # Ok(BackendResult.Unit)

    # fn process_class(class_: HirClass) -> text:
        # Ok(BackendResult.Unit)

    # fn process_struct(struct_: HirStruct) -> text:
        # Ok(BackendResult.Unit)

    # fn process_enum(enum_: HirEnum) -> text:
        # Ok(BackendResult.Unit)

    # fn process_trait(trait_: HirTrait) -> text:
        # Ok(BackendResult.Unit)

    # fn process_impl(impl_: HirImpl) -> text:
        # Ok(BackendResult.Unit)

    # fn eval_expr(expr: HirExpr, ctx: EvalContext) -> text:
        # # Debug hooks for DAP integration (only in classic mode)
        # if self.config.enable_debug_hooks and debug_is_active():
            # val span = expr.span
            val _cast_0 = span.column as i64
            val _asv_0 = span.line as i64
            # debug_set_current_location(span.file, _asv_0, _cast_0)
            # if debug_should_break():
                # debug_wait_for_continue()

        # match expr.kind:
            # case IntLit(value, _):
                # Ok(value_int(value))

            # case FloatLit(value, _):
                # Ok(value_float(value))

            # case StringLit(value, _):
                # Ok(value_string(value))

            # case BoolLit(value):
                # Ok(value_bool(value))

            # case NilLit:
                # Ok(value_make_nil())

            # case UnitLit:
                # Ok(value_make_nil())

            # case Var(symbol):
                # val value = ctx.env_lookup(env, symbol)
                # if has_value:
                    # Ok(value_value)
                # else:
                    # Err(BackendError.runtime_error("undefined variable", expr.span))

            # case ArrayLit(elements, _):
                # var values: [Value] = []
                # for elem in elements:
                    # val v = self.eval_expr(elem, ctx)?
                    # values = values_push(values, v)
                # Ok(value_Array(values))

            # case TupleLit(elements):
                # var values: [Value] = []
                # for elem in elements:
                    # val v = self.eval_expr(elem, ctx)?
                    # values = values_push(values, v)
                # Ok(value_Tuple(values))

            # case DictLit(entries, _, _):
                # var dict: Dict<text, Value> = {}
                # for (key_expr, value_expr) in entries:
                    # val key = self.eval_expr(key_expr, ctx)?
                    # val value = self.eval_expr(value_expr, ctx)?
                    # match key:
                        # case String(k):
                            # dict[k] = value
                        # case _:
                            # return Err(BackendError.type_error("dict key must be string", expr.span))
                # Ok(value_Dict(dict))

            # case Binary(op, left, right):
                # val lv = self.eval_expr(left, ctx)?
                # val rv = self.eval_expr(right, ctx)?
                # self.eval_binop(op, lv, rv, expr.span)

            # case Unary(op, operand):
                # val v = self.eval_expr(operand, ctx)?
                # self.eval_unaryop(op, v, expr.span)

            # case If(cond, then_, else_):
                # val cv = self.eval_expr(cond, ctx)?
                # if cv_is_truthy(cv):
                    # self.eval_block(then_, ctx)
                # elif has_else_:
                    # self.eval_block(else__value, ctx)
                # else:
                    # Ok(value_make_nil())

            # case Call(callee, args, _):
                # val fn_value = self.eval_expr(callee, ctx)?
                # var arg_values: [Value] = []
                # for arg in args:
                    # val v = self.eval_expr(arg.value, ctx)?
                    # arg_values = arg_values_push(arg_values, v)
                # self.call_function(fn_value, arg_values, ctx, expr.span)

            # case MethodCall(receiver, method_name, args, resolution):
                # match resolution:
                    # case StaticMethod(_, method_id):
                        # # Static method: ClassName.method(args) - no receiver needed
                        # var arg_values: [Value] = []
                        # for arg in args:
                            # val v = self.eval_expr(arg.value, ctx)?
                            # arg_values = arg_values_push(arg_values, v)

                        # # Look up method by symbol ID
                        # self.call_function_by_id(method_id, arg_values, ctx, expr.span)

                    # case InstanceMethod(_, method_id):
                        # # Instance method: receiver.method(args)
                        # val receiver_val = self.eval_expr(receiver, ctx)?

                        # var arg_values: [Value] = []
                        # arg_values = arg_values_push(arg_values, receiver_val)  # Receiver as first arg
                        # for arg in args:
                            # val v = self.eval_expr(arg.value, ctx)?
                            # arg_values = arg_values_push(arg_values, v)

                        # self.call_function_by_id(method_id, arg_values, ctx, expr.span)

                    # case FreeFunction(func_id):
                        # # UFCS: receiver.func(args) â†’ func(receiver, args)
                        # val receiver_val = self.eval_expr(receiver, ctx)?

                        # var arg_values: [Value] = []
                        # arg_values = arg_values_push(arg_values, receiver_val)
                        # for arg in args:
                            # val v = self.eval_expr(arg.value, ctx)?
                            # arg_values = arg_values_push(arg_values, v)

                        # self.call_function_by_id(func_id, arg_values, ctx, expr.span)

                    # case TraitMethod(_, _):
                        # # Trait method - requires dynamic dispatch (not implemented yet)
                        # Err(BackendError.not_implemented("trait method calls not yet supported"))

                    # case Unresolved:
                        # Err(BackendError.runtime_error("unresolved method call: {method_name}", expr.span))

            # case StaticCall(type_, method_name, args, resolution):
                # # Static call: Type.method(args) - similar to StaticMethod variant
                # match resolution:
                    # case StaticMethod(_, method_id):
                        # var arg_values: [Value] = []
                        # for arg in args:
                            # val v = self.eval_expr(arg.value, ctx)?
                            # arg_values = arg_values_push(arg_values, v)

                        # self.call_function_by_id(method_id, arg_values, ctx, expr.span)

                    # case _:
                        # Err(BackendError.runtime_error("invalid static call resolution", expr.span))

            # case Lambda(params, body, _):
                # # Capture free variables from current scope
                # var captures: Dict<SymbolId, Value> = {}
                # val free_vars = body_free_variables(body)
                # for var_id in free_vars:
                    # val value = ctx_lookup(ctx, var_id)
                    # if has_value:
                        # captures[var_id] = value_value
                # Ok(Value.Closure(ClosureValue(
                    # params: params,
                    # body: body,
                    # captures: captures
                # )))

            # case Block(block):
                # self.eval_block(block, ctx)

            # case _:
                # Err(BackendError.not_implemented("expression kind not implemented"))

    # fn exec_stmt(stmt: HirStmt, ctx: EvalContext) -> text:
        # match stmt.kind:
            # case Expr(expr):
                # self.eval_expr(expr, ctx)?
                # Ok(())

            # case Let(symbol, _, init):
                # val value = self.eval_expr(init, ctx)?
                # ctx.env_define(env, symbol, value)
                # Ok(())

            # case Assign(target, op, value):
                # val new_value = self.eval_expr(value, ctx)?
                # match target.kind:
                    # case Var(symbol):
                        # if has_op:
                            # val old_value = ctx.env_lookup(env, symbol)
                            # if old_value_is_none(old_value):
                                # return Err(BackendError.runtime_error("undefined variable", stmt.span))
                            # val combined = self.apply_assign_op(op_value, old_value_value, new_value, stmt.span)?
                            # ctx.env_assign(env, symbol, combined)
                        # else:
                            # ctx.env_assign(env, symbol, new_value)
                        # Ok(())
                    # case _:
                        # Err(BackendError.not_implemented("assignment target not implemented"))

            # case Block(block):
                # self.eval_block(block, ctx)?
                # Ok(())

    # fn is_allowed(expr: HirExpr) -> bool:
        # # Interpreter allows all expressions
        # true

    # fn is_allowed_stmt(stmt: HirStmt) -> bool:
        # # Interpreter allows all statements
        # true


# ============================================================================
# InterpreterBackendImpl Methods (was: impl InterpreterBackendImpl:)
# ============================================================================

# ============================================================================
# Exports
# ============================================================================

export InterpreterMode, InterpreterConfig, InterpreterBackendImpl
