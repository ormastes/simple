# LLVM IR Builder - Passes, IR Building, and MIR Translation
#
# LLVM optimization passes, IR builder, and MIR→LLVM IR translation.
# Split from llvm_backend.spl for modularity.

use compiler.mir_data.*
use compiler.backend.backend_api.*
use compiler.backend.llvm_target.{LlvmTargetTriple, LlvmTargetConfig, LlvmTargetTriple__from_target_with_mode, LlvmTargetConfig__for_target, LlvmTargetConfig__for_target_baremetal}
use compiler.backend.llvm_type_mapper.LlvmTypeMapper
use std.string.{NL}

# ============================================================================
# LLVM Optimization Passes
# ============================================================================

enum LlvmPass:
    """LLVM optimization passes."""
    # Analysis passes
    DominatorTree
    LoopInfo
    ScalarEvolution
    AliasAnalysis

    # Transform passes
    InstCombine
    SimplifyCFG
    Reassociate
    GVN
    LICM
    IndVarSimplify
    LoopUnroll
    LoopVectorize
    SLPVectorize
    DeadCodeElimination
    Inlining


# ============================================================================
# LlvmPass Methods (was: impl LlvmPass:)
# ============================================================================

fn passes_for_level(level: OptimizationLevel) -> [LlvmPass]:
    """Get LLVM passes for optimization level."""
    match level:
        case nil:
            []
        case Debug:
            [
                LlvmPass.InstCombine,
                LlvmPass.SimplifyCFG
            ]
        case Size:
            [
                LlvmPass.InstCombine,
                LlvmPass.SimplifyCFG,
                LlvmPass.DeadCodeElimination,
                LlvmPass.GVN
            ]
        case Speed:
            [
                LlvmPass.InstCombine,
                LlvmPass.SimplifyCFG,
                LlvmPass.Reassociate,
                LlvmPass.GVN,
                LlvmPass.LICM,
                LlvmPass.DeadCodeElimination,
                LlvmPass.Inlining
            ]
        case Aggressive:
            [
                LlvmPass.InstCombine,
                LlvmPass.SimplifyCFG,
                LlvmPass.Reassociate,
                LlvmPass.GVN,
                LlvmPass.LICM,
                LlvmPass.IndVarSimplify,
                LlvmPass.LoopUnroll,
                LlvmPass.LoopVectorize,
                LlvmPass.SLPVectorize,
                LlvmPass.DeadCodeElimination,
                LlvmPass.Inlining
            ]

# ============================================================================
# LLVM IR Builder
# ============================================================================

class LlvmIRBuilder:
    """Builds LLVM IR from MIR."""
    module_name: text
    target: LlvmTargetTriple
    instructions: [text]
    current_function: text
    local_counter: i64

    static fn create(name: text, target: LlvmTargetTriple) -> LlvmIRBuilder:
        LlvmIRBuilder(
            module_name: name,
            target: target,
            instructions: [],
            #  # DESUGARED: current_function: nil
            local_counter: 0
        )

    me emit(line: text):
        """Emit an IR line."""
        self.instructions = self.instructions_push(instructions, line)

    me emit_module_header():
        """Emit module header."""
        self.emit("; ModuleID = '{self.module_name}'")
        self.emit("source_filename = \"{self.module_name}.spl\"")
        self.emit("target triple = \"{self.target.to_text()}\"")
        self.emit("")

    me emit_baremetal_attributes():
        """Emit bare-metal module attributes (no stdlib, panic=abort, etc.)."""
        self.emit("; Bare-metal attributes")
        self.emit("!0 = !{!\"no-builtins\"}")
        self.emit("!1 = !{!\"trap-func-name\", !\"abort\"}")
        self.emit("")

    me start_function(name: text, params: [text], return_type: text):
        """Start a function definition."""
        self.current_function = name
        val param_str = params.join(", ")
        self.emit("define {return_type} @{name}({param_str}) {{")

    me end_function():
        """End a function definition."""
        self.emit("}")
        self.emit("")
        self.current_function = nil

    me fresh_local() -> text:
        """Generate a fresh local name."""
        val id = self.local_counter
        self.local_counter = self.local_counter + 1
        "%{id}"

    me emit_alloca(dest: text, ty: text):
        """Emit alloca instruction."""
        self.emit("  {dest} = alloca {ty}")

    me emit_load(dest: text, ty: text, ptr: text):
        """Emit load instruction."""
        self.emit("  {dest} = load {ty}, ptr {ptr}")

    me emit_store(ty: text, value: text, ptr: text):
        """Emit store instruction."""
        self.emit("  store {ty} {value}, ptr {ptr}")

    me emit_add(dest: text, ty: text, lhs: text, rhs: text):
        """Emit add instruction."""
        self.emit("  {dest} = add {ty} {lhs}, {rhs}")

    me emit_sub(dest: text, ty: text, lhs: text, rhs: text):
        """Emit sub instruction."""
        self.emit("  {dest} = sub {ty} {lhs}, {rhs}")

    me emit_mul(dest: text, ty: text, lhs: text, rhs: text):
        """Emit mul instruction."""
        self.emit("  {dest} = mul {ty} {lhs}, {rhs}")

    me emit_div(dest: text, ty: text, lhs: text, rhs: text):
        """Emit div instruction (signed)."""
        self.emit("  {dest} = sdiv {ty} {lhs}, {rhs}")

    me emit_call(dest: text, ret_ty: text, func: text, args: [text]):
        """Emit call instruction."""
        val args_str = args.join(", ")
        if has_dest:
            self.emit("  {dest_value} = call {ret_ty} @{func}({args_str})")
        else:
            self.emit("  call {ret_ty} @{func}({args_str})")

    me emit_ret(ty: text, value: text):
        """Emit return instruction."""
        self.emit("  ret {ty} {value}")

    me emit_ret_void():
        """Emit void return."""
        self.emit("  ret void")

    me emit_br(label: text):
        """Emit unconditional branch."""
        self.emit("  br label %{label}")

    me emit_cond_br(cond: text, true_label: text, false_label: text):
        """Emit conditional branch."""
        self.emit("  br i1 {cond}, label %{true_label}, label %{false_label}")

    me emit_label(name: text):
        """Emit a label."""
        self.emit("{name}:")

    fn build() -> text:
        """Build final IR string."""
        self.instructions.join(NL)

# ============================================================================
# MIR to LLVM IR Translation
# ============================================================================

class MirToLlvm:
    """Translates MIR to LLVM IR."""
    builder: LlvmIRBuilder
    local_map: Dict
    config: LlvmTargetConfig
    type_mapper: LlvmTypeMapper

    static fn create(module_name: text, target: CodegenTarget, cpu_override: text?) -> MirToLlvm:
        val config = LlvmTargetConfig__for_target(target, cpu_override)
        MirToLlvm(
            builder: LlvmIRBuilder__create(module_name, config.triple),
            local_map: {},
            config: config,
            type_mapper: LlvmTypeMapper__create_for_target(target)
        )

    static fn create_baremetal(module_name: text, target: CodegenTarget, cpu_override: text?) -> MirToLlvm:
        """Create MIR→LLVM translator for bare-metal targets."""
        val config = LlvmTargetConfig__for_target_baremetal(target, cpu_override)
        val builder = LlvmIRBuilder__create(module_name, config.triple)

        # Add bare-metal module attributes
        builder_emit_baremetal_attributes(builder)

        MirToLlvm(
            builder: builder,
            local_map: {},
            config: config,
            type_mapper: LlvmTypeMapper__create_for_target(target)
        )

    me translate_module(module: MirModule) -> text:
        """Translate MIR module to LLVM IR."""
        self.builder_emit_module_header(builder)

        for _for_item_0 in module.functions:
            val name = _for_item_0[0]
            val body = _for_item_0[1]
            self.translate_function(name, body)

        self.builder_build(builder)

    me translate_function(name: text, body: MirBody):
        """Translate a MIR function."""
        var params: [text] = []
        for i in 0..body.arg_count:
            params = params.push("i64 %arg{i}")

        val ret_ty = self.type_mapper_map_type(type_mapper, body.return_ty)

        self.builder_start_function(builder, name, params, ret_ty)

        for block in body.blocks:
            self.translate_block(block)

        self.builder_end_function(builder)

    me translate_block(block: MirBasicBlock):
        """Translate a MIR basic block."""
        self.builder.emit_label("bb{block.id}")

        for inst in block.instructions:
            self.translate_instruction(inst)

        self.translate_terminator(block.terminator)

    me translate_instruction(inst: MirInst):
        """Translate a MIR instruction."""
        match inst.kind:
            case Assign(dest, value):
                val dest_name = self.get_local(dest.id)

            case InlineAsm(asm_template, is_volatile, inputs, outputs, clobbers):
                self.translate_inline_asm(asm_template, is_volatile, inputs, outputs, clobbers)

            case _:
                pass

    me translate_terminator(term: MirTerminator):
        """Translate a block terminator."""
        match term.kind:
            case Return:
                self.builder_emit_ret_void(builder)
            case Goto(target):
                self.builder.emit_br("bb{target}")
            case _:
                self.builder_emit_ret_void(builder)

    me translate_inline_asm(
        asm_template: text,
        is_volatile: bool,
        inputs: [MirAsmOperand],
        outputs: [MirAsmOperand],
        clobbers: [text]
    ):
        """Translate inline assembly to LLVM inline asm call."""
        var constraint_parts: [text] = []
        var arg_values: [text] = []
        var arg_types: [text] = []

        for output in outputs:
            val constraint = self.build_output_constraint(output)
            constraint_parts_push(constraint_parts, constraint)

        for input in inputs:
            val constraint = self.build_input_constraint(input)
            constraint_parts_push(constraint_parts, constraint)

            val operand_value = self.translate_operand(input.operand)
            arg_values_push(arg_values, operand_value)
            arg_types.push("i64")

        for clobber in clobbers:
            constraint_parts.push("~{{clobber}}")

        val constraints = constraint_parts.join(",")

        var arg_list = ""
        for i in 0..arg_values_len(arg_values):
            if i > 0:
                arg_list = arg_list + ", "
            arg_list = arg_list + "{arg_types[i]} {arg_values[i]}"

        val volatile_flag = if is_volatile: " sideeffect" else: ""
        val asm_call = "  call void asm{volatile_flag} \"{asm_template}\", \"{constraints}\"({arg_list})"
        self.builder_emit(builder, asm_call)

    fn build_output_constraint(output: MirAsmOperand) -> text:
        """Build LLVM constraint string for output operand."""
        val prefix = match output.kind:
            case Out: "="
            case LateOut: "=&"
            case InOut: "+"
            case _: "="

        val location = self.constraint_location(output.location)
        "{prefix}{location}"

    fn build_input_constraint(input: MirAsmOperand) -> text:
        """Build LLVM constraint string for input operand."""
        self.constraint_location(input.location)

    fn constraint_location(location: AsmLocation) -> text:
        """Convert AsmLocation to LLVM constraint code."""
        match location:
            case Reg: "r"
            case Mem: "m"
            case Imm: "i"
            case RegSpec(name): "{{name}}"

    fn translate_operand(operand: MirOperand) -> text:
        """Translate MIR operand to LLVM value."""
        match operand.kind:
            case Copy(local):
                self.get_local(local)
            case Move(local):
                self.get_local(local)
            case Const(value, type_):
                "0"

    fn get_local(id: i64) -> text:
        """Get LLVM local name for MIR local."""
        match self.local_map_get(local_map, id):
            case name: name
            case nil:
                val name = "%l{id}"
                self.local_map[id] = name
                name

# Desugared static methods
fn LlvmIRBuilder__create(name: text, target: LlvmTargetTriple) -> LlvmIRBuilder:
    LlvmIRBuilder__create(name, target)

fn MirToLlvm__create(module_name: text, target: CodegenTarget, cpu_override: text?) -> MirToLlvm:
    MirToLlvm__create(module_name, target, cpu_override)

fn MirToLlvm__create_baremetal(module_name: text, target: CodegenTarget, cpu_override: text?) -> MirToLlvm:
    MirToLlvm__create_baremetal(module_name, target, cpu_override)

export LlvmPass, passes_for_level
export LlvmIRBuilder, MirToLlvm
export LlvmIRBuilder__create
export MirToLlvm__create, MirToLlvm__create_baremetal
