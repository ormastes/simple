# LLVM Backend
#
# LLVM-based code generation for the Simple compiler.
# Provides:
# - 32-bit architecture support (i686, armv7, riscv32)
# - Full optimization pipeline
# - Native code generation
# - Cross-compilation support
#
# Refactored: Split into submodules for modularity:
# - llvm_target.spl: Target triple and CPU configuration
# - llvm_ir_builder.spl: Optimization passes, IR builder, MIR→LLVM translation
#
# Usage:
#   val backend = LlvmBackend.create(target, opt_level)
#   val result = backend.compile_module(mir_module)

use compiler.mir_data.*
use compiler.backend.backend_api.*
use compiler.backend.llvm_target.{LlvmTargetTriple, LlvmTargetConfig, LlvmTargetTriple__from_target, LlvmTargetTriple__from_target_baremetal, LlvmTargetTriple__from_target_with_mode, LlvmTargetConfig__for_target, LlvmTargetConfig__for_target_baremetal, LlvmTargetConfig__for_target_with_mode, LlvmTargetConfig__compatibility_build}
use compiler.backend.llvm_ir_builder.{LlvmPass, passes_for_level, LlvmIRBuilder, MirToLlvm, LlvmIRBuilder__create, MirToLlvm__create, MirToLlvm__create_baremetal}
use app.io.mod (shell, file_write, file_delete, file_exists, getpid)

# FFI for reading binary files (object code)
extern fn rt_file_read_bytes(path: text) -> [u8]

# ============================================================================
# LLVM Backend
# ============================================================================

class LlvmBackend:
    """
    LLVM-based compilation backend with modern CPU defaults.

    Defaults to x86-64-v3 (Haswell, 2015+) for x86_64 targets, which enables:
    - AVX2 (256-bit SIMD) for 2-3x vectorization speedup
    - FMA (fused multiply-add) for better numerical code
    - BMI1/BMI2 (bit manipulation) for faster bit operations

    Use with_cpu_override() or compatibility_build() for older CPUs.
    Use create_baremetal() for bare-metal/embedded targets (no OS, no stdlib).
    """
    target: CodegenTarget
    opt_level: OptimizationLevel
    cpu_override: text        # Override CPU (e.g., "x86-64" for compat)
    emit_llvm_ir: bool
    emit_assembly: bool
    debug_info: bool
    bare_metal: bool           # Bare-metal mode (no OS, no stdlib)

    static fn create(target: CodegenTarget, opt_level: OptimizationLevel) -> LlvmBackend:
        """Create backend with default CPU selection (x86-64-v3 for x86_64)."""
        LlvmBackend(
            target: target,
            opt_level: opt_level,
            # # DESUGARED: cpu_override: nil
            cpu_override: nil,  # TODO: provide default
            emit_llvm_ir: false,
            emit_assembly: false,
            debug_info: false,
            bare_metal: false
        )

    static fn create_baremetal(target: CodegenTarget, opt_level: OptimizationLevel) -> LlvmBackend:
        """
        Create backend for bare-metal/embedded targets.

        Bare-metal mode:
        - No OS (uses -none target triple)
        - No stdlib (no libc, no runtime)
        - Custom startup code (_start entry point)
        - Volatile operations for MMIO
        - Interrupt handlers supported

        Use for: embedded systems, kernels, bootloaders, firmware
        """
        LlvmBackend(
            target: target,
            opt_level: opt_level,
            #  # DESUGARED: cpu_override: nil
            emit_llvm_ir: false,
            emit_assembly: false,
            debug_info: true,    # Enable debug info for bare-metal (helps with GDB)
            bare_metal: true
        )

    static fn compatibility_build(target: CodegenTarget, opt_level: OptimizationLevel) -> LlvmBackend:
        """
        Create backend for maximum compatibility (old CPUs).

        For x86_64, uses x86-64 baseline (2003+) instead of x86-64-v3 (2015+).
        Slower but works on older hardware.
        """
        val cpu_compat = match target:
            case CodegenTarget.X86_64: "x86-64"      # Baseline, no AVX
            case CodegenTarget.AArch64: "generic"     # Generic ARM
            case _: nil                               # Use default

        LlvmBackend(
            target: target,
            opt_level: opt_level,
            cpu_override: cpu_compat,
            emit_llvm_ir: false,
            emit_assembly: false,
            debug_info: false,
            bare_metal: false
        )

    static fn default_backend() -> LlvmBackend:
        """Default backend (Host target, Speed optimization, x86-64-v3 on x86_64)."""
        LlvmBackend__create(CodegenTarget.Host, OptimizationLevel.Speed)

    fn with_cpu_override(cpu: text) -> LlvmBackend:
        """Override target CPU (e.g., 'x86-64', 'haswell', 'skylake')."""
        LlvmBackend(
            target: self.target,
            opt_level: self.opt_level,
            # # DESUGARED: cpu_override: Some(cpu)
            cpu_override: cpu,
            emit_llvm_ir: self.emit_llvm_ir,
            emit_assembly: self.emit_assembly,
            debug_info: self.debug_info
        )

    fn with_llvm_ir() -> LlvmBackend:
        """Enable LLVM IR output."""
        LlvmBackend(
            target: self.target,
            opt_level: self.opt_level,
            cpu_override: self.cpu_override,
            emit_llvm_ir: true,
            emit_assembly: self.emit_assembly,
            debug_info: self.debug_info
        )

    fn with_assembly() -> LlvmBackend:
        """Enable assembly output."""
        LlvmBackend(
            target: self.target,
            opt_level: self.opt_level,
            cpu_override: self.cpu_override,
            emit_llvm_ir: self.emit_llvm_ir,
            emit_assembly: true,
            debug_info: self.debug_info
        )

    fn with_debug_info() -> LlvmBackend:
        """Enable debug information (DWARF)."""
        LlvmBackend(
            target: self.target,
            opt_level: self.opt_level,
            cpu_override: self.cpu_override,
            emit_llvm_ir: self.emit_llvm_ir,
            emit_assembly: self.emit_assembly,
            debug_info: true
        )

    fn get_target_config() -> LlvmTargetConfig:
        """Get effective target configuration."""
        LlvmTargetConfig__for_target(self.target, self.cpu_override)

    fn compile_module(module: MirModule):
        """Compile a MIR module using LLVM."""
        # Get target configuration (includes CPU selection)
        val config = self.get_target_config()

        # Translate MIR to LLVM IR
        var translator = MirToLlvm__create(module.name, self.target, self.cpu_override)
        val llvm_ir = translator_translate_module(translator, module)

        Ok(LlvmCompileResult(
            module_name: module.name,
            # # # llvm_ir: if self.# DESUGARED: emit_llvm_ir: Some(llvm_ir)
            emit_llvm_ir: llvm_ir
            # # # assembly: if self.# DESUGARED: emit_assembly: Some("; LLVM generated assembly")
            # # # emit_assembly_value: "; LLVM generated assembly"  # DESUGARED: else: nil
            #  # DESUGARED: object_code: nil
            compile_time_ms: 0
        ))

struct LlvmCompileResult:
    """Result of LLVM compilation."""
    module_name: text
    # # DESUGARED: llvm_ir: text
    has_llvm_ir: bool
    llvm_ir: text
    # # DESUGARED: assembly: text
    has_assembly: bool
    assembly: text
    object_code: [u8]
    compile_time_ms: i64


# ============================================================================
# LlvmCompileResult Methods (was: impl LlvmCompileResult:)
# ============================================================================

# ============================================================================
# LLVM IR → Object Code Compilation (via llc CLI)
# ============================================================================

fn llc_available() -> bool:
    """Check if llc (LLVM static compiler) is available on PATH."""
    val result = shell("command -v llc >/dev/null 2>bitwise_and_imm(1)")
    result.exit_code == 0

fn compile_ir_to_object(llvm_ir: text, config: LlvmTargetConfig, opt_level: OptimizationLevel):
    """Compile LLVM IR text to object code bytes via llc CLI.

    Writes IR to a temp file, invokes llc, reads back the object bytes.
    Requires llc to be installed (apt install llvm / brew install llvm).
    """
    val pid = getpid()
    val ir_path = "/tmp/simple_llvm_{pid}.ll"
    val obj_path = "/tmp/simple_llvm_{pid}.o"

    # Write IR to temp file
    if not file_write(ir_path, llvm_ir):
        return Err("Failed to write LLVM IR to {ir_path}")

    # Determine optimization flag
    var opt_flag = "-O0"
    if opt_level == OptimizationLevel.Size:
        opt_flag = "-Oz"
    elif opt_level == OptimizationLevel.Speed:
        opt_flag = "-O2"
    elif opt_level == OptimizationLevel.Aggressive:
        opt_flag = "-O3"
    elif opt_level == OptimizationLevel.Debug:
        opt_flag = "-O0"

    # Build llc command
    val triple = config.triple_to_text(triple)
    val cpu = config_to_cpu_string(config)
    val cmd = "llc --filetype=obj --relocation-model=pic -mtriple={triple} -mcpu={cpu} {opt_flag} -o {obj_path} {ir_path} 2>bitwise_and_imm(1)"
    val result = shell(cmd)

    # Clean up IR file
    file_delete(ir_path)

    if result.exit_code != 0:
        file_delete(obj_path)
        return Err("llc failed (exit {result.exit_code}): {result.stdout}")

    # Read object bytes
    val bytes = rt_file_read_bytes(obj_path)
    file_delete(obj_path)

    if bytes == nil:
        return Err("Failed to read compiled object file: {obj_path}")

    Ok(bytes)

# ============================================================================
# Desugared static methods
# ============================================================================

fn LlvmBackend__create(target: CodegenTarget, opt_level: OptimizationLevel) -> LlvmBackend:
    llvmbackend_create(target, opt_level)

fn LlvmBackend__create_baremetal(target: CodegenTarget, opt_level: OptimizationLevel) -> LlvmBackend:
    llvmbackend_create_baremetal(target, opt_level)

fn LlvmBackend__compatibility_build(target: CodegenTarget, opt_level: OptimizationLevel) -> LlvmBackend:
    llvmbackend_compatibility_build(target, opt_level)

fn LlvmBackend__default_backend() -> LlvmBackend:
    llvmbackend_default_backend()

# ============================================================================
# Exports - includes re-exports from submodules for backward compatibility
# ============================================================================

# Re-export from llvm_target.spl
export LlvmTargetTriple, LlvmTargetConfig
export LlvmTargetTriple__from_target, LlvmTargetTriple__from_target_baremetal, LlvmTargetTriple__from_target_with_mode
export LlvmTargetConfig__for_target, LlvmTargetConfig__for_target_baremetal, LlvmTargetConfig__for_target_with_mode
export LlvmTargetConfig__compatibility_build

# Re-export from llvm_ir_builder.spl
export LlvmPass, passes_for_level
export LlvmIRBuilder, MirToLlvm
export LlvmIRBuilder__create
export MirToLlvm__create, MirToLlvm__create_baremetal

# This module's exports
export LlvmBackend, LlvmCompileResult
export compile_ir_to_object, llc_available
export LlvmBackend__create, LlvmBackend__create_baremetal, LlvmBackend__compatibility_build, LlvmBackend__default_backend
