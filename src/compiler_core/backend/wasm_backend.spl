# WebAssembly Backend
#
# Compiles Simple programs to WebAssembly for browser deployment.
# Provides:
# - WASM binary generation
# - JavaScript glue code generation
# - Browser FFI via @extern("browser")
# - WASI support for non-browser environments
#
# Usage:
#   val backend = WasmBackend.create(WasmTarget.Browser)
#   val result = backend.compile_module(mir_module)
#   result.write_to_files("output")

use compiler.mir_data.*
use compiler.backend.backend_api.*
use compiler.backend.wasm_type_mapper.WasmTypeMapper

# ============================================================================
# WASM Target
# ============================================================================

enum WasmTarget:
    """WebAssembly target environment."""
    Browser     # Browser with JavaScript glue
    Wasi        # WASI for standalone/CLI
    Minimal     # Minimal runtime (no JS, no WASI)


# ============================================================================
# WasmTarget Methods (was: impl WasmTarget:)
# ============================================================================

# ============================================================================
# WASM Type System
# ============================================================================

enum WasmType:
    """WebAssembly value types."""
    I32
    I64
    F32
    F64
    FuncRef
    ExternRef


# ============================================================================
# WasmType Methods (was: impl WasmType:)
# ============================================================================

fn mir_type_to_wasm(ty: MirType, target: CodegenTarget) -> WasmType:
    """
    Convert MIR type to WASM type using shared type mapper.

    Note: For new code, consider using WasmTypeMapper directly for more control.
    This function provides backwards compatibility with existing code.
    """
    val mapper = WasmTypeMapper__create_for_target(target)
    val type_str = mapper_map_type(mapper, ty)

    # Convert text back to WasmType enum for backwards compatibility
    match type_str:
        case "i64": WasmType.I64
        case "i32": WasmType.I32
        case "f64": WasmType.F64
        case "f32": WasmType.F32
        case _: WasmType.I32  # Default for unknown types

# ============================================================================
# WASM Import/Export
# ============================================================================

struct WasmImport:
    """An imported function/global."""
    module_name: text
    field_name: text
    kind: WasmImportKind

enum WasmImportKind:
    Function(params: [WasmType], results: [WasmType])
    Global(ty: WasmType, mutable: bool)
    Memory(min_pages: i64, max_pages: i64?)
    Table(element_type: WasmType, min_size: i64, max_size: i64?)

struct WasmExport:
    """An exported function/global."""
    name: text
    kind: WasmExportKind

enum WasmExportKind:
    Function(index: i64)
    Global(index: i64)
    Memory(index: i64)
    Table(index: i64)

# ============================================================================
# Browser FFI
# ============================================================================

struct BrowserBinding:
    """A browser FFI binding from @extern("browser")."""
    simple_name: text      # Name in Simple code
    js_module: text        # JavaScript module (e.g., "console", "document")
    js_function: text      # JavaScript function name
    params: [WasmType]
    # # DESUGARED: result: WasmType
    has_result: bool
    result: WasmType


# ============================================================================
# BrowserBinding Methods (was: impl BrowserBinding:)
# ============================================================================

fn browserbinding_console_log() -> BrowserBinding:
        BrowserBinding(
            simple_name: "print",
            js_module: "console",
            js_function: "log",
            params: [WasmType.I32],  # String pointer
            ## DESUGARED: result: nil
        )


fn browserbinding_alert() -> BrowserBinding:
        BrowserBinding(
            simple_name: "alert",
            js_module: "window",
            js_function: "alert",
            params: [WasmType.I32]
            ## DESUGARED: result: nil
        )


# ============================================================================
# JavaScript Glue Code Generator
# ============================================================================

class JsGlueGenerator:
    """Generates JavaScript glue code for browser deployment."""
    bindings: [BrowserBinding]
    exports: [text]
    memory_pages: i64

    static fn create() -> JsGlueGenerator:
        JsGlueGenerator(
            bindings: [],
            exports: [],
            memory_pages: 16  # Default 1MB
        )

    me add_binding(binding: BrowserBinding):
        """Add a browser binding."""
        self.bindings = self.bindings_push(bindings, binding)

    me add_export(name: text):
        """Add an exported function."""
        self.exports = self.exports_push(exports, name)

    fn generate() -> text:
        """Generate JavaScript glue code."""
        var js = "// Generated JavaScript glue code\n"
        js = "{js}\n"

        # Memory setup
        js = "{js}const memory = new WebAssembly.Memory({{ initial: {self.memory_pages} }});\n\n"

        # String helper
        js = "{js}function readString(ptr, len) {{\n"
        js = "{js}  const bytes = new Uint8Array(memory.buffer, ptr, len);\n"
        js = "{js}  return new TextDecoder().decode(bytes);\n"
        js = "{js}}}\n\n"

        # Import object
        js = "{js}const imports = {{\n"
        js = "{js}  env: {{\n"
        js = "{js}    memory: memory,\n"
        js = "{js}  }},\n"

        # Browser bindings
        js = "{js}  browser: {{\n"
        for binding in self.bindings:
            js = "{js}    {binding.js_function}: ({self.generate_params(binding)}) => {{\n"
            js = "{js}      {self.generate_body(binding)}\n"
            js = "{js}    }},\n"
        js = "{js}  }},\n"
        js = "{js}}};\n\n"

        # Loader
        js = "{js}async function loadWasm(wasmPath) {{\n"
        js = "{js}  const response = await fetch(wasmPath);\n"
        js = "{js}  const bytes = await response.arrayBuffer();\n"
        js = "{js}  const {{ instance }} = await WebAssembly.instantiate(bytes, imports);\n"
        js = "{js}  return instance.exports;\n"
        js = "{js}}}\n\n"

        # Export list
        js = "{js}export {{ loadWasm }};\n"

        js

    fn generate_params(binding: BrowserBinding) -> text:
        var params: [text] = []
        for i in 0..binding.params_len(params):
            params = params.push("arg{i}")
        params.join(", ")

    fn generate_body(binding: BrowserBinding) -> text:
        match binding.js_module:
            case "console":
                "console.{binding.js_function}(readString(arg0, arg1));"
            case "window":
                "window.{binding.js_function}(readString(arg0, arg1));"
            case _:
                "{binding.js_module}.{binding.js_function}();"

# ============================================================================
# WASM Text Format (WAT) Builder
# ============================================================================

class WatBuilder:
    """Builds WebAssembly text format."""
    lines: [text]
    indent_level: i64

    static fn create() -> WatBuilder:
        WatBuilder(lines: [], indent_level: 0)

    me emit(line: text):
        """Emit a line with current indentation."""
        val indent = "  ".repeat(self.indent_level)
        self.lines = self.lines.push("{indent}{line}")

    me begin_module(name: text):
        """Start a module."""
        self.emit("(module ${name}")
        self.indent_level = self.indent_level + 1

    me end_module():
        """End a module."""
        self.indent_level = self.indent_level - 1
        self.emit(")")

    me emit_import(import_def: WasmImport):
        """Emit an import."""
        match import_def.kind:
            case Function(params, results):
                var param_strs: [text] = []
                for t in params:
                    param_strs.push(t.to_text())
                val param_str = param_strs.join(" ")
                var result_strs: [text] = []
                for t in results:
                    result_strs.push(t.to_text())
                val result_str = result_strs.join(" ")
                self.emit("(import \"{import_def.module_name}\" \"{import_def.field_name}\" (func (param {param_str}) (result {result_str})))")
            case Memory(min, max):
                val max_str = if has_max: " {max_value}" else: ""
                self.emit("(import \"{import_def.module_name}\" \"{import_def.field_name}\" (memory {min}{max_str}))")
            case _:

    me emit_export(export_def: WasmExport):
        """Emit an export."""
        match export_def.kind:
            case Function(idx):
                self.emit("(export \"{export_def.name}\" (func {idx}))")
            case Memory(idx):
                self.emit("(export \"{export_def.name}\" (memory {idx}))")
            case _:
                pass

    me begin_func(name: text, params: [WasmType], results: [WasmType]):
        """Start a function."""
        var param_strs: [text] = []
        for t in params:
            param_strs.push("(param {t.to_text()})")
        val param_str = param_strs.join(" ")
        var result_strs: [text] = []
        for t in results:
            result_strs.push("(result {t.to_text()})")
        val result_str = result_strs.join(" ")
        self.emit("(func ${name} {param_str} {result_str}")
        self.indent_level = self.indent_level + 1

    me end_func():
        """End a function."""
        self.indent_level = self.indent_level - 1
        self.emit(")")

    me emit_local(ty: WasmType):
        """Emit a local variable."""
        self.emit("(local {ty.to_text()})")

    me emit_i32_const(value: i64):
        """Emit i32.const."""
        self.emit("i32.const {value}")

    me emit_i64_const(value: i64):
        """Emit i64.const."""
        self.emit("i64.const {value}")

    me emit_local_get(idx: i64):
        """Emit local.get."""
        self.emit("local.get {idx}")

    me emit_local_set(idx: i64):
        """Emit local.set."""
        self.emit("local.set {idx}")

    me emit_call(func_idx: i64):
        """Emit call."""
        self.emit("call {func_idx}")

    me emit_return():
        """Emit return."""
        self.emit("return")

    fn build() -> text:
        """Build final WAT string."""
        self.lines.join("\n")

# ============================================================================
# WASM Backend
# ============================================================================

class WasmBackend:
    """WebAssembly compilation backend."""
    target: WasmTarget
    opt_level: OptimizationLevel
    memory_pages: i64
    browser_bindings: [BrowserBinding]
    type_mapper: WasmTypeMapper     # Type mapper for MIR â†’ Wasm types

    static fn create(target: WasmTarget) -> WasmBackend:
        # Default to Wasm32 (most common target)
        val codegen_target = CodegenTarget.Wasm32
        WasmBackend(
            target: target,
            opt_level: OptimizationLevel.Size,  # Default to size opt for WASM
            memory_pages: 16,
            browser_bindings: [],
            type_mapper: WasmTypeMapper__create_for_target(codegen_target)
        )

    static fn browser() -> WasmBackend:
        WasmBackend__create(WasmTarget.Browser)

    static fn wasi() -> WasmBackend:
        WasmBackend__create(WasmTarget.Wasi)

    me add_browser_binding(binding: BrowserBinding):
        """Add a browser FFI binding."""
        self.browser_bindings = self.browser_bindings_push(browser_bindings, binding)

    fn compile_module(module: MirModule) -> text:
        """Compile a MIR module to WebAssembly."""
        # Build WAT
        var builder = WatBuilder__create()
        builder_begin_module(builder, module.name)

        # Add imports based on target
        if self.target == WasmTarget.Browser:
            for binding in self.browser_bindings:
                builder_emit_import(builder, binding.to_import())

        # Add memory
        builder.emit("(memory 1)")
        builder.emit_export(WasmExport(
            name: "memory",
            kind: wasmexportkind_Memory(0)
        ))

        # Translate functions
        for _for_item_0 in module.functions:
            val name = _for_item_0[0]
            val body = _for_item_0[1]
            self.translate_function(builder, name, body, self.type_mapper)

        builder_end_module(builder)

        val wat = builder_build(builder)

        # Generate JS glue if needed
        var js_glue: text = nil
        if self.target_needs_js_glue(target):
            var glue_gen = JsGlueGenerator__create()
            for binding in self.browser_bindings:
                glue_gen_add_binding(glue_gen, binding)
            for _for_item_1 in module.functions:
                val name = _for_item_1[0]
                val _unused_1 = _for_item_1[1]
                glue_gen_add_export(glue_gen, name)
            js_glue = glue_gen_generate(glue_gen)

        Ok(WasmCompileResult(
            module_name: module.name,
            wat: wat,
            # # DESUGARED: wasm: nil
            wasm: nil,  # TODO: provide default
            js_glue: js_glue,
            compile_time_ms: 0
        ))

    fn translate_function(
        builder: WatBuilder,
        name: text,
        body: MirBody,
        type_mapper: WasmTypeMapper
    ):
        """Translate a MIR function to WAT using shared type mapper."""
        var params: [WasmType] = []
        for _unused in 0..body.arg_count:
            params = params_push(params, WasmType.I64)

        var results: [WasmType] = []
        if body.return_ty.kind != MirTypeKind.Unit:
            # Use type mapper and convert text to WasmType
            val type_str = type_mapper_map_type(type_mapper, body.return_ty)
            val wasm_type = match type_str:
                case "i64": WasmType.I64
                case "i32": WasmType.I32
                case "f64": WasmType.F64
                case "f32": WasmType.F32
                case _: WasmType.I32
            results = [wasm_type]

        builder_begin_func(builder, name, params, results)

        # Would translate MIR to WASM instructions here

        builder_end_func(builder)

struct WasmCompileResult:
    """Result of WASM compilation."""
    module_name: text
    wat: text                # WebAssembly text format
    wasm: [u8]             # WebAssembly binary
    # # DESUGARED: js_glue: text
    has_js_glue: bool
    js_glue: text
    compile_time_ms: i64


# ============================================================================
# WasmCompileResult Methods (was: impl WasmCompileResult:)
# ============================================================================

# ============================================================================
# Exports
# ============================================================================

export WasmTarget, WasmType, mir_type_to_wasm
export WasmImport, WasmImportKind, WasmExport, WasmExportKind
export BrowserBinding, JsGlueGenerator
export WatBuilder, WasmBackend, WasmCompileResult
