# Codegen Errors
#
# Standardized error handling for code generation.
# All error types are defined in Simple for consistency.

use core.lexer.Span
use std.string.{NL}

# ============================================================================
# Error Types
# ============================================================================

enum CodegenErrorKind:
    """Type of codegen error."""
    ModuleInitFailed
    FunctionDeclFailed
    FunctionCompileFailed
    VerificationFailed     # IR verification errors
    InvalidSignature
    UnsupportedType
    UnsupportedInstruction
    InvalidTarget
    FinalizationFailed
    ObjectEmitFailed
    JitExecutionFailed
    UnknownFunction
    InvalidFunctionCall
    RuntimeError
    NameConflict          # Function name conflicts with runtime

struct CodegenError:
    """Error during code generation."""
    kind: CodegenErrorKind
    message: text
    # # DESUGARED: function_name: text
    has_function_name: bool
    function_name: text
    # # DESUGARED: span: Span
    has_span: bool
    span: Span
    # # DESUGARED: cause: text
    has_cause: bool
    cause: text


# ============================================================================
# CodegenError Methods (was: impl CodegenError:)
# ============================================================================

fn codegenerror_new(kind: CodegenErrorKind, message: text) -> CodegenError:
        CodegenError(
            kind: kind,
            message: message
            #  # DESUGARED: function_name: nil
            #  # DESUGARED: span: nil
            ## DESUGARED: cause: nil
        )


fn codegenerror_module_init(message: text) -> CodegenError:
        codegenerror_new(CodegenErrorKind.ModuleInitFailed, message)


fn codegenerror_function_decl(func_name: text, message: text) -> CodegenError:
        CodegenError(
            kind: CodegenErrorKind.FunctionDeclFailed,
            message: message,
            # # DESUGARED: function_name: Some(func_name)
            function_name: func_name
            #  # DESUGARED: span: nil
            ## DESUGARED: cause: nil
        )


fn codegenerror_function_compile(func_name: text, message: text) -> CodegenError:
        CodegenError(
            kind: CodegenErrorKind.FunctionCompileFailed,
            message: message,
            # # DESUGARED: function_name: Some(func_name)
            function_name: func_name
            #  # DESUGARED: span: nil
            ## DESUGARED: cause: nil
        )


fn codegenerror_unsupported_type(type_name: text) -> CodegenError:
        CodegenError.new(
            CodegenErrorKind.UnsupportedType,
            "unsupported type: {type_name}"
        )


fn codegenerror_unsupported_instruction(inst: text) -> CodegenError:
        CodegenError.new(
            CodegenErrorKind.UnsupportedInstruction,
            "unsupported instruction: {inst}"
        )


fn codegenerror_invalid_target(target: text) -> CodegenError:
        CodegenError.new(
            CodegenErrorKind.InvalidTarget,
            "invalid target: {target}"
        )


fn codegenerror_finalization_failed(message: text) -> CodegenError:
        codegenerror_new(CodegenErrorKind.FinalizationFailed, message)


fn codegenerror_unknown_function(name: text) -> CodegenError:
        CodegenError.new(
            CodegenErrorKind.UnknownFunction,
            "unknown function: {name}"
        )


fn codegenerror_verification_failed(func_name: text, errors: text) -> CodegenError:
        CodegenError(
            kind: CodegenErrorKind.VerificationFailed,
            message: "IR verification failed",
            # # DESUGARED: function_name: Some(func_name)
            function_name: func_name,
            #  # DESUGARED: span: nil
            # # DESUGARED: cause: Some(errors)
            cause: errors
        )


fn codegenerror_name_conflict(name: text, conflict: text) -> CodegenError:
        CodegenError.new(
            CodegenErrorKind.NameConflict,
            "function '{name}' conflicts with {conflict}"
        )


fn codegenerror_with_function(self: CodegenError, func_name: text) -> CodegenError:
        """Add function name context."""
        self.function_name = func_name
        self


fn codegenerror_with_span(self: CodegenError, span: Span) -> CodegenError:
        """Add source location context."""
        self.span = span
        self


fn codegenerror_with_cause(self: CodegenError, cause: text) -> CodegenError:
        """Add underlying error cause."""
        self.cause = cause
        self


# ============================================================================
# Error Formatting Helpers
# ============================================================================

fn format_compile_error(func_name: text, stage: text, error: text) -> text:
    """Format compilation error message."""
    "failed to compile '{func_name}' at {stage}: {error}"

fn format_verification_error(func_name: text, errors: text) -> text:
    """Format IR verification error."""
    "verification errors in '{func_name}':{NL}{errors}"

fn format_runtime_error(func_name: text, error: text) -> text:
    """Format runtime execution error."""
    "runtime error in '{func_name}': {error}"

# ============================================================================
# Error Recovery
# ============================================================================

struct ErrorRecoveryStrategy:
    """Strategy for recovering from errors."""
    continue_on_error: bool
    create_stubs: bool
    max_errors: i64


# ============================================================================
# ErrorRecoveryStrategy Methods (was: impl ErrorRecoveryStrategy:)
# ============================================================================

fn errorrecoverystrategy_strict() -> ErrorRecoveryStrategy:
        """Fail on first error."""
        ErrorRecoveryStrategy(
            continue_on_error: false,
            create_stubs: false,
            max_errors: 1
        )


fn errorrecoverystrategy_lenient() -> ErrorRecoveryStrategy:
        """Continue on errors, create stubs."""
        ErrorRecoveryStrategy(
            continue_on_error: true,
            create_stubs: true,
            max_errors: 100
        )


fn errorrecoverystrategy_testing() -> ErrorRecoveryStrategy:
        """Continue on errors for testing."""
        ErrorRecoveryStrategy(
            continue_on_error: true,
            create_stubs: true,
            max_errors: 1000
        )


struct ErrorContext:
    """Context for error accumulation."""
    errors: [CodegenError]
    warnings: [CodegenError]
    strategy: ErrorRecoveryStrategy


# ============================================================================
# ErrorContext Methods (was: impl ErrorContext:)
# ============================================================================

fn errorcontext_new(strategy: ErrorRecoveryStrategy) -> ErrorContext:
        ErrorContext(
            errors: [],
            warnings: [],
            strategy: strategy
        )


# ============================================================================
# Exports
# ============================================================================

export CodegenErrorKind, CodegenError
export ErrorRecoveryStrategy, ErrorContext
export format_compile_error, format_verification_error, format_runtime_error
