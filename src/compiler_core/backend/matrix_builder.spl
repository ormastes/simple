"""{NL}# Backend Support Matrix Builder{NL}{NL}Generates support matrix documentation showing which backends support which instructions.{NL}{NL}**Phase:** 3 - Documentation Generation{NL}**Status:** Complete{NL}"""{NL}{NL}use compiler.backend.capability_tracker.{{NL}    CapabilityTracker, InstructionCategory, create_default_tracker{NL}}{NL}use std.text.{NL}{NL}{NL}# Matrix builder{NL}class MatrixBuilder:{NL}    tracker: CapabilityTracker{NL}{NL}    # Generate markdown table for all instructions{NL}    fn generate_full_matrix() -> text:{NL}        var output = "# Backend Instruction Support Matrix\n\n"{NL}        output = output + "| Instruction | Category | Cranelift | LLVM | Vulkan | Interpreter |\n"{NL}        output = output + "|-------------|----------|-----------|------|--------|-------------|\n"{NL}{NL}        for inst in self.tracker.instructions:{NL}            val cran = if inst.cranelift: "âœ…" else: "âŒ"{NL}            val llvm_ = if inst.llvm: "âœ…" else: "âŒ"{NL}            val vulk = if inst.vulkan: "âœ…" else: "âŒ"{NL}            val interp = if inst.interpreter: "âœ…" else: "âŒ"{NL}{NL}            val cat_name = self.category_to_string(inst.category){NL}{NL}            output = output + "| {inst.instruction_name} | {cat_name} | {cran} | {llvm_} | {vulk} | {interp} |\n"{NL}{NL}        output{NL}{NL}    # Generate summary statistics{NL}    fn generate_summary() -> text:{NL}        var output = "## Backend Coverage Summary\n\n"{NL}{NL}        val cran_cov = self.tracker.get_coverage("cranelift"){NL}        val llvm_cov = self.tracker.get_coverage("llvm"){NL}        val vulk_cov = self.tracker.get_coverage("vulkan"){NL}        val interp_cov = self.tracker.get_coverage("interpreter"){NL}{NL}        output = output + "| Backend | Coverage | Status |\n"{NL}        output = output + "|---------|----------|--------|\n"{NL}        output = output + "| Cranelift | {cran_cov}% | {self.coverage_status(cran_cov)} |\n"{NL}        output = output + "| LLVM | {llvm_cov}% | {self.coverage_status(llvm_cov)} |\n"{NL}        output = output + "| Vulkan | {vulk_cov}% | {self.coverage_status(vulk_cov)} |\n"{NL}        output = output + "| Interpreter | {interp_cov}% | {self.coverage_status(interp_cov)} |\n"{NL}{NL}        output{NL}{NL}    # Generate category breakdown{NL}    fn generate_category_matrix() -> text:{NL}        var output = "## Support by Category\n\n"{NL}{NL}        output = output + self.generate_category_section(InstructionCategory.Constants){NL}        output = output + self.generate_category_section(InstructionCategory.Arithmetic){NL}        output = output + self.generate_category_section(InstructionCategory.ControlFlow){NL}        output = output + self.generate_category_section(InstructionCategory.SIMD){NL}        output = output + self.generate_category_section(InstructionCategory.GPU){NL}        output = output + self.generate_category_section(InstructionCategory.Async){NL}{NL}        output{NL}{NL}    # Generate section for one category{NL}    fn generate_category_section(cat: InstructionCategory) -> text:{NL}        val cat_name = self.category_to_string(cat){NL}        var output = "### {cat_name}\n\n"{NL}{NL}        val insts = self.tracker_get_by_category(tracker, cat){NL}        if insts_len(insts) == 0:{NL}            return output + "No instructions in this category.\n\n"{NL}{NL}        output = output + "| Instruction | Cranelift | LLVM | Vulkan | Interpreter |\n"{NL}        output = output + "|-------------|-----------|------|--------|-------------|\n"{NL}{NL}        for inst in insts:{NL}            val cran = if inst.cranelift: "âœ…" else: "âŒ"{NL}            val llvm_ = if inst.llvm: "âœ…" else: "âŒ"{NL}            val vulk = if inst.vulkan: "âœ…" else: "âŒ"{NL}            val interp = if inst.interpreter: "âœ…" else: "âŒ"{NL}{NL}            output = output + "| {inst.instruction_name} | {cran} | {llvm_} | {vulk} | {interp} |\n"{NL}{NL}        output = output + "\n"{NL}        output{NL}{NL}    # Helper: category to string{NL}    fn category_to_string(cat: InstructionCategory) -> text:{NL}        if cat == InstructionCategory.Constants:{NL}            "Constants"{NL}        elif cat == InstructionCategory.Arithmetic:{NL}            "Arithmetic"{NL}        elif cat == InstructionCategory.Bitwise:{NL}            "Bitwise"{NL}        elif cat == InstructionCategory.Comparison:{NL}            "Comparison"{NL}        elif cat == InstructionCategory.Memory:{NL}            "Memory"{NL}        elif cat == InstructionCategory.ControlFlow:{NL}            "Control Flow"{NL}        elif cat == InstructionCategory.Collections:{NL}            "Collections"{NL}        elif cat == InstructionCategory.SIMD:{NL}            "SIMD"{NL}        elif cat == InstructionCategory.GPU:{NL}            "GPU"{NL}        elif cat == InstructionCategory.Pointers:{NL}            "Pointers"{NL}        elif cat == InstructionCategory.Structs:{NL}            "Structs"{NL}        elif cat == InstructionCategory.Enums:{NL}            "Enums"{NL}        elif cat == InstructionCategory.Async:{NL}            "Async"{NL}        elif cat == InstructionCategory.ErrorHandling:{NL}            "Error Handling"{NL}        elif cat == InstructionCategory.Closures:{NL}            "Closures"{NL}        else:{NL}            "Unknown"{NL}{NL}    # Helper: coverage status{NL}    fn coverage_status(pct: i32) -> text:{NL}        if pct >= 90:{NL}            "ğŸŸ¢ Excellent"{NL}        elif pct >= 70:{NL}            "ğŸŸ¡ Good"{NL}        elif pct >= 50:{NL}            "ğŸŸ  Partial"{NL}        else:{NL}            "ğŸ”´ Limited"{NL}{NL}# Create builder with default tracker{NL}fn create_matrix_builder() -> MatrixBuilder:{NL}    MatrixBuilder(tracker: create_default_tracker()){NL}{NL}# Generate complete documentation{NL}fn generate_complete_docs() -> text:{NL}    val builder = create_matrix_builder(){NL}    var output = ""{NL}{NL}    output = output + builder_generate_summary(builder){NL}    output = output + "\n---\n\n"{NL}    output = output + builder_generate_category_matrix(builder){NL}    output = output + "\n---\n\n"{NL}    output = output + builder_generate_full_matrix(builder){NL}{NL}    output{NL}{NL}export MatrixBuilder, create_matrix_builder, generate_complete_docs{NL}