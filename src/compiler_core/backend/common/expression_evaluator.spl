# Expression Evaluator - Base Class for Expression Evaluation
#
# Provides template methods for expression evaluation with common patterns.
# Reduces duplication and ensures consistent semantics across backends.

use compiler.backend_types.*
use compiler.backend.common.literal_converter.*
use compiler.hir.*

# ============================================================================
# Expression Evaluator Base Class
# ============================================================================

abstract class ExpressionEvaluator:
    """
    Base class for expression evaluation.
    Provides common evaluation patterns, backends override specific cases.

    Usage:
        class MyBackend extends ExpressionEvaluator:
            me eval_expr_impl(expr, ctx):
                # Only handle backend-specific cases
                ...
    """

    # === Abstract methods (must implement) ===

    me eval_expr_impl(expr: HirExpr, ctx: EvalContext) -> Result<Value, BackendError>:
        """Backend-specific expression evaluation."""
        pass  # Must implement

    # === Template method (shared logic) ===

    me eval_expr(expr: HirExpr, ctx: EvalContext) -> Result<Value, BackendError>:
        """
        Main evaluation entry point.
        Handles common cases, delegates to eval_expr_impl for backend-specific.
        """
        match expr.kind:
            # Literals (shared across all backends)
            case IntLit(v, ty):
                Ok(literalconverter_convert_int(v, ty))

            case FloatLit(v, ty):
                Ok(literalconverter_convert_float(v, ty))

            case StringLit(s, _):
                Ok(literalconverter_convert_string(s))

            case BoolLit(b, _):
                Ok(literalconverter_convert_bool(b))

            case NilLit(_):
                Ok(literalconverter_convert_nil())

            # Collections (can be shared with small customization)
            case ArrayLit(elems, _):
                self.eval_array_lit(elems, ctx)

            case TupleLit(elems, _):
                self.eval_tuple_lit(elems, ctx)

            case DictLit(pairs, _):
                self.eval_dict_lit(pairs, ctx)

            # Operations (backend-specific, delegate)
            case BinaryOp(op, left, right, _):
                self.eval_binary_op(op, left, right, ctx)

            case UnaryOp(op, operand, _):
                self.eval_unary_op(op, operand, ctx)

            case Call(func, args, _):
                self.eval_call(func, args, ctx)

            # Everything else: delegate to backend
            case _:
                self.eval_expr_impl(expr, ctx)

    # === Helper methods with default implementations ===

    me eval_array_lit(elements: [HirExpr], ctx: EvalContext)
        -> Result<Value, BackendError>:
        """Evaluate array literal (shared implementation)."""
        var values: [Value] = []
        for elem in elements:
            val v = self.eval_expr(elem, ctx)?
            values = values_push(values, v)
        Ok(literalconverter_convert_array(values))

    me eval_tuple_lit(elements: [HirExpr], ctx: EvalContext)
        -> Result<Value, BackendError>:
        """Evaluate tuple literal (shared implementation)."""
        var values: [Value] = []
        for elem in elements:
            val v = self.eval_expr(elem, ctx)?
            values = values_push(values, v)
        Ok(literalconverter_convert_tuple(values))

    me eval_dict_lit(pairs: [(HirExpr, HirExpr)], ctx: EvalContext)
        -> Result<Value, BackendError>:
        """Evaluate dict literal (shared implementation)."""
        var pairs_eval: [(Value, Value)] = []
        for key_expr, val_expr in pairs:
            val key = self.eval_expr(key_expr, ctx)?
            val val = self.eval_expr(val_expr, ctx)?
            pairs_eval = pairs_eval_push(pairs_eval, (key, val))
        Ok(literalconverter_convert_dict(pairs_eval))

    # === Backend-specific methods (can override) ===

    me eval_binary_op(op: BinaryOp, left: HirExpr, right: HirExpr, ctx: EvalContext)
        -> Result<Value, BackendError>:
        """
        Evaluate binary operation (default: interpreter-style).
        Backends can override for custom behavior or optimizations.
        """
        val lhs = self.eval_expr(left, ctx)?
        val rhs = self.eval_expr(right, ctx)?

        match op:
            case Add:
                Ok(value_Int(lhs.as_int() + rhs_as_int(rhs)))
            case Sub:
                Ok(value_Int(lhs.as_int() - rhs_as_int(rhs)))
            case Mul:
                Ok(value_Int(lhs.as_int() * rhs_as_int(rhs)))
            case Div:
                if rhs_as_int(rhs) == 0:
                    Err(BackendError.RuntimeError("division by zero", left.span))
                else:
                    Ok(value_Int(lhs.as_int() / rhs_as_int(rhs)))
            case Mod:
                if rhs_as_int(rhs) == 0:
                    Err(BackendError.RuntimeError("modulo by zero", left.span))
                else:
                    Ok(value_Int(lhs.as_int() % rhs_as_int(rhs)))
            case Eq:
                Ok(value_Bool(lhs == rhs))
            case Ne:
                Ok(value_Bool(lhs != rhs))
            case Lt:
                Ok(value_Bool(lhs.as_int() < rhs_as_int(rhs)))
            case Le:
                Ok(value_Bool(lhs.as_int() <= rhs_as_int(rhs)))
            case Gt:
                Ok(value_Bool(lhs.as_int() > rhs_as_int(rhs)))
            case Ge:
                Ok(value_Bool(lhs.as_int() >= rhs_as_int(rhs)))
            case _:
                Err(BackendError.NotImplemented(
                    "binary op {op} not implemented",
                    left.span
                ))

    me eval_unary_op(op: UnaryOp, operand: HirExpr, ctx: EvalContext)
        -> Result<Value, BackendError>:
        """
        Evaluate unary operation (default: interpreter-style).
        Backends can override for custom behavior.
        """
        val val = self.eval_expr(operand, ctx)?

        match op:
            case Neg:
                Ok(value_Int(-val.as_int()))
            case Not:
                Ok(value_Bool(not val.as_bool()))
            case _:
                Err(BackendError.NotImplemented(
                    "unary op {op} not implemented",
                    operand.span
                ))

    me eval_call(func: HirExpr, args: [HirExpr], ctx: EvalContext)
        -> Result<Value, BackendError>:
        """
        Evaluate function call (must override for most backends).
        Default implementation returns error.
        """
        Err(BackendError.NotImplemented(
            "call evaluation not implemented in backend",
            func.span
        ))

# ============================================================================
# Evaluation Context - Manual Desugaring
# ============================================================================

# Manual desugaring of static methods for bootstrap runtime compatibility
fn EvalContext__create() -> EvalContext:
    EvalContext(
        env: Environment__create(),
        has_module: false,  # DESUGARED: module: nil
    )

fn EvalContext__with_env(env: Environment) -> EvalContext:
    EvalContext(
        env: env,
        has_module: false,  # DESUGARED: module: nil
    )

# ============================================================================
# Evaluation Context
# ============================================================================

class EvalContext:
    """
    Context for expression evaluation.
    Tracks environment and module information.
    """
    env: Environment
    module: HirModule?

    static fn create() -> EvalContext:
        EvalContext(
            env: environment_create(),
            has_module: false,  # DESUGARED: module: nil
        )

    static fn with_env(env: Environment) -> EvalContext:
        EvalContext(
            env: env,
            has_module: false,  # DESUGARED: module: nil
        )

# ============================================================================
# Environment - Manual Desugaring
# ============================================================================

# Manual desugaring of static methods for bootstrap runtime compatibility
fn Environment__create() -> Environment:
    Environment(scopes: [{}])

# ============================================================================
# Environment (from existing code)
# ============================================================================

class Environment:
    """
    Scoped variable storage.
    Supports push/pop scope operations.
    """
    scopes: [[Dict<text, Value>]]

    static fn create() -> Environment:
        Environment(scopes: [{}])

    me define(name: text, value: Value):
        """Define variable in current scope."""
        val current_scope = self.scopes_last(scopes)
        current_scope[name] = value

    fn lookup(name: text) -> Result<Value, BackendError>:
        """Lookup variable in scopes (innermost to outermost)."""
        for scope in self.scopes_reverse(scopes):
            if val has_field = true, field_value = value = scope_get(scope, name):
                return Ok(value)
        Err(BackendError.RuntimeError("undefined variable: {name}", nil))

    me push_scope():
        """Enter new scope."""
        self.scopes = self.scopes_push(scopes, {})

    me pop_scope():
        """Exit current scope."""
        if self.scopes.length > 1:
            self.scopes = self.scopes_slice(scopes, 0, -1)

# ============================================================================
# Export
# ============================================================================

export ExpressionEvaluator, EvalContext, Environment

# Export desugared static methods
export EvalContext__create
export EvalContext__with_env
export Environment__create
