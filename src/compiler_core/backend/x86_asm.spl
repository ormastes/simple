# x86/x86_64 Inline Assembly Backend
#
# Generates x86/x86_64 assembly from inline asm blocks.

use compiler.inline_asm.{InlineAsm, AsmOperand, AsmRegister, AsmOption}
use std.common.target.{TargetArch}

# ===========================================================================
# x86 Register Allocation
# ===========================================================================

class X86RegisterAllocator:
    """Allocates x86 registers for inline assembly."""
    arch: TargetArch
    used_regs: Dict<text, bool>


# ============================================================================
# X86RegisterAllocator Methods (was: impl X86RegisterAllocator:)
# ============================================================================

fn x86registerallocator_new(arch: TargetArch) -> X86RegisterAllocator:
        X86RegisterAllocator(
            arch: arch,
            used_regs: {}
        )


# ===========================================================================
# x86 Assembly Generator
# ===========================================================================

class X86AsmGenerator:
    """Generates x86/x86_64 assembly."""
    arch: TargetArch
    allocator: X86RegisterAllocator


# ============================================================================
# X86AsmGenerator Methods (was: impl X86AsmGenerator:)
# ============================================================================

fn x86asmgenerator_new(arch: TargetArch) -> X86AsmGenerator:
        X86AsmGenerator(
            arch: arch,
            allocator: x86registerallocator_new(arch)
        )


# ===========================================================================
# x86-Specific Instructions
# ===========================================================================

# Common x86 instruction helpers
fn cli() -> InlineAsm:
    """Clear interrupts (disable interrupts)."""
    var asm = InlineAsm.new(["cli"], Span.empty())
    asm_add_option(asm, AsmOption.Volatile)
    asm

fn sti() -> InlineAsm:
    """Set interrupts (enable interrupts)."""
    var asm = InlineAsm.new(["sti"], Span.empty())
    asm_add_option(asm, AsmOption.Volatile)
    asm

fn hlt() -> InlineAsm:
    """Halt processor."""
    var asm = InlineAsm.new(["hlt"], Span.empty())
    asm_add_option(asm, AsmOption.Volatile)
    asm

fn nop() -> InlineAsm:
    """No operation."""
    InlineAsm.new(["nop"], Span.empty())

fn rdmsr(msr: i32) -> InlineAsm:
    """Read model-specific register."""
    var asm = InlineAsm.new(["rdmsr"], Span.empty())
    asm_add_option(asm, AsmOption.Volatile)
    # Input: ecx = MSR number
    # Output: edx:eax = MSR value
    asm

fn wrmsr(msr: i32, value: i64) -> InlineAsm:
    """Write model-specific register."""
    var asm = InlineAsm.new(["wrmsr"], Span.empty())
    asm_add_option(asm, AsmOption.Volatile)
    asm

fn cpuid() -> InlineAsm:
    """CPU identification."""
    var asm = InlineAsm.new(["cpuid"], Span.empty())
    asm_add_option(asm, AsmOption.Volatile)
    # Input: eax = function number
    # Output: eax, ebx, ecx, edx = results
    asm.add_clobber("eax")
    asm.add_clobber("ebx")
    asm.add_clobber("ecx")
    asm.add_clobber("edx")
    asm

fn inb(port: i32) -> InlineAsm:
    """Input byte from I/O port."""
    var asm = InlineAsm.new(["in al, dx"], Span.empty())
    asm_add_option(asm, AsmOption.Volatile)
    asm

fn outb(port: i32, value: i32) -> InlineAsm:
    """Output byte to I/O port."""
    var asm = InlineAsm.new(["out dx, al"], Span.empty())
    asm_add_option(asm, AsmOption.Volatile)
    asm

fn inw(port: i32) -> InlineAsm:
    """Input word from I/O port."""
    var asm = InlineAsm.new(["in ax, dx"], Span.empty())
    asm_add_option(asm, AsmOption.Volatile)
    asm

fn outw(port: i32, value: i32) -> InlineAsm:
    """Output word to I/O port."""
    var asm = InlineAsm.new(["out dx, ax"], Span.empty())
    asm_add_option(asm, AsmOption.Volatile)
    asm

fn inl(port: i32) -> InlineAsm:
    """Input long from I/O port."""
    var asm = InlineAsm.new(["in eax, dx"], Span.empty())
    asm_add_option(asm, AsmOption.Volatile)
    asm

fn outl(port: i32, value: i32) -> InlineAsm:
    """Output long to I/O port."""
    var asm = InlineAsm.new(["out dx, eax"], Span.empty())
    asm_add_option(asm, AsmOption.Volatile)
    asm

# Memory barriers
fn mfence() -> InlineAsm:
    """Memory fence (full)."""
    InlineAsm.new(["mfence"], Span.empty())

fn lfence() -> InlineAsm:
    """Load fence."""
    InlineAsm.new(["lfence"], Span.empty())

fn sfence() -> InlineAsm:
    """Store fence."""
    InlineAsm.new(["sfence"], Span.empty())

# Atomic operations
fn lock_prefix() -> text:
    "lock"

fn xchg(ptr: text, value: text) -> InlineAsm:
    """Atomic exchange."""
    InlineAsm.new(["lock xchg [{ptr}], {value}"], Span.empty())

fn cmpxchg(ptr: text, old: text, new: text) -> InlineAsm:
    """Compare and exchange."""
    InlineAsm.new(["lock cmpxchg [{ptr}], {new}"], Span.empty())

# Control register access
fn read_cr0() -> InlineAsm:
    """Read CR0."""
    var asm = InlineAsm.new(["mov rax, cr0"], Span.empty())
    asm_add_option(asm, AsmOption.Volatile)
    asm

fn write_cr0(value: i64) -> InlineAsm:
    """Write CR0."""
    var asm = InlineAsm.new(["mov cr0, rax"], Span.empty())
    asm_add_option(asm, AsmOption.Volatile)
    asm

fn read_cr3() -> InlineAsm:
    """Read CR3 (page directory base)."""
    var asm = InlineAsm.new(["mov rax, cr3"], Span.empty())
    asm_add_option(asm, AsmOption.Volatile)
    asm

fn write_cr3(value: i64) -> InlineAsm:
    """Write CR3 (flush TLB)."""
    var asm = InlineAsm.new(["mov cr3, rax"], Span.empty())
    asm_add_option(asm, AsmOption.Volatile)
    asm

# ===========================================================================
# Exports
# ===========================================================================

export X86RegisterAllocator, X86AsmGenerator
export cli, sti, hlt, nop
export rdmsr, wrmsr, cpuid
export inb, outb, inw, outw, inl, outl
export mfence, lfence, sfence
export lock_prefix, xchg, cmpxchg
export read_cr0, write_cr0, read_cr3, write_cr3
