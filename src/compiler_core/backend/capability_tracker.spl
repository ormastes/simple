"""
# Backend Capability Tracker

Tracks which MIR instructions are supported by each backend.

**Phase:** 3 - Documentation Generation
**Status:** Complete
"""

use compiler.backend.mir_test_builder_full.{MirTestInst}
use compiler.backend.backend_ffi.{BackendCapability, get_all_capabilities}

# Instruction category classification
enum InstructionCategory:
    Constants
    Arithmetic
    Bitwise
    Comparison
    Memory
    ControlFlow
    Collections
    SIMD
    GPU
    Pointers
    Structs
    Enums
    Async
    ErrorHandling
    Closures

# Instruction support status
class InstructionSupport:
    instruction_name: text
    category: InstructionCategory
    cranelift: bool
    llvm: bool
    vulkan: bool
    interpreter: bool

# Capability tracker
class CapabilityTracker:
    instructions: [InstructionSupport]

    # Add instruction support info
    me add_instruction(name: text, cat: InstructionCategory, cran: bool, llvm_: bool, vulk: bool, interp: bool):
        val support = InstructionSupport(
            instruction_name: name,
            category: cat,
            cranelift: cran,
            llvm: llvm_,
            vulkan: vulk,
            interpreter: interp
        )
        self.instructions_push(instructions, support)

    # Get all instructions in a category
    fn get_by_category(cat: InstructionCategory) -> [InstructionSupport]:
        val result: [InstructionSupport] = []
        for inst in self.instructions:
            if inst.category == cat:
                result_push(result, inst)
        result

    # Get coverage percentage for a backend
    fn get_coverage(backend: text) -> i32:
        val total = self.instructions_len(instructions)
        if total == 0:
            return 0

        var supported = 0
        for inst in self.instructions:
            if backend == "cranelift" and inst.cranelift:
                supported = supported + 1
            else if backend == "llvm" and inst.llvm:
                supported = supported + 1
            else if backend == "vulkan" and inst.vulkan:
                supported = supported + 1
            else if backend == "interpreter" and inst.interpreter:
                supported = supported + 1

        (supported * 100) / total

# Create tracker with all known instructions
fn create_default_tracker() -> CapabilityTracker:
    val tracker = CapabilityTracker(instructions: [])

    # Constants (all backends support)
    tracker.add_instruction("ConstInt", InstructionCategory.Constants, true, true, true, true)
    tracker.add_instruction("ConstFloat", InstructionCategory.Constants, true, true, true, true)
    tracker.add_instruction("ConstBool", InstructionCategory.Constants, true, true, true, true)
    tracker.add_instruction("ConstString", InstructionCategory.Constants, true, true, false, true)

    # Arithmetic (most backends support)
    tracker.add_instruction("Add", InstructionCategory.Arithmetic, true, true, true, true)
    tracker.add_instruction("Sub", InstructionCategory.Arithmetic, true, true, true, true)
    tracker.add_instruction("Mul", InstructionCategory.Arithmetic, true, true, true, true)
    tracker.add_instruction("Div", InstructionCategory.Arithmetic, true, true, true, true)
    tracker.add_instruction("Mod", InstructionCategory.Arithmetic, true, true, false, true)
    tracker.add_instruction("Neg", InstructionCategory.Arithmetic, true, true, true, true)

    # Control flow (all backends)
    tracker.add_instruction("Ret", InstructionCategory.ControlFlow, true, true, true, true)
    tracker.add_instruction("RetVoid", InstructionCategory.ControlFlow, true, true, true, true)
    tracker.add_instruction("Branch", InstructionCategory.ControlFlow, true, true, true, true)
    tracker.add_instruction("Jump", InstructionCategory.ControlFlow, true, true, true, true)

    # SIMD (Cranelift + Interpreter only)
    tracker.add_instruction("VecLit", InstructionCategory.SIMD, true, false, false, true)
    tracker.add_instruction("VecSum", InstructionCategory.SIMD, true, false, false, true)
    tracker.add_instruction("VecProduct", InstructionCategory.SIMD, true, false, false, true)
    tracker.add_instruction("VecMin", InstructionCategory.SIMD, true, false, false, true)
    tracker.add_instruction("VecMax", InstructionCategory.SIMD, true, false, false, true)
    tracker.add_instruction("VecExtract", InstructionCategory.SIMD, true, false, false, true)
    tracker.add_instruction("VecShuffle", InstructionCategory.SIMD, true, false, false, true)
    tracker.add_instruction("VecFma", InstructionCategory.SIMD, true, false, false, true)
    tracker.add_instruction("VecSqrt", InstructionCategory.SIMD, true, false, false, true)

    # GPU (Vulkan + Interpreter only)
    tracker.add_instruction("GpuGlobalId", InstructionCategory.GPU, false, false, true, true)
    tracker.add_instruction("GpuLocalId", InstructionCategory.GPU, false, false, true, true)
    tracker.add_instruction("GpuGroupId", InstructionCategory.GPU, false, false, true, true)
    tracker.add_instruction("GpuBarrier", InstructionCategory.GPU, false, false, true, true)
    tracker.add_instruction("GpuMemFence", InstructionCategory.GPU, false, false, true, true)
    tracker.add_instruction("GpuAtomicAdd", InstructionCategory.GPU, false, false, true, true)

    # Async (Cranelift + Interpreter only)
    tracker.add_instruction("ActorSpawn", InstructionCategory.Async, true, false, false, true)
    tracker.add_instruction("ActorSend", InstructionCategory.Async, true, false, false, true)
    tracker.add_instruction("ActorRecv", InstructionCategory.Async, true, false, false, true)
    tracker.add_instruction("FutureCreate", InstructionCategory.Async, true, false, false, true)
    tracker.add_instruction("Await", InstructionCategory.Async, true, false, false, true)

    tracker

export InstructionCategory, InstructionSupport, CapabilityTracker
export create_default_tracker
