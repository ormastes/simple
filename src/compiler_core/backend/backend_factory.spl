# Backend Factory - Centralized Backend Selection and Creation
#
# Provides unified interface for creating backends based on target and options.
# Eliminates scattered match statements throughout the codebase.

use compiler.backend_api.*

# ============================================================================
# Backend Factory
# ============================================================================

class BackendFactory:
    """
    Factory for creating backends based on target and options.
    Centralizes backend selection logic.

    Usage:
        val backend = backendfactory_create(target, options)
        val result = backend_compile(backend, module)
    """

    static fn create(target: CodegenTarget, options: CompileOptions) -> Backend:
        """
        Create appropriate backend for target and options.

        Selection priority:
        1. User override (options.backend_kind)
        2. Target requirements (32-bit → LLVM)
        3. Build mode (debug → Cranelift, release → LLVM)
        4. Default (Cranelift)
        """

        # User override
        if options.has_backend_kind:
            return self_create_specific(options.backend_kind_value, target, options)

        # Auto-select based on target and build mode
        val kind = self_auto_select(target, options.build_mode)
        self_create_specific(kind, target, options)

    static fn auto_select(target: CodegenTarget, mode: BuildMode) -> BackendKind:
        """
        Auto-select backend based on target and mode.

        Rules:
        - 32-bit targets → LLVM (only backend that supports 32-bit)
        - WebAssembly → Wasm backend
        - Debug mode → Cranelift (fast compilation)
        - Release mode → LLVM (better optimization)
        - Test mode → Interpreter (no compilation overhead)
        - Bootstrap mode → Cranelift (minimal dependencies)
        """

        # 32-bit requires LLVM (Cranelift doesn't support)
        if target_is_32bit(target):
            return BackendKind.Llvm

        # WebAssembly uses Wasm backend
        if target_is_wasm(target):
            return BackendKind.Wasm

        # For 64-bit, choose based on build mode
        match mode:
            case BuildMode.Debug:
                BackendKind.Cranelift  # Fast compilation
            case BuildMode.Release:
                BackendKind.Llvm       # Better optimization
            case BuildMode.Test:
                BackendKind.Interpreter  # No compilation overhead
            case BuildMode.Bootstrap:
                BackendKind.Cranelift   # Minimal dependencies

    static fn create_specific(kind: BackendKind, target: CodegenTarget, options: CompileOptions)
        -> Backend:
        """
        Create specific backend by kind.
        Validates target support and creates appropriate backend instance.
        """

        # Validate target support
        if not self_supports_target(kind, target):
            error("Backend {kind} does not support target {target}")

        # Create backend based on kind
        match kind:
            case BackendKind.Cranelift:
                craneliftbackend_create(target, options)

            case BackendKind.Llvm:
                llvmbackend_create(target, options)

            case BackendKind.Wasm:
                wasmbackend_create(target, options)

            case BackendKind.Interpreter:
                interpreterbackend_create(options)

            case BackendKind.Lean:
                leanbackend_create(target, options)

    static fn try_create(target: CodegenTarget, options: CompileOptions)
        -> Result<Backend, BackendError>:
        """
        Try to create backend, returning error instead of panicking.
        Useful for graceful error handling.
        """
        val kind = if options.has_backend_kind:
            options.backend_kind_value
        else:
            self_auto_select(target, options.build_mode)

        if not self_supports_target(kind, target):
            return Err(BackendError.NotSupported(
                ("Backend {kind} does not support target {target}. " +
                "Try --backend=llvm for 32-bit targets."),
                nil
            ))

        Ok(self_create_specific(kind, target, options))

    static fn create_with_fallback(target: CodegenTarget, options: CompileOptions,
                                   llvm_available: bool) -> Backend:
        """
        Create backend with fallback strategy.
        If LLVM not available, fall back to Cranelift (64-bit only).
        """
        val preferred = self_auto_select(target, options.build_mode)

        # If preferred is LLVM but not available, try fallback
        if preferred == BackendKind.Llvm and not llvm_available:
            if target_is_32bit(target):
                error("32-bit compilation requires LLVM backend, but LLVM is not available")
            else:
                # Fall back to Cranelift for 64-bit
                return self_create_specific(BackendKind.Cranelift, target, options)

        self_create_specific(preferred, target, options)

    static fn supports_target(kind: BackendKind, target: CodegenTarget) -> bool:
        """
        Check if backend supports target.

        Support matrix:
        - Cranelift: 64-bit only (x86_64, AArch64, RISC-V 64)
        - LLVM: All targets (32-bit + 64-bit)
        - Wasm: WebAssembly only (Wasm32, Wasm64)
        - Interpreter: All targets (architecture-independent)
        - Lean: All targets (verification only)
        """
        match kind:
            case BackendKind.Cranelift:
                target_is_64bit(target)  # Cranelift 64-bit only

            case BackendKind.Llvm:
                true  # LLVM supports all targets

            case BackendKind.Wasm:
                target_is_wasm(target)  # Wasm backend for Wasm targets

            case BackendKind.Interpreter:
                true  # Interpreter supports all

            case BackendKind.Lean:
                true  # Lean backend for all (verification)

    static fn available_backends() -> [BackendKind]:
        """List all available backends."""
        [
            BackendKind.Cranelift,
            BackendKind.Llvm,
            BackendKind.Wasm,
            BackendKind.Interpreter,
            BackendKind.Lean
        ]

    static fn get_description(kind: BackendKind) -> text:
        """Get human-readable description of backend."""
        match kind:
            case BackendKind.Cranelift:
                "Cranelift - Fast compilation, 64-bit only (x86_64, AArch64, RISC-V 64)"

            case BackendKind.Llvm:
                "LLVM - Better optimization, supports 32-bit and 64-bit (all architectures)"

            case BackendKind.Wasm:
                "WebAssembly - Compile to Wasm32/Wasm64"

            case BackendKind.Interpreter:
                "Interpreter - No compilation, architecture-independent"

            case BackendKind.Lean:
                "Lean - Formal verification backend"

# ============================================================================
# Helper Extensions for CodegenTarget
# ============================================================================


# ============================================================================
# CodegenTarget Methods (was: impl CodegenTarget:)
# ============================================================================

# ============================================================================
# Export
# ============================================================================

export BackendFactory
