# Backend Factory - Centralized Backend Selection and Creation
#
# Provides unified interface for creating backends based on target and options.
# Eliminates scattered match statements throughout the codebase.

use compiler.backend_api.*

# ============================================================================
# Backend Factory
# ============================================================================

class BackendFactory:
    """
    Factory for creating backends based on target and options.
    Centralizes backend selection logic.

    Usage:
        val backend = backendfactory_create(target, options)
        val result = backend_compile(backend, module)
    """

    static fn create(target: CodegenTarget, options: CompileOptions) -> Backend:
        """
        Create appropriate backend for target and options.

        Selection priority:
        1. User override (options.backend_kind)
        2. Target requirements (32-bit → LLVM)
        3. Build mode (debug → Cranelift, release → LLVM)
        4. Default (Cranelift)
        """

        # Stub: Option field access not supported in seed_cpp
        # Return a default backend (would be properly selected in full compiler)
        BackendFactory.create_specific(BackendKind.Cranelift, target, options)

    static fn auto_select(target: CodegenTarget, mode: BuildMode) -> BackendKind:
        """
        Auto-select backend based on target and mode.

        Rules:
        - 32-bit targets → LlvmJit (only backend that supports 32-bit)
        - WebAssembly → Interpreter (Wasm backend not in compiler_core)
        - Debug mode → CraneliftJit (fast compilation)
        - Release mode → LlvmJit (better optimization)
        - Test mode → Interpreter (no compilation overhead)
        - Bootstrap mode → CraneliftJit (minimal dependencies)
        """

        # Simplified for compiler_core - just choose based on build mode
        # (Target architecture checks require functions not available in seed_cpp)
        match mode:
            case BuildMode.Debug:
                BackendKind.Cranelift  # Fast compilation
            case BuildMode.Release:
                BackendKind.Llvm       # Better optimization
            case BuildMode.Test:
                BackendKind.Interpreter  # No compilation overhead
            case BuildMode.Bootstrap:
                BackendKind.Cranelift   # Minimal dependencies

    static fn create_specific(kind: BackendKind, target: CodegenTarget, options: CompileOptions)
        -> Backend:
        """
        Create specific backend by kind.
        Validates target support and creates appropriate backend instance.
        """

        # Validate target support
        if not BackendFactory.supports_target(kind, target):
            error("Backend {kind} does not support target {target}")

        # Create backend based on kind
        match kind:
            case BackendKind.Cranelift:
                craneliftbackend_create(target, options)

            case BackendKind.Llvm:
                llvmbackend_create(target, options)

            case BackendKind.Interpreter:
                interpreterbackend_create(options)

            case BackendKind.Native:
                # Stub: Native C backend not fully implemented in compiler_core
                craneliftbackend_create(target, options)

            case BackendKind.Wasm:
                # Stub: Wasm backend not implemented in compiler_core
                interpreterbackend_create(options)

            case BackendKind.Lean:
                # Stub: Lean verification backend not implemented in compiler_core
                interpreterbackend_create(options)

            case BackendKind.Cuda:
                # Stub: CUDA backend not implemented in compiler_core
                interpreterbackend_create(options)

            case BackendKind.Vulkan:
                # Stub: Vulkan backend not implemented in compiler_core
                interpreterbackend_create(options)

    static fn try_create(target: CodegenTarget, options: CompileOptions)
        -> text:
        """
        Try to create backend, returning error instead of panicking.
        Useful for graceful error handling.
        """
        # Stub: Option field access not supported in seed_cpp
        val kind = BackendFactory.auto_select(target, options.build_mode)

        if not BackendFactory.supports_target(kind, target):
            return Err(BackendError.NotSupported(
                ("Backend {kind} does not support target {target}. " +
                "Try --backend=llvm for 32-bit targets."),
                nil
            ))

        Ok(BackendFactory.create_specific(kind, target, options))

    static fn create_with_fallback(target: CodegenTarget, options: CompileOptions,
                                   llvm_available: bool) -> Backend:
        """
        Create backend with fallback strategy.
        If LLVM not available, fall back to Cranelift (64-bit only).
        """
        val preferred = BackendFactory.auto_select(target, options.build_mode)

        # If preferred is LLVM but not available, try fallback
        if preferred == BackendKind.Llvm:
            if not llvm_available:
            # Simplified for seed.cpp: assume 64-bit target, fall back to Cranelift
            # (target_is_32bit not available in seed.cpp)
            return BackendFactory.create_specific(BackendKind.Cranelift, target, options)

        BackendFactory.create_specific(preferred, target, options)

    static fn supports_target(kind: BackendKind, target: CodegenTarget) -> bool:
        """
        Check if backend supports target.

        Support matrix:
        - Cranelift: 64-bit only (x86_64, AArch64, RISC-V 64)
        - Llvm: All targets (32-bit + 64-bit)
        - Interpreter: All targets (architecture-independent)
        - Others: Target-specific or all
        """
        match kind:
            case BackendKind.Cranelift:
                true  # Simplified: assume all targets supported in compiler_core

            case BackendKind.Llvm:
                true  # LLVM supports all targets

            case BackendKind.Interpreter:
                true  # Interpreter supports all

            case BackendKind.Native:
                true  # Native C backend supports all

            case BackendKind.Wasm:
                true  # Simplified: assume all targets supported in compiler_core

            case BackendKind.Lean:
                true  # Lean verification supports all

            case BackendKind.Cuda:
                true  # CUDA stub

            case BackendKind.Vulkan:
                true  # Vulkan stub

    static fn available_backends() -> [BackendKind]:
        """List all available backends."""
        [
            BackendKind.Cranelift,
            BackendKind.Llvm,
            BackendKind.Native,
            BackendKind.Wasm,
            BackendKind.Lean,
            BackendKind.Interpreter
        ]

    static fn get_description(kind: BackendKind) -> text:
        """Get human-readable description of backend."""
        match kind:
            case BackendKind.Cranelift:
                "Cranelift - Fast compilation, 64-bit only (x86_64, AArch64, RISC-V 64)"

            case BackendKind.Llvm:
                "LLVM - Better optimization, supports 32-bit and 64-bit (all architectures)"

            case BackendKind.Native:
                "Native - Compile to native binary via C codegen"

            case BackendKind.Wasm:
                "WebAssembly - Compile to Wasm32/Wasm64"

            case BackendKind.Lean:
                "Lean - Formal verification backend"

            case BackendKind.Interpreter:
                "Interpreter - No compilation, architecture-independent"

            case BackendKind.Cuda:
                "CUDA - GPU acceleration via CUDA (stub)"

            case BackendKind.Vulkan:
                "Vulkan - GPU acceleration via Vulkan (stub)"

# ============================================================================
# Helper Extensions for CodegenTarget
# ============================================================================

# Check if target is 32-bit architecture
fn target_is_32bit(target: CodegenTarget) -> bool:
    # Stub implementation for compiler_core
    # In full compiler, would check target.arch for 32-bit variants
    false

# Check if target is 64-bit architecture
fn target_is_64bit(target: CodegenTarget) -> bool:
    # Stub implementation for compiler_core
    # In full compiler, would check target.arch for 64-bit variants
    # For now, assume most targets are 64-bit
    true

# Check if target is WebAssembly
fn target_is_wasm(target: CodegenTarget) -> bool:
    # Stub implementation for compiler_core
    # In full compiler, would check if target.arch is Wasm32 or Wasm64
    false

# ============================================================================
# CodegenTarget Methods (was: impl CodegenTarget:)
# ============================================================================

# ============================================================================
# Export
# ============================================================================

export BackendFactory
export target_is_32bit, target_is_64bit, target_is_wasm
