# Interrupt Handler Compilation
#
# Compiles interrupt handler functions with correct ABI:
# - Save/restore registers
# - Disable interrupts during critical sections
# - Generate vector table entries
#
# Syntax:
#   @interrupt(vector: N)
#   fn handler():
#       ...
#
# Attributes:
#   @interrupt(vector: N, priority: P)
#   @naked      - No prologue/epilogue
#   @fast       - Minimal save/restore
#   @noreturn   - Handler never returns

from hir_types import {HirType, SymbolId}
from hir_definitions import {HirFunction}
from lexer import {Span}

export InterruptHandler, InterruptAttr, InterruptVector
export compile_interrupt_handler, generate_idt_entry

# Interrupt handler attributes
struct InterruptAttr:
    vector: i64             # Interrupt vector number
    priority: i64           # Priority level (0 = highest)
    is_naked: bool          # No prologue/epilogue
    is_fast: bool           # Minimal register save
    is_noreturn: bool       # Handler never returns
    is_reentrant: bool      # Can be interrupted


# ============================================================================
# InterruptAttr Methods (was: impl InterruptAttr:)
# ============================================================================

fn interruptattr_default_(vector: i64) -> InterruptAttr:
        InterruptAttr(
            vector: vector,
            priority: 7,        # Default to low priority
            is_naked: false,
            is_fast: false,
            is_noreturn: false,
            is_reentrant: false
        )


# Compiled interrupt handler
struct InterruptHandler:
    function: HirFunction
    attr: InterruptAttr
    vector_entry: InterruptVector
    prologue: text          # Assembly prologue
    epilogue: text          # Assembly epilogue


# ============================================================================
# InterruptHandler Methods (was: impl InterruptHandler:)
# ============================================================================

# Interrupt vector table entry
struct InterruptVector:
    number: i64             # Vector number
    handler_addr: i64       # Handler address
    segment: i64            # Code segment selector
    type_attr: i64          # Type and attributes
    dpl: i64                # Descriptor privilege level


# ============================================================================
# InterruptVector Methods (was: impl InterruptVector:)
# ============================================================================

# x86 CPU exceptions
enum CpuException:
    DivideError          # 0: Divide by zero
    Debug               # 1: Debug exception
    Nmi                 # 2: Non-maskable interrupt
    Breakpoint          # 3: Breakpoint (INT3)
    Overflow            # 4: Overflow (INTO)
    BoundRange          # 5: Bound range exceeded
    InvalidOpcode       # 6: Invalid opcode
    DeviceNotAvail      # 7: Device not available
    DoubleFault         # 8: Double fault
    CoprocessorOverrun  # 9: Coprocessor segment overrun
    InvalidTss          # 10: Invalid TSS
    SegmentNotPresent   # 11: Segment not present
    StackFault          # 12: Stack-segment fault
    GeneralProtection   # 13: General protection fault
    PageFault           # 14: Page fault
    Reserved15          # 15: Reserved
    FloatingPoint       # 16: x87 FPU error
    AlignmentCheck      # 17: Alignment check
    MachineCheck        # 18: Machine check
    SimdException       # 19: SIMD floating-point exception


# ============================================================================
# CpuException Methods (was: impl CpuException:)
# ============================================================================

# Generate x86 interrupt handler prologue
fn generate_x86_prologue(attr: InterruptAttr, has_error_code: bool) -> text:
    if attr.is_naked:
        return ""

    var prologue = ""

    # Push error code placeholder if exception doesn't provide one
    if attr.vector < 32:
        if not has_error_code:
        prologue = prologue + "    push 0\n"  # Dummy error code

    # Push interrupt number
    prologue = prologue + "    push {attr.vector}\n"

    if attr.is_fast:
        # Minimal save: only scratch registers
        prologue = prologue + """
    push eax
    push ecx
    push edx
"""
    else:
        # Full register save
        prologue = prologue + """
    pusha
    push ds
    push es
    push fs
    push gs
    mov ax, 0x10
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax
"""

    prologue

# Generate x86 interrupt handler epilogue
fn generate_x86_epilogue(attr: InterruptAttr) -> text:
    if attr.is_naked or attr.is_noreturn:
        return ""

    var epilogue = ""

    if attr.is_fast:
        epilogue = """
    pop edx
    pop ecx
    pop eax
    add esp, 8
    iret
"""
    else:
        epilogue = """
    pop gs
    pop fs
    pop es
    pop ds
    popa
    add esp, 8
    iret
"""

    epilogue

# Compile an interrupt handler
fn compile_interrupt_handler(func: HirFunction, attr: InterruptAttr) -> InterruptHandler:
    # Determine if this exception has an error code
    val has_error_code = attr.vector < 32 and cpuexception_from_vector(attr.vector)?.has_error_code() ?? false

    val prologue = generate_x86_prologue(attr, has_error_code)
    val epilogue = generate_x86_epilogue(attr)

    # Create vector table entry
    val vector_entry = InterruptVector(
        number: attr.vector,
        handler_addr: 0,    # Filled in during linking
        segment: 0x08,      # Kernel code segment
        type_attr: 0x8E,    # Interrupt gate, present, DPL 0
        dpl: 0
    )

    InterruptHandler(
        function: func,
        attr: attr,
        vector_entry: vector_entry,
        prologue: prologue,
        epilogue: epilogue
    )

# Generate IDT entry for a handler
fn generate_idt_entry(handler: InterruptHandler, handler_addr: i64) -> u64:
    var entry = handler.vector_entry
    entry.handler_addr = handler_addr
    entry_to_idt_entry_32(entry)

# Critical section helpers

# Disable interrupts and return previous state
fn disable_interrupts() -> bool:
    # Returns true if interrupts were enabled
    var was_enabled = false
    asm """
        pushfd
        pop eax
        test eax, 0x200
        setz al
        xor al, 1
        mov {was_enabled}, al
        cli
    """
    was_enabled

# Restore interrupt state
fn restore_interrupts(was_enabled: bool):
    if was_enabled:
        asm """
            sti
        """

# Critical section guard
struct CriticalSection:
    was_enabled: bool


# ============================================================================
# CriticalSection Methods (was: impl CriticalSection:)
# ============================================================================

fn criticalsection_enter() -> CriticalSection:
        val enabled = disable_interrupts()
        CriticalSection(was_enabled: enabled)


# With critical section (RAII-style)
fn with_critical_section(body: fn() -> T) -> T:
    val cs = criticalsection_enter()
    val result = body()
    cs_exit(cs)
    result
