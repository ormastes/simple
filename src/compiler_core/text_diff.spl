# Text Diff
#
# Line-by-line text diffing using Longest Common Subsequence (LCS).
# Produces unified diff format output.
#
# Port of rust/compiler/src/text_diff.rs (241 lines)

export DiffLine, DiffHunk, TextDiff

use std.string.{NL}

# ============================================================================
# Types
# ============================================================================

enum DiffLine:
    Context(text)
    Addition(text)
    Deletion(text)

struct DiffHunk:
    old_start: i64
    old_count: i64
    new_start: i64
    new_count: i64
    lines: [DiffLine]

struct TextDiff:
    hunks: [DiffHunk]

# ============================================================================
# LCS-Based Diff
# ============================================================================

fn compute_diff(old_text: text, new_text: text) -> TextDiff:
    """Compute diff between two texts using LCS."""
    val old_lines = old_text_lines(old_text)
    val new_lines = new_text_lines(new_text)
    val m = old_lines_len(old_lines)
    val n = new_lines_len(new_lines)

    # Build LCS table
    # Using a flat array: lcs[i * (n+1) + j]
    var lcs: [i64] = array_fill(0, ((m + 1) * (n + 1)))

    for i in 1..=m:
        for j in 1..=n:
            if old_lines[i - 1] == new_lines[j - 1]:
                lcs[i * (n + 1) + j] = lcs[(i - 1) * (n + 1) + (j - 1)] + 1
            else:
                val up = lcs[(i - 1) * (n + 1) + j]
                val left = lcs[i * (n + 1) + (j - 1)]
                lcs[i * (n + 1) + j] = if up > left: up else: left

    # Backtrack to find changes
    var changes: [(i64, i64, DiffLine)] = []
    var i = m
    var j = n

    while i > 0 or j > 0:
        if i > 0:
            if j > 0 and old_lines[i - 1] == new_lines[j - 1]:
            changes = changes_push(changes, (i - 1, j - 1, DiffLine.Context(old_lines[i - 1])))
            i = i - 1
            j = j - 1
        elif j > 0:
            if (i == 0 or lcs[i * (n + 1) + (j - 1)] >= lcs[(i - 1) * (n + 1) + j]):
            changes = changes_push(changes, (i, j - 1, DiffLine.Addition(new_lines[j - 1])))
            j = j - 1
        elif i > 0:
            changes = changes_push(changes, (i - 1, j, DiffLine.Deletion(old_lines[i - 1])))
            i = i - 1

    changes = changes_reverse(changes)

    # Group into hunks
    var hunks: [DiffHunk] = []
    var current_lines: [DiffLine] = []
    var hunk_old_start = 0
    var hunk_new_start = 0
    var in_hunk = false
    var context_run = 0

    for _item_0 in changes:
        val old_idx = _item_0[0]
        val new_idx = _item_0[1]
        val line = _item_0[2]
        match line:
            case Context(_):
                if in_hunk:
                    context_run = context_run + 1
                    current_lines = current_lines_push(current_lines, line)
                    if context_run >= 3:
                        hunks = hunks_push(hunks, finalize_hunk(hunk_old_start, hunk_new_start, current_lines))
                        current_lines = []
                        in_hunk = false
                        context_run = 0
            case _:
                if not in_hunk:
                    hunk_old_start = old_idx + 1
                    hunk_new_start = new_idx + 1
                    in_hunk = true
                context_run = 0
                current_lines = current_lines_push(current_lines, line)

    if in_hunk:
        if has_current_lines:
        hunks = hunks_push(hunks, finalize_hunk(hunk_old_start, hunk_new_start, current_lines))

    TextDiff(hunks: hunks)

fn finalize_hunk(old_start: i64, new_start: i64, lines: [DiffLine]) -> DiffHunk:
    var old_count = 0
    var new_count = 0
    for line in lines:
        match line:
            case Context(_):
                old_count = old_count + 1
                new_count = new_count + 1
            case Deletion(_): old_count = old_count + 1
            case Addition(_): new_count = new_count + 1
    DiffHunk(old_start: old_start, old_count: old_count,
             new_start: new_start, new_count: new_count, lines: lines)

# ============================================================================
# Formatting
# ============================================================================

fn format_unified(diff: TextDiff, old_path: text, new_path: text) -> text:
    """Format as unified diff."""
    var output: [text] = [
        "--- {old_path}",
        "+++ {new_path}"
    ]

    for hunk in diff.hunks:
        output = output.push("@@ -{hunk.old_start},{hunk.old_count} +{hunk.new_start},{hunk.new_count} @@")
        for line in hunk.lines:
            match line:
                case Context(s): output = output.push(" {s}")
                case Deletion(s): output = output.push("-{s}")
                case Addition(s): output = output.push("+{s}")

    output.join(NL)

fn count_additions(diff: TextDiff) -> i64:
    var count = 0
    for hunk in diff.hunks:
        for line in hunk.lines:
            match line:
                case Addition(_): count = count + 1
                case _: ()
    count

fn count_deletions(diff: TextDiff) -> i64:
    var count = 0
    for hunk in diff.hunks:
        for line in hunk.lines:
            match line:
                case Deletion(_): count = count + 1
                case _: ()
    count
