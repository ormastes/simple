# Module Resolution
#
# Implements the module path resolution semantics verified in:
# verification/module_resolution/src/ModuleResolution.lean
#
# Proven Properties (Lean theorems):
# 1. wellformed_not_ambiguous: In well-formed filesystems, resolution never returns ambiguous
# 2. unique_path_form: Unique resolution returns one of the two expected path forms
# 3. unique_implies_exists: Unique resolution implies the file exists
# 4. notfound_means_neither: Not found means neither file nor directory exists

# A module path segment is a non-empty string identifier
#
# Corresponds to Lean: `structure Segment where name : String; nonEmpty : name ≠ ""`
struct Segment:
    name: text


# ============================================================================
# Segment Methods (was: impl Segment:)
# ============================================================================

# A module path is a non-empty list of segments (e.g., `crate.sys.http`)
#
# Corresponds to Lean: `structure ModPath where segments : List Segment; nonEmpty : segments ≠ []`
struct ModPath:
    segments: [Segment]


# ============================================================================
# ModPath Methods (was: impl ModPath:)
# ============================================================================

# Module can be either a file or a directory with __init__.spl
#
# Corresponds to Lean: `inductive FileKind | file | directory`
enum FileKind:
    File        # foo.spl
    Directory   # foo/__init__.spl


# ============================================================================
# FileKind Methods (was: impl FileKind:)
# ============================================================================

# The result of resolving a module path
#
# Corresponds to Lean: `inductive ResolutionResult`
enum ResolutionResult:
    Unique(kind: FileKind, path: text)
    Ambiguous(file_path: text, dir_path: text)
    NotFound


# ============================================================================
# ResolutionResult Methods (was: impl ResolutionResult:)
# ============================================================================

# File system state: tracks which files exist
#
# Corresponds to Lean: `structure FileSystem where files : List String`
struct FileSystem:
    files: [text]


# ============================================================================
# FileSystem Methods (was: impl FileSystem:)
# ============================================================================

fn filesystem_new() -> FileSystem:
        FileSystem(files: [])


fn filesystem_from_files(files: [text]) -> FileSystem:
        FileSystem(files: files)


# Convert a module path to a filesystem path for file resolution
#
# Corresponds to Lean: `def toFilePath`
fn to_file_path(root: text, mp: ModPath) -> text:
    var path = root + "/"

    val segs = mp_segments(mp)
    var i = 0
    while i < segs_len(segs):
        if i > 0:
            path = path + "/"
        path = path + segs[i].name()
        i = i + 1

    path + ".spl"

# Convert a module path to a filesystem path for directory resolution
#
# Corresponds to Lean: `def toDirPath`
fn to_dir_path(root: text, mp: ModPath) -> text:
    var path = root + "/"

    val segs = mp_segments(mp)
    var i = 0
    while i < segs_len(segs):
        if i > 0:
            path = path + "/"
        path = path + segs[i].name()
        i = i + 1

    path + "/__init__.spl"

# Resolve a module path in a filesystem
#
# Corresponds to Lean: `def resolve`
#
# This is the core resolution algorithm verified by Lean theorems
fn resolve(fs: FileSystem, root: text, mp: ModPath) -> ResolutionResult:
    val file_path = to_file_path(root, mp)
    val dir_path = to_dir_path(root, mp)

    val file_exists = fs_has_file(fs, file_path)
    val dir_exists = fs_has_file(fs, dir_path)

    # Match both booleans (corresponds to Lean match pattern)
    if file_exists and dir_exists:
        resolutionresult_Ambiguous(file_path: file_path, dir_path: dir_path)
    else if file_exists:
        resolutionresult_Unique(kind: FileKind.File, path: file_path)
    else if dir_exists:
        resolutionresult_Unique(kind: FileKind.Directory, path: dir_path)
    else:
        ResolutionResult.NotFound

# Check if a filesystem is well-formed
# (no module has both file and directory forms)
#
# Corresponds to Lean: `def wellFormed`
fn is_well_formed(fs: FileSystem, root: text) -> bool:
    # In Simple, we'll check all existing files to ensure no conflicts
    # For each .spl file, check that the corresponding __init__.spl doesn't exist

    for file_path in fs.files:
        if file_path.ends_with(".spl") and not file_path.ends_with("__init__.spl"):
            # Extract the directory path
            # If file is "foo/bar.spl", check for "foo/bar/__init__.spl"
            val base = file_path[0..-4]  # Remove ".spl"
            val init_path = base + "/__init__.spl"

            if fs_has_file(fs, init_path):
                return false

    true

# Public exports
export Segment
export ModPath
export FileKind
export ResolutionResult
export FileSystem
export to_file_path
export to_dir_path
export resolve
export is_well_formed
