# Macro Auto-Import Model
#
# Implements the macro import/export and `auto import` semantics verified in:
# verification/macro_auto_import/src/MacroAutoImport.lean
#
# Proven Properties (Lean theorems):
# 1. glob_doesnt_leak_macros_wf: Macros not in auto-import are never in glob import result
# 2. nonmacros_always_globbed: All non-macros are always in glob import
# 3. auto_imported_in_glob: Auto-imported macros are in glob import
# 4. glob_subset: Glob import symbols come from exports
# 5. empty_auto_import_no_macros: Empty auto-import means no macros in glob
# 6. autoImported_combine: Combined exports combine auto-imported macros
#
# Key Properties (Invariants):
# 1. **Glob doesn't leak**: If macro `m` is not in `auto import`, then `m` is never
#    in the result of `globImport`
# 2. **Explicit always works**: Explicit `use module.macroName` always imports the macro
#    if it exists and is public
# 3. **Two-phase visibility**: Macro export happens in Phase 1 (module exports it),
#    glob participation happens in Phase 2 (directory's `autoImports` lists it)

# Symbol kind distinguishes macros from other symbols
#
# Corresponds to Lean: `inductive SymKind | valueOrType | macro`
enum SymKind:
    ValueOrType  # Functions, types, constants
    MacroKind    # Macro definitions


# ============================================================================
# SymKind Methods (was: impl SymKind:)
# ============================================================================

# A fully-qualified symbol
#
# Corresponds to Lean: `structure Symbol where modulePath : String; name : String; kind : SymKind`
struct MacroSymbol:
    module_path: text
    name: text
    kind: SymKind


# ============================================================================
# MacroSymbol Methods (was: impl MacroSymbol:)
# ============================================================================

fn macrosymbol_new(module_path: text, name: text, kind: SymKind) -> MacroSymbol:
        MacroSymbol(module_path: module_path, name: name, kind: kind)


fn macrosymbol_value_sym(module_path: text, name: text) -> MacroSymbol:
        macrosymbol_new(module_path, name, SymKind.ValueOrType)


fn macrosymbol_macro_sym(module_path: text, name: text) -> MacroSymbol:
        macrosymbol_new(module_path, name, SymKind.MacroKind)


# Auto-import declaration from __init__.spl
#
# Corresponds to Lean: `structure AutoImport where fromModule : String; macroName : String`
struct AutoImport:
    from_module: text
    macro_name: text


# ============================================================================
# AutoImport Methods (was: impl AutoImport:)
# ============================================================================

fn autoimport_new(from_module: text, macro_name: text) -> AutoImport:
        AutoImport(from_module: from_module, macro_name: macro_name)


# What a module publicly exports
#
# Corresponds to Lean: `structure ModuleExports where nonMacros : List Symbol; macros : List Symbol`
struct MacroExports:
    non_macros: [MacroSymbol]  # Public non-macro symbols
    macros: [MacroSymbol]      # Public macros


# ============================================================================
# MacroExports Methods (was: impl MacroExports:)
# ============================================================================

fn macroexports_new() -> MacroExports:
        MacroExports(non_macros: [], macros: [])


# Directory manifest for macro handling
#
# Corresponds to Lean: `structure DirManifest where name : String; autoImports : List AutoImport`
struct MacroDirManifest:
    name: text
    auto_imports: [AutoImport]


# ============================================================================
# MacroDirManifest Methods (was: impl MacroDirManifest:)
# ============================================================================

fn macrodirmanifest_new(name: text) -> MacroDirManifest:
        MacroDirManifest(name: name, auto_imports: [])


# Check if a macro is in the auto-import list
#
# Corresponds to Lean: `def isAutoImported (m : DirManifest) (sym : Symbol) : Bool`
fn is_auto_imported(manifest: MacroDirManifest, sym: MacroSymbol) -> bool:
    # First check if it's a macro
    val sym_kind = sym_get_kind(sym)
    match sym_kind:
        case SymKind.ValueOrType:
            return false
        case SymKind.MacroKind:
            ()

    # Check if it's in the auto-import list
    val sym_module = sym_get_module_path(sym)
    val sym_name = sym_get_name(sym)
    for ai in manifest.auto_imports:
        val ai_module = ai_get_from_module(ai)
        val ai_macro = ai_get_macro_name(ai)
        if ai_module == sym_module:
            if ai_macro == sym_name:
            return true

    false

# Filter macros that are in auto-import list
#
# Corresponds to Lean: `def autoImportedMacros (m : DirManifest) (exports : ModuleExports) : List Symbol`
fn auto_imported_macros(manifest: MacroDirManifest, exports: MacroExports) -> [MacroSymbol]:
    var result: [MacroSymbol] = []
    for sym in exports.macros:
        if is_auto_imported(manifest, sym):
            result_push(result, sym)
    result

# Glob import result: non-macros + auto-imported macros only
#
# Corresponds to Lean: `def globImport (m : DirManifest) (exports : ModuleExports) : List Symbol`
#
# This is the key function: it returns all non-macros, plus ONLY the macros
# that are listed in `auto import`.
fn glob_import(manifest: MacroDirManifest, exports: MacroExports) -> [MacroSymbol]:
    var result: [MacroSymbol] = []

    # Add all non-macros
    for sym in exports.non_macros:
        result_push(result, sym)

    # Add only auto-imported macros
    val auto_macros = auto_imported_macros(manifest, exports)
    for sym in auto_macros:
        result_push(result, sym)

    result

# Explicit import: always works for any public symbol
#
# Corresponds to Lean: `def explicitImport (exports : ModuleExports) (name : String) : Option Symbol`
fn explicit_import(exports: MacroExports, name: text) -> has_MacroSymbol:
    # Check non-macros first
    for sym in exports.non_macros:
        val sym_name = sym_get_name(sym)
        if sym_name == name:
            return sym

    # Check macros
    for sym in exports.macros:
        val sym_name = sym_get_name(sym)
        if sym_name == name:
            return sym

    nil

# Combine two module exports
#
# Corresponds to Lean: `def combineExports (e1 e2 : ModuleExports) : ModuleExports`
fn combine_exports(e1: MacroExports, e2: MacroExports) -> MacroExports:
    var result = macroexports_new()

    # Add all non-macros from both
    for sym in e1.non_macros:
        result.non_macros_push(non_macros, sym)
    for sym in e2.non_macros:
        result.non_macros_push(non_macros, sym)

    # Add all macros from both
    for sym in e1.macros:
        result.macros_push(macros, sym)
    for sym in e2.macros:
        result.macros_push(macros, sym)

    result

# Public exports
export SymKind
export MacroSymbol
export AutoImport
export MacroExports
export MacroDirManifest
export is_auto_imported
export auto_imported_macros
export glob_import
export explicit_import
export combine_exports
