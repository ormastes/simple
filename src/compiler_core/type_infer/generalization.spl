# Level-Based Generalization and Instantiation
#
# Implements the let-polymorphism mechanism of Algorithm W:
# - Level management (enter_level, exit_level)
# - Fresh type variable generation
# - Free variable collection
# - Generalization (types → type schemes)
# - Instantiation (type schemes → types with fresh vars)
#
# The level system ensures we only generalize variables that are
# local to the current binding, not those from outer scopes.

use compiler.hir.*
use core.lexer.*
use type_infer_types.*


# ============================================================================
# HmInferContext Methods (was: impl HmInferContext:)
# ============================================================================

fn hminfercontext_fresh_var(self: HmInferContext, span: Span) -> HirType:
        """Create a fresh type variable at the current level."""
        self.fresh_var_at_level(self.level, span)


fn hminfercontext_fresh_var_at_level(self: HmInferContext, level: i64, span: Span) -> HirType:
        """Create a fresh type variable at a specific level."""
        val id = self.next_var
        self.next_var = self.next_var + 1
        HirType(
            kind: hirtypekind_Infer(id, level),
            span: span
        )


fn hminfercontext_instantiate(self: HmInferContext, scheme: TypeScheme) -> HirType:
        """Instantiate a type scheme with fresh type variables."""
        if scheme.vars_is_empty(vars):
            return scheme.ty

        # Create mapping from bound vars to fresh vars
        var var_map: Dict<i64, HirType> = {}
        for bound_var in scheme.vars:
            var_map[bound_var] = self.fresh_var(scheme.ty.span)

        # Apply the mapping
        self.instantiate_type(scheme.ty, var_map)

