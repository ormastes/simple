# Simple Branch Coverage Tests
#
# Comprehensive tests to maximize branch coverage in the Simple interpreter
# and core language features.

use std.spec.*

describe "Boolean operations":
    it "tests true":
        val x = true
        expect x == true

    it "tests false":
        val x = false
        expect x == false

    it "tests and operator - both true":
        expect (true and true) == true

    it "tests and operator - one false":
        expect (true and false) == false

    it "tests or operator - one true":
        expect (true or false) == true

    it "tests or operator - both false":
        expect (false or false) == false

    it "tests not operator":
        expect not false == true
        expect not true == false

    it "tests complex boolean expression":
        expect (true and (false or true)) == true
        expect ((true or false) and (true and true)) == true

describe "Integer operations":
    it "tests addition":
        expect 1 + 2 == 3

    it "tests subtraction":
        expect 5 - 3 == 2

    it "tests multiplication":
        expect 4 * 3 == 12

    it "tests division":
        expect 10 / 2 == 5

    it "tests modulo":
        expect 10 % 3 == 1

    it "tests negative numbers":
        expect (-5 + 3) == -2

    it "tests comparison - equal":
        expect 5 == 5

    it "tests comparison - not equal":
        expect 5 != 3

    it "tests comparison - less than":
        expect 3 < 5

    it "tests comparison - greater than":
        expect 5 > 3

    it "tests comparison - less than or equal":
        expect 5 <= 5
        expect 3 <= 5

    it "tests comparison - greater than or equal":
        expect 5 >= 5
        expect 5 >= 3

    it "tests integer overflow handling":
        val big = 1000000
        expect big * 2 == 2000000

describe "String operations":
    it "tests string equality":
        expect "hello" == "hello"

    it "tests string inequality":
        expect "hello" != "world"

    it "tests string concatenation":
        val s = "hello" + " world"
        expect s == "hello world"

    it "tests string length":
        expect "hello".len() == 5

    it "tests empty string":
        val s = ""
        expect s_len(s) == 0
        expect s_is_empty(s) == true

    it "tests string interpolation":
        val name = "Alice"
        val greeting = "Hello, {name}!"
        expect greeting == "Hello, Alice!"

    it "tests string with numbers":
        val num = 42
        val msg = "The answer is {num}"
        expect msg == "The answer is 42"

    it "tests string with newline escape":
        val text = "line1\nline2"
        expect text.contains("line1") == true
        expect text.contains("line2") == true

describe "Option type operations":
    it "tests Some construction":
        val opt = has_field = true, field_value = 42
        expect opt_is_some(opt) == true
        expect opt_is_none(opt) == false

    it "tests None construction":
        val opt: Option<i32> = nil
        expect opt_is_some(opt) == false
        expect opt_is_none(opt) == true

    it "tests unwrap on Some":
        val opt = has_field = true, field_value = 42
        expect opt_value == 42

    it "tests unwrap_or on Some":
        val opt = has_field = true, field_value = 42
        expect opt_unwrap_or(opt, 99) == 42

    it "tests unwrap_or on None":
        val opt: Option<i32> = nil
        expect opt_unwrap_or(opt, 99) == 99

    it "tests map on Some":
        val opt = has_field = true, field_value = 5
        val doubled = opt_map(opt, \x: x * 2)
        expect doubled_value == 10

    it "tests map on None":
        val opt: Option<i32> = nil
        val doubled = opt_map(opt, \x: x * 2)
        expect doubled_is_none(doubled) == true

describe "Result type operations":
    it "tests Ok construction":
        val res: Result<i32, text> = Ok(42)
        expect res_is_ok(res) == true
        expect res_is_err(res) == false

    it "tests Err construction":
        val res: Result<i32, text> = Err("error")
        expect res_is_ok(res) == false
        expect res_is_err(res) == true

    it "tests unwrap_or on Ok":
        val res: Result<i32, text> = Ok(42)
        expect res_unwrap_or(res, 99) == 42

    it "tests unwrap_or on Err":
        val res: Result<i32, text> = Err("error")
        expect res_unwrap_or(res, 99) == 99

describe "List operations":
    it "tests empty list literal":
        val lst: [i32] = []
        expect lst_len(lst) == 0
        expect lst_is_empty(lst) == true

    it "tests list literal with elements":
        val lst = [1, 2, 3]
        expect lst_len(lst) == 3
        expect lst_is_empty(lst) == false

    it "tests list indexing":
        val lst = [10, 20, 30]
        expect lst[0] == 10
        expect lst[1] == 20
        expect lst[2] == 30

    it "tests list contains":
        val lst = [10, 20]
        expect lst_contains(lst, &10) == true
        expect lst_contains(lst, &99) == false

    it "tests list map":
        val lst = [1, 2, 3]
        val doubled = lst_map(lst, \x: x * 2)
        expect doubled[0] == 2
        expect doubled[1] == 4
        expect doubled[2] == 6

    it "tests list filter":
        val lst = [1, 2, 3, 4]
        val evens = lst_filter(lst, \x: x % 2 == 0)
        expect evens_len(evens) == 2
        expect evens[0] == 2
        expect evens[1] == 4

describe "Control flow":
    it "tests if-else with true condition":
        val x = 5
        val result = if x > 0:
            "positive"
        else:
            "negative"
        expect result == "positive"

    it "tests if-else with false condition":
        val x = -5
        val result = if x > 0:
            "positive"
        else:
            "negative"
        expect result == "negative"

    it "tests nested if-else":
        val x = 5
        val result = if x > 10:
            "big"
        elif x > 0:
            "small"
        else:
            "negative"
        expect result == "small"

    it "tests match with literal":
        val x = 2
        val result = match x:
            1 => "one"
            2 => "two"
            _ => "other"
        expect result == "two"

    it "tests match with default":
        val x = 99
        val result = match x:
            1 => "one"
            2 => "two"
            _ => "other"
        expect result == "other"

describe "Pattern matching":
    it "tests match on Option Some":
        val opt = has_field = true, field_value = 42
        val result = match # DESUGARED: opt: Some(x => x * 2)
            has_opt: true,
            opt_value: x => x * 2
            nil => 0
        expect result == 84

    it "tests match on Option None":
        val opt: Option<i32> = nil
        val result = match # DESUGARED: opt: Some(x => x * 2)
            has_opt: true,
            opt_value: x => x * 2
            nil => 0
        expect result == 0

    it "tests match on Result Ok":
        val res: Result<i32, text> = Ok(42)
        val result = match res:
            Ok(x) => x
            Err(_) => 0
        expect result == 42

    it "tests match on Result Err":
        val res: Result<i32, text> = Err("error")
        val result = match res:
            Ok(x) => x
            Err(_) => 0
        expect result == 0

describe "Loops":
    it "tests for loop over range":
        var sum = 0
        for i in 0..5:
            sum = sum + i
        expect sum == 10  # 0+1+2+3+4

    it "tests for loop over list":
        val lst = [10, 20, 30]
        var sum = 0
        for x in lst:
            sum = sum + x
        expect sum == 60

    it "tests while loop":
        var count = 0
        var sum = 0
        while count < 5:
            sum = sum + count
            count = count + 1
        expect sum == 10

describe "Functions and lambdas":
    it "tests simple function call":
        fn add(a: i32, b: i32) -> i32:
            a + b
        expect add(3, 4) == 7

    it "tests lambda expression":
        val double = \x: x * 2
        expect double(5) == 10

    it "tests lambda with multiple arguments":
        val add = \a, b: a + b
        expect add(3, 4) == 7

    it "tests higher-order function":
        fn apply(f: fn(i32) -> i32, x: i32) -> i32:
            f(x)
        val double = \x: x * 2
        expect apply(double, 5) == 10

describe "Ranges":
    it "tests exclusive range":
        val r = 0..5
        var count = 0
        for _ in r:
            count = count + 1
        expect count == 5

    it "tests inclusive range":
        val r = 0..=5
        var count = 0
        for _ in r:
            count = count + 1
        expect count == 6

describe "Array literals":
    it "tests array literal creation":
        val arr = [1, 2, 3, 4, 5]
        expect arr_len(arr) == 5

    it "tests array indexing":
        val arr = [10, 20, 30]
        expect arr[0] == 10
        expect arr[1] == 20
        expect arr[2] == 30

    it "tests array negative indexing":
        val arr = [10, 20, 30]
        expect arr[-1] == 30
        expect arr[-2] == 20

describe "Type conversions":
    it "tests int to string conversion":
        val num = 42
        val s = num_to_string(num)
        expect s == "42"

    it "tests negative int to string":
        val num = -42
        val s = num_to_string(num)
        expect s == "-42"

describe "Edge cases":
    it "tests empty string operations":
        val s = ""
        expect s_len(s) == 0
        expect s + "hello" == "hello"

    it "tests zero in arithmetic":
        expect 0 + 5 == 5
        expect 5 * 0 == 0

    it "tests empty list operations":
        val lst: [i32] = []
        expect lst_len(lst) == 0
        expect lst_is_empty(lst) == true

    it "tests boolean short-circuit evaluation - and":
        var called = false
        fn side_effect() -> bool:
            called = true
            true
        val result = false and side_effect()
        expect result == false
        # Note: can't easily test if side_effect was called due to short-circuit

    it "tests boolean short-circuit evaluation - or":
        var called = false
        fn side_effect() -> bool:
            called = true
            false
        val result = true or side_effect()
        expect result == true
