# Common Subexpression Elimination (CSE)
#
# Identifies and eliminates redundant computations.
#
# Transformation:
#   val a = x + y
#   val b = z * 2
#   val c = x + y    # Redundant! Same as 'a'
#
# After:
#   val a = x + y
#   val b = z * 2
#   val c = a        # Reuse computed value
#
# Benefits:
# - Reduces redundant computation
# - Saves CPU cycles
# - Reduces register pressure
# - Enables further optimization
#
# Algorithm:
# 1. Build expression table (expression -> local that computes it)
# 2. For each instruction:
#    a. Compute expression hash/key
#    b. If expression already computed, reuse result
#    c. Otherwise, add to table
#
# Limitations:
# - Only within single basic block (local CSE)
# - Doesn't handle memory operations (complex aliasing)
# - Conservative about side effects

use compiler.mir_data.*
use compiler.mir.*
use compiler.mir_opt.mod.{MirPass}

# ============================================================================
# Expression Representation
# ============================================================================

enum Expression:
    """
    Canonical representation of an expression for CSE.

    Two expressions are equal if they compute the same value.
    """
    BinOp(op: MirBinOp, left: LocalId, right: LocalId)
    UnaryOp(op: MirUnaryOp, operand: LocalId)
    Load(ptr: LocalId)
    GetField(base: LocalId, field: i64)
    ConstInt(value: i64)
    ConstFloat(value: f64)
    ConstBool(value: bool)


# ============================================================================
# Expression Methods (was: impl Expression:)
# ============================================================================

# ============================================================================
# Expression Table
# ============================================================================

class ExpressionTable:
    """
    Maps expressions to the locals that compute them.

    Used to detect redundant computations.
    """
    table: Dict<text, LocalId>  # expression key -> local that computes it
    eliminated: i64


# ============================================================================
# ExpressionTable Methods (was: impl ExpressionTable:)
# ============================================================================

fn expressiontable_new() -> ExpressionTable:
        ExpressionTable(
            table: {},
            eliminated: 0
        )


# ============================================================================
# Common Subexpression Elimination Pass
# ============================================================================

class CommonSubexprElimination:
    """
    CSE optimization pass.

    Eliminates redundant computations within basic blocks.
    """
    expr_table: ExpressionTable
    eliminated_count: i64
    reused_count: i64


# ============================================================================
# CommonSubexprElimination Methods (was: impl CommonSubexprElimination:)
# ============================================================================

fn commonsubexprelimination_new() -> CommonSubexprElimination:
        CommonSubexprElimination(
            expr_table: expressiontable_new(),
            eliminated_count: 0,
            reused_count: 0
        )


fn commonsubexprelimination_run_on_function(self: CommonSubexprElimination, func: MirFunction) -> MirFunction:
        """
        Run CSE on a function.

        Process each basic block independently (local CSE).
        """
        var optimized_blocks: [MirBlock] = []

        for block in func.blocks:
            # Clear expression table for new block
            self.expr_table_clear(expr_table)

            val optimized = self.eliminate_block(block)
            optimized_blocks_push(optimized_blocks, optimized)

        copy_mir_function_with_blocks(func, optimized_blocks)


fn commonsubexprelimination_eliminate_block(self: CommonSubexprElimination, block: MirBlock) -> MirBlock:
        """
        Eliminate common subexpressions in a block.

        Strategy:
        1. Scan instructions sequentially
        2. For each pure expression:
           a. Check if already computed
           b. If yes, replace with copy
           c. If no, add to table
        """
        var optimized_instructions: [MirInst] = []

        for inst in block.instructions:
            val optimized = self.try_eliminate_instruction(inst)
            optimized_instructions_push(optimized_instructions, optimized)

        MirBlock(
            id: block.id,
            label: block.label,
            instructions: optimized_instructions,
            terminator: block.terminator
        )


fn commonsubexprelimination_try_eliminate_instruction(self: CommonSubexprElimination, inst: MirInst) -> MirInst:
        """
        Try to eliminate instruction via CSE.

        Returns:
        - Original instruction if can't eliminate
        - Copy instruction if redundant computation found
        """
        match inst.kind:
            case BinOp(dest, op, left, right):
                # Try to build expression from operands
                val expr_opt = self.operands_to_binop_expr(op, left, right)
                if not has_expr_opt:
                    return inst

                val expr = expr_opt_value

                # Check if already computed
                val cached = self.expr_table_lookup(expr_table, expr)
                if has_cached:
                    # Redundant! Replace with copy
                    self.eliminated_count = self.eliminated_count + 1
                    self.reused_count = self.reused_count + 1
                    return MirInst(
                        kind: mirinstkind_Copy(dest, cached_value),
                        span: inst.span
                    )

                # First occurrence - add to table
                self.expr_table_insert(expr_table, expr, dest)
                inst

            case UnaryOp(dest, op, operand):
                val expr_opt = self.operand_to_unaryop_expr(op, operand)
                if not has_expr_opt:
                    return inst

                val expr = expr_opt_value

                val cached = self.expr_table_lookup(expr_table, expr)
                if has_cached:
                    self.eliminated_count = self.eliminated_count + 1
                    self.reused_count = self.reused_count + 1
                    return MirInst(
                        kind: mirinstkind_Copy(dest, cached_value),
                        span: inst.span
                    )

                self.expr_table_insert(expr_table, expr, dest)
                inst

            case GetField(dest, base, field):
                val expr_opt = self.operand_to_getfield_expr(base, field)
                if not has_expr_opt:
                    return inst

                val expr = expr_opt_value

                val cached = self.expr_table_lookup(expr_table, expr)
                if has_cached:
                    self.eliminated_count = self.eliminated_count + 1
                    self.reused_count = self.reused_count + 1
                    return MirInst(
                        kind: mirinstkind_Copy(dest, cached_value),
                        span: inst.span
                    )

                self.expr_table_insert(expr_table, expr, dest)
                inst

            case Store(_, _):
                # Store may invalidate expressions (conservative)
                self.expr_table_clear(expr_table)
                inst

            case Call(_, _, _):
                # Function call may have side effects (conservative)
                self.expr_table_clear(expr_table)
                inst

            case _:
                # Other instructions don't participate in CSE
                inst


# ============================================================================
# Factory Function
# ============================================================================

fn create_cse_pass() -> CommonSubexprElimination:
    """Create a new CSE pass instance."""
    commonsubexprelimination_new()

# ============================================================================
# Exports
# ============================================================================

export CommonSubexprElimination, create_cse_pass
export Expression, ExpressionTable
