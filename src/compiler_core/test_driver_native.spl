# Test: Driver -> Native Backend End-to-End
#
# Tests compiling a simple program through the full driver pipeline
# using the native backend (Parse -> HIR -> MIR -> ISel -> RegAlloc -> Encode -> ELF).

extern fn rt_process_run(cmd: text, args: [text]) -> (text, text, i64)
extern fn rt_file_write_text(path: text, content: text) -> bool

fn shell(command: text) -> (text, text, i64):
    rt_process_run("sh", ["-c", command])

use compiler.driver.{CompilerDriver}
use compiler.driver_types.{CompileOptions, CompileMode, OutputFormat, CompileResult}

print "=== Driver -> Native Backend Test ==="

# Write a minimal Simple program
val source = "fn main() -> i64:\n    0\n"
rt_file_write_text("/tmp/test_native_input.spl", source)

# Construct driver options
var options = CompileOptions(
    mode: CompileMode.Aot,
    input_files: ["/tmp/test_native_input.spl"],
    # DESUGARED: output_file: Some("/tmp/test_native_output")
            has_output_file: true,
            output_file_value: "/tmp/test_native_output",
    output_format: OutputFormat.Native,
    optimize: false,
    has_opt_level: false,  # DESUGARED: opt_level: nil
    release: false,
    debug_info: false,
    verbose: true,
    log_level: 2,
    profile: "dev",
    no_borrow_check: true,
    backend: "native",
    interpreter_mode: "classic",
    gc_off: false
)

print "  Creating driver..."
var driver = compilerdriver_create(options)
print "  Compiling..."
val result = driver_compile(driver)

print "  Result: {result}"

match result:
    case Success(path):
        print "  Compiled to: {path}"
        if path != nil:
            val run_r = rt_process_run(path, [])
            print "  Exit code: {run_r[2]}"
            if run_r[2] == 0:
                print ""
                print "=== SUCCESS: Driver -> Native Backend ==="
            else:
                print "=== PARTIAL: Binary returned non-zero ==="
        else:
            print "=== PARTIAL: Success but no path ==="
    case CodegenError(msg):
        print "  Codegen error: {msg}"
    case ParseError(errors):
        print "  Parse errors: {errors.len()}"
        for e in errors:
            print "    {e}"
    case TypeError(errors):
        print "  Type errors: {errors.len()}"
        for e in errors:
            print "    {e}"
    case _:
        print "  Other result"

print "=== Done ==="
