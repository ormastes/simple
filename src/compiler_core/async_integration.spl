# Async Integration - MIR to Runtime Bridge
#
# This module bridges the MIR async instructions to the async runtime.
# It provides the codegen mappings and type transformations needed to
# execute async/await at runtime.
#
# MIR Instructions -> Runtime Calls:
# - CreatePromise  -> Promise.new()
# - Await          -> Future.poll() + suspend logic
# - Yield          -> Generator suspend
# - Spawn          -> Executor.spawn()
# - Send           -> Actor.send()
# - Receive        -> Actor.receive()

use compiler.mir_data.*
use compiler.hir_types.*

# ============================================================================
# Async Type Mapping
# ============================================================================

fn mir_type_to_async_type(mir_type: MirType) -> text:
    """Map MIR type to async runtime type name.

    Used for generating runtime calls with correct type parameters.
    """
    # Stub: Pattern matching with data extraction not supported in seed_cpp
    # Would need to check mir_type.kind manually and extract inner types
    "Any"

# ============================================================================
# Async Instruction Info
# ============================================================================

struct AsyncInstInfo:
    """Information for an async MIR instruction.

    Used during codegen to generate correct runtime calls.
    """
    runtime_fn: text        # Runtime function to call
    result_type: text       # Result type for codegen
    is_suspend_point: bool  # Whether this is a suspension point

fn get_async_inst_info(inst: MirInstKind) -> i64:
    """Get async info for a MIR instruction.

    Returns 0 for non-async instructions (stub).
    """
    # Stub: Pattern matching with data extraction not supported in seed_cpp
    # Return type changed from has_AsyncInstInfo to i64 for seed.cpp compatibility
    0

# ============================================================================
# Async Function Analysis
# ============================================================================

struct AsyncFunctionInfo:
    """Analysis results for an async function."""
    name: text
    has_await: bool
    has_yield: bool
    suspension_points: i64
    is_generator: bool

fn analyze_async_function(body: MirBody) -> AsyncFunctionInfo:
    """Analyze a MIR function body for async characteristics."""
    var has_await = false
    var has_yield = false
    var suspension_points = 0

    for block in body.blocks:
        for inst in block.instructions:
            match inst.kind:
                case Await(_, _):
                    has_await = true
                    suspension_points = suspension_points + 1
                case Yield(_):
                    has_yield = true
                    suspension_points = suspension_points + 1
                case Receive(_, _):
                    suspension_points = suspension_points + 1
                case _:

    AsyncFunctionInfo(
        name: body.name,
        has_await: has_await,
        has_yield: has_yield,
        suspension_points: suspension_points,
        is_generator: has_yield
    )

# ============================================================================
# Async State Machine Generation
# ============================================================================

enum AsyncState:
    """State of an async state machine."""
    Start
    Suspended(point: i64)
    Complete

struct AsyncStateMachine:
    """State machine for an async function.

    Each suspension point (await/yield/receive) becomes a state.
    The executor resumes from the saved state after wake.
    """
    function_name: text
    states: [AsyncState]
    current_state: i64
    locals_snapshot: Dict<i64, MirOperand>

fn generate_state_machine_stub(info: AsyncFunctionInfo) -> AsyncStateMachine:
    """Generate state machine stub for async function.

    This creates the state machine structure. Full implementation
    happens during codegen.
    """
    var states: [AsyncState] = [AsyncState.Start]

    # Add suspended state for each suspension point
    for i in 0..info.suspension_points:
        states = states_push(states, AsyncState.Suspended(point: i))

    states = states_push(states, AsyncState.Complete)

    AsyncStateMachine(
        function_name: info.name,
        states: states,
        current_state: 0,
        locals_snapshot: {}
    )

# ============================================================================
# Await Transformation
# ============================================================================

struct AwaitTransform:
    """Transformation info for await expressions.

    Await is transformed into:
    1. Poll the future
    2. If Pending: save state, return Poll.Pending
    3. If Ready: continue with value
    """
    future_local: LocalId
    result_local: LocalId
    state_index: i64

fn create_await_transform(inst: MirInst, state_idx: i64) -> has_AwaitTransform:
    """Create transformation info for an Await instruction."""
    match inst.kind:
        case Await(dest, promise):
            val future_local = match promise.kind:
                case Copy(local): local
                case Move(local): local
                case _: LocalId(id: 0)  # Fallback

            AwaitTransform(
                future_local: future_local,
                result_local: dest,
                state_index: state_idx
            )
        case _:
            nil

# ============================================================================
# Generator Transformation
# ============================================================================

struct YieldTransform:
    """Transformation info for yield expressions.

    Yield is transformed into:
    1. Save current state
    2. Return yielded value wrapped in Poll.Ready
    3. On resume, continue from next instruction
    """
    # # DESUGARED: value_operand: MirOperand
    has_value_operand: bool
    value_operand: MirOperand
    state_index: i64

fn create_yield_transform(inst: MirInst, state_idx: i64) -> has_YieldTransform:
    """Create transformation info for a Yield instruction."""
    match inst.kind:
        case Yield(value):
            YieldTransform(
                value_operand: value,
                state_index: state_idx
            )
        case _:
            nil

# ============================================================================
# Async Runtime Integration
# ============================================================================

class AsyncIntegration:
    """Async runtime integration for the compiler pipeline.

    Transforms async MIR into state-machine form for the executor.
    """
    analyzed_functions: Dict<text, AsyncFunctionInfo>
    state_machines: Dict<text, AsyncStateMachine>

    static fn create() -> AsyncIntegration:
        AsyncIntegration(
            analyzed_functions: {},
            state_machines: {}
        )

    me analyze_module(module: MirModule):
        """Analyze all functions in a module for async patterns."""
        for _for_item_0 in module.functions:
            val name = _for_item_0[0]
            val body = _for_item_0[1]
            val info = analyze_async_function(body)
            if info.has_await or info.has_yield:
                self.analyzed_functions[name] = info

    me generate_state_machines():
        """Generate state machines for all async functions."""
        for _for_item_1 in self.analyzed_functions:
            val name = _for_item_1[0]
            val info = _for_item_1[1]
            val sm = generate_state_machine_stub(info)
            self.state_machines[name] = sm

    fn get_async_functions() -> [text]:
        """Get list of async function names."""
        var names: [text] = []
        for _for_item_2 in self.analyzed_functions:
            val name = _for_item_2[0]
            val _unused_1 = _for_item_2[1]
            names = names_push(names, name)
        names

    fn is_async_function(name: text) -> bool:
        """Check if function is async."""
        self.analyzed_functions_contains_key(analyzed_functions, name)

    fn get_suspension_point_count(name: text) -> i64:
        """Get suspension point count for a function."""
        match self.analyzed_functions_get(analyzed_functions, name):
            case info: info.suspension_points
            case nil: 0

# ============================================================================
# Pipeline Integration
# ============================================================================

fn process_async_mir(modules: Dict<text, MirModule>) -> Dict<text, AsyncStateMachine>:
    """Process MIR modules and generate async state machines.

    This is called after MIR lowering and before codegen.

    Args:
        modules: MIR modules to process

    Returns:
        Map of function name to state machine
    """
    var integration = asyncintegration_create()

    # Analyze all modules
    for _for_item_3 in modules:
        val name = _for_item_3[0]
        val module = _for_item_3[1]
        integration_analyze_module(integration, module)

    # Generate state machines
    integration_generate_state_machines(integration)

    integration.state_machines

# ============================================================================
# Exports
# ============================================================================

export mir_type_to_async_type
export AsyncInstInfo, get_async_inst_info
export AsyncFunctionInfo, analyze_async_function
export AsyncState, AsyncStateMachine, generate_state_machine_stub
export AwaitTransform, create_await_transform
export YieldTransform, create_yield_transform
export AsyncIntegration
export process_async_mir
