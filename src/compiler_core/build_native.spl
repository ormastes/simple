# Build Native - Compile Simple programs to native binaries.
#
# This module provides the build pipeline for creating native executables:
# 1. Compile source files to SMF
# 2. Link SMFs using Simple linker
# 3. Generate native binary via mold
#
# Usage:
#   build_native("src/app/cli/main.spl", "simple_new_native")
#
# This enables self-hosting: compiling the Simple CLI (written in Simple)
# to a native binary using the Simple linker.

use linker.*
use driver (compile_to_smf)
use std.string.{NL}

# ============================================================================
# Link Pipeline Types (defined locally because linker/link.spl has deps
# that the bootstrap parser cannot handle)
# ============================================================================

use app.io.{file_read}
use app.io.{file_exists as io_file_exists}
extern fn rt_process_run(cmd: text, args: [text]) -> text

enum OutputFormat:
    Smf
    Native

struct LinkConfig:
    output_format: OutputFormat
    output_path: text
    libraries: [text]
    library_paths: [text]
    pie: bool
    debug: bool
    verbose: bool
    allow_deferred: bool
    optimization_level: i32
    target_flags: [text]
    linker_flags: [text]

struct LinkStats:
    output_size: i64
    symbol_count: i32

enum LinkResult:
    Success(output_path: text, stats: LinkStats)
    Error(message: text, errors: [LinkError])

struct LinkError:
    message: text

struct Linker:
    config: LinkConfig


# ============================================================================
# Linker Methods (was: impl Linker:)
# ============================================================================

fn linker_new(config: LinkConfig) -> i64:
        # Stub: Linker struct and config passing not supported in seed_cpp
        0


fn linker_link(self: Linker, smf_files: [text]) -> LinkResult:
        """Link SMF files to native binary using linker_wrapper."""
        if smf_files_is_empty(smf_files):
            return LinkResult.Error(
                message: "No SMF files to link",
                errors: [LinkError(message: "empty input")]
            )

        # Use linker_wrapper to create native binary
        val output = self.config.output_path
        val verbose = self.config.verbose

        if verbose:
            print "[linker] Linking {smf_files.len()} files -> {output}"

        # Delegate to linker_wrapper's link_native function
        val result = link_native(smf_files, output, self.config)
        match result:
            case Ok(path):
                val stats = LinkStats(output_size: 0, symbol_count: 0)
                linkresult_Success(output_path: path, stats: stats)
            case Err(msg):
                LinkResult.Error(
                    message: msg,
                    errors: [LinkError(message: msg)]
                )


fn link_native(smf_files: [text], output: text, config: LinkConfig) -> text:
    """Link SMF files to a native binary."""
    # For now, use the linker_wrapper's link_native_unix
    var args: [text] = []
    args.push("-o")
    args_push(args, output)

    for lib in config.libraries:
        args.push("-l{lib}")

    for path in config.library_paths:
        args.push("-L{path}")

    if config.pie:
        args.push("-pie")

    for smf in smf_files:
        args_push(args, smf)

    for flag in config.linker_flags:
        args_push(args, flag)

    # Call mold/ld linker
    if config.verbose:
        val args_str = args.join(" ")
        print "[linker] mold {args_str}"

    # MOVED TO MODULE LEVEL: extern fn rt_process_run(cmd: text, args: [text]) -> text
    val result = rt_process_run("mold", args)
    if result.contains("error"):
        Err("Link failed: {result}")
    else:
        Ok(output)

# ============================================================================
# Build Configuration
# ============================================================================

struct BuildConfig:
    """Configuration for native build."""
    entry_point: text
    output: text
    dependencies: [text]
    libraries: [text]
    library_paths: [text]
    optimization: i32
    debug: bool
    verbose: bool
    pie: bool
    # # DESUGARED: target_cpu: text
    has_target_cpu: bool
    target_cpu: text
    target_features: [text]     # Target features (e.g., ["+avx2", "+fma"])
    linker_flags: [text]        # Extra linker flags


# ============================================================================
# BuildConfig Methods (was: impl BuildConfig:)
# ============================================================================

fn buildconfig_default(entry: text, output: text) -> BuildConfig:
        BuildConfig(
            entry_point: entry,
            output: output,
            dependencies: [],
            libraries: ["c"],
            library_paths: [],
            optimization: 0,
            debug: false,
            verbose: false,
            pie: true,
            #  # DESUGARED: target_cpu: nil
            target_features: [],
            linker_flags: []
        )


fn buildconfig_for_simple_cli() -> BuildConfig:
        """Configuration for building simple_new native."""
        BuildConfig(
            entry_point: "src/app/cli/main.spl",
            output: "simple_new_native",
            dependencies: [
                "src/compiler/mod.spl",
                "src/std/src/mod.spl"
            ],
            libraries: ["c", "m", "pthread"],
            library_paths: [],
            optimization: 2,
            debug: false,
            verbose: true,
            pie: true,
            # # DESUGARED: target_cpu: Some("x86-64-v3")
            target_cpu: "x86-64-v3",      # Default to modern CPUs
            target_features: [],
            linker_flags: []
        )


# ============================================================================
# Build Result
# ============================================================================

enum BuildResult:
    Success(output: text, stats: BuildStats)
    CompileError(file: text, message: text)
    LinkError(message: text)
    Error(message: text)

struct BuildStats:
    """Statistics from the build."""
    source_files: i32
    smf_files: i32
    total_symbols: i32
    output_size: i64
    compile_time_ms: i64
    link_time_ms: i64


# ============================================================================
# BuildResult Methods (was: impl BuildResult:)
# ============================================================================

# ============================================================================
# Build Pipeline
# ============================================================================

fn build_native(config: BuildConfig) -> BuildResult:
    """Build a native binary from Simple source files.

    Pipeline:
    1. Discover all source files (entry + dependencies)
    2. Compile each source file to SMF
    3. Link all SMFs with the Simple linker
    4. Generate native binary via mold
    """
    val start_time = current_time_ms()

    if config.verbose:
        print "[build] Starting native build"
        print "[build] Entry point: {config.entry_point}"
        print "[build] Output: {config.output}"

    # 1. Collect all source files
    var source_files: [text] = [config.entry_point]
    source_files = source_files_concat(source_files, config.dependencies)

    # Add implicit dependencies
    source_files = discover_dependencies(source_files, config.verbose)

    if config.verbose:
        print "[build] Compiling {source_files.len()} source files"

    # 2. Compile each source to SMF
    var smf_files: [text] = []
    for source in source_files:
        val smf_path = source_to_smf_path(source)

        if config.verbose:
            print "[build] Compiling: {source} -> {smf_path}"

        val compile_result = compile_to_smf(source, smf_path)
        if compile_result_is_err(compile_result):
            return BuildResult.CompileError(
                file: source,
                message: compile_result_unwrap_err(compile_result)
            )

        smf_files = smf_files_push(smf_files, smf_path)

    val compile_time = current_time_ms() - start_time

    if config.verbose:
        print "[build] Compilation complete ({compile_time}ms)"
        print "[build] Linking {smf_files.len()} SMF files"

    # 3. Link SMFs to native binary
    val link_start = current_time_ms()

    # Build target flags from CPU and features
    var target_flags: [text] = []
    if config.has_target_cpu:
        target_flags.push("-march={config.target_cpu_value}")
    for feature in config.target_features:
        target_flags.push("-m{feature}")

    val link_config = LinkConfig(
        output_format: OutputFormat.Native,
        output_path: config.output,
        libraries: config.libraries,
        library_paths: config.library_paths,
        pie: config.pie,
        debug: config.debug,
        verbose: config.verbose,
        allow_deferred: false,
        optimization_level: config.optimization,
        target_flags: target_flags,
        linker_flags: config.linker_flags
    )

    var linker = linker_new(link_config)
    val link_result = linker_link(linker, smf_files)

    match link_result:
        case Success(output_path, stats):
            val link_time = current_time_ms() - link_start
            val total_time = current_time_ms() - start_time

            if config.verbose:
                print "[build] Link complete ({link_time}ms)"
                print "[build] Output: {output_path}"
                print "[build] Size: {stats.output_size} bytes"
                print "[build] Total time: {total_time}ms"

            BuildResult.Success(
                output: output_path,
                stats: BuildStats(
                    val _as_0 = source_files_len(source_files) as i32
                    source_files: _as_0,
                    val _as_1 = smf_files_len(smf_files) as i32
                    smf_files: _as_1,
                    total_symbols: stats.symbol_count,
                    output_size: stats.output_size,
                    compile_time_ms: compile_time,
                    link_time_ms: link_time
                )
            )

        case Error(message, errors):
            var error_msg_list: [text] = []
            for e in errors:
                error_msg_list.push(e.message)
            val error_msgs = error_msg_list.join(NL)
            BuildResult.LinkError(message: "{message}{NL}{error_msgs}")

# ============================================================================
# Helper Functions
# ============================================================================

fn discover_dependencies(sources: [text], verbose: bool) -> [text]:
    """Discover all transitive dependencies."""
    var all_sources = sources
    var seen: {text: bool} = {}

    for source in sources:
        seen[source] = true

    # Implement import scanning (Phase 1B[5] - TODO #75 ✅)
    # MOVED: use app.io.{file_read}

    # Scan each source file for imports
    var to_scan = sources_copy(sources)
    var scanned = sources_copy(sources)  # Include initial sources in result

    while to_scan_len(to_scan) > 0:
        var current = to_scan[0]
        to_scan = to_scan[1..]  # Remove first element

        if seen_contains_key(seen, current):
            ()  # Already processed
        else:
            seen[current] = true
            scanned_push(scanned, current)

            # Read file and find imports
            if file_exists(current):
                val content = file_read(current)
                val imports = extract_imports(content)

                # Add new imports to scan queue
                for import_path in imports:
                    if not seen_contains_key(seen, import_path):
                        to_scan_push(to_scan, import_path)

    scanned

fn extract_imports(source_code: text) -> [text]:
    """Extract import statements from source code.

    Parses 'use' and 'import' statements to find module dependencies.
    Returns list of module paths (converted to file paths).

    Phase 1B[5] - TODO #75 ✅
    """
    var imports = []
    val lines = source_code.split(NL)

    for line in lines:
        val trimmed = line_trim(line)

        # Match 'use module.path' or 'import module.path'
        if trimmed.starts_with("use ") or trimmed.starts_with("import "):
            # Extract module path
            var module_path = ""

            if trimmed.starts_with("use "):
                module_path = trimmed[4..].trim()
            else:
                module_path = trimmed[7..].trim()

            # Remove curly braces if present (use foo.{bar, baz})
            if module_path.contains("{"):
                val parts = module_path.split("{")
                module_path = parts[0].trim()

            # Remove 'as' aliases
            if module_path.contains(" as "):
                val parts = module_path.split(" as ")
                module_path = parts[0].trim()

            # Convert module path to file path
            # e.g., "std.json" -> "src/std/json.spl"
            if module_path.len() > 0:
                if not module_path.contains("("):
                val file_path = module_to_file_path(module_path)
                imports_push(imports, file_path)

    imports

fn module_to_file_path(module_path: text) -> text:
    """Convert module path to file path.

    Examples:
        std.json -> src/std/json.spl
        app.io.mod -> src/app/io/mod.spl
        compiler.lexer -> src/compiler/lexer.spl
    """
    val path = module_path.replace(".", "/")
    "src/{path}.spl"

fn file_exists(path: text) -> bool:
    """Check if file exists (helper for import scanning)."""
    # MOVED: use app.io.{file_exists as io_file_exists}
    io_file_exists(path)

fn source_to_smf_path(source: text) -> text:
    """Convert source path to SMF output path."""
    # Replace .spl with .smf, put in .build directory
    val base_no_ext = source.replace(".spl", "")
    val base = base_no_ext.replace("/", "_")
    ".build/{base}.smf"

fn current_time_ms() -> i64:
    """Get current time in milliseconds."""
    # Note: rt_time_now_unix_millis not available in bootstrap binary
    0

# ============================================================================
# Convenience Functions
# ============================================================================

fn build_simple_cli() -> BuildResult:
    """Build the Simple CLI to native binary."""
    val config = buildconfig_for_simple_cli()
    build_native(config)

fn build_file(source: text, output: text) -> BuildResult:
    """Build a single file to native binary."""
    val config = buildconfig_default(source, output)
    build_native(config)

# ============================================================================
# CLI Integration
# ============================================================================

fn handle_build_command(args: [text]) -> i32:
    """Handle 'simple build' command.

    Usage:
      simple build <source.spl> [-o <output>] [--native] [--verbose]
      simple build --self  # Build simple_new_native
    """
    if args_is_empty(args):
        print "Usage: simple build <source.spl> [-o <output>] [--native]"
        print "       simple build --self  # Build simple_new_native"
        return 1

    # Check for --self flag (build simple_new)
    if args[0] == "--self":
        print "Building simple_new_native..."
        val result = build_simple_cli()
        match result:
            case Success(output, stats):
                print "Build successful!"
                print "  Output: {output}"
                print "  Size: {stats.output_size} bytes"
                print "  Source files: {stats.source_files}"
                print "  Compile time: {stats.compile_time_ms}ms"
                print "  Link time: {stats.link_time_ms}ms"
                return 0
            case CompileError(file, msg):
                print "Compile error in {file}:"
                print "  {msg}"
                return 1
            case LinkError(msg):
                print "Link error: {msg}"
                return 1
            case Error(msg):
                print "Build error: {msg}"
                return 1

    # Parse arguments
    var source = args[0]
    var output = source.replace(".spl", "")
    var verbose = false

    var i = 1
    while i < args_len(args):
        match args[i]:
            case "-o":
                if i + 1 < args_len(args):
                    output = args[i + 1]
                    i = i + 2
                else:
                    print "Error: -o requires an argument"
                    return 1
            case "--verbose":
                verbose = true
                i = i + 1
            case "--native":
                # Default is native, this is a no-op
                i = i + 1
            case _:
                print "Unknown option: {args[i]}"
                return 1

    # Build
    var config = buildconfig_default(source, output)
    config.verbose = verbose

    val result = build_native(config)
    match result:
        case Success(out, stats):
            print "Build successful: {out}"
            return 0
        case CompileError(file, msg):
            print "Compile error in {file}: {msg}"
            return 1
        case LinkError(msg):
            print "Link error: {msg}"
            return 1
        case Error(msg):
            print "Build error: {msg}"
            return 1

# ============================================================================
# Exports
# ============================================================================

export BuildConfig
export BuildResult
export BuildStats
export build_native
export build_simple_cli
export build_file
export handle_build_command

# ============================================================================
# Entry Point
# ============================================================================

val args = sys_get_args()
# Skip the script path itself - args[0] is the script, rest are user args
var user_args: [text] = []
if args_len(args) > 1:
    for i in 1..args_len(args):
        user_args_push(user_args, args[i])

val exit_code = handle_build_command(user_args)
if exit_code != 0:
    exit(exit_code)
