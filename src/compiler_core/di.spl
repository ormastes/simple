# Dependency Injection Container
#
# DI container with profile-based bindings for compiler services.
# Profiles: dev, test, prod, sdn â€” each binds different implementations.

use compiler.config (CompilerProfile)

# Local panic function for DI errors
fn di_panic(msg: text):
    print "DI PANIC: {msg}"

# ============================================================================
# Binding
# ============================================================================

struct Binding:
    """A named binding: factory + optional profile restriction."""
    factory: fn() -> Any
    # # DESUGARED: profile: CompilerProfile
    has_profile: bool
    profile: CompilerProfile
    tags: [text]

# ============================================================================
# DiContainer
# ============================================================================

class DiContainer:
    """Dependency injection container with profile-based bindings.

    Usage:
        val di = DiContainer(bindings: {}, singletons: {}, profile: "dev", all_bindings: [])
        di.bind("Backend", \: InterpreterBackendImpl.new())
        di.bind_for_profile("Backend", CompilerProfile.Prod, \: CompilerBackendImpl.jit())
        val backend = di.resolve("Backend")
    """
    bindings: Dict<text, fn() -> Any>
    singletons: Dict<text, Any>
    profile: text
    all_bindings: [Binding]


# ============================================================================
# DiContainer Methods (was: impl DiContainer:)
# ============================================================================

fn dicontainer_for_profile(profile: CompilerProfile) -> DiContainer:
        """Create container configured for a specific profile."""
        DiContainer(
            bindings: {},
            singletons: {},
            profile: profile_to_text(profile),
            all_bindings: []
        )


fn dicontainer_resolve_singleton(self: DiContainer, name: text) -> Any:
        """Resolve and cache as singleton for future calls."""
        if self.singletons_contains(singletons, name):
            return self.singletons[name]
        if self.bindings_contains(bindings, name):
            val instance = self.bindings[name]()
            var s = self.singletons
            s[name] = instance
            self.singletons = s
            return instance
        di_panic("No binding found for: {name}")
        nil


# ============================================================================
# Global container access
# ============================================================================

var _global_container: DiContainer = nil

fn set_container(container: DiContainer):
    """Set the global DI container."""
    _global_container = container

fn get_container() -> DiContainer:
    """Get the global DI container (creates default if not set)."""
    if has__global_container:
        return _global_container_value
    val default = dicontainer_for_profile(CompilerProfile.Dev)
    _global_container = default
    default

export DiContainer, Binding
export set_container, get_container
