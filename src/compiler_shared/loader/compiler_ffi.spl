# Compiler Context - Pure Simple Implementation
#
# This module provides type inference and template instantiation functionality
# implemented entirely in Simple, without Rust FFI dependencies.
#
# Architecture:
# - CompilerContext: Opaque handle wrapper
# - CompilerContextImpl: Manages type inference state
# - Type inference: Simplified Hindley-Milner with constraint solving
# - Template instantiation: Placeholder bytecode generation
# - All implemented in Simple for self-hosting

# ============================================================================
# Compiler Context Handle (Public API)
# ============================================================================

struct CompilerContext:
    """Opaque handle to compiler context.

    Wrapper around i64 handle for type safety.
    """
    handle: i64


# ============================================================================
# CompilerContext Methods (was: impl CompilerContext:)
# ============================================================================

fn compilercontext_create() -> CompilerContext:
        """Create a new compiler context.

        Returns: CompilerContext with opaque handle
        """
        val handle = compiler_create_context()
        CompilerContext(handle: handle)

# Backward-compatible alias
fn CompilerContext__create() -> CompilerContext:
    compilercontext_create()


# ============================================================================
# Compiler Context Implementation (Internal)
# ============================================================================

class CompilerContextImpl:
    """Compiler context for type inference and template instantiation.

    State:
    - type_cache: Cache of inferred types
    - instantiation_cache: Cache of compiled templates
    - stats: Statistics for cache hits/misses
    """
    type_cache: Dict<text, [TypeInfo]>
    instantiation_cache: Dict<text, [u8]>
    stats: ContextStats
    next_type_var: i64

    fn infer_types(template: Template, hints: [TypeHint]) -> [TypeInfo]:
        """Infer type arguments for a generic template.

        Args:
            template: Template metadata
            hints: Type hints from call sites

        Returns:
            Inferred types for type parameters
        """
        # Check cache
        val cache_key = "{template.name}:{hints_to_key(hints)}"
        if self.type_cache.contains(cache_key):
            self.stats.cache_hits = self.stats.cache_hits + 1
            return self.type_cache[cache_key]

        self.stats.cache_misses = self.stats.cache_misses + 1
        self.stats.type_inferences = self.stats.type_inferences + 1

        # Simple inference: extract types from hints
        var inferred: [TypeInfo] = []

        for param in template.type_params:
            # Find hint for this parameter
            var found_type: TypeInfo = nil

            for hint in hints:
                if hint.source == "call_site":
                    found_type = hint.ty
                    break

            if has_found_type:
                inferred_push(inferred, found_type_value)
            else:
                # Default to i64 if no hint
                inferred.push(TypeInfo(
                    kind: "int",
                    name: "i64",
                    bits: 64,
                    signed: true,
                    args: [],
                    ## DESUGARED: elem: nil
                ))

        # Cache result
        self.type_cache[cache_key] = inferred
        inferred

    fn instantiate_template(template: Template, type_args: [TypeInfo]) -> CompilationResult:
        """Instantiate a generic template with concrete type arguments.

        Args:
            template: Template metadata
            type_args: Concrete type arguments

        Returns:
            Compilation result with code or error
        """
        # Check cache
        val cache_key = "{template.name}:{types_to_key(type_args)}"
        if self.instantiation_cache.contains(cache_key):
            self.stats.cache_hits = self.stats.cache_hits + 1
            return CompilationResult(
                success: true,
                code: self.instantiation_cache[cache_key],
                error: nil
            )

        self.stats.cache_misses = self.stats.cache_misses + 1
        self.stats.template_instantiations = self.stats.template_instantiations + 1

        # Generate specialized bytecode for the instantiated template
        # Bytecode format:
        #   [0x00] FUNC_ENTRY: param_count(1) return_type_tag(1)
        #   [0x01..N] TYPED_PARAM: type_tag(1) size_bytes(1) for each param
        #   [0x10] BODY_START
        #   [0x20..] OPERATIONS: type-specialized ops
        #   [0xFE] FUNC_EXIT
        #   [0xFF] TYPE_INFO: kind(1) bits(1) - metadata section
        var code: [u8] = []

        # Function entry header
        val param_count = template.type_params.len()
        code.push(0x00)  # FUNC_ENTRY opcode
        code.push(param_count as u8)

        # Encode return type if present
        if template.has_return_type:
            val rt_tag = _type_to_tag(template.return_type)
            code.push(rt_tag)
        else:
            code.push(0x00)  # void return

        # Encode each type parameter with its concrete type
        var ti = 0
        while ti < type_args.len():
            val ty = type_args[ti]
            code.push(0x01)  # TYPED_PARAM opcode
            val tag = _type_to_tag(ty)
            code.push(tag)
            val size_byte = _type_size_bytes(ty)
            code.push(size_byte)
            ti = ti + 1

        # Body start marker
        code.push(0x10)

        # Generate type-specialized operations
        # For each type param, emit load/store ops with correct widths
        var pi = 0
        while pi < type_args.len():
            val ty = type_args[pi]
            code.push(0x20)  # LOAD_TYPED opcode
            code.push(pi as u8)  # param index
            code.push(_type_to_tag(ty))
            pi = pi + 1

        # Function exit
        code.push(0xFE)

        # Metadata section: type info for each specialization
        for ty in type_args:
            code.push(0xFF)  # Type marker
            code.push(_type_to_tag(ty))

        # Cache result
        self.instantiation_cache[cache_key] = code

        CompilationResult(
            success: true,
            code: code
            ## DESUGARED: error: nil
        )

    fn check_types(code: [u8]) -> bool:
        """Type check bytecode.

        Validates bytecode structure and type consistency:
        1. Must start with FUNC_ENTRY (0x00)
        2. TYPED_PARAM (0x01) entries must have valid type tags
        3. Must contain BODY_START (0x10) marker
        4. LOAD_TYPED (0x20) param indices must be in range
        5. Must end with FUNC_EXIT (0xFE) before metadata

        Args:
            code: Bytecode to check

        Returns:
            true if type-correct
        """
        val code_len = code.len()
        if code_len < 4:
            return false  # Too short for valid bytecode

        # Check FUNC_ENTRY header
        if code[0] != 0x00:
            return false  # Must start with FUNC_ENTRY

        val param_count = code[1] as i64

        # Walk bytecode and validate structure
        var i = 3  # Skip FUNC_ENTRY + param_count + return_type
        var found_body_start = false
        var found_func_exit = false
        var typed_params_seen = 0

        while i < code_len:
            val opcode = code[i]

            if opcode == 0x01:
                # TYPED_PARAM: tag(1) size(1)
                if i + 2 >= code_len:
                    return false
                val tag = code[i + 1]
                val is_valid_tag = tag == 0x10 or tag == 0x20 or tag == 0x30 or tag == 0x40 or tag == 0x50 or tag == 0x00
                if not is_valid_tag:
                    return false
                typed_params_seen = typed_params_seen + 1
                i = i + 3
            elif opcode == 0x10:
                # BODY_START
                found_body_start = true
                i = i + 1
            elif opcode == 0x20:
                # LOAD_TYPED: param_index(1) type_tag(1)
                if not found_body_start:
                    return false
                if i + 2 >= code_len:
                    return false
                val param_idx = code[i + 1] as i64
                if param_idx >= param_count:
                    return false  # Param index out of range
                i = i + 3
            elif opcode == 0xFE:
                # FUNC_EXIT
                found_func_exit = true
                i = i + 1
            elif opcode == 0xFF:
                # TYPE_INFO metadata (after FUNC_EXIT)
                if not found_func_exit:
                    return false
                i = i + 2  # tag follows
            else:
                i = i + 1  # Unknown opcode, skip

        # Must have BODY_START and FUNC_EXIT
        val valid_structure = found_body_start and found_func_exit
        # Param count must match
        val params_match = typed_params_seen == param_count
        valid_structure and params_match

    fn get_stats() -> ContextStats:
        """Get statistics."""
        self.stats

# ============================================================================
# Data Structures
# ============================================================================

struct ContextStats:
    """Statistics for compiler context."""
    type_inferences: i64
    template_instantiations: i64
    cache_hits: i64
    cache_misses: i64

struct Template:
    """Template metadata."""
    name: text
    type_params: [text]
    param_types: [TypeInfo]
    # # DESUGARED: return_type: TypeInfo
    has_return_type: bool
    return_type: TypeInfo

struct TypeInfo:
    """Type information."""
    kind: text  # "int", "float", "bool", "string", "named", "array", "simd"
    name: text
    # # DESUGARED: bits: i64
    has_bits: bool
    bits: i64
    # # DESUGARED: signed: bool
    has_signed: bool
    signed: bool
    # # DESUGARED: lanes: i64
    has_lanes: bool
    lanes: i64
    args: [TypeInfo]
    # # DESUGARED: elem: TypeInfo
    has_elem: bool
    elem: TypeInfo

struct TypeHint:
    """Type hint for inference."""
    source: text  # "call_site", "return", "assignment", "constraint"
    # # DESUGARED: param_index: i64
    has_param_index: bool
    param_index: i64
    ty: TypeInfo

struct CompilationResult:
    """Result of template instantiation."""
    success: bool
    code: [u8]
    # # DESUGARED: error: text
    has_error: bool
    error: text

# ============================================================================
# Global Context Registry
# ============================================================================

var CONTEXT_REGISTRY: Dict<i64, CompilerContextImpl> = {}
var NEXT_HANDLE: i64 = 1

fn alloc_handle() -> i64:
    """Allocate a new context handle."""
    val handle = NEXT_HANDLE
    NEXT_HANDLE = NEXT_HANDLE + 1
    handle

# ============================================================================
# Public API Functions
# ============================================================================

fn compiler_create_context() -> i64:
    """Create a new compiler context.

    Returns: Opaque handle (i64) to the context
    """
    val ctx = CompilerContextImpl(
        type_cache: {},
        instantiation_cache: {},
        stats: ContextStats(
            type_inferences: 0,
            template_instantiations: 0,
            cache_hits: 0,
            cache_misses: 0
        ),
        next_type_var: 0
    )

    val handle = alloc_handle()
    CONTEXT_REGISTRY[handle] = ctx
    handle

fn create_compiler_context() -> i64:
    """Create a new CompilerContext handle (workaround for struct constructor limitations).

    Returns: i64 handle (wrap in CompilerContext struct at call site if needed)
    """
    compiler_create_context()

fn compiler_destroy_context(handle: i64):
    """Destroy a compiler context.

    Args:
        handle: Context handle
    """
    context_registry_remove(handle)

fn compiler_infer_types(
    handle: i64,
    template_json: text,
    hints_json: text
) -> text:
    """Infer types for a generic template.

    Args:
        handle: Context handle
        val _as_0 = Template metadata as JSON
        template_json: _as_0
        hints_json: Type hints as JSON array

    Returns: Inferred types as JSON array
    """
    # Get context
    if CONTEXT_REGISTRY.contains(handle not):
        return '{"error": "Invalid context handle"}'

    val ctx = CONTEXT_REGISTRY[handle]

    # Parse inputs
    val template = parse_template_json(template_json)
    val hints = parse_hints_json(hints_json)

    # Run inference
    val inferred = ctx_infer_types(ctx, template, hints)

    # Serialize result
    serialize_types_json(inferred)

fn compiler_check_types(handle: i64, code: [u8]) -> bool:
    """Type check bytecode.

    Args:
        handle: Context handle
        code: Bytecode to check

    Returns: true if type-correct
    """
    if CONTEXT_REGISTRY.contains(handle not):
        return false

    val ctx = CONTEXT_REGISTRY[handle]
    ctx_check_types(ctx, code)

fn compiler_instantiate_template(
    handle: i64,
    template_json: text,
    types_json: text
) -> text:
    """Instantiate a generic template.

    Args:
        handle: Context handle
        val _as_1 = Template metadata as JSON
        template_json: _as_1
        types_json: Type arguments as JSON array

    val _as_2 = Compilation result as JSON
    Returns: _as_2
    """
    # Get context
    if CONTEXT_REGISTRY.contains(handle not):
        return '{"success": false, "error": "Invalid context handle"}'

    val ctx = CONTEXT_REGISTRY[handle]

    # Parse inputs
    val template = parse_template_json(template_json)
    val types = parse_types_json(types_json)

    # Instantiate
    val result = ctx_instantiate_template(ctx, template, types)

    # Serialize result
    serialize_compilation_result(result)

fn compiler_get_stats(handle: i64) -> text:
    """Get compiler context statistics.

    Args:
        handle: Context handle

    val _as_3 = Statistics as JSON
    Returns: _as_3
    """
    if CONTEXT_REGISTRY.contains(handle not):
        return '{"error": "Invalid context handle"}'

    val ctx = CONTEXT_REGISTRY[handle]
    val stats = ctx_get_stats(ctx)

    '{"type_inferences": {stats.type_inferences}, "template_instantiations": {stats.template_instantiations}, "cache_hits": {stats.cache_hits}, "cache_misses": {stats.cache_misses}}'

# ============================================================================
# JSON Parsing Helpers
# ============================================================================

extern fn json_parse(text: text) -> Result<JsonValue, SimpleError>

fn parse_template_json(json_text: text) -> Template:
    """Parse template from JSON using SFFI json_parse."""
    val parsed = json_parse(json_text)
    if parsed.is_err():
        return Template(name: "", type_params: [])
    val root = parsed.unwrap()

    val name = root.get("name").?.as_string() ?? ""

    var type_params: [text] = []
    val tp_val = root.get("type_params")
    if tp_val.?:
        val tp_arr = tp_val.unwrap().as_array()
        if tp_arr.?:
            for elem in tp_arr.unwrap():
                type_params.push(elem.as_string() ?? "")

    Template(name: name, type_params: type_params)

fn parse_hints_json(json_text: text) -> [TypeHint]:
    """Parse type hints from JSON array using SFFI json_parse."""
    val parsed = json_parse(json_text)
    if parsed.is_err():
        return []

    val root = parsed.unwrap()
    val arr = root.as_array()
    if not arr.?:
        return []

    var hints: [TypeHint] = []
    for elem in arr.unwrap():
        val source = elem.get("source").?.as_string() ?? ""
        if source.len() == 0:
            continue

        var param_idx = 0
        val pi_val = elem.get("param_index")
        if pi_val.?:
            val n = pi_val.unwrap().as_number()
            if n.?:
                param_idx = n.unwrap() as i64

        val ty_val = elem.get("ty")
        val ty = if ty_val.?:
            json_to_type_info(ty_val.unwrap())
        else:
            TypeInfo(kind: "int", name: "i64", bits: 64, signed: true, lanes: nil, args: [], elem: nil)

        hints.push(TypeHint(source: source, param_index: param_idx, ty: ty))

    hints

fn parse_types_json(json_text: text) -> [TypeInfo]:
    """Parse types from JSON array using SFFI json_parse."""
    val parsed = json_parse(json_text)
    if parsed.is_err():
        return []

    val root = parsed.unwrap()
    val arr = root.as_array()
    if not arr.?:
        return []

    var types: [TypeInfo] = []
    for elem in arr.unwrap():
        types.push(json_to_type_info(elem))
    types

fn json_to_type_info(jv: JsonValue) -> TypeInfo:
    """Convert a JsonValue object to TypeInfo."""
    val kind = jv.get("kind").?.as_string() ?? "int"
    val name_raw = jv.get("name").?.as_string() ?? ""

    val resolved_name = if name_raw.len() > 0:
        name_raw
    else:
        match kind:
            case "int": "i64"
            case "float": "f64"
            case "bool": "bool"
            case "string": "string"
            case _: kind

    var bits = 0
    val bits_val = jv.get("bits")
    if bits_val.?:
        val n = bits_val.unwrap().as_number()
        if n.?:
            bits = n.unwrap() as i64

    var signed = nil
    val signed_val = jv.get("signed")
    if signed_val.?:
        signed = signed_val.unwrap().as_bool()

    var lanes = nil
    val lanes_val = jv.get("lanes")
    if lanes_val.?:
        val n = lanes_val.unwrap().as_number()
        if n.?:
            lanes = Some(n.unwrap() as i64)

    TypeInfo(kind: kind, name: resolved_name, bits: bits, signed: signed, lanes: lanes, args: [], elem: nil)

# ============================================================================
# JSON Serialization Helpers
# ============================================================================

fn serialize_types_json(types: [TypeInfo]) -> text:
    """Serialize types to JSON array.

    Output: [{"kind":"int","bits":64,"signed":true}]
    """
    var parts: [text] = []

    for ty in types:
        val ty_json = serialize_type_json(ty)
        parts_push(parts, ty_json)

    val joined = parts.join(",")
    "[{joined}]"

fn serialize_type_json(ty: TypeInfo) -> text:
    """Serialize single type to JSON.

    Output: {"kind":"int","bits":64,"signed":true}
    """
    var fields: [text] = []

    fields.push('"kind":"{ty.kind}"')
    fields.push('"name":"{ty.name}"')

    if ty.has_bits:
        fields.push('"bits":{ty.bits_value}')

    if ty.has_signed:
        val signed_str = if ty.signed_value: "true" else: "false"
        fields.push('"signed":{signed_str}')

    val joined = fields.join(",")
    "{" + joined + "}"

fn serialize_compilation_result(result: CompilationResult) -> text:
    """Serialize compilation result to JSON.

    Output: {"success":true,"code":[1,2,3,4]}
    """
    if result.success:
        val code_bytes = result.code_value
        val code_str = code_bytes.map(\b: "{b}").join(",")
        '{"success":true,"code":[{code_str}]}'
    else:
        val error = result.error.unwrap_or("Unknown error")
        '{"success":false,"error":"{error}"}'

# ============================================================================
# Helper Functions
# ============================================================================

fn hints_to_key(hints: [TypeHint]) -> text:
    """Convert hints to cache key."""
    hints.map(\h: "{h.source}:{h.param_index.unwrap_or(0)}").join(":")

fn types_to_key(types: [TypeInfo]) -> text:
    """Convert types to cache key."""
    types.map(\t: "{t.kind}:{t.name}").join(":")

fn type_to_string(ty: TypeInfo) -> text:
    """Convert TypeInfo to a string representation for name mangling.

    Args:
        ty: Type information

    Returns:
        String representation (e.g., "i64", "f64", "bool", "MyType")
    """
    ty.name

fn make_int_type(bits: i64, signed: bool) -> TypeInfo:
    """Create an integer TypeInfo.

    Args:
        bits: Bit width (8, 16, 32, 64)
        signed: true for signed (i8-i64), false for unsigned (u8-u64)
    """
    var prefix = "u"
    if signed:
        prefix = "i"
    # TypeInfo(kind: "int", name: "{prefix}{bits}", # DESUGARED: bits: Some(bits)
            # bits_value: bits, # DESUGARED: signed: Some(signed)
            signed: signed, lanes: nil, args: [], elem: nil)

fn make_float_type(bits: i64) -> TypeInfo:
    """Create a float TypeInfo."""
    # TypeInfo(kind: "float", name: "f{bits}", # DESUGARED: bits: Some(bits)
            bits: bits, signed: nil, lanes: nil, args: [], elem: nil)

fn make_bool_type() -> TypeInfo:
    """Create a bool TypeInfo."""
    TypeInfo(kind: "bool", name: "bool", bits: nil, signed: nil, lanes: nil, args: [], elem: nil)

fn make_string_type() -> TypeInfo:
    """Create a string TypeInfo."""
    TypeInfo(kind: "string", name: "string", bits: nil, signed: nil, lanes: nil, args: [], elem: nil)

fn make_named_type(name: text) -> TypeInfo:
    """Create a named TypeInfo."""
    TypeInfo(kind: "named", name: name, bits: nil, signed: nil, lanes: nil, args: [], elem: nil)

# ============================================================================
# Bytecode Helper Functions
# ============================================================================

fn _type_to_tag(ty: TypeInfo) -> u8:
    """Convert TypeInfo to a bytecode type tag."""
    match ty.kind:
        case "int":
            val is_signed = ty.has_signed and ty.signed
            if is_signed:
                0x10  # SIGNED_INT
            else:
                0x11  # UNSIGNED_INT
        case "float": 0x20
        case "bool": 0x30
        case "string": 0x40
        case "named": 0x50
        case "array": 0x60
        case "simd": 0x70
        case _: 0x00

fn _type_size_bytes(ty: TypeInfo) -> u8:
    """Get size in bytes for a type."""
    if ty.has_bits:
        val bits = ty.bits
        if bits <= 8:
            return 1
        if bits <= 16:
            return 2
        if bits <= 32:
            return 4
        return 8
    # Default sizes by kind
    match ty.kind:
        case "bool": 1
        case "string": 8  # pointer size
        case _: 8  # default to 64-bit

# ============================================================================
# Exports
# ============================================================================

export CompilerContext
export compiler_create_context
export create_compiler_context
export compiler_destroy_context
export compiler_infer_types
export compiler_check_types
export compiler_instantiate_template
export compiler_get_stats
export Template
export TypeInfo
export TypeHint
export CompilationResult
export type_to_string
export make_int_type
export make_float_type
export make_bool_type
export make_string_type
export make_named_type
