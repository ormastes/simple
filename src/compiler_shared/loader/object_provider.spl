# Object Provider - unified access to SMF modules and instantiated objects
#
# Wraps SmfGetter (module discovery, .smf/.lsm reading) and ObjTaker
# (template/deferred instantiation) behind a single API so loader and linker
# can share caches and instantiation logic. The provider exposes both
# object-file bytes (when available from .lsm) and raw exported code units
# as a fallback for loaders and the linker wrapper.

use compiler.linker.smf_getter.{SmfGetter, SmfLocation}
use compiler_shared.linker.obj_taker.{ObjTaker, ObjTakerConfig, ObjTakeResult}
use compiler_shared.linker.obj_taker.{Template, TypeInfo, SmfReader}
use compiler_shared.linker.object_code_unit.{ObjectCodeUnit, make_object_code_unit}
use compiler.linker.smf_reader_memory.{SmfReaderMemory}
use compiler_shared.loader.compiler_ffi.{CompilerContext, compiler_create_context}
use compiler_shared.linker.object_emitter.{assemble_code_units}
use app.io.mod (shell, file_read_bytes)

struct ObjectProviderConfig:
    search_paths: [text]
    libraries: [text]
    enable_cache: bool
    verbose: bool
    prefer_backend: text?   # nil/"llvm"/"cranlift"

struct ObjectProvider:
    getter: SmfGetter
    obj_taker: ObjTaker
    verbose: bool
    prefer_backend: text?
    object_cache: Dict<text, [u8]>
    smf_cache: Dict<text, [u8]>

impl ObjectProvider:
    static fn new(config: ObjectProviderConfig) -> ObjectProvider:
        var getter = SmfGetter.new()
        getter.set_verbose(config.verbose)
        for p in config.search_paths:
            getter.add_search_path(p)
        for lib in config.libraries:
            _ = getter.add_library(lib)

        val ctx = compiler_create_context()
        val ot_config = ObjTakerConfig(
            enable_caching: config.enable_cache,
            max_cache_size: 10_000,
            verbose: config.verbose,
            allow_deferred: true
        )
        ObjectProvider(
            getter: getter,
            obj_taker: ObjTaker__with_compiler_context(ctx, ot_config),
            verbose: config.verbose,
            prefer_backend: config.prefer_backend,
            object_cache: {},
            smf_cache: {}
        )

    me add_search_path(path: text):
        if not self.getter.search_paths.contains(path):
            self.getter.add_search_path(path)

    me add_library(lib_path: text) -> Result<(), text>:
        self.getter.add_library(lib_path)

    fn list_modules(self: ObjectProvider) -> [text]:
        self.getter.list_modules()

    fn get_module_bytes(self: ObjectProvider, module_name_or_path: text) -> Result<[u8], text>:
        if self.smf_cache.contains_key(module_name_or_path):
            return Ok(self.smf_cache[module_name_or_path])

        val smf_res = self.getter.get(module_name_or_path)
        if smf_res.is_err():
            return Err(smf_res.unwrap_err())

        val smf = smf_res.unwrap()
        if self.getter.verbose:
            print "[object-provider] loaded {module_name_or_path} ({smf.len()} bytes)"
        self.smf_cache[module_name_or_path] = smf
        Ok(smf)

    fn get_reader(self: ObjectProvider, module_name_or_path: text) -> Result<SmfReaderMemory, text>:
        val smf_bytes = self.get_module_bytes(module_name_or_path)?
        SmfReaderMemory.from_data(smf_bytes)

    fn get_object(self: ObjectProvider, module_or_path: text) -> Result<[u8], text>:
        # Prefer cached object
        if self.object_cache.contains_key(module_or_path):
            return Ok(self.object_cache[module_or_path])

        # Try direct object extraction (lsm provides .o)
        val obj_result = self.getter.get_object(module_or_path)
        if obj_result.is_ok():
            val obj = obj_result.unwrap()
            self.object_cache[module_or_path] = obj
            return Ok(obj)

        # Fallback: build object from exported code (ObjTaker-aware)
        val code_units_result = self.get_exported_code(module_or_path)
        if code_units_result.is_err():
            return Err("Object not found for {module_or_path}")

        val units = code_units_result.unwrap()
        val obj_build = self.build_object_from_units(units, module_or_path)
        if obj_build.is_err():
            return Err(obj_build.unwrap_err())

        val obj_bytes = obj_build.unwrap()
        self.object_cache[module_or_path] = obj_bytes
        Ok(obj_bytes)

    fn get_exported_code(self: ObjectProvider, module_or_path: text) -> Result<[ObjectCodeUnit], text>:
        """Return raw code for all exported symbols (fallback when no .o exists)."""
        val reader_res = self.get_reader(module_or_path)
        if reader_res.is_err():
            return Err(reader_res.unwrap_err())

        val reader = reader_res.unwrap()
        # Basic safety: require PIC code when emitting executable sections
        if not reader.header.flags.pic:
            return Err("SMF {module_or_path} is not PIC; cannot embed raw code safely")

        val exports = reader.exported_symbols()
        if exports.len() == 0:
            return Err("No exported symbols in {module_or_path}")

        var units: [ObjectCodeUnit] = []
        for sym in exports:
            # Prefer ObjTaker so deferred/templates are materialized
            val take_res = self.obj_taker.take_object(reader, sym.name)
            var code: [u8] = []
            match take_res:
                case Code(bytes, _, _):
                    code = bytes
                case _:
                    val code_res = reader.read_code(sym)
                    if code_res.is_err():
                        if self.verbose:
                            print "[object-provider] skip {sym.name}: {code_res.unwrap_err()}"
                        continue
                    code = code_res.unwrap()

            units.push(make_object_code_unit(sym.name, code))
        if units.len() == 0:
            return Err("Failed to read exported code for {module_or_path}")
        Ok(units)

    fn instantiate_symbol(self: ObjectProvider, reader: SmfReader, symbol: text, type_args: [TypeInfo]) -> Result<[u8], text>:
        val take_result = self.obj_taker.take_with_types(reader, symbol, type_args)
        match take_result:
            case Code(bytes, _, _):
                Ok(bytes)
            case Error(msg):
                Err(msg)
            case _:
                Err("Unsupported instantiation result for {symbol}")

    fn build_object_from_units(self: ObjectProvider, units: [ObjectCodeUnit], module_name: text) -> Result<[u8], text>:
        """Assemble multiple exported code units into a single temporary .o and return its bytes."""
        if units.len() == 0:
            return Err("No code units to assemble for {module_name}")

        val tmp_dir_cmd = shell("mktemp -d /tmp/simple_objprov.XXXXXX")
        if tmp_dir_cmd.exit_code != 0:
            return Err("mktemp failed for {module_name}")
        val tmp_dir_parts = tmp_dir_cmd.stdout.split("\n")
        val tmp_dir = tmp_dir_parts[0]
        val obj_path = "{tmp_dir}/{module_name.replace(\"/\", \"_\")}.o"

        val asm_res = assemble_code_units(units, obj_path, self.verbose)
        if asm_res.is_err():
            _ = shell("rm -rf '{tmp_dir}'")
            return Err(asm_res.unwrap_err())

        # Read object bytes
        val obj_bytes = file_read_bytes(obj_path)
        _ = shell("rm -rf '{tmp_dir}'")

        if obj_bytes.len() == 0:
            return Err("Empty object generated for {module_name}")

        Ok(obj_bytes)

# ============================================================================
# Exports
# ============================================================================

export ObjectProvider
export ObjectProviderConfig
export ObjectCodeUnit
