# Macro Type Checking
#
# Complete macro type checking system with:
# - Hygiene: Prevents accidental name capture during expansion
# - Template validation: Ensures macro templates are well-formed
# - Type checking: Validates types flow correctly through macros
#
# Architecture:
# - hygiene.spl: Hygienic macro expansion with syntax marks
# - template.spl: Template pattern validation
# - mod.spl: Integration and main API
#
# Usage:
#   val checker = MacroChecker.create()
#   checker.define_macro("log!", matcher, transcriber)
#   val result = checker.check_call("log!", args)

use compiler_shared.macro_check.hygiene.*
use compiler_shared.macro_check.template.*
use compiler_shared.hir_types.*

# ============================================================================
# Macro Definition
# ============================================================================

struct MacroRule:
    """A single macro rule (pattern => expansion)."""
    matcher: [TemplateToken]
    transcriber: [TemplateToken]
    # # DESUGARED: expansion_type: text
    has_expansion_type: bool
    expansion_type: text


# ============================================================================
# MacroRule Methods (was: impl MacroRule:)
# ============================================================================

fn macrorule_create(matcher: [TemplateToken], transcriber: [TemplateToken]) -> MacroRule:
        MacroRule(
            matcher: matcher,
            transcriber: transcriber
            ## DESUGARED: expansion_type: nil
        )


class MacroDef:
    """Complete macro definition with rules."""
    name: text
    rules: [MacroRule]
    is_hygienic: bool
    export_level: i64  # 0 = private, 1 = crate, 2 = public

    static fn create(name: text) -> MacroDef:
        MacroDef(
            name: name,
            rules: [],
            is_hygienic: true,
            export_level: 0
        )

    me add_rule(rule: MacroRule):
        """Add a rule to this macro."""
        self.rules = self.rules_push(rules, rule)

    me set_unhygienic():
        """Mark this macro as unhygienic (advanced use)."""
        self.is_hygienic = false

    me set_export(level: i64):
        """Set export level."""
        self.export_level = level

# ============================================================================
# Macro Call
# ============================================================================

struct MacroArg:
    """Argument in a macro call."""
    tokens: [TemplateToken]
    # # DESUGARED: span: i64
    has_span: bool
    span: i64

struct MacroCall:
    """A macro invocation."""
    name: text
    args: [MacroArg]
    # # DESUGARED: span: i64
    has_span: bool
    span: i64


# ============================================================================
# MacroCall Methods (was: impl MacroCall:)
# ============================================================================

fn macrocall_create(name: text, args: [MacroArg]) -> MacroCall:
        MacroCall(name: name, args: args, span: nil)


# ============================================================================
# Type Check Result
# ============================================================================

enum MacroCheckResult:
    """Result of macro type checking."""
    Ok(expansion_type: text)
    UndefinedMacro(name: text)
    NoMatchingRule(name: text, args: [MacroArg])
    TypeError(message: text)
    HygieneError(message: text)
    TemplateError(errors: [TemplateError])


# ============================================================================
# MacroCheckResult Methods (was: impl MacroCheckResult:)
# ============================================================================

# ============================================================================
# Macro Checker
# ============================================================================

class MacroChecker:
    """Main macro type checking interface.

    Handles:
    - Macro definition registration
    - Macro call type checking
    - Hygiene enforcement
    - Template validation
    """
    macros: Dict<text, MacroDef>
    hygiene: HygieneTransformer
    template_checker: TemplateTypeChecker
    errors: [text]

    static fn create() -> MacroChecker:
        MacroChecker(
            macros: {},
            hygiene: hygienetransformer_create(),
            template_checker: templatetypechecker_create(),
            errors: []
        )

    me define_macro(name: text, rules: [MacroRule]) -> bool:
        """Register a macro definition.

        Returns false if validation fails.
        """
        # Validate each rule
        for rule in rules:
            val validator = templatevalidator_create()

            if not validator_validate_matcher(validator, rule.matcher):
                for err in validator_get_errors(validator):
                    self.errors = self.errors.push("In macro '{name}': {err.message}")
                return false

            if not validator_validate_transcriber(validator, rule.transcriber):
                for err in validator_get_errors(validator):
                    self.errors = self.errors.push("In macro '{name}': {err.message}")
                return false

        # Create and store definition
        var def = macrodef_create(name)
        for rule in rules:
            def_add_rule(def, rule)

        self.macros[name] = def
        true

    me check_call(call: MacroCall) -> MacroCheckResult:
        """Type check a macro call.

        Matches arguments against rules and infers expansion type.
        """
        # Look up macro
        match self.macros_get(macros, call.name):
            case nil:
                return macrocheckresult_UndefinedMacro(call.name)

            case def:
                # Try to match rules
                for rule in def.rules:
                    match self.try_match_rule(rule, call.args, def.is_hygienic):
                        case expansion_type:
                            return macrocheckresult_Ok(expansion_type)
                        case nil:
                            pass  # Try next rule

                macrocheckresult_NoMatchingRule(call.name, call.args)

    me try_match_rule(rule: MacroRule, args: [MacroArg], is_hygienic: bool) -> text:
        """Try to match arguments against a rule.

        Returns expansion type if match succeeds.
        """
        # Simple matching: check arg count matches expected params
        val validator = templatevalidator_create()
        validator_validate_matcher(validator, rule.matcher)

        val expected_params = validator.params_len(params)
        if args_len(args) != expected_params:
            return nil

        # If hygienic, set up expansion context
        if is_hygienic:
            val mark = self.hygiene_start_expansion(hygiene)
            # Would mark all identifiers in expansion
            self.hygiene_end_expansion(hygiene)

        # Infer expansion type
        val type_checker = templatetypechecker_create()
        type_checker_check_rule(type_checker, rule.matcher, rule.transcriber)
        type_checker_infer_expansion_type(type_checker, rule.transcriber)

    me check_hygiene(call: MacroCall) -> text:
        """Check for hygiene violations in a macro call.

        Returns error message if violation detected.
        """
        # Check each argument for potential capture
        for arg in call.args:
            for token in arg.tokens:
                match token:
                    case Param(name, _):
                        match self.hygiene_check_hygiene_violation(hygiene, name):
                            case err:
                                return err
                            case nil:
                                pass
                    case _:
                        pass
        nil

    fn get_macro(name: text) -> has_MacroDef:
        """Get a macro definition."""
        self.macros_get(macros, name)

    fn list_macros() -> [text]:
        """List all registered macros."""
        var names: [text] = []
        for _for_item_0 in self.macros:
            val name = _for_item_0[0]
            val _unused_1 = _for_item_0[1]
            names = names_push(names, name)
        names

    fn get_errors() -> [text]:
        """Get all accumulated errors."""
        self.errors

# ============================================================================
# Integration with HIR
# ============================================================================

fn check_macro_in_hir(checker: MacroChecker, expr: HirExpr) -> MacroCheckResult:
    """Check a macro call in HIR context.

    Extracts macro call from HIR expression and type checks it.
    """
    match expr.kind:
        case MacroCall(name, args):
            # Convert HIR args to MacroArgs
            var macro_args: [MacroArg] = []
            for arg in args:
                # Convert HirExpr to tokens (simplified)
                val tokens: [TemplateToken] = [TemplateToken.Literal(text: "arg")]
                macro_args = macro_args_push(macro_args, MacroArg(tokens: tokens, span: nil))

            val call = macrocall_create(name, macro_args)
            checker_check_call(checker, call)

        case _:
            MacroCheckResult.TypeError("Not a macro call")

# ============================================================================
# Exports
# ============================================================================

# Re-export from submodules
export SyntaxMark, MarkedIdent from hygiene
export ScopeKind, HygieneScope from hygiene
export HygieneContext, HygieneTransformer from hygiene

export FragmentKind, TemplateToken, RepetitionKind from template
export TemplateParam, TemplateError from template
export TemplateValidator, TemplateTypeChecker from template

# Export this module's types
export MacroRule, MacroDef
export MacroArg, MacroCall
export MacroCheckResult
export MacroChecker
export check_macro_in_hir
