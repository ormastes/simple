# Expression Type Inference
#
# Implements expression-level type inference using Hindley-Milner algorithm.
# Port of rust/type/src/checker_infer.rs::infer_expr()
#
# This module extends TypeChecker with expression inference capabilities.

use compiler.type_system.stmt_check.{bind_pattern, extract_element_type}
use compiler.type_system.stmt_check.{bind_pattern}
from inference.types import {Type, TypeVarId, UnifyError, InferError}
from inference.infer import {InferenceEngine}
from ast import {Expr, BinOp, UnaryOp, FStringPart, MacroArg}
from compiler.type_system.checker import {TypeError}
from compiler.type_system.module_check import {ast_type_to_inference_type_engine}

# ============================================================================
# Expression Inference (Extension to TypeChecker)
# ============================================================================

# NOTE: These methods should be added to the TypeChecker class in checker.spl
# For now, we define them as standalone functions that can be integrated.

fn infer_expr(engine: InferenceEngine, expr: Expr, env: Dict<text, Type>) -> text:
    """Infer type of an expression using Hindley-Milner algorithm.

    Port of rust/type/src/checker_infer.rs::infer_expr()
    """
    match expr:
        # ====================================================================
        # Literals
        # ====================================================================
        case Integer(_):
            Ok(type_Int(bits: 64, signed: true))

        case Float(_):
            Ok(type_Float(bits: 64))

        case TypedInteger(_, suffix):
            # Decode numeric suffix to exact integer type
            match suffix:
                case I8: Ok(type_Int(bits: 8, signed: true))
                case I16: Ok(type_Int(bits: 16, signed: true))
                case I32: Ok(type_Int(bits: 32, signed: true))
                case I64: Ok(type_Int(bits: 64, signed: true))
                case U8: Ok(type_Int(bits: 8, signed: false))
                case U16: Ok(type_Int(bits: 16, signed: false))
                case U32: Ok(type_Int(bits: 32, signed: false))
                case U64: Ok(type_Int(bits: 64, signed: false))
                case _: Ok(type_Int(bits: 64, signed: true))

        case TypedFloat(_, suffix):
            # Decode numeric suffix to exact float type
            match suffix:
                case F32: Ok(type_Float(bits: 32))
                case F64: Ok(type_Float(bits: 64))
                case _: Ok(type_Float(bits: 64))

        case String(_):
            Ok(Type.Str)

        case TypedString(_, _):
            Ok(Type.Str)

        case Bool(_):
            Ok(Type.Bool)

        case Nil:
            Ok(Type.Nil)

        case Symbol(_):
            # Symbol literals have a fresh type
            Ok(engine_fresh_var(engine))

        # ====================================================================
        # FString (interpolated strings)
        # ====================================================================
        case FString(parts):
            # Infer each interpolated expression
            # Allow undefined identifiers in placeholders (for template.with pattern)
            for part in parts:
                match part:
                    case ExprPart(e):
                        val result = infer_expr(engine, e, env)
                        match result:
                            case Ok(_):
                                pass  # Continue checking
                            case Err(typeerror_Undefined(_)):
                                # Ignore undefined in FString placeholders
                                # They'll be provided via .with method
                                pass
                            case Err(other_err):
                                return Err(other_err)
                    case Literal(_):
                        pass  # No type checking needed for literals

            Ok(Type.Str)

        # ====================================================================
        # Identifiers
        # ====================================================================
        case Identifier(name):
            # Handle FFI calls: @rt_function_name - strip @ prefix for lookup
            val lookup_name = if name.starts_with("@"):
                name[1:]
            else:
                name

            if env_contains(env, lookup_name):
                Ok(env[lookup_name])
            else:
                Err(TypeError.Undefined("undefined identifier: {name}"))

        case Path(segments):
            # Multi-segment path (e.g., module::Type)
            # For now, return fresh var - full resolution needs module system
            Ok(engine_fresh_var(engine))

        # ====================================================================
        # Binary Operators
        # ====================================================================
        case Binary(op, left, right):
            infer_binary(engine, op, left, right, env)

        # ====================================================================
        # Unary Operators
        # ====================================================================
        case Unary(op, operand):
            infer_unary(engine, op, operand, env)

        # ====================================================================
        # Function Calls
        # ====================================================================
        case Call(callee, args):
            infer_call(engine, callee, args, env)

        case MethodCall(receiver, method, args):
            infer_method_call(engine, receiver, method, args, env)

        # ====================================================================
        # Lambdas
        # ====================================================================
        case Lambda(params, body, move_mode, capture_all):
            infer_lambda(engine, params, body, env)

        # ====================================================================
        # Control Flow
        # ====================================================================
        case IfExpr(let_pattern, condition, then_branch, else_branch):
            infer_if(engine, condition, then_branch, else_branch, env)

        case MatchCase(subject, arms):
            infer_match(engine, subject, arms, env)

        # ====================================================================
        # Collections
        # ====================================================================
        case Array(elements):
            infer_array(engine, elements, env)

        case ArrayRepeat(value, count):
\\\\\        to: zzoxzqoo 2b48645a "feat: Complete Track A/B/C - Native backend layout optimization and LLVM backend" (rebase destination)
-            val value_ty = infer_expr(engine, value, env)
-            val count_ty = infer_expr(engine, count, env)
+            val value_ty = infer_expr(engine, value, env)?
+            val count_ty = infer_expr(engine, count, env)?
             engine_unify(engine, count_ty, Type.Int(bits: 64, signed: true))?
            Ok(type_Array(elem: value_ty, size: nil))

        case VecLiteral(elements):
            # Same as array for type inference purposes
            infer_array(engine, elements, env)

        case Tuple(elements):
            infer_tuple(engine, elements, env)

        case Dict(pairs):
            infer_dict(engine, pairs, env)

        # ====================================================================
        # Field and Index Access
        # ====================================================================
        case FieldAccess(receiver, field):
            infer_field_access(engine, receiver, field, env)

        case Index(receiver, index):
            infer_index_access(engine, receiver, index, env)

        case TupleIndex(receiver, index):
            # Tuple indexing with literal index
            val recv_ty = infer_expr(engine, receiver, env)?
            match engine_resolve(engine, recv_ty):
                case Tuple(elems):
                    if index >= 0:
                        if index < elems_len(elems):
                        Ok(elems[index])
                    else:
                        Err(TypeError.Other("tuple index out of bounds"))
                case _:
                    # Not a tuple - return fresh var
                    Ok(engine_fresh_var(engine))

        case Slice(receiver, start, end, step):
            # Slicing returns same type as receiver (for arrays/strings)
            val recv_ty = infer_expr(engine, receiver, env)?

            # Check slice indices are integers
            if has_start:
\\\\\        to: zzoxzqoo 2b48645a "feat: Complete Track A/B/C - Native backend layout optimization and LLVM backend" (rebase destination)
-                val start_ty = infer_expr(engine, start_value, env)
+                val start_ty = infer_expr(engine, start_value, env)?
                 engine_unify(engine, start_ty, Type.Int(bits: 64, signed: true))?
            if has_end:
\\\\\        to: zzoxzqoo 2b48645a "feat: Complete Track A/B/C - Native backend layout optimization and LLVM backend" (rebase destination)
-                val end_ty = infer_expr(engine, end_value, env)
+                val end_ty = infer_expr(engine, end_value, env)?
                 engine_unify(engine, end_ty, Type.Int(bits: 64, signed: true))?
            if has_step:
\\\\\        to: zzoxzqoo 2b48645a "feat: Complete Track A/B/C - Native backend layout optimization and LLVM backend" (rebase destination)
-                val step_ty = infer_expr(engine, step_value, env)
+                val step_ty = infer_expr(engine, step_value, env)?
                 engine_unify(engine, step_ty, Type.Int(bits: 64, signed: true))?

            Ok(recv_ty)

        # ====================================================================
        # Ranges
        # ====================================================================
        case Range(start, end, bound):
            # Infer range bounds
            if has_start:
                val _unused_1 = infer_expr(engine, start_value, env)?
            if has_end:
                val _unused_2 = infer_expr(engine, end_value, env)?

            # Range type is a fresh variable for now
            # Full implementation needs Range<T> type
            Ok(engine_fresh_var(engine))

        # ====================================================================
        # List/Dict Comprehensions
        # ====================================================================
        case ListComprehension(expr, pattern, iterable, condition):
            # Infer iterable type
            val iterable_ty = infer_expr(engine, iterable, env)?

            # Bind pattern variables (Phase 3[2] - TODO #171 ✅)
            # MOVED: use compiler.type_system.stmt_check.{bind_pattern, extract_element_type}

            val elem_ty_iter = extract_element_type(engine, iterable_ty)?
            val comp_env = bind_pattern(pattern, elem_ty_iter, env)

            # Infer condition with extended environment
            if has_condition:
                val cond_ty = infer_expr(engine, condition_value, comp_env)?
                engine_unify(engine, cond_ty, Type.Bool)?

            # Infer element expression with extended environment
            val elem_ty = infer_expr(engine, expr, comp_env)?

            Ok(type_Array(elem: elem_ty, size: nil))

        case DictComprehension(key, value, pattern, iterable, condition):
            # Similar to list comprehension but returns dict
            val _unused_3 = infer_expr(engine, iterable, env)?

            if has_condition:
                val cond_ty = infer_expr(engine, condition_value, env)?
                engine_unify(engine, cond_ty, Type.Bool)?

            val key_ty = infer_expr(engine, key, env)?
            val value_ty = infer_expr(engine, value, env)?

            Ok(type_Dict(key: key_ty, value: value_ty))

        # ====================================================================
        # Struct Initialization
        # ====================================================================
        case StructInit(name, fields):
            # Infer each field expression
            for _item_0 in fields:
                val field_name = _item_0[0]
                val field_expr = _item_0[1]
                val _unused_4 = infer_expr(engine, field_expr, env)?

            # Return named type - full resolution needs struct definition
            Ok(type_Named(name))

        # ====================================================================
        # Concurrency
        # ====================================================================
        case Spawn(expr):
            # Spawn returns a future/thread handle
            val expr_ty = infer_expr(engine, expr, env)?
            # Return Future<T> or similar
            Ok(Type.Generic(base: "Future", args: [expr_ty]))

        case Go(args, params, body):
            # Go block returns fresh var for now
            Ok(engine_fresh_var(engine))

        case Await(expr):
            # Await unwraps Future<T> to T
            val expr_ty = infer_expr(engine, expr, env)?
            match engine_resolve(engine, expr_ty):
                case Generic(base, args):
                    if base == "Future":
                        if has_args:
                        Ok(args[0])
                    else:
                        Ok(engine_fresh_var(engine))
                case _:
                    Ok(engine_fresh_var(engine))

        case Yield(value):
            if has_value:
                infer_expr(engine, value_value, env)
            else:
                Ok(Type.Unit)

        # ====================================================================
        # Memory Operations
        # ====================================================================
        case New(kind, expr):
            val expr_ty = infer_expr(engine, expr, env)?
            # New creates a pointer to the type
            match kind:
                case Borrow:
                    Ok(type_Borrow(inner: expr_ty))
                case BorrowMut:
                    Ok(type_BorrowMut(inner: expr_ty))
                case _:
                    # Other pointer kinds - return generic pointer for now
                    Ok(engine_fresh_var(engine))

        # ====================================================================
        # Type Casts
        # ====================================================================
        case Cast(expr, target_type):
            # Type annotation - just return the target type
            val _unused_5 = infer_expr(engine, expr, env)?
            Ok(ast_type_to_inference_type_engine(target_type, engine))

        # ====================================================================
        # Optional/Result Operations
        # ====================================================================
        case Try(expr):
            # Try operator (?) unwraps Result<T, E> to T
            val expr_ty = infer_expr(engine, expr, env)?
            match engine_resolve(engine, expr_ty):
                case Result(ok, err):
                    Ok(ok)
                case Optional(inner):
                    Ok(inner)
                case _:
                    # Not a Result/Optional - return fresh var
                    Ok(engine_fresh_var(engine))

        case ExistsCheck(expr):
            # .? operator always returns bool
            val _unused_6 = infer_expr(engine, expr, env)?
            Ok(Type.Bool)

        case UnwrapOr(expr, default):
            # expr ?? default - returns T from Option<T> or default
            val expr_ty = infer_expr(engine, expr, env)?
            val default_ty = infer_expr(engine, default, env)?

            # Unify with default type
            engine_unify(engine, expr_ty, default_ty)?

            Ok(engine_resolve(engine, expr_ty))

        case UnwrapElse(expr, fallback_fn):
            # Similar to UnwrapOr but with function
            val expr_ty = infer_expr(engine, expr, env)?
            val _unused_7 = infer_expr(engine, fallback_fn, env)?

            match engine_resolve(engine, expr_ty):
                case Optional(inner):
                    Ok(inner)
                case _:
                    Ok(engine_fresh_var(engine))

        case UnwrapOrReturn(expr):
            # Unwrap or early return
            val expr_ty = infer_expr(engine, expr, env)?
            match engine_resolve(engine, expr_ty):
                case Optional(inner):
                    Ok(inner)
                case Result(ok, _):
                    Ok(ok)
                case _:
                    Ok(engine_fresh_var(engine))

        case Coalesce(expr, default):
            # Same as UnwrapOr
            val expr_ty = infer_expr(engine, expr, env)?
            val default_ty = infer_expr(engine, default, env)?
            engine_unify(engine, expr_ty, default_ty)?
            Ok(engine_resolve(engine, expr_ty))

        case OptionalChain(expr, field):
            # expr?.field returns Option<FieldType>
            val _unused_8 = infer_expr(engine, expr, env)?
            # Field type lookup needs struct definitions
            val field_ty = engine_fresh_var(engine)
            Ok(type_Optional(inner: field_ty))

        case OptionalMethodCall(receiver, method, args):
            # receiver?.method() returns Option<ReturnType>
            val _unused_9 = infer_expr(engine, receiver, env)?
            for arg in args:
                val _unused_10 = infer_expr(engine, arg.value, env)?

            val ret_ty = engine_fresh_var(engine)
            Ok(type_Optional(inner: ret_ty))

        # ====================================================================
        # Cast Operations
        # ====================================================================
        case CastOr(expr, target_type, default):
            # Cast with default value
            val _unused_11 = infer_expr(engine, expr, env)?
            val _unused_12 = infer_expr(engine, default, env)?
            Ok(ast_type_to_inference_type_engine(target_type, engine))

        case CastElse(expr, target_type, fallback_fn):
            val _unused_13 = infer_expr(engine, expr, env)?
            val _unused_14 = infer_expr(engine, fallback_fn, env)?
            Ok(engine_fresh_var(engine))

        case CastOrReturn(expr, target_type):
            val _unused_15 = infer_expr(engine, expr, env)?
            Ok(engine_fresh_var(engine))

        # ====================================================================
        # Macros
        # ====================================================================
        case MacroInvocation(name, args):
            infer_macro(engine, name, args, env)

        # ====================================================================
        # Spread Operators
        # ====================================================================
        case Spread(expr):
            # Spread preserves the array type
            infer_expr(engine, expr, env)

        case DictSpread(expr):
            # Dict spread preserves the dict type
            infer_expr(engine, expr, env)

        # ====================================================================
        # Functional Update
        # ====================================================================
        case FunctionalUpdate(target, method, args):
            # Returns same type as target
            val target_ty = infer_expr(engine, target, env)?
            for arg in args:
                val _unused_16 = infer_expr(engine, arg.value, env)?
            Ok(target_ty)

        # ====================================================================
        # Contract/Verification Expressions
        # ====================================================================
        case ContractResult:
            # Result placeholder in contracts
            Ok(engine_fresh_var(engine))

        case ContractOld(expr):
            # Old value in postconditions - same type as expr
            infer_expr(engine, expr, env)

        case Forall(pattern, range, predicate):
            val _unused_17 = infer_expr(engine, range, env)?
            val pred_ty = infer_expr(engine, predicate, env)?
            engine_unify(engine, pred_ty, Type.Bool)?
            Ok(Type.Bool)

        case Exists(pattern, range, predicate):
            val _unused_18 = infer_expr(engine, range, env)?
            val pred_ty = infer_expr(engine, predicate, env)?
            engine_unify(engine, pred_ty, Type.Bool)?
            Ok(Type.Bool)

        # ====================================================================
        # Block Expressions
        # ====================================================================
        case DoBlock(stmts):
            # Do block returns type of last statement
            # For now, return fresh var (needs statement inference)
            Ok(engine_fresh_var(engine))

        # ====================================================================
        # Math/ML Extensions
        # ====================================================================
        case GridLiteral(rows, device):
            # Grid literal is a 2D array/tensor
            # Infer element type from first element
\\\\\        to: zzoxzqoo 2b48645a "feat: Complete Track A/B/C - Native backend layout optimization and LLVM backend" (rebase destination)
-            if rows != nil:
+            if rows.?:
                 if rows[0].?:
-                val first_elem_ty = infer_expr(engine, rows[0][0], env)
+                val first_elem_ty = infer_expr(engine, rows[0][0], env)?
                 Ok(type_Array(elem: Type.Array(elem: first_elem_ty, size: nil), size: nil))
            else:
                Ok(engine_fresh_var(engine))

        case TensorLiteral(dtype, dims, mode, device):
            # Tensor type - use dtype and dimensions
            # For now, return generic Tensor type
            Ok(Type.Named("Tensor"))

        case BlockExpr(kind, payload):
            # Math blocks and other special blocks
            Ok(engine_fresh_var(engine))

        # ====================================================================
        # I18n
        # ====================================================================
        case I18nString(_, _):
            Ok(Type.Str)

        case I18nTemplate(_, _, _):
            Ok(Type.Str)

        case I18nRef(_):
            Ok(Type.Str)

        # ====================================================================
        # Fallback
        # ====================================================================
        case _:
            # Unsupported expression type - return fresh variable
            Ok(engine_fresh_var(engine))

# ============================================================================
# Binary Operators
# ============================================================================

fn infer_binary(engine: InferenceEngine, op: BinOp, left: Expr, right: Expr,
                env: Dict<text, Type>) -> text:
    """Infer type of binary operation."""
    val left_ty = infer_expr(engine, left, env)?
    val right_ty = infer_expr(engine, right, env)?

    match op:
        # Arithmetic operators: unify operands, return numeric type
        case Add:
            engine_unify(engine, left_ty, right_ty)?
            Ok(engine_resolve(engine, left_ty))

        case Sub:
            engine_unify(engine, left_ty, right_ty)?
            Ok(engine_resolve(engine, left_ty))

        case Mul:
            engine_unify(engine, left_ty, right_ty)?
            Ok(engine_resolve(engine, left_ty))

        case Div:
            engine_unify(engine, left_ty, right_ty)?
            Ok(engine_resolve(engine, left_ty))

        case Mod:
            engine_unify(engine, left_ty, right_ty)?
            Ok(engine_resolve(engine, left_ty))

        case Pow:
            engine_unify(engine, left_ty, right_ty)?
            Ok(engine_resolve(engine, left_ty))

        case MatMul:
            engine_unify(engine, left_ty, right_ty)?
            Ok(engine_resolve(engine, left_ty))

        # Comparison operators: unify operands, return bool
        case Eq:
            engine_unify(engine, left_ty, right_ty)?
            Ok(Type.Bool)

        case NotEq:
            engine_unify(engine, left_ty, right_ty)?
            Ok(Type.Bool)

        case Lt:
            engine_unify(engine, left_ty, right_ty)?
            Ok(Type.Bool)

        case Gt:
            engine_unify(engine, left_ty, right_ty)?
            Ok(Type.Bool)

        case LtEq:
            engine_unify(engine, left_ty, right_ty)?
            Ok(Type.Bool)

        case GtEq:
            engine_unify(engine, left_ty, right_ty)?
            Ok(Type.Bool)

        # Logical operators: both operands bool, return bool
        case And:
            engine_unify(engine, left_ty, Type.Bool)?
            engine_unify(engine, right_ty, Type.Bool)?
            Ok(Type.Bool)

        case Or:
            engine_unify(engine, left_ty, Type.Bool)?
            engine_unify(engine, right_ty, Type.Bool)?
            Ok(Type.Bool)

        case AndSuspend:
            engine_unify(engine, left_ty, Type.Bool)?
            engine_unify(engine, right_ty, Type.Bool)?
            Ok(Type.Bool)

        case OrSuspend:
            engine_unify(engine, left_ty, Type.Bool)?
            engine_unify(engine, right_ty, Type.Bool)?
            Ok(Type.Bool)

        # Bitwise operators: both operands int, return int
        case BitAnd:
            val unify_left1 = engine_unify(engine, left_ty, Type.Int(bits: 64, signed: true))
            if unify_left1.is_err():
                return unify_left1
            val unify_right1 = engine_unify(engine, right_ty, Type.Int(bits: 64, signed: true))
            if unify_right1.is_err():
                return unify_right1
            Ok(type_Int(bits: 64, signed: true))

        case BitOr:
            val unify_left2 = engine_unify(engine, left_ty, Type.Int(bits: 64, signed: true))
            if unify_left2.is_err():
                return unify_left2
            val unify_right2 = engine_unify(engine, right_ty, Type.Int(bits: 64, signed: true))
            if unify_right2.is_err():
                return unify_right2
            Ok(type_Int(bits: 64, signed: true))

        case BitXor:
            val unify_left3 = engine_unify(engine, left_ty, Type.Int(bits: 64, signed: true))
            if unify_left3.is_err():
                return unify_left3
            val unify_right3 = engine_unify(engine, right_ty, Type.Int(bits: 64, signed: true))
            if unify_right3.is_err():
                return unify_right3
            Ok(type_Int(bits: 64, signed: true))

        case ShiftLeft:
            val unify_left4 = engine_unify(engine, left_ty, Type.Int(bits: 64, signed: true))
            if unify_left4.is_err():
                return unify_left4
            val unify_right4 = engine_unify(engine, right_ty, Type.Int(bits: 64, signed: true))
            if unify_right4.is_err():
                return unify_right4
            Ok(type_Int(bits: 64, signed: true))

        case ShiftRight:
            val unify_left5 = engine_unify(engine, left_ty, Type.Int(bits: 64, signed: true))
            if unify_left5.is_err():
                return unify_left5
            val unify_right5 = engine_unify(engine, right_ty, Type.Int(bits: 64, signed: true))
            if unify_right5.is_err():
                return unify_right5
            Ok(type_Int(bits: 64, signed: true))

        # Is and In operators: return bool
        case Is:
            Ok(Type.Bool)

        case In:
            Ok(Type.Bool)

        case NotIn:
            Ok(Type.Bool)

        # Pipe forward: x |> f - return function result type
        case PipeForward:
            match engine_resolve(engine, right_ty):
                case Function(params, ret):
                    Ok(ret)
                case _:
                    # Not a function - return fresh var
                    Ok(engine_fresh_var(engine))

        # Parallel operator: returns tuple of both results
        case Parallel:
            Ok(type_Tuple(elements: [left_ty, right_ty]))

        case _:
            # Unknown operator - return fresh var
            Ok(engine_fresh_var(engine))

# ============================================================================
# Unary Operators
# ============================================================================

fn infer_unary(engine: InferenceEngine, op: UnaryOp, operand: Expr,
               env: Dict<text, Type>) -> text:
    """Infer type of unary operation."""
    val operand_ty = infer_expr(engine, operand, env)?

    match op:
        case Neg:
            # Negation: operand must be numeric
            val unify_neg = engine_unify(engine, operand_ty, Type.Int(bits: 64, signed: true))
            if unify_neg.is_err():
                return unify_neg
            Ok(type_Int(bits: 64, signed: true))

        case Not:
            # Logical not: returns bool
            Ok(Type.Bool)

        case BitNot:
            # Bitwise not: operand must be int
            val unify_bitnot = engine_unify(engine, operand_ty, Type.Int(bits: 64, signed: true))
            if unify_bitnot.is_err():
                return unify_bitnot
            Ok(type_Int(bits: 64, signed: true))

        case Ref:
            # Borrow: &T
            Ok(type_Borrow(inner: operand_ty))

        case RefMut:
            # Mutable borrow: &mut T
            Ok(type_BorrowMut(inner: operand_ty))

        case Deref:
            # Dereference: *T -> T
            match engine_resolve(engine, operand_ty):
                case Borrow(inner):
                    Ok(inner)
                case BorrowMut(inner):
                    Ok(inner)
                case _:
                    # Not a reference - pass through
                    Ok(operand_ty)

        case ChannelRecv:
            # Channel receive: <-chan extracts T from Channel<T>
            match engine_resolve(engine, operand_ty):
                case Generic(base, args):
                    if base == "Channel":
                        if has_args:
                        Ok(args[0])
                    else:
                        Ok(engine_fresh_var(engine))
                case Named(name):
                    if name == "Channel":
                        Ok(engine_fresh_var(engine))
                    else:
                        Ok(engine_fresh_var(engine))
                case Var(_):
                    # Create constraint: must be Channel<T>
                    val inner = engine_fresh_var(engine)
                    val channel_ty = Type.Generic(base: "Channel", args: [inner])
                    engine_unify(engine, operand_ty, channel_ty)?
                    Ok(inner)
                case _:
                    Ok(engine_fresh_var(engine))

        case Move:
            # Move is a semantic marker - type unchanged
            Ok(operand_ty)

        case _:
            # Unknown operator
            Ok(engine_fresh_var(engine))

# ============================================================================
# Function Calls
# ============================================================================

fn infer_call(engine: InferenceEngine, callee: Expr, args: [Argument],
              env: Dict<text, Type>) -> text:
    """Infer type of function call."""
    val callee_ty = infer_expr(engine, callee, env)?

    # Infer argument types
    var arg_types: [Type] = []
    for arg in args:
        val arg_ty = infer_expr(engine, arg.value, env)
        if arg_ty.is_err():
            return arg_ty
        arg_types = arg_types_push(arg_types, arg_ty)

    # Create result type variable
    val result_ty = engine_fresh_var(engine)

    # Check if callee is a function
    match engine_resolve(engine, callee_ty):
        case Function(params, ret):
            # Unify argument types with parameter types
            var i = 0
            while i < arg_types_len(arg_types) and i < params_len(params):
                engine_unify(engine, arg_types[i], params[i])?
                i = i + 1

            Ok(ret)

        case _:
            # Not a function type - return fresh var
            Ok(result_ty)

fn infer_method_call(engine: InferenceEngine, receiver: Expr, method: text,
                     args: [Argument], env: Dict<text, Type>) -> text:
    """Infer type of method call."""
    val receiver_ty = infer_expr(engine, receiver, env)?

    # Infer argument types
    for arg in args:
        val _unused_19 = infer_expr(engine, arg.value, env)?

    # Special handling for .with method (FString template instantiation)
    if method == "with":
        # Validate dict argument matches FString keys
        # If receiver is FString type, check that dict has matching keys
        match receiver_ty:
\\\\\        to: zzoxzqoo 2b48645a "feat: Complete Track A/B/C - Native backend layout optimization and LLVM backend" (rebase destination)
             case Generic(base, key_types) if base == "FString":
                 # Verify dict argument has all required keys
                 if args_len(args) >= 1:
-                    val arg_ty = infer_expr(engine, args[0].value, env)
+                    val arg_ty = infer_expr(engine, args[0].value, env)?
                     # Dict type should be compatible with FString's key set
                     engine.unify(arg_ty, Type.Generic(base: "Dict", args: [Type.Str, Type.Str]))?
            case _:
                ()  # Non-FString .with() - no key validation
        return Ok(Type.Str)

    # General method call - return fresh var
    # Full implementation needs method lookup
    Ok(engine_fresh_var(engine))

# ============================================================================
# Lambdas
# ============================================================================

fn infer_lambda(engine: InferenceEngine, params: [LambdaParam], body: Expr,
                env: Dict<text, Type>) -> text:
    """Infer type of lambda expression."""
    # Create fresh variables for parameters
    var param_types: [Type] = []
    var new_env = env

    for param in params:
        val param_ty = if param.has_ty:
            ast_type_to_inference_type_engine(param.ty_value, engine)
        else:
            engine_fresh_var(engine)

        param_types = param_types_push(param_types, param_ty)
        new_env[param.name] = param_ty

    # Infer body type with extended environment
    val body_ty = infer_expr(engine, body, new_env)?

    # Construct function type
    Ok(type_Function(params: param_types, ret: body_ty))

# ============================================================================
# Control Flow
# ============================================================================

fn infer_if(engine: InferenceEngine, condition: Expr, then_branch: Expr,
            else_branch: Expr, env: Dict<text, Type>) -> text:
    """Infer type of if expression."""
    # Condition must be bool
    val cond_ty = infer_expr(engine, condition, env)?
    engine_unify(engine, cond_ty, Type.Bool)?

    # Infer then branch
    val then_ty = infer_expr(engine, then_branch, env)?

    # If there's an else branch, unify with then
    if has_else_branch:
        val else_ty = infer_expr(engine, else_branch_value, env)?
        engine_unify(engine, then_ty, else_ty)?
        Ok(engine_resolve(engine, then_ty))
    else:
        # No else branch - type is Unit
        Ok(Type.Unit)

fn infer_match(engine: InferenceEngine, subject: Expr, arms: [MatchArm],
               env: Dict<text, Type>) -> text:
    """Infer type of match expression."""
    # Infer subject type
    val subject_ty = infer_expr(engine, subject, env)?

    # Create result type variable
    val result_ty = engine_fresh_var(engine)

    # Check each arm
    for arm in arms:
        # Check pattern against subject type (Phase 3[2] - TODO #173 ✅)
        # Bind pattern variables (Phase 3[2] - TODO #174 ✅)
        # MOVED: use compiler.type_system.stmt_check.{bind_pattern}

        val arm_env = bind_pattern(arm.pattern, subject_ty, env)

        # Infer arm body with extended environment
        val arm_ty = infer_expr(engine, arm.body, arm_env)?

        # Unify with result type
        engine_unify(engine, arm_ty, result_ty)?

    Ok(result_ty)

# ============================================================================
# Collections
# ============================================================================

fn infer_array(engine: InferenceEngine, elements: [Expr],
               env: Dict<text, Type>) -> text:
    """Infer type of array literal."""
    if not has_elements:
        # Empty array - element type unknown
        val elem_ty = engine_fresh_var(engine)
        return Ok(type_Array(elem: elem_ty, size: nil))

    # Infer first element type
    val first_ty = infer_expr(engine, elements[0], env)?

    # Unify all other elements with first
    var i = 1
    while i < elements_len(elements):
        val elem_ty = infer_expr(engine, elements[i], env)?
        engine_unify(engine, first_ty, elem_ty)?
        i = i + 1

    Ok(type_Array(elem: engine.resolve(first_ty), size: nil))

fn infer_tuple(engine: InferenceEngine, elements: [Expr],
               env: Dict<text, Type>) -> text:
    """Infer type of tuple literal."""
    var elem_types: [Type] = []

    for elem in elements:
        val elem_ty = infer_expr(engine, elem, env)
        if elem_ty.is_err():
            return elem_ty
        elem_types = elem_types_push(elem_types, elem_ty)

    Ok(type_Tuple(elements: elem_types))

fn infer_dict(engine: InferenceEngine, pairs: [(Expr, Expr)],
              env: Dict<text, Type>) -> text:
    """Infer type of dictionary literal."""
    if not has_pairs:
        # Empty dict - key and value types unknown
        val key_ty = engine_fresh_var(engine)
        val value_ty = engine_fresh_var(engine)
        return Ok(type_Dict(key: key_ty, value: value_ty))

    # Infer first pair types
    val _destruct_1 = pairs[0]
    val first_key = _destruct_1[0]
    val first_value = _destruct_1[1]
    val key_ty = infer_expr(engine, first_key, env)?
    val value_ty = infer_expr(engine, first_value, env)?

    # Unify all other pairs
    var i = 1
    while i < pairs_len(pairs):
        val _destruct_2 = pairs[i]
        val k = _destruct_2[0]
        val v = _destruct_2[1]
        val k_ty = infer_expr(engine, k, env)?
        val v_ty = infer_expr(engine, v, env)?
        engine_unify(engine, key_ty, k_ty)?
        engine_unify(engine, value_ty, v_ty)?
        i = i + 1

    Ok(type_Dict(key: engine.resolve(key_ty), value: engine_resolve(engine, value_ty)))

# ============================================================================
# Field and Index Access
# ============================================================================

fn infer_field_access(engine: InferenceEngine, receiver: Expr, field: text,
                      env: Dict<text, Type>) -> text:
    """Infer type of field access."""
    val receiver_ty = infer_expr(engine, receiver, env)?

    # Field type lookup needs struct/class definitions
    # For now, return fresh var
    Ok(engine_fresh_var(engine))

fn infer_index_access(engine: InferenceEngine, receiver: Expr, index: Expr,
                      env: Dict<text, Type>) -> text:
    """Infer type of index access."""
    val receiver_ty = infer_expr(engine, receiver, env)?
    val index_ty = infer_expr(engine, index, env)?

    # Index should be Int for arrays
    val unify_index = engine_unify(engine, index_ty, Type.Int(bits: 64, signed: true))
    if unify_index.is_err():
        return unify_index

    # Result type depends on receiver
    match engine_resolve(engine, receiver_ty):
        case Array(elem, _):
            Ok(elem)

        case Str:
            # String indexing returns string
            Ok(Type.Str)

        case Dict(key, value):
            # Dict indexing returns value type
            Ok(value)

        case Tuple(elems):
            # Tuple indexing - return fresh var (need literal index)
            Ok(engine_fresh_var(engine))

        case _:
            # Unknown type - return fresh var
            Ok(engine_fresh_var(engine))

# ============================================================================
# Macros
# ============================================================================

fn infer_macro(engine: InferenceEngine, name: text, args: [MacroArg],
               env: Dict<text, Type>) -> text:
    """Infer type of macro invocation."""
    # Infer argument types
    for arg in args:
        match arg:
            case Expr(e):
                val _unused_20 = infer_expr(engine, e, env)?

    # Macro return type depends on macro definition
    # For now, return fresh var
    Ok(engine_fresh_var(engine))

# ============================================================================
# Exports
# ============================================================================

export infer_expr, infer_binary, infer_unary, infer_call, infer_method_call
export infer_lambda, infer_if, infer_match
export infer_array, infer_tuple, infer_dict
export infer_field_access, infer_index_access, infer_macro
