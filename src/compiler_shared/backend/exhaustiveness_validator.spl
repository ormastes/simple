"""
# Backend Exhaustiveness Validator

Analyzes Rust backend implementations to detect catch-all patterns (`_ =>`)
that may hide unsupported instructions.

**Category:** Testing Infrastructure
**Status:** In Progress

## Overview

This tool reads Rust backend source files and detects `_ =>` catch-all patterns
in match expressions. These catch-alls can hide unsupported MIR instructions,
leading to silent failures or unclear error messages.

## Usage

```simple
val validator = exhaustivenessvalidator_new()
validator.add_file("rust/compiler/src/codegen/llvm/functions.rs")
validator_analyze(validator)
val report = validator_generate_report(validator)
print report
```

## Detection Strategy

1. Parse Rust source files
2. Find match expressions on MirInst
3. Detect `_ =>` catch-all patterns
4. Filter out intentional catch-alls (type matching, etc.)
5. Report problematic patterns with location and severity

## Fix Suggestions

For each catch-all, suggests:
- Listing unsupported instructions explicitly
- Grouping by category (SIMD, GPU, Concurrency)
- Adding clear error messages
"""

use std.text.{NL}

# Location in source file
extern fn rt_file_read_text(path: text) -> text

struct SourceLocation:
    file_path: text
    line_number: i32
    column: i32

    fn to_string() -> text:
        "{self.file_path}:{self.line_number}:{self.column}"

# Severity level for catch-all patterns
enum CatchAllSeverity:
    Error      # Must be fixed - hiding critical instructions
    Warning    # Should be fixed - unclear error handling
    Info       # Intentional - documented reason

# A detected catch-all pattern
class CatchAllPattern:
    location: SourceLocation
    severity: CatchAllSeverity
    context: text           # Surrounding code
    suggestion: text        # How to fix it
    val _as_0 = bool    # Whether it's documented as intentional
    is_intentional: _as_0

    fn get_location() -> SourceLocation:
        self.location

    fn get_severity() -> CatchAllSeverity:
        self.severity

    fn is_error() -> bool:
        match self.severity:
            CatchAllSeverity.Error: true
            case _: false

    fn format_report() -> text:
        val severity_str = match self.severity:
            CatchAllSeverity.Error: "ERROR"
            CatchAllSeverity.Warning: "WARNING"
            CatchAllSeverity.Info: "INFO"

        val intentional_mark = if self.is_intentional:
            " (intentional)"
        else:
            ""

        """
        [{severity_str}] {self.location_to_string(location)}{intentional_mark}

        Context:
        {self.context}

        Suggestion:
        {self.suggestion}
        """

# Analysis result for a single file
class FileAnalysisResult:
    file_path: text
    patterns: [CatchAllPattern]
    error_count: i32
    warning_count: i32
    info_count: i32

    static fn new(path: text) -> FileAnalysisResult:
        FileAnalysisResult(
            file_path: path,
            patterns: [],
            error_count: 0,
            warning_count: 0,
            info_count: 0
        )

    me add_pattern(pattern: CatchAllPattern):
        self.patterns_push(patterns, pattern)

        match pattern_get_severity(pattern):
            CatchAllSeverity.Error:
                self.error_count = self.error_count + 1
            CatchAllSeverity.Warning:
                self.warning_count = self.warning_count + 1
            CatchAllSeverity.Info:
                self.info_count = self.info_count + 1

    fn has_errors() -> bool:
        self.error_count > 0

    fn total_issues() -> i32:
        self.error_count + self.warning_count

    fn format_summary() -> text:
        """
        File: {self.file_path}
        Errors: {self.error_count}, Warnings: {self.warning_count}, Info: {self.info_count}
        Total issues: {self.total_issues()}
        """

# Main validator class
class ExhaustivenessValidator:
    files: [text]
    results: [FileAnalysisResult]
    strict_mode: bool

    static fn new() -> ExhaustivenessValidator:
        ExhaustivenessValidator(
            files: [],
            results: [],
            strict_mode: false
        )

    me set_strict(strict: bool):
        """Enable strict mode: treat warnings as errors"""
        self.strict_mode = strict

    me add_file(path: text):
        """Add a Rust source file to analyze"""
        self.files_push(files, path)

    me add_directory(dir_path: text, pattern: text):
        """
        Add all files matching pattern in directory.
        Example: add_directory("rust/compiler/src/codegen", "*.rs")
        """
        # Would use file system traversal
        # For now, just add known files
        if dir_path == "rust/compiler/src/codegen/llvm":
            self.files.push("rust/compiler/src/codegen/llvm/functions.rs")
            self.files.push("rust/compiler/src/codegen/llvm/backend.rs")
        elif dir_path == "rust/compiler/src/codegen/vulkan":
            self.files.push("rust/compiler/src/codegen/vulkan/spirv_instructions.rs")

    me analyze() -> bool:
        """
        Analyze all added files.
        Returns: true if no errors found (or warnings in strict mode)
        """
        self.results = []
        var all_ok = true

        for file_path in self.files:
            val result = self.analyze_file(file_path)
            self.results_push(results, result)

            if result_has_errors(result):
                all_ok = false
            elif self.strict_mode:
                if result.warning_count > 0:
                all_ok = false

        all_ok

    fn analyze_file(file_path: text) -> FileAnalysisResult:
        """Analyze a single Rust file for catch-all patterns"""
        val result = fileanalysisresult_new(file_path)

        # Read file content
        val content = self.read_file(file_path)

        # Parse and detect patterns
        val patterns = self.detect_catch_alls(file_path, content)

        for pattern in patterns:
            result_add_pattern(result, pattern)

        result

    fn read_file(path: text) -> text:
        """Read file content using FFI."""
        # MOVED TO MODULE LEVEL: extern fn rt_file_read_text(path: text) -> text
        val content = rt_file_read_text(path)
        content ?? ""

    fn detect_catch_alls(file_path: text, content: text) -> [CatchAllPattern]:
        """
        Detect catch-all patterns in Rust code.
        Look for `_ =>` in match expressions.
        """
        val patterns: [CatchAllPattern] = []

        # Split into lines for analysis
        val lines = content.split(NL)
        var line_num = 1

        for line in lines:
            if self.is_catch_all_line(line):
                val pattern = self.analyze_catch_all(
                    file_path,
                    line_num,
                    line,
                    lines
                )
                patterns_push(patterns, pattern)

            line_num = line_num + 1

        patterns

    fn is_catch_all_line(line: text) -> bool:
        """Check if line contains a catch-all pattern"""
        val trimmed = line_trim(line)

        # Look for `_ =>` pattern
        if trimmed.starts_with("_ =>"):
            true
        elif trimmed.contains("_ =>"):
            # Check it's not in a comment
            val before_comment = trimmed.split("//")[0]
            before_comment.contains("_ =>")
        else:
            false

    fn analyze_catch_all(
        file_path: text,
        line_num: i32,
        line: text,
        all_lines: [text]
    ) -> CatchAllPattern:
        """Analyze a specific catch-all pattern"""

        # Extract context (5 lines before and after)
        val context_lines = self.extract_context(all_lines, line_num, 5)
        val context = context_lines.join(NL)

        # Determine if it's intentional
        val is_intentional = self.is_intentional_catch_all(context)

        # Determine severity
        val severity = self.determine_severity(file_path, context, is_intentional)

        # Generate suggestion
        val suggestion = self.generate_suggestion(file_path, context)

        val location = SourceLocation(
            file_path: file_path,
            line_number: line_num,
            column: line.find("_ =>") ?? 0
        )

        CatchAllPattern(
            location: location,
            severity: severity,
            context: context,
            suggestion: suggestion,
            is_intentional: is_intentional
        )

    fn extract_context(lines: [text], center: i32, radius: i32) -> [text]:
        """Extract lines around a center line"""
        val start = (center - radius).max(0)
        val end = (center + radius).min(lines_len(lines))

        lines[start:end]

    fn is_intentional_catch_all(context: text) -> bool:
        """
        Check if catch-all is intentional (documented).
        Look for comments like:
        - "// Intentional catch-all"
        - "// Type matching only"
        - "// Other instructions not yet implemented"
        """
        val lower = context_to_lower(context)

        (lower.contains("intentional") or
        lower.contains("type matching") or
        lower.contains("not yet implemented"))

    fn determine_severity(
        file_path: text,
        context: text,
        is_intentional: bool
    ) -> CatchAllSeverity:
        """
        Determine severity based on context.

        ERROR: In instruction dispatch code, not intentional
        WARNING: In instruction dispatch, intentional but no error message
        INFO: In type matching or other non-critical code
        """

        # Check if it's in instruction dispatch (match on MirInst)
        val is_instruction_dispatch = context.contains("MirInst::")

        if is_instruction_dispatch:
            if is_intentional:
                # Check if it has error handling
                if context.contains("return Err") or context.contains("panic"):
                    CatchAllSeverity.Warning
                else:
                    CatchAllSeverity.Error
            else:
                CatchAllSeverity.Error
        else:
            # Type matching or other non-critical code
            CatchAllSeverity.Info

    fn generate_suggestion(file_path: text, context: text) -> text:
        """Generate a fix suggestion based on context"""

        val is_instruction_dispatch = context.contains("MirInst::")

        if is_instruction_dispatch:
            """
            Replace catch-all with exhaustive listing of unsupported instructions:

            # SIMD instructions (not yet supported)
            MirInst::VecSum { .. } |
            MirInst::VecProduct { .. } |
            MirInst::VecMin { .. } |
            MirInst::VecMax { .. } => {{
                return Err(CompileError::Codegen(format!(
                    "SIMD instruction {{:?}} not supported by this backend. Try LLVM: --backend=llvm",
                    inst
                )));
            }}

            # GPU instructions (not yet supported)
            MirInst::GpuGlobalId {{ .. }} |
            MirInst::GpuBarrier => {{
                return Err(CompileError::Codegen(format!(
                    "GPU instruction {{:?}} not supported by this backend. Try Vulkan: --backend=vulkan",
                    inst
                )));
            }}
            """
        else:
            "Consider replacing catch-all with explicit pattern matching."

    fn generate_report() -> text:
        """Generate a comprehensive report of all findings"""
        var report = "Backend Exhaustiveness Analysis Report" + NL
        report = report + "=" * 60 + NL + NL

        var total_errors = 0
        var total_warnings = 0
        var total_info = 0

        for result in self.results:
            report = report + result.format_summary() + NL

            total_errors = total_errors + result.error_count
            total_warnings = total_warnings + result.warning_count
            total_info = total_info + result.info_count

            if result_total_issues(result) > 0:
                report = report + NL + "Details:" + NL + NL

                for pattern in result.patterns:
                    if pattern_is_error(pattern) or not self.strict_mode:
                        report = report + pattern.format_report() + NL + NL

        # Summary
        report = report + "=" * 60 + NL
        report = report + "Total: {total_errors} errors, {total_warnings} warnings, {total_info} info" + NL

        if total_errors > 0:
            report = report + NL + "⚠️  FAIL: Found {total_errors} critical issues" + NL
        elif total_warnings > 0:
            report = report + NL + "⚠️  WARNING: Found {total_warnings} potential issues" + NL
        else:
            report = report + NL + "✓ PASS: No issues found" + NL

        report

    fn get_error_count() -> i32:
        """Get total error count across all files"""
        var total = 0
        for result in self.results:
            total = total + result.error_count
        total

    fn get_warning_count() -> i32:
        """Get total warning count across all files"""
        var total = 0
        for result in self.results:
            total = total + result.warning_count
        total

# ============================================================================
# CLI Entry Point
# ============================================================================

fn main():
    """Run exhaustiveness validation on backend implementations"""
    print "Backend Exhaustiveness Validator" + NL
    print "Analyzing Rust backend implementations..." + NL

    val validator = exhaustivenessvalidator_new()

    # Add LLVM backend files
    validator.add_file("rust/compiler/src/codegen/llvm/functions.rs")
    validator.add_file("rust/compiler/src/codegen/llvm/backend.rs")

    # Add Vulkan backend files
    validator.add_file("rust/compiler/src/codegen/vulkan/spirv_instructions.rs")

    # Add Cranelift backend files
    validator.add_file("rust/compiler/src/codegen/cranelift.rs")

    # Analyze
    val success = validator_analyze(validator)

    # Generate and print report
    val report = validator_generate_report(validator)
    print report

    # Exit with error code if issues found
    if not success:
        std.sys_exit(sys, 1)
