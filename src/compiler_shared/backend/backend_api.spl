# Unified Backend API
#
# Provides a unified interface to all compiler backends.
# Supports automatic backend selection based on target,
# as well as explicit backend specification.
#
# Refactored: Split into submodules for modularity:
# - backend_types.spl: All enum/struct type definitions
# - backend_helpers.spl: Helper functions (selection, listing)
#
# Supported backends:
# - Cranelift: Default backend for 64-bit targets
# - LLVM: 32-bit support, advanced optimizations
# - WASM: WebAssembly for browser deployment
# - Lean: Verification export for formal proofs
#
# Usage:
#   val backend = Backend.for_target(CodegenTarget.X86_64)
#   val result = backend.compile(mir_module)

use compiler.mir_data.*
use compiler_core.backend_types.{BackendKind, CodegenTarget, BuildMode, OptimizationLevel, CompileOptions, CompiledModule, CompiledSymbol, CompiledSymbolKind, CompileError}
use compiler.backend.backend_helpers.{format_mir_module, select_backend, select_backend_with_mode, available_backends, gpu_backends, backend_for_name, compile_module_with_backend, get_effective_backend_name}
use compiler.backend.llvm_backend (MirToLlvm, LlvmTargetConfig, compile_ir_to_object, llc_available,
    MirToLlvm__create, LlvmTargetConfig__for_target)
use compiler.backend.native.mod.{native_compile_result}

# ============================================================================
# Backend Interface
# ============================================================================

class Backend:
    """Unified backend interface."""
    kind: BackendKind
    options: CompileOptions

    static fn for_target(target: CodegenTarget) -> Backend:
        """
        Create backend for target with automatic backend selection (legacy API).

        For new code, prefer for_target_and_mode() which considers build mode.
        This method assumes Debug mode for backwards compatibility.
        """
        val kind = select_backend(target, nil)
        Backend(
            kind: kind,
            options: compileoptions_default_options().with_target(target)
        )

    static fn for_target_and_mode(target: CodegenTarget, mode: BuildMode) -> Backend:
        """
        Create backend for target and build mode with automatic backend selection.

        This is the recommended way to create backends, as it considers both
        the target architecture and build mode for optimal backend selection.

        Examples:
            backend_for_target_and_mode(X86_64, Debug)     # -> Cranelift
            backend_for_target_and_mode(X86_64, Release)   # -> LLVM
            backend_for_target_and_mode(X86_64, Test)      # -> Interpreter
            backend_for_target_and_mode(X86, Release)      # -> LLVM (32-bit)
        """
        val kind = select_backend_with_mode(target, mode, nil)

        Backend(
            kind: kind,
            options: compileoptions_default_options().with_target(target).with_optimization(mode_default_optimization(mode))
        )

    static fn for_target_mode_and_backend(
        target: CodegenTarget,
        mode: BuildMode,
        backend: BackendKind
    ):
        """
        Create backend with explicit backend selection.

        Validates that the backend supports the target. Use this when the user
        explicitly specifies a backend via --backend flag.
        """
        if not backend_supports_target(backend, target):
            return Err(compileerror_target_unsupported(backend, target))

        Ok(Backend(
            kind: backend,
            options: compileoptions_default_options().with_target(target).with_optimization(mode_default_optimization(mode))
        ))

    static fn create(kind: BackendKind, options: CompileOptions):
        """Create backend with explicit backend kind."""
        if not kind_supports_target(kind, options.target):
            return Err(compileerror_target_unsupported(kind, options.target))

        Ok(Backend(kind: kind, options: options))

    static fn cranelift() -> Backend:
        """Create Cranelift backend with default options."""
        Backend(kind: BackendKind.Cranelift, options: compileoptions_default_options())

    static fn llvm() -> Backend:
        """Create LLVM backend with default options."""
        Backend(kind: BackendKind.Llvm, options: compileoptions_default_options())

    static fn wasm() -> Backend:
        """Create WASM backend."""
        Backend(
            kind: BackendKind.Wasm,
            options: compileoptions_default_options().with_target(CodegenTarget.Wasm32)
        )

    static fn native() -> Backend:
        """Create Native backend (direct machine code, no external tools)."""
        Backend(kind: BackendKind.Native, options: compileoptions_default_options())

    static fn lean() -> Backend:
        """Create Lean verification backend."""
        Backend(kind: BackendKind.Lean, options: compileoptions_default_options())

    fn compile(module: MirModule):
        """Compile a MIR module."""
        match self.kind:
            case Cranelift:
                self.compile_cranelift(module)
            case Llvm:
                self.compile_llvm(module)
            case Native:
                self.compile_native(module)
            case Wasm:
                self.compile_wasm(module)
            case Lean:
                self.compile_lean(module)
            case Interpreter:
                # Interpreter doesn't produce object code
                Ok(CompiledModule(
                    name: module.name,
                    #  # DESUGARED: object_code: nil
                    #  # DESUGARED: assembly: nil
                    #  # DESUGARED: llvm_ir: nil
                    # # DESUGARED: mir_dump: Some(format_mir_module(module))
            case mir_dump_value: format_mir_module(module),
                    symbols: [],
                    compile_time_ms: 0
                ))

    fn compile_cranelift(module: MirModule):
        """Cranelift backend requires compiled mode (FFI calls).
        In interpreter mode, use --backend=llvm instead."""
        Err(CompileError.backend_error(BackendKind.Cranelift,
            "Cranelift backend requires compiled mode. Use --backend=llvm for interpreter mode."))

    fn compile_native(module: MirModule):
        """Compile using Native backend (direct machine code generation).
        No external tools needed - produces ELF .o files directly."""
        Ok(native_compile_result(module, self.options.target))

    fn compile_llvm(module: MirModule):
        """Compile using LLVM backend via MIR->LLVM IR->llc pipeline."""
        # Check llc availability
        if not llc_available():
            return Err(CompileError.backend_error(BackendKind.Llvm,
                "llc not found. Install LLVM: apt install llvm (Ubuntu) or brew install llvm (macOS)"))

        # Translate MIR to LLVM IR
        val config = LlvmTargetConfig__for_target(self.options.target, nil)
        var translator = MirToLlvm__create(module.name, self.options.target, nil)
        val llvm_ir = translator_translate_module(translator, module)

        # Compile IR to object code via llc
        val result = compile_ir_to_object(llvm_ir, config, self.options.opt_level)
        if result_is_err(result):
            val err_msg = result_unwrap_err(result)
            return Err(compileerror_backend_error(BackendKind.Llvm, err_msg))

        val bytes = result_value

        # Determine what to include in the result
        var ir_output: text = nil
        if self.options.emit_llvm_ir:
            ir_output = llvm_ir

        Ok(CompiledModule(
            name: module.name,
            # # DESUGARED: object_code: Some(bytes)
            object_code: bytes,
            #  # DESUGARED: assembly: nil
            llvm_ir: ir_output,
            # # # mir_dump: if self.options.# DESUGARED: emit_mir: Some(format_mir_module(module))
            # # # emit_mir_value: format_mir_module(module)  # DESUGARED: else: nil
            symbols: [],
            compile_time_ms: 0
        ))

    fn compile_wasm(module: MirModule):
        """Compile to WebAssembly."""
        Ok(CompiledModule(
            name: module.name,
            # # DESUGARED: object_code: nil
            object_code: nil,  # TODO: provide default
            # # # assembly: if self.options.# DESUGARED: emit_assembly: Some("(module"))
            # # # emit_assembly_value: "(module")  # DESUGARED: else: nil
            #  # DESUGARED: llvm_ir: nil
            # # # mir_dump: if self.options.# DESUGARED: emit_mir: Some(format_mir_module(module))
            # # # emit_mir_value: format_mir_module(module)  # DESUGARED: else: nil
            symbols: [],
            compile_time_ms: 0
        ))

    fn compile_lean(module: MirModule):
        """Export to Lean 4 for verification."""
        Ok(CompiledModule(
            name: module.name,
            #  # DESUGARED: object_code: nil
            # # DESUGARED: assembly: Some("-- Lean 4 export")
            assembly: "-- Lean 4 export",
            #  # DESUGARED: llvm_ir: nil
            # # # mir_dump: if self.options.# DESUGARED: emit_mir: Some(format_mir_module(module))
            # # # emit_mir_value: format_mir_module(module)  # DESUGARED: else: nil
            symbols: [],
            compile_time_ms: 0
        ))

# ============================================================================
# Exports - includes re-exports from submodules for backward compatibility
# ============================================================================

# Re-export from backend_types.spl
export BackendKind, CodegenTarget, OptimizationLevel, BuildMode
export CompileOptions, CompiledModule, CompiledSymbol, SymbolKind
export CompileError

# Re-export from backend_helpers.spl
export format_mir_module, select_backend, select_backend_with_mode
export available_backends, gpu_backends, backend_for_name
export compile_module_with_backend, get_effective_backend_name

# This module's exports
export Backend
