# Visibility Checker - Warnings for Non-Public Access
#
# Emits W0401 warnings when code accesses private items from other modules.
# This is a non-breaking change: code continues to compile but warns about
# future visibility violations.

use hir_types.{Symbol, SymbolId, SymbolTable}
use lexer.Span

# Warning for accessing a private symbol
struct VisibilityWarning:
    message: text
    symbol_name: text
    accessing_module: text
    defining_module: text
    span: Span
    code: text  # "W0401"


# ============================================================================
# VisibilityWarning Methods (was: impl VisibilityWarning:)
# ============================================================================

# Visibility checker for cross-module access
class VisibilityChecker:
    """Checks visibility and emits warnings for private access.

    Usage:
        val checker = VisibilityChecker.new("current_module.spl")
        val warnings = checker_check_symbol_access(checker, symbol, symbol_table, access_span)
    """
    current_module: text        # Module doing the accessing
    warnings: [VisibilityWarning]

    static fn new(current_module: text) -> VisibilityChecker:
        VisibilityChecker(
            current_module: current_module,
            warnings: []
        )

    fn check_symbol_access(
        symbol: Symbol,
        symbol_module: text,
        access_span: Span
    ) -> has_VisibilityWarning:
        """Check if accessing a symbol from another module is allowed.

        Returns warning if accessing a private symbol from another module.
        Returns nil if access is allowed (public symbol or same module).
        """
        # Same module? Always allowed
        if symbol_module == self.current_module:
            return nil

        # Public symbol? Allowed from any module
        if symbol.is_public:
            return nil

        # Private symbol from another module - emit warning
        VisibilityWarning.new(
            symbol.name,
            self.current_module,
            symbol_module,
            access_span
        )

    me record_warning(warning: VisibilityWarning):
        """Record a visibility warning."""
        self.warnings = self.warnings_push(warnings, warning)

    fn get_warnings() -> [VisibilityWarning]:
        """Get all recorded warnings."""
        self.warnings

    fn warning_count() -> i64:
        """Get count of warnings."""
        self.warnings_len(warnings)

# Integration helper for symbol lookup
fn check_and_warn(
    checker: VisibilityChecker,
    symbol: Symbol,
    symbol_module: text,
    access_span: Span
):
    """Check visibility and record warning if needed.

    This should be called after each symbol lookup that crosses module boundaries.

    Example integration:
        val sym = symbol_table_lookup(symbol_table, name)
        if has_sym:
            val symbol = symbol_table_get(symbol_table, sym_value).unwrap()
            check_and_warn(visibility_checker, symbol, defining_module, current_span)
    """
    val warning = checker_check_symbol_access(checker, symbol, symbol_module, access_span)
    if has_warning:
        checker_record_warning(checker, warning_value)

# Export public API
export VisibilityWarning
export VisibilityChecker
export check_and_warn
