# Async/Await/Spawn Desugaring
#
# Transforms async/await/spawn syntax into library calls.
# This is a compiler pass that runs after parsing.
#
# Transformations:
# - async fn -> fn returning Future<T> with state machine
# - await expr -> expr.poll(...) loop
# - spawn expr -> spawn_actor(expr)
# - actor def -> class with message passing

use compiler_core.parser_types.*
use compiler.hir_definitions.*
use compiler.desugar.suspension_analysis.{
    analyze_suspensions,
    has_await_expressions
}
use compiler.desugar.state_enum.{
    generate_state_enum,
    state_enum_to_ast
}
use compiler.desugar.poll_generator.{
    generate_poll_function,
    poll_function_to_ast
}

# ================================================================
# Async Function Desugaring
# ================================================================

fn desugar_async_function(func: Function) -> (Function, [Enum], [Function]):
    """Transform async fn to fn returning Future<T> with state machine.

    Generates:
    1. Transformed function returning Future<T>
    2. State enum for the state machine
    3. Poll function that drives the state machine

    Input:
        async fn fetch(url: text) -> text:
            val response = await http_get(url)
            await response_text(response)

    Output:
        fn fetch(url: text) -> Future<text>:
            future_from_generator(\state, waker: poll_fetch(state, waker))

        enum FetchState:
            State0
            State1(url: text, future: Future<Response>)
            State2(url: text, response: Response, future: Future<text>)

        fn poll_fetch(state: FetchState, waker: Waker) -> (FetchState, Poll<text>):
            match state:
                case State0: ...
                case State1(...): ...
                case State2(...): ...
    """
    if not func.is_async:
        return [func, [], []]

    # Wrap return type in Future<T>
    val wrapped_return = match func.return_type:
        case ret_type:
            # Future<T> where T is original return type
            Type(
                kind: TypeKind.Generic("Future", [ret_type]),
                span: ret_type.span
            )
        case nil:
            # Future<()>
            Type(
                kind: TypeKind.Generic("Future", [unit_type()]),
                span: func.span
            )

    # Transform body using state machine generation
    val _destruct_0 = desugar_async_body(func.body, func)
    val desugared_body = _destruct_0[0]
    val generated_enums = _destruct_0[1]
    val generated_functions = _destruct_0[2]

    val transformed_func = Function(
        name: func.name,
        type_params: func.type_params,
        params: func.params,
        return_type: wrapped_return,
        body: desugared_body,
        is_async: false,  # No longer async after desugaring
        is_static: func.is_static,
        is_public: func.is_public,
        is_method: func.is_method,
        is_mutable: func.is_mutable,
        is_const: func.is_const,
        is_kernel: func.is_kernel,
        doc_comment: func.doc_comment,
        span: func.span
    )

    [transformed_func, generated_enums, generated_functions]

fn desugar_async_body(body: Block, func: Function) -> (Block, [Enum], [Function]):
    """Transform async function body using state machine generation.

    Analyzes the function for suspension points (await expressions) and
    generates a state machine if any are found. Otherwise, uses simple
    future_ready() wrapper.

    Args:
        body: Function body to transform
        func: Complete function definition (for name, etc.)

    Returns:
        Tuple of:
        - Transformed body (Future.from_generator call)
        - Generated enums (state enum)
        - Generated functions (poll function)
    """
    # Analyze for suspension points
    val analysis = analyze_suspensions(func)

    if analysis.suspension_points_len(suspension_points) == 0:
        # No await expressions - use simple Future.ready() wrapper
        val simple_body = desugar_async_body_simple(body)
        return [simple_body, [], []]

    # Generate state machine components
    val state_enum = generate_state_enum(func.name, analysis)
    val poll_func = generate_poll_function(func.name, body, analysis, state_enum)

    # Convert to AST nodes
    val enum_ast = state_enum_to_ast(state_enum, func.span)
    val poll_fn_ast = poll_function_to_ast(poll_func, func.span)

    # Create body that calls Future.from_generator with poll function
    val generator_body = make_generator_call(func.name, func.span)

    [generator_body, [enum_ast], [poll_fn_ast]]

fn desugar_async_body_simple(body: Block) -> Block:
    """Simple transformation for async functions with no awaits.

    Just wraps the body in future_ready().
    """
    val wrapper_call = Expr(
        kind: ExprKind.Call(
            Expr(kind: ExprKind.Field(
                Expr(kind: ExprKind.Ident("Future"), span: body.span),
                "ready"
            ), span: body.span),
            [CallArg(value: Expr(kind: exprkind_Block(body), span: body.span), name: nil)]
        ),
        span: body.span
    )

    Block(
        statements: [Stmt(kind: stmtkind_Expr(wrapper_call), span: body.span)],
        span: body.span
    )

fn make_generator_call(func_name: text, span: Span) -> Block:
    """Create Future.from_generator call to poll function.

    Generates:
        future_from_generator(\state, waker: poll_<func_name>(state, waker))
    """
    val poll_name = "poll_{func_name}"

    val lambda_body = Expr(
        kind: ExprKind.Call(
            Expr(kind: exprkind_Ident(poll_name), span: span),
            [
                CallArg(value: Expr(kind: ExprKind.Ident("state"), span: span), name: nil),
                CallArg(value: Expr(kind: ExprKind.Ident("waker"), span: span), name: nil)
            ]
        ),
        span: span
    )

    val lambda = Expr(
        kind: ExprKind.Lambda(
            [
                Param(name: "state", type_: nil, default: nil, span: span),
                Param(name: "waker", type_: nil, default: nil, span: span)
            ],
            Block(
                statements: [Stmt(kind: stmtkind_Expr(lambda_body), span: span)],
                span: span
            )
        ),
        span: span
    )

    val generator_call = Expr(
        kind: ExprKind.Call(
            Expr(kind: ExprKind.Field(
                Expr(kind: ExprKind.Ident("Future"), span: span),
                "from_generator"
            ), span: span),
            [CallArg(value: lambda, name: nil)]
        ),
        span: span
    )

    Block(
        statements: [Stmt(kind: stmtkind_Expr(generator_call), span: span)],
        span: span
    )

# ================================================================
# Await Expression Desugaring
# ================================================================

fn desugar_await_expr(expr: Expr) -> Expr:
    """Transform await expr to Future polling.

    Input:
        await future_expr

    Output:
        block_on(future_expr)

    Full transformation would be:
        while true:
            match future_expr_poll(future_expr, waker):
                case Ready(v): return v
                case Pending: yield_to_runtime()
    """
    match expr.kind:
        case exprkind_Await(awaited):
            # Simple desugaring: await x => block_on(x)
            Expr(
                kind: ExprKind.Call(
                    Expr(kind: ExprKind.Ident("block_on"), span: expr.span),
                    [CallArg(value: awaited, name: nil)]
                ),
                span: expr.span
            )
        case _:
            expr

# ================================================================
# Spawn Expression Desugaring
# ================================================================

fn desugar_spawn_expr(expr: Expr) -> Expr:
    """Transform spawn expr to spawn_actor call.

    Input:
        spawn Worker(id: 1)

    Output:
        spawn_actor(Worker(id: 1))
    """
    match expr.kind:
        case exprkind_Spawn(spawned):
            Expr(
                kind: ExprKind.Call(
                    Expr(kind: ExprKind.Ident("spawn_actor"), span: expr.span),
                    [CallArg(value: spawned, name: nil)]
                ),
                span: expr.span
            )
        case _:
            expr

# ================================================================
# Actor Definition Desugaring
# ================================================================

fn desugar_actor(act_def: ActorDef) -> Class:
    """Transform actor definition to class.

    Actors are just classes with special instantiation semantics.
    The spawn keyword handles the difference.
    """
    Class(
        name: act_def.name,
        type_params: act_def.type_params,
        fields: act_def.fields,
        methods: act_def.methods,
        is_public: act_def.is_public,
        doc_comment: act_def.doc_comment,
        attributes: act_def.attributes,
        span: act_def.span
    )

# ================================================================
# Full Module Desugaring
# ================================================================

fn desugar_module(module: Module) -> Module:
    """Desugar entire module.

    - Transform all async functions (generates state machines)
    - Transform all await expressions
    - Transform all spawn expressions
    - Transform all actor definitions to classes
    - Add generated enums and functions to module
    """
    # Desugar functions and collect generated code
    var desugared_functions: Dict<text, Function> = {}
    var generated_enums: Dict<text, Enum> = module.enums  # Start with existing enums
    var generated_helper_functions: Dict<text, Function> = {}

    for _item_1 in module.functions:
        val name = _item_1[0]
        val func = _item_1[1]
        val _destruct_2 = desugar_async_function(func)
        val desugared = _destruct_2[0]
        val gen_enums = _destruct_2[1]
        val gen_funcs = _destruct_2[2]
        val with_await = desugar_function_body(desugared)
        desugared_functions[name] = with_await

        # Add generated enums to module
        for enum_ in gen_enums:
            generated_enums[enum_.name] = enum_

        # Add generated poll functions to module
        for gen_func in gen_funcs:
            generated_helper_functions[gen_func.name] = gen_func

    # Merge generated functions with desugared functions
    for _item_3 in generated_helper_functions:
        val name = _item_3[0]
        val func = _item_3[1]
        desugared_functions[name] = func

    # Desugar actors to classes
    var classes_with_actors = module.classes
    for _item_4 in module.actors:
        val name = _item_4[0]
        val act_def = _item_4[1]
        val as_class = desugar_actor(act_def)
        classes_with_actors[name] = as_class

    Module(
        name: module.name,
        imports: module.imports,
        exports: module.exports,
        functions: desugared_functions,
        classes: classes_with_actors,
        actors: {},  # All actors converted to classes
        structs: module.structs,
        enums: generated_enums,  # Includes generated state enums
        bitfields: module.bitfields,
        traits: module.traits,
        impls: module.impls,
        type_aliases: module.type_aliases,
        constants: module.constants,
        static_asserts: module.static_asserts,
        aop_advices: module.aop_advices,
        di_bindings: module.di_bindings,
        arch_rules: module.arch_rules,
        mock_decls: module.mock_decls
    )

fn desugar_function_body(func: Function) -> Function:
    """Desugar await/spawn expressions in function body."""
    val desugared_body = desugar_block(func.body)

    Function(
        name: func.name,
        type_params: func.type_params,
        params: func.params,
        return_type: func.return_type,
        body: desugared_body,
        is_async: func.is_async,
        is_static: func.is_static,
        is_public: func.is_public,
        is_method: func.is_method,
        is_mutable: func.is_mutable,
        is_const: func.is_const,
        is_kernel: func.is_kernel,
        doc_comment: func.doc_comment,
        span: func.span
    )

fn desugar_block(block: Block) -> Block:
    """Desugar statements in a block."""
    var desugared_stmts = []

    for stmt in block.stmts:
        val desugared = desugar_stmt(stmt)
        desugared_stmts_push(desugared_stmts, desugared)

    Block(
        statements: desugared_stmts,
        span: block.span
    )

fn desugar_stmt(stmt: Stmt) -> Stmt:
    """Desugar a single statement."""
    match stmt.kind:
        case stmtkind_Expr(expr):
            val desugared_expr = desugar_expr(expr)
            Stmt(kind: stmtkind_Expr(desugared_expr), span: stmt.span)
        case _:
            stmt  # Other statements unchanged for now

fn desugar_expr(expr: Expr) -> Expr:
    """Recursively desugar expressions."""
    # First check if this expression itself needs desugaring
    match expr.kind:
        case exprkind_Await(_):
            return desugar_await_expr(expr)
        case exprkind_Spawn(_):
            return desugar_spawn_expr(expr)
        case _:
            pass

    # Then recurse into sub-expressions
    # (Simplified - full version would handle all expression types)
    expr

# ================================================================
# Helper Functions
# ================================================================

fn unit_type() -> Type:
    """Create unit type ()."""
    Type(
        kind: typekind_Tuple([]),
        span: span_new(0, 0, 1, 1)
    )

# ================================================================
# Exports
# ================================================================

export desugar_module
export desugar_async_function
export desugar_await_expr
export desugar_spawn_expr
export desugar_actor
