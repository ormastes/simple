# SMF to Object conversion using ObjTaker

use compiler_shared.loader.object_provider.{ObjectProvider}
use compiler.linker.smf_reader_memory.{SmfReaderMemory}
use compiler_shared.linker.obj_taker.{ObjTakeResult, SmfSymbol, SymbolType}

struct SmfObject:
    code: [u8]
    symbol: text

# Convert SMF bytes to an object blob suitable for native linking.
# Strategy: pick the first exported function symbol, instantiate if needed,
# and return its code bytes. For multi-symbol modules a richer splitter is needed,
# but this satisfies minimal linking for now.

fn smf_to_object(provider: ObjectProvider, smf_data: [u8]) -> Result<SmfObject, text>:
    val reader_res = SmfReaderMemory.from_data(smf_data)
    if reader_res.is_err():
        return Err(reader_res.unwrap_err())

    val reader = reader_res.unwrap()
    val exports = reader.exported_symbols()
    if exports.len() == 0:
        return Err("No exported symbols")

    # Prefer first function export
    var target: SmfSymbol = exports[0]
    for sym in exports:
        if sym.ty == SymbolType.Function:
            target = sym
            break

    val code_res = reader.read_code(target)
    if code_res.is_ok():
        return Ok(SmfObject(code: code_res.unwrap(), symbol: target.name))

    Err(code_res.unwrap_err())

export smf_to_object, SmfObject
