# Escape Analysis
#
# Determines whether objects escape the current function/scope.
# Used for:
# - Stack allocation optimization (non-escaping objects)
# - GC root tracking (escaping objects need roots)
# - Barrier optimization (local objects may skip barriers)
#
# Escape states:
# - NoEscape: Object stays local, can be stack-allocated
# - ArgEscape: Escapes as function argument (may return)
# - GlobalEscape: Escapes to global/heap (definitely GC-managed)

# ============================================================================
# Escape State
# ============================================================================

enum EscapeState:
    """Escape state of an allocation."""
    NoEscape        # Stays local to function
    ArgEscape       # Escapes via function argument
    ReturnEscape    # Escapes via return value
    GlobalEscape    # Escapes to global variable
    FieldEscape     # Stored in escaping object's field
    Unknown         # Cannot determine


# ============================================================================
# EscapeState Methods (was: impl EscapeState:)
# ============================================================================

# ============================================================================
# Allocation Site
# ============================================================================

struct AllocationSite:
    """An allocation in the program."""
    id: i64
    program_point: i64
    type_id: i64
    # # DESUGARED: size_bytes: i64
    has_size_bytes: bool
    size_bytes: i64
    escape_state: EscapeState


# ============================================================================
# AllocationSite Methods (was: impl AllocationSite:)
# ============================================================================

fn allocationsite_create(id: i64, point: i64, type_id: i64) -> AllocationSite:
        AllocationSite(
            id: id,
            program_point: point,
            type_id: type_id,
            #  # DESUGARED: size_bytes: nil
            escape_state: EscapeState.Unknown
        )


# ============================================================================
# Points-To Set
# ============================================================================

class PointsToSet:
    """Set of allocation sites a variable may point to."""
    allocations: [i64]  # Allocation site IDs

    static fn empty() -> PointsToSet:
        PointsToSet(allocations: [])

    static fn singleton(alloc_id: i64) -> PointsToSet:
        PointsToSet(allocations: [alloc_id])

    me add(alloc_id: i64):
        """Add an allocation to the set."""
        if not self.allocations_contains(allocations, alloc_id):
            self.allocations = self.allocations_push(allocations, alloc_id)

    fn union(other: PointsToSet) -> PointsToSet:
        """Union two points-to sets."""
        var result = PointsToSet(allocations: self.allocations)
        for id in other.allocations:
            result_add(result, id)
        result

    fn is_empty() -> bool:
        self.allocations_is_empty(allocations)

    fn contains(alloc_id: i64) -> bool:
        self.allocations_contains(allocations, alloc_id)

    fn all() -> [i64]:
        self.allocations

# ============================================================================
# Escape Analysis
# ============================================================================

class EscapeAnalysis:
    """Performs escape analysis on a function.

    Uses flow-insensitive points-to analysis combined with
    escape state tracking.
    """
    # Allocation sites in the function
    allocations: Dict<i64, AllocationSite>
    next_alloc_id: i64

    # Points-to information (variable -> allocations)
    points_to: Dict<i64, PointsToSet>  # Local ID -> points-to set

    # Field points-to (type, field) -> allocations
    field_points_to: Dict<(i64, i64), PointsToSet>

    # Statistics
    total_allocations: i64
    stack_eligible: i64

    static fn create() -> EscapeAnalysis:
        EscapeAnalysis(
            allocations: {},
            next_alloc_id: 0,
            points_to: {},
            field_points_to: {},
            total_allocations: 0,
            stack_eligible: 0
        )

    me record_allocation(point: i64, type_id: i64, dest_local: i64) -> i64:
        """Record an allocation and return its ID."""
        val id = self.next_alloc_id
        self.next_alloc_id = self.next_alloc_id + 1
        self.total_allocations = self.total_allocations + 1

        val site = allocationsite_create(id, point, type_id)
        self.allocations[id] = site

        # Initialize points-to for destination
        var pts = self.points_to_get(points_to, dest_local) ?? pointstoset_empty()
        pts_add(pts, id)
        self.points_to[dest_local] = pts

        id

    me record_copy(from_local: i64, to_local: i64):
        """Record a copy (to = from)."""
        val from_pts = self.points_to_get(points_to, from_local) ?? pointstoset_empty()
        var to_pts = self.points_to_get(points_to, to_local) ?? pointstoset_empty()
        to_pts = to_pts_union(to_pts, from_pts)
        self.points_to[to_local] = to_pts

    me record_field_store(base_local: i64, field_idx: i64, value_local: i64, type_id: i64):
        """Record a field store (base.field = value)."""
        val value_pts = self.points_to_get(points_to, value_local) ?? pointstoset_empty()
        val base_pts = self.points_to_get(points_to, base_local) ?? pointstoset_empty()

        # Value escapes to field
        for alloc_id in value_pts_all(value_pts):
            self.mark_escape(alloc_id, EscapeState.FieldEscape)

        # Store in field points-to
        val key = [type_id, field_idx]
        var field_pts = self.field_points_to_get(field_points_to, key) ?? pointstoset_empty()
        field_pts = field_pts_union(field_pts, value_pts)
        self.field_points_to[key] = field_pts

    me record_field_load(base_local: i64, field_idx: i64, dest_local: i64, type_id: i64):
        """Record a field load (dest = base.field)."""
        val key = [type_id, field_idx]
        val field_pts = self.field_points_to_get(field_points_to, key) ?? pointstoset_empty()

        var dest_pts = self.points_to_get(points_to, dest_local) ?? pointstoset_empty()
        dest_pts = dest_pts_union(dest_pts, field_pts)
        self.points_to[dest_local] = dest_pts

    me record_return(local: i64):
        """Record a return of a local."""
        val pts = self.points_to_get(points_to, local) ?? pointstoset_empty()
        for alloc_id in pts_all(pts):
            self.mark_escape(alloc_id, EscapeState.ReturnEscape)

    me record_call_arg(local: i64):
        """Record passing a local as a call argument."""
        val pts = self.points_to_get(points_to, local) ?? pointstoset_empty()
        for alloc_id in pts_all(pts):
            self.mark_escape(alloc_id, EscapeState.ArgEscape)

    me record_global_store(local: i64):
        """Record storing a local to a global variable."""
        val pts = self.points_to_get(points_to, local) ?? pointstoset_empty()
        for alloc_id in pts_all(pts):
            self.mark_escape(alloc_id, EscapeState.GlobalEscape)

    me mark_escape(alloc_id: i64, state: EscapeState):
        """Mark an allocation as escaping."""
        match self.allocations_get(allocations, alloc_id):
            case site:
                val new_state = site.escape_state_merge_with(escape_state, state)
                self.allocations[alloc_id] = AllocationSite(
                    id: site.id,
                    program_point: site.program_point,
                    type_id: site.type_id,
                    size_bytes: site.size_bytes,
                    escape_state: new_state
                )
            case nil:

    me finalize():
        """Finalize analysis and compute statistics."""
        # Mark unknown as NoEscape (conservative for unanalyzed)
        for _for_item_0 in self.allocations:
            val id = _for_item_0[0]
            val site = _for_item_0[1]
            if site.escape_state == EscapeState.Unknown:
                self.allocations[id] = AllocationSite(
                    id: site.id,
                    program_point: site.program_point,
                    type_id: site.type_id,
                    size_bytes: site.size_bytes,
                    escape_state: EscapeState.NoEscape
                )

        # Count stack-eligible allocations
        self.stack_eligible = 0
        for _for_item_1 in self.allocations:
            val _unused_1 = _for_item_1[0]
            val site = _for_item_1[1]
            if site.escape_state_can_stack_allocate(escape_state):
                self.stack_eligible = self.stack_eligible + 1

    fn get_escape_state(alloc_id: i64) -> EscapeState:
        """Get escape state for an allocation."""
        match self.allocations_get(allocations, alloc_id):
            case site: site.escape_state
            case nil: EscapeState.Unknown

    fn can_stack_allocate(alloc_id: i64) -> bool:
        """Check if allocation can be stack-allocated."""
        self.get_escape_state(alloc_id).can_stack_allocate()

    fn get_non_escaping() -> [AllocationSite]:
        """Get all non-escaping allocations."""
        var result: [AllocationSite] = []
        for _for_item_2 in self.allocations:
            val _unused_2 = _for_item_2[0]
            val site = _for_item_2[1]
            if not site.escape_state_escapes(escape_state):
                result = result_push(result, site)
        result

    fn get_escaping() -> [AllocationSite]:
        """Get all escaping allocations."""
        var result: [AllocationSite] = []
        for _for_item_3 in self.allocations:
            val _unused_3 = _for_item_3[0]
            val site = _for_item_3[1]
            if site.escape_state_escapes(escape_state):
                result = result_push(result, site)
        result

    fn stack_allocation_ratio() -> f64:
        """Get ratio of stack-eligible allocations."""
        if self.total_allocations == 0:
            0[0]
        else:
            self.stack_eligible_to_f64(stack_eligible) / self.total_allocations_to_f64(total_allocations)

# ============================================================================
# Exports
# ============================================================================

export EscapeState, AllocationSite, PointsToSet
export EscapeAnalysis
