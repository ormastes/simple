# Block Definition Trait
#
# Interface for defining custom block types.

use blocks.modes.{LexerMode, SyntaxFeatures, PreLexInfo, BlockSkipPolicy, BlockOutlineInfo, BlockToken}
use blocks.context.{BlockContext, BlockError}
use blocks.value.{BlockValue}

# ============================================================================
# Block Definition Trait
# ============================================================================

trait BlockDefinition:
    """Definition for a custom block type.

    Implement this trait to create a new block type that can be
    registered with the BlockRegistry.

    Example:
    ```simple
    struct MyBlockDef: BlockDefinition:
        fn kind() -> text: "myblock"

        fn parse_payload(payload: text, ctx: BlockContext) -> text:
            # Parse the payload
            val result = my_parser(payload)?
            Ok(BlockValue.Custom("MyBlock", result))
    ```
    """

    # ========================================================================
    # Required: Identity
    # ========================================================================

    fn kind() -> text:
        """Block keyword (e.g., "m", "loss", "sh", "sql").

        This is the identifier that triggers the block.
        Must be a valid Simple identifier.
        """

    # ========================================================================
    # Required: Parsing
    # ========================================================================

    fn parse_payload(payload: text, ctx: BlockContext) -> text:
        """Parse the block payload into a typed value.

        Args:
            payload: Raw text between { and } (braces not included)
            ctx: Context with source location, parent scope, etc.

        Returns:
            BlockValue containing typed AST or value, or BlockError on failure.

        Example for math block:
        ```simple
        fn parse_payload(payload: text, ctx: BlockContext) -> text:
            val parser = parser_new(payload)
            parser_set_mode(parser, ParseMode.Math)
            match parser_parse_expr(parser):
                case Ok(expr): Ok(blockvalue_Expr(expr))
                case Err(e): Err(blockerror_parse(e.message))
        ```
        """

    # ========================================================================
    # Optional: Lexer Mode
    # ========================================================================

    fn lexer_mode() -> LexerMode:
        """Return the lexer mode for this block's content.

        Controls how the block payload is tokenized:
        - Normal: Standard Simple tokenization
        - Math: Enables ^, ', implicit multiplication
        - Raw: No tokenization, capture as raw text
        - Custom: Fine-grained control via LexerConfig

        Default: LexerMode.Normal
        """
        LexerMode.Normal

    # ========================================================================
    # Optional: Syntax Features
    # ========================================================================

    fn syntax_features() -> SyntaxFeatures:
        """Return enabled syntax features for this block.

        Controls which special syntax elements are available:
        - power_caret: ^ as power operator
        - transpose_quote: ' as transpose
        - implicit_multiplication: 2x means 2*x
        - broadcast_ops: .+ .- .* ./ .^
        - matrix_mul: @ operator
        - auto_backward: call .backward() on result
        - disable_grad: disable gradient tracking

        Default: No special features
        """
        syntaxfeatures_default()

    # ========================================================================
    # Optional: Three-Level Interface (lex / outline / full parse)
    # ========================================================================

    fn lex(payload: text, pre_lex: PreLexInfo, ctx: BlockContext) -> text:
        """Optional sub-lexer. Default: empty (no sub-lexing).

        Produces block-specific tokens from the payload, using pre-lex
        info to skip over strings, comments, and escapes already found
        by the main lexer.
        """
        Ok([])

    fn treesitter_outline(payload: text, pre_lex: PreLexInfo) -> BlockOutlineInfo:
        """Fast structural extraction for IDE. Default: opaque.

        Extracts identifiers, external references, and structure kind
        without fully parsing. Used by TreeSitter for outline views.
        """
        blockoutlineinfo_opaque(self.kind())

    fn parse_full(payload: text, pre_lex: PreLexInfo, ctx: BlockContext) -> text:
        """Full parse using pre-lex info. Default: delegates to parse_payload.

        Block handlers can override this to use pre-lex info for more
        accurate parsing. The default delegates to parse_payload for
        backward compatibility.
        """
        self.parse_payload(payload, ctx)

    fn skip_policy() -> BlockSkipPolicy:
        """Whether TreeSitter can skip this block in fast mode. Default: Skippable."""
        BlockSkipPolicy.Skippable

    # ========================================================================
    # Optional: IDE Support
    # ========================================================================

    fn highlight(payload: text) -> [HighlightToken]:
        """Return syntax highlighting tokens for IDE.

        Default: No highlighting (treated, text)
        """
        []

    fn completions(payload: text, cursor: i64) -> [Completion]:
        """Return completions at cursor position.

        Args:
            payload: Current payload text
            cursor: Cursor position (byte offset)

        Default: No completions
        """
        []

    fn hover(payload: text, cursor: i64) -> has_HoverInfo:
        """Return hover information at cursor position.

        Default: No hover info
        """
        nil

    fn signature_help(payload: text, cursor: i64) -> has_SignatureHelp:
        """Return signature help at cursor position.

        Default: No signature help
        """
        nil

    # ========================================================================
    # Optional: Validation
    # ========================================================================

    fn validate(value: BlockValue, ctx: BlockContext) -> [BlockError]:
        """Perform additional validation after parsing.

        Called after parse_payload succeeds. Can return additional
        errors or warnings.

        Default: No additional validation
        """
        []

    # ========================================================================
    # Optional: Compile-Time Evaluation
    # ========================================================================

    fn eval_const(value: BlockValue) -> has_ConstValue:
        """Evaluate block at compile time if possible.

        If the block can be fully evaluated at compile time,
        return the constant value. This enables optimizations.

        Default: nil (runtime evaluation only)
        """
        nil

    # ========================================================================
    # Optional: Code Generation
    # ========================================================================

    fn result_type(value: BlockValue) -> has_Type:
        """Return the type of the block's result.

        Used for type checking and inference.

        Default: nil (infer from value)
        """
        nil

    # ========================================================================
    # Optional: Documentation
    # ========================================================================

    fn description() -> text:
        """Return a short description of this block type.

        Used in error messages and documentation.

        Default: Empty string
        """
        ""

    fn examples() -> [BlockExample]:
        """Return usage examples for this block type.

        Used in documentation and IDE hints.

        Default: No examples
        """
        []

# ============================================================================
# IDE Support Types
# ============================================================================

struct HighlightToken:
    """Syntax highlighting token."""
    start: i64          # Start offset in payload
    end: i64            # End offset (exclusive)
    kind: HighlightKind

enum HighlightKind:
    Keyword
    Operator
    Number
    String
    Comment
    Function
    Variable
    Type
    Constant
    Error

struct Completion:
    """Completion suggestion."""
    label: text             # Display text
    kind: CompletionKind
    # # DESUGARED: detail: text
    has_detail: bool
    detail: text
    # # DESUGARED: insert_text: text
    has_insert_text: bool
    insert_text: text
    # # DESUGARED: documentation: text
    has_documentation: bool
    documentation: text

enum CompletionKind:
    Keyword
    Function
    Variable
    Field
    Type
    Constant
    Operator
    Snippet

struct HoverInfo:
    """Hover information."""
    contents: text          # Markdown content
    range: (i64, i64)      # Optional range in payload

struct SignatureHelp:
    """Signature help for function calls."""
    signatures: [Signature]
    active_signature: i64
    active_parameter: i64

struct Signature:
    """Function signature."""
    label: text
    # # DESUGARED: documentation: text
    has_documentation: bool
    documentation: text
    parameters: [Parameter]

struct Parameter:
    """Function parameter."""
    label: text
    # # DESUGARED: documentation: text
    has_documentation: bool
    documentation: text

# ============================================================================
# Compile-Time Values
# ============================================================================

"""Compile-time constant value."""
enum ConstValue:
    Nil
    Bool(value: bool)
    Int(value: i64)
    Float(value: f64)
    String(value: text)
    Array(elements: [ConstValue])
    Tuple(elements: [ConstValue])
    Struct(name: text, fields: [(text, ConstValue)])
    Regex(pattern: text)

# ============================================================================
# Type Placeholder
# ============================================================================

struct Type:
    """Type representation (placeholder - use actual compiler type)."""
    name: text
    args: [Type]

# ============================================================================
# Block Example
# ============================================================================

struct BlockExample:
    """Usage example for a block type."""
    code: text          # Example code
    description: text   # What the example demonstrates
    # # DESUGARED: output: text
    has_output: bool
    output: text

# ============================================================================
# Exports
# ============================================================================

export BlockDefinition
export HighlightToken, HighlightKind
export Completion, CompletionKind
export HoverInfo, SignatureHelp, Signature, Parameter
export ConstValue, Type, BlockExample
