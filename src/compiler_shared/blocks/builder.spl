# Block Builder API - Fluent Builder Pattern
#
# Declarative, fluent API for creating custom blocks with features.
# Progressive disclosure: start simple, add features as needed.

use blocks.definition.{BlockDefinition, ConstValue, HighlightToken, Completion, HoverInfo, BlockExample}
use blocks.value.{BlockValue}
use blocks.context.{BlockContext, BlockError}
use blocks.modes.{LexerMode, SyntaxFeatures}

# ============================================================================
# Block Builder
# ============================================================================

struct BlockBuilder:
    """Fluent builder for custom blocks.

    Provides a declarative, chainable API for block configuration:

    Example:
    ```simple
    val sql = BlockBuilder("sql").raw_text()
        .simple_parser(\text: parse_sql(text)).simple_validator(\val: validate_sql(val))
        .build()
    ```

    Features:
    - Fluent method chaining
    - Smart defaults
    - Feature presets (enable_all_math, enable_pipelines)
    - Simple parser/validator signatures
    - IDE support (highlight, completions, hover)
    """

    # Core configuration
    _kind: text
    _mode: LexerMode
    _features: SyntaxFeatures

    # Parser (required)
    _parser: fn(text, BlockContext) -> Option<Result<BlockValue, BlockError>>

    # Optional hooks
    _validator: Option<fn(BlockValue, BlockContext) -> [BlockError]>
    _const_eval: Option<fn(BlockValue) -> ConstValue>

    # IDE support hooks
    _highlighter: fn(text) -> [HighlightToken]
    _completer: fn(text, i64) -> [Completion]
    _hover: fn(text, i64) -> HoverInfo

    # Documentation
    _description: text
    _examples: [BlockExample]


# ============================================================================
# BlockBuilder Methods (was: impl BlockBuilder:)
# ============================================================================

fn blockbuilder_new(kind: text) -> BlockBuilder:
        """Create a new builder for a block type.

        Args:
            kind: Block keyword (e.g., "sql", "json", "tensor")

        Returns:
            Builder with smart defaults
        """
        BlockBuilder(
            _kind: kind,
            _mode: LexerMode.Raw,  # Safest default
            _features: SyntaxFeatures__default(),  # No features by default
            # # DESUGARED: _parser: nil
            _parser: nil,  # TODO: provide default
            #  # DESUGARED: _validator: nil
            #  # DESUGARED: _const_eval: nil
            #  # DESUGARED: _highlighter: nil
            #  # DESUGARED: _completer: nil
            #  # DESUGARED: _hover: nil
            _description: "",
            _examples: []
        )


fn blockbuilder_lexer_mode(self: BlockBuilder, mode: LexerMode) -> BlockBuilder:
        """Set the lexer mode explicitly.

        Args:
            mode: LexerMode (Raw, Math, Normal, or Custom)

        Returns:
            Self for chaining
        """
        self._mode = mode
        self


fn blockbuilder_raw_text(self: BlockBuilder) -> BlockBuilder:
        """Use raw text mode (no tokenization).

        Shortcut for `.lexer_mode(LexerMode.Raw)`.
        Best for DSLs, JSON, SQL, shell commands.

        Returns:
            Self for chaining
        """
        self._mode = LexerMode.Raw
        self


fn blockbuilder_math_mode(self: BlockBuilder) -> BlockBuilder:
        """Use math mode (enable math operators).

        Shortcut for `.lexer_mode(LexerMode.Math)`.
        Enables: ^, ', implicit multiplication.

        Returns:
            Self for chaining
        """
        self._mode = LexerMode.Math
        self


fn blockbuilder_normal_mode(self: BlockBuilder) -> BlockBuilder:
        """Use normal Simple tokenization.

        Shortcut for `.lexer_mode(LexerMode.Normal)`.
        Use for blocks with Simple syntax + custom features.

        Returns:
            Self for chaining
        """
        self._mode = LexerMode.Normal
        self


fn blockbuilder_enable_feature(self: BlockBuilder, name: text) -> BlockBuilder:
        """Enable a syntax feature by name.

        Available features:
        - Math: "power_caret", "transpose_quote", "implicit_multiplication", "broadcast_ops", "matrix_mul"
        - Pipeline: "pipe_forward", "composition"
        - ML: "auto_backward", "disable_grad"

        Args:
            name: Feature name

        Returns:
            Self for chaining
        """
        match name:
            # Math features
            case "power_caret":
                self._features.power_caret = true
            case "transpose_quote":
                self._features.transpose_quote = true
            case "implicit_multiplication":
                self._features.implicit_multiplication = true
            case "broadcast_ops":
                self._features.broadcast_ops = true
            case "matrix_mul":
                self._features.matrix_mul = true

            # ML features
            case "auto_backward":
                self._features.auto_backward = true
            case "disable_grad":
                self._features.disable_grad = true

            # Pipeline features
            case "pipe_forward":
                self._features.pipe_forward = true
            case "composition":
                self._features.composition = true

            case _:
                # Unknown feature - could log warning
                pass

        self


fn blockbuilder_disable_feature(self: BlockBuilder, name: text) -> BlockBuilder:
        """Disable a syntax feature by name.

        Args:
            name: Feature name

        Returns:
            Self for chaining
        """
        match name:
            case "power_caret":
                self._features.power_caret = false
            case "transpose_quote":
                self._features.transpose_quote = false
            case "implicit_multiplication":
                self._features.implicit_multiplication = false
            case "broadcast_ops":
                self._features.broadcast_ops = false
            case "matrix_mul":
                self._features.matrix_mul = false
            case "auto_backward":
                self._features.auto_backward = false
            case "disable_grad":
                self._features.disable_grad = false
            case "pipe_forward":
                self._features.pipe_forward = false
            case "composition":
                self._features.composition = false
            case _:
                pass

        self


fn blockbuilder_enable_all_math(self: BlockBuilder) -> BlockBuilder:
        """Enable all math features at once.

        Enables: power_caret, transpose_quote, implicit_multiplication, broadcast_ops, matrix_mul

        Returns:
            Self for chaining
        """
        self._features = SyntaxFeatures__math()
        self


fn blockbuilder_enable_pipelines(self: BlockBuilder) -> BlockBuilder:
        """Enable all pipeline operators.

        Enables: pipe_forward, composition

        Returns:
            Self for chaining
        """
        self._features.pipe_forward = true
        self._features.composition = true
        self


fn blockbuilder_enable_deep_learning(self: BlockBuilder) -> BlockBuilder:
        """Enable deep learning features.

        Enables: auto_backward (for loss blocks)

        Returns:
            Self for chaining
        """
        self._features.auto_backward = true
        self


fn blockbuilder_simple_parser(self: BlockBuilder, parser_fn: fn(text) -> text) -> BlockBuilder:
        """Set parser with simple signature.

        Args:
            fn: Parser function (text -> text)

        Returns:
            Self for chaining

        Example:
        ```simple.simple_parser(\text:
            parse_json(text)
        )
        ```
        """
        # Wrap simple parser to match full signature
        self._parser = \payload, ctx:
            match parser_fn(payload:
                case Ok(value): Ok(value)
                case Err(message): Err(BlockError__parse(message))
        )
        self


fn blockbuilder_parser(self: BlockBuilder, parser_fn: fn(text, BlockContext) -> text) -> BlockBuilder:
        """Set parser with full signature.

        Args:
            parser_fn: Parser function with full context

        Returns:
            Self for chaining

        Example:
        ```simple.parser(\payload, ctx:
            parse_sql(payload, ctx.file_path)
        )
        ```
        """
        self._parser = parser_fn
        self


fn blockbuilder_simple_validator(self: BlockBuilder, validator_fn: fn(BlockValue) -> [text]) -> BlockBuilder:
        """Set validator with simple signature.

        Args:
            fn: Validator function (BlockValue -> [text])

        Returns:
            Self for chaining

        Example:
        ```simple.simple_validator(\value:
            match value:
                case Sql(query): validate_sql_syntax(query)
                case _: ["Expected SQL query"]
        )
        ```
        """
        # Wrap simple validator to match full signature
        self._validator = \value, ctx:
            val messages = validator_fn(value
            messages_map(messages, \msg: BlockError__validation(msg))
        )
        self


fn blockbuilder_validator(self: BlockBuilder, validator_fn: fn(BlockValue, BlockContext) -> [BlockError]) -> BlockBuilder:
        """Set validator with full signature.

        Args:
            fn: Validator function with full context

        Returns:
            Self for chaining
        """
        self._validator = validator_fn
        self


fn blockbuilder_const_eval(self: BlockBuilder, eval_fn: fn(BlockValue) -> ConstValue?) -> BlockBuilder:
        """Set compile-time evaluation function.

        Args:
            fn: Function to evaluate block at compile time

        Returns:
            Self for chaining

        Example:
        ```simple.const_eval(\value:
            match value:
                case Regex(p): constvalue_String(p.raw)
                case _: nil
        )
        ```
        """
        self._const_eval = eval_fn
        self


fn blockbuilder_highlighter(self: BlockBuilder, highlighter_fn: fn(text) -> [HighlightToken]) -> BlockBuilder:
        """Set syntax highlighting function.

        Args:
            fn: Function to produce highlight tokens

        Returns:
            Self for chaining
        """
        self._highlighter = highlighter_fn
        self


fn blockbuilder_completer(self: BlockBuilder, completer_fn: fn(text, i64) -> [Completion]) -> BlockBuilder:
        """Set completion function.

        Args:
            fn: Function to provide completions at cursor

        Returns:
            Self for chaining
        """
        self._completer = completer_fn
        self


fn blockbuilder_hover_provider(self: BlockBuilder, hover_fn: fn(text, i64) -> HoverInfo?) -> BlockBuilder:
        """Set hover information provider.

        Args:
            fn: Function to provide hover info at cursor

        Returns:
            Self for chaining
        """
        self._hover = hover_fn
        self


fn blockbuilder_doc(self: BlockBuilder, description: text) -> BlockBuilder:
        """Set block description.

        Args:
            description: Human-readable description

        Returns:
            Self for chaining
        """
        self._description = description
        self


fn blockbuilder_example(self: BlockBuilder, code: text, description: text, output: text?) -> BlockBuilder:
        """Add an example.

        Args:
            code: Example code
            description: What it demonstrates
            output: Expected output (optional)

        Returns:
            Self for chaining
        """
        val ex = BlockExample(
            code: code,
            description: description,
            output: output
        )
        self._examples = self._examples_push(_examples, ex)
        self


# ============================================================================
# Implementation: Built Block Definition
# ============================================================================

struct BuiltBlockDef(BlockDefinition):
    """BlockDefinition built from BlockBuilder.

    Implements all methods using captured builder state.
    """

    # Configuration from builder
    _kind: text
    _mode: LexerMode
    _features: SyntaxFeatures

    # Required
    _parser: fn(text, BlockContext) -> text

    # Optional
    _validator: fn(BlockValue, BlockContext) -> [BlockError]
    _const_eval: fn(BlockValue) -> ConstValue
    _highlighter: fn(text) -> [HighlightToken]
    _completer: fn(text, i64) -> [Completion]
    _hover: fn(text, i64) -> HoverInfo

    # Documentation
    _description: text
    _examples: [BlockExample]

    # --- Required Methods ---

    fn kind() -> text:
        self._kind

    fn parse_payload(payload: text, ctx: BlockContext) -> text:
        [self._parser)(payload, ctx]

    # --- Optional Methods ---

    fn lexer_mode() -> LexerMode:
        self._mode

    fn syntax_features() -> SyntaxFeatures:
        self._features

    fn validate(value: BlockValue, ctx: BlockContext) -> [BlockError]:
        match self._validator:
            case validator:
                validator(value, ctx)
            case nil:
                []

    fn eval_const(value: BlockValue) -> has_ConstValue:
        match self._const_eval:
            case eval:
                eval(value)
            case nil:
                nil

    fn highlight(payload: text) -> [HighlightToken]:
        match self._highlighter:
            case highlighter:
                highlighter(payload)
            case nil:
                []

    fn completions(payload: text, cursor: i64) -> [Completion]:
        match self._completer:
            case completer:
                completer(payload, cursor)
            case nil:
                []

    fn hover(payload: text, cursor: i64) -> has_HoverInfo:
        match self._hover:
            case hover_fn:
                hover_fn(payload, cursor)
            case nil:
                nil

    fn description() -> text:
        if self.has__description:
            self._description
        else:
            "Custom block: {self._kind}"

    fn examples() -> [BlockExample]:
        self._examples

# ============================================================================
# Exports
# ============================================================================

export BlockBuilder
