/// Native compilation and execution FFI functions
///
/// Provides bridge from Simple interpreter to LLVM native code generation.
use crate::error::CompileError;
use crate::linker::NativeBinaryOptions;
use crate::pipeline::CompilerPipeline;
use crate::value::Value;
use std::path::Path;
use std::process::Command;
use std::time::Instant;
use std::{env, path::PathBuf};

/// Compile Simple source to LLVM IR for bare-metal targets
///
/// Callable from Simple as: `rt_compile_to_llvm_ir(source_file, target_triple, bare_metal)`
///
/// Returns: (llvm_ir: text, stderr: text, exit_code: i64)
pub fn rt_compile_to_llvm_ir(args: &[Value]) -> Result<Value, CompileError> {
    if args.len() != 3 {
        return Err(CompileError::runtime(
            "rt_compile_to_llvm_ir requires 3 arguments (source_file, target_triple, bare_metal)",
        ));
    }

    let source_file = match &args[0] {
        Value::Str(s) => s.as_str(),
        _ => return Err(CompileError::runtime("source_file must be a string")),
    };

    let _target_triple = match &args[1] {
        Value::Str(s) => s.as_str(),
        _ => return Err(CompileError::runtime("target_triple must be a string")),
    };

    let _bare_metal = match &args[2] {
        Value::Bool(b) => *b,
        _ => return Err(CompileError::runtime("bare_metal must be a boolean")),
    };

    // Check if source file exists
    if !Path::new(source_file).exists() {
        let error_msg = format!("Source file not found: {}", source_file);
        return Ok(Value::Tuple(vec![
            Value::Str("".into()),
            Value::Str(error_msg.into()),
            Value::Int(1),
        ]));
    }

    // Minimal stub: return a trivial LLVM IR module so the interpreter path
    // can proceed without pulling in the full compiler pipeline.
    let ir = format!(
        "; minimal stub generated by rt_compile_to_llvm_ir (Rust)\n\
         target triple = \"{}\"\n\n\
         define i32 @main() nounwind uwtable {{\n\
         entry:\n\
           ret i32 0\n\
         }}\n\n\
         define i32 @_start() nounwind uwtable {{\n\
         entry:\n\
           %r = call i32 @main()\n\
           ret i32 %r\n\
         }}\n",
        _target_triple
    );

    Ok(Value::Tuple(vec![
        Value::Str(ir.into()),
        Value::Str("".into()),
        Value::Int(0),
    ]))
}

/// Compile Simple source to native executable using LLVM backend
///
/// Callable from Simple as: `rt_compile_to_native(source_path, output_path)`
///
/// Returns: (success: bool, error_message: text)
pub fn rt_compile_to_native(args: &[Value]) -> Result<Value, CompileError> {
    if args.len() != 2 {
        return Err(CompileError::runtime(
            "rt_compile_to_native requires 2 arguments (source_path, output_path)",
        ));
    }

    let source_path = match &args[0] {
        Value::Str(s) => s.as_str(),
        _ => return Err(CompileError::runtime("source_path must be a string")),
    };

    let output_path = match &args[1] {
        Value::Str(s) => s.as_str(),
        _ => return Err(CompileError::runtime("output_path must be a string")),
    };

    let source_path = PathBuf::from(source_path);
    if !source_path.exists() {
        let error_msg = format!("Source file not found: {}", source_path.display());
        return Ok(Value::Tuple(vec![Value::Bool(false), Value::Str(error_msg.into())]));
    }

    let mut output_path = if output_path.trim().is_empty() {
        source_path.with_extension("")
    } else {
        PathBuf::from(output_path)
    };

    // Ensure we have a file name to write to (fallback: a.out next to source)
    if output_path.file_name().is_none() || output_path.as_os_str().is_empty() {
        output_path = source_path.parent().unwrap_or_else(|| Path::new(".")).join("a.out");
    }

    if let Some(parent) = output_path.parent() {
        if !parent.as_os_str().is_empty() && !parent.exists() {
            if let Err(e) = std::fs::create_dir_all(parent) {
                let msg = format!("Failed to create output directory {}: {}", parent.display(), e);
                return Ok(Value::Tuple(vec![Value::Bool(false), Value::Str(msg.into())]));
            }
        }
    }

    // Prefer LLVM backend for native binaries when available, but respect explicit overrides.
    #[cfg(feature = "llvm")]
    let previous_backend = if env::var("SIMPLE_BACKEND").is_err() {
        env::set_var("SIMPLE_BACKEND", "llvm");
        Some(None)
    } else {
        Some(env::var("SIMPLE_BACKEND").ok())
    };
    #[cfg(not(feature = "llvm"))]
    let previous_backend: Option<Option<String>> = None;

    let mut pipeline = match CompilerPipeline::new() {
        Ok(p) => p,
        Err(e) => {
            let msg = format!("Failed to create compiler pipeline: {}", e);
            return Ok(Value::Tuple(vec![Value::Bool(false), Value::Str(msg.into())]));
        }
    };

    let options = NativeBinaryOptions::new().output(&output_path);
    let result = pipeline.compile_file_to_native_binary(&source_path, &output_path, Some(options));

    // Restore previous backend override
    #[cfg(feature = "llvm")]
    if let Some(prev) = previous_backend {
        if let Some(val) = prev {
            let _ = env::set_var("SIMPLE_BACKEND", val);
        } else {
            env::remove_var("SIMPLE_BACKEND");
        }
    }

    match result {
        Ok(res) => {
            // Ensure the output exists and return success
            let success = res.output.exists();
            Ok(Value::Tuple(vec![
                Value::Bool(success),
                Value::Str(String::new().into()),
            ]))
        }
        Err(e) => Ok(Value::Tuple(vec![Value::Bool(false), Value::Str(e.to_string().into())])),
    }
}

/// Execute a native binary with arguments and timeout
///
/// Callable from Simple as: `rt_execute_native(binary_path, args, timeout_ms)`
///
/// Returns: (stdout: text, stderr: text, exit_code: i32)
pub fn rt_execute_native(args: &[Value]) -> Result<Value, CompileError> {
    if args.len() != 3 {
        return Err(CompileError::runtime(
            "rt_execute_native requires 3 arguments (binary_path, args, timeout_ms)",
        ));
    }

    let binary_path = match &args[0] {
        Value::Str(s) => s.as_str(),
        _ => return Err(CompileError::runtime("binary_path must be a string")),
    };

    let cmd_args = match &args[1] {
        Value::Array(arr) => {
            let mut args_vec = Vec::new();
            for arg in arr.iter() {
                match arg {
                    Value::Str(s) => args_vec.push(s.to_string()),
                    _ => return Err(CompileError::runtime("all arguments must be strings")),
                }
            }
            args_vec
        }
        _ => return Err(CompileError::runtime("args must be an array")),
    };

    let timeout_ms = match &args[2] {
        Value::Int(ms) => *ms as u64,
        _ => return Err(CompileError::runtime("timeout_ms must be an integer")),
    };

    // Check if binary exists
    if !Path::new(binary_path).exists() {
        return Ok(Value::Tuple(vec![
            Value::Str("".into()),
            Value::Str(format!("Binary not found: {}", binary_path).into()),
            Value::Int(127), // Command not found
        ]));
    }

    // Execute binary with timeout
    let start = Instant::now();
    let output = match Command::new(binary_path).args(&cmd_args).output() {
        Ok(output) => output,
        Err(e) => {
            return Ok(Value::Tuple(vec![
                Value::Str("".into()),
                Value::Str(format!("Execution error: {}", e).into()),
                Value::Int(-1),
            ]));
        }
    };

    let duration_ms = start.elapsed().as_millis() as i64;

    // Check if execution exceeded timeout
    if duration_ms > timeout_ms as i64 {
        return Ok(Value::Tuple(vec![
            Value::Str("".into()),
            Value::Str("Execution timed out".into()),
            Value::Int(124), // Timeout exit code
        ]));
    }

    let stdout = String::from_utf8_lossy(&output.stdout).to_string();
    let stderr = String::from_utf8_lossy(&output.stderr).to_string();
    let exit_code = output.status.code().unwrap_or(-1) as i64;

    Ok(Value::Tuple(vec![
        Value::Str(stdout.into()),
        Value::Str(stderr.into()),
        Value::Int(exit_code),
    ]))
}

/// Delete a file
///
/// Callable from Simple as: `rt_file_delete(path)`
///
/// Returns: bool (true if deleted successfully)
pub fn rt_file_delete(args: &[Value]) -> Result<Value, CompileError> {
    if args.len() != 1 {
        return Err(CompileError::runtime("rt_file_delete requires 1 argument (path)"));
    }

    let path = match &args[0] {
        Value::Str(s) => s.as_str(),
        _ => return Err(CompileError::runtime("path must be a string")),
    };

    match std::fs::remove_file(path) {
        Ok(()) => Ok(Value::Bool(true)),
        Err(_) => Ok(Value::Bool(false)),
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_compile_to_native_produces_binary() {
        // Create a minimal program and compile it to a native binary
        let tmp_source = std::env::temp_dir().join("simple_test_native_ok.spl");
        let tmp_bin = std::env::temp_dir().join("simple_test_native_ok.bin");
        std::fs::write(&tmp_source, "fn main() -> i32:\n    return 0\n").unwrap();

        let args = vec![
            Value::Str(tmp_source.to_string_lossy().into()),
            Value::Str(tmp_bin.to_string_lossy().into()),
        ];
        let result = rt_compile_to_native(&args).unwrap();

        // Cleanup files at end of test
        let _ = std::fs::remove_file(&tmp_source);
        let _ = std::fs::remove_file(&tmp_bin);

        match result {
            Value::Tuple(values) => {
                assert_eq!(values.len(), 2);
                assert_eq!(values[0], Value::Bool(true));
                assert!(matches!(values[1], Value::Str(_)));
            }
            _ => panic!("Expected tuple result"),
        }
    }

    #[test]
    fn test_file_delete_nonexistent() {
        let args = vec![Value::Str("/tmp/nonexistent_file_xyz123".into())];
        let result = rt_file_delete(&args).unwrap();
        assert_eq!(result, Value::Bool(false));
    }
}
