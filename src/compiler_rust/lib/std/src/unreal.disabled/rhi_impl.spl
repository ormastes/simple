# Unreal RHI Implementation Extension
# Part 2 of rhi module: RHITexture, RHIBuffer, ShaderType, RHIShader, RHI views,
# RHICommandList, VulkanDevice/VulkanTexture/VulkanBuffer, resource creation functions,
# and FFI declarations.

use sys.ffi

mod rhi

# RHITexture
# GPU texture resource
pub struct RHITexture:
    texture_ptr: ffi.VoidPtr

impl RHITexture:
    pub fn from_ptr(ptr: ffi.VoidPtr) -> RHITexture:
        return RHITexture(texture_ptr: ptr)

    # Get texture dimensions
    pub fn get_size(self) -> (i32, i32, i32):
        val width = ffi.alloc_i32()
        val height = ffi.alloc_i32()
        val depth = ffi.alloc_i32()

        unreal_rhi_texture_get_size(self.texture_ptr, width, height, depth)

        val result = (ffi.read_i32(width), ffi.read_i32(height), ffi.read_i32(depth))

        ffi.free(width)
        ffi.free(height)
        ffi.free(depth)

        return result

    # Get pixel format
    pub fn get_format(self) -> PixelFormat:
        val format = unreal_rhi_texture_get_format(self.texture_ptr)
        # Map i32 back to enum (simplified)
        if format == 1:
            return PixelFormat.R8G8B8A8_UNORM
        elif format == 2:
            return PixelFormat.B8G8R8A8_UNORM
        else:
            return PixelFormat.Unknown

    # Get mip count
    pub fn get_num_mips(self) -> i32:
        return unreal_rhi_texture_get_num_mips(self.texture_ptr)

    # Update texture data
    pub fn update_texture_2d(mut self, mip_level: i32, data: ffi.VoidPtr, data_size: i32):
        unreal_rhi_update_texture_2d(self.texture_ptr, mip_level, data, data_size)

    # Get native pointer
    pub fn as_ptr(self) -> ffi.VoidPtr:
        return self.texture_ptr


# RHIBuffer
# GPU buffer resource
pub struct RHIBuffer:
    buffer_ptr: ffi.VoidPtr

impl RHIBuffer:
    pub fn from_ptr(ptr: ffi.VoidPtr) -> RHIBuffer:
        return RHIBuffer(buffer_ptr: ptr)

    # Get buffer size
    pub fn get_size(self) -> i32:
        return unreal_rhi_buffer_get_size(self.buffer_ptr)

    # Update buffer data
    pub fn update_buffer(mut self, data: ffi.VoidPtr, data_size: i32, offset: i32 = 0):
        unreal_rhi_update_buffer(self.buffer_ptr, data, data_size, offset)

    # Lock buffer for CPU access
    pub fn lock_buffer(mut self, offset: i32, size: i32) -> ffi.VoidPtr:
        return unreal_rhi_lock_buffer(self.buffer_ptr, offset, size)

    # Unlock buffer
    pub fn unlock_buffer(mut self):
        unreal_rhi_unlock_buffer(self.buffer_ptr)

    # Get native pointer
    pub fn as_ptr(self) -> ffi.VoidPtr:
        return self.buffer_ptr


# ShaderType
# Shader stage types
pub enum ShaderType:
    Vertex = 0
    Pixel = 1
    Geometry = 2
    Compute = 3
    Hull = 4
    Domain = 5

impl ShaderType:
    pub fn to_int(self) -> i32:
        if self == ShaderType.Vertex:
            return 0
        elif self == ShaderType.Pixel:
            return 1
        elif self == ShaderType.Geometry:
            return 2
        elif self == ShaderType.Compute:
            return 3
        elif self == ShaderType.Hull:
            return 4
        else:
            return 5

    pub fn to_string(self) -> text:
        """Convert shader type to string."""
        match self:
            case Vertex: "Vertex"
            case Pixel: "Pixel"
            case Geometry: "Geometry"
            case Compute: "Compute"
            case Hull: "Hull"
            case Domain: "Domain"

    pub fn description(self) -> text:
        """Get shader type description."""
        match self:
            case Vertex: "Vertex shader (processes vertices)"
            case Pixel: "Pixel/Fragment shader (processes pixels)"
            case Geometry: "Geometry shader (generates primitives)"
            case Compute: "Compute shader (general GPU computation)"
            case Hull: "Hull/Tessellation control shader"
            case Domain: "Domain/Tessellation evaluation shader"

    pub fn is_vertex(self) -> bool:
        """Check if shader type is Vertex."""
        match self:
            case Vertex: true
            case _: false

    pub fn is_pixel(self) -> bool:
        """Check if shader type is Pixel."""
        match self:
            case Pixel: true
            case _: false

    pub fn is_geometry(self) -> bool:
        """Check if shader type is Geometry."""
        match self:
            case Geometry: true
            case _: false

    pub fn is_compute(self) -> bool:
        """Check if shader type is Compute."""
        match self:
            case Compute: true
            case _: false

    pub fn is_hull(self) -> bool:
        """Check if shader type is Hull."""
        match self:
            case Hull: true
            case _: false

    pub fn is_domain(self) -> bool:
        """Check if shader type is Domain."""
        match self:
            case Domain: true
            case _: false

    pub fn is_graphics_stage(self) -> bool:
        """Check if shader is a graphics pipeline stage."""
        match self:
            case Vertex: true
            case Pixel: true
            case Geometry: true
            case Hull: true
            case Domain: true
            case _: false

    pub fn is_tessellation_stage(self) -> bool:
        """Check if shader is a tessellation stage."""
        match self:
            case Hull: true
            case Domain: true
            case _: false

    pub fn is_rasterization_stage(self) -> bool:
        """Check if shader participates in rasterization."""
        match self:
            case Vertex: true
            case Geometry: true
            case Pixel: true
            case _: false

    pub fn summary(self) -> text:
        """Get comprehensive shader type summary."""
        val name = self.to_string()
        val desc = self.description()
        var props = []
        if self.is_graphics_stage():
            props.push("graphics")
        if self.is_compute():
            props.push("compute")
        if self.is_tessellation_stage():
            props.push("tessellation")
        if self.is_rasterization_stage():
            props.push("rasterization")
        if props.len() > 0:
            val props_str = ", ".join(props)
            return "ShaderType: {name} ({desc}, {props_str})"
        else:
            return "ShaderType: {name} ({desc})"

# RHIShader
# Compiled shader
pub struct RHIShader:
    shader_ptr: ffi.VoidPtr
    shader_type: ShaderType

impl RHIShader:
    pub fn from_ptr(ptr: ffi.VoidPtr, shader_type: ShaderType) -> RHIShader:
        return RHIShader(shader_ptr: ptr, shader_type: shader_type)

    pub fn get_type(self) -> ShaderType:
        return self.shader_type

    pub fn as_ptr(self) -> ffi.VoidPtr:
        return self.shader_ptr


# RHIRenderTargetView
# Render target view
pub struct RHIRenderTargetView:
    rtv_ptr: ffi.VoidPtr

impl RHIRenderTargetView:
    pub fn from_ptr(ptr: ffi.VoidPtr) -> RHIRenderTargetView:
        return RHIRenderTargetView(rtv_ptr: ptr)

    pub fn as_ptr(self) -> ffi.VoidPtr:
        return self.rtv_ptr


# RHIDepthStencilView
# Depth stencil view
pub struct RHIDepthStencilView:
    dsv_ptr: ffi.VoidPtr

impl RHIDepthStencilView:
    pub fn from_ptr(ptr: ffi.VoidPtr) -> RHIDepthStencilView:
        return RHIDepthStencilView(dsv_ptr: ptr)

    pub fn as_ptr(self) -> ffi.VoidPtr:
        return self.dsv_ptr


# RHICommandList
# Command list for recording rendering commands
pub struct RHICommandList:
    cmd_list_ptr: ffi.VoidPtr

impl RHICommandList:
    pub fn from_ptr(ptr: ffi.VoidPtr) -> RHICommandList:
        return RHICommandList(cmd_list_ptr: ptr)

    # Clear render target
    pub fn clear_render_target(mut self, rtv: RHIRenderTargetView, r: f32, g: f32, b: f32, a: f32):
        unreal_rhi_clear_render_target(self.cmd_list_ptr, rtv.as_ptr(), r, g, b, a)

    # Clear depth stencil
    pub fn clear_depth_stencil(mut self, dsv: RHIDepthStencilView, depth: f32, stencil: i32):
        unreal_rhi_clear_depth_stencil(self.cmd_list_ptr, dsv.as_ptr(), depth, stencil)

    # Set render targets
    pub fn set_render_targets(mut self, rtvs: Vec<RHIRenderTargetView>, dsv: Option<RHIDepthStencilView>):
        val num_rtvs = rtvs.len()
        val rtv_array = ffi.alloc_array_ptr(num_rtvs)

        for i in 0..num_rtvs:
            ffi.write_array_ptr(rtv_array, i, rtvs[i].as_ptr())

        val dsv_ptr = if dsv.is_some():
            dsv.unwrap().as_ptr()
        else:
            ffi.null_ptr()

        unreal_rhi_set_render_targets(self.cmd_list_ptr, num_rtvs as i32, rtv_array, dsv_ptr)
        ffi.free(rtv_array)

    # Set viewport
    pub fn set_viewport(mut self, x: f32, y: f32, width: f32, height: f32, min_depth: f32 = 0.0, max_depth: f32 = 1.0):
        unreal_rhi_set_viewport(self.cmd_list_ptr, x, y, width, height, min_depth, max_depth)

    # Set scissor rect
    pub fn set_scissor_rect(mut self, x: i32, y: i32, width: i32, height: i32):
        unreal_rhi_set_scissor_rect(self.cmd_list_ptr, x, y, width, height)

    # Draw primitives
    pub fn draw_primitive(mut self, vertex_count: i32, instance_count: i32 = 1, start_vertex: i32 = 0, start_instance: i32 = 0):
        unreal_rhi_draw_primitive(self.cmd_list_ptr, vertex_count, instance_count, start_vertex, start_instance)

    # Draw indexed primitives
    pub fn draw_indexed_primitive(mut self, index_count: i32, instance_count: i32 = 1, start_index: i32 = 0, base_vertex: i32 = 0, start_instance: i32 = 0):
        unreal_rhi_draw_indexed_primitive(self.cmd_list_ptr, index_count, instance_count, start_index, base_vertex, start_instance)

    # Submit command list
    pub fn submit(mut self):
        unreal_rhi_submit_command_list(self.cmd_list_ptr)

    pub fn as_ptr(self) -> ffi.VoidPtr:
        return self.cmd_list_ptr


# Vulkan-specific backend access

# VulkanDevice
# Access to Vulkan device
pub struct VulkanDevice:
    device_ptr: ffi.VoidPtr

impl VulkanDevice:
    pub fn get_instance() -> VulkanDevice:
        val ptr = unreal_vulkan_get_device()
        return VulkanDevice(device_ptr: ptr)

    # Get native VkDevice handle
    pub fn get_vk_device(self) -> ffi.VoidPtr:
        return unreal_vulkan_get_vk_device(self.device_ptr)

    # Get native VkPhysicalDevice handle
    pub fn get_vk_physical_device(self) -> ffi.VoidPtr:
        return unreal_vulkan_get_vk_physical_device(self.device_ptr)

    # Get native VkInstance handle
    pub fn get_vk_instance(self) -> ffi.VoidPtr:
        return unreal_vulkan_get_vk_instance(self.device_ptr)

    # Get graphics queue
    pub fn get_graphics_queue(self) -> ffi.VoidPtr:
        return unreal_vulkan_get_graphics_queue(self.device_ptr)

    # Get compute queue
    pub fn get_compute_queue(self) -> ffi.VoidPtr:
        return unreal_vulkan_get_compute_queue(self.device_ptr)

    # Get transfer queue
    pub fn get_transfer_queue(self) -> ffi.VoidPtr:
        return unreal_vulkan_get_transfer_queue(self.device_ptr)


# VulkanTexture
# Vulkan-specific texture access
pub struct VulkanTexture:
    base: RHITexture

impl VulkanTexture:
    pub fn from_rhi_texture(texture: RHITexture) -> VulkanTexture:
        return VulkanTexture(base: texture)

    # Get native VkImage handle
    pub fn get_vk_image(self) -> ffi.VoidPtr:
        return unreal_vulkan_texture_get_vk_image(self.base.as_ptr())

    # Get native VkImageView handle
    pub fn get_vk_image_view(self) -> ffi.VoidPtr:
        return unreal_vulkan_texture_get_vk_image_view(self.base.as_ptr())

    # Get VkFormat
    pub fn get_vk_format(self) -> i32:
        return unreal_vulkan_texture_get_vk_format(self.base.as_ptr())


# VulkanBuffer
# Vulkan-specific buffer access
pub struct VulkanBuffer:
    base: RHIBuffer

impl VulkanBuffer:
    pub fn from_rhi_buffer(buffer: RHIBuffer) -> VulkanBuffer:
        return VulkanBuffer(base: buffer)

    # Get native VkBuffer handle
    pub fn get_vk_buffer(self) -> ffi.VoidPtr:
        return unreal_vulkan_buffer_get_vk_buffer(self.base.as_ptr())

    # Get VkDeviceMemory handle
    pub fn get_vk_device_memory(self) -> ffi.VoidPtr:
        return unreal_vulkan_buffer_get_vk_device_memory(self.base.as_ptr())


# Resource creation functions

# Create 2D texture
pub fn create_texture_2d(width: i32, height: i32, format: PixelFormat, usage: TextureUsage, num_mips: i32 = 1) -> RHITexture:
    val ptr = unreal_rhi_create_texture_2d(width, height, format.to_int(), usage.to_int(), num_mips)
    return RHITexture.from_ptr(ptr)

# Create render target
pub fn create_render_target(width: i32, height: i32, format: PixelFormat) -> RHITexture:
    val usage_flags = TextureUsage.RenderTargetable.to_int() | TextureUsage.ShaderResource.to_int()
    val ptr = unreal_rhi_create_texture_2d(width, height, format.to_int(), usage_flags, 1)
    return RHITexture.from_ptr(ptr)

# Create depth stencil target
pub fn create_depth_stencil_target(width: i32, height: i32) -> RHITexture:
    val format = PixelFormat.D24_UNORM_S8_UINT
    val usage_flags = TextureUsage.DepthStencil.to_int() | TextureUsage.ShaderResource.to_int()
    val ptr = unreal_rhi_create_texture_2d(width, height, format.to_int(), usage_flags, 1)
    return RHITexture.from_ptr(ptr)

# Create vertex buffer
pub fn create_vertex_buffer(size: i32, data: ffi.VoidPtr = ffi.null_ptr()) -> RHIBuffer:
    val ptr = unreal_rhi_create_vertex_buffer(size, data)
    return RHIBuffer.from_ptr(ptr)

# Create index buffer
pub fn create_index_buffer(size: i32, data: ffi.VoidPtr = ffi.null_ptr()) -> RHIBuffer:
    val ptr = unreal_rhi_create_index_buffer(size, data)
    return RHIBuffer.from_ptr(ptr)

# Create uniform buffer
pub fn create_uniform_buffer(size: i32, data: ffi.VoidPtr = ffi.null_ptr()) -> RHIBuffer:
    val ptr = unreal_rhi_create_uniform_buffer(size, data)
    return RHIBuffer.from_ptr(ptr)

# Get immediate command list for quick commands
pub fn get_immediate_command_list() -> RHICommandList:
    val ptr = unreal_rhi_get_immediate_command_list()
    return RHICommandList.from_ptr(ptr)


# FFI function declarations

extern "C":
    # Texture functions
    fn unreal_rhi_create_texture_2d(width: i32, height: i32, format: i32, usage: i32, num_mips: i32) -> ffi.VoidPtr
    fn unreal_rhi_texture_get_size(texture: ffi.VoidPtr, width: ffi.VoidPtr, height: ffi.VoidPtr, depth: ffi.VoidPtr)
    fn unreal_rhi_texture_get_format(texture: ffi.VoidPtr) -> i32
    fn unreal_rhi_texture_get_num_mips(texture: ffi.VoidPtr) -> i32
    fn unreal_rhi_update_texture_2d(texture: ffi.VoidPtr, mip_level: i32, data: ffi.VoidPtr, data_size: i32)

    # Buffer functions
    fn unreal_rhi_create_vertex_buffer(size: i32, data: ffi.VoidPtr) -> ffi.VoidPtr
    fn unreal_rhi_create_index_buffer(size: i32, data: ffi.VoidPtr) -> ffi.VoidPtr
    fn unreal_rhi_create_uniform_buffer(size: i32, data: ffi.VoidPtr) -> ffi.VoidPtr
    fn unreal_rhi_buffer_get_size(buffer: ffi.VoidPtr) -> i32
    fn unreal_rhi_update_buffer(buffer: ffi.VoidPtr, data: ffi.VoidPtr, data_size: i32, offset: i32)
    fn unreal_rhi_lock_buffer(buffer: ffi.VoidPtr, offset: i32, size: i32) -> ffi.VoidPtr
    fn unreal_rhi_unlock_buffer(buffer: ffi.VoidPtr)

    # Command list functions
    fn unreal_rhi_get_immediate_command_list() -> ffi.VoidPtr
    fn unreal_rhi_clear_render_target(cmd_list: ffi.VoidPtr, rtv: ffi.VoidPtr, r: f32, g: f32, b: f32, a: f32)
    fn unreal_rhi_clear_depth_stencil(cmd_list: ffi.VoidPtr, dsv: ffi.VoidPtr, depth: f32, stencil: i32)
    fn unreal_rhi_set_render_targets(cmd_list: ffi.VoidPtr, num_rtvs: i32, rtvs: ffi.VoidPtr, dsv: ffi.VoidPtr)
    fn unreal_rhi_set_viewport(cmd_list: ffi.VoidPtr, x: f32, y: f32, width: f32, height: f32, min_depth: f32, max_depth: f32)
    fn unreal_rhi_set_scissor_rect(cmd_list: ffi.VoidPtr, x: i32, y: i32, width: i32, height: i32)
    fn unreal_rhi_draw_primitive(cmd_list: ffi.VoidPtr, vertex_count: i32, instance_count: i32, start_vertex: i32, start_instance: i32)
    fn unreal_rhi_draw_indexed_primitive(cmd_list: ffi.VoidPtr, index_count: i32, instance_count: i32, start_index: i32, base_vertex: i32, start_instance: i32)
    fn unreal_rhi_submit_command_list(cmd_list: ffi.VoidPtr)

    # Vulkan backend functions
    fn unreal_vulkan_get_device() -> ffi.VoidPtr
    fn unreal_vulkan_get_vk_device(device: ffi.VoidPtr) -> ffi.VoidPtr
    fn unreal_vulkan_get_vk_physical_device(device: ffi.VoidPtr) -> ffi.VoidPtr
    fn unreal_vulkan_get_vk_instance(device: ffi.VoidPtr) -> ffi.VoidPtr
    fn unreal_vulkan_get_graphics_queue(device: ffi.VoidPtr) -> ffi.VoidPtr
    fn unreal_vulkan_get_compute_queue(device: ffi.VoidPtr) -> ffi.VoidPtr
    fn unreal_vulkan_get_transfer_queue(device: ffi.VoidPtr) -> ffi.VoidPtr
    fn unreal_vulkan_texture_get_vk_image(texture: ffi.VoidPtr) -> ffi.VoidPtr
    fn unreal_vulkan_texture_get_vk_image_view(texture: ffi.VoidPtr) -> ffi.VoidPtr
    fn unreal_vulkan_texture_get_vk_format(texture: ffi.VoidPtr) -> i32
    fn unreal_vulkan_buffer_get_vk_buffer(buffer: ffi.VoidPtr) -> ffi.VoidPtr
    fn unreal_vulkan_buffer_get_vk_device_memory(buffer: ffi.VoidPtr) -> ffi.VoidPtr


# Example usage:
#
# # Create render target
# val rt = create_render_target(1920, 1080, PixelFormat.R8G8B8A8_UNORM)
# val ds = create_depth_stencil_target(1920, 1080)
#
# # Get command list
# var cmd_list = get_immediate_command_list()
#
# # Clear and draw
# val rtv = RHIRenderTargetView.from_ptr(unreal_rhi_get_render_target_view(rt.as_ptr()))
# val dsv = RHIDepthStencilView.from_ptr(unreal_rhi_get_depth_stencil_view(ds.as_ptr()))
#
# cmd_list.set_render_targets([rtv], Some(dsv))
# cmd_list.set_viewport(0.0, 0.0, 1920.0, 1080.0)
# cmd_list.clear_render_target(rtv, 0.0, 0.0, 0.0, 1.0)
# cmd_list.clear_depth_stencil(dsv, 1.0, 0)
# cmd_list.draw_primitive(3, 1, 0, 0)
# cmd_list.submit()
#
# # Vulkan-specific access
# val vk_device = VulkanDevice.get_instance()
# val vk_handle = vk_device.get_vk_device()
# val vk_tex = VulkanTexture.from_rhi_texture(rt)
# val vk_image = vk_tex.get_vk_image()
