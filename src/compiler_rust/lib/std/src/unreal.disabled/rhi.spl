# Unreal RHI (Rendering Hardware Interface)
#
# Low-level rendering abstraction for Unreal Engine
#
# Features:
# - RHI resource management (textures, buffers, shaders)
# - Command list recording and submission
# - Graphics pipeline state objects
# - Render target and viewport management
# - Vulkan backend access
#
# Based on: https://docs.unrealengine.com/5.4/en-US/API/Runtime/RHI/

use sys.ffi

mod rhi

# PixelFormat
# Texture pixel formats
pub enum PixelFormat:
    Unknown = 0
    R8G8B8A8_UNORM = 1
    B8G8R8A8_UNORM = 2
    R16G16B16A16_FLOAT = 3
    R32G32B32A32_FLOAT = 4
    D24_UNORM_S8_UINT = 5
    D32_FLOAT = 6
    R8_UNORM = 7
    BC1_UNORM = 8
    BC2_UNORM = 9
    BC3_UNORM = 10

impl PixelFormat:
    pub fn to_int(self) -> i32:
        if self == PixelFormat.Unknown:
            return 0
        elif self == PixelFormat.R8G8B8A8_UNORM:
            return 1
        elif self == PixelFormat.B8G8R8A8_UNORM:
            return 2
        elif self == PixelFormat.R16G16B16A16_FLOAT:
            return 3
        elif self == PixelFormat.R32G32B32A32_FLOAT:
            return 4
        elif self == PixelFormat.D24_UNORM_S8_UINT:
            return 5
        elif self == PixelFormat.D32_FLOAT:
            return 6
        elif self == PixelFormat.R8_UNORM:
            return 7
        elif self == PixelFormat.BC1_UNORM:
            return 8
        elif self == PixelFormat.BC2_UNORM:
            return 9
        else:
            return 10

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn to_string(self) -> text:
        """Convert pixel format to string.

        Returns:
            Format name

        Example:
            PixelFormat.R8G8B8A8_UNORM.to_string()  # → "R8G8B8A8_UNORM"
        """
        if self == PixelFormat.Unknown:
            return "Unknown"
        elif self == PixelFormat.R8G8B8A8_UNORM:
            return "R8G8B8A8_UNORM"
        elif self == PixelFormat.B8G8R8A8_UNORM:
            return "B8G8R8A8_UNORM"
        elif self == PixelFormat.R16G16B16A16_FLOAT:
            return "R16G16B16A16_FLOAT"
        elif self == PixelFormat.R32G32B32A32_FLOAT:
            return "R32G32B32A32_FLOAT"
        elif self == PixelFormat.D24_UNORM_S8_UINT:
            return "D24_UNORM_S8_UINT"
        elif self == PixelFormat.D32_FLOAT:
            return "D32_FLOAT"
        elif self == PixelFormat.R8_UNORM:
            return "R8_UNORM"
        elif self == PixelFormat.BC1_UNORM:
            return "BC1_UNORM"
        elif self == PixelFormat.BC2_UNORM:
            return "BC2_UNORM"
        else:
            return "BC3_UNORM"

    pub fn description(self) -> text:
        """Get pixel format description.

        Returns:
            Human-readable description

        Example:
            PixelFormat.R8G8B8A8_UNORM.description()
            # → "8-bit RGBA unsigned normalized"
        """
        if self == PixelFormat.Unknown:
            return "Unknown pixel format"
        elif self == PixelFormat.R8G8B8A8_UNORM:
            return "8-bit RGBA unsigned normalized"
        elif self == PixelFormat.B8G8R8A8_UNORM:
            return "8-bit BGRA unsigned normalized"
        elif self == PixelFormat.R16G16B16A16_FLOAT:
            return "16-bit RGBA f32 (half precision)"
        elif self == PixelFormat.R32G32B32A32_FLOAT:
            return "32-bit RGBA f32 (full precision)"
        elif self == PixelFormat.D24_UNORM_S8_UINT:
            return "24-bit depth + 8-bit stencil"
        elif self == PixelFormat.D32_FLOAT:
            return "32-bit depth f32"
        elif self == PixelFormat.R8_UNORM:
            return "8-bit single channel unsigned normalized"
        elif self == PixelFormat.BC1_UNORM:
            return "BC1 block compression (DXT1)"
        elif self == PixelFormat.BC2_UNORM:
            return "BC2 block compression (DXT3)"
        else:
            return "BC3 block compression (DXT5)"

    pub fn is_unknown(self) -> bool:
        """Check if format is Unknown.

        Returns:
            True if Unknown
        """
        return self == PixelFormat.Unknown

    pub fn is_r8g8b8a8_unorm(self) -> bool:
        """Check if format is R8G8B8A8_UNORM.

        Returns:
            True if R8G8B8A8_UNORM
        """
        return self == PixelFormat.R8G8B8A8_UNORM

    pub fn is_b8g8r8a8_unorm(self) -> bool:
        """Check if format is B8G8R8A8_UNORM.

        Returns:
            True if B8G8R8A8_UNORM
        """
        return self == PixelFormat.B8G8R8A8_UNORM

    pub fn is_r16g16b16a16_float(self) -> bool:
        """Check if format is R16G16B16A16_FLOAT.

        Returns:
            True if R16G16B16A16_FLOAT
        """
        return self == PixelFormat.R16G16B16A16_FLOAT

    pub fn is_r32g32b32a32_float(self) -> bool:
        """Check if format is R32G32B32A32_FLOAT.

        Returns:
            True if R32G32B32A32_FLOAT
        """
        return self == PixelFormat.R32G32B32A32_FLOAT

    pub fn is_d24_unorm_s8_uint(self) -> bool:
        """Check if format is D24_UNORM_S8_UINT.

        Returns:
            True if D24_UNORM_S8_UINT
        """
        return self == PixelFormat.D24_UNORM_S8_UINT

    pub fn is_d32_float(self) -> bool:
        """Check if format is D32_FLOAT.

        Returns:
            True if D32_FLOAT
        """
        return self == PixelFormat.D32_FLOAT

    pub fn is_r8_unorm(self) -> bool:
        """Check if format is R8_UNORM.

        Returns:
            True if R8_UNORM
        """
        return self == PixelFormat.R8_UNORM

    pub fn is_bc1_unorm(self) -> bool:
        """Check if format is BC1_UNORM.

        Returns:
            True if BC1_UNORM
        """
        return self == PixelFormat.BC1_UNORM

    pub fn is_bc2_unorm(self) -> bool:
        """Check if format is BC2_UNORM.

        Returns:
            True if BC2_UNORM
        """
        return self == PixelFormat.BC2_UNORM

    pub fn is_bc3_unorm(self) -> bool:
        """Check if format is BC3_UNORM.

        Returns:
            True if BC3_UNORM
        """
        return self == PixelFormat.BC3_UNORM

    pub fn is_depth_format(self) -> bool:
        """Check if format is depth/stencil format.

        Returns:
            True for depth or depth-stencil formats

        Example:
            PixelFormat.D24_UNORM_S8_UINT.is_depth_format()  # → true
        """
        return self == PixelFormat.D24_UNORM_S8_UINT or self == PixelFormat.D32_FLOAT

    pub fn is_color_format(self) -> bool:
        """Check if format is color format.

        Returns:
            True for color formats (not depth/stencil)

        Example:
            PixelFormat.R8G8B8A8_UNORM.is_color_format()  # → true
        """
        return not self.is_depth_format() and not self.is_unknown()

    pub fn is_compressed(self) -> bool:
        """Check if format uses block compression.

        Returns:
            True for BC1/BC2/BC3 formats

        Example:
            PixelFormat.BC1_UNORM.is_compressed()  # → true
        """
        return self == PixelFormat.BC1_UNORM or self == PixelFormat.BC2_UNORM or self == PixelFormat.BC3_UNORM

    pub fn is_float_format(self) -> bool:
        """Check if format uses floating point.

        Returns:
            True for f32 formats

        Example:
            PixelFormat.R32G32B32A32_FLOAT.is_float_format()  # → true
        """
        return self == PixelFormat.R16G16B16A16_FLOAT or self == PixelFormat.R32G32B32A32_FLOAT or self == PixelFormat.D32_FLOAT

    pub fn is_hdr(self) -> bool:
        """Check if format supports HDR (high dynamic range).

        Returns:
            True for HDR-capable formats

        Example:
            PixelFormat.R16G16B16A16_FLOAT.is_hdr()  # → true
        """
        return self == PixelFormat.R16G16B16A16_FLOAT or self == PixelFormat.R32G32B32A32_FLOAT

    pub fn bytes_per_pixel(self) -> i32:
        """Get bytes per pixel (uncompressed formats only).

        Returns:
            Bytes per pixel, or 0 for compressed/unknown

        Example:
            PixelFormat.R8G8B8A8_UNORM.bytes_per_pixel()  # → 4
        """
        if self == PixelFormat.R8G8B8A8_UNORM or self == PixelFormat.B8G8R8A8_UNORM:
            return 4
        elif self == PixelFormat.R16G16B16A16_FLOAT:
            return 8
        elif self == PixelFormat.R32G32B32A32_FLOAT:
            return 16
        elif self == PixelFormat.D24_UNORM_S8_UINT:
            return 4
        elif self == PixelFormat.D32_FLOAT:
            return 4
        elif self == PixelFormat.R8_UNORM:
            return 1
        else:
            return 0

    pub fn summary(self) -> text:
        """Get pixel format summary.

        Returns:
            Human-readable summary

        Example:
            PixelFormat.R8G8B8A8_UNORM.summary()
            # → "PixelFormat: R8G8B8A8_UNORM (8-bit RGBA unsigned normalized, color, 4 bytes/pixel)"
        """
        val name = self.to_string()
        val desc = self.description()
        var props = []

        if self.is_color_format():
            props.push("color")
        if self.is_depth_format():
            props.push("depth")
        if self.is_compressed():
            props.push("compressed")
        if self.is_float_format():
            props.push("f32")
        if self.is_hdr():
            props.push("HDR")

        val bpp = self.bytes_per_pixel()
        if bpp > 0:
            props.push("{bpp} bytes/pixel")

        if props.len() > 0:
            val props_str = ", ".join(props)
            return "PixelFormat: {name} ({desc}, {props_str})"
        else:
            return "PixelFormat: {name} ({desc})"

# TextureUsage
# Texture usage flags
pub enum TextureUsage:
    None = 0
    RenderTargetable = 1
    DepthStencil = 2
    ShaderResource = 4
    UAV = 8

impl TextureUsage:
    pub fn to_int(self) -> i32:
        if self == TextureUsage.None:
            return 0
        elif self == TextureUsage.RenderTargetable:
            return 1
        elif self == TextureUsage.DepthStencil:
            return 2
        elif self == TextureUsage.ShaderResource:
            return 4
        else:
            return 8

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn to_string(self) -> text:
        """Convert texture usage to string.

        Returns:
            Usage name

        Example:
            TextureUsage.RenderTargetable.to_string()  # → "RenderTargetable"
        """
        if self == TextureUsage.None:
            return "None"
        elif self == TextureUsage.RenderTargetable:
            return "RenderTargetable"
        elif self == TextureUsage.DepthStencil:
            return "DepthStencil"
        elif self == TextureUsage.ShaderResource:
            return "ShaderResource"
        else:
            return "UAV"

    pub fn description(self) -> text:
        """Get texture usage description.

        Returns:
            Human-readable description

        Example:
            TextureUsage.RenderTargetable.description()
            # → "Can be used as render target"
        """
        if self == TextureUsage.None:
            return "No special usage"
        elif self == TextureUsage.RenderTargetable:
            return "Can be used as render target"
        elif self == TextureUsage.DepthStencil:
            return "Can be used as depth/stencil buffer"
        elif self == TextureUsage.ShaderResource:
            return "Can be read in shaders"
        else:
            return "Unordered access view (read/write in compute)"

    pub fn is_none(self) -> bool:
        """Check if usage is None.

        Returns:
            True if None
        """
        return self == TextureUsage.None

    pub fn is_render_targetable(self) -> bool:
        """Check if usage is RenderTargetable.

        Returns:
            True if RenderTargetable
        """
        return self == TextureUsage.RenderTargetable

    pub fn is_depth_stencil(self) -> bool:
        """Check if usage is DepthStencil.

        Returns:
            True if DepthStencil
        """
        return self == TextureUsage.DepthStencil

    pub fn is_shader_resource(self) -> bool:
        """Check if usage is ShaderResource.

        Returns:
            True if ShaderResource
        """
        return self == TextureUsage.ShaderResource

    pub fn is_uav(self) -> bool:
        """Check if usage is UAV.

        Returns:
            True if UAV
        """
        return self == TextureUsage.UAV

    pub fn is_writable(self) -> bool:
        """Check if texture can be written to.

        Returns:
            True for RenderTargetable, DepthStencil, or UAV

        Example:
            TextureUsage.UAV.is_writable()  # → true
            TextureUsage.ShaderResource.is_writable()  # → false
        """
        return self == TextureUsage.RenderTargetable or self == TextureUsage.DepthStencil or self == TextureUsage.UAV

    pub fn is_readable(self) -> bool:
        """Check if texture can be read from.

        Returns:
            True for ShaderResource or UAV

        Example:
            TextureUsage.ShaderResource.is_readable()  # → true
        """
        return self == TextureUsage.ShaderResource or self == TextureUsage.UAV

    pub fn requires_render_target_support(self) -> bool:
        """Check if usage requires render target support.

        Returns:
            True for RenderTargetable or DepthStencil

        Example:
            TextureUsage.RenderTargetable.requires_render_target_support()  # → true
        """
        return self == TextureUsage.RenderTargetable or self == TextureUsage.DepthStencil

    pub fn summary(self) -> text:
        """Get texture usage summary.

        Returns:
            Human-readable summary

        Example:
            TextureUsage.UAV.summary()
            # → "TextureUsage: UAV (Unordered access view (read/write in compute), writable, readable)"
        """
        val name = self.to_string()
        val desc = self.description()
        var props = []

        if self.is_writable():
            props.push("writable")
        if self.is_readable():
            props.push("readable")
        if self.requires_render_target_support():
            props.push("requires RT support")

        if props.len() > 0:
            val props_str = ", ".join(props)
            return "TextureUsage: {name} ({desc}, {props_str})"
        else:
            return "TextureUsage: {name} ({desc})"

# See rhi_impl.spl for RHITexture, RHIBuffer, ShaderType, RHIShader, RHI views,
# RHICommandList, VulkanDevice/VulkanTexture/VulkanBuffer, resource creation functions,
# and FFI declarations.
