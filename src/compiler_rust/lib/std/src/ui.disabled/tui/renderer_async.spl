# TUI Async Renderer - Terminal UI Backend
#
# Renders UI elements to terminal using ANSI escape codes and box-drawing characters.
# Demonstrates that the same Element/PatchSet API works for terminal output.
#
# Key Features:
#   - ANSI color support (16 colors, 256 colors, true color)
#   - Box drawing characters (Unicode)
#   - Keyboard and mouse input
#   - Async rendering with terminal buffering
#   - Layout calculation for text-based UI
#   - Focus management
#
# See renderer_async_draw.spl for rendering functions, terminal buffer, and FFI.

use core.*
use concurrency.*
use ui.element.*
use ui.attrs.*
use ui.patchset.*
use ui.renderer.*
use ui.common.colors.parse_color_string
use ui.common.colors.Color

# =============================================================================
# TUI Async Renderer (Terminal-based)
# =============================================================================

pub struct TuiAsyncRenderer:
    # Terminal state
    terminal_fd: i32           # File descriptor (stdin/stdout)
    width: u16                 # Terminal width in columns
    height: u16                # Terminal height in rows

    # Display buffer (double buffering)
    front_buffer: TerminalBuffer
    back_buffer: TerminalBuffer

    # Element tracking
    layout_cache: LayoutCache
    focus_id: Option<NodeId>

    # State
    initialized: bool
    mouse_enabled: bool
    alternate_screen: bool

    # Current tree (for diffing)
    current_tree: Option<ElementTree>

impl TuiAsyncRenderer:
    # Create a new TUI renderer
    pub fn new() -> Result<TuiAsyncRenderer, RenderError>:
        return Ok(TuiAsyncRenderer {terminal_fd: 0, # Will be set in init width: 80, # Default, updated in init height: 24, # Default, updated in init front_buffer: TerminalBuffer.new(80, 24), back_buffer: TerminalBuffer.new(80, 24), layout_cache: LayoutCache.new(), focus_id: None, initialized: false, mouse_enabled: false, alternate_screen: false, current_tree: None})

    # Create with options
    pub fn with_mouse(mut self) -> TuiAsyncRenderer:
        self.mouse_enabled = true
        return self

    pub fn with_alternate_screen(mut self) -> TuiAsyncRenderer:
        self.alternate_screen = true
        return self

# =============================================================================
# Async RenderBackend Implementation
# =============================================================================

impl RenderBackend for TuiAsyncRenderer:
    async fn init(self) -> Future<Result<(), RenderError>>:
        if self.initialized:
            return Future.ready(Err(RenderError.AlreadyInitialized))

        # Get terminal file descriptor
        self.terminal_fd = await terminal_get_fd()

        # Enter raw mode (disable line buffering, echo, etc.)
        await terminal_enter_raw_mode(self.terminal_fd)

        # Get terminal size
        val (width, height) = await terminal_get_size(self.terminal_fd)
        self.width = width
        self.height = height

        # Resize buffers
        self.front_buffer = TerminalBuffer.new(width, height)
        self.back_buffer = TerminalBuffer.new(width, height)

        # Enter alternate screen (optional)
        if self.alternate_screen:
            await terminal_write(self.terminal_fd, "\x1b[?1049h")  # Enter alt screen

        # Enable mouse (optional)
        if self.mouse_enabled:
            await terminal_write(self.terminal_fd, "\x1b[?1000h")  # Enable mouse tracking
            await terminal_write(self.terminal_fd, "\x1b[?1003h")  # Enable any-event tracking

        # Hide cursor
        await terminal_write(self.terminal_fd, "\x1b[?25l")

        # Clear screen
        await terminal_write(self.terminal_fd, "\x1b[2J")
        await terminal_write(self.terminal_fd, "\x1b[H")

        self.initialized = true
        return Future.ready(Ok(()))

    async fn shutdown(self) -> Future<Result<(), RenderError>>:
        if not self.initialized:
            return Future.ready(Err(RenderError.NotInitialized))

        # Show cursor
        await terminal_write(self.terminal_fd, "\x1b[?25h")

        # Disable mouse
        if self.mouse_enabled:
            await terminal_write(self.terminal_fd, "\x1b[?1000l")
            await terminal_write(self.terminal_fd, "\x1b[?1003l")

        # Exit alternate screen
        if self.alternate_screen:
            await terminal_write(self.terminal_fd, "\x1b[?1049l")

        # Leave raw mode
        await terminal_exit_raw_mode(self.terminal_fd)

        self.initialized = false
        return Future.ready(Ok(()))

    fn dimensions() -> (u16, u16):
        return (self.width, self.height)

    # Render element tree to terminal
    async fn render(self, tree: &ElementTree) -> Future<Result<(), RenderError>>:
        if not self.initialized:
            return Future.ready(Err(RenderError.NotInitialized))

        # Compute layout
        val layout_result = self.compute_layout(tree)

        # Render to back buffer
        self.back_buffer.clear()
        self.render_element_to_buffer(tree.root(), &layout_result, &mut self.back_buffer)

        # Swap buffers and flush diff to terminal
        await self.flush_buffer_diff()

        # Store tree for diffing
        self.current_tree = Some(tree.clone())

        return Future.ready(Ok(()))

    async fn apply_patches(self, patches: &PatchSet) -> Future<Result<(), RenderError>>:
        if not self.initialized:
            return Future.ready(Err(RenderError.NotInitialized))

        # For TUI, we typically re-render the whole screen
        # (incremental updates are harder with terminal rendering)
        # But we can optimize by only updating dirty regions

        if val Some(tree) = &self.current_tree:
            # Apply patches to tree
            val updated_tree = self.apply_patches_to_tree(tree, patches)
            # Re-render
            await self.render(&updated_tree)

        return Future.ready(Ok(()))

    async fn clear(self) -> Future<Result<(), RenderError>>:
        if not self.initialized:
            return Future.ready(Err(RenderError.NotInitialized))

        # Clear both buffers
        self.front_buffer.clear()
        self.back_buffer.clear()

        # Clear terminal
        await terminal_write(self.terminal_fd, "\x1b[2J")
        await terminal_write(self.terminal_fd, "\x1b[H")

        return Future.ready(Ok(()))

    async fn flush(self) -> Future<Result<(), RenderError>>:
        if not self.initialized:
            return Future.ready(Err(RenderError.NotInitialized))

        # Flush any pending writes
        await terminal_flush(self.terminal_fd)

        return Future.ready(Ok(()))

    # Poll terminal events (keyboard, mouse, resize)
    async fn poll_event(self, timeout_ms: u64) -> Future<Result<Option<Event>, RenderError>>:
        if not self.initialized:
            return Future.ready(Err(RenderError.NotInitialized))

        # Poll terminal for input with timeout
        val input = await terminal_poll_input(self.terminal_fd, timeout_ms)

        match input:
            case Some(bytes):
                # Parse input bytes into Event
                val event = self.parse_input_bytes(&bytes)
                return Future.ready(Ok(Some(event)))
            case None:
                return Future.ready(Ok(None))

    async fn read_event(self) -> Future<Result<Event, RenderError>>:
        # Block until event arrives
        loop:
            match await self.poll_event(1000):
                case Ok(Some(event)): return Future.ready(Ok(event))
                case Ok(None): pass
                case Err(e): return Future.ready(Err(e))

# =============================================================================
# Internal Layout Implementation
# =============================================================================

impl TuiAsyncRenderer:
    # Compute layout for terminal
    fn compute_layout(tree: &ElementTree) -> LayoutResult:
        # Terminal layout is character-based
        var result = LayoutResult.default()

        # Root element takes full terminal
        val root_layout = Layout.new(0, 0, self.width, self.height)
        result.bounds.set(tree.root().id.value(), self.layout_to_rect(root_layout))

        # Recursively layout children
        self.layout_element(tree.root(), root_layout, &mut result)

        return result

    fn layout_element(elem: &Element, parent_layout: Layout, result: &mut LayoutResult):
        # Proper flexbox/grid layout implementation
        val num_children = elem.children.len() as u16
        if num_children == 0:
            return

        # Determine layout mode from element style or kind
        val layout_mode = match elem.style.display:
            case Some("flex"): LayoutMode.Flex
            case Some("grid"): LayoutMode.Grid
            case _: LayoutMode.Block

        match layout_mode:
            case LayoutMode.Flex:
                self.layout_flex_children(elem, parent_layout, result)
            case LayoutMode.Grid:
                self.layout_grid_children(elem, parent_layout, result)
            case LayoutMode.Block:
                self.layout_block_children(elem, parent_layout, result)

    fn layout_flex_children(elem: &Element, parent_layout: Layout, result: &mut LayoutResult):
        # Flexbox layout: distribute space based on flex properties
        val is_row = elem.style.flex_direction.unwrap_or("row") == "row"
        val num_children = elem.children.len() as u16

        # Calculate flex factors
        var total_flex: f32 = 0.0
        for child in &elem.children:
            total_flex += child.style.flex_grow.unwrap_or(1.0)

        val gap = elem.style.gap.unwrap_or(0) as u16

        if is_row:
            # Horizontal flex
            val available_width = parent_layout.content_width - (gap * (num_children - 1).max(0))
            var x = parent_layout.content_x

            for child in &elem.children:
                val flex = child.style.flex_grow.unwrap_or(1.0)
                val child_width = ((available_width as f32) * (flex / total_flex)) as u16

                val child_layout = Layout.new(
                    x,
                    parent_layout.content_y,
                    child_width,
                    parent_layout.content_height
                )

                result.bounds.set(child.id.value(), self.layout_to_rect(child_layout))
                self.layout_element(child, child_layout, result)

                x = x + child_width + gap
        else:
            # Vertical flex
            val available_height = parent_layout.content_height - (gap * (num_children - 1).max(0))
            var y = parent_layout.content_y

            for child in &elem.children:
                val flex = child.style.flex_grow.unwrap_or(1.0)
                val child_height = ((available_height as f32) * (flex / total_flex)) as u16

                val child_layout = Layout.new(
                    parent_layout.content_x,
                    y,
                    parent_layout.content_width,
                    child_height
                )

                result.bounds.set(child.id.value(), self.layout_to_rect(child_layout))
                self.layout_element(child, child_layout, result)

                y = y + child_height + gap

    fn layout_grid_children(elem: &Element, parent_layout: Layout, result: &mut LayoutResult):
        # Grid layout: arrange children in a grid
        val columns = elem.style.grid_columns.unwrap_or(2) as u16
        val num_children = elem.children.len() as u16
        val rows = (num_children + columns - 1) / columns

        val gap = elem.style.gap.unwrap_or(0) as u16
        val cell_width = (parent_layout.content_width - (gap * (columns - 1))) / columns
        val cell_height = (parent_layout.content_height - (gap * (rows - 1).max(0))) / rows.max(1)

        for (i, child) in elem.children.iter().enumerate():
            val col = (i as u16) % columns
            val row = (i as u16) / columns

            val x = parent_layout.content_x + col * (cell_width + gap)
            val y = parent_layout.content_y + row * (cell_height + gap)

            val child_layout = Layout.new(x, y, cell_width, cell_height)

            result.bounds.set(child.id.value(), self.layout_to_rect(child_layout))
            self.layout_element(child, child_layout, result)

    fn layout_block_children(elem: &Element, parent_layout: Layout, result: &mut LayoutResult):
        # Block layout: stack children vertically with full width
        val num_children = elem.children.len() as u16
        val child_height = parent_layout.content_height / num_children.max(1)
        var y = parent_layout.content_y

        for child in &elem.children:
            val child_layout = Layout.new(
                parent_layout.content_x,
                y,
                parent_layout.content_width,
                child_height
            )

            result.bounds.set(child.id.value(), self.layout_to_rect(child_layout))
            self.layout_element(child, child_layout, result)

            y = y + child_height
