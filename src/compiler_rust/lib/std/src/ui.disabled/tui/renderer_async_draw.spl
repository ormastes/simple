# TUI Async Renderer - Drawing, Buffer, and FFI
#
# Rendering functions, terminal buffer management, and FFI bindings.
# Part of the TUI async renderer module - see renderer_async.spl for
# TuiAsyncRenderer struct, RenderBackend impl, and layout computation.

use core.*
use concurrency.*
use ui.element.*
use ui.attrs.*
use ui.patchset.*
use ui.renderer.*
use ui.common.colors.parse_color_string
use ui.common.colors.Color

# =============================================================================
# Layout Mode (shared by layout and rendering)
# =============================================================================

enum LayoutMode:
    Flex
    Grid
    Block

impl TuiAsyncRenderer:
    fn layout_to_rect(layout: Layout) -> Rect:
        return Rect {x: layout.x as f32, y: layout.y as f32, width: layout.width as f32, height: layout.height as f32}

    # Render element to terminal buffer
    fn render_element_to_buffer(elem: &Element, layout: &LayoutResult, buffer: &mut TerminalBuffer):
        # Get layout bounds
        val bounds = match layout.bounds.get(&elem.id.value()):
            case Some(rect): rect
            case None: return

        val x = bounds.x as u16
        val y = bounds.y as u16
        val w = bounds.width as u16
        val h = bounds.height as u16

        # Render based on element type
        match elem.kind:
            case ElementKind.Box:
                self.render_box(x, y, w, h, elem, buffer)
            case ElementKind.Button:
                self.render_button(x, y, w, h, elem, buffer)
            case ElementKind.Text:
                self.render_text(x, y, w, h, elem, buffer)
            case ElementKind.Paragraph:
                self.render_paragraph(x, y, w, h, elem, buffer)
            case _:
                # Default: just render background
                self.render_background(x, y, w, h, elem, buffer)

        # Render children
        for child in &elem.children:
            self.render_element_to_buffer(child, layout, buffer)

    fn render_box(x: u16, y: u16, w: u16, h: u16, elem: &Element, buffer: &mut TerminalBuffer):
        # Draw box with Unicode box-drawing characters
        val (fg, bg) = self.get_colors(elem)

        # Top edge
        buffer.set_cell(x, y, Cell.new('┌', fg, bg))
        for i in 1..(w-1):
            buffer.set_cell(x + i, y, Cell.new('─', fg, bg))
        buffer.set_cell(x + w - 1, y, Cell.new('┐', fg, bg))

        # Sides
        for j in 1..(h-1):
            buffer.set_cell(x, y + j, Cell.new('│', fg, bg))
            buffer.set_cell(x + w - 1, y + j, Cell.new('│', fg, bg))

        # Bottom edge
        buffer.set_cell(x, y + h - 1, Cell.new('└', fg, bg))
        for i in 1..(w-1):
            buffer.set_cell(x + i, y + h - 1, Cell.new('─', fg, bg))
        buffer.set_cell(x + w - 1, y + h - 1, Cell.new('┘', fg, bg))

    fn render_button(x: u16, y: u16, w: u16, h: u16, elem: &Element, buffer: &mut TerminalBuffer):
        val (fg, bg) = self.get_colors(elem)

        # Draw button background
        for j in 0..h:
            for i in 0..w:
                buffer.set_cell(x + i, y + j, Cell.new(' ', fg, bg))

        # Draw label (centered)
        if val Some(text) = &elem.text:
            val text_len = text.len() as u16
            val text_x = x + (w - text_len) / 2
            val text_y = y + h / 2

            for (i, ch) in text.chars().enumerate():
                buffer.set_cell(text_x + (i as u16), text_y, Cell.new(ch, fg, bg))

        # Draw border if focused
        if elem.focused:
            self.render_box(x, y, w, h, elem, buffer)

    fn render_text(x: u16, y: u16, w: u16, h: u16, elem: &Element, buffer: &mut TerminalBuffer):
        val (fg, bg) = self.get_colors(elem)

        if val Some(text) = &elem.text:
            # Render single line of text
            for (i, ch) in text.chars().enumerate():
                if i as u16 >= w:
                    break
                buffer.set_cell(x + (i as u16), y, Cell.new(ch, fg, bg))

    fn render_paragraph(x: u16, y: u16, w: u16, h: u16, elem: &Element, buffer: &mut TerminalBuffer):
        val (fg, bg) = self.get_colors(elem)

        if val Some(text) = &elem.text:
            # Word wrap text
            val lines = self.wrap_text(text, w)

            for (j, line) in lines.iter().enumerate():
                if j as u16 >= h:
                    break
                for (i, ch) in line.chars().enumerate():
                    if i as u16 >= w:
                        break
                    buffer.set_cell(x + (i as u16), y + (j as u16), Cell.new(ch, fg, bg))

    fn render_background(x: u16, y: u16, w: u16, h: u16, elem: &Element, buffer: &mut TerminalBuffer):
        val (fg, bg) = self.get_colors(elem)

        for j in 0..h:
            for i in 0..w:
                buffer.set_cell(x + i, y + j, Cell.new(' ', fg, bg))

    fn get_colors(elem: &Element) -> (Color, Color):
        val fg = match elem.styles.get("color"):
            case Some(color_str): parse_color_string(color_str)
            case None: Color.Default

        val bg = match elem.styles.get("background-color"):
            case Some(color_str): parse_color_string(color_str)
            case None: Color.Default

        return (fg, bg)

    fn wrap_text(text: &str, width: u16) -> Array<text>:
        # Simple word wrapping
        var lines: Array<text> = []
        var current_line = text.new()

        for word in text.split(' '):
            if (current_line.len() + word.len() + 1) as u16 > width:
                if not current_line.is_empty():
                    lines.push(current_line)
                    current_line = text.new()

            if not current_line.is_empty():
                current_line.push(' ')
            current_line.push_str(word)

        if not current_line.is_empty():
            lines.push(current_line)

        return lines

    # Flush buffer diff to terminal
    async fn flush_buffer_diff(self) -> Future<()>:
        # Compare front and back buffers, output only diff
        var output = text.new()

        for y in 0..self.height:
            for x in 0..self.width:
                val front_cell = self.front_buffer.get_cell(x, y)
                val back_cell = self.back_buffer.get_cell(x, y)

                if front_cell != back_cell:
                    # Move cursor to position
                    output.push_str(&"\x1b[{y + 1};{x + 1}H")

                    # Set colors if changed
                    if front_cell.fg != back_cell.fg or front_cell.bg != back_cell.bg:
                        output.push_str(&self.color_to_ansi(back_cell.fg, back_cell.bg))

                    # Output character
                    output.push(back_cell.ch)

        # Write to terminal
        if not output.is_empty():
            await terminal_write(self.terminal_fd, &output)

        # Swap buffers
        val temp = self.front_buffer
        self.front_buffer = self.back_buffer
        self.back_buffer = temp

        return Future.ready(())

    fn color_to_ansi(fg: Color, bg: Color) -> text:
        var result = text.new()

        # Foreground color
        match fg:
            case Color.Black: result.push_str("\x1b[30m")
            case Color.Red: result.push_str("\x1b[31m")
            case Color.Green: result.push_str("\x1b[32m")
            case Color.Yellow: result.push_str("\x1b[33m")
            case Color.Blue: result.push_str("\x1b[34m")
            case Color.Magenta: result.push_str("\x1b[35m")
            case Color.Cyan: result.push_str("\x1b[36m")
            case Color.White: result.push_str("\x1b[37m")
            case Color.Default: result.push_str("\x1b[39m")
            case Color.Rgb(r, g, b):
                result.push_str(&"\x1b[38;2;{r};{g};{b}m")
            case _: pass

        # Background color
        match bg:
            case Color.Black: result.push_str("\x1b[40m")
            case Color.Red: result.push_str("\x1b[41m")
            case Color.Green: result.push_str("\x1b[42m")
            case Color.Yellow: result.push_str("\x1b[43m")
            case Color.Blue: result.push_str("\x1b[44m")
            case Color.Magenta: result.push_str("\x1b[45m")
            case Color.Cyan: result.push_str("\x1b[46m")
            case Color.White: result.push_str("\x1b[47m")
            case Color.Default: result.push_str("\x1b[49m")
            case Color.Rgb(r, g, b):
                result.push_str(&"\x1b[48;2;{r};{g};{b}m")
            case _: pass

        return result

    # Parse terminal input into Event
    fn parse_input_bytes(bytes: &Array<u8>) -> Event:
        # Parse ANSI escape sequences
        if bytes.is_empty():
            return Event.Key(KeyEvent { code: KeyCode.Null, modifiers: KeyModifiers.none() })

        # Special keys (escape sequences)
        if bytes[0] == 0x1b:  # ESC
            if bytes.len() == 1:
                return Event.Key(KeyEvent { code: KeyCode.Escape, modifiers: KeyModifiers.none() })

            # Arrow keys, function keys, etc.
            if bytes.len() >= 3 and bytes[1] == 0x5b:  # ESC [
                match bytes[2]:
                    case 0x41: return Event.Key(KeyEvent { code: KeyCode.Up, modifiers: KeyModifiers.none() })
                    case 0x42: return Event.Key(KeyEvent { code: KeyCode.Down, modifiers: KeyModifiers.none() })
                    case 0x43: return Event.Key(KeyEvent { code: KeyCode.Right, modifiers: KeyModifiers.none() })
                    case 0x44: return Event.Key(KeyEvent { code: KeyCode.Left, modifiers: KeyModifiers.none() })
                    case _: pass

            # Mouse events
            if bytes.len() >= 6 and bytes[1] == 0x5b and bytes[2] == 0x4d:  # ESC [ M
                val button = bytes[3] - 32
                val x = (bytes[4] - 32) as u16
                val y = (bytes[5] - 32) as u16

                val kind = if button & 0x3 == 0:
                    MouseEventKind.Down(MouseButton.Left)
                else if button & 0x3 == 1:
                    MouseEventKind.Down(MouseButton.Middle)
                else:
                    MouseEventKind.Down(MouseButton.Right)

                return Event.Mouse(MouseEvent.new(kind, x, y))

        # Regular keys
        match bytes[0]:
            case 0x0d: return Event.Key(KeyEvent { code: KeyCode.Enter, modifiers: KeyModifiers.none() })
            case 0x7f: return Event.Key(KeyEvent { code: KeyCode.Backspace, modifiers: KeyModifiers.none() })
            case 0x09: return Event.Key(KeyEvent { code: KeyCode.Tab, modifiers: KeyModifiers.none() })
            case ch:
                return Event.Key(KeyEvent {
                    code: KeyCode.Char(ch as char),
                    modifiers: KeyModifiers.none()
                })

    fn apply_patches_to_tree(tree: &ElementTree, patches: &PatchSet) -> ElementTree:
        # Apply each patch operation to the tree
        # Note: Modifies tree in-place since Simple uses reference semantics
        for patch in patches.iter():
            apply_single_patch(tree, patch)
        return tree


# Apply a single patch operation to the element tree
fn apply_single_patch(tree: &ElementTree, patch: &PatchOp):
    match patch:
        case SetText { node_id, text }:
            if val Some(elem) = find_element_mut(tree, node_id):
                elem.text = Some(text)

        case SetAttr { node_id, name, value }:
            if val Some(elem) = find_element_mut(tree, node_id):
                elem.attrs.insert(name, value)

        case RemoveAttr { node_id, name }:
            if val Some(elem) = find_element_mut(tree, node_id):
                elem.attrs.remove(name)

        case AddClass { node_id, class }:
            if val Some(elem) = find_element_mut(tree, node_id):
                if not elem.classes.contains(class):
                    elem.classes.push(class)

        case RemoveClass { node_id, class }:
            if val Some(elem) = find_element_mut(tree, node_id):
                elem.classes = elem.classes.filter(fn(c): c != class)

        case SetStyle { node_id, property, value }:
            if val Some(elem) = find_element_mut(tree, node_id):
                elem.styles.insert(property, value)

        case RemoveStyle { node_id, property }:
            if val Some(elem) = find_element_mut(tree, node_id):
                elem.styles.remove(property)

        case InsertChild { parent_id, index, element }:
            if val Some(parent) = find_element_mut(tree, parent_id):
                val idx = index as i64
                if idx >= parent.children.len() as i64:
                    parent.children.push(element)
                else:
                    parent.children.insert(idx, element)

        case RemoveChild { parent_id, child_id }:
            if val Some(parent) = find_element_mut(tree, parent_id):
                parent.children = parent.children.filter(fn(c): c.id != child_id)

        case ReplaceChild { parent_id, old_id, element }:
            if val Some(parent) = find_element_mut(tree, parent_id):
                for i in 0..parent.children.len():
                    if parent.children[i].id == old_id:
                        parent.children[i] = element
                        break

        case MoveChild { parent_id, child_id, from_index, to_index }:
            if val Some(parent) = find_element_mut(tree, parent_id):
                val from_i = from_index as i64
                val to_i = to_index as i64
                if from_i < parent.children.len() as i64:
                    val child = parent.children.remove(from_i)
                    if to_i >= parent.children.len() as i64:
                        parent.children.push(child)
                    else:
                        parent.children.insert(to_i, child)

        case ReplaceSubtree { node_id, element }:
            # Find parent and replace the subtree
            replace_subtree_recursive(&mut tree.root, node_id, element)

        case SetFocus { node_id }:
            tree.set_focus(node_id)

        case ClearFocus { node_id }:
            if tree.focus_id == Some(node_id):
                tree.focus_id = None
            if val Some(elem) = find_element_mut(tree, node_id):
                elem.focused = false

        case BindEvent { node_id, event, handler_id }:
            if val Some(elem) = find_element_mut(tree, node_id):
                elem.events.insert(event, handler_id)

        case UnbindEvent { node_id, event }:
            if val Some(elem) = find_element_mut(tree, node_id):
                elem.events.remove(event)


# Find element by ID (mutable reference via tree traversal)
fn find_element_mut(tree: &ElementTree, id: NodeId) -> Option<&Element>:
    return find_element_in_subtree(&mut tree.root, id)


fn find_element_in_subtree(elem: &mut Element, id: NodeId) -> Option<&Element>:
    if elem.id == id:
        return Some(elem)
    for child in &mut elem.children:
        match find_element_in_subtree(child, id):
            case Some(found): return Some(found)
            case None: pass
    return None


fn replace_subtree_recursive(elem: &mut Element, target_id: NodeId, replacement: Element) -> bool:
    # Check if this element is the target
    if elem.id == target_id:
        # Can't replace root from within, caller handles this
        return false

    # Check children
    for i in 0..elem.children.len():
        if elem.children[i].id == target_id:
            elem.children[i] = replacement
            return true
        # Recurse into child
        if replace_subtree_recursive(&mut elem.children[i], target_id, replacement):
            return true

    return false

# =============================================================================
# Terminal Buffer (Double Buffering)
# =============================================================================

struct TerminalBuffer:
    width: u16
    height: u16
    cells: Array<Cell>

impl TerminalBuffer:
    fn new(width: u16, height: u16) -> TerminalBuffer:
        val size = (width * height) as u64
        var cells: Array<Cell> = []
        for _ in 0..size:
            cells.push(Cell.default())

        return TerminalBuffer {
            width: width,
            height: height,
            cells: cells
        }

    fn clear():
        for cell in &mut self.cells:
            *cell = Cell.default()

    fn get_cell(x: u16, y: u16) -> &Cell:
        if x >= self.width or y >= self.height:
            # Return default cell for out-of-bounds
            return &Cell.default()

        val idx = (y * self.width + x) as u64
        return &self.cells[idx]

    fn set_cell(x: u16, y: u16, cell: Cell):
        if x >= self.width or y >= self.height:
            return

        val idx = (y * self.width + x) as u64
        self.cells[idx] = cell

struct Cell:
    ch: char
    fg: Color
    bg: Color

impl Cell:
    fn new(ch: char, fg: Color, bg: Color) -> Cell:
        return Cell { ch: ch, fg: fg, bg: bg }

    static fn default() -> Cell:
        return Cell {
            ch: ' ',
            fg: Color.Default,
            bg: Color.Default
        }

impl Eq for Cell:
    fn eq(other: &Cell) -> bool:
        return self.ch == other.ch and self.fg == other.fg and self.bg == other.bg

# =============================================================================
# Terminal FFI (OS-specific)
# =============================================================================

# Terminal API functions (implemented via FFI to termios/Windows Console API)

extern async fn terminal_get_fd() -> Future<i32>
extern async fn terminal_enter_raw_mode(fd: i32) -> Future<()>
extern async fn terminal_exit_raw_mode(fd: i32) -> Future<()>
extern async fn terminal_get_size(fd: i32) -> Future<(u16, u16)>
extern async fn terminal_write(fd: i32, data: &str) -> Future<()>
extern async fn terminal_flush(fd: i32) -> Future<()>
extern async fn terminal_poll_input(fd: i32, timeout_ms: u64) -> Future<Option<Array<u8>>>

# Supporting types
struct Rect:
    x: f32
    y: f32
    width: f32
    height: f32

struct LayoutResult:
    bounds: Dict<u64, Rect>

impl LayoutResult:
    static fn default() -> LayoutResult:
        return LayoutResult { bounds: Dict.new() }

struct LayoutCache:
    cache: Dict<u64, Layout>

impl LayoutCache:
    static fn new() -> LayoutCache:
        return LayoutCache { cache: Dict.new() }
