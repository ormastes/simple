# Interactive - Checkbox, Select, Slider, RadioGroup Widgets
#
# Checkbox, Select, Slider, and RadioGroup widget implementations.
# Part of the interactive module - see interactive.spl for ButtonVariant,
# Button, and TextField.

use core.*
use ui.element.*
use ui.widget.*

pub struct Checkbox:
    checked: bool
    label: text
    on_change: Option<fn(bool)>
    disabled: bool

impl Checkbox:
    # Create a new checkbox
    pub fn new(label: &str) -> Checkbox:
        return Checkbox {
            checked: false,
            label: label.to_string(),
            on_change: None,
            disabled: false
        }

    # Set checked state
    pub fn checked(mut self, checked: bool) -> Checkbox:
        self.checked = checked
        return self

    # Set change handler
    pub fn on_change(mut self, handler: fn(bool)) -> Checkbox:
        self.on_change = Some(handler)
        return self

    # Set disabled state
    pub fn disabled(mut self, value: bool) -> Checkbox:
        self.disabled = value
        return self

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_checked(self) -> bool:
        """Check if checkbox is checked.

        Returns:
            true if checked

        Example:
            checkbox.is_checked()  # → false
        """
        return self.checked

    pub fn is_unchecked(self) -> bool:
        """Check if checkbox is unchecked.

        Returns:
            true if not checked

        Example:
            checkbox.is_unchecked()  # → true
        """
        return not self.checked

    pub fn has_change_handler(self) -> bool:
        """Check if change handler is set.

        Returns:
            true if on_change is set

        Example:
            checkbox.has_change_handler()  # → false
        """
        return self.on_change.is_some()

    pub fn is_disabled(self) -> bool:
        """Check if disabled.

        Returns:
            true if disabled

        Example:
            checkbox.is_disabled()  # → false
        """
        return self.disabled

    pub fn get_label(self) -> &text:
        """Get checkbox label.

        Returns:
            Label string

        Example:
            checkbox.get_label()  # → "Accept terms"
        """
        return &self.label

    pub fn summary(self) -> text:
        """Get checkbox summary.

        Returns:
            Human-readable summary

        Example:
            checkbox.summary()
            # → "Checkbox: 'Accept terms', checked=false, disabled=false"
        """
        return "Checkbox: '{self.label}', checked={self.checked}, disabled={self.disabled}"

impl Widget for Checkbox:
    fn build(ctx: &mut BuildContext) -> WidgetNode:
        val id = ctx.alloc_id()
        var elem = Element.new(id, ElementKind.Checkbox)
            .with_class("checkbox")
            .with_attr("type", "checkbox")

        if self.checked:
            elem = elem.with_attr("checked", "true")

        if self.disabled:
            elem = elem.with_attr("disabled", "true")

        # Wrap with label
        val label_id = ctx.alloc_id()
        var label = Element.new(label_id, ElementKind.Div)
            .with_class("checkbox-wrapper")
            .with_child(elem)
            .with_child(
                Element.text(ctx.alloc_id(), &self.label)
                    .with_class("checkbox-label")
            )

        # Register change handler
        if val Some(_) = &self.on_change:
            label = label.on_event("change", 0)  # Placeholder handler ID

        return WidgetNode.new(label)

# Select - Dropdown selection widget
pub struct Select:
    options: Array<(text, text)>  # (value, label) pairs
    selected: Option<text>
    placeholder: text
    on_change: Option<fn(text)>
    disabled: bool

impl Select:
    # Create a new select widget
    pub fn new() -> Select:
        return Select {
            options: [],
            selected: None,
            placeholder: text.new(),
            on_change: None,
            disabled: false
        }

    # Add an option
    pub fn option(mut self, value: &str, label: &str) -> Select:
        self.options.push((value.to_string(), label.to_string()))
        return self

    # Set options from array
    pub fn options(mut self, options: Array<(text, text)>) -> Select:
        self.options = options
        return self

    # Set selected value
    pub fn selected(mut self, value: &str) -> Select:
        self.selected = Some(value.to_string())
        return self

    # Set placeholder
    pub fn placeholder(mut self, placeholder: &str) -> Select:
        self.placeholder = placeholder.to_string()
        return self

    # Set change handler
    pub fn on_change(mut self, handler: fn(text)) -> Select:
        self.on_change = Some(handler)
        return self

    # Set disabled state
    pub fn disabled(mut self, value: bool) -> Select:
        self.disabled = value
        return self

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_options(self) -> bool:
        """Check if select has options.

        Returns:
            true if options exist

        Example:
            select.has_options()  # → true
        """
        return not self.options.is_empty()

    pub fn option_count(self) -> u64:
        """Get number of options.

        Returns:
            Count of options

        Example:
            select.option_count()  # → 3
        """
        return self.options.len()

    pub fn has_selected(self) -> bool:
        """Check if a value is selected.

        Returns:
            true if selected is set

        Example:
            select.has_selected()  # → false
        """
        return self.selected.is_some()

    pub fn has_placeholder(self) -> bool:
        """Check if placeholder is set.

        Returns:
            true if placeholder not empty

        Example:
            select.has_placeholder()  # → true
        """
        return not self.placeholder.is_empty()

    pub fn has_change_handler(self) -> bool:
        """Check if change handler is set.

        Returns:
            true if on_change is set

        Example:
            select.has_change_handler()  # → false
        """
        return self.on_change.is_some()

    pub fn is_disabled(self) -> bool:
        """Check if disabled.

        Returns:
            true if disabled

        Example:
            select.is_disabled()  # → false
        """
        return self.disabled

    pub fn summary(self) -> text:
        """Get select summary.

        Returns:
            Human-readable summary

        Example:
            select.summary()
            # → "Select: options=3, selected=Some, disabled=false"
        """
        val opts = self.option_count()
        val sel = if self.has_selected() { "Some" } else { "None" }
        return "Select: options={opts}, selected={sel}, disabled={self.disabled}"

impl Widget for Select:
    fn build(ctx: &mut BuildContext) -> WidgetNode:
        val id = ctx.alloc_id()
        var elem = Element.new(id, ElementKind.Select)
            .with_class("select")

        if self.disabled:
            elem = elem.with_attr("disabled", "true")

        # Add placeholder option
        if not self.placeholder.is_empty():
            val placeholder_opt = Element.new(ctx.alloc_id(), ElementKind.Div)
                .with_attr("value", "")
                .with_attr("disabled", "true")
                .with_attr("selected", "true")
                .with_text(&self.placeholder)
            elem = elem.with_child(placeholder_opt)

        # Add options
        for (value, label) in &self.options:
            var option = Element.new(ctx.alloc_id(), ElementKind.Div)
                .with_attr("value", value)
                .with_text(label)

            if val Some(selected) = &self.selected:
                if selected == value:
                    option = option.with_attr("selected", "true")

            elem = elem.with_child(option)

        # Register change handler
        if val Some(_) = &self.on_change:
            elem = elem.on_event("change", 0)  # Placeholder handler ID

        return WidgetNode.new(elem)

# Slider - Range input widget
pub struct Slider:
    value: f64
    min: f64
    max: f64
    step: f64
    on_change: Option<fn(f64)>
    disabled: bool

impl Slider:
    # Create a new slider
    pub fn new(value: f64) -> Slider:
        return Slider {
            value: value,
            min: 0.0,
            max: 100.0,
            step: 1.0,
            on_change: None,
            disabled: false
        }

    # Set min value
    pub fn min(mut self, min: f64) -> Slider:
        self.min = min
        return self

    # Set max value
    pub fn max(mut self, max: f64) -> Slider:
        self.max = max
        return self

    # Set step increment
    pub fn step(mut self, step: f64) -> Slider:
        self.step = step
        return self

    # Set change handler
    pub fn on_change(mut self, handler: fn(f64)) -> Slider:
        self.on_change = Some(handler)
        return self

    # Set disabled state
    pub fn disabled(mut self, value: bool) -> Slider:
        self.disabled = value
        return self

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_change_handler(self) -> bool:
        """Check if change handler is set.

        Returns:
            true if on_change is set

        Example:
            slider.has_change_handler()  # → false
        """
        return self.on_change.is_some()

    pub fn is_disabled(self) -> bool:
        """Check if disabled.

        Returns:
            true if disabled

        Example:
            slider.is_disabled()  # → false
        """
        return self.disabled

    pub fn get_value(self) -> f64:
        """Get current value.

        Returns:
            Current value

        Example:
            slider.get_value()  # → 50.0
        """
        return self.value

    pub fn get_min(self) -> f64:
        """Get minimum value.

        Returns:
            Minimum value

        Example:
            slider.get_min()  # → 0.0
        """
        return self.min

    pub fn get_max(self) -> f64:
        """Get maximum value.

        Returns:
            Maximum value

        Example:
            slider.get_max()  # → 100.0
        """
        return self.max

    pub fn get_step(self) -> f64:
        """Get step increment.

        Returns:
            Step value

        Example:
            slider.get_step()  # → 1.0
        """
        return self.step

    pub fn get_range(self) -> (f64, f64):
        """Get range as (min, max) tuple.

        Returns:
            Tuple of (min, max)

        Example:
            slider.get_range()  # → (0.0, 100.0)
        """
        return (self.min, self.max)

    pub fn is_at_min(self) -> bool:
        """Check if value is at minimum.

        Returns:
            true if value equals min

        Example:
            slider.is_at_min()  # → false
        """
        return self.value == self.min

    pub fn is_at_max(self) -> bool:
        """Check if value is at maximum.

        Returns:
            true if value equals max

        Example:
            slider.is_at_max()  # → false
        """
        return self.value == self.max

    pub fn summary(self) -> text:
        """Get slider summary.

        Returns:
            Human-readable summary

        Example:
            slider.summary()
            # → "Slider: value=50.0, range=[0.0-100.0], step=1.0, disabled=false"
        """
        return "Slider: value={self.value}, range=[{self.min}-{self.max}], step={self.step}, disabled={self.disabled}"

impl Widget for Slider:
    fn build(ctx: &mut BuildContext) -> WidgetNode:
        val id = ctx.alloc_id()
        var elem = Element.new(id, ElementKind.Input)
            .with_class("slider")
            .with_attr("type", "range")
            .with_attr("value", &self.value.to_string())
            .with_attr("min", &self.min.to_string())
            .with_attr("max", &self.max.to_string())
            .with_attr("step", &self.step.to_string())

        if self.disabled:
            elem = elem.with_attr("disabled", "true")

        # Register change handler
        if val Some(_) = &self.on_change:
            elem = elem.on_event("input", 0)  # Placeholder handler ID

        return WidgetNode.new(elem)

# Radio - Radio button group widget
pub struct RadioGroup:
    name: text
    options: Array<(text, text)>  # (value, label) pairs
    selected: Option<text>
    on_change: Option<fn(text)>
    disabled: bool

impl RadioGroup:
    # Create a new radio group
    pub fn new(name: &str) -> RadioGroup:
        return RadioGroup {
            name: name.to_string(),
            options: [],
            selected: None,
            on_change: None,
            disabled: false
        }

    # Add an option
    pub fn option(mut self, value: &str, label: &str) -> RadioGroup:
        self.options.push((value.to_string(), label.to_string()))
        return self

    # Set selected value
    pub fn selected(mut self, value: &str) -> RadioGroup:
        self.selected = Some(value.to_string())
        return self

    # Set change handler
    pub fn on_change(mut self, handler: fn(text)) -> RadioGroup:
        self.on_change = Some(handler)
        return self

    # Set disabled state
    pub fn disabled(mut self, value: bool) -> RadioGroup:
        self.disabled = value
        return self

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_options(self) -> bool:
        """Check if radio group has options.

        Returns:
            true if options exist

        Example:
            radiogroup.has_options()  # → true
        """
        return not self.options.is_empty()

    pub fn option_count(self) -> u64:
        """Get number of options.

        Returns:
            Count of options

        Example:
            radiogroup.option_count()  # → 3
        """
        return self.options.len()

    pub fn has_selected(self) -> bool:
        """Check if a value is selected.

        Returns:
            true if selected is set

        Example:
            radiogroup.has_selected()  # → false
        """
        return self.selected.is_some()

    pub fn has_change_handler(self) -> bool:
        """Check if change handler is set.

        Returns:
            true if on_change is set

        Example:
            radiogroup.has_change_handler()  # → false
        """
        return self.on_change.is_some()

    pub fn is_disabled(self) -> bool:
        """Check if disabled.

        Returns:
            true if disabled

        Example:
            radiogroup.is_disabled()  # → false
        """
        return self.disabled

    pub fn get_name(self) -> &text:
        """Get radio group name.

        Returns:
            Name string

        Example:
            radiogroup.get_name()  # → "gender"
        """
        return &self.name

    pub fn get_selected(self) -> Option<&text>:
        """Get selected value if any.

        Returns:
            Selected value or None

        Example:
            radiogroup.get_selected()  # → Some("male")
        """
        return self.selected.as_ref()

    pub fn is_selected(self, value: &str) -> bool:
        """Check if specific value is selected.

        Args:
            value: Value to check

        Returns:
            true if value is selected

        Example:
            radiogroup.is_selected("male")  # → true
        """
        match &self.selected:
            case Some(sel): return sel == value
            case None: return false

    pub fn summary(self) -> text:
        """Get radio group summary.

        Returns:
            Human-readable summary

        Example:
            radiogroup.summary()
            # → "RadioGroup: name='gender', options=2, selected=Some, disabled=false"
        """
        val opts = self.option_count()
        val sel = if self.has_selected() { "Some" } else { "None" }
        return "RadioGroup: name='{self.name}', options={opts}, selected={sel}, disabled={self.disabled}"

impl Widget for RadioGroup:
    fn build(ctx: &mut BuildContext) -> WidgetNode:
        val id = ctx.alloc_id()
        var group = Element.new(id, ElementKind.Div)
            .with_class("radio-group")

        # Create radio buttons
        for (value, label) in &self.options:
            val radio_id = ctx.alloc_id()
            var radio = Element.new(radio_id, ElementKind.Radio)
                .with_attr("type", "radio")
                .with_attr("name", &self.name)
                .with_attr("value", value)

            if val Some(selected) = &self.selected:
                if selected == value:
                    radio = radio.with_attr("checked", "true")

            if self.disabled:
                radio = radio.with_attr("disabled", "true")

            # Wrap with label
            val wrapper = Element.new(ctx.alloc_id(), ElementKind.Div)
                .with_class("radio-wrapper")
                .with_child(radio)
                .with_child(
                    Element.text(ctx.alloc_id(), label)
                        .with_class("radio-label")
                )

            group = group.with_child(wrapper)

        # Register change handler
        if val Some(_) = &self.on_change:
            group = group.on_event("change", 0)  # Placeholder handler ID

        return WidgetNode.new(group)
