# Layout - Layout Widgets (Column, Row, Stack, Container, Grid)
#
# Provides composable layout widgets using the builder pattern.
# Based on: doc/research/ui_framework_unified.md

use core.*
use ui.element.*
use ui.widget.*

# Column - Vertical flex container
pub struct Column:
    children: Array<Box<Widget>>
    spacing: i32
    align: Align
    padding: EdgeInsets

impl Column:
    # Create a new column
    pub fn new() -> Column:
        return Column {children: [], spacing: 0, align: Align.Start, padding: EdgeInsets.zero()}

    # Set spacing between children
    pub fn spacing(mut self, px: i32) -> Column:
        self.spacing = px
        return self

    # Set cross-axis alignment
    pub fn align(mut self, align: Align) -> Column:
        self.align = align
        return self

    # Set padding
    pub fn padding(mut self, insets: EdgeInsets) -> Column:
        self.padding = insets
        return self

    # Add a child widget
    pub fn child(mut self, widget: impl Widget) -> Column:
        self.children.push(Box.new(widget))
        return self

    # Add multiple children
    pub fn children(mut self, widgets: Array<Box<Widget>>) -> Column:
        for widget in widgets:
            self.children.push(widget)
        return self

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_children(self) -> bool:
        """Check if column has children.

        Returns:
            true if children exist

        Example:
            column.has_children()  # → true
        """
        return not self.children.is_empty()

    pub fn child_count(self) -> u64:
        """Get number of children.

        Returns:
            Count of children

        Example:
            column.child_count()  # → 3
        """
        return self.children.len()

    pub fn has_spacing(self) -> bool:
        """Check if spacing is set.

        Returns:
            true if spacing > 0

        Example:
            column.has_spacing()  # → false
        """
        return self.spacing > 0

    pub fn has_padding(self) -> bool:
        """Check if padding is set.

        Returns:
            true if any padding

        Example:
            column.has_padding()  # → false
        """
        return not (self.padding.top == 0 and self.padding.right == 0 and
                    self.padding.bottom == 0 and self.padding.left == 0)

    pub fn summary(self) -> text:
        """Get column summary.

        Returns:
            Human-readable summary

        Example:
            column.summary()  # → "Column: children=3, spacing=8"
        """
        val count = self.child_count()
        return "Column: children={count}, spacing={self.spacing}"

impl Widget for Column:
    fn build(ctx: &mut BuildContext) -> WidgetNode:
        val id = ctx.alloc_id()
        var elem = Element.new(id, ElementKind.Column)
            .with_class("flex flex-col")

        # Apply alignment
        val align_items = match self.align:
            case Align.Start: "flex-start"
            case Align.Center: "center"
            case Align.End: "flex-end"
            case Align.Stretch: "stretch"

        elem = elem
            .with_style("display", "flex")
            .with_style("flex-direction", "column")
            .with_style("align-items", align_items)

        # Apply spacing
        if self.spacing > 0:
            elem = elem.with_style("gap", &"{self.spacing}px")

        # Apply padding
        if not (self.padding.top == 0 and self.padding.right == 0 and
                self.padding.bottom == 0 and self.padding.left == 0):
            elem = elem.with_style("padding", &self.padding.to_css())

        # Build children
        var child_ctx = ctx.with_parent(id)
        for child in &self.children:
            val child_node = child.build(&mut child_ctx)
            elem = elem.with_child(child_node.to_element())

        return WidgetNode.new(elem)

# Row - Horizontal flex container
pub struct Row:
    children: Array<Box<Widget>>
    spacing: i32
    justify: Justify
    align: Align
    padding: EdgeInsets

impl Row:
    # Create a new row
    pub fn new() -> Row:
        return Row {
            children: [],
            spacing: 0,
            justify: Justify.Start,
            align: Align.Center,
            padding: EdgeInsets.zero()
        }

    # Set spacing between children
    pub fn spacing(mut self, px: i32) -> Row:
        self.spacing = px
        return self

    # Set main-axis justification
    pub fn justify(mut self, justify: Justify) -> Row:
        self.justify = justify
        return self

    # Set cross-axis alignment
    pub fn align(mut self, align: Align) -> Row:
        self.align = align
        return self

    # Set padding
    pub fn padding(mut self, insets: EdgeInsets) -> Row:
        self.padding = insets
        return self

    # Add a child widget
    pub fn child(mut self, widget: impl Widget) -> Row:
        self.children.push(Box.new(widget))
        return self

    # Add multiple children
    pub fn children(mut self, widgets: Array<Box<Widget>>) -> Row:
        for widget in widgets:
            self.children.push(widget)
        return self

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_children(self) -> bool:
        """Check if row has children.

        Returns:
            true if children exist

        Example:
            row.has_children()  # → true
        """
        return not self.children.is_empty()

    pub fn child_count(self) -> u64:
        """Get number of children.

        Returns:
            Count of children

        Example:
            row.child_count()  # → 4
        """
        return self.children.len()

    pub fn has_spacing(self) -> bool:
        """Check if spacing is set.

        Returns:
            true if spacing > 0

        Example:
            row.has_spacing()  # → true
        """
        return self.spacing > 0

    pub fn has_padding(self) -> bool:
        """Check if padding is set.

        Returns:
            true if any padding

        Example:
            row.has_padding()  # → false
        """
        return not (self.padding.top == 0 and self.padding.right == 0 and
                    self.padding.bottom == 0 and self.padding.left == 0)

    pub fn summary(self) -> text:
        """Get row summary.

        Returns:
            Human-readable summary

        Example:
            row.summary()  # → "Row: children=4, spacing=16"
        """
        val count = self.child_count()
        return "Row: children={count}, spacing={self.spacing}"

impl Widget for Row:
    fn build(ctx: &mut BuildContext) -> WidgetNode:
        val id = ctx.alloc_id()
        var elem = Element.new(id, ElementKind.Row)
            .with_class("flex flex-row")

        # Apply justification
        val justify_content = match self.justify:
            case Justify.Start: "flex-start"
            case Justify.Center: "center"
            case Justify.End: "flex-end"
            case Justify.SpaceBetween: "space-between"
            case Justify.SpaceAround: "space-around"
            case Justify.SpaceEvenly: "space-evenly"

        # Apply alignment
        val align_items = match self.align:
            case Align.Start: "flex-start"
            case Align.Center: "center"
            case Align.End: "flex-end"
            case Align.Stretch: "stretch"

        elem = elem
            .with_style("display", "flex")
            .with_style("flex-direction", "row")
            .with_style("justify-content", justify_content)
            .with_style("align-items", align_items)

        # Apply spacing
        if self.spacing > 0:
            elem = elem.with_style("gap", &"{self.spacing}px")

        # Apply padding
        if not (self.padding.top == 0 and self.padding.right == 0 and
                self.padding.bottom == 0 and self.padding.left == 0):
            elem = elem.with_style("padding", &self.padding.to_css())

        # Build children
        var child_ctx = ctx.with_parent(id)
        for child in &self.children:
            val child_node = child.build(&mut child_ctx)
            elem = elem.with_child(child_node.to_element())

        return WidgetNode.new(elem)

# Stack - Layered/absolute positioned container
pub struct Stack:
    children: Array<Box<Widget>>
    alignment: Alignment

impl Stack:
    # Create a new stack
    pub fn new() -> Stack:
        return Stack {
            children: [],
            alignment: Alignment.TopLeft
        }

    # Set alignment for children
    pub fn alignment(mut self, alignment: Alignment) -> Stack:
        self.alignment = alignment
        return self

    # Add a child widget
    pub fn child(mut self, widget: impl Widget) -> Stack:
        self.children.push(Box.new(widget))
        return self

    # Add multiple children
    pub fn children(mut self, widgets: Array<Box<Widget>>) -> Stack:
        for widget in widgets:
            self.children.push(widget)
        return self

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_children(self) -> bool:
        """Check if stack has children.

        Returns:
            true if children exist

        Example:
            stack.has_children()  # → true
        """
        return not self.children.is_empty()

    pub fn child_count(self) -> u64:
        """Get number of children (layers).

        Returns:
            Count of children

        Example:
            stack.child_count()  # → 2
        """
        return self.children.len()

    pub fn summary(self) -> text:
        """Get stack summary.

        Returns:
            Human-readable summary

        Example:
            stack.summary()  # → "Stack: layers=2"
        """
        val count = self.child_count()
        return "Stack: layers={count}"

impl Widget for Stack:
    fn build(ctx: &mut BuildContext) -> WidgetNode:
        val id = ctx.alloc_id()
        var elem = Element.new(id, ElementKind.Div)
            .with_class("stack")
            .with_style("position", "relative")

        # Build children with absolute positioning
        var child_ctx = ctx.with_parent(id)
        for child in &self.children:
            val child_node = child.build(&mut child_ctx)
            var child_elem = child_node.to_element()

            # Apply absolute positioning
            child_elem = child_elem.with_style("position", "absolute")

            # Apply alignment
            match self.alignment:
                case Alignment.TopLeft:
                    child_elem = child_elem
                        .with_style("top", "0")
                        .with_style("left", "0")
                case Alignment.TopCenter:
                    child_elem = child_elem
                        .with_style("top", "0")
                        .with_style("left", "50%")
                        .with_style("transform", "translateX(-50%)")
                case Alignment.TopRight:
                    child_elem = child_elem
                        .with_style("top", "0")
                        .with_style("right", "0")
                case Alignment.CenterLeft:
                    child_elem = child_elem
                        .with_style("top", "50%")
                        .with_style("left", "0")
                        .with_style("transform", "translateY(-50%)")
                case Alignment.Center:
                    child_elem = child_elem
                        .with_style("top", "50%")
                        .with_style("left", "50%")
                        .with_style("transform", "translate(-50%, -50%)")
                case Alignment.CenterRight:
                    child_elem = child_elem
                        .with_style("top", "50%")
                        .with_style("right", "0")
                        .with_style("transform", "translateY(-50%)")
                case Alignment.BottomLeft:
                    child_elem = child_elem
                        .with_style("bottom", "0")
                        .with_style("left", "0")
                case Alignment.BottomCenter:
                    child_elem = child_elem
                        .with_style("bottom", "0")
                        .with_style("left", "50%")
                        .with_style("transform", "translateX(-50%)")
                case Alignment.BottomRight:
                    child_elem = child_elem
                        .with_style("bottom", "0")
                        .with_style("right", "0")

            elem = elem.with_child(child_elem)

        return WidgetNode.new(elem)

