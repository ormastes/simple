# Interactive - Interactive Widgets (Button, TextField, Checkbox, Select, Slider)
#
# Provides interactive form and control widgets using the builder pattern.
# Based on: doc/research/ui_framework_unified.md

use core.*
use ui.element.*
use ui.widget.*

# Button variants
pub enum ButtonVariant:
    Primary
    Secondary
    Outlined
    Text
    Icon

impl ButtonVariant:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_primary(self) -> bool:
        """Check if primary variant.

        Returns:
            true for Primary

        Example:
            variant.is_primary()  # → true
        """
        match self:
            case Primary: return true
            case _: return false

    pub fn is_secondary(self) -> bool:
        """Check if secondary variant.

        Returns:
            true for Secondary

        Example:
            variant.is_secondary()  # → false
        """
        match self:
            case Secondary: return true
            case _: return false

    pub fn is_outlined(self) -> bool:
        """Check if outlined variant.

        Returns:
            true for Outlined

        Example:
            variant.is_outlined()  # → false
        """
        match self:
            case Outlined: return true
            case _: return false

    pub fn is_text(self) -> bool:
        """Check if text variant.

        Returns:
            true for Text

        Example:
            variant.is_text()  # → false
        """
        match self:
            case Text: return true
            case _: return false

    pub fn is_icon(self) -> bool:
        """Check if icon variant.

        Returns:
            true for Icon

        Example:
            variant.is_icon()  # → false
        """
        match self:
            case Icon: return true
            case _: return false

    pub fn to_string(self) -> text:
        """Convert to string.

        Returns:
            Variant name

        Example:
            variant.to_string()  # → "Primary"
        """
        match self:
            case Primary: return "Primary"
            case Secondary: return "Secondary"
            case Outlined: return "Outlined"
            case Text: return "Text"
            case Icon: return "Icon"

    pub fn description(self) -> text:
        """Get button variant description.

        Returns:
            Human-readable description

        Example:
            ButtonVariant.Primary.description()
            # → "Primary button (most important action)"
        """
        match self:
            case Primary: return "Primary button (most important action)"
            case Secondary: return "Secondary button (less prominent)"
            case Outlined: return "Outlined button (border only)"
            case Text: return "Text button (minimal styling)"
            case Icon: return "Icon button (icon only)"

    pub fn summary(self) -> text:
        """Get button variant summary.

        Returns:
            Human-readable summary

        Example:
            ButtonVariant.Primary.summary()
            # → "ButtonVariant: Primary (Primary button (most important action))"
        """
        val name = self.to_string()
        val desc = self.description()
        return "ButtonVariant: {name} ({desc})"

# Button - Clickable button widget
pub struct Button:
    label: text
    icon: Option<text>
    on_click: Option<fn()>
    variant: ButtonVariant
    disabled: bool
    full_width: bool

impl Button:
    # Create a new button with label
    pub fn new(label: &str) -> Button:
        return Button {
            label: label.to_string(),
            icon: None,
            on_click: None,
            variant: ButtonVariant.Primary,
            disabled: false,
            full_width: false
        }

    # Set button icon
    pub fn icon(mut self, icon: &str) -> Button:
        self.icon = Some(icon.to_string())
        return self

    # Set click handler
    pub fn on_click(mut self, handler: fn()) -> Button:
        self.on_click = Some(handler)
        return self

    # Set variant
    pub fn variant(mut self, variant: ButtonVariant) -> Button:
        self.variant = variant
        return self

    # Make button secondary
    pub fn secondary(mut self) -> Button:
        self.variant = ButtonVariant.Secondary
        return self

    # Make button outlined
    pub fn outlined(mut self) -> Button:
        self.variant = ButtonVariant.Outlined
        return self

    # Make button text-only
    pub fn text(mut self) -> Button:
        self.variant = ButtonVariant.Text
        return self

    # Set disabled state
    pub fn disabled(mut self, value: bool) -> Button:
        self.disabled = value
        return self

    # Make button full width
    pub fn full_width(mut self) -> Button:
        self.full_width = true
        return self

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_icon(self) -> bool:
        """Check if button has an icon.

        Returns:
            true if icon is set

        Example:
            button.has_icon()  # → false
        """
        return self.icon.is_some()

    pub fn has_click_handler(self) -> bool:
        """Check if click handler is set.

        Returns:
            true if on_click is set

        Example:
            button.has_click_handler()  # → true
        """
        return self.on_click.is_some()

    pub fn is_disabled(self) -> bool:
        """Check if button is disabled.

        Returns:
            true if disabled

        Example:
            button.is_disabled()  # → false
        """
        return self.disabled

    pub fn is_full_width(self) -> bool:
        """Check if button is full width.

        Returns:
            true if full width

        Example:
            button.is_full_width()  # → false
        """
        return self.full_width

    pub fn get_label(self) -> &text:
        """Get button label.

        Returns:
            Label string

        Example:
            button.get_label()  # → "Submit"
        """
        return &self.label

    pub fn summary(self) -> text:
        """Get button summary.

        Returns:
            Human-readable summary

        Example:
            button.summary()
            # → "Button: 'Submit', variant=Primary, disabled=false"
        """
        val variant = self.variant.to_string()
        return "Button: '{self.label}', variant={variant}, disabled={self.disabled}"

impl Widget for Button:
    fn build(ctx: &mut BuildContext) -> WidgetNode:
        val id = ctx.alloc_id()
        var elem = Element.button(id, &self.label)

        # Apply variant classes
        val variant_class = match self.variant:
            case ButtonVariant.Primary: "btn-primary"
            case ButtonVariant.Secondary: "btn-secondary"
            case ButtonVariant.Outlined: "btn-outlined"
            case ButtonVariant.Text: "btn-text"
            case ButtonVariant.Icon: "btn-icon"

        elem = elem
            .with_class("btn")
            .with_class(variant_class)

        # Apply full width
        if self.full_width:
            elem = elem
                .with_class("btn-full-width")
                .with_style("width", "100%")

        # Apply disabled state
        if self.disabled:
            elem = elem.with_attr("disabled", "true")

        # Register click handler
        if val Some(handler) = &self.on_click:
            # In a real implementation, this would register the handler
            # with the event system and assign a unique ID
            elem = elem.on_event("click", 0)  # Placeholder handler ID

        return WidgetNode.new(elem)

# TextField - Text input widget
pub struct TextField:
    value: text
    placeholder: text
    on_change: Option<fn(text)>
    on_submit: Option<fn(text)>
    multiline: bool
    max_length: Option<u32>
    disabled: bool
    password: bool
    autofocus: bool

impl TextField:
    # Create a new text field
    pub fn new() -> TextField:
        return TextField {
            value: text.new(),
            placeholder: text.new(),
            on_change: None,
            on_submit: None,
            multiline: false,
            max_length: None,
            disabled: false,
            password: false,
            autofocus: false
        }

    # Set initial value
    pub fn value(mut self, value: &str) -> TextField:
        self.value = value.to_string()
        return self

    # Set placeholder text
    pub fn placeholder(mut self, placeholder: &str) -> TextField:
        self.placeholder = placeholder.to_string()
        return self

    # Set change handler
    pub fn on_change(mut self, handler: fn(text)) -> TextField:
        self.on_change = Some(handler)
        return self

    # Set submit handler (Enter key)
    pub fn on_submit(mut self, handler: fn(text)) -> TextField:
        self.on_submit = Some(handler)
        return self

    # Make multiline (textarea)
    pub fn multiline(mut self) -> TextField:
        self.multiline = true
        return self

    # Set max length
    pub fn max_length(mut self, length: u32) -> TextField:
        self.max_length = Some(length)
        return self

    # Set disabled state
    pub fn disabled(mut self, value: bool) -> TextField:
        self.disabled = value
        return self

    # Make password field
    pub fn password(mut self) -> TextField:
        self.password = true
        return self

    # Enable autofocus
    pub fn autofocus(mut self) -> TextField:
        self.autofocus = true
        return self

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_value(self) -> bool:
        """Check if field has a value.

        Returns:
            true if value is not empty

        Example:
            textfield.has_value()  # → false
        """
        return not self.value.is_empty()

    pub fn has_placeholder(self) -> bool:
        """Check if placeholder is set.

        Returns:
            true if placeholder is not empty

        Example:
            textfield.has_placeholder()  # → true
        """
        return not self.placeholder.is_empty()

    pub fn has_change_handler(self) -> bool:
        """Check if change handler is set.

        Returns:
            true if on_change is set

        Example:
            textfield.has_change_handler()  # → false
        """
        return self.on_change.is_some()

    pub fn has_submit_handler(self) -> bool:
        """Check if submit handler is set.

        Returns:
            true if on_submit is set

        Example:
            textfield.has_submit_handler()  # → false
        """
        return self.on_submit.is_some()

    pub fn is_multiline(self) -> bool:
        """Check if multiline (textarea).

        Returns:
            true if multiline

        Example:
            textfield.is_multiline()  # → false
        """
        return self.multiline

    pub fn is_password(self) -> bool:
        """Check if password field.

        Returns:
            true if password

        Example:
            textfield.is_password()  # → false
        """
        return self.password

    pub fn is_disabled(self) -> bool:
        """Check if disabled.

        Returns:
            true if disabled

        Example:
            textfield.is_disabled()  # → false
        """
        return self.disabled

    pub fn has_autofocus(self) -> bool:
        """Check if autofocus enabled.

        Returns:
            true if autofocus

        Example:
            textfield.has_autofocus()  # → false
        """
        return self.autofocus

    pub fn has_max_length(self) -> bool:
        """Check if max length is set.

        Returns:
            true if max_length is set

        Example:
            textfield.has_max_length()  # → false
        """
        return self.max_length.is_some()

    pub fn get_value(self) -> &text:
        """Get current value.

        Returns:
            Value string

        Example:
            textfield.get_value()  # → "Hello"
        """
        return &self.value

    pub fn summary(self) -> text:
        """Get textfield summary.

        Returns:
            Human-readable summary

        Example:
            textfield.summary()
            # → "TextField: multiline=false, password=false, disabled=false"
        """
        return "TextField: multiline={self.multiline}, password={self.password}, disabled={self.disabled}"

impl Widget for TextField:
    fn build(ctx: &mut BuildContext) -> WidgetNode:
        val id = ctx.alloc_id()
        var elem = Element.input(id)
        if self.multiline:
            elem = elem.with_attr("type", "textarea")
        else:
            val input_type = ""
            if self.password:
                input_type = "password"
            else:
                input_type = "text"
            elem = elem.with_attr("type", input_type)

        elem = elem
            .with_class("text-field")
            .with_attr("value", &self.value)
            .with_attr("placeholder", &self.placeholder)

        # Apply max length
        if val Some(max_len) = self.max_length:
            elem = elem.with_attr("maxlength", &max_len.to_string())

        # Apply disabled state
        if self.disabled:
            elem = elem.with_attr("disabled", "true")

        # Apply autofocus
        if self.autofocus:
            elem = elem.with_attr("autofocus", "true")

        # Register handlers
        if val Some(_) = &self.on_change:
            elem = elem.on_event("input", 0)  # Placeholder handler ID
        if val Some(_) = &self.on_submit:
            elem = elem.on_event("submit", 0)  # Placeholder handler ID

        return WidgetNode.new(elem)

# Checkbox - Boolean toggle widget
