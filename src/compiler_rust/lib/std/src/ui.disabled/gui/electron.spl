# Electron Renderer - Desktop App Backend
#
# Extends Browser renderer with native desktop capabilities via Electron.
# Combines DOM rendering (shared with Browser backend) with Node.js integration
# for file system, IPC, system tray, notifications, and power management.
#
# Key Features:
#   - All Browser backend features (DOM manipulation, events)
#   - IPC (Inter-Process Communication) between main and renderer
#   - Native file dialogs and system integration
#   - System tray and notifications
#   - Power management events
#   - Clipboard access
#   - Auto-update support

use core.*
use concurrency.*
use ui.element.*
use ui.attrs.*
use ui.patchset.*
use ui.renderer.*
use ui.gui.browser.*  # Extend Browser renderer

# =============================================================================
# Electron Async Renderer (Browser + Native)
# =============================================================================

pub struct ElectronRenderer:
    # Reuse browser rendering
    browser_renderer: BrowserRenderer

    # Electron-specific state
    ipc_handlers: Dict<text, IpcCallback>
    window_id: u32
    is_main_window: bool

    # Native features
    system_tray: Option<SystemTray>
    power_monitor: PowerMonitor
    clipboard: Clipboard

    # Settings
    enable_node_integration: bool
    context_isolation: bool

impl ElectronRenderer:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_main_window(self) -> bool:
        """Check if this is the main window."""
        self.is_main_window

    pub fn has_system_tray(self) -> bool:
        """Check if system tray is created."""
        match self.system_tray:
            case Some(_): true
            case None: false

    pub fn has_ipc_handlers(self) -> bool:
        """Check if any IPC handlers are registered."""
        self.ipc_handlers.len() > 0

    pub fn ipc_handler_count(self) -> usize:
        """Get number of IPC handlers."""
        self.ipc_handlers.len()

    pub fn has_node_integration(self) -> bool:
        """Check if Node integration is enabled."""
        self.enable_node_integration

    pub fn has_context_isolation(self) -> bool:
        """Check if context isolation is enabled."""
        self.context_isolation

    pub fn is_secure_config(self) -> bool:
        """Check if running with secure configuration (no Node integration, with context isolation)."""
        not self.enable_node_integration and self.context_isolation

    pub fn summary(self) -> text:
        """Get summary of Electron renderer state."""
        val main = if self.is_main_window: "main" else: "child"
        val tray = if self.has_system_tray(): "yes" else: "no"
        return "ElectronRenderer: window_id={self.window_id} ({main}), tray={tray}, {self.ipc_handler_count()} IPC handlers"

    # =========================================================================
    # Constructor
    # =========================================================================

    # Create a new Electron renderer
    pub fn new(root_element_id: &str, window_id: u32) -> Result<ElectronRenderer, RenderError>:
        val browser = BrowserRenderer.new(root_element_id)?

        return Ok(ElectronRenderer {
            browser_renderer: browser,
            ipc_handlers: Dict.new(),
            window_id: window_id,
            is_main_window: window_id == 1,
            system_tray: None,
            power_monitor: PowerMonitor.new(),
            clipboard: Clipboard.new(),
            enable_node_integration: false,  # Security best practice
            context_isolation: true
        })

# =============================================================================
# Async RenderBackend Implementation (Delegate to Browser)
# =============================================================================

impl RenderBackend for ElectronRenderer:
    async fn init(self) -> Future<Result<(), RenderError>>:
        # Initialize browser renderer
        await self.browser_renderer.init()

        # Set up Electron-specific features
        await self.setup_ipc()
        await self.setup_power_monitor()

        # Check if running in Electron environment
        val is_electron = await electron_is_available()
        if not is_electron:
            return Future.ready(Err(RenderError.IoError(
                "Not running in Electron environment"
            )))

        return Future.ready(Ok(()))

    async fn shutdown(self) -> Future<Result<(), RenderError>>:
        # Cleanup Electron resources
        await self.cleanup_ipc()
        if val Some(tray) = &self.system_tray:
            await tray.destroy()

        # Shutdown browser renderer
        await self.browser_renderer.shutdown()

        return Future.ready(Ok(()))

    fn dimensions() -> (u16, u16):
        return self.browser_renderer.dimensions()

    async fn render(self, tree: &ElementTree) -> Future<Result<(), RenderError>>:
        # Delegate to browser renderer
        return await self.browser_renderer.render(tree)

    async fn apply_patches(self, patches: &PatchSet) -> Future<Result<(), RenderError>>:
        # Delegate to browser renderer
        return await self.browser_renderer.apply_patches(patches)

    async fn clear(self) -> Future<Result<(), RenderError>>:
        return await self.browser_renderer.clear()

    async fn flush(self) -> Future<Result<(), RenderError>>:
        return await self.browser_renderer.flush()

    async fn poll_event(self, timeout_ms: u64) -> Future<Result<Option<Event>, RenderError>>:
        # Check for IPC events first
        val ipc_event = await self.poll_ipc_event()
        if ipc_event.is_some():
            return Future.ready(Ok(ipc_event))

        # Fall back to browser events
        return await self.browser_renderer.poll_event(timeout_ms)

    async fn read_event(self) -> Future<Result<Event, RenderError>>:
        loop:
            match await self.poll_event(1000):
                case Ok(Some(event)): return Future.ready(Ok(event))
                case Ok(None): pass
                case Err(e): return Future.ready(Err(e))

# =============================================================================
# Electron-Specific Features
# =============================================================================

impl ElectronRenderer:
    # IPC Setup
    async fn setup_ipc(self) -> Future<()>:
        # Register renderer â†’ main IPC channel
        await electron_ipc_on("main-message", |event, args| {
            self.handle_main_message(args)
        })

        # Send ready signal to main process
        await electron_ipc_send("renderer-ready", [self.window_id])

        return Future.ready(())

    async fn cleanup_ipc(self) -> Future<()>:
        await electron_ipc_remove_all_listeners("main-message")
        return Future.ready(())

    # IPC Event Handling
    async fn poll_ipc_event(self) -> Future<Option<Event>>:
        # Check if there are pending IPC events
        # (In real implementation, this would use an event queue)
        return Future.ready(None)

    fn handle_main_message(args: Array<Any>):
        # Handle messages from main process
        if args.is_empty():
            return

        val message_type = args[0].to_string()
        match message_type:
            case "quit":
                # Main process requesting quit
                self.dispatch_event(Event.Quit)
            case "reload":
                # Reload requested
                electron_reload_window()
            case _:
                # Custom message - dispatch as custom event
                pass

    fn dispatch_event(&mut self, event: Event):
        # Push event to the browser renderer's event queue for poll_event/read_event
        self.browser_renderer.push_event(event)

    # Power Monitor
    async fn setup_power_monitor(self) -> Future<()>:
        await self.power_monitor.on_suspend(|| {self.dispatch_event(Event.PowerSuspend)})

        await self.power_monitor.on_resume(|| {
            self.dispatch_event(Event.PowerResume)
        })

        await self.power_monitor.on_battery(|| {
            self.dispatch_event(Event.BatteryPower)
        })

        return Future.ready(())

    # System Tray
    pub async fn create_system_tray(self, icon_path: &str, tooltip: &str)
        -> Future<Result<(), RenderError>>:
        val tray = await SystemTray.new(icon_path, tooltip)
        self.system_tray = Some(tray)
        return Future.ready(Ok(()))

    pub fn get_system_tray(self) -> Option<&SystemTray>:
        return self.system_tray.as_ref()

    # Native Dialogs
    pub async fn show_open_dialog(self, options: OpenDialogOptions)
        -> Future<Result<Option<Array<text>>, RenderError>>:
        val result = await electron_show_open_dialog(self.window_id, options)
        return Future.ready(Ok(result))

    pub async fn show_save_dialog(self, options: SaveDialogOptions)
        -> Future<Result<Option<text>, RenderError>>:
        val result = await electron_show_save_dialog(self.window_id, options)
        return Future.ready(Ok(result))

    pub async fn show_message_box(self, options: MessageBoxOptions)
        -> Future<Result<u32, RenderError>>:
        val button_index = await electron_show_message_box(self.window_id, options)
        return Future.ready(Ok(button_index))

    # Clipboard
    pub fn read_clipboard_text(self) -> text:
        return self.clipboard.read_text()

    pub fn write_clipboard_text(self, text: &str):
        self.clipboard.write_text(text)

    pub fn read_clipboard_image(self) -> Option<Image>:
        return self.clipboard.read_image()

    # Window Management
    pub async fn set_window_title(self, title: &str) -> Future<()>:
        await electron_set_window_title(self.window_id, title)
        return Future.ready(())

    pub async fn set_window_size(self, width: u32, height: u32) -> Future<()>:
        await electron_set_window_size(self.window_id, width, height)
        return Future.ready(())

    pub async fn maximize_window(self) -> Future<()>:
        await electron_maximize_window(self.window_id)
        return Future.ready(())

    pub async fn minimize_window(self) -> Future<()>:
        await electron_minimize_window(self.window_id)
        return Future.ready(())

    pub async fn close_window(self) -> Future<()>:
        await electron_close_window(self.window_id)
        return Future.ready(())

    # Notifications
    pub async fn show_notification(self, options: NotificationOptions) -> Future<()>:
        await electron_show_notification(options)
        return Future.ready(())

# =============================================================================
