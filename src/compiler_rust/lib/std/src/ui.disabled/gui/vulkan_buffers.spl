# Vulkan Buffers - Vertex, Index Buffers
#
# Vertex, index, and uniform buffer management for graphics pipeline.
# Supports both graphics and compute use cases.
#
# See vulkan_buffers_ops.spl for UniformBuffer, StorageBuffer, FFI, and constants.

use core.*
use ui.gui.vulkan_types.*

# =============================================================================
# Buffer Types
# =============================================================================

pub enum BufferUsage:
    Vertex          # Vertex buffer
    Index           # Index buffer
    Uniform         # Uniform buffer (UBO)
    Storage         # Storage buffer (SSBO)
    TransferSrc     # Source for transfer
    TransferDst     # Destination for transfer

impl BufferUsage:
    pub fn to_string(self) -> text:
        """Convert buffer usage to string.

        Returns:
            text representation

        Example:
            val usage = BufferUsage.Vertex
            assert(usage.to_string() == "vertex")
        """
        match self:
            case Vertex: return "vertex"
            case Index: return "index"
            case Uniform: return "uniform"
            case Storage: return "storage"
            case TransferSrc: return "transfer_src"
            case TransferDst: return "transfer_dst"

    pub fn description(self) -> text:
        """Get detailed description of buffer usage.

        Returns:
            Human-readable description

        Example:
            val usage = BufferUsage.Uniform
            assert(usage.description().contains("Uniform buffer"))
        """
        match self:
            case Vertex: return "Vertex buffer - stores vertex attributes (position, normal, color, etc.)"
            case Index: return "Index buffer - stores vertex indices for indexed drawing"
            case Uniform: return "Uniform buffer (UBO) - stores shader uniform data"
            case Storage: return "Storage buffer (SSBO) - stores large read/write data for compute shaders"
            case TransferSrc: return "Transfer source - buffer used as source for copy operations"
            case TransferDst: return "Transfer destination - buffer used as destination for copy operations"

    pub fn is_graphics_buffer(self) -> bool:
        """Check if this is a graphics pipeline buffer.

        Returns:
            True if used in graphics pipeline

        Example:
            assert(BufferUsage.Vertex.is_graphics_buffer())
            assert(not BufferUsage.TransferSrc.is_graphics_buffer())
        """
        match self:
            case Vertex: return true
            case Index: return true
            case Uniform: return true
            case _: return false

    pub fn is_compute_buffer(self) -> bool:
        """Check if this is typically used for compute.

        Returns:
            True if commonly used in compute pipelines

        Example:
            assert(BufferUsage.Storage.is_compute_buffer())
            assert(not BufferUsage.Vertex.is_compute_buffer())
        """
        match self:
            case Storage: return true
            case Uniform: return true
            case _: return false

    pub fn is_transfer_buffer(self) -> bool:
        """Check if this is a transfer operation buffer.

        Returns:
            True if used for transfers

        Example:
            assert(BufferUsage.TransferSrc.is_transfer_buffer())
            assert(not BufferUsage.Vertex.is_transfer_buffer())
        """
        match self:
            case TransferSrc: return true
            case TransferDst: return true
            case _: return false

    pub fn requires_host_visible(self) -> bool:
        """Check if usage typically requires host-visible memory.

        Returns:
            True if should be CPU-accessible

        Example:
            assert(BufferUsage.Uniform.requires_host_visible())
            assert(not BufferUsage.Vertex.requires_host_visible())
        """
        match self:
            case Uniform: return true
            case TransferSrc: return true
            case _: return false

    pub fn to_vk_flags(self) -> VkBufferUsageFlags:
        """Convert to Vulkan buffer usage flags.

        Returns:
            Vulkan buffer usage bit flags

        Example:
            val usage = BufferUsage.Vertex
            val flags = usage.to_vk_flags()
            assert(flags == VK_BUFFER_USAGE_VERTEX_BUFFER_BIT)
        """
        match self:
            case Vertex: return VK_BUFFER_USAGE_VERTEX_BUFFER_BIT
            case Index: return VK_BUFFER_USAGE_INDEX_BUFFER_BIT
            case Uniform: return VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT
            case Storage: return VK_BUFFER_USAGE_STORAGE_BUFFER_BIT
            case TransferSrc: return VK_BUFFER_USAGE_TRANSFER_SRC_BIT
            case TransferDst: return VK_BUFFER_USAGE_TRANSFER_DST_BIT

# =============================================================================
# Vertex Buffer - GPU-side vertex data storage
# =============================================================================

pub struct VertexBuffer:
    device: VkDevice
    buffer: VkBuffer
    memory: VkDeviceMemory
    size: u64
    vertex_count: u32

impl VertexBuffer:
    # Create vertex buffer from data
    pub fn new<T>(device: &VulkanDevice, vertices: &Array<T>) -> Result<VertexBuffer, text>:
        val size = (vertices.len() * size_of.<T>()) as u64

        # Create staging buffer (CPU-visible)
        val staging_buffer = vulkan_create_buffer(
            device.device,
            size,
            VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
            VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT
        )?

        # Map and copy data to staging
        val data_ptr = vulkan_map_memory(device.device, staging_buffer.memory, 0, size)?
        vulkan_memcpy(data_ptr, vertices.as_ptr(), size)
        vulkan_unmap_memory(device.device, staging_buffer.memory)

        # Create device-local vertex buffer
        val vertex_buffer = vulkan_create_buffer(
            device.device,
            size,
            VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_VERTEX_BUFFER_BIT,
            VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT
        )?

        # Copy from staging to device-local
        vulkan_copy_buffer(device.device, staging_buffer.buffer, vertex_buffer.buffer, size)?

        # Clean up staging buffer
        vulkan_destroy_buffer(device.device, staging_buffer.buffer, staging_buffer.memory)

        Ok(VertexBuffer {device: device.device, buffer: vertex_buffer.buffer, memory: vertex_buffer.memory, size: size, vertex_count: vertices.len() as u32,})

    # Cleanup
    pub async fn destroy(&self):
        await vulkan_destroy_buffer_async(self.device, self.buffer, self.memory)

    pub fn get_size(self) -> u64:
        """Get buffer size in bytes.

        Returns:
            Size in bytes

        Example:
            val vb = VertexBuffer.new(&device, &vertices)?
            val size = vb.get_size()
        """
        self.size

    pub fn get_vertex_count(self) -> u32:
        """Get number of vertices in buffer.

        Returns:
            Vertex count

        Example:
            val vb = VertexBuffer.new(&device, &vertices)?
            assert(vb.get_vertex_count() == vertices.len() as u32)
        """
        self.vertex_count

    pub fn is_empty(self) -> bool:
        """Check if buffer is empty.

        Returns:
            True if no vertices

        Example:
            val vb = VertexBuffer.new(&device, &empty_array)?
            assert(vb.is_empty())
        """
        self.vertex_count == 0

    pub fn bytes_per_vertex(self) -> u64:
        """Calculate bytes per vertex.

        Returns:
            Average bytes per vertex

        Example:
            val vb = VertexBuffer.new(&device, &vertices)?
            val bpv = vb.bytes_per_vertex()
        """
        if self.vertex_count == 0:
            return 0
        self.size / (self.vertex_count as u64)

    pub fn is_large(self) -> bool:
        """Check if this is a large buffer (>1MB).

        Returns:
            True if buffer exceeds 1MB

        Example:
            val vb = VertexBuffer.new(&device, &large_mesh)?
            if vb.is_large():
                print("Large vertex buffer allocated")
        """
        self.size > 1024 * 1024

    pub fn summary(self) -> text:
        """Get vertex buffer summary.

        Returns:
            Human-readable summary

        Example:
            val vb = VertexBuffer.new(&device, &vertices)?
            print(vb.summary())
        """
        val kb = self.size / 1024
        val bpv = self.bytes_per_vertex()
        return "VertexBuffer: {self.vertex_count} vertices, {kb} KB ({bpv} bytes/vertex)"

# =============================================================================
# Index Buffer - GPU-side index data storage
# =============================================================================

pub struct IndexBuffer:
    device: VkDevice
    buffer: VkBuffer
    memory: VkDeviceMemory
    size: u64
    index_count: u32
    index_type: VkIndexType

impl IndexBuffer:
    # Create index buffer from u16 indices
    pub fn new_u16(device: &VulkanDevice, indices: &Array<u16>) -> Result<IndexBuffer, text>:
        Self.new_impl(device, indices, VK_INDEX_TYPE_UINT16)

    # Create index buffer from u32 indices
    pub fn new_u32(device: &VulkanDevice, indices: &Array<u32>) -> Result<IndexBuffer, text>:
        Self.new_impl(device, indices, VK_INDEX_TYPE_UINT32)

    # Internal implementation
    fn new_impl<T>(device: &VulkanDevice, indices: &Array<T>, index_type: VkIndexType) -> Result<IndexBuffer, text>:
        val size = (indices.len() * size_of.<T>()) as u64

        # Create staging buffer
        val staging_buffer = vulkan_create_buffer(
            device.device,
            size,
            VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
            VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT
        )?

        # Map and copy
        val data_ptr = vulkan_map_memory(device.device, staging_buffer.memory, 0, size)?
        vulkan_memcpy(data_ptr, indices.as_ptr(), size)
        vulkan_unmap_memory(device.device, staging_buffer.memory)

        # Create device-local index buffer
        val index_buffer = vulkan_create_buffer(
            device.device,
            size,
            VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_INDEX_BUFFER_BIT,
            VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT
        )?

        # Copy
        vulkan_copy_buffer(device.device, staging_buffer.buffer, index_buffer.buffer, size)?

        # Clean up staging
        vulkan_destroy_buffer(device.device, staging_buffer.buffer, staging_buffer.memory)

        Ok(IndexBuffer {
            device: device.device,
            buffer: index_buffer.buffer,
            memory: index_buffer.memory,
            size: size,
            index_count: indices.len() as u32,
            index_type: index_type,
        })

    # Cleanup
    pub async fn destroy(&self):
        await vulkan_destroy_buffer_async(self.device, self.buffer, self.memory)

    pub fn get_size(self) -> u64:
        """Get buffer size in bytes.

        Returns:
            Size in bytes

        Example:
            val ib = IndexBuffer.new_u16(&device, &indices)?
            val size = ib.get_size()
        """
        self.size

    pub fn get_index_count(self) -> u32:
        """Get number of indices in buffer.

        Returns:
            Index count

        Example:
            val ib = IndexBuffer.new_u32(&device, &indices)?
            assert(ib.get_index_count() == indices.len() as u32)
        """
        self.index_count

    pub fn get_index_type(self) -> VkIndexType:
        """Get index type (u16 or u32).

        Returns:
            Vulkan index type

        Example:
            val ib = IndexBuffer.new_u16(&device, &indices)?
            assert(ib.get_index_type() == VK_INDEX_TYPE_UINT16)
        """
        self.index_type

    pub fn is_empty(self) -> bool:
        """Check if buffer is empty.

        Returns:
            True if no indices

        Example:
            val ib = IndexBuffer.new_u16(&device, &empty)?
            assert(ib.is_empty())
        """
        self.index_count == 0

    pub fn is_u16(self) -> bool:
        """Check if using 16-bit indices.

        Returns:
            True if using u16 indices

        Example:
            val ib = IndexBuffer.new_u16(&device, &indices)?
            assert(ib.is_u16())
        """
        self.index_type == VK_INDEX_TYPE_UINT16

    pub fn is_u32(self) -> bool:
        """Check if using 32-bit indices.

        Returns:
            True if using u32 indices

        Example:
            val ib = IndexBuffer.new_u32(&device, &indices)?
            assert(ib.is_u32())
        """
        self.index_type == VK_INDEX_TYPE_UINT32

    pub fn bytes_per_index(self) -> u64:
        """Get bytes per index.

        Returns:
            2 for u16, 4 for u32

        Example:
            val ib = IndexBuffer.new_u16(&device, &indices)?
            assert(ib.bytes_per_index() == 2)
        """
        if self.index_type == VK_INDEX_TYPE_UINT16:
            return 2
        else:
            return 4

    pub fn triangle_count(self) -> u32:
        """Calculate number of triangles.

        Returns:
            Number of triangles (indices / 3)

        Example:
            val ib = IndexBuffer.new_u16(&device, &indices)?
            val tris = ib.triangle_count()
        """
        self.index_count / 3

    pub fn is_large(self) -> bool:
        """Check if this is a large buffer (>1MB).

        Returns:
            True if buffer exceeds 1MB

        Example:
            val ib = IndexBuffer.new_u32(&device, &large_mesh)?
            if ib.is_large():
                print("Large index buffer allocated")
        """
        self.size > 1024 * 1024

    pub fn summary(self) -> text:
        """Get index buffer summary.

        Returns:
            Human-readable summary

        Example:
            val ib = IndexBuffer.new_u16(&device, &indices)?
            print(ib.summary())
        """
        val kb = self.size / 1024
        val index_type = if self.is_u16(): "u16" else: "u32"
        val tris = self.triangle_count()
        return "IndexBuffer: {self.index_count} {index_type} indices, {kb} KB ({tris} triangles)"

