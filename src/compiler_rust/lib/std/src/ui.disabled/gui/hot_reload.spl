# Hot Reload Support for GUI Applications
#
# Provides hot module reloading for GUI applications without losing state.
# Monitors source files for changes and reloads UI components on the fly.
#
# Key Features:
#   - File watching: Detects changes to .spl and .sui files
#   - State preservation: Maintains application state across reloads
#   - Incremental updates: Only reloads changed components
#   - Error recovery: Graceful handling of compilation errors
#   - Socket-based communication: Live connection to dev server
#
# Usage:
#   val hot_reload = HotReload.new("./src")
#   hot_reload.watch()?
#
#   loop:
#       if val Some(update) = hot_reload.poll_update():
#           app.apply_update(update)
#       app.render()
#
# See hot_reload_apply.spl for implementation, file system monitoring,
# error types, and FFI declarations.

use core.*
use concurrency.*
use host.async_nogc_mut.io.fs.*
use host.async_nogc_mut.net.tcp.*

# =============================================================================
# Hot Reload Manager
# =============================================================================

pub struct HotReload:
    # Watch configuration
    watch_paths: Array<text>
    ignore_patterns: Array<text>

    # File system monitoring
    file_watcher: FileWatcher
    last_modified: Dict<text, u64>  # path -> timestamp

    # Update queue
    pending_updates: Array<HotUpdate>

    # State preservation
    state_snapshot: Option<StateSnapshot>
    preserve_state: bool

    # Socket connection to dev server
    dev_server: Option<TcpClient>
    server_addr: text

    # Status
    watching: bool
    last_error: Option<text>

impl HotReload:
    pub fn is_watching(self) -> bool:
        """Check if currently watching files."""
        self.watching

    pub fn has_pending_updates(self) -> bool:
        """Check if there are pending updates."""
        self.pending_updates.len() > 0

    pub fn pending_update_count(self) -> usize:
        """Get number of pending updates."""
        self.pending_updates.len()

    pub fn has_state_snapshot(self) -> bool:
        """Check if state snapshot exists."""
        match self.state_snapshot:
            case Some(_): true
            case None: false

    pub fn is_state_preserved(self) -> bool:
        """Check if state preservation is enabled."""
        self.preserve_state

    pub fn has_dev_server(self) -> bool:
        """Check if dev server connection exists."""
        match self.dev_server:
            case Some(_): true
            case None: false

    pub fn has_error(self) -> bool:
        """Check if there's a last error."""
        match self.last_error:
            case Some(_): true
            case None: false

    pub fn watch_path_count(self) -> usize:
        """Get number of watched paths."""
        self.watch_paths.len()

    pub fn ignore_pattern_count(self) -> usize:
        """Get number of ignore patterns."""
        self.ignore_patterns.len()

    pub fn tracked_file_count(self) -> usize:
        """Get number of tracked files."""
        self.last_modified.len()

    pub fn summary(self) -> text:
        """Get summary of hot reload state."""
        val status = if self.watching: "watching" else: "stopped"
        return "HotReload: {status}, {self.watch_path_count()} paths, {self.tracked_file_count()} files, {self.pending_update_count()} pending"

# Hot reload update
pub struct HotUpdate:
    kind: UpdateKind
    file_path: text
    content: Option<text>
    timestamp: u64

impl HotUpdate:
    pub fn has_content(self) -> bool:
        """Check if content is loaded."""
        match self.content:
            case Some(_): true
            case None: false

    pub fn is_component_reload(self) -> bool:
        """Check if this is a component reload."""
        match self.kind:
            case UpdateKind.ComponentReload: true
            case _: false

    pub fn is_module_reload(self) -> bool:
        """Check if this is a module reload."""
        match self.kind:
            case UpdateKind.ModuleReload: true
            case _: false

    pub fn is_style_update(self) -> bool:
        """Check if this is a style update."""
        match self.kind:
            case UpdateKind.StyleUpdate: true
            case _: false

    pub fn is_asset_update(self) -> bool:
        """Check if this is an asset update."""
        match self.kind:
            case UpdateKind.AssetUpdate: true
            case _: false

    pub fn summary(self) -> text:
        """Get summary of hot update."""
        val has_content = if self.has_content(): "with content" else: "no content"
        return "HotUpdate: {self.kind.to_string()} '{self.file_path}' ({has_content})"

pub enum UpdateKind:
    ComponentReload  # UI component (.sui)
    ModuleReload     # Code module (.spl)
    StyleUpdate      # Style changes (CSS/theme)
    AssetUpdate      # Asset file (image, font, etc.)

impl UpdateKind:
    pub fn to_string(self) -> text:
        """Convert to string representation."""
        match self:
            case ComponentReload: return "ComponentReload"
            case ModuleReload: return "ModuleReload"
            case StyleUpdate: return "StyleUpdate"
            case AssetUpdate: return "AssetUpdate"

    pub fn description(self) -> text:
        """Get description of update kind."""
        match self:
            case ComponentReload: return "UI component reload (.sui)"
            case ModuleReload: return "Code module reload (.spl)"
            case StyleUpdate: return "Style changes (CSS/theme)"
            case AssetUpdate: return "Asset file update (image, font, etc.)"

    pub fn is_component_reload(self) -> bool:
        """Check if this is component reload."""
        match self:
            case ComponentReload: true
            case _: false

    pub fn is_module_reload(self) -> bool:
        """Check if this is module reload."""
        match self:
            case ModuleReload: true
            case _: false

    pub fn is_code_change(self) -> bool:
        """Check if this is a code change (component or module)."""
        match self:
            case ComponentReload: true
            case ModuleReload: true
            case _: false

    pub fn summary(self) -> text:
        """Get update kind summary.

        Returns:
            Human-readable summary

        Example:
            UpdateKind.ComponentReload.summary()
            # â†’ "UpdateKind: ComponentReload (UI component reload (.sui), code change)"
        """
        val name = self.to_string()
        val desc = self.description()
        val category = if self.is_code_change(): "code change" else: "asset change"
        return "UpdateKind: {name} ({desc}, {category})"

# State snapshot for preservation
struct StateSnapshot:
    component_states: Dict<text, ComponentState>
    global_state: Dict<text, Any>
    timestamp: u64

impl StateSnapshot:
    pub fn has_component_states(self) -> bool:
        """Check if any component states exist."""
        self.component_states.len() > 0

    pub fn has_global_state(self) -> bool:
        """Check if any global state exists."""
        self.global_state.len() > 0

    pub fn component_count(self) -> usize:
        """Get number of component states."""
        self.component_states.len()

    pub fn summary(self) -> text:
        """Get summary of state snapshot."""
        return "StateSnapshot: {self.component_count()} components, timestamp={self.timestamp}"

struct ComponentState:
    component_id: text
    props: Dict<text, Any>
    local_state: Dict<text, Any>

impl ComponentState:
    pub fn has_props(self) -> bool:
        """Check if component has props."""
        self.props.len() > 0

    pub fn has_local_state(self) -> bool:
        """Check if component has local state."""
        self.local_state.len() > 0

    pub fn summary(self) -> text:
        """Get summary of component state."""
        return "ComponentState: id='{self.component_id}', {self.props.len()} props, {self.local_state.len()} local state"

# File watcher
struct FileWatcher:
    watched_files: Dict<text, FileMetadata>
    poll_interval_ms: u64

impl FileWatcher:
    pub fn file_count(self) -> usize:
        """Get number of watched files."""
        self.watched_files.len()

    pub fn has_files(self) -> bool:
        """Check if any files are watched."""
        self.watched_files.len() > 0

    pub fn summary(self) -> text:
        """Get summary of file watcher."""
        return "FileWatcher: {self.file_count()} files, poll interval={self.poll_interval_ms}ms"

struct FileMetadata:
    path: text
    size: u64
    modified: u64
    hash: u64

impl FileMetadata:
    pub fn summary(self) -> text:
        """Get summary of file metadata."""
        return "FileMetadata: '{self.path}', size={self.size}, modified={self.modified}"

# TCP client for dev server
struct TcpClient:
    socket: TcpStream
    connected: bool

impl TcpClient:
    pub fn is_connected(self) -> bool:
        """Check if client is connected."""
        self.connected

    pub fn summary(self) -> text:
        """Get summary of TCP client."""
        val status = if self.connected: "connected" else: "disconnected"
        return "TcpClient: {status}"
