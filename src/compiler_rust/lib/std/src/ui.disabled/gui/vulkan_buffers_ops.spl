# Vulkan Buffers - Uniform/Storage Buffers, FFI, and Types
#
# UniformBuffer, StorageBuffer, FFI declarations, Vulkan constants, and
# supporting types (VkBufferMemory).
# Part of the buffers module - see vulkan_buffers.spl for BufferUsage,
# VertexBuffer, and IndexBuffer.

use core.*
use ui.gui.vulkan_types.*

# =============================================================================
# Uniform Buffer - GPU-side uniform data (UBO)
# =============================================================================

pub struct UniformBuffer<T>:
    device: VkDevice
    buffer: VkBuffer
    memory: VkDeviceMemory
    size: u64
    mapped_ptr: Option<*mut u8>  # Persistently mapped

impl UniformBuffer<T>:
    # Create uniform buffer (persistently mapped for easy updates)
    pub fn new(device: &VulkanDevice, initial_data: &T) -> Result<UniformBuffer<T>, text>:
        val size = size_of.<T>() as u64

        # Create host-visible uniform buffer (persistently mapped)
        val uniform_buffer = vulkan_create_buffer(
            device.device,
            size,
            VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT,
            VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT
        )?

        # Map memory (keep mapped)
        val mapped_ptr = vulkan_map_memory(device.device, uniform_buffer.memory, 0, size)?

        # Copy initial data
        vulkan_memcpy(mapped_ptr, initial_data as *const u8, size)

        Ok(UniformBuffer {
            device: device.device,
            buffer: uniform_buffer.buffer,
            memory: uniform_buffer.memory,
            size: size,
            mapped_ptr: Some(mapped_ptr),
        })

    # Update uniform data (no map/unmap needed - already mapped)
    pub fn update(&mut self, data: &T):
        if val Some(ptr) = self.mapped_ptr:
            vulkan_memcpy(ptr, data as *const u8, self.size)

    # Cleanup
    pub async fn destroy(&mut self):
        if val Some(_) = self.mapped_ptr:
            vulkan_unmap_memory(self.device, self.memory)
            self.mapped_ptr = None
        await vulkan_destroy_buffer_async(self.device, self.buffer, self.memory)

    pub fn get_size(self) -> u64:
        """Get buffer size in bytes.

        Returns:
            Size in bytes

        Example:
            val ub = UniformBuffer.new(&device, &mvp_matrix)?
            val size = ub.get_size()
        """
        self.size

    pub fn is_mapped(self) -> bool:
        """Check if buffer is currently mapped.

        Returns:
            True if mapped to CPU memory

        Example:
            val ub = UniformBuffer.new(&device, &data)?
            assert(ub.is_mapped())
        """
        match self.mapped_ptr:
            case Some(_): true
            case None: false

    pub fn can_update(self) -> bool:
        """Check if buffer can be updated.

        Returns:
            True if mapped and ready for updates

        Example:
            var ub = UniformBuffer.new(&device, &data)?
            if ub.can_update():
                ub.update(&new_data)
        """
        self.is_mapped()

    pub fn is_small(self) -> bool:
        """Check if this is a small uniform buffer (<256 bytes).

        Returns:
            True if size is small

        Example:
            val ub = UniformBuffer.new(&device, &small_struct)?
            if ub.is_small():
                print("Small UBO, good for push constants")
        """
        self.size < 256

    pub fn is_large(self) -> bool:
        """Check if this is a large uniform buffer (>16KB).

        Returns:
            True if exceeds typical UBO size

        Example:
            val ub = UniformBuffer.new(&device, &large_struct)?
            if ub.is_large():
                print("Warning: Large UBO, consider using SSBO")
        """
        self.size > 16 * 1024

    pub fn summary(self) -> text:
        """Get uniform buffer summary.

        Returns:
            Human-readable summary

        Example:
            val ub = UniformBuffer.new(&device, &data)?
            print(ub.summary())
        """
        val mapped = if self.is_mapped(): "mapped" else: "unmapped"
        return "UniformBuffer: {self.size} bytes ({mapped})"

# =============================================================================
# Storage Buffer - GPU-side storage buffer (SSBO)
# =============================================================================

pub struct StorageBuffer<T>:
    device: VkDevice
    buffer: VkBuffer
    memory: VkDeviceMemory
    size: u64
    element_count: u32

impl StorageBuffer<T>:
    # Create storage buffer from array
    pub fn new(device: &VulkanDevice, data: &Array<T>) -> Result<StorageBuffer<T>, text>:
        val size = (data.len() * size_of.<T>()) as u64

        # Create staging buffer
        val staging_buffer = vulkan_create_buffer(
            device.device,
            size,
            VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
            VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT
        )?

        # Map and copy
        val data_ptr = vulkan_map_memory(device.device, staging_buffer.memory, 0, size)?
        vulkan_memcpy(data_ptr, data.as_ptr(), size)
        vulkan_unmap_memory(device.device, staging_buffer.memory)

        # Create device-local storage buffer
        val storage_buffer = vulkan_create_buffer(
            device.device,
            size,
            VK_BUFFER_USAGE_TRANSFER_SRC_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_STORAGE_BUFFER_BIT,
            VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT
        )?

        # Copy
        vulkan_copy_buffer(device.device, staging_buffer.buffer, storage_buffer.buffer, size)?

        # Clean up staging
        vulkan_destroy_buffer(device.device, staging_buffer.buffer, staging_buffer.memory)

        Ok(StorageBuffer {
            device: device.device,
            buffer: storage_buffer.buffer,
            memory: storage_buffer.memory,
            size: size,
            element_count: data.len() as u32,
        })

    # Download data from GPU
    pub fn download(&self) -> Result<Array<T>, text>:
        val size = self.size

        # Create staging buffer for readback
        val staging_buffer = vulkan_create_buffer(
            self.device,
            size,
            VK_BUFFER_USAGE_TRANSFER_DST_BIT,
            VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT
        )?

        # Copy from device to staging
        vulkan_copy_buffer(self.device, self.buffer, staging_buffer.buffer, size)?

        # Map and read
        val data_ptr = vulkan_map_memory(self.device, staging_buffer.memory, 0, size)?
        var result: Array<T> = Array.with_capacity(self.element_count as usize)
        vulkan_memcpy(result.as_mut_ptr(), data_ptr, size)
        result.set_len(self.element_count as usize)
        vulkan_unmap_memory(self.device, staging_buffer.memory)

        # Clean up staging
        vulkan_destroy_buffer(self.device, staging_buffer.buffer, staging_buffer.memory)

        Ok(result)

    # Cleanup
    pub async fn destroy(&self):
        await vulkan_destroy_buffer_async(self.device, self.buffer, self.memory)

    pub fn get_size(self) -> u64:
        """Get buffer size in bytes.

        Returns:
            Size in bytes

        Example:
            val sb = StorageBuffer.new(&device, &data)?
            val size = sb.get_size()
        """
        self.size

    pub fn get_element_count(self) -> u32:
        """Get number of elements in buffer.

        Returns:
            Element count

        Example:
            val sb = StorageBuffer.new(&device, &data)?
            assert(sb.get_element_count() == data.len() as u32)
        """
        self.element_count

    pub fn is_empty(self) -> bool:
        """Check if buffer is empty.

        Returns:
            True if no elements

        Example:
            val sb = StorageBuffer.new(&device, &empty)?
            assert(sb.is_empty())
        """
        self.element_count == 0

    pub fn bytes_per_element(self) -> u64:
        """Calculate bytes per element.

        Returns:
            Average bytes per element

        Example:
            val sb = StorageBuffer.new(&device, &data)?
            val bpe = sb.bytes_per_element()
        """
        if self.element_count == 0:
            return 0
        self.size / (self.element_count as u64)

    pub fn is_large(self) -> bool:
        """Check if this is a large buffer (>1MB).

        Returns:
            True if buffer exceeds 1MB

        Example:
            val sb = StorageBuffer.new(&device, &big_data)?
            if sb.is_large():
                print("Large storage buffer allocated")
        """
        self.size > 1024 * 1024

    pub fn is_small(self) -> bool:
        """Check if this is a small buffer (<64KB).

        Returns:
            True if size is small

        Example:
            val sb = StorageBuffer.new(&device, &small_data)?
            if sb.is_small():
                print("Consider using UBO for small data")
        """
        self.size < 64 * 1024

    pub fn can_download(self) -> bool:
        """Check if buffer can be downloaded.

        Returns:
            True (storage buffers support download)

        Example:
            val sb = StorageBuffer.new(&device, &data)?
            if sb.can_download():
                val result = sb.download()?
        """
        true

    pub fn summary(self) -> text:
        """Get storage buffer summary.

        Returns:
            Human-readable summary

        Example:
            val sb = StorageBuffer.new(&device, &data)?
            print(sb.summary())
        """
        val kb = self.size / 1024
        val bpe = self.bytes_per_element()
        return "StorageBuffer: {self.element_count} elements, {kb} KB ({bpe} bytes/element)"

# =============================================================================
# FFI Declarations
# =============================================================================

# Buffer creation/destruction
extern fn vulkan_create_buffer(device: VkDevice, size: u64, usage: VkBufferUsageFlags, properties: VkMemoryPropertyFlags) -> Result<VkBufferMemory, text>
extern fn vulkan_destroy_buffer(device: VkDevice, buffer: VkBuffer, memory: VkDeviceMemory)
extern fn vulkan_destroy_buffer_async(device: VkDevice, buffer: VkBuffer, memory: VkDeviceMemory) -> Future<Result<(), text>>

# Memory operations
extern fn vulkan_map_memory(device: VkDevice, memory: VkDeviceMemory, offset: u64, size: u64) -> Result<*mut u8, text>
extern fn vulkan_unmap_memory(device: VkDevice, memory: VkDeviceMemory)
extern fn vulkan_memcpy(dst: *mut u8, src: *const u8, size: u64)
extern fn vulkan_copy_buffer(device: VkDevice, src: VkBuffer, dst: VkBuffer, size: u64) -> Result<(), text>

# Utility
extern fn size_of<T>() -> usize

# =============================================================================
# Vulkan Constants - Buffer Usage
# =============================================================================

pub const VK_BUFFER_USAGE_TRANSFER_SRC_BIT: u32 = 0x00000001
pub const VK_BUFFER_USAGE_TRANSFER_DST_BIT: u32 = 0x00000002
pub const VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT: u32 = 0x00000010
pub const VK_BUFFER_USAGE_STORAGE_BUFFER_BIT: u32 = 0x00000020
pub const VK_BUFFER_USAGE_INDEX_BUFFER_BIT: u32 = 0x00000040
pub const VK_BUFFER_USAGE_VERTEX_BUFFER_BIT: u32 = 0x00000080

# Memory properties
pub const VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT: u32 = 0x00000001
pub const VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT: u32 = 0x00000002
pub const VK_MEMORY_PROPERTY_HOST_COHERENT_BIT: u32 = 0x00000004

# Index types
pub const VK_INDEX_TYPE_UINT16: u32 = 0
pub const VK_INDEX_TYPE_UINT32: u32 = 1

# =============================================================================
# Supporting Types
# =============================================================================

pub type VkBuffer = i64
pub type VkDeviceMemory = i64
pub type VkBufferUsageFlags = u32
pub type VkMemoryPropertyFlags = u32
pub type VkIndexType = u32

pub struct VkBufferMemory:
    buffer: VkBuffer
    memory: VkDeviceMemory

impl VkBufferMemory:
    pub fn get_buffer(self) -> VkBuffer:
        """Get the Vulkan buffer handle.

        Returns:
            VkBuffer handle

        Example:
            val buf_mem = vulkan_create_buffer(...)?
            val buffer = buf_mem.get_buffer()
        """
        self.buffer

    pub fn get_memory(self) -> VkDeviceMemory:
        """Get the Vulkan device memory handle.

        Returns:
            VkDeviceMemory handle

        Example:
            val buf_mem = vulkan_create_buffer(...)?
            val memory = buf_mem.get_memory()
        """
        self.memory

    pub fn is_valid(self) -> bool:
        """Check if both handles are valid (non-zero).

        Returns:
            True if buffer and memory are valid

        Example:
            val buf_mem = vulkan_create_buffer(...)?
            assert(buf_mem.is_valid())
        """
        self.buffer != 0 and self.memory != 0

    pub fn summary(self) -> text:
        """Get buffer memory summary.

        Returns:
            Human-readable summary

        Example:
            val buf_mem = vulkan_create_buffer(...)?
            print(buf_mem.summary())
        """
        return "VkBufferMemory: buffer={self.buffer}, memory={self.memory}"
