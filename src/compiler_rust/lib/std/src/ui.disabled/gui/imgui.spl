# Immediate Mode GUI - egui-style API
#
# Provides an immediate mode GUI paradigm where UI is rebuilt every frame.
# Simpler mental model than retained mode - no state management needed.
# Integrates with existing renderers (Browser, Electron, VSCode, Native, Vulkan).
#
# Key Features:
#   - Stateless API: UI declared in render loop
#   - Automatic layout: Stacking containers
#   - Built-in widgets: Button, Slider, TextEdit, Checkbox, etc.
#   - Response system: Immediate interaction feedback
#   - No manual event handling: Widget functions return interaction state
#
# Example:
#   loop:
#       val ui = ImGui.new()
#       ui.window("Demo Window"):
#           if ui.button("Click me!"):
#               println("Button clicked!")
#           ui.label("Counter: {}", counter)
#           ui.slider("Value", &mut value, 0.0, 100.0)
#       ui.render(renderer)

use core.*
use concurrency.*
use ui.element.*
use ui.attrs.*
use ui.renderer.*

# =============================================================================
# Draw Commands - Render primitives for ImGui
# =============================================================================

pub enum DrawCommand:
    Rect(x: f32, y: f32, w: f32, h: f32, color: Color)
    RectOutline(x: f32, y: f32, w: f32, h: f32, color: Color, thickness: f32)
    RoundedRect(x: f32, y: f32, w: f32, h: f32, radius: f32, color: Color)
    Text(x: f32, y: f32, content: text, color: Color, size: f32)
    Line(x1: f32, y1: f32, x2: f32, y2: f32, color: Color, thickness: f32)
    Circle(cx: f32, cy: f32, radius: f32, color: Color)
    SetClipRect(x: f32, y: f32, w: f32, h: f32)
    ResetClipRect

pub struct DrawList:
    commands: Array<DrawCommand>

impl DrawList:
    pub static fn new() -> DrawList:
        DrawList { commands: [] }

    pub fn add(&mut self, cmd: DrawCommand):
        self.commands.push(cmd)

    pub fn add_rect(&mut self, x: f32, y: f32, w: f32, h: f32, color: Color):
        self.add(DrawCommand.Rect(x, y, w, h, color))

    pub fn add_rect_outline(&mut self, x: f32, y: f32, w: f32, h: f32, color: Color, thickness: f32):
        self.add(DrawCommand.RectOutline(x, y, w, h, color, thickness))

    pub fn add_rounded_rect(&mut self, x: f32, y: f32, w: f32, h: f32, radius: f32, color: Color):
        self.add(DrawCommand.RoundedRect(x, y, w, h, radius, color))

    pub fn add_text(&mut self, x: f32, y: f32, content: text, color: Color, size: f32):
        self.add(DrawCommand.Text(x, y, content, color, size))

    pub fn add_line(&mut self, x1: f32, y1: f32, x2: f32, y2: f32, color: Color, thickness: f32):
        self.add(DrawCommand.Line(x1, y1, x2, y2, color, thickness))

    pub fn add_circle(&mut self, cx: f32, cy: f32, radius: f32, color: Color):
        self.add(DrawCommand.Circle(cx, cy, radius, color))

    pub fn clear(&mut self):
        self.commands.clear()

    pub fn len(&self) -> usize:
        self.commands.len()

    pub fn is_empty(&self) -> bool:
        self.commands.is_empty()

# =============================================================================
# Immediate Mode GUI Context
# =============================================================================

pub struct ImGui:
    # Render state
    ctx: ImGuiContext
    current_window: Option<WindowState>
    current_container: Option<ContainerId>

    # Layout state
    cursor: Point2D
    layout_stack: Array<LayoutInfo>

    # Interaction state
    hot_id: Option<WidgetId>     # Widget under cursor
    active_id: Option<WidgetId>  # Widget being interacted with
    keyboard_focus: Option<WidgetId>

    # Input state
    mouse_pos: Point2D
    mouse_down: bool
    mouse_clicked: bool
    keys_down: Set<KeyCode>

    # ID generation
    id_stack: Array<u64>
    next_id: u64

    # Draw commands for rendering
    draw_list: DrawList

impl ImGui:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_current_window(self) -> bool:
        """Check if a window is currently active."""
        match self.current_window:
            case Some(_): true
            case None: false

    pub fn has_hot_widget(self) -> bool:
        """Check if a widget is currently hot (under cursor)."""
        match self.hot_id:
            case Some(_): true
            case None: false

    pub fn has_active_widget(self) -> bool:
        """Check if a widget is currently active (being interacted with)."""
        match self.active_id:
            case Some(_): true
            case None: false

    pub fn has_keyboard_focus(self) -> bool:
        """Check if any widget has keyboard focus."""
        match self.keyboard_focus:
            case Some(_): true
            case None: false

    pub fn is_mouse_down(self) -> bool:
        """Check if mouse button is down."""
        self.mouse_down

    pub fn was_mouse_clicked(self) -> bool:
        """Check if mouse was clicked this frame."""
        self.mouse_clicked

    pub fn has_keys_down(self) -> bool:
        """Check if any keys are currently pressed."""
        self.keys_down.len() > 0

    pub fn key_count(self) -> usize:
        """Get number of keys currently pressed."""
        self.keys_down.len()

    pub fn layout_depth(self) -> usize:
        """Get current layout nesting depth."""
        self.layout_stack.len()

    pub fn summary(self) -> text:
        """Get summary of ImGui state."""
        val window = if self.has_current_window(): "yes" else: "no"
        val focus = if self.has_keyboard_focus(): "yes" else: "no"
        return "ImGui: window={window}, focus={focus}, {self.layout_depth()} layout levels"

# Persistent context (survives frames)
struct ImGuiContext:
    windows: Dict<text, WindowState>
    widget_state: Dict<WidgetId, WidgetState>
    last_frame_time: f64
    delta_time: f64

impl ImGuiContext:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_windows(self) -> bool:
        """Check if any windows exist."""
        self.windows.len() > 0

    pub fn has_widget_state(self) -> bool:
        """Check if any widget state exists."""
        self.widget_state.len() > 0

    pub fn window_count(self) -> usize:
        """Get number of windows."""
        self.windows.len()

    pub fn widget_count(self) -> usize:
        """Get number of widgets with state."""
        self.widget_state.len()

    pub fn fps(self) -> f64:
        """Calculate FPS from delta time."""
        if self.delta_time > 0.0:
            1.0 / self.delta_time
        else:
            0.0

    pub fn summary(self) -> text:
        """Get summary of context state."""
        return "ImGuiContext: {self.window_count()} windows, {self.widget_count()} widgets, {self.fps():.1} FPS"

# Window state
struct WindowState:
    id: text
    title: text
    pos: Point2D
    size: Size2D
    collapsed: bool
    focused: bool
    dragging: bool
    drag_offset: Point2D

impl WindowState:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_collapsed(self) -> bool:
        """Check if window is collapsed."""
        self.collapsed

    pub fn is_focused(self) -> bool:
        """Check if window is focused."""
        self.focused

    pub fn is_dragging(self) -> bool:
        """Check if window is being dragged."""
        self.dragging

    pub fn is_expanded(self) -> bool:
        """Check if window is expanded (not collapsed)."""
        not self.collapsed

    pub fn area(self) -> f32:
        """Calculate window area."""
        self.size.width * self.size.height

    pub fn aspect_ratio(self) -> f32:
        """Calculate window aspect ratio."""
        if self.size.height > 0.0:
            self.size.width / self.size.height
        else:
            0.0

    pub fn summary(self) -> text:
        """Get summary of window state."""
        val state = if self.is_collapsed(): "collapsed" else if self.is_dragging(): "dragging" else if self.is_focused(): "focused" else: "normal"
        return "Window '{self.title}': ({self.pos.x}, {self.pos.y}) {self.size.width}x{self.size.height} ({state})"

# Widget identifier (hash-based)
type WidgetId = u64

# Widget state (persistent between frames)
struct WidgetState:
    value: Any  # Stored value (for sliders, inputs, etc.)
    animation: f32  # Animation progress [0.0, 1.0]
    last_interaction: f64

impl WidgetState:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_animating(self) -> bool:
        """Check if widget is animating."""
        self.animation > 0.0 and self.animation < 1.0

    pub fn is_animation_complete(self) -> bool:
        """Check if animation is complete."""
        self.animation >= 1.0

    pub fn animation_progress(self) -> f32:
        """Get animation progress [0.0, 1.0]."""
        self.animation.max(0.0).min(1.0)

    pub fn summary(self) -> text:
        """Get summary of widget state."""
        val anim = if self.is_animating(): "animating" else: "static"
        return "WidgetState: {anim}, animation={self.animation:.2}"

# Container identifier
type ContainerId = u64

# Layout info
struct LayoutInfo:
    direction: LayoutDirection
    spacing: f32
    padding: f32
    available_width: f32
    available_height: f32
    cursor_x: f32
    cursor_y: f32

impl LayoutInfo:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_vertical(self) -> bool:
        """Check if layout direction is vertical."""
        match self.direction:
            case LayoutDirection.Vertical: true
            case _: false

    pub fn is_horizontal(self) -> bool:
        """Check if layout direction is horizontal."""
        match self.direction:
            case LayoutDirection.Horizontal: true
            case _: false

    pub fn available_area(self) -> f32:
        """Calculate available area."""
        self.available_width * self.available_height

    pub fn cursor_position(self) -> Point2D:
        """Get cursor position as Point2D."""
        Point2D.new(self.cursor_x, self.cursor_y)

    pub fn summary(self) -> text:
        """Get summary of layout info."""
        val dir = if self.is_vertical(): "vertical" else: "horizontal"
        return "LayoutInfo: {dir}, {self.available_width}x{self.available_height}, cursor=({self.cursor_x}, {self.cursor_y})"

enum LayoutDirection:
    Vertical
    Horizontal

impl LayoutDirection:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn to_string(self) -> text:
        """Convert to string representation."""
        match self:
            case Vertical: return "vertical"
            case Horizontal: return "horizontal"

    pub fn description(self) -> text:
        """Get description of this layout direction."""
        match self:
            case Vertical: return "Layout stacks elements vertically"
            case Horizontal: return "Layout stacks elements horizontally"

    pub fn is_vertical(self) -> bool:
        """Check if this is vertical layout."""
        match self:
            case Vertical: return true
            case Horizontal: return false

    pub fn is_horizontal(self) -> bool:
        """Check if this is horizontal layout."""
        match self:
            case Horizontal: return true
            case Vertical: return false

# Point in 2D space
struct Point2D:
    x: f32
    y: f32

impl Point2D:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn distance_to(self, other: Point2D) -> f32:
        """Calculate Euclidean distance to another point."""
        val dx = other.x - self.x
        val dy = other.y - self.y
        (dx * dx + dy * dy).sqrt()

    pub fn manhattan_distance(self, other: Point2D) -> f32:
        """Calculate Manhattan distance to another point."""
        (other.x - self.x).abs() + (other.y - self.y).abs()

    pub fn is_zero(self) -> bool:
        """Check if point is at origin."""
        self.x == 0.0 and self.y == 0.0

    pub fn summary(self) -> text:
        """Get summary of point."""
        return "Point2D({self.x}, {self.y})"

    # =========================================================================
    # Constructor
    # =========================================================================

    fn new(x: f32, y: f32) -> Point2D:
        return Point2D { x: x, y: y }

# 2D size
struct Size2D:
    width: f32
    height: f32

impl Size2D:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn area(self) -> f32:
        """Calculate area."""
        self.width * self.height

    pub fn aspect_ratio(self) -> f32:
        """Calculate aspect ratio."""
        if self.height > 0.0:
            self.width / self.height
        else:
            0.0

    pub fn is_landscape(self) -> bool:
        """Check if landscape orientation."""
        self.width > self.height

    pub fn is_portrait(self) -> bool:
        """Check if portrait orientation."""
        self.height > self.width

    pub fn is_square(self) -> bool:
        """Check if square."""
        self.width == self.height

    pub fn is_zero(self) -> bool:
        """Check if both dimensions are zero."""
        self.width == 0.0 and self.height == 0.0

    pub fn summary(self) -> text:
        """Get summary of size."""
        return "Size2D({self.width}x{self.height})"

    # =========================================================================
    # Constructor
    # =========================================================================

    fn new(w: f32, h: f32) -> Size2D:
        return Size2D { width: w, height: h }

# Widget response
pub struct Response:
    id: WidgetId
    rect: Rect
    clicked: bool
    hovered: bool
    dragged: bool
    drag_delta: Point2D
    has_keyboard_focus: bool
    changed: bool  # Value changed (for inputs)

impl Response:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_clicked(self) -> bool:
        """Check if widget was clicked."""
        self.clicked

    pub fn is_hovered(self) -> bool:
        """Check if widget is hovered."""
        self.hovered

    pub fn is_dragged(self) -> bool:
        """Check if widget is being dragged."""
        self.dragged

    pub fn is_focused(self) -> bool:
        """Check if widget has keyboard focus."""
        self.has_keyboard_focus

    pub fn is_changed(self) -> bool:
        """Check if widget value changed."""
        self.changed

    pub fn is_interacted(self) -> bool:
        """Check if widget had any interaction."""
        self.clicked or self.hovered or self.dragged or self.changed

    pub fn drag_magnitude(self) -> f32:
        """Calculate magnitude of drag delta."""
        (self.drag_delta.x * self.drag_delta.x + self.drag_delta.y * self.drag_delta.y).sqrt()

    pub fn summary(self) -> text:
        """Get summary of response state."""
        val states = []
        if self.clicked: states.push("clicked")
        if self.hovered: states.push("hovered")
        if self.dragged: states.push("dragged")
        if self.changed: states.push("changed")
        val state_str = states.join(", ")
        return "Response: {state_str}"

struct Rect:
    x: f32
    y: f32
    width: f32
    height: f32

impl Rect:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn area(self) -> f32:
        """Calculate rectangle area."""
        self.width * self.height

    pub fn aspect_ratio(self) -> f32:
        """Calculate aspect ratio."""
        if self.height > 0.0:
            self.width / self.height
        else:
            0.0

    pub fn center(self) -> Point2D:
        """Get center point of rectangle."""
        Point2D.new(self.x + self.width / 2.0, self.y + self.height / 2.0)

    pub fn is_landscape(self) -> bool:
        """Check if landscape orientation."""
        self.width > self.height

    pub fn is_portrait(self) -> bool:
        """Check if portrait orientation."""
        self.height > self.width

    pub fn is_square(self) -> bool:
        """Check if square."""
        self.width == self.height

    pub fn is_empty(self) -> bool:
        """Check if rectangle has zero area."""
        self.width == 0.0 or self.height == 0.0

    pub fn summary(self) -> text:
        """Get summary of rectangle."""
        return "Rect: ({self.x}, {self.y}) {self.width}x{self.height}"

    # =========================================================================
    # Constructor and Existing Methods
    # =========================================================================

    fn new(x: f32, y: f32, w: f32, h: f32) -> Rect:
        return Rect { x: x, y: y, width: w, height: h }

    fn contains(p: Point2D) -> bool:
        return p.x >= self.x and p.x < self.x + self.width
            and p.y >= self.y and p.y < self.y + self.height

