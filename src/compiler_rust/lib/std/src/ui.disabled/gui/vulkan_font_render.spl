# Vulkan Font - Rendering Helpers, FFI, and Advanced Features
#
# GlyphBitmap, FontMetrics, FFI bindings, text layout helpers,
# and FontWeight enum.
# Part of the font module - see vulkan_font.spl for FontAtlas and GlyphInfo.

use core.*
use ui.gui.vulkan_types.*
use ui.gui.vulkan_buffers.*
use ui.gui.vulkan_font.*

# =============================================================================
# Glyph Bitmap - Rasterized Character Data
# =============================================================================

struct GlyphBitmap:
    pixels: Array<u8>      # RGBA pixel data
    width: u32
    height: u32
    bearing_x: f32         # Horizontal bearing (offset from cursor)
    bearing_y: f32         # Vertical bearing (offset from baseline)
    advance: f32           # How far to advance cursor

# =============================================================================
# Font Metrics
# =============================================================================

struct FontMetrics:
    ascent: f32            # Distance from baseline to top
    descent: f32           # Distance from baseline to bottom (negative)
    line_gap: f32          # Recommended line spacing

# =============================================================================
# Font Loading and Rasterization (FFI)
# =============================================================================

# Load TTF/OTF font file
async fn load_font_file(path: &str) -> Result<Array<u8>, text>:
    # Read font file bytes
    val bytes = await read_file_async(path)?
    Ok(bytes)

# Parse font metrics from font data
fn parse_font_metrics(font_data: &Array<u8>, font_size: u32) -> Result<FontMetrics, text>:
    # Call FFI to parse TTF header and get metrics
    vulkan_parse_font_metrics(font_data, font_size)

# Rasterize a character to a bitmap
fn rasterize_char(font_data: &Array<u8>, ch: char, font_size: u32) -> Result<GlyphBitmap, text>:
    # Call FFI to rasterize character using FreeType or similar
    vulkan_rasterize_char(font_data, ch, font_size)

# =============================================================================
# Vertex Cache Extension for Textured Rendering
# =============================================================================

# Already implemented in vulkan_renderer.spl:
# impl VertexCache:
#     pub fn add_textured_rect(...)

# =============================================================================
# FFI Declarations - Font Operations
# =============================================================================

extern fn read_file_async(path: &str) -> Future<Result<Array<u8>, text>>
extern fn vulkan_parse_font_metrics(font_data: &Array<u8>, font_size: u32) -> Result<FontMetrics, text>
extern fn vulkan_rasterize_char(font_data: &Array<u8>, ch: char, font_size: u32) -> Result<GlyphBitmap, text>

# =============================================================================
# FFI Declarations - Texture Operations
# =============================================================================

extern fn vulkan_create_texture(device: VkDevice, width: u32, height: u32, format: VkFormat) -> Result<VkTexture, text>
extern fn vulkan_upload_texture(device: VkDevice, texture: VkTexture, data: &Array<u8>) -> Result<(), text>
extern fn vulkan_upload_texture_region(device: VkDevice, texture: VkTexture, data: &Array<u8>, x: u32, y: u32, width: u32, height: u32) -> Result<(), text>
extern fn vulkan_destroy_texture_async(device: VkDevice, texture: VkTexture) -> Future<Result<(), text>>

# =============================================================================
# Vulkan Constants
# =============================================================================

pub type VkTexture = i64
pub type VkFormat = u32

pub const VK_FORMAT_R8G8B8A8_UNORM: u32 = 37  # Standard RGBA format

# =============================================================================
# Default Font Fallback
# =============================================================================

impl FontAtlas:
    # Create font atlas with embedded default font
    pub async fn default(device: &VulkanDevice) -> Result<FontAtlas, text>:
        # Use embedded DejaVu Sans or similar free font
        # For now, try to load system font
        val font_paths = [
            "/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf",  # Linux
            "C:\\Windows\\Fonts\\arial.ttf",                     # Windows
            "/System/Library/Fonts/Helvetica.ttc",              # macOS
            "/usr/share/fonts/TTF/DejaVuSans.ttf",              # Arch Linux
        ]

        for path in &font_paths:
            match Self.new(device, path, 16).await:
                case Ok(atlas): return Ok(atlas)
                case Err(_): continue

        Err("No default font found - please provide font path explicitly")

# =============================================================================
# Text Layout Helpers
# =============================================================================

impl FontAtlas:
    # Layout multi-line text
    pub fn layout_text(&self, text: &str, max_width: f32) -> Array<TextLine>:
        var lines: Array<TextLine> = Array.new()
        var current_line = text.new()
        var current_width = 0.0f32

        for word in text.split(' '):
            val word_width = self.measure_text(word) + self.measure_text(" ")

            if current_width + word_width > max_width and !current_line.is_empty():
                # Start new line
                lines.push(TextLine {
                    text: current_line.clone(),
                    width: current_width,
                })
                current_line = text.new()
                current_width = 0.0

            current_line.push_str(word)
            current_line.push(' ')
            current_width += word_width

        # Add last line
        if !current_line.is_empty():
            lines.push(TextLine {
                text: current_line,
                width: current_width,
            })

        lines

    # Center text horizontally
    pub fn center_text(&self, text: &str, container_width: f32) -> f32:
        val text_width = self.measure_text(text)
        (container_width - text_width) / 2.0

    # Align text right
    pub fn align_right(&self, text: &str, container_width: f32) -> f32:
        val text_width = self.measure_text(text)
        container_width - text_width

pub struct TextLine:
    text: text
    width: f32

impl TextLine:
    pub fn get_text(self) -> &text:
        """Get line text.

        Returns:
            Text content

        Example:
            val line = TextLine { text: "Hello".to_string(), width: 50.0 }
            assert(line.get_text() == "Hello")
        """
        &self.text

    pub fn get_width(self) -> f32:
        """Get line width in pixels.

        Returns:
            Width in pixels

        Example:
            val line = TextLine { text: "Hello".to_string(), width: 50.0 }
            assert(line.get_width() == 50.0)
        """
        self.width

    pub fn is_empty(self) -> bool:
        """Check if line is empty.

        Returns:
            True if text is empty

        Example:
            val line = TextLine { text: "".to_string(), width: 0.0 }
            assert(line.is_empty())
        """
        self.text.is_empty()

    pub fn char_count(self) -> usize:
        """Get number of characters.

        Returns:
            Character count

        Example:
            val line = TextLine { text: "Hello".to_string(), width: 50.0 }
            assert(line.char_count() == 5)
        """
        self.text.len()

    pub fn summary(self) -> text:
        """Get text line summary.

        Returns:
            Human-readable summary

        Example:
            val line = TextLine { text: "Hello".to_string(), width: 50.0 }
            print(line.summary())
        """
        return "TextLine: '{self.text}' ({self.width}px)"

# =============================================================================
# Advanced Font Features
# =============================================================================

impl FontAtlas:
    # Get kerning adjustment between two characters
    # Returns 0.0 as kerning table parsing is not yet implemented
    # Requires: TTF kerning table (KERN or GPOS) parsing in FFI layer
    pub fn get_kerning(&self, left: char, right: char) -> f32:
        # Kerning would adjust horizontal spacing between specific character pairs
        # e.g., "AV" typically has negative kerning to bring letters closer
        0.0

    # Set font weight for bold/light variants
    # Requires: loading multiple font files or synthetic emboldening
    pub fn set_font_weight(&mut self, weight: FontWeight):
        # Would need to either:
        # 1. Load a different font file (e.g., Font-Bold.ttf)
        # 2. Apply synthetic transformations (not recommended for quality)
        pass

    # Enable sub-pixel rendering for LCD displays
    # Requires: RGB sub-pixel layout detection and specialized fragment shader
    pub fn enable_subpixel_rendering(&mut self):
        # Sub-pixel rendering uses RGB sub-pixels for ~3x horizontal resolution
        # Requires platform-specific sub-pixel order detection (RGB vs BGR)
        pass

    # Enable SDF (Signed Distance Field) rendering for scalable text
    # Requires: SDF atlas generation and specialized fragment shader
    pub fn enable_sdf_rendering(&mut self):
        # SDF allows resolution-independent text that scales smoothly
        # Requires generating distance field atlas instead of bitmap atlas
        pass

pub enum FontWeight:
    Thin
    Light
    Regular
    Medium
    Bold
    Black

impl FontWeight:
    pub fn to_string(self) -> text:
        """Convert font weight to string.

        Returns:
            text representation

        Example:
            val weight = FontWeight.Bold
            assert(weight.to_string() == "bold")
        """
        match self:
            case Thin: return "thin"
            case Light: return "light"
            case Regular: return "regular"
            case Medium: return "medium"
            case Bold: return "bold"
            case Black: return "black"

    pub fn description(self) -> text:
        """Get detailed description of weight.

        Returns:
            Human-readable description

        Example:
            val weight = FontWeight.Bold
            assert(weight.description().contains("Bold"))
        """
        match self:
            case Thin: return "Thin weight (100)"
            case Light: return "Light weight (300)"
            case Regular: return "Regular weight (400)"
            case Medium: return "Medium weight (500)"
            case Bold: return "Bold weight (700)"
            case Black: return "Black weight (900)"

    pub fn to_weight_value(self) -> u16:
        """Get numeric weight value.

        Returns:
            Weight value (100-900)

        Example:
            assert(FontWeight.Bold.to_weight_value() == 700)
            assert(FontWeight.Regular.to_weight_value() == 400)
        """
        match self:
            case Thin: return 100
            case Light: return 300
            case Regular: return 400
            case Medium: return 500
            case Bold: return 700
            case Black: return 900

    pub fn is_light(self) -> bool:
        """Check if this is a light weight.

        Returns:
            True if thin or light

        Example:
            assert(FontWeight.Thin.is_light())
            assert(not FontWeight.Bold.is_light())
        """
        match self:
            case Thin: return true
            case Light: return true
            case _: return false

    pub fn is_heavy(self) -> bool:
        """Check if this is a heavy weight.

        Returns:
            True if bold or black

        Example:
            assert(FontWeight.Bold.is_heavy())
            assert(not FontWeight.Light.is_heavy())
        """
        match self:
            case Bold: return true
            case Black: return true
            case _: return false

    pub fn is_normal(self) -> bool:
        """Check if this is normal/regular weight.

        Returns:
            True if regular

        Example:
            assert(FontWeight.Regular.is_normal())
            assert(not FontWeight.Bold.is_normal())
        """
        match self:
            case Regular: return true
            case _: return false

    pub fn is_heavier_than(self, other: FontWeight) -> bool:
        """Check if this weight is heavier than another.

        Returns:
            True if weight value is greater

        Example:
            assert(FontWeight.Bold.is_heavier_than(FontWeight.Regular))
            assert(not FontWeight.Light.is_heavier_than(FontWeight.Bold))
        """
        self.to_weight_value() > other.to_weight_value()
