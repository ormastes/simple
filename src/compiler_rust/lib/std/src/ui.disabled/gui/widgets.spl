# GUI Widgets - Graphical UI Components
#
# Pre-built widgets styled for graphical display.
# These widgets build on the shared Element types with
# GUI-specific styling and behavior.

use core.*
use ui.element.*
use ui.attrs.*
use ui.gui.theme.*

# Card component - elevated surface with content
pub struct Card:
    id: NodeId
    title: Option<text>
    content: Array<Element>
    elevation: u8  # 0-5, higher = more shadow
    padding: u16

impl Card:
    pub fn new(id: NodeId) -> Card:
        return Card {id: id, title: None, content: [], elevation: 1, padding: 16}

    pub fn with_title(self, title: &str) -> Card:
        self.title = Some(title.to_string())
        return self

    pub fn with_elevation(self, level: u8) -> Card:
        self.elevation = level.min(5)
        return self

    pub fn with_padding(self, padding: u16) -> Card:
        self.padding = padding
        return self

    pub fn add_content(self, elem: Element):
        self.content.push(elem)

    pub fn to_element(self, alloc: fn() -> NodeId, theme: &Theme) -> Element:
        var card = Element.new(self.id, ElementKind.Box)
            .with_class("card")
            .with_class(&"elevation-{self.elevation}")
            .with_style("background-color", &color_to_style(&theme.palette.surface))
            .with_style("border-radius", &"{theme.border_radius.md}px")
            .with_style("padding", &"{self.padding}px")

        # Add title if present
        if val Some(title) = &self.title:
            val title_elem = Element.new(alloc(), ElementKind.Heading(2))
                .with_text(title)
                .with_class("card-title")
                .with_style("color", &color_to_style(&theme.palette.text_primary))
                .with_style("margin-bottom", &"{theme.spacing.sm}px")
            card = card.with_child(title_elem)

        # Add content
        for elem in &self.content:
            card = card.with_child(elem.clone())

        return card

# Chip component - compact element for tags/selections
pub struct Chip:
    id: NodeId
    label: text
    icon: Option<text>
    deletable: bool
    selected: bool
    variant: ChipVariant

pub enum ChipVariant:
    Filled
    Outlined

impl ChipVariant:
    pub fn to_string(self) -> text:
        """Convert chip variant to string.

        Returns:
            Variant name
        """
        match self:
            case ChipVariant.Filled: "filled"
            case ChipVariant.Outlined: "outlined"

    pub fn description(self) -> text:
        """Get variant description.

        Returns:
            Human-readable description
        """
        match self:
            case ChipVariant.Filled:
                "Filled background style"
            case ChipVariant.Outlined:
                "Outlined border style"

    pub fn is_filled(self) -> bool:
        """Check if filled variant."""
        match self:
            case ChipVariant.Filled: true
            case _: false

    pub fn is_outlined(self) -> bool:
        """Check if outlined variant."""
        match self:
            case ChipVariant.Outlined: true
            case _: false

    pub fn summary(self) -> text:
        """Get summary of chip variant.

        Returns:
            Human-readable summary

        Example:
            ChipVariant.Filled.summary()
            # → "ChipVariant: filled (Filled background style)"
        """
        val name = self.to_string()
        val desc = self.description()
        return "ChipVariant: {name} ({desc})"

impl Chip:
    pub fn new(id: NodeId, label: &str) -> Chip:
        return Chip {
            id: id,
            label: label.to_string(),
            icon: None,
            deletable: false,
            selected: false,
            variant: ChipVariant.Filled
        }

    pub fn with_icon(self, icon: &str) -> Chip:
        self.icon = Some(icon.to_string())
        return self

    pub fn deletable(self) -> Chip:
        self.deletable = true
        return self

    pub fn selected(self) -> Chip:
        self.selected = true
        return self

    pub fn outlined(self) -> Chip:
        self.variant = ChipVariant.Outlined
        return self

    pub fn to_element(self, alloc: fn() -> NodeId, theme: &Theme) -> Element:
        val bg_color = match self.variant:
            case ChipVariant.Filled:
                if self.selected { &theme.palette.primary } else { &theme.palette.hover }
            case ChipVariant.Outlined:
                &theme.palette.surface

        val text_color = match self.variant:
            case ChipVariant.Filled:
                if self.selected { &theme.palette.surface } else { &theme.palette.text_primary }
            case ChipVariant.Outlined:
                if self.selected { &theme.palette.primary } else { &theme.palette.text_primary }

        var chip = Element.new(self.id, ElementKind.Span)
            .with_class("chip")
            .with_style("display", "inline-flex")
            .with_style("align-items", "center")
            .with_style("padding", "4px 12px")
            .with_style("border-radius", &"{theme.border_radius.full}px")
            .with_style("background-color", &color_to_style(bg_color))
            .with_style("color", &color_to_style(text_color))

        if self.variant == ChipVariant.Outlined:
            chip = chip.with_style("border", &"1px solid {color_to_style(&theme.palette.border)}")

        # Add icon if present
        if val Some(icon) = &self.icon:
            val icon_elem = Element.new(alloc(), ElementKind.Span)
                .with_text(icon)
                .with_class("chip-icon")
                .with_style("margin-right", "4px")
            chip = chip.with_child(icon_elem)

        # Add label
        val label_elem = Element.new(alloc(), ElementKind.Span)
            .with_text(&self.label)
            .with_class("chip-label")
        chip = chip.with_child(label_elem)

        # Add delete button if deletable
        if self.deletable:
            val delete_elem = Element.new(alloc(), ElementKind.Span)
                .with_text("×")
                .with_class("chip-delete")
                .with_style("margin-left", "4px")
                .with_style("cursor", "pointer")
            chip = chip.with_child(delete_elem)

        return chip

# Avatar component - user/entity image
pub struct Avatar:
    id: NodeId
    src: Option<text>  # Image URL
    alt: text
    initials: Option<text>
    size: AvatarSize

pub enum AvatarSize:
    Small   # 32px
    Medium  # 40px
    Large   # 56px

impl AvatarSize:
    pub fn to_string(self) -> text:
        """Convert avatar size to string.

        Returns:
            Size name
        """
        match self:
            case AvatarSize.Small: "small"
            case AvatarSize.Medium: "medium"
            case AvatarSize.Large: "large"

    pub fn description(self) -> text:
        """Get size description.

        Returns:
            Human-readable description
        """
        match self:
            case AvatarSize.Small: "Small avatar (32px)"
            case AvatarSize.Medium: "Medium avatar (40px)"
            case AvatarSize.Large: "Large avatar (56px)"

    pub fn to_pixels(self) -> u16:
        """Get size in pixels.

        Returns:
            Size in pixels
        """
        match self:
            case AvatarSize.Small: 32
            case AvatarSize.Medium: 40
            case AvatarSize.Large: 56

    pub fn is_small(self) -> bool:
        """Check if small size."""
        match self:
            case AvatarSize.Small: true
            case _: false

    pub fn is_medium(self) -> bool:
        """Check if medium size."""
        match self:
            case AvatarSize.Medium: true
            case _: false

    pub fn is_large(self) -> bool:
        """Check if large size."""
        match self:
            case AvatarSize.Large: true
            case _: false

    pub fn summary(self) -> text:
        """Get summary of avatar size.

        Returns:
            Human-readable summary

        Example:
            AvatarSize.Medium.summary()
            # → "AvatarSize: medium (40px)"
        """
        val name = self.to_string()
        val pixels = self.to_pixels()
        return "AvatarSize: {name} ({pixels}px)"

impl Avatar:
    pub fn new(id: NodeId, alt: &str) -> Avatar:
        return Avatar {
            id: id,
            src: None,
            alt: alt.to_string(),
            initials: None,
            size: AvatarSize.Medium
        }

    pub fn with_src(self, src: &str) -> Avatar:
        self.src = Some(src.to_string())
        return self

    pub fn with_initials(self, initials: &str) -> Avatar:
        self.initials = Some(initials.to_string())
        return self

    pub fn small(self) -> Avatar:
        self.size = AvatarSize.Small
        return self

    pub fn large(self) -> Avatar:
        self.size = AvatarSize.Large
        return self

    pub fn to_element(self, alloc: fn() -> NodeId, theme: &Theme) -> Element:
        val size_px = match self.size:
            case AvatarSize.Small: 32
            case AvatarSize.Medium: 40
            case AvatarSize.Large: 56

        var avatar = Element.new(self.id, ElementKind.Div)
            .with_class("avatar")
            .with_style("width", &"{size_px}px")
            .with_style("height", &"{size_px}px")
            .with_style("border-radius", "50%")
            .with_style("overflow", "hidden")
            .with_style("display", "flex")
            .with_style("align-items", "center")
            .with_style("justify-content", "center")
            .with_style("background-color", &color_to_style(&theme.palette.primary_light))

        if val Some(src) = &self.src:
            # Image avatar
            avatar = avatar.with_attr("style", &"background-image: url({src}); background-size: cover;")
        else if val Some(initials) = &self.initials:
            # Initials avatar
            val text_elem = Element.new(alloc(), ElementKind.Span)
                .with_text(initials)
                .with_style("color", &color_to_style(&theme.palette.primary_dark))
                .with_style("font-weight", "500")
            avatar = avatar.with_child(text_elem)

        return avatar

# Badge component - small count/status indicator
pub struct Badge:
    id: NodeId
    content: text
    variant: BadgeVariant
    max: Option<u32>

pub enum BadgeVariant:
    Default
    Primary
    Secondary
    Error
    Success

impl BadgeVariant:
    pub fn to_string(self) -> text:
        """Convert badge variant to string.

        Returns:
            Variant name
        """
        match self:
            case BadgeVariant.Default: "default"
            case BadgeVariant.Primary: "primary"
            case BadgeVariant.Secondary: "secondary"
            case BadgeVariant.Error: "error"
            case BadgeVariant.Success: "success"

    pub fn description(self) -> text:
        """Get variant description.

        Returns:
            Human-readable description
        """
        match self:
            case BadgeVariant.Default: "Default badge style"
            case BadgeVariant.Primary: "Primary color badge"
            case BadgeVariant.Secondary: "Secondary color badge"
            case BadgeVariant.Error: "Error/danger badge"
            case BadgeVariant.Success: "Success badge"

    pub fn is_semantic(self) -> bool:
        """Check if this is a semantic variant.

        Returns:
            True for Error or Success
        """
        match self:
            case BadgeVariant.Error: true
            case BadgeVariant.Success: true
            case _: false

    pub fn is_default(self) -> bool:
        """Check if default variant."""
        match self:
            case BadgeVariant.Default: true
            case _: false

    pub fn is_primary(self) -> bool:
        """Check if primary variant."""
        match self:
            case BadgeVariant.Primary: true
            case _: false

    pub fn is_error(self) -> bool:
        """Check if error variant."""
        match self:
            case BadgeVariant.Error: true
            case _: false

    pub fn is_success(self) -> bool:
        """Check if success variant."""
        match self:
            case BadgeVariant.Success: true
            case _: false

    pub fn summary(self) -> text:
        """Get comprehensive badge variant summary.

        Returns:
            Summary with variant name and characteristics
        """
        val name = self.to_string()
        val desc = self.description()
        var props = []
        if self.is_semantic():
            props.push("semantic")
        if self.is_primary():
            props.push("primary")
        if self.is_default():
            props.push("default")
        if props.len() > 0:
            val props_str = ", ".join(props)
            return "BadgeVariant: {name} ({desc}, {props_str})"
        else:
            return "BadgeVariant: {name} ({desc})"

impl Badge:
    pub fn new(id: NodeId, content: &str) -> Badge:
        return Badge {
            id: id,
            content: content.to_string(),
            variant: BadgeVariant.Default,
            max: None
        }

    pub fn count(id: NodeId, count: u32) -> Badge:
        return Badge {
            id: id,
            content: count.to_string(),
            variant: BadgeVariant.Default,
            max: None
        }

    pub fn with_max(self, max: u32) -> Badge:
        self.max = Some(max)
        if val Ok(count) = self.content.parse_int():
            if (count as u32) > max:
                self.content = "{max}+"
        return self

    pub fn primary(self) -> Badge:
        self.variant = BadgeVariant.Primary
        return self

    pub fn error(self) -> Badge:
        self.variant = BadgeVariant.Error
        return self

    pub fn success(self) -> Badge:
        self.variant = BadgeVariant.Success
        return self

    pub fn to_element(self, alloc: fn() -> NodeId, theme: &Theme) -> Element:
        val bg_color = match self.variant:
            case BadgeVariant.Default: &theme.palette.secondary
            case BadgeVariant.Primary: &theme.palette.primary
            case BadgeVariant.Secondary: &theme.palette.secondary
            case BadgeVariant.Error: &theme.palette.error
            case BadgeVariant.Success: &theme.palette.success

        return Element.new(self.id, ElementKind.Span)
            .with_class("badge")
            .with_text(&self.content)
            .with_style("display", "inline-flex")
            .with_style("align-items", "center")
            .with_style("justify-content", "center")
            .with_style("min-width", "20px")
            .with_style("height", "20px")
            .with_style("padding", "0 6px")
            .with_style("border-radius", "10px")
            .with_style("background-color", &color_to_style(bg_color))
            .with_style("color", &color_to_style(&theme.palette.surface))
            .with_style("font-size", "12px")
            .with_style("font-weight", "500")

