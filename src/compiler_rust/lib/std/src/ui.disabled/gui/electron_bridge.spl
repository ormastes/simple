# Electron Bridge - Data Types, Native APIs, and FFI
#
# Electron-specific data types (dialogs, menus, clipboard, events),
# native system integrations, and FFI declarations.
# Part of the Electron renderer module - see electron.spl for
# ElectronRenderer struct and RenderBackend implementation.

use core.*
use concurrency.*
use ui.element.*
use ui.attrs.*
use ui.patchset.*
use ui.renderer.*
use ui.gui.electron.*

# Electron Data Types
# =============================================================================

pub struct OpenDialogOptions:
    title: text
    default_path: Option<text>
    button_label: Option<text>
    filters: Array<FileFilter>
    properties: Array<OpenDialogProperty>

impl OpenDialogOptions:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_default_path(self) -> bool:
        """Check if default path is set."""
        match self.default_path:
            case Some(_): true
            case None: false

    pub fn has_button_label(self) -> bool:
        """Check if custom button label is set."""
        match self.button_label:
            case Some(_): true
            case None: false

    pub fn has_filters(self) -> bool:
        """Check if any file filters are set."""
        self.filters.len() > 0

    pub fn filter_count(self) -> usize:
        """Get number of file filters."""
        self.filters.len()

    pub fn property_count(self) -> usize:
        """Get number of properties."""
        self.properties.len()

    pub fn summary(self) -> text:
        """Get summary of dialog options."""
        return "OpenDialogOptions: '{self.title}', {self.filter_count()} filters, {self.property_count()} properties"

pub struct FileFilter:
    name: text
    extensions: Array<text>

impl FileFilter:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_extensions(self) -> bool:
        """Check if any extensions are defined."""
        self.extensions.len() > 0

    pub fn extension_count(self) -> usize:
        """Get number of extensions."""
        self.extensions.len()

    pub fn summary(self) -> text:
        """Get summary of file filter."""
        return "FileFilter: {self.name} ({self.extension_count()} extensions)"

pub enum OpenDialogProperty:
    OpenFile
    OpenDirectory
    MultiSelections
    ShowHiddenFiles
    CreateDirectory

impl OpenDialogProperty:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn to_string(self) -> text:
        """Convert to string representation."""
        match self:
            case OpenFile: return "openFile"
            case OpenDirectory: return "openDirectory"
            case MultiSelections: return "multiSelections"
            case ShowHiddenFiles: return "showHiddenFiles"
            case CreateDirectory: return "createDirectory"

    pub fn description(self) -> text:
        """Get description of this property."""
        match self:
            case OpenFile: return "Allow files to be selected"
            case OpenDirectory: return "Allow directories to be selected"
            case MultiSelections: return "Allow multiple paths to be selected"
            case ShowHiddenFiles: return "Show hidden files in dialog"
            case CreateDirectory: return "Allow creating new directories"

    pub fn is_open_file(self) -> bool:
        """Check if this allows opening files."""
        match self:
            case OpenFile: true
            case _: false

    pub fn is_open_directory(self) -> bool:
        """Check if this allows opening directories."""
        match self:
            case OpenDirectory: true
            case _: false

    pub fn is_multi_selections(self) -> bool:
        """Check if this allows multiple selections."""
        match self:
            case MultiSelections: true
            case _: false

    pub fn summary(self) -> text:
        """Get dialog property summary.

        Returns:
            Human-readable summary

        Example:
            OpenDialogProperty.OpenFile.summary()
            # â†’ "OpenDialogProperty: openFile (Allow files to be selected)"
        """
        val name = self.to_string()
        val desc = self.description()
        return "OpenDialogProperty: {name} ({desc})"

pub struct SaveDialogOptions:
    title: text
    default_path: Option<text>
    button_label: Option<text>
    filters: Array<FileFilter>

impl SaveDialogOptions:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_default_path(self) -> bool:
        """Check if default path is set."""
        match self.default_path:
            case Some(_): true
            case None: false

    pub fn has_button_label(self) -> bool:
        """Check if custom button label is set."""
        match self.button_label:
            case Some(_): true
            case None: false

    pub fn has_filters(self) -> bool:
        """Check if any file filters are set."""
        self.filters.len() > 0

    pub fn filter_count(self) -> usize:
        """Get number of file filters."""
        self.filters.len()

    pub fn summary(self) -> text:
        """Get summary of dialog options."""
        return "SaveDialogOptions: '{self.title}', {self.filter_count()} filters"

pub struct MessageBoxOptions:
    type: MessageBoxType
    buttons: Array<text>
    default_id: u32
    title: text
    message: text
    detail: Option<text>

impl MessageBoxOptions:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_detail(self) -> bool:
        """Check if detail text is provided."""
        match self.detail:
            case Some(_): true
            case None: false

    pub fn button_count(self) -> usize:
        """Get number of buttons."""
        self.buttons.len()

    pub fn has_buttons(self) -> bool:
        """Check if any buttons are defined."""
        self.buttons.len() > 0

    pub fn summary(self) -> text:
        """Get summary of message box options."""
        return "MessageBoxOptions: '{self.title}', type={self.type.to_string()}, {self.button_count()} buttons"

pub enum MessageBoxType:
    None
    Info
    Error
    Question
    Warning

impl MessageBoxType:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn to_string(self) -> text:
        """Convert to string representation."""
        match self:
            case None: return "none"
            case Info: return "info"
            case Error: return "error"
            case Question: return "question"
            case Warning: return "warning"

    pub fn description(self) -> text:
        """Get description of this message box type."""
        match self:
            case None: return "Plain message box with no icon"
            case Info: return "Information message with info icon"
            case Error: return "Error message with error icon"
            case Question: return "Question dialog with question icon"
            case Warning: return "Warning message with warning icon"

    pub fn is_info(self) -> bool:
        """Check if this is an info message."""
        match self:
            case Info: true
            case _: false

    pub fn is_error(self) -> bool:
        """Check if this is an error message."""
        match self:
            case Error: true
            case _: false

    pub fn is_warning(self) -> bool:
        """Check if this is a warning message."""
        match self:
            case Warning: true
            case _: false

    pub fn is_question(self) -> bool:
        """Check if this is a question dialog."""
        match self:
            case Question: true
            case _: false

pub struct NotificationOptions:
    title: text
    body: text
    icon: Option<text>
    silent: bool
    timeout_ms: u32

impl NotificationOptions:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_icon(self) -> bool:
        """Check if icon is provided."""
        match self.icon:
            case Some(_): true
            case None: false

    pub fn is_silent(self) -> bool:
        """Check if notification is silent."""
        self.silent

    pub fn has_timeout(self) -> bool:
        """Check if timeout is set (non-zero)."""
        self.timeout_ms > 0

    pub fn summary(self) -> text:
        """Get summary of notification options."""
        val silent = if self.silent: "silent" else: "audible"
        return "NotificationOptions: '{self.title}', {silent}, timeout={self.timeout_ms}ms"

# =============================================================================
# System Tray
# =============================================================================

pub struct SystemTray:
    icon_path: text
    tooltip: text
    menu: Option<TrayMenu>

impl SystemTray:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_menu(self) -> bool:
        """Check if context menu is set."""
        match self.menu:
            case Some(_): true
            case None: false

    pub fn summary(self) -> text:
        """Get summary of system tray."""
        val menu = if self.has_menu(): "yes" else: "no"
        return "SystemTray: '{self.tooltip}', icon='{self.icon_path}', menu={menu}"

    # =========================================================================
    # Methods
    # =========================================================================

    pub async fn new(icon_path: &str, tooltip: &str) -> Future<SystemTray>:
        val tray = SystemTray {
            icon_path: icon_path.to_string(),
            tooltip: tooltip.to_string(),
            menu: None
        }

        await electron_create_tray(icon_path, tooltip)

        return Future.ready(tray)

    pub async fn set_icon(self, icon_path: &str) -> Future<()>:
        self.icon_path = icon_path.to_string()
        await electron_tray_set_icon(icon_path)
        return Future.ready(())

    pub async fn set_tooltip(self, tooltip: &str) -> Future<()>:
        self.tooltip = tooltip.to_string()
        await electron_tray_set_tooltip(tooltip)
        return Future.ready(())

    pub async fn set_context_menu(self, menu: TrayMenu) -> Future<()>:
        self.menu = Some(menu)
        await electron_tray_set_menu(&menu)
        return Future.ready(())

    pub async fn destroy(self) -> Future<()>:
        await electron_destroy_tray()
        return Future.ready(())

pub struct TrayMenu:
    items: Array<TrayMenuItem>

impl TrayMenu:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_items(self) -> bool:
        """Check if menu has any items."""
        self.items.len() > 0

    pub fn item_count(self) -> usize:
        """Get number of menu items."""
        self.items.len()

    pub fn is_empty(self) -> bool:
        """Check if menu is empty."""
        self.items.len() == 0

    pub fn summary(self) -> text:
        """Get summary of tray menu."""
        return "TrayMenu: {self.item_count()} items"

pub enum TrayMenuItem:
    Normal { label: text, click: fn() }
    Separator
    Submenu { label: text, submenu: TrayMenu }

impl TrayMenuItem:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn to_string(self) -> text:
        """Convert to string representation."""
        match self:
            case Normal { label, .. }: return "Normal: {label}"
            case Separator: return "Separator"
            case Submenu { label, .. }: return "Submenu: {label}"

    pub fn description(self) -> text:
        """Get description of this menu item."""
        match self:
            case Normal { .. }: return "Normal clickable menu item"
            case Separator: return "Menu separator"
            case Submenu { .. }: return "Submenu with child items"

    pub fn is_normal(self) -> bool:
        """Check if this is a normal menu item."""
        match self:
            case Normal { .. }: true
            case _: false

    pub fn is_separator(self) -> bool:
        """Check if this is a separator."""
        match self:
            case Separator: true
            case _: false

    pub fn is_submenu(self) -> bool:
        """Check if this is a submenu."""
        match self:
            case Submenu { .. }: true
            case _: false

# =============================================================================
# Power Monitor
# =============================================================================

pub struct PowerMonitor:
    on_suspend_handler: Option<fn()>
    on_resume_handler: Option<fn()>
    on_battery_handler: Option<fn()>
    on_ac_handler: Option<fn()>

impl PowerMonitor:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_suspend_handler(self) -> bool:
        """Check if suspend handler is registered."""
        match self.on_suspend_handler:
            case Some(_): true
            case None: false

    pub fn has_resume_handler(self) -> bool:
        """Check if resume handler is registered."""
        match self.on_resume_handler:
            case Some(_): true
            case None: false

    pub fn has_battery_handler(self) -> bool:
        """Check if battery handler is registered."""
        match self.on_battery_handler:
            case Some(_): true
            case None: false

    pub fn has_ac_handler(self) -> bool:
        """Check if AC power handler is registered."""
        match self.on_ac_handler:
            case Some(_): true
            case None: false

    pub fn has_any_handlers(self) -> bool:
        """Check if any power event handlers are registered."""
        self.has_suspend_handler() or self.has_resume_handler() or self.has_battery_handler() or self.has_ac_handler()

    pub fn handler_count(self) -> usize:
        """Get number of registered handlers."""
        var count = 0
        if self.has_suspend_handler(): count = count + 1
        if self.has_resume_handler(): count = count + 1
        if self.has_battery_handler(): count = count + 1
        if self.has_ac_handler(): count = count + 1
        count

    pub fn summary(self) -> text:
        """Get summary of power monitor."""
        return "PowerMonitor: {self.handler_count()} handlers registered"

    # =========================================================================
    # Constructor
    # =========================================================================

    pub fn new() -> PowerMonitor:
        return PowerMonitor {
            on_suspend_handler: None,
            on_resume_handler: None,
            on_battery_handler: None,
            on_ac_handler: None
        }

    pub async fn on_suspend(self, handler: fn()) -> Future<()>:
        self.on_suspend_handler = Some(handler)
        await electron_power_on("suspend", handler)
        return Future.ready(())

    pub async fn on_resume(self, handler: fn()) -> Future<()>:
        self.on_resume_handler = Some(handler)
        await electron_power_on("resume", handler)
        return Future.ready(())

    pub async fn on_battery(self, handler: fn()) -> Future<()>:
        self.on_battery_handler = Some(handler)
        await electron_power_on("on-battery", handler)
        return Future.ready(())

    pub async fn on_ac(self, handler: fn()) -> Future<()>:
        self.on_ac_handler = Some(handler)
        await electron_power_on("on-ac", handler)
        return Future.ready(())

# =============================================================================
# Clipboard
# =============================================================================

pub struct Clipboard

impl Clipboard:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn summary(self) -> text:
        """Get summary of clipboard."""
        return "Clipboard: system clipboard access"

    # =========================================================================
    # Constructor and Methods
    # =========================================================================

    pub fn new() -> Clipboard:
        return Clipboard {}

    pub fn read_text(self) -> text:
        return electron_clipboard_read_text()

    pub fn write_text(self, text: &str):
        electron_clipboard_write_text(text)

    pub fn read_image(self) -> Option<Image>:
        # Read image from clipboard using Electron's nativeImage
        val native_image = electron_clipboard_read_image()
        if native_image.is_empty():
            return None

        # Convert to our Image type
        val size = native_image.get_size()
        val buffer = native_image.to_png()

        return Some(Image {
            width: size.width,
            height: size.height,
            format: ImageFormat.Png,
            data: buffer
        })

    pub fn clear(self):
        electron_clipboard_clear()

# =============================================================================
# Custom Events
# =============================================================================

pub enum Event:
    # Extend base Event enum with Electron-specific events
    PowerSuspend
    PowerResume
    BatteryPower
    ACPower
    Quit
    IpcMessage { channel: text, data: Any }

impl Event:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn to_string(self) -> text:
        """Convert to string representation."""
        match self:
            case PowerSuspend: return "PowerSuspend"
            case PowerResume: return "PowerResume"
            case BatteryPower: return "BatteryPower"
            case ACPower: return "ACPower"
            case Quit: return "Quit"
            case IpcMessage { channel, .. }: return "IpcMessage: {channel}"

    pub fn description(self) -> text:
        """Get description of this event."""
        match self:
            case PowerSuspend: return "System is suspending"
            case PowerResume: return "System resumed from suspend"
            case BatteryPower: return "Switched to battery power"
            case ACPower: return "Switched to AC power"
            case Quit: return "Application quit requested"
            case IpcMessage { .. }: return "IPC message from main process"

    pub fn is_power_event(self) -> bool:
        """Check if this is a power-related event."""
        match self:
            case PowerSuspend: true
            case PowerResume: true
            case BatteryPower: true
            case ACPower: true
            case _: false

    pub fn is_power_suspend(self) -> bool:
        """Check if this is a power suspend event."""
        match self:
            case PowerSuspend: true
            case _: false

    pub fn is_power_resume(self) -> bool:
        """Check if this is a power resume event."""
        match self:
            case PowerResume: true
            case _: false

    pub fn is_battery_power(self) -> bool:
        """Check if this is a battery power event."""
        match self:
            case BatteryPower: true
            case _: false

    pub fn is_ac_power(self) -> bool:
        """Check if this is an AC power event."""
        match self:
            case ACPower: true
            case _: false

    pub fn is_quit(self) -> bool:
        """Check if this is a quit event."""
        match self:
            case Quit: true
            case _: false

    pub fn is_ipc_message(self) -> bool:
        """Check if this is an IPC message."""
        match self:
            case IpcMessage { .. }: true
            case _: false

# =============================================================================
# Electron FFI (Node.js Integration)
# =============================================================================

type IpcCallback = fn(Event, Array<Any>) -> ()

# Environment check
extern fn electron_is_available() -> bool

# IPC (Inter-Process Communication)
extern async fn electron_ipc_send(channel: &str, args: Array<Any>) -> Future<()>
extern async fn electron_ipc_on(channel: &str, callback: IpcCallback) -> Future<()>
extern async fn electron_ipc_remove_all_listeners(channel: &str) -> Future<()>

# Dialogs
extern async fn electron_show_open_dialog(window_id: u32, options: OpenDialogOptions)
    -> Future<Option<Array<text>>>
extern async fn electron_show_save_dialog(window_id: u32, options: SaveDialogOptions)
    -> Future<Option<text>>
extern async fn electron_show_message_box(window_id: u32, options: MessageBoxOptions)
    -> Future<u32>

# Window management
extern async fn electron_set_window_title(window_id: u32, title: &str) -> Future<()>
extern async fn electron_set_window_size(window_id: u32, width: u32, height: u32) -> Future<()>
extern async fn electron_maximize_window(window_id: u32) -> Future<()>
extern async fn electron_minimize_window(window_id: u32) -> Future<()>
extern async fn electron_close_window(window_id: u32) -> Future<()>
extern fn electron_reload_window() -> ()

# System Tray
extern async fn electron_create_tray(icon_path: &str, tooltip: &str) -> Future<()>
extern async fn electron_tray_set_icon(icon_path: &str) -> Future<()>
extern async fn electron_tray_set_tooltip(tooltip: &str) -> Future<()>
extern async fn electron_tray_set_menu(menu: &TrayMenu) -> Future<()>
extern async fn electron_destroy_tray() -> Future<()>

# Power Monitor
extern async fn electron_power_on(event: &str, callback: fn()) -> Future<()>

# Clipboard
extern fn electron_clipboard_read_text() -> text
extern fn electron_clipboard_write_text(text: &str) -> ()
extern fn electron_clipboard_read_image() -> NativeImage
extern fn electron_clipboard_clear() -> ()

# NativeImage type for Electron's image handling
struct NativeImage:
    handle: i64

impl NativeImage:
    fn is_empty(self) -> bool:
        return electron_native_image_is_empty(self.handle)

    fn get_size(self) -> ImageSize:
        return electron_native_image_get_size(self.handle)

    fn to_png(self) -> Array<u8>:
        return electron_native_image_to_png(self.handle)

struct ImageSize:
    width: u32
    height: u32

extern fn electron_native_image_is_empty(handle: i64) -> bool
extern fn electron_native_image_get_size(handle: i64) -> ImageSize
extern fn electron_native_image_to_png(handle: i64) -> Array<u8>

# Notifications
extern async fn electron_show_notification(options: NotificationOptions) -> Future<()>
