# Vulkan Core Types - Phase 1 Implementation
#
# Foundational Vulkan types for the async renderer.
# Follows builder pattern with smart defaults from vulkan_dsl.md research.
#
# Implementation Status: Phase 1 - Core Initialization
# - VulkanDevice: Device selection and initialization
# - Swapchain: Swapchain creation and management
# - RenderPass: Render pass configuration
# - Supporting types and utilities

use core.*
use concurrency.*

# =============================================================================
# Vulkan Device - Smart Device Selection and Initialization
# =============================================================================

pub struct VulkanDevice:
    # Core Vulkan handles (FFI)
    instance: VkInstance                # Vulkan instance
    physical_device: VkPhysicalDevice   # Selected GPU
    device: VkDevice                    # Logical device

    # Queues
    graphics_queue: VkQueue             # Graphics queue
    present_queue: VkQueue              # Present queue (may be same as graphics)

    # Queue family indices
    graphics_family: u32
    present_family: u32

    # Device properties
    properties: VkPhysicalDeviceProperties
    features: VkPhysicalDeviceFeatures
    memory_properties: VkPhysicalDeviceMemoryProperties

impl VulkanDevice:
    # Create device with smart defaults (auto-selects best GPU)
    pub fn new(window_handle: i64) -> Result<VulkanDevice, text>:
        # Create Vulkan instance with application info, required extensions, and validation layers
        val instance = vulkan_create_instance("Simple UI", 1)?

        # Enumerate available physical devices
        val physical_devices = vulkan_enumerate_physical_devices(instance)?
        if physical_devices.is_empty():
            return Err("No Vulkan-capable GPU found")

        # Select best device (prefer discrete GPU)
        val (physical_device, graphics_family, present_family) =
            Self.select_best_device(instance, window_handle, &physical_devices)?

        # Create logical device with required queue families
        val device = vulkan_create_device(physical_device, graphics_family, present_family)?

        # Get queue handles from the logical device
        val graphics_queue = vulkan_get_device_queue(device, graphics_family, 0)
        val present_queue = vulkan_get_device_queue(device, present_family, 0)

        # Query device properties, features, and memory properties
        val properties = vulkan_get_physical_device_properties(physical_device)
        val features = vulkan_get_physical_device_features(physical_device)
        val memory_properties = vulkan_get_physical_device_memory_properties(physical_device)

        return Ok(VulkanDevice {instance: instance, physical_device: physical_device, device: device, graphics_queue: graphics_queue, present_queue: present_queue, graphics_family: graphics_family, present_family: present_family, properties: properties, features: features, memory_properties: memory_properties})

    # Select best GPU (prefer discrete, check queue families)
    fn select_best_device(instance: VkInstance, window: i64, devices: &Array<VkPhysicalDevice>)
        -> Result<(VkPhysicalDevice, u32, u32), text>:

        # Score devices and pick best
        var best_device = None
        var best_score = 0
        var best_graphics_family = 0
        var best_present_family = 0

        for device in devices:
            # Query queue families for this device
            val queue_families = vulkan_get_physical_device_queue_families(device)

            # Find graphics and present queues
            val graphics_family = Self.find_queue_family(
                &queue_families,
                QueueFamilyFlags.Graphics
            )
            val present_family = Self.find_present_queue_family(
                device,
                window,
                &queue_families
            )

            if graphics_family.is_none() or present_family.is_none():
                continue  # Skip devices without required queues

            # Score device based on type and capabilities
            val score = Self.score_device(device)

            if score > best_score:
                best_score = score
                best_device = Some(device)
                best_graphics_family = graphics_family.unwrap()
                best_present_family = present_family.unwrap()

        match best_device:
            case Some(device):
                return Ok((device, best_graphics_family, best_present_family))
            case None:
                return Err("No suitable GPU found")

    # Score device (prefer discrete GPU, more VRAM)
    fn score_device(device: VkPhysicalDevice) -> i32:
        val properties = vulkan_get_physical_device_properties(device)

        var score = 0

        # Discrete GPU gets huge bonus
        if properties.device_type == VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU:
            score += 1000

        # Integrated GPU gets smaller bonus
        if properties.device_type == VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU:
            score += 100

        # More VRAM is better (simplified - would need to query heap sizes)
        score += properties.limits.max_image_dimension_2d as i32 / 1000

        return score

    # Find queue family with specific flags
    fn find_queue_family(families: &Array<VkQueueFamilyProperties>, flags: QueueFamilyFlags)
        -> Option<u32>:
        for (i, family) in families.enumerate():
            if (family.queue_flags & flags.bits()) != 0:
                return Some(i as u32)
        return None

    # Find queue family that supports present
    fn find_present_queue_family(device: VkPhysicalDevice, window: i64,
                                  families: &Array<VkQueueFamilyProperties>)
        -> Option<u32>:
        for (i, _family) in families.enumerate():
            # Check if this queue family supports present to the surface
            val supports_present = vulkan_queue_family_supports_present(
                device,
                i as u32,
                window
            )
            if supports_present:
                return Some(i as u32)
        return None

    # Async wait for device to be idle (vkDeviceWaitIdle)
    pub async fn wait_idle_async(self) -> Future<()>:
        await spawn_blocking(|| {
            vulkan_device_wait_idle(self.device)
        })
        return Future.ready(())

    # Async fence operations (vkWaitForFences)
    pub async fn wait_for_fence_async(self, fence: i64) -> Future<()>:
        await spawn_blocking(|| {
            vulkan_wait_for_fence(self.device, fence, u64.MAX)
        })
        return Future.ready(())

    # Reset fence (vkResetFences)
    pub fn reset_fence(self, fence: i64):
        vulkan_reset_fence(self.device, fence)

    # Reset command buffer (vkResetCommandBuffer)
    pub fn reset_command_buffer(self, cmd_buf: i64):
        vulkan_reset_command_buffer(cmd_buf)

    # Create future that completes when fence is signaled
    pub fn create_fence_future(self, fence: i64) -> Future<GpuSubmitResult>:
        # Return async operation that polls fence
        return async {
            await self.wait_for_fence_async(fence)
            return GpuSubmitResult { success: true }
        }

    # Async present (vkQueuePresentKHR)
    pub async fn queue_present_async(self, present_info: VkPresentInfo)
        -> Future<Result<(), SwapchainError>>:
        val result = vulkan_queue_present(self.present_queue, &present_info)

        match result:
            case VK_SUCCESS:
                return Future.ready(Ok(()))
            case VK_ERROR_OUT_OF_DATE_KHR | VK_SUBOPTIMAL_KHR:
                return Future.ready(Err(SwapchainError.OutOfDate))
            case _:
                return Future.ready(Err(SwapchainError.DeviceLost))

    pub fn get_device(self) -> VkDevice:
        """Get logical device handle.

        Returns:
            Device handle

        Example:
            val vk = VulkanDevice.new(window)?
            val device = vk.get_device()
        """
        self.device

    pub fn get_graphics_queue(self) -> VkQueue:
        """Get graphics queue handle.

        Returns:
            Graphics queue

        Example:
            val vk = VulkanDevice.new(window)?
            val queue = vk.get_graphics_queue()
        """
        self.graphics_queue

    pub fn get_graphics_family(self) -> u32:
        """Get graphics queue family index.

        Returns:
            Queue family index

        Example:
            val vk = VulkanDevice.new(window)?
            val family = vk.get_graphics_family()
        """
        self.graphics_family

    pub fn has_same_queue_families(self) -> bool:
        """Check if graphics and present queues are the same.

        Returns:
            True if same family

        Example:
            val vk = VulkanDevice.new(window)?
            if vk.has_same_queue_families():
                print("Single queue family for graphics+present")
        """
        self.graphics_family == self.present_family

    pub fn is_discrete_gpu(self) -> bool:
        """Check if using discrete GPU.

        Returns:
            True if discrete GPU

        Example:
            val vk = VulkanDevice.new(window)?
            if vk.is_discrete_gpu():
                print("Using dedicated graphics card")
        """
        self.properties.device_type == VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU

    pub fn is_integrated_gpu(self) -> bool:
        """Check if using integrated GPU.

        Returns:
            True if integrated GPU

        Example:
            val vk = VulkanDevice.new(window)?
            if vk.is_integrated_gpu():
                print("Using integrated graphics")
        """
        self.properties.device_type == VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU

    pub fn get_device_name(self) -> &text:
        """Get GPU device name.

        Returns:
            Device name

        Example:
            val vk = VulkanDevice.new(window)?
            print("GPU: {}", vk.get_device_name())
        """
        &self.properties.device_name

    pub fn summary(self) -> text:
        """Get Vulkan device summary.

        Returns:
            Human-readable summary

        Example:
            val vk = VulkanDevice.new(window)?
            print(vk.summary())
        """
        val gpu_type = if self.is_discrete_gpu(): "discrete" else if self.is_integrated_gpu(): "integrated" else: "other"
        return "VulkanDevice: {self.properties.device_name} ({gpu_type} GPU), graphics_family={self.graphics_family}"

# =============================================================================
# Swapchain - Image Presentation
# =============================================================================

pub struct Swapchain:
    swapchain: VkSwapchainKHR
    images: Array<VkImage>
    image_views: Array<VkImageView>
    format: VkSurfaceFormatKHR
    extent: VkExtent2D
    device: VulkanDevice  # Reference to device

impl Swapchain:
    # Create swapchain with smart defaults
    pub fn new(device: &VulkanDevice, width: u32, height: u32) -> Result<Swapchain, text>:
        # Query surface capabilities
        val capabilities = vulkan_get_surface_capabilities(
            device.physical_device,
            device.surface
        )?

        # Choose best surface format (prefer SRGB)
        val surface_formats = vulkan_get_surface_formats(
            device.physical_device,
            device.surface
        )?
        val format = Self.choose_surface_format(&surface_formats)

        # Choose present mode (prefer Mailbox for triple buffering, fallback to Fifo)
        val present_modes = vulkan_get_surface_present_modes(
            device.physical_device,
            device.surface
        )?
        val present_mode = Self.choose_present_mode(&present_modes)

        # Choose extent (clamp to surface capabilities)
        val extent = Self.choose_extent(&capabilities, width, height)

        # Choose image count (prefer triple buffering: 3)
        val image_count = Self.choose_image_count(&capabilities)

        # Create swapchain
        val swapchain = vulkan_create_swapchain(
            device.device,
            device.surface,
            &format,
            &extent,
            image_count,
            present_mode,
            device.graphics_family,
            device.present_family
        )?

        # Get swapchain images
        val images = vulkan_get_swapchain_images(device.device, swapchain)?

        # Create image views for each swapchain image
        val image_views = images.map(|image| {
            vulkan_create_image_view(device.device, image, format.format)
        })

        return Ok(Swapchain {
            swapchain: swapchain,
            images: images,
            image_views: image_views,
            format: format,
            extent: extent,
            device: device.clone()
        })

    # Choose best surface format (prefer BGRA8_SRGB)
    fn choose_surface_format(formats: &Array<VkSurfaceFormatKHR>) -> VkSurfaceFormatKHR:
        # Prefer SRGB format
        for format in formats:
            if format.format == VK_FORMAT_B8G8R8A8_SRGB and
               format.color_space == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR:
                return format

        # Fallback to first available
        return formats[0]

    # Choose present mode (prefer Mailbox for triple buffering)
    fn choose_present_mode(modes: &Array<VkPresentModeKHR>) -> VkPresentModeKHR:
        # Prefer Mailbox (triple buffering, no tearing)
        if modes.contains(&VK_PRESENT_MODE_MAILBOX_KHR):
            return VK_PRESENT_MODE_MAILBOX_KHR

        # Fallback to Fifo (guaranteed available, vsync)
        return VK_PRESENT_MODE_FIFO_KHR

    # Choose extent (window size, clamped to capabilities)
    fn choose_extent(capabilities: &VkSurfaceCapabilitiesKHR, width: u32, height: u32)
        -> VkExtent2D:
        # If current extent is not special value, use it
        if capabilities.current_extent.width != 0xFFFFFFFF:
            return capabilities.current_extent

        # Otherwise, clamp requested size to capabilities
        val actual_width = clamp(
            width,
            capabilities.min_image_extent.width,
            capabilities.max_image_extent.width
        )
        val actual_height = clamp(
            height,
            capabilities.min_image_extent.height,
            capabilities.max_image_extent.height
        )

        return VkExtent2D {width: actual_width, height: actual_height}

    # Choose image count (prefer 3 for triple buffering)
    fn choose_image_count(capabilities: &VkSurfaceCapabilitiesKHR) -> u32:
        val desired = 3  # Triple buffering

        # Clamp to min/max
        var count = desired
        if count < capabilities.min_image_count:
            count = capabilities.min_image_count
        if capabilities.max_image_count > 0 and count > capabilities.max_image_count:
            count = capabilities.max_image_count

        return count

    # Acquire next swapchain image (vkAcquireNextImageKHR)
    pub async fn acquire_next_image_async(self, semaphore: i64)
        -> Future<Result<u32, SwapchainError>>:
        val result = await spawn_blocking(|| {
            vulkan_acquire_next_image(
                self.device.device,
                self.swapchain,
                u64.MAX,  # Timeout
                semaphore,
                VK_NULL_HANDLE  # No fence
            )
        })

        match result:
            case Ok(index):
                return Future.ready(Ok(index))
            case Err(VK_ERROR_OUT_OF_DATE_KHR):
                return Future.ready(Err(SwapchainError.OutOfDate))
            case Err(_):
                return Future.ready(Err(SwapchainError.DeviceLost))

    pub fn get_extent(self) -> VkExtent2D:
        """Get swapchain extent (width/height).

        Returns:
            Swapchain dimensions

        Example:
            val swapchain = Swapchain.new(&device, 800, 600)?
            val extent = swapchain.get_extent()
        """
        self.extent

    pub fn get_width(self) -> u32:
        """Get swapchain width.

        Returns:
            Width in pixels

        Example:
            val swapchain = Swapchain.new(&device, 800, 600)?
            assert(swapchain.get_width() == 800)
        """
        self.extent.width

    pub fn get_height(self) -> u32:
        """Get swapchain height.

        Returns:
            Height in pixels

        Example:
            val swapchain = Swapchain.new(&device, 800, 600)?
            assert(swapchain.get_height() == 600)
        """
        self.extent.height

    pub fn image_count(self) -> usize:
        """Get number of swapchain images.

        Returns:
            Number of images

        Example:
            val swapchain = Swapchain.new(&device, 800, 600)?
            val count = swapchain.image_count()
        """
        self.images.len()

    pub fn is_triple_buffered(self) -> bool:
        """Check if using triple buffering (3 images).

        Returns:
            True if 3 images

        Example:
            val swapchain = Swapchain.new(&device, 800, 600)?
            if swapchain.is_triple_buffered():
                print("Triple buffering enabled")
        """
        self.images.len() == 3

    pub fn is_double_buffered(self) -> bool:
        """Check if using double buffering (2 images).

        Returns:
            True if 2 images

        Example:
            val swapchain = Swapchain.new(&device, 800, 600)?
            if swapchain.is_double_buffered():
                print("Double buffering")
        """
        self.images.len() == 2

    pub fn aspect_ratio(self) -> f64:
        """Calculate swapchain aspect ratio.

        Returns:
            Width / height ratio

        Example:
            val swapchain = Swapchain.new(&device, 1920, 1080)?
            assert(swapchain.aspect_ratio() > 1.7)
        """
        (self.extent.width as f64) / (self.extent.height as f64)

    pub fn summary(self) -> text:
        """Get swapchain summary.

        Returns:
            Human-readable summary

        Example:
            val swapchain = Swapchain.new(&device, 800, 600)?
            print(swapchain.summary())
        """
        return "Swapchain: {self.extent.width}x{self.extent.height}, {self.images.len()} images"

