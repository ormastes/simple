# Vulkan FFI Bindings - Direct mapping to Rust rt_vk_* functions
#
# This module provides direct bindings to the Vulkan FFI layer implemented
# in Rust (src/runtime/src/value/vulkan_ffi/).
#
# All functions use handle-based API with u64 handles for resources.
# Error codes are returned as i32 (0 = success, negative = error).
#
# See vulkan_ffi_calls.spl for high-level wrapper types (VkDevice, VkBuffer,
# VkWindow, VkSwapchain, WindowEvent).

# =============================================================================
# Error Codes
# =============================================================================

val VK_SUCCESS = 0
val VK_ERROR_NOT_AVAILABLE = -1
val VK_ERROR_INVALID_HANDLE = -2
val VK_ERROR_OUT_OF_MEMORY = -3
val VK_ERROR_DEVICE_LOST = -4
val VK_ERROR_COMPILATION_FAILED = -5
val VK_ERROR_BUFFER_TOO_SMALL = -6
val VK_ERROR_INVALID_PARAMETER = -7
val VK_ERROR_SWAPCHAIN_OUT_OF_DATE = -8
val VK_ERROR_SURFACE_LOST = -9

# =============================================================================
# Availability Check
# =============================================================================

# Check if Vulkan is available on this system
# Returns: 1 if available, 0 if not
extern fn rt_vk_available() -> i32

# =============================================================================
# Device Management
# =============================================================================

# Create a Vulkan device with auto-selected GPU
# Returns: device handle (>0) on success, 0 on failure
extern fn rt_vk_device_create() -> u64

# Free a Vulkan device
# Returns: 0 on success, negative error code on failure
extern fn rt_vk_device_free(device_handle: u64) -> i32

# Wait for device to be idle (all operations complete)
# Returns: 0 on success, negative error code on failure
extern fn rt_vk_device_sync(device_handle: u64) -> i32

# =============================================================================
# Buffer Management
# =============================================================================

# Allocate a GPU buffer
# Returns: buffer handle (>0) on success, 0 on failure
extern fn rt_vk_buffer_alloc(device_handle: u64, size: u64) -> u64

# Free a GPU buffer
# Returns: 0 on success, negative error code on failure
extern fn rt_vk_buffer_free(buffer_handle: u64) -> i32

# Upload data from CPU to GPU buffer
# Returns: 0 on success, negative error code on failure
extern fn rt_vk_buffer_upload(buffer_handle: u64, data: *const u8, size: u64) -> i32

# Download data from GPU buffer to CPU
# Returns: 0 on success, negative error code on failure
extern fn rt_vk_buffer_download(buffer_handle: u64, data: *mut u8, size: u64) -> i32

# =============================================================================
# Compute Kernel Management
# =============================================================================

# Compile SPIR-V bytecode into a compute pipeline
# Returns: pipeline handle (>0) on success, 0 on failure
extern fn rt_vk_kernel_compile(device_handle: u64, spirv: *const u8, spirv_size: u64) -> u64

# Free a compute pipeline
# Returns: 0 on success, negative error code on failure
extern fn rt_vk_kernel_free(pipeline_handle: u64) -> i32

# Launch a compute kernel (3D dispatch)
# Returns: 0 on success, negative error code on failure
extern fn rt_vk_kernel_launch(
    pipeline_handle: u64,
    buffer_handles: *const u64,
    buffer_count: u64,
    grid_x: u32,
    grid_y: u32,
    grid_z: u32,
    block_x: u32,
    block_y: u32,
    block_z: u32
) -> i32

# Launch a compute kernel (1D dispatch)
# Returns: 0 on success, negative error code on failure
extern fn rt_vk_kernel_launch_1d(
    pipeline_handle: u64,
    buffer_handles: *const u64,
    buffer_count: u64,
    num_elements: u32
) -> i32

# =============================================================================
# Descriptor Management
# =============================================================================

# Create a descriptor layout for uniform buffer
extern fn rt_vk_descriptor_layout_create_uniform(device_handle: u64) -> u64

# Create a descriptor layout for sampler
extern fn rt_vk_descriptor_layout_create_sampler(device_handle: u64) -> u64

# Free a descriptor layout
extern fn rt_vk_descriptor_layout_free(layout_handle: u64) -> i32

# Create a descriptor pool
extern fn rt_vk_descriptor_pool_create(device_handle: u64, max_sets: u32) -> u64

# Free a descriptor pool
extern fn rt_vk_descriptor_pool_free(pool_handle: u64) -> i32

# Allocate a descriptor set from pool
extern fn rt_vk_descriptor_set_allocate(pool_handle: u64, layout_handle: u64) -> u64

# Free a descriptor set
extern fn rt_vk_descriptor_set_free(set_handle: u64) -> i32

# Update descriptor set with buffer binding
extern fn rt_vk_descriptor_set_update_buffer(
    set_handle: u64,
    binding: u32,
    buffer_handle: u64,
    offset: u64,
    range: u64
) -> i32

# =============================================================================
# Window Management
# =============================================================================

# Create a window with Vulkan surface
# Returns: window handle (>0) on success, 0 on failure
extern fn rt_vk_window_create(
    title: *const u8,
    title_len: u64,
    width: u32,
    height: u32
) -> u64

# Destroy a window
extern fn rt_vk_window_destroy(window_handle: u64) -> i32

# Get window size
# Returns dimensions via out parameters, returns 0 on success
extern fn rt_vk_window_get_size(
    window_handle: u64,
    width_out: *mut u32,
    height_out: *mut u32
) -> i32

# Set fullscreen mode (0=windowed, 1=borderless, 2=exclusive)
extern fn rt_vk_window_set_fullscreen(window_handle: u64, mode: i32) -> i32

# Poll for window events (non-blocking)
# Returns event data via out parameters
# event_type: 0=none, 1=resize, 2=close, 3=key, 4=mouse
extern fn rt_vk_window_poll_event(
    window_handle: u64,
    event_type_out: *mut i32,
    event_data_out: *mut u8,
    event_data_size: u64
) -> i32

# Wait for window event (blocking with timeout)
extern fn rt_vk_window_wait_event(
    window_handle: u64,
    timeout_ms: u64,
    event_type_out: *mut i32,
    event_data_out: *mut u8,
    event_data_size: u64
) -> i32

# =============================================================================
# Swapchain Management
# =============================================================================

# Create a swapchain for a window
extern fn rt_vk_swapchain_create(
    device_handle: u64,
    window_handle: u64,
    width: u32,
    height: u32
) -> u64

# Recreate swapchain (e.g., after window resize)
extern fn rt_vk_swapchain_recreate(
    swapchain_handle: u64,
    width: u32,
    height: u32
) -> i32

# Destroy a swapchain
extern fn rt_vk_swapchain_destroy(swapchain_handle: u64) -> i32

# Acquire next swapchain image for rendering
# Returns image index via out parameter
extern fn rt_vk_swapchain_acquire_next_image(
    swapchain_handle: u64,
    timeout_ns: u64,
    image_index_out: *mut u32
) -> i32

# Present the current swapchain image
extern fn rt_vk_swapchain_present(swapchain_handle: u64, image_index: u32) -> i32

# Get swapchain image count
extern fn rt_vk_swapchain_get_image_count(swapchain_handle: u64) -> u32

# Get swapchain extent (width, height)
extern fn rt_vk_swapchain_get_extent(
    swapchain_handle: u64,
    width_out: *mut u32,
    height_out: *mut u32
) -> i32
