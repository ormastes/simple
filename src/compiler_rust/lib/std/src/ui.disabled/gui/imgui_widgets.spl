# Immediate Mode GUI - Widget Implementation
#
# ImGui widget implementations (label, button, checkbox, slider, text_edit),
# WindowScope, layout helpers, input handling, and supporting types.
# Part of the ImGui module - see imgui.spl for type definitions.

use core.*
use ui.element.*
use ui.gui.imgui.*

# =============================================================================
# ImGui Implementation
# =============================================================================

impl ImGui:
    # Create new ImGui instance
    pub fn new() -> ImGui:
        return ImGui.with_context(ImGuiContext.new())

    pub fn with_context(ctx: ImGuiContext) -> ImGui:
        return ImGui {
            ctx: ctx,
            current_window: None,
            current_container: None,
            cursor: Point2D.new(0.0, 0.0),
            layout_stack: [],
            hot_id: None,
            active_id: None,
            keyboard_focus: None,
            mouse_pos: Point2D.new(0.0, 0.0),
            mouse_down: false,
            mouse_clicked: false,
            keys_down: Set.new(),
            id_stack: [],
            next_id: 0,
            draw_list: DrawList.new()
        }

    # Get the draw list for rendering
    pub fn get_draw_list(&self) -> &DrawList:
        &self.draw_list

    # Clear draw list for new frame
    pub fn clear_draw_list(&mut self):
        self.draw_list.clear()

    # Begin new frame
    pub fn begin_frame(self):
        self.mouse_clicked = false
        self.hot_id = None

    # End frame and generate render commands
    pub fn end_frame(self):
        # Cleanup per-frame state
        if not self.mouse_down:
            self.active_id = None

    # Create a window
    pub fn window(self, title: &str) -> WindowScope:
        val window_id = self.hash_str(title)

        # Get or create window state
        var win = self.ctx.windows.get(title).cloned().unwrap_or_else(||:
            WindowState {
                id: title.to_string(),
                title: title.to_string(),
                pos: Point2D.new(100.0, 100.0),
                size: Size2D.new(300.0, 400.0),
                collapsed: false,
                focused: false,
                dragging: false,
                drag_offset: Point2D.new(0.0, 0.0)
            }
        )

        # Handle window dragging
        val title_bar_rect = Rect.new(win.pos.x, win.pos.y, win.size.width, 30.0)
        if title_bar_rect.contains(self.mouse_pos) and self.mouse_clicked:
            win.dragging = true
            win.drag_offset = Point2D.new(
                self.mouse_pos.x - win.pos.x,
                self.mouse_pos.y - win.pos.y
            )

        if win.dragging:
            if self.mouse_down:
                win.pos.x = self.mouse_pos.x - win.drag_offset.x
                win.pos.y = self.mouse_pos.y - win.drag_offset.y
            else:
                win.dragging = false

        # Setup layout
        self.cursor = Point2D.new(win.pos.x + 10.0, win.pos.y + 40.0)
        self.push_layout(LayoutInfo {
            direction: LayoutDirection.Vertical,
            spacing: 5.0,
            padding: 10.0,
            available_width: win.size.width - 20.0,
            available_height: win.size.height - 50.0,
            cursor_x: self.cursor.x,
            cursor_y: self.cursor.y
        })

        self.current_window = Some(win)
        return WindowScope { gui: self }

# Window scope (RAII-style)
pub struct WindowScope:
    gui: &mut ImGui

impl WindowScope:
    pub fn end(self):
        if val Some(win) = &self.gui.current_window:
            self.gui.ctx.windows.insert(win.id.clone(), win.clone())
        self.gui.current_window = None
        self.gui.pop_layout()

# =============================================================================
# Widget Functions
# =============================================================================

impl ImGui:
    # Label widget (non-interactive text)
    pub fn label(self, label_text: &str) -> Response:
        val id = self.generate_id()
        val layout = self.current_layout()

        val size = Size2D.new(layout.available_width, 20.0)
        val rect = Rect.new(self.cursor.x, self.cursor.y, size.width, size.height)

        # Emit render command for text
        self.draw_list.add_text(
            rect.x + 4.0,
            rect.y + 2.0,
            label_text.to_string(),
            Color.White,
            14.0
        )

        self.advance_cursor(size.height + layout.spacing)

        return Response {
            id: id,
            rect: rect,
            clicked: false,
            hovered: false,
            dragged: false,
            drag_delta: Point2D.new(0.0, 0.0),
            has_keyboard_focus: false,
            changed: false
        }

    # Button widget
    pub fn button(self, label: &str) -> bool:
        val id = self.generate_id()
        val layout = self.current_layout()

        val size = Size2D.new(layout.available_width, 30.0)
        val rect = Rect.new(self.cursor.x, self.cursor.y, size.width, size.height)

        val hovered = rect.contains(self.mouse_pos)
        val clicked = hovered and self.mouse_clicked

        if hovered:
            self.hot_id = Some(id)

        if clicked:
            self.active_id = Some(id)

        # Emit render command for button background
        val bg_color = if clicked:
            Color.Ansi256(240)
        else if hovered:
            Color.Ansi256(245)
        else:
            Color.Ansi256(242)

        self.draw_list.add_rounded_rect(
            rect.x, rect.y, rect.width, rect.height,
            4.0,
            bg_color
        )

        # Emit render command for button text
        self.draw_list.add_text(
            rect.x + rect.width / 2.0 - 20.0,
            rect.y + 8.0,
            label.to_string(),
            Color.White,
            14.0
        )

        self.advance_cursor(size.height + layout.spacing)

        return clicked

    # Checkbox widget
    pub fn checkbox(self, label: &str, checked: &mut bool) -> Response:
        val id = self.generate_id()
        val layout = self.current_layout()

        val size = Size2D.new(20.0, 20.0)
        val rect = Rect.new(self.cursor.x, self.cursor.y, size.width, size.height)

        val hovered = rect.contains(self.mouse_pos)
        val clicked = hovered and self.mouse_clicked

        if clicked:
            *checked = not *checked

        # Emit render command for checkbox box
        val box_color = if hovered:
            Color.Ansi256(245)
        else:
            Color.Ansi256(240)

        self.draw_list.add_rect_outline(
            rect.x, rect.y, rect.width, rect.height,
            box_color,
            2.0
        )

        # Draw checkmark if checked
        if *checked:
            self.draw_list.add_line(
                rect.x + 4.0, rect.y + 10.0,
                rect.x + 8.0, rect.y + 14.0,
                Color.Green, 2.0
            )
            self.draw_list.add_line(
                rect.x + 8.0, rect.y + 14.0,
                rect.x + 16.0, rect.y + 4.0,
                Color.Green, 2.0
            )

        # Draw label text
        self.draw_list.add_text(
            rect.x + rect.width + 8.0,
            rect.y + 2.0,
            label.to_string(),
            Color.White,
            14.0
        )

        self.advance_cursor(size.height + layout.spacing)

        return Response {
            id: id,
            rect: rect,
            clicked: clicked,
            hovered: hovered,
            dragged: false,
            drag_delta: Point2D.new(0.0, 0.0),
            has_keyboard_focus: false,
            changed: clicked
        }

    # Slider widget
    pub fn slider(self, label: &str, value: &mut f32, min: f32, max: f32) -> Response:
        val id = self.generate_id()
        val layout = self.current_layout()

        val size = Size2D.new(layout.available_width, 20.0)
        val rect = Rect.new(self.cursor.x, self.cursor.y, size.width, size.height)

        val hovered = rect.contains(self.mouse_pos)
        var changed = false

        if hovered and self.mouse_down:
            self.active_id = Some(id)

        if self.active_id == Some(id) and self.mouse_down:
            # Calculate value from mouse position
            val normalized = (self.mouse_pos.x - rect.x) / rect.width
            val clamped = normalized.max(0.0).min(1.0)
            *value = min + (max - min) * clamped
            changed = true

        # Emit render command for slider track
        val track_height = 4.0
        val track_y = rect.y + (rect.height - track_height) / 2.0
        self.draw_list.add_rounded_rect(
            rect.x, track_y, rect.width, track_height,
            2.0,
            Color.Ansi256(238)
        )

        # Calculate handle position
        val normalized_value = (*value - min) / (max - min)
        val handle_x = rect.x + normalized_value * (rect.width - 12.0)
        val handle_size = 12.0

        # Emit render command for slider handle
        val handle_color = if self.active_id == Some(id):
            Color.Blue
        else if hovered:
            Color.Cyan
        else:
            Color.White

        self.draw_list.add_circle(
            handle_x + handle_size / 2.0,
            rect.y + rect.height / 2.0,
            handle_size / 2.0,
            handle_color
        )

        # Draw label and value
        self.draw_list.add_text(
            rect.x + rect.width + 8.0,
            rect.y + 2.0,
            "{label}: {*value:.2}",
            Color.White,
            12.0
        )

        self.advance_cursor(size.height + layout.spacing)

        return Response {
            id: id,
            rect: rect,
            clicked: false,
            hovered: hovered,
            dragged: self.active_id == Some(id),
            drag_delta: Point2D.new(0.0, 0.0),
            has_keyboard_focus: false,
            changed: changed
        }

    # Text input widget
    pub fn text_edit(self, label: &str, text: &mut text) -> Response:
        val id = self.generate_id()
        val layout = self.current_layout()

        val size = Size2D.new(layout.available_width, 30.0)
        val rect = Rect.new(self.cursor.x, self.cursor.y, size.width, size.height)

        val hovered = rect.contains(self.mouse_pos)
        val clicked = hovered and self.mouse_clicked
        var changed = false

        if clicked:
            self.keyboard_focus = Some(id)

        val has_focus = self.keyboard_focus == Some(id)

        if has_focus:
            # Handle text input
            for key in &self.keys_down:
                match key:
                    case KeyCode.Char(c):
                        text.push(*c)
                        changed = true
                    case KeyCode.Backspace:
                        if not text.is_empty():
                            text.pop()
                            changed = true
                    case _:
                        pass

        # Emit render command for text input background
        val bg_color = if has_focus:
            Color.Ansi256(238)
        else if hovered:
            Color.Ansi256(240)
        else:
            Color.Ansi256(236)

        self.draw_list.add_rect(
            rect.x, rect.y, rect.width, rect.height,
            bg_color
        )

        # Emit render command for text input border
        val border_color = if has_focus:
            Color.Blue
        else:
            Color.Ansi256(245)

        self.draw_list.add_rect_outline(
            rect.x, rect.y, rect.width, rect.height,
            border_color,
            1.0
        )

        # Emit render command for text content
        self.draw_list.add_text(
            rect.x + 8.0,
            rect.y + 8.0,
            text.to_string(),
            Color.White,
            14.0
        )

        # Draw cursor if focused
        if has_focus:
            val cursor_x = rect.x + 8.0 + (text.len() as f32) * 8.0
            self.draw_list.add_line(
                cursor_x, rect.y + 4.0,
                cursor_x, rect.y + rect.height - 4.0,
                Color.White, 1.0
            )

        # Draw label
        self.draw_list.add_text(
            rect.x + rect.width + 8.0,
            rect.y + 8.0,
            label.to_string(),
            Color.Ansi256(250),
            12.0
        )

        self.advance_cursor(size.height + layout.spacing)

        return Response {
            id: id,
            rect: rect,
            clicked: clicked,
            hovered: hovered,
            dragged: false,
            drag_delta: Point2D.new(0.0, 0.0),
            has_keyboard_focus: has_focus,
            changed: changed
        }

    # Horizontal separator
    pub fn separator(self):
        val layout = self.current_layout()

        # Emit render command for separator line
        val y = self.cursor.y + 5.0
        self.draw_list.add_line(
            self.cursor.x, y,
            self.cursor.x + layout.available_width, y,
            Color.Ansi256(240),
            1.0
        )

        self.advance_cursor(10.0)

    # Collapsing header
    pub fn collapsing_header(self, label: &str, default_open: bool) -> HeaderScope:
        val id = self.generate_id()
        val layout = self.current_layout()

        # Get or create state
        var is_open = self.ctx.widget_state.get(&id)
            .and_then(|s|: s.value.as_bool())
            .unwrap_or(default_open)

        val size = Size2D.new(layout.available_width, 25.0)
        val rect = Rect.new(self.cursor.x, self.cursor.y, size.width, size.height)

        val hovered = rect.contains(self.mouse_pos)
        val clicked = hovered and self.mouse_clicked

        if clicked:
            is_open = not is_open
            self.ctx.widget_state.insert(id, WidgetState {
                value: Any.bool(is_open),
                animation: 0.0,
                last_interaction: self.ctx.last_frame_time
            })

        # Emit render command for header background
        val bg_color = if clicked:
            Color.Ansi256(238)
        else if hovered:
            Color.Ansi256(242)
        else:
            Color.Ansi256(240)

        self.draw_list.add_rect(
            rect.x, rect.y, rect.width, rect.height,
            bg_color
        )

        # Emit render command for arrow indicator
        val arrow_x = rect.x + 8.0
        val arrow_y = rect.y + rect.height / 2.0
        if is_open:
            # Down arrow (V shape)
            self.draw_list.add_line(
                arrow_x, arrow_y - 3.0,
                arrow_x + 5.0, arrow_y + 3.0,
                Color.White, 2.0
            )
            self.draw_list.add_line(
                arrow_x + 5.0, arrow_y + 3.0,
                arrow_x + 10.0, arrow_y - 3.0,
                Color.White, 2.0
            )
        else:
            # Right arrow (> shape)
            self.draw_list.add_line(
                arrow_x, arrow_y - 5.0,
                arrow_x + 6.0, arrow_y,
                Color.White, 2.0
            )
            self.draw_list.add_line(
                arrow_x + 6.0, arrow_y,
                arrow_x, arrow_y + 5.0,
                Color.White, 2.0
            )

        # Emit render command for header label
        self.draw_list.add_text(
            rect.x + 24.0,
            rect.y + 5.0,
            label.to_string(),
            Color.White,
            14.0
        )

        self.advance_cursor(size.height + layout.spacing)

        return HeaderScope {
            gui: self,
            is_open: is_open
        }

# Header scope
pub struct HeaderScope:
    gui: &mut ImGui
    is_open: bool

impl HeaderScope:
    pub fn is_open(self) -> bool:
        return self.is_open

    pub fn end(self):
        pass  # Nothing to clean up

# =============================================================================
# Layout Helpers
# =============================================================================

impl ImGui:
    fn push_layout(info: LayoutInfo):
        self.layout_stack.push(info)

    fn pop_layout():
        self.layout_stack.pop()

    fn current_layout() -> &LayoutInfo:
        return &self.layout_stack[self.layout_stack.len() - 1]

    fn advance_cursor(amount: f32):
        val layout = self.current_layout()
        match layout.direction:
            case LayoutDirection.Vertical:
                self.cursor.y = self.cursor.y + amount
            case LayoutDirection.Horizontal:
                self.cursor.x = self.cursor.x + amount

# =============================================================================
# ID Generation
# =============================================================================

impl ImGui:
    fn generate_id() -> WidgetId:
        val id = self.next_id
        self.next_id = self.next_id + 1
        return id

    fn hash_str(s: &str) -> u64:
        var hash: u64 = 5381
        for c in s.chars():
            hash = ((hash << 5) + hash) + (c as u64)
        return hash

# =============================================================================
# Context Implementation
# =============================================================================

impl ImGuiContext:
    static fn new() -> ImGuiContext:
        return ImGuiContext {
            windows: Dict.new(),
            widget_state: Dict.new(),
            last_frame_time: 0.0,
            delta_time: 0.0
        }

# =============================================================================
# Input Handling
# =============================================================================

impl ImGui:
    pub fn handle_mouse_move(self, x: f32, y: f32):
        self.mouse_pos = Point2D.new(x, y)

    pub fn handle_mouse_down(self, x: f32, y: f32):
        self.mouse_pos = Point2D.new(x, y)
        self.mouse_down = true
        self.mouse_clicked = true

    pub fn handle_mouse_up(self, x: f32, y: f32):
        self.mouse_pos = Point2D.new(x, y)
        self.mouse_down = false

    pub fn handle_key_down(self, key: KeyCode):
        self.keys_down.insert(key)

    pub fn handle_key_up(self, key: KeyCode):
        self.keys_down.remove(&key)

# Placeholder for Any type (would use real Any in production)
enum Any:
    bool(bool)
    i32(i64)
    f32(f64)
    text(text)

impl Any:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_bool(self) -> bool:
        """Check if this is a boolean value."""
        match self:
            case bool(_): true
            case _: false

    pub fn is_int(self) -> bool:
        """Check if this is an integer value."""
        match self:
            case i32(_): true
            case _: false

    pub fn is_float(self) -> bool:
        """Check if this is a f32 value."""
        match self:
            case f32(_): true
            case _: false

    pub fn is_string(self) -> bool:
        """Check if this is a string value."""
        match self:
            case text(_): true
            case _: false

    pub fn is_numeric(self) -> bool:
        """Check if this is a numeric value (i32 or f32)."""
        self.is_int() or self.is_float()

    pub fn to_string(self) -> text:
        """Convert to string representation."""
        match self:
            case bool(b): return if b: "true" else: "false"
            case i32(i): return i.to_string()
            case f32(f): return f.to_string()
            case text(s): return s

    pub fn description(self) -> text:
        """Get description of this value type."""
        match self:
            case bool(_): return "Boolean value"
            case i32(_): return "Integer value"
            case f32(_): return "Floating-point value"
            case text(_): return "text value"

    # =========================================================================
    # Existing Methods
    # =========================================================================

    fn as_bool() -> Option<bool>:
        match self:
            case Any.bool(b): return Some(b)
            case _: return None

# Key codes (simplified)
enum KeyCode:
    Char(char)
    Enter
    Backspace
    Escape
    Tab
    Up
    Down
    Left
    Right

impl KeyCode:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn to_string(self) -> text:
        """Convert to string representation."""
        match self:
            case Char(c): return c.to_string()
            case Enter: return "Enter"
            case Backspace: return "Backspace"
            case Escape: return "Escape"
            case Tab: return "Tab"
            case Up: return "Up"
            case Down: return "Down"
            case Left: return "Left"
            case Right: return "Right"

    pub fn description(self) -> text:
        """Get description of this key."""
        match self:
            case Char(_): return "Character key"
            case Enter: return "Enter/Return key"
            case Backspace: return "Backspace key"
            case Escape: return "Escape key"
            case Tab: return "Tab key"
            case Up: return "Up arrow key"
            case Down: return "Down arrow key"
            case Left: return "Left arrow key"
            case Right: return "Right arrow key"

    pub fn is_char(self) -> bool:
        """Check if this is a character key."""
        match self:
            case Char(_): true
            case _: false

    pub fn is_enter(self) -> bool:
        """Check if this is the Enter key."""
        match self:
            case Enter: true
            case _: false

    pub fn is_backspace(self) -> bool:
        """Check if this is the Backspace key."""
        match self:
            case Backspace: true
            case _: false

    pub fn is_escape(self) -> bool:
        """Check if this is the Escape key."""
        match self:
            case Escape: true
            case _: false

    pub fn is_tab(self) -> bool:
        """Check if this is the Tab key."""
        match self:
            case Tab: true
            case _: false

    pub fn is_arrow(self) -> bool:
        """Check if this is an arrow key."""
        match self:
            case Up: true
            case Down: true
            case Left: true
            case Right: true
            case _: false

    pub fn is_navigation(self) -> bool:
        """Check if this is a navigation key (arrows, Enter, Escape, Tab)."""
        self.is_arrow() or self.is_enter() or self.is_escape() or self.is_tab()

    pub fn is_text_editing(self) -> bool:
        """Check if this is a text editing key (char or backspace)."""
        self.is_char() or self.is_backspace()
