# Vulkan GUI Renderer - Layout, Drawing, and Vertex Management
#
# Layout computation, element rendering (draw_box, draw_text, draw_image),
# UIVertex, VertexCache, and shader pipeline setup.
# Part of the renderer module - see vulkan_renderer.spl for VulkanRenderer
# struct and RenderBackend implementation.
# Extended helpers (PipelineBuilder, Attributes, parsers, event converters)
# moved to vulkan_renderer_pipeline.spl.

use core.*
use concurrency.*
use ui.element.*
use ui.attrs.*
use ui.patchset.*
use ui.renderer.*
use ui.gui.vulkan_types.*
use ui.gui.vulkan_buffers.*
use ui.gui.vulkan_ffi.*

# =============================================================================
# Layout Computation
# =============================================================================

impl VulkanRenderer:
    # Recursively compute layout for element tree
    async fn compute_layout(&mut self, node: &Node, parent_layout: Layout) -> Result<(), RenderError>:
        match node:
            case Node.Container(container):
                # Apply container's layout attributes
                val layout = self.compute_container_layout(container, parent_layout)
                self.layout_cache.set(container.id(), layout)

                # Layout children
                var child_y = layout.content_y
                for child in &container.children:
                    val child_layout = Layout.new(
                        layout.content_x,
                        child_y,
                        layout.content_width,
                        20  # Default height, will be refined
                    )
                    await self.compute_layout(child, child_layout)?
                    child_y += 20

            case Node.Text(text):
                # Text layout is simple - just bounding box
                val layout = Layout.new(
                    parent_layout.x,
                    parent_layout.y,
                    parent_layout.width,
                    20  # Single line height
                )
                self.layout_cache.set(text.id(), layout)

            case Node.Button(button):
                # Button has fixed height, centered text
                val layout = Layout.new(
                    parent_layout.x,
                    parent_layout.y,
                    parent_layout.width,
                    30  # Button height
                )
                self.layout_cache.set(button.id(), layout)

            case _:
                # Other elements use parent layout
                pass

        Ok(())

    fn compute_container_layout(&self, container: &Container, parent: Layout) -> Layout:
        # Extract layout attributes
        var layout = parent

        # Apply width/height if specified
        if val Some(width) = container.attrs.get_width():
            layout.width = width
        if val Some(height) = container.attrs.get_height():
            layout.height = height

        # Apply padding
        val padding = container.attrs.get_padding().unwrap_or((0, 0, 0, 0))
        layout = layout.with_padding(padding.0, padding.1, padding.2, padding.3)

        layout

    pub fn get_width(self) -> u16:
        """Get renderer window width.

        Returns:
            Width in pixels

        Example:
            val renderer = VulkanRenderer.new(handle, 800, 600)
            assert(renderer.get_width() == 800)
        """
        self.width

    pub fn get_height(self) -> u16:
        """Get renderer window height.

        Returns:
            Height in pixels

        Example:
            val renderer = VulkanRenderer.new(handle, 800, 600)
            assert(renderer.get_height() == 600)
        """
        self.height

    pub fn is_initialized(self) -> bool:
        """Check if renderer is initialized.

        Returns:
            True if initialized

        Example:
            var renderer = VulkanRenderer.new(handle, 800, 600)
            assert(not renderer.is_initialized())
            renderer.init().await?
            assert(renderer.is_initialized())
        """
        self.is_initialized

    pub fn has_device(self) -> bool:
        """Check if Vulkan device is created.

        Returns:
            True if device exists

        Example:
            val renderer = VulkanRenderer.new(handle, 800, 600)
            if renderer.has_device():
                print("Device ready")
        """
        self.device.is_some()

    pub fn has_font_atlas(self) -> bool:
        """Check if font atlas is loaded.

        Returns:
            True if font atlas exists

        Example:
            val renderer = VulkanRenderer.new(handle, 800, 600)
            if renderer.has_font_atlas():
                print("Text rendering available")
        """
        self.font_atlas.is_some()

    pub fn vertex_count(self) -> usize:
        """Get current vertex cache size.

        Returns:
            Number of cached vertices

        Example:
            val renderer = VulkanRenderer.new(handle, 800, 600)
            val count = renderer.vertex_count()
        """
        self.vertex_cache.vertices.len()

    pub fn aspect_ratio(self) -> f64:
        """Calculate window aspect ratio.

        Returns:
            Width / height ratio

        Example:
            val renderer = VulkanRenderer.new(handle, 1920, 1080)
            assert(renderer.aspect_ratio() > 1.7)
        """
        (self.width as f64) / (self.height as f64)

    pub fn is_landscape(self) -> bool:
        """Check if window is landscape orientation.

        Returns:
            True if width > height

        Example:
            val renderer = VulkanRenderer.new(handle, 1920, 1080)
            assert(renderer.is_landscape())
        """
        self.width > self.height

    pub fn summary(self) -> text:
        """Get renderer summary.

        Returns:
            Human-readable summary

        Example:
            val renderer = VulkanRenderer.new(handle, 800, 600)
            print(renderer.summary())
        """
        val state = if self.is_initialized: "initialized" else: "uninitialized"
        return "VulkanRenderer: {self.width}x{self.height}, {state}, {self.vertex_count()} vertices"
    }

# =============================================================================
# Vertex Generation
# =============================================================================

impl VulkanRenderer:
    # Generate vertices for element rendering
    async fn generate_vertices(&mut self, node: &Node) -> Result<(), RenderError>:
        match node:
            case Node.Container(container):
                # Draw container background
                if val Some(layout) = self.layout_cache.get(container.id()):
                    val bg_color = container.attrs.get_background_color().unwrap_or([0.2, 0.2, 0.2, 1.0])
                    self.vertex_cache.add_rect(
                        layout.x as f32,
                        layout.y as f32,
                        layout.width as f32,
                        layout.height as f32,
                        bg_color
                    )

                # Render children
                for child in &container.children:
                    await self.generate_vertices(child)?

            case Node.Text(text):
                # Render text using font atlas
                if val Some(layout) = self.layout_cache.get(text.id()):
                    val color = text.attrs.get_color().unwrap_or([1.0, 1.0, 1.0, 1.0])
                    val font_atlas = self.font_atlas.as_ref().unwrap()

                    match await font_atlas.add_text(
                        &mut self.vertex_cache,
                        &text.content,
                        layout.x as f32,
                        layout.y as f32,
                        color
                    ):
                        case Ok(_): pass
                        case Err(e): return Err(RenderError.IoError(e))

            case Node.Button(button):
                # Draw button background
                if val Some(layout) = self.layout_cache.get(button.id()):
                    val bg_color = button.attrs.get_background_color().unwrap_or([0.3, 0.5, 0.8, 1.0])
                    self.vertex_cache.add_rect(
                        layout.x as f32,
                        layout.y as f32,
                        layout.width as f32,
                        layout.height as f32,
                        bg_color
                    )

                    # Draw button text (centered)
                    val text_color = button.attrs.get_color().unwrap_or([1.0, 1.0, 1.0, 1.0])
                    val font_atlas = self.font_atlas.as_ref().unwrap()

                    # Compute text dimensions for centering (monospace: 8x16 pixels)
                    val glyph_width: f32 = 8.0
                    val glyph_height: f32 = 16.0
                    val text_width = button.label.len() as f32 * glyph_width
                    val text_height = glyph_height

                    # Center text horizontally and vertically within button
                    val text_x = layout.x as f32 + (layout.width as f32 - text_width) / 2.0
                    val text_y = layout.y as f32 + (layout.height as f32 - text_height) / 2.0

                    match await font_atlas.add_text(
                        &mut self.vertex_cache,
                        &button.label,
                        text_x,
                        text_y,
                        text_color
                    ):
                        case Ok(_): pass
                        case Err(e): return Err(RenderError.IoError(e))

            case _:
                pass

        Ok(())
    }

# =============================================================================
# UI Vertex Format
# =============================================================================

pub struct UIVertex:
    position: [f32; 2]    # Screen position (0..width, 0..height)
    tex_coord: [f32; 2]   # Texture coordinates (0..1, 0..1)
    color: [f32; 4]       # RGBA color (0..1)

impl UIVertex:
    pub fn get_position(self) -> (f32, f32):
        """Get vertex position.

        Returns:
            (x, y) screen coordinates

        Example:
            val v = UIVertex { position: [100.0, 200.0], tex_coord: [0.0, 0.0], color: [1.0, 1.0, 1.0, 1.0] }
            val (x, y) = v.get_position()
            assert(x == 100.0 and y == 200.0)
        """
        (self.position[0], self.position[1])

    pub fn get_tex_coord(self) -> (f32, f32):
        """Get texture coordinates.

        Returns:
            (u, v) texture coordinates

        Example:
            val v = UIVertex { position: [0.0, 0.0], tex_coord: [0.5, 0.5], color: [1.0, 1.0, 1.0, 1.0] }
            val (u, v) = v.get_tex_coord()
            assert(u == 0.5 and v == 0.5)
        """
        (self.tex_coord[0], self.tex_coord[1])

    pub fn get_color(self) -> [f32; 4]:
        """Get vertex color.

        Returns:
            RGBA color array

        Example:
            val v = UIVertex { position: [0.0, 0.0], tex_coord: [0.0, 0.0], color: [1.0, 0.0, 0.0, 1.0] }
            val c = v.get_color()
            assert(c[0] == 1.0)  # Red
        """
        self.color

    pub fn is_textured(self) -> bool:
        """Check if vertex has non-zero texture coordinates.

        Returns:
            True if texture coordinates are non-zero

        Example:
            val v = UIVertex { position: [0.0, 0.0], tex_coord: [0.5, 0.5], color: [1.0, 1.0, 1.0, 1.0] }
            assert(v.is_textured())
        """
        self.tex_coord[0] != 0.0 or self.tex_coord[1] != 0.0

    pub fn is_opaque(self) -> bool:
        """Check if vertex color is fully opaque.

        Returns:
            True if alpha is 1.0

        Example:
            val v = UIVertex { position: [0.0, 0.0], tex_coord: [0.0, 0.0], color: [1.0, 1.0, 1.0, 1.0] }
            assert(v.is_opaque())
        """
        self.color[3] == 1.0

    pub fn is_transparent(self) -> bool:
        """Check if vertex has any transparency.

        Returns:
            True if alpha < 1.0

        Example:
            val v = UIVertex { position: [0.0, 0.0], tex_coord: [0.0, 0.0], color: [1.0, 1.0, 1.0, 0.5] }
            assert(v.is_transparent())
        """
        self.color[3] < 1.0

    pub fn summary(self) -> text:
        """Get vertex summary.

        Returns:
            Human-readable summary

        Example:
            val v = UIVertex { position: [100.0, 200.0], tex_coord: [0.0, 0.0], color: [1.0, 1.0, 1.0, 1.0] }
            print(v.summary())
        """
        val (x, y) = self.get_position()
        return "UIVertex: pos({x:.1}, {y:.1}), tex({self.tex_coord[0]:.2}, {self.tex_coord[1]:.2}), alpha={self.color[3]:.2}"

# =============================================================================
# Vertex Cache - Batches UI drawing
# =============================================================================

pub struct VertexCache:
    vertices: Array<UIVertex>

impl VertexCache:
    pub fn new() -> VertexCache:
        VertexCache {
            vertices: Array.new()
        }

    pub fn clear(&mut self):
        self.vertices.clear()

    # Add a colored rectangle (2 triangles = 6 vertices)
    pub fn add_rect(&mut self, x: f32, y: f32, w: f32, h: f32, color: [f32; 4]):
        # Triangle 1: top-left, top-right, bottom-left
        self.vertices.push(UIVertex {
            position: [x, y],
            tex_coord: [0.0, 0.0],
            color: color,
        })
        self.vertices.push(UIVertex {
            position: [x + w, y],
            tex_coord: [1.0, 0.0],
            color: color,
        })
        self.vertices.push(UIVertex {
            position: [x, y + h],
            tex_coord: [0.0, 1.0],
            color: color,
        })

        # Triangle 2: bottom-left, top-right, bottom-right
        self.vertices.push(UIVertex {
            position: [x, y + h],
            tex_coord: [0.0, 1.0],
            color: color,
        })
        self.vertices.push(UIVertex {
            position: [x + w, y],
            tex_coord: [1.0, 0.0],
            color: color,
        })
        self.vertices.push(UIVertex {
            position: [x + w, y + h],
            tex_coord: [1.0, 1.0],
            color: color,
        })

    pub fn vertex_count(self) -> usize:
        """Get number of vertices in cache.

        Returns:
            Vertex count

        Example:
            val cache = VertexCache.new()
            assert(cache.vertex_count() == 0)
        """
        self.vertices.len()

    pub fn is_empty(self) -> bool:
        """Check if cache is empty.

        Returns:
            True if no vertices

        Example:
            val cache = VertexCache.new()
            assert(cache.is_empty())
        """
        self.vertices.len() == 0

    pub fn triangle_count(self) -> usize:
        """Get number of triangles (vertices / 3).

        Returns:
            Triangle count

        Example:
            var cache = VertexCache.new()
            cache.add_rect(0.0, 0.0, 100.0, 100.0, [1.0, 1.0, 1.0, 1.0])
            assert(cache.triangle_count() == 2)
        """
        self.vertices.len() / 3

    pub fn rect_count(self) -> usize:
        """Estimate number of rectangles (triangles / 2).

        Returns:
            Estimated rect count

        Example:
            var cache = VertexCache.new()
            cache.add_rect(0.0, 0.0, 100.0, 100.0, [1.0, 1.0, 1.0, 1.0])
            assert(cache.rect_count() == 1)
        """
        self.triangle_count() / 2

    pub fn has_vertices(self) -> bool:
        """Check if cache has any vertices.

        Returns:
            True if vertices exist

        Example:
            var cache = VertexCache.new()
            assert(not cache.has_vertices())
            cache.add_rect(0.0, 0.0, 100.0, 100.0, [1.0, 1.0, 1.0, 1.0])
            assert(cache.has_vertices())
        """
        self.vertices.len() > 0

    pub fn is_large(self) -> bool:
        """Check if cache has many vertices (>10000).

        Returns:
            True if vertex count exceeds 10000

        Example:
            val cache = VertexCache.new()
            if cache.is_large():
                print("Large vertex cache, consider batching")
        """
        self.vertices.len() > 10000

    pub fn summary(self) -> text:
        """Get vertex cache summary.

        Returns:
            Human-readable summary

        Example:
            val cache = VertexCache.new()
            print(cache.summary())
        """
        val tris = self.triangle_count()
        val rects = self.rect_count()
        return "VertexCache: {self.vertices.len()} vertices, {tris} triangles, ~{rects} rects"

# =============================================================================
# Font Atlas - Imported from vulkan_font.spl
# =============================================================================
# FontAtlas and related types are imported from ui.gui.vulkan_font

impl VertexCache:
    # Add textured rectangle for glyph rendering
    pub fn add_textured_rect(
        &mut self,
        x: f32,
        y: f32,
        w: f32,
        h: f32,
        tx: f32,
        ty: f32,
        tw: f32,
        th: f32,
        color: [f32; 4]
    ):
        # Similar to add_rect but with custom texture coordinates
        # Triangle 1
        self.vertices.push(UIVertex {
            position: [x, y],
            tex_coord: [tx, ty],
            color: color,
        })
        self.vertices.push(UIVertex {
            position: [x + w, y],
            tex_coord: [tx + tw, ty],
            color: color,
        })
        self.vertices.push(UIVertex {
            position: [x, y + h],
            tex_coord: [tx, ty + th],
            color: color,
        })

        # Triangle 2
        self.vertices.push(UIVertex {
            position: [x, y + h],
            tex_coord: [tx, ty + th],
            color: color,
        })
        self.vertices.push(UIVertex {
            position: [x + w, y],
            tex_coord: [tx + tw, ty],
            color: color,
        })
        self.vertices.push(UIVertex {
            position: [x + w, y + h],
            tex_coord: [tx + tw, ty + th],
            color: color,
        })
