# Vulkan GUI Renderer - Layout, Drawing, and Vertex Management
#
# Layout computation, element rendering (draw_box, draw_text, draw_image),
# UIVertex, VertexCache, and shader pipeline setup.
# Part of the renderer module - see vulkan_renderer.spl for VulkanRenderer
# struct and RenderBackend implementation.

use core.*
use concurrency.*
use ui.element.*
use ui.attrs.*
use ui.patchset.*
use ui.renderer.*
use ui.gui.vulkan_types.*
use ui.gui.vulkan_buffers.*
use ui.gui.vulkan_ffi.*

# =============================================================================
# Layout Computation
# =============================================================================

impl VulkanRenderer:
    # Recursively compute layout for element tree
    async fn compute_layout(&mut self, node: &Node, parent_layout: Layout) -> Result<(), RenderError>:
        match node:
            case Node.Container(container):
                # Apply container's layout attributes
                val layout = self.compute_container_layout(container, parent_layout)
                self.layout_cache.set(container.id(), layout)

                # Layout children
                var child_y = layout.content_y
                for child in &container.children:
                    val child_layout = Layout.new(
                        layout.content_x,
                        child_y,
                        layout.content_width,
                        20  # Default height, will be refined
                    )
                    await self.compute_layout(child, child_layout)?
                    child_y += 20

            case Node.Text(text):
                # Text layout is simple - just bounding box
                val layout = Layout.new(
                    parent_layout.x,
                    parent_layout.y,
                    parent_layout.width,
                    20  # Single line height
                )
                self.layout_cache.set(text.id(), layout)

            case Node.Button(button):
                # Button has fixed height, centered text
                val layout = Layout.new(
                    parent_layout.x,
                    parent_layout.y,
                    parent_layout.width,
                    30  # Button height
                )
                self.layout_cache.set(button.id(), layout)

            case _:
                # Other elements use parent layout
                pass

        Ok(())

    fn compute_container_layout(&self, container: &Container, parent: Layout) -> Layout:
        # Extract layout attributes
        var layout = parent

        # Apply width/height if specified
        if val Some(width) = container.attrs.get_width():
            layout.width = width
        if val Some(height) = container.attrs.get_height():
            layout.height = height

        # Apply padding
        val padding = container.attrs.get_padding().unwrap_or((0, 0, 0, 0))
        layout = layout.with_padding(padding.0, padding.1, padding.2, padding.3)

        layout

    pub fn get_width(self) -> u16:
        """Get renderer window width.

        Returns:
            Width in pixels

        Example:
            val renderer = VulkanRenderer.new(handle, 800, 600)
            assert(renderer.get_width() == 800)
        """
        self.width

    pub fn get_height(self) -> u16:
        """Get renderer window height.

        Returns:
            Height in pixels

        Example:
            val renderer = VulkanRenderer.new(handle, 800, 600)
            assert(renderer.get_height() == 600)
        """
        self.height

    pub fn is_initialized(self) -> bool:
        """Check if renderer is initialized.

        Returns:
            True if initialized

        Example:
            var renderer = VulkanRenderer.new(handle, 800, 600)
            assert(not renderer.is_initialized())
            renderer.init().await?
            assert(renderer.is_initialized())
        """
        self.is_initialized

    pub fn has_device(self) -> bool:
        """Check if Vulkan device is created.

        Returns:
            True if device exists

        Example:
            val renderer = VulkanRenderer.new(handle, 800, 600)
            if renderer.has_device():
                print("Device ready")
        """
        self.device.is_some()

    pub fn has_font_atlas(self) -> bool:
        """Check if font atlas is loaded.

        Returns:
            True if font atlas exists

        Example:
            val renderer = VulkanRenderer.new(handle, 800, 600)
            if renderer.has_font_atlas():
                print("Text rendering available")
        """
        self.font_atlas.is_some()

    pub fn vertex_count(self) -> usize:
        """Get current vertex cache size.

        Returns:
            Number of cached vertices

        Example:
            val renderer = VulkanRenderer.new(handle, 800, 600)
            val count = renderer.vertex_count()
        """
        self.vertex_cache.vertices.len()

    pub fn aspect_ratio(self) -> f64:
        """Calculate window aspect ratio.

        Returns:
            Width / height ratio

        Example:
            val renderer = VulkanRenderer.new(handle, 1920, 1080)
            assert(renderer.aspect_ratio() > 1.7)
        """
        (self.width as f64) / (self.height as f64)

    pub fn is_landscape(self) -> bool:
        """Check if window is landscape orientation.

        Returns:
            True if width > height

        Example:
            val renderer = VulkanRenderer.new(handle, 1920, 1080)
            assert(renderer.is_landscape())
        """
        self.width > self.height

    pub fn summary(self) -> text:
        """Get renderer summary.

        Returns:
            Human-readable summary

        Example:
            val renderer = VulkanRenderer.new(handle, 800, 600)
            print(renderer.summary())
        """
        val state = if self.is_initialized: "initialized" else: "uninitialized"
        return "VulkanRenderer: {self.width}x{self.height}, {state}, {self.vertex_count()} vertices"
    }

# =============================================================================
# Vertex Generation
# =============================================================================

impl VulkanRenderer:
    # Generate vertices for element rendering
    async fn generate_vertices(&mut self, node: &Node) -> Result<(), RenderError>:
        match node:
            case Node.Container(container):
                # Draw container background
                if val Some(layout) = self.layout_cache.get(container.id()):
                    val bg_color = container.attrs.get_background_color().unwrap_or([0.2, 0.2, 0.2, 1.0])
                    self.vertex_cache.add_rect(
                        layout.x as f32,
                        layout.y as f32,
                        layout.width as f32,
                        layout.height as f32,
                        bg_color
                    )

                # Render children
                for child in &container.children:
                    await self.generate_vertices(child)?

            case Node.Text(text):
                # Render text using font atlas
                if val Some(layout) = self.layout_cache.get(text.id()):
                    val color = text.attrs.get_color().unwrap_or([1.0, 1.0, 1.0, 1.0])
                    val font_atlas = self.font_atlas.as_ref().unwrap()

                    match await font_atlas.add_text(
                        &mut self.vertex_cache,
                        &text.content,
                        layout.x as f32,
                        layout.y as f32,
                        color
                    ):
                        case Ok(_): pass
                        case Err(e): return Err(RenderError.IoError(e))

            case Node.Button(button):
                # Draw button background
                if val Some(layout) = self.layout_cache.get(button.id()):
                    val bg_color = button.attrs.get_background_color().unwrap_or([0.3, 0.5, 0.8, 1.0])
                    self.vertex_cache.add_rect(
                        layout.x as f32,
                        layout.y as f32,
                        layout.width as f32,
                        layout.height as f32,
                        bg_color
                    )

                    # Draw button text (centered)
                    val text_color = button.attrs.get_color().unwrap_or([1.0, 1.0, 1.0, 1.0])
                    val font_atlas = self.font_atlas.as_ref().unwrap()

                    # Compute text dimensions for centering (monospace: 8x16 pixels)
                    val glyph_width: f32 = 8.0
                    val glyph_height: f32 = 16.0
                    val text_width = button.label.len() as f32 * glyph_width
                    val text_height = glyph_height

                    # Center text horizontally and vertically within button
                    val text_x = layout.x as f32 + (layout.width as f32 - text_width) / 2.0
                    val text_y = layout.y as f32 + (layout.height as f32 - text_height) / 2.0

                    match await font_atlas.add_text(
                        &mut self.vertex_cache,
                        &button.label,
                        text_x,
                        text_y,
                        text_color
                    ):
                        case Ok(_): pass
                        case Err(e): return Err(RenderError.IoError(e))

            case _:
                pass

        Ok(())
    }

# =============================================================================
# UI Vertex Format
# =============================================================================

pub struct UIVertex:
    position: [f32; 2]    # Screen position (0..width, 0..height)
    tex_coord: [f32; 2]   # Texture coordinates (0..1, 0..1)
    color: [f32; 4]       # RGBA color (0..1)

impl UIVertex:
    pub fn get_position(self) -> (f32, f32):
        """Get vertex position.

        Returns:
            (x, y) screen coordinates

        Example:
            val v = UIVertex { position: [100.0, 200.0], tex_coord: [0.0, 0.0], color: [1.0, 1.0, 1.0, 1.0] }
            val (x, y) = v.get_position()
            assert(x == 100.0 and y == 200.0)
        """
        (self.position[0], self.position[1])

    pub fn get_tex_coord(self) -> (f32, f32):
        """Get texture coordinates.

        Returns:
            (u, v) texture coordinates

        Example:
            val v = UIVertex { position: [0.0, 0.0], tex_coord: [0.5, 0.5], color: [1.0, 1.0, 1.0, 1.0] }
            val (u, v) = v.get_tex_coord()
            assert(u == 0.5 and v == 0.5)
        """
        (self.tex_coord[0], self.tex_coord[1])

    pub fn get_color(self) -> [f32; 4]:
        """Get vertex color.

        Returns:
            RGBA color array

        Example:
            val v = UIVertex { position: [0.0, 0.0], tex_coord: [0.0, 0.0], color: [1.0, 0.0, 0.0, 1.0] }
            val c = v.get_color()
            assert(c[0] == 1.0)  # Red
        """
        self.color

    pub fn is_textured(self) -> bool:
        """Check if vertex has non-zero texture coordinates.

        Returns:
            True if texture coordinates are non-zero

        Example:
            val v = UIVertex { position: [0.0, 0.0], tex_coord: [0.5, 0.5], color: [1.0, 1.0, 1.0, 1.0] }
            assert(v.is_textured())
        """
        self.tex_coord[0] != 0.0 or self.tex_coord[1] != 0.0

    pub fn is_opaque(self) -> bool:
        """Check if vertex color is fully opaque.

        Returns:
            True if alpha is 1.0

        Example:
            val v = UIVertex { position: [0.0, 0.0], tex_coord: [0.0, 0.0], color: [1.0, 1.0, 1.0, 1.0] }
            assert(v.is_opaque())
        """
        self.color[3] == 1.0

    pub fn is_transparent(self) -> bool:
        """Check if vertex has any transparency.

        Returns:
            True if alpha < 1.0

        Example:
            val v = UIVertex { position: [0.0, 0.0], tex_coord: [0.0, 0.0], color: [1.0, 1.0, 1.0, 0.5] }
            assert(v.is_transparent())
        """
        self.color[3] < 1.0

    pub fn summary(self) -> text:
        """Get vertex summary.

        Returns:
            Human-readable summary

        Example:
            val v = UIVertex { position: [100.0, 200.0], tex_coord: [0.0, 0.0], color: [1.0, 1.0, 1.0, 1.0] }
            print(v.summary())
        """
        val (x, y) = self.get_position()
        return "UIVertex: pos({x:.1}, {y:.1}), tex({self.tex_coord[0]:.2}, {self.tex_coord[1]:.2}), alpha={self.color[3]:.2}"

# =============================================================================
# Vertex Cache - Batches UI drawing
# =============================================================================

pub struct VertexCache:
    vertices: Array<UIVertex>

impl VertexCache:
    pub fn new() -> VertexCache:
        VertexCache {
            vertices: Array.new()
        }

    pub fn clear(&mut self):
        self.vertices.clear()

    # Add a colored rectangle (2 triangles = 6 vertices)
    pub fn add_rect(&mut self, x: f32, y: f32, w: f32, h: f32, color: [f32; 4]):
        # Triangle 1: top-left, top-right, bottom-left
        self.vertices.push(UIVertex {
            position: [x, y],
            tex_coord: [0.0, 0.0],
            color: color,
        })
        self.vertices.push(UIVertex {
            position: [x + w, y],
            tex_coord: [1.0, 0.0],
            color: color,
        })
        self.vertices.push(UIVertex {
            position: [x, y + h],
            tex_coord: [0.0, 1.0],
            color: color,
        })

        # Triangle 2: bottom-left, top-right, bottom-right
        self.vertices.push(UIVertex {
            position: [x, y + h],
            tex_coord: [0.0, 1.0],
            color: color,
        })
        self.vertices.push(UIVertex {
            position: [x + w, y],
            tex_coord: [1.0, 0.0],
            color: color,
        })
        self.vertices.push(UIVertex {
            position: [x + w, y + h],
            tex_coord: [1.0, 1.0],
            color: color,
        })

    pub fn vertex_count(self) -> usize:
        """Get number of vertices in cache.

        Returns:
            Vertex count

        Example:
            val cache = VertexCache.new()
            assert(cache.vertex_count() == 0)
        """
        self.vertices.len()

    pub fn is_empty(self) -> bool:
        """Check if cache is empty.

        Returns:
            True if no vertices

        Example:
            val cache = VertexCache.new()
            assert(cache.is_empty())
        """
        self.vertices.len() == 0

    pub fn triangle_count(self) -> usize:
        """Get number of triangles (vertices / 3).

        Returns:
            Triangle count

        Example:
            var cache = VertexCache.new()
            cache.add_rect(0.0, 0.0, 100.0, 100.0, [1.0, 1.0, 1.0, 1.0])
            assert(cache.triangle_count() == 2)
        """
        self.vertices.len() / 3

    pub fn rect_count(self) -> usize:
        """Estimate number of rectangles (triangles / 2).

        Returns:
            Estimated rect count

        Example:
            var cache = VertexCache.new()
            cache.add_rect(0.0, 0.0, 100.0, 100.0, [1.0, 1.0, 1.0, 1.0])
            assert(cache.rect_count() == 1)
        """
        self.triangle_count() / 2

    pub fn has_vertices(self) -> bool:
        """Check if cache has any vertices.

        Returns:
            True if vertices exist

        Example:
            var cache = VertexCache.new()
            assert(not cache.has_vertices())
            cache.add_rect(0.0, 0.0, 100.0, 100.0, [1.0, 1.0, 1.0, 1.0])
            assert(cache.has_vertices())
        """
        self.vertices.len() > 0

    pub fn is_large(self) -> bool:
        """Check if cache has many vertices (>10000).

        Returns:
            True if vertex count exceeds 10000

        Example:
            val cache = VertexCache.new()
            if cache.is_large():
                print("Large vertex cache, consider batching")
        """
        self.vertices.len() > 10000

    pub fn summary(self) -> text:
        """Get vertex cache summary.

        Returns:
            Human-readable summary

        Example:
            val cache = VertexCache.new()
            print(cache.summary())
        """
        val tris = self.triangle_count()
        val rects = self.rect_count()
        return "VertexCache: {self.vertices.len()} vertices, {tris} triangles, ~{rects} rects"

# =============================================================================
# Font Atlas - Imported from vulkan_font.spl
# =============================================================================
# FontAtlas and related types are imported from ui.gui.vulkan_font

impl VertexCache:
    # Add textured rectangle for glyph rendering
    pub fn add_textured_rect(
        &mut self,
        x: f32,
        y: f32,
        w: f32,
        h: f32,
        tx: f32,
        ty: f32,
        tw: f32,
        th: f32,
        color: [f32; 4]
    ):
        # Similar to add_rect but with custom texture coordinates
        # Triangle 1
        self.vertices.push(UIVertex {
            position: [x, y],
            tex_coord: [tx, ty],
            color: color,
        })
        self.vertices.push(UIVertex {
            position: [x + w, y],
            tex_coord: [tx + tw, ty],
            color: color,
        })
        self.vertices.push(UIVertex {
            position: [x, y + h],
            tex_coord: [tx, ty + th],
            color: color,
        })

        # Triangle 2
        self.vertices.push(UIVertex {
            position: [x, y + h],
            tex_coord: [tx, ty + th],
            color: color,
        })
        self.vertices.push(UIVertex {
            position: [x + w, y],
            tex_coord: [tx + tw, ty],
            color: color,
        })
        self.vertices.push(UIVertex {
            position: [x + w, y + h],
            tex_coord: [tx + tw, ty + th],
            color: color,
        })

# =============================================================================
# Pipeline Builder Extension for UI
# =============================================================================

impl PipelineBuilder:
    # Vertex input for UI rendering (Position2 + TexCoord2 + Color4)
    pub fn vertex_input_ui(mut self) -> PipelineBuilder:
        self.vertex_bindings.push(VkVertexInputBindingDescription {
            binding: 0,
            stride: 32,  # 2*4 + 2*4 + 4*4 = 32 bytes
            input_rate: VK_VERTEX_INPUT_RATE_VERTEX,
        })

        # Position (vec2)
        self.vertex_attributes.push(VkVertexInputAttributeDescription {
            location: 0,
            binding: 0,
            format: VK_FORMAT_R32G32_SFLOAT,
            offset: 0,
        })

        # TexCoord (vec2)
        self.vertex_attributes.push(VkVertexInputAttributeDescription {
            location: 1,
            binding: 0,
            format: VK_FORMAT_R32G32_SFLOAT,
            offset: 8,
        })

        # Color (vec4)
        self.vertex_attributes.push(VkVertexInputAttributeDescription {
            location: 2,
            binding: 0,
            format: VK_FORMAT_R32G32B32A32_SFLOAT,
            offset: 16,
        })

        self

# =============================================================================
# Attribute Helpers
# =============================================================================

# Attributes wrapper for parsing element attributes and styles
pub struct Attributes:
    attrs: Dict<text, text>
    styles: Dict<text, text>

impl Attributes:
    # Create Attributes from an Element
    pub fn from_element(elem: &Element) -> Attributes:
        return Attributes {
            attrs: elem.attrs.clone(),
            styles: elem.styles.clone()
        }

    # Get attribute value by name
    pub fn get(&self, name: &str) -> Option<text>:
        match self.attrs.get(&name.to_string()):
            case Some(v): return Some(v.clone())
            case None:
                match self.styles.get(&name.to_string()):
                    case Some(v): return Some(v.clone())
                    case None: return None

    pub fn get_width(&self) -> Option<u16>:
        match self.get("width"):
            case Some(val): return parse_dimension(&val)
            case None: return None

    pub fn get_height(&self) -> Option<u16>:
        match self.get("height"):
            case Some(val): return parse_dimension(&val)
            case None: return None

    pub fn get_padding(&self) -> Option<(u16, u16, u16, u16)>:
        match self.get("padding"):
            case Some(val): return parse_padding(&val)
            case None: return None

    pub fn get_background_color(&self) -> Option<[f32; 4]>:
        match self.get("background-color"):
            case Some(val): return parse_color(&val)
            case None:
                match self.get("background"):
                    case Some(val): return parse_color(&val)
                    case None: return None

    pub fn get_color(&self) -> Option<[f32; 4]>:
        match self.get("color"):
            case Some(val): return parse_color(&val)
            case None: return None

# Parse dimension value (e.g., "100", "100px", "50%")
fn parse_dimension(val: &str) -> Option<u16>:
    val trimmed = val.trim()
    # Remove 'px' suffix if present
    val numeric = if trimmed.ends_with("px"):
        trimmed[0..trimmed.len() - 2]
    else if trimmed.ends_with("%"):
        # Percentage not supported yet, return None
        return None
    else:
        trimmed

    match numeric.parse.<u16>():
        case Ok(n): return Some(n)
        case Err(_): return None

# Parse padding value (e.g., "10", "10 20", "10 20 30 40")
fn parse_padding(val: &str) -> Option<(u16, u16, u16, u16)>:
    val parts = val.trim().split_whitespace().collect.<Array<&str>>()

    match parts.len():
        case 1:
            # All sides same
            match parts[0].parse.<u16>():
                case Ok(n): return Some((n, n, n, n))
                case Err(_): return None
        case 2:
            # Vertical, Horizontal
            match (parts[0].parse.<u16>(), parts[1].parse.<u16>()):
                case (Ok(v), Ok(h)): return Some((v, h, v, h))
                case _: return None
        case 4:
            # Top, Right, Bottom, Left
            match (parts[0].parse.<u16>(), parts[1].parse.<u16>(),
                   parts[2].parse.<u16>(), parts[3].parse.<u16>()):
                case (Ok(t), Ok(r), Ok(b), Ok(l)): return Some((t, r, b, l))
                case _: return None
        case _:
            return None

# Parse color value (e.g., "#FF0000", "rgb(255,0,0)", "red")
fn parse_color(val: &str) -> Option<[f32; 4]>:
    val trimmed = val.trim().lower()

    # Named colors
    match trimmed.as_str():
        case "red": return Some([1.0, 0.0, 0.0, 1.0])
        case "green": return Some([0.0, 1.0, 0.0, 1.0])
        case "blue": return Some([0.0, 0.0, 1.0, 1.0])
        case "white": return Some([1.0, 1.0, 1.0, 1.0])
        case "black": return Some([0.0, 0.0, 0.0, 1.0])
        case "yellow": return Some([1.0, 1.0, 0.0, 1.0])
        case "cyan": return Some([0.0, 1.0, 1.0, 1.0])
        case "magenta": return Some([1.0, 0.0, 1.0, 1.0])
        case "gray" | "grey": return Some([0.5, 0.5, 0.5, 1.0])
        case "transparent": return Some([0.0, 0.0, 0.0, 0.0])
        case _: pass

    # Hex color (#RGB, #RRGGBB, #RRGGBBAA)
    if trimmed.starts_with("#"):
        val hex = &trimmed[1..]
        match hex.len():
            case 3:
                # #RGB -> #RRGGBB
                val r = parse_hex_digit(hex[0..1]) * 17
                val g = parse_hex_digit(hex[1..2]) * 17
                val b = parse_hex_digit(hex[2..3]) * 17
                return Some([r as f32 / 255.0, g as f32 / 255.0, b as f32 / 255.0, 1.0])
            case 6:
                # #RRGGBB
                val r = parse_hex_byte(&hex[0..2])
                val g = parse_hex_byte(&hex[2..4])
                val b = parse_hex_byte(&hex[4..6])
                return Some([r as f32 / 255.0, g as f32 / 255.0, b as f32 / 255.0, 1.0])
            case 8:
                # #RRGGBBAA
                val r = parse_hex_byte(&hex[0..2])
                val g = parse_hex_byte(&hex[2..4])
                val b = parse_hex_byte(&hex[4..6])
                val a = parse_hex_byte(&hex[6..8])
                return Some([r as f32 / 255.0, g as f32 / 255.0, b as f32 / 255.0, a as f32 / 255.0])
            case _:
                return None

    # rgb(r, g, b) or rgba(r, g, b, a)
    if trimmed.starts_with("rgb"):
        val inner = if trimmed.starts_with("rgba("):
            &trimmed[5..trimmed.len()-1]
        else if trimmed.starts_with("rgb("):
            &trimmed[4..trimmed.len()-1]
        else:
            return None

        val parts = inner.split(",").map(|s| s.trim()).collect.<Array<&str>>()
        match parts.len():
            case 3:
                match (parts[0].parse.<u8>(), parts[1].parse.<u8>(), parts[2].parse.<u8>()):
                    case (Ok(r), Ok(g), Ok(b)):
                        return Some([r as f32 / 255.0, g as f32 / 255.0, b as f32 / 255.0, 1.0])
                    case _: return None
            case 4:
                match (parts[0].parse.<u8>(), parts[1].parse.<u8>(),
                       parts[2].parse.<u8>(), parts[3].parse.<f32>()):
                    case (Ok(r), Ok(g), Ok(b), Ok(a)):
                        return Some([r as f32 / 255.0, g as f32 / 255.0, b as f32 / 255.0, a])
                    case _: return None
            case _: return None

    return None

# Parse single hex digit (0-15)
fn parse_hex_digit(s: &str) -> u8:
    match s.chars().next():
        case Some(c):
            if c >= '0' and c <= '9':
                return (c as u8) - ('0' as u8)
            if c >= 'a' and c <= 'f':
                return (c as u8) - ('a' as u8) + 10
            if c >= 'A' and c <= 'F':
                return (c as u8) - ('A' as u8) + 10
            return 0
        case None: return 0

# Parse two hex digits (00-FF)
fn parse_hex_byte(s: &str) -> u8:
    val high = parse_hex_digit(&s[0..1])
    val low = parse_hex_digit(&s[1..2])
    return high * 16 + low

# =============================================================================
# Event Conversion Helpers
# =============================================================================

# Convert raw key event data to KeyEvent
fn convert_key_event(key_code: u32, modifiers: u8) -> KeyEvent:
    # Parse modifier flags: ctrl=0x01, shift=0x02, alt=0x04
    val ctrl = (modifiers & 0x01) != 0
    val shift = (modifiers & 0x02) != 0
    val alt = (modifiers & 0x04) != 0

    val key_modifiers = KeyModifiers { shift: shift, ctrl: ctrl, alt: alt }

    # Convert key_code to KeyCode enum
    val code = match key_code:
        case 0x0D: KeyCode.Enter          # VK_RETURN
        case 0x1B: KeyCode.Escape         # VK_ESCAPE
        case 0x08: KeyCode.Backspace      # VK_BACK
        case 0x09: KeyCode.Tab            # VK_TAB
        case 0x2E: KeyCode.Delete         # VK_DELETE
        case 0x2D: KeyCode.Insert         # VK_INSERT
        case 0x24: KeyCode.Home           # VK_HOME
        case 0x23: KeyCode.End            # VK_END
        case 0x21: KeyCode.PageUp         # VK_PRIOR
        case 0x22: KeyCode.PageDown       # VK_NEXT
        case 0x26: KeyCode.Up             # VK_UP
        case 0x28: KeyCode.Down           # VK_DOWN
        case 0x25: KeyCode.Left           # VK_LEFT
        case 0x27: KeyCode.Right          # VK_RIGHT
        case 0x70: KeyCode.F(1)           # VK_F1
        case 0x71: KeyCode.F(2)           # VK_F2
        case 0x72: KeyCode.F(3)           # VK_F3
        case 0x73: KeyCode.F(4)           # VK_F4
        case 0x74: KeyCode.F(5)           # VK_F5
        case 0x75: KeyCode.F(6)           # VK_F6
        case 0x76: KeyCode.F(7)           # VK_F7
        case 0x77: KeyCode.F(8)           # VK_F8
        case 0x78: KeyCode.F(9)           # VK_F9
        case 0x79: KeyCode.F(10)          # VK_F10
        case 0x7A: KeyCode.F(11)          # VK_F11
        case 0x7B: KeyCode.F(12)          # VK_F12
        case _:
            # Printable character range
            if key_code >= 0x20 and key_code <= 0x7E:
                KeyCode.Char((key_code as u8) as char)
            else:
                KeyCode.Null

    return KeyEvent.new(code, key_modifiers)

# Convert raw mouse event data to MouseEvent
fn convert_mouse_event(x: u16, y: u16, button: u8, kind: u8) -> MouseEvent:
    val mouse_button = match button:
        case 0: MouseButton.Left
        case 1: MouseButton.Right
        case 2: MouseButton.Middle
        case _: MouseButton.Left

    val event_kind = match kind:
        case 0: MouseEventKind.Down(mouse_button)
        case 1: MouseEventKind.Up(mouse_button)
        case 2: MouseEventKind.Moved
        case 3: MouseEventKind.Drag(mouse_button)
        case 4: MouseEventKind.ScrollUp
        case 5: MouseEventKind.ScrollDown
        case 6: MouseEventKind.ScrollLeft
        case 7: MouseEventKind.ScrollRight
        case _: MouseEventKind.Moved

    return MouseEvent {kind: event_kind, column: x, row: y, modifiers: KeyModifiers.none()}

# =============================================================================
# Type Aliases for Vulkan Integration
# =============================================================================

pub type VkTexture = i64
pub type VkVertexInputBindingDescription = i64
pub type VkVertexInputAttributeDescription = i64

pub const VK_VERTEX_INPUT_RATE_VERTEX: u32 = 0
pub const VK_FORMAT_R32G32_SFLOAT: u32 = 103
pub const VK_FORMAT_R32G32B32A32_SFLOAT: u32 = 109
