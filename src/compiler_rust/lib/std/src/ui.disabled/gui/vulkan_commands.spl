# Vulkan Renderer - Element Processing
#
# ElementProcessor (CPU→GPU data conversion) — processes element trees
# into draw lists with vertex/index geometry for rendering.
# Part of the Vulkan renderer - see vulkan.spl and vulkan_pipeline.spl.
# Synchronization/advanced types moved to vulkan_commands_sync.spl.

use core.*
use concurrency.*
use ui.element.*
use ui.attrs.*
use ui.patchset.*
use ui.renderer.*
use ui.gui.vulkan_types.*
use ui.gui.vulkan_buffers.*
use ui.gui.vulkan_ffi.*

# =============================================================================
# Element Processor (CPU → GPU Data)
# =============================================================================

struct ElementProcessor:
    vertex_builder: VertexBuilder
    draw_list: DrawList

impl ElementProcessor:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_vertices(self) -> bool:
        """Check if any vertices have been generated."""
        self.draw_list.vertices.len() > 0

    pub fn has_indices(self) -> bool:
        """Check if any indices have been generated."""
        self.draw_list.indices.len() > 0

    pub fn vertex_count(self) -> usize:
        """Get number of vertices in draw list."""
        self.draw_list.vertices.len()

    pub fn index_count(self) -> usize:
        """Get number of indices in draw list."""
        self.draw_list.indices.len()

    pub fn triangle_count(self) -> usize:
        """Get number of triangles (indices / 3)."""
        self.draw_list.indices.len() / 3

    pub fn is_empty(self) -> bool:
        """Check if no geometry has been generated."""
        not self.has_vertices()

    pub fn summary(self) -> text:
        """Get summary of element processor state."""
        return "ElementProcessor: {self.vertex_count()} vertices, {self.triangle_count()} triangles"

    # =========================================================================
    # Style Helpers
    # =========================================================================

    fn has_background(elem: &Element) -> bool:
        """Check if element has a background color style."""
        return elem.styles.contains_key("background-color")

    fn get_bg_color(elem: &Element) -> Color:
        """Get background color from element styles."""
        if val Some(color_str) = elem.styles.get("background-color"):
            # Try to parse as hex color
            if color_str.starts_with("#"):
                match Color.hex(color_str):
                    case Ok(c): return c
                    case Err(_): pass
            # Named colors
            match color_str.lower().as_str():
                case "black": return Color.rgb(0, 0, 0)
                case "white": return Color.rgb(255, 255, 255)
                case "red": return Color.rgb(255, 0, 0)
                case "green": return Color.rgb(0, 255, 0)
                case "blue": return Color.rgb(0, 0, 255)
                case "gray" | "grey": return Color.rgb(128, 128, 128)
                case _: pass
        # Default: white background
        return Color.rgb(255, 255, 255)

    # =========================================================================
    # Constructor
    # =========================================================================

    static fn new() -> ElementProcessor:
        return ElementProcessor {
            vertex_builder: VertexBuilder.new(),
            draw_list: DrawList.new()
        }

    fn process_tree(tree: &ElementTree, layout: &LayoutResult) -> DrawList:
        # Clear previous frame's data
        self.draw_list.clear()
        self.vertex_builder.clear()

        # Traverse tree and generate geometry
        self.process_element(tree.root(), layout)

        # Finalize draw list
        self.draw_list.vertices = self.vertex_builder.vertices
        self.draw_list.indices = self.vertex_builder.indices

        return self.draw_list

    fn process_element(elem: &Element, layout: &LayoutResult):
        # Get layout for this element
        val bounds = layout.get_bounds(elem.id)

        # Generate geometry based on element type
        match elem.kind:
            case ElementKind.Box:
                self.emit_rounded_rect(bounds, 4.0, elem)
            case ElementKind.Button:
                self.emit_button(bounds, elem)
            case ElementKind.Text:
                self.emit_text(bounds, elem)
            case _:
                # Default: just background if specified
                if self.has_background(elem):
                    self.emit_rect(bounds, self.get_bg_color(elem))

        # Process children
        for child in &elem.children:
            self.process_element(child, layout)

    fn emit_rect(bounds: Rect, color: Color):
        # Get base vertex index for indices
        val base_vertex = self.vertex_builder.vertices.len() as u32
        val base_index = self.vertex_builder.indices.len() as u32
        val color_packed = color.rgba

        # Add 4 vertices: top-left, top-right, bottom-right, bottom-left
        # Vertex positions
        val x0 = bounds.x
        val y0 = bounds.y
        val x1 = bounds.x + bounds.width
        val y1 = bounds.y + bounds.height

        # Top-left vertex
        self.vertex_builder.vertices.push(Vertex {
            position: (x0, y0),
            uv: (0.0, 0.0),
            color: color_packed
        })
        # Top-right vertex
        self.vertex_builder.vertices.push(Vertex {
            position: (x1, y0),
            uv: (1.0, 0.0),
            color: color_packed
        })
        # Bottom-right vertex
        self.vertex_builder.vertices.push(Vertex {
            position: (x1, y1),
            uv: (1.0, 1.0),
            color: color_packed
        })
        # Bottom-left vertex
        self.vertex_builder.vertices.push(Vertex {
            position: (x0, y1),
            uv: (0.0, 1.0),
            color: color_packed
        })

        # Add 6 indices for 2 triangles (CCW winding)
        # Triangle 1: top-left, top-right, bottom-right
        self.vertex_builder.indices.push(base_vertex + 0)
        self.vertex_builder.indices.push(base_vertex + 1)
        self.vertex_builder.indices.push(base_vertex + 2)
        # Triangle 2: bottom-right, bottom-left, top-left
        self.vertex_builder.indices.push(base_vertex + 2)
        self.vertex_builder.indices.push(base_vertex + 3)
        self.vertex_builder.indices.push(base_vertex + 0)

        # Add draw call
        self.draw_list.draw_calls.push(DrawCall {
            pipeline_type: PipelineType.SolidColor,
            vertex_offset: base_vertex,
            vertex_count: 4,
            index_offset: base_index,
            index_count: 6,
            texture_id: None,
            scissor: None
        })

    fn emit_rounded_rect(bounds: Rect, radius: f32, elem: &Element):
        # Get base vertex/index offsets
        val base_vertex = self.vertex_builder.vertices.len() as u32
        val base_index = self.vertex_builder.indices.len() as u32
        val color = self.get_bg_color(elem)
        val color_packed = color.rgba

        # For SDF rounded rect, we need normalized coordinates
        # UVs will be used by the shader to compute distance from edges
        val x0 = bounds.x
        val y0 = bounds.y
        val x1 = bounds.x + bounds.width
        val y1 = bounds.y + bounds.height

        # Compute normalized radius for shader (as fraction of smaller dimension)
        val min_dim = if bounds.width < bounds.height: bounds.width else: bounds.height
        val norm_radius = if min_dim > 0.0: radius / min_dim else: 0.0

        # Top-left vertex - UVs encode normalized position for SDF
        self.vertex_builder.vertices.push(Vertex {
            position: (x0, y0),
            uv: (0.0, 0.0),
            color: color_packed
        })
        # Top-right vertex
        self.vertex_builder.vertices.push(Vertex {
            position: (x1, y0),
            uv: (1.0, 0.0),
            color: color_packed
        })
        # Bottom-right vertex
        self.vertex_builder.vertices.push(Vertex {
            position: (x1, y1),
            uv: (1.0, 1.0),
            color: color_packed
        })
        # Bottom-left vertex
        self.vertex_builder.vertices.push(Vertex {
            position: (x0, y1),
            uv: (0.0, 1.0),
            color: color_packed
        })

        # Add 6 indices for 2 triangles (CCW winding)
        self.vertex_builder.indices.push(base_vertex + 0)
        self.vertex_builder.indices.push(base_vertex + 1)
        self.vertex_builder.indices.push(base_vertex + 2)
        self.vertex_builder.indices.push(base_vertex + 2)
        self.vertex_builder.indices.push(base_vertex + 3)
        self.vertex_builder.indices.push(base_vertex + 0)

        # Add draw call with RoundedRect pipeline
        # Note: radius and dimensions should be passed via push constants
        # when recording commands (see record_commands)
        self.draw_list.draw_calls.push(DrawCall {
            pipeline_type: PipelineType.RoundedRect,
            vertex_offset: base_vertex,
            vertex_count: 4,
            index_offset: base_index,
            index_count: 6,
            texture_id: None,
            scissor: Some(Rect {
                x: bounds.x,
                y: bounds.y,
                width: bounds.width,
                height: bounds.height
            })
        })

    fn emit_text(bounds: Rect, elem: &Element):
        # Get text content from element
        val text_content = match &elem.text:
            case Some(t): t
            case None: return  # No text to render

        if text_content.is_empty():
            return

        # Get text color from styles (default: black)
        val text_color = self.get_text_color(elem)
        val color_packed = text_color.rgba

        # Font metrics (monospace: 8x16 pixels per glyph)
        val glyph_width: f32 = 8.0
        val glyph_height: f32 = 16.0

        # Font atlas layout: 16x16 grid (256 ASCII characters)
        val atlas_cols: f32 = 16.0
        val atlas_rows: f32 = 16.0
        val uv_width = 1.0 / atlas_cols
        val uv_height = 1.0 / atlas_rows

        # Current position (start at top-left of bounds)
        var x = bounds.x
        var y = bounds.y

        # Get base indices for batch
        val base_vertex = self.vertex_builder.vertices.len() as u32
        val base_index = self.vertex_builder.indices.len() as u32
        var vertex_count: u32 = 0
        var index_count: u32 = 0

        # Generate quad for each character
        for ch in text_content.chars():
            # Check if we're still within bounds
            if x + glyph_width > bounds.x + bounds.width:
                # Line wrap
                x = bounds.x
                y = y + glyph_height
                if y + glyph_height > bounds.y + bounds.height:
                    break  # No more space

            # Skip newlines and handle them
            if ch == '\n':
                x = bounds.x
                y = y + glyph_height
                continue

            # Compute UV coordinates from character code
            # ASCII layout in 16x16 grid
            val char_code = ch as u32
            val atlas_col = (char_code % 16) as f32
            val atlas_row = (char_code / 16) as f32
            val u0 = atlas_col * uv_width
            val v0 = atlas_row * uv_height
            val u1 = u0 + uv_width
            val v1 = v0 + uv_height

            # Glyph quad positions
            val x0 = x
            val y0 = y
            val x1 = x + glyph_width
            val y1 = y + glyph_height

            # Current vertex index for this quad
            val quad_base = base_vertex + vertex_count

            # Add 4 vertices for glyph quad
            self.vertex_builder.vertices.push(Vertex {
                position: (x0, y0),
                uv: (u0, v0),
                color: color_packed
            })
            self.vertex_builder.vertices.push(Vertex {
                position: (x1, y0),
                uv: (u1, v0),
                color: color_packed
            })
            self.vertex_builder.vertices.push(Vertex {
                position: (x1, y1),
                uv: (u1, v1),
                color: color_packed
            })
            self.vertex_builder.vertices.push(Vertex {
                position: (x0, y1),
                uv: (u0, v1),
                color: color_packed
            })

            # Add 6 indices for 2 triangles
            self.vertex_builder.indices.push(quad_base + 0)
            self.vertex_builder.indices.push(quad_base + 1)
            self.vertex_builder.indices.push(quad_base + 2)
            self.vertex_builder.indices.push(quad_base + 2)
            self.vertex_builder.indices.push(quad_base + 3)
            self.vertex_builder.indices.push(quad_base + 0)

            vertex_count = vertex_count + 4
            index_count = index_count + 6

            # Advance cursor
            x = x + glyph_width

        # Add draw call for all text glyphs (batched)
        if vertex_count > 0:
            self.draw_list.draw_calls.push(DrawCall {
                pipeline_type: PipelineType.Text,
                vertex_offset: base_vertex,
                vertex_count: vertex_count,
                index_offset: base_index,
                index_count: index_count,
                texture_id: None,  # Font atlas texture ID would go here
                scissor: None
            })

    fn get_text_color(elem: &Element) -> Color:
        """Get text color from element styles."""
        if val Some(color_str) = elem.styles.get("color"):
            # Try to parse as hex color
            if color_str.starts_with("#"):
                match Color.hex(color_str):
                    case Ok(c): return c
                    case Err(_): pass
            # Named colors
            match color_str.lower().as_str():
                case "black": return Color.rgb(0, 0, 0)
                case "white": return Color.rgb(255, 255, 255)
                case "red": return Color.rgb(255, 0, 0)
                case "green": return Color.rgb(0, 255, 0)
                case "blue": return Color.rgb(0, 0, 255)
                case "gray" | "grey": return Color.rgb(128, 128, 128)
                case _: pass
        # Default: black text
        return Color.rgb(0, 0, 0)

    fn emit_button(bounds: Rect, elem: &Element):
        # Emit background
        self.emit_rounded_rect(bounds, 4.0, elem)

        # Emit label text if present
        if val Some(text_content) = &elem.text:
            # Center text in button
            # Font metrics (must match emit_text)
            val glyph_width: f32 = 8.0
            val glyph_height: f32 = 16.0

            # Calculate text dimensions
            val text_width = text_content.len() as f32 * glyph_width
            val text_height = glyph_height

            # Calculate centered position
            val text_x = bounds.x + (bounds.width - text_width) / 2.0
            val text_y = bounds.y + (bounds.height - text_height) / 2.0

            # Create centered text bounds
            val text_bounds = Rect {
                x: text_x,
                y: text_y,
                width: text_width,
                height: text_height
            }

            self.emit_text(text_bounds, elem)
