# Packaging Build Steps
# Packager class and artifact collection logic

use tooling.core.project.{Language, ProjectContext}
use tooling.compiler.compiler_interface.Artifact
use core.result.{Result, Ok, Err}
use tooling.deployment.packaging.{PackageMetadata, PackageManifest, PackageFile, PackageFormat}

# Package builder
pub class Packager:
    pub root: text
    pub manifest: PackageManifest
    pub verbose: bool

    pub fn new(root: text) -> Packager:
        """Create packager.

        Args:
            root: Project root

        Returns:
            Packager instance

        Example:
            val packager = Packager.new(".")

            val package = packager.create_package(
                name: "my-app",
                version: "1.0.0",
                include: [Language.Simple, Language.Rust],
                format: PackageFormat.Tarball
            )

            package.write("my-app-1.0.0.tar.gz")
        """
        val metadata = PackageMetadata.new("unnamed", "0.1.0")
        val manifest = PackageManifest.new(metadata)

        Packager {
            root: root,
            manifest: manifest,
            verbose: false
        }

    pub fn set_verbose(self, enabled: bool):
        """Enable verbose logging."""
        self.verbose = enabled

    pub fn is_verbose(self) -> bool:
        """Check if verbose logging is enabled.

        Returns:
            True if verbose mode is on
        """
        self.verbose

    pub fn with_verbose(self, enabled: bool) -> Packager:
        """Set verbose logging (fluent API).

        Args:
            enabled: Verbose flag

        Returns:
            Self for chaining

        Example:
            val packager = Packager.new(".").with_verbose(true)
        """
        self.verbose = enabled
        self

    pub fn set_metadata(self, metadata: PackageMetadata):
        """Set package metadata.

        Args:
            metadata: Package metadata
        """
        self.manifest.metadata = metadata

    pub fn get_file_count(self) -> i32:
        """Get number of files in package.

        Returns:
            File count
        """
        self.manifest.get_file_count()

    pub fn has_files(self) -> bool:
        """Check if package has files.

        Returns:
            True if files exist
        """
        self.manifest.has_files()

    pub fn summary(self) -> text:
        """Get packager summary.

        Returns:
            Human-readable summary

        Example:
            packager.summary()
            # → "Packager: . (10 files, verbose: true)"
        """
        val verbose_str = if self.verbose: "true" else: "false"
        "Packager: {self.root} ({self.get_file_count()} files, verbose: {verbose_str})"

    pub fn create_package(
        self,
        name: text,
        version: text,
        include: List<Language>,
        format: PackageFormat
    ) -> Package:
        """Create package from multi-language artifacts.

        Args:
            name: Package name
            version: Package version
            include: Languages to include
            format: Package format

        Returns:
            Package ready to write

        Example:
            val package = packager.create_package(
                name: "my-app",
                version: "1.0.0",
                include: [Language.Simple, Language.Rust, Language.Python],
                format: PackageFormat.Tarball
            )

            print("Package size: {package.size_mb}MB")
            package.write("my-app-1.0.0.tar.gz")
        """
        if self.verbose:
            print("Creating package {name} v{version}")

        # Update metadata
        self.manifest.metadata.name = name
        self.manifest.metadata.version = version

        # Collect artifacts for each language
        for language in include:
            self.collect_language_artifacts(language)

        # Create package
        val package = Package.new(self.manifest, format)

        if self.verbose:
            print("Package contains {package.file_count} files")

        package

    fn collect_language_artifacts(language: Language):
        """Collect artifacts for language.

        Args:
            language: Language to collect artifacts for
        """
        match language:
            Language.Simple:
                self.collect_simple_artifacts()
            Language.Rust:
                self.collect_rust_artifacts()
            Language.Python:
                self.collect_python_artifacts()
            Language.JavaScript:
                self.collect_javascript_artifacts()
            _:
                pass

    fn collect_simple_artifacts():
        """Collect Simple language artifacts."""
        @extern("runtime", "rt_glob")
        fn _rt_glob(pattern_ptr: &u8, pattern_len: u64) -> text

        # Find .smf compiled files in .simple/build/
        val smf_pattern = ".simple/build/**/*.smf"
        val smf_files = _rt_glob(smf_pattern.ptr(), smf_pattern.len())
        for file in smf_files.split("\n"):
            if not file.is_empty():
                self.manifest.add_file(file, "lib/{self.get_filename(file)}")

        # Find executables in .simple/build/
        val exe_pattern = ".simple/build/**/bin/*"
        val exe_files = _rt_glob(exe_pattern.ptr(), exe_pattern.len())
        for file in exe_files.split("\n"):
            if not file.is_empty():
                self.manifest.add_file(file, "bin/{self.get_filename(file)}")

    fn collect_rust_artifacts():
        """Collect Rust artifacts."""
        @extern("runtime", "rt_glob")
        fn _rt_glob(pattern_ptr: &u8, pattern_len: u64) -> text

        @extern("runtime", "rt_file_stat")
        fn _rt_file_stat(path_ptr: &u8, path_len: u64, out_exists: &mut bool, out_is_file: &mut bool, out_is_dir: &mut bool, out_is_readable: &mut bool, out_is_writable: &mut bool, out_size: &mut i64)

        # Find binaries in target/release/
        val bin_pattern = "target/release/*"
        val bin_files = _rt_glob(bin_pattern.ptr(), bin_pattern.len())
        for file in bin_files.split("\n"):
            if file.is_empty():
                continue
            # Skip directories and deps folder
            if file.contains("/deps/") or file.contains("/build/") or file.contains("/."):
                continue
            var exists = false
            var is_file = false
            var is_dir = false
            var is_readable = false
            var is_writable = false
            var size: i64 = 0
            _rt_file_stat(file.ptr(), file.len(), &mut exists, &mut is_file, &mut is_dir, &mut is_readable, &mut is_writable, &mut size)
            if is_file and not file.ends_with(".d"):
                # Check if it's likely an executable or library
                if file.ends_with(".so") or file.ends_with(".dylib") or file.ends_with(".dll") or file.ends_with(".a"):
                    self.manifest.add_file(file, "lib/{self.get_filename(file)}")
                else:
                    self.manifest.add_file(file, "bin/{self.get_filename(file)}")

    fn collect_python_artifacts():
        """Collect Python artifacts."""
        @extern("runtime", "rt_glob")
        fn _rt_glob(pattern_ptr: &u8, pattern_len: u64) -> text

        # Find Python source files
        val py_pattern = "src/**/*.py"
        val py_files = _rt_glob(py_pattern.ptr(), py_pattern.len())
        for file in py_files.split("\n"):
            if not file.is_empty() and not file.contains("__pycache__"):
                # Preserve directory structure under src/
                val dest = file.replace("src/", "lib/")
                self.manifest.add_file(file, dest)

        # Find wheels in dist/
        val wheel_pattern = "dist/*.whl"
        val wheel_files = _rt_glob(wheel_pattern.ptr(), wheel_pattern.len())
        for file in wheel_files.split("\n"):
            if not file.is_empty():
                self.manifest.add_file(file, "dist/{self.get_filename(file)}")

    fn collect_javascript_artifacts():
        """Collect JavaScript artifacts."""
        @extern("runtime", "rt_glob")
        fn _rt_glob(pattern_ptr: &u8, pattern_len: u64) -> text

        # Find built bundles in dist/
        val dist_pattern = "dist/**/*.js"
        val dist_files = _rt_glob(dist_pattern.ptr(), dist_pattern.len())
        for file in dist_files.split("\n"):
            if not file.is_empty():
                val dest = file.replace("dist/", "lib/")
                self.manifest.add_file(file, dest)

        # Find CSS bundles
        val css_pattern = "dist/**/*.css"
        val css_files = _rt_glob(css_pattern.ptr(), css_pattern.len())
        for file in css_files.split("\n"):
            if not file.is_empty():
                val dest = file.replace("dist/", "lib/")
                self.manifest.add_file(file, dest)

        # Find source maps if needed
        val map_pattern = "dist/**/*.map"
        val map_files = _rt_glob(map_pattern.ptr(), map_pattern.len())
        for file in map_files.split("\n"):
            if not file.is_empty():
                val dest = file.replace("dist/", "lib/")
                self.manifest.add_file(file, dest)

    pub fn add_binary(self, binary_path: text):
        """Add binary to package.

        Args:
            binary_path: Path to binary
        """
        self.manifest.add_file(binary_path, "bin/{self.get_filename(binary_path)}")

    pub fn add_library(self, lib_path: text):
        """Add library to package.

        Args:
            lib_path: Path to library
        """
        self.manifest.add_file(lib_path, "lib/{self.get_filename(lib_path)}")

    pub fn add_resource(self, resource_path: text, dest: text):
        """Add resource file to package.

        Args:
            resource_path: Path to resource
            dest: Destination path in package
        """
        self.manifest.add_file(resource_path, dest)

    fn get_filename(path: text) -> text:
        """Extract filename from path.

        Args:
            path: File path

        Returns:
            Filename

        Examples:
        - "/path/to/file.txt" → "file.txt"
        - "file.txt" → "file.txt"
        - "/path/to/" → ""
        """
        # Find last slash
        val last_slash = path.rfind("/")
        if last_slash >= 0:
            path[last_slash+1:]
        else:
            # No slash, return whole path
            path
