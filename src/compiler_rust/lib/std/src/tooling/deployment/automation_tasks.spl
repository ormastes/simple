# Release Automation Tasks
# ReleaseAutomation class with git, build, GitHub, and notification operations

use core.result.{Result, Ok, Err}
use shell.shell
use host.common.net.http.{HttpClient, HttpRequest}
use host.common.net.types.{HttpUrl, HttpMethod}
use tooling.deployment.automation.{ReleaseType, ReleaseArtifact, ReleaseConfig}

# FFI for process execution and file operations
@extern("runtime", "rt_process_run")
fn _rt_process_run(cmd_ptr: &u8, cmd_len: u64, args_ptr: &u8, args_len: u64) -> (i32, text, text)

@extern("runtime", "rt_file_size")
fn _rt_file_size(path_ptr: &u8, path_len: u64) -> i64

# Release automation
pub class ReleaseAutomation:
    pub repo: text
    pub verbose: bool

    pub fn new() -> ReleaseAutomation:
        """Create release automation.

        Returns:
            Release automation instance

        Example:
            val release = ReleaseAutomation.new()

            release.set_version("1.0.0")
            release.generate_changelog("v0.9.0..HEAD")
            release.create_git_tag()
            release.build_artifacts(platforms: ["linux", "macos", "windows"])
            release.create_github_release(
                repo: "user/my-app",
                title: "Release 1.0.0",
                draft: false
            )
            release.upload_artifacts()
            release.notify_slack("#releases", "Released v1.0.0!")

            print("✓ Release 1.0.0 complete")
        """
        ReleaseAutomation {
            repo: "",
            verbose: false
        }

    pub fn set_verbose(self, enabled: bool):
        """Enable verbose logging."""
        self.verbose = enabled

    pub fn is_verbose(self) -> bool:
        """Check if verbose logging is enabled.

        Returns:
            True if verbose mode is on
        """
        self.verbose

    pub fn with_verbose(self, enabled: bool) -> ReleaseAutomation:
        """Set verbose logging (fluent API).

        Args:
            enabled: Verbose flag

        Returns:
            Self for chaining

        Example:
            val release = ReleaseAutomation.new().with_verbose(true)
        """
        self.verbose = enabled
        self

    pub fn has_repo(self) -> bool:
        """Check if repository is configured.

        Returns:
            True if repo is set
        """
        not self.repo.is_empty()

    pub fn summary(self) -> text:
        """Get automation summary.

        Returns:
            Human-readable summary

        Example:
            release.summary()
            # → "ReleaseAutomation: user/repo (verbose: true)"
        """
        val verbose_str = if self.verbose: "true" else: "false"
        val repo_str = if self.has_repo(): self.repo else: "(no repo)"
        "ReleaseAutomation: {repo_str} (verbose: {verbose_str})"

    pub fn set_version(self, version: text):
        """Set release version.

        Args:
            version: Version string (e.g., "1.0.0")
        """
        if self.verbose:
            print("Setting version: {version}")

    pub fn generate_changelog(self, git_range: text) -> text:
        """Generate changelog from git commits.

        Args:
            git_range: Git range (e.g., "v0.9.0..HEAD")

        Returns:
            Changelog markdown

        Example:
            val changelog = release.generate_changelog("v0.9.0..HEAD")
            # → "## Changes\n- Add feature X\n- Fix bug Y\n..."
        """
        if self.verbose:
            print("Generating changelog for {git_range}")

        # Execute git log to get commits
        val cmd = "git"
        val args = "log --oneline {git_range}"
        val (exit_code, stdout, stderr) = _rt_process_run(cmd.ptr(), cmd.len(), args.ptr(), args.len())

        if exit_code != 0:
            return "# Changelog\n\nNo commits found.\n"

        # Parse commits and categorize
        var features: List<text> = []
        var fixes: List<text> = []
        var other: List<text> = []

        for line in stdout.lines():
            if line.is_empty():
                continue
            if line.contains("feat:") or line.contains("feat("):
                features.append(line)
            elif line.contains("fix:") or line.contains("fix("):
                fixes.append(line)
            else:
                other.append(line)

        # Generate markdown
        var changelog = "# Changelog\n\n"

        if features.len() > 0:
            changelog += "## Features\n"
            for f in features:
                changelog += "- {f}\n"
            changelog += "\n"

        if fixes.len() > 0:
            changelog += "## Bug Fixes\n"
            for f in fixes:
                changelog += "- {f}\n"
            changelog += "\n"

        if other.len() > 0:
            changelog += "## Other Changes\n"
            for o in other:
                changelog += "- {o}\n"
            changelog += "\n"

        changelog

    pub fn create_git_tag(self, version: text, message: text) -> Result<(), text>:
        """Create git tag.

        Args:
            version: Tag version
            message: Tag message

        Returns:
            Ok if successful

        Example:
            release.create_git_tag("v1.0.0", "Release 1.0.0")
        """
        if self.verbose:
            print("Creating git tag: {version}")

        # Execute git tag command
        val cmd = "git"
        val args = "tag -a {version} -m \"{message}\""
        val (exit_code, stdout, stderr) = _rt_process_run(cmd.ptr(), cmd.len(), args.ptr(), args.len())

        if exit_code == 0:
            Ok(())
        else:
            Err("Failed to create git tag: {stderr}")

    pub fn build_artifacts(self, platforms: List<text>) -> List<ReleaseArtifact>:
        """Build artifacts for all platforms.

        Args:
            platforms: Target platforms

        Returns:
            Built artifacts

        Example:
            val artifacts = release.build_artifacts([
                "linux-amd64",
                "darwin-arm64",
                "windows-amd64"
            ])
        """
        if self.verbose:
            print("Building artifacts for {platforms.len()} platforms")

        val artifacts: List<ReleaseArtifact> = []

        for platform in platforms:
            if self.verbose:
                print("Building for {platform}...")

            # Parse platform to determine build target
            val (os, arch) = self.parse_platform(platform)
            val target = self.get_rust_target(os, arch)

            # Build using cargo with cross-compilation target
            val build_result = if target.is_empty():
                # Native build
                shell.run("cargo", ["build", "--release"])
            else:
                # Cross-compile
                shell.run("cargo", ["build", "--release", "--target", target])

            if build_result.exit_code != 0:
                if self.verbose:
                    print("  ✗ Build failed for {platform}: {build_result.stderr}")
                continue

            # Determine output path based on target
            val output_path = if target.is_empty():
                "target/release/app"
            else:
                "target/{target}/release/app"

            val artifact = ReleaseArtifact.new(
                "app-{platform}",
                output_path,
                platform
            )
            artifacts.append(artifact)

            if self.verbose:
                print("  ✓ Built {artifact.name}")

        artifacts

    fn parse_platform(platform: text): (text, text):
        """Parse platform string into OS and architecture.

        Args:
            platform: Platform string (e.g., "linux-amd64")

        Returns:
            Tuple of (os, arch)
        """
        if platform.contains("-"):
            val parts = platform.split("-")
            if parts.len() >= 2:
                return (parts[0], parts[1])
        (platform, "x86_64")

    fn get_rust_target(os: text, arch: text) -> text:
        """Get Rust target triple from OS and architecture.

        Args:
            os: Operating system
            arch: Architecture

        Returns:
            Rust target triple or empty string for native
        """
        val arch_part = match arch:
            "amd64": "x86_64"
            "x64": "x86_64"
            "arm64": "aarch64"
            "aarch64": "aarch64"
            _: arch

        match os:
            "linux":
                "{arch_part}-unknown-linux-gnu"
            "darwin":
                "{arch_part}-apple-darwin"
            "macos":
                "{arch_part}-apple-darwin"
            "windows":
                "{arch_part}-pc-windows-msvc"
            _:
                ""

    pub fn create_github_release(
        self,
        repo: text,
        title: text,
        draft: bool
    ) -> Result<(), text>:
        """Create GitHub release.

        Args:
            repo: Repository (org/name)
            title: Release title
            draft: Create as draft

        Returns:
            Ok if successful

        Example:
            release.create_github_release(
                repo: "user/my-app",
                title: "Release 1.0.0",
                draft: false
            )
        """
        if self.verbose:
            print("Creating GitHub release: {title}")

        self.repo = repo

        # Execute gh release create command
        val cmd = "gh"
        var args = "release create --title \"{title}\""
        if draft:
            args = args + " --draft"
        val (exit_code, stdout, stderr) = _rt_process_run(cmd.ptr(), cmd.len(), args.ptr(), args.len())

        if exit_code == 0:
            Ok(())
        else:
            Err("Failed to create GitHub release: {stderr}")

    pub fn upload_artifacts(self, artifacts: List<ReleaseArtifact>) -> Result<(), text>:
        """Upload artifacts to GitHub release.

        Args:
            artifacts: Artifacts to upload

        Returns:
            Ok if successful

        Example:
            release.upload_artifacts(artifacts)
        """
        if self.verbose:
            print("Uploading {artifacts.len()} artifacts")

        for artifact in artifacts:
            if self.verbose:
                print("Uploading {artifact.name}...")

            # Execute gh release upload command
            val cmd = "gh"
            val args = "release upload latest {artifact.path}"
            val (exit_code, stdout, stderr) = _rt_process_run(cmd.ptr(), cmd.len(), args.ptr(), args.len())

            if exit_code != 0:
                return Err("Failed to upload artifact {artifact.name}: {stderr}")

        Ok(())

    pub async fn notify_slack(self, channel: text, message: text) -> Result<(), text>:
        """Send Slack notification.

        Args:
            channel: Slack channel
            message: Message to send

        Returns:
            Ok if successful

        Example:
            release.notify_slack("#releases", "Released v1.0.0!")

        Note: Requires SLACK_WEBHOOK_URL environment variable to be set.
        """
        if self.verbose:
            print("Sending Slack notification to {channel}")

        # Get Slack webhook URL from environment
        val webhook_result = shell.run("sh", ["-c", "echo $SLACK_WEBHOOK_URL"])
        val webhook_url = webhook_result.stdout.trim()

        if webhook_url.is_empty():
            return Err("SLACK_WEBHOOK_URL environment variable not set")

        val client = HttpClient.new()
        val http_url = HttpUrl.parse(webhook_url)

        match http_url:
            Ok(parsed_url):
                # Build Slack payload
                val payload = "{\"channel\": \"{channel}\", \"text\": \"{message}\"}"
                val request = HttpRequest.post(parsed_url)
                    .json_body(payload.to_bytes())

                match await client.send(request):
                    Ok(response):
                        if response.is_success():
                            if self.verbose:
                                print("  ✓ Slack notification sent to {channel}")
                            Ok(())
                        else:
                            Err("Slack notification failed: HTTP {response.status()}")
                    Err(err):
                        Err("Slack request failed: {err}")
            Err(_):
                Err("Invalid Slack webhook URL")

    pub fn notify_email(
        self,
        recipients: List<text>,
        subject: text,
        body: text
    ) -> Result<(), text>:
        """Send email notification.

        Args:
            recipients: Email addresses
            subject: Email subject
            body: Email body

        Returns:
            Ok if successful

        Note: Uses system mail/sendmail command. For SMTP, configure
              SMTP_HOST, SMTP_USER, SMTP_PASS environment variables
              or install mailx/sendmail.
        """
        if self.verbose:
            print("Sending email to {recipients.len()} recipients")

        if recipients.len() == 0:
            return Err("No recipients specified")

        # Try different mail commands in order of preference
        val recipient_str = recipients.join(",")

        # Try mailx first (common on Linux)
        val mailx_result = shell.run("which", ["mailx"])
        if mailx_result.exit_code == 0:
            val result = shell.run("mailx", ["-s", subject, recipient_str])
            # Note: Would need stdin for body - using echo pipe
            val pipe_result = shell.run("sh", ["-c", "echo '{body}' | mailx -s '{subject}' {recipient_str}"])
            if pipe_result.exit_code == 0:
                if self.verbose:
                    print("  ✓ Email sent via mailx")
                return Ok(())

        # Try sendmail
        val sendmail_result = shell.run("which", ["sendmail"])
        if sendmail_result.exit_code == 0:
            # Build email message
            var email_msg = "To: {recipient_str}\n"
            email_msg += "Subject: {subject}\n"
            email_msg += "Content-Type: text/plain; charset=utf-8\n"
            email_msg += "\n"
            email_msg += body

            val pipe_result = shell.run("sh", ["-c", "echo '{email_msg}' | sendmail -t"])
            if pipe_result.exit_code == 0:
                if self.verbose:
                    print("  ✓ Email sent via sendmail")
                return Ok(())

        # Try mail command
        val mail_result = shell.run("which", ["mail"])
        if mail_result.exit_code == 0:
            val pipe_result = shell.run("sh", ["-c", "echo '{body}' | mail -s '{subject}' {recipient_str}"])
            if pipe_result.exit_code == 0:
                if self.verbose:
                    print("  ✓ Email sent via mail")
                return Ok(())

        Err("No mail command available (tried mailx, sendmail, mail)")

    pub fn publish_to_registry(self, registry: text) -> Result<(), text>:
        """Publish package to registry.

        Args:
            registry: Registry type (npm, pypi, crates, etc.)

        Returns:
            Ok if successful

        Example:
            release.publish_to_registry("npm")
            release.publish_to_registry("pypi")
        """
        if self.verbose:
            print("Publishing to {registry}")

        match registry:
            "npm":
                val cmd = "npm"
                val args = "publish"
                val (exit_code, stdout, stderr) = _rt_process_run(cmd.ptr(), cmd.len(), args.ptr(), args.len())
                if exit_code == 0: Ok(()) else: Err("npm publish failed: {stderr}")
            "pypi":
                val cmd = "twine"
                val args = "upload dist/*"
                val (exit_code, stdout, stderr) = _rt_process_run(cmd.ptr(), cmd.len(), args.ptr(), args.len())
                if exit_code == 0: Ok(()) else: Err("twine upload failed: {stderr}")
            "crates":
                val cmd = "cargo"
                val args = "publish"
                val (exit_code, stdout, stderr) = _rt_process_run(cmd.ptr(), cmd.len(), args.ptr(), args.len())
                if exit_code == 0: Ok(()) else: Err("cargo publish failed: {stderr}")
            _:
                Err("Unknown registry: {registry}")
