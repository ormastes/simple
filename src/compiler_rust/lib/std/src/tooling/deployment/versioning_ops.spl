# Version Operations
# BumpType enum and VersionManager class for managing project versions

use core.result.{Result, Ok, Err}
use shell.{file, path}
use tooling.deployment.versioning.SemVer

# Version bump type
pub enum BumpType:
    Major
    Minor
    Patch
    PreRelease

    pub fn to_string(self) -> text:
        """Convert bump type to string.

        Returns:
            Bump type name

        Example:
            BumpType.Major.to_string()  # → "major"
        """
        match self:
            BumpType.Major: "major"
            BumpType.Minor: "minor"
            BumpType.Patch: "patch"
            BumpType.PreRelease: "prerelease"

    pub fn description(self) -> text:
        """Get bump type description.

        Returns:
            Human-readable description
        """
        match self:
            BumpType.Major: "Major version (breaking changes)"
            BumpType.Minor: "Minor version (new features)"
            BumpType.Patch: "Patch version (bug fixes)"
            BumpType.PreRelease: "Prerelease version"

    pub fn is_major(self) -> bool:
        """Check if bump type is Major.

        Returns:
            True if Major variant
        """
        match self:
            BumpType.Major: true
            _: false

    pub fn is_minor(self) -> bool:
        """Check if bump type is Minor.

        Returns:
            True if Minor variant
        """
        match self:
            BumpType.Minor: true
            _: false

    pub fn is_patch(self) -> bool:
        """Check if bump type is Patch.

        Returns:
            True if Patch variant
        """
        match self:
            BumpType.Patch: true
            _: false

    pub fn is_prerelease(self) -> bool:
        """Check if bump type is PreRelease.

        Returns:
            True if PreRelease variant
        """
        match self:
            BumpType.PreRelease: true
            _: false

    pub fn is_breaking(self) -> bool:
        """Check if bump introduces breaking changes.

        Returns:
            True if Major bump

        Example:
            BumpType.Major.is_breaking()  # → true
            BumpType.Minor.is_breaking()  # → false
        """
        match self:
            BumpType.Major: true
            _: false

    pub fn is_stable(self) -> bool:
        """Check if bump is for stable release (not prerelease).

        Returns:
            True if not PreRelease

        Example:
            BumpType.Minor.is_stable()  # → true
            BumpType.PreRelease.is_stable()  # → false
        """
        match self:
            BumpType.PreRelease: false
            _: true

    pub fn resets_lower_versions(self) -> bool:
        """Check if bump resets lower version components.

        Returns:
            True if Major or Minor

        Example:
            BumpType.Major.resets_lower_versions()  # → true (resets minor and patch to 0)
            BumpType.Minor.resets_lower_versions()  # → true (resets patch to 0)
            BumpType.Patch.resets_lower_versions()  # → false
        """
        match self:
            BumpType.Major: true
            BumpType.Minor: true
            _: false

    pub fn summary(self) -> text:
        """Get bump type summary.

        Returns:
            Human-readable summary

        Example:
            BumpType.Major.summary()
            # → "BumpType: major (Major version (breaking changes), breaking, resets lower)"
        """
        val name = self.to_string()
        val desc = self.description()
        var props = []

        if self.is_breaking():
            props.append("breaking")
        if self.is_stable():
            props.append("stable")
        if self.resets_lower_versions():
            props.append("resets lower")

        if props.len() > 0:
            val props_str = props.join(", ")
            "BumpType: {name} ({desc}, {props_str})"
        else:
            "BumpType: {name} ({desc})"

# Version manager
pub class VersionManager:
    pub root: text
    pub current_version: SemVer
    pub verbose: bool

    pub fn new(root: text) -> VersionManager:
        """Create version manager.

        Args:
            root: Project root

        Returns:
            Version manager

        Example:
            val version = VersionManager.new(".")

            # Current version
            print("Current: {version.get_current()}")  # → "1.0.0"

            # Bump version
            version.bump(BumpType.Minor)  # → "1.1.0"

            # Update all version files
            version.sync_all([
                "Cargo.toml",
                "package.json",
                "pyproject.toml",
                "simple.sdn"
            ])
        """
        VersionManager(
            root: root,
            current_version: SemVer.new(0, 1, 0),
            verbose: false
        )

    pub fn set_verbose(self, enabled: bool):
        """Enable verbose logging."""
        self.verbose = enabled

    pub fn get_current(self) -> text:
        """Get current version.

        Returns:
            Current version string

        Example:
            val v = version.get_current()  # → "1.0.0"
        """
        self.current_version.to_string()

    pub fn bump(self, bump_type: BumpType) -> text:
        """Bump version.

        Args:
            bump_type: Type of bump

        Returns:
            New version string

        Example:
            version.bump(BumpType.Major)  # 1.0.0 → 2.0.0
            version.bump(BumpType.Minor)  # 1.0.0 → 1.1.0
            version.bump(BumpType.Patch)  # 1.0.0 → 1.0.1
        """
        self.current_version = match bump_type:
            BumpType.Major:
                self.current_version.bump_major()
            BumpType.Minor:
                self.current_version.bump_minor()
            BumpType.Patch:
                self.current_version.bump_patch()
            BumpType.PreRelease:
                self.current_version.bump_prerelease()

        if self.verbose:
            print("Bumped version to {self.current_version.to_string()}")

        self.current_version.to_string()

    pub fn sync_all(self, files: List<text>) -> Result<(), text>:
        """Update version in all files.

        Args:
            files: List of version files

        Returns:
            Ok if successful

        Updates version in:
        - Cargo.toml: version = "1.0.0"
        - package.json: "version": "1.0.0"
        - pyproject.toml: version = "1.0.0"
        - simple.sdn: version: 1.0.0

        Example:
            version.sync_all([
                "Cargo.toml",
                "package.json",
                "simple.sdn"
            ])
        """
        val version_str = self.current_version.to_string()

        if self.verbose:
            print("Syncing version {version_str} to {files.len()} files")

        for file in files:
            match self.update_version_file(file, version_str):
                Ok(_):
                    if self.verbose:
                        print("Updated {file}")
                Err(err):
                    return Err("Failed to update {file}: {err}")

        Ok(())

    fn update_version_file(file_path: text, version: text) -> Result<(), text>:
        """Update version in single file.

        Args:
            file_path: File to update
            version: New version

        Returns:
            Ok if successful
        """
        # Read file content
        if not file.exist(file_path):
            return Err("File not found: {file_path}")

        val content = file.read_text(file_path)
        val ext = path.ext(file_path)
        val basename = path.basename(file_path)

        # Update version based on file type
        val updated_content = match basename:
            "Cargo.toml":
                self.update_cargo_toml(content, version)
            "package.json":
                self.update_package_json(content, version)
            "pyproject.toml":
                self.update_pyproject_toml(content, version)
            "simple.sdn":
                self.update_simple_sdn(content, version)
            "VERSION":
                version
            _:
                match ext:
                    ".toml":
                        self.update_generic_toml(content, version)
                    ".json":
                        self.update_generic_json(content, version)
                    _:
                        return Err("Unknown file type: {file_path}")

        # Write file back
        file.write_text(file_path, updated_content)
        Ok(())

    fn update_cargo_toml(content: text, version: text) -> text:
        """Update version in Cargo.toml.

        Args:
            content: File content
            version: New version

        Returns:
            Updated content
        """
        var lines: List<text> = []
        var in_package = false

        for line in content.lines():
            if line.trim() == "[package]":
                in_package = true
                lines.append(line)
            elif line.trim().starts_with("[") and line.trim() != "[package]":
                in_package = false
                lines.append(line)
            elif in_package and line.trim().starts_with("version"):
                lines.append("version = \"{version}\"")
            else:
                lines.append(line)

        lines.join("\n")

    fn update_package_json(content: text, version: text) -> text:
        """Update version in package.json.

        Args:
            content: File content
            version: New version

        Returns:
            Updated content
        """
        var lines: List<text> = []

        for line in content.lines():
            if line.trim().starts_with("\"version\""):
                val indent = self.get_indent(line)
                lines.append("{indent}\"version\": \"{version}\",")
            else:
                lines.append(line)

        lines.join("\n")

    fn update_pyproject_toml(content: text, version: text) -> text:
        """Update version in pyproject.toml.

        Args:
            content: File content
            version: New version

        Returns:
            Updated content
        """
        var lines: List<text> = []
        var in_project = false

        for line in content.lines():
            if line.trim() == "[project]" or line.trim() == "[tool.poetry]":
                in_project = true
                lines.append(line)
            elif line.trim().starts_with("[") and not line.trim().starts_with("[project") and not line.trim().starts_with("[tool.poetry"):
                in_project = false
                lines.append(line)
            elif in_project and line.trim().starts_with("version"):
                lines.append("version = \"{version}\"")
            else:
                lines.append(line)

        lines.join("\n")

    fn update_simple_sdn(content: text, version: text) -> text:
        """Update version in simple.sdn.

        Args:
            content: File content
            version: New version

        Returns:
            Updated content
        """
        var lines: List<text> = []

        for line in content.lines():
            if line.trim().starts_with("version:"):
                lines.append("version: {version}")
            else:
                lines.append(line)

        lines.join("\n")

    fn update_generic_toml(content: text, version: text) -> text:
        """Update version in generic TOML file.

        Args:
            content: File content
            version: New version

        Returns:
            Updated content
        """
        var lines: List<text> = []

        for line in content.lines():
            if line.trim().starts_with("version"):
                lines.append("version = \"{version}\"")
            else:
                lines.append(line)

        lines.join("\n")

    fn update_generic_json(content: text, version: text) -> text:
        """Update version in generic JSON file.

        Args:
            content: File content
            version: New version

        Returns:
            Updated content
        """
        var lines: List<text> = []

        for line in content.lines():
            if line.trim().starts_with("\"version\""):
                val indent = self.get_indent(line)
                lines.append("{indent}\"version\": \"{version}\",")
            else:
                lines.append(line)

        lines.join("\n")

    fn get_indent(line: text) -> text:
        """Get leading whitespace from line.

        Args:
            line: Line to check

        Returns:
            Leading whitespace
        """
        var indent = ""
        for ch in line.chars():
            if ch == ' ' or ch == '\t':
                indent += ch
            else:
                break
        indent

    pub fn validate(self, version: text) -> Result<(), text>:
        """Validate version string.

        Args:
            version: Version string

        Returns:
            Ok if valid SemVer

        Example:
            match version.validate("1.2.3"):
                Ok(_):
                    print("Valid version")
                Err(err):
                    print("Invalid: {err}")
        """
        match SemVer.parse(version):
            Ok(_):
                Ok(())
            Err(err):
                Err(err)
