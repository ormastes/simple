# Multi-Language Packaging
# Package artifacts from multiple languages into deployable units

use tooling.core.project.{Language, ProjectContext}
use tooling.compiler.compiler_interface.Artifact
use core.result.{Result, Ok, Err}

# Package format
pub enum PackageFormat:
    Tarball     # .tar.gz archive
    Zip         # .zip archive
    Deb         # Debian package
    Rpm         # RPM package
    NuGet       # NuGet package
    Npm         # NPM package
    PyPI        # Python wheel/sdist

    pub fn get_extension(self) -> text:
        """Get file extension for package format.

        Returns:
            File extension

        Example:
            PackageFormat.Tarball.get_extension()  # → ".tar.gz"
        """
        match self:
            PackageFormat.Tarball: ".tar.gz"
            PackageFormat.Zip: ".zip"
            PackageFormat.Deb: ".deb"
            PackageFormat.Rpm: ".rpm"
            PackageFormat.NuGet: ".nupkg"
            PackageFormat.Npm: ".tgz"
            PackageFormat.PyPI: ".whl"

    pub fn to_string(self) -> text:
        """Convert package format to string.

        Returns:
            Format name

        Example:
            PackageFormat.Deb.to_string()  # → "debian"
        """
        match self:
            PackageFormat.Tarball: "tarball"
            PackageFormat.Zip: "zip"
            PackageFormat.Deb: "debian"
            PackageFormat.Rpm: "rpm"
            PackageFormat.NuGet: "nuget"
            PackageFormat.Npm: "npm"
            PackageFormat.PyPI: "python"

    pub fn description(self) -> text:
        """Get package format description.

        Returns:
            Human-readable description

        Example:
            PackageFormat.Deb.description()
            # → "Debian package (.deb)"
        """
        match self:
            PackageFormat.Tarball: "Tarball archive (.tar.gz)"
            PackageFormat.Zip: "Zip archive (.zip)"
            PackageFormat.Deb: "Debian package (.deb)"
            PackageFormat.Rpm: "RPM package (.rpm)"
            PackageFormat.NuGet: "NuGet package (.nupkg)"
            PackageFormat.Npm: "NPM package (.tgz)"
            PackageFormat.PyPI: "Python wheel (.whl)"

    pub fn is_archive(self) -> bool:
        """Check if format is a generic archive.

        Returns:
            True for tarball/zip

        Example:
            PackageFormat.Tarball.is_archive()  # → true
            PackageFormat.Deb.is_archive()  # → false
        """
        match self:
            PackageFormat.Tarball: true
            PackageFormat.Zip: true
            PackageFormat.Deb: false
            PackageFormat.Rpm: false
            PackageFormat.NuGet: false
            PackageFormat.Npm: false
            PackageFormat.PyPI: false

    pub fn is_linux_package(self) -> bool:
        """Check if format is a Linux package.

        Returns:
            True for deb/rpm
        """
        match self:
            PackageFormat.Tarball: false
            PackageFormat.Zip: false
            PackageFormat.Deb: true
            PackageFormat.Rpm: true
            PackageFormat.NuGet: false
            PackageFormat.Npm: false
            PackageFormat.PyPI: false

    pub fn is_language_package(self) -> bool:
        """Check if format is language-specific.

        Returns:
            True for npm/pypi/nuget
        """
        match self:
            PackageFormat.Tarball: false
            PackageFormat.Zip: false
            PackageFormat.Deb: false
            PackageFormat.Rpm: false
            PackageFormat.NuGet: true
            PackageFormat.Npm: true
            PackageFormat.PyPI: true

    pub fn is_tarball(self) -> bool:
        """Check if format is Tarball.

        Returns:
            True for Tarball variant
        """
        match self:
            PackageFormat.Tarball: true
            _: false

    pub fn is_zip(self) -> bool:
        """Check if format is Zip.

        Returns:
            True for Zip variant
        """
        match self:
            PackageFormat.Zip: true
            _: false

    pub fn is_deb(self) -> bool:
        """Check if format is Deb.

        Returns:
            True for Deb variant
        """
        match self:
            PackageFormat.Deb: true
            _: false

    pub fn is_rpm(self) -> bool:
        """Check if format is Rpm.

        Returns:
            True for Rpm variant
        """
        match self:
            PackageFormat.Rpm: true
            _: false

    pub fn is_nuget(self) -> bool:
        """Check if format is NuGet.

        Returns:
            True for NuGet variant
        """
        match self:
            PackageFormat.NuGet: true
            _: false

    pub fn is_npm(self) -> bool:
        """Check if format is Npm.

        Returns:
            True for Npm variant
        """
        match self:
            PackageFormat.Npm: true
            _: false

    pub fn is_pypi(self) -> bool:
        """Check if format is PyPI.

        Returns:
            True for PyPI variant
        """
        match self:
            PackageFormat.PyPI: true
            _: false

    pub fn summary(self) -> text:
        """Get package format summary.

        Returns:
            Human-readable summary

        Example:
            PackageFormat.Deb.summary()
            # → "PackageFormat: debian (Debian package (.deb), linux package)"
        """
        val name = self.to_string()
        val desc = self.description()
        var props = []

        if self.is_archive():
            props.append("archive")
        if self.is_linux_package():
            props.append("linux package")
        if self.is_language_package():
            props.append("language package")

        if props.len() > 0:
            val props_str = props.join(", ")
            "PackageFormat: {name} ({desc}, {props_str})"
        else:
            "PackageFormat: {name} ({desc})"

# Package metadata
pub class PackageMetadata:
    pub name: text
    pub version: text
    pub description: text
    pub author: text
    pub license: text
    pub homepage: text
    pub dependencies: List<text>

    pub fn new(name: text, version: text) -> PackageMetadata:
        """Create package metadata.

        Args:
            name: Package name
            version: Package version

        Returns:
            Package metadata
        """
        PackageMetadata {
            name: name,
            version: version,
            description: "",
            author: "",
            license: "MIT",
            homepage: "",
            dependencies: []
        }

    pub fn has_description(self) -> bool:
        """Check if description is set.

        Returns:
            True if description is non-empty
        """
        not self.description.is_empty()

    pub fn has_author(self) -> bool:
        """Check if author is set.

        Returns:
            True if author is non-empty
        """
        not self.author.is_empty()

    pub fn has_homepage(self) -> bool:
        """Check if homepage is set.

        Returns:
            True if homepage is non-empty
        """
        not self.homepage.is_empty()

    pub fn has_license(self) -> bool:
        """Check if license is set.

        Returns:
            True if license is non-empty
        """
        not self.license.is_empty()

    pub fn has_dependencies(self) -> bool:
        """Check if package has dependencies.

        Returns:
            True if dependencies exist
        """
        self.dependencies.len() > 0

    pub fn get_dependency_count(self) -> i32:
        """Get number of dependencies.

        Returns:
            Dependency count

        Example:
            metadata.get_dependency_count()  # → 5
        """
        self.dependencies.len()

    pub fn is_complete(self) -> bool:
        """Check if metadata is complete.

        Returns:
            True if name, version, description, and author are set
        """
        not self.name.is_empty() and not self.version.is_empty() and self.has_description() and self.has_author()

    pub fn summary(self) -> text:
        """Get metadata summary.

        Returns:
            Human-readable summary

        Example:
            metadata.summary()
            # → "my-app v1.0.0 (MIT, 3 dependencies)"
        """
        val license_str = if self.has_license(): self.license else: "no license"
        "{self.name} v{self.version} ({license_str}, {self.get_dependency_count()} dependencies)"

# Package manifest
pub class PackageManifest:
    pub metadata: PackageMetadata
    pub files: List<PackageFile>
    pub scripts: Dict<text, text>  # install, uninstall, etc.

    pub fn new(metadata: PackageMetadata) -> PackageManifest:
        """Create package manifest.

        Args:
            metadata: Package metadata

        Returns:
            Package manifest
        """
        PackageManifest {
            metadata: metadata,
            files: [],
            scripts: {}
        }

    pub fn add_file(self, source: text, destination: text):
        """Add file to package.

        Args:
            source: Source file path
            destination: Destination path in package
        """
        self.files.append(PackageFile.new(source, destination))

    pub fn add_script(self, name: text, script: text):
        """Add installation script.

        Args:
            name: Script name (install, uninstall, pre-install, post-install)
            script: Script contents
        """
        self.scripts[name] = script

    pub fn get_file_count(self) -> i32:
        """Get file count in package.

        Returns:
            Number of files
        """
        self.files.len()

    pub fn has_script(self, name: text) -> bool:
        """Check if manifest has script.

        Args:
            name: Script name

        Returns:
            True if script exists
        """
        self.scripts.contains_key(name)

    pub fn has_files(self) -> bool:
        """Check if manifest has files.

        Returns:
            True if files exist
        """
        self.files.len() > 0

    pub fn has_scripts(self) -> bool:
        """Check if manifest has any scripts.

        Returns:
            True if scripts exist
        """
        self.scripts.len() > 0

    pub fn get_script_count(self) -> i32:
        """Get number of scripts.

        Returns:
            Script count
        """
        self.scripts.len()

    pub fn is_valid(self) -> bool:
        """Check if manifest is valid.

        Returns:
            True if metadata is complete and has files
        """
        self.metadata.is_complete() and self.has_files()

    pub fn summary(self) -> text:
        """Get manifest summary.

        Returns:
            Human-readable summary

        Example:
            manifest.summary()
            # → "Manifest: my-app v1.0.0 (10 files, 2 scripts)"
        """
        "{self.metadata.name} v{self.metadata.version} ({self.get_file_count()} files, {self.get_script_count()} scripts)"

# Package file entry
pub class PackageFile:
    pub source: text
    pub destination: text
    pub mode: i32  # Unix file permissions

    pub fn new(source: text, destination: text) -> PackageFile:
        """Create package file entry.

        Args:
            source: Source file path
            destination: Destination path

        Returns:
            Package file entry
        """
        PackageFile {
            source: source,
            destination: destination,
            mode: 0o644  # rw-r--r--
        }

    pub fn is_executable(self) -> bool:
        """Check if file is executable.

        Returns:
            True if executable bit is set

        Example:
            file.is_executable()  # → true if mode has execute bit
        """
        (self.mode & 0o111) != 0

    pub fn is_readable(self) -> bool:
        """Check if file is readable.

        Returns:
            True if readable bit is set
        """
        (self.mode & 0o444) != 0

    pub fn is_writable(self) -> bool:
        """Check if file is writable.

        Returns:
            True if writable bit is set
        """
        (self.mode & 0o222) != 0

    pub fn set_executable(self):
        """Make file executable (add execute bit)."""
        self.mode = self.mode | 0o111

    pub fn summary(self) -> text:
        """Get file summary.

        Returns:
            Human-readable summary

        Example:
            file.summary()
            # → "src/main.spl → bin/main.spl (mode: 0644)"
        """
        "{self.source} → {self.destination} (mode: {self.mode:o})"
