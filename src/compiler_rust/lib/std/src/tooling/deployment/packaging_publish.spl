# Packaging Publish/Distribute
# Package class with write/distribute operations

use tooling.deployment.packaging.{PackageManifest, PackageFormat}
use core.result.{Result, Ok, Err}

# Package
pub class Package:
    pub manifest: PackageManifest
    pub format: PackageFormat
    pub file_count: i32
    pub size_mb: f64

    pub fn new(manifest: PackageManifest, format: PackageFormat) -> Package:
        """Create package.

        Args:
            manifest: Package manifest
            format: Package format

        Returns:
            Package
        """
        # Calculate total size of all files
        @extern("runtime", "rt_file_size")
        fn _rt_file_size(path_ptr: &u8, path_len: u64) -> i64

        var total_bytes: i64 = 0
        for (src_path, _) in manifest.files.items():
            val size = _rt_file_size(src_path.ptr(), src_path.len())
            if size > 0:
                total_bytes = total_bytes + size

        val size_mb = (total_bytes as f64) / (1024.0 * 1024.0)

        Package {
            manifest: manifest,
            format: format,
            file_count: manifest.files.len(),
            size_mb: size_mb
        }

    pub fn write(self, output_path: text) -> Result<(), text>:
        """Write package to file.

        Args:
            output_path: Output file path

        Returns:
            Ok if successful

        Example:
            package.write("my-app-1.0.0.tar.gz")
        """
        match self.format:
            PackageFormat.Tarball:
                self.write_tarball(output_path)
            PackageFormat.Zip:
                self.write_zip(output_path)
            PackageFormat.Deb:
                self.write_deb(output_path)
            PackageFormat.Rpm:
                self.write_rpm(output_path)
            PackageFormat.NuGet:
                self.write_nuget(output_path)
            PackageFormat.Npm:
                self.write_npm(output_path)
            PackageFormat.PyPI:
                self.write_pypi(output_path)

    fn write_tarball(output_path: text) -> Result<(), text>:
        """Write tarball (.tar.gz).

        Args:
            output_path: Output file

        Returns:
            Ok if successful
        """
        @extern("runtime", "rt_process_run")
        fn _rt_process_run(cmd_ptr: &u8, cmd_len: u64, args_ptr: &u8, args_len: u64) -> (i32, text, text)

        # Build file list for tar command
        var file_args = ""
        for (src_path, dest_path) in self.manifest.files.items():
            file_args = file_args + " " + src_path

        # Create tarball using tar command
        val cmd = "tar"
        val args = "czf {output_path} {file_args}"
        val (exit_code, stdout, stderr) = _rt_process_run(cmd.ptr(), cmd.len(), args.ptr(), args.len())

        if exit_code == 0:
            Ok(())
        else:
            Err("Failed to create tarball: {stderr}")

    fn write_zip(output_path: text) -> Result<(), text>:
        """Write zip archive.

        Args:
            output_path: Output file

        Returns:
            Ok if successful
        """
        @extern("runtime", "rt_process_run")
        fn _rt_process_run(cmd_ptr: &u8, cmd_len: u64, args_ptr: &u8, args_len: u64) -> (i32, text, text)

        # Build file list for zip command
        var file_args = ""
        for (src_path, dest_path) in self.manifest.files.items():
            file_args = file_args + " " + src_path

        # Create zip archive using zip command
        val cmd = "zip"
        val args = "-r {output_path} {file_args}"
        val (exit_code, stdout, stderr) = _rt_process_run(cmd.ptr(), cmd.len(), args.ptr(), args.len())

        if exit_code == 0:
            Ok(())
        else:
            Err("Failed to create zip: {stderr}")

    fn write_deb(output_path: text) -> Result<(), text>:
        """Write Debian package.

        Args:
            output_path: Output file

        Returns:
            Ok if successful
        """
        @extern("runtime", "rt_process_run")
        fn _rt_process_run(cmd_ptr: &u8, cmd_len: u64, args_ptr: &u8, args_len: u64) -> (i32, text, text)

        @extern("runtime", "rt_file_write_text")
        fn _rt_file_write_text(path_ptr: &u8, path_len: u64, content_ptr: &u8, content_len: u64) -> bool

        @extern("runtime", "rt_mkdir")
        fn _rt_mkdir(path_ptr: &u8, path_len: u64) -> bool

        # Create temporary package structure
        val pkg_name = self.manifest.metadata.name
        val pkg_dir = "/tmp/deb_pkg_{pkg_name}"
        _rt_mkdir(pkg_dir.ptr(), pkg_dir.len())

        val debian_dir = "{pkg_dir}/DEBIAN"
        _rt_mkdir(debian_dir.ptr(), debian_dir.len())

        # Generate control file
        val control_content = """Package: {self.manifest.metadata.name}
Version: {self.manifest.metadata.version}
Architecture: amd64
Maintainer: {self.manifest.metadata.author}
Description: {self.manifest.metadata.description}
"""
        val control_path = "{debian_dir}/control"
        _rt_file_write_text(control_path.ptr(), control_path.len(), control_content.ptr(), control_content.len())

        # Copy files to package directory
        for (src_path, dest_path) in self.manifest.files.items():
            val full_dest = "{pkg_dir}/{dest_path}"
            val cp_cmd = "cp"
            val cp_args = "-r {src_path} {full_dest}"
            _rt_process_run(cp_cmd.ptr(), cp_cmd.len(), cp_args.ptr(), cp_args.len())

        # Build .deb using dpkg-deb
        val cmd = "dpkg-deb"
        val args = "--build {pkg_dir} {output_path}"
        val (exit_code, stdout, stderr) = _rt_process_run(cmd.ptr(), cmd.len(), args.ptr(), args.len())

        if exit_code == 0:
            Ok(())
        else:
            Err("Failed to create deb: {stderr}")

    fn write_rpm(output_path: text) -> Result<(), text>:
        """Write RPM package.

        Args:
            output_path: Output file

        Returns:
            Ok if successful
        """
        @extern("runtime", "rt_process_run")
        fn _rt_process_run(cmd_ptr: &u8, cmd_len: u64, args_ptr: &u8, args_len: u64) -> (i32, text, text)

        @extern("runtime", "rt_file_write_text")
        fn _rt_file_write_text(path_ptr: &u8, path_len: u64, content_ptr: &u8, content_len: u64) -> bool

        @extern("runtime", "rt_mkdir")
        fn _rt_mkdir(path_ptr: &u8, path_len: u64) -> bool

        # Create RPM build directory structure
        val rpmbuild_dir = "/tmp/rpmbuild_{self.manifest.metadata.name}"
        _rt_mkdir(rpmbuild_dir.ptr(), rpmbuild_dir.len())

        val specs_dir = "{rpmbuild_dir}/SPECS"
        _rt_mkdir(specs_dir.ptr(), specs_dir.len())

        val sources_dir = "{rpmbuild_dir}/SOURCES"
        _rt_mkdir(sources_dir.ptr(), sources_dir.len())

        # Generate .spec file
        val spec_content = """Name: {self.manifest.metadata.name}
Version: {self.manifest.metadata.version}
Release: 1
Summary: {self.manifest.metadata.description}
License: MIT

%description
{self.manifest.metadata.description}

%install
mkdir -p %{buildroot}

%files
"""
        val spec_path = "{specs_dir}/{self.manifest.metadata.name}.spec"
        _rt_file_write_text(spec_path.ptr(), spec_path.len(), spec_content.ptr(), spec_content.len())

        # Build RPM using rpmbuild
        val cmd = "rpmbuild"
        val args = "-bb --define '_topdir {rpmbuild_dir}' {spec_path}"
        val (exit_code, stdout, stderr) = _rt_process_run(cmd.ptr(), cmd.len(), args.ptr(), args.len())

        if exit_code == 0:
            Ok(())
        else:
            Err("Failed to create rpm: {stderr}")

    fn write_nuget(output_path: text) -> Result<(), text>:
        """Write NuGet package.

        Args:
            output_path: Output file

        Returns:
            Ok if successful
        """
        @extern("runtime", "rt_process_run")
        fn _rt_process_run(cmd_ptr: &u8, cmd_len: u64, args_ptr: &u8, args_len: u64) -> (i32, text, text)

        @extern("runtime", "rt_file_write_text")
        fn _rt_file_write_text(path_ptr: &u8, path_len: u64, content_ptr: &u8, content_len: u64) -> bool

        # Generate .nuspec file
        val nuspec_content = """<?xml version="1.0"?>
<package>
  <metadata>
    <id>{self.manifest.metadata.name}</id>
    <version>{self.manifest.metadata.version}</version>
    <authors>{self.manifest.metadata.author}</authors>
    <description>{self.manifest.metadata.description}</description>
  </metadata>
</package>
"""
        val nuspec_path = "{self.manifest.metadata.name}.nuspec"
        _rt_file_write_text(nuspec_path.ptr(), nuspec_path.len(), nuspec_content.ptr(), nuspec_content.len())

        # Build NuGet package using nuget or dotnet pack
        val cmd = "nuget"
        val args = "pack {nuspec_path} -OutputDirectory ."
        val (exit_code, stdout, stderr) = _rt_process_run(cmd.ptr(), cmd.len(), args.ptr(), args.len())

        if exit_code == 0:
            Ok(())
        else:
            Err("Failed to create nupkg: {stderr}")

    fn write_npm(output_path: text) -> Result<(), text>:
        """Write NPM package.

        Args:
            output_path: Output file

        Returns:
            Ok if successful
        """
        @extern("runtime", "rt_process_run")
        fn _rt_process_run(cmd_ptr: &u8, cmd_len: u64, args_ptr: &u8, args_len: u64) -> (i32, text, text)

        @extern("runtime", "rt_file_write_text")
        fn _rt_file_write_text(path_ptr: &u8, path_len: u64, content_ptr: &u8, content_len: u64) -> bool

        # Generate package.json if it doesn't exist
        val pkg_json_content = """{
  "name": "{self.manifest.metadata.name}",
  "version": "{self.manifest.metadata.version}",
  "description": "{self.manifest.metadata.description}",
  "author": "{self.manifest.metadata.author}",
  "main": "index.js"
}
"""
        val pkg_json_path = "package.json"
        _rt_file_write_text(pkg_json_path.ptr(), pkg_json_path.len(), pkg_json_content.ptr(), pkg_json_content.len())

        # Create npm tarball using npm pack
        val cmd = "npm"
        val args = "pack"
        val (exit_code, stdout, stderr) = _rt_process_run(cmd.ptr(), cmd.len(), args.ptr(), args.len())

        if exit_code == 0:
            Ok(())
        else:
            Err("Failed to create npm package: {stderr}")

    fn write_pypi(output_path: text) -> Result<(), text>:
        """Write Python package (wheel or sdist).

        Args:
            output_path: Output file

        Returns:
            Ok if successful
        """
        @extern("runtime", "rt_process_run")
        fn _rt_process_run(cmd_ptr: &u8, cmd_len: u64, args_ptr: &u8, args_len: u64) -> (i32, text, text)

        @extern("runtime", "rt_file_write_text")
        fn _rt_file_write_text(path_ptr: &u8, path_len: u64, content_ptr: &u8, content_len: u64) -> bool

        # Generate setup.py if it doesn't exist
        val setup_content = """from setuptools import setup, find_packages

setup(
    name="{self.manifest.metadata.name}",
    version="{self.manifest.metadata.version}",
    description="{self.manifest.metadata.description}",
    author="{self.manifest.metadata.author}",
    packages=find_packages(),
)
"""
        val setup_path = "setup.py"
        _rt_file_write_text(setup_path.ptr(), setup_path.len(), setup_content.ptr(), setup_content.len())

        # Build wheel using python -m build
        val cmd = "python"
        val args = "-m build --wheel"
        val (exit_code, stdout, stderr) = _rt_process_run(cmd.ptr(), cmd.len(), args.ptr(), args.len())

        if exit_code == 0:
            Ok(())
        else:
            Err("Failed to create wheel: {stderr}")

    pub fn get_name(self) -> text:
        """Get package name with version.

        Returns:
            Package name

        Example:
            # manifest.metadata.name = "my-app"
            # manifest.metadata.version = "1.0.0"
            package.get_name()  # → "my-app-1.0.0"
        """
        "{self.manifest.metadata.name}-{self.manifest.metadata.version}"

    pub fn validate(self) -> Result<(), text>:
        """Validate package configuration.

        Returns:
            Ok if valid, Err with message otherwise

        Checks:
        - Name and version are set
        - At least one file
        - File paths exist (when possible)
        """
        if self.manifest.metadata.name == "":
            return Err("Package name is required")

        if self.manifest.metadata.version == "":
            return Err("Package version is required")

        if self.manifest.files.len() == 0:
            return Err("Package must contain at least one file")

        Ok(())

    pub fn is_valid(self) -> bool:
        """Check if package is valid.

        Returns:
            True if validation passes

        Example:
            if package.is_valid():
                package.write("output.tar.gz")
        """
        match self.validate():
            Ok(_): true
            Err(_): false

    pub fn has_files(self) -> bool:
        """Check if package has files.

        Returns:
            True if file count > 0
        """
        self.file_count > 0

    pub fn is_archive(self) -> bool:
        """Check if package format is a generic archive.

        Returns:
            True for tarball/zip
        """
        self.format.is_archive()

    pub fn is_linux_package(self) -> bool:
        """Check if package format is a Linux package.

        Returns:
            True for deb/rpm
        """
        self.format.is_linux_package()

    pub fn is_language_package(self) -> bool:
        """Check if package format is language-specific.

        Returns:
            True for npm/pypi/nuget
        """
        self.format.is_language_package()

    pub fn get_filename(self) -> text:
        """Get suggested output filename.

        Returns:
            Filename with appropriate extension

        Example:
            package.get_filename()
            # → "my-app-1.0.0.tar.gz"
        """
        "{self.get_name()}{self.format.get_extension()}"

    pub fn summary(self) -> text:
        """Get package summary.

        Returns:
            Human-readable summary

        Example:
            package.summary()
            # → "Package: my-app-1.0.0.tar.gz (10 files, 5.2 MB)"
        """
        "Package: {self.get_filename()} ({self.file_count} files, {self.size_mb:.1f} MB)"
