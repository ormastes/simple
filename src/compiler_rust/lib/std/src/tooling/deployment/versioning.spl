# Version Management
# Manage versioning across multi-language projects

use core.result.{Result, Ok, Err}
use shell.{file, path}

# Semantic version
pub class SemVer:
    pub major: i32
    pub minor: i32
    pub patch: i32
    pub prerelease: text
    pub build_metadata: text

    pub fn new(major: i32, minor: i32, patch: i32) -> SemVer:
        """Create semantic version.

        Args:
            major: Major version
            minor: Minor version
            patch: Patch version

        Returns:
            Semantic version

        Example:
            val v = SemVer.new(1, 2, 3)
            print(v.to_string())  # → "1.2.3"
        """
        SemVer(
            major: major,
            minor: minor,
            patch: patch,
            prerelease: "",
            build_metadata: ""
        )

    pub fn parse(version_str: text) -> Result<SemVer, text>:
        """Parse version string.

        Args:
            version_str: Version string (e.g., "1.2.3", "2.0.0-beta.1")

        Returns:
            Parsed version or error

        Supports:
        - Basic: "1.2.3"
        - Prerelease: "1.2.3-beta.1", "1.2.3-alpha"
        - Build metadata: "1.2.3+20240110"
        - Combined: "1.2.3-beta.1+build.123"

        Example:
            match SemVer.parse("1.2.3"):
                Ok(v):
                    print("Version: {v.major}.{v.minor}.{v.patch}")
                Err(e):
                    print("Parse error: {e}")
        """
        # Clean version string
        val trimmed = version_str.trim()

        # Extract build metadata (after '+')
        val (core_and_pre, build_meta) = self.split_on_plus(trimmed)

        # Extract prerelease (after '-')
        val (core, prerelease) = self.split_on_dash(core_and_pre)

        # Parse core version (MAJOR.MINOR.PATCH)
        val parts = core.split(".")
        if parts.len() != 3:
            return Err("Invalid version format: expected MAJOR.MINOR.PATCH, got '" + core + "'")

        # Parse major
        val major = self.parse_int(parts[0])?

        # Parse minor
        val minor = self.parse_int(parts[1])?

        # Parse patch
        val patch = self.parse_int(parts[2])?

        # Build version
        var version = SemVer.new(major, minor, patch)
        version.prerelease = prerelease
        version.build_metadata = build_meta

        Ok(version)

    fn split_on_plus(text: text) -> (text, text):
        """Split on '+' for build metadata.

        Args:
            text: Version string

        Returns:
            (core_and_prerelease, build_metadata)
        """
        val plus_idx = text.find("+")
        if plus_idx >= 0:
            val before = text[0:plus_idx]
            val after = text[plus_idx+1:]
            (before, after)
        else:
            (text, "")

    fn split_on_dash(text: text) -> (text, text):
        """Split on '-' for prerelease.

        Args:
            text: Version string

        Returns:
            (core, prerelease)
        """
        val dash_idx = text.find("-")
        if dash_idx >= 0:
            val before = text[0:dash_idx]
            val after = text[dash_idx+1:]
            (before, after)
        else:
            (text, "")

    fn parse_int(s: text) -> Result<i32, text>:
        """Parse integer from string.

        Args:
            s: text to parse

        Returns:
            Parsed integer or error
        """
        # Simple integer parsing
        val trimmed = s.trim()
        if trimmed.is_empty():
            return Err("Empty string cannot be parsed as integer")

        var result = 0
        var negative = false
        var start_idx = 0

        # Check for negative sign
        if trimmed[0] == '-':
            negative = true
            start_idx = 1

        # Parse digits
        for i in start_idx..trimmed.len():
            val ch = trimmed[i]
            if ch >= '0' and ch <= '9':
                val digit = (ch as i32) - ('0' as i32)
                result = result * 10 + digit
            else:
                return Err("Invalid character in number: '" + ch + "'")

        if negative:
            result = -result

        Ok(result)

    pub fn to_string(self) -> text:
        """Convert to string.

        Returns:
            Version string

        Example:
            SemVer.new(1, 2, 3).to_string()  # → "1.2.3"
        """
        var version = "{self.major}.{self.minor}.{self.patch}"

        if not self.prerelease.is_empty():
            version += "-{self.prerelease}"

        if not self.build_metadata.is_empty():
            version += "+{self.build_metadata}"

        version

    pub fn bump_major(self) -> SemVer:
        """Bump major version.

        Returns:
            New version with major incremented

        Example:
            SemVer.new(1, 2, 3).bump_major()  # → 2.0.0
        """
        SemVer.new(self.major + 1, 0, 0)

    pub fn bump_minor(self) -> SemVer:
        """Bump minor version.

        Returns:
            New version with minor incremented

        Example:
            SemVer.new(1, 2, 3).bump_minor()  # → 1.3.0
        """
        SemVer.new(self.major, self.minor + 1, 0)

    pub fn bump_patch(self) -> SemVer:
        """Bump patch version.

        Returns:
            New version with patch incremented

        Example:
            SemVer.new(1, 2, 3).bump_patch()  # → 1.2.4
        """
        SemVer.new(self.major, self.minor, self.patch + 1)

    pub fn bump_prerelease(self) -> SemVer:
        """Bump prerelease version.

        Returns:
            New version with prerelease incremented

        Example:
            SemVer.new(1, 2, 3).bump_prerelease()  # → 1.2.3-alpha.0
            v.prerelease = "beta.1"
            v.bump_prerelease()  # → 1.2.3-beta.2
        """
        var new_version = SemVer.new(self.major, self.minor, self.patch)
        new_version.build_metadata = self.build_metadata

        if self.prerelease.is_empty():
            # No prerelease yet, start with alpha.0
            new_version.prerelease = "alpha.0"
        else:
            # Try to find and increment numeric suffix
            val dot_idx = self.prerelease.rfind(".")
            if dot_idx >= 0:
                # Has a dot, try to parse number after it
                val prefix = self.prerelease[0:dot_idx]
                val suffix = self.prerelease[dot_idx+1:]

                # Try to parse suffix as integer
                val num = self.parse_prerelease_num(suffix)
                if num >= 0:
                    # Successfully parsed, increment
                    new_version.prerelease = "{prefix}.{num + 1}"
                else:
                    # Not a number, append .1
                    new_version.prerelease = "{self.prerelease}.1"
            else:
                # No dot, append .1
                new_version.prerelease = "{self.prerelease}.1"

        new_version

    fn parse_prerelease_num(s: text) -> i32:
        """Parse prerelease number.

        Args:
            s: text to parse

        Returns:
            Parsed number or -1 on error
        """
        if s.is_empty():
            return -1

        var result = 0
        for i in 0..s.len():
            val ch = s[i]
            if ch >= '0' and ch <= '9':
                val digit = (ch as i32) - ('0' as i32)
                result = result * 10 + digit
            else:
                # Not a valid number
                return -1

        result

    pub fn is_prerelease(self) -> bool:
        """Check if this is a prerelease version.

        Returns:
            True if prerelease tag exists

        Example:
            SemVer.new(1, 2, 3).is_prerelease()  # → false
            v.prerelease = "beta.1"
            v.is_prerelease()  # → true
        """
        not self.prerelease.is_empty()

    pub fn is_stable(self) -> bool:
        """Check if this is a stable release.

        Returns:
            True if no prerelease tag

        Example:
            SemVer.new(1, 0, 0).is_stable()  # → true
        """
        not self.is_prerelease()

    pub fn compare(self, other: SemVer) -> i32:
        """Compare two versions.

        Args:
            other: Version to compare with

        Returns:
            -1 if self < other, 0 if equal, 1 if self > other

        Example:
            SemVer.new(1, 2, 3).compare(SemVer.new(1, 2, 4))  # → -1
            SemVer.new(2, 0, 0).compare(SemVer.new(1, 9, 9))  # → 1
        """
        # Compare major
        if self.major < other.major:
            return -1
        elif self.major > other.major:
            return 1

        # Compare minor
        if self.minor < other.minor:
            return -1
        elif self.minor > other.minor:
            return 1

        # Compare patch
        if self.patch < other.patch:
            return -1
        elif self.patch > other.patch:
            return 1

        # Equal
        0


# BumpType and VersionManager are in versioning_ops.spl
