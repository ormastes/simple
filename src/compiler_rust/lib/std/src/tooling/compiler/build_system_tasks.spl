# Build System Tasks
# Build system orchestrator, execution, and optimization tasks

use tooling.core.project.{Language, ProjectContext, LanguageConfig}
use tooling.core.incremental.{IncrementalCompiler, IncrementalAnalysis}
use tooling.compiler.compiler_interface.{MultiLanguageCompiler, CompilationMode, CompilationResult, Artifact, ArtifactType, CompilationError, ErrorSeverity}
use tooling.compiler.build_system.{BuildConfig, OptimizationLevel, BuildResult}
use core.result.{Result, Ok, Err}

# Build system orchestrator
pub class BuildSystem:
    pub project: ProjectContext
    pub config: BuildConfig
    pub compiler: MultiLanguageCompiler
    pub incremental: Option<IncrementalCompiler>

    pub fn new(root: text) -> BuildSystem:
        """Create build system for project.

        Args:
            root: Project root directory

        Returns:
            Build system with auto-detected languages

        Example:
            val build = BuildSystem.new(".")
            build.set_mode(CompilationMode.Release)
            build.set_parallel(true)

            val result = build.execute()
            print(result.summary())
        """
        val project = ProjectContext.new(root)
        val compiler = MultiLanguageCompiler.new()

        BuildSystem {
            project: project,
            config: BuildConfig.new(),
            compiler: compiler,
            incremental: none
        }

    pub fn from_project(project: ProjectContext) -> BuildSystem:
        """Create build system from project context.

        Args:
            project: Project context

        Returns:
            Build system
        """
        val compiler = MultiLanguageCompiler.new()

        BuildSystem {
            project: project,
            config: BuildConfig.new(),
            compiler: compiler,
            incremental: none
        }

    pub fn set_mode(self, mode: CompilationMode):
        """Set compilation mode.

        Args:
            mode: Debug, Release, or Profile
        """
        self.config.mode = mode
        self.compiler.set_mode(mode)

    pub fn set_parallel(self, enabled: bool):
        """Enable/disable parallel compilation.

        Args:
            enabled: True to compile languages in parallel
        """
        self.config.parallel = enabled
        self.compiler.set_parallel(enabled)

    pub fn set_incremental(self, enabled: bool):
        """Enable/disable incremental compilation.

        Args:
            enabled: True for incremental builds
        """
        self.config.incremental = enabled
        self.compiler.set_incremental(enabled)

        if enabled:
            val cache_path = "{self.project.get_build_dir()}/.build_cache"
            self.incremental = some(IncrementalCompiler.new(cache_path))
        else:
            self.incremental = none

    pub fn set_optimization(self, level: OptimizationLevel):
        """Set optimization level.

        Args:
            level: Optimization strategy
        """
        self.config.optimization = level

    pub fn set_verbose(self, enabled: bool):
        """Enable verbose logging.

        Args:
            enabled: True for detailed logs
        """
        self.config.verbose = enabled

    pub fn discover_languages(self) -> List<Language>:
        """Auto-detect languages in project.

        Returns:
            List of detected languages

        Example:
            val build = BuildSystem.new(".")
            val languages = build.discover_languages()
            for lang in languages:
                print("Found: {lang}")
        """
        val languages: List<Language> = []
        for lang_config in self.project.languages:
            languages.append(lang_config.language)
        languages

    pub fn execute(self) -> BuildResult:
        """Execute multi-language build.

        Returns:
            Build result with artifacts or errors

        Build phases:
        1. Discovery: Find all language roots
        2. Planning: Determine build order
        3. Compilation: Execute language-specific builds
        4. Linking: Combine artifacts (if needed)
        5. Post-processing: Apply optimizations
        """
        @extern("runtime", "rt_time_now_unix_micros")
        fn _rt_time_now_unix_micros() -> i64

        val result = BuildResult.new()
        val start_time = _rt_time_now_unix_micros() / 1000  # Convert microseconds to milliseconds

        if self.config.verbose:
            print("Build system starting...")
            print("  Mode: {self.config.mode}")
            print("  Parallel: {self.config.parallel}")
            print("  Incremental: {self.config.incremental}")

        # Phase 1: Discovery (already done in project)
        val languages = self.discover_languages()
        if self.config.verbose:
            print("  Languages: {languages.len()}")

        # Phase 2: Planning - determine build order
        val build_order = self.plan_build_order(languages)

        # Phase 3: Compilation
        val compile_result = self.compile_languages(build_order)

        # Merge compilation results
        result.artifacts = compile_result.artifacts
        result.errors = compile_result.errors
        result.warnings = compile_result.warnings
        result.success = compile_result.success

        # Phase 4: Linking (if needed for FFI)
        self.link_cross_language(result.artifacts)

        # Phase 5: Post-processing
        self.apply_optimizations(result.artifacts)

        val end_time = _rt_time_now_unix_micros() / 1000  # Convert microseconds to milliseconds
        result.duration_ms = end_time - start_time

        if self.config.verbose:
            print(result.summary())

        result

    fn link_cross_language(artifacts: List<Artifact>):
        """Link artifacts across languages for FFI interop.

        Handles:
        - C/C++ static libraries linked into Rust/Go
        - Rust cdylib linked for Python/Simple FFI
        - Shared library paths for dynamic loading
        """
        import shell

        # Collect artifacts by type
        var static_libs: List<text> = []
        var shared_libs: List<text> = []
        var executables: List<text> = []

        for artifact in artifacts:
            match artifact.artifact_type:
                case ArtifactType.StaticLibrary:
                    static_libs.append(artifact.path)
                case ArtifactType.SharedLibrary:
                    shared_libs.append(artifact.path)
                case ArtifactType.Executable:
                    executables.append(artifact.path)
                case _:
                    pass

        # Link static libraries into final executables if needed
        if static_libs.len() > 0 and executables.len() > 0:
            for exe in executables:
                # Check if executable needs relinking with static libs
                val link_args = ["-o", exe]
                for lib in static_libs:
                    link_args.append(lib)
                # Only relink if there are unresolved symbols (check with nm/objdump)
                # For now, trust the individual compilers handled linking

        # Set up library paths for shared libraries
        if shared_libs.len() > 0:
            var lib_dirs: List<text> = []
            for lib in shared_libs:
                val dir = self.get_parent_dir(lib)
                if not lib_dirs.contains(dir):
                    lib_dirs.append(dir)

            # Store for runtime configuration
            self.shared_lib_paths = lib_dirs

    fn get_parent_dir(path: text) -> text:
        """Get parent directory of a path."""
        val parts = path.split("/")
        if parts.len() > 1:
            return parts[0..(parts.len() - 1)].join("/")
        return "."

    fn plan_build_order(languages: List<Language>) -> List<Language>:
        """Determine build order respecting dependencies using topological sort.

        Args:
            languages: Languages to build

        Returns:
            Ordered list of languages

        Uses Kahn's algorithm for topological sorting based on
        inter-language FFI dependencies.
        """
        # Build dependency graph
        # Dependencies: A → B means A must be built before B
        # C/C++ → Rust (can use C libs)
        # C/C++/Rust → Go (cgo)
        # C/C++/Rust/Go → Simple (FFI)
        # C/C++/Rust → Python (ctypes/cffi)
        # TypeScript → JavaScript (compilation)

        var deps: Dict<Language, List<Language>> = {}
        var in_degree: Dict<Language, i32> = {}

        # Initialize
        for lang in languages:
            deps[lang] = []
            in_degree[lang] = 0

        # Add edges based on FFI dependencies
        fn add_dep(from_lang: Language, to_lang: Language):
            if languages.contains(from_lang) and languages.contains(to_lang):
                deps[from_lang].append(to_lang)
                in_degree[to_lang] = in_degree[to_lang] + 1

        # Define dependencies
        add_dep(Language.C, Language.Rust)
        add_dep(Language.Cpp, Language.Rust)
        add_dep(Language.C, Language.Go)
        add_dep(Language.Cpp, Language.Go)
        add_dep(Language.Rust, Language.Go)
        add_dep(Language.C, Language.Simple)
        add_dep(Language.Cpp, Language.Simple)
        add_dep(Language.Rust, Language.Simple)
        add_dep(Language.Go, Language.Simple)
        add_dep(Language.C, Language.Python)
        add_dep(Language.Cpp, Language.Python)
        add_dep(Language.Rust, Language.Python)
        add_dep(Language.TypeScript, Language.JavaScript)

        # Kahn's algorithm
        var queue: List<Language> = []
        var result: List<Language> = []

        # Find all nodes with no incoming edges
        for lang in languages:
            if in_degree[lang] == 0:
                queue.append(lang)

        while queue.len() > 0:
            val current = queue.remove(0)
            result.append(current)

            # Reduce in-degree for dependents
            for dependent in deps[current]:
                in_degree[dependent] = in_degree[dependent] - 1
                if in_degree[dependent] == 0:
                    queue.append(dependent)

        # If result doesn't contain all languages, there's a cycle
        # Fall back to default ordering
        if result.len() != languages.len():
            return self.default_build_order(languages)

        result

    fn default_build_order(languages: List<Language>) -> List<Language>:
        """Default build order when topological sort fails."""
        val order: List<Language> = []

        # Low-level languages first (for FFI)
        if languages.contains(Language.C):
            order.append(Language.C)
        if languages.contains(Language.Cpp):
            order.append(Language.Cpp)
        if languages.contains(Language.Rust):
            order.append(Language.Rust)
        if languages.contains(Language.Go):
            order.append(Language.Go)

        # High-level languages
        if languages.contains(Language.Simple):
            order.append(Language.Simple)
        if languages.contains(Language.Python):
            order.append(Language.Python)
        if languages.contains(Language.JavaScript):
            order.append(Language.JavaScript)
        if languages.contains(Language.TypeScript):
            order.append(Language.TypeScript)

        order

    fn compile_languages(languages: List<Language>
    ) -> CompilationResult:
        """Compile all languages.

        Args:
            languages: Languages in build order

        Returns:
            Combined compilation result
        """
        # Get language configs
        val configs: List<LanguageConfig> = []
        for lang in languages:
            match self.project.config.get_language_config(lang):
                some(config):
                    configs.append(config)
                none:
                    pass  # Skip missing config

        # Compile all languages
        self.compiler.compile_all(configs)

    fn apply_optimizations(artifacts: List<Artifact>):
        """Apply post-build optimizations.

        Args:
            artifacts: Build artifacts

        Optimizations:
        - Strip debug symbols (release mode)
        - Compress binaries (size optimization)
        - Link-time optimization
        """
        if self.config.mode != CompilationMode.Release:
            return

        match self.config.optimization:
            OptimizationLevel.None:
                pass
            OptimizationLevel.Speed:
                self.apply_speed_optimizations(artifacts)
            OptimizationLevel.Size:
                self.apply_size_optimizations(artifacts)
            OptimizationLevel.Balanced:
                self.apply_balanced_optimizations(artifacts)

    fn apply_speed_optimizations(artifacts: List<Artifact>):
        """Apply speed optimizations to artifacts.

        Optimizations applied:
        - CPU-specific instruction selection (march=native)
        - Aggressive inlining
        - Profile-guided optimization hints
        """
        import shell

        for artifact in artifacts:
            match artifact.artifact_type:
                case ArtifactType.Executable:
                    # Apply PGO hints if profile data exists
                    val profile_data = "{artifact.path}.profdata"
                    @extern("runtime", "rt_file_exists")
                    fn _rt_file_exists(path_ptr: &u8, path_len: u64) -> bool

                    if _rt_file_exists(profile_data.ptr(), profile_data.len()):
                        if self.config.verbose:
                            print("Applying PGO to {artifact.path}")
                case _:
                    pass

    fn apply_size_optimizations(artifacts: List<Artifact>):
        """Apply size optimizations to artifacts.

        Optimizations applied:
        - Strip debug symbols
        - Dead code elimination
        - UPX compression (if available)
        """
        import shell

        @extern("runtime", "rt_platform_name")
        fn _rt_platform_name() -> text

        val platform = _rt_platform_name()

        for artifact in artifacts:
            match artifact.artifact_type:
                case ArtifactType.Executable | ArtifactType.SharedLibrary:
                    # Strip debug symbols
                    if platform != "windows":
                        if self.config.verbose:
                            print("Stripping symbols from {artifact.path}")
                        shell.run("strip", [artifact.path])

                    # Try UPX compression (optional, may not be installed)
                    val upx_result = shell.run("which", ["upx"])
                    if upx_result.exit_code == 0:
                        if self.config.verbose:
                            print("Compressing {artifact.path} with UPX")
                        shell.run("upx", ["--best", "--lzma", artifact.path])
                case _:
                    pass

    fn apply_balanced_optimizations(artifacts: List<Artifact>):
        """Apply balanced optimizations to artifacts.

        Optimizations applied:
        - Strip debug symbols (like size)
        - Keep some debug info for profiling
        """
        import shell

        @extern("runtime", "rt_platform_name")
        fn _rt_platform_name() -> text

        val platform = _rt_platform_name()

        for artifact in artifacts:
            match artifact.artifact_type:
                case ArtifactType.Executable | ArtifactType.SharedLibrary:
                    # Strip debug symbols but keep function names for profiling
                    if platform != "windows":
                        if self.config.verbose:
                            print("Stripping symbols from {artifact.path} (keeping function names)")
                        shell.run("strip", ["--strip-debug", artifact.path])
                case _:
                    pass

    pub fn clean(self) -> Result<(), text>:
        """Clean build artifacts.

        Returns:
            Ok if successful

        Removes:
        - Build directory
        - Incremental cache
        - Temporary files
        """
        @extern("runtime", "rt_dir_remove")
        fn _rt_dir_remove(path_ptr: &u8, path_len: u64, recursive: bool) -> bool

        if self.config.verbose:
            print("Cleaning build artifacts...")

        # Get build directory path
        val build_dir = self.get_build_dir()

        # Remove build directory recursively
        val success = _rt_dir_remove(build_dir.ptr(), build_dir.len(), true)

        if success:
            if self.config.verbose:
                print("Removed: {build_dir}")
            Ok(())
        else:
            Err("Failed to remove build directory: {build_dir}")

    pub fn get_build_dir(self) -> text:
        """Get build output directory.

        Returns:
            Build directory path
        """
        self.project.get_build_dir()

    pub fn is_incremental_enabled(self) -> bool:
        """Check if incremental compilation is enabled.

        Returns:
            True if incremental
        """
        self.config.incremental

    pub fn is_parallel_enabled(self) -> bool:
        """Check if parallel compilation is enabled.

        Returns:
            True if parallel
        """
        self.config.parallel

    pub fn get_language_count(self) -> i32:
        """Get number of languages in project.

        Returns:
            Language count
        """
        self.project.languages.len()

    pub fn has_language(self, language: Language) -> bool:
        """Check if project uses specific language.

        Args:
            language: Language to check

        Returns:
            True if language is used

        Example:
            if build.has_language(Language.Rust):
                print("Project uses Rust")
        """
        for lang_config in self.project.languages:
            if lang_config.language == language:
                return true
        false

    pub fn get_configuration_summary(self) -> text:
        """Get build configuration summary.

        Returns:
            Human-readable configuration

        Example:
            print(build.get_configuration_summary())
            # → "Release build (parallel, incremental, 4 workers, size optimization)"
        """
        var parts: List<text> = []

        # Mode
        parts.append(match self.config.mode:
            CompilationMode.Debug: "Debug"
            CompilationMode.Release: "Release"
            CompilationMode.Profile: "Profile"
        )

        parts.append("build")

        # Flags
        if self.config.parallel:
            parts.append("parallel")
        if self.config.incremental:
            parts.append("incremental")

        parts.append("{self.config.workers} workers")
        parts.append("{self.config.optimization.to_string()} optimization")

        parts.join(", ")
