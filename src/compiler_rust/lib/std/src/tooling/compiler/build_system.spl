# Build System Integration
# Orchestrate builds across multiple languages

use tooling.core.project.{Language, ProjectContext, LanguageConfig}
use tooling.core.incremental.{IncrementalCompiler, IncrementalAnalysis}
use tooling.compiler.compiler_interface.{MultiLanguageCompiler, CompilationMode, CompilationResult, Artifact, CompilationError}
use core.result.{Result, Ok, Err}

# Build configuration
pub class BuildConfig:
    pub mode: CompilationMode
    pub parallel: bool
    pub incremental: bool
    pub workers: i32
    pub optimization: OptimizationLevel
    pub verbose: bool

    pub fn new() -> BuildConfig:
        """Create default build configuration.

        Returns:
            Default configuration
        """
        BuildConfig {
            mode: CompilationMode.Debug,
            parallel: false,
            incremental: false,
            workers: 4,
            optimization: OptimizationLevel.None,
            verbose: false
        }

    pub fn release() -> BuildConfig:
        """Create release build configuration.

        Returns:
            Release configuration with optimizations
        """
        BuildConfig {
            mode: CompilationMode.Release,
            parallel: true,
            incremental: true,
            workers: 4,
            optimization: OptimizationLevel.Size,
            verbose: false
        }

    pub fn with_mode(self, mode: CompilationMode) -> BuildConfig:
        """Set compilation mode (fluent API).

        Args:
            mode: Compilation mode

        Returns:
            Modified config
        """
        self.mode = mode
        self

    pub fn with_parallel(self, enabled: bool) -> BuildConfig:
        """Set parallel compilation (fluent API).

        Args:
            enabled: True to enable

        Returns:
            Modified config
        """
        self.parallel = enabled
        self

    pub fn with_workers(self, count: i32) -> BuildConfig:
        """Set worker count (fluent API).

        Args:
            count: Number of workers

        Returns:
            Modified config
        """
        self.workers = count
        self

    pub fn with_optimization(self, level: OptimizationLevel) -> BuildConfig:
        """Set optimization level (fluent API).

        Args:
            level: Optimization level

        Returns:
            Modified config
        """
        self.optimization = level
        self

    pub fn is_release(self) -> bool:
        """Check if this is a release build.

        Returns:
            True if release mode
        """
        match self.mode:
            CompilationMode.Release: true
            _: false

# Optimization level
pub enum OptimizationLevel:
    None
    Speed
    Size
    Balanced

    pub fn to_string(self) -> text:
        """Convert optimization level to string.

        Returns:
            Level name

        Example:
            OptimizationLevel.Speed.to_string()  # → "speed"
        """
        match self:
            OptimizationLevel.None: "none"
            OptimizationLevel.Speed: "speed"
            OptimizationLevel.Size: "size"
            OptimizationLevel.Balanced: "balanced"

    pub fn description(self) -> text:
        """Get optimization description.

        Returns:
            Human-readable description

        Example:
            OptimizationLevel.Size.description()
            # → "Optimize for binary size"
        """
        match self:
            OptimizationLevel.None:
                "No optimizations (fastest builds)"
            OptimizationLevel.Speed:
                "Optimize for execution speed"
            OptimizationLevel.Size:
                "Optimize for binary size"
            OptimizationLevel.Balanced:
                "Balance speed and size"

    pub fn get_compiler_flags(self) -> List<text>:
        """Get compiler flags for this optimization level.

        Returns:
            Compiler flags

        Example:
            OptimizationLevel.Speed.get_compiler_flags()
            # → ["-O3", "-march=native"]
        """
        match self:
            OptimizationLevel.None:
                ["-O0"]
            OptimizationLevel.Speed:
                ["-O3", "-march=native"]
            OptimizationLevel.Size:
                ["-Os", "-flto"]
            OptimizationLevel.Balanced:
                ["-O2"]

    pub fn is_none(self) -> bool:
        """Check if optimization is disabled.

        Returns:
            True if None

        Example:
            OptimizationLevel.None.is_none()  # → true
        """
        match self:
            OptimizationLevel.None: true
            _: false

    pub fn is_speed(self) -> bool:
        """Check if optimizing for speed.

        Returns:
            True if Speed

        Example:
            OptimizationLevel.Speed.is_speed()  # → true
        """
        match self:
            OptimizationLevel.Speed: true
            _: false

    pub fn is_size(self) -> bool:
        """Check if optimizing for size.

        Returns:
            True if Size

        Example:
            OptimizationLevel.Size.is_size()  # → true
        """
        match self:
            OptimizationLevel.Size: true
            _: false

    pub fn is_balanced(self) -> bool:
        """Check if using balanced optimization.

        Returns:
            True if Balanced

        Example:
            OptimizationLevel.Balanced.is_balanced()  # → true
        """
        match self:
            OptimizationLevel.Balanced: true
            _: false

    pub fn is_optimized(self) -> bool:
        """Check if any optimization is enabled.

        Returns:
            False for None, true otherwise

        Example:
            OptimizationLevel.None.is_optimized()  # → false
            OptimizationLevel.Speed.is_optimized()  # → true
        """
        match self:
            OptimizationLevel.None: false
            _: true

    pub fn is_aggressive(self) -> bool:
        """Check if using aggressive optimization.

        Returns:
            True for Speed (most aggressive)

        Example:
            OptimizationLevel.Speed.is_aggressive()  # → true
        """
        match self:
            OptimizationLevel.Speed: true
            _: false

    pub fn summary(self) -> text:
        """Get optimization level summary.

        Returns:
            Human-readable summary

        Example:
            OptimizationLevel.Speed.summary()
            # → "OptimizationLevel: speed (Optimize for execution speed, optimized, aggressive)"
        """
        val name = self.to_string()
        val desc = self.description()
        val status = if self.is_optimized(): "optimized" else: "unoptimized"
        val mode = if self.is_aggressive():
            ", aggressive"
        elif self.is_balanced():
            ", balanced"
        else:
            ""
        return "OptimizationLevel: {name} ({desc}, {status}{mode})"

# Build result
pub class BuildResult:
    pub success: bool
    pub artifacts: List<Artifact>
    pub errors: List<CompilationError>
    pub warnings: List<CompilationError>
    pub duration_ms: i64
    pub files_built: i32
    pub files_skipped: i32

    pub fn new() -> BuildResult:
        """Create empty build result."""
        BuildResult {
            success: true,
            artifacts: [],
            errors: [],
            warnings: [],
            duration_ms: 0,
            files_built: 0,
            files_skipped: 0
        }

    pub fn is_ok(self) -> bool:
        """Check if build succeeded.

        Returns:
            True if no errors
        """
        self.errors.len() == 0

    pub fn summary(self) -> text:
        """Get build summary string.

        Returns:
            Human-readable summary
        """
        if self.is_ok():
            "✓ Build succeeded: {self.artifacts.len()} artifacts in {self.duration_ms}ms"
        else:
            "✗ Build failed: {self.errors.len()} errors, {self.warnings.len()} warnings"

    pub fn total_files(self) -> i32:
        """Get total files processed.

        Returns:
            Total files (built + skipped)
        """
        self.files_built + self.files_skipped

    pub fn duration_seconds(self) -> f64:
        """Get build duration in seconds.

        Returns:
            Duration in seconds
        """
        (self.duration_ms as f64) / 1000.0

    pub fn artifact_count(self) -> i32:
        """Get artifact count.

        Returns:
            Number of artifacts
        """
        self.artifacts.len()

    pub fn error_count(self) -> i32:
        """Get error count.

        Returns:
            Number of errors
        """
        self.errors.len()

    pub fn warning_count(self) -> i32:
        """Get warning count.

        Returns:
            Number of warnings
        """
        self.warnings.len()

    pub fn has_warnings(self) -> bool:
        """Check if build has warnings.

        Returns:
            True if warnings present
        """
        self.warnings.len() > 0

    pub fn get_artifacts_by_type(self, artifact_type: ArtifactType) -> List<Artifact>:
        """Get artifacts of specific type.

        Args:
            artifact_type: Type to filter by

        Returns:
            Filtered artifacts

        Example:
            val executables = result.get_artifacts_by_type(ArtifactType.Executable)
            for exe in executables:
                print("Built: {exe.path}")
        """
        val filtered: List<Artifact> = []
        for artifact in self.artifacts:
            if artifact.artifact_type == artifact_type:
                filtered.append(artifact)
        filtered

# BuildSystem class is in build_system_tasks.spl
