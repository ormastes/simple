# Multi-Language Project Detection & Configuration
# Detects language roots, reads config files, manages project structure

use host.async_nogc_mut.io.fs
use host.common.io.types.{FileType, DirEntry, FilePath, DirPath}
use sdn.{SdnDocument, SdnValue}
use core.result.{Result, Ok, Err}

# Project language type
pub enum Language:
    Simple
    Rust
    Python
    JavaScript
    TypeScript
    Go
    C
    Cpp

    pub fn to_string(self) -> text:
        """Convert language to string.

        Returns:
            Language name

        Example:
            Language.Rust.to_string()  # -> "Rust"
        """
        match self:
            Language.Simple: "Simple"
            Language.Rust: "Rust"
            Language.Python: "Python"
            Language.JavaScript: "JavaScript"
            Language.TypeScript: "TypeScript"
            Language.Go: "Go"
            Language.C: "C"
            Language.Cpp: "C++"

    pub fn description(self) -> text:
        """Get language description.

        Returns:
            Human-readable description

        Example:
            Language.Rust.description()
            # -> "Systems programming language with memory safety"
        """
        match self:
            Language.Simple: "Simple programming language (this project)"
            Language.Rust: "Systems programming language with memory safety"
            Language.Python: "High-level interpreted scripting language"
            Language.JavaScript: "Dynamic scripting language for web"
            Language.TypeScript: "Typed superset of JavaScript"
            Language.Go: "Compiled language with goroutines and channels"
            Language.C: "Low-level systems programming language"
            Language.Cpp: "C++ systems programming with object-oriented features"

    pub fn get_extension(self) -> text:
        """Get file extension for language.

        Returns:
            File extension with dot

        Example:
            Language.Rust.get_extension()  # -> ".rs"
        """
        match self:
            Language.Simple: ".spl"
            Language.Rust: ".rs"
            Language.Python: ".py"
            Language.JavaScript: ".js"
            Language.TypeScript: ".ts"
            Language.Go: ".go"
            Language.C: ".c"
            Language.Cpp: ".cpp"

    pub fn is_compiled(self) -> bool:
        """Check if language is compiled.

        Returns:
            True if compiled language

        Example:
            Language.Rust.is_compiled()  # -> true
            Language.Python.is_compiled()  # -> false
        """
        match self:
            Language.Simple: true
            Language.Rust: true
            Language.Go: true
            Language.C: true
            Language.Cpp: true
            Language.Python: false
            Language.JavaScript: false
            Language.TypeScript: false  # TypeScript transpiles, not compiles to machine code

    pub fn is_interpreted(self) -> bool:
        """Check if language is interpreted.

        Returns:
            True if interpreted language
        """
        not self.is_compiled()

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_simple(self) -> bool:
        """Check if language is Simple.

        Returns:
            True if Simple
        """
        match self:
            Language.Simple: true
            _: false

    pub fn is_rust(self) -> bool:
        """Check if language is Rust.

        Returns:
            True if Rust
        """
        match self:
            Language.Rust: true
            _: false

    pub fn is_python(self) -> bool:
        """Check if language is Python.

        Returns:
            True if Python
        """
        match self:
            Language.Python: true
            _: false

    pub fn is_javascript(self) -> bool:
        """Check if language is JavaScript.

        Returns:
            True if JavaScript
        """
        match self:
            Language.JavaScript: true
            _: false

    pub fn is_typescript(self) -> bool:
        """Check if language is TypeScript.

        Returns:
            True if TypeScript
        """
        match self:
            Language.TypeScript: true
            _: false

    pub fn is_go(self) -> bool:
        """Check if language is Go.

        Returns:
            True if Go
        """
        match self:
            Language.Go: true
            _: false

    pub fn is_c(self) -> bool:
        """Check if language is C.

        Returns:
            True if C
        """
        match self:
            Language.C: true
            _: false

    pub fn is_cpp(self) -> bool:
        """Check if language is C++.

        Returns:
            True if C++
        """
        match self:
            Language.Cpp: true
            _: false

    pub fn is_scripting_language(self) -> bool:
        """Check if language is a scripting language.

        Returns:
            True if Python or JavaScript
        """
        match self:
            Language.Python: true
            Language.JavaScript: true
            _: false

    pub fn is_systems_language(self) -> bool:
        """Check if language is a systems programming language.

        Returns:
            True if Rust, C, C++, or Go
        """
        match self:
            Language.Rust: true
            Language.C: true
            Language.Cpp: true
            Language.Go: true
            _: false

    pub fn supports_type_annotations(self) -> bool:
        """Check if language supports type annotations.

        Returns:
            True if language has type system
        """
        match self:
            Language.Simple: true
            Language.Rust: true
            Language.TypeScript: true
            Language.Go: true
            Language.C: true
            Language.Cpp: true
            Language.Python: true  # Python has optional type hints
            Language.JavaScript: false

    pub fn is_statically_typed(self) -> bool:
        """Check if language is statically typed.

        Returns:
            True if static typing
        """
        match self:
            Language.Simple: true
            Language.Rust: true
            Language.TypeScript: true
            Language.Go: true
            Language.C: true
            Language.Cpp: true
            _: false

    pub fn is_dynamically_typed(self) -> bool:
        """Check if language is dynamically typed.

        Returns:
            True if dynamic typing
        """
        not self.is_statically_typed()

    pub fn has_package_manager(self) -> bool:
        """Check if language has a standard package manager.

        Returns:
            True if package manager exists
        """
        match self:
            Language.Simple: true   # spm
            Language.Rust: true     # cargo
            Language.Python: true   # pip
            Language.JavaScript: true  # npm
            Language.TypeScript: true  # npm
            Language.Go: true       # go mod
            _: false

    pub fn get_package_manager(self) -> text:
        """Get name of package manager.

        Returns:
            Package manager name or empty string

        Example:
            Language.Rust.get_package_manager()  # -> "cargo"
        """
        match self:
            Language.Simple: "spm"
            Language.Rust: "cargo"
            Language.Python: "pip"
            Language.JavaScript: "npm"
            Language.TypeScript: "npm"
            Language.Go: "go"
            Language.C: ""
            Language.Cpp: ""

    pub fn summary(self) -> text:
        """Get summary of language.

        Returns:
            Human-readable summary

        Example:
            Language.Rust.summary()
            # -> "Language: Rust (compiled, static typing, cargo)"
        """
        val name = self.to_string()
        val compilation = if self.is_compiled():
            "compiled"
        else:
            "interpreted"
        val typing = if self.is_statically_typed():
            "static typing"
        else:
            "dynamic typing"
        val pm = self.get_package_manager()
        val pm_str = if pm.is_empty():
            ""
        else:
            ", {pm}"
        "Language: {name} ({compilation}, {typing}{pm_str})"

# Project configuration
pub class ProjectConfig:
    pub name: text
    pub version: text
    pub root: text
    pub languages: List<LanguageConfig>
    pub build_dir: text
    pub test_dir: text
    pub deploy_dir: text

    pub fn new(root: text) -> ProjectConfig:
        """Create default project configuration.

        Args:
            root: Project root directory

        Returns:
            Default configuration
        """
        ProjectConfig {
            name: "unnamed",
            version: "0.1.0",
            root: root,
            languages: [],
            build_dir: "target",
            test_dir: "tests",
            deploy_dir: "dist"
        }

    pub fn load_from_file(path: text) -> Result<ProjectConfig, text>:
        """Load project config from simple.sdn.

        Args:
            path: Path to simple.sdn file

        Returns:
            Loaded configuration or error

        Example simple.sdn format:
            name: my-project
            version: 1.0.0

            languages:
              - language: Simple
                root: .
                source_dirs: [src, lib]

              - language: Rust
                root: ./backend
                source_dirs: [src]
                exclude_patterns: [target]

            build_dir: target
            test_dir: tests
            deploy_dir: dist
        """
        # Try to read the file
        match fs.read_text_sync(path as FilePath):
            Ok(content):
                # Parse SDN
                match SdnDocument.parse(content):
                    Ok(doc):
                        # Extract configuration from SDN document
                        val config = self.parse_sdn_config(doc, path)
                        Ok(config)
                    Err(err):
                        Err("Failed to parse SDN config: " + err.to_string())
            Err(_):
                # File doesn't exist, return default
                val config = ProjectConfig.new(".")
                Ok(config)

    fn parse_sdn_config(doc: SdnDocument, path: text) -> ProjectConfig:
        """Parse SDN document into project configuration.

        Args:
            doc: Parsed SDN document
            path: Original file path for root extraction

        Returns:
            Project configuration
        """
        val root_path = self.get_parent_dir_static(path)
        var config = ProjectConfig.new(root_path)

        # Extract name
        match doc.get("name"):
            some(SdnValue.text(name)):
                config.name = name
            _:
                pass

        # Extract version
        match doc.get("version"):
            some(SdnValue.text(version)):
                config.version = version
            _:
                pass

        # Extract build_dir
        match doc.get("build_dir"):
            some(SdnValue.text(dir)):
                config.build_dir = dir
            _:
                pass

        # Extract test_dir
        match doc.get("test_dir"):
            some(SdnValue.text(dir)):
                config.test_dir = dir
            _:
                pass

        # Extract deploy_dir
        match doc.get("deploy_dir"):
            some(SdnValue.text(dir)):
                config.deploy_dir = dir
            _:
                pass

        # Extract language configurations
        match doc.get("languages"):
            some(SdnValue.Array(langs)):
                for lang_val in langs:
                    match self.parse_language_config(lang_val):
                        some(lang_config):
                            config.languages.append(lang_config)
                        none:
                            pass
            _:
                pass

        config

    fn parse_language_config(value: SdnValue) -> Option<LanguageConfig>:
        """Parse language configuration from SDN value.

        Args:
            value: SDN value representing language config

        Returns:
            Language configuration if valid
        """
        match value:
            SdnValue.Dict(dict):
                # Get language type
                val lang_type = match dict.get("language"):
                    some(SdnValue.text(lang_str)):
                        self.parse_language_string(lang_str)
                    _:
                        return none

                # Get root path
                val root = match dict.get("root"):
                    some(SdnValue.text(r)):
                        r
                    _:
                        "."

                # Create config
                var config = LanguageConfig.new(lang_type, root)

                # Get source directories
                match dict.get("source_dirs"):
                    some(SdnValue.Array(dirs)):
                        config.source_dirs = []
                        for dir_val in dirs:
                            match dir_val:
                                SdnValue.text(dir):
                                    config.source_dirs.append(dir)
                                _:
                                    pass
                    _:
                        pass

                # Get exclude patterns
                match dict.get("exclude_patterns"):
                    some(SdnValue.Array(patterns)):
                        config.exclude_patterns = []
                        for pat_val in patterns:
                            match pat_val:
                                SdnValue.text(pat):
                                    config.exclude_patterns.append(pat)
                                _:
                                    pass
                    _:
                        pass

                # Get compiler flags
                match dict.get("compiler_flags"):
                    some(SdnValue.Array(flags)):
                        config.compiler_flags = []
                        for flag_val in flags:
                            match flag_val:
                                SdnValue.text(flag):
                                    config.compiler_flags.append(flag)
                                _:
                                    pass
                    _:
                        pass

                # Get test command
                match dict.get("test_command"):
                    some(SdnValue.text(cmd)):
                        config.test_command = cmd
                    _:
                        pass

                some(config)
            _:
                none

    fn parse_language_string(lang_str: text) -> Language:
        """Parse language string to Language enum.

        Args:
            lang_str: Language name

        Returns:
            Language enum value
        """
        match lang_str:
            "Simple": Language.Simple
            "Rust": Language.Rust
            "Python": Language.Python
            "JavaScript": Language.JavaScript
            "TypeScript": Language.TypeScript
            "Go": Language.Go
            "C": Language.C
            "Cpp": Language.Cpp
            "C++": Language.Cpp
            _: Language.Simple  # Default

    fn get_parent_dir_static(path: text) -> text:
        """Get parent directory from path (static method).

        Args:
            path: File path

        Returns:
            Parent directory
        """
        val last_slash = path.rfind("/")
        if last_slash >= 0:
            path[0:last_slash]
        else:
            "."

    pub fn add_language(self, lang_config: LanguageConfig):
        """Add language configuration.

        Args:
            lang_config: Language configuration to add
        """
        self.languages.append(lang_config)

    pub fn get_language_config(self, language: Language) -> Option<LanguageConfig>:
        """Get configuration for specific language.

        Args:
            language: Language to get config for

        Returns:
            Language config if found
        """
        for config in self.languages:
            if config.language == language:
                return some(config)
        none

    pub fn has_language(self, language: Language) -> bool:
        """Check if project uses specific language.

        Args:
            language: Language to check

        Returns:
            True if language is configured
        """
        for config in self.languages:
            if config.language == language:
                return true
        false

    pub fn language_count(self) -> i32:
        """Get number of configured languages.

        Returns:
            Language count
        """
        self.languages.len()

    pub fn is_multi_language(self) -> bool:
        """Check if project uses multiple languages.

        Returns:
            True if 2+ languages
        """
        self.languages.len() >= 2

    pub fn summary(self) -> text:
        """Get project summary.

        Returns:
            Human-readable summary

        Example:
            config.summary()
            # -> "my-project v1.0.0 (3 languages: Simple, Rust, Python)"
        """
        val lang_names: List<text> = []
        for config in self.languages:
            lang_names.append(config.language.to_string())

        "{self.name} v{self.version} ({self.language_count()} languages: {lang_names.join(', ')})"

# Language-specific configuration
pub class LanguageConfig:
    pub language: Language
    pub root: text
    pub source_dirs: List<text>
    pub exclude_patterns: List<text>
    pub compiler_flags: List<text>
    pub test_command: text

    pub fn new(language: Language, root: text) -> LanguageConfig:
        """Create language configuration.

        Args:
            language: Language type
            root: Language root directory

        Returns:
            Default language configuration
        """
        LanguageConfig {
            language: language,
            root: root,
            source_dirs: ["src"],
            exclude_patterns: ["target", "node_modules", "__pycache__", ".git"],
            compiler_flags: [],
            test_command: ""
        }

    pub fn has_compiler_flags(self) -> bool:
        """Check if compiler flags are set.

        Returns:
            True if custom flags exist
        """
        self.compiler_flags.len() > 0

    pub fn has_test_command(self) -> bool:
        """Check if test command is set.

        Returns:
            True if test command exists
        """
        self.test_command != ""

    pub fn summary(self) -> text:
        """Get language config summary.

        Returns:
            Human-readable summary

        Example:
            config.summary()
            # -> "Rust at ./backend (src dirs: src, lib)"
        """
        "{self.language.to_string()} at {self.root} (src dirs: {self.source_dirs.join(', ')})"

# ProjectDetector is in project_detector.spl
