# Dependency Fetching and Caching
# File parsing, tracker analysis, and statistics

use tooling.core.project.{Language, ProjectContext}
use core.result.{Result, Ok, Err}
use tooling.core.dependency.{DependencyGraph, DependencyNode, DependencyType, Dependency}


fn find_files_with_extension(root: text, ext: text) -> List<text>:
    """Find all files with given extension recursively.

    Args:
        root: Root directory
        ext: File extension (e.g., ".spl")

    Returns:
        List of file paths
    """
    @extern("runtime", "rt_dir_list")
    fn _rt_dir_list(path_ptr: &u8, path_len: u64) -> Any

    @extern("runtime", "rt_file_stat")
    fn _rt_file_stat(
        path_ptr: &u8,
        path_len: u64,
        out_exists: &mut bool,
        out_is_file: &mut bool,
        out_is_dir: &mut bool,
        out_is_readable: &mut bool,
        out_is_writable: &mut bool,
        out_size: &mut i64
    )

    var results: List<text> = []

    val entries = _rt_dir_list(root.ptr(), root.len())
    if entries.is_nil():
        return results

    # Cast to list of strings
    val entry_list = entries as List<text>
    for entry in entry_list:
        val full_path = root + "/" + entry

        var exists = false
        var is_file = false
        var is_dir = false
        var is_readable = false
        var is_writable = false
        var size: i64 = 0

        _rt_file_stat(
            full_path.ptr(), full_path.len(),
            &mut exists, &mut is_file, &mut is_dir,
            &mut is_readable, &mut is_writable, &mut size
        )

        if is_file and full_path.ends_with(ext):
            results.append(full_path)
        elif is_dir and not entry.starts_with("."):
            # Recurse into subdirectory
            val sub_files = find_files_with_extension(full_path, ext)
            for f in sub_files:
                results.append(f)

    results


fn parse_simple_imports(file_path: text) -> List<text>:
    """Parse Simple language import statements.

    Args:
        file_path: Path to .spl file

    Returns:
        List of imported module paths
    """
    @extern("runtime", "rt_file_read_text")
    fn _rt_file_read_text(path_ptr: &u8, path_len: u64) -> text

    val content = _rt_file_read_text(file_path.ptr(), file_path.len())
    var imports: List<text> = []

    val lines = content.split("\n")
    for line in lines:
        val trimmed = line.trim()
        # Match: import module.path
        if trimmed.starts_with("import "):
            val module = trimmed.substring(7, trimmed.len()).trim()
            # Remove 'as alias' if present
            val as_pos = module.find(" as ")
            val clean_module = if as_pos >= 0:
                module.substring(0, as_pos)
            else:
                module
            imports.append(clean_module)
        # Match: from module import ...
        elif trimmed.starts_with("from "):
            val rest = trimmed.substring(5, trimmed.len()).trim()
            val import_pos = rest.find(" import ")
            if import_pos >= 0:
                val module = rest.substring(0, import_pos).trim()
                imports.append(module)

    imports


fn parse_rust_imports(file_path: text) -> List<text>:
    """Parse Rust use statements.

    Args:
        file_path: Path to .rs file

    Returns:
        List of imported crate/module paths
    """
    @extern("runtime", "rt_file_read_text")
    fn _rt_file_read_text(path_ptr: &u8, path_len: u64) -> text

    val content = _rt_file_read_text(file_path.ptr(), file_path.len())
    var imports: List<text> = []

    val lines = content.split("\n")
    for line in lines:
        val trimmed = line.trim()
        # Match: use crate.path;
        if trimmed.starts_with("use "):
            var path = trimmed.substring(4, trimmed.len()).trim()
            # Remove trailing semicolon
            if path.ends_with(";"):
                path = path.substring(0, path.len() - 1)
            # Remove braces for grouped imports
            val brace_pos = path.find("{")
            if brace_pos >= 0:
                path = path.substring(0, brace_pos)
            imports.append(path)
        # Match: mod module;
        elif trimmed.starts_with("mod ") and trimmed.ends_with(";"):
            val module = trimmed.substring(4, trimmed.len() - 1).trim()
            imports.append(module)

    imports


fn parse_python_imports(file_path: text) -> List<text>:
    """Parse Python import statements.

    Args:
        file_path: Path to .py file

    Returns:
        List of imported modules
    """
    @extern("runtime", "rt_file_read_text")
    fn _rt_file_read_text(path_ptr: &u8, path_len: u64) -> text

    val content = _rt_file_read_text(file_path.ptr(), file_path.len())
    var imports: List<text> = []

    val lines = content.split("\n")
    for line in lines:
        val trimmed = line.trim()
        # Match: import module
        if trimmed.starts_with("import "):
            val rest = trimmed.substring(7, trimmed.len()).trim()
            # Handle "import a, b, c"
            val parts = rest.split(",")
            for part in parts:
                var module = part.trim()
                # Remove "as alias"
                val as_pos = module.find(" as ")
                if as_pos >= 0:
                    module = module.substring(0, as_pos)
                imports.append(module)
        # Match: from module import ...
        elif trimmed.starts_with("from "):
            val rest = trimmed.substring(5, trimmed.len()).trim()
            val import_pos = rest.find(" import ")
            if import_pos >= 0:
                val module = rest.substring(0, import_pos).trim()
                imports.append(module)

    imports


fn parse_js_imports(file_path: text) -> List<text>:
    """Parse JavaScript/TypeScript import statements.

    Args:
        file_path: Path to .js/.ts file

    Returns:
        List of imported modules
    """
    @extern("runtime", "rt_file_read_text")
    fn _rt_file_read_text(path_ptr: &u8, path_len: u64) -> text

    val content = _rt_file_read_text(file_path.ptr(), file_path.len())
    var imports: List<text> = []

    val lines = content.split("\n")
    for line in lines:
        val trimmed = line.trim()
        # Match: import ... from "module"
        if trimmed.starts_with("import "):
            val from_pos = trimmed.find(" from ")
            if from_pos >= 0:
                var module = trimmed.substring(from_pos + 6, trimmed.len()).trim()
                # Remove quotes and semicolon
                module = module.replace("\"", "").replace("'", "").replace(";", "")
                imports.append(module)
        # Match: const x = require("module")
        val require_pos = trimmed.find("require(")
        if require_pos >= 0:
            var start = require_pos + 8
            val close = trimmed.find(")", start)
            if close > start:
                var module = trimmed.substring(start, close).trim()
                module = module.replace("\"", "").replace("'", "")
                imports.append(module)

    imports


# Dependency tracker - builds and analyzes dependency graph
pub class DependencyTracker:
    pub root: text
    pub graph: DependencyGraph
    pub verbose: bool

    pub fn new(root: text) -> DependencyTracker:
        """Create dependency tracker.

        Args:
            root: Project root directory

        Returns:
            Tracker with empty graph

        Example:
            val tracker = DependencyTracker.new(".")
            tracker.analyze_all_languages()

            val deps = tracker.get_dependencies("app.spl")
            print("Dependencies: {deps}")
        """
        DependencyTracker {
            root: root,
            graph: DependencyGraph.new(),
            verbose: false
        }

    pub fn set_verbose(self, enabled: bool):
        """Enable verbose logging.

        Args:
            enabled: True for detailed logs
        """
        self.verbose = enabled

    pub fn is_verbose(self) -> bool:
        """Check if verbose logging is enabled.

        Returns:
            True if verbose mode is on
        """
        self.verbose

    pub fn with_verbose(self, enabled: bool) -> DependencyTracker:
        """Set verbose logging (fluent API).

        Args:
            enabled: Verbose flag

        Returns:
            Self for chaining

        Example:
            val tracker = DependencyTracker.new(".").with_verbose(true)
        """
        self.verbose = enabled
        self

    pub fn has_graph(self) -> bool:
        """Check if tracker has built dependency graph.

        Returns:
            True if graph has nodes
        """
        self.graph.has_nodes()

    pub fn get_node_count(self) -> i32:
        """Get number of nodes in graph.

        Returns:
            Node count
        """
        self.graph.node_count()

    pub fn get_edge_count(self) -> i32:
        """Get number of edges in graph.

        Returns:
            Edge count
        """
        self.graph.edge_count()

    pub fn summary(self) -> text:
        """Get tracker summary.

        Returns:
            Human-readable summary

        Example:
            tracker.summary()
            # → "DependencyTracker: . (50 files, 120 dependencies, verbose: true)"
        """
        val verbose_str = if self.verbose: "true" else: "false"
        "DependencyTracker: {self.root} ({self.get_node_count()} files, {self.get_edge_count()} dependencies, verbose: {verbose_str})"

    pub fn analyze_all_languages(self):
        """Analyze dependencies for all languages in project.

        Builds complete dependency graph by parsing all source files.
        """
        if self.verbose:
            print("Analyzing dependencies...")

        # Find and analyze all source files by language
        val extensions = [
            (".spl", Language.Simple),
            (".rs", Language.Rust),
            (".py", Language.Python),
            (".js", Language.JavaScript),
            (".ts", Language.TypeScript)
        ]

        for (ext, lang) in extensions:
            val files = find_files_with_extension(self.root, ext)
            for file in files:
                self.analyze_file(file, lang)

        if self.verbose:
            print("Found {self.get_node_count()} files with {self.get_edge_count()} dependencies")

    pub fn analyze_file(self, file: text, language: Language):
        """Analyze dependencies for single file.

        Args:
            file: File to analyze
            language: Source language
        """
        # Add node
        self.graph.add_node(file, language)

        # Parse file and extract dependencies using language-specific patterns
        val deps = self.extract_dependencies(file, language)

        for dep in deps:
            self.graph.add_node(dep, language)
            self.graph.add_edge(file, dep, DependencyType.Import)

    fn extract_dependencies(self, file: text, language: Language) -> List<text>:
        """Extract dependencies from source file.

        Args:
            file: File to parse
            language: Source language

        Returns:
            List of dependency files
        """
        @extern("runtime", "rt_file_read_text")
        fn _rt_file_read_text(path_ptr: &u8, path_len: u64) -> text

        val content = _rt_file_read_text(file.ptr(), file.len())
        var deps: List<text> = []

        # Use regex-like pattern matching for import statements
        match language:
            Language.Simple:
                # Pattern: import module.submodule
                for line in content.lines():
                    val trimmed = line.trim()
                    if trimmed.starts_with("import "):
                        val module = trimmed.substring(7, trimmed.len()).trim()
                        deps.append(module.replace(".", "/") + ".spl")
            Language.Rust:
                # Pattern: use crate.module; or mod module;
                for line in content.lines():
                    val trimmed = line.trim()
                    if trimmed.starts_with("use ") or trimmed.starts_with("mod "):
                        val parts = trimmed.split(" ")
                        if parts.len() >= 2:
                            val module = parts[1].replace(";", "").replace(".", "/")
                            deps.append(module + ".rs")
            Language.Python:
                # Pattern: import module or from module import ...
                for line in content.lines():
                    val trimmed = line.trim()
                    if trimmed.starts_with("import "):
                        val module = trimmed.substring(7, trimmed.len()).split(" ")[0]
                        deps.append(module.replace(".", "/") + ".py")
                    elif trimmed.starts_with("from "):
                        val parts = trimmed.split(" ")
                        if parts.len() >= 2:
                            val module = parts[1]
                            deps.append(module.replace(".", "/") + ".py")
            Language.TypeScript:
                # Pattern: import ... from "module"
                for line in content.lines():
                    val trimmed = line.trim()
                    if trimmed.starts_with("import "):
                        # Find quoted module path
                        val quote_start = trimmed.index_of("\"").unwrap_or(trimmed.index_of("'").unwrap_or(-1))
                        if quote_start >= 0:
                            val after_quote = trimmed.substring(quote_start + 1, trimmed.len())
                            val quote_end = after_quote.index_of("\"").unwrap_or(after_quote.index_of("'").unwrap_or(-1))
                            if quote_end >= 0:
                                val module = after_quote.substring(0, quote_end)
                                deps.append(module + ".ts")
            _:
                # Unsupported language - return empty
                pass

        deps

    pub fn get_dependencies(self, file: text) -> List<text>:
        """Get dependencies of file.

        Args:
            file: File path

        Returns:
            Direct dependencies
        """
        self.graph.get_dependencies(file)

    pub fn get_reverse_dependencies(self, file: text) -> List<text>:
        """Get reverse dependencies of file.

        Args:
            file: File path

        Returns:
            Files that depend on this file
        """
        self.graph.get_reverse_dependencies(file)

    pub fn detect_cycles(self) -> List<List<text>>:
        """Detect circular dependencies.

        Returns:
            List of dependency cycles
        """
        self.graph.detect_cycles()

    pub fn visualize(self) -> text:
        """Generate DOT graph visualization.

        Returns:
            DOT format graph

        Example:
            val dot = tracker.visualize()
            # Save to file for rendering with Graphviz
        """
        var output = "digraph dependencies {\n"

        for edge in self.graph.edges:
            output += "  \"{edge.source}\" -> \"{edge.target}\";\n"

        output += "}\n"
        output

# Dependency graph statistics
pub class DependencyStatistics:
    pub total_nodes: i32
    pub total_edges: i32
    pub avg_dependencies_per_node: f64
    pub max_dependencies: i32
    pub most_dependent_file: text

    pub fn new() -> DependencyStatistics:
        """Create dependency statistics."""
        DependencyStatistics {
            total_nodes: 0,
            total_edges: 0,
            avg_dependencies_per_node: 0.0,
            max_dependencies: 0,
            most_dependent_file: ""
        }

    pub fn summary(self) -> text:
        """Get statistics summary.

        Returns:
            Human-readable summary

        Example:
            print(stats.summary())
            # → "50 files, 120 dependencies, avg 2.4 deps/file"
        """
        "{self.total_nodes} files, {self.total_edges} dependencies, avg {self.avg_dependencies_per_node:.1f} deps/file"

    pub fn has_data(self) -> bool:
        """Check if statistics have data.

        Returns:
            True if nodes exist
        """
        self.total_nodes > 0

    pub fn is_complex(self) -> bool:
        """Check if dependency graph is complex.

        Returns:
            True if avg dependencies per node > 3.0

        Example:
            if stats.is_complex():
                print("Warning: complex dependency structure")
        """
        self.avg_dependencies_per_node > 3.0

    pub fn has_hotspots(self) -> bool:
        """Check if there are dependency hotspots.

        Returns:
            True if max dependencies > 10
        """
        self.max_dependencies > 10
