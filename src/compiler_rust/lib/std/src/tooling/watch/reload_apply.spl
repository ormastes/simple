# Hot Reload Application
# Module reloading, hot reload analysis, and watch/reload integration

use core.result.{Result, Ok, Err}
use tooling.watch.reload.{ReloadStrategy, ReloadEvent, HMRServer}

# Module reloader - handles actual module reloading
pub class ModuleReloader:
    pub loaded_modules: Dict<text, i64>  # module -> mtime
    pub verbose: bool

    pub fn new() -> ModuleReloader:
        """Create module reloader.

        Returns:
            Module reloader
        """
        ModuleReloader {
            loaded_modules: {},
            verbose: false
        }

    pub fn set_verbose(self, enabled: bool):
        """Enable verbose logging.

        Args:
            enabled: True for detailed logs
        """
        self.verbose = enabled

    pub fn is_verbose(self) -> bool:
        """Check if verbose."""
        self.verbose

    pub fn with_verbose(self, enabled: bool) -> ModuleReloader:
        """Set verbose (fluent API)."""
        self.verbose = enabled
        self

    pub fn has_loaded_modules(self) -> bool:
        """Check if has loaded modules."""
        self.get_loaded_count() > 0

    pub fn get_loaded_count(self) -> i32:
        """Get number of loaded modules.

        Returns:
            Count of loaded modules
        """
        self.loaded_modules.len()

    pub fn is_loaded(self, module_path: text) -> bool:
        """Check if module is currently loaded.

        Args:
            module_path: Module to check

        Returns:
            True if loaded
        """
        self.loaded_modules.contains_key(module_path)

    pub fn clear_cache(self):
        """Clear loaded module cache.

        Forces full reload on next request.
        """
        self.loaded_modules = {}

    pub fn summary(self) -> text:
        """Get reloader summary."""
        val verbose_str = if self.verbose: "true" else: "false"
        "ModuleReloader: {self.get_loaded_count()} loaded modules (verbose: {verbose_str})"

    pub fn reload_module(self, module_path: text) -> Result<(), text>:
        """Reload a module from disk.

        Args:
            module_path: Path to module file

        Returns:
            Ok if successful, Err with error message

        Example:
            val reloader = ModuleReloader.new()

            match reloader.reload_module("lib.spl"):
                Ok(_):
                    print("Module reloaded successfully")
                Err(err):
                    print("Reload failed: {err}")
        """
        if self.verbose:
            print("Reloading module: {module_path}")

        # Module reloading steps:
        # 1. Unload old module
        # 2. Re-compile module
        # 3. Load new module
        # 4. Update function pointers

        # Check if file exists
        @extern("runtime", "rt_file_exists")
        fn _rt_file_exists(path_ptr: &u8, path_len: u64) -> bool

        if not _rt_file_exists(module_path.ptr(), module_path.len()):
            return Err("Module file not found: {module_path}")

        # Step 1: Unload old module if loaded
        if self.loaded_modules.contains_key(module_path):
            if self.verbose:
                print("Unloading old version of {module_path}")
            self.unload_module(module_path)

        # Step 2: Re-compile the module
        if self.verbose:
            print("Compiling {module_path}")

        match self.compile_module(module_path):
            Ok(compiled_path) ->
                # Step 3: Load the new module
                if self.verbose:
                    print("Loading compiled module from {compiled_path}")

                match self.load_compiled_module(compiled_path, module_path):
                    Ok(module_handle) ->
                        # Step 4: Register the loaded module
                        self.loaded_modules[module_path] = module_handle

                        if self.verbose:
                            print("Module {module_path} reloaded successfully")

                        Ok(())
                    Err(load_err) ->
                        Err("Failed to load module: {load_err}")
            Err(compile_err) ->
                Err("Failed to compile module: {compile_err}")

    fn unload_module(self, module_path: text):
        """Unload a previously loaded module."""
        @extern("runtime", "rt_module_unload")
        fn _rt_module_unload(handle: i64)

        if self.loaded_modules.contains_key(module_path):
            val handle = self.loaded_modules[module_path]
            _rt_module_unload(handle)
            self.loaded_modules.remove(module_path)

    fn compile_module(self, module_path: text) -> Result<text, text>:
        """Compile a module file to bytecode/native."""
        import shell

        # Use the Simple compiler
        val output_path = module_path.replace(".spl", ".smf")
        val result = shell.run("simple", ["compile", module_path, "-o", output_path])

        if result.exit_code == 0:
            Ok(output_path)
        else:
            Err(result.stderr)

    fn load_compiled_module(self, compiled_path: text, module_path: text) -> Result<i64, text>:
        """Load a compiled module into the runtime."""
        @extern("runtime", "rt_module_load")
        fn _rt_module_load(path_ptr: &u8, path_len: u64) -> i64

        val handle = _rt_module_load(compiled_path.ptr(), compiled_path.len())

        if handle > 0:
            Ok(handle)
        else:
            Err("Runtime failed to load module")

    pub fn reload_modules(self, modules: List<text>) -> Result<(), text>:
        """Reload multiple modules.

        Args:
            modules: Module paths to reload

        Returns:
            Ok if all successful
        """
        for module in modules:
            match self.reload_module(module):
                Ok(_):
                    pass
                Err(err):
                    return Err("Failed to reload {module}: {err}")

        Ok(())

    pub fn can_hot_reload(self, module_path: text) -> bool:
        """Check if module can be hot-reloaded.

        Args:
            module_path: Module to check

        Returns:
            True if hot-reloadable

        Not all code can be safely hot-reloaded:
        - Pure functions: Safe
        - Stateful code: Requires state preservation
        - Type definitions: May require full restart
        """
        val analysis = self.analyze_hot_reload_safety(module_path)
        analysis.is_safe

    pub fn analyze_hot_reload_safety(self, module_path: text) -> HotReloadAnalysis:
        """Analyze module for hot-reload safety.

        Args:
            module_path: Module to analyze

        Returns:
            Analysis result with safety info and warnings

        Checks for:
        - Global mutable state (unsafe)
        - Type definitions that may change layout (unsafe)
        - Pure functions (safe)
        - Side effects (needs care)
        """
        @extern("runtime", "rt_file_read")
        fn _rt_file_read(path_ptr: &u8, path_len: u64) -> text

        val analysis = HotReloadAnalysis.new(module_path)

        val content = _rt_file_read(module_path.ptr(), module_path.len())
        if content.is_empty():
            analysis.is_safe = false
            analysis.warnings.append("Could not read module file")
            return analysis

        # Check for global mutable state
        if self.has_global_mutable_state(content):
            analysis.is_safe = false
            analysis.has_global_state = true
            analysis.warnings.append("Module has global mutable state - hot reload may lose state")

        # Check for type definitions (struct, class, enum changes)
        if self.has_type_definitions(content):
            analysis.has_type_definitions = true
            analysis.warnings.append("Module defines types - layout changes require full restart")

        # Check for FFI declarations (external dependencies)
        if self.has_ffi_declarations(content):
            analysis.has_ffi = true
            analysis.warnings.append("Module uses FFI - external library state may not be preserved")

        # Check for initialization code
        if self.has_init_code(content):
            analysis.has_init_code = true
            analysis.warnings.append("Module has initialization code - will re-run on reload")

        # Safe if no blocking issues found
        if not analysis.has_global_state:
            analysis.is_safe = true

        analysis

    fn has_global_mutable_state(content: text) -> bool:
        """Check if module has global mutable variables."""
        # Look for: var name = ... at module level (not indented)
        for line in content.lines():
            val trimmed = line.trim()
            # Global var declarations (not indented, not in function)
            if trimmed.starts_with("var ") and not line.starts_with(" ") and not line.starts_with("\t"):
                return true
            # Also check for: pub var
            if trimmed.starts_with("pub var "):
                return true
        false

    fn has_type_definitions(content: text) -> bool:
        """Check if module defines types."""
        for line in content.lines():
            val trimmed = line.trim()
            if trimmed.starts_with("class ") or trimmed.starts_with("pub class "):
                return true
            if trimmed.starts_with("struct ") or trimmed.starts_with("pub struct "):
                return true
            if trimmed.starts_with("enum ") or trimmed.starts_with("pub enum "):
                return true
        false

    fn has_ffi_declarations(content: text) -> bool:
        """Check if module uses FFI."""
        for line in content.lines():
            val trimmed = line.trim()
            if trimmed.starts_with("@extern(") or trimmed.contains("extern fn"):
                return true
        false

    fn has_init_code(content: text) -> bool:
        """Check if module has top-level initialization code."""
        # Look for function calls at module level (not in function bodies)
        var in_function = false
        var brace_depth = 0

        for line in content.lines():
            val trimmed = line.trim()

            # Track function/class bodies (including static, async, me variants)
            if (trimmed.starts_with("fn ") or trimmed.starts_with("pub fn ") or
                trimmed.starts_with("static fn ") or trimmed.starts_with("pub static fn ") or
                trimmed.starts_with("async fn ") or trimmed.starts_with("pub async fn ") or
                trimmed.starts_with("me ") or trimmed.starts_with("pub me ") or
                trimmed.starts_with("class ") or trimmed.starts_with("pub class ")):
                in_function = true

            # Track brace depth
            for ch in trimmed.chars():
                if ch == '{':
                    brace_depth += 1
                elif ch == '}':
                    brace_depth -= 1
                    if brace_depth <= 0:
                        in_function = false
                        brace_depth = 0

            # Check for function calls at module level
            if not in_function and brace_depth == 0:
                # Look for function calls: name(...)
                # Exclude function definitions (with various modifiers) and comments
                if (trimmed.contains("(") and
                    not trimmed.starts_with("fn ") and not trimmed.starts_with("pub fn ") and
                    not trimmed.starts_with("static fn ") and not trimmed.starts_with("pub static fn ") and
                    not trimmed.starts_with("async fn ") and not trimmed.starts_with("pub async fn ") and
                    not trimmed.starts_with("me ") and not trimmed.starts_with("pub me ") and
                    not trimmed.starts_with("#")):
                    return true

        false

# Hot reload safety analysis result
pub class HotReloadAnalysis:
    pub module_path: text
    pub is_safe: bool
    pub has_global_state: bool
    pub has_type_definitions: bool
    pub has_ffi: bool
    pub has_init_code: bool
    pub warnings: List<text>

    pub fn new(module_path: text) -> HotReloadAnalysis:
        """Create hot reload analysis."""
        HotReloadAnalysis {
            module_path: module_path,
            is_safe: true,
            has_global_state: false,
            has_type_definitions: false,
            has_ffi: false,
            has_init_code: false,
            warnings: []
        }

    pub fn summary(self) -> text:
        """Get analysis summary."""
        val status = if self.is_safe: "safe" else: "unsafe"
        var details: List<text> = []

        if self.has_global_state:
            details.append("global state")
        if self.has_type_definitions:
            details.append("type definitions")
        if self.has_ffi:
            details.append("FFI")
        if self.has_init_code:
            details.append("init code")

        val detail_str = if details.len() > 0: " ({details.join(', ')})" else: ""
        "Hot reload {status} for {self.module_path}{detail_str}"

    pub fn has_warnings(self) -> bool:
        """Check if analysis has warnings."""
        self.warnings.len() > 0

    pub fn print_warnings(self):
        """Print all warnings."""
        for warning in self.warnings:
            print("Warning: {warning}")

# Watch mode integration - combines watching + reloading
pub class WatchReloadIntegration:
    pub watcher: Watcher
    pub reloader: ModuleReloader
    pub hmr_server: Option<HMRServer>
    pub auto_reload: bool

    pub fn new(root: text) -> WatchReloadIntegration:
        """Create integrated watch + reload system.

        Args:
            root: Project root

        Returns:
            Integrated system

        Example:
            val watch_reload = WatchReloadIntegration.new(".")
            watch_reload.set_auto_reload(true)
            watch_reload.start_hmr_server(3000)

            watch_reload.start()  # Watch + auto-reload
        """
        WatchReloadIntegration {
            watcher: Watcher.new(root),
            reloader: ModuleReloader.new(),
            hmr_server: none,
            auto_reload: false
        }

    pub fn set_auto_reload(self, enabled: bool):
        """Enable automatic module reloading.

        Args:
            enabled: True to auto-reload on file changes
        """
        self.auto_reload = enabled

    pub fn start_hmr_server(self, port: i32):
        """Start HMR server for client notifications.

        Args:
            port: Server port
        """
        val server = HMRServer.new(port)
        server.start()
        self.hmr_server = some(server)

    pub fn start(self):
        """Start watching and reloading.

        Blocks until stopped.
        """
        # Set up watch callback
        self.watcher.on_change(fn(files):
            print("Files changed: {files.len()}")

            if self.auto_reload:
                # Reload modules
                match self.reloader.reload_modules(files):
                    Ok(_):
                        print("✓ Modules reloaded successfully")

                        # Notify HMR clients
                        match self.hmr_server:
                            some(server):
                                server.notify_reload(files)
                            none:
                                pass
                    Err(err):
                        print("✗ Reload failed: {err}")
        )

        # Start watching
        self.watcher.start()

    pub fn stop(self):
        """Stop watching and reloading."""
        self.watcher.stop()

        match self.hmr_server:
            some(server):
                server.stop()
            none:
                pass

    pub fn is_auto_reload_enabled(self) -> bool:
        """Check if auto-reload enabled."""
        self.auto_reload

    pub fn has_hmr_server(self) -> bool:
        """Check if HMR server is configured."""
        match self.hmr_server:
            some(_): true
            none: false

    pub fn is_running(self) -> bool:
        """Check if watching is active."""
        self.watcher.is_running()

    pub fn summary(self) -> text:
        """Get integration summary."""
        val auto_str = if self.auto_reload: "enabled" else: "disabled"
        val hmr_str = if self.has_hmr_server(): "yes" else: "no"
        "WatchReloadIntegration: auto-reload {auto_str}, HMR server: {hmr_str}, {self.reloader.get_loaded_count()} loaded modules"
