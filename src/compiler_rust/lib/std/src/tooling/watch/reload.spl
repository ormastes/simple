# Hot Module Replacement (HMR)
# Reload code without restarting application

use core.result.{Result, Ok, Err}

# Reload strategy
pub enum ReloadStrategy:
    Full        # Full application restart
    Incremental # Reload only changed modules
    HotSwap     # Hot-swap functions without restart

    pub fn to_string(self) -> text:
        """Convert reload strategy to string.

        Returns:
            Strategy name

        Example:
            ReloadStrategy.HotSwap.to_string()  # → "hot-swap"
        """
        match self:
            ReloadStrategy.Full: "full"
            ReloadStrategy.Incremental: "incremental"
            ReloadStrategy.HotSwap: "hot-swap"

    pub fn description(self) -> text:
        """Get strategy description.

        Returns:
            Human-readable description

        Example:
            ReloadStrategy.HotSwap.description()
            # → "Hot-swap functions without application restart"
        """
        match self:
            ReloadStrategy.Full:
                "Full application restart with state loss"
            ReloadStrategy.Incremental:
                "Reload only changed modules, preserve app state"
            ReloadStrategy.HotSwap:
                "Hot-swap functions without application restart"

    pub fn preserves_state(self) -> bool:
        """Check if strategy preserves application state.

        Returns:
            True if state is preserved

        Example:
            ReloadStrategy.Full.preserves_state()  # → false
            ReloadStrategy.HotSwap.preserves_state()  # → true
        """
        match self:
            ReloadStrategy.Full: false
            ReloadStrategy.Incremental: true
            ReloadStrategy.HotSwap: true

    pub fn is_full(self) -> bool:
        """Check if full restart."""
        match self:
            ReloadStrategy.Full: true
            _: false

    pub fn is_incremental(self) -> bool:
        """Check if incremental."""
        match self:
            ReloadStrategy.Incremental: true
            _: false

    pub fn is_hot_swap(self) -> bool:
        """Check if hot-swap."""
        match self:
            ReloadStrategy.HotSwap: true
            _: false

# Reload event
pub class ReloadEvent:
    pub modules: List<text>
    pub timestamp: i64
    pub strategy: ReloadStrategy

    pub fn new(modules: List<text>, strategy: ReloadStrategy) -> ReloadEvent:
        """Create reload event.

        Args:
            modules: Modules to reload
            strategy: Reload strategy

        Returns:
            Reload event
        """
        @extern("runtime", "rt_time_now_unix_micros")
        fn _rt_time_now_unix_micros() -> i64

        ReloadEvent {
            modules: modules,
            timestamp: _rt_time_now_unix_micros() / 1000,  # Convert microseconds to milliseconds
            strategy: strategy
        }

    pub fn module_count(self) -> i32:
        """Get number of modules to reload.

        Returns:
            Module count
        """
        self.modules.len()

    pub fn contains_module(self, module: text) -> bool:
        """Check if event contains specific module.

        Args:
            module: Module path to check

        Returns:
            True if module is in list
        """
        for m in self.modules:
            if m == module:
                return true
        false

    pub fn summary(self) -> text:
        """Get event summary.

        Returns:
            Human-readable summary

        Example:
            event.summary()
            # → "Reloading 3 modules (incremental)"
        """
        "Reloading {self.module_count()} modules ({self.strategy.to_string()})"

    pub fn is_single_module(self) -> bool:
        """Check if single module reload."""
        self.module_count() == 1

    pub fn is_batch_reload(self) -> bool:
        """Check if batch reload."""
        self.module_count() > 1

# HMR client - receives reload notifications
pub class HMRClient:
    pub on_reload_callback: (ReloadEvent) -> ()
    pub connected: bool
    pub ws_connection_id: i64
    pub server_url: text

    pub fn new() -> HMRClient:
        """Create HMR client.

        Returns:
            Client ready to receive reload events

        Example:
            val client = HMRClient.new()

            client.on_reload(fn(event):
                print("Reloading modules: {event.modules}")
                # Reload application state
            )

            client.connect()
        """
        HMRClient {
            on_reload_callback: fn(event): pass,
            connected: false,
            ws_connection_id: 0,
            server_url: "localhost:3000"
        }

    pub fn set_server_url(self, url: text):
        """Set HMR server URL."""
        self.server_url = url

    pub fn on_reload(self, callback: (ReloadEvent) -> ()):
        """Set reload callback.

        Args:
            callback: Function to call on reload event
        """
        self.on_reload_callback = callback

    pub fn connect(self):
        """Connect to HMR server.

        Establishes connection for receiving reload events.
        Uses HTTP long-polling for simplicity (WebSocket requires more infrastructure).
        """
        @extern("runtime", "rt_http_get")
        fn _rt_http_get(url_ptr: &u8, url_len: u64) -> text

        # Try to connect to HMR server
        val url = "http://{self.server_url}/hmr/connect"
        val response = _rt_http_get(url.ptr(), url.len())

        if response.contains("connected"):
            self.connected = true
            # Start polling for events in background
            self.start_event_polling()
        else:
            self.connected = false

    fn start_event_polling(self):
        """Start background polling for HMR events."""
        import concurrency.threads.{rt_thread_spawn_isolated}

        # Spawn polling thread
        val poll_fn = || self.poll_events()
        rt_thread_spawn_isolated(poll_fn, ())

    fn poll_events(self):
        """Poll for HMR events in a loop."""
        @extern("runtime", "rt_http_get")
        fn _rt_http_get(url_ptr: &u8, url_len: u64) -> text

        @extern("runtime", "rt_thread_sleep")
        fn _rt_thread_sleep(ms: i64)

        while self.connected:
            val url = "http://{self.server_url}/hmr/events"
            val response = _rt_http_get(url.ptr(), url.len())

            if not response.is_empty() and response != "none":
                # Parse event and call callback
                val modules = parse_hmr_event(response)
                if self.on_reload_callback.is_some():
                    self.on_reload_callback.unwrap()(modules)

            # Poll every 100ms
            _rt_thread_sleep(100)

    pub fn disconnect(self):
        """Disconnect from HMR server."""
        self.connected = false

    pub fn is_connected(self) -> bool:
        """Check if client is connected.

        Returns:
            True if connected
        """
        self.connected

    pub fn summary(self) -> text:
        """Get client summary."""
        val status = if self.connected: "connected" else: "disconnected"
        "HMRClient: {status}"

# HMR server - sends reload notifications
pub class HMRServer:
    pub clients: List<HMRClient>
    pub running: bool
    pub port: i32

    pub fn new(port: i32) -> HMRServer:
        """Create HMR server.

        Args:
            port: Server port

        Returns:
            HMR server

        Example:
            val server = HMRServer.new(3000)
            server.start()

            # In watch callback:
            server.notify_reload(["app.spl", "lib.spl"])
        """
        HMRServer {
            clients: [],
            running: false,
            port: port
        }

    pub fn start(self):
        """Start HMR server.

        Listens for client connections using HTTP server.
        Uses HTTP long-polling for simplicity.
        """
        import concurrency.threads.{rt_thread_spawn_isolated}

        self.running = true

        # Start HTTP server in background thread
        val server_fn = || self.run_http_server()
        rt_thread_spawn_isolated(server_fn, ())

    fn run_http_server(self):
        """Run HTTP server for HMR events."""
        @extern("runtime", "rt_http_server_start")
        fn _rt_http_server_start(port: i32) -> i64

        @extern("runtime", "rt_http_server_accept")
        fn _rt_http_server_accept(handle: i64) -> i64

        @extern("runtime", "rt_http_request_path")
        fn _rt_http_request_path(conn: i64) -> text

        @extern("runtime", "rt_http_response_send")
        fn _rt_http_response_send(conn: i64, body_ptr: &u8, body_len: u64)

        val server_handle = _rt_http_server_start(self.port)
        if server_handle < 0:
            self.running = false
            return

        while self.running:
            val conn = _rt_http_server_accept(server_handle)
            if conn < 0:
                continue

            val path = _rt_http_request_path(conn)

            if path == "/hmr/connect":
                # Register client and respond
                _rt_http_response_send(conn, "connected".ptr(), 9)
            elif path == "/hmr/events":
                # Return pending events or "none"
                if self.pending_events.len() > 0:
                    val events = self.pending_events.join(",")
                    self.pending_events.clear()
                    _rt_http_response_send(conn, events.ptr(), events.len())
                else:
                    _rt_http_response_send(conn, "none".ptr(), 4)
            else:
                _rt_http_response_send(conn, "not found".ptr(), 9)

    pub fn stop(self):
        """Stop HMR server."""
        self.running = false

    pub fn client_count(self) -> i32:
        """Get number of connected clients.

        Returns:
            Client count
        """
        self.clients.len()

    pub fn is_running(self) -> bool:
        """Check if server is running.

        Returns:
            True if running
        """
        self.running

    pub fn has_clients(self) -> bool:
        """Check if has connected clients."""
        self.client_count() > 0

    pub fn summary(self) -> text:
        """Get server summary."""
        val status = if self.running: "running" else: "stopped"
        "HMRServer: port {self.port}, {self.client_count()} clients ({status})"

    pub fn notify_reload(self, modules: List<text>):
        """Notify all clients to reload modules.

        Args:
            modules: Modules that changed
        """
        val event = ReloadEvent.new(modules, ReloadStrategy.Incremental)

        for client in self.clients:
            self.send_reload_event(client, event)

    fn send_reload_event(client: HMRClient, event: ReloadEvent):
        """Send reload event to client.

        Args:
            client: HMR client
            event: Reload event

        Uses WebSocket if available, falls back to direct callback.
        """
        @extern("runtime", "rt_websocket_send")
        fn _rt_websocket_send(conn_id: i64, msg_ptr: &u8, msg_len: u64) -> bool

        # Build JSON message for WebSocket
        val json_msg = self.serialize_reload_event(event)

        # Try WebSocket first if client has connection
        if client.ws_connection_id > 0:
            val success = _rt_websocket_send(
                client.ws_connection_id,
                json_msg.ptr(),
                json_msg.len()
            )

            if not success:
                # WebSocket failed, fall back to direct callback
                client.on_reload_callback(event)
        else:
            # No WebSocket connection, use direct callback
            client.on_reload_callback(event)

    fn serialize_reload_event(event: ReloadEvent) -> text:
        """Serialize reload event to JSON for WebSocket transmission.

        Args:
            event: Reload event

        Returns:
            JSON string

        Format:
        {"type": "reload", "modules": ["mod1.spl", "mod2.spl"], "strategy": "incremental", "timestamp": 1234567890}
        """
        var modules_json = "["
        var first = true
        for module in event.modules:
            if not first:
                modules_json += ","
            modules_json += "\"{module}\""
            first = false
        modules_json += "]"

        "{\"type\":\"reload\",\"modules\":{modules_json},\"strategy\":\"{event.strategy.to_string()}\",\"timestamp\":{event.timestamp}}"


# ModuleReloader, HotReloadAnalysis, WatchReloadIntegration are in reload_apply.spl
