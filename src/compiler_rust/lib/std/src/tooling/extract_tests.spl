# Extract Tests from Spec - Extract testable code examples from markdown specs
# Migrated from: scripts/extract_tests_from_spec.py
# Purpose: Convert markdown specs to executable _spec.spl test files

use core.regex

# Metadata extracted from markdown file
struct SpecMetadata:
    title: text
    status: text
    feature_ids: text

impl SpecMetadata:
    # Create empty metadata
    static fn new() -> SpecMetadata:
        SpecMetadata(
            title: "",
            status: "Reference",
            feature_ids: ""
        )

    # Create with values
    static fn with_values(title: text, status: text, feature_ids: text) -> SpecMetadata:
        SpecMetadata(
            title: title,
            status: status,
            feature_ids: feature_ids
        )

# A code example extracted from markdown
struct CodeExample:
    section: text          # Section name where example appears
    context: text          # Descriptive context before the code
    code: text             # The actual code
    line_number: u64       # Approximate line in source file

impl CodeExample:
    # Create a new code example
    static fn new(section: text, context: text, code: text, line_number: u64) -> CodeExample:
        CodeExample(section, context, code, line_number)

# Extraction result
struct ExtractionResult:
    success: bool
    examples_count: u64
    output_path: text
    error_message: text

impl ExtractionResult:
    # Create success result
    static fn success(count: u64, output: text) -> ExtractionResult:
        ExtractionResult(
            success: true,
            examples_count: count,
            output_path: output,
            error_message: ""
        )

    # Create failure result
    static fn error(message: text) -> ExtractionResult:
        ExtractionResult(
            success: false,
            examples_count: 0,
            output_path: "",
            error_message: message
        )

# Extract metadata from markdown content
fn extract_metadata(md_content: text) -> SpecMetadata:
    var title = ""
    var status = "Reference"
    var feature_ids = ""

    # Extract title from first level-1 heading
    val title_pattern = regex.compile("^# (.+)$")
    val title_matches = title_pattern.findall(md_content)
    if title_matches.len() > 0:
        val first_match = title_matches[0]
        title = first_match.matched_text()
        # Remove the '# ' prefix
        title = title.substring(2, title.len())

    # Extract status from **Status:** line
    val status_pattern = regex.compile("\\*\\*Status:\\*\\* (.+)")
    val status_match = status_pattern.search(md_content)
    if status_match!= nil:
        val m = status_match.unwrap()
        # Extract the captured group (after the colon and space)
        if m.group_count() > 0:
            val group_opt = m.group(0)
            if group_opt!= nil:
                status = group_opt.unwrap()

    # Extract feature IDs from **Feature IDs:** line
    val fids_pattern = regex.compile("\\*\\*Feature IDs:\\*\\* (.+)")
    val fids_match = fids_pattern.search(md_content)
    if fids_match!= nil:
        val m = fids_match.unwrap()
        if m.group_count() > 0:
            val group_opt = m.group(0)
            if group_opt!= nil:
                feature_ids = group_opt.unwrap()

    SpecMetadata.with_values(title, status, feature_ids)

# Extract code examples from markdown
fn extract_code_examples(md_content: text) -> List<CodeExample>:
    # Initialize with a dummy example to establish type
    val dummy = CodeExample.new("", "", "", 0)
    var examples = [dummy]
    examples = []

    # Split content into lines for line tracking
    val lines = md_content.split("\n")

    var current_section = "General"
    var line_num: u64 = 0
    var in_code_block = false
    var current_code = ""
    var current_context = ""
    var code_start_line: u64 = 0

    # Patterns
    val section_pattern = regex.compile("^## (.+)$")
    val code_fence_pattern = regex.compile("^```simple")
    val code_end_pattern = regex.compile("^```$")

    for line in lines:
        line_num = line_num + 1

        # Check for section headers
        val section_match = section_pattern.search(line)
        if section_match != nil:
            val m = section_match.unwrap()
            val section_text = m.matched_text()
            # Remove '## ' prefix
            current_section = section_text.substring(3, section_text.len())
            current_context = ""
            continue

        # Check for code block start
        if not in_code_block:
            val fence_match = code_fence_pattern.search(line)
            if fence_match != nil:
                in_code_block = true
                current_code = ""
                code_start_line = line_num + 1
                continue
            else:
                # Accumulate context (non-empty lines that aren't headers or fences)
                if not line.trim().is_empty() and not line.starts_with("#"):
                    if not current_context.is_empty():
                        current_context = current_context + " "
                    current_context = current_context + line.trim()
        else:
            # We're in a code block - check for end
            val end_match = code_end_pattern.search(line)
            if end_match != nil:
                # End of code block - create example
                in_code_block = false
                if not current_code.trim().is_empty():
                    val example = CodeExample.new(
                        current_section,
                        current_context,
                        current_code.trim(),
                        code_start_line
                    )
                    examples.append(example)
                current_code = ""
                current_context = ""
            else:
                # Accumulate code
                if not current_code.is_empty():
                    current_code = current_code + "\n"
                current_code = current_code + line

    examples

# Generate _spec.spl file content from examples
fn generate_spec_spl(
    source_filename: text,
    metadata: SpecMetadata,
    examples: List<CodeExample>
) -> text:
    var output = ""

    # Header with metadata
    output = output + "\"\"\"\n"
    output = output + "# {metadata.title} - Test Specification\n\n"
    output = output + "**Status:** {metadata.status}\n"

    if not metadata.feature_ids.is_empty():
        output = output + "**Feature IDs:** {metadata.feature_ids}\n"

    output = output + "**Source:** {source_filename}\n"
    output = output + "**Type:** Extracted Examples (Category B)\n\n"

    output = output + "## Overview\n\n"
    output = output + "This file contains executable test cases extracted from {source_filename}.\n"
    output = output + "The original specification file remains as architectural reference documentation.\n\n"

    output = output + "**Note:** This is a test extraction file. For complete specification text,\n"
    output = output + "design rationale, and architecture, see doc/spec/{source_filename}\n\n"

    output = output + "## Extracted Test Cases\n\n"
    output = output + "{examples.len()} test cases extracted covering:\n"
    output = output + "- Core functionality examples\n"
    output = output + "- Edge cases and validation\n"
    output = output + "- Integration patterns\n"
    output = output + "\"\"\"\n\n"

    # Generate test cases
    if examples.is_empty():
        # No examples found
        output = output + "# No testable code examples found\n\n"
        output = output + "test \"placeholder\":\n"
        output = output + "    \"\"\"\n"
        output = output + "    Placeholder test - add test cases as implementation progresses.\n"
        output = output + "    \"\"\"\n"
        output = output + "    assert_compiles()\n"
    else:
        var i = 0
        while i < examples.len():
            val example = examples[i]
            val test_num = i + 1

            # Test marker
            output = output + "## Test: {example.section} (Line ~{example.line_number})\n\n"

            # Add context if available
            if not example.context.is_empty() and example.context.len() > 20:
                val context_short = if example.context.len() > 100:
                    example.context.slice(0, 100) + "..."
                else:
                    example.context

                output = output + "\"\"\"\n"
                output = output + "{context_short}\n"
                output = output + "\"\"\"\n"

            # Check if code already has test structure
            if example.code.contains("test ") or example.code.starts_with("fn "):
                # Already structured, use as-is
                output = output + "{example.code}\n\n"
            else:
                # Wrap in test function
                val test_name = generate_test_name(example.section, test_num)
                output = output + "test \"{test_name}\":\n"

                # Indent code
                val indented = indent_code(example.code, 4)
                output = output + "{indented}\n"
                output = output + "    assert_compiles()\n\n"

            i = i + 1

    output

# Generate test name from section name
fn generate_test_name(section: text, num: u64) -> text:
    # Convert section to valid test name
    var name = section.lower()

    # Remove special characters
    name = name.replace("?", "")
    name = name.replace("!", "")
    name = name.replace(",", "")
    name = name.replace(".", "")
    name = name.replace("(", "")
    name = name.replace(")", "")

    # Replace spaces and dashes with underscores
    name = name.replace(" ", "_")
    name = name.replace("-", "_")

    # Add number
    "{name}_{num}"

# Indent code by n spaces
fn indent_code(code: text, spaces: u64) -> text:
    val lines = code.split("\n")
    var result = ""

    var i = 0
    while i < lines.len():
        val line = lines[i]

        # Add indentation if line is not empty
        if not line.trim().is_empty():
            var indent = ""
            var j: u64 = 0
            while j < spaces:
                indent = indent + " "
                j = j + 1
            result = result + indent + line
        else:
            # Keep empty lines empty
            result = result + ""

        # Add newline except for last line
        if i < lines.len() - 1:
            result = result + "\n"

        i = i + 1

    result

# Extract tests from markdown file to _spec.spl file
fn extract_tests(
    input_md: text,
    output_spl: text,
    dry_run: bool
) -> ExtractionResult:
    # Stub: Needs file I/O
    # Would:
    # 1. Read input markdown file
    # 2. Extract metadata and examples
    # 3. Generate _spec.spl content
    # 4. Write to output file (unless dry_run)
    ExtractionResult.error("file I/O not yet implemented")

# Extract tests from all Category B files
fn extract_all_category_b(
    base_dir: text,
    output_dir: text,
    dry_run: bool
) -> (u64, u64):
    # Stub: Needs file I/O and directory operations
    # Would process all files in CATEGORY_B_FILES list
    # Returns (success_count, total_count)
    (0, 0)

# Category B files mapping
fn get_category_b_files() -> List<(text, text)>:
    [
        ("functions.md", "functions_spec.spl"),
        ("traits.md", "traits_spec.spl"),
        ("memory.md", "memory_spec.spl"),
        ("modules.md", "modules_spec.spl"),
        ("data_structures.md", "data_structures_spec.spl"),
        ("concurrency.md", "concurrency_spec.spl"),
        ("macro.md", "macro_spec.spl"),
        ("metaprogramming.md", "metaprogramming_spec.spl")
    ]

# Extraction statistics
struct ExtractionStats:
    total_files: u64
    successful: u64
    failed: u64
    total_examples: u64

impl ExtractionStats:
    # Create empty stats
    static fn new() -> ExtractionStats:
        ExtractionStats(
            total_files: 0,
            successful: 0,
            failed: 0,
            total_examples: 0
        )

    # Record successful extraction
    me add_success(examples: u64):
        self.total_files = self.total_files + 1
        self.successful = self.successful + 1
        self.total_examples = self.total_examples + examples

    # Record failed extraction
    me add_failure():
        self.total_files = self.total_files + 1
        self.failed = self.failed + 1

    # Generate summary report
    fn summary() -> text:
        var report = ""
        report = report + "Extraction Statistics:\n"
        report = report + "  Total Files: {self.total_files}\n"
        report = report + "  Successful: {self.successful}\n"
        report = report + "  Failed: {self.failed}\n"
        report = report + "  Total Examples: {self.total_examples}\n"
        report

# CLI options for extract_tests command
struct ExtractTestsOptions:
    all_files: bool
    dry_run: bool
    verbose: bool
    input_md: Option<text>
    output_spl: Option<text>
    output_dir: Option<text>
    show_help: bool

impl ExtractTestsOptions:
    # Create default options
    static fn default() -> ExtractTestsOptions:
        ExtractTestsOptions(
            all_files: false,
            dry_run: false,
            verbose: false,
            input_md: None,
            output_spl: None,
            output_dir: None,
            show_help: false
        )

    # Parse CLI arguments
    static fn parse(args: List<text>) -> ExtractTestsOptions:
        var options = ExtractTestsOptions.default()
        var positional_count = 0
        var i = 0

        while i < args.len():
            val arg = args[i]

            if arg == "--all" or arg == "-a":
                options.all_files = true
            elif arg == "--dry-run" or arg == "-n":
                options.dry_run = true
            elif arg == "--verbose" or arg == "-v":
                options.verbose = true
            elif arg == "--output" and i + 1 < args.len():
                i = i + 1
                options.output_dir = Some(args[i])
            elif arg == "--help" or arg == "-h":
                options.show_help = true
            elif not arg.starts_with("-"):
                # Positional arguments: input_md and output_spl
                if positional_count == 0:
                    options.input_md = Some(arg)
                elif positional_count == 1:
                    options.output_spl = Some(arg)
                positional_count = positional_count + 1

            i = i + 1

        options

# Print usage help for extract_tests
fn print_extract_tests_help() -> text:
    var help = ""
    help = help + "Usage: simple extract-tests [OPTIONS] [INPUT_MD] [OUTPUT_SPL]\n\n"
    help = help + "Extract testable code examples from markdown specs into _spec.spl files.\n\n"
    help = help + "Arguments:\n"
    help = help + "  INPUT_MD         Input markdown specification file\n"
    help = help + "  OUTPUT_SPL       Output _spec.spl test file\n\n"
    help = help + "Options:\n"
    help = help + "  -a, --all        Extract from all Category B files\n"
    help = help + "  -n, --dry-run    Preview extraction without writing files\n"
    help = help + "  -v, --verbose    Show detailed extraction information\n"
    help = help + "  --output DIR     Output directory for extracted tests\n"
    help = help + "  -h, --help       Show this help message\n\n"
    help = help + "Examples:\n"
    help = help + "  simple extract-tests doc/spec/functions.md tests/specs/functions_spec.spl\n"
    help = help + "  simple extract-tests --all                  # Extract all Category B files\n"
    help = help + "  simple extract-tests --all --dry-run        # Preview all extractions\n"
    help

# Main entry point
fn main_extract_tests(args: List<text>) -> Result<(), text>:
    val options = ExtractTestsOptions.parse(args)

    # Show help if requested
    if options.show_help:
        print print_extract_tests_help()
        return Ok(())

    # Determine mode: all files or single file
    if options.all_files:
        # Extract from all Category B files
        print "Extracting tests from all Category B files..."
        if options.dry_run:
            print "=== Dry Run Mode - No files will be written ===\n"

        val base_dir = "doc/spec"
        val output_dir = match options.output_dir:
            Some(dir): dir
            None: "tests/specs"

        val (success_count, total_count) = extract_all_category_b(base_dir=base_dir, output_dir=output_dir, options.dry_run)

        print "\n=== Extraction Complete ==="
        print "Files processed: {total_count}"
        print "Successfully extracted: {success_count}"

        if options.verbose:
            print "\nCategory B files:"
            val files = get_category_b_files()
            var j = 0
            while j < files.len():
                val (md, spl) = files[j]
                print "  {md} -> {spl}"
                j = j + 1

        Ok(())
    else:
        # Single file extraction
        match (options.input_md, options.output_spl):
            (Some(input), Some(output)):
                print "Extracting tests from: {input}"
                print "Output file: {output}"

                if options.dry_run:
                    print "=== Dry Run Mode - No files will be written ===\n"

                val result = extract_tests(input_md=input, output_spl=output, options.dry_run)
                if result.success:
                    print "\n=== Extraction Complete ==="
                    print "Examples extracted: {result.examples_count}"
                    print "Output: {result.output_path}"
                    Ok(())
                else:
                    Err(result.error_message)
            _:
                Err("Missing required arguments. Use --all or provide INPUT_MD OUTPUT_SPL.\nRun with --help for usage information.")
