# Option and Result utility functions
# Functional programming helpers for error handling

# =====================================
# Option Utilities
# =====================================

# Map over an Option value
fn map_option<T, U>(opt: Option<T>, f: fn(T) -> U) -> Option<U>:
    match opt:
        Some(value) => Some(f(value))
        None => None

# Map over an Option with a function that returns Option
fn flat_map_option<T, U>(opt: Option<T>, f: fn(T) -> Option<U>) -> Option<U>:
    match opt:
        Some(value) => f(value)
        None => None

# Provide a default value if None
fn unwrap_or<T>(opt: Option<T>, default: T) -> T:
    match opt:
        Some(value) => value
        None => default

# Provide a computed default value if None
fn unwrap_or_else<T>(opt: Option<T>, default_fn: fn() -> T) -> T:
    match opt:
        Some(value) => value
        None => default_fn()

# Convert Option to Result with error message
fn ok_or<T, E>(opt: Option<T>, error: E) -> Result<T, E>:
    match opt:
        Some(value) => Ok(value)
        None => Err(error)

# Check if Option is Some
fn is_some<T>(opt: Option<T>) -> bool:
    match opt:
        Some(_) => true
        None => false

# Check if Option is None
fn is_none<T>(opt: Option<T>) -> bool:
    match opt:
        Some(_) => false
        None => true

# Filter Option by predicate
fn filter_option<T>(opt: Option<T>, predicate: fn(T) -> bool) -> Option<T>:
    match opt:
        Some(value) =>
            if predicate(value):
                Some(value)
            else:
                None
        None => None

# Zip two Options together
fn zip_option<A, B>(opt_a: Option<A>, opt_b: Option<B>) -> Option<(A, B)>:
    match opt_a:
        Some(a) =>
            match opt_b:
                Some(b) => Some((a, b))
                None => None
        None => None

# =====================================
# Result Utilities
# =====================================

# Map over a Result value
fn map_result<T, U, E>(result: Result<T, E>, f: fn(T) -> U) -> Result<U, E>:
    match result:
        Ok(value) => Ok(f(value))
        Err(e) => Err(e)

# Map over a Result error
fn map_err<T, E, F>(result: Result<T, E>, f: fn(E) -> F) -> Result<T, F>:
    match result:
        Ok(value) => Ok(value)
        Err(e) => Err(f(e))

# Map over a Result with a function that returns Result
fn flat_map_result<T, U, E>(result: Result<T, E>, f: fn(T) -> Result<U, E>) -> Result<U, E>:
    match result:
        Ok(value) => f(value)
        Err(e) => Err(e)

# Unwrap Result or provide default value
fn unwrap_or_result<T, E>(result: Result<T, E>, default: T) -> T:
    match result:
        Ok(value) => value
        Err(_) => default

# Unwrap Result or compute default value
fn unwrap_or_else_result<T, E>(result: Result<T, E>, default_fn: fn(E) -> T) -> T:
    match result:
        Ok(value) => value
        Err(e) => default_fn(e)

# Check if Result is Ok
fn is_ok<T, E>(result: Result<T, E>) -> bool:
    match result:
        Ok(_) => true
        Err(_) => false

# Check if Result is Err
fn is_err<T, E>(result: Result<T, E>) -> bool:
    match result:
        Ok(_) => false
        Err(_) => true

# Convert Result to Option (discarding error)
fn ok<T, E>(result: Result<T, E>) -> Option<T>:
    match result:
        Ok(value) => Some(value)
        Err(_) => None

# Convert Result to Option of error (discarding Ok)
fn err<T, E>(result: Result<T, E>) -> Option<E>:
    match result:
        Ok(_) => None
        Err(e) => Some(e)

# =====================================
# Collection Utilities for Option/Result
# =====================================

# Collect list of Options into Option of list
# Returns None if any element is None
fn sequence_options<T>(list: List<Option<T>>) -> Option<List<T>>:
    var result = []

    for opt in list:
        match opt:
            Some(value) => result.push(value)
            None => return None

    Some(result)

# Collect list of Results into Result of list
# Returns first Err if any element is Err
fn sequence_results<T, E>(list: List<Result<T, E>>) -> Result<List<T>, E>:
    var result = []

    for res in list:
        match res:
            Ok(value) => result.push(value)
            Err(e) => return Err(e)

    Ok(result)

# Filter out None values from list of Options
fn flatten_options<T>(list: List<Option<T>>) -> List<T>:
    var result = []

    for opt in list:
        match opt:
            Some(value) => result.push(value)
            None => {}

    result

# Partition list of Results into successes and failures
fn partition_results<T, E>(list: List<Result<T, E>>) -> (List<T>, List<E>):
    var successes = []
    var failures = []

    for res in list:
        match res:
            Ok(value) => successes.push(value)
            Err(e) => failures.push(e)

    (successes, failures)

# =====================================
# Combinators
# =====================================

# Try multiple operations until one succeeds
fn first_ok<T, E>(operations: List<fn() -> Result<T, E>>) -> Result<T, List<E>>:
    var errors = []

    for op in operations:
        match op():
            Ok(value) => return Ok(value)
            Err(e) => errors.push(e)

    Err(errors)

# Execute all operations and collect results
fn all_ok<T, E>(operations: List<fn() -> Result<T, E>>) -> Result<List<T>, E>:
    var results = []

    for op in operations:
        match op():
            Ok(value) => results.push(value)
            Err(e) => return Err(e)

    Ok(results)

# Try an operation, return default if it fails
fn try_or<T, E>(operation: fn() -> Result<T, E>, default: T) -> T:
    match operation():
        Ok(value) => value
        Err(_) => default

# Chain two operations, passing result from first to second
fn chain<T, U, E>(first: fn() -> Result<T, E>, second: fn(T) -> Result<U, E>) -> Result<U, E>:
    match first():
        Ok(value) => second(value)
        Err(e) => Err(e)

# Transpose Result<Option<T>, E> to Option<Result<T, E>>
fn transpose_result_option<T, E>(result: Result<Option<T>, E>) -> Option<Result<T, E>>:
    match result:
        Ok(opt) =>
            match opt:
                Some(value) => Some(Ok(value))
                None => None
        Err(e) => Some(Err(e))

# Transpose Option<Result<T, E>> to Result<Option<T>, E>
fn transpose_option_result<T, E>(opt: Option<Result<T, E>>) -> Result<Option<T>, E>:
    match opt:
        Some(result) =>
            match result:
                Ok(value) => Ok(Some(value))
                Err(e) => Err(e)
        None => Ok(None)

# Convert Result to Option, discarding error
fn result_to_option<T, E>(result: Result<T, E>) -> Option<T>:
    match result:
        Ok(value) => Some(value)
        Err(_) => None

# Flatten nested Result
fn flatten_result<T, E>(result: Result<Result<T, E>, E>) -> Result<T, E>:
    match result:
        Ok(inner_result) => inner_result
        Err(e) => Err(e)

# Apply function to both Ok and Err values
fn bimap<T, U, E, F>(result: Result<T, E>, ok_fn: fn(T) -> U, err_fn: fn(E) -> F) -> Result<U, F>:
    match result:
        Ok(value) => Ok(ok_fn(value))
        Err(e) => Err(err_fn(e))

# Recover from error by transforming it to Ok
fn recover<T, E>(result: Result<T, E>, recovery_fn: fn(E) -> T) -> Result<T, E>:
    match result:
        Ok(value) => Ok(value)
        Err(e) => Ok(recovery_fn(e))

# Combine two Results with a function
fn combine_results<T, U, V, E>(
    result1: Result<T, E>,
    result2: Result<U, E>,
    combine_fn: fn(T, U) -> V
) -> Result<V, E>:
    match result1:
        Ok(val1) =>
            match result2:
                Ok(val2) => Ok(combine_fn(val1, val2))
                Err(e) => Err(e)
        Err(e) => Err(e)

# Combine three Results with a function
fn combine_results3<T, U, V, W, E>(
    result1: Result<T, E>,
    result2: Result<U, E>,
    result3: Result<V, E>,
    combine_fn: fn(T, U, V) -> W
) -> Result<W, E>:
    match result1:
        Ok(val1) =>
            match result2:
                Ok(val2) =>
                    match result3:
                        Ok(val3) => Ok(combine_fn(val1, val2, val3))
                        Err(e) => Err(e)
                Err(e) => Err(e)
        Err(e) => Err(e)

# Inspect Ok value without consuming
fn inspect_ok<T, E>(result: Result<T, E>, inspector: fn(T)):
    match result:
        Ok(value) => inspector(value)
        Err(_) => pass

# Inspect Err value without consuming
fn inspect_err<T, E>(result: Result<T, E>, inspector: fn(E)):
    match result:
        Ok(_) => pass
        Err(e) => inspector(e)
