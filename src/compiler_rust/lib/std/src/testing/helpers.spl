# Test Helper Utilities
# Common utilities for writing tests more easily

# ============================================================================
# Assertion Helpers
# ============================================================================

pub fn assert_eq<T>(actual: T, expected: T, message: text):
    """Assert that two values are equal.

    Args:
        actual: Actual value
        expected: Expected value
        message: Error message if not equal

    Example:
        assert_eq(result, 42, "Result should be 42")
    """
    if actual != expected:
        panic("{message}: expected {expected}, got {actual}")

pub fn assert_ne<T>(actual: T, unexpected: T, message: text):
    """Assert that two values are not equal.

    Args:
        actual: Actual value
        unexpected: Value that should not match
        message: Error message if equal

    Example:
        assert_ne(result, 0, "Result should not be zero")
    """
    if actual == unexpected:
        panic("{message}: expected not {unexpected}, but got {actual}")

pub fn assert_true(condition: bool, message: text):
    """Assert that condition is true.

    Args:
        condition: Boolean condition
        message: Error message if false

    Example:
        assert_true(user.is_active(), "User should be active")
    """
    if not condition:
        panic("{message}: expected true, got false")

pub fn assert_false(condition: bool, message: text):
    """Assert that condition is false.

    Args:
        condition: Boolean condition
        message: Error message if true

    Example:
        assert_false(user.is_deleted(), "User should not be deleted")
    """
    if condition:
        panic("{message}: expected false, got true")

pub fn assert_some<T>(option: Option<T>, message: text) -> T:
    """Assert that Option is Some and return value.

    Args:
        option: Option to check
        message: Error message if None

    Returns:
        The unwrapped value

    Example:
        val user = assert_some(find_user("id123"), "User should exist")
    """
    match option:
        Some(v): v
        nil: panic("{message}: expected Some, got nil")

pub fn assert_none<T>(option: Option<T>, message: text):
    """Assert that Option is None.

    Args:
        option: Option to check
        message: Error message if Some

    Example:
        assert_none(find_user("invalid"), "User should not exist")
    """
    match option:
        Some(v): panic("{message}: expected nil, got Some({v})")
        nil: pass

pub fn assert_contains<T>(collection: List<T>, item: T, message: text):
    """Assert list contains item.

    Args:
        collection: List to check
        item: Item to find
        message: Error message if not found

    Example:
        assert_contains(users, "Alice", "Should contain Alice")
    """
    if not collection.contains(item):
        panic("{message}: {item} not found in collection")

pub fn assert_not_contains<T>(collection: List<T>, item: T, message: text):
    """Assert list does not contain item.

    Args:
        collection: List to check
        item: Item that should not exist
        message: Error message if found

    Example:
        assert_not_contains(blocked_users, "Alice", "Should not be blocked")
    """
    if collection.contains(item):
        panic("{message}: {item} should not be in collection")

pub fn assert_empty<T>(collection: List<T>, message: text):
    """Assert collection is empty.

    Args:
        collection: List to check
        message: Error message if not empty

    Example:
        assert_empty(errors, "Should have no errors")
    """
    if collection.len() > 0:
        panic("{message}: expected empty, got {collection.len()} items")

pub fn assert_len<T>(collection: List<T>, expected_len: i32, message: text):
    """Assert collection has specific length.

    Args:
        collection: List to check
        expected_len: Expected length
        message: Error message if wrong length

    Example:
        assert_len(results, 5, "Should have 5 results")
    """
    val actual_len = collection.len()
    if actual_len != expected_len:
        panic("{message}: expected length {expected_len}, got {actual_len}")

# ============================================================================
# Result Assertions
# ============================================================================

pub fn assert_ok<T, E>(result: Result<T, E>, message: text) -> T:
    """Assert that Result is Ok and return value.

    Args:
        result: Result to check
        message: Error message if Err

    Returns:
        The unwrapped Ok value

    Example:
        val data = assert_ok(parse_json(input), "Should parse successfully")
    """
    match result:
        Ok(v): v
        Err(e): panic("{message}: expected Ok, got Err({e})")

pub fn assert_err<T, E>(result: Result<T, E>, message: text) -> E:
    """Assert that Result is Err and return error.

    Args:
        result: Result to check
        message: Error message if Ok

    Returns:
        The unwrapped Err value

    Example:
        val error = assert_err(parse_invalid(), "Should fail to parse")
    """
    match result:
        Ok(v): panic("{message}: expected Err, got Ok({v})")
        Err(e): e

# ============================================================================
# Timing Helpers
# ============================================================================

use time

pub fn measure_time<T>(action: fn() -> T) -> (T, i64):
    """Measure execution time of an action.

    Args:
        action: Function to execute and measure

    Returns:
        Tuple of (result, elapsed_microseconds)

    Example:
        val (result, elapsed) = measure_time(\: expensive_operation())
        print "Took {elapsed}μs"
    """
    val start = time.now_micros()
    val result = action()
    val elapsed = time.now_micros() - start
    (result, elapsed)

pub fn assert_fast<T>(action: fn() -> T, max_micros: i64, message: text) -> T:
    """Assert that an action completes within time limit.

    Args:
        action: Function to execute
        max_micros: Maximum allowed time in microseconds
        message: Error message if too slow

    Returns:
        The action result

    Example:
        val result = assert_fast(\: quick_lookup(), 1000, "Should be under 1ms")
    """
    val (result, elapsed) = measure_time(action)
    if elapsed > max_micros:
        panic("{message}: took {elapsed}μs, limit was {max_micros}μs")
    result

pub fn with_timeout<T>(action: fn() -> T, timeout_seconds: f64, message: text) -> T:
    """Execute action with a timeout (soft check - measures after completion).

    Args:
        action: Function to execute
        timeout_seconds: Timeout in seconds
        message: Error message if timeout exceeded

    Returns:
        The action result

    Note: This is a soft timeout - it measures after completion.
          For hard timeouts, use async/concurrent primitives.

    Example:
        val result = with_timeout(\: fetch_data(), 5.0, "Should complete within 5s")
    """
    val max_micros = (timeout_seconds * 1000000.0) as i64
    val (result, elapsed) = measure_time(action)
    if elapsed > max_micros:
        val elapsed_sec = (elapsed as f64) / 1000000.0
        panic("{message}: took {elapsed_sec}s, timeout was {timeout_seconds}s")
    result

# ============================================================================
# Fixture Helpers
# ============================================================================

pub fn with_cleanup<T, R>(setup: fn() -> T, teardown: fn(T), test: fn(T) -> R) -> R:
    """Run test with setup and guaranteed teardown.

    Args:
        setup: Function that creates the fixture
        teardown: Function that cleans up the fixture (always runs)
        test: Test function that receives the fixture

    Returns:
        The test result

    Example:
        with_cleanup(
            \: create_temp_file(),
            \f: delete_file(f),
            \f: test_file_operations(f)
        )
    """
    val fixture = setup()
    val result = test(fixture)
    teardown(fixture)
    result

# ============================================================================
# Call Verification Helpers
# ============================================================================

# Note: For creating test doubles, use `testing.mocking.create_mock()` directly.
# These helpers work with any object that has the call tracking interface.

pub fn assert_called(mock_fn, expected_count: i32):
    """Assert mock was called expected number of times.

    Args:
        mock_fn: The mock function to check (must have call_count() method)
        expected_count: Expected number of calls

    Example:
        assert_called(save_mock, 3)
    """
    val actual = mock_fn.call_count()
    if actual != expected_count:
        panic("Expected {expected_count} calls, got {actual}")

pub fn assert_called_with(mock_fn, expected_args: List<text>):
    """Assert mock was called with specific arguments (checks last call).

    Args:
        mock_fn: The mock function to check (must have get_last_call() method)
        expected_args: Expected arguments

    Example:
        assert_called_with(save_mock, ["user123", "data"])
    """
    val last_call = mock_fn.get_last_call()
    match last_call:
        Some(call):
            if call.args != expected_args:
                panic("Expected call with {expected_args}, got {call.args}")
        nil:
            panic("Expected call with {expected_args}, but mock was never called")

pub fn assert_not_called(mock_fn):
    """Assert mock was never called.

    Args:
        mock_fn: The mock function to check (must have call_count() method)

    Example:
        assert_not_called(error_handler_mock)
    """
    val count = mock_fn.call_count()
    if count > 0:
        panic("Expected no calls, but mock was called {count} times")

# ============================================================================
# Export
# ============================================================================

export assert_eq
export assert_ne
export assert_true
export assert_false
export assert_some
export assert_none
export assert_contains
export assert_not_contains
export assert_empty
export assert_len
export assert_ok
export assert_err
export measure_time
export assert_fast
export with_timeout
export with_cleanup
export assert_called
export assert_called_with
export assert_not_called
