# MCP Error Handler and Crash Prevention
# Provides error isolation, recovery, and defensive programming utilities

use std.nogc_async_mut.mcp.core.logger.*
use std.nogc_async_mut.mcp.core.protocol.*

# Error categories
pub enum ErrorCategory:
    Transport       # Network/IO errors
    Protocol        # JSON-RPC protocol errors
    Validation      # Input validation errors
    Resource        # Resource access errors
    Tool            # Tool execution errors
    Internal        # Internal server errors
    Timeout         # Operation timeout
    RateLimit       # Rate limiting

impl ErrorCategory:
    pub fn to_string() -> text:
        match self:
            case ErrorCategory.Transport: "Transport"
            case ErrorCategory.Protocol: "Protocol"
            case ErrorCategory.Validation: "Validation"
            case ErrorCategory.Resource: "Resource"
            case ErrorCategory.Tool: "Tool"
            case ErrorCategory.Internal: "Internal"
            case ErrorCategory.Timeout: "Timeout"
            case ErrorCategory.RateLimit: "RateLimit"

# Structured error type
pub class McpError:
    pub category: ErrorCategory
    pub message: text
    pub code: i64
    pub details: Dict<text, text>
    pub recoverable: bool

    static fn new(category: ErrorCategory, message: text, code: i64) -> McpError:
        return McpError(
            category: category,
            message: message,
            code: code,
            details: {},
            recoverable: true
        )

    pub fn with_details(details: Dict<text, text>) -> McpError:
        var err = self
        err.details = details
        err

    pub fn unrecoverable() -> McpError:
        var err = self
        err.recoverable = false
        err

    pub fn to_json_rpc_error() -> ErrorObject:
        ErrorObject.new(self.code, "{self.category.to_string()}: {self.message}")

# Error codes (following JSON-RPC 2.0 spec)
pub val ERROR_PARSE: i64 = -32700
pub val ERROR_INVALID_REQUEST: i64 = -32600
pub val ERROR_METHOD_NOT_FOUND: i64 = -32601
pub val ERROR_INVALID_PARAMS: i64 = -32602
pub val ERROR_INTERNAL: i64 = -32603
pub val ERROR_TIMEOUT: i64 = -32000
pub val ERROR_RATE_LIMIT: i64 = -32001
pub val ERROR_VALIDATION: i64 = -32002

# Input validation limits (prevent DoS)
pub class ValidationLimits:
    pub max_content_length: i64      # Max request size (default 10MB)
    pub max_string_length: i64       # Max string field length (default 1MB)
    pub max_array_size: i64          # Max array length (default 10000)
    pub max_dict_size: i64           # Max dict entries (default 1000)
    pub max_json_depth: i64          # Max JSON nesting (default 32)
    pub max_uri_length: i64          # Max URI length (default 2048)
    pub max_tool_name_length: i64    # Max tool name length (default 256)

    static fn default() -> ValidationLimits:
        return ValidationLimits(
            max_content_length: 10_000_000,    # 10MB
            max_string_length: 1_000_000,      # 1MB
            max_array_size: 10_000,
            max_dict_size: 1_000,
            max_json_depth: 32,
            max_uri_length: 2_048,
            max_tool_name_length: 256
        )

    static fn strict() -> ValidationLimits:
        return ValidationLimits(
            max_content_length: 1_000_000,     # 1MB
            max_string_length: 100_000,        # 100KB
            max_array_size: 1_000,
            max_dict_size: 100,
            max_json_depth: 16,
            max_uri_length: 1_024,
            max_tool_name_length: 128
        )

# Input validator
pub class InputValidator:
    pub limits: ValidationLimits

    static fn new(limits: ValidationLimits) -> InputValidator:
        return InputValidator(limits: limits)

    static fn default() -> InputValidator:
        InputValidator.new(ValidationLimits.default())

    # Validate content length
    pub fn validate_content_length(length: i64) -> Result<(), McpError>:
        if length < 0:
            return Err(McpError.new(
                ErrorCategory.Validation,
                "Negative content length: {length}",
                -32002
            ))

        if length > self.limits.max_content_length:
            return Err(McpError.new(
                ErrorCategory.Validation,
                "Content length {length} exceeds limit {self.limits.max_content_length}",
                -32002
            ))

        Ok(())

    # Validate string length
    pub fn validate_string(value: text, field_name: text) -> Result<(), McpError>:
        if value.len() > self.limits.max_string_length:
            return Err(McpError.new(
                ErrorCategory.Validation,
                "Field '{field_name}' length {value.len()} exceeds limit {self.limits.max_string_length}",
                -32002
            ))
        Ok(())

    # Validate URI
    pub fn validate_uri(uri: text) -> Result<(), McpError>:
        if uri == "":
            return Err(McpError.new(
                ErrorCategory.Validation,
                "Empty URI",
                -32002
            ))

        if uri.len() > self.limits.max_uri_length:
            return Err(McpError.new(
                ErrorCategory.Validation,
                "URI length {uri.len()} exceeds limit {self.limits.max_uri_length}",
                -32002
            ))

        # Basic URI format validation
        if not (uri.starts_with("file://") or uri.starts_with("symbol://") or uri.starts_with("project://") or uri.starts_with("http://") or uri.starts_with("https://")):
            return Err(McpError.new(
                ErrorCategory.Validation,
                "Invalid URI scheme: {uri}",
                -32002
            ))

        Ok(())

    # Validate tool name
    pub fn validate_tool_name(name: text) -> Result<(), McpError>:
        if name == "":
            return Err(McpError.new(
                ErrorCategory.Validation,
                "Empty tool name",
                -32002
            ))

        if name.len() > self.limits.max_tool_name_length:
            return Err(McpError.new(
                ErrorCategory.Validation,
                "Tool name length {name.len()} exceeds limit",
                -32002
            ))

        # Tool names should be alphanumeric with underscores/hyphens/slashes
        for ch in name:
            if not (ch.is_alphanumeric() or ch == "_" or ch == "-" or ch == "/"):
                return Err(McpError.new(
                    ErrorCategory.Validation,
                    "Invalid character in tool name: {ch}",
                    -32002
                ))

        Ok(())

    # Validate array size
    pub fn validate_array_size(size: i64, field_name: text) -> Result<(), McpError>:
        if size < 0:
            return Err(McpError.new(
                ErrorCategory.Validation,
                "Negative array size for '{field_name}'",
                -32002
            ))

        if size > self.limits.max_array_size:
            return Err(McpError.new(
                ErrorCategory.Validation,
                "Array '{field_name}' size {size} exceeds limit {self.limits.max_array_size}",
                -32002
            ))

        Ok(())

    # Validate dict size
    pub fn validate_dict_size(size: i64, field_name: text) -> Result<(), McpError>:
        if size < 0:
            return Err(McpError.new(
                ErrorCategory.Validation,
                "Negative dict size for '{field_name}'",
                -32002
            ))

        if size > self.limits.max_dict_size:
            return Err(McpError.new(
                ErrorCategory.Validation,
                "Dict '{field_name}' size {size} exceeds limit {self.limits.max_dict_size}",
                -32002
            ))

        Ok(())

# Crash recovery wrapper
pub class CrashRecovery:
    pub max_consecutive_errors: i64
    pub consecutive_errors: i64
    pub total_errors: i64
    pub enabled: bool

    static fn new() -> CrashRecovery:
        return CrashRecovery(
            max_consecutive_errors: 5,
            consecutive_errors: 0,
            total_errors: 0,
            enabled: true
        )

    pub me disable():
        self.enabled = false

    pub me reset():
        self.consecutive_errors = 0

    # Check if we should stop due to too many errors
    pub fn should_stop() -> bool:
        self.consecutive_errors >= self.max_consecutive_errors

    # Record error
    pub me record_error(error: McpError):
        self.consecutive_errors = self.consecutive_errors + 1
        self.total_errors = self.total_errors + 1

        log_error_ctx("MCP error occurred",
            {
                "category": error.category.to_string(),
                "message": error.message,
                "consecutive": self.consecutive_errors.to_string(),
                "total": self.total_errors.to_string()
            })

        if self.should_stop():
            log_fatal("Too many consecutive errors, stopping MCP server")

    # Record success (resets consecutive counter)
    pub me record_success():
        if self.consecutive_errors > 0:
            log_debug("Resetting consecutive error counter")
            self.consecutive_errors = 0

    # Wrap operation with error recovery
    pub me safe_call<T>(operation: fn() -> Result<T, McpError>, operation_name: text) -> Result<T, McpError>:
        if not self.enabled:
            return operation()

        log_debug("Executing: {operation_name}")

        val result = operation()
        match result:
            case Ok(value):
                self.record_success()
                return Ok(value)
            case Err(error):
                self.record_error(error)

                # Log detailed error
                log_error_ctx("Operation failed: {operation_name}",
                    {
                        "category": error.category.to_string(),
                        "message": error.message,
                        "code": error.code.to_string(),
                        "recoverable": error.recoverable.to_string()
                    })

                # If unrecoverable or too many errors, propagate
                if not error.recoverable or self.should_stop():
                    return Err(error)

                # Otherwise return error but server continues
                return Err(error)

# Safe wrappers for common operations
pub fn safe_parse_json(json_str: text, validator: InputValidator) -> Result<JsonValue, McpError>:
    # Validate length first
    validator.validate_string(json_str, "json_body")?

    match json.parse(json_str):
        case Ok(value):
            Ok(value)
        case Err(e):
            Err(McpError.new(
                ErrorCategory.Protocol,
                "JSON parse error: {e}",
                -32700
            ))

pub fn safe_read_resource(provider: ResourceProvider, uri: text, validator: InputValidator) -> Result<ResourceContents, McpError>:
    # Validate URI
    validator.validate_uri(uri)?

    # Log the operation
    log_debug_ctx("Reading resource", {"uri": uri})

    # Read with error handling
    match provider.read_resource(uri):
        case Some(contents):
            Ok(contents)
        case None:
            Err(McpError.new(
                ErrorCategory.Resource,
                "Resource not found: {uri}",
                -32602
            ))

pub fn safe_execute_tool(handler: ToolHandler, arguments: Dict<text, Any>,
                         validator: InputValidator, recovery: CrashRecovery) -> Result<ToolResult, McpError>:
    # Validate tool name
    validator.validate_tool_name(handler.tool.name)?

    # Validate argument count
    validator.validate_dict_size(arguments.len(), "tool_arguments")?

    # Log execution
    log_info_ctx("Executing tool", {
        "tool": handler.tool.name,
        "arg_count": arguments.len().to_string()
    })

    # Execute with recovery
    val tool_name = handler.tool.name
    recovery.safe_call(
        \: Ok(handler.execute(arguments)),
        "tool:{tool_name}"
    )
