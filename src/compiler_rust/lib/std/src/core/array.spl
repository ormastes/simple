# Array<T, N> - Fixed-size array
# Syntax: [T; N] creates an Array
# Implements collection traits except Growable (fixed size)

use core.traits.*
use core.collections.*

# ============================================
# Array Type Definition
# ============================================

struct Array<T, const N: usize>:
    data: [T; N]

# ============================================
# Constructors
# ============================================

impl Array<T, N>:
    # Create with default values
    static fn new() -> Array<T, N> where T: Default:
        Array { data: [T.default(); N] }

    # Create from inline array
    fn of(items: [T; N]) -> Array<T, N>:
        Array { data: items }

    # Create filled with single value
    fn filled(value: T) -> Array<T, N> where T: Clone:
        var data: [T; N]
        for i in 0..N:
            data[i] = value.clone()
        Array { data: data }

    # Create filled with function
    fn filled_with(f: fn(usize) -> T) -> Array<T, N>:
        var data: [T; N]
        for i in 0..N:
            data[i] = f(i)
        Array { data: data }

    # Create zeroed (for numeric types)
    fn zeroed() -> Array<T, N> where T: Default:
        Array.new()

# ============================================
# Len trait
# ============================================

impl Len for Array<T, N>:
    fn len() -> usize:
        N

# ============================================
# Capacity trait (always full for fixed arrays)
# ============================================

impl Capacity for Array<T, N>:
    fn capacity() -> usize:
        N

    fn is_full() -> bool:
        true  # Fixed arrays are always "full"

# ============================================
# Iterable trait
# ============================================

impl Iterable<T> for Array<T, N>:
    type Iter = ArrayIter<T, N>

    fn iter() -> Self.Iter:
        ArrayIter { array: self, index: 0 }

    fn into_iter() -> Self.Iter:
        self.iter()

    fn each(f: fn(T)):
        for item in self.iter():
            f(item)

    fn each_with_index(f: fn(usize, T)):
        for (idx, item) in self.iter().enumerate():
            f(idx, item)

# ============================================
# Collection trait
# ============================================

impl Collection<T> for Array<T, N>:
    fn contains(item: &T) -> bool where T: Eq:
        for x in self.iter():
            if x == item: return true
        false

    fn count_matching(predicate: fn(&T) -> bool) -> usize:
        var count = 0
        for item in self.iter():
            if predicate(&item): count = count + 1
        count

# ============================================
# Sequence trait
# ============================================

impl Sequence<T> for Array<T, N>:
    fn get(idx: usize) -> Option<T>:
        if idx < N:
            Some(self.data[idx])
        else:
            nil

    fn get_slice(start: usize, end: usize) -> Slice<T>:
        if start > end or end > N:
            Slice.empty()
        else:
            danger:
                Slice.new(&self.data[start] as *T, end - start)

    fn first() -> Option<T>:
        self.get(0)

    fn last() -> Option<T>:
        if N > 0: self.get(N - 1) else: nil

    fn find(predicate: fn(&T) -> bool) -> Option<T>:
        for item in self.iter():
            if predicate(&item): return Some(item)
        nil

    fn find_index(predicate: fn(&T) -> bool) -> Option<usize>:
        for (idx, item) in self.iter().enumerate():
            if predicate(&item): return Some(idx)
        nil

    fn position(item: &T) -> Option<usize> where T: Eq:
        self.find_index(\x: x == item)

    fn get_slice_from(start: usize) -> Slice<T>:
        self.get_slice(start, N)

    fn get_slice_to(end: usize) -> Slice<T>:
        self.get_slice(0, end)

    fn enumerate() -> Enumerate<Self.Iter>:
        self.iter().enumerate()

    fn all(predicate: fn(&T) -> bool) -> bool:
        for item in self.iter():
            if not predicate(&item): return false
        true

    fn any(predicate: fn(&T) -> bool) -> bool:
        for item in self.iter():
            if predicate(&item): return true
        false

    fn fold<U>(self, init: U, f: fn(U, T) -> U) -> U:
        var acc = init
        for item in self.iter():
            acc = f(acc, item)
        acc

    fn sum() -> T where T: Add<Output=T> + Default:
        self.fold(T.default(), \acc, x: acc + x)

    fn product() -> T where T: Mul<Output=T> + Default:
        self.fold(T.default(), \acc, x: acc * x)

    fn max() -> Option<T> where T: Ord:
        if N == 0: return nil
        var max_val = self.get(0).unwrap()
        for item in self.iter():
            if item > max_val: max_val = item
        Some(max_val)

    fn min() -> Option<T> where T: Ord:
        if N == 0: return nil
        var min_val = self.get(0).unwrap()
        for item in self.iter():
            if item < min_val: min_val = item
        Some(min_val)

    fn mean() -> f32 where T: Add + Default:
        0.0

    fn variance() -> f32 where T: Add + Default:
        0.0

    fn sample_variance() -> f32 where T: Add + Default:
        0.0

    fn std() -> f32 where T: Add + Default:
        0.0

    fn sample_std() -> f32 where T: Add + Default:
        0.0

    fn median() -> f32 where T: Ord + Clone:
        0.0

    fn quantile(p: f32) -> f32 where T: Ord + Clone:
        0.0

    fn range() -> f32 where T: Ord:
        0.0

    fn iqr() -> f32 where T: Ord + Clone:
        0.0

# ============================================
# MutSequence trait
# ============================================

impl MutSequence<T> for Array<T, N>:
    fn get_mut(idx: usize) -> Option<&mut T>:
        if idx < N:
            Some(&mut self.data[idx])
        else:
            nil

    fn set(idx: usize, value: T) -> Result<(), IndexError>:
        if idx >= N:
            return Err(IndexError.OutOfBounds(idx, N))
        self.data[idx] = value
        Ok(())

    fn swap(i: usize, j: usize) -> Result<(), IndexError>:
        if i >= N or j >= N:
            return Err(IndexError.OutOfBounds(if i >= N: i else: j, N))
        val temp = self.data[i]
        self.data[i] = self.data[j]
        self.data[j] = temp
        Ok(())

    fn fill(value: T) where T: Clone:
        for i in 0..N:
            self.data[i] = value.clone()

    fn fill_with(f: fn(usize) -> T):
        for i in 0..N:
            self.data[i] = f(i)

    fn reverse():
        var i = 0
        var j = N - 1
        while i < j:
            val _ = self.swap(i, j)
            i = i + 1
            j = j - 1

    fn sort() where T: Ord:
        # Insertion sort for fixed arrays
        for i in 1..N:
            var j = i
            while j > 0 and self.data[j].lt(&self.data[j - 1]):
                val tmp = self.data[j]
                self.data[j] = self.data[j - 1]
                self.data[j - 1] = tmp
                j = j - 1

    fn sort_with(algo: SortAlgorithm) where T: Ord:
        # Use specified algorithm
        sort_with_algorithm(self.as_mut_slice(), algo)

    fn retain(predicate: fn(&T) -> bool):
        # Fixed arrays cannot change size, this is a no-op
        # For filtering, use filtered() which returns a List
        pass

    fn as_mut_slice() -> MutSlice<T>:
        danger:
            MutSlice.new(&mut self.data[0] as *mut T, N)

# ============================================
# ImmutSequence trait
# ============================================

impl ImmutSequence<T> for Array<T, N> where T: Clone:
    type Output = Array<T, N>

    fn with_index(idx: usize, value: T) -> Option<Self.Output>:
        if idx >= N:
            return None
        var new_data = self.data
        new_data[idx] = value
        Some(Array { data: new_data })

    fn sorted() -> Self.Output where T: Ord:
        var new_array = Array { data: self.data }
        new_array.sort()
        new_array

    fn reversed() -> Self.Output:
        var new_data = self.data
        var left: usize = 0
        var right = N - 1
        while left < right:
            val tmp = new_data[left]
            new_data[left] = new_data[right]
            new_data[right] = tmp
            left = left + 1
            right = right - 1
        Array { data: new_data }

    fn filtered(predicate: fn(&T) -> bool) -> List<T>:
        # Returns List because result size is unknown at compile time
        var result = List.new()
        for i in 0..N:
            if predicate(&self.data[i]):
                result.push(self.data[i].clone())
        result

    fn mapped<U>(self, f: fn(T) -> U) -> Array<U, N> where U: Default:
        var new_data: [U; N] = [U.default(); N]
        for i in 0..N:
            new_data[i] = f(self.data[i].clone())
        Array { data: new_data }

    fn appended(item: T) -> List<T>:
        # Returns List because size increases
        var result = List.with_capacity(N + 1)
        for i in 0..N:
            result.push(self.data[i].clone())
        result.push(item)
        result

    fn prepended(item: T) -> List<T>:
        # Returns List because size increases
        var result = List.with_capacity(N + 1)
        result.push(item)
        for i in 0..N:
            result.push(self.data[i].clone())
        result

    fn taken(n: usize) -> List<T>:
        var result = List.new()
        val take_count = if n < N: n else: N
        for i in 0..take_count:
            result.push(self.data[i].clone())
        result

    fn dropped(n: usize) -> List<T>:
        var result = List.new()
        if n < N:
            for i in n..N:
                result.push(self.data[i].clone())
        result

    fn taken_while(predicate: fn(&T) -> bool) -> List<T>:
        var result = List.new()
        for i in 0..N:
            if not predicate(&self.data[i]):
                break
            result.push(self.data[i].clone())
        result

    fn dropped_while(predicate: fn(&T) -> bool) -> List<T>:
        var result = List.new()
        var dropping = true
        for i in 0..N:
            if dropping and predicate(&self.data[i]):
                continue
            dropping = false
            result.push(self.data[i].clone())
        result
