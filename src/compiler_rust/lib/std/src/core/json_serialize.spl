# JSON Serialization and Helpers
# Part 2 of json module: stringify, helpers, JsonBuilder.

# Escape string for JSON output
fn escape_string(s: text) -> text:
    var result = ""
    for i in 0..s.len():
        val ch = s[i]
        if ch == "\"":
            result = result + "\\\""
        elif ch == "\\":
            result = result + "\\\\"
        elif ch == "\n":
            result = result + "\\n"
        elif ch == "\r":
            result = result + "\\r"
        elif ch == "\t":
            result = result + "\\t"
        else:
            result = result + ch
    return result

# Serialize JSON value to string
pub fn stringify(value: JsonValue) -> text:
    match value:
        case JsonValue.Null:
            return "null"
        case JsonValue.bool(b):
            if b:
                return "true"
            else:
                return "false"
        case JsonValue.Number(n):
            return n.to_string()
        case JsonValue.Integer(i):
            return i.to_string()
        case JsonValue.text(s):
            return "\"" + escape_string(s) + "\""
        case JsonValue.Array(arr):
            var parts = []
            for item in arr:
                parts.append(stringify(item))
            return "[" + parts.join(", ") + "]"
        case JsonValue.Object(obj):
            var parts = []
            for key in obj.keys():
                val value = obj.get(key)
                parts.append("\"" + escape_string(key) + "\": " + stringify(value))
            return '{' + parts.join(", ") + '}'

# Pretty print JSON with indentation
pub fn stringify_pretty(value: JsonValue, indent: i64) -> text:
    return stringify_indent(value, indent=indent, level=0)

fn stringify_indent(value: JsonValue, indent: i64, level: i64) -> text:
    val spaces = " ".repeat(indent * level)
    val next_spaces = " ".repeat(indent * (level + 1))

    match value:
        case JsonValue.Null:
            return "null"
        case JsonValue.bool(b):
            if b:
                return "true"
            else:
                return "false"
        case JsonValue.Number(n):
            return n.to_string()
        case JsonValue.Integer(i):
            return i.to_string()
        case JsonValue.text(s):
            return "\"" + escape_string(s) + "\""
        case JsonValue.Array(arr):
            if arr.len() == 0:
                return "[]"
            var parts = []
            for item in arr:
                parts.append(next_spaces + stringify_indent(item, indent=indent, level=level + 1))
            return "[\n" + parts.join(",\n") + "\n" + spaces + "]"
        case JsonValue.Object(obj):
            val keys = obj.keys()
            if keys.len() == 0:
                return '{}'
            var parts = []
            for key in keys:
                val value = obj.get(key)
                parts.append(next_spaces + "\"" + escape_string(key) + "\": " + stringify_indent(value, indent=indent, level=level + 1))
            return '{\n' + parts.join(",\n") + "\n" + spaces + '}'

# Parse JSON string into a Dict (convenience function)
pub fn parse_object(input: text) -> Result<Dict<text, JsonValue>, text>:
    match parse(input):
        case Ok(JsonValue.Object(obj)):
            Ok(obj)
        case Ok(_):
            Err("JSON value is not an object")
        case Err(e):
            Err(e)

# Helper to get string from JsonValue
pub fn get_string(value: JsonValue) -> Option<text>:
    match value:
        case JsonValue.text(s):
            return Some(s)
        case _:
            return nil

# Helper to get integer from JsonValue
pub fn get_int(value: JsonValue) -> Option<i64>:
    match value:
        case JsonValue.Integer(i):
            return Some(i)
        case JsonValue.Number(n):
            return Some(n as i64)
        case _:
            return nil

# Helper to get object from JsonValue
pub fn get_object(value: JsonValue) -> Option<Dict<text, JsonValue> >:
    match value:
        case JsonValue.Object(obj):
            return Some(obj)
        case _:
            return nil

# Helper to get array from JsonValue
pub fn get_array(value: JsonValue) -> Option<List<JsonValue> >:
    match value:
        case JsonValue.Array(arr):
            return Some(arr)
        case _:
            return nil

# Builder for creating JSON objects
pub class JsonBuilder:
    obj: Dict<text, JsonValue>

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_empty() -> bool:
        """Check if builder has no fields."""
        return self.obj.len() == 0

    pub fn has_fields() -> bool:
        """Check if builder has any fields."""
        return self.obj.len() > 0

    pub fn field_count() -> usize:
        """Get number of fields."""
        return self.obj.len()

    pub fn has_field(key: text) -> bool:
        """Check if field exists."""
        return self.obj.has_key(key)

    pub fn get_field(key: text) -> Option<JsonValue>:
        """Get field value."""
        if self.obj.has_key(key):
            return Some(self.obj.get(key))
        return nil

    pub me remove_field(key: text) -> JsonBuilder:
        """Remove a field."""
        self.obj = self.obj.remove(key)
        return self

    pub me clear() -> JsonBuilder:
        """Clear all fields."""
        self.obj = {}
        return self

    pub fn keys() -> List<text>:
        """Get list of all field keys."""
        return self.obj.keys()

    pub fn summary() -> text:
        """Get summary of JSON builder state."""
        return "JsonBuilder: {self.field_count()} fields"

    # =========================================================================
    # Constructor
    # =========================================================================

    static fn new() -> JsonBuilder:
        return JsonBuilder { obj: {} }

    pub me set_string(key: text, value: text) -> JsonBuilder:
        self.obj = self.obj.set(key, JsonValue.text(value))
        return self

    pub me set_int(key: text, value: i64) -> JsonBuilder:
        self.obj = self.obj.set(key, JsonValue.Integer(value))
        return self

    pub me set_bool(key: text, value: bool) -> JsonBuilder:
        self.obj = self.obj.set(key, JsonValue.bool(value))
        return self

    pub me set_null(key: text) -> JsonBuilder:
        self.obj = self.obj.set(key, JsonValue.Null)
        return self

    pub me set_object(key: text, value: Dict<text, JsonValue>) -> JsonBuilder:
        self.obj = self.obj.set(key, JsonValue.Object(value))
        return self

    pub me set_array(key: text, value: List<JsonValue>) -> JsonBuilder:
        self.obj = self.obj.set(key, JsonValue.Array(value))
        return self

    pub me set(key: text, value: JsonValue) -> JsonBuilder:
        self.obj = self.obj.set(key, value)
        return self

    pub fn build() -> JsonValue:
        return JsonValue.Object(self.obj)

    pub fn to_string() -> text:
        return stringify(self.build())
