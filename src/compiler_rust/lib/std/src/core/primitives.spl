# Primitive Type Extensions
# Feature #1387: Integer/f32/bool object methods

use core.traits.*

"""
Extension methods for primitive types.

This module provides object-oriented methods for primitive types,
allowing syntax like `42.abs()` and `3.14.round()`.

These are implemented as extension methods that work with the
primitive types without boxing/wrapping.
"""

# ============================================
# Integer Extensions (i8, i16, i32, i64, u8, u16, u32, u64)
# ============================================

impl i64:
    # Integer extension methods

    fn abs() -> i64:
        """Absolute value"""
        if self < 0: -self else: self

    fn sign() -> i64:
        """Sign: -1, 0, or 1"""
        if self < 0: -1
        elif self > 0: 1
        else: 0

    fn pow(exp: u32) -> i64:
        """Raise to power"""
        var result = 1
        for _ in 0..exp:
            result *= self
        result

    fn min(other: i64) -> i64:
        """Minimum of two values"""
        if self < other: self else: other

    fn max(other: i64) -> i64:
        """Maximum of two values"""
        if self > other: self else: other

    fn clamp(min: i64, max: i64) -> i64:
        """Clamp value between min and max"""
        if self < min: min
        elif self > max: max
        else: self

    fn is_even() -> bool:
        """Check if even"""
        self % 2 == 0

    fn is_odd() -> bool:
        """Check if odd"""
        self % 2 != 0

    fn is_positive() -> bool:
        """Check if positive"""
        self > 0

    fn is_negative() -> bool:
        """Check if negative"""
        self < 0

    fn div_euclid(rhs: i64) -> i64:
        """Euclidean division (always non-negative remainder)"""
        val q = self / rhs
        val r = self % rhs
        if r < 0:
            if rhs > 0: q - 1 else: q + 1
        else:
            q

    fn rem_euclid(rhs: i64) -> i64:
        """Euclidean remainder (always non-negative)"""
        val r = self % rhs
        if r < 0:
            if rhs > 0: r + rhs else: r - rhs
        else:
            r

    fn fdiv(rhs: i64) -> i64:
        """Floor division (rounds towards negative infinity).

        Replacement for the old floor division operator.
        Floor division always rounds down (towards negative infinity), unlike
        truncating division which rounds towards zero.

        Examples:
            7.fdiv(2)    # → 3
            (-7).fdiv(2) # → -4 (not -3)
            7.fdiv(-2)   # → -4 (not -3)
            (-7).fdiv(-2) # → 3

        Math:
            Floor division: ⌊a/b⌋
            Always: a = b * fdiv(a,b) + rem
            Where rem has same sign as divisor

        Raises:
            Error if rhs == 0 (division by zero)
        """
        if rhs == 0:
            panic("division by zero in fdiv")

        val q = self / rhs
        val r = self % rhs

        # If remainder is non-zero and signs differ, adjust quotient down
        if r != 0 and ((self < 0) != (rhs < 0)):
            q - 1
        else:
            q

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_zero() -> bool:
        """Check if value is zero.

        Returns:
            true if value is 0

        Example:
            0.is_zero()  # → true
            5.is_zero()  # → false
        """
        self == 0

    fn is_power_of_two() -> bool:
        """Check if value is a power of two.

        Returns:
            true if value is power of 2

        Example:
            8.is_power_of_two()  # → true
            7.is_power_of_two()  # → false
        """
        self > 0 and (self & (self - 1)) == 0

    fn next_power_of_two() -> i64:
        """Get next power of two >= self.

        Returns:
            Next power of 2

        Example:
            5.next_power_of_two()  # → 8
            8.next_power_of_two()  # → 8
        """
        if self <= 1:
            return 1
        var n = self - 1
        n = n | (n >> 1)
        n = n | (n >> 2)
        n = n | (n >> 4)
        n = n | (n >> 8)
        n = n | (n >> 16)
        n = n | (n >> 32)
        n + 1

    fn checked_add(other: i64) -> Option<i64>:
        """Add with overflow checking.

        Args:
            other: Value to add

        Returns:
            Some(sum) or None if overflow

        Example:
            5.checked_add(10)  # → Some(15)
            i64.MAX.checked_add(1)  # → None
        """
        val result = self + other
        if (other > 0 and result < self) or (other < 0 and result > self):
            return None
        Some(result)

    fn checked_sub(other: i64) -> Option<i64>:
        """Subtract with overflow checking.

        Args:
            other: Value to subtract

        Returns:
            Some(difference) or None if overflow

        Example:
            10.checked_sub(5)  # → Some(5)
            i64.MIN.checked_sub(1)  # → None
        """
        val result = self - other
        if (other > 0 and result > self) or (other < 0 and result < self):
            return None
        Some(result)

    fn checked_mul(other: i64) -> Option<i64>:
        """Multiply with overflow checking.

        Args:
            other: Value to multiply

        Returns:
            Some(product) or None if overflow

        Example:
            5.checked_mul(10)  # → Some(50)
            i64.MAX.checked_mul(2)  # → None
        """
        if self == 0 or other == 0:
            return Some(0)
        val result = self * other
        if result / other != self:
            return None
        Some(result)

    fn saturating_add(other: i64) -> i64:
        """Add, saturating at bounds.

        Args:
            other: Value to add

        Returns:
            Sum, or i64.MAX/MIN if overflow

        Example:
            5.saturating_add(10)  # → 15
            i64.MAX.saturating_add(1)  # → i64.MAX
        """
        match self.checked_add(other):
            case Some(v): v
            case None: if other > 0: i64.MAX else: i64.MIN

    fn saturating_sub(other: i64) -> i64:
        """Subtract, saturating at bounds.

        Args:
            other: Value to subtract

        Returns:
            Difference, or i64.MAX/MIN if overflow

        Example:
            10.saturating_sub(5)  # → 5
            i64.MIN.saturating_sub(1)  # → i64.MIN
        """
        match self.checked_sub(other):
            case Some(v): v
            case None: if other > 0: i64.MIN else: i64.MAX

    fn saturating_mul(other: i64) -> i64:
        """Multiply, saturating at bounds.

        Args:
            other: Value to multiply

        Returns:
            Product, or i64.MAX/MIN if overflow

        Example:
            5.saturating_mul(10)  # → 50
            i64.MAX.saturating_mul(2)  # → i64.MAX
        """
        match self.checked_mul(other):
            case Some(v): v
            case None:
                if (self > 0 and other > 0) or (self < 0 and other < 0):
                    i64.MAX
                else:
                    i64.MIN

    fn wrapping_add(other: i64) -> i64:
        """Add with wrapping on overflow.

        Args:
            other: Value to add

        Returns:
            Sum with wrapping

        Example:
            5.wrapping_add(10)  # → 15
            i64.MAX.wrapping_add(1)  # → i64.MIN
        """
        self + other

    fn wrapping_sub(other: i64) -> i64:
        """Subtract with wrapping on overflow.

        Args:
            other: Value to subtract

        Returns:
            Difference with wrapping

        Example:
            10.wrapping_sub(5)  # → 5
            i64.MIN.wrapping_sub(1)  # → i64.MAX
        """
        self - other

    fn wrapping_mul(other: i64) -> i64:
        """Multiply with wrapping on overflow.

        Args:
            other: Value to multiply

        Returns:
            Product with wrapping

        Example:
            5.wrapping_mul(10)  # → 50
        """
        self * other

    # =========================================================================
    # Integer Iteration Methods (Ruby-style)
    # =========================================================================

    fn times(f: fn(i64)):
        """Execute closure n times (0 to n-1).

        Args:
            f: Closure to execute with index

        Example:
            3.times(|i| print(i))  # prints 0, 1, 2
            5.times(|_| print("hello"))  # prints "hello" 5 times
        """
        if self <= 0:
            return
        for i in 0..self:
            f(i)

    fn upto(end: i64, f: fn(i64)):
        """Iterate from self up to end (inclusive).

        Args:
            end: End value (inclusive)
            f: Closure to execute with each value

        Example:
            1.upto(5, |i| print(i))  # prints 1, 2, 3, 4, 5
        """
        var i = self
        while i <= end:
            f(i)
            i = i + 1

    fn downto(end: i64, f: fn(i64)):
        """Iterate from self down to end (inclusive).

        Args:
            end: End value (inclusive)
            f: Closure to execute with each value

        Example:
            5.downto(1, |i| print(i))  # prints 5, 4, 3, 2, 1
        """
        var i = self
        while i >= end:
            f(i)
            i = i - 1
