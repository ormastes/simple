# Primitive Type Extensions (Part 2)
# Number trait impls, f64 extensions, bool extensions, constants.

use core.traits.*

# ============================================
# Number Trait Implementation for i64
# ============================================

impl Number for i64:
    fn zero() -> i64:
        0

    fn one() -> i64:
        1

    fn abs() -> i64:
        if self < 0: -self else: self

    fn is_zero() -> bool:
        self == 0

    fn is_positive() -> bool:
        self > 0

    fn is_negative() -> bool:
        self < 0

    fn to_f64() -> f64:
        self as f64

    fn to_i64() -> i64:
        self

    fn signum() -> i64:
        if self < 0: -1
        elif self > 0: 1
        else: 0

# ============================================
# f32 Extensions (f32, f64)
# ============================================

impl f64:
    # f64 extension methods

    fn abs() -> f64:
        """Absolute value"""
        if self < 0.0: -self else: self

    fn floor() -> f64:
        """Round down to integer"""
        # Compiler intrinsic or stdlib implementation
        __builtin_floor(self)

    fn ceil() -> f64:
        """Round up to integer"""
        # Compiler intrinsic or stdlib implementation
        __builtin_ceil(self)

    fn round() -> f64:
        """Round to nearest integer"""
        # Compiler intrinsic or stdlib implementation
        __builtin_round(self)

    fn trunc() -> f64:
        """Round toward zero"""
        if self >= 0.0: self.floor() else: self.ceil()

    fn sqrt() -> f64:
        """Square root"""
        __builtin_sqrt(self)

    fn powi(exp: i32) -> f64:
        """Raise to integer power"""
        __builtin_powi(self, exp)

    fn powf(exp: f64) -> f64:
        """Raise to f32 power"""
        __builtin_powf(self, exp)

    fn sin() -> f64:
        """Sine"""
        __builtin_sin(self)

    fn cos() -> f64:
        """Cosine"""
        __builtin_cos(self)

    fn tan() -> f64:
        """Tangent"""
        __builtin_tan(self)

    fn min(other: f64) -> f64:
        """Minimum of two values"""
        if self < other: self else: other

    fn max(other: f64) -> f64:
        """Maximum of two values"""
        if self > other: self else: other

    fn clamp(min: f64, max: f64) -> f64:
        """Clamp value between min and max"""
        if self < min: min
        elif self > max: max
        else: self

    fn is_nan() -> bool:
        """Check if NaN"""
        self != self

    fn is_infinite() -> bool:
        """Check if infinite"""
        self == f64.INFINITY or self == f64.NEG_INFINITY

    fn is_finite() -> bool:
        """Check if finite"""
        not self.is_infinite() and not self.is_nan()

    fn fdiv(rhs: f64) -> f64:
        """Floor division for floating point numbers.

        Replacement for the old floor division operator.
        Divides and rounds down (towards negative infinity).

        Examples:
            7.5.fdiv(2.0)    # → 3.0
            (-7.5).fdiv(2.0) # → -4.0
            7.5.fdiv(-2.0)   # → -4.0
            (-7.5).fdiv(-2.0) # → 3.0

        Returns:
            Floor of self divided by rhs

        Special cases:
            x.fdiv(0.0)     → inf or -inf or nan
            nan.fdiv(x)     → nan
            x.fdiv(nan)     → nan
            inf.fdiv(inf)   → nan
        """
        (self / rhs).floor()

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_zero() -> bool:
        """Check if value is zero.

        Returns:
            true if value is 0.0

        Example:
            0.0.is_zero()  # → true
            0.1.is_zero()  # → false
        """
        self == 0.0

    fn is_positive() -> bool:
        """Check if value is positive.

        Returns:
            true if value > 0

        Example:
            5.0.is_positive()  # → true
            (-5.0).is_positive()  # → false
        """
        self > 0.0

    fn is_negative() -> bool:
        """Check if value is negative.

        Returns:
            true if value < 0

        Example:
            (-5.0).is_negative()  # → true
            5.0.is_negative()  # → false
        """
        self < 0.0

    fn signum() -> f64:
        """Get sign as -1.0, 0.0, or 1.0.

        Returns:
            Sign value

        Example:
            5.0.signum()  # → 1.0
            (-3.0).signum()  # → -1.0
            0.0.signum()  # → 0.0
        """
        if self > 0.0:
            1.0
        elif self < 0.0:
            -1.0
        else:
            0.0

    fn to_degrees() -> f64:
        """Convert radians to degrees.

        Returns:
            Value in degrees

        Example:
            f64.PI.to_degrees()  # → 180.0
        """
        self * (180.0 / f64.PI)

    fn to_radians() -> f64:
        """Convert degrees to radians.

        Returns:
            Value in radians

        Example:
            180.0.to_radians()  # → π
        """
        self * (f64.PI / 180.0)

    fn recip() -> f64:
        """Get reciprocal (1/x).

        Returns:
            Reciprocal

        Example:
            2.0.recip()  # → 0.5
            4.0.recip()  # → 0.25
        """
        1.0 / self

    fn exp() -> f64:
        """Exponential function (e^x).

        Returns:
            e raised to self

        Example:
            1.0.exp()  # → e
            2.0.exp()  # → e²
        """
        __builtin_exp(self)

    fn ln() -> f64:
        """Natural logarithm.

        Returns:
            ln(self)

        Example:
            f64.E.ln()  # → 1.0
        """
        __builtin_ln(self)

    fn log10() -> f64:
        """Base-10 logarithm.

        Returns:
            log₁₀(self)

        Example:
            100.0.log10()  # → 2.0
        """
        __builtin_log10(self)

    fn log2() -> f64:
        """Base-2 logarithm.

        Returns:
            log₂(self)

        Example:
            8.0.log2()  # → 3.0
        """
        __builtin_log2(self)

    fn fract() -> f64:
        """Get fractional part.

        Returns:
            Fractional component

        Example:
            3.75.fract()  # → 0.75
        """
        self - self.trunc()

    fn mul_add(a: f64, b: f64) -> f64:
        """Fused multiply-add: (self * a) + b.

        Args:
            a: Multiplier
            b: Addend

        Returns:
            (self * a) + b

        Example:
            2.0.mul_add(3.0, 4.0)  # → 10.0
        """
        (self * a) + b

# ============================================
# Number Trait Implementation for f64
# ============================================

impl Number for f64:
    fn zero() -> f64:
        0.0

    fn one() -> f64:
        1.0

    fn abs() -> f64:
        if self < 0.0: -self else: self

    fn is_zero() -> bool:
        self == 0.0

    fn is_positive() -> bool:
        self > 0.0

    fn is_negative() -> bool:
        self < 0.0

    fn to_f64() -> f64:
        self

    fn to_i64() -> i64:
        self as i64

    fn signum() -> f64:
        if self > 0.0: 1.0
        elif self < 0.0: -1.0
        else: 0.0

# ============================================
# bool Extensions
# ============================================

impl bool:
    # Boolean extension methods

    fn then<T>(self, value: T) -> Option<T>:
        """Return Some(value) if true, None if false"""
        if self: Some(value) else: None

    fn then_some<T>(self, f: fn() -> T) -> Option<T>:
        """Evaluate and return Some(result) if true"""
        if self: Some(f()) else: None

    fn to_int() -> i64:
        """Convert to integer (0 or 1)"""
        if self: 1 else: 0

    fn to_string() -> str:
        """Convert to string"""
        if self: "true" else: "false"

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn not() -> bool:
        """Logical NOT.

        Returns:
            Negated value

        Example:
            true.not()  # → false
            false.not()  # → true
        """
        not self

    fn and(other: bool) -> bool:
        """Logical AND.

        Args:
            other: Other boolean

        Returns:
            self AND other

        Example:
            true.and(true)  # → true
            true.and(false)  # → false
        """
        self and other

    fn or(other: bool) -> bool:
        """Logical OR.

        Args:
            other: Other boolean

        Returns:
            self OR other

        Example:
            true.or(false)  # → true
            false.or(false)  # → false
        """
        self or other

    fn exclusive_or(other: bool) -> bool:
        """Logical XOR.

        Args:
            other: Other boolean

        Returns:
            self XOR other

        Example:
            true.exclusive_or(false)  # → true
            true.exclusive_or(true)  # → false

        Note:
            You can also use the `xor` operator directly: `true xor false`
        """
        (self or other) and not (self and other)

    fn implies(other: bool) -> bool:
        """Logical implication (self → other).

        Args:
            other: Consequent

        Returns:
            true if self implies other

        Example:
            true.implies(false)  # → false
            false.implies(true)  # → true
        """
        not self or other

    fn to_option<T>(self, value: T) -> Option<T>:
        """Convert to Option (alias for then).

        Args:
            value: Value to wrap

        Returns:
            Some(value) if true, None otherwise

        Example:
            true.to_option(42)  # → Some(42)
            false.to_option(42)  # → None
        """
        if self: Some(value) else: None

# ============================================
# Constants
# ============================================

# TODO: const declarations in impl blocks not yet supported by parser
# impl f64:
#     const PI: f64 = 3.14159265358979323846
#     const E: f64 = 2.71828182845904523536
#     const INFINITY: f64 = 1.0 / 0.0
#     const NEG_INFINITY: f64 = -1.0 / 0.0
#     const NAN: f64 = 0.0 / 0.0
#
# impl i64:
#     const MIN: i64 = -9223372036854775808
#     const MAX: i64 = 9223372036854775807

# ============================================
# Example Usage
# ============================================

"""
Example usage of primitive extensions:

    # Integer methods
    val x = -42
    assert x.abs() == 42
    assert x.is_negative()
    assert 10.pow(3) == 1000
    assert 5.min(10) == 5
    assert 7.clamp(0, 5) == 5

    # f32 methods
    val y = 3.7
    assert y.floor() == 3.0
    assert y.ceil() == 4.0
    assert y.round() == 4.0
    assert 2.0.sqrt() == 1.414...
    assert 9.0.sqrt() == 3.0

    # Boolean methods
    val b = true
    assert b.to_int() == 1
    assert b.then(42) == Some(42)
    assert false.then(42) == None

    # Constants
    val circle_area = r * r * f64.PI
    assert f64.INFINITY.is_infinite()
"""
