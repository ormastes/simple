# Godot Lighting Effects and Environments
#
# Light effect enumerations and preset environment configurations
#
# Features:
# - BlendMode (additive, subtractive, mix blending)
# - DirectionalShadowMode (orthogonal, parallel cascade splits)
# - BackgroundMode (clear color, sky, canvas, etc.)
# - ToneMapper (linear, Reinhard, filmic, ACES)
# - Preset environments (outdoor, indoor, night)

use godot.ffi
use godot.variant
use godot.node2d
use godot.node3d
use godot.resource

mod lighting


# Enums

pub enum BlendMode:
    Add = 0       # Additive blending
    Sub = 1       # Subtractive blending
    Mix = 2       # Mix blending

impl BlendMode:
    pub fn to_string(self) -> text:
        """Convert blend mode to string."""
        match self:
            case Add: "Add"
            case Sub: "Sub"
            case Mix: "Mix"

    pub fn description(self) -> text:
        """Get blend mode description."""
        match self:
            case Add: "Additive blending (colors are added)"
            case Sub: "Subtractive blending (colors are subtracted)"
            case Mix: "Mix blending (standard alpha blending)"

    pub fn is_add(self) -> bool:
        """Check if blend mode is Add."""
        match self:
            case Add: true
            case _: false

    pub fn is_sub(self) -> bool:
        """Check if blend mode is Sub."""
        match self:
            case Sub: true
            case _: false

    pub fn is_mix(self) -> bool:
        """Check if blend mode is Mix."""
        match self:
            case Mix: true
            case _: false

    pub fn summary(self) -> text:
        """Get blend mode summary."""
        val name = self.to_string()
        val desc = self.description()
        return "BlendMode: {name} ({desc})"

pub enum DirectionalShadowMode:
    Orthogonal = 0       # Orthogonal shadows
    Parallel2Splits = 1  # 2-split parallel
    Parallel4Splits = 2  # 4-split parallel (CSM)

impl DirectionalShadowMode:
    pub fn to_string(self) -> text:
        """Convert shadow mode to string."""
        match self:
            case Orthogonal: "Orthogonal"
            case Parallel2Splits: "Parallel2Splits"
            case Parallel4Splits: "Parallel4Splits"

    pub fn description(self) -> text:
        """Get shadow mode description."""
        match self:
            case Orthogonal: "Simple orthogonal shadow projection"
            case Parallel2Splits: "Parallel split shadow maps (2 cascades)"
            case Parallel4Splits: "Parallel split shadow maps (4 cascades, CSM)"

    pub fn is_orthogonal(self) -> bool:
        """Check if shadow mode is Orthogonal."""
        match self:
            case Orthogonal: true
            case _: false

    pub fn is_parallel_2_splits(self) -> bool:
        """Check if shadow mode is Parallel2Splits."""
        match self:
            case Parallel2Splits: true
            case _: false

    pub fn is_parallel_4_splits(self) -> bool:
        """Check if shadow mode is Parallel4Splits."""
        match self:
            case Parallel4Splits: true
            case _: false

    pub fn is_cascaded(self) -> bool:
        """Check if shadow mode uses cascades."""
        match self:
            case Parallel2Splits: true
            case Parallel4Splits: true
            case _: false

    pub fn get_cascade_count(self) -> i32:
        """Get number of shadow cascades."""
        match self:
            case Orthogonal: 1
            case Parallel2Splits: 2
            case Parallel4Splits: 4

    pub fn summary(self) -> text:
        """Get shadow mode summary."""
        val name = self.to_string()
        val desc = self.description()
        val cascades = self.get_cascade_count()
        var props = []
        if self.is_cascaded():
            props.push("cascaded")
        props.push("{cascades} cascade(s)")
        val props_str = ", ".join(props)
        return "DirectionalShadowMode: {name} ({desc}, {props_str})"

pub enum BackgroundMode:
    ClearColor = 0   # Solid color
    Color = 1        # Custom color
    Sky = 2          # Sky shader
    Canvas = 3       # Canvas layer
    Keep = 4         # Keep previous
    CameraNone = 5   # No background

impl BackgroundMode:
    pub fn to_string(self) -> text:
        """Convert background mode to string."""
        match self:
            case ClearColor: "ClearColor"
            case Color: "Color"
            case Sky: "Sky"
            case Canvas: "Canvas"
            case Keep: "Keep"
            case CameraNone: "CameraNone"

    pub fn description(self) -> text:
        """Get background mode description."""
        match self:
            case ClearColor: "Solid clear color background"
            case Color: "Custom solid color background"
            case Sky: "Sky shader background"
            case Canvas: "Canvas layer as background"
            case Keep: "Keep previous frame's background"
            case CameraNone: "No background rendering"

    pub fn is_clear_color(self) -> bool:
        """Check if background mode is ClearColor."""
        match self:
            case ClearColor: true
            case _: false

    pub fn is_color(self) -> bool:
        """Check if background mode is Color."""
        match self:
            case Color: true
            case _: false

    pub fn is_sky(self) -> bool:
        """Check if background mode is Sky."""
        match self:
            case Sky: true
            case _: false

    pub fn is_canvas(self) -> bool:
        """Check if background mode is Canvas."""
        match self:
            case Canvas: true
            case _: false

    pub fn is_keep(self) -> bool:
        """Check if background mode is Keep."""
        match self:
            case Keep: true
            case _: false

    pub fn is_camera_none(self) -> bool:
        """Check if background mode is CameraNone."""
        match self:
            case CameraNone: true
            case _: false

    pub fn uses_color(self) -> bool:
        """Check if mode uses a solid color."""
        match self:
            case ClearColor: true
            case Color: true
            case _: false

    pub fn is_transparent(self) -> bool:
        """Check if mode allows transparency."""
        match self:
            case Keep: true
            case CameraNone: true
            case _: false

    pub fn summary(self) -> text:
        """Get background mode summary."""
        val name = self.to_string()
        val desc = self.description()
        var props = []
        if self.uses_color():
            props.push("solid color")
        if self.is_transparent():
            props.push("transparent")
        if props.len() > 0:
            val props_str = ", ".join(props)
            return "BackgroundMode: {name} ({desc}, {props_str})"
        else:
            return "BackgroundMode: {name} ({desc})"

pub enum ToneMapper:
    Linear = 0       # No tonemapping
    Reinhard = 1     # Reinhard
    Filmic = 2       # Filmic (ACES-like)
    Aces = 3         # ACES

impl ToneMapper:
    pub fn to_string(self) -> text:
        """Convert tone mapper to string."""
        match self:
            case Linear: "Linear"
            case Reinhard: "Reinhard"
            case Filmic: "Filmic"
            case Aces: "Aces"

    pub fn description(self) -> text:
        """Get tone mapper description."""
        match self:
            case Linear: "No tonemapping (linear color space)"
            case Reinhard: "Reinhard tonemapping (simple HDR compression)"
            case Filmic: "Filmic tonemapping (ACES-like, cinematic)"
            case Aces: "ACES tonemapping (Academy Color Encoding System)"

    pub fn is_linear(self) -> bool:
        """Check if tone mapper is Linear."""
        match self:
            case Linear: true
            case _: false

    pub fn is_reinhard(self) -> bool:
        """Check if tone mapper is Reinhard."""
        match self:
            case Reinhard: true
            case _: false

    pub fn is_filmic(self) -> bool:
        """Check if tone mapper is Filmic."""
        match self:
            case Filmic: true
            case _: false

    pub fn is_aces(self) -> bool:
        """Check if tone mapper is Aces."""
        match self:
            case Aces: true
            case _: false

    pub fn uses_hdr_compression(self) -> bool:
        """Check if tone mapper performs HDR compression."""
        match self:
            case Linear: false
            case _: true

    pub fn is_cinematic(self) -> bool:
        """Check if tone mapper is cinematic-oriented."""
        match self:
            case Filmic: true
            case Aces: true
            case _: false

    pub fn summary(self) -> text:
        """Get tone mapper summary."""
        val name = self.to_string()
        val desc = self.description()
        var props = []
        if self.uses_hdr_compression():
            props.push("HDR compression")
        if self.is_cinematic():
            props.push("cinematic")
        if props.len() > 0:
            val props_str = ", ".join(props)
            return "ToneMapper: {name} ({desc}, {props_str})"
        else:
            return "ToneMapper: {name} ({desc})"


# Preset environments

# Outdoor daytime
pub fn create_outdoor_environment() -> Environment:
    var env = Environment.new()
    env.set_background(BackgroundMode.Sky)
    env.set_bg_energy(1.0)
    env.set_ambient_light_color(0.4, 0.5, 0.6)
    env.set_ambient_light_energy(1.0)
    env.set_tonemap_mode(ToneMapper.Filmic)
    env.set_tonemap_exposure(1.0)
    return env

# Indoor with fog
pub fn create_indoor_environment() -> Environment:
    var env = Environment.new()
    env.set_background(BackgroundMode.Color)
    env.set_bg_color(0.1, 0.1, 0.1)
    env.set_ambient_light_color(0.3, 0.3, 0.3)
    env.set_ambient_light_energy(0.5)
    env.set_fog_enabled(true)
    env.set_fog_density(0.01)
    env.set_tonemap_mode(ToneMapper.Reinhard)
    return env

# Night scene
pub fn create_night_environment() -> Environment:
    var env = Environment.new()
    env.set_background(BackgroundMode.Color)
    env.set_bg_color(0.01, 0.01, 0.02)
    env.set_ambient_light_color(0.05, 0.05, 0.1)
    env.set_ambient_light_energy(0.2)
    env.set_glow_enabled(true)
    env.set_tonemap_mode(ToneMapper.Aces)
    return env
