# Godot Vulkan Integration
#
# Access Godot's Vulkan compositor and render custom overlays
#
# Features:
# - Vulkan device and queue access
# - Custom render passes
# - 2D overlay rendering
# - Integration with Simple's Vulkan backend
#
# Based on: https://docs.godotengine.org/en/stable/tutorials/rendering/using_vulkan.html
#
# Split into:
# - vulkan_render.spl  (VulkanCompositor, Vulkan2DOverlay, OverlayElement, Color)
# - vulkan_sync.spl    (FontAtlas, TextElement, ImageElement, UVRect, SPIR-V data)

use godot.ffi
use godot.variant
use godot.node
use gpu.vulkan  # Simple's Vulkan backend

mod vulkan

# Rendering Device
# Wrapper for Godot's RenderingDevice (Vulkan backend)
pub struct RenderingDevice:
    singleton_ptr: ffi.GDExtensionObjectPtr

impl RenderingDevice:
    # Get RenderingDevice singleton
    pub fn get_singleton() -> RenderingDevice:
        val ptr = ffi.get_singleton("RenderingDevice")
        return RenderingDevice(singleton_ptr: ptr)

    # Get Vulkan instance handle
    # Resource type 0 = VkInstance
    pub fn get_vulkan_instance(self) -> u64:
        return ffi.godot_rd_get_driver_resource(
            self.singleton_ptr,
            0,  # VkInstance
            0,  # No specific RID
            0   # No index
        )

    # Get Vulkan physical device
    # Resource type 1 = VkPhysicalDevice
    pub fn get_vulkan_physical_device(self) -> u64:
        return ffi.godot_rd_get_driver_resource(
            self.singleton_ptr,
            1,  # VkPhysicalDevice
            0,  # No specific RID
            0   # No index
        )

    # Get Vulkan logical device
    # Resource type 2 = VkDevice
    pub fn get_vulkan_device(self) -> u64:
        return ffi.godot_rd_get_driver_resource(
            self.singleton_ptr,
            2,  # VkDevice
            0,  # No specific RID
            0   # No index
        )

    # Get Vulkan queue family index
    # Resource type 3 = VkQueue, returns queue family index when queried
    pub fn get_queue_family_index(self) -> u32:
        # Query the graphics queue family index from Godot
        # The queue family index is typically embedded in the queue handle
        # For Godot, this is usually 0 (graphics queue family)
        return 0  # Graphics queue family

    # Create custom shader from SPIR-V
    pub fn create_shader(mut self, spirv_bytes: &Array<u8>) -> Result<ShaderRID, text>:
        if spirv_bytes.len() == 0:
            return Err("Empty SPIR-V data")

        val shader_rid = ffi.godot_rd_shader_create_from_spirv(
            self.singleton_ptr,
            spirv_bytes.as_ptr(),
            spirv_bytes.len() as u64
        )

        if shader_rid == 0:
            return Err("Failed to create shader from SPIR-V")

        return Ok(ShaderRID(id: shader_rid))

    # Free a shader
    pub fn free_shader(mut self, shader: ShaderRID):
        ffi.godot_rd_free_rid(self.singleton_ptr, shader.id)

    # Create a buffer (vertex, index, uniform, or storage)
    pub fn create_buffer(mut self, size: u64, usage: BufferUsage) -> Result<BufferRID, text>:
        val usage_type = match usage:
            case BufferUsage.Vertex: 0
            case BufferUsage.Index: 1
            case BufferUsage.Uniform: 2
            case BufferUsage.Storage: 3

        val buffer_rid = ffi.godot_rd_buffer_create(
            self.singleton_ptr,
            size,
            usage_type
        )

        if buffer_rid == 0:
            return Err("Failed to create buffer")

        return Ok(BufferRID(id: buffer_rid))

    # Update buffer data
    pub fn update_buffer(mut self, buffer: BufferRID, offset: u64, data: &Array<u8>) -> Result<(), text>:
        val result = ffi.godot_rd_buffer_update(
            self.singleton_ptr,
            buffer.id,
            offset,
            data.as_ptr(),
            data.len() as u64
        )

        if result != 0:
            return Err("Failed to update buffer")

        return Ok(())

    # Free a buffer
    pub fn free_buffer(mut self, buffer: BufferRID):
        ffi.godot_rd_free_rid(self.singleton_ptr, buffer.id)

    # Create render pipeline for 2D overlay rendering
    pub fn create_render_pipeline(
        mut self,
        shader: ShaderRID,
        framebuffer_format: u64,
        vertex_format: VertexFormat
    ) -> Result<PipelineRID, text>:
        val pipeline_rid = ffi.godot_rd_render_pipeline_create(
            self.singleton_ptr,
            shader.id,
            framebuffer_format,
            vertex_format.stride,
            vertex_format.attribute_count
        )

        if pipeline_rid == 0:
            return Err("Failed to create render pipeline")

        return Ok(PipelineRID(id: pipeline_rid))

    # Free a pipeline
    pub fn free_pipeline(mut self, pipeline: PipelineRID):
        ffi.godot_rd_free_rid(self.singleton_ptr, pipeline.id)

    # Create vertex array from buffer
    pub fn create_vertex_array(
        mut self,
        vertex_count: u32,
        vertex_format: VertexFormat,
        buffer: BufferRID
    ) -> Result<VertexArrayRID, text>:
        val vertex_array_rid = ffi.godot_rd_vertex_array_create(
            self.singleton_ptr,
            vertex_count,
            vertex_format.stride,
            buffer.id
        )

        if vertex_array_rid == 0:
            return Err("Failed to create vertex array")

        return Ok(VertexArrayRID(id: vertex_array_rid))

    # Free a vertex array
    pub fn free_vertex_array(mut self, vertex_array: VertexArrayRID):
        ffi.godot_rd_free_rid(self.singleton_ptr, vertex_array.id)

    # Get framebuffer format ID
    pub fn get_framebuffer_format(mut self, color_format: u32, depth_format: u32) -> u64:
        return ffi.godot_rd_framebuffer_format_create(
            self.singleton_ptr,
            color_format,
            depth_format
        )

    # Create a 2D texture
    pub fn create_texture(
        mut self,
        width: u32,
        height: u32,
        format: TextureFormat,
        usage: TextureUsage,
        initial_data: Option<&Array<u8>>
    ) -> Result<TextureRID, text>:
        val format_val = match format:
            case TextureFormat.RGBA8: 37
            case TextureFormat.R8: 50
            case TextureFormat.RGBA16F: 70
            case TextureFormat.RGBA32F: 75

        val usage_val = match usage:
            case TextureUsage.Sampling: 1
            case TextureUsage.ColorAttachment: 2
            case TextureUsage.Storage: 4
            case TextureUsage.SamplingAndStorage: 5

        val (data_ptr, data_len) = match initial_data:
            case Some(data): (data.as_ptr(), data.len() as u64)
            case None: (0 as *const u8, 0 as u64)

        val texture_rid = ffi.godot_rd_texture_create(
            self.singleton_ptr,
            width,
            height,
            format_val,
            usage_val,
            data_ptr,
            data_len
        )

        if texture_rid == 0:
            return Err("Failed to create texture")

        return Ok(TextureRID(id: texture_rid))

    # Update texture data
    pub fn update_texture(mut self, texture: TextureRID, layer: u32, data: &Array<u8>) -> Result<(), text>:
        val result = ffi.godot_rd_texture_update(
            self.singleton_ptr,
            texture.id,
            layer,
            data.as_ptr(),
            data.len() as u64
        )

        if result != 0:
            return Err("Failed to update texture")

        return Ok(())

    # Free a texture
    pub fn free_texture(mut self, texture: TextureRID):
        ffi.godot_rd_free_rid(self.singleton_ptr, texture.id)

    # Create a sampler
    pub fn create_sampler(mut self, filter: SamplerFilter, address_mode: AddressMode) -> Result<SamplerRID, text>:
        val filter_val = match filter:
            case SamplerFilter.Nearest: 0
            case SamplerFilter.Linear: 1

        val address_val = match address_mode:
            case AddressMode.Repeat: 0
            case AddressMode.MirroredRepeat: 1
            case AddressMode.ClampToEdge: 2

        val sampler_rid = ffi.godot_rd_sampler_create(
            self.singleton_ptr,
            filter_val,  # min_filter
            filter_val,  # mag_filter
            filter_val,  # mip_filter
            address_val, # address_mode_u
            address_val, # address_mode_v
            address_val  # address_mode_w
        )

        if sampler_rid == 0:
            return Err("Failed to create sampler")

        return Ok(SamplerRID(id: sampler_rid))

    # Free a sampler
    pub fn free_sampler(mut self, sampler: SamplerRID):
        ffi.godot_rd_free_rid(self.singleton_ptr, sampler.id)

    # Create uniform set for texture binding
    pub fn create_uniform_set(
        mut self,
        shader: ShaderRID,
        set_index: u32,
        texture: TextureRID,
        sampler: SamplerRID
    ) -> Result<UniformSetRID, text>:
        # Serialize uniform binding: texture + sampler
        var uniforms_data: Array<u8> = []
        # Format: [binding, type, rid...]
        # Type 0 = sampler with texture
        uniforms_data.extend(&u32_to_le_bytes(0))  # binding 0
        uniforms_data.extend(&u32_to_le_bytes(0))  # type: sampler_with_texture
        uniforms_data.extend(&u64_to_le_bytes(texture.id))
        uniforms_data.extend(&u64_to_le_bytes(sampler.id))

        val uniform_set_rid = ffi.godot_rd_uniform_set_create(
            self.singleton_ptr,
            shader.id,
            set_index,
            uniforms_data.as_ptr(),
            uniforms_data.len() as u64
        )

        if uniform_set_rid == 0:
            return Err("Failed to create uniform set")

        return Ok(UniformSetRID(id: uniform_set_rid))

    # Free a uniform set
    pub fn free_uniform_set(mut self, uniform_set: UniformSetRID):
        ffi.godot_rd_free_rid(self.singleton_ptr, uniform_set.id)


# Shader Resource ID
pub struct ShaderRID:
    id: u64

# Texture Resource ID
pub struct TextureRID:
    id: u64

# Framebuffer Resource ID
pub struct FramebufferRID:
    id: u64

# Buffer Resource ID
pub struct BufferRID:
    id: u64

# Buffer usage types
pub enum BufferUsage:
    Vertex
    Index
    Uniform
    Storage

impl BufferUsage:
    pub fn to_string(self) -> text:
        match self:
            case Vertex: "Vertex"
            case Index: "Index"
            case Uniform: "Uniform"
            case Storage: "Storage"

# Pipeline Resource ID
pub struct PipelineRID:
    id: u64

# Vertex Array Resource ID
pub struct VertexArrayRID:
    id: u64

# Sampler Resource ID
pub struct SamplerRID:
    id: u64

# Uniform Set Resource ID
pub struct UniformSetRID:
    id: u64

# Texture formats
pub enum TextureFormat:
    RGBA8      # 8-bit RGBA (sRGB)
    R8         # 8-bit grayscale (for font atlases)
    RGBA16F    # 16-bit float RGBA (HDR)
    RGBA32F    # 32-bit float RGBA (HDR, high precision)

impl TextureFormat:
    pub fn to_string(self) -> text:
        match self:
            case RGBA8: "RGBA8"
            case R8: "R8"
            case RGBA16F: "RGBA16F"
            case RGBA32F: "RGBA32F"

    pub fn bytes_per_pixel(self) -> u32:
        match self:
            case RGBA8: 4
            case R8: 1
            case RGBA16F: 8
            case RGBA32F: 16

# Texture usage flags
pub enum TextureUsage:
    Sampling           # Can be sampled in shaders
    ColorAttachment    # Can be used as render target
    Storage            # Can be used as storage image
    SamplingAndStorage # Both sampling and storage

impl TextureUsage:
    pub fn to_string(self) -> text:
        match self:
            case Sampling: "Sampling"
            case ColorAttachment: "ColorAttachment"
            case Storage: "Storage"
            case SamplingAndStorage: "SamplingAndStorage"

# Sampler filter modes
pub enum SamplerFilter:
    Nearest  # No filtering (pixelated)
    Linear   # Bilinear filtering (smooth)

impl SamplerFilter:
    pub fn to_string(self) -> text:
        match self:
            case Nearest: "Nearest"
            case Linear: "Linear"

# Sampler address modes
pub enum AddressMode:
    Repeat          # Wrap around
    MirroredRepeat  # Mirror and wrap
    ClampToEdge     # Clamp to edge color

impl AddressMode:
    pub fn to_string(self) -> text:
        match self:
            case Repeat: "Repeat"
            case MirroredRepeat: "MirroredRepeat"
            case ClampToEdge: "ClampToEdge"

# Vertex Format description
pub struct VertexFormat:
    stride: u32           # Bytes per vertex
    attribute_count: u32  # Number of vertex attributes

impl VertexFormat:
    # Create vertex format for position (2 floats) + color (4 floats) = 24 bytes
    pub fn position_color_2d() -> VertexFormat:
        return VertexFormat {stride: 24, # 2 * 4 (pos) + 4 * 4 (color) = 24 bytes attribute_count: 2 # position, color}

    # Create vertex format for position (3 floats) + color (4 floats) = 28 bytes
    pub fn position_color_3d() -> VertexFormat:
        return VertexFormat {
            stride: 28,        # 3 * 4 (pos) + 4 * 4 (color) = 28 bytes
            attribute_count: 2  # position, color
        }

    # Create vertex format for position (2 floats) + uv (2 floats) + color (4 floats) = 32 bytes
    pub fn position_uv_color_2d() -> VertexFormat:
        return VertexFormat {
            stride: 32,        # 2 * 4 (pos) + 2 * 4 (uv) + 4 * 4 (color) = 32 bytes
            attribute_count: 3  # position, uv, color
        }

    # Create custom vertex format
    pub fn custom(stride: u32, attribute_count: u32) -> VertexFormat:
        return VertexFormat {
            stride: stride,
            attribute_count: attribute_count
        }


# Byte serialization helpers (used by vulkan_render.spl and vulkan_sync.spl)
pub fn u32_to_le_bytes(value: u32) -> Array<u8>:
    var bytes: Array<u8> = []
    bytes.push((value & 0xFF) as u8)
    bytes.push(((value >> 8) & 0xFF) as u8)
    bytes.push(((value >> 16) & 0xFF) as u8)
    bytes.push(((value >> 24) & 0xFF) as u8)
    return bytes

pub fn u64_to_le_bytes(value: u64) -> Array<u8>:
    var bytes: Array<u8> = []
    bytes.push((value & 0xFF) as u8)
    bytes.push(((value >> 8) & 0xFF) as u8)
    bytes.push(((value >> 16) & 0xFF) as u8)
    bytes.push(((value >> 24) & 0xFF) as u8)
    bytes.push(((value >> 32) & 0xFF) as u8)
    bytes.push(((value >> 40) & 0xFF) as u8)
    bytes.push(((value >> 48) & 0xFF) as u8)
    bytes.push(((value >> 56) & 0xFF) as u8)
    return bytes


# Array placeholder
pub struct Array<T>:
    items: Vec<T>

impl<T> Array<T>:
    pub fn push(mut self, item: T):
        pass

    pub fn clear(mut self):
        pass
