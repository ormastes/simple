# Godot Camera Enums and Factory Functions
#
# Camera-related enumerations and camera creation utilities
#
# Features:
# - ProcessCallback (idle vs physics update)
# - ProjectionMode (perspective vs orthogonal)
# - KeepAspectMode (aspect ratio handling)
# - MSAA (multi-sample anti-aliasing levels)
# - ScreenSpaceAA (FXAA post-process)
# - Camera factory functions

use godot.ffi
use godot.variant
use godot.node2d
use godot.node3d

mod camera


pub enum ProcessCallback:
    Idle = 0       # Update during _process
    Physics = 1    # Update during _physics_process

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_idle(self) -> bool:
        """Check if callback is during idle.

        Returns:
            true if Idle variant

        Example:
            callback.is_idle()  # → true
        """
        match self:
            case Idle: return true
            case _: return false

    pub fn is_physics(self) -> bool:
        """Check if callback is during physics.

        Returns:
            true if Physics variant

        Example:
            callback.is_physics()  # → false
        """
        match self:
            case Physics: return true
            case _: return false

    pub fn to_string(self) -> text:
        """Convert to string.

        Returns:
            text representation

        Example:
            callback.to_string()  # → "Idle"
        """
        match self:
            case Idle: return "Idle"
            case Physics: return "Physics"

    fn description() -> text:
        """Get process callback description.

        Returns:
            Human-readable description

        Example:
            ProcessCallback.Idle.description()
            # → "Update during idle frame (_process)"
        """
        match self:
            case Idle: return "Update during idle frame (_process)"
            case Physics: return "Update during physics frame (_physics_process)"

    pub fn summary(self) -> text:
        """Get summary.

        Returns:
            Human-readable summary

        Example:
            callback.summary()
            # → "ProcessCallback: Idle"
        """
        val name = self.to_string()
        return "ProcessCallback: {name}"

pub enum ProjectionMode:
    Perspective = 0    # Perspective projection (3D)
    Orthogonal = 1     # Orthogonal projection (2D-like)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_perspective(self) -> bool:
        """Check if projection is perspective.

        Returns:
            true if Perspective variant

        Example:
            mode.is_perspective()  # → true
        """
        match self:
            case Perspective: return true
            case _: return false

    pub fn is_orthogonal(self) -> bool:
        """Check if projection is orthogonal.

        Returns:
            true if Orthogonal variant

        Example:
            mode.is_orthogonal()  # → false
        """
        match self:
            case Orthogonal: return true
            case _: return false

    pub fn to_string(self) -> text:
        """Convert to string.

        Returns:
            text representation

        Example:
            mode.to_string()  # → "Perspective"
        """
        match self:
            case Perspective: return "Perspective"
            case Orthogonal: return "Orthogonal"

    fn description() -> text:
        """Get projection mode description.

        Returns:
            Human-readable description

        Example:
            ProjectionMode.Perspective.description()
            # → "Perspective projection (3D depth perception)"
        """
        match self:
            case Perspective: return "Perspective projection (3D depth perception)"
            case Orthogonal: return "Orthogonal projection (2D-like, no depth distortion)"

    pub fn summary(self) -> text:
        """Get summary.

        Returns:
            Human-readable summary

        Example:
            mode.summary()
            # → "ProjectionMode: Perspective"
        """
        val name = self.to_string()
        return "ProjectionMode: {name}"

pub enum KeepAspectMode:
    Keep = 0       # Keep aspect ratio
    Cover = 1      # Cover viewport (crop if needed)
    Disabled = 2   # Stretch to fill

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_keep(self) -> bool:
        """Check if keeping aspect ratio.

        Returns:
            true if Keep variant

        Example:
            mode.is_keep()  # → true
        """
        match self:
            case Keep: return true
            case _: return false

    pub fn is_cover(self) -> bool:
        """Check if covering viewport.

        Returns:
            true if Cover variant

        Example:
            mode.is_cover()  # → false
        """
        match self:
            case Cover: return true
            case _: return false

    pub fn is_disabled(self) -> bool:
        """Check if aspect ratio is disabled (stretch).

        Returns:
            true if Disabled variant

        Example:
            mode.is_disabled()  # → false
        """
        match self:
            case Disabled: return true
            case _: return false

    pub fn preserves_aspect(self) -> bool:
        """Check if aspect ratio is preserved.

        Returns:
            true if Keep or Cover

        Example:
            mode.preserves_aspect()  # → true
        """
        match self:
            case Keep | Cover: return true
            case _: return false

    pub fn to_string(self) -> text:
        """Convert to string.

        Returns:
            text representation

        Example:
            mode.to_string()  # → "Keep"
        """
        match self:
            case Keep: return "Keep"
            case Cover: return "Cover"
            case Disabled: return "Disabled"

    fn description() -> text:
        """Get keep aspect mode description.

        Returns:
            Human-readable description

        Example:
            KeepAspectMode.Keep.description()
            # → "Keep aspect ratio (add black bars if needed)"
        """
        match self:
            case Keep: return "Keep aspect ratio (add black bars if needed)"
            case Cover: return "Cover viewport (crop content to fill, preserve aspect)"
            case Disabled: return "Stretch to fill viewport (distort aspect ratio)"

    pub fn summary(self) -> text:
        """Get summary.

        Returns:
            Human-readable summary

        Example:
            mode.summary()
            # → "KeepAspectMode: Keep"
        """
        val name = self.to_string()
        return "KeepAspectMode: {name}"

pub enum MSAA:
    Disabled = 0   # No MSAA
    X2 = 1         # 2x MSAA
    X4 = 2         # 4x MSAA
    X8 = 3         # 8x MSAA

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_disabled(self) -> bool:
        """Check if MSAA is disabled.

        Returns:
            true if Disabled variant

        Example:
            msaa.is_disabled()  # → false
        """
        match self:
            case Disabled: return true
            case _: return false

    pub fn is_enabled(self) -> bool:
        """Check if MSAA is enabled.

        Returns:
            true if not Disabled

        Example:
            msaa.is_enabled()  # → true
        """
        return not self.is_disabled()

    pub fn get_sample_count(self) -> i32:
        """Get MSAA sample count.

        Returns:
            Sample count (0, 2, 4, or 8)

        Example:
            msaa.get_sample_count()  # → 4
        """
        match self:
            case Disabled: return 0
            case X2: return 2
            case X4: return 4
            case X8: return 8

    pub fn to_string(self) -> text:
        """Convert to string.

        Returns:
            text representation

        Example:
            msaa.to_string()  # → "X4"
        """
        match self:
            case Disabled: return "Disabled"
            case X2: return "X2"
            case X4: return "X4"
            case X8: return "X8"

    fn description() -> text:
        """Get MSAA description.

        Returns:
            Human-readable description

        Example:
            MSAA.X4.description()
            # → "4x Multi-Sample Anti-Aliasing (4 samples per pixel)"
        """
        match self:
            case Disabled: return "No anti-aliasing (best performance)"
            case X2: return "2x Multi-Sample Anti-Aliasing (2 samples per pixel)"
            case X4: return "4x Multi-Sample Anti-Aliasing (4 samples per pixel)"
            case X8: return "8x Multi-Sample Anti-Aliasing (8 samples per pixel)"

    pub fn summary(self) -> text:
        """Get summary.

        Returns:
            Human-readable summary

        Example:
            msaa.summary()
            # → "MSAA: X4 (4 samples)"
        """
        val name = self.to_string()
        val samples = self.get_sample_count()
        return "MSAA: {name} ({samples} samples)"

pub enum ScreenSpaceAA:
    Disabled = 0   # No AA
    FXAA = 1       # Fast Approximate Anti-Aliasing

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_disabled(self) -> bool:
        """Check if screen space AA is disabled.

        Returns:
            true if Disabled variant

        Example:
            aa.is_disabled()  # → false
        """
        match self:
            case Disabled: return true
            case _: return false

    pub fn is_fxaa(self) -> bool:
        """Check if using FXAA.

        Returns:
            true if FXAA variant

        Example:
            aa.is_fxaa()  # → true
        """
        match self:
            case FXAA: return true
            case _: return false

    pub fn is_enabled(self) -> bool:
        """Check if screen space AA is enabled.

        Returns:
            true if not Disabled

        Example:
            aa.is_enabled()  # → true
        """
        return not self.is_disabled()

    pub fn to_string(self) -> text:
        """Convert to string.

        Returns:
            text representation

        Example:
            aa.to_string()  # → "FXAA"
        """
        match self:
            case Disabled: return "Disabled"
            case FXAA: return "FXAA"

    fn description() -> text:
        """Get screen space AA description.

        Returns:
            Human-readable description

        Example:
            ScreenSpaceAA.FXAA.description()
            # → "Fast Approximate Anti-Aliasing (post-process, cheaper than MSAA)"
        """
        match self:
            case Disabled: return "No screen-space anti-aliasing"
            case FXAA: return "Fast Approximate Anti-Aliasing (post-process, cheaper than MSAA)"

    pub fn summary(self) -> text:
        """Get summary.

        Returns:
            Human-readable summary

        Example:
            aa.summary()
            # → "ScreenSpaceAA: FXAA"
        """
        val name = self.to_string()
        return "ScreenSpaceAA: {name}"


# Camera utilities

# Create a basic 2D camera with common settings
pub fn create_2d_camera(smooth: bool = true, zoom: f64 = 1.0) -> Camera2D:
    val ptr = ffi.godot_new_object("Camera2D")
    var cam = Camera2D.from_ptr(ptr)

    if smooth:
        cam.set_position_smoothing_enabled(true)
        cam.set_position_smoothing_speed(5.0)

    cam.set_zoom(zoom, zoom)
    cam.make_current()

    return cam

# Create a basic 3D camera with common settings
pub fn create_3d_camera(fov: f64 = 75.0, near: f64 = 0.1, far: f64 = 1000.0) -> Camera3D:
    val ptr = ffi.godot_new_object("Camera3D")
    var cam = Camera3D.from_ptr(ptr)

    cam.set_projection(ProjectionMode.Perspective)
    cam.set_fov(fov)
    cam.set_near(near)
    cam.set_far(far)
    cam.make_current()

    return cam

# Create an orthogonal 3D camera (for 2.5D games)
pub fn create_orthogonal_camera(size: f64 = 10.0) -> Camera3D:
    val ptr = ffi.godot_new_object("Camera3D")
    var cam = Camera3D.from_ptr(ptr)

    cam.set_projection(ProjectionMode.Orthogonal)
    cam.set_size(size)
    cam.make_current()

    return cam
