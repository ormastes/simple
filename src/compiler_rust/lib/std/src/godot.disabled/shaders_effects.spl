# Godot Shader Effects and Programs
#
# Shader builder, uniform types, helper functions, and preset shaders
#
# Features:
# - ShaderBuilder (fluent API for creating shaders)
# - ShaderUniform (uniform parameter definition)
# - UniformType (GLSL type enumeration)
# - Helper functions (mode/type conversions)
# - Preset shaders (color, scrolling texture, dissolve, outline, hologram)

use godot.ffi
use godot.variant
use godot.resource

mod shaders


# Shader Builder
# Fluent API for creating shaders
pub struct ShaderBuilder:
    mode: ShaderMode
    vertex_code: text
    fragment_code: text
    light_code: text
    uniforms: Array<ShaderUniform>

impl ShaderBuilder:
    # Create new builder
    pub fn new(mode: ShaderMode) -> ShaderBuilder:
        return ShaderBuilder(
            mode: mode,
            vertex_code: "",
            fragment_code: "",
            light_code: "",
            uniforms: []
        )

    # Add uniform parameter
    pub fn uniform(mut self, name: text, uniform_type: UniformType, default_value: text = "") -> ShaderBuilder:
        val uniform = ShaderUniform(
            name: name,
            uniform_type: uniform_type,
            default_value: default_value
        )
        self.uniforms.push(uniform)
        return self

    # Set vertex shader code
    pub fn vertex(mut self, code: text) -> ShaderBuilder:
        self.vertex_code = code
        return self

    # Set fragment shader code
    pub fn fragment(mut self, code: text) -> ShaderBuilder:
        self.fragment_code = code
        return self

    # Set light shader code (for lit materials)
    pub fn light(mut self, code: text) -> ShaderBuilder:
        self.light_code = code
        return self

    # Build final shader
    pub fn build(self) -> Shader:
        var shader = Shader.new()

        # Build shader code
        var code = "shader_type {shader_mode_to_string(self.mode)};\n\n"

        # Add uniforms
        for uniform in self.uniforms:
            code += "uniform {uniform_type_to_string(uniform.uniform_type)} {uniform.name}"
            if uniform.default_value != "":
                code += " = {uniform.default_value}"
            code += ";\n"

        code += "\n"

        # Add vertex shader
        if self.vertex_code != "":
            code += "void vertex() {\n"
            code += self.vertex_code
            code += "\n}\n\n"

        # Add fragment shader
        if self.fragment_code != "":
            code += "void fragment() {\n"
            code += self.fragment_code
            code += "\n}\n\n"

        # Add light shader
        if self.light_code != "":
            code += "void light() {\n"
            code += self.light_code
            code += "\n}\n"

        shader.set_code(code)
        return shader


# Shader Uniform
struct ShaderUniform:
    name: text
    uniform_type: UniformType
    default_value: text


# Uniform Types
pub enum UniformType:
    f32
    Vec2
    Vec3
    Vec4
    Color
    i32
    UInt
    bool
    Sampler2D
    Sampler3D
    SamplerCube
    Mat2
    Mat3
    Mat4

impl UniformType:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_float(self) -> bool:
        """Check if this is f32 type.

        Returns:
            true for f32

        Example:
            UniformType.f32.is_float()  # → true
        """
        self == UniformType.f32

    pub fn is_vec2(self) -> bool:
        """Check if this is Vec2 type.

        Returns:
            true for Vec2

        Example:
            UniformType.Vec2.is_vec2()  # → true
        """
        self == UniformType.Vec2

    pub fn is_vec3(self) -> bool:
        """Check if this is Vec3 type.

        Returns:
            true for Vec3

        Example:
            UniformType.Vec3.is_vec3()  # → true
        """
        self == UniformType.Vec3

    pub fn is_vec4(self) -> bool:
        """Check if this is Vec4 type.

        Returns:
            true for Vec4

        Example:
            UniformType.Vec4.is_vec4()  # → true
        """
        self == UniformType.Vec4

    pub fn is_color(self) -> bool:
        """Check if this is Color type.

        Returns:
            true for Color

        Example:
            UniformType.Color.is_color()  # → true
        """
        self == UniformType.Color

    pub fn is_int(self) -> bool:
        """Check if this is i32 type.

        Returns:
            true for i32

        Example:
            UniformType.i32.is_int()  # → true
        """
        self == UniformType.i32

    pub fn is_uint(self) -> bool:
        """Check if this is UInt type.

        Returns:
            true for UInt

        Example:
            UniformType.UInt.is_uint()  # → true
        """
        self == UniformType.UInt

    pub fn is_bool(self) -> bool:
        """Check if this is bool type.

        Returns:
            true for bool

        Example:
            UniformType.bool.is_bool()  # → true
        """
        self == UniformType.bool

    pub fn is_sampler2d(self) -> bool:
        """Check if this is Sampler2D type.

        Returns:
            true for Sampler2D

        Example:
            UniformType.Sampler2D.is_sampler2d()  # → true
        """
        self == UniformType.Sampler2D

    pub fn is_sampler3d(self) -> bool:
        """Check if this is Sampler3D type.

        Returns:
            true for Sampler3D

        Example:
            UniformType.Sampler3D.is_sampler3d()  # → true
        """
        self == UniformType.Sampler3D

    pub fn is_sampler_cube(self) -> bool:
        """Check if this is SamplerCube type.

        Returns:
            true for SamplerCube

        Example:
            UniformType.SamplerCube.is_sampler_cube()  # → true
        """
        self == UniformType.SamplerCube

    pub fn is_mat2(self) -> bool:
        """Check if this is Mat2 type.

        Returns:
            true for Mat2

        Example:
            UniformType.Mat2.is_mat2()  # → true
        """
        self == UniformType.Mat2

    pub fn is_mat3(self) -> bool:
        """Check if this is Mat3 type.

        Returns:
            true for Mat3

        Example:
            UniformType.Mat3.is_mat3()  # → true
        """
        self == UniformType.Mat3

    pub fn is_mat4(self) -> bool:
        """Check if this is Mat4 type.

        Returns:
            true for Mat4

        Example:
            UniformType.Mat4.is_mat4()  # → true
        """
        self == UniformType.Mat4

    pub fn is_scalar(self) -> bool:
        """Check if type is scalar.

        Returns:
            true for f32, i32, UInt, bool

        Example:
            UniformType.f32.is_scalar()  # → true
            UniformType.Vec3.is_scalar()  # → false
        """
        self == UniformType.f32 or self == UniformType.i32 or
        self == UniformType.UInt or self == UniformType.bool

    pub fn is_vector(self) -> bool:
        """Check if type is vector.

        Returns:
            true for Vec2, Vec3, Vec4, Color

        Example:
            UniformType.Vec3.is_vector()  # → true
        """
        self == UniformType.Vec2 or self == UniformType.Vec3 or
        self == UniformType.Vec4 or self == UniformType.Color

    pub fn is_matrix(self) -> bool:
        """Check if type is matrix.

        Returns:
            true for Mat2, Mat3, Mat4

        Example:
            UniformType.Mat4.is_matrix()  # → true
        """
        self == UniformType.Mat2 or self == UniformType.Mat3 or self == UniformType.Mat4

    pub fn is_sampler(self) -> bool:
        """Check if type is texture sampler.

        Returns:
            true for Sampler2D, Sampler3D, SamplerCube

        Example:
            UniformType.Sampler2D.is_sampler()  # → true
        """
        self == UniformType.Sampler2D or self == UniformType.Sampler3D or
        self == UniformType.SamplerCube

    pub fn is_numeric(self) -> bool:
        """Check if type is numeric.

        Returns:
            true for scalar, vector, or matrix types

        Example:
            UniformType.Vec3.is_numeric()  # → true
            UniformType.Sampler2D.is_numeric()  # → false
        """
        self.is_scalar() or self.is_vector() or self.is_matrix()

    pub fn component_count(self) -> i32:
        """Get number of components.

        Returns:
            Component count

        Example:
            UniformType.Vec3.component_count()  # → 3
            UniformType.Mat4.component_count()  # → 16
        """
        if self == UniformType.f32 or self == UniformType.i32 or
           self == UniformType.UInt or self == UniformType.bool:
            1
        elif self == UniformType.Vec2:
            2
        elif self == UniformType.Vec3:
            3
        elif self == UniformType.Vec4 or self == UniformType.Color:
            4
        elif self == UniformType.Mat2:
            4
        elif self == UniformType.Mat3:
            9
        elif self == UniformType.Mat4:
            16
        else:
            0

    pub fn to_string(self) -> text:
        """Convert uniform type to string.

        Returns:
            GLSL type name

        Example:
            UniformType.Vec3.to_string()  # → "vec3"
        """
        uniform_type_to_string(self)

    pub fn description(self) -> text:
        """Get uniform type description.

        Returns:
            Human-readable description

        Example:
            UniformType.Sampler2D.description()
            # → "2D texture sampler"
        """
        if self == UniformType.f32:
            "Single precision floating point"
        elif self == UniformType.Vec2:
            "2D vector (x, y)"
        elif self == UniformType.Vec3:
            "3D vector (x, y, z)"
        elif self == UniformType.Vec4:
            "4D vector (x, y, z, w)"
        elif self == UniformType.Color:
            "Color (r, g, b, a)"
        elif self == UniformType.i32:
            "Signed integer"
        elif self == UniformType.UInt:
            "Unsigned integer"
        elif self == UniformType.bool:
            "Boolean value"
        elif self == UniformType.Sampler2D:
            "2D texture sampler"
        elif self == UniformType.Sampler3D:
            "3D texture sampler"
        elif self == UniformType.SamplerCube:
            "Cubemap texture sampler"
        elif self == UniformType.Mat2:
            "2x2 matrix"
        elif self == UniformType.Mat3:
            "3x3 matrix"
        elif self == UniformType.Mat4:
            "4x4 matrix"
        else:
            "Unknown type"

    pub fn summary(self) -> text:
        """Get summary of uniform type.

        Returns:
            Human-readable summary

        Example:
            UniformType.Vec3.summary()
            # → "UniformType: vec3 (vector, numeric, 3 components)"
        """
        val name = self.to_string()
        var attrs: Array<text> = []

        if self.is_scalar():
            attrs.push("scalar")
        if self.is_vector():
            attrs.push("vector")
        if self.is_matrix():
            attrs.push("matrix")
        if self.is_sampler():
            attrs.push("sampler")
        if self.is_numeric():
            attrs.push("numeric")

        val components = self.component_count()
        if components > 0:
            attrs.push("{components} components")

        val attrs_str = attrs.join(", ")
        return "UniformType: {name} ({attrs_str})"


# Helper functions

fn shader_mode_from_int(value: i32) -> ShaderMode:
    if value == 0:
        return ShaderMode.Spatial
    elif value == 1:
        return ShaderMode.CanvasItem
    elif value == 2:
        return ShaderMode.Particles
    elif value == 3:
        return ShaderMode.Sky
    elif value == 4:
        return ShaderMode.Fog
    else:
        return ShaderMode.Spatial

fn shader_mode_to_string(mode: ShaderMode) -> text:
    if mode == ShaderMode.Spatial:
        return "spatial"
    elif mode == ShaderMode.CanvasItem:
        return "canvas_item"
    elif mode == ShaderMode.Particles:
        return "particles"
    elif mode == ShaderMode.Sky:
        return "sky"
    elif mode == ShaderMode.Fog:
        return "fog"
    else:
        return "spatial"

fn uniform_type_to_string(uniform_type: UniformType) -> text:
    if uniform_type == UniformType.f32:
        return "f32"
    elif uniform_type == UniformType.Vec2:
        return "vec2"
    elif uniform_type == UniformType.Vec3:
        return "vec3"
    elif uniform_type == UniformType.Vec4:
        return "vec4"
    elif uniform_type == UniformType.Color:
        return "vec4"
    elif uniform_type == UniformType.i32:
        return "i32"
    elif uniform_type == UniformType.UInt:
        return "uint"
    elif uniform_type == UniformType.bool:
        return "bool"
    elif uniform_type == UniformType.Sampler2D:
        return "sampler2D"
    elif uniform_type == UniformType.Sampler3D:
        return "sampler3D"
    elif uniform_type == UniformType.SamplerCube:
        return "samplerCube"
    elif uniform_type == UniformType.Mat2:
        return "mat2"
    elif uniform_type == UniformType.Mat3:
        return "mat3"
    elif uniform_type == UniformType.Mat4:
        return "mat4"
    else:
        return "f32"


# Preset Shaders

# Simple color shader
pub fn create_color_shader() -> Shader:
    return ShaderBuilder.new(ShaderMode.Spatial)
        .uniform("albedo", UniformType.Color, "vec4(1.0, 1.0, 1.0, 1.0)")
        .fragment("    ALBEDO = albedo.rgb;")
        .build()

# Texture shader with UV scrolling
pub fn create_scrolling_texture_shader() -> Shader:
    return ShaderBuilder.new(ShaderMode.CanvasItem)
        .uniform("texture_albedo", UniformType.Sampler2D)
        .uniform("scroll_speed", UniformType.Vec2, "vec2(0.1, 0.0)")
        .fragment(
            "    vec2 uv = UV + scroll_speed * TIME;\n" +
            "    COLOR = texture(texture_albedo, uv);"
        )
        .build()

# Dissolve shader
pub fn create_dissolve_shader() -> Shader:
    return ShaderBuilder.new(ShaderMode.Spatial)
        .uniform("dissolve_texture", UniformType.Sampler2D)
        .uniform("dissolve_amount", UniformType.f32, "0.0")
        .fragment(
            "    f32 dissolve = texture(dissolve_texture, UV).r;\n" +
            "    if (dissolve < dissolve_amount) {\n" +
            "        discard;\n" +
            "    }\n" +
            "    ALBEDO = vec3(1.0);"
        )
        .build()

# Outline shader
pub fn create_outline_shader() -> Shader:
    return ShaderBuilder.new(ShaderMode.Spatial)
        .uniform("outline_color", UniformType.Color, "vec4(0.0, 0.0, 0.0, 1.0)")
        .uniform("outline_width", UniformType.f32, "0.03")
        .vertex(
            "    VERTEX += NORMAL * outline_width;"
        )
        .fragment(
            "    ALBEDO = outline_color.rgb;\n" +
            "    ALPHA = outline_color.a;"
        )
        .build()

# Hologram shader
pub fn create_hologram_shader() -> Shader:
    return ShaderBuilder.new(ShaderMode.Spatial)
        .uniform("hologram_color", UniformType.Color, "vec4(0.0, 1.0, 1.0, 0.5)")
        .uniform("scan_speed", UniformType.f32, "2.0")
        .uniform("scan_width", UniformType.f32, "0.1")
        .fragment(
            "    f32 scan = sin(UV.y * 20.0 - TIME * scan_speed);\n" +
            "    f32 scan_line = step(1.0 - scan_width, scan);\n" +
            "    vec3 color = hologram_color.rgb + scan_line * 0.5;\n" +
            "    ALBEDO = color;\n" +
            "    ALPHA = hologram_color.a;\n" +
            "    EMISSION = color * 0.5;"
        )
        .build()


# Array placeholder
pub struct Array<T>:
    items: Vec<T>

impl<T> Array<T>:
    pub fn push(mut self, item: T):
        pass
