# Godot Particle Systems
#
# Type-safe wrappers for Godot's particle systems
#
# Features:
# - GPUParticles2D (GPU-accelerated 2D particles)
# - CPUParticles2D (CPU-based 2D particles)
# - ParticleMaterial (particle behavior)
# - Emission shapes and parameters
#
# Based on: https://docs.godotengine.org/en/stable/classes/class_gpuparticles2d.html
#
# Split into:
# - particles_sim.spl (EmissionShape, ParticleBuilder, ParticleType, preset effects)

use godot.ffi
use godot.variant
use godot.node2d
use godot.resource

mod particles

# GPU Particles 2D
# Hardware-accelerated particle system
pub struct GPUParticles2D extends godot.node2d.Node2D:

impl GPUParticles2D:
    # Create from Godot object pointer
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> GPUParticles2D:
        return GPUParticles2D(base: godot.node2d.Node2D.from_ptr(ptr))

    # Set emitting state
    pub fn set_emitting(mut self, emitting: bool):
        val obj = self.base.as_node().as_object()
        val emit_var = variant.Variant.from_bool(emitting)
        obj.call1("set_emitting", emit_var)

    # Check if emitting
    pub fn is_emitting(self) -> bool:
        val obj = self.base.as_node().as_object()
        val result = obj.call0("is_emitting")
        return result.as_bool()

    # Set number of particles
    pub fn set_amount(mut self, amount: i32):
        val obj = self.base.as_node().as_object()
        val amount_var = variant.Variant.from_int(amount as i64)
        obj.call1("set_amount", amount_var)

    # Get number of particles
    pub fn get_amount(self) -> i32:
        val obj = self.base.as_node().as_object()
        val result = obj.call0("get_amount")
        return result.as_int() as i32

    # Set particle lifetime
    pub fn set_lifetime(mut self, seconds: f64):
        val obj = self.base.as_node().as_object()
        val time_var = variant.Variant.from_float(seconds)
        obj.call1("set_lifetime", time_var)

    # Get particle lifetime
    pub fn get_lifetime(self) -> f64:
        val obj = self.base.as_node().as_object()
        val result = obj.call0("get_lifetime")
        return result.as_float()

    # Set one-shot mode
    pub fn set_one_shot(mut self, enable: bool):
        val obj = self.base.as_node().as_object()
        val enable_var = variant.Variant.from_bool(enable)
        obj.call1("set_one_shot", enable_var)

    # Get one-shot mode
    pub fn is_one_shot(self) -> bool:
        val obj = self.base.as_node().as_object()
        val result = obj.call0("get_one_shot")
        return result.as_bool()

    # Set preprocess time (simulation warmup)
    pub fn set_pre_process_time(mut self, seconds: f64):
        val obj = self.base.as_node().as_object()
        val time_var = variant.Variant.from_float(seconds)
        obj.call1("set_pre_process_time", time_var)

    # Set particle speed scale
    pub fn set_speed_scale(mut self, scale: f64):
        val obj = self.base.as_node().as_object()
        val scale_var = variant.Variant.from_float(scale)
        obj.call1("set_speed_scale", scale_var)

    # Set process material (ParticleMaterial)
    pub fn set_process_material(mut self, material: resource.Resource):
        val obj = self.base.as_node().as_object()
        val mat_var = variant.Variant.from_object(material.as_object())
        obj.call1("set_process_material", mat_var)

    # Set texture for particles
    pub fn set_texture(mut self, texture: resource.Resource):
        val obj = self.base.as_node().as_object()
        val tex_var = variant.Variant.from_object(texture.as_object())
        obj.call1("set_texture", tex_var)

    # Restart emission
    pub fn restart(mut self):
        val obj = self.base.as_node().as_object()
        obj.call0("restart")

    # Set fixed FPS (0 = variable)
    pub fn set_fixed_fps(mut self, fps: i32):
        val obj = self.base.as_node().as_object()
        val fps_var = variant.Variant.from_int(fps as i64)
        obj.call1("set_fixed_fps", fps_var)

    # Set draw order
    pub fn set_draw_order(mut self, order: DrawOrder):
        val obj = self.base.as_node().as_object()
        val order_var = variant.Variant.from_int(order as i64)
        obj.call1("set_draw_order", order_var)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn start(mut self):
        """Start emitting particles.

        Example:
            particles.start()
        """
        self.set_emitting(true)

    pub fn stop(mut self):
        """Stop emitting particles.

        Example:
            particles.stop()
        """
        self.set_emitting(false)

    pub fn is_stopped(self) -> bool:
        """Check if particles are stopped (not emitting).

        Returns:
            true if not emitting

        Example:
            particles.is_stopped()  # → false
        """
        return not self.is_emitting()

    pub fn get_particle_count(self) -> i32:
        """Get number of particles (alias for get_amount).

        Returns:
            Particle count

        Example:
            particles.get_particle_count()  # → 100
        """
        return self.get_amount()

    pub fn enable_one_shot(mut self):
        """Enable one-shot mode.

        Example:
            particles.enable_one_shot()
        """
        self.set_one_shot(true)

    pub fn disable_one_shot(mut self):
        """Disable one-shot mode.

        Example:
            particles.disable_one_shot()
        """
        self.set_one_shot(false)

    pub fn summary(self) -> text:
        """Get GPU particles 2D summary.

        Returns:
            Human-readable summary

        Example:
            particles.summary()
            # → "GPUParticles2D: emitting, 100 particles"
        """
        val state = if self.is_emitting() { "emitting" } else { "stopped" }
        val count = self.get_amount()
        return "GPUParticles2D: {state}, {count} particles"


# CPU Particles 2D
# CPU-based particle system (fallback/lightweight)
pub struct CPUParticles2D extends godot.node2d.Node2D:

impl CPUParticles2D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> CPUParticles2D:
        return CPUParticles2D(base: godot.node2d.Node2D.from_ptr(ptr))

    # Set emitting state
    pub fn set_emitting(mut self, emitting: bool):
        val obj = self.base.as_node().as_object()
        val emit_var = variant.Variant.from_bool(emitting)
        obj.call1("set_emitting", emit_var)

    # Check if emitting
    pub fn is_emitting(self) -> bool:
        val obj = self.base.as_node().as_object()
        val result = obj.call0("is_emitting")
        return result.as_bool()

    # Set number of particles
    pub fn set_amount(mut self, amount: i32):
        val obj = self.base.as_node().as_object()
        val amount_var = variant.Variant.from_int(amount as i64)
        obj.call1("set_amount", amount_var)

    # Set particle lifetime
    pub fn set_lifetime(mut self, seconds: f64):
        val obj = self.base.as_node().as_object()
        val time_var = variant.Variant.from_float(seconds)
        obj.call1("set_lifetime", time_var)

    # Set one-shot mode
    pub fn set_one_shot(mut self, enable: bool):
        val obj = self.base.as_node().as_object()
        val enable_var = variant.Variant.from_bool(enable)
        obj.call1("set_one_shot", enable_var)

    # Set emission shape
    pub fn set_emission_shape(mut self, shape: EmissionShape):
        val obj = self.base.as_node().as_object()
        val shape_var = variant.Variant.from_int(shape as i64)
        obj.call1("set_emission_shape", shape_var)

    # Set emission sphere radius
    pub fn set_emission_sphere_radius(mut self, radius: f32):
        val obj = self.base.as_node().as_object()
        val radius_var = variant.Variant.from_float(radius as f64)
        obj.call1("set_emission_sphere_radius", radius_var)

    # Set emission rect extents
    pub fn set_emission_rect_extents(mut self, width: f32, height: f32):
        val obj = self.base.as_node().as_object()
        val extents_var = variant.Variant.from_vector2(width as f64, height as f64)
        obj.call1("set_emission_rect_extents", extents_var)

    # Set direction
    pub fn set_direction(mut self, x: f32, y: f32):
        val obj = self.base.as_node().as_object()
        val dir_var = variant.Variant.from_vector2(x as f64, y as f64)
        obj.call1("set_direction", dir_var)

    # Set spread (angle in degrees)
    pub fn set_spread(mut self, degrees: f32):
        val obj = self.base.as_node().as_object()
        val spread_var = variant.Variant.from_float(degrees as f64)
        obj.call1("set_param", spread_var)

    # Set gravity
    pub fn set_gravity(mut self, x: f32, y: f32):
        val obj = self.base.as_node().as_object()
        val gravity_var = variant.Variant.from_vector2(x as f64, y as f64)
        obj.call1("set_gravity", gravity_var)

    # Set initial velocity (min/max)
    pub fn set_initial_velocity_min(mut self, velocity: f32):
        val obj = self.base.as_node().as_object()
        val vel_var = variant.Variant.from_float(velocity as f64)
        obj.call1("set_param_min", vel_var)

    pub fn set_initial_velocity_max(mut self, velocity: f32):
        val obj = self.base.as_node().as_object()
        val vel_var = variant.Variant.from_float(velocity as f64)
        obj.call1("set_param_max", vel_var)

    # Set angular velocity (rotation speed)
    pub fn set_angular_velocity_min(mut self, degrees_per_sec: f32):
        val obj = self.base.as_node().as_object()
        val vel_var = variant.Variant.from_float(degrees_per_sec as f64)
        # obj.call2("set_param_min", param_type, vel_var)

    # Set scale (particle size)
    pub fn set_scale_amount_min(mut self, scale: f32):
        val obj = self.base.as_node().as_object()
        val scale_var = variant.Variant.from_float(scale as f64)
        # obj.call2("set_param_min", param_type, scale_var)

    pub fn set_scale_amount_max(mut self, scale: f32):
        val obj = self.base.as_node().as_object()
        val scale_var = variant.Variant.from_float(scale as f64)
        # obj.call2("set_param_max", param_type, scale_var)

    # Set color
    pub fn set_color(mut self, r: f32, g: f32, b: f32, a: f32):
        val obj = self.base.as_node().as_object()
        val color_var = variant.Variant.from_color(r, g, b, a)
        obj.call1("set_color", color_var)

    # Set texture
    pub fn set_texture(mut self, texture: resource.Resource):
        val obj = self.base.as_node().as_object()
        val tex_var = variant.Variant.from_object(texture.as_object())
        obj.call1("set_texture", tex_var)

    # Restart emission
    pub fn restart(mut self):
        val obj = self.base.as_node().as_object()
        obj.call0("restart")

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn start(mut self):
        """Start emitting particles.

        Example:
            particles.start()
        """
        self.set_emitting(true)

    pub fn stop(mut self):
        """Stop emitting particles.

        Example:
            particles.stop()
        """
        self.set_emitting(false)

    pub fn is_stopped(self) -> bool:
        """Check if particles are stopped (not emitting).

        Returns:
            true if not emitting

        Example:
            particles.is_stopped()  # → false
        """
        return not self.is_emitting()

    pub fn enable_one_shot(mut self):
        """Enable one-shot mode.

        Example:
            particles.enable_one_shot()
        """
        self.set_one_shot(true)

    pub fn disable_one_shot(mut self):
        """Disable one-shot mode.

        Example:
            particles.disable_one_shot()
        """
        self.set_one_shot(false)

    pub fn summary(self) -> text:
        """Get CPU particles 2D summary.

        Returns:
            Human-readable summary

        Example:
            particles.summary()
            # → "CPUParticles2D: emitting"
        """
        val state = if self.is_emitting() { "emitting" } else { "stopped" }
        return "CPUParticles2D: {state}"


# Draw Order
pub enum DrawOrder:
    Index = 0       # By index
    Lifetime = 1    # By remaining lifetime
    ReverseLifetime = 2  # By elapsed time

impl DrawOrder:
    pub fn to_string(self) -> text:
        """Convert draw order to string."""
        match self:
            case Index: "index"
            case Lifetime: "lifetime"
            case ReverseLifetime: "reverse-lifetime"

    pub fn description(self) -> text:
        """Get draw order description."""
        match self:
            case Index: "Draw particles by creation index"
            case Lifetime: "Draw by remaining lifetime (oldest last)"
            case ReverseLifetime: "Draw by elapsed time (newest last)"

    pub fn is_index(self) -> bool:
        """Check if draw order is Index."""
        match self:
            case Index: true
            case _: false

    pub fn is_lifetime(self) -> bool:
        """Check if draw order is Lifetime."""
        match self:
            case Lifetime: true
            case _: false

    pub fn is_reverse_lifetime(self) -> bool:
        """Check if draw order is ReverseLifetime."""
        match self:
            case ReverseLifetime: true
            case _: false

    pub fn is_time_based(self) -> bool:
        """Check if draw order is time-based."""
        match self:
            case Lifetime: true
            case ReverseLifetime: true
            case _: false

    pub fn summary(self) -> text:
        """Get draw order summary."""
        val name = self.to_string()
        val desc = self.description()
        var props = []
        if self.is_time_based():
            props.push("time-based")
        if props.len() > 0:
            val props_str = ", ".join(props)
            return "DrawOrder: {name} ({desc}, {props_str})"
        else:
            return "DrawOrder: {name} ({desc})"


# EmissionShape forward reference (defined in particles_sim.spl)
pub enum EmissionShape:
    Point = 0
    Sphere = 1
    Box = 2
    Points = 3
    DirectedPoints = 4
