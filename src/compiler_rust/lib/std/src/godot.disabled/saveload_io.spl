# Godot Save/Load I/O and Management
#
# High-level save game management and settings persistence
#
# Features:
# - SaveGameManager (slot-based save/load API)
# - SaveData (player and progress data structure)
# - SettingsManager (persistent game settings)

use godot.ffi
use godot.variant

mod saveload


# Save Game Manager
# High-level save/load API
pub struct SaveGameManager:
    save_dir: text
    current_slot: i32

impl SaveGameManager:
    # Create new save manager
    pub fn new(save_dir: text = "user://saves/") -> SaveGameManager:
        return SaveGameManager(save_dir: save_dir, current_slot: 0)

    # Get save file path
    fn get_save_path(slot: i32) -> text:
        return "{self.save_dir}save_{slot}.cfg"

    # Save game state
    pub fn save_game(mut self, slot: i32, data: SaveData) -> Result<(), text>:
        var config = ConfigFile.new()

        # Player data
        config.set_value("player", "name", variant.Variant.from_string(data.player_name))
        config.set_value("player", "level", variant.Variant.from_int(data.player_level as i64))
        config.set_value("player", "health", variant.Variant.from_int(data.player_health as i64))
        config.set_value("player", "position_x", variant.Variant.from_float(data.position_x))
        config.set_value("player", "position_y", variant.Variant.from_float(data.position_y))

        # Game progress
        config.set_value("progress", "current_scene", variant.Variant.from_string(data.current_scene))
        config.set_value("progress", "playtime", variant.Variant.from_float(data.playtime))

        # Save to file
        val path = self.get_save_path(slot)
        val result = config.save(path)

        if result.is_ok():
            self.current_slot = slot
            println("Game saved to slot {slot}")
            return Ok(())
        else:
            return Err(result.unwrap_err())

    # Load game state
    pub fn load_game(mut self, slot: i32) -> Result<SaveData, text>:
        val path = self.get_save_path(slot)
        val result = ConfigFile.load(path)

        if result.is_err():
            return Err(result.unwrap_err())

        val config = result.unwrap()

        # Load player data
        val default_str = variant.Variant.from_string("")
        val default_int = variant.Variant.from_int(0)
        val default_float = variant.Variant.from_float(0.0)

        val name = config.get_value("player", "name", default_str).as_string()
        val level = config.get_value("player", "level", default_int).as_int() as i32
        val health = config.get_value("player", "health", default_int).as_int() as i32
        val pos_x = config.get_value("player", "position_x", default_float).as_float()
        val pos_y = config.get_value("player", "position_y", default_float).as_float()

        # Load progress
        val scene = config.get_value("progress", "current_scene", default_str).as_string()
        val playtime = config.get_value("progress", "playtime", default_float).as_float()

        val data = SaveData(
            player_name: name,
            player_level: level,
            player_health: health,
            position_x: pos_x,
            position_y: pos_y,
            current_scene: scene,
            playtime: playtime
        )

        self.current_slot = slot
        println("Game loaded from slot {slot}")

        return Ok(data)

    # Check if save exists
    pub fn has_save(self, slot: i32) -> bool:
        val path = self.get_save_path(slot)
        return FileAccess.file_exists(path)

    # Delete save
    pub fn delete_save(mut self, slot: i32) -> Result<(), text>:
        """Delete a save file.

        Args:
            slot: Save slot number

        Returns:
            Ok if successful, Err with message if failed
        """
        @extern("runtime", "rt_file_remove")
        fn _rt_file_remove(path_ptr: &u8, path_len: u64) -> bool

        val path = self.get_save_path(slot)
        val success = _rt_file_remove(path.ptr(), path.len())

        if success:
            return Ok(())
        else:
            return Err("Failed to delete save file: {path}")

    # Get all save slots
    pub fn get_save_slots(self) -> Array<i32>:
        var slots: Array<i32> = []

        for i in range(0, 10):
            if self.has_save(i):
                slots.push(i)

        return slots

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_slot_empty(slot: i32) -> bool:
        """Check if save slot is empty (no save file).

        Args:
            slot: Save slot number

        Returns:
            true if slot is empty

        Example:
            manager.is_slot_empty(0)  # → false
        """
        return not self.has_save(slot)

    me try_save_game(slot: i32, data: SaveData) -> bool:
        """Try to save game, returning true on success.

        Args:
            slot: Save slot number
            data: Save data to write

        Returns:
            true if saved successfully

        Example:
            manager.try_save_game(0, data)  # → true
        """
        return self.save_game(slot, data).is_ok()

    me try_load_game(slot: i32) -> Option<SaveData>:
        """Try to load game, returning None on failure.

        Args:
            slot: Save slot number

        Returns:
            Option containing save data or None

        Example:
            if val Some(data) = manager.try_load_game(0):
                # Use data
        """
        val result = self.load_game(slot)
        if result.is_ok():
            return Some(result.unwrap())
        else:
            return None

    me try_delete_save(slot: i32) -> bool:
        """Try to delete save, returning true on success.

        Args:
            slot: Save slot number

        Returns:
            true if deleted successfully

        Example:
            manager.try_delete_save(0)  # → true
        """
        return self.delete_save(slot).is_ok()

    fn get_current_slot() -> i32:
        """Get the currently active save slot.

        Returns:
            Current slot number

        Example:
            manager.get_current_slot()  # → 0
        """
        return self.current_slot

    fn has_any_saves() -> bool:
        """Check if there are any save files.

        Returns:
            true if at least one save exists

        Example:
            manager.has_any_saves()  # → true
        """
        return self.get_save_slots().len() > 0

    fn count_saves() -> i32:
        """Count the number of save files.

        Returns:
            Number of saves

        Example:
            manager.count_saves()  # → 3
        """
        return self.get_save_slots().len()

    fn summary() -> text:
        """Get save game manager summary.

        Returns:
            Human-readable summary

        Example:
            manager.summary()
            # → "SaveGameManager: 3 saves, current=0"
        """
        val count = self.count_saves()
        val current = self.current_slot
        return "SaveGameManager: {count} saves, current={current}"


# Save Data Structure
pub struct SaveData:
    # Player data
    player_name: text
    player_level: i32
    player_health: i32
    position_x: f64
    position_y: f64

    # Game progress
    current_scene: text
    playtime: f64


# Settings Manager
# Persistent game settings
pub struct SettingsManager:
    config: ConfigFile
    config_path: text

impl SettingsManager:
    # Create new settings manager
    pub fn new(config_path: text = "user://settings.cfg") -> SettingsManager:
        var config = ConfigFile.new()
        val _ = config.load_file(config_path)  # Ignore error if file doesn't exist

        return SettingsManager(config: config, config_path: config_path)

    # Get setting
    pub fn get_setting(self, key: text, default: variant.Variant) -> variant.Variant:
        return self.config.get_value("settings", key, default)

    # Set setting
    pub fn set_setting(mut self, key: text, value: variant.Variant):
        self.config.set_value("settings", key, value)

    # Save settings
    pub fn save(self) -> Result<(), text>:
        return self.config.save(self.config_path)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn get(key: text, default: variant.Variant) -> variant.Variant:
        """Get setting value (alias for get_setting).

        Args:
            key: Setting key
            default: Default value if not found

        Returns:
            Setting value or default

        Example:
            volume = settings.get("volume", Variant.from_int(100))
        """
        return self.get_setting(key, default)

    me set(key: text, value: variant.Variant):
        """Set setting value (alias for set_setting).

        Args:
            key: Setting key
            value: Setting value

        Example:
            settings.set("volume", Variant.from_int(80))
        """
        self.set_setting(key, value)

    fn try_save() -> bool:
        """Try to save settings, returning true on success.

        Returns:
            true if saved successfully

        Example:
            settings.try_save()  # → true
        """
        return self.save().is_ok()

    fn has_setting(key: text) -> bool:
        """Check if setting exists.

        Args:
            key: Setting key

        Returns:
            true if setting exists

        Example:
            settings.has_setting("volume")  # → true
        """
        return self.config.has_section_key("settings", key)

    fn summary() -> text:
        """Get settings manager summary.

        Returns:
            Human-readable summary

        Example:
            settings.summary()
            # → "SettingsManager: path=user://settings.cfg"
        """
        return "SettingsManager: path={self.config_path}"


# Array placeholder
pub struct Array<T>:
    items: Vec<T>

impl<T> Array<T>:
    pub fn push(mut self, item: T):
        pass
