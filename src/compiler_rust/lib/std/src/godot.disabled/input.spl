# Godot Input System
#
# Input handling for keyboard, mouse, and gamepad.
# Uses Godot's Input singleton for cross-platform input.
#
# Reference: https://docs.godotengine.org/en/stable/classes/class_input.html
#
# Split into:
# - input_handlers.spl (KeyCode, MouseButton, MouseMode, JoyButton, JoyAxis)

use godot.ffi
use godot.variant
use godot.object

# Input singleton wrapper
pub struct Input:
    singleton_ptr: ffi.GDExtensionObjectPtr

impl Input:
    # Get the Input singleton
    pub fn get_singleton() -> Input:
        val ptr = godot_get_singleton("Input")
        return Input(singleton_ptr: ptr)

    # Keyboard input
    pub fn is_key_pressed(self, keycode: KeyCode) -> bool:
        val key_var = variant.Variant.from_int(keycode as i64)
        val obj = object.Object.from_ptr(self.singleton_ptr)
        val result = obj.call1("is_key_pressed", key_var)
        return result.as_bool()

    pub fn is_key_just_pressed(self, keycode: KeyCode) -> bool:
        # Check if key was just pressed this frame
        val key_var = variant.Variant.from_int(keycode as i64)
        val obj = object.Object.from_ptr(self.singleton_ptr)
        val result = obj.call1("is_key_just_pressed", key_var)
        return result.as_bool()

    pub fn is_key_just_released(self, keycode: KeyCode) -> bool:
        val key_var = variant.Variant.from_int(keycode as i64)
        val obj = object.Object.from_ptr(self.singleton_ptr)
        val result = obj.call1("is_key_just_released", key_var)
        return result.as_bool()

    # Action-based input (configured in project settings)
    pub fn is_action_pressed(self, action: text) -> bool:
        val action_var = variant.Variant.from_string(action)
        val obj = object.Object.from_ptr(self.singleton_ptr)
        val result = obj.call1("is_action_pressed", action_var)
        return result.as_bool()

    pub fn is_action_just_pressed(self, action: text) -> bool:
        val action_var = variant.Variant.from_string(action)
        val obj = object.Object.from_ptr(self.singleton_ptr)
        val result = obj.call1("is_action_just_pressed", action_var)
        return result.as_bool()

    pub fn is_action_just_released(self, action: text) -> bool:
        val action_var = variant.Variant.from_string(action)
        val obj = object.Object.from_ptr(self.singleton_ptr)
        val result = obj.call1("is_action_just_released", action_var)
        return result.as_bool()

    pub fn get_action_strength(self, action: text) -> f64:
        val action_var = variant.Variant.from_string(action)
        val obj = object.Object.from_ptr(self.singleton_ptr)
        val result = obj.call1("get_action_strength", action_var)
        return result.as_float()

    # Mouse input
    pub fn get_mouse_position(self) -> (f64, f64):
        val obj = object.Object.from_ptr(self.singleton_ptr)
        val result = obj.call0("get_mouse_position")
        return result.as_vector2()

    pub fn is_mouse_button_pressed(self, button: MouseButton) -> bool:
        val button_var = variant.Variant.from_int(button as i64)
        val obj = object.Object.from_ptr(self.singleton_ptr)
        val result = obj.call1("is_mouse_button_pressed", button_var)
        return result.as_bool()

    # Mouse mode (visible, captured, hidden, etc.)
    pub fn set_mouse_mode(mut self, mode: MouseMode):
        val mode_var = variant.Variant.from_int(mode as i64)
        val obj = object.Object.from_ptr(self.singleton_ptr)
        obj.call1("set_mouse_mode", mode_var)

    pub fn get_mouse_mode(self) -> MouseMode:
        val obj = object.Object.from_ptr(self.singleton_ptr)
        val result = obj.call0("get_mouse_mode")
        return result.as_int() as MouseMode

    # Gamepad/Joypad input
    pub fn is_joy_button_pressed(self, device: i32, button: JoyButton) -> bool:
        val device_var = variant.Variant.from_int(device as i64)
        val button_var = variant.Variant.from_int(button as i64)
        val obj = object.Object.from_ptr(self.singleton_ptr)
        val result = obj.call2("is_joy_button_pressed", device_var, button_var)
        return result.as_bool()

    pub fn get_joy_axis(self, device: i32, axis: JoyAxis) -> f64:
        val device_var = variant.Variant.from_int(device as i64)
        val axis_var = variant.Variant.from_int(axis as i64)
        val obj = object.Object.from_ptr(self.singleton_ptr)
        val result = obj.call2("get_joy_axis", device_var, axis_var)
        return result.as_float()

    pub fn get_connected_joypads(self) -> Array<i32>:
        val obj = object.Object.from_ptr(self.singleton_ptr)
        val result = obj.call0("get_connected_joypads")
        # Convert array variant to Array<i32>
        var joypads: Array<i32> = Array<i32>.new()
        val array_size = result.call0("size").as_int()
        for i in 0..array_size:
            val idx_var = variant.Variant.from_int(i)
            val element = result.call1("get", idx_var)
            val joypad_id = element.as_int() as i32
            joypads.push(joypad_id)
        return joypads

    # Vibration (gamepad rumble)
    pub fn start_joy_vibration(mut self, device: i32, weak: f64, strong: f64, duration: f64):
        val device_var = variant.Variant.from_int(device as i64)
        val weak_var = variant.Variant.from_float(weak)
        val strong_var = variant.Variant.from_float(strong)
        val duration_var = variant.Variant.from_float(duration)

        val obj = object.Object.from_ptr(self.singleton_ptr)
        var args = Array<variant.Variant>.new()
        args.push(device_var)
        args.push(weak_var)
        args.push(strong_var)
        args.push(duration_var)
        obj.call("start_joy_vibration", args)

    pub fn stop_joy_vibration(mut self, device: i32):
        val device_var = variant.Variant.from_int(device as i64)
        val obj = object.Object.from_ptr(self.singleton_ptr)
        obj.call1("stop_joy_vibration", device_var)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn hide_mouse(mut self):
        """Hide mouse cursor.

        Example:
            input.hide_mouse()
        """
        self.set_mouse_mode(MouseMode.Hidden)

    pub fn show_mouse(mut self):
        """Show mouse cursor.

        Example:
            input.show_mouse()
        """
        self.set_mouse_mode(MouseMode.Visible)

    pub fn capture_mouse(mut self):
        """Capture mouse (confine to window).

        Example:
            input.capture_mouse()
        """
        self.set_mouse_mode(MouseMode.Captured)

    pub fn is_mouse_visible(self) -> bool:
        """Check if mouse is visible.

        Returns:
            true if MouseMode.Visible

        Example:
            input.is_mouse_visible()  # → true
        """
        return self.get_mouse_mode() == MouseMode.Visible

    pub fn is_mouse_hidden(self) -> bool:
        """Check if mouse is hidden.

        Returns:
            true if MouseMode.Hidden

        Example:
            input.is_mouse_hidden()  # → false
        """
        return self.get_mouse_mode() == MouseMode.Hidden

    pub fn is_mouse_captured(self) -> bool:
        """Check if mouse is captured.

        Returns:
            true if MouseMode.Captured

        Example:
            input.is_mouse_captured()  # → false
        """
        return self.get_mouse_mode() == MouseMode.Captured

    pub fn vibrate_gamepad(mut self, device: i32, intensity: f64, duration: f64):
        """Vibrate gamepad with uniform intensity.

        Args:
            device: Gamepad device index
            intensity: Vibration intensity (0.0-1.0)
            duration: Duration in seconds

        Example:
            input.vibrate_gamepad(0, 0.5, 0.2)
        """
        self.start_joy_vibration(device, intensity, intensity, duration)

    pub fn summary(self) -> text:
        """Get input system summary.

        Returns:
            Human-readable summary

        Example:
            input.summary()
            # → "Input: mouse visible"
        """
        val mouse_mode = if self.is_mouse_visible() {"mouse visible"} elif self.is_mouse_hidden() {
            "mouse hidden"
        } elif self.is_mouse_captured() {"mouse captured"} else {
            "mouse mode unknown"
        }
        return "Input: {mouse_mode}"

extern "C" fn godot_get_singleton(name: text) -> ffi.GDExtensionObjectPtr
