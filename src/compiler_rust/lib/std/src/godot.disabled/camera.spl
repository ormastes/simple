# Godot Camera System
#
# Type-safe wrappers for Godot's camera system
#
# Features:
# - Camera2D (2D camera with follow, zoom, limits)
# - Camera3D (3D camera with projection modes)
# - Viewport (render target and camera management)
#
# Based on: https://docs.godotengine.org/en/stable/classes/class_camera2d.html
#
# Split into:
# - camera_controllers.spl (ProcessCallback, ProjectionMode, KeepAspectMode,
#                            MSAA, ScreenSpaceAA, camera factory functions)

use godot.ffi
use godot.variant
use godot.node2d
use godot.node3d

mod camera

# Camera2D
# 2D camera for viewport control
pub struct Camera2D extends godot.node2d.Node2D:

impl Camera2D:
    # Create from Godot object pointer
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> Camera2D:
        return Camera2D(base: godot.node2d.Node2D.from_ptr(ptr))

    # Set camera offset (screen center offset)
    pub fn set_offset(mut self, x: f64, y: f64):
        val obj = self.base.as_node().as_object()
        val offset_var = variant.Variant.from_vector2(x, y)
        obj.call1("set_offset", offset_var)

    # Set zoom level (2.0 = 2x zoom)
    pub fn set_zoom(mut self, x: f64, y: f64):
        val obj = self.base.as_node().as_object()
        val zoom_var = variant.Variant.from_vector2(x, y)
        obj.call1("set_zoom", zoom_var)

    # Set camera as current
    pub fn make_current(mut self):
        val obj = self.base.as_node().as_object()
        obj.call0("make_current")

    # Check if this is the current camera
    pub fn is_current(self) -> bool:
        val obj = self.base.as_node().as_object()
        val result = obj.call0("is_current")
        return result.as_bool()

    # Set position smoothing (for smooth follow)
    pub fn set_position_smoothing_enabled(mut self, enabled: bool):
        val obj = self.base.as_node().as_object()
        val smooth_var = variant.Variant.from_bool(enabled)
        obj.call1("set_position_smoothing_enabled", smooth_var)

    # Set smoothing speed
    pub fn set_position_smoothing_speed(mut self, speed: f64):
        val obj = self.base.as_node().as_object()
        val speed_var = variant.Variant.from_float(speed)
        obj.call1("set_position_smoothing_speed", speed_var)

    # Set rotation smoothing
    pub fn set_rotation_smoothing_enabled(mut self, enabled: bool):
        val obj = self.base.as_node().as_object()
        val smooth_var = variant.Variant.from_bool(enabled)
        obj.call1("set_rotation_smoothing_enabled", smooth_var)

    # Set rotation smoothing speed
    pub fn set_rotation_smoothing_speed(mut self, speed: f64):
        val obj = self.base.as_node().as_object()
        val speed_var = variant.Variant.from_float(speed)
        obj.call1("set_rotation_smoothing_speed", speed_var)

    # Set camera limits (min/max position)
    pub fn set_limit_left(mut self, limit: i32):
        val obj = self.base.as_node().as_object()
        val limit_var = variant.Variant.from_int(limit as i64)
        obj.call1("set_limit", limit_var)

    pub fn set_limit_right(mut self, limit: i32):
        val obj = self.base.as_node().as_object()
        val limit_var = variant.Variant.from_int(limit as i64)
        obj.call1("set_limit", limit_var)

    pub fn set_limit_top(mut self, limit: i32):
        val obj = self.base.as_node().as_object()
        val limit_var = variant.Variant.from_int(limit as i64)
        obj.call1("set_limit", limit_var)

    pub fn set_limit_bottom(mut self, limit: i32):
        val obj = self.base.as_node().as_object()
        val limit_var = variant.Variant.from_int(limit as i64)
        obj.call1("set_limit", limit_var)

    # Set limit smoothing
    pub fn set_limit_smoothed(mut self, enabled: bool):
        val obj = self.base.as_node().as_object()
        val smooth_var = variant.Variant.from_bool(enabled)
        obj.call1("set_limit_smoothed", smooth_var)

    # Set drag margins (how far from edge before scrolling)
    pub fn set_drag_horizontal_enabled(mut self, enabled: bool):
        val obj = self.base.as_node().as_object()
        val drag_var = variant.Variant.from_bool(enabled)
        obj.call1("set_drag_horizontal_enabled", drag_var)

    pub fn set_drag_vertical_enabled(mut self, enabled: bool):
        val obj = self.base.as_node().as_object()
        val drag_var = variant.Variant.from_bool(enabled)
        obj.call1("set_drag_vertical_enabled", drag_var)

    pub fn set_drag_horizontal_offset(mut self, offset: f64):
        val obj = self.base.as_node().as_object()
        val offset_var = variant.Variant.from_float(offset)
        obj.call1("set_drag_horizontal_offset", offset_var)

    pub fn set_drag_vertical_offset(mut self, offset: f64):
        val obj = self.base.as_node().as_object()
        val offset_var = variant.Variant.from_float(offset)
        obj.call1("set_drag_vertical_offset", offset_var)

    # Set process callback (idle or physics)
    pub fn set_process_callback(mut self, mode: ProcessCallback):
        val obj = self.base.as_node().as_object()
        val mode_var = variant.Variant.from_int(mode as i64)
        obj.call1("set_process_callback", mode_var)

    # Align camera to center
    pub fn align(mut self):
        val obj = self.base.as_node().as_object()
        obj.call0("align")

    # Reset smoothing (snap to target)
    pub fn reset_smoothing(mut self):
        val obj = self.base.as_node().as_object()
        obj.call0("reset_smoothing")

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn activate(mut self):
        """Make this camera the current camera (alias for make_current).

        Example:
            camera.activate()
        """
        self.make_current()

    pub fn is_active(self) -> bool:
        """Check if this is the active camera (alias for is_current).

        Returns:
            true if current camera

        Example:
            camera.is_active()  # → true
        """
        return self.is_current()

    pub fn enable_smoothing(mut self):
        """Enable both position and rotation smoothing.

        Example:
            camera.enable_smoothing()
        """
        self.set_position_smoothing_enabled(true)
        self.set_rotation_smoothing_enabled(true)

    pub fn disable_smoothing(mut self):
        """Disable both position and rotation smoothing.

        Example:
            camera.disable_smoothing()
        """
        self.set_position_smoothing_enabled(false)
        self.set_rotation_smoothing_enabled(false)

    pub fn summary(self) -> text:
        """Get Camera2D summary.

        Returns:
            Human-readable summary

        Example:
            camera.summary()
            # → "Camera2D: current camera"
        """
        val status = if self.is_current() { "current camera" } else { "inactive" }
        return "Camera2D: {status}"


# Camera3D
# 3D camera with projection modes
pub struct Camera3D extends godot.node3d.Node3D:

impl Camera3D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> Camera3D:
        return Camera3D(base: godot.node3d.Node3D.from_ptr(ptr))

    # Set camera as current
    pub fn make_current(mut self):
        val obj = self.base.as_node().as_object()
        obj.call0("make_current")

    # Check if this is the current camera
    pub fn is_current(self) -> bool:
        val obj = self.base.as_node().as_object()
        val result = obj.call0("is_current")
        return result.as_bool()

    # Set projection mode
    pub fn set_projection(mut self, mode: ProjectionMode):
        val obj = self.base.as_node().as_object()
        val mode_var = variant.Variant.from_int(mode as i64)
        obj.call1("set_projection", mode_var)

    # Get projection mode
    pub fn get_projection(self) -> ProjectionMode:
        val obj = self.base.as_node().as_object()
        val result = obj.call0("get_projection")
        val mode_int = result.as_int()
        if mode_int == 0:
            return ProjectionMode.Perspective
        else:
            return ProjectionMode.Orthogonal

    # Set field of view (in degrees, for perspective)
    pub fn set_fov(mut self, fov: f64):
        val obj = self.base.as_node().as_object()
        val fov_var = variant.Variant.from_float(fov)
        obj.call1("set_fov", fov_var)

    # Get field of view
    pub fn get_fov(self) -> f64:
        val obj = self.base.as_node().as_object()
        val result = obj.call0("get_fov")
        return result.as_float()

    # Set orthogonal size (for orthogonal projection)
    pub fn set_size(mut self, size: f64):
        val obj = self.base.as_node().as_object()
        val size_var = variant.Variant.from_float(size)
        obj.call1("set_size", size_var)

    # Set near clip plane
    pub fn set_near(mut self, near: f64):
        val obj = self.base.as_node().as_object()
        val near_var = variant.Variant.from_float(near)
        obj.call1("set_near", near_var)

    # Set far clip plane
    pub fn set_far(mut self, far: f64):
        val obj = self.base.as_node().as_object()
        val far_var = variant.Variant.from_float(far)
        obj.call1("set_far", far_var)

    # Set H offset (horizontal offset for stereo/VR)
    pub fn set_h_offset(mut self, offset: f64):
        val obj = self.base.as_node().as_object()
        val offset_var = variant.Variant.from_float(offset)
        obj.call1("set_h_offset", offset_var)

    # Set V offset (vertical offset)
    pub fn set_v_offset(mut self, offset: f64):
        val obj = self.base.as_node().as_object()
        val offset_var = variant.Variant.from_float(offset)
        obj.call1("set_v_offset", offset_var)

    # Set keep aspect mode
    pub fn set_keep_aspect_mode(mut self, mode: KeepAspectMode):
        val obj = self.base.as_node().as_object()
        val mode_var = variant.Variant.from_int(mode as i64)
        obj.call1("set_keep_aspect_mode", mode_var)

    # Set cull mask (layers to render)
    pub fn set_cull_mask(mut self, mask: u32):
        val obj = self.base.as_node().as_object()
        val mask_var = variant.Variant.from_int(mask as i64)
        obj.call1("set_cull_mask", mask_var)

    # Set environment
    pub fn set_environment(mut self, env: godot.resource.Resource):
        val obj = self.base.as_node().as_object()
        val env_var = variant.Variant.from_object(env.as_object())
        obj.call1("set_environment", env_var)

    # Project 3D position to 2D screen coordinates
    pub fn project_position(self, world_point_x: f64, world_point_y: f64, world_point_z: f64) -> (f64, f64):
        val obj = self.base.as_node().as_object()
        val world_var = variant.Variant.from_vector3(world_point_x, world_point_y, world_point_z)
        val result = obj.call1("project_position", world_var)
        return result.as_vector2()

    # Project 2D screen coordinates to 3D ray
    pub fn project_ray_origin(self, screen_x: f64, screen_y: f64) -> (f64, f64, f64):
        val obj = self.base.as_node().as_object()
        val screen_var = variant.Variant.from_vector2(screen_x, screen_y)
        val result = obj.call1("project_ray_origin", screen_var)
        return result.as_vector3()

    pub fn project_ray_normal(self, screen_x: f64, screen_y: f64) -> (f64, f64, f64):
        val obj = self.base.as_node().as_object()
        val screen_var = variant.Variant.from_vector2(screen_x, screen_y)
        val result = obj.call1("project_ray_normal", screen_var)
        return result.as_vector3()

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn activate(mut self):
        """Make this camera the current camera (alias for make_current).

        Example:
            camera.activate()
        """
        self.make_current()

    pub fn is_active(self) -> bool:
        """Check if this is the active camera (alias for is_current).

        Returns:
            true if current camera

        Example:
            camera.is_active()  # → true
        """
        return self.is_current()

    pub fn is_perspective(self) -> bool:
        """Check if camera is in perspective mode.

        Returns:
            true if ProjectionMode.Perspective

        Example:
            camera.is_perspective()  # → true
        """
        return self.get_projection() == ProjectionMode.Perspective

    pub fn is_orthogonal(self) -> bool:
        """Check if camera is in orthogonal mode.

        Returns:
            true if ProjectionMode.Orthogonal

        Example:
            camera.is_orthogonal()  # → false
        """
        return self.get_projection() == ProjectionMode.Orthogonal

    pub fn use_perspective(mut self):
        """Switch to perspective projection.

        Example:
            camera.use_perspective()
        """
        self.set_projection(ProjectionMode.Perspective)

    pub fn use_orthogonal(mut self):
        """Switch to orthogonal projection.

        Example:
            camera.use_orthogonal()
        """
        self.set_projection(ProjectionMode.Orthogonal)

    pub fn summary(self) -> text:
        """Get Camera3D summary.

        Returns:
            Human-readable summary

        Example:
            camera.summary()
            # → "Camera3D: current, perspective, fov=70.0"
        """
        val status = if self.is_current() { "current" } else { "inactive" }
        val projection = if self.is_perspective() { "perspective" } else { "orthogonal" }
        val fov = self.get_fov()
        return "Camera3D: {status}, {projection}, fov={fov}"


# Viewport
# Render target and camera management
pub struct Viewport:
    ptr: ffi.GDExtensionObjectPtr

impl Viewport:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> Viewport:
        return Viewport(ptr: ptr)

    # Get viewport size
    pub fn get_size(self) -> (i32, i32):
        val obj = variant.Object.from_ptr(self.ptr)
        val result = obj.call0("get_size")
        return result.as_vector2i()

    # Set viewport size
    pub fn set_size(mut self, width: i32, height: i32):
        val obj = variant.Object.from_ptr(self.ptr)
        val size_var = variant.Variant.from_vector2i(width, height)
        obj.call1("set_size", size_var)

    # Get camera 2D
    pub fn get_camera_2d(self) -> Option<Camera2D>:
        val obj = variant.Object.from_ptr(self.ptr)
        val result = obj.call0("get_camera_2d")

        if result.is_null():
            return None
        else:
            return Some(Camera2D.from_ptr(result.as_object().ptr()))

    # Get camera 3D
    pub fn get_camera_3d(self) -> Option<Camera3D>:
        val obj = variant.Object.from_ptr(self.ptr)
        val result = obj.call0("get_camera_3d")

        if result.is_null():
            return None
        else:
            return Some(Camera3D.from_ptr(result.as_object().ptr()))

    # Set MSAA (anti-aliasing)
    pub fn set_msaa_3d(mut self, msaa: MSAA):
        val obj = variant.Object.from_ptr(self.ptr)
        val msaa_var = variant.Variant.from_int(msaa as i64)
        obj.call1("set_msaa_3d", msaa_var)

    # Set screen space AA
    pub fn set_screen_space_aa(mut self, aa: ScreenSpaceAA):
        val obj = variant.Object.from_ptr(self.ptr)
        val aa_var = variant.Variant.from_int(aa as i64)
        obj.call1("set_screen_space_aa", aa_var)

    # Set HDR
    pub fn set_use_hdr_2d(mut self, enabled: bool):
        val obj = variant.Object.from_ptr(self.ptr)
        val hdr_var = variant.Variant.from_bool(enabled)
        obj.call1("set_use_hdr_2d", hdr_var)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_camera_2d(self) -> bool:
        """Check if viewport has a 2D camera.

        Returns:
            true if camera exists

        Example:
            viewport.has_camera_2d()  # → true
        """
        return self.get_camera_2d().is_some()

    pub fn has_camera_3d(self) -> bool:
        """Check if viewport has a 3D camera.

        Returns:
            true if camera exists

        Example:
            viewport.has_camera_3d()  # → false
        """
        return self.get_camera_3d().is_some()

    pub fn has_camera(self) -> bool:
        """Check if viewport has any camera (2D or 3D).

        Returns:
            true if any camera exists

        Example:
            viewport.has_camera()  # → true
        """
        return self.has_camera_2d() or self.has_camera_3d()

    pub fn enable_hdr(mut self):
        """Enable HDR rendering.

        Example:
            viewport.enable_hdr()
        """
        self.set_use_hdr_2d(true)

    pub fn disable_hdr(mut self):
        """Disable HDR rendering.

        Example:
            viewport.disable_hdr()
        """
        self.set_use_hdr_2d(false)

    pub fn summary(self) -> text:
        """Get viewport summary.

        Returns:
            Human-readable summary

        Example:
            viewport.summary()
            # → "Viewport: has 2D camera"
        """
        if self.has_camera_2d():
            return "Viewport: has 2D camera"
        elif self.has_camera_3d():
            return "Viewport: has 3D camera"
        else:
            return "Viewport: no camera"
