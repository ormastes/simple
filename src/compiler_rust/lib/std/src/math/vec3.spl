# Math Vec3 - 3D Vectors
#
# Vec3 (f32) and Vec3d (f64) for 3D math operations.

export Vec3, Vec3d


# ============================================================================
# Vec3 - 3D Vector (f32)
# ============================================================================

class Vec3:
    """3D vector with f32 precision."""
    x: f32
    y: f32
    z: f32

    fn __init__(x: f32, y: f32, z: f32):
        self.x = x
        self.y = y
        self.z = z

    # Statics
    static fn zero() -> Vec3:
        Vec3(0.0, 0.0, 0.0)

    static fn one() -> Vec3:
        Vec3(1.0, 1.0, 1.0)

    static fn up() -> Vec3:
        Vec3(0.0, 1.0, 0.0)

    static fn down() -> Vec3:
        Vec3(0.0, -1.0, 0.0)

    static fn left() -> Vec3:
        Vec3(-1.0, 0.0, 0.0)

    static fn right() -> Vec3:
        Vec3(1.0, 0.0, 0.0)

    static fn forward() -> Vec3:
        Vec3(0.0, 0.0, 1.0)

    static fn back() -> Vec3:
        Vec3(0.0, 0.0, -1.0)

    # Arithmetic
    fn add(other: Vec3) -> Vec3:
        Vec3(self.x + other.x, self.y + other.y, self.z + other.z)

    fn sub(other: Vec3) -> Vec3:
        Vec3(self.x - other.x, self.y - other.y, self.z - other.z)

    fn scale(scalar: f32) -> Vec3:
        Vec3(self.x * scalar, self.y * scalar, self.z * scalar)

    fn dot(other: Vec3) -> f32:
        self.x * other.x + self.y * other.y + self.z * other.z

    fn cross(other: Vec3) -> Vec3:
        Vec3(
            self.y * other.z - self.z * other.y,
            self.z * other.x - self.x * other.z,
            self.x * other.y - self.y * other.x
        )

    fn magnitude() -> f32:
        (self.x * self.x + self.y * self.y + self.z * self.z).sqrt()

    fn length() -> f32:
        self.magnitude()

    fn length_squared() -> f32:
        self.x * self.x + self.y * self.y + self.z * self.z

    fn normalize() -> Vec3:
        val mag = self.magnitude()
        if mag > 0.0:
            return self.scale(1.0 / mag)
        Vec3(0.0, 0.0, 0.0)

    fn distance(other: Vec3) -> f32:
        self.sub(other).magnitude()

    fn distance_to(other: Vec3) -> f32:
        self.distance(other)

    fn lerp(other: Vec3, t: f32) -> Vec3:
        Vec3(
            self.x + (other.x - self.x) * t,
            self.y + (other.y - self.y) * t,
            self.z + (other.z - self.z) * t
        )

    fn is_zero() -> bool:
        self.x == 0.0 and self.y == 0.0 and self.z == 0.0

    fn is_near_zero(epsilon: f32 = 1e-6) -> bool:
        self.magnitude() < epsilon

    fn is_finite() -> bool:
        self.x.is_finite() and self.y.is_finite() and self.z.is_finite()

    fn is_unit(epsilon: f32 = 1e-6) -> bool:
        (self.length_squared() - 1.0).abs() < epsilon

    fn has_nan() -> bool:
        self.x.is_nan() or self.y.is_nan() or self.z.is_nan()

    fn component_min(other: Vec3) -> Vec3:
        Vec3(
            if self.x < other.x { self.x } else { other.x },
            if self.y < other.y { self.y } else { other.y },
            if self.z < other.z { self.z } else { other.z }
        )

    fn component_max(other: Vec3) -> Vec3:
        Vec3(
            if self.x > other.x { self.x } else { other.x },
            if self.y > other.y { self.y } else { other.y },
            if self.z > other.z { self.z } else { other.z }
        )

    fn to_f64() -> Vec3d:
        Vec3d(self.x as f64, self.y as f64, self.z as f64)


# ============================================================================
# Vec3d - 3D Vector (f64)
# ============================================================================

class Vec3d:
    """3D vector with f64 precision."""
    x: f64
    y: f64
    z: f64

    fn __init__(x: f64, y: f64, z: f64):
        self.x = x
        self.y = y
        self.z = z

    static fn zero() -> Vec3d:
        Vec3d(0.0, 0.0, 0.0)

    static fn create(x: f64, y: f64, z: f64) -> Vec3d:
        Vec3d(x, y, z)

    static fn one() -> Vec3d:
        Vec3d(1.0, 1.0, 1.0)

    static fn up() -> Vec3d:
        Vec3d(0.0, 1.0, 0.0)

    static fn down() -> Vec3d:
        Vec3d(0.0, -1.0, 0.0)

    static fn left() -> Vec3d:
        Vec3d(-1.0, 0.0, 0.0)

    static fn right() -> Vec3d:
        Vec3d(1.0, 0.0, 0.0)

    static fn forward() -> Vec3d:
        Vec3d(0.0, 0.0, 1.0)

    static fn back() -> Vec3d:
        Vec3d(0.0, 0.0, -1.0)

    fn add(other: Vec3d) -> Vec3d:
        Vec3d(self.x + other.x, self.y + other.y, self.z + other.z)

    fn sub(other: Vec3d) -> Vec3d:
        Vec3d(self.x - other.x, self.y - other.y, self.z - other.z)

    fn scale(scalar: f64) -> Vec3d:
        Vec3d(self.x * scalar, self.y * scalar, self.z * scalar)

    fn dot(other: Vec3d) -> f64:
        self.x * other.x + self.y * other.y + self.z * other.z

    fn cross(other: Vec3d) -> Vec3d:
        Vec3d(
            self.y * other.z - self.z * other.y,
            self.z * other.x - self.x * other.z,
            self.x * other.y - self.y * other.x
        )

    fn magnitude() -> f64:
        (self.x * self.x + self.y * self.y + self.z * self.z).sqrt()

    fn length() -> f64:
        self.magnitude()

    fn length_squared() -> f64:
        self.x * self.x + self.y * self.y + self.z * self.z

    fn normalize() -> Vec3d:
        val mag = self.magnitude()
        if mag > 0.0:
            return self.scale(1.0 / mag)
        Vec3d(0.0, 0.0, 0.0)

    fn distance(other: Vec3d) -> f64:
        self.sub(other).magnitude()

    fn distance_to(other: Vec3d) -> f64:
        self.distance(other)

    fn lerp(other: Vec3d, t: f64) -> Vec3d:
        Vec3d(
            self.x + (other.x - self.x) * t,
            self.y + (other.y - self.y) * t,
            self.z + (other.z - self.z) * t
        )

    fn is_zero() -> bool:
        self.x == 0.0 and self.y == 0.0 and self.z == 0.0

    fn is_near_zero(epsilon: f64 = 1e-12) -> bool:
        self.magnitude() < epsilon

    fn is_finite() -> bool:
        self.x.is_finite() and self.y.is_finite() and self.z.is_finite()

    fn is_unit(epsilon: f64 = 1e-12) -> bool:
        (self.length_squared() - 1.0).abs() < epsilon

    fn has_nan() -> bool:
        self.x.is_nan() or self.y.is_nan() or self.z.is_nan()

    fn component_min(other: Vec3d) -> Vec3d:
        Vec3d(
            if self.x < other.x { self.x } else { other.x },
            if self.y < other.y { self.y } else { other.y },
            if self.z < other.z { self.z } else { other.z }
        )

    fn component_max(other: Vec3d) -> Vec3d:
        Vec3d(
            if self.x > other.x { self.x } else { other.x },
            if self.y > other.y { self.y } else { other.y },
            if self.z > other.z { self.z } else { other.z }
        )

    fn to_f32() -> Vec3:
        Vec3(self.x as f32, self.y as f32, self.z as f32)
