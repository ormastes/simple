# Math Advanced - Quaternions, Transforms, Colors, Tensor Bridge
#
# Part 3 of math module: high-level types and conversions.
# See __init__.spl for Vec2/Vec3 types.
# See math_functions.spl for Vec4 and matrix types.

# ============================================================================
# Quat - Quaternion (f32)
# ============================================================================

class Quat:
    """Quaternion for 3D rotations (f32 precision).

    Quaternions avoid gimbal lock and interpolate smoothly.
    Convention: (w, x, y, z) where w is scalar.
    """
    w: f32
    x: f32
    y: f32
    z: f32

    fn __init__(w: f32, x: f32, y: f32, z: f32):
        self.w = w
        self.x = x
        self.y = y
        self.z = z

    static fn identity() -> Quat:
        Quat(1.0, 0.0, 0.0, 0.0)

    static fn from_axis_angle(axis: Vec3, angle: f32) -> Quat:
        val half_angle = angle * 0.5
        val s = half_angle.sin()
        val c = half_angle.cos()
        val n = axis.normalize()
        Quat(c, n.x * s, n.y * s, n.z * s)

    static fn from_euler(pitch: f32, yaw: f32, roll: f32) -> Quat:
        """Create quaternion from Euler angles (radians)."""
        val cp = (pitch * 0.5).cos()
        val sp = (pitch * 0.5).sin()
        val cy = (yaw * 0.5).cos()
        val sy = (yaw * 0.5).sin()
        val cr = (roll * 0.5).cos()
        val sr = (roll * 0.5).sin()
        Quat(
            cr * cp * cy + sr * sp * sy,
            sr * cp * cy - cr * sp * sy,
            cr * sp * cy + sr * cp * sy,
            cr * cp * sy - sr * sp * cy
        )

    fn magnitude() -> f32:
        (self.w * self.w + self.x * self.x + self.y * self.y + self.z * self.z).sqrt()

    me normalize() -> Quat:
        val mag = self.magnitude()
        if mag > 0.0:
            return Quat(self.w / mag, self.x / mag, self.y / mag, self.z / mag)
        Quat.identity()

    me conjugate() -> Quat:
        Quat(self.w, -self.x, -self.y, -self.z)

    me inverse() -> Quat:
        val mag_sq = self.w * self.w + self.x * self.x + self.y * self.y + self.z * self.z
        if mag_sq > 0.0:
            val inv = 1.0 / mag_sq
            return Quat(self.w * inv, -self.x * inv, -self.y * inv, -self.z * inv)
        Quat.identity()

    me mul(other: Quat) -> Quat:
        """Quaternion multiplication (composition of rotations)."""
        Quat(
            self.w * other.w - self.x * other.x - self.y * other.y - self.z * other.z,
            self.w * other.x + self.x * other.w + self.y * other.z - self.z * other.y,
            self.w * other.y - self.x * other.z + self.y * other.w + self.z * other.x,
            self.w * other.z + self.x * other.y - self.y * other.x + self.z * other.w
        )

    me rotate_vector(v: Vec3) -> Vec3:
        """Rotate vector by this quaternion."""
        val qv = Vec3(self.x, self.y, self.z)
        val t = qv.cross(v).scale(2.0)
        v.add(t.scale(self.w)).add(qv.cross(t))

    me slerp(other: Quat, t: f32) -> Quat:
        """Spherical linear interpolation."""
        var cos_half = self.w * other.w + self.x * other.x + self.y * other.y + self.z * other.z
        var target = other
        if cos_half < 0.0:
            target = Quat(-other.w, -other.x, -other.y, -other.z)
            cos_half = -cos_half

        if cos_half > 0.9995:
            # Very close - use linear interpolation
            val result = Quat(
                self.w + (target.w - self.w) * t,
                self.x + (target.x - self.x) * t,
                self.y + (target.y - self.y) * t,
                self.z + (target.z - self.z) * t
            )
            return result.normalize()

        val half_angle = cos_half.acos()
        val sin_half = (1.0 - cos_half * cos_half).sqrt()
        val a = ((1.0 - t) * half_angle).sin() / sin_half
        val b = (t * half_angle).sin() / sin_half

        Quat(
            self.w * a + target.w * b,
            self.x * a + target.x * b,
            self.y * a + target.y * b,
            self.z * a + target.z * b
        )

    me to_mat3() -> Mat3:
        """Convert to 3x3 rotation matrix (column-major)."""
        val xx = self.x * self.x
        val yy = self.y * self.y
        val zz = self.z * self.z
        val xy = self.x * self.y
        val xz = self.x * self.z
        val yz = self.y * self.z
        val wx = self.w * self.x
        val wy = self.w * self.y
        val wz = self.w * self.z
        Mat3([
            1.0 - 2.0 * (yy + zz), 2.0 * (xy + wz),       2.0 * (xz - wy),
            2.0 * (xy - wz),       1.0 - 2.0 * (xx + zz), 2.0 * (yz + wx),
            2.0 * (xz + wy),       2.0 * (yz - wx),       1.0 - 2.0 * (xx + yy)
        ])

    me to_mat4() -> Mat4:
        """Convert to 4x4 rotation matrix (column-major)."""
        val m3 = self.to_mat3()
        Mat4([
            m3.data[0], m3.data[1], m3.data[2], 0.0,
            m3.data[3], m3.data[4], m3.data[5], 0.0,
            m3.data[6], m3.data[7], m3.data[8], 0.0,
            0.0,        0.0,        0.0,        1.0
        ])

    me to_f64() -> Quatd:
        Quatd(self.w as f64, self.x as f64, self.y as f64, self.z as f64)


# ============================================================================
# Quatd - Quaternion (f64)
# ============================================================================

class Quatd:
    """Quaternion for 3D rotations (f64 precision)."""
    w: f64
    x: f64
    y: f64
    z: f64

    fn __init__(w: f64, x: f64, y: f64, z: f64):
        self.w = w
        self.x = x
        self.y = y
        self.z = z

    static fn identity() -> Quatd:
        Quatd(1.0, 0.0, 0.0, 0.0)

    static fn from_axis_angle(axis: Vec3d, angle: f64) -> Quatd:
        val half_angle = angle * 0.5
        val s = half_angle.sin()
        val c = half_angle.cos()
        val n = axis.normalize()
        Quatd(c, n.x * s, n.y * s, n.z * s)

    static fn from_euler(pitch: f64, yaw: f64, roll: f64) -> Quatd:
        val cp = (pitch * 0.5).cos()
        val sp = (pitch * 0.5).sin()
        val cy = (yaw * 0.5).cos()
        val sy = (yaw * 0.5).sin()
        val cr = (roll * 0.5).cos()
        val sr = (roll * 0.5).sin()
        Quatd(
            cr * cp * cy + sr * sp * sy,
            sr * cp * cy - cr * sp * sy,
            cr * sp * cy + sr * cp * sy,
            cr * cp * sy - sr * sp * cy
        )

    fn magnitude() -> f64:
        (self.w * self.w + self.x * self.x + self.y * self.y + self.z * self.z).sqrt()

    me normalize() -> Quatd:
        val mag = self.magnitude()
        if mag > 0.0:
            return Quatd(self.w / mag, self.x / mag, self.y / mag, self.z / mag)
        Quatd.identity()

    me conjugate() -> Quatd:
        Quatd(self.w, -self.x, -self.y, -self.z)

    me inverse() -> Quatd:
        val mag_sq = self.w * self.w + self.x * self.x + self.y * self.y + self.z * self.z
        if mag_sq > 0.0:
            val inv = 1.0 / mag_sq
            return Quatd(self.w * inv, -self.x * inv, -self.y * inv, -self.z * inv)
        Quatd.identity()

    me mul(other: Quatd) -> Quatd:
        Quatd(
            self.w * other.w - self.x * other.x - self.y * other.y - self.z * other.z,
            self.w * other.x + self.x * other.w + self.y * other.z - self.z * other.y,
            self.w * other.y - self.x * other.z + self.y * other.w + self.z * other.x,
            self.w * other.z + self.x * other.y - self.y * other.x + self.z * other.w
        )

    me rotate_vector(v: Vec3d) -> Vec3d:
        val qv = Vec3d(self.x, self.y, self.z)
        val t = qv.cross(v).scale(2.0)
        v.add(t.scale(self.w)).add(qv.cross(t))

    me slerp(other: Quatd, t: f64) -> Quatd:
        var cos_half = self.w * other.w + self.x * other.x + self.y * other.y + self.z * other.z
        var target = other
        if cos_half < 0.0:
            target = Quatd(-other.w, -other.x, -other.y, -other.z)
            cos_half = -cos_half

        if cos_half > 0.9995:
            val result = Quatd(
                self.w + (target.w - self.w) * t,
                self.x + (target.x - self.x) * t,
                self.y + (target.y - self.y) * t,
                self.z + (target.z - self.z) * t
            )
            return result.normalize()

        val half_angle = cos_half.acos()
        val sin_half = (1.0 - cos_half * cos_half).sqrt()
        val a = ((1.0 - t) * half_angle).sin() / sin_half
        val b = (t * half_angle).sin() / sin_half

        Quatd(
            self.w * a + target.w * b,
            self.x * a + target.x * b,
            self.y * a + target.y * b,
            self.z * a + target.z * b
        )

    me to_mat3() -> Mat3d:
        val xx = self.x * self.x
        val yy = self.y * self.y
        val zz = self.z * self.z
        val xy = self.x * self.y
        val xz = self.x * self.z
        val yz = self.y * self.z
        val wx = self.w * self.x
        val wy = self.w * self.y
        val wz = self.w * self.z
        Mat3d([
            1.0 - 2.0 * (yy + zz), 2.0 * (xy + wz),       2.0 * (xz - wy),
            2.0 * (xy - wz),       1.0 - 2.0 * (xx + zz), 2.0 * (yz + wx),
            2.0 * (xz + wy),       2.0 * (yz - wx),       1.0 - 2.0 * (xx + yy)
        ])

    me to_mat4() -> Mat4d:
        val m3 = self.to_mat3()
        Mat4d([
            m3.data[0], m3.data[1], m3.data[2], 0.0,
            m3.data[3], m3.data[4], m3.data[5], 0.0,
            m3.data[6], m3.data[7], m3.data[8], 0.0,
            0.0,        0.0,        0.0,        1.0
        ])

    me to_f32() -> Quat:
        Quat(self.w as f32, self.x as f32, self.y as f32, self.z as f32)


# ============================================================================
# Transform - 3D Transform (f32)
# ============================================================================

class Transform:
    """3D transform combining position, rotation, and scale (f32)."""
    position: Vec3
    rotation: Quat
    scale: Vec3

    fn __init__(position: Vec3, rotation: Quat, scale: Vec3):
        self.position = position
        self.rotation = rotation
        self.scale = scale

    static fn identity() -> Transform:
        Transform(
            position: Vec3.zero(),
            rotation: Quat.identity(),
            scale: Vec3.one()
        )

    me to_mat4() -> Mat4:
        """Convert to 4x4 transformation matrix."""
        val rot_mat = self.rotation.to_mat4()
        val scale_mat = Mat4.scale(self.scale.x, self.scale.y, self.scale.z)
        val trans_mat = Mat4.translation(self.position.x, self.position.y, self.position.z)
        trans_mat.mul(rot_mat.mul(scale_mat))

    me forward() -> Vec3:
        self.rotation.rotate_vector(Vec3.forward())

    me right() -> Vec3:
        self.rotation.rotate_vector(Vec3.right())

    me up() -> Vec3:
        self.rotation.rotate_vector(Vec3.up())

    me inverse() -> Transform:
        val inv_rot = self.rotation.inverse()
        val inv_scale = Vec3(1.0 / self.scale.x, 1.0 / self.scale.y, 1.0 / self.scale.z)
        val inv_pos = inv_rot.rotate_vector(self.position.scale(-1.0))
        Transform(
            position: Vec3(inv_pos.x * inv_scale.x, inv_pos.y * inv_scale.y, inv_pos.z * inv_scale.z),
            rotation: inv_rot,
            scale: inv_scale
        )

    me lerp(other: Transform, t: f32) -> Transform:
        Transform(
            position: self.position.lerp(other.position, t),
            rotation: self.rotation.slerp(other.rotation, t),
            scale: self.scale.lerp(other.scale, t)
        )

    me combine(child: Transform) -> Transform:
        """Combine transforms (parent * child)."""
        val new_rot = self.rotation.mul(child.rotation)
        val scaled_pos = Vec3(
            child.position.x * self.scale.x,
            child.position.y * self.scale.y,
            child.position.z * self.scale.z
        )
        val new_pos = self.position.add(self.rotation.rotate_vector(scaled_pos))
        val new_scale = Vec3(
            self.scale.x * child.scale.x,
            self.scale.y * child.scale.y,
            self.scale.z * child.scale.z
        )
        Transform(position: new_pos, rotation: new_rot, scale: new_scale)

    me transform_point(p: Vec3) -> Vec3:
        val scaled = Vec3(p.x * self.scale.x, p.y * self.scale.y, p.z * self.scale.z)
        self.position.add(self.rotation.rotate_vector(scaled))

    me transform_vector(v: Vec3) -> Vec3:
        val scaled = Vec3(v.x * self.scale.x, v.y * self.scale.y, v.z * self.scale.z)
        self.rotation.rotate_vector(scaled)


# ============================================================================
# Transformd - 3D Transform (f64)
# ============================================================================

class Transformd:
    """3D transform combining position, rotation, and scale (f64)."""
    position: Vec3d
    rotation: Quatd
    scale: Vec3d

    fn __init__(position: Vec3d, rotation: Quatd, scale: Vec3d):
        self.position = position
        self.rotation = rotation
        self.scale = scale

    static fn identity() -> Transformd:
        Transformd(
            position: Vec3d.zero(),
            rotation: Quatd.identity(),
            scale: Vec3d.one()
        )

    me to_mat4() -> Mat4d:
        val rot_mat = self.rotation.to_mat4()
        val scale_mat = Mat4d.scale(self.scale.x, self.scale.y, self.scale.z)
        val trans_mat = Mat4d.translation(self.position.x, self.position.y, self.position.z)
        trans_mat.mul(rot_mat.mul(scale_mat))

    me forward() -> Vec3d:
        self.rotation.rotate_vector(Vec3d.forward())

    me right() -> Vec3d:
        self.rotation.rotate_vector(Vec3d.right())

    me up() -> Vec3d:
        self.rotation.rotate_vector(Vec3d.up())

    me inverse() -> Transformd:
        val inv_rot = self.rotation.inverse()
        val inv_scale = Vec3d(1.0 / self.scale.x, 1.0 / self.scale.y, 1.0 / self.scale.z)
        val inv_pos = inv_rot.rotate_vector(self.position.scale(-1.0))
        Transformd(
            position: Vec3d(inv_pos.x * inv_scale.x, inv_pos.y * inv_scale.y, inv_pos.z * inv_scale.z),
            rotation: inv_rot,
            scale: inv_scale
        )

    me lerp(other: Transformd, t: f64) -> Transformd:
        Transformd(
            position: self.position.lerp(other.position, t),
            rotation: self.rotation.slerp(other.rotation, t),
            scale: self.scale.lerp(other.scale, t)
        )

    me combine(child: Transformd) -> Transformd:
        val new_rot = self.rotation.mul(child.rotation)
        val scaled_pos = Vec3d(
            child.position.x * self.scale.x,
            child.position.y * self.scale.y,
            child.position.z * self.scale.z
        )
        val new_pos = self.position.add(self.rotation.rotate_vector(scaled_pos))
        val new_scale = Vec3d(
            self.scale.x * child.scale.x,
            self.scale.y * child.scale.y,
            self.scale.z * child.scale.z
        )
        Transformd(position: new_pos, rotation: new_rot, scale: new_scale)

    me transform_point(p: Vec3d) -> Vec3d:
        val scaled = Vec3d(p.x * self.scale.x, p.y * self.scale.y, p.z * self.scale.z)
        self.position.add(self.rotation.rotate_vector(scaled))

    me transform_vector(v: Vec3d) -> Vec3d:
        val scaled = Vec3d(v.x * self.scale.x, v.y * self.scale.y, v.z * self.scale.z)
        self.rotation.rotate_vector(scaled)


# ============================================================================
# Color - RGBA (f32, 0.0-1.0)
# ============================================================================

class Color:
    """RGBA color with f32 components (0.0 to 1.0)."""
    r: f32
    g: f32
    b: f32
    a: f32

    fn __init__(r: f32, g: f32, b: f32, a: f32 = 1.0):
        self.r = r
        self.g = g
        self.b = b
        self.a = a

    static fn red() -> Color:
        Color(1.0, 0.0, 0.0, 1.0)

    static fn green() -> Color:
        Color(0.0, 1.0, 0.0, 1.0)

    static fn blue() -> Color:
        Color(0.0, 0.0, 1.0, 1.0)

    static fn white() -> Color:
        Color(1.0, 1.0, 1.0, 1.0)

    static fn black() -> Color:
        Color(0.0, 0.0, 0.0, 1.0)

    static fn transparent() -> Color:
        Color(0.0, 0.0, 0.0, 0.0)

    me lerp(other: Color, t: f32) -> Color:
        Color(
            self.r + (other.r - self.r) * t,
            self.g + (other.g - self.g) * t,
            self.b + (other.b - self.b) * t,
            self.a + (other.a - self.a) * t
        )

    fn to_hex() -> text:
        """Convert to hex string (e.g., '#FF0000FF')."""
        val ri = (self.r * 255.0) as u8
        val gi = (self.g * 255.0) as u8
        val bi = (self.b * 255.0) as u8
        val ai = (self.a * 255.0) as u8
        "#{ri:02X}{gi:02X}{bi:02X}{ai:02X}"

    static fn from_hex(hex: text) -> Color:
        """Parse hex color string (e.g., '#FF0000' or '#FF0000FF')."""
        # Strip leading #
        val h = if hex[0] == '#' { hex[1:] } else { hex }
        val r = i64.from_hex(h[0:2]) as f32 / 255.0
        val g = i64.from_hex(h[2:4]) as f32 / 255.0
        val b = i64.from_hex(h[4:6]) as f32 / 255.0
        val a = if h.len() >= 8 { i64.from_hex(h[6:8]) as f32 / 255.0 } else { 1.0 }
        Color(r, g, b, a)

    me to_color32() -> Color32:
        Color32(
            (self.r * 255.0) as u8,
            (self.g * 255.0) as u8,
            (self.b * 255.0) as u8,
            (self.a * 255.0) as u8
        )


# ============================================================================
# Color32 - RGBA (u8, 0-255)
# ============================================================================

class Color32:
    """RGBA color with u8 components (0 to 255)."""
    r: u8
    g: u8
    b: u8
    a: u8

    fn __init__(r: u8, g: u8, b: u8, a: u8 = 255):
        self.r = r
        self.g = g
        self.b = b
        self.a = a

    static fn red() -> Color32:
        Color32(255, 0, 0, 255)

    static fn green() -> Color32:
        Color32(0, 255, 0, 255)

    static fn blue() -> Color32:
        Color32(0, 0, 255, 255)

    static fn white() -> Color32:
        Color32(255, 255, 255, 255)

    static fn black() -> Color32:
        Color32(0, 0, 0, 255)

    me to_color() -> Color:
        Color(
            self.r as f32 / 255.0,
            self.g as f32 / 255.0,
            self.b as f32 / 255.0,
            self.a as f32 / 255.0
        )


# ============================================================================
# Aliases - Backward compatibility type aliases
# ============================================================================

# Physics module backward compatibility aliases (f64 precision)
# TODO: type aliases not yet supported in interpreter
# type Vector2 = Vec2d
# type Vector3 = Vec3d
# type Matrix3 = Mat3d
# type Matrix4 = Mat4d
# type Quaternion = Quatd


# ============================================================================
# Tensor Bridge - Conversions between math types and tensors
# ============================================================================

# TODO: Re-enable after torch parse issues are fixed
# import ml.torch as torch

# TODO: Uncomment when torch imports work
#
# impl TensorConvertible for Vec3:
#     fn to_tensor(device: torch.Device) -> torch.Tensor:
#         torch.tensor([self.x, self.y, self.z], dtype: torch.DType.Float32, device: device)
#
#     static fn from_tensor(t: torch.Tensor) -> Vec3:
#         Vec3(x: t[0].item(), y: t[1].item(), z: t[2].item())
#
# fn vecs_to_tensor(vecs: [Vec3], device: torch.Device) -> torch.Tensor:
#     """Convert list of Vec3 to [N, 3] tensor."""
#     var data = []
#     for v in vecs:
#         data.append([v.x, v.y, v.z])
#     torch.tensor(data, dtype: torch.DType.Float32, device: device)
#
# fn tensor_to_vecs(t: torch.Tensor) -> [Vec3]:
#     """Convert [N, 3] tensor to list of Vec3."""
#     var result = []
#     for i in 0..t.shape()[0]:
#         result.append(Vec3(t[i, 0].item(), t[i, 1].item(), t[i, 2].item()))
#     result
#
# fn vecs3d_to_tensor(vecs: [Vec3d], device: torch.Device) -> torch.Tensor:
#     """Convert list of Vec3d to [N, 3] tensor."""
#     var data = []
#     for v in vecs:
#         data.append([v.x, v.y, v.z])
#     torch.tensor(data, dtype: torch.DType.Float64, device: device)
#
# fn tensor_to_vecs3d(t: torch.Tensor) -> [Vec3d]:
#     """Convert [N, 3] tensor to list of Vec3d."""
#     var result = []
#     for i in 0..t.shape()[0]:
#         result.append(Vec3d(t[i, 0].item(), t[i, 1].item(), t[i, 2].item()))
#     result

# Placeholder functions until torch is available
fn vecs_to_tensor(vecs):
    """Placeholder: flatten Vec3 list to f32 array."""
    var result = []
    for v in vecs:
        result.append(v.x)
        result.append(v.y)
        result.append(v.z)
    result

fn tensor_to_vecs(data):
    """Placeholder: unflatten f32 array to Vec3 list."""
    var result = []
    var i = 0
    while i + 2 < data.len():
        result.append(Vec3(data[i], data[i + 1], data[i + 2]))
        i = i + 3
    result

fn vecs3d_to_tensor(vecs):
    """Placeholder: flatten Vec3d list to f64 array."""
    var result = []
    for v in vecs:
        result.append(v.x)
        result.append(v.y)
        result.append(v.z)
    result

fn tensor_to_vecs3d(data):
    """Placeholder: unflatten f64 array to Vec3d list."""
    var result = []
    var i = 0
    while i + 2 < data.len():
        result.append(Vec3d(data[i], data[i + 1], data[i + 2]))
        i = i + 3
    result
