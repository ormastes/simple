# Math Transform - 3D Transforms
#
# Transform (f32) and Transformd (f64) combining position, rotation, scale.

export Transform, Transformd

use .vec3
use .quat
use .mat4


# ============================================================================
# Transform - 3D Transform (f32)
# ============================================================================

class Transform:
    """3D transform combining position, rotation, and scale (f32)."""
    position: vec3.Vec3
    rotation: quat.Quat
    scale: vec3.Vec3

    fn __init__(position: vec3.Vec3, rotation: quat.Quat, scale: vec3.Vec3):
        self.position = position
        self.rotation = rotation
        self.scale = scale

    static fn identity() -> Transform:
        Transform(
            position: vec3.Vec3.zero(),
            rotation: quat.Quat.identity(),
            scale: vec3.Vec3.one()
        )

    fn to_mat4() -> mat4.Mat4:
        """Convert to 4x4 transformation matrix."""
        val rot_mat = self.rotation.to_mat4()
        val scale_mat = mat4.Mat4.scale(self.scale.x, self.scale.y, self.scale.z)
        val trans_mat = mat4.Mat4.translation(self.position.x, self.position.y, self.position.z)
        trans_mat.mul(rot_mat.mul(scale_mat))

    fn forward() -> vec3.Vec3:
        self.rotation.rotate_vector(vec3.Vec3.forward())

    fn right() -> vec3.Vec3:
        self.rotation.rotate_vector(vec3.Vec3.right())

    fn up() -> vec3.Vec3:
        self.rotation.rotate_vector(vec3.Vec3.up())

    fn inverse() -> Transform:
        val inv_rot = self.rotation.inverse()
        val inv_scale = vec3.Vec3(1.0 / self.scale.x, 1.0 / self.scale.y, 1.0 / self.scale.z)
        val inv_pos = inv_rot.rotate_vector(self.position.scale(-1.0))
        Transform(
            position: vec3.Vec3(inv_pos.x * inv_scale.x, inv_pos.y * inv_scale.y, inv_pos.z * inv_scale.z),
            rotation: inv_rot,
            scale: inv_scale
        )

    fn lerp(other: Transform, t: f32) -> Transform:
        Transform(
            position: self.position.lerp(other.position, t),
            rotation: self.rotation.slerp(other.rotation, t),
            scale: self.scale.lerp(other.scale, t)
        )

    fn combine(child: Transform) -> Transform:
        """Combine transforms (parent * child)."""
        val new_rot = self.rotation.mul(child.rotation)
        val scaled_pos = vec3.Vec3(
            child.position.x * self.scale.x,
            child.position.y * self.scale.y,
            child.position.z * self.scale.z
        )
        val new_pos = self.position.add(self.rotation.rotate_vector(scaled_pos))
        val new_scale = vec3.Vec3(
            self.scale.x * child.scale.x,
            self.scale.y * child.scale.y,
            self.scale.z * child.scale.z
        )
        Transform(position: new_pos, rotation: new_rot, scale: new_scale)

    fn transform_point(p: vec3.Vec3) -> vec3.Vec3:
        val scaled = vec3.Vec3(p.x * self.scale.x, p.y * self.scale.y, p.z * self.scale.z)
        self.position.add(self.rotation.rotate_vector(scaled))

    fn transform_vector(v: vec3.Vec3) -> vec3.Vec3:
        val scaled = vec3.Vec3(v.x * self.scale.x, v.y * self.scale.y, v.z * self.scale.z)
        self.rotation.rotate_vector(scaled)


# ============================================================================
# Transformd - 3D Transform (f64)
# ============================================================================

class Transformd:
    """3D transform combining position, rotation, and scale (f64)."""
    position: vec3.Vec3d
    rotation: quat.Quatd
    scale: vec3.Vec3d

    fn __init__(position: vec3.Vec3d, rotation: quat.Quatd, scale: vec3.Vec3d):
        self.position = position
        self.rotation = rotation
        self.scale = scale

    static fn identity() -> Transformd:
        Transformd(
            position: vec3.Vec3d.zero(),
            rotation: quat.Quatd.identity(),
            scale: vec3.Vec3d.one()
        )

    fn to_mat4() -> mat4.Mat4d:
        val rot_mat = self.rotation.to_mat4()
        val scale_mat = mat4.Mat4d.scale(self.scale.x, self.scale.y, self.scale.z)
        val trans_mat = mat4.Mat4d.translation(self.position.x, self.position.y, self.position.z)
        trans_mat.mul(rot_mat.mul(scale_mat))

    fn forward() -> vec3.Vec3d:
        self.rotation.rotate_vector(vec3.Vec3d.forward())

    fn right() -> vec3.Vec3d:
        self.rotation.rotate_vector(vec3.Vec3d.right())

    fn up() -> vec3.Vec3d:
        self.rotation.rotate_vector(vec3.Vec3d.up())

    fn inverse() -> Transformd:
        val inv_rot = self.rotation.inverse()
        val inv_scale = vec3.Vec3d(1.0 / self.scale.x, 1.0 / self.scale.y, 1.0 / self.scale.z)
        val inv_pos = inv_rot.rotate_vector(self.position.scale(-1.0))
        Transformd(
            position: vec3.Vec3d(inv_pos.x * inv_scale.x, inv_pos.y * inv_scale.y, inv_pos.z * inv_scale.z),
            rotation: inv_rot,
            scale: inv_scale
        )

    fn lerp(other: Transformd, t: f64) -> Transformd:
        Transformd(
            position: self.position.lerp(other.position, t),
            rotation: self.rotation.slerp(other.rotation, t),
            scale: self.scale.lerp(other.scale, t)
        )

    fn combine(child: Transformd) -> Transformd:
        val new_rot = self.rotation.mul(child.rotation)
        val scaled_pos = vec3.Vec3d(
            child.position.x * self.scale.x,
            child.position.y * self.scale.y,
            child.position.z * self.scale.z
        )
        val new_pos = self.position.add(self.rotation.rotate_vector(scaled_pos))
        val new_scale = vec3.Vec3d(
            self.scale.x * child.scale.x,
            self.scale.y * child.scale.y,
            self.scale.z * child.scale.z
        )
        Transformd(position: new_pos, rotation: new_rot, scale: new_scale)

    fn transform_point(p: vec3.Vec3d) -> vec3.Vec3d:
        val scaled = vec3.Vec3d(p.x * self.scale.x, p.y * self.scale.y, p.z * self.scale.z)
        self.position.add(self.rotation.rotate_vector(scaled))

    fn transform_vector(v: vec3.Vec3d) -> vec3.Vec3d:
        val scaled = vec3.Vec3d(v.x * self.scale.x, v.y * self.scale.y, v.z * self.scale.z)
        self.rotation.rotate_vector(scaled)
