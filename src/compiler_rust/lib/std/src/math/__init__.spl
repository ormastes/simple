# Math - Unified Math Module
#
# Shared math types for physics, game engine, graphics, and ML.
# All types are available in both f32 and f64 precision.
#
# ## Types
# - `Vec2` / `Vec2d`: 2D vectors
# - `Vec3` / `Vec3d`: 3D vectors
# - `Vec4` / `Vec4d`: 4D vectors
# - `Mat3` / `Mat3d`: 3x3 matrices (column-major)
# - `Mat4` / `Mat4d`: 4x4 matrices (column-major)
# - `Quat` / `Quatd`: Quaternions
# - `Transform` / `Transformd`: Position + rotation + scale
# - `Color` / `Color32`: RGBA colors
#
# ## Aliases (backward compat with physics)
# - `Vector2` = `Vec2d`, `Vector3` = `Vec3d`
# - `Matrix3` = `Mat3d`, `Matrix4` = `Mat4d`
# - `Quaternion` = `Quatd`
#
# ## Design Decisions
# - Column-major matrices (GPU/Vulkan standard)
# - Operators primary, named methods as aliases
# - Approximate float equality (epsilon = 1e-6 for f32, 1e-12 for f64)
#
# ## Example
# ```simple
# use math
#
# val pos = math.Vec3(1.0, 2.0, 3.0)
# val dir = math.Vec3.forward()
# val rot = math.Quat.from_axis_angle(math.Vec3.up(), 1.57)
# val rotated = rot.rotate_vector(pos)
#
# val t = math.Transform.identity()
# val mat = t.to_mat4()
# ```

export Vec2, Vec2d, Vec3, Vec3d, Vec4, Vec4d, Mat3, Mat3d, Mat4, Mat4d, Quat, Quatd, Transform, Transformd, Color, Color32, vecs_to_tensor, tensor_to_vecs, vecs3d_to_tensor, tensor_to_vecs3d


# ============================================================================
# Traits - Common interfaces for math types
# ============================================================================

# VecLike trait
# Common interface for vector types
# TODO: Traits disabled - interpreter doesn't support trait definitions yet
# trait VecLike:
#     fn magnitude() -> f64
#     fn normalize() -> Self
#     fn dot(other: Self) -> f64
#     fn lerp(other: Self, t: f64) -> Self
#     fn is_zero() -> bool
#     fn is_near_zero(epsilon: f64) -> bool
#     fn is_finite() -> bool
#
# trait TensorConvertible:
#     fn to_tensor(device: torch.Device) -> torch.Tensor
#     static fn from_tensor(t: torch.Tensor) -> Self


# ============================================================================
# Vec2 - 2D Vector (f32)
# ============================================================================

class Vec2:
    """2D vector with f32 precision."""
    x: f32
    y: f32

    fn __init__(x: f32, y: f32):
        self.x = x
        self.y = y

    static fn zero() -> Vec2:
        Vec2(0.0, 0.0)

    static fn one() -> Vec2:
        Vec2(1.0, 1.0)

    me add(other: Vec2) -> Vec2:
        Vec2(self.x + other.x, self.y + other.y)

    me sub(other: Vec2) -> Vec2:
        Vec2(self.x - other.x, self.y - other.y)

    me scale(scalar: f32) -> Vec2:
        Vec2(self.x * scalar, self.y * scalar)

    fn dot(other: Vec2) -> f32:
        self.x * other.x + self.y * other.y

    fn magnitude() -> f32:
        (self.x * self.x + self.y * self.y).sqrt()

    fn length() -> f32:
        """Alias for magnitude."""
        self.magnitude()

    fn length_squared() -> f32:
        self.x * self.x + self.y * self.y

    me normalize() -> Vec2:
        val mag = self.magnitude()
        if mag > 0.0:
            return self.scale(1.0 / mag)
        Vec2(0.0, 0.0)

    me distance(other: Vec2) -> f32:
        self.sub(other).magnitude()

    me distance_to(other: Vec2) -> f32:
        """Alias for distance."""
        self.distance(other)

    me lerp(other: Vec2, t: f32) -> Vec2:
        Vec2(
            self.x + (other.x - self.x) * t,
            self.y + (other.y - self.y) * t
        )

    fn is_zero() -> bool:
        self.x == 0.0 and self.y == 0.0

    fn is_near_zero(epsilon: f32 = 1e-6) -> bool:
        self.magnitude() < epsilon

    fn is_finite() -> bool:
        self.x.is_finite() and self.y.is_finite()

    me component_min(other: Vec2) -> Vec2:
        Vec2(
            if self.x < other.x { self.x } else { other.x },
            if self.y < other.y { self.y } else { other.y }
        )

    me component_max(other: Vec2) -> Vec2:
        Vec2(
            if self.x > other.x { self.x } else { other.x },
            if self.y > other.y { self.y } else { other.y }
        )

    me to_f64() -> Vec2d:
        Vec2d(self.x as f64, self.y as f64)


# ============================================================================
# Vec2d - 2D Vector (f64)
# ============================================================================

class Vec2d:
    """2D vector with f64 precision."""
    x: f64
    y: f64

    fn __init__(x: f64, y: f64):
        self.x = x
        self.y = y

    static fn zero() -> Vec2d:
        Vec2d(0.0, 0.0)

    static fn one() -> Vec2d:
        Vec2d(1.0, 1.0)

    me add(other: Vec2d) -> Vec2d:
        Vec2d(self.x + other.x, self.y + other.y)

    me sub(other: Vec2d) -> Vec2d:
        Vec2d(self.x - other.x, self.y - other.y)

    me scale(scalar: f64) -> Vec2d:
        Vec2d(self.x * scalar, self.y * scalar)

    fn dot(other: Vec2d) -> f64:
        self.x * other.x + self.y * other.y

    fn magnitude() -> f64:
        (self.x * self.x + self.y * self.y).sqrt()

    fn length() -> f64:
        self.magnitude()

    fn length_squared() -> f64:
        self.x * self.x + self.y * self.y

    me normalize() -> Vec2d:
        val mag = self.magnitude()
        if mag > 0.0:
            return self.scale(1.0 / mag)
        Vec2d(0.0, 0.0)

    me distance(other: Vec2d) -> f64:
        self.sub(other).magnitude()

    me distance_to(other: Vec2d) -> f64:
        self.distance(other)

    me lerp(other: Vec2d, t: f64) -> Vec2d:
        Vec2d(
            self.x + (other.x - self.x) * t,
            self.y + (other.y - self.y) * t
        )

    fn is_zero() -> bool:
        self.x == 0.0 and self.y == 0.0

    fn is_near_zero(epsilon: f64 = 1e-12) -> bool:
        self.magnitude() < epsilon

    fn is_finite() -> bool:
        self.x.is_finite() and self.y.is_finite()

    me component_min(other: Vec2d) -> Vec2d:
        Vec2d(
            if self.x < other.x { self.x } else { other.x },
            if self.y < other.y { self.y } else { other.y }
        )

    me component_max(other: Vec2d) -> Vec2d:
        Vec2d(
            if self.x > other.x { self.x } else { other.x },
            if self.y > other.y { self.y } else { other.y }
        )

    me to_f32() -> Vec2:
        Vec2(self.x as f32, self.y as f32)


# ============================================================================
# Vec3 - 3D Vector (f32)
# ============================================================================

class Vec3:
    """3D vector with f32 precision."""
    x: f32
    y: f32
    z: f32

    fn __init__(x: f32, y: f32, z: f32):
        self.x = x
        self.y = y
        self.z = z

    # Statics
    static fn zero() -> Vec3:
        Vec3(0.0, 0.0, 0.0)

    static fn one() -> Vec3:
        Vec3(1.0, 1.0, 1.0)

    static fn up() -> Vec3:
        Vec3(0.0, 1.0, 0.0)

    static fn down() -> Vec3:
        Vec3(0.0, -1.0, 0.0)

    static fn left() -> Vec3:
        Vec3(-1.0, 0.0, 0.0)

    static fn right() -> Vec3:
        Vec3(1.0, 0.0, 0.0)

    static fn forward() -> Vec3:
        Vec3(0.0, 0.0, 1.0)

    static fn back() -> Vec3:
        Vec3(0.0, 0.0, -1.0)

    # Arithmetic
    me add(other: Vec3) -> Vec3:
        Vec3(self.x + other.x, self.y + other.y, self.z + other.z)

    me sub(other: Vec3) -> Vec3:
        Vec3(self.x - other.x, self.y - other.y, self.z - other.z)

    me scale(scalar: f32) -> Vec3:
        Vec3(self.x * scalar, self.y * scalar, self.z * scalar)

    fn dot(other: Vec3) -> f32:
        self.x * other.x + self.y * other.y + self.z * other.z

    me cross(other: Vec3) -> Vec3:
        Vec3(
            self.y * other.z - self.z * other.y,
            self.z * other.x - self.x * other.z,
            self.x * other.y - self.y * other.x
        )

    fn magnitude() -> f32:
        (self.x * self.x + self.y * self.y + self.z * self.z).sqrt()

    fn length() -> f32:
        self.magnitude()

    fn length_squared() -> f32:
        self.x * self.x + self.y * self.y + self.z * self.z

    me normalize() -> Vec3:
        val mag = self.magnitude()
        if mag > 0.0:
            return self.scale(1.0 / mag)
        Vec3(0.0, 0.0, 0.0)

    me distance(other: Vec3) -> f32:
        self.sub(other).magnitude()

    me distance_to(other: Vec3) -> f32:
        self.distance(other)

    me lerp(other: Vec3, t: f32) -> Vec3:
        Vec3(
            self.x + (other.x - self.x) * t,
            self.y + (other.y - self.y) * t,
            self.z + (other.z - self.z) * t
        )

    fn is_zero() -> bool:
        self.x == 0.0 and self.y == 0.0 and self.z == 0.0

    fn is_near_zero(epsilon: f32 = 1e-6) -> bool:
        self.magnitude() < epsilon

    fn is_finite() -> bool:
        self.x.is_finite() and self.y.is_finite() and self.z.is_finite()

    fn is_unit(epsilon: f32 = 1e-6) -> bool:
        (self.length_squared() - 1.0).abs() < epsilon

    fn has_nan() -> bool:
        self.x.is_nan() or self.y.is_nan() or self.z.is_nan()

    me component_min(other: Vec3) -> Vec3:
        Vec3(
            if self.x < other.x { self.x } else { other.x },
            if self.y < other.y { self.y } else { other.y },
            if self.z < other.z { self.z } else { other.z }
        )

    me component_max(other: Vec3) -> Vec3:
        Vec3(
            if self.x > other.x { self.x } else { other.x },
            if self.y > other.y { self.y } else { other.y },
            if self.z > other.z { self.z } else { other.z }
        )

    me to_f64() -> Vec3d:
        Vec3d(self.x as f64, self.y as f64, self.z as f64)


# ============================================================================
# Vec3d - 3D Vector (f64)
# ============================================================================

class Vec3d:
    """3D vector with f64 precision."""
    x: f64
    y: f64
    z: f64

    fn __init__(x: f64, y: f64, z: f64):
        self.x = x
        self.y = y
        self.z = z

    static fn zero() -> Vec3d:
        Vec3d(0.0, 0.0, 0.0)

    static fn create(x: f64, y: f64, z: f64) -> Vec3d:
        Vec3d(x, y, z)

    static fn one() -> Vec3d:
        Vec3d(1.0, 1.0, 1.0)

    static fn up() -> Vec3d:
        Vec3d(0.0, 1.0, 0.0)

    static fn down() -> Vec3d:
        Vec3d(0.0, -1.0, 0.0)

    static fn left() -> Vec3d:
        Vec3d(-1.0, 0.0, 0.0)

    static fn right() -> Vec3d:
        Vec3d(1.0, 0.0, 0.0)

    static fn forward() -> Vec3d:
        Vec3d(0.0, 0.0, 1.0)

    static fn back() -> Vec3d:
        Vec3d(0.0, 0.0, -1.0)

    me add(other: Vec3d) -> Vec3d:
        Vec3d(self.x + other.x, self.y + other.y, self.z + other.z)

    me sub(other: Vec3d) -> Vec3d:
        Vec3d(self.x - other.x, self.y - other.y, self.z - other.z)

    me scale(scalar: f64) -> Vec3d:
        Vec3d(self.x * scalar, self.y * scalar, self.z * scalar)

    fn dot(other: Vec3d) -> f64:
        self.x * other.x + self.y * other.y + self.z * other.z

    me cross(other: Vec3d) -> Vec3d:
        Vec3d(
            self.y * other.z - self.z * other.y,
            self.z * other.x - self.x * other.z,
            self.x * other.y - self.y * other.x
        )

    fn magnitude() -> f64:
        (self.x * self.x + self.y * self.y + self.z * self.z).sqrt()

    fn length() -> f64:
        self.magnitude()

    fn length_squared() -> f64:
        self.x * self.x + self.y * self.y + self.z * self.z

    me normalize() -> Vec3d:
        val mag = self.magnitude()
        if mag > 0.0:
            return self.scale(1.0 / mag)
        Vec3d(0.0, 0.0, 0.0)

    me distance(other: Vec3d) -> f64:
        self.sub(other).magnitude()

    me distance_to(other: Vec3d) -> f64:
        self.distance(other)

    me lerp(other: Vec3d, t: f64) -> Vec3d:
        Vec3d(
            self.x + (other.x - self.x) * t,
            self.y + (other.y - self.y) * t,
            self.z + (other.z - self.z) * t
        )

    fn is_zero() -> bool:
        self.x == 0.0 and self.y == 0.0 and self.z == 0.0

    fn is_near_zero(epsilon: f64 = 1e-12) -> bool:
        self.magnitude() < epsilon

    fn is_finite() -> bool:
        self.x.is_finite() and self.y.is_finite() and self.z.is_finite()

    fn is_unit(epsilon: f64 = 1e-12) -> bool:
        (self.length_squared() - 1.0).abs() < epsilon

    fn has_nan() -> bool:
        self.x.is_nan() or self.y.is_nan() or self.z.is_nan()

    me component_min(other: Vec3d) -> Vec3d:
        Vec3d(
            if self.x < other.x { self.x } else { other.x },
            if self.y < other.y { self.y } else { other.y },
            if self.z < other.z { self.z } else { other.z }
        )

    me component_max(other: Vec3d) -> Vec3d:
        Vec3d(
            if self.x > other.x { self.x } else { other.x },
            if self.y > other.y { self.y } else { other.y },
            if self.z > other.z { self.z } else { other.z }
        )

    me to_f32() -> Vec3:
        Vec3(self.x as f32, self.y as f32, self.z as f32)
