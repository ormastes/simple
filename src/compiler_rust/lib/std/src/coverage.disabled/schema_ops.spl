# Coverage Schema Operations Extension
# Part 2 of schema module: ModuleCoverage, CoverageSummary, and CoverageReport
# structs with their implementations.

# Coverage data for a module/file
struct ModuleCoverage:
    file: str
    functions: List<FunctionCoverage>

impl ModuleCoverage:
    fn new(file: str) -> ModuleCoverage:
        return ModuleCoverage(file: file, functions: [])

    fn add_function(func: FunctionCoverage):
        self.functions.push(func)

    fn function_count() -> u32:
        return len(self.functions) as u32

    fn total_decisions() -> u32:
        val total = 0
        for f in self.functions:
            total += f.decision_count()
        return total

    fn covered_decisions() -> u32:
        val covered = 0
        for f in self.functions:
            covered += f.covered_decision_count()
        return covered

    fn decision_coverage_percent() -> f64:
        val total = self.total_decisions()
        if total == 0:
            return 100.0
        return (self.covered_decisions() as f64) / (total as f64) * 100.0

    fn total_conditions() -> u32:
        val total = 0
        for f in self.functions:
            total += f.condition_count()
        return total

    fn covered_conditions() -> u32:
        val covered = 0
        for f in self.functions:
            covered += f.covered_condition_count()
        return covered

    fn condition_coverage_percent() -> f64:
        val total = self.total_conditions()
        if total == 0:
            return 100.0
        return (self.covered_conditions() as f64) / (total as f64) * 100.0

    fn total_paths() -> u32:
        val total = 0
        for f in self.functions:
            total += f.path_count()
        return total

    fn covered_paths() -> u32:
        val covered = 0
        for f in self.functions:
            covered += f.covered_path_count()
        return covered

    fn path_coverage_percent() -> f64:
        val total = self.total_paths()
        if total == 0:
            return 100.0
        return (self.covered_paths() as f64) / (total as f64) * 100.0

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn has_file(file_path: str) -> bool:
        """Check if module is for specific file."""
        return self.file == file_path

    fn has_functions() -> bool:
        """Check if module has any functions."""
        return len(self.functions) > 0

    fn is_empty() -> bool:
        """Check if module has no functions."""
        return len(self.functions) == 0

    fn has_decisions() -> bool:
        """Check if module has any decisions."""
        return self.total_decisions() > 0

    fn has_paths() -> bool:
        """Check if module has any paths."""
        return self.total_paths() > 0

    fn is_fully_decision_covered() -> bool:
        """Check if all decisions are covered."""
        return self.decision_coverage_percent() >= 100.0

    fn is_fully_condition_covered() -> bool:
        """Check if all conditions are covered."""
        return self.condition_coverage_percent() >= 100.0

    fn is_fully_path_covered() -> bool:
        """Check if all paths are covered."""
        return self.path_coverage_percent() >= 100.0

    fn has_uncovered_decisions() -> bool:
        """Check if any decisions are uncovered."""
        return self.covered_decisions() < self.total_decisions()

    fn has_uncovered_conditions() -> bool:
        """Check if any conditions are uncovered."""
        return self.covered_conditions() < self.total_conditions()

    fn summary() -> str:
        """Get summary of module coverage."""
        val dec_pct = self.decision_coverage_percent()
        val cond_pct = self.condition_coverage_percent()
        val path_pct = self.path_coverage_percent()
        return "Module '{self.file}': {self.function_count()} funcs, dec={dec_pct}%, cond={cond_pct}%, path={path_pct}%"

# Summary statistics for a coverage report
struct CoverageSummary:
    total_functions: u32
    covered_functions: u32
    total_decisions: u32
    covered_decisions: u32
    total_conditions: u32
    covered_conditions: u32
    total_paths: u32
    covered_paths: u32
    mc_dc_total: u32
    mc_dc_covered: u32

impl CoverageSummary:
    static fn new() -> CoverageSummary:
        return CoverageSummary(
            total_functions: 0,
            covered_functions: 0,
            total_decisions: 0,
            covered_decisions: 0,
            total_conditions: 0,
            covered_conditions: 0,
            total_paths: 0,
            covered_paths: 0,
            mc_dc_total: 0,
            mc_dc_covered: 0
        )

    fn function_percent() -> f64:
        if self.total_functions == 0:
            return 100.0
        return (self.covered_functions as f64) / (self.total_functions as f64) * 100.0

    fn decision_percent() -> f64:
        if self.total_decisions == 0:
            return 100.0
        return (self.covered_decisions as f64) / (self.total_decisions as f64) * 100.0

    fn condition_percent() -> f64:
        if self.total_conditions == 0:
            return 100.0
        return (self.covered_conditions as f64) / (self.total_conditions as f64) * 100.0

    fn path_percent() -> f64:
        if self.total_paths == 0:
            return 100.0
        return (self.covered_paths as f64) / (self.total_paths as f64) * 100.0

    fn mc_dc_percent() -> f64:
        if self.mc_dc_total == 0:
            return 100.0
        return (self.mc_dc_covered as f64) / (self.mc_dc_total as f64) * 100.0

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn has_functions() -> bool:
        """Check if summary has any functions."""
        return self.total_functions > 0

    fn has_decisions() -> bool:
        """Check if summary has any decisions."""
        return self.total_decisions > 0

    fn has_conditions() -> bool:
        """Check if summary has any conditions."""
        return self.total_conditions > 0

    fn has_paths() -> bool:
        """Check if summary has any paths."""
        return self.total_paths > 0

    fn is_fully_function_covered() -> bool:
        """Check if all functions are covered."""
        return self.function_percent() >= 100.0

    fn is_fully_decision_covered() -> bool:
        """Check if all decisions are covered."""
        return self.decision_percent() >= 100.0

    fn is_fully_condition_covered() -> bool:
        """Check if all conditions are covered."""
        return self.condition_percent() >= 100.0

    fn is_fully_path_covered() -> bool:
        """Check if all paths are covered."""
        return self.path_percent() >= 100.0

    fn is_fully_mc_dc_covered() -> bool:
        """Check if all decisions satisfy MC/DC."""
        return self.mc_dc_percent() >= 100.0

    fn is_fully_covered() -> bool:
        """Check if fully covered (all metrics at 100%)."""
        return self.is_fully_function_covered() and
               self.is_fully_decision_covered() and
               self.is_fully_condition_covered() and
               self.is_fully_path_covered()

    fn has_uncovered_functions() -> bool:
        """Check if any functions are uncovered."""
        return self.covered_functions < self.total_functions

    fn has_uncovered_decisions() -> bool:
        """Check if any decisions are uncovered."""
        return self.covered_decisions < self.total_decisions

    fn has_uncovered_paths() -> bool:
        """Check if any paths are uncovered."""
        return self.covered_paths < self.total_paths

    fn summary() -> str:
        """Get summary text."""
        val func_pct = self.function_percent()
        val dec_pct = self.decision_percent()
        val path_pct = self.path_percent()
        return "Coverage: funcs={func_pct}%, dec={dec_pct}%, paths={path_pct}%"

# Top-level coverage report
struct CoverageReport:
    version: str
    timestamp: str
    modules: List<ModuleCoverage>

impl CoverageReport:
    static fn new() -> CoverageReport:
        return CoverageReport(
            version: "1.0",
            timestamp: "",
            modules: []
        )

    fn add_module(module: ModuleCoverage):
        self.modules.push(module)

    fn module_count() -> u32:
        return len(self.modules) as u32

    fn summary() -> CoverageSummary:
        val s = CoverageSummary.new()
        for m in self.modules:
            for f in m.functions:
                s.total_functions += 1
                if f.entry_count > 0:
                    s.covered_functions += 1
                s.total_decisions += f.decision_count()
                s.covered_decisions += f.covered_decision_count()
                s.total_conditions += f.condition_count()
                s.covered_conditions += f.covered_condition_count()
                s.total_paths += f.path_count()
                s.covered_paths += f.covered_path_count()
                s.mc_dc_total += f.mc_dc_count()
                s.mc_dc_covered += f.mc_dc_covered_count()
        return s

    fn get_function(name: str) -> Option<FunctionCoverage>:
        for m in self.modules:
            for f in m.functions:
                if f.name == name:
                    return Some(f)
        return None

    fn get_module(file: str) -> Option<ModuleCoverage>:
        for m in self.modules:
            if m.file == file:
                return Some(m)
        return None

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn has_version() -> bool:
        """Check if version is set."""
        return not self.version.is_empty()

    fn has_timestamp() -> bool:
        """Check if timestamp is set."""
        return not self.timestamp.is_empty()

    fn has_modules() -> bool:
        """Check if report has any modules."""
        return len(self.modules) > 0

    fn is_empty() -> bool:
        """Check if report has no modules."""
        return len(self.modules) == 0

    fn has_function(name: str) -> bool:
        """Check if function exists in any module."""
        return self.get_function(name).is_some()

    fn has_module(file: str) -> bool:
        """Check if module exists for file."""
        return self.get_module(file).is_some()

    fn is_fully_covered() -> bool:
        """Check if all metrics are at 100%."""
        val s = self.summary()
        return s.is_fully_covered()

    fn has_uncovered_items() -> bool:
        """Check if any items are uncovered."""
        val s = self.summary()
        return s.has_uncovered_functions() or
               s.has_uncovered_decisions() or
               s.has_uncovered_paths()

    fn get_overall_percent() -> f64:
        """Get average coverage percentage across all metrics."""
        val s = self.summary()
        return (s.function_percent() +
                s.decision_percent() +
                s.condition_percent() +
                s.path_percent()) / 4.0

    fn summary_text() -> str:
        """Get summary text of coverage report."""
        val s = self.summary()
        val overall = self.get_overall_percent()
        return "CoverageReport v{self.version}: {self.module_count()} modules, {overall}% overall coverage"
