# Coverage Schema - Simple Class Definitions
# These define the structure for SDN coverage reports
#
# Coverage Metrics Supported:
# - Decision Coverage: Each decision taken both true and false
# - Condition Coverage: Each condition in decision taken both ways
# - MC/DC: Each condition independently affects decision outcome
# - Path Coverage: Each execution path hit at least once

# Source location for coverage data
struct SourceLoc:
    file: str
    line: u32
    column: u32

impl SourceLoc:
    fn new(file: str, line: u32, column: u32) -> SourceLoc:
        return SourceLoc(file: file, line: line, column: column)

    fn to_string() -> str:
        return "{self.file}:{self.line}:{self.column}"

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn has_file() -> bool:
        """Check if file path is set."""
        return not self.file.is_empty()

    fn is_at_line(line_num: u32) -> bool:
        """Check if location is at specific line."""
        return self.line == line_num

    fn is_at_column(col_num: u32) -> bool:
        """Check if location is at specific column."""
        return self.column == col_num

    fn summary() -> str:
        """Get summary of source location."""
        return "SourceLoc: {self.file}:{self.line}:{self.column}"

# A single condition within a decision
# Each condition must be evaluated both true and false for full coverage
struct Condition:
    id: u32
    loc: SourceLoc
    true_count: u64      # Times condition evaluated to true
    false_count: u64     # Times condition evaluated to false

impl Condition:
    fn new(id: u32, loc: SourceLoc) -> Condition:
        return Condition(
            id: id,
            loc: loc,
            true_count: 0,
            false_count: 0
        )

    fn is_covered() -> bool:
        # Condition is covered if evaluated both true and false
        return self.true_count > 0 and self.false_count > 0

    fn coverage_percent() -> f64:
        # 0% if neither, 50% if one, 100% if both
        val covered = 0
        if self.true_count > 0:
            covered += 1
        if self.false_count > 0:
            covered += 1
        return (covered as f64) / 2.0 * 100.0

    fn total_evaluations() -> u64:
        return self.true_count + self.false_count

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn has_true_evaluation() -> bool:
        """Check if condition was evaluated to true at least once."""
        return self.true_count > 0

    fn has_false_evaluation() -> bool:
        """Check if condition was evaluated to false at least once."""
        return self.false_count > 0

    fn is_fully_covered() -> bool:
        """Check if condition is fully covered (both true and false)."""
        return self.is_covered()

    fn is_uncovered() -> bool:
        """Check if condition is completely uncovered."""
        return self.true_count == 0 and self.false_count == 0

    fn is_partially_covered() -> bool:
        """Check if condition is partially covered (only true or false)."""
        return (self.true_count > 0) != (self.false_count > 0)

    fn has_id(cond_id: u32) -> bool:
        """Check if this is a specific condition ID."""
        return self.id == cond_id

    fn summary() -> str:
        """Get summary of condition coverage."""
        val percent = self.coverage_percent()
        return "Condition {self.id}: {percent}% covered (true={self.true_count}, false={self.false_count})"

# A decision (boolean expression with one or more conditions)
# For MC/DC, each condition must independently affect the decision outcome
struct Decision:
    id: u32
    loc: SourceLoc
    conditions: List<Condition>
    true_count: u64      # Times decision evaluated to true
    false_count: u64     # Times decision evaluated to false

impl Decision:
    fn new(id: u32, loc: SourceLoc) -> Decision:
        return Decision(
            id: id,
            loc: loc,
            conditions: [],
            true_count: 0,
            false_count: 0
        )

    fn add_condition(cond: Condition):
        self.conditions.push(cond)

    fn is_covered() -> bool:
        # Decision is covered if evaluated both true and false
        return self.true_count > 0 and self.false_count > 0

    fn condition_count() -> u32:
        return len(self.conditions) as u32

    fn covered_condition_count() -> u32:
        val covered = 0
        for cond in self.conditions:
            if cond.is_covered():
                covered += 1
        return covered

    fn condition_coverage_percent() -> f64:
        if len(self.conditions) == 0:
            return 100.0
        val total = 0
        val covered = 0
        for cond in self.conditions:
            total += 2  # Each condition has true and false
            if cond.true_count > 0:
                covered += 1
            if cond.false_count > 0:
                covered += 1
        return (covered as f64) / (total as f64) * 100.0

    fn mc_dc_covered() -> bool:
        # MC/DC requires:
        # 1. Decision coverage (both outcomes)
        # 2. Each condition independently affects decision
        if not self.is_covered():
            return false
        for cond in self.conditions:
            if not cond.is_covered():
                return false
        return true

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn has_true_outcome() -> bool:
        """Check if decision evaluated to true at least once."""
        return self.true_count > 0

    fn has_false_outcome() -> bool:
        """Check if decision evaluated to false at least once."""
        return self.false_count > 0

    fn is_fully_covered() -> bool:
        """Check if decision is fully covered (both outcomes)."""
        return self.is_covered()

    fn is_uncovered() -> bool:
        """Check if decision is completely uncovered."""
        return self.true_count == 0 and self.false_count == 0

    fn has_conditions() -> bool:
        """Check if decision has any conditions."""
        return len(self.conditions) > 0

    fn is_simple_decision() -> bool:
        """Check if decision has only one condition."""
        return len(self.conditions) == 1

    fn is_complex_decision() -> bool:
        """Check if decision has multiple conditions."""
        return len(self.conditions) > 1

    fn all_conditions_covered() -> bool:
        """Check if all conditions are covered."""
        if len(self.conditions) == 0:
            return true
        for cond in self.conditions:
            if not cond.is_covered():
                return false
        return true

    fn has_uncovered_conditions() -> bool:
        """Check if any conditions are uncovered."""
        return not self.all_conditions_covered()

    fn has_id(dec_id: u32) -> bool:
        """Check if this is a specific decision ID."""
        return self.id == dec_id

    fn summary() -> str:
        """Get summary of decision coverage."""
        val cond_count = len(self.conditions)
        val covered_conds = self.covered_condition_count()
        val mcdc = if self.mc_dc_covered(): "MC/DC✓" else: "MC/DC✗"
        return "Decision {self.id}: {covered_conds}/{cond_count} conditions, {mcdc}"

# An execution path through a function
# Represented as a sequence of basic block IDs
struct ExecutionPath:
    id: u32
    block_sequence: List<u32>  # Sequence of block IDs traversed
    hit_count: u64             # Number of times this path was taken

impl ExecutionPath:
    fn new(id: u32, blocks: List<u32>) -> ExecutionPath:
        return ExecutionPath(
            id: id,
            block_sequence: blocks,
            hit_count: 0
        )

    fn is_covered() -> bool:
        return self.hit_count > 0

    fn path_length() -> u32:
        return len(self.block_sequence) as u32

    fn blocks_string() -> str:
        # Format: [0 1 2 3]
        val parts = []
        for b in self.block_sequence:
            parts.push(str(b))
        return "[" + " ".join(parts) + "]"

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_uncovered() -> bool:
        """Check if path is completely uncovered."""
        return self.hit_count == 0

    fn is_frequently_hit(threshold: u64) -> bool:
        """Check if path hit count exceeds threshold."""
        return self.hit_count >= threshold

    fn has_blocks() -> bool:
        """Check if path has any blocks."""
        return len(self.block_sequence) > 0

    fn is_empty_path() -> bool:
        """Check if path has no blocks."""
        return len(self.block_sequence) == 0

    fn is_single_block() -> bool:
        """Check if path contains only one block."""
        return len(self.block_sequence) == 1

    fn contains_block(block_id: u32) -> bool:
        """Check if path contains specific block ID."""
        for b in self.block_sequence:
            if b == block_id:
                return true
        return false

    fn has_id(path_id: u32) -> bool:
        """Check if this is a specific path ID."""
        return self.id == path_id

    fn summary() -> str:
        """Get summary of execution path."""
        val blocks = self.blocks_string()
        val status = if self.is_covered(): "covered" else: "uncovered"
        return "Path {self.id}: {blocks} - {status} (hits={self.hit_count})"

# Coverage data for a single function
struct FunctionCoverage:
    name: str
    loc: SourceLoc
    decisions: List<Decision>
    paths: List<ExecutionPath>
    entry_count: u64           # Number of times function was called

impl FunctionCoverage:
    fn new(name: str, loc: SourceLoc) -> FunctionCoverage:
        return FunctionCoverage(
            name: name,
            loc: loc,
            decisions: [],
            paths: [],
            entry_count: 0
        )

    fn add_decision(decision: Decision):
        self.decisions.push(decision)

    fn add_path(path: ExecutionPath):
        self.paths.push(path)

    fn decision_count() -> u32:
        return len(self.decisions) as u32

    fn covered_decision_count() -> u32:
        val covered = 0
        for d in self.decisions:
            if d.is_covered():
                covered += 1
        return covered

    fn decision_coverage_percent() -> f64:
        if len(self.decisions) == 0:
            return 100.0
        val covered = 0
        for d in self.decisions:
            if d.is_covered():
                covered += 1
        return (covered as f64) / (len(self.decisions) as f64) * 100.0

    fn condition_count() -> u32:
        val total = 0
        for d in self.decisions:
            total += len(d.conditions)
        return total as u32

    fn covered_condition_count() -> u32:
        val covered = 0
        for d in self.decisions:
            for c in d.conditions:
                if c.is_covered():
                    covered += 1
        return covered

    fn condition_coverage_percent() -> f64:
        val total = 0
        val covered = 0
        for d in self.decisions:
            for c in d.conditions:
                total += 1
                if c.is_covered():
                    covered += 1
        if total == 0:
            return 100.0
        return (covered as f64) / (total as f64) * 100.0

    fn path_count() -> u32:
        return len(self.paths) as u32

    fn covered_path_count() -> u32:
        val covered = 0
        for p in self.paths:
            if p.is_covered():
                covered += 1
        return covered

    fn path_coverage_percent() -> f64:
        if len(self.paths) == 0:
            return 100.0
        val covered = 0
        for p in self.paths:
            if p.is_covered():
                covered += 1
        return (covered as f64) / (len(self.paths) as f64) * 100.0

    fn mc_dc_count() -> u32:
        return len(self.decisions) as u32

    fn mc_dc_covered_count() -> u32:
        val covered = 0
        for d in self.decisions:
            if d.mc_dc_covered():
                covered += 1
        return covered

    fn mc_dc_percent() -> f64:
        if len(self.decisions) == 0:
            return 100.0
        val covered = 0
        for d in self.decisions:
            if d.mc_dc_covered():
                covered += 1
        return (covered as f64) / (len(self.decisions) as f64) * 100.0

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn has_name(func_name: str) -> bool:
        """Check if function has specific name."""
        return self.name == func_name

    fn was_called() -> bool:
        """Check if function was called at least once."""
        return self.entry_count > 0

    fn is_uncalled() -> bool:
        """Check if function was never called."""
        return self.entry_count == 0

    fn has_decisions() -> bool:
        """Check if function has any decisions."""
        return len(self.decisions) > 0

    fn has_paths() -> bool:
        """Check if function has any execution paths."""
        return len(self.paths) > 0

    fn has_conditions() -> bool:
        """Check if function has any conditions."""
        return self.condition_count() > 0

    fn is_fully_decision_covered() -> bool:
        """Check if all decisions are covered."""
        return self.decision_coverage_percent() >= 100.0

    fn is_fully_condition_covered() -> bool:
        """Check if all conditions are covered."""
        return self.condition_coverage_percent() >= 100.0

    fn is_fully_path_covered() -> bool:
        """Check if all paths are covered."""
        return self.path_coverage_percent() >= 100.0

    fn is_fully_mc_dc_covered() -> bool:
        """Check if all decisions satisfy MC/DC."""
        return self.mc_dc_percent() >= 100.0

    fn is_fully_covered() -> bool:
        """Check if function is fully covered (all metrics at 100%)."""
        return self.is_fully_decision_covered() and
               self.is_fully_condition_covered() and
               self.is_fully_path_covered()

    fn has_uncovered_decisions() -> bool:
        """Check if any decisions are uncovered."""
        return self.covered_decision_count() < self.decision_count()

    fn has_uncovered_paths() -> bool:
        """Check if any paths are uncovered."""
        return self.covered_path_count() < self.path_count()

    fn summary() -> str:
        """Get summary of function coverage."""
        val dec_pct = self.decision_coverage_percent()
        val cond_pct = self.condition_coverage_percent()
        val path_pct = self.path_coverage_percent()
        return "Function '{self.name}': calls={self.entry_count}, dec={dec_pct}%, cond={cond_pct}%, path={path_pct}%"

# See schema_ops.spl for ModuleCoverage, CoverageSummary, and CoverageReport
# structs with their implementations.
