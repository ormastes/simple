# Graphics Unit Types
# Angular units and 3D semantic types for graphics programming
#
# Split into:
# - graphics_ops.spl (PBR material units, light units, dimension/index units)

use core.*
use graphics.math.*

# =============================================================================
# Angle Units
# =============================================================================

# Base unit: Radians (internal representation)
unit Radians: f32 as rad

# Derived unit: Degrees
unit Degrees: f32 as deg

# Unit family for automatic conversion
# 1 radian = 57.2957795 degrees
# 1 degree = 0.0174532925 radians
unit family Angle: f32 as rad
    Radians = 1.0
    Degrees = 57.2957795131  # 180/π

# Constants
const PI: f32 = 3.14159265359
const TAU: f32 = 6.28318530718  # 2π
const DEG_TO_RAD: f32 = 0.0174532925
const RAD_TO_DEG: f32 = 57.2957795131

# Radians implementation
impl Radians:
    fn from_f32(n: f32) -> Radians:
        return n_rad

    fn to_f32() -> f32:
        return self as f32

    fn zero() -> Radians:
        return 0.0_rad

    # Convert to degrees
    fn to_deg() -> Degrees:
        return ((self as f32) * RAD_TO_DEG)_deg

    # Normalize to [0, 2π)
    fn normalize() -> Radians:
        var angle = self as f32
        while angle >= TAU:
            angle = angle - TAU
        while angle < 0.0:
            angle = angle + TAU
        return angle_rad

    # Normalize to [-π, π)
    fn normalize_signed() -> Radians:
        var angle = self as f32
        while angle >= PI:
            angle = angle - TAU
        while angle < -PI:
            angle = angle + TAU
        return angle_rad

    # Trigonometric functions
    fn sin() -> f32:
        return sin(self as f32)

    fn cos() -> f32:
        return cos(self as f32)

    fn tan() -> f32:
        return tan(self as f32)

    # Arithmetic
    fn add(other: Radians) -> Radians:
        return ((self as f32) + (other as f32))_rad

    fn sub(other: Radians) -> Radians:
        return ((self as f32) - (other as f32))_rad

    fn mul(scalar: f32) -> Radians:
        return ((self as f32) * scalar)_rad

    fn div(scalar: f32) -> Radians:
        if scalar == 0.0:
            return 0.0_rad
        return ((self as f32) / scalar)_rad

    fn negate() -> Radians:
        return (-(self as f32))_rad

# Degrees implementation
impl Degrees:
    fn from_f32(n: f32) -> Degrees:
        return n_deg

    fn to_f32() -> f32:
        return self as f32

    fn zero() -> Degrees:
        return 0.0_deg

    # Convert to radians
    fn to_rad() -> Radians:
        return ((self as f32) * DEG_TO_RAD)_rad

    # Normalize to [0, 360)
    fn normalize() -> Degrees:
        var angle = self as f32
        while angle >= 360.0:
            angle = angle - 360.0
        while angle < 0.0:
            angle = angle + 360.0
        return angle_deg

    # Normalize to [-180, 180)
    fn normalize_signed() -> Degrees:
        var angle = self as f32
        while angle >= 180.0:
            angle = angle - 360.0
        while angle < -180.0:
            angle = angle + 360.0
        return angle_deg

    # Arithmetic
    fn add(other: Degrees) -> Degrees:
        return ((self as f32) + (other as f32))_deg

    fn sub(other: Degrees) -> Degrees:
        return ((self as f32) - (other as f32))_deg

    fn mul(scalar: f32) -> Degrees:
        return ((self as f32) * scalar)_deg

    fn div(scalar: f32) -> Degrees:
        if scalar == 0.0:
            return 0.0_deg
        return ((self as f32) / scalar)_deg

    fn negate() -> Degrees:
        return (-(self as f32))_deg

# =============================================================================
# Length Units (for 3D coordinates)
# =============================================================================

# Base unit: Meters
unit Meters: f32 as m

# Derived units
unit Centimeters: f32 as cm
unit Millimeters: f32 as mm
unit Kilometers: f32 as km
unit Pixels: f32 as px

# Unit family for automatic conversion
unit family Length: f32 as m
    Meters = 1.0
    Centimeters = 100.0
    Millimeters = 1000.0
    Kilometers = 0.001
    Pixels = 1.0  # 1:1 with meters for simplicity

# Meters implementation
impl Meters:
    fn from_f32(n: f32) -> Meters:
        return n_m

    fn to_f32() -> f32:
        return self as f32

    fn zero() -> Meters:
        return 0.0_m

    fn to_cm() -> Centimeters:
        return ((self as f32) * 100.0)_cm

    fn to_mm() -> Millimeters:
        return ((self as f32) * 1000.0)_mm

    fn to_km() -> Kilometers:
        return ((self as f32) * 0.001)_km

    fn to_px() -> Pixels:
        return ((self as f32))_px

# =============================================================================
# Semantic 3D Types
# =============================================================================

# Position3D - A point in 3D space (has a location)
# Uses parametric length unit U
pub struct Position3D<U>:
    x: U
    y: U
    z: U

impl<U> Position3D<U>:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_zero(self) -> bool:
        """Check if position is at origin."""
        return (self.x as f32) == 0.0 and (self.y as f32) == 0.0 and (self.z as f32) == 0.0

    pub fn is_valid(self) -> bool:
        """Check if all components are valid (not NaN or infinity)."""
        val x_val = self.x as f32
        val y_val = self.y as f32
        val z_val = self.z as f32
        return not (is_nan(x_val) or is_nan(y_val) or is_nan(z_val) or
                    is_infinite(x_val) or is_infinite(y_val) or is_infinite(z_val))

    pub fn manhattan_distance_to(self, other: Position3D<U>) -> U:
        """Calculate Manhattan (L1) distance to another position."""
        val dx = abs((other.x as f32) - (self.x as f32))
        val dy = abs((other.y as f32) - (self.y as f32))
        val dz = abs((other.z as f32) - (self.z as f32))
        return (dx + dy + dz) as U

    pub fn chebyshev_distance_to(self, other: Position3D<U>) -> U:
        """Calculate Chebyshev (L∞) distance to another position."""
        val dx = abs((other.x as f32) - (self.x as f32))
        val dy = abs((other.y as f32) - (self.y as f32))
        val dz = abs((other.z as f32) - (self.z as f32))
        return max(max(dx, dy), dz) as U

    pub fn midpoint(self, other: Position3D<U>) -> Position3D<U>:
        """Calculate midpoint between two positions."""
        return self.lerp(other, 0.5)

    pub fn summary(self) -> text:
        """Get summary of position."""
        return "Position3D: ({self.x as f32}, {self.y as f32}, {self.z as f32})"

    # =========================================================================
    # Constructor
    # =========================================================================

    pub fn new(x: U, y: U, z: U) -> Position3D<U>:
        return Position3D { x: x, y: y, z: z }

    pub fn origin() -> Position3D<U>:
        return Position3D {
            x: 0.0 as U,
            y: 0.0 as U,
            z: 0.0 as U
        }

    # Convert to raw Vec3
    pub fn to_vec3(self) -> Vec3:
        return Vec3.new(self.x as f32, self.y as f32, self.z as f32)

    # From raw Vec3
    pub fn from_vec3(v: Vec3) -> Position3D<U>:
        return Position3D {
            x: v.x as U,
            y: v.y as U,
            z: v.z as U
        }

    # Distance to another position
    pub fn distance_to(self, other: Position3D<U>) -> U:
        val dx = (other.x as f32) - (self.x as f32)
        val dy = (other.y as f32) - (self.y as f32)
        val dz = (other.z as f32) - (self.z as f32)
        return sqrt(dx * dx + dy * dy + dz * dz) as U

    # Lerp between positions
    pub fn lerp(self, other: Position3D<U>, t: f32) -> Position3D<U>:
        val x = (self.x as f32) + ((other.x as f32) - (self.x as f32)) * t
        val y = (self.y as f32) + ((other.y as f32) - (self.y as f32)) * t
        val z = (self.z as f32) + ((other.z as f32) - (self.z as f32)) * t
        return Position3D { x: x as U, y: y as U, z: z as U }

# Vector3D - A direction/displacement in 3D space (no location)
# Uses parametric length unit U
pub struct Vector3D<U>:
    x: U
    y: U
    z: U

impl<U> Vector3D<U>:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_zero(self) -> bool:
        """Check if this is a zero vector."""
        return (self.x as f32) == 0.0 and (self.y as f32) == 0.0 and (self.z as f32) == 0.0

    pub fn is_normalized(self) -> bool:
        """Check if vector has unit length (within tolerance)."""
        val len_sq = self.dot(self)
        return abs(len_sq - 1.0) < 0.0001

    pub fn is_valid(self) -> bool:
        """Check if all components are valid (not NaN or infinity)."""
        val x_val = self.x as f32
        val y_val = self.y as f32
        val z_val = self.z as f32
        return not (is_nan(x_val) or is_nan(y_val) or is_nan(z_val) or
                    is_infinite(x_val) or is_infinite(y_val) or is_infinite(z_val))

    pub fn is_parallel_to(self, other: Vector3D<U>) -> bool:
        """Check if this vector is parallel to another (within tolerance)."""
        # Vectors are parallel if their cross product is (near) zero
        val cross_prod = self.cross(other)
        val cross_len_sq = cross_prod.dot(cross_prod)
        return cross_len_sq < 0.0001

    pub fn is_perpendicular_to(self, other: Vector3D<U>) -> bool:
        """Check if this vector is perpendicular to another (within tolerance)."""
        # Vectors are perpendicular if their dot product is (near) zero
        val dot_prod = self.dot(other)
        return abs(dot_prod) < 0.0001

    pub fn angle_to(self, other: Vector3D<U>) -> Radians:
        """Calculate angle to another vector in radians."""
        val self_len = self.length() as f32
        val other_len = other.length() as f32

        if self_len < 0.0001 or other_len < 0.0001:
            return 0.0_rad

        val dot_prod = self.dot(other)
        val cos_angle = dot_prod / (self_len * other_len)

        # Clamp to [-1, 1] to avoid acos domain errors
        val clamped = max(-1.0, min(1.0, cos_angle))
        return acos(clamped)_rad

    pub fn length_squared(self) -> f32:
        """Get squared length (faster than length(), no sqrt)."""
        return self.dot(self)

    pub fn distance_to(self, other: Vector3D<U>) -> U:
        """Calculate distance to another vector."""
        val diff = self.sub(other)
        return diff.length()

    pub fn project_onto(self, onto: Vector3D<U>) -> Vector3D<U>:
        """Project this vector onto another vector."""
        val onto_len_sq = onto.dot(onto)
        if onto_len_sq < 0.0001:
            return Vector3D.zero()

        val scalar = self.dot(onto) / onto_len_sq
        return onto.scale(scalar)

    pub fn reflect(self, normal: Vector3D<U>) -> Vector3D<U>:
        """Reflect this vector across a surface with given normal."""
        val dot_prod = self.dot(normal)
        val reflection = normal.scale(2.0 * dot_prod)
        return self.sub(reflection)

    pub fn summary(self) -> text:
        """Get summary of vector."""
        val len = self.length() as f32
        return "Vector3D: ({self.x as f32}, {self.y as f32}, {self.z as f32}), length={len}"

    # =========================================================================
    # Constructor
    # =========================================================================

    pub fn new(x: U, y: U, z: U) -> Vector3D<U>:
        return Vector3D { x: x, y: y, z: z }

    pub fn zero() -> Vector3D<U>:
        return Vector3D {
            x: 0.0 as U,
            y: 0.0 as U,
            z: 0.0 as U
        }

    pub fn unit_x() -> Vector3D<U>:
        return Vector3D {
            x: 1.0 as U,
            y: 0.0 as U,
            z: 0.0 as U
        }

    pub fn unit_y() -> Vector3D<U>:
        return Vector3D {
            x: 0.0 as U,
            y: 1.0 as U,
            z: 0.0 as U
        }

    pub fn unit_z() -> Vector3D<U>:
        return Vector3D {
            x: 0.0 as U,
            y: 0.0 as U,
            z: 1.0 as U
        }

    # Convert to raw Vec3
    pub fn to_vec3(self) -> Vec3:
        return Vec3.new(self.x as f32, self.y as f32, self.z as f32)

    # From raw Vec3
    pub fn from_vec3(v: Vec3) -> Vector3D<U>:
        return Vector3D {
            x: v.x as U,
            y: v.y as U,
            z: v.z as U
        }

    # Vector operations
    pub fn dot(self, other: Vector3D<U>) -> f32:
        return (self.x as f32) * (other.x as f32) +
               (self.y as f32) * (other.y as f32) +
               (self.z as f32) * (other.z as f32)

    pub fn cross(self, other: Vector3D<U>) -> Vector3D<U>:
        return Vector3D {
            x: ((self.y as f32) * (other.z as f32) - (self.z as f32) * (other.y as f32)) as U,
            y: ((self.z as f32) * (other.x as f32) - (self.x as f32) * (other.z as f32)) as U,
            z: ((self.x as f32) * (other.y as f32) - (self.y as f32) * (other.x as f32)) as U
        }

    pub fn length(self) -> U:
        val len_sq = self.dot(self)
        return sqrt(len_sq) as U

    pub fn normalize(self) -> Vector3D<U>:
        val len = self.length() as f32
        if len < 0.0001:
            return Vector3D.unit_x()

        return Vector3D {
            x: ((self.x as f32) / len) as U,
            y: ((self.y as f32) / len) as U,
            z: ((self.z as f32) / len) as U
        }

    pub fn scale(self, scalar: f32) -> Vector3D<U>:
        return Vector3D {
            x: ((self.x as f32) * scalar) as U,
            y: ((self.y as f32) * scalar) as U,
            z: ((self.z as f32) * scalar) as U
        }

# Type-safe operations

# Position - Position = Vector
impl<U> Sub<Position3D<U>> for Position3D<U>:
    fn sub(other: Position3D<U>) -> Vector3D<U>:
        return Vector3D {
            x: ((self.x as f32) - (other.x as f32)) as U,
            y: ((self.y as f32) - (other.y as f32)) as U,
            z: ((self.z as f32) - (other.z as f32)) as U
        }

# Position + Vector = Position
impl<U> Add<Vector3D<U>> for Position3D<U>:
    fn add(vector: Vector3D<U>) -> Position3D<U>:
        return Position3D {
            x: ((self.x as f32) + (vector.x as f32)) as U,
            y: ((self.y as f32) + (vector.y as f32)) as U,
            z: ((self.z as f32) + (vector.z as f32)) as U
        }

# Vector + Vector = Vector
impl<U> Add for Vector3D<U>:
    fn add(other: Vector3D<U>) -> Vector3D<U>:
        return Vector3D {
            x: ((self.x as f32) + (other.x as f32)) as U,
            y: ((self.y as f32) + (other.y as f32)) as U,
            z: ((self.z as f32) + (other.z as f32)) as U
        }

# Vector - Vector = Vector
impl<U> Sub for Vector3D<U>:
    fn sub(other: Vector3D<U>) -> Vector3D<U>:
        return Vector3D {
            x: ((self.x as f32) - (other.x as f32)) as U,
            y: ((self.y as f32) - (other.y as f32)) as U,
            z: ((self.z as f32) - (other.z as f32)) as U
        }

# Vector * scalar = Vector
impl<U> Mul[f32] for Vector3D<U>:
    fn mul(scalar: f32) -> Vector3D<U>:
        return self.scale(scalar)

# -Vector = Vector
impl<U> Neg for Vector3D<U>:
    fn neg() -> Vector3D<U>:
        return Vector3D {
            x: (-(self.x as f32)) as U,
            y: (-(self.y as f32)) as U,
            z: (-(self.z as f32)) as U
        }
