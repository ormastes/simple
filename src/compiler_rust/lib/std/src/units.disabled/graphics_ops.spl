# Graphics Operations Unit Types
# PBR material units, light property units, and graphics dimension/index units
#
# Split from graphics.spl for size management.
# graphics.spl contains: Angle units, Length units, Position3D, Vector3D

use core.*
use graphics.math.*

# =============================================================================
# PBR Material Coefficient Units
# =============================================================================
# These units ensure type safety for material properties and prevent
# accidental mixing of different physical properties.

# Metallic coefficient (0.0 = dielectric, 1.0 = metal)
unit Metallic: f32 as metallic

# Surface roughness (0.0 = smooth/mirror-like, 1.0 = rough/diffuse)
unit Roughness: f32 as roughness

# Ambient occlusion factor (0.0 = fully occluded, 1.0 = no occlusion)
unit AmbientOcclusion: f32 as ao

# Opacity/alpha (0.0 = fully transparent, 1.0 = fully opaque)
unit Opacity: f32 as opacity

# Fresnel reflectance at normal incidence (0.0-1.0)
unit Reflectance: f32 as reflectance

# Generic normalized float (0.0-1.0) for other material properties
unit NormalizedFloat: f32 as nf

# Generic multiplicative factor
unit Factor: f32 as factor

# Metallic implementation
impl Metallic:
    pub fn from_f32(n: f32) -> Metallic:
        """Create Metallic from f32, clamping to valid range [0.0, 1.0]."""
        val clamped = max(0.0, min(1.0, n))
        return clamped_metallic

    pub fn value() -> f32:
        """Get the raw f32 value."""
        return self as f32

    pub fn zero() -> Metallic:
        """Pure dielectric (non-metal)."""
        return 0.0_metallic

    pub fn one() -> Metallic:
        """Pure metal."""
        return 1.0_metallic

    pub fn is_metal() -> bool:
        """Check if this represents a metal (metallic >= 0.9)."""
        return self.value() >= 0.9

    pub fn is_dielectric() -> bool:
        """Check if this represents a dielectric (metallic <= 0.1)."""
        return self.value() <= 0.1

    pub fn lerp(other: Metallic, t: f32) -> Metallic:
        """Linear interpolation between two metallic values."""
        val v1 = self.value()
        val v2 = other.value()
        val result = v1 + (v2 - v1) * t
        return Metallic.from_f32(result)

# Roughness implementation
impl Roughness:
    pub fn from_f32(n: f32) -> Roughness:
        """Create Roughness from f32, clamping to valid range [0.0, 1.0]."""
        val clamped = max(0.0, min(1.0, n))
        return clamped_roughness

    pub fn value() -> f32:
        """Get the raw f32 value."""
        return self as f32

    pub fn zero() -> Roughness:
        """Perfect mirror (no roughness)."""
        return 0.0_roughness

    pub fn one() -> Roughness:
        """Fully rough/diffuse surface."""
        return 1.0_roughness

    pub fn is_smooth() -> bool:
        """Check if surface is smooth (roughness <= 0.1)."""
        return self.value() <= 0.1

    pub fn is_rough() -> bool:
        """Check if surface is rough (roughness >= 0.9)."""
        return self.value() >= 0.9

    pub fn lerp(other: Roughness, t: f32) -> Roughness:
        """Linear interpolation between two roughness values."""
        val v1 = self.value()
        val v2 = other.value()
        val result = v1 + (v2 - v1) * t
        return Roughness.from_f32(result)

    pub fn perceptual() -> f32:
        """
        Convert linear roughness to perceptual roughness (sqrt).
        Useful for artist-friendly controls.
        """
        return sqrt(self.value())

    pub fn from_perceptual(perceptual: f32) -> Roughness:
        """
        Create roughness from perceptual value (squared).
        Converts artist-friendly perceptual roughness to physically-based linear.
        """
        val linear = perceptual * perceptual
        return Roughness.from_f32(linear)

# AmbientOcclusion implementation
impl AmbientOcclusion:
    pub fn from_f32(n: f32) -> AmbientOcclusion:
        """Create AO from f32, clamping to valid range [0.0, 1.0]."""
        val clamped = max(0.0, min(1.0, n))
        return clamped_ao

    pub fn value() -> f32:
        """Get the raw f32 value."""
        return self as f32

    pub fn zero() -> AmbientOcclusion:
        """Fully occluded."""
        return 0.0_ao

    pub fn one() -> AmbientOcclusion:
        """No occlusion."""
        return 1.0_ao

    pub fn lerp(other: AmbientOcclusion, t: f32) -> AmbientOcclusion:
        """Linear interpolation between two AO values."""
        val v1 = self.value()
        val v2 = other.value()
        val result = v1 + (v2 - v1) * t
        return AmbientOcclusion.from_f32(result)

# Opacity implementation
impl Opacity:
    pub fn from_f32(n: f32) -> Opacity:
        """Create Opacity from f32, clamping to valid range [0.0, 1.0]."""
        val clamped = max(0.0, min(1.0, n))
        return clamped_opacity

    pub fn value() -> f32:
        """Get the raw f32 value."""
        return self as f32

    pub fn transparent() -> Opacity:
        """Fully transparent."""
        return 0.0_opacity

    pub fn opaque() -> Opacity:
        """Fully opaque."""
        return 1.0_opacity

    pub fn is_transparent() -> bool:
        """Check if fully or nearly transparent."""
        return self.value() <= 0.01

    pub fn is_opaque() -> bool:
        """Check if fully or nearly opaque."""
        return self.value() >= 0.99

    pub fn lerp(other: Opacity, t: f32) -> Opacity:
        """Linear interpolation between two opacity values."""
        val v1 = self.value()
        val v2 = other.value()
        val result = v1 + (v2 - v1) * t
        return Opacity.from_f32(result)

# Reflectance implementation
impl Reflectance:
    pub fn from_f32(n: f32) -> Reflectance:
        """Create Reflectance from f32, clamping to valid range [0.0, 1.0]."""
        val clamped = max(0.0, min(1.0, n))
        return clamped_reflectance

    pub fn value() -> f32:
        """Get the raw f32 value."""
        return self as f32

    pub fn zero() -> Reflectance:
        """No reflectance."""
        return 0.0_reflectance

    pub fn one() -> Reflectance:
        """Full reflectance."""
        return 1.0_reflectance

    pub fn default_dielectric() -> Reflectance:
        """
        Default reflectance for common dielectrics (0.04).
        Corresponds to IOR ~1.5 (glass, plastic, etc.)
        """
        return 0.04_reflectance

    pub fn lerp(other: Reflectance, t: f32) -> Reflectance:
        """Linear interpolation between two reflectance values."""
        val v1 = self.value()
        val v2 = other.value()
        val result = v1 + (v2 - v1) * t
        return Reflectance.from_f32(result)

# NormalizedFloat implementation
impl NormalizedFloat:
    pub fn from_f32(n: f32) -> NormalizedFloat:
        """Create NormalizedFloat from f32, clamping to valid range [0.0, 1.0]."""
        val clamped = max(0.0, min(1.0, n))
        return clamped_nf

    pub fn value() -> f32:
        """Get the raw f32 value."""
        return self as f32

    pub fn zero() -> NormalizedFloat:
        return 0.0_nf

    pub fn one() -> NormalizedFloat:
        return 1.0_nf

    pub fn lerp(other: NormalizedFloat, t: f32) -> NormalizedFloat:
        """Linear interpolation between two normalized values."""
        val v1 = self.value()
        val v2 = other.value()
        val result = v1 + (v2 - v1) * t
        return NormalizedFloat.from_f32(result)

# Factor implementation (can be > 1.0)
impl Factor:
    pub fn from_f32(n: f32) -> Factor:
        """Create Factor from f32 (no clamping)."""
        return n_factor

    pub fn value() -> f32:
        """Get the raw f32 value."""
        return self as f32

    pub fn zero() -> Factor:
        return 0.0_factor

    pub fn one() -> Factor:
        return 1.0_factor

    pub fn mul(other: Factor) -> Factor:
        """Multiply two factors."""
        return (self.value() * other.value())_factor

    pub fn scale(n: f32) -> Factor:
        """Scale factor by a scalar."""
        return (self.value() * n)_factor

# =============================================================================
# Light Property Units
# =============================================================================

# Light intensity (can be > 1.0, typically in lumens or watts)
unit Intensity: f32 as intensity

# Luminance (brightness per unit area)
unit Luminance: f32 as lum

# Intensity implementation
impl Intensity:
    pub fn from_f32(n: f32) -> Intensity:
        """Create Intensity from f32 (clamped to non-negative)."""
        val clamped = max(0.0, n)
        return clamped_intensity

    pub fn value() -> f32:
        """Get the raw f32 value."""
        return self as f32

    pub fn zero() -> Intensity:
        """No light."""
        return 0.0_intensity

    pub fn one() -> Intensity:
        """Unit intensity."""
        return 1.0_intensity

    pub fn scale(factor: f32) -> Intensity:
        """Scale intensity by a factor."""
        return Intensity.from_f32(self.value() * factor)

    pub fn add(other: Intensity) -> Intensity:
        """Add two intensities."""
        return Intensity.from_f32(self.value() + other.value())

# Luminance implementation
impl Luminance:
    pub fn from_f32(n: f32) -> Luminance:
        """Create Luminance from f32 (clamped to non-negative)."""
        val clamped = max(0.0, n)
        return clamped_lum

    pub fn value() -> f32:
        """Get the raw f32 value."""
        return self as f32

    pub fn zero() -> Luminance:
        """No luminance."""
        return 0.0_lum

    pub fn scale(factor: f32) -> Luminance:
        """Scale luminance by a factor."""
        return Luminance.from_f32(self.value() * factor)

    pub fn add(other: Luminance) -> Luminance:
        """Add two luminance values."""
        return Luminance.from_f32(self.value() + other.value())

# =============================================================================
# Graphics Dimension Units (Counts)
# =============================================================================

# Pixel count (for texture/buffer sizes)
unit PixelCount: u32 as px_count

# Texture dimension size
unit TextureSize: u32 as tex_size

# Number of vertices in a mesh
unit VertexCount: u32 as vtx_count

# Number of indices in an index buffer
unit IndexCount: u32 as idx_count

# Mipmap level (0 = full resolution, increasing = smaller)
unit MipLevel: u32 as mip

# PixelCount implementation
impl PixelCount:
    pub fn from_u32(n: u32) -> PixelCount:
        return n_px_count

    pub fn value() -> u32:
        return self as u32

    pub fn zero() -> PixelCount:
        return 0_px_count

# TextureSize implementation
impl TextureSize:
    pub fn from_u32(n: u32) -> TextureSize:
        return n_tex_size

    pub fn value() -> u32:
        return self as u32

    pub fn is_power_of_two() -> bool:
        """Check if size is power of two (common for textures)."""
        val n = self.value()
        return n > 0 and (n & (n - 1)) == 0

    pub fn next_power_of_two() -> TextureSize:
        """Round up to next power of two."""
        var n = self.value()
        if n == 0:
            return 1_tex_size

        n = n - 1
        n = n | (n >> 1)
        n = n | (n >> 2)
        n = n | (n >> 4)
        n = n | (n >> 8)
        n = n | (n >> 16)
        return (n + 1)_tex_size

# VertexCount implementation
impl VertexCount:
    pub fn from_u32(n: u32) -> VertexCount:
        return n_vtx_count

    pub fn value() -> u32:
        return self as u32

    pub fn zero() -> VertexCount:
        return 0_vtx_count

    pub fn add(other: VertexCount) -> VertexCount:
        return (self.value() + other.value())_vtx_count

# IndexCount implementation
impl IndexCount:
    pub fn from_u32(n: u32) -> IndexCount:
        return n_idx_count

    pub fn value() -> u32:
        return self as u32

    pub fn zero() -> IndexCount:
        return 0_idx_count

    pub fn add(other: IndexCount) -> IndexCount:
        return (self.value() + other.value())_idx_count

    pub fn triangle_count() -> u32:
        """Get number of triangles (assuming triangle list topology)."""
        return self.value() / 3

# MipLevel implementation
impl MipLevel:
    pub fn from_u32(n: u32) -> MipLevel:
        return n_mip

    pub fn value() -> u32:
        return self as u32

    pub fn base_level() -> MipLevel:
        """Base mip level (full resolution)."""
        return 0_mip

    pub fn next_level() -> MipLevel:
        """Get next mip level (smaller resolution)."""
        return (self.value() + 1)_mip

    pub fn prev_level() -> MipLevel:
        """Get previous mip level (larger resolution), clamped to 0."""
        val current = self.value()
        if current == 0:
            return 0_mip
        return (current - 1)_mip

# =============================================================================
# Graphics Index Units
# =============================================================================

# Index into a vertex buffer
unit VertexIndex: i32 as vtx_idx

# Index into a light array
unit LightIndex: i32 as light_idx

# Layer index for layered rendering (e.g., cubemap faces)
unit LayerIndex: i32 as layer

# VertexIndex implementation
impl VertexIndex:
    pub fn from_i32(n: i32) -> VertexIndex:
        return n_vtx_idx

    pub fn value() -> i32:
        return self as i32

    pub fn invalid() -> VertexIndex:
        """Invalid index (-1)."""
        return (-1)_vtx_idx

    pub fn is_valid() -> bool:
        """Check if index is valid (>= 0)."""
        return self.value() >= 0

# LightIndex implementation
impl LightIndex:
    pub fn from_i32(n: i32) -> LightIndex:
        return n_light_idx

    pub fn value() -> i32:
        return self as i32

    pub fn invalid() -> LightIndex:
        """Invalid index (-1)."""
        return (-1)_light_idx

    pub fn is_valid() -> bool:
        """Check if index is valid (>= 0)."""
        return self.value() >= 0

# LayerIndex implementation
impl LayerIndex:
    pub fn from_i32(n: i32) -> LayerIndex:
        return n_layer

    pub fn value() -> i32:
        return self as i32

    pub fn zero() -> LayerIndex:
        """First layer."""
        return 0_layer

    pub fn is_valid() -> bool:
        """Check if index is valid (>= 0)."""
        return self.value() >= 0
