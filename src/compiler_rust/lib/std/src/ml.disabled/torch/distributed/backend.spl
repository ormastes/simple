# Distributed Backend and Reduction Operations
#
# Backend types and reduction operations for distributed training.

export Backend, ReduceOp

# ============================================================================
# Backend Enum
# ============================================================================

enum Backend:
    """Distributed backend type.

    - NCCL: NVIDIA Collective Communications Library (GPU-only, recommended)
    - GLOO: CPU and GPU support (cross-platform)
    - MPI: Message Passing Interface (research/HPC)
    """
    NCCL   # GPU-only, fastest for multi-GPU
    GLOO   # CPU and GPU, cross-platform
    MPI    # Research/HPC environments

    fn to_str(self) -> str:
        """Convert backend to string."""
        match self:
            Backend.NCCL -> "nccl"
            Backend.GLOO -> "gloo"
            Backend.MPI -> "mpi"

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_nccl(self) -> bool:
        """Check if this is NCCL backend.

        Returns:
            true for NCCL

        Example:
            Backend.NCCL.is_nccl()  # → true
        """
        match self:
            case NCCL: true
            case _: false

    fn is_gloo(self) -> bool:
        """Check if this is GLOO backend.

        Returns:
            true for GLOO

        Example:
            Backend.GLOO.is_gloo()  # → true
        """
        match self:
            case GLOO: true
            case _: false

    fn is_mpi(self) -> bool:
        """Check if this is MPI backend.

        Returns:
            true for MPI

        Example:
            Backend.MPI.is_mpi()  # → true
        """
        match self:
            case MPI: true
            case _: false

    fn is_gpu_only(self) -> bool:
        """Check if backend is GPU-only.

        Returns:
            true for NCCL

        Example:
            Backend.NCCL.is_gpu_only()  # → true
            Backend.GLOO.is_gpu_only()  # → false
        """
        match self:
            case NCCL: true
            case _: false

    fn supports_cpu(self) -> bool:
        """Check if backend supports CPU.

        Returns:
            true for GLOO and MPI

        Example:
            Backend.GLOO.supports_cpu()  # → true
            Backend.NCCL.supports_cpu()  # → false
        """
        match self:
            case GLOO: true
            case MPI: true
            case NCCL: false

    fn supports_gpu() -> bool:
        """Check if backend supports GPU.

        Returns:
            true for all backends

        Example:
            Backend.NCCL.supports_gpu()  # → true
        """
        true

    fn is_recommended(self) -> bool:
        """Check if this is the recommended backend.

        Returns:
            true for NCCL (best for multi-GPU)

        Example:
            Backend.NCCL.is_recommended()  # → true
        """
        match self:
            case NCCL: true
            case _: false

    fn description(self) -> text:
        """Get backend description.

        Returns:
            Human-readable description

        Example:
            Backend.NCCL.description()
            # → "NVIDIA Collective Communications Library (GPU-only)"
        """
        match self:
            case NCCL: "NVIDIA Collective Communications Library (GPU-only)"
            case GLOO: "CPU and GPU support (cross-platform)"
            case MPI: "Message Passing Interface (research/HPC)"

    fn summary(self) -> text:
        """Get summary of backend.

        Returns:
            Human-readable summary

        Example:
            Backend.NCCL.summary()
            # → "Backend: nccl (GPU-only, recommended)"
        """
        val name = self.to_str()
        val platform = if self.is_gpu_only():
                           "GPU-only"
                       else if self.supports_cpu():
                           "CPU/GPU"
                       else:
                           "multi-platform"
        val rec = if self.is_recommended(): ", recommended" else: ""
        return "Backend: {name} ({platform}{rec})"


# ============================================================================
# Reduction Operations
# ============================================================================

enum ReduceOp:
    """Reduction operation for collective communication.

    - SUM: Sum values across processes
    - PRODUCT: Multiply values across processes
    - MIN: Minimum value across processes
    - MAX: Maximum value across processes
    - BAND: Bitwise AND across processes
    - BOR: Bitwise OR across processes
    - BXOR: Bitwise XOR across processes
    """
    SUM
    PRODUCT
    MIN
    MAX
    BAND   # Bitwise AND
    BOR    # Bitwise OR
    BXOR   # Bitwise XOR

    fn code(self) -> i32:
        """Convert to FFI code."""
        match self:
            ReduceOp.SUM -> 0
            ReduceOp.PRODUCT -> 1
            ReduceOp.MIN -> 2
            ReduceOp.MAX -> 3
            ReduceOp.BAND -> 4
            ReduceOp.BOR -> 5
            ReduceOp.BXOR -> 6

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_sum(self) -> bool:
        """Check if this is SUM operation."""
        match self:
            case SUM: true
            case _: false

    fn is_product(self) -> bool:
        """Check if this is PRODUCT operation."""
        match self:
            case PRODUCT: true
            case _: false

    fn is_min(self) -> bool:
        """Check if this is MIN operation."""
        match self:
            case MIN: true
            case _: false

    fn is_max(self) -> bool:
        """Check if this is MAX operation."""
        match self:
            case MAX: true
            case _: false

    fn is_bitwise(self) -> bool:
        """Check if this is a bitwise operation.

        Returns:
            true for BAND, BOR, BXOR

        Example:
            ReduceOp.BAND.is_bitwise()  # → true
            ReduceOp.SUM.is_bitwise()  # → false
        """
        match self:
            case BAND: true
            case BOR: true
            case BXOR: true
            case _: false

    fn is_arithmetic(self) -> bool:
        """Check if this is an arithmetic operation.

        Returns:
            true for SUM, PRODUCT, MIN, MAX

        Example:
            ReduceOp.SUM.is_arithmetic()  # → true
            ReduceOp.BAND.is_arithmetic()  # → false
        """
        match self:
            case SUM: true
            case PRODUCT: true
            case MIN: true
            case MAX: true
            case _: false

    fn is_associative() -> bool:
        """Check if operation is associative.

        Returns:
            true for all reduce operations

        Example:
            ReduceOp.SUM.is_associative()  # → true
        """
        true

    fn is_commutative() -> bool:
        """Check if operation is commutative.

        Returns:
            true for all reduce operations

        Example:
            ReduceOp.SUM.is_commutative()  # → true
        """
        true

    fn to_string(self) -> text:
        """Convert operation to string.

        Returns:
            Operation name

        Example:
            ReduceOp.SUM.to_string()  # → "sum"
        """
        match self:
            case SUM: "sum"
            case PRODUCT: "product"
            case MIN: "min"
            case MAX: "max"
            case BAND: "band"
            case BOR: "bor"
            case BXOR: "bxor"

    fn description(self) -> text:
        """Get operation description.

        Returns:
            Human-readable description

        Example:
            ReduceOp.SUM.description()
            # → "Sum values across processes"
        """
        match self:
            case SUM: "Sum values across processes"
            case PRODUCT: "Multiply values across processes"
            case MIN: "Minimum value across processes"
            case MAX: "Maximum value across processes"
            case BAND: "Bitwise AND across processes"
            case BOR: "Bitwise OR across processes"
            case BXOR: "Bitwise XOR across processes"

    fn summary(self) -> text:
        """Get summary of reduce operation.

        Returns:
            Human-readable summary

        Example:
            ReduceOp.SUM.summary()
            # → "ReduceOp: sum (arithmetic, associative, commutative)"
        """
        val name = self.to_string()
        val kind = if self.is_arithmetic(): "arithmetic" else: "bitwise"
        return "ReduceOp: {name} ({kind}, associative, commutative)"
