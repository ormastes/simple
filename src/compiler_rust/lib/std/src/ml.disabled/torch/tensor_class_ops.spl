# Tensor Operations - Comparison, Reduction, and Indexing
#
# Extension methods for the Tensor class covering:
# - Comparison operations (gt, lt, ge, le, eq, ne, allclose)
# - Reduction operations (sum, mean, max, min, std, variance, norm)
# - Indexing operations (index, select, slice_dim, narrow, get, head, tail)

use tensor_ffi.{rt_torch_sum, rt_torch_mean, rt_torch_max, rt_torch_min, rt_torch_std, rt_torch_var, rt_torch_norm, rt_torch_index, rt_torch_slice, rt_torch_select, rt_torch_narrow, rt_torch_gt, rt_torch_allclose}
use tensor_class.{Tensor}


impl Tensor:
    # Comparison Operations
    fn gt(other: Tensor) -> Tensor:
        """Element-wise greater than comparison.

        Args:
            other: Tensor to compare with

        Returns:
            Boolean tensor (1.0 where self > other, 0.0 otherwise)

        Example:
            val a = Tensor.randn([2, 3])
            val b = Tensor.zeros([2, 3])
            val mask = a.gt(b)  # 1.0 where a > 0
        """
        return Tensor(rt_torch_gt(self.handle, other.handle))

    fn lt(other: Tensor) -> Tensor:
        """Element-wise less than comparison.

        Args:
            other: Tensor to compare with

        Returns:
            Boolean tensor (1.0 where self < other, 0.0 otherwise)

        Example:
            val a = Tensor.randn([2, 3])
            val b = Tensor.zeros([2, 3])
            val mask = a.lt(b)  # 1.0 where a < 0
        """
        return other.gt(self)

    fn ge(other: Tensor) -> Tensor:
        """Element-wise greater than or equal comparison.

        Args:
            other: Tensor to compare with

        Returns:
            Boolean tensor (1.0 where self >= other)
        """
        val less = self.lt(other)
        return less.mul_scalar(-1.0).add_scalar(1.0)

    fn le(other: Tensor) -> Tensor:
        """Element-wise less than or equal comparison.

        Args:
            other: Tensor to compare with

        Returns:
            Boolean tensor (1.0 where self <= other)
        """
        val greater = self.gt(other)
        return greater.mul_scalar(-1.0).add_scalar(1.0)

    fn eq(other: Tensor) -> Tensor:
        """Element-wise equality comparison.

        Args:
            other: Tensor to compare with

        Returns:
            Boolean tensor (1.0 where self == other)
        """
        val gt_mask = self.gt(other)
        val lt_mask = self.lt(other)
        val ne_mask = gt_mask.add(lt_mask)
        return ne_mask.mul_scalar(-1.0).add_scalar(1.0)

    fn ne(other: Tensor) -> Tensor:
        """Element-wise not equal comparison.

        Args:
            other: Tensor to compare with

        Returns:
            Boolean tensor (1.0 where self != other)
        """
        val eq_mask = self.eq(other)
        return eq_mask.mul_scalar(-1.0).add_scalar(1.0)

    fn allclose(other: Tensor, rtol: f64 = 1e-5, atol: f64 = 1e-8) -> bool:
        """Check if tensors are element-wise equal within tolerance.

        Args:
            other: Tensor to compare with
            rtol: Relative tolerance
            atol: Absolute tolerance

        Returns:
            true if all elements are close

        Example:
            val a = Tensor.ones([2, 3])
            val b = Tensor.ones([2, 3]).add_scalar(1e-7)
            a.allclose(b)  # → true
        """
        return rt_torch_allclose(self.handle, other.handle, rtol, atol) != 0

    # Reduction Operations
    fn sum() -> Tensor:
        """Sum all elements."""
        return Tensor(rt_torch_sum(self.handle, -1, 0))

    fn mean() -> Tensor:
        """Mean of all elements."""
        return Tensor(rt_torch_mean(self.handle, -1, 0))

    fn max() -> Tensor:
        """Maximum value of all elements.

        Returns:
            Scalar tensor with maximum value

        Example:
            val t = Tensor.randn([3, 4])
            val m = t.max()  # → scalar tensor
        """
        return Tensor(rt_torch_max(self.handle, -1, 0))

    fn max_dim(dim: i64, keepdim: bool = false) -> Tensor:
        """Maximum values along a dimension.

        Args:
            dim: Dimension to reduce
            keepdim: Keep reduced dimension as size 1

        Returns:
            Tensor with max values along dim

        Example:
            val t = Tensor.randn([3, 4])
            val m = t.max_dim(1)  # → shape [3]
        """
        return Tensor(rt_torch_max(self.handle, dim as i32, keepdim as i32))

    fn min() -> Tensor:
        """Minimum value of all elements.

        Returns:
            Scalar tensor with minimum value

        Example:
            val t = Tensor.randn([3, 4])
            val m = t.min()  # → scalar tensor
        """
        return Tensor(rt_torch_min(self.handle, -1, 0))

    fn min_dim(dim: i64, keepdim: bool = false) -> Tensor:
        """Minimum values along a dimension.

        Args:
            dim: Dimension to reduce
            keepdim: Keep reduced dimension as size 1

        Returns:
            Tensor with min values along dim

        Example:
            val t = Tensor.randn([3, 4])
            val m = t.min_dim(1)  # → shape [3]
        """
        return Tensor(rt_torch_min(self.handle, dim as i32, keepdim as i32))

    fn std(unbiased: bool = true) -> Tensor:
        """Standard deviation of all elements.

        Args:
            unbiased: Use Bessel's correction (N-1 denominator)

        Returns:
            Scalar tensor with standard deviation

        Example:
            val t = Tensor.randn([3, 4])
            val s = t.std()  # → scalar tensor
        """
        return Tensor(rt_torch_std(self.handle, -1, 0, unbiased as i32))

    fn std_dim(dim: i64, keepdim: bool = false, unbiased: bool = true) -> Tensor:
        """Standard deviation along a dimension.

        Args:
            dim: Dimension to reduce
            keepdim: Keep reduced dimension as size 1
            unbiased: Use Bessel's correction

        Returns:
            Tensor with std values along dim

        Example:
            val t = Tensor.randn([3, 4])
            val s = t.std_dim(1)  # → shape [3]
        """
        return Tensor(rt_torch_std(self.handle, dim as i32, keepdim as i32, unbiased as i32))

    fn variance(unbiased: bool = true) -> Tensor:
        """Variance of all elements.

        Args:
            unbiased: Use Bessel's correction (N-1 denominator)

        Returns:
            Scalar tensor with variance

        Example:
            val t = Tensor.randn([3, 4])
            val v = t.var()  # → scalar tensor
        """
        return Tensor(rt_torch_var(self.handle, -1, 0, unbiased as i32))

    fn variance_dim(dim: i64, keepdim: bool = false, unbiased: bool = true) -> Tensor:
        """Variance along a dimension.

        Args:
            dim: Dimension to reduce
            keepdim: Keep reduced dimension as size 1
            unbiased: Use Bessel's correction

        Returns:
            Tensor with variance values along dim

        Example:
            val t = Tensor.randn([3, 4])
            val v = t.var_dim(1)  # → shape [3]
        """
        return Tensor(rt_torch_var(self.handle, dim as i32, keepdim as i32, unbiased as i32))

    fn norm(p: f64 = 2.0) -> Tensor:
        """Lp norm of all elements.

        Args:
            p: Norm order (default: 2.0 for L2/Euclidean norm)

        Returns:
            Scalar tensor with norm value

        Example:
            val t = Tensor.randn([3, 4])
            val n = t.norm()      # → L2 norm
            val n1 = t.norm(1.0)  # → L1 norm
        """
        return Tensor(rt_torch_norm(self.handle, p, -1, 0))

    fn norm_dim(p: f64, dim: i64, keepdim: bool = false) -> Tensor:
        """Lp norm along a dimension.

        Args:
            p: Norm order
            dim: Dimension to reduce
            keepdim: Keep reduced dimension as size 1

        Returns:
            Tensor with norm values along dim

        Example:
            val t = Tensor.randn([3, 4])
            val n = t.norm_dim(2.0, 1)  # → shape [3]
        """
        return Tensor(rt_torch_norm(self.handle, p, dim as i32, keepdim as i32))

    # Indexing Operations
    fn index(idx: i64) -> Tensor:
        """Index into first dimension.

        Args:
            idx: Index along first dimension

        Returns:
            Tensor with first dimension indexed

        Example:
            val t = Tensor.randn([3, 4, 5])
            val r = t.index(1)  # → shape [4, 5]
        """
        return Tensor(rt_torch_index(self.handle, idx))

    fn select(dim: i64, idx: i64) -> Tensor:
        """Select single index along a dimension.

        Reduces the tensor by one dimension.

        Args:
            dim: Dimension to index into
            idx: Index to select

        Returns:
            Tensor with dimension removed

        Example:
            val t = Tensor.randn([3, 4, 5])
            val r = t.select(1, 2)  # → shape [3, 5]
        """
        return Tensor(rt_torch_select(self.handle, dim as i32, idx))

    fn slice_dim(dim: i64, start: i64, end: i64, step: i64 = 1) -> Tensor:
        """Slice along a dimension.

        Args:
            dim: Dimension to slice
            start: Start index (inclusive)
            end: End index (exclusive), use -1 for end
            step: Step size (default: 1)

        Returns:
            Sliced tensor

        Example:
            val t = Tensor.randn([10, 4])
            val r = t.slice_dim(0, 2, 8)     # → shape [6, 4]
            val s = t.slice_dim(0, 0, 10, 2) # → shape [5, 4] (every 2nd)
        """
        return Tensor(rt_torch_slice(self.handle, dim as i32, start, end, step))

    fn narrow(dim: i64, start: i64, length: i64) -> Tensor:
        """Narrow tensor along a dimension.

        Similar to slice but uses length instead of end index.

        Args:
            dim: Dimension to narrow
            start: Start index
            length: Number of elements to keep

        Returns:
            Narrowed tensor

        Example:
            val t = Tensor.randn([10, 4])
            val r = t.narrow(0, 2, 5)  # → shape [5, 4]
        """
        return Tensor(rt_torch_narrow(self.handle, dim as i32, start, length))

    fn get(indices: [i64]) -> Tensor:
        """Get element or sub-tensor by multiple indices.

        Args:
            indices: List of indices for each dimension

        Returns:
            Indexed tensor

        Example:
            val t = Tensor.randn([3, 4, 5])
            val r = t.get([1])        # → shape [4, 5]
            val s = t.get([1, 2])     # → shape [5]
            val v = t.get([1, 2, 3])  # → scalar tensor
        """
        var result = self
        var i = 0
        while i < indices.len():
            result = result.select(0, indices[i])
            i = i + 1
        return result

    fn head(n: i64) -> Tensor:
        """Get first n elements along first dimension.

        Args:
            n: Number of elements

        Returns:
            Tensor with first n elements

        Example:
            val t = Tensor.randn([10, 4])
            val h = t.head(3)  # → shape [3, 4]
        """
        return self.narrow(0, 0, n)

    fn tail(n: i64) -> Tensor:
        """Get last n elements along first dimension.

        Args:
            n: Number of elements

        Returns:
            Tensor with last n elements

        Example:
            val t = Tensor.randn([10, 4])
            val t = t.tail(3)  # → shape [3, 4]
        """
        val size = self.shape()[0]
        return self.narrow(0, size - n, n)
