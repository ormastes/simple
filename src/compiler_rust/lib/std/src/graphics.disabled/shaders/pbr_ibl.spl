# PBR with IBL - Enhanced PBR shader with Image-Based Lighting
#
# Integrates diffuse irradiance and specular reflection from environment
# maps for photorealistic global illumination.
#
# Based on: doc/spec/graphics_3d.md (Part 4.2 + 1.2: PBR + IBL)

use core.*
use graphics.math.*
use graphics.scene.*

# Import shared shader utilities
use graphics.shaders.shader_constants.{PI}
use graphics.shaders.shader_math.*
use graphics.shaders.pbr_common.*

# Import base PBR types
use graphics.shaders.pbr.{PBRVaryings}

# =============================================================================
# Enhanced PBR Uniforms with IBL
# =============================================================================

pub struct PBRIBLMaterialUniforms:
    # Base PBR properties
    albedo_color: Vec3
    metallic: f32
    roughness: f32
    ao: f32
    emissive: Vec3

    # Texture flags
    use_albedo_map: bool
    use_metallic_roughness_map: bool
    use_normal_map: bool
    use_ao_map: bool
    use_emissive_map: bool

    # IBL settings
    use_ibl: bool
    ibl_diffuse_intensity: f32    # Default: 1.0
    ibl_specular_intensity: f32   # Default: 1.0

# =============================================================================
# Enhanced PBR Fragment Shader with IBL
# =============================================================================

#[fragment_shader]
pub fn pbr_ibl_fragment_shader(
    varyings: PBRVaryings,
    material: PBRIBLMaterialUniforms,
    lighting: PBRLightingUniforms
) -> Vec4:
    # Sample textures (same as basic PBR)
    val albedo = if material.use_albedo_map:
        sample_texture_2d(albedo_map, varyings.tex_coord).rgb() * material.albedo_color
    else:
        material.albedo_color

    val metallic = if material.use_metallic_roughness_map:
        sample_texture_2d(metallic_roughness_map, varyings.tex_coord).b
    else:
        material.metallic

    val roughness = if material.use_metallic_roughness_map:
        sample_texture_2d(metallic_roughness_map, varyings.tex_coord).g
    else:
        material.roughness

    val ao = if material.use_ao_map:
        sample_texture_2d(ao_map, varyings.tex_coord).r
    else:
        material.ao

    val emissive = if material.use_emissive_map:
        sample_texture_2d(emissive_map, varyings.tex_coord).rgb() * material.emissive
    else:
        material.emissive

    # Get normal from normal map or vertex normal
    val N = if material.use_normal_map:
        val normal_sample = sample_texture_2d(normal_map, varyings.tex_coord).rgb()
        val normal_tangent = normal_sample * 2.0 - Vec3.one()

        val T = varyings.tangent_world.normalize()
        val B = varyings.bitangent_world.normalize()
        val N_base = varyings.normal_world.normalize()

        (T * normal_tangent.x + B * normal_tangent.y + N_base * normal_tangent.z).normalize()
    else:
        varyings.normal_world.normalize()

    val V = varyings.view_dir.normalize()

    # Calculate reflectance at normal incidence
    val F0 = calculate_f0(albedo, metallic)

    # =============================================================================
    # Direct Lighting (uses shared functions from pbr_common)
    # =============================================================================

    var Lo = Vec3.zero()

    # Directional light
    Lo = Lo + calculate_directional_light(N, V, albedo, metallic, roughness, F0, lighting)

    # Point lights
    for i in 0..lighting.point_light_count:
        Lo = Lo + calculate_point_light(
            varyings.position_world,
            N,
            V,
            albedo,
            metallic,
            roughness,
            F0,
            lighting.point_light_positions[i],
            lighting.point_light_colors[i],
            lighting.point_light_intensities[i],
            lighting.point_light_ranges[i]
        )

    # =============================================================================
    # Image-Based Lighting (IBL)
    # =============================================================================

    val ambient = if material.use_ibl:
        calculate_ibl_contribution(
            N=N,
            V=V,
            F0=F0,
            albedo=albedo,
            roughness=roughness,
            metallic=metallic,
            ao=ao,
            diffuse_intensity=material.ibl_diffuse_intensity,
            specular_intensity=material.ibl_specular_intensity
        )
    else:
        # Fallback to simple ambient
        val kD = (Vec3.one() - F0) * (1.0 - metallic)
        kD * albedo * lighting.ambient_color * lighting.ambient_intensity * ao

    # =============================================================================
    # Final Color
    # =============================================================================

    var color = ambient + Lo + emissive

    # HDR tone mapping (Reinhard)
    color = tone_map_reinhard(color)

    # Gamma correction
    color = linear_to_srgb(color)

    return Vec4.from_vec3(color, 1.0)

# =============================================================================
# IBL Contribution Calculation
# =============================================================================

fn calculate_ibl_contribution(
    N: Vec3,
    V: Vec3,
    F0: Vec3,
    albedo: Vec3,
    roughness: f32,
    metallic: f32,
    ao: f32,
    diffuse_intensity: f32,
    specular_intensity: f32
) -> Vec3:
    # Reflection vector
    val R = reflect(-V, N)

    # Fresnel for IBL (with roughness)
    val F = fresnel_schlick_roughness(max(dot(N, V), 0.0), F0, roughness)

    # Energy conservation
    val kS = F
    var kD = Vec3.one() - kS
    kD = kD * (1.0 - metallic)

    # =============================================================================
    # Diffuse IBL (Irradiance)
    # =============================================================================

    val irradiance = sample_cubemap(irradiance_map, N).rgb()
    val diffuse = irradiance * albedo

    # =============================================================================
    # Specular IBL (Prefiltered Environment + BRDF LUT)
    # =============================================================================

    # Sample prefiltered environment at appropriate roughness level
    val max_reflection_lod = 4.0  # Number of mip levels - 1
    val prefiltered_color = sample_cubemap_lod(
        prefiltered_env_map,
        R,
        roughness * max_reflection_lod
    ).rgb()

    # Sample BRDF integration LUT
    val NdotV = max(dot(N, V), 0.0)
    val brdf = sample_texture_2d(
        brdf_lut,
        Vec2.new(NdotV, roughness)
    ).rg()

    # Combine specular terms
    val specular = prefiltered_color * (F * brdf.x + brdf.y)

    # =============================================================================
    # Combine IBL
    # =============================================================================

    val ibl = (kD * diffuse * diffuse_intensity + specular * specular_intensity) * ao

    return ibl

# =============================================================================
# Texture Sampling
# =============================================================================

extern fn sample_texture_2d(texture_id: u64, uv: Vec2) -> Vec4
extern fn sample_cubemap(cubemap_id: u64, direction: Vec3) -> Vec4
extern fn sample_cubemap_lod(cubemap_id: u64, direction: Vec3, lod: f32) -> Vec4

extern fn albedo_map() -> u64
extern fn metallic_roughness_map() -> u64
extern fn normal_map() -> u64
extern fn ao_map() -> u64
extern fn emissive_map() -> u64

# IBL maps
extern fn irradiance_map() -> u64
extern fn prefiltered_env_map() -> u64
extern fn brdf_lut() -> u64
