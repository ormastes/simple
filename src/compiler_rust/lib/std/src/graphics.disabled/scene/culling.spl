# Culling - Frustum and occlusion culling systems
#
# Provides frustum culling for efficiently rejecting off-screen objects,
# and spatial queries for visibility determination.
#
# Based on: doc/spec/graphics_3d.md (Part 3: Rendering Pipeline)

use core.*
use graphics.math.*
use graphics.scene.*

# =============================================================================
# Plane - 3D plane for frustum definition
# =============================================================================

pub struct Plane:
    normal: Vec3    # Unit normal vector
    distance: f32   # Distance from origin along normal

impl Plane:
    # Create plane from normal and distance
    pub fn new(normal: Vec3, distance: f32) -> Plane:
        return Plane {normal: normal.normalize(), distance: distance}

    # Create plane from normal and point
    pub fn from_point(normal: Vec3, point: Vec3) -> Plane:
        val n = normal.normalize()
        val d = n.dot(point)
        return Plane {
            normal: n,
            distance: d
        }

    # Create plane from three points (counter-clockwise)
    pub fn from_points(p0: Vec3, p1: Vec3, p2: Vec3) -> Plane:
        val v1 = p1 - p0
        val v2 = p2 - p0
        val normal = v1.cross(v2).normalize()
        val distance = normal.dot(p0)
        return Plane {
            normal: normal,
            distance: distance
        }

    # Signed distance from point to plane (positive = in front)
    pub fn distance_to_point(self, point: Vec3) -> f32:
        return self.normal.dot(point) - self.distance

    # Check if point is in front of plane
    pub fn is_in_front(self, point: Vec3) -> bool:
        return self.distance_to_point(point) > 0.0

    # Normalize the plane
    pub fn normalize(mut self):
        val length = self.normal.length()
        self.normal = self.normal / length
        self.distance = self.distance / length

# =============================================================================
# Frustum - View frustum for culling
# =============================================================================

pub struct Frustum:
    planes: [Plane; 6]  # Left, Right, Top, Bottom, Near, Far

impl Frustum:
    # Create frustum from view-projection matrix
    pub fn from_view_proj(view_proj: Mat4) -> Frustum:
        # Extract frustum planes from matrix
        # Using Gribb-Hartmann method
        val m = view_proj

        # Left plane: m[3] + m[0]
        val left = Plane.new(
            Vec3.new(
                m.get(0, 3) + m.get(0, 0),
                m.get(1, 3) + m.get(1, 0),
                m.get(2, 3) + m.get(2, 0)
            ),
            m.get(3, 3) + m.get(3, 0)
        )

        # Right plane: m[3] - m[0]
        val right = Plane.new(
            Vec3.new(
                m.get(0, 3) - m.get(0, 0),
                m.get(1, 3) - m.get(1, 0),
                m.get(2, 3) - m.get(2, 0)
            ),
            m.get(3, 3) - m.get(3, 0)
        )

        # Bottom plane: m[3] + m[1]
        val bottom = Plane.new(
            Vec3.new(
                m.get(0, 3) + m.get(0, 1),
                m.get(1, 3) + m.get(1, 1),
                m.get(2, 3) + m.get(2, 1)
            ),
            m.get(3, 3) + m.get(3, 1)
        )

        # Top plane: m[3] - m[1]
        val top = Plane.new(
            Vec3.new(
                m.get(0, 3) - m.get(0, 1),
                m.get(1, 3) - m.get(1, 1),
                m.get(2, 3) - m.get(2, 1)
            ),
            m.get(3, 3) - m.get(3, 1)
        )

        # Near plane: m[3] + m[2]
        val near = Plane.new(
            Vec3.new(
                m.get(0, 3) + m.get(0, 2),
                m.get(1, 3) + m.get(1, 2),
                m.get(2, 3) + m.get(2, 2)
            ),
            m.get(3, 3) + m.get(3, 2)
        )

        # Far plane: m[3] - m[2]
        val far = Plane.new(
            Vec3.new(
                m.get(0, 3) - m.get(0, 2),
                m.get(1, 3) - m.get(1, 2),
                m.get(2, 3) - m.get(2, 2)
            ),
            m.get(3, 3) - m.get(3, 2)
        )

        return Frustum {
            planes: [left, right, top, bottom, near, far]
        }

    # Test if sphere is inside frustum
    pub fn contains_sphere(self, center: Vec3, radius: f32) -> bool:
        for plane in self.planes:
            if plane.distance_to_point(center) < -radius:
                return false  # Sphere is completely outside
        return true  # Sphere intersects or is inside

    # Test if AABB is inside frustum
    pub fn contains_aabb(self, aabb: AABB) -> bool:
        # Get AABB center and extents
        val center = aabb.center()
        val extents = (aabb.max - aabb.min) / 2.0

        # Test against each plane
        for plane in self.planes:
            # Get the positive vertex (farthest along normal)
            val p = Vec3.new(
                if plane.normal.x >= 0.0: extents.x else: -extents.x,
                if plane.normal.y >= 0.0: extents.y else: -extents.y,
                if plane.normal.z >= 0.0: extents.z else: -extents.z
            )

            if plane.distance_to_point(center + p) < 0.0:
                return false  # AABB is completely outside
        return true  # AABB intersects or is inside

    # Test if point is inside frustum
    pub fn contains_point(self, point: Vec3) -> bool:
        for plane in self.planes:
            if not plane.is_in_front(point):
                return false
        return true

# =============================================================================
# BoundingSphere - Bounding sphere for culling
# =============================================================================

pub struct BoundingSphere:
    center: Vec3
    radius: f32

impl BoundingSphere:
    pub fn new(center: Vec3, radius: f32) -> BoundingSphere:
        return BoundingSphere {
            center: center,
            radius: radius
        }

    # Create from AABB
    pub fn from_aabb(aabb: AABB) -> BoundingSphere:
        val center = aabb.center()
        val extents = aabb.max - aabb.min
        val radius = extents.length() / 2.0
        return BoundingSphere.new(center, radius)

    # Create from points
    pub fn from_points(points: Array<Vec3>) -> BoundingSphere:
        if points.len() == 0:
            return BoundingSphere.new(Vec3.zero(), 0.0)

        # Simple method: use AABB center and max distance
        var min = points[0]
        var max = points[0]

        for point in points:
            min = Vec3.new(
                math.min(min.x, point.x),
                math.min(min.y, point.y),
                math.min(min.z, point.z)
            )
            max = Vec3.new(
                math.max(max.x, point.x),
                math.max(max.y, point.y),
                math.max(max.z, point.z)
            )

        val center = (min + max) / 2.0
        var max_distance = 0.0

        for point in points:
            val distance = (point - center).length()
            max_distance = math.max(max_distance, distance)

        return BoundingSphere.new(center, max_distance)

    # Check if spheres intersect
    pub fn intersects(self, other: BoundingSphere) -> bool:
        val distance = (self.center - other.center).length()
        return distance <= (self.radius + other.radius)

    # Transform sphere by matrix
    pub fn transform(self, matrix: Mat4) -> BoundingSphere:
        val new_center = matrix.transform_point(self.center)
        # Approximate radius scaling (use max scale component)
        val scale = matrix.extract_scale()
        val max_scale = math.max(math.max(scale.x, scale.y), scale.z)
        val new_radius = self.radius * max_scale
        return BoundingSphere.new(new_center, new_radius)

# =============================================================================
# CullingStats - Statistics for culling operations
# =============================================================================

pub struct CullingStats:
    total_objects: i32
    culled_objects: i32
    visible_objects: i32
    tests_performed: i32

impl CullingStats:
    pub fn new() -> CullingStats:
        return CullingStats {total_objects: 0, culled_objects: 0, visible_objects: 0, tests_performed: 0}

    pub fn reset(mut self):
        self.total_objects = 0
        self.culled_objects = 0
        self.visible_objects = 0
        self.tests_performed = 0

    pub fn record_test(mut self, is_visible: bool):
        self.total_objects = self.total_objects + 1
        self.tests_performed = self.tests_performed + 1
        if is_visible:
            self.visible_objects = self.visible_objects + 1
        else:
            self.culled_objects = self.culled_objects + 1

    pub fn get_cull_ratio(self) -> f32:
        if self.total_objects == 0:
            return 0.0
        return (self.culled_objects as f32) / (self.total_objects as f32)

    pub fn print(self):
        io.println("Culling Statistics:")
        io.println("  Total Objects:   " + self.total_objects.to_string())
        io.println("  Visible Objects: " + self.visible_objects.to_string())
        io.println("  Culled Objects:  " + self.culled_objects.to_string())
        io.println("  Cull Ratio:      " + (self.get_cull_ratio() * 100.0).to_string() + "%")
        io.println("  Tests Performed: " + self.tests_performed.to_string())
