# Rust Grammar Extension
# Part 2 of grammar_rust module: add_statements, add_expressions, add_patterns, add_types, add_common.

use simple_grammar.{Grammar, Token}

impl RustGrammarBuilder:
    # Statements
    me add_statements():
        self.grammar.add_rule("statement", choice([
            ref("let_statement"),
            ref("expression_statement"),
            ref("item")
        ]))

        self.grammar.add_rule("let_statement", seq([
            token(Let),
            optional(token(Mut)),
            ref("pattern"),
            optional(seq([token(Colon), ref("type")])),
            optional(seq([token(Equals), ref("expression")])),
            token(Semicolon)
        ]))

        self.grammar.add_rule("expression_statement", seq([
            ref("expression"),
            optional(token(Semicolon))
        ]))

    # Expressions
    me add_expressions():
        # Expression hierarchy (precedence order)
        self.grammar.add_rule("expression", choice([
            ref("return_expression"),
            ref("break_expression"),
            ref("continue_expression"),
            ref("range_expression")
        ]))

        self.grammar.add_rule("return_expression", seq([
            token(Return),
            optional(ref("expression"))
        ]))

        self.grammar.add_rule("break_expression", seq([
            token(Break),
            optional(ref("expression"))
        ]))

        self.grammar.add_rule("continue_expression", token(Continue))

        self.grammar.add_rule("range_expression", binary_op(
            ref("or_expression"),
            choice([token(DotDot), token(DotDotEquals)])
        ))

        self.grammar.add_rule("or_expression", binary_op(
            ref("and_expression"),
            token(PipePipe)
        ))

        self.grammar.add_rule("and_expression", binary_op(
            ref("comparison"),
            token(AmpersandAmpersand)
        ))

        self.grammar.add_rule("comparison", binary_op(
            ref("bitwise_or"),
            choice([
                token(Less), token(Greater), token(LessEquals),
                token(GreaterEquals), token(EqualsEquals), token(NotEquals)
            ])
        ))

        self.grammar.add_rule("bitwise_or", binary_op(
            ref("bitwise_xor"),
            token(Pipe)
        ))

        self.grammar.add_rule("bitwise_xor", binary_op(
            ref("bitwise_and"),
            token(Caret)
        ))

        self.grammar.add_rule("bitwise_and", binary_op(
            ref("shift_expression"),
            token(Ampersand)
        ))

        self.grammar.add_rule("shift_expression", binary_op(
            ref("additive_expression"),
            choice([token(LShift), token(RShift)])
        ))

        self.grammar.add_rule("additive_expression", binary_op(
            ref("multiplicative_expression"),
            choice([token(Plus), token(Minus)])
        ))

        self.grammar.add_rule("multiplicative_expression", binary_op(
            ref("cast_expression"),
            choice([token(Star), token(Slash), token(Percent)])
        ))

        self.grammar.add_rule("cast_expression", binary_op(
            ref("unary_expression"),
            token(As)
        ))

        self.grammar.add_rule("unary_expression", choice([
            seq([choice([token(Minus), token(Not), token(Star), token(Ampersand)]), ref("primary_expression")]),
            ref("primary_expression")
        ]))

        # Primary expressions
        self.grammar.add_rule("primary_expression", choice([
            ref("literal_expression"),
            ref("identifier"),
            ref("call_expression"),
            ref("field_expression"),
            ref("index_expression"),
            ref("macro_invocation"),
            ref("struct_expression"),
            ref("tuple_expression"),
            ref("array_expression"),
            ref("parenthesized_expression"),
            ref("block_expression"),
            ref("if_expression"),
            ref("match_expression"),
            ref("while_expression"),
            ref("for_expression"),
            ref("loop_expression"),
            ref("closure_expression")
        ]))

        # Literals
        self.grammar.add_rule("literal_expression", choice([
            token(Integer),
            token(f32),
            token(text),
            token(Char),
            token(True),
            token(False)
        ]))

        # Call/field/index
        self.grammar.add_rule("call_expression", seq([
            ref("expression"),
            token(LParen),
            optional(ref("argument_list")),
            token(RParen)
        ]))

        self.grammar.add_rule("field_expression", seq([
            ref("expression"),
            token(Dot),
            choice([ref("identifier"), token(Integer)])
        ]))

        self.grammar.add_rule("index_expression", seq([
            ref("expression"),
            token(LBracket),
            ref("expression"),
            token(RBracket)
        ]))

        # Struct/tuple/array
        self.grammar.add_rule("struct_expression", seq([
            ref("type"),
            token(LBrace),
            optional(ref("field_initializers")),
            token(RBrace)
        ]))

        self.grammar.add_rule("tuple_expression", seq([
            token(LParen),
            optional(ref("expression_list")),
            token(RParen)
        ]))

        self.grammar.add_rule("array_expression", seq([
            token(LBracket),
            optional(ref("array_elements")),
            token(RBracket)
        ]))

        # Control flow
        self.grammar.add_rule("block_expression", seq([
            token(LBrace),
            repeat(ref("statement")),
            optional(ref("expression")),
            token(RBrace)
        ]))

        self.grammar.add_rule("if_expression", seq([
            token(If),
            ref("expression"),
            ref("block"),
            optional(seq([token(Else), choice([ref("if_expression"), ref("block")])]))
        ]))

        self.grammar.add_rule("match_expression", seq([
            token(Match),
            ref("expression"),
            token(LBrace),
            repeat(ref("match_arm")),
            token(RBrace)
        ]))

        self.grammar.add_rule("while_expression", seq([
            token(While),
            ref("expression"),
            ref("block")
        ]))

        self.grammar.add_rule("for_expression", seq([
            token(For),
            ref("pattern"),
            token(In),
            ref("expression"),
            ref("block")
        ]))

        self.grammar.add_rule("loop_expression", seq([
            token(Loop),
            ref("block")
        ]))

        self.grammar.add_rule("closure_expression", seq([
            token(Pipe),
            optional(ref("closure_parameters")),
            token(Pipe),
            choice([ref("expression"), ref("block")])
        ]))

    # Patterns
    me add_patterns():
        self.grammar.add_rule("pattern", choice([
            ref("literal_pattern"),
            ref("identifier_pattern"),
            ref("wildcard_pattern"),
            ref("tuple_pattern"),
            ref("struct_pattern"),
            ref("or_pattern"),
            ref("ref_pattern")
        ]))

        self.grammar.add_rule("literal_pattern", ref("literal_expression"))
        self.grammar.add_rule("identifier_pattern", ref("identifier"))
        self.grammar.add_rule("wildcard_pattern", token(Underscore))

        self.grammar.add_rule("tuple_pattern", seq([
            token(LParen),
            optional(ref("pattern_list")),
            token(RParen)
        ]))

        self.grammar.add_rule("struct_pattern", seq([
            ref("type"),
            token(LBrace),
            optional(ref("field_patterns")),
            token(RBrace)
        ]))

        self.grammar.add_rule("or_pattern", binary_op(
            ref("pattern"),
            token(Pipe)
        ))

        self.grammar.add_rule("ref_pattern", seq([
            token(Ref),
            optional(token(Mut)),
            ref("pattern")
        ]))

    # Types
    me add_types():
        self.grammar.add_rule("type", choice([
            ref("primitive_type"),
            ref("type_identifier"),
            ref("generic_type"),
            ref("reference_type"),
            ref("pointer_type"),
            ref("tuple_type"),
            ref("array_type"),
            ref("function_type"),
            ref("impl_trait_type"),
            ref("dyn_trait_type")
        ]))

        self.grammar.add_rule("primitive_type", choice([
            token(I8), token(I16), token(I32), token(I64), token(I128),
            token(U8), token(U16), token(U32), token(U64), token(U128),
            token(F32), token(F64),
            token(bool), token(Char), token(Str)
        ]))

        self.grammar.add_rule("generic_type", seq([
            ref("type"),
            token(Less),
            ref("type_list"),
            token(Greater)
        ]))

        self.grammar.add_rule("reference_type", seq([
            token(Ampersand),
            optional(ref("lifetime")),
            optional(token(Mut)),
            ref("type")
        ]))

        self.grammar.add_rule("pointer_type", seq([
            token(Star),
            choice([token(Const), token(Mut)]),
            ref("type")
        ]))

        self.grammar.add_rule("tuple_type", seq([
            token(LParen),
            optional(ref("type_list")),
            token(RParen)
        ]))

        self.grammar.add_rule("array_type", seq([
            token(LBracket),
            ref("type"),
            token(Semicolon),
            ref("expression"),
            token(RBracket)
        ]))

        self.grammar.add_rule("function_type", seq([
            token(Fn),
            token(LParen),
            optional(ref("type_list")),
            token(RParen),
            optional(seq([token(Arrow), ref("type")]))
        ]))

        self.grammar.add_rule("impl_trait_type", seq([
            token(Impl),
            ref("type_bounds")
        ]))

        self.grammar.add_rule("dyn_trait_type", seq([
            token(Dyn),
            ref("type_bounds")
        ]))

    # Common elements
    me add_common():
        self.grammar.add_rule("identifier", token(Identifier))
        self.grammar.add_rule("type_identifier", token(TypeIdentifier))

        self.grammar.add_rule("visibility", choice([
            token(Pub),
            seq([token(Pub), token(LParen), ref("visibility_modifier"), token(RParen)])
        ]))

        self.grammar.add_rule("visibility_modifier", choice([
            token(Crate),
            token(Super),
            token(SelfValue),
            seq([token(In), ref("use_path")])
        ]))

        self.grammar.add_rule("generic_params", seq([
            token(Less),
            ref("generic_param_list"),
            token(Greater)
        ]))

        self.grammar.add_rule("where_clause", seq([
            token(Where),
            ref("where_predicates")
        ]))

        self.grammar.add_rule("type_bounds", seq([
            ref("type"),
            repeat(seq([token(Plus), ref("type")]))
        ]))

        self.grammar.add_rule("lifetime", token(Lifetime))

        self.grammar.add_rule("attribute", seq([
            token(Hash),
            token(LBracket),
            ref("attribute_item"),
            token(RBracket)
        ]))

        self.grammar.add_rule("parameters", seq([
            ref("parameter"),
            repeat(seq([token(Comma), ref("parameter")])),
            optional(token(Comma))
        ]))

        self.grammar.add_rule("parameter", seq([
            optional(token(Mut)),
            ref("pattern"),
            token(Colon),
            ref("type")
        ]))

        self.grammar.add_rule("block", seq([
            token(LBrace),
            repeat(ref("statement")),
            optional(ref("expression")),
            token(RBrace)
        ]))

        self.grammar.add_rule("match_arm", seq([
            ref("pattern"),
            optional(seq([token(If), ref("expression")])),
            token(FatArrow),
            ref("expression"),
            optional(token(Comma))
        ]))

        self.grammar.add_rule("fields", seq([
            ref("field"),
            repeat(seq([token(Comma), ref("field")])),
            optional(token(Comma))
        ]))

        self.grammar.add_rule("field", seq([
            optional(ref("visibility")),
            ref("identifier"),
            token(Colon),
            ref("type")
        ]))

        self.grammar.add_rule("tuple_fields", seq([
            ref("tuple_field"),
            repeat(seq([token(Comma), ref("tuple_field")])),
            optional(token(Comma))
        ]))

        self.grammar.add_rule("tuple_field", seq([
            optional(ref("visibility")),
            ref("type")
        ]))

        self.grammar.add_rule("expression_list", seq([
            ref("expression"),
            repeat(seq([token(Comma), ref("expression")])),
            optional(token(Comma))
        ]))

        self.grammar.add_rule("type_list", seq([
            ref("type"),
            repeat(seq([token(Comma), ref("type")])),
            optional(token(Comma))
        ]))

        self.grammar.add_rule("pattern_list", seq([
            ref("pattern"),
            repeat(seq([token(Comma), ref("pattern")])),
            optional(token(Comma))
        ]))

        self.grammar.add_rule("use_path", seq([
            ref("identifier"),
            repeat(seq([token(ColonColon), ref("identifier")]))
        ]))

        self.grammar.add_rule("use_list", seq([
            ref("use_tree"),
            repeat(seq([token(Comma), ref("use_tree")])),
            optional(token(Comma))
        ]))

        self.grammar.add_rule("argument_list", seq([
            ref("expression"),
            repeat(seq([token(Comma), ref("expression")])),
            optional(token(Comma))
        ]))

        self.grammar.add_rule("field_initializers", seq([
            ref("field_initializer"),
            repeat(seq([token(Comma), ref("field_initializer")])),
            optional(token(Comma))
        ]))

        self.grammar.add_rule("field_initializer", seq([
            ref("identifier"),
            token(Colon),
            ref("expression")
        ]))

        self.grammar.add_rule("field_patterns", seq([
            ref("field_pattern"),
            repeat(seq([token(Comma), ref("field_pattern")])),
            optional(token(Comma))
        ]))

        self.grammar.add_rule("field_pattern", seq([
            ref("identifier"),
            optional(seq([token(Colon), ref("pattern")]))
        ]))

        self.grammar.add_rule("array_elements", choice([
            ref("expression_list"),
            seq([ref("expression"), token(Semicolon), ref("expression")])
        ]))

        self.grammar.add_rule("closure_parameters", seq([
            ref("closure_parameter"),
            repeat(seq([token(Comma), ref("closure_parameter")])),
            optional(token(Comma))
        ]))

        self.grammar.add_rule("closure_parameter", seq([
            ref("pattern"),
            optional(seq([token(Colon), ref("type")]))
        ]))

        self.grammar.add_rule("macro_invocation", seq([
            ref("identifier"),
            token(Bang),
            choice([
                seq([token(LParen), token(RParen)]),
                seq([token(LBracket), token(RBracket)]),
                seq([token(LBrace), token(RBrace)])
            ])
        ]))

        self.grammar.add_rule("extern_abi", seq([
            token(Extern),
            optional(token(text))
        ]))

        self.grammar.add_rule("function_signature", seq([
            token(Fn),
            ref("identifier"),
            optional(ref("generic_params")),
            token(LParen),
            optional(ref("parameters")),
            token(RParen),
            optional(seq([token(Arrow), ref("type")])),
            token(Semicolon)
        ]))

        self.grammar.add_rule("associated_type", seq([
            token(Type),
            ref("type_identifier"),
            optional(ref("type_bounds")),
            token(Semicolon)
        ]))

        self.grammar.add_rule("generic_param_list", seq([
            ref("generic_param"),
            repeat(seq([token(Comma), ref("generic_param")])),
            optional(token(Comma))
        ]))

        self.grammar.add_rule("generic_param", choice([
            seq([ref("lifetime"), optional(ref("lifetime_bounds"))]),
            seq([ref("type_identifier"), optional(ref("type_bounds"))]),
            seq([token(Const), ref("identifier"), token(Colon), ref("type")])
        ]))

        self.grammar.add_rule("lifetime_bounds", seq([
            token(Colon),
            ref("lifetime"),
            repeat(seq([token(Plus), ref("lifetime")]))
        ]))

        self.grammar.add_rule("where_predicates", seq([
            ref("where_predicate"),
            repeat(seq([token(Comma), ref("where_predicate")])),
            optional(token(Comma))
        ]))

        self.grammar.add_rule("where_predicate", seq([
            choice([ref("lifetime"), ref("type")]),
            token(Colon),
            ref("type_bounds")
        ]))

        self.grammar.add_rule("attribute_item", ref("use_path"))

        self.grammar.add_rule("parenthesized_expression", seq([
            token(LParen),
            ref("expression"),
            token(RParen)
        ]))
