# Grammar Declarations
#
# Top-level declaration rules: function, class, struct, enum, trait, import.

use simple_grammar.{Grammar}
use tokens.{TokenKind, token, ref, seq, choice, optional, field, repeat, # Core keywords Fn, Class, Struct, Enum, Union, Trait, Impl, Mixin, Actor, Import, From, As, Mod, Use, Export, Common, # Type system Type, Unit, HandlePool, Static, Me, # AOP On, Bind, Forbid, Allow, Mock, # BDD Feature, Scenario, Outline, Examples, Given, When, Then, AndThen, # Operators LParen, RParen, LBrace, RBrace, Colon, Arrow, Comma, Dot, Star, Assign, For, Newline, Indent, Dedent, # Special tokens Pointcut}

export add_declaration_rules

# Add all declaration rules to grammar
fn add_declaration_rules(grammar: Grammar):
    # Top-level declarations
    grammar.add_rule("declaration", choice([
        # Core declarations
        ref("function_def"),
        ref("class_def"),
        ref("struct_def"),
        ref("enum_def"),
        ref("union_def"),
        ref("trait_def"),
        ref("impl_def"),
        ref("mixin_def"),
        ref("actor_def"),
        # Module system
        ref("mod_def"),
        ref("use_stmt"),
        ref("import_stmt"),
        ref("export_stmt"),
        ref("common_stmt"),
        # Advanced types
        ref("unit_def"),
        ref("handle_pool_def"),
        # AOP & Testing
        ref("on_stmt"),
        ref("bind_stmt"),
        ref("forbid_stmt"),
        ref("allow_stmt"),
        ref("mock_def"),
        # BDD/Gherkin
        ref("feature_def"),
        ref("scenario_def")
    ]))

    # Function definition
    grammar.add_rule("function_def", seq([
        token(Fn),
        field("name", ref("identifier")),
        token(LParen),
        optional(ref("parameter_list")),
        token(RParen),
        optional(seq([token(Arrow), field("return_type", ref("type"))])),
        token(Colon),
        ref("block")
    ]))

    # Parameter list
    grammar.add_rule("parameter_list", seq([
        ref("parameter"),
        repeat(seq([token(Comma), ref("parameter")]))
    ]))

    # Parameter
    grammar.add_rule("parameter", seq([
        field("name", ref("identifier")),
        token(Colon),
        field("type", ref("type"))
    ]))

    # Class definition
    grammar.add_rule("class_def", seq([
        token(Class),
        field("name", ref("type_identifier")),
        optional(ref("type_parameters")),
        token(Colon),
        ref("class_block")
    ]))

    # Class block
    grammar.add_rule("class_block", seq([
        token(Newline),
        token(Indent),
        repeat(choice([
            ref("field_def"),
            ref("function_def"),
            token(Newline)
        ])),
        token(Dedent)
    ]))

    # Field definition
    grammar.add_rule("field_def", seq([
        field("name", ref("identifier")),
        token(Colon),
        field("type", ref("type")),
        token(Newline)
    ]))

    # Struct definition
    grammar.add_rule("struct_def", seq([
        token(Struct),
        field("name", ref("type_identifier")),
        optional(ref("type_parameters")),
        token(Colon),
        ref("struct_block")
    ]))

    # Struct block (same as class block)
    grammar.add_rule("struct_block", ref("class_block"))

    # Enum definition
    grammar.add_rule("enum_def", seq([
        token(Enum),
        field("name", ref("type_identifier")),
        optional(ref("type_parameters")),
        token(Colon),
        ref("enum_block")
    ]))

    # Enum block
    grammar.add_rule("enum_block", seq([
        token(Newline),
        token(Indent),
        repeat(choice([
            ref("enum_variant"),
            token(Newline)
        ])),
        token(Dedent)
    ]))

    # Enum variant
    grammar.add_rule("enum_variant", choice([
        field("name", ref("type_identifier")),
        seq([
            field("name", ref("type_identifier")),
            token(LParen),
            ref("type_list"),
            token(RParen)
        ]),
        seq([
            field("name", ref("type_identifier")),
            token(LBrace),
            ref("field_list"),
            token(RBrace)
        ])
    ]))

    # Trait definition
    grammar.add_rule("trait_def", seq([
        token(Trait),
        field("name", ref("type_identifier")),
        optional(ref("type_parameters")),
        token(Colon),
        ref("trait_block")
    ]))

    # Trait block
    grammar.add_rule("trait_block", seq([
        token(Newline),
        token(Indent),
        repeat(choice([
            ref("trait_method"),
            token(Newline)
        ])),
        token(Dedent)
    ]))

    # Trait method
    grammar.add_rule("trait_method", seq([
        token(Fn),
        field("name", ref("identifier")),
        token(LParen),
        optional(ref("parameter_list")),
        token(RParen),
        optional(seq([token(Arrow), field("return_type", ref("type"))])),
        token(Newline)
    ]))

    # Import statement
    grammar.add_rule("import_stmt", seq([
        token(Import),
        ref("import_path"),
        optional(seq([
            token(As),
            ref("identifier")
        ])),
        token(Newline)
    ]))

    # Import path
    grammar.add_rule("import_path", seq([
        ref("identifier"),
        repeat(seq([token(Dot), ref("identifier")]))
    ]))

    # ========================================================================
    # Module System
    # ========================================================================

    # Module definition: mod name:
    grammar.add_rule("mod_def", seq([
        token(Mod),
        field("name", ref("identifier")),
        token(Colon),
        ref("block")
    ]))

    # Use statement: use module.{A, B} or use module.*
    grammar.add_rule("use_stmt", seq([
        token(Use),
        ref("use_path"),
        token(Newline)
    ]))

    # Use path
    grammar.add_rule("use_path", choice([
        # Glob: use module.*
        seq([ref("module_path"), token(Dot), token(Star)]),
        # Braces: use module.{A, B}
        seq([
            ref("module_path"),
            token(Dot),
            token(LBrace),
            ref("import_list"),
            token(RBrace)
        ]),
        # Single: use module.Item
        ref("module_path")
    ]))

    # Module path
    grammar.add_rule("module_path", seq([
        ref("identifier"),
        repeat(seq([token(Dot), ref("identifier")]))
    ]))

    # Import list
    grammar.add_rule("import_list", seq([
        ref("identifier"),
        repeat(seq([token(Comma), ref("identifier")])),
        optional(token(Comma))
    ]))

    # Export statement: export use module.{A, B}
    grammar.add_rule("export_stmt", seq([
        token(Export),
        choice([
            seq([token(Use), ref("use_path")]),
            ref("identifier")
        ]),
        token(Newline)
    ]))

    # Common statement: common use module.*
    grammar.add_rule("common_stmt", seq([
        token(Common),
        token(Use),
        ref("use_path"),
        token(Newline)
    ]))

    # ========================================================================
    # Advanced Type Declarations
    # ========================================================================

    # Union definition: union Result<T, E>:
    grammar.add_rule("union_def", seq([
        token(Union),
        field("name", ref("type_identifier")),
        optional(ref("type_parameters")),
        token(Colon),
        ref("enum_block")  # Unions are like enums
    ]))

    # Impl block: impl Type: or impl Trait for Type:
    grammar.add_rule("impl_def", seq([
        token(Impl),
        choice([
            # impl Type:
            seq([
                field("type", ref("type_identifier")),
                optional(ref("type_parameters"))
            ]),
            # impl Trait for Type:
            seq([
                field("trait", ref("type_identifier")),
                token(For),
                field("type", ref("type_identifier")),
                optional(ref("type_parameters"))
            ])
        ]),
        token(Colon),
        ref("impl_block")
    ]))

    # Impl block
    grammar.add_rule("impl_block", seq([
        token(Newline),
        token(Indent),
        repeat(choice([
            ref("function_def"),
            ref("method_def"),
            ref("static_method_def"),
            token(Newline)
        ])),
        token(Dedent)
    ]))

    # Method definition (me keyword for mutable methods)
    grammar.add_rule("method_def", seq([
        optional(token(Me)),  # Mutable method
        token(Fn),
        field("name", ref("identifier")),
        token(LParen),
        optional(ref("parameter_list")),
        token(RParen),
        optional(seq([token(Arrow), field("return_type", ref("type"))])),
        token(Colon),
        ref("block")
    ]))

    # Static method definition
    grammar.add_rule("static_method_def", seq([
        token(Static),
        token(Fn),
        field("name", ref("identifier")),
        token(LParen),
        optional(ref("parameter_list")),
        token(RParen),
        optional(seq([token(Arrow), field("return_type", ref("type"))])),
        token(Colon),
        ref("block")
    ]))

    # Mixin definition: mixin Name:
    grammar.add_rule("mixin_def", seq([
        token(Mixin),
        field("name", ref("type_identifier")),
        optional(ref("type_parameters")),
        token(Colon),
        ref("trait_block")  # Mixins are like traits
    ]))

    # Actor definition: actor Name:
    grammar.add_rule("actor_def", seq([
        token(Actor),
        field("name", ref("type_identifier")),
        optional(ref("type_parameters")),
        token(Colon),
        ref("class_block")  # Actors are like classes
    ]))

    # Unit definition: unit UserId: i64 as uid
    grammar.add_rule("unit_def", choice([
        # Standalone unit: unit UserId: i64 as uid
        seq([
            token(Unit),
            field("name", ref("type_identifier")),
            token(Colon),
            field("base_type", ref("type")),
            token(As),
            field("suffix", ref("identifier")),
            token(Newline)
        ]),
        # Unit family: unit length(base: f64): m = 1.0, km = 1000.0
        seq([
            token(Unit),
            field("name", ref("type_identifier")),
            token(LParen),
            ref("identifier"),  # base
            token(Colon),
            field("base_type", ref("type")),
            token(RParen),
            token(Colon),
            ref("unit_variants")
        ])
    ]))

    # Unit variants
    grammar.add_rule("unit_variants", seq([
        token(Newline),
        token(Indent),
        repeat(ref("unit_variant")),
        token(Dedent)
    ]))

    # Unit variant: m = 1.0
    grammar.add_rule("unit_variant", seq([
        field("name", ref("identifier")),
        token(Assign),
        field("factor", ref("expression")),
        token(Newline)
    ]))

    # Handle pool definition: handle_pool Enemy: capacity: 1024
    grammar.add_rule("handle_pool_def", seq([
        token(HandlePool),
        field("type", ref("type_identifier")),
        optional(seq([
            token(Colon),
            ref("handle_pool_block")
        ])),
        token(Newline)
    ]))

    # Handle pool block
    grammar.add_rule("handle_pool_block", seq([
        token(Newline),
        token(Indent),
        repeat(choice([
            ref("handle_pool_field"),
            token(Newline)
        ])),
        token(Dedent)
    ]))

    # Handle pool field
    grammar.add_rule("handle_pool_field", seq([
        field("key", ref("identifier")),
        token(Colon),
        field("value", ref("expression")),
        token(Newline)
    ]))

    # ========================================================================
    # AOP (Aspect-Oriented Programming)
    # ========================================================================

    # On statement: on pc{pattern} use Interceptor
    grammar.add_rule("on_stmt", seq([
        token(On),
        field("pointcut", token(Pointcut)),
        token(Use),
        field("interceptor", ref("type_identifier")),
        token(Newline)
    ]))

    # Bind statement: bind on pc{pattern} -> Impl
    grammar.add_rule("bind_stmt", seq([
        token(Bind),
        token(On),
        field("pointcut", token(Pointcut)),
        token(Arrow),
        field("implementation", ref("type_identifier")),
        token(Newline)
    ]))

    # Forbid statement: forbid pc{pattern}
    grammar.add_rule("forbid_stmt", seq([
        token(Forbid),
        field("pointcut", token(Pointcut)),
        optional(seq([token(Comma), field("message", ref("expression"))])),
        token(Newline)
    ]))

    # Allow statement: allow pc{pattern}
    grammar.add_rule("allow_stmt", seq([
        token(Allow),
        field("pointcut", token(Pointcut)),
        token(Newline)
    ]))

    # Mock definition: mock Name implements Trait:
    grammar.add_rule("mock_def", seq([
        token(Mock),
        field("name", ref("type_identifier")),
        token(Impl),
        field("trait", ref("type_identifier")),
        token(Colon),
        ref("mock_block")
    ]))

    # Mock block
    grammar.add_rule("mock_block", seq([
        token(Newline),
        token(Indent),
        repeat(choice([
            ref("mock_method"),
            token(Newline)
        ])),
        token(Dedent)
    ]))

    # Mock method
    grammar.add_rule("mock_method", seq([
        token(Fn),
        field("name", ref("identifier")),
        token(LParen),
        optional(ref("parameter_list")),
        token(RParen),
        optional(seq([token(Arrow), field("return_type", ref("type"))])),
        token(Arrow),
        field("mock_value", ref("expression")),
        token(Newline)
    ]))

    # ========================================================================
    # BDD/Gherkin Testing DSL
    # ========================================================================

    # Feature definition: feature Name:
    grammar.add_rule("feature_def", seq([
        token(Feature),
        field("name", ref("string_literal")),
        token(Colon),
        ref("feature_block")
    ]))

    # Feature block
    grammar.add_rule("feature_block", seq([
        token(Newline),
        token(Indent),
        repeat(choice([
            ref("scenario_def"),
            token(Newline)
        ])),
        token(Dedent)
    ]))

    # Scenario definition: scenario Name: or scenario outline Name:
    grammar.add_rule("scenario_def", seq([
        token(Scenario),
        optional(token(Outline)),
        field("name", ref("string_literal")),
        token(Colon),
        ref("scenario_block")
    ]))

    # Scenario block
    grammar.add_rule("scenario_block", seq([
        token(Newline),
        token(Indent),
        repeat(choice([
            ref("given_step"),
            ref("when_step"),
            ref("then_step"),
            ref("and_then_step"),
            ref("examples_block"),
            token(Newline)
        ])),
        token(Dedent)
    ]))

    # Given step: given step_pattern:
    grammar.add_rule("given_step", seq([
        token(Given),
        field("pattern", ref("string_literal")),
        token(Colon),
        ref("block")
    ]))

    # When step: when step_pattern:
    grammar.add_rule("when_step", seq([
        token(When),
        field("pattern", ref("string_literal")),
        token(Colon),
        ref("block")
    ]))

    # Then step: then step_pattern:
    grammar.add_rule("then_step", seq([
        token(Then),
        field("pattern", ref("string_literal")),
        token(Colon),
        ref("block")
    ]))

    # And then step: and_then step_pattern:
    grammar.add_rule("and_then_step", seq([
        token(AndThen),
        field("pattern", ref("string_literal")),
        token(Colon),
        ref("block")
    ]))

    # Examples block: examples name:
    grammar.add_rule("examples_block", seq([
        token(Examples),
        field("name", ref("string_literal")),
        token(Colon),
        ref("examples_table")
    ]))

    # Examples table
    grammar.add_rule("examples_table", seq([
        token(Newline),
        token(Indent),
        repeat(ref("table_row")),
        token(Dedent)
    ]))

    # Table row (simplified - actual parsing would be more complex)
    grammar.add_rule("table_row", seq([
        ref("expression"),
        repeat(seq([token(Comma), ref("expression")])),
        token(Newline)
    ]))
