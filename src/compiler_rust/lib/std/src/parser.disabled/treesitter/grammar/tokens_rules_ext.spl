# Token Kind Rules - Extended
# Part 3 of tokens module: description() and summary() methods.
# See tokens.spl for enum definition, tokens_rules.spl for is_* and to_string.

impl TokenKind:
    fn description() -> text:
        """Get human-readable description of the token kind.
        Returns: descriptive explanation
        Example: TokenKind.Fn.description()  # → "Function declaration keyword"
        """
        match self:
            # Core keywords
            case Fn: "Function declaration keyword"
            case Me: "Mutable method keyword"
            case Let: "Variable binding keyword (legacy)"
            case Mut: "Mutable modifier keyword (legacy)"
            case Val: "Immutable variable keyword (Scala-style)"
            case Var: "Mutable variable keyword (Scala-style)"
            case Return: "Return statement keyword"
            case If: "Conditional if keyword"
            case Elif: "Conditional elif keyword"
            case Else: "Conditional else keyword"
            case Match: "Pattern match keyword"
            case Case: "Match case keyword"
            case For: "For loop keyword"
            case In: "In operator keyword"
            case While: "While loop keyword"
            case Loop: "Infinite loop keyword"
            case Break: "Break statement keyword"
            case Continue: "Continue statement keyword"
            case Class: "Class declaration keyword"
            case Struct: "Struct declaration keyword"
            case Enum: "Enum declaration keyword"
            case Trait: "Trait declaration keyword"
            case Impl: "Implementation block keyword"
            case Import: "Import statement keyword"
            case As: "Alias as keyword"
            case From: "From import keyword"
            case True: "Boolean true literal"
            case False: "Boolean false literal"
            case Nil: "Null/nil literal"
            case And: "Logical and operator"
            case Or: "Logical or operator"
            case Not: "Logical not operator"
            case Then: "Then keyword for expressions"
            # Module system
            case Mod: "Module declaration keyword"
            case Use: "Use/import keyword"
            case Export: "Export/re-export keyword"
            case Common: "Common prelude keyword"
            case Auto: "Auto import keyword"
            case Crate: "Crate root keyword"
            # Type system & memory
            case Union: "Union type keyword"
            case Mixin: "Mixin declaration keyword"
            case Extends: "Class inheritance keyword"
            case Move: "Move semantics keyword"
            case Const: "Compile-time constant keyword"
            case Static: "Static variable/method keyword"
            case Type: "Type alias keyword"
            case Unit: "Unit type keyword"
            case Extern: "External function keyword"
            case Iso: "Isolated reference capability"
            case Ref: "Reference capability"
            case Dyn: "Dynamic trait object keyword"
            case Repr: "Representation constraint keyword"
            case Self_: "Self reference keyword"
            case Super: "Super reference keyword"
            case New: "Constructor keyword"
            case Pub: "Public visibility keyword"
            case Priv: "Private visibility keyword"
            case Context: "Context manager keyword"
            case With: "With context keyword"
            case Ghost: "Verification-only code keyword"
            # Concurrency
            case Actor: "Actor declaration keyword"
            case Spawn: "Spawn thread keyword"
            case Go: "Go-style spawn keyword"
            case Yield: "Yield control keyword"
            case Async: "Async function keyword"
            case Await: "Await suspension keyword"
            case Sync: "Synchronous keyword"
            # Suspension
            case IfSuspend: "Suspension if keyword"
            case WhileSuspend: "Suspension while keyword"
            case ForSuspend: "Suspension for keyword"
            case AndSuspend: "Suspension and operator"
            case OrSuspend: "Suspension or operator"
            # GPU/SIMD
            case Macro: "Macro keyword"
            case Bang: "Macro invocation operator"
            case Vec: "SIMD vector keyword"
            case Shared: "GPU shared memory keyword"
            case Gpu: "GPU intrinsics keyword"
            case Bounds: "Kernel bounds keyword"
            # AOP
            case On: "AOP advice keyword"
            case Bind: "Dependency injection keyword"
            case Forbid: "Architecture rule forbid keyword"
            case Allow: "Architecture rule allow keyword"
            case Mock: "Mock declaration keyword"
            # Contracts
            case Out: "Postcondition block keyword"
            case OutErr: "Error postcondition keyword"
            case Where: "Refinement predicate keyword"
            case Requires: "Precondition keyword (legacy)"
            case Ensures: "Postcondition keyword (legacy)"
            case Invariant: "Invariant keyword"
            case Old: "Old value keyword"
            case Result: "Result value keyword"
            case Decreases: "Termination measure keyword"
            case Forall: "Universal quantifier keyword"
            case Exists: "Existential quantifier keyword"
            case Assert: "Assertion keyword"
            case Assume: "Assumption keyword"
            case Admit: "Admit proof keyword"
            case Calc: "Calculational proof keyword"
            # BDD
            case Feature: "BDD feature keyword"
            case Scenario: "BDD scenario keyword"
            case Outline: "BDD scenario outline keyword"
            case Examples: "BDD examples keyword"
            case Given: "BDD given step keyword"
            case When: "BDD when step keyword"
            case AndThen: "BDD and_then step keyword"
            case To: "Infix assertion keyword"
            case NotTo: "Negative infix assertion keyword"
            # Special
            case HandlePool: "Handle pool declaration keyword"
            case Grid: "2D matrix literal keyword"
            case Tensor: "N-D tensor literal keyword"
            case Slice: "Tensor slice keyword"
            case Flat: "Sparse tensor mode keyword"
            case Default: "Default value keyword"
            # Arithmetic operators
            case Plus: "Addition operator"
            case Minus: "Subtraction operator"
            case Star: "Multiplication operator"
            case Slash: "Division operator"
            case Percent: "Modulo operator"
            case DoubleStar: "Exponentiation operator"
            case DoubleSlash: "Floor division operator"
            # Comparison operators
            case Eq: "Equality comparison"
            case DoubleEq: "Equality comparison"
            case NotEq: "Inequality comparison"
            case Lt: "Less-than comparison"
            case Gt: "Greater-than comparison"
            case LtEq: "Less-or-equal comparison"
            case GtEq: "Greater-or-equal comparison"
            # Assignment operators
            case Assign: "Assignment operator"
            case PlusAssign: "Add-assign operator"
            case MinusAssign: "Subtract-assign operator"
            case StarAssign: "Multiply-assign operator"
            case SlashAssign: "Divide-assign operator"
            case TildeAssign: "Suspension assignment operator"
            case TildePlusAssign: "Suspension add-assign operator"
            case TildeMinusAssign: "Suspension subtract-assign operator"
            case TildeStarAssign: "Suspension multiply-assign operator"
            case TildeSlashAssign: "Suspension divide-assign operator"
            # Bitwise operators
            case Pipe: "Bitwise OR operator"
            case Ampersand: "Bitwise AND operator"
            case Caret: "Bitwise XOR operator"
            case Tilde: "Bitwise NOT operator"
            case LtLt: "Left shift operator"
            case GtGt: "Right shift operator"
            case DoublePipe: "Logical OR operator"
            case DoubleAmp: "Logical AND operator"
            # Special operators
            case Dot: "Member access operator"
            case Comma: "Comma separator"
            case Colon: "Colon separator"
            case DoubleColon: "Static method call operator"
            case Semicolon: "Statement terminator"
            case Arrow: "Function return type arrow"
            case FatArrow: "Fat arrow operator"
            case ChannelArrow: "Channel receive operator"
            case DoubleDot: "Exclusive range operator"
            case DoubleDotEq: "Inclusive range operator"
            case Ellipsis: "Ellipsis operator"
            case Question: "Optional type operator"
            case Exclamation: "Unwrap/assertion operator"
            case At: "Attribute marker"
            case Hash: "Hash symbol"
            case Dollar: "String interpolation marker"
            case Backslash: "Lambda parameter marker"
            case Underscore: "Wildcard pattern"
            # Delimiters
            case LParen: "Left parenthesis"
            case RParen: "Right parenthesis"
            case LBracket: "Left bracket"
            case RBracket: "Right bracket"
            case LBrace: "Left brace"
            case RBrace: "Right brace"
            case Newline: "Newline character"
            case Indent: "Indentation increase"
            case Dedent: "Indentation decrease"
            # Literals
            case Integer: "Integer literal"
            case Float: "Float literal"
            case TypedInteger: "Typed integer literal (e.g., 42i32)"
            case TypedFloat: "Typed float literal (e.g., 3.14f64)"
            case text: "String literal"
            case RawString: "Raw string literal (no escapes)"
            case Symbol: "Symbol literal (:symbol)"
            case TypedString: "Typed string literal with suffix"
            case TypedRawString: "Typed raw string literal with suffix"
            case FStringStart: "F-string start delimiter"
            case FStringText: "F-string text content"
            case FStringEnd: "F-string end delimiter"
            case FStringFormatSpec: "F-string format specifier"
            # Identifiers
            case Identifier: "Variable/function identifier"
            case TypeIdentifier: "Type name identifier"
            # Special tokens
            case CustomBlock: "Custom DSL block (m{}, sh{}, sql{}, etc.)"
            case Pointcut: "AOP pointcut expression pc{...}"
            case DocComment: "Documentation comment"
            case Error: "Error token"
            case Eof: "End of file"

    fn summary() -> text:
        """Get comprehensive summary of the token kind.
        Returns: summary with token, description, and category
        Example: TokenKind.Plus.summary()
                # → "TokenKind: + (Addition operator, operator, arithmetic)"
        """
        val name = self.to_string()
        val desc = self.description()
        var cats = []

        if self.is_keyword():
            cats.push("keyword")
        if self.is_operator():
            cats.push("operator")
        if self.is_delimiter():
            cats.push("delimiter")
        if self.is_literal():
            cats.push("literal")
        if self.is_identifier():
            cats.push("identifier")
        if self.is_control_flow():
            cats.push("control flow")
        if self.is_declaration():
            cats.push("declaration")
        if self.is_comparison():
            cats.push("comparison")
        if self.is_arithmetic():
            cats.push("arithmetic")
        if self.is_bitwise():
            cats.push("bitwise")
        if self.is_logical():
            cats.push("logical")

        val cats_str = if cats.len() > 0:
            ", " + cats.join(", ")
        else:
            ""

        "TokenKind: {name} ({desc}{cats_str})"
