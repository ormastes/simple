# Token Kind Rules - impl TokenKind
# Part 2 of tokens module: is_* methods and to_string.
# See tokens_rules_ext.spl for description() and summary() methods.

use simple_grammar.{GrammarRule as Rule}

impl TokenKind:
    fn is_keyword() -> bool:
        """Check if this is any keyword token.
        Returns: true for all keyword variants
        Example: TokenKind.Fn.is_keyword()  # → true
        """
        match self:
            # Core keywords
            case Fn: true
            case Me: true
            case Let: true
            case Mut: true
            case Val: true
            case Var: true
            case Return: true
            case If: true
            case Elif: true
            case Else: true
            case Match: true
            case Case: true
            case For: true
            case In: true
            case While: true
            case Loop: true
            case Break: true
            case Continue: true
            case Class: true
            case Struct: true
            case Enum: true
            case Trait: true
            case Impl: true
            case Import: true
            case As: true
            case From: true
            case True: true
            case False: true
            case Nil: true
            case And: true
            case Or: true
            case Not: true
            case Then: true
            # Module system
            case Mod: true
            case Use: true
            case Export: true
            case Common: true
            case Auto: true
            case Crate: true
            # Type system & memory
            case Union: true
            case Mixin: true
            case Extends: true
            case Move: true
            case Const: true
            case Static: true
            case Type: true
            case Unit: true
            case Extern: true
            case Iso: true
            case Ref: true
            case Dyn: true
            case Repr: true
            case Self_: true
            case Super: true
            case New: true
            case Pub: true
            case Priv: true
            case Context: true
            case With: true
            case Ghost: true
            # Concurrency
            case Actor: true
            case Spawn: true
            case Go: true
            case Yield: true
            case Async: true
            case Await: true
            case Sync: true
            # Suspension
            case IfSuspend: true
            case WhileSuspend: true
            case ForSuspend: true
            case AndSuspend: true
            case OrSuspend: true
            # GPU/SIMD
            case Macro: true
            case Bang: true
            case Vec: true
            case Shared: true
            case Gpu: true
            case Bounds: true
            # AOP
            case On: true
            case Bind: true
            case Forbid: true
            case Allow: true
            case Mock: true
            # Contracts
            case Out: true
            case OutErr: true
            case Where: true
            case Requires: true
            case Ensures: true
            case Invariant: true
            case Old: true
            case Result: true
            case Decreases: true
            case Forall: true
            case Exists: true
            case Assert: true
            case Assume: true
            case Admit: true
            case Calc: true
            # BDD
            case Feature: true
            case Scenario: true
            case Outline: true
            case Examples: true
            case Given: true
            case When: true
            case AndThen: true
            case To: true
            case NotTo: true
            # Special
            case HandlePool: true
            case Grid: true
            case Tensor: true
            case Slice: true
            case Flat: true
            case Default: true
            case _: false

    fn is_operator() -> bool:
        """Check if this is an operator token.
        Returns: true for operator variants
        Example: TokenKind.Plus.is_operator()  # → true
        """
        match self:
            # Arithmetic
            case Plus: true
            case Minus: true
            case Star: true
            case Slash: true
            case Percent: true
            case DoubleStar: true
            case DoubleSlash: true
            # Comparison
            case Eq: true
            case DoubleEq: true
            case NotEq: true
            case Lt: true
            case Gt: true
            case LtEq: true
            case GtEq: true
            # Assignment
            case Assign: true
            case PlusAssign: true
            case MinusAssign: true
            case StarAssign: true
            case SlashAssign: true
            case TildeAssign: true
            case TildePlusAssign: true
            case TildeMinusAssign: true
            case TildeStarAssign: true
            case TildeSlashAssign: true
            # Bitwise
            case Pipe: true
            case Ampersand: true
            case Caret: true
            case Tilde: true
            case LtLt: true
            case GtGt: true
            case DoublePipe: true
            case DoubleAmp: true
            # Special
            case Dot: true
            case Comma: true
            case Colon: true
            case DoubleColon: true
            case Semicolon: true
            case Arrow: true
            case FatArrow: true
            case ChannelArrow: true
            case DoubleDot: true
            case DoubleDotEq: true
            case Ellipsis: true
            case Question: true
            case Exclamation: true
            case At: true
            case Hash: true
            case Dollar: true
            case Backslash: true
            case Underscore: true
            case _: false

    fn is_delimiter() -> bool:
        """Check if this is a delimiter token.
        Returns: true for delimiter variants
        Example: TokenKind.LParen.is_delimiter()  # → true
        """
        match self:
            case LParen: true
            case RParen: true
            case LBracket: true
            case RBracket: true
            case LBrace: true
            case RBrace: true
            case Newline: true
            case Indent: true
            case Dedent: true
            case _: false

    fn is_literal() -> bool:
        """Check if this is a literal token.
        Returns: true for literal variants
        Example: TokenKind.Integer.is_literal()  # → true
        """
        match self:
            case Integer: true
            case Float: true
            case TypedInteger: true
            case TypedFloat: true
            case text: true
            case RawString: true
            case Symbol: true
            case TypedString: true
            case TypedRawString: true
            case FStringStart: true
            case FStringText: true
            case FStringEnd: true
            case FStringFormatSpec: true
            case _: false

    fn is_identifier() -> bool:
        """Check if this is an identifier token.
        Returns: true for Identifier or TypeIdentifier
        Example: TokenKind.Identifier.is_identifier()  # → true
        """
        match self:
            case Identifier: true
            case TypeIdentifier: true
            case _: false

    fn is_control_flow() -> bool:
        """Check if this is a control flow keyword.
        Returns: true for control flow keywords
        Example: TokenKind.If.is_control_flow()  # → true
        """
        match self:
            case If: true
            case Elif: true
            case Else: true
            case Match: true
            case Case: true
            case For: true
            case While: true
            case Loop: true
            case Break: true
            case Continue: true
            case Return: true
            case _: false

    fn is_declaration() -> bool:
        """Check if this is a declaration keyword.
        Returns: true for declaration keywords
        Example: TokenKind.Fn.is_declaration()  # → true
        """
        match self:
            case Fn: true
            case Me: true
            case Let: true
            case Mut: true
            case Val: true
            case Var: true
            case Const: true
            case Static: true
            case Type: true
            case Unit: true
            case Class: true
            case Struct: true
            case Enum: true
            case Union: true
            case Trait: true
            case Impl: true
            case Mixin: true
            case Actor: true
            case Extern: true
            case Mod: true
            case HandlePool: true
            case _: false

    fn is_comparison() -> bool:
        """Check if this is a comparison operator.
        Returns: true for comparison operators
        Example: TokenKind.Lt.is_comparison()  # → true
        """
        match self:
            case DoubleEq: true
            case NotEq: true
            case Lt: true
            case Gt: true
            case LtEq: true
            case GtEq: true
            case _: false

    fn is_arithmetic() -> bool:
        """Check if this is an arithmetic operator.
        Returns: true for arithmetic operators
        Example: TokenKind.Plus.is_arithmetic()  # → true
        """
        match self:
            case Plus: true
            case Minus: true
            case Star: true
            case Slash: true
            case Percent: true
            case DoubleStar: true
            case _: false

    fn is_bitwise() -> bool:
        """Check if this is a bitwise operator.
        Returns: true for bitwise operators
        Example: TokenKind.Pipe.is_bitwise()  # → true
        """
        match self:
            case Pipe: true
            case Ampersand: true
            case Caret: true
            case Tilde: true
            case LtLt: true
            case GtGt: true
            case _: false

    fn is_logical() -> bool:
        """Check if this is a logical operator.
        Returns: true for logical operators
        Example: TokenKind.And.is_logical()  # → true
        """
        match self:
            case And: true
            case Or: true
            case Not: true
            case _: false

    fn is_bracket() -> bool:
        """Check if this is a bracket delimiter.
        Returns: true for bracket pairs
        Example: TokenKind.LBracket.is_bracket()  # → true
        """
        match self:
            case LParen: true
            case RParen: true
            case LBracket: true
            case RBracket: true
            case LBrace: true
            case RBrace: true
            case _: false

    fn is_whitespace() -> bool:
        """Check if this is whitespace/indentation token.
        Returns: true for Newline, Indent, Dedent
        Example: TokenKind.Indent.is_whitespace()  # → true
        """
        match self:
            case Newline: true
            case Indent: true
            case Dedent: true
            case _: false

    fn is_fstring_part() -> bool:
        """Check if this is part of f-string literal.
        Returns: true for f-string components
        Example: TokenKind.FStringText.is_fstring_part()  # → true
        """
        match self:
            case FStringStart: true
            case FStringText: true
            case FStringEnd: true
            case FStringFormatSpec: true
            case _: false

    fn to_string() -> text:
        """Convert TokenKind to string representation.
        Returns: lowercase symbolic name
        Example: TokenKind.DoubleEq.to_string()  # → "=="
        """
        match self:
            # Core keywords
            case Fn: "fn"
            case Me: "me"
            case Let: "let"
            case Mut: "mut"
            case Val: "val"
            case Var: "var"
            case Return: "return"
            case If: "if"
            case Elif: "elif"
            case Else: "else"
            case Match: "match"
            case Case: "case"
            case For: "for"
            case In: "in"
            case While: "while"
            case Loop: "loop"
            case Break: "break"
            case Continue: "continue"
            case Class: "class"
            case Struct: "struct"
            case Enum: "enum"
            case Trait: "trait"
            case Impl: "impl"
            case Import: "import"
            case As: "as"
            case From: "from"
            case True: "true"
            case False: "false"
            case Nil: "nil"
            case And: "and"
            case Or: "or"
            case Not: "not"
            case Then: "then"
            # Module system
            case Mod: "mod"
            case Use: "use"
            case Export: "export"
            case Common: "common"
            case Auto: "auto"
            case Crate: "crate"
            # Type system & memory
            case Union: "union"
            case Mixin: "mixin"
            case Extends: "extends"
            case Move: "move"
            case Const: "const"
            case Static: "static"
            case Type: "type"
            case Unit: "unit"
            case Extern: "extern"
            case Iso: "iso"
            case Ref: "ref"
            case Dyn: "dyn"
            case Repr: "repr"
            case Self_: "self"
            case Super: "super"
            case New: "new"
            case Pub: "pub"
            case Priv: "priv"
            case Context: "context"
            case With: "with"
            case Ghost: "ghost"
            # Concurrency
            case Actor: "actor"
            case Spawn: "spawn"
            case Go: "go"
            case Yield: "yield"
            case Async: "async"
            case Await: "await"
            case Sync: "sync"
            # Suspension
            case IfSuspend: "if~"
            case WhileSuspend: "while~"
            case ForSuspend: "for~"
            case AndSuspend: "and~"
            case OrSuspend: "or~"
            # GPU/SIMD
            case Macro: "macro"
            case Bang: "!"
            case Vec: "vec"
            case Shared: "shared"
            case Gpu: "gpu"
            case Bounds: "bounds"
            # AOP
            case On: "on"
            case Bind: "bind"
            case Forbid: "forbid"
            case Allow: "allow"
            case Mock: "mock"
            # Contracts
            case Out: "out"
            case OutErr: "out_err"
            case Where: "where"
            case Requires: "requires"
            case Ensures: "ensures"
            case Invariant: "invariant"
            case Old: "old"
            case Result: "result"
            case Decreases: "decreases"
            case Forall: "forall"
            case Exists: "exists"
            case Assert: "assert"
            case Assume: "assume"
            case Admit: "admit"
            case Calc: "calc"
            # BDD
            case Feature: "feature"
            case Scenario: "scenario"
            case Outline: "outline"
            case Examples: "examples"
            case Given: "given"
            case When: "when"
            case AndThen: "and_then"
            case To: "to"
            case NotTo: "not_to"
            # Special
            case HandlePool: "handle_pool"
            case Grid: "grid"
            case Tensor: "tensor"
            case Slice: "slice"
            case Flat: "flat"
            case Default: "default"
            # Arithmetic operators
            case Plus: "+"
            case Minus: "-"
            case Star: "*"
            case Slash: "/"
            case Percent: "%"
            case DoubleStar: "**"
            case DoubleSlash: "//"
            # Comparison operators
            case Eq: "=="
            case DoubleEq: "=="
            case NotEq: "!="
            case Lt: "<"
            case Gt: ">"
            case LtEq: "<="
            case GtEq: ">="
            # Assignment operators
            case Assign: "="
            case PlusAssign: "+="
            case MinusAssign: "-="
            case StarAssign: "*="
            case SlashAssign: "/="
            case TildeAssign: "~="
            case TildePlusAssign: "~+="
            case TildeMinusAssign: "~-="
            case TildeStarAssign: "~*="
            case TildeSlashAssign: "~/="
            # Bitwise operators
            case Pipe: "|"
            case Ampersand: "&"
            case Caret: "^"
            case Tilde: "~"
            case LtLt: "<<"
            case GtGt: ">>"
            case DoublePipe: "||"
            case DoubleAmp: "&&"
            # Special operators
            case Dot: "."
            case Comma: ","
            case Colon: ":"
            case DoubleColon: "."
            case Semicolon: ";"
            case Arrow: "->"
            case FatArrow: "=>"
            case ChannelArrow: "<-"
            case DoubleDot: ".."
            case DoubleDotEq: "..="
            case Ellipsis: "..."
            case Question: "?"
            case Exclamation: "!"
            case At: "@"
            case Hash: "#"
            case Dollar: "$"
            case Backslash: "\\"
            case Underscore: "_"
            # Delimiters
            case LParen: "("
            case RParen: ")"
            case LBracket: "["
            case RBracket: "]"
            case LBrace: "{"
            case RBrace: "}"
            case Newline: "\\n"
            case Indent: "<indent>"
            case Dedent: "<dedent>"
            # Literals
            case Integer: "<integer>"
            case Float: "<float>"
            case TypedInteger: "<typed_integer>"
            case TypedFloat: "<typed_float>"
            case text: "<string>"
            case RawString: "<raw_string>"
            case Symbol: "<symbol>"
            case TypedString: "<typed_string>"
            case TypedRawString: "<typed_raw_string>"
            case FStringStart: "<fstring_start>"
            case FStringText: "<fstring_text>"
            case FStringEnd: "<fstring_end>"
            case FStringFormatSpec: "<fstring_fmt>"
            # Identifiers
            case Identifier: "<identifier>"
            case TypeIdentifier: "<type_id>"
            # Special tokens
            case CustomBlock: "<custom_block>"
            case Pointcut: "<pointcut>"
            case DocComment: "<doc_comment>"
            case Error: "<error>"
            case Eof: "<eof>"

    # description() and summary() methods are in tokens_rules_ext.spl
