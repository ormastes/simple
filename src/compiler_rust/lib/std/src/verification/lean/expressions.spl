# Lean Expression Translation
#
# Translates Simple expressions to Lean 4 syntax.

use verification.models.contracts as contracts

# Simple expression AST
enum SimpleExpr:
    IntLit(value: i32)
    BoolLit(value: bool)
    StringLit(value: text)
    Variable(name: text)
    BinOp(op: text, left: SimpleExpr, right: SimpleExpr)
    UnOp(op: text, expr: SimpleExpr)
    Call(fn_name: text, args: List<SimpleExpr>)
    FieldAccess(obj: SimpleExpr, field: text)
    MethodCall(obj: SimpleExpr, method: text, args: List<SimpleExpr>)
    If(cond: SimpleExpr, then_branch: SimpleExpr, else_branch: SimpleExpr)
    Match(expr: SimpleExpr, cases: List<(text, SimpleExpr)>)
    Lambda(params: List<text>, body: SimpleExpr)
    Let(name: text, value: SimpleExpr, body: SimpleExpr)
    ListLit(elements: List<SimpleExpr>)
    TupleLit(elements: List<SimpleExpr>)
    Constructor(type_name: text, variant: text, args: List<SimpleExpr>)

impl SimpleExpr:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    me is_literal() -> bool:
        """Check if expression is a literal.

        Returns:
            true for literals

        Example:
            SimpleExpr.IntLit(42).is_literal()  # → true
        """
        match self:
            case IntLit(_): true
            case BoolLit(_): true
            case StringLit(_): true
            case ListLit(_): true
            case TupleLit(_): true
            case _: false

    me is_variable() -> bool:
        """Check if expression is a variable.

        Returns:
            true for Variable

        Example:
            SimpleExpr.Variable("x").is_variable()  # → true
        """
        match self:
            case Variable(_): true
            case _: false

    me is_operator() -> bool:
        """Check if expression is an operator.

        Returns:
            true for BinOp or UnOp

        Example:
            SimpleExpr.BinOp("+", left, right).is_operator()  # → true
        """
        match self:
            case BinOp(_, _, _): true
            case UnOp(_, _): true
            case _: false

    me is_call() -> bool:
        """Check if expression is a function call.

        Returns:
            true for Call or MethodCall

        Example:
            SimpleExpr.Call("foo", []).is_call()  # → true
        """
        match self:
            case Call(_, _): true
            case MethodCall(_, _, _): true
            case _: false

    me is_control_flow() -> bool:
        """Check if expression is control flow.

        Returns:
            true for If or Match

        Example:
            SimpleExpr.If(cond, t, e).is_control_flow()  # → true
        """
        match self:
            case If(_, _, _): true
            case Match(_, _): true
            case _: false

    me is_lambda() -> bool:
        """Check if expression is a lambda.

        Returns:
            true for Lambda

        Example:
            SimpleExpr.Lambda([], body).is_lambda()  # → true
        """
        match self:
            case Lambda(_, _): true
            case _: false

    me is_compound() -> bool:
        """Check if expression is compound (contains sub-expressions).

        Returns:
            true for compound expressions

        Example:
            SimpleExpr.IntLit(42).is_compound()  # → false
            SimpleExpr.BinOp("+", left, right).is_compound()  # → true
        """
        not (self.is_literal() or self.is_variable())

    me to_string() -> text:
        """Convert expression to string representation.

        Returns:
            text representation

        Example:
            SimpleExpr.IntLit(42).to_string()  # → "IntLit(42)"
        """
        match self:
            case IntLit(v): "IntLit({v})"
            case BoolLit(v): "BoolLit({v})"
            case StringLit(v): "StringLit(\"{v}\")"
            case Variable(name): "Variable({name})"
            case BinOp(op, _, _): "BinOp({op}, ...)"
            case UnOp(op, _): "UnOp({op}, ...)"
            case Call(fn_name, args): "Call({fn_name}, {args.len()} args)"
            case FieldAccess(_, field): "FieldAccess(..., {field})"
            case MethodCall(_, method, _): "MethodCall(..., {method})"
            case If(_, _, _): "If(...)"
            case Match(_, cases): "Match(..., {cases.len()} cases)"
            case Lambda(params, _): "Lambda({params.len()} params)"
            case Let(name, _, _): "Let({name}, ...)"
            case ListLit(elems): "ListLit({elems.len()} elements)"
            case TupleLit(elems): "TupleLit({elems.len()} elements)"
            case Constructor(type_name, variant, _): "Constructor({type_name}.{variant})"

    me summary() -> text:
        """Get summary of expression.

        Returns:
            Human-readable summary

        Example:
            SimpleExpr.BinOp("+", left, right).summary()
            # → "SimpleExpr: BinOp(+, ...) (operator, compound)"
        """
        name = self.to_string()
        var attrs: List<text> = []

        if self.is_literal():
            attrs.push("literal")
        if self.is_variable():
            attrs.push("variable")
        if self.is_operator():
            attrs.push("operator")
        if self.is_call():
            attrs.push("call")
        if self.is_control_flow():
            attrs.push("control flow")
        if self.is_lambda():
            attrs.push("lambda")
        if self.is_compound():
            attrs.push("compound")

        attrs_str = attrs.join(", ")
        return "SimpleExpr: {name} ({attrs_str})"

# Translate Simple expression to Lean
fn translate_expr(expr: SimpleExpr) -> text:
    match expr:
        case SimpleExpr.IntLit(v):
            return str(v)

        case SimpleExpr.BoolLit(v):
            if v:
                return "true"
            else:
                return "false"

        case SimpleExpr.StringLit(v):
            return "\"" + escape_string(v) + "\""

        case SimpleExpr.Variable(name):
            return lean_ident(name)

        case SimpleExpr.BinOp(op, left, right):
            l = translate_expr(left)
            r = translate_expr(right)
            lean_op = translate_operator(op)
            return "(" + l + " " + lean_op + " " + r + ")"

        case SimpleExpr.UnOp(op, e):
            inner = translate_expr(e)
            lean_op = translate_unary_operator(op)
            return "(" + lean_op + inner + ")"

        case SimpleExpr.Call(fn_name, args):
            arg_strs = [translate_expr(a) for a in args]
            if len(arg_strs) == 0:
                return lean_ident(fn_name)
            return lean_ident(fn_name) + " " + arg_strs.join(" ")

        case SimpleExpr.FieldAccess(obj, field):
            obj_str = translate_expr(obj)
            return obj_str + "." + lean_ident(field)

        case SimpleExpr.MethodCall(obj, method, args):
            obj_str = translate_expr(obj)
            arg_strs = [translate_expr(a) for a in args]
            if len(arg_strs) == 0:
                return obj_str + "." + lean_ident(method)
            return obj_str + "." + lean_ident(method) + " " + arg_strs.join(" ")

        case SimpleExpr.If(cond, then_b, else_b):
            c = translate_expr(cond)
            t = translate_expr(then_b)
            e = translate_expr(else_b)
            return "if " + c + " then " + t + " else " + e

        case SimpleExpr.Match(e, cases):
            expr_str = translate_expr(e)
            var case_strs = []
            for (pattern, body) in cases:
                body_str = translate_expr(body)
                case_strs.append("| " + pattern + " => " + body_str)
            return "match " + expr_str + " with\n" + case_strs.join("\n")

        case SimpleExpr.Lambda(params, body):
            body_str = translate_expr(body)
            params_str = params.join(" ")
            return "fun " + params_str + " => " + body_str

        case SimpleExpr.Let(name, value, body):
            v = translate_expr(value)
            b = translate_expr(body)
            return "val " + lean_ident(name) + " := " + v + "\n" + b

        case SimpleExpr.ListLit(elements):
            elem_strs = [translate_expr(e) for e in elements]
            return "[" + elem_strs.join(", ") + "]"

        case SimpleExpr.TupleLit(elements):
            elem_strs = [translate_expr(e) for e in elements]
            return "(" + elem_strs.join(", ") + ")"

        case SimpleExpr.Constructor(type_name, variant, args):
            arg_strs = [translate_expr(a) for a in args]
            if len(arg_strs) == 0:
                return type_name + "." + variant
            return type_name + "." + variant + " " + arg_strs.join(" ")

# Convert snake_case to camelCase
fn lean_ident(name: text) -> text:
    parts = name.split("_")
    if len(parts) == 1:
        return name
    var result = parts[0]
    for i in range(1, len(parts)):
        if len(parts[i]) > 0:
            result = result + parts[i][0].upper() + parts[i][1:]
    return result

# Escape special characters in strings
fn escape_string(s: text) -> text:
    var result = ""
    for c in s:
        if c == "\\":
            result = result + "\\\\"
        elif c == "\"":
            result = result + "\\\""
        elif c == "\n":
            result = result + "\\n"
        elif c == "\t":
            result = result + "\\t"
        else:
            result = result + c
    return result

# Translate binary operator
fn translate_operator(op: text) -> text:
    match op:
        case "+": return "+"
        case "-": return "-"
        case "*": return "*"
        case "/": return "/"
        case "%": return "%"
        case "==": return "=="
        case "!=": return "!="
        case "<": return "<"
        case "<=": return "<="
        case ">": return ">"
        case ">=": return ">="
        case "and": return "&&"
        case "or": return "||"
        case "&&": return "&&"
        case "||": return "||"
        case "++": return "++"  # List concat
        case ".": return "."  # List cons
        case _: return op

# Translate unary operator
fn translate_unary_operator(op: text) -> text:
    match op:
        case "-": return "-"
        case "not": return "!"
        case "!": return "!"
        case _: return op

# See expressions_eval.spl for SimplePattern, translate_pattern, SimpleStmt,
# translate_stmt, contract expression translation, and exports.
