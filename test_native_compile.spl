#!/usr/bin/env simple
# Test Native Compilation Demo
# Demonstrates: compile test → native binary → execute

use app.io.mod (process_run_timeout, file_exists, time_now_unix_micros)

fn main():
    print "=== Native Test Compilation Demo ==="
    print ""

    val test_file = "test/runtime/runtime_parser_bugs_spec.spl"
    val output_binary = "test/runtime/runtime_parser_bugs_spec.native"
    val timeout_ms = 60000

    # Step 1: Compile to native
    print "[1/3] Compiling {test_file} to native binary..."
    val compile_start = time_now_unix_micros()

    var compile_args: [text] = ["compile", test_file, "-o", output_binary]
    val binary = "bin/bootstrap/simple"

    val (compile_out, compile_err, compile_code) = process_run_timeout(binary, compile_args, timeout_ms)
    val compile_time = (time_now_unix_micros() - compile_start) / 1000

    if compile_code != 0:
        print "❌ Compilation FAILED ({compile_time}ms)"
        print "Error: {compile_err}"
        return

    print "✅ Compilation succeeded ({compile_time}ms)"

    # Step 2: Verify binary exists
    print "[2/3] Verifying native binary..."
    if file_exists(output_binary):
        print "✅ Binary exists: {output_binary}"
    else:
        print "❌ Binary not found: {output_binary}"
        return

    # Step 3: Run native binary
    print "[3/3] Executing native binary..."
    val run_start = time_now_unix_micros()

    val (run_out, run_err, run_code) = process_run_timeout(output_binary, [], timeout_ms)
    val run_time = (time_now_unix_micros() - run_start) / 1000

    if run_code == 0:
        print "✅ Execution succeeded ({run_time}ms)"
        print ""
        print "=== Test Output ==="
        print run_out
    else:
        print "❌ Execution failed ({run_time}ms)"
        print "Error: {run_err}"

    print ""
    print "Total time: {compile_time + run_time}ms"
