//! Lean 4 memory safety verification code generation.
//!
//! This module generates Lean 4 verification code for memory safety properties,
//! including lifetime constraints, borrow checking, and reference safety.
//!
//! ## Generated Artifacts
//!
//! - `inductive Lifetime` - Lifetime representation
//! - `def outlives` - Outlives relation
//! - `def safe_borrow` - Safe borrow predicate
//! - `theorem` statements for memory safety properties
//!
//! ## Properties Verified
//!
//! 1. **Well-Formedness**: Every reference has a valid lifetime
//! 2. **Containment**: Borrowed reference lifetime ⊆ owner lifetime
//! 3. **Non-Escaping**: References don't escape their defining scope
//! 4. **Drop Order**: Values dropped in reverse declaration order
//! 5. **Uniqueness**: Unique references have exclusive access

use crate::hir::lifetime::{LifetimeContext, LifetimeViolation, ScopeKind};
use crate::hir::{HirModule, MemoryWarningCollector, WarningSummary};

/// Memory safety Lean 4 code generator
pub struct MemorySafetyLeanGen<'a> {
    /// Lifetime context from HIR lowering
    lifetime_ctx: Option<&'a LifetimeContext>,
    /// Memory warnings from HIR lowering
    memory_warnings: Option<&'a MemoryWarningCollector>,
    /// Summary of memory warnings (cached to avoid borrow issues)
    warning_summary: Option<WarningSummary>,
    /// Number of lifetime violations detected during lowering
    lifetime_violation_count: Option<usize>,
    /// Module name for the generated Lean file
    module_name: String,
}

impl<'a> MemorySafetyLeanGen<'a> {
    /// Create a new memory safety Lean generator
    pub fn new(module_name: &str) -> Self {
        Self {
            lifetime_ctx: None,
            memory_warnings: None,
            warning_summary: None,
            lifetime_violation_count: None,
            module_name: module_name.to_string(),
        }
    }

    /// Set the lifetime context
    pub fn with_lifetime_context(mut self, ctx: &'a LifetimeContext) -> Self {
        self.lifetime_ctx = Some(ctx);
        self.lifetime_violation_count = Some(ctx.violations().len());
        self
    }

    /// Set the memory warnings
    pub fn with_memory_warnings(mut self, warnings: &'a MemoryWarningCollector) -> Self {
        self.memory_warnings = Some(warnings);
        self.warning_summary = Some(warnings.summary());
        self
    }

    /// Set the lifetime violation count explicitly (used when context isn't available)
    pub fn with_lifetime_violation_count(mut self, count: usize) -> Self {
        self.lifetime_violation_count = Some(count);
        self
    }

    /// Generate complete Lean 4 memory safety verification module
    pub fn generate(&self) -> String {
        let mut lean = String::new();

        let summary = self
            .warning_summary
            .clone()
            .or_else(|| self.memory_warnings.map(|w| w.summary()))
            .unwrap_or_default();
        let lifetime_violation_count = self
            .lifetime_violation_count
            .or_else(|| self.lifetime_ctx.map(|ctx| ctx.violations().len()))
            .unwrap_or(0);

        // Module header
        lean.push_str(&self.generate_header());
        lean.push_str("\n");

        // Core memory safety types
        lean.push_str(&self.generate_memory_types());
        lean.push_str("\n");

        // Lifetime types and relations
        lean.push_str(&self.generate_lifetime_types());
        lean.push_str("\n");

        // Reference safety predicates
        lean.push_str(&self.generate_reference_safety());
        lean.push_str("\n");

        // Pointer types and rules
        lean.push_str(&self.generate_pointer_rules());
        lean.push_str("\n");

        // Verification obligations (counts, move-only/aliasing expectations)
        lean.push_str(&self.generate_obligations(&summary, lifetime_violation_count));
        lean.push_str("\n");

        // Generate lifetime-specific verification if context available
        if let Some(ctx) = self.lifetime_ctx {
            lean.push_str(&self.generate_lifetime_verification(ctx));
            lean.push_str("\n");
        }

        // Generate violation documentation if any
        if let Some(warnings) = self.memory_warnings {
            if warnings.has_warnings() {
                lean.push_str(&self.generate_warning_documentation(warnings));
                lean.push_str("\n");
            }
        }

        // Module footer
        lean.push_str(&self.generate_footer());

        lean
    }

    fn generate_header(&self) -> String {
        format!(
            r#"/-
  Memory Safety Verification for Simple Language
  Generated by Simple Compiler

  This file contains Lean 4 formalizations of memory safety properties
  for the {} module.

  ## Verification Goals

  1. Reference Safety: All references point to valid memory
  2. Lifetime Safety: References don't outlive their referents
  3. Aliasing Control: Mutation respects aliasing rules
  4. Drop Safety: Resources are released correctly
-/

import Mathlib.Data.Set.Basic
import Mathlib.Order.Basic

namespace {}.MemorySafety

"#,
            self.module_name, self.module_name
        )
    }

    fn generate_footer(&self) -> String {
        format!("end {}.MemorySafety\n", self.module_name)
    }

    fn generate_memory_types(&self) -> String {
        r#"/-
  ## Core Memory Model Types
-/

-- Memory location (abstract address)
structure Loc where
  id : Nat
  deriving DecidableEq, Repr

-- Memory state (maps locations to values)
def MemState := Loc → Option Nat

-- Allocation status
inductive AllocStatus where
  | Allocated : AllocStatus
  | Freed : AllocStatus
  | Uninitialized : AllocStatus
  deriving DecidableEq, Repr

-- Heap representation
structure Heap where
  state : MemState
  alloc : Loc → AllocStatus

-- Initial empty heap
def Heap.empty : Heap := {
  state := fun _ => none,
  alloc := fun _ => AllocStatus.Uninitialized
}

-- Check if location is valid (allocated)
def Heap.isValid (h : Heap) (loc : Loc) : Bool :=
  h.alloc loc = AllocStatus.Allocated

"#
        .to_string()
    }

    fn generate_lifetime_types(&self) -> String {
        r#"/-
  ## Lifetime System
-/

-- Lifetime identifier
structure LifetimeId where
  id : Nat
  deriving DecidableEq, Repr, Ord

-- Static lifetime (lives forever)
def LifetimeId.static : LifetimeId := ⟨0⟩

-- Scope kind for lifetime tracking
inductive ScopeKind where
  | Module : ScopeKind
  | Function : ScopeKind
  | Block : ScopeKind
  | Expression : ScopeKind
  deriving DecidableEq, Repr

-- Scope with lifetime
structure Scope where
  lifetime : LifetimeId
  parent : Option LifetimeId
  kind : ScopeKind

-- Lifetime context
structure LifetimeCtx where
  scopes : List Scope
  current : LifetimeId

-- Outlives relation: a ≥ b means 'a outlives 'b
def outlives (ctx : LifetimeCtx) (a b : LifetimeId) : Bool :=
  if a = LifetimeId.static then true
  else if b = LifetimeId.static then false
  else
    -- Check if a is an ancestor of b in the scope tree
    ctx.scopes.any fun s =>
      s.lifetime = b && s.parent = some a

-- Shorthand notation
notation:50 a " ≥ₗ " b => outlives _ a b

-- Static lifetime outlives all other lifetimes
theorem static_outlives_all (ctx : LifetimeCtx) (lt : LifetimeId) :
  outlives ctx LifetimeId.static lt = true := by
  simp [outlives]

"#
        .to_string()
    }

    fn generate_reference_safety(&self) -> String {
        r#"/-
  ## Reference Safety Predicates
-/

-- Reference origin (where a reference points)
inductive RefOrigin where
  | Local : String → LifetimeId → RefOrigin
  | Parameter : String → Nat → RefOrigin
  | Global : String → RefOrigin
  | Temporary : LifetimeId → RefOrigin
  | Field : RefOrigin → String → RefOrigin
  | Return : String → RefOrigin
  deriving Repr

-- Get the lifetime of a reference origin
def RefOrigin.lifetime : RefOrigin → LifetimeId
  | .Local _ lt => lt
  | .Parameter _ _ => LifetimeId.static  -- Params outlive function body
  | .Global _ => LifetimeId.static
  | .Temporary lt => lt
  | .Field base _ => base.lifetime
  | .Return _ => LifetimeId.static

-- A reference with lifetime tracking
structure Ref (α : Type) where
  value : α
  lifetime : LifetimeId
  origin : RefOrigin

-- Safe borrow predicate: borrow is valid if it doesn't outlive owner
def safeBorrow (ctx : LifetimeCtx) (borrowLt ownerLt : LifetimeId) : Prop :=
  outlives ctx ownerLt borrowLt = true

-- Reference escape check
def doesNotEscape (ctx : LifetimeCtx) (refLt targetLt : LifetimeId) : Prop :=
  outlives ctx refLt targetLt = true

-- Safe return predicate (reference doesn't escape function)
def safeReturn (origin : RefOrigin) : Prop :=
  match origin with
  | .Local _ _ => False  -- Cannot return local reference
  | .Temporary _ => False  -- Cannot return temporary
  | .Field base _ => safeReturn base
  | _ => True  -- Parameters and globals are safe to return

"#
        .to_string()
    }

    fn generate_pointer_rules(&self) -> String {
        r#"/-
  ## Pointer Types and Rules
-/

-- Pointer kind (matches Simple's memory model)
inductive PointerKind where
  | GC : PointerKind      -- T (GC-managed, default)
  | Unique : PointerKind  -- &T (unique/owned)
  | Shared : PointerKind  -- *T (reference-counted)
  | Weak : PointerKind    -- -T (weak reference)
  | Handle : PointerKind  -- +T (arena handle)
  deriving DecidableEq, Repr

-- Capability for mutation control
inductive Capability where
  | Shared : Capability   -- T (read-only, aliasable)
  | Exclusive : Capability -- mut T (mutable, exclusive)
  | Isolated : Capability  -- iso T (isolated, transferable)
  deriving DecidableEq, Repr

-- Typed pointer with capability
structure TypedPtr (α : Type) where
  kind : PointerKind
  capability : Capability
  loc : Loc

-- Aliasing rules
def canAlias (cap : Capability) : Bool :=
  match cap with
  | Capability.Shared => true
  | Capability.Exclusive => false
  | Capability.Isolated => false

def canMutate (cap : Capability) : Bool :=
  match cap with
  | Capability.Shared => false
  | Capability.Exclusive => true
  | Capability.Isolated => true

-- Basic capability properties
theorem shared_no_mut : canMutate Capability.Shared = false := rfl
theorem exclusive_allows_mut : canMutate Capability.Exclusive = true := rfl
theorem isolated_allows_mut : canMutate Capability.Isolated = true := rfl
theorem exclusive_no_alias : canAlias Capability.Exclusive = false := rfl
theorem isolated_no_alias : canAlias Capability.Isolated = false := rfl

-- Shared pointer is read-only (W1001 rule)
theorem shared_readonly : ∀ {α : Type} (ptr : TypedPtr α),
  ptr.capability = Capability.Shared →
  canMutate ptr.capability = false := by
  intro _ ptr hcap
  cases ptr with
  | mk _ capability _ =>
    cases hcap
    simp [canMutate]

-- Unique pointer has move semantics (W1002 rule)
def uniqueMoveOnly {α : Type} (ptr : TypedPtr α) : Prop :=
  ptr.kind = PointerKind.Unique → canAlias ptr.capability = false

"#
        .to_string()
    }

    fn generate_obligations(&self, summary: &WarningSummary, lifetime_violation_count: usize) -> String {
        format!(
            r#"/-
  ## Verification Obligations
-/

-- Compile-time warning counts (must be zero for Rust-level safety)
def sharedMutationWarnings : Nat := {w1001}
def uniqueCopyWarnings : Nat := {w1002}
def mutableSharedWarnings : Nat := {w1003}
def escapingBorrowWarnings : Nat := {w1004}
def potentialCycleWarnings : Nat := {w1005}
def missingMutWarnings : Nat := {w1006}
def lifetimeViolations : Nat := {lifetime_violation_count}

-- Aggregated obligations (aliasing, move-only, and escape)
def aliasingWarnings : Nat := sharedMutationWarnings + mutableSharedWarnings
def moveOnlyWarnings : Nat := uniqueCopyWarnings
def escapeWarnings : Nat := escapingBorrowWarnings + lifetimeViolations

theorem aliasing_blocked : aliasingWarnings = 0 := by decide
theorem move_only_enforced : moveOnlyWarnings = 0 := by decide
theorem escape_blocked : escapeWarnings = 0 := by decide
theorem no_lifetime_violations : lifetimeViolations = 0 := by decide
theorem no_shared_mutation_warnings : sharedMutationWarnings = 0 := by decide
theorem no_mutable_shared_warnings : mutableSharedWarnings = 0 := by decide
theorem no_unique_copy_warnings : uniqueCopyWarnings = 0 := by decide
theorem no_escaping_borrow_warnings : escapingBorrowWarnings = 0 := by decide
theorem no_missing_mut_warnings : missingMutWarnings = 0 := by decide
theorem no_cycle_warnings : potentialCycleWarnings = 0 := by decide

-- Exclusive or isolated capabilities cannot alias
theorem no_alias_for_strong_caps {{α : Type}} (ptr : TypedPtr α) :
  (ptr.capability = Capability.Exclusive ∨ ptr.capability = Capability.Isolated) →
  canAlias ptr.capability = false := by
  intro h
  cases ptr with
  | mk _ capability _ =>
    cases h with
    | inl h_excl =>
        cases h_excl
        simp [canAlias]
    | inr h_iso =>
        cases h_iso
        simp [canAlias]

-- Move-only obligation for unique pointers (relies on compiler checks)
axiom unique_move_only {{α : Type}} (ptr : TypedPtr α) :
  ptr.kind = PointerKind.Unique → canAlias ptr.capability = false
            "#,
            w1001 = summary.w1001,
            w1002 = summary.w1002,
            w1003 = summary.w1003,
            w1004 = summary.w1004,
            w1005 = summary.w1005,
            w1006 = summary.w1006,
            lifetime_violation_count = lifetime_violation_count,
        )
    }

    fn generate_lifetime_verification(&self, ctx: &LifetimeContext) -> String {
        let mut lean = String::new();

        lean.push_str("/-\n");
        lean.push_str("  ## Module-Specific Lifetime Verification\n");
        lean.push_str("-/\n\n");

        // Generate lifetime constants
        lean.push_str("-- Lifetimes in this module\n");

        // Use the existing generate_lean4 method for scope-specific code
        let ctx_lean = ctx.generate_lean4();
        // Extract the relevant parts (skip the namespace wrapper since we have our own)
        for line in ctx_lean.lines() {
            if line.starts_with("namespace") || line.starts_with("end") {
                continue;
            }
            if line.contains("inductive Lifetime") || line.contains("def outlives") {
                // Skip - we already define these
                continue;
            }
            lean.push_str(line);
            lean.push_str("\n");
        }

        // Generate violation checks if any
        if ctx.has_violations() {
            lean.push_str("\n/-\n");
            lean.push_str("  ### Detected Lifetime Violations\n");
            lean.push_str("  These represent compile-time errors that were detected.\n");
            lean.push_str("-/\n\n");

            for (i, violation) in ctx.violations().iter().enumerate() {
                lean.push_str(&format!(
                    "-- Violation {}: [{}] {}\n",
                    i + 1,
                    violation.code(),
                    violation.description()
                ));

                // Generate a theorem that would prove this violation doesn't occur
                // (which would be unprovable if the violation is real)
                match violation {
                    LifetimeViolation::EscapingReference {
                        ref_lifetime,
                        target_scope,
                        ..
                    } => {
                        lean.push_str(&format!(
                            "-- theorem no_escape_{} : outlives ctx (LifetimeId.mk {}) (LifetimeId.mk {}) = true\n",
                            i + 1,
                            ref_lifetime.as_u32(),
                            target_scope.as_u32()
                        ));
                    }
                    LifetimeViolation::ReturnLocalReference { variable, function, .. } => {
                        lean.push_str(&format!(
                            "-- Local '{}' in function '{}' cannot be returned\n",
                            variable, function
                        ));
                    }
                    LifetimeViolation::BorrowOutlivesOwner {
                        borrow_lifetime,
                        owner_lifetime,
                        ..
                    } => {
                        lean.push_str(&format!(
                            "-- theorem borrow_valid_{} : outlives ctx (LifetimeId.mk {}) (LifetimeId.mk {}) = true\n",
                            i + 1,
                            owner_lifetime.as_u32(),
                            borrow_lifetime.as_u32()
                        ));
                    }
                    _ => {
                        lean.push_str(&format!("-- {}\n", violation.description()));
                    }
                }
                lean.push_str("\n");
            }
        }

        lean
    }

    fn generate_warning_documentation(&self, warnings: &MemoryWarningCollector) -> String {
        let mut lean = String::new();

        lean.push_str("/-\n");
        lean.push_str("  ## Memory Safety Warnings\n");
        lean.push_str("  These warnings indicate potential memory safety issues.\n");
        lean.push_str("-/\n\n");

        let summary = warnings.summary();
        lean.push_str(&format!("-- Total warnings: {}\n", summary.total));
        lean.push_str(&format!("-- W1001 (Shared mutation): {}\n", summary.w1001));
        lean.push_str(&format!("-- W1002 (Unique copy): {}\n", summary.w1002));
        lean.push_str(&format!("-- W1003 (Mutable shared): {}\n", summary.w1003));
        lean.push_str(&format!("-- W1004 (Borrow escapes): {}\n", summary.w1004));
        lean.push_str(&format!("-- W1005 (Potential cycle): {}\n", summary.w1005));
        lean.push_str(&format!("-- W1006 (Missing mut): {}\n", summary.w1006));
        lean.push_str("\n");

        lean
    }
}

/// Generate memory safety verification for a HIR module
pub fn generate_memory_safety_lean(
    module: &HirModule,
    lifetime_ctx: Option<&LifetimeContext>,
    memory_warnings: Option<&MemoryWarningCollector>,
    lifetime_violation_count: Option<usize>,
) -> String {
    let module_name = module.name.clone().unwrap_or_else(|| "Main".to_string());
    let mut gen = MemorySafetyLeanGen::new(&module_name);

    if let Some(ctx) = lifetime_ctx {
        gen = gen.with_lifetime_context(ctx);
    }

    if let Some(warnings) = memory_warnings {
        gen = gen.with_memory_warnings(warnings);
    }

    if let Some(count) = lifetime_violation_count {
        gen = gen.with_lifetime_violation_count(count);
    }

    gen.generate()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_basic_generation() {
        let gen = MemorySafetyLeanGen::new("TestModule");
        let lean = gen.generate();

        assert!(lean.contains("namespace TestModule.MemorySafety"));
        assert!(lean.contains("inductive PointerKind"));
        assert!(lean.contains("def safeBorrow"));
        assert!(lean.contains("theorem static_outlives_all"));
    }

    #[test]
    fn test_with_lifetime_context() {
        let mut ctx = LifetimeContext::new();
        ctx.enter_scope(ScopeKind::Function, None);
        ctx.enter_scope(ScopeKind::Block, None);

        let gen = MemorySafetyLeanGen::new("TestModule").with_lifetime_context(&ctx);
        let lean = gen.generate();

        assert!(lean.contains("Module-Specific Lifetime Verification"));
    }
}
