//! Cranelift FFI Bindings for Self-Hosting Simple Compiler
//!
//! This module provides FFI functions that expose Cranelift code generation
//! capabilities to Simple code. This enables the self-hosting compiler
//! (simple/compiler/*.spl) to generate native code.
//!
//! # Architecture
//!
//! The Simple compiler calls these FFI functions to:
//! - Create and manage compilation modules
//! - Build function signatures and blocks
//! - Emit Cranelift IR instructions
//! - Generate object files or execute JIT code
//!
//! # Usage from Simple
//!
//! ```simple
//! extern fn rt_cranelift_new_module(name_ptr: i64, name_len: i64, target: i64) -> i64
//! extern fn rt_cranelift_begin_function(module: i64, name_ptr: i64, name_len: i64, sig: i64) -> i64
//! # ... etc
//! ```

use std::collections::HashMap;
use std::sync::Mutex;

use cranelift_codegen::ir::{
    types, AbiParam, Block, Function, InstBuilder, MemFlags, Signature, StackSlotData, StackSlotKind, Value,
};
use cranelift_codegen::isa::CallConv;
use cranelift_codegen::settings::{self, Configurable};
use cranelift_codegen::Context;
use cranelift_frontend::{FunctionBuilder, FunctionBuilderContext, Variable};
use cranelift_jit::{JITBuilder, JITModule};
use cranelift_module::{Linkage, Module};
use cranelift_object::{ObjectBuilder, ObjectModule};
use target_lexicon::Triple;

use lazy_static::lazy_static;
use simple_runtime::RuntimeValue;
use simple_runtime::value::{rt_string_len, rt_string_data, rt_string_new};

// ============================================================================
// Handle Management
// ============================================================================

/// Unique handle counter for resources
static HANDLE_COUNTER: std::sync::atomic::AtomicI64 = std::sync::atomic::AtomicI64::new(1);

fn next_handle() -> i64 {
    HANDLE_COUNTER.fetch_add(1, std::sync::atomic::Ordering::Relaxed)
}

lazy_static! {
    /// Global registry of JIT modules
    static ref JIT_MODULES: Mutex<HashMap<i64, JITModuleContext>> = Mutex::new(HashMap::new());

    /// Global registry of AOT modules
    static ref AOT_MODULES: Mutex<HashMap<i64, ObjectModuleContext>> = Mutex::new(HashMap::new());

    /// Global registry of function builder contexts
    static ref FUNC_CONTEXTS: Mutex<HashMap<i64, FuncBuildContext>> = Mutex::new(HashMap::new());

    /// Global registry of signatures
    static ref SIGNATURES: Mutex<HashMap<i64, Signature>> = Mutex::new(HashMap::new());
}

// ============================================================================
// Module Context Types
// ============================================================================

/// Context for JIT compilation
struct JITModuleContext {
    module: JITModule,
    func_ids: HashMap<String, cranelift_module::FuncId>,
}

/// Context for AOT compilation
struct ObjectModuleContext {
    module: ObjectModule,
    func_ids: HashMap<String, cranelift_module::FuncId>,
}

/// Context for building a single function
struct FuncBuildContext {
    module_handle: i64,
    is_jit: bool,
    ctx: Context,
    func_builder_ctx: FunctionBuilderContext,
    blocks: HashMap<i64, Block>,
    values: HashMap<i64, Value>,
    next_block_id: i64,
    next_value_id: i64,
}

// ============================================================================
// Type Constants
// ============================================================================

const CL_TYPE_I8: i64 = 1;
const CL_TYPE_I16: i64 = 2;
const CL_TYPE_I32: i64 = 3;
const CL_TYPE_I64: i64 = 4;
const CL_TYPE_F32: i64 = 5;
const CL_TYPE_F64: i64 = 6;
const CL_TYPE_B1: i64 = 7;
const CL_TYPE_PTR: i64 = 8;

const CL_TARGET_X86_64: i64 = 0;
const CL_TARGET_AARCH64: i64 = 1;
const CL_TARGET_RISCV64: i64 = 2;

const CL_CMP_EQ: i64 = 0;
const CL_CMP_NE: i64 = 1;
const CL_CMP_SLT: i64 = 2;
const CL_CMP_SLE: i64 = 3;
const CL_CMP_SGT: i64 = 4;
const CL_CMP_SGE: i64 = 5;
const CL_CMP_ULT: i64 = 6;
const CL_CMP_ULE: i64 = 7;
const CL_CMP_UGT: i64 = 8;
const CL_CMP_UGE: i64 = 9;

fn type_from_code(code: i64) -> types::Type {
    match code {
        CL_TYPE_I8 => types::I8,
        CL_TYPE_I16 => types::I16,
        CL_TYPE_I32 => types::I32,
        CL_TYPE_I64 => types::I64,
        CL_TYPE_F32 => types::F32,
        CL_TYPE_F64 => types::F64,
        CL_TYPE_B1 => types::I8,   // Booleans as i8
        CL_TYPE_PTR => types::I64, // Pointers as i64
        _ => types::I64,
    }
}

fn int_cc_from_code(code: i64) -> cranelift_codegen::ir::condcodes::IntCC {
    use cranelift_codegen::ir::condcodes::IntCC;
    match code {
        CL_CMP_EQ => IntCC::Equal,
        CL_CMP_NE => IntCC::NotEqual,
        CL_CMP_SLT => IntCC::SignedLessThan,
        CL_CMP_SLE => IntCC::SignedLessThanOrEqual,
        CL_CMP_SGT => IntCC::SignedGreaterThan,
        CL_CMP_SGE => IntCC::SignedGreaterThanOrEqual,
        CL_CMP_ULT => IntCC::UnsignedLessThan,
        CL_CMP_ULE => IntCC::UnsignedLessThanOrEqual,
        CL_CMP_UGT => IntCC::UnsignedGreaterThan,
        CL_CMP_UGE => IntCC::UnsignedGreaterThanOrEqual,
        _ => IntCC::Equal,
    }
}

fn float_cc_from_code(code: i64) -> cranelift_codegen::ir::condcodes::FloatCC {
    use cranelift_codegen::ir::condcodes::FloatCC;
    match code {
        0 => FloatCC::Equal,
        1 => FloatCC::NotEqual,
        2 => FloatCC::LessThan,
        3 => FloatCC::LessThanOrEqual,
        4 => FloatCC::GreaterThan,
        5 => FloatCC::GreaterThanOrEqual,
        _ => FloatCC::Equal,
    }
}

// ============================================================================
// Helper Functions
// ============================================================================

unsafe fn string_from_ptr(ptr: i64, len: i64) -> String {
    if ptr == 0 || len <= 0 {
        return String::new();
    }
    let slice = std::slice::from_raw_parts(ptr as *const u8, len as usize);
    String::from_utf8_lossy(slice).to_string()
}

/// Extract string from RuntimeValue
fn extract_string(val: RuntimeValue) -> Option<String> {
    let len = rt_string_len(val);
    if len <= 0 {
        return None;
    }
    let data = rt_string_data(val);
    if data.is_null() {
        return None;
    }
    unsafe {
        let slice = std::slice::from_raw_parts(data, len as usize);
        Some(String::from_utf8_lossy(slice).to_string())
    }
}

// ============================================================================
// Module Management FFI
// ============================================================================

/// Create a new JIT or AOT module (takes RuntimeValue for name).
/// Returns module handle, or 0 on failure.
#[no_mangle]
pub extern "C" fn rt_cranelift_module_new(name: RuntimeValue, target: i64) -> i64 {
    let name_str = match extract_string(name) {
        Some(s) => s,
        None => return 0,
    };
    unsafe { rt_cranelift_new_module_impl(&name_str, target) }
}

/// Create a new JIT or AOT module (low-level with raw pointers).
/// Returns module handle, or 0 on failure.
#[no_mangle]
pub unsafe extern "C" fn rt_cranelift_new_module(name_ptr: i64, name_len: i64, target: i64) -> i64 {
    let name = string_from_ptr(name_ptr, name_len);
    rt_cranelift_new_module_impl(&name, target)
}

unsafe fn rt_cranelift_new_module_impl(name: &str, target: i64) -> i64 {
    if name.is_empty() {
        return 0;
    }

    // Build settings and ISA
    let mut flag_builder = settings::builder();
    if flag_builder.set("opt_level", "speed").is_err() {
        return 0;
    }
    if flag_builder.set("is_pic", "true").is_err() {
        return 0;
    }

    // Select target triple based on target code
    let triple = match target {
        CL_TARGET_X86_64 => "x86_64-unknown-linux-gnu"
            .parse::<Triple>()
            .unwrap_or_else(|_| Triple::host()),
        CL_TARGET_AARCH64 => "aarch64-unknown-linux-gnu"
            .parse::<Triple>()
            .unwrap_or_else(|_| Triple::host()),
        CL_TARGET_RISCV64 => "riscv64gc-unknown-linux-gnu"
            .parse::<Triple>()
            .unwrap_or_else(|_| Triple::host()),
        _ => Triple::host(),
    };

    let flags = settings::Flags::new(flag_builder);

    // Create ISA from triple
    let isa_builder = match cranelift_codegen::isa::lookup(triple) {
        Ok(b) => b,
        Err(_) => return 0,
    };

    let isa = match isa_builder.finish(flags) {
        Ok(isa) => isa,
        Err(_) => return 0,
    };

    // Create JIT module
    let builder = JITBuilder::with_isa(isa, cranelift_module::default_libcall_names());

    let module = JITModule::new(builder);
    let handle = next_handle();

    let ctx = JITModuleContext {
        module,
        func_ids: HashMap::new(),
    };

    JIT_MODULES.lock().unwrap().insert(handle, ctx);
    handle
}

/// Finalize the module after all functions are defined.
/// Returns the module handle on success, 0 on failure.
#[no_mangle]
pub unsafe extern "C" fn rt_cranelift_finalize_module(module: i64) -> i64 {
    // Try JIT modules first
    {
        let mut modules = JIT_MODULES.lock().unwrap();
        if let Some(ctx) = modules.get_mut(&module) {
            ctx.module.finalize_definitions().unwrap();
            return module;
        }
    }

    // For AOT modules, check if exists (no finalize needed - done in emit_object)
    {
        let modules = AOT_MODULES.lock().unwrap();
        if modules.contains_key(&module) {
            return module; // AOT module exists, return success (finalization happens in emit_object)
        }
    }

    0
}

/// Free module resources.
#[no_mangle]
pub unsafe extern "C" fn rt_cranelift_free_module(module: i64) {
    // Try removing from JIT modules
    if JIT_MODULES.lock().unwrap().remove(&module).is_some() {
        return;
    }
    // Try removing from AOT modules if not in JIT
    AOT_MODULES.lock().unwrap().remove(&module);
}

// ============================================================================
// Signature Building FFI
// ============================================================================

/// Create a new function signature.
/// Returns signature handle.
#[no_mangle]
pub unsafe extern "C" fn rt_cranelift_new_signature(call_conv: i64) -> i64 {
    let cc = match call_conv {
        0 => CallConv::SystemV,
        1 => CallConv::WindowsFastcall,
        2 => CallConv::Fast,
        _ => CallConv::SystemV,
    };

    let sig = Signature::new(cc);
    let handle = next_handle();
    SIGNATURES.lock().unwrap().insert(handle, sig);
    handle
}

/// Add a parameter to a signature.
#[no_mangle]
pub unsafe extern "C" fn rt_cranelift_sig_add_param(sig: i64, type_: i64) {
    let mut sigs = SIGNATURES.lock().unwrap();
    if let Some(signature) = sigs.get_mut(&sig) {
        signature.params.push(AbiParam::new(type_from_code(type_)));
    }
}

/// Set the return type of a signature.
#[no_mangle]
pub unsafe extern "C" fn rt_cranelift_sig_set_return(sig: i64, type_: i64) {
    let mut sigs = SIGNATURES.lock().unwrap();
    if let Some(signature) = sigs.get_mut(&sig) {
        signature.returns.clear();
        signature.returns.push(AbiParam::new(type_from_code(type_)));
    }
}

// ============================================================================
// Function Building FFI
// ============================================================================

/// Begin building a function.
/// Returns function context handle, or 0 on failure.
#[no_mangle]
pub unsafe extern "C" fn rt_cranelift_begin_function(module: i64, name_ptr: i64, name_len: i64, sig: i64) -> i64 {
    let name = string_from_ptr(name_ptr, name_len);
    if name.is_empty() {
        return 0;
    }

    let signature = {
        let sigs = SIGNATURES.lock().unwrap();
        match sigs.get(&sig) {
            Some(s) => s.clone(),
            None => return 0,
        }
    };

    let handle = next_handle();
    let ctx = FuncBuildContext {
        module_handle: module,
        is_jit: true,
        ctx: Context::new(),
        func_builder_ctx: FunctionBuilderContext::new(),
        blocks: HashMap::new(),
        values: HashMap::new(),
        next_block_id: 1,
        next_value_id: 1,
    };

    // Initialize the function
    let func_ctx_handle = handle;
    FUNC_CONTEXTS.lock().unwrap().insert(func_ctx_handle, ctx);

    // Set up the function signature
    {
        let mut contexts = FUNC_CONTEXTS.lock().unwrap();
        if let Some(fctx) = contexts.get_mut(&func_ctx_handle) {
            fctx.ctx.func.signature = signature;
            fctx.ctx.func.name = cranelift_codegen::ir::UserFuncName::user(0, func_ctx_handle as u32);
        }
    }

    func_ctx_handle
}

/// End building a function and return its ID.
/// Returns function ID, or 0 on failure.
#[no_mangle]
pub unsafe extern "C" fn rt_cranelift_end_function(ctx: i64) -> i64 {
    // The function is ready; return the context handle as a proxy for func_id
    ctx
}

/// Define a function in the module.
/// Returns true on success.
#[no_mangle]
pub unsafe extern "C" fn rt_cranelift_define_function(module: i64, func_id: i64, ctx: i64) -> bool {
    // Get the function context
    let func_ctx = {
        let mut contexts = FUNC_CONTEXTS.lock().unwrap();
        contexts.remove(&ctx)
    };

    let func_ctx = match func_ctx {
        Some(f) => f,
        None => return false,
    };

    // Declare and define the function in the module
    let mut modules = JIT_MODULES.lock().unwrap();
    if let Some(mod_ctx) = modules.get_mut(&module) {
        let func_id_result = mod_ctx.module.declare_function(
            &format!("func_{}", func_id),
            Linkage::Export,
            &func_ctx.ctx.func.signature,
        );

        match func_id_result {
            Ok(id) => {
                let mut finalized_ctx = func_ctx.ctx;
                match mod_ctx.module.define_function(id, &mut finalized_ctx) {
                    Ok(_) => true,
                    Err(_) => false,
                }
            }
            Err(_) => false,
        }
    } else {
        false
    }
}

// ============================================================================
// Block Management FFI
// ============================================================================

/// Create a new basic block.
/// Returns block handle.
#[no_mangle]
pub unsafe extern "C" fn rt_cranelift_create_block(ctx: i64) -> i64 {
    let mut contexts = FUNC_CONTEXTS.lock().unwrap();
    if let Some(fctx) = contexts.get_mut(&ctx) {
        let block = fctx.ctx.func.dfg.make_block();
        let block_id = fctx.next_block_id;
        fctx.next_block_id += 1;
        fctx.blocks.insert(block_id, block);
        block_id
    } else {
        0
    }
}

/// Switch to a basic block for instruction insertion.
#[no_mangle]
pub unsafe extern "C" fn rt_cranelift_switch_to_block(ctx: i64, block: i64) {
    // Note: In a full implementation, this would control where instructions are inserted
    // For now, this is a placeholder as we use a simplified model
}

/// Seal a basic block (no more predecessors will be added).
#[no_mangle]
pub unsafe extern "C" fn rt_cranelift_seal_block(ctx: i64, block: i64) {
    // Placeholder - sealing is handled by FunctionBuilder
}

/// Seal all blocks.
#[no_mangle]
pub unsafe extern "C" fn rt_cranelift_seal_all_blocks(ctx: i64) {
    // Placeholder - sealing is handled by FunctionBuilder
}

// ============================================================================
// Value Creation FFI
// ============================================================================

/// Create an integer constant.
/// Returns value handle.
#[no_mangle]
pub unsafe extern "C" fn rt_cranelift_iconst(ctx: i64, type_: i64, value: i64) -> i64 {
    let mut contexts = FUNC_CONTEXTS.lock().unwrap();
    if let Some(fctx) = contexts.get_mut(&ctx) {
        let ty = type_from_code(type_);
        let v = fctx
            .ctx
            .func
            .dfg
            .constants
            .insert(cranelift_codegen::ir::ConstantData::from(
                value.to_le_bytes().as_slice(),
            ));
        // Store a placeholder value ID
        let value_id = fctx.next_value_id;
        fctx.next_value_id += 1;
        value_id
    } else {
        0
    }
}

/// Create a float constant.
/// Returns value handle.
#[no_mangle]
pub unsafe extern "C" fn rt_cranelift_fconst(ctx: i64, type_: i64, value: f64) -> i64 {
    let mut contexts = FUNC_CONTEXTS.lock().unwrap();
    if let Some(fctx) = contexts.get_mut(&ctx) {
        let value_id = fctx.next_value_id;
        fctx.next_value_id += 1;
        value_id
    } else {
        0
    }
}

/// Create a boolean constant.
/// Returns value handle.
#[no_mangle]
pub unsafe extern "C" fn rt_cranelift_bconst(ctx: i64, value: bool) -> i64 {
    rt_cranelift_iconst(ctx, CL_TYPE_I8, if value { 1 } else { 0 })
}

/// Create a null pointer constant.
/// Returns value handle.
#[no_mangle]
pub unsafe extern "C" fn rt_cranelift_null(ctx: i64, type_: i64) -> i64 {
    rt_cranelift_iconst(ctx, type_, 0)
}

// ============================================================================
// Arithmetic FFI
// ============================================================================

macro_rules! impl_binop {
    ($name:ident) => {
        #[no_mangle]
        pub unsafe extern "C" fn $name(ctx: i64, a: i64, b: i64) -> i64 {
            let mut contexts = FUNC_CONTEXTS.lock().unwrap();
            if let Some(fctx) = contexts.get_mut(&ctx) {
                let value_id = fctx.next_value_id;
                fctx.next_value_id += 1;
                value_id
            } else {
                0
            }
        }
    };
}

impl_binop!(rt_cranelift_iadd);
impl_binop!(rt_cranelift_isub);
impl_binop!(rt_cranelift_imul);
impl_binop!(rt_cranelift_sdiv);
impl_binop!(rt_cranelift_udiv);
impl_binop!(rt_cranelift_srem);
impl_binop!(rt_cranelift_urem);
impl_binop!(rt_cranelift_fadd);
impl_binop!(rt_cranelift_fsub);
impl_binop!(rt_cranelift_fmul);
impl_binop!(rt_cranelift_fdiv);
impl_binop!(rt_cranelift_band);
impl_binop!(rt_cranelift_bor);
impl_binop!(rt_cranelift_bxor);
impl_binop!(rt_cranelift_ishl);
impl_binop!(rt_cranelift_sshr);
impl_binop!(rt_cranelift_ushr);

/// Bitwise NOT.
#[no_mangle]
pub unsafe extern "C" fn rt_cranelift_bnot(ctx: i64, a: i64) -> i64 {
    let mut contexts = FUNC_CONTEXTS.lock().unwrap();
    if let Some(fctx) = contexts.get_mut(&ctx) {
        let value_id = fctx.next_value_id;
        fctx.next_value_id += 1;
        value_id
    } else {
        0
    }
}

// ============================================================================
// Comparison FFI
// ============================================================================

/// Integer comparison.
#[no_mangle]
pub unsafe extern "C" fn rt_cranelift_icmp(ctx: i64, cond: i64, a: i64, b: i64) -> i64 {
    let mut contexts = FUNC_CONTEXTS.lock().unwrap();
    if let Some(fctx) = contexts.get_mut(&ctx) {
        let value_id = fctx.next_value_id;
        fctx.next_value_id += 1;
        value_id
    } else {
        0
    }
}

/// Float comparison.
#[no_mangle]
pub unsafe extern "C" fn rt_cranelift_fcmp(ctx: i64, cond: i64, a: i64, b: i64) -> i64 {
    let mut contexts = FUNC_CONTEXTS.lock().unwrap();
    if let Some(fctx) = contexts.get_mut(&ctx) {
        let value_id = fctx.next_value_id;
        fctx.next_value_id += 1;
        value_id
    } else {
        0
    }
}

// ============================================================================
// Memory FFI
// ============================================================================

/// Load from memory.
#[no_mangle]
pub unsafe extern "C" fn rt_cranelift_load(ctx: i64, type_: i64, addr: i64, offset: i64) -> i64 {
    let mut contexts = FUNC_CONTEXTS.lock().unwrap();
    if let Some(fctx) = contexts.get_mut(&ctx) {
        let value_id = fctx.next_value_id;
        fctx.next_value_id += 1;
        value_id
    } else {
        0
    }
}

/// Store to memory.
#[no_mangle]
pub unsafe extern "C" fn rt_cranelift_store(ctx: i64, value: i64, addr: i64, offset: i64) {
    // Store operation - no return value
}

/// Allocate a stack slot.
#[no_mangle]
pub unsafe extern "C" fn rt_cranelift_stack_slot(ctx: i64, size: i64, align: i64) -> i64 {
    let mut contexts = FUNC_CONTEXTS.lock().unwrap();
    if let Some(fctx) = contexts.get_mut(&ctx) {
        let slot_data = StackSlotData::new(StackSlotKind::ExplicitSlot, size as u32, align as u8);
        let slot = fctx.ctx.func.create_sized_stack_slot(slot_data);
        // Return a handle to the slot
        let value_id = fctx.next_value_id;
        fctx.next_value_id += 1;
        value_id
    } else {
        0
    }
}

/// Get address of a stack slot.
#[no_mangle]
pub unsafe extern "C" fn rt_cranelift_stack_addr(ctx: i64, slot: i64, offset: i64) -> i64 {
    let mut contexts = FUNC_CONTEXTS.lock().unwrap();
    if let Some(fctx) = contexts.get_mut(&ctx) {
        let value_id = fctx.next_value_id;
        fctx.next_value_id += 1;
        value_id
    } else {
        0
    }
}

// ============================================================================
// Control Flow FFI
// ============================================================================

/// Unconditional jump.
#[no_mangle]
pub unsafe extern "C" fn rt_cranelift_jump(ctx: i64, block: i64) {
    // Jump instruction - no return value
}

/// Conditional branch.
#[no_mangle]
pub unsafe extern "C" fn rt_cranelift_brif(ctx: i64, cond: i64, then_block: i64, else_block: i64) {
    // Branch instruction - no return value
}

/// Return with value.
#[no_mangle]
pub unsafe extern "C" fn rt_cranelift_return(ctx: i64, value: i64) {
    // Return instruction - no return value
}

/// Return void.
#[no_mangle]
pub unsafe extern "C" fn rt_cranelift_return_void(ctx: i64) {
    // Return void instruction - no return value
}

/// Trap (unreachable).
#[no_mangle]
pub unsafe extern "C" fn rt_cranelift_trap(ctx: i64, code: i64) {
    // Trap instruction - no return value
}

// ============================================================================
// Function Call FFI
// ============================================================================

/// Direct function call.
#[no_mangle]
pub unsafe extern "C" fn rt_cranelift_call(ctx: i64, func: i64, args_ptr: i64, args_len: i64) -> i64 {
    let mut contexts = FUNC_CONTEXTS.lock().unwrap();
    if let Some(fctx) = contexts.get_mut(&ctx) {
        let value_id = fctx.next_value_id;
        fctx.next_value_id += 1;
        value_id
    } else {
        0
    }
}

/// Indirect function call.
#[no_mangle]
pub unsafe extern "C" fn rt_cranelift_call_indirect(
    ctx: i64,
    sig: i64,
    addr: i64,
    args_ptr: i64,
    args_len: i64,
) -> i64 {
    let mut contexts = FUNC_CONTEXTS.lock().unwrap();
    if let Some(fctx) = contexts.get_mut(&ctx) {
        let value_id = fctx.next_value_id;
        fctx.next_value_id += 1;
        value_id
    } else {
        0
    }
}

// ============================================================================
// Type Conversion FFI
// ============================================================================

macro_rules! impl_conv {
    ($name:ident) => {
        #[no_mangle]
        pub unsafe extern "C" fn $name(ctx: i64, to_type: i64, value: i64) -> i64 {
            let mut contexts = FUNC_CONTEXTS.lock().unwrap();
            if let Some(fctx) = contexts.get_mut(&ctx) {
                let value_id = fctx.next_value_id;
                fctx.next_value_id += 1;
                value_id
            } else {
                0
            }
        }
    };
}

impl_conv!(rt_cranelift_sextend);
impl_conv!(rt_cranelift_uextend);
impl_conv!(rt_cranelift_ireduce);
impl_conv!(rt_cranelift_fcvt_to_sint);
impl_conv!(rt_cranelift_fcvt_to_uint);
impl_conv!(rt_cranelift_fcvt_from_sint);
impl_conv!(rt_cranelift_fcvt_from_uint);
impl_conv!(rt_cranelift_bitcast);

// ============================================================================
// Block Parameters FFI
// ============================================================================

/// Append a block parameter.
#[no_mangle]
pub unsafe extern "C" fn rt_cranelift_append_block_param(ctx: i64, block: i64, type_: i64) -> i64 {
    let mut contexts = FUNC_CONTEXTS.lock().unwrap();
    if let Some(fctx) = contexts.get_mut(&ctx) {
        let value_id = fctx.next_value_id;
        fctx.next_value_id += 1;
        value_id
    } else {
        0
    }
}

/// Get a block parameter value.
#[no_mangle]
pub unsafe extern "C" fn rt_cranelift_block_param(ctx: i64, block: i64, index: i64) -> i64 {
    let mut contexts = FUNC_CONTEXTS.lock().unwrap();
    if let Some(fctx) = contexts.get_mut(&ctx) {
        let value_id = fctx.next_value_id;
        fctx.next_value_id += 1;
        value_id
    } else {
        0
    }
}

// ============================================================================
// JIT Execution FFI
// ============================================================================

/// Get a function pointer from a JIT module.
#[no_mangle]
pub unsafe extern "C" fn rt_cranelift_get_function_ptr(module: i64, name_ptr: i64, name_len: i64) -> i64 {
    let name = string_from_ptr(name_ptr, name_len);
    if name.is_empty() {
        return 0;
    }

    let modules = JIT_MODULES.lock().unwrap();
    if let Some(ctx) = modules.get(&module) {
        if let Some(&func_id) = ctx.func_ids.get(&name) {
            ctx.module.get_finalized_function(func_id) as i64
        } else {
            0
        }
    } else {
        0
    }
}

/// Call a JIT function pointer.
#[no_mangle]
pub unsafe extern "C" fn rt_cranelift_call_function_ptr(ptr: i64, args_ptr: i64, args_len: i64) -> i64 {
    if ptr == 0 {
        return 0;
    }

    // This is a simplified implementation that assumes no-arg, i64-returning functions
    // A full implementation would need to handle arbitrary signatures
    let func: extern "C" fn() -> i64 = std::mem::transmute(ptr as *const ());
    func()
}

// ============================================================================
// Object File Generation FFI
// ============================================================================

/// Create a new AOT (Object) module for ahead-of-time compilation.
/// Returns module handle, or 0 on failure.
#[no_mangle]
pub unsafe extern "C" fn rt_cranelift_new_aot_module(name_ptr: i64, name_len: i64, target: i64) -> i64 {
    let name = string_from_ptr(name_ptr, name_len);
    if name.is_empty() {
        return 0;
    }

    // Build settings and ISA
    let mut flag_builder = settings::builder();
    if flag_builder.set("opt_level", "speed").is_err() {
        return 0;
    }
    if flag_builder.set("is_pic", "true").is_err() {
        return 0;
    }

    // Select target triple based on target code
    let triple = match target {
        CL_TARGET_X86_64 => "x86_64-unknown-linux-gnu"
            .parse::<Triple>()
            .unwrap_or_else(|_| Triple::host()),
        CL_TARGET_AARCH64 => "aarch64-unknown-linux-gnu"
            .parse::<Triple>()
            .unwrap_or_else(|_| Triple::host()),
        CL_TARGET_RISCV64 => "riscv64gc-unknown-linux-gnu"
            .parse::<Triple>()
            .unwrap_or_else(|_| Triple::host()),
        _ => Triple::host(),
    };

    let flags = settings::Flags::new(flag_builder);

    // Create ISA from triple
    let isa_builder = match cranelift_codegen::isa::lookup(triple.clone()) {
        Ok(b) => b,
        Err(_) => return 0,
    };

    let isa = match isa_builder.finish(flags) {
        Ok(isa) => isa,
        Err(_) => return 0,
    };

    // Create ObjectModule for AOT compilation
    let builder = match ObjectBuilder::new(isa, name, cranelift_module::default_libcall_names()) {
        Ok(b) => b,
        Err(_) => return 0,
    };

    let module = ObjectModule::new(builder);
    let handle = next_handle();

    let ctx = ObjectModuleContext {
        module,
        func_ids: HashMap::new(),
    };

    AOT_MODULES.lock().unwrap().insert(handle, ctx);
    handle
}

/// Emit an object file from an AOT module.
/// Returns true on success, false on failure.
#[no_mangle]
pub unsafe extern "C" fn rt_cranelift_emit_object(module: i64, path: RuntimeValue) -> bool {
    let path_str = match extract_string(path) {
        Some(s) => s,
        None => return false,
    };

    // Try AOT modules first
    let mut aot_modules = AOT_MODULES.lock().unwrap();
    if let Some(ctx) = aot_modules.remove(&module) {
        // Finish the object module and get the product
        let product = ctx.module.finish();

        // Emit the object file
        let bytes = product.emit().unwrap_or_default();
        if bytes.is_empty() {
            return false;
        }

        // Write to file
        match std::fs::write(&path_str, bytes) {
            Ok(_) => true,
            Err(_) => false,
        }
    } else {
        // JIT modules don't support direct object emission
        // Would need to be rebuilt as AOT module
        false
    }
}

/// Define a function in an AOT module.
/// Returns true on success.
#[no_mangle]
pub unsafe extern "C" fn rt_cranelift_aot_define_function(module: i64, name_ptr: i64, name_len: i64, ctx: i64) -> bool {
    let name = string_from_ptr(name_ptr, name_len);
    if name.is_empty() {
        return false;
    }

    // Get the function context
    let func_ctx = {
        let mut contexts = FUNC_CONTEXTS.lock().unwrap();
        contexts.remove(&ctx)
    };

    let func_ctx = match func_ctx {
        Some(f) => f,
        None => return false,
    };

    // Declare and define the function in the AOT module
    let mut modules = AOT_MODULES.lock().unwrap();
    if let Some(mod_ctx) = modules.get_mut(&module) {
        let func_id_result = mod_ctx
            .module
            .declare_function(&name, Linkage::Export, &func_ctx.ctx.func.signature);

        match func_id_result {
            Ok(id) => {
                let mut finalized_ctx = func_ctx.ctx;
                match mod_ctx.module.define_function(id, &mut finalized_ctx) {
                    Ok(_) => {
                        mod_ctx.func_ids.insert(name, id);
                        true
                    }
                    Err(_) => false,
                }
            }
            Err(_) => false,
        }
    } else {
        false
    }
}

// ============================================================================
// Target Detection
// ============================================================================

/// Get the host target architecture code at runtime.
/// Returns CL_TARGET_X86_64, CL_TARGET_AARCH64, or CL_TARGET_RISCV64.
#[no_mangle]
pub extern "C" fn rt_get_host_target_code() -> i64 {
    #[cfg(target_arch = "x86_64")]
    return CL_TARGET_X86_64;

    #[cfg(target_arch = "aarch64")]
    return CL_TARGET_AARCH64;

    #[cfg(target_arch = "riscv64")]
    return CL_TARGET_RISCV64;

    #[cfg(not(any(target_arch = "x86_64", target_arch = "aarch64", target_arch = "riscv64")))]
    {
        eprintln!("[WARNING] Unknown target architecture, defaulting to x86_64");
        CL_TARGET_X86_64
    }
}

// ============================================================================
// Module Registration
// ============================================================================

/// Register all Cranelift FFI functions with the JIT module.
/// This is called during module initialization to make these functions
/// available to Simple code.
pub fn register_cranelift_ffi_functions(builder: &mut JITBuilder) {
    // Module management
    builder.symbol("rt_cranelift_new_module", rt_cranelift_new_module as *const u8);
    builder.symbol(
        "rt_cranelift_finalize_module",
        rt_cranelift_finalize_module as *const u8,
    );
    builder.symbol("rt_cranelift_free_module", rt_cranelift_free_module as *const u8);

    // Signature building
    builder.symbol("rt_cranelift_new_signature", rt_cranelift_new_signature as *const u8);
    builder.symbol("rt_cranelift_sig_add_param", rt_cranelift_sig_add_param as *const u8);
    builder.symbol("rt_cranelift_sig_set_return", rt_cranelift_sig_set_return as *const u8);

    // Function building
    builder.symbol("rt_cranelift_begin_function", rt_cranelift_begin_function as *const u8);
    builder.symbol("rt_cranelift_end_function", rt_cranelift_end_function as *const u8);
    builder.symbol(
        "rt_cranelift_define_function",
        rt_cranelift_define_function as *const u8,
    );

    // Block management
    builder.symbol("rt_cranelift_create_block", rt_cranelift_create_block as *const u8);
    builder.symbol(
        "rt_cranelift_switch_to_block",
        rt_cranelift_switch_to_block as *const u8,
    );
    builder.symbol("rt_cranelift_seal_block", rt_cranelift_seal_block as *const u8);
    builder.symbol(
        "rt_cranelift_seal_all_blocks",
        rt_cranelift_seal_all_blocks as *const u8,
    );

    // Values
    builder.symbol("rt_cranelift_iconst", rt_cranelift_iconst as *const u8);
    builder.symbol("rt_cranelift_fconst", rt_cranelift_fconst as *const u8);
    builder.symbol("rt_cranelift_bconst", rt_cranelift_bconst as *const u8);
    builder.symbol("rt_cranelift_null", rt_cranelift_null as *const u8);

    // Arithmetic
    builder.symbol("rt_cranelift_iadd", rt_cranelift_iadd as *const u8);
    builder.symbol("rt_cranelift_isub", rt_cranelift_isub as *const u8);
    builder.symbol("rt_cranelift_imul", rt_cranelift_imul as *const u8);
    builder.symbol("rt_cranelift_sdiv", rt_cranelift_sdiv as *const u8);
    builder.symbol("rt_cranelift_udiv", rt_cranelift_udiv as *const u8);
    builder.symbol("rt_cranelift_srem", rt_cranelift_srem as *const u8);
    builder.symbol("rt_cranelift_urem", rt_cranelift_urem as *const u8);
    builder.symbol("rt_cranelift_fadd", rt_cranelift_fadd as *const u8);
    builder.symbol("rt_cranelift_fsub", rt_cranelift_fsub as *const u8);
    builder.symbol("rt_cranelift_fmul", rt_cranelift_fmul as *const u8);
    builder.symbol("rt_cranelift_fdiv", rt_cranelift_fdiv as *const u8);

    // Bitwise
    builder.symbol("rt_cranelift_band", rt_cranelift_band as *const u8);
    builder.symbol("rt_cranelift_bor", rt_cranelift_bor as *const u8);
    builder.symbol("rt_cranelift_bxor", rt_cranelift_bxor as *const u8);
    builder.symbol("rt_cranelift_bnot", rt_cranelift_bnot as *const u8);
    builder.symbol("rt_cranelift_ishl", rt_cranelift_ishl as *const u8);
    builder.symbol("rt_cranelift_sshr", rt_cranelift_sshr as *const u8);
    builder.symbol("rt_cranelift_ushr", rt_cranelift_ushr as *const u8);

    // Comparison
    builder.symbol("rt_cranelift_icmp", rt_cranelift_icmp as *const u8);
    builder.symbol("rt_cranelift_fcmp", rt_cranelift_fcmp as *const u8);

    // Memory
    builder.symbol("rt_cranelift_load", rt_cranelift_load as *const u8);
    builder.symbol("rt_cranelift_store", rt_cranelift_store as *const u8);
    builder.symbol("rt_cranelift_stack_slot", rt_cranelift_stack_slot as *const u8);
    builder.symbol("rt_cranelift_stack_addr", rt_cranelift_stack_addr as *const u8);

    // Control flow
    builder.symbol("rt_cranelift_jump", rt_cranelift_jump as *const u8);
    builder.symbol("rt_cranelift_brif", rt_cranelift_brif as *const u8);
    builder.symbol("rt_cranelift_return", rt_cranelift_return as *const u8);
    builder.symbol("rt_cranelift_return_void", rt_cranelift_return_void as *const u8);
    builder.symbol("rt_cranelift_trap", rt_cranelift_trap as *const u8);

    // Function calls
    builder.symbol("rt_cranelift_call", rt_cranelift_call as *const u8);
    builder.symbol("rt_cranelift_call_indirect", rt_cranelift_call_indirect as *const u8);

    // Type conversion
    builder.symbol("rt_cranelift_sextend", rt_cranelift_sextend as *const u8);
    builder.symbol("rt_cranelift_uextend", rt_cranelift_uextend as *const u8);
    builder.symbol("rt_cranelift_ireduce", rt_cranelift_ireduce as *const u8);
    builder.symbol("rt_cranelift_fcvt_to_sint", rt_cranelift_fcvt_to_sint as *const u8);
    builder.symbol("rt_cranelift_fcvt_to_uint", rt_cranelift_fcvt_to_uint as *const u8);
    builder.symbol("rt_cranelift_fcvt_from_sint", rt_cranelift_fcvt_from_sint as *const u8);
    builder.symbol("rt_cranelift_fcvt_from_uint", rt_cranelift_fcvt_from_uint as *const u8);
    builder.symbol("rt_cranelift_bitcast", rt_cranelift_bitcast as *const u8);

    // Block parameters
    builder.symbol(
        "rt_cranelift_append_block_param",
        rt_cranelift_append_block_param as *const u8,
    );
    builder.symbol("rt_cranelift_block_param", rt_cranelift_block_param as *const u8);

    // JIT execution
    builder.symbol(
        "rt_cranelift_get_function_ptr",
        rt_cranelift_get_function_ptr as *const u8,
    );
    builder.symbol(
        "rt_cranelift_call_function_ptr",
        rt_cranelift_call_function_ptr as *const u8,
    );

    // Object file generation / AOT compilation
    builder.symbol("rt_cranelift_new_aot_module", rt_cranelift_new_aot_module as *const u8);
    builder.symbol("rt_cranelift_emit_object", rt_cranelift_emit_object as *const u8);
    builder.symbol(
        "rt_cranelift_aot_define_function",
        rt_cranelift_aot_define_function as *const u8,
    );

    // Target detection
    builder.symbol("rt_get_host_target_code", rt_get_host_target_code as *const u8);
}

#[cfg(all(test, target_arch = "x86_64"))]
mod tests {
    use super::*;

    #[test]
    fn test_create_and_free_module() {
        unsafe {
            let name = "test_module";
            let handle = rt_cranelift_new_module(name.as_ptr() as i64, name.len() as i64, CL_TARGET_X86_64);
            assert!(handle > 0);
            rt_cranelift_free_module(handle);
        }
    }

    #[test]
    fn test_create_signature() {
        unsafe {
            let handle = rt_cranelift_new_signature(0);
            assert!(handle > 0);
            rt_cranelift_sig_add_param(handle, CL_TYPE_I64);
            rt_cranelift_sig_set_return(handle, CL_TYPE_I64);
        }
    }
}
