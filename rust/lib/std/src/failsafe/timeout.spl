# Fail-Safe Timeout Manager
# Prevents operations from hanging indefinitely
# Provides configurable timeouts with cancellation support

use core.*
use std.failsafe.core.*

# ============================================================================
# TIMEOUT CONFIGURATION
# ============================================================================

# Timeout configuration
pub class TimeoutConfig:
    pub default_timeout_ms: i64
    pub max_timeout_ms: i64
    pub warn_threshold_ms: i64      # Log warning if operation takes longer
    pub cancel_on_timeout: bool     # Auto-cancel on timeout
    pub retry_on_timeout: bool      # Auto-retry on timeout
    pub max_retries: i64

    static fn default() -> TimeoutConfig:
        return TimeoutConfig(
            default_timeout_ms: 30000,      # 30 seconds
            max_timeout_ms: 300000,         # 5 minutes
            warn_threshold_ms: 10000,       # 10 seconds
            cancel_on_timeout: true,
            retry_on_timeout: false,
            max_retries: 0
        )

    static fn strict() -> TimeoutConfig:
        return TimeoutConfig(
            default_timeout_ms: 5000,       # 5 seconds
            max_timeout_ms: 30000,          # 30 seconds
            warn_threshold_ms: 2000,        # 2 seconds
            cancel_on_timeout: true,
            retry_on_timeout: false,
            max_retries: 0
        )

    static fn permissive() -> TimeoutConfig:
        return TimeoutConfig(
            default_timeout_ms: 60000,      # 1 minute
            max_timeout_ms: 600000,         # 10 minutes
            warn_threshold_ms: 30000,       # 30 seconds
            cancel_on_timeout: false,
            retry_on_timeout: true,
            max_retries: 3
        )

# ============================================================================
# TIMEOUT TOKEN
# ============================================================================

# Token for tracking timeout state
pub class TimeoutToken:
    pub id: text
    pub deadline: i64               # Absolute time when timeout expires
    pub started_at: i64
    pub cancelled: bool
    pub completed: bool
    pub operation_name: text

    static fn new(id: text, timeout_ms: i64, operation_name: text) -> TimeoutToken:
        val now = current_time_ms()
        return TimeoutToken(
            id: id,
            deadline: now + timeout_ms,
            started_at: now,
            cancelled: false,
            completed: false,
            operation_name: operation_name
        )

    # Check if timeout has expired
    pub fn is_expired() -> bool:
        if self.cancelled or self.completed:
            return false
        return current_time_ms() >= self.deadline

    # Get remaining time in ms
    pub fn remaining_ms() -> i64:
        if self.cancelled or self.completed:
            return 0
        val remaining = self.deadline - current_time_ms()
        if remaining < 0:
            return 0
        return remaining

    # Get elapsed time in ms
    pub fn elapsed_ms() -> i64:
        return current_time_ms() - self.started_at

    # Cancel the timeout
    pub me cancel():
        self.cancelled = true

    # Mark as completed
    pub me complete():
        self.completed = true

    # Check if still active
    pub fn is_active() -> bool:
        return not self.cancelled and not self.completed and not self.is_expired()

# ============================================================================
# TIMEOUT MANAGER
# ============================================================================

# Manager for tracking multiple timeouts
pub class TimeoutManager:
    pub config: TimeoutConfig
    pub tokens: Dict<text, TimeoutToken>
    pub next_id: i64
    pub stats: TimeoutStats
    pub on_timeout: Option<fn(TimeoutToken)>
    pub on_warning: Option<fn(TimeoutToken)>

    static fn new(config: TimeoutConfig) -> TimeoutManager:
        return TimeoutManager(
            config: config,
            tokens: {},
            next_id: 0,
            stats: TimeoutStats.new(),
            on_timeout: nil,
            on_warning: nil
        )

    static fn default() -> TimeoutManager:
        return TimeoutManager.new(TimeoutConfig.default())

    # Start a new timeout
    pub me start_timeout(operation_name: text) -> TimeoutToken:
        return self.start_timeout_ms(operation_name, self.config.default_timeout_ms)

    # Start a timeout with custom duration
    pub me start_timeout_ms(operation_name: text, timeout_ms: i64) -> TimeoutToken:
        val clamped_timeout = min_i64(timeout_ms, self.config.max_timeout_ms)
        val id = "timeout_{self.next_id}"
        self.next_id = self.next_id + 1

        val token = TimeoutToken.new(id, clamped_timeout, operation_name)
        self.tokens.set(id, token)
        self.stats.started = self.stats.started + 1

        return token

    # Check a timeout token
    pub me check_timeout(token_id: text) -> FailSafeResult<()>:
        match self.tokens.get(token_id):
            case Some(token):
                if token.is_expired():
                    self.handle_timeout(token)
                    return FailSafeResult.Err(
                        FailSafeError.new(ErrorCategory.Timeout, "Operation timed out: {token.operation_name}")
                            .with_detail("timeout_id", token_id)
                            .with_detail("elapsed_ms", token.elapsed_ms().to_string())
                    )

                # Check warning threshold
                if token.elapsed_ms() >= self.config.warn_threshold_ms:
                    match self.on_warning:
                        case Some(callback):
                            callback(token)
                        case nil:
                            pass

                return FailSafeResult.Ok(())

            case nil:
                return FailSafeResult.Err(
                    FailSafeError.new(ErrorCategory.Internal, "Unknown timeout token: {token_id}")
                )

    # Complete a timeout (operation finished successfully)
    pub me complete_timeout(token_id: text):
        match self.tokens.get(token_id):
            case Some(token):
                token.complete()
                self.stats.completed = self.stats.completed + 1
                self.tokens.remove(token_id)
            case nil:
                pass

    # Cancel a timeout
    pub me cancel_timeout(token_id: text):
        match self.tokens.get(token_id):
            case Some(token):
                token.cancel()
                self.stats.cancelled = self.stats.cancelled + 1
                self.tokens.remove(token_id)
            case nil:
                pass

    # Handle timeout expiration
    fn handle_timeout(token: TimeoutToken):
        self.stats.timed_out = self.stats.timed_out + 1

        match self.on_timeout:
            case Some(callback):
                callback(token)
            case nil:
                pass

        if self.config.cancel_on_timeout:
            token.cancel()

    # Check all active timeouts
    pub me check_all_timeouts() -> List<TimeoutToken>:
        var expired: List<TimeoutToken> = []

        for id in self.tokens.keys():
            match self.tokens.get(id):
                case Some(token):
                    if token.is_expired():
                        self.handle_timeout(token)
                        expired.append(token)
                case nil:
                    pass

        # Remove expired tokens
        for token in expired:
            self.tokens.remove(token.id)

        return expired

    # Get active timeout count
    pub fn active_count() -> i64:
        var count: i64 = 0
        for id in self.tokens.keys():
            match self.tokens.get(id):
                case Some(token):
                    if token.is_active():
                        count = count + 1
                case nil:
                    pass
        return count

    # Set timeout callback
    pub fn with_timeout_callback(self, callback: fn(TimeoutToken)) -> TimeoutManager:
        return TimeoutManager(
            config: self.config,
            tokens: self.tokens,
            next_id: self.next_id,
            stats: self.stats,
            on_timeout: Some(callback),
            on_warning: self.on_warning
        )

    # Set warning callback
    pub fn with_warning_callback(self, callback: fn(TimeoutToken)) -> TimeoutManager:
        return TimeoutManager(
            config: self.config,
            tokens: self.tokens,
            next_id: self.next_id,
            stats: self.stats,
            on_timeout: self.on_timeout,
            on_warning: Some(callback)
        )

# Timeout statistics
pub class TimeoutStats:
    pub started: i64
    pub completed: i64
    pub timed_out: i64
    pub cancelled: i64

    static fn new() -> TimeoutStats:
        return TimeoutStats(
            started: 0,
            completed: 0,
            timed_out: 0,
            cancelled: 0
        )

    pub fn timeout_rate() -> f64:
        if self.started == 0:
            return 0.0
        return self.timed_out as f64 / self.started as f64

    pub fn completion_rate() -> f64:
        if self.started == 0:
            return 0.0
        return self.completed as f64 / self.started as f64

# ============================================================================
# TIMEOUT GUARD
# ============================================================================

# Guard for executing operations with timeout
pub class TimeoutGuard<T>:
    pub manager: TimeoutManager
    pub operation_name: text
    pub timeout_ms: i64

    static fn new(manager: TimeoutManager, name: text) -> TimeoutGuard<T>:
        return TimeoutGuard(
            manager: manager,
            operation_name: name,
            timeout_ms: manager.config.default_timeout_ms
        )

    pub fn with_timeout(self, timeout_ms: i64) -> TimeoutGuard<T>:
        return TimeoutGuard(
            manager: self.manager,
            operation_name: self.operation_name,
            timeout_ms: timeout_ms
        )

    # Execute with timeout
    pub fn execute(operation: fn() -> T) -> FailSafeResult<T>:
        val token = self.manager.start_timeout_ms(self.operation_name, self.timeout_ms)

        # Execute with periodic timeout checks
        val result = execute_with_timeout_ffi(
            operation,
            token.deadline
        )

        match result.timed_out:
            case true:
                self.manager.stats.timed_out = self.manager.stats.timed_out + 1
                return FailSafeResult.Err(
                    FailSafeError.new(ErrorCategory.Timeout, "Operation timed out: {self.operation_name}")
                        .with_detail("timeout_ms", self.timeout_ms.to_string())
                )
            case false:
                self.manager.complete_timeout(token.id)
                return FailSafeResult.Ok(result.value)

# Result from FFI timeout execution
pub class TimeoutExecuteResult<T>:
    pub value: T
    pub timed_out: bool

# ============================================================================
# DEADLINE
# ============================================================================

# Deadline for multi-operation sequences
pub class Deadline:
    pub deadline_time: i64
    pub created_at: i64
    pub operations_started: i64
    pub operations_completed: i64

    static fn new(timeout_ms: i64) -> Deadline:
        val now = current_time_ms()
        return Deadline(
            deadline_time: now + timeout_ms,
            created_at: now,
            operations_started: 0,
            operations_completed: 0
        )

    static fn from_timeout(timeout_ms: i64) -> Deadline:
        return Deadline.new(timeout_ms)

    # Check if deadline is exceeded
    pub fn is_exceeded() -> bool:
        return current_time_ms() >= self.deadline_time

    # Get remaining time
    pub fn remaining_ms() -> i64:
        val remaining = self.deadline_time - current_time_ms()
        if remaining < 0:
            return 0
        return remaining

    # Get elapsed time
    pub fn elapsed_ms() -> i64:
        return current_time_ms() - self.created_at

    # Check deadline and return error if exceeded
    pub fn check() -> FailSafeResult<()>:
        if self.is_exceeded():
            return FailSafeResult.Err(
                FailSafeError.new(ErrorCategory.Timeout, "Deadline exceeded")
                    .with_detail("elapsed_ms", self.elapsed_ms().to_string())
            )
        return FailSafeResult.Ok(())

    # Get timeout for sub-operation (remaining time)
    pub fn sub_timeout() -> i64:
        return self.remaining_ms()

    # Track operation start
    pub me start_operation():
        self.operations_started = self.operations_started + 1

    # Track operation completion
    pub me complete_operation():
        self.operations_completed = self.operations_completed + 1

# ============================================================================
# WRAPPER FUNCTIONS
# ============================================================================

# Execute operation with timeout
pub fn with_timeout<T>(
    timeout_ms: i64,
    operation_name: text,
    operation: fn() -> T
) -> FailSafeResult<T>:
    var manager = TimeoutManager.default()
    return TimeoutGuard.new(manager, operation_name)
        .with_timeout(timeout_ms)
        .execute(operation)

# Execute operation with deadline
pub fn with_deadline<T>(
    deadline: Deadline,
    operation_name: text,
    operation: fn() -> T
) -> FailSafeResult<T>:
    match deadline.check():
        case FailSafeResult.Err(e):
            return FailSafeResult.Err(e)
        case FailSafeResult.Ok(_):
            pass

    deadline.start_operation()
    val result = with_timeout(deadline.remaining_ms(), operation_name, operation)
    deadline.complete_operation()
    return result

# Execute with retry on timeout
pub fn with_timeout_retry<T>(
    timeout_ms: i64,
    max_retries: i64,
    operation_name: text,
    operation: fn() -> T
) -> FailSafeResult<T>:
    var last_error: Option<FailSafeError> = nil

    for attempt in 0..=max_retries:
        match with_timeout(timeout_ms, operation_name, operation):
            case FailSafeResult.Ok(v):
                return FailSafeResult.Ok(v)
            case FailSafeResult.Err(e):
                last_error = Some(e)
                # Only retry on timeout errors
                if e.category != ErrorCategory.Timeout:
                    return FailSafeResult.Err(e)

    match last_error:
        case Some(e):
            return FailSafeResult.Err(
                FailSafeError.new(ErrorCategory.Exhausted, "All retry attempts timed out for {operation_name}")
                    .with_cause(e)
            )
        case nil:
            return FailSafeResult.Err(
                FailSafeError.new(ErrorCategory.Internal, "Retry loop completed without result")
            )

# ============================================================================
# HELPER FUNCTIONS
# ============================================================================

fn current_time_ms() -> i64:
    return time_now_ms()

fn min_i64(a: i64, b: i64) -> i64:
    if a < b: a else: b

# FFI for timeout execution (implementation dependent on runtime)
extern fn execute_with_timeout_ffi<T>(operation: fn() -> T, deadline: i64) -> TimeoutExecuteResult<T>
extern fn time_now_ms() -> i64
