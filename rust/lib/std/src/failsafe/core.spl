# Fail-Safe Framework Core
# Production-grade crash prevention and recovery for protocol servers
# Designed for MCP, LSP, DAP and similar applications

use core.*

# ============================================================================
# ERROR TYPES
# ============================================================================

# Fail-safe error severity levels
pub enum ErrorSeverity:
    Debug       # Informational only
    Info        # Normal operation info
    Warning     # Potential issue
    Error       # Recoverable error
    Critical    # Requires attention
    Fatal       # Unrecoverable, shutdown required

    pub fn to_string() -> text:
        match self:
            case Debug: "debug"
            case Info: "info"
            case Warning: "warning"
            case Error: "error"
            case Critical: "critical"
            case Fatal: "fatal"

    pub fn to_i64() -> i64:
        match self:
            case Debug: 0
            case Info: 1
            case Warning: 2
            case Error: 3
            case Critical: 4
            case Fatal: 5

    pub fn is_severe() -> bool:
        return self.to_i64() >= ErrorSeverity.Critical.to_i64()

# Error category for classification
pub enum ErrorCategory:
    # Transport/IO errors
    Transport
    ConnectionLost
    ConnectionRefused
    Timeout

    # Protocol errors
    Protocol
    ParseError
    InvalidRequest
    InvalidResponse
    MethodNotFound
    InvalidParams

    # Validation errors
    Validation
    InputTooLarge
    InputTooDeep
    InvalidFormat

    # Resource errors
    Resource
    NotFound
    AccessDenied
    Exhausted

    # Execution errors
    Execution
    Panic
    Overflow
    DivisionByZero

    # System errors
    System
    OutOfMemory
    DiskFull
    PermissionDenied

    # Rate limiting
    RateLimit
    TooManyRequests

    # Internal
    Internal
    Unknown

    pub fn to_string() -> text:
        match self:
            case Transport: "transport"
            case ConnectionLost: "connection_lost"
            case ConnectionRefused: "connection_refused"
            case Timeout: "timeout"
            case Protocol: "protocol"
            case ParseError: "parse_error"
            case InvalidRequest: "invalid_request"
            case InvalidResponse: "invalid_response"
            case MethodNotFound: "method_not_found"
            case InvalidParams: "invalid_params"
            case Validation: "validation"
            case InputTooLarge: "input_too_large"
            case InputTooDeep: "input_too_deep"
            case InvalidFormat: "invalid_format"
            case Resource: "resource"
            case NotFound: "not_found"
            case AccessDenied: "access_denied"
            case Exhausted: "exhausted"
            case Execution: "execution"
            case Panic: "panic"
            case Overflow: "overflow"
            case DivisionByZero: "division_by_zero"
            case System: "system"
            case OutOfMemory: "out_of_memory"
            case DiskFull: "disk_full"
            case PermissionDenied: "permission_denied"
            case RateLimit: "rate_limit"
            case TooManyRequests: "too_many_requests"
            case Internal: "internal"
            case Unknown: "unknown"

    pub fn is_recoverable() -> bool:
        match self:
            case Timeout: true
            case RateLimit: true
            case TooManyRequests: true
            case ConnectionLost: true
            case Exhausted: true
            case _: false

    pub fn default_severity() -> ErrorSeverity:
        match self:
            case Panic: ErrorSeverity.Fatal
            case OutOfMemory: ErrorSeverity.Fatal
            case Overflow: ErrorSeverity.Critical
            case ConnectionLost: ErrorSeverity.Warning
            case Timeout: ErrorSeverity.Warning
            case RateLimit: ErrorSeverity.Warning
            case _: ErrorSeverity.Error

# Structured fail-safe error
pub class FailSafeError:
    pub id: text                    # Unique error ID
    pub category: ErrorCategory
    pub severity: ErrorSeverity
    pub message: text
    pub details: Dict<text, text>
    pub cause: Option<FailSafeError>
    pub timestamp: i64
    pub recoverable: bool
    pub retry_after_ms: Option<i64>

    static fn new(category: ErrorCategory, message: text) -> FailSafeError:
        return FailSafeError(
            id: generate_error_id(),
            category: category,
            severity: category.default_severity(),
            message: message,
            details: {},
            cause: nil,
            timestamp: current_time_ms(),
            recoverable: category.is_recoverable(),
            retry_after_ms: nil
        )

    pub fn with_severity(self, severity: ErrorSeverity) -> FailSafeError:
        return FailSafeError(
            id: self.id,
            category: self.category,
            severity: severity,
            message: self.message,
            details: self.details,
            cause: self.cause,
            timestamp: self.timestamp,
            recoverable: self.recoverable,
            retry_after_ms: self.retry_after_ms
        )

    pub fn with_detail(self, key: text, value: text) -> FailSafeError:
        var new_details = self.details.clone()
        new_details.set(key, value)
        return FailSafeError(
            id: self.id,
            category: self.category,
            severity: self.severity,
            message: self.message,
            details: new_details,
            cause: self.cause,
            timestamp: self.timestamp,
            recoverable: self.recoverable,
            retry_after_ms: self.retry_after_ms
        )

    pub fn with_cause(self, cause: FailSafeError) -> FailSafeError:
        return FailSafeError(
            id: self.id,
            category: self.category,
            severity: self.severity,
            message: self.message,
            details: self.details,
            cause: Some(cause),
            timestamp: self.timestamp,
            recoverable: self.recoverable,
            retry_after_ms: self.retry_after_ms
        )

    pub fn with_retry(self, retry_after_ms: i64) -> FailSafeError:
        return FailSafeError(
            id: self.id,
            category: self.category,
            severity: self.severity,
            message: self.message,
            details: self.details,
            cause: self.cause,
            timestamp: self.timestamp,
            recoverable: true,
            retry_after_ms: Some(retry_after_ms)
        )

    pub fn as_unrecoverable(self) -> FailSafeError:
        return FailSafeError(
            id: self.id,
            category: self.category,
            severity: self.severity,
            message: self.message,
            details: self.details,
            cause: self.cause,
            timestamp: self.timestamp,
            recoverable: false,
            retry_after_ms: nil
        )

    pub fn is_fatal() -> bool:
        return self.severity == ErrorSeverity.Fatal

    pub fn should_shutdown() -> bool:
        return self.is_fatal() and not self.recoverable

    pub fn to_string() -> text:
        return "[{self.severity.to_string()}] {self.category.to_string()}: {self.message}"

    pub fn to_dict() -> Dict<text, Any>:
        var result: Dict<text, Any> = {
            "id": self.id,
            "category": self.category.to_string(),
            "severity": self.severity.to_string(),
            "message": self.message,
            "timestamp": self.timestamp,
            "recoverable": self.recoverable
        }

        if self.details.len() > 0:
            result.set("details", self.details)

        match self.retry_after_ms:
            case Some(ms):
                result.set("retryAfterMs", ms)
            case nil:
                pass

        match self.cause:
            case Some(c):
                result.set("cause", c.to_dict())
            case nil:
                pass

        return result

# ============================================================================
# RESULT TYPE
# ============================================================================

# Fail-safe result type with rich error context
pub enum FailSafeResult<T>:
    Ok(T)
    Err(FailSafeError)

    pub fn is_ok() -> bool:
        match self:
            case Ok(_): true
            case Err(_): false

    pub fn is_err() -> bool:
        return not self.is_ok()

    pub fn unwrap() -> T:
        match self:
            case Ok(v): v
            case Err(e): panic("unwrap on Err: {e.to_string()}")

    pub fn unwrap_or(default: T) -> T:
        match self:
            case Ok(v): v
            case Err(_): default

    pub fn map<U>(f: fn(T) -> U) -> FailSafeResult<U>:
        match self:
            case Ok(v): FailSafeResult.Ok(f(v))
            case Err(e): FailSafeResult.Err(e)

    pub fn and_then<U>(f: fn(T) -> FailSafeResult<U>) -> FailSafeResult<U>:
        match self:
            case Ok(v): f(v)
            case Err(e): FailSafeResult.Err(e)

    pub fn map_err(f: fn(FailSafeError) -> FailSafeError) -> FailSafeResult<T>:
        match self:
            case Ok(v): FailSafeResult.Ok(v)
            case Err(e): FailSafeResult.Err(f(e))

# ============================================================================
# HEALTH STATUS
# ============================================================================

# Health status for services
pub enum HealthStatus:
    Healthy
    Degraded
    Unhealthy
    Unknown

    pub fn to_string() -> text:
        match self:
            case Healthy: "healthy"
            case Degraded: "degraded"
            case Unhealthy: "unhealthy"
            case Unknown: "unknown"

# Health check result
pub class HealthCheck:
    pub name: text
    pub status: HealthStatus
    pub message: Option<text>
    pub latency_ms: Option<i64>
    pub checked_at: i64

    static fn healthy(name: text) -> HealthCheck:
        return HealthCheck(
            name: name,
            status: HealthStatus.Healthy,
            message: nil,
            latency_ms: nil,
            checked_at: current_time_ms()
        )

    static fn unhealthy(name: text, message: text) -> HealthCheck:
        return HealthCheck(
            name: name,
            status: HealthStatus.Unhealthy,
            message: Some(message),
            latency_ms: nil,
            checked_at: current_time_ms()
        )

    pub fn with_latency(self, latency_ms: i64) -> HealthCheck:
        return HealthCheck(
            name: self.name,
            status: self.status,
            message: self.message,
            latency_ms: Some(latency_ms),
            checked_at: self.checked_at
        )

# ============================================================================
# METRICS
# ============================================================================

# Counter metric
pub class Counter:
    pub name: text
    pub value: i64
    pub labels: Dict<text, text>

    static fn new(name: text) -> Counter:
        return Counter(name: name, value: 0, labels: {})

    pub me increment():
        self.value = self.value + 1

    pub me increment_by(n: i64):
        self.value = self.value + n

    pub me reset():
        self.value = 0

# Gauge metric
pub class Gauge:
    pub name: text
    pub value: f64
    pub labels: Dict<text, text>

    static fn new(name: text) -> Gauge:
        return Gauge(name: name, value: 0.0, labels: {})

    pub me set(value: f64):
        self.value = value

    pub me increment():
        self.value = self.value + 1.0

    pub me decrement():
        self.value = self.value - 1.0

# Histogram metric for latency tracking
pub class Histogram:
    pub name: text
    pub buckets: List<f64>
    pub counts: List<i64>
    pub sum: f64
    pub count: i64

    static fn new(name: text, buckets: List<f64>) -> Histogram:
        var counts: List<i64> = []
        for _ in 0..buckets.len():
            counts.append(0)
        return Histogram(
            name: name,
            buckets: buckets,
            counts: counts,
            sum: 0.0,
            count: 0
        )

    static fn default_latency(name: text) -> Histogram:
        # Default buckets for latency in ms
        return Histogram.new(name, [1.0, 5.0, 10.0, 25.0, 50.0, 100.0, 250.0, 500.0, 1000.0, 5000.0])

    pub me observe(value: f64):
        self.sum = self.sum + value
        self.count = self.count + 1

        # Increment bucket counts
        for i in 0..self.buckets.len():
            if value <= self.buckets[i]:
                self.counts[i] = self.counts[i] + 1

    pub fn mean() -> f64:
        if self.count == 0:
            return 0.0
        return self.sum / self.count as f64

# Metrics registry
pub class MetricsRegistry:
    pub counters: Dict<text, Counter>
    pub gauges: Dict<text, Gauge>
    pub histograms: Dict<text, Histogram>

    static fn new() -> MetricsRegistry:
        return MetricsRegistry(
            counters: {},
            gauges: {},
            histograms: {}
        )

    pub me counter(name: text) -> Counter:
        match self.counters.get(name):
            case Some(c):
                return c
            case nil:
                val c = Counter.new(name)
                self.counters.set(name, c)
                return c

    pub me gauge(name: text) -> Gauge:
        match self.gauges.get(name):
            case Some(g):
                return g
            case nil:
                val g = Gauge.new(name)
                self.gauges.set(name, g)
                return g

    pub me histogram(name: text) -> Histogram:
        match self.histograms.get(name):
            case Some(h):
                return h
            case nil:
                val h = Histogram.default_latency(name)
                self.histograms.set(name, h)
                return h

# ============================================================================
# LOGGING
# ============================================================================

# Log level
pub enum LogLevel:
    Trace
    Debug
    Info
    Warn
    Error
    Fatal

    pub fn to_string() -> text:
        match self:
            case Trace: "TRACE"
            case Debug: "DEBUG"
            case Info: "INFO"
            case Warn: "WARN"
            case Error: "ERROR"
            case Fatal: "FATAL"

    pub fn to_i64() -> i64:
        match self:
            case Trace: 0
            case Debug: 1
            case Info: 2
            case Warn: 3
            case Error: 4
            case Fatal: 5

# Log entry
pub class LogEntry:
    pub level: LogLevel
    pub message: text
    pub context: Dict<text, text>
    pub timestamp: i64
    pub source: Option<text>
    pub error_id: Option<text>

    static fn new(level: LogLevel, message: text) -> LogEntry:
        return LogEntry(
            level: level,
            message: message,
            context: {},
            timestamp: current_time_ms(),
            source: nil,
            error_id: nil
        )

    pub fn with_context(self, key: text, value: text) -> LogEntry:
        var ctx = self.context.clone()
        ctx.set(key, value)
        return LogEntry(
            level: self.level,
            message: self.message,
            context: ctx,
            timestamp: self.timestamp,
            source: self.source,
            error_id: self.error_id
        )

    pub fn with_source(self, source: text) -> LogEntry:
        return LogEntry(
            level: self.level,
            message: self.message,
            context: self.context,
            timestamp: self.timestamp,
            source: Some(source),
            error_id: self.error_id
        )

    pub fn with_error(self, error: FailSafeError) -> LogEntry:
        return LogEntry(
            level: self.level,
            message: self.message,
            context: self.context,
            timestamp: self.timestamp,
            source: self.source,
            error_id: Some(error.id)
        )

    pub fn format() -> text:
        var parts: List<text> = []
        parts.append("[{self.level.to_string()}]")
        parts.append(format_timestamp(self.timestamp))

        match self.source:
            case Some(s):
                parts.append("[{s}]")
            case nil:
                pass

        parts.append(self.message)

        for key in self.context.keys():
            match self.context.get(key):
                case Some(value):
                    parts.append("{key}={value}")
                case nil:
                    pass

        match self.error_id:
            case Some(id):
                parts.append("error_id={id}")
            case nil:
                pass

        return parts.join(" ")

# Logger interface
pub trait Logger:
    fn log(entry: LogEntry)
    fn flush()

# Console logger (writes to stderr to not interfere with protocol)
pub class ConsoleLogger:
    pub min_level: LogLevel
    pub source: text

    static fn new(source: text) -> ConsoleLogger:
        return ConsoleLogger(
            min_level: LogLevel.Info,
            source: source
        )

    pub fn with_level(self, level: LogLevel) -> ConsoleLogger:
        return ConsoleLogger(
            min_level: level,
            source: self.source
        )

impl Logger for ConsoleLogger:
    fn log(entry: LogEntry):
        if entry.level.to_i64() < self.min_level.to_i64():
            return

        val formatted = entry.with_source(self.source).format()
        stderr_write(formatted + "\n")
        stderr_flush()

    fn flush():
        stderr_flush()

# ============================================================================
# HELPER FUNCTIONS
# ============================================================================

fn generate_error_id() -> text:
    val timestamp = current_time_ms()
    val random = random_i64() % 10000
    return "err_{timestamp}_{random}"

fn format_timestamp(ms: i64) -> text:
    # Simple ISO-like format (would use proper formatting in production)
    return "{ms}"

fn current_time_ms() -> i64:
    return time_now_ms()

# External functions
extern fn time_now_ms() -> i64
extern fn random_i64() -> i64
extern fn stderr_write(s: text)
extern fn stderr_flush()
extern fn panic(msg: text) -> !
