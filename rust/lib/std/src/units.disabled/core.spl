# Core Unit Types
# Generic semantic types for counts, indices, hashes, and error codes

# =============================================================================
# Count and Size Units
# =============================================================================

# Generic count (signed, can represent differences)
unit Count: i64 as count

# Generic index into collections (signed, -1 for invalid)
unit Index: i64 as idx

# Capacity of a collection (unsigned, always non-negative)
unit Capacity: u64 as cap

# Length of a collection or string (unsigned, always non-negative)
unit Length: u64 as len

# Count implementation
impl Count:
    pub fn from_i64(n: i64) -> Count:
        return n_count

    pub fn value() -> i64:
        return self as i64

    pub fn zero() -> Count:
        return 0_count

    pub fn increment() -> Count:
        return (self.value() + 1)_count

    pub fn decrement() -> Count:
        return (self.value() - 1)_count

    pub fn add(other: Count) -> Count:
        return (self.value() + other.value())_count

    pub fn sub(other: Count) -> Count:
        return (self.value() - other.value())_count

    pub fn is_positive() -> bool:
        return self.value() > 0

    pub fn is_negative() -> bool:
        return self.value() < 0

    pub fn is_zero() -> bool:
        return self.value() == 0

# Index implementation
impl Index:
    pub fn from_i64(n: i64) -> Index:
        return n_idx

    pub fn value() -> i64:
        return self as i64

    pub fn zero() -> Index:
        """First index."""
        return 0_idx

    pub fn invalid() -> Index:
        """Invalid index (-1)."""
        return (-1)_idx

    pub fn is_valid() -> bool:
        """Check if index is valid (>= 0)."""
        return self.value() >= 0

    pub fn next() -> Index:
        """Get next index."""
        return (self.value() + 1)_idx

    pub fn prev() -> Index:
        """Get previous index, clamped to 0."""
        val current = self.value()
        if current <= 0:
            return 0_idx
        return (current - 1)_idx

# Capacity implementation
impl Capacity:
    pub fn from_u64(n: u64) -> Capacity:
        return n_cap

    pub fn value() -> u64:
        return self as u64

    pub fn zero() -> Capacity:
        return 0_cap

    pub fn is_empty() -> bool:
        return self.value() == 0

    pub fn add(other: Capacity) -> Capacity:
        return (self.value() + other.value())_cap

    pub fn double() -> Capacity:
        """Double the capacity (common growth strategy)."""
        return (self.value() * 2)_cap

    pub fn grow_by_factor(factor: f32) -> Capacity:
        """Grow capacity by a multiplicative factor."""
        val new_cap = (self.value() as f32) * factor
        return (new_cap as u64)_cap

# Length implementation
impl Length:
    pub fn from_u64(n: u64) -> Length:
        return n_len

    pub fn value() -> u64:
        return self as u64

    pub fn zero() -> Length:
        return 0_len

    pub fn is_empty() -> bool:
        return self.value() == 0

    pub fn add(other: Length) -> Length:
        return (self.value() + other.value())_len

    pub fn increment() -> Length:
        return (self.value() + 1)_len

    pub fn decrement() -> Length:
        """Decrement length, clamped to 0."""
        val current = self.value()
        if current == 0:
            return 0_len
        return (current - 1)_len

    pub fn fits_in(capacity: Capacity) -> bool:
        """Check if this length fits within given capacity."""
        return self.value() <= capacity.value()

# =============================================================================
# Hash and Checksum Units
# =============================================================================

# Hash value (64-bit)
unit Hash: u64 as hash

# Checksum value (32-bit, for smaller checksums like CRC32)
unit Checksum: u32 as checksum

# Hash implementation
impl Hash:
    pub fn from_u64(n: u64) -> Hash:
        return n_hash

    pub fn value() -> u64:
        return self as u64

    pub fn zero() -> Hash:
        """Zero hash (often used as sentinel)."""
        return 0_hash

    pub fn is_zero() -> bool:
        return self.value() == 0

    pub fn combine(other: Hash) -> Hash:
        """
        Combine two hash values using XOR rotation.
        Common pattern for combining hashes.
        """
        val h1 = self.value()
        val h2 = other.value()
        # Rotate h1 left by 7 bits and XOR with h2
        val rotated = (h1 << 7) | (h1 >> 57)
        return (rotated xor h2)_hash

# Checksum implementation
impl Checksum:
    pub fn from_u32(n: u32) -> Checksum:
        return n_checksum

    pub fn value() -> u32:
        return self as u32

    pub fn zero() -> Checksum:
        return 0_checksum

    pub fn is_zero() -> bool:
        return self.value() == 0

# =============================================================================
# Error Code Unit
# =============================================================================

# Error code (signed integer, convention: negative = error, 0 = success, positive = info)
unit ErrorCode: i32 as errcode

# ErrorCode implementation
impl ErrorCode:
    pub fn from_i32(n: i32) -> ErrorCode:
        return n_errcode

    pub fn value() -> i32:
        return self as i32

    pub fn success() -> ErrorCode:
        """Success code (0)."""
        return 0_errcode

    pub fn is_success() -> bool:
        """Check if code represents success (0)."""
        return self.value() == 0

    pub fn is_error() -> bool:
        """Check if code represents an error (negative)."""
        return self.value() < 0

    pub fn is_warning() -> bool:
        """Check if code represents a warning/info (positive, non-zero)."""
        return self.value() > 0
