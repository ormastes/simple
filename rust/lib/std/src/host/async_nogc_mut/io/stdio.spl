# Standard I/O - Basic stdin/stdout operations
# Provides simple functions for reading from stdin and writing to stdout

use units.size.ByteCount

# Extern declarations for stdin/stdout FFI
extern fn rt_read_stdin_line() -> Option<text>

# Read a line from stdin (including newline)
pub fn read_line() -> Result<text, text>:
    match rt_read_stdin_line():
        case Some(line):
            Ok(line)
        case None:
            Err("Failed to read from stdin")

# Read exactly n bytes from stdin
pub fn read_exact(count: ByteCount) -> Result<text, text>:
    """Read exact number of bytes from stdin.

    Args:
        count: Number of bytes to read

    Returns:
        Ok(text) on success, Err on failure
    """
    # Read characters one by one until we have n bytes
    val n = count.value() as i32
    var result = ""
    for _ in 0..n:
        match rt_read_stdin_line():
            case Some(line):
                result = result + line
                if result.len() >= n:
                    return Ok(result.substring(0, n))
            case None:
                if result.len() > 0:
                    return Ok(result)
                else:
                    return Err("Failed to read from stdin")
    Ok(result)

# Write string to stdout
pub fn write(s: text) -> Result<ByteCount, text>:
    """Write string to stdout.

    Returns:
        Ok(bytes_written) on success
    """
    print(s)
    val len_val = (s.len() as u64)
    Ok(len_val_bytes)

# Flush stdout buffer
pub fn flush() -> Result<(), text>:
    # Stdout is auto-flushed by print in most cases
    # No explicit FFI needed for now
    Ok(())
