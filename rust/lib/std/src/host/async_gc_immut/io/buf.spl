# Buffered I/O - Immutable Variant
# All buffer operations return new buffer instances

use units.size.*

# Immutable buffer - operations return new buffers
struct Buffer:
    data: Bytes
    capacity: ByteCount

impl Buffer:
    # Create empty buffer with capacity
    fn with_capacity(cap: ByteCount) -> Buffer:
        Buffer { data: Bytes.empty(), capacity: cap }

    # Create from bytes
    fn from_bytes(bytes: Bytes) -> Buffer:
        Buffer { data: bytes, capacity: (bytes.len() as ByteCount) }

    fn len() -> ByteCount:
        self.data.len() as ByteCount

    fn capacity() -> ByteCount:
        self.capacity

    fn is_empty() -> bool:
        self.data.is_empty()

    fn remaining() -> ByteCount:
        self.capacity - self.len()

    # Append data, return new buffer
    fn append(data: Bytes) -> Option<Buffer>:
        val new_len = self.len() + (data.len() as ByteCount)
        if new_len > self.capacity:
            return None
        Some(Buffer { data: self.data.append(data), capacity: self.capacity })

    # Clear buffer, return empty buffer with same capacity
    fn cleared() -> Buffer:
        Buffer { data: Bytes.empty(), capacity: self.capacity }

    # Take first n bytes, return (taken, remaining)
    fn take(n: ByteCount) -> (Bytes, Buffer):
        val take_count = min(n, self.len())
        val taken = self.data.slice(0, take_count as u64)
        val remaining = self.data.slice(take_count as u64, self.data.len())
        (taken, Buffer { data: remaining, capacity: self.capacity })

    # Get data as byte slice (cheap borrow)
    fn as_bytes() -> &[u8]:
        &self.data

    # Get a copy of data as Bytes (allocates)
    fn to_bytes() -> Bytes:
        self.data.clone()

    # Consume buffer and return data
    fn into_bytes() -> Bytes:
        self.data

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn get_capacity() -> ByteCount:
        """Get buffer capacity (alias for capacity).

        Returns:
            Capacity in bytes

        Example:
            buffer.get_capacity()  # → 8192_bytes
        """
        return self.capacity()

    fn get_len() -> ByteCount:
        """Get current buffer length (alias for len).

        Returns:
            Length in bytes

        Example:
            buffer.get_len()  # → 1024_bytes
        """
        return self.len()

    fn is_full() -> bool:
        """Check if buffer is at capacity.

        Returns:
            true if full

        Example:
            buffer.is_full()  # → false
        """
        return self.len() >= self.capacity

    fn has_space() -> bool:
        """Check if buffer has remaining capacity.

        Returns:
            true if space available

        Example:
            buffer.has_space()  # → true
        """
        return self.len() < self.capacity

    fn summary() -> text:
        """Get buffer summary.

        Returns:
            Human-readable summary

        Example:
            buffer.summary()
            # → "Buffer: 1024/8192 bytes"
        """
        val len = self.len()
        val cap = self.capacity
        return "Buffer: {len}/{cap} bytes"

# Immutable read buffer with fill tracking
struct ReadBuffer:
    inner: Buffer
    read_pos: ByteCount

impl ReadBuffer:
    fn new(capacity: ByteCount) -> ReadBuffer:
        ReadBuffer { inner: Buffer.with_capacity(capacity), read_pos: 0_bytes }

    fn from_bytes(bytes: Bytes) -> ReadBuffer:
        ReadBuffer { inner: Buffer.from_bytes(bytes), read_pos: 0_bytes }

    fn available() -> ByteCount:
        self.inner.len() - self.read_pos

    fn is_empty() -> bool:
        self.available() == 0_bytes

    # Read n bytes, return (bytes, new_buffer)
    fn read(n: ByteCount) -> (Bytes, ReadBuffer):
        val take_count = min(n, self.available())
        val data = self.inner.data.slice(
            self.read_pos as u64,
            (self.read_pos + take_count) as u64
        )
        (data, ReadBuffer { inner: self.inner, read_pos: self.read_pos + take_count })

    # Fill buffer with more data, return new buffer
    fn fill(data: Bytes) -> Option<ReadBuffer>:
        # Compact: move unread data to front
        val unread = self.inner.data.slice(self.read_pos as u64, self.inner.data.len())
        val compacted = Buffer { data: unread.append(data), capacity: self.inner.capacity }
        if compacted.len() > self.inner.capacity:
            return None
        Some(ReadBuffer { inner: compacted, read_pos: 0_bytes })

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn get_capacity() -> ByteCount:
        """Get buffer capacity.

        Returns:
            Capacity in bytes

        Example:
            buffer.get_capacity()  # → 8192_bytes
        """
        return self.inner.capacity()

    fn get_available() -> ByteCount:
        """Get available bytes (alias for available).

        Returns:
            Available bytes to read

        Example:
            buffer.get_available()  # → 512_bytes
        """
        return self.available()

    fn get_position() -> ByteCount:
        """Get current read position.

        Returns:
            Read position in buffer

        Example:
            buffer.get_position()  # → 1024_bytes
        """
        return self.read_pos

    fn has_data() -> bool:
        """Check if buffer has data available.

        Returns:
            true if data available

        Example:
            buffer.has_data()  # → true
        """
        return not self.is_empty()

    fn summary() -> text:
        """Get read buffer summary.

        Returns:
            Human-readable summary

        Example:
            buffer.summary()
            # → "ReadBuffer: 512 bytes available, position=1024"
        """
        val avail = self.available()
        val pos = self.read_pos
        return "ReadBuffer: {avail} bytes available, position={pos}"

# Immutable write buffer
struct WriteBuffer:
    inner: Buffer
    flushed: ByteCount

impl WriteBuffer:
    fn new(capacity: ByteCount) -> WriteBuffer:
        WriteBuffer { inner: Buffer.with_capacity(capacity), flushed: 0_bytes }

    fn buffered() -> ByteCount:
        self.inner.len()

    fn total_written() -> ByteCount:
        self.flushed + self.buffered()

    fn remaining() -> ByteCount:
        self.inner.remaining()

    # Write data to buffer, return new buffer or None if full
    fn write(data: Bytes) -> Option<WriteBuffer>:
        match self.inner.append(data):
            case Some(new_inner):
                Some(WriteBuffer { inner: new_inner, flushed: self.flushed })
            case None:
                None

    # Get buffered data and return flushed buffer
    fn flush() -> (Bytes, WriteBuffer):
        val data = self.inner.data
        val new_flushed = self.flushed + self.inner.len()
        (data, WriteBuffer {
            inner: self.inner.cleared(),
            flushed: new_flushed
        })

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn get_capacity() -> ByteCount:
        """Get buffer capacity.

        Returns:
            Capacity in bytes

        Example:
            buffer.get_capacity()  # → 8192_bytes
        """
        return self.inner.capacity()

    fn get_buffered() -> ByteCount:
        """Get buffered bytes (alias for buffered).

        Returns:
            Bytes in buffer

        Example:
            buffer.get_buffered()  # → 512_bytes
        """
        return self.buffered()

    fn get_flushed() -> ByteCount:
        """Get total flushed bytes.

        Returns:
            Flushed byte count

        Example:
            buffer.get_flushed()  # → 4096_bytes
        """
        return self.flushed

    fn is_buffer_empty() -> bool:
        """Check if buffer is empty.

        Returns:
            true if no buffered data

        Example:
            buffer.is_buffer_empty()  # → false
        """
        return self.buffered() == 0_bytes

    fn has_buffered_data() -> bool:
        """Check if buffer has data.

        Returns:
            true if data buffered

        Example:
            buffer.has_buffered_data()  # → true
        """
        return self.buffered() > 0_bytes

    fn summary() -> text:
        """Get write buffer summary.

        Returns:
            Human-readable summary

        Example:
            buffer.summary()
            # → "WriteBuffer: 512 bytes buffered, 4096 bytes flushed"
        """
        val buffered = self.buffered()
        val flushed = self.flushed
        return "WriteBuffer: {buffered} bytes buffered, {flushed} bytes flushed"

# Helper
fn min(a: ByteCount, b: ByteCount) -> ByteCount:
    if a < b: a else: b
