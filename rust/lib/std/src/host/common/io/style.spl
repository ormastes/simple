# ANSI escape sequence prefix
val ESC = chr(27)

pub struct Style:
    fg: Option<Color>
    bg: Option<Color>
    bold: bool
    dim: bool
    italic: bool
    underline: bool
    blink: bool
    reverse: bool
    hidden: bool
    strikethrough: bool

impl Style:
    # Create default style (no formatting)
    pub fn new() -> Style:
        return Style(
            fg: None,
            bg: None,
            bold: false,
            dim: false,
            italic: false,
            underline: false,
            blink: false,
            reverse: false,
            hidden: false,
            strikethrough: false
        )

    # Set foreground color
    pub fn fg(self, color: Color) -> Style:
        self.fg = Some(color)
        return self

    # Set background color
    pub fn bg(self, color: Color) -> Style:
        self.bg = Some(color)
        return self

    # Enable bold
    pub fn bold(self) -> Style:
        self.bold = true
        return self

    # Enable dim
    pub fn dim(self) -> Style:
        self.dim = true
        return self

    # Enable italic
    pub fn italic(self) -> Style:
        self.italic = true
        return self

    # Enable underline
    pub fn underline(self) -> Style:
        self.underline = true
        return self

    # Enable blink
    pub fn blink(self) -> Style:
        self.blink = true
        return self

    # Enable reverse video
    pub fn reverse(self) -> Style:
        self.reverse = true
        return self

    # Enable hidden
    pub fn hidden(self) -> Style:
        self.hidden = true
        return self

    # Enable strikethrough
    pub fn strikethrough(self) -> Style:
        self.strikethrough = true
        return self

    # Generate ANSI escape sequence
    pub fn to_ansi(self) -> text:
        var codes: Array<text> = []

        if self.bold:
            codes.push("1")
        if self.dim:
            codes.push("2")
        if self.italic:
            codes.push("3")
        if self.underline:
            codes.push("4")
        if self.blink:
            codes.push("5")
        if self.reverse:
            codes.push("7")
        if self.hidden:
            codes.push("8")
        if self.strikethrough:
            codes.push("9")

        match self.fg:
            case Some(color):
                match color:
                    case Rgb(r, g, b):
                        codes.push("38;2;{r};{g};{b}")
                    case Ansi256(n):
                        codes.push("38;5;{n}")
                    case _:
                        codes.push("{color.fg_code()}")
            case None: pass

        match self.bg:
            case Some(color):
                match color:
                    case Rgb(r, g, b):
                        codes.push("48;2;{r};{g};{b}")
                    case Ansi256(n):
                        codes.push("48;5;{n}")
                    case _:
                        codes.push("{color.bg_code()}")
            case None: pass

        if codes.is_empty():
            return ""

        return ESC + "[{codes.join(';')}m"

    # Apply style to text and return styled string
    pub fn apply(self, text: &str) -> text:
        val prefix = self.to_ansi()
        if prefix.is_empty():
            return text.to_string()
        return "{prefix}{text}" + ESC + "[0m"

    pub fn has_fg(self) -> bool:
        """Check if foreground color is set.

        Returns:
            True if fg color is configured
        """
        match self.fg:
            case Some(_): return true
            case None: return false

    pub fn has_bg(self) -> bool:
        """Check if background color is set.

        Returns:
            True if bg color is configured
        """
        match self.bg:
            case Some(_): return true
            case None: return false

    pub fn has_any_style(self) -> bool:
        """Check if any styling is configured.

        Returns:
            True if any attribute is set
        """
        return self.has_fg() or self.has_bg() or self.bold or self.dim or self.italic or self.underline or self.blink or self.reverse or self.hidden or self.strikethrough

    pub fn is_plain(self) -> bool:
        """Check if this is plain (no styling).

        Returns:
            True if no attributes are set
        """
        return not self.has_any_style()

    pub fn count_attributes(self) -> u8:
        """Count number of active style attributes.

        Returns:
            Number of enabled attributes
        """
        var count: u8 = 0
        if self.has_fg():
            count = count + 1
        if self.has_bg():
            count = count + 1
        if self.bold:
            count = count + 1
        if self.dim:
            count = count + 1
        if self.italic:
            count = count + 1
        if self.underline:
            count = count + 1
        if self.blink:
            count = count + 1
        if self.reverse:
            count = count + 1
        if self.hidden:
            count = count + 1
        if self.strikethrough:
            count = count + 1
        return count

    pub fn summary(self) -> text:
        """Get style summary.

        Returns:
            Human-readable summary

        Example:
            style.summary()  # â†’ "Style: red fg, bold, underline (3 attrs)"
        """
        if self.is_plain():
            return "Style: plain (0 attrs)"

        var attrs: Array<text> = []
        match self.fg:
            case Some(color):
                attrs.push("{color.to_string()} fg")
            case None: pass

        match self.bg:
            case Some(color):
                attrs.push("{color.to_string()} bg")
            case None: pass

        if self.bold:
            attrs.push("bold")
        if self.dim:
            attrs.push("dim")
        if self.italic:
            attrs.push("italic")
        if self.underline:
            attrs.push("underline")
        if self.blink:
            attrs.push("blink")
        if self.reverse:
            attrs.push("reverse")
        if self.hidden:
            attrs.push("hidden")
        if self.strikethrough:
            attrs.push("strikethrough")

        val count = self.count_attributes()
        return "Style: {attrs.join(', ')} ({count} attrs)"

# Reset all formatting
pub fn reset() -> text:
    return ESC + "[0m"

# Convenience functions for common styles
pub fn red(text: &str) -> text:
    return Style.new().fg(Color.Red).apply(text)

pub fn green(text: &str) -> text:
    return Style.new().fg(Color.Green).apply(text)

pub fn yellow(text: &str) -> text:
    return Style.new().fg(Color.Yellow).apply(text)

pub fn blue(text: &str) -> text:
    return Style.new().fg(Color.Blue).apply(text)

pub fn magenta(text: &str) -> text:
    return Style.new().fg(Color.Magenta).apply(text)

pub fn cyan(text: &str) -> text:
    return Style.new().fg(Color.Cyan).apply(text)

pub fn white(text: &str) -> text:
    return Style.new().fg(Color.White).apply(text)

pub fn bold(text: &str) -> text:
    return Style.new().bold().apply(text)

pub fn dim(text: &str) -> text:
    return Style.new().dim().apply(text)

pub fn italic(text: &str) -> text:
    return Style.new().italic().apply(text)

pub fn underline(text: &str) -> text:
    return Style.new().underline().apply(text)

pub fn strikethrough(text: &str) -> text:
    return Style.new().strikethrough().apply(text)

# Error styling (red + bold)
pub fn error(text: &str) -> text:
    return Style.new().fg(Color.Red).bold().apply(text)

# Warning styling (yellow + bold)
pub fn warning(text: &str) -> text:
    return Style.new().fg(Color.Yellow).bold().apply(text)

# Success styling (green + bold)
pub fn success(text: &str) -> text:
    return Style.new().fg(Color.Green).bold().apply(text)

# Info styling (cyan)
pub fn info(text: &str) -> text:
    return Style.new().fg(Color.Cyan).apply(text)

# Styled string builder for complex formatting
