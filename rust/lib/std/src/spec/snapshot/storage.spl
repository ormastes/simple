# Snapshot Testing - Storage
# Feature #900: Snapshot file I/O and directory management

module std.spec.snapshot.storage:
    use core.result.{Result, Ok, Err}
    use core.option.{Option, Some, None}
    use std.io.{File, Path, read_file, write_file, exists, create_dir_all}
    use std.time

    # Snapshot file structure
    pub struct SnapshotFile:
        # Test file path (e.g., "test/user_service_spec.spl")
        test_file: text

        # Test function name (e.g., "test_render_user_json")
        test_name: text

        # Snapshot content
        content: text

        # Format (text, json, yaml, etc.)
        format: text

        # Creation timestamp
        created_at: text

        # Last updated timestamp
        updated_at: text

    impl SnapshotFile:
        # Create new snapshot
        pub fn new(
            test_file: text,
            test_name: text,
            content: text,
            format: text
        ) -> SnapshotFile:
            val now = time.now_iso8601()
            return SnapshotFile(
                test_file: test_file,
                test_name: test_name,
                content: content,
                format: format,
                created_at: now,
                updated_at: now
            )

        # Get snapshot file path
        pub fn get_path(self, snapshot_dir: text) -> text:
            # Extract base name from test file (remove path and extension)
            val base_name = self.test_file
                .split("/").last()
                .unwrap_or(self.test_file)
                .replace(".spl", "")

            # Build path: .snapshots/<test_file_name>/<test_name>.snap
            return "{snapshot_dir}/{base_name}/{self.test_name}.snap"

        # Serialize to snapshot file format
        pub fn to_file_format(self) -> text:
            var result = ""

            # Add metadata header
            result += "# Snapshot: {self.test_name}\n"
            result += "# Created: {self.created_at}\n"
            result += "# Updated: {self.updated_at}\n"
            result += "# Format: {self.format}\n"
            result += "\n"

            # Add content
            result += self.content

            return result

        # Parse from snapshot file format
        pub fn from_file_format(
            content: text,
            test_file: text,
            test_name: text
        ) -> Result<SnapshotFile, text>:
            val lines = content.split("\n")
            var snapshot_content = ""
            var format = "text"
            var created_at = ""
            var updated_at = ""
            var in_content = false

            for line in lines:
                if line.starts_with("# Snapshot:"):
                    continue
                elif line.starts_with("# Created:"):
                    created_at = line.replace("# Created: ", "").trim()
                elif line.starts_with("# Updated:"):
                    updated_at = line.replace("# Updated: ", "").trim()
                elif line.starts_with("# Format:"):
                    format = line.replace("# Format: ", "").trim()
                elif line.trim().is_empty() and !in_content:
                    in_content = true
                elif in_content:
                    snapshot_content += line + "\n"

            # Remove trailing newline
            if snapshot_content.ends_with("\n"):
                snapshot_content = snapshot_content[0..snapshot_content.length()-1]

            return Ok(SnapshotFile(
                test_file: test_file,
                test_name: test_name,
                content: snapshot_content,
                format: format,
                created_at: created_at,
                updated_at: updated_at
            ))

    # Load snapshot from file
    pub fn load_snapshot(
        test_file: text,
        test_name: text,
        snapshot_dir: text
    ) -> Result<SnapshotFile, text>:
        val snapshot = SnapshotFile.new(test_file, test_name, "", "text")
        val path = snapshot.get_path(snapshot_dir)

        if !exist(path):
            return Err("Snapshot not found: {path}")

        val content = read_file(path)?
        return SnapshotFile.from_file_format(content, test_file, test_name)

    # Save snapshot to file
    pub fn save_snapshot(
        snapshot: SnapshotFile,
        snapshot_dir: text
    ) -> Result<(), text>:
        val path = snapshot.get_path(snapshot_dir)

        # Create directory if needed
        val dir_path = path.rsplit_once("/").map(|(d, _)| d).unwrap_or(".")
        create_dir_all(dir_path)?

        # Write file
        val content = snapshot.to_file_format()
        write_file(path, content)?

        return Ok(())

    # Check if snapshot exists
    pub fn snapshot_exists(
        test_file: text,
        test_name: text,
        snapshot_dir: text
    ) -> bool:
        val snapshot = SnapshotFile.new(test_file, test_name, "", "text")
        val path = snapshot.get_path(snapshot_dir)
        return exist(path)

    # Delete snapshot file
    pub fn delete_snapshot(
        test_file: text,
        test_name: text,
        snapshot_dir: text
    ) -> Result<(), text>:
        val snapshot = SnapshotFile.new(test_file, test_name, "", "text")
        val path = snapshot.get_path(snapshot_dir)

        if exist(path):
            std.io.remove_file(path)?

        return Ok(())
