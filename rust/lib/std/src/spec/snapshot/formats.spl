# Snapshot Testing - Format Support
# Feature #902: Multi-format snapshot serialization

module std.spec.snapshot.formats:
    use core.result.{Result, Ok, Err}
    use core.option.{Option, Some, None}

    # Trait for snapshot formatters
    pub trait SnapshotFormatter:
        fn serialize(value: Any) -> Result<text, text>
        fn deserialize(content: text) -> Result<Any, text>
        fn normalize(content: text) -> text

    # Text formatter (default)
    pub struct TextFormatter:
        pass

    impl SnapshotFormatter for TextFormatter:
        fn serialize(value: Any) -> Result<text, text>:
            return Ok(value.to_string())

        fn deserialize(content: text) -> Result<Any, text>:
            return Ok(content)

        fn normalize(content: text) -> text:
            # Normalize line endings
            val normalized = content.replace("\r\n", "\n")
            # Trim trailing whitespace from each line
            val lines = normalized.split("\n")
            val trimmed = lines.map(|line| line.trim_end())
            return trimmed.join("\n")

    # JSON formatter
    pub struct JsonFormatter:
        pretty: bool

    impl JsonFormatter:
        pub fn new() -> JsonFormatter:
            return JsonFormatter(pretty: true)

        pub fn compact() -> JsonFormatter:
            return JsonFormatter(pretty: false)

    impl SnapshotFormatter for JsonFormatter:
        fn serialize(value: Any) -> Result<text, text>:
            if self.pretty:
                return json.to_string_pretty(value)
            else:
                return json.to_string(value)

        fn deserialize(content: text) -> Result<Any, text>:
            return json.parse(content)

        fn normalize(content: text) -> text:
            # Parse and re-serialize to normalize formatting
            match json.parse(content):
                Ok(value) ->
                    return json.to_string_pretty(value).unwrap_or(content)
                Err(_) ->
                    return content

    # YAML formatter
    pub struct YamlFormatter:
        pass

    impl SnapshotFormatter for YamlFormatter:
        fn serialize(value: Any) -> Result<text, text>:
            return yaml.to_string(value)

        fn deserialize(content: text) -> Result<Any, text>:
            return yaml.parse(content)

        fn normalize(content: text) -> text:
            # Parse and re-serialize to normalize formatting
            match yaml.parse(content):
                Ok(value) ->
                    return yaml.to_string(value).unwrap_or(content)
                Err(_) ->
                    return content

    # HTML formatter
    pub struct HtmlFormatter:
        pretty: bool

    impl HtmlFormatter:
        pub fn new() -> HtmlFormatter:
            return HtmlFormatter(pretty: true)

    impl SnapshotFormatter for HtmlFormatter:
        fn serialize(value: Any) -> Result<text, text>:
            val html = value.to_string()
            if self.pretty:
                return Ok(prettify_html(html))
            return Ok(html)

        fn deserialize(content: text) -> Result<Any, text>:
            return Ok(content)

        fn normalize(content: text) -> text:
            # Normalize whitespace between tags
            val normalized = content
                .replace("\r\n", "\n")
                .replace("\t", "  ")
            return normalized

    # Base64 formatter (for binary data)
    pub struct Base64Formatter:
        pass

    impl SnapshotFormatter for Base64Formatter:
        fn serialize(value: Any) -> Result<text, text>:
            # Assume value is byte array
            return base64.encode(value)

        fn deserialize(content: text) -> Result<Any, text>:
            return base64.decode(content)

        fn normalize(content: text) -> text:
            # Base64 doesn't need normalization
            return content.trim()

    # Get formatter by format name
    pub fn get_formatter(format: text) -> impl SnapshotFormatter:
        match format:
            "text" -> return TextFormatter()
            "json" -> return JsonFormatter.new()
            "yaml" -> return YamlFormatter()
            "html" -> return HtmlFormatter.new()
            "base64" -> return Base64Formatter()
            _ -> return TextFormatter()  # Default to text

    # Helper: prettify HTML
    fn prettify_html(html: text) -> text:
        # Simple HTML prettification
        var result = ""
        var indent = 0
        val lines = html.split(">")

        for line in lines:
            val trimmed = line.trim()
            if trimmed.is_empty():
                continue

            # Dedent on closing tag
            if trimmed.starts_with("</"):
                indent = max(0, indent - 1)

            # Add indentation
            result += "  ".repeat(indent) + trimmed + ">\n"

            # Indent on opening tag (but not self-closing)
            if !trimmed.starts_with("</") and !trimmed.ends_with("/"):
                indent += 1

        return result.trim()

    # Apply normalization patterns
    pub fn apply_normalizations(
        content: text,
        normalize_timestamps: bool,
        normalize_ids: bool
    ) -> text:
        var normalized = content

        if normalize_timestamps:
            # Replace ISO timestamps
            normalized = regex.replace_all(
                normalized,
                r"\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(Z|[+-]\d{2}:\d{2})",
                "<TIMESTAMP>"
            )
            # Replace Unix timestamps
            normalized = regex.replace_all(
                normalized,
                r"\b\d{10,13}\b",
                "<TIMESTAMP>"
            )

        if normalize_ids:
            # Replace UUIDs
            normalized = regex.replace_all(
                normalized,
                r"[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}",
                "<UUID>"
            )
            # Replace sequential IDs (heuristic)
            val id_pattern = r'"id"\s*:\s*\d+'
            var id_counter = 0
            normalized = regex.replace_all_with(
                normalized,
                id_pattern,
                |_| {
                    id_counter += 1
                    return f'"id": <ID-{id_counter}>'
                }
            )

        return normalized
