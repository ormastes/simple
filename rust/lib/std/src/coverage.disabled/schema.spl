# Coverage Schema - Simple Class Definitions
# These define the structure for SDN coverage reports
#
# Coverage Metrics Supported:
# - Decision Coverage: Each decision taken both true and false
# - Condition Coverage: Each condition in decision taken both ways
# - MC/DC: Each condition independently affects decision outcome
# - Path Coverage: Each execution path hit at least once

# Source location for coverage data
struct SourceLoc:
    file: str
    line: u32
    column: u32

impl SourceLoc:
    fn new(file: str, line: u32, column: u32) -> SourceLoc:
        return SourceLoc(file: file, line: line, column: column)

    fn to_string() -> str:
        return "{self.file}:{self.line}:{self.column}"

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn has_file() -> bool:
        """Check if file path is set."""
        return not self.file.is_empty()

    fn is_at_line(line_num: u32) -> bool:
        """Check if location is at specific line."""
        return self.line == line_num

    fn is_at_column(col_num: u32) -> bool:
        """Check if location is at specific column."""
        return self.column == col_num

    fn summary() -> str:
        """Get summary of source location."""
        return "SourceLoc: {self.file}:{self.line}:{self.column}"

# A single condition within a decision
# Each condition must be evaluated both true and false for full coverage
struct Condition:
    id: u32
    loc: SourceLoc
    true_count: u64      # Times condition evaluated to true
    false_count: u64     # Times condition evaluated to false

impl Condition:
    fn new(id: u32, loc: SourceLoc) -> Condition:
        return Condition(
            id: id,
            loc: loc,
            true_count: 0,
            false_count: 0
        )

    fn is_covered() -> bool:
        # Condition is covered if evaluated both true and false
        return self.true_count > 0 and self.false_count > 0

    fn coverage_percent() -> f64:
        # 0% if neither, 50% if one, 100% if both
        val covered = 0
        if self.true_count > 0:
            covered += 1
        if self.false_count > 0:
            covered += 1
        return (covered as f64) / 2.0 * 100.0

    fn total_evaluations() -> u64:
        return self.true_count + self.false_count

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn has_true_evaluation() -> bool:
        """Check if condition was evaluated to true at least once."""
        return self.true_count > 0

    fn has_false_evaluation() -> bool:
        """Check if condition was evaluated to false at least once."""
        return self.false_count > 0

    fn is_fully_covered() -> bool:
        """Check if condition is fully covered (both true and false)."""
        return self.is_covered()

    fn is_uncovered() -> bool:
        """Check if condition is completely uncovered."""
        return self.true_count == 0 and self.false_count == 0

    fn is_partially_covered() -> bool:
        """Check if condition is partially covered (only true or false)."""
        return (self.true_count > 0) != (self.false_count > 0)

    fn has_id(cond_id: u32) -> bool:
        """Check if this is a specific condition ID."""
        return self.id == cond_id

    fn summary() -> str:
        """Get summary of condition coverage."""
        val percent = self.coverage_percent()
        return "Condition {self.id}: {percent}% covered (true={self.true_count}, false={self.false_count})"

# A decision (boolean expression with one or more conditions)
# For MC/DC, each condition must independently affect the decision outcome
struct Decision:
    id: u32
    loc: SourceLoc
    conditions: List<Condition>
    true_count: u64      # Times decision evaluated to true
    false_count: u64     # Times decision evaluated to false

impl Decision:
    fn new(id: u32, loc: SourceLoc) -> Decision:
        return Decision(
            id: id,
            loc: loc,
            conditions: [],
            true_count: 0,
            false_count: 0
        )

    fn add_condition(cond: Condition):
        self.conditions.push(cond)

    fn is_covered() -> bool:
        # Decision is covered if evaluated both true and false
        return self.true_count > 0 and self.false_count > 0

    fn condition_count() -> u32:
        return len(self.conditions) as u32

    fn covered_condition_count() -> u32:
        val covered = 0
        for cond in self.conditions:
            if cond.is_covered():
                covered += 1
        return covered

    fn condition_coverage_percent() -> f64:
        if len(self.conditions) == 0:
            return 100.0
        val total = 0
        val covered = 0
        for cond in self.conditions:
            total += 2  # Each condition has true and false
            if cond.true_count > 0:
                covered += 1
            if cond.false_count > 0:
                covered += 1
        return (covered as f64) / (total as f64) * 100.0

    fn mc_dc_covered() -> bool:
        # MC/DC requires:
        # 1. Decision coverage (both outcomes)
        # 2. Each condition independently affects decision
        if not self.is_covered():
            return false
        for cond in self.conditions:
            if not cond.is_covered():
                return false
        return true

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn has_true_outcome() -> bool:
        """Check if decision evaluated to true at least once."""
        return self.true_count > 0

    fn has_false_outcome() -> bool:
        """Check if decision evaluated to false at least once."""
        return self.false_count > 0

    fn is_fully_covered() -> bool:
        """Check if decision is fully covered (both outcomes)."""
        return self.is_covered()

    fn is_uncovered() -> bool:
        """Check if decision is completely uncovered."""
        return self.true_count == 0 and self.false_count == 0

    fn has_conditions() -> bool:
        """Check if decision has any conditions."""
        return len(self.conditions) > 0

    fn is_simple_decision() -> bool:
        """Check if decision has only one condition."""
        return len(self.conditions) == 1

    fn is_complex_decision() -> bool:
        """Check if decision has multiple conditions."""
        return len(self.conditions) > 1

    fn all_conditions_covered() -> bool:
        """Check if all conditions are covered."""
        if len(self.conditions) == 0:
            return true
        for cond in self.conditions:
            if not cond.is_covered():
                return false
        return true

    fn has_uncovered_conditions() -> bool:
        """Check if any conditions are uncovered."""
        return not self.all_conditions_covered()

    fn has_id(dec_id: u32) -> bool:
        """Check if this is a specific decision ID."""
        return self.id == dec_id

    fn summary() -> str:
        """Get summary of decision coverage."""
        val cond_count = len(self.conditions)
        val covered_conds = self.covered_condition_count()
        val mcdc = if self.mc_dc_covered(): "MC/DC✓" else: "MC/DC✗"
        return "Decision {self.id}: {covered_conds}/{cond_count} conditions, {mcdc}"

# An execution path through a function
# Represented as a sequence of basic block IDs
struct ExecutionPath:
    id: u32
    block_sequence: List<u32>  # Sequence of block IDs traversed
    hit_count: u64             # Number of times this path was taken

impl ExecutionPath:
    fn new(id: u32, blocks: List<u32>) -> ExecutionPath:
        return ExecutionPath(
            id: id,
            block_sequence: blocks,
            hit_count: 0
        )

    fn is_covered() -> bool:
        return self.hit_count > 0

    fn path_length() -> u32:
        return len(self.block_sequence) as u32

    fn blocks_string() -> str:
        # Format: [0 1 2 3]
        val parts = []
        for b in self.block_sequence:
            parts.push(str(b))
        return "[" + " ".join(parts) + "]"

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_uncovered() -> bool:
        """Check if path is completely uncovered."""
        return self.hit_count == 0

    fn is_frequently_hit(threshold: u64) -> bool:
        """Check if path hit count exceeds threshold."""
        return self.hit_count >= threshold

    fn has_blocks() -> bool:
        """Check if path has any blocks."""
        return len(self.block_sequence) > 0

    fn is_empty_path() -> bool:
        """Check if path has no blocks."""
        return len(self.block_sequence) == 0

    fn is_single_block() -> bool:
        """Check if path contains only one block."""
        return len(self.block_sequence) == 1

    fn contains_block(block_id: u32) -> bool:
        """Check if path contains specific block ID."""
        for b in self.block_sequence:
            if b == block_id:
                return true
        return false

    fn has_id(path_id: u32) -> bool:
        """Check if this is a specific path ID."""
        return self.id == path_id

    fn summary() -> str:
        """Get summary of execution path."""
        val blocks = self.blocks_string()
        val status = if self.is_covered(): "covered" else: "uncovered"
        return "Path {self.id}: {blocks} - {status} (hits={self.hit_count})"

# Coverage data for a single function
struct FunctionCoverage:
    name: str
    loc: SourceLoc
    decisions: List<Decision>
    paths: List<ExecutionPath>
    entry_count: u64           # Number of times function was called

impl FunctionCoverage:
    fn new(name: str, loc: SourceLoc) -> FunctionCoverage:
        return FunctionCoverage(
            name: name,
            loc: loc,
            decisions: [],
            paths: [],
            entry_count: 0
        )

    fn add_decision(decision: Decision):
        self.decisions.push(decision)

    fn add_path(path: ExecutionPath):
        self.paths.push(path)

    fn decision_count() -> u32:
        return len(self.decisions) as u32

    fn covered_decision_count() -> u32:
        val covered = 0
        for d in self.decisions:
            if d.is_covered():
                covered += 1
        return covered

    fn decision_coverage_percent() -> f64:
        if len(self.decisions) == 0:
            return 100.0
        val covered = 0
        for d in self.decisions:
            if d.is_covered():
                covered += 1
        return (covered as f64) / (len(self.decisions) as f64) * 100.0

    fn condition_count() -> u32:
        val total = 0
        for d in self.decisions:
            total += len(d.conditions)
        return total as u32

    fn covered_condition_count() -> u32:
        val covered = 0
        for d in self.decisions:
            for c in d.conditions:
                if c.is_covered():
                    covered += 1
        return covered

    fn condition_coverage_percent() -> f64:
        val total = 0
        val covered = 0
        for d in self.decisions:
            for c in d.conditions:
                total += 1
                if c.is_covered():
                    covered += 1
        if total == 0:
            return 100.0
        return (covered as f64) / (total as f64) * 100.0

    fn path_count() -> u32:
        return len(self.paths) as u32

    fn covered_path_count() -> u32:
        val covered = 0
        for p in self.paths:
            if p.is_covered():
                covered += 1
        return covered

    fn path_coverage_percent() -> f64:
        if len(self.paths) == 0:
            return 100.0
        val covered = 0
        for p in self.paths:
            if p.is_covered():
                covered += 1
        return (covered as f64) / (len(self.paths) as f64) * 100.0

    fn mc_dc_count() -> u32:
        return len(self.decisions) as u32

    fn mc_dc_covered_count() -> u32:
        val covered = 0
        for d in self.decisions:
            if d.mc_dc_covered():
                covered += 1
        return covered

    fn mc_dc_percent() -> f64:
        if len(self.decisions) == 0:
            return 100.0
        val covered = 0
        for d in self.decisions:
            if d.mc_dc_covered():
                covered += 1
        return (covered as f64) / (len(self.decisions) as f64) * 100.0

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn has_name(func_name: str) -> bool:
        """Check if function has specific name."""
        return self.name == func_name

    fn was_called() -> bool:
        """Check if function was called at least once."""
        return self.entry_count > 0

    fn is_uncalled() -> bool:
        """Check if function was never called."""
        return self.entry_count == 0

    fn has_decisions() -> bool:
        """Check if function has any decisions."""
        return len(self.decisions) > 0

    fn has_paths() -> bool:
        """Check if function has any execution paths."""
        return len(self.paths) > 0

    fn has_conditions() -> bool:
        """Check if function has any conditions."""
        return self.condition_count() > 0

    fn is_fully_decision_covered() -> bool:
        """Check if all decisions are covered."""
        return self.decision_coverage_percent() >= 100.0

    fn is_fully_condition_covered() -> bool:
        """Check if all conditions are covered."""
        return self.condition_coverage_percent() >= 100.0

    fn is_fully_path_covered() -> bool:
        """Check if all paths are covered."""
        return self.path_coverage_percent() >= 100.0

    fn is_fully_mc_dc_covered() -> bool:
        """Check if all decisions satisfy MC/DC."""
        return self.mc_dc_percent() >= 100.0

    fn is_fully_covered() -> bool:
        """Check if function is fully covered (all metrics at 100%)."""
        return self.is_fully_decision_covered() and
               self.is_fully_condition_covered() and
               self.is_fully_path_covered()

    fn has_uncovered_decisions() -> bool:
        """Check if any decisions are uncovered."""
        return self.covered_decision_count() < self.decision_count()

    fn has_uncovered_paths() -> bool:
        """Check if any paths are uncovered."""
        return self.covered_path_count() < self.path_count()

    fn summary() -> str:
        """Get summary of function coverage."""
        val dec_pct = self.decision_coverage_percent()
        val cond_pct = self.condition_coverage_percent()
        val path_pct = self.path_coverage_percent()
        return "Function '{self.name}': calls={self.entry_count}, dec={dec_pct}%, cond={cond_pct}%, path={path_pct}%"

# Coverage data for a module/file
struct ModuleCoverage:
    file: str
    functions: List<FunctionCoverage>

impl ModuleCoverage:
    fn new(file: str) -> ModuleCoverage:
        return ModuleCoverage(file: file, functions: [])

    fn add_function(func: FunctionCoverage):
        self.functions.push(func)

    fn function_count() -> u32:
        return len(self.functions) as u32

    fn total_decisions() -> u32:
        val total = 0
        for f in self.functions:
            total += f.decision_count()
        return total

    fn covered_decisions() -> u32:
        val covered = 0
        for f in self.functions:
            covered += f.covered_decision_count()
        return covered

    fn decision_coverage_percent() -> f64:
        val total = self.total_decisions()
        if total == 0:
            return 100.0
        return (self.covered_decisions() as f64) / (total as f64) * 100.0

    fn total_conditions() -> u32:
        val total = 0
        for f in self.functions:
            total += f.condition_count()
        return total

    fn covered_conditions() -> u32:
        val covered = 0
        for f in self.functions:
            covered += f.covered_condition_count()
        return covered

    fn condition_coverage_percent() -> f64:
        val total = self.total_conditions()
        if total == 0:
            return 100.0
        return (self.covered_conditions() as f64) / (total as f64) * 100.0

    fn total_paths() -> u32:
        val total = 0
        for f in self.functions:
            total += f.path_count()
        return total

    fn covered_paths() -> u32:
        val covered = 0
        for f in self.functions:
            covered += f.covered_path_count()
        return covered

    fn path_coverage_percent() -> f64:
        val total = self.total_paths()
        if total == 0:
            return 100.0
        return (self.covered_paths() as f64) / (total as f64) * 100.0

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn has_file(file_path: str) -> bool:
        """Check if module is for specific file."""
        return self.file == file_path

    fn has_functions() -> bool:
        """Check if module has any functions."""
        return len(self.functions) > 0

    fn is_empty() -> bool:
        """Check if module has no functions."""
        return len(self.functions) == 0

    fn has_decisions() -> bool:
        """Check if module has any decisions."""
        return self.total_decisions() > 0

    fn has_paths() -> bool:
        """Check if module has any paths."""
        return self.total_paths() > 0

    fn is_fully_decision_covered() -> bool:
        """Check if all decisions are covered."""
        return self.decision_coverage_percent() >= 100.0

    fn is_fully_condition_covered() -> bool:
        """Check if all conditions are covered."""
        return self.condition_coverage_percent() >= 100.0

    fn is_fully_path_covered() -> bool:
        """Check if all paths are covered."""
        return self.path_coverage_percent() >= 100.0

    fn has_uncovered_decisions() -> bool:
        """Check if any decisions are uncovered."""
        return self.covered_decisions() < self.total_decisions()

    fn has_uncovered_conditions() -> bool:
        """Check if any conditions are uncovered."""
        return self.covered_conditions() < self.total_conditions()

    fn summary() -> str:
        """Get summary of module coverage."""
        val dec_pct = self.decision_coverage_percent()
        val cond_pct = self.condition_coverage_percent()
        val path_pct = self.path_coverage_percent()
        return "Module '{self.file}': {self.function_count()} funcs, dec={dec_pct}%, cond={cond_pct}%, path={path_pct}%"

# Summary statistics for a coverage report
struct CoverageSummary:
    total_functions: u32
    covered_functions: u32
    total_decisions: u32
    covered_decisions: u32
    total_conditions: u32
    covered_conditions: u32
    total_paths: u32
    covered_paths: u32
    mc_dc_total: u32
    mc_dc_covered: u32

impl CoverageSummary:
    static fn new() -> CoverageSummary:
        return CoverageSummary(
            total_functions: 0,
            covered_functions: 0,
            total_decisions: 0,
            covered_decisions: 0,
            total_conditions: 0,
            covered_conditions: 0,
            total_paths: 0,
            covered_paths: 0,
            mc_dc_total: 0,
            mc_dc_covered: 0
        )

    fn function_percent() -> f64:
        if self.total_functions == 0:
            return 100.0
        return (self.covered_functions as f64) / (self.total_functions as f64) * 100.0

    fn decision_percent() -> f64:
        if self.total_decisions == 0:
            return 100.0
        return (self.covered_decisions as f64) / (self.total_decisions as f64) * 100.0

    fn condition_percent() -> f64:
        if self.total_conditions == 0:
            return 100.0
        return (self.covered_conditions as f64) / (self.total_conditions as f64) * 100.0

    fn path_percent() -> f64:
        if self.total_paths == 0:
            return 100.0
        return (self.covered_paths as f64) / (self.total_paths as f64) * 100.0

    fn mc_dc_percent() -> f64:
        if self.mc_dc_total == 0:
            return 100.0
        return (self.mc_dc_covered as f64) / (self.mc_dc_total as f64) * 100.0

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn has_functions() -> bool:
        """Check if summary has any functions."""
        return self.total_functions > 0

    fn has_decisions() -> bool:
        """Check if summary has any decisions."""
        return self.total_decisions > 0

    fn has_conditions() -> bool:
        """Check if summary has any conditions."""
        return self.total_conditions > 0

    fn has_paths() -> bool:
        """Check if summary has any paths."""
        return self.total_paths > 0

    fn is_fully_function_covered() -> bool:
        """Check if all functions are covered."""
        return self.function_percent() >= 100.0

    fn is_fully_decision_covered() -> bool:
        """Check if all decisions are covered."""
        return self.decision_percent() >= 100.0

    fn is_fully_condition_covered() -> bool:
        """Check if all conditions are covered."""
        return self.condition_percent() >= 100.0

    fn is_fully_path_covered() -> bool:
        """Check if all paths are covered."""
        return self.path_percent() >= 100.0

    fn is_fully_mc_dc_covered() -> bool:
        """Check if all decisions satisfy MC/DC."""
        return self.mc_dc_percent() >= 100.0

    fn is_fully_covered() -> bool:
        """Check if fully covered (all metrics at 100%)."""
        return self.is_fully_function_covered() and
               self.is_fully_decision_covered() and
               self.is_fully_condition_covered() and
               self.is_fully_path_covered()

    fn has_uncovered_functions() -> bool:
        """Check if any functions are uncovered."""
        return self.covered_functions < self.total_functions

    fn has_uncovered_decisions() -> bool:
        """Check if any decisions are uncovered."""
        return self.covered_decisions < self.total_decisions

    fn has_uncovered_paths() -> bool:
        """Check if any paths are uncovered."""
        return self.covered_paths < self.total_paths

    fn summary() -> str:
        """Get summary text."""
        val func_pct = self.function_percent()
        val dec_pct = self.decision_percent()
        val path_pct = self.path_percent()
        return "Coverage: funcs={func_pct}%, dec={dec_pct}%, paths={path_pct}%"

# Top-level coverage report
struct CoverageReport:
    version: str
    timestamp: str
    modules: List<ModuleCoverage>

impl CoverageReport:
    static fn new() -> CoverageReport:
        return CoverageReport(
            version: "1.0",
            timestamp: "",
            modules: []
        )

    fn add_module(module: ModuleCoverage):
        self.modules.push(module)

    fn module_count() -> u32:
        return len(self.modules) as u32

    fn summary() -> CoverageSummary:
        val s = CoverageSummary.new()
        for m in self.modules:
            for f in m.functions:
                s.total_functions += 1
                if f.entry_count > 0:
                    s.covered_functions += 1
                s.total_decisions += f.decision_count()
                s.covered_decisions += f.covered_decision_count()
                s.total_conditions += f.condition_count()
                s.covered_conditions += f.covered_condition_count()
                s.total_paths += f.path_count()
                s.covered_paths += f.covered_path_count()
                s.mc_dc_total += f.mc_dc_count()
                s.mc_dc_covered += f.mc_dc_covered_count()
        return s

    fn get_function(name: str) -> Option<FunctionCoverage>:
        for m in self.modules:
            for f in m.functions:
                if f.name == name:
                    return Some(f)
        return None

    fn get_module(file: str) -> Option<ModuleCoverage>:
        for m in self.modules:
            if m.file == file:
                return Some(m)
        return None

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn has_version() -> bool:
        """Check if version is set."""
        return not self.version.is_empty()

    fn has_timestamp() -> bool:
        """Check if timestamp is set."""
        return not self.timestamp.is_empty()

    fn has_modules() -> bool:
        """Check if report has any modules."""
        return len(self.modules) > 0

    fn is_empty() -> bool:
        """Check if report has no modules."""
        return len(self.modules) == 0

    fn has_function(name: str) -> bool:
        """Check if function exists in any module."""
        return self.get_function(name).is_some()

    fn has_module(file: str) -> bool:
        """Check if module exists for file."""
        return self.get_module(file).is_some()

    fn is_fully_covered() -> bool:
        """Check if all metrics are at 100%."""
        val s = self.summary()
        return s.is_fully_covered()

    fn has_uncovered_items() -> bool:
        """Check if any items are uncovered."""
        val s = self.summary()
        return s.has_uncovered_functions() or
               s.has_uncovered_decisions() or
               s.has_uncovered_paths()

    fn get_overall_percent() -> f64:
        """Get average coverage percentage across all metrics."""
        val s = self.summary()
        return (s.function_percent() +
                s.decision_percent() +
                s.condition_percent() +
                s.path_percent()) / 4.0

    fn summary_text() -> str:
        """Get summary text of coverage report."""
        val s = self.summary()
        val overall = self.get_overall_percent()
        return "CoverageReport v{self.version}: {self.module_count()} modules, {overall}% overall coverage"
