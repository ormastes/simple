# Spatial Hashing - Broad-Phase Collision Optimization

export SpatialHash

use ..core as core

class SpatialHash:
    """Spatial hashing for efficient broad-phase collision detection.

    Divides space into a uniform grid and maps objects to grid cells.
    Only objects in the same or nearby cells are tested for collision,
    reducing collision checks from O(nÂ²) to approximately O(n).
    """
    cell_size: f64
    cells: Dict<i64, List<i64>>
    object_positions: [core.Vector3]
    object_radii: [f64]
    fn __init__(cell_size: f64 = 10.0):
        """Initialize spatial hash."""
        self.cell_size = cell_size
        self.cells = {}
        self.object_positions = []
        self.object_radii = []

    fn insert(object_id: i64, position: core.Vector3, radius: f64):
        """Insert object into spatial hash."""
        if object_id >= self.object_positions.len() as i64:
            while self.object_positions.len() as i64 <= object_id:
                self.object_positions.append(core.Vector3(0.0, 0.0, 0.0))
                self.object_radii.append(0.0)

        self.object_positions[object_id as usize] = position
        self.object_radii[object_id as usize] = radius

        val min_cell = self._position_to_cell(position.sub(core.Vector3(radius, radius, radius)))
        val max_cell = self._position_to_cell(position.add(core.Vector3(radius, radius, radius)))

        for x in range(min_cell.x as i64, max_cell.x as i64 + 1):
            for y in range(min_cell.y as i64, max_cell.y as i64 + 1):
                for z in range(min_cell.z as i64, max_cell.z as i64 + 1):
                    val cell_hash = self._hash_cell(x, y, z)
                    if not (cell_hash in self.cells):
                        self.cells[cell_hash] = []
                    self.cells[cell_hash].append(object_id)
    fn query_nearby(position: core.Vector3, radius: f64) -> [i64]:
        """Query objects near a position."""
        val result = []
        val visited = {}

        val min_cell = self._position_to_cell(position.sub(core.Vector3(radius, radius, radius)))
        val max_cell = self._position_to_cell(position.add(core.Vector3(radius, radius, radius)))

        for x in range(min_cell.x as i64, max_cell.x as i64 + 1):
            for y in range(min_cell.y as i64, max_cell.y as i64 + 1):
                for z in range(min_cell.z as i64, max_cell.z as i64 + 1):
                    val cell_hash = self._hash_cell(x, y, z)
                    if cell_hash in self.cells:
                        for obj_id in self.cells[cell_hash]:
                            if not (obj_id in visited):
                                visited[obj_id] = true
                                result.append(obj_id)

        return result
    fn get_potential_pairs() -> [(i64, i64)]:
        """Get all potential collision pairs."""
        val pairs = []
        val tested = {}

        for cell_hash in self.cells.keys():
            val objects = self.cells[cell_hash]
            for i in range(objects.len()):
                for j in range(i + 1, objects.len()):
                    val id1 = objects[i]
                    val id2 = objects[j]
                    val pair_key = if id1 < id2: (id1, id2) else: (id2, id1)
                    if not (pair_key in tested):
                        tested[pair_key] = true
                        pairs.append(pair_key)

        return pairs
    fn clear():
        """Clear all objects from the spatial hash."""
        self.cells = {}
    fn _position_to_cell(position: core.Vector3) -> core.Vector3:
        """Convert world position to grid cell coordinates."""
        return core.Vector3(
            (position.x / self.cell_size).floor(),
            (position.y / self.cell_size).floor(),
            (position.z / self.cell_size).floor()
        )
    fn _hash_cell(x: i64, y: i64, z: i64) -> i64:
        """Hash 3D cell coordinates to a single integer."""
        val h = (x * 73856093) xor (y * 19349663) xor (z * 83492791)
        return h
    fn get_cell_count() -> i64:
        """Get number of occupied cells."""
        return self.cells.keys().len() as i64
    fn get_max_objects_per_cell() -> i64:
        """Get maximum number of objects in any single cell."""
        val max_count = 0
        for cell_hash in self.cells.keys():
            val count = self.cells[cell_hash].len() as i64
            if count > max_count:
                max_count = count
        return max_count
    fn get_average_objects_per_cell() -> f64:
        """Get average number of objects per occupied cell."""
        if self.cells.keys().len() == 0:
            return 0.0
        val total = 0
        for cell_hash in self.cells.keys():
            total += self.cells[cell_hash].len()
        return total as f64 / self.cells.keys().len() as f64
