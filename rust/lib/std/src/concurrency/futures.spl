/**
Future Utilities

Futures represent values that will be available asynchronously.
They are created with `future(expr)` and resolved with `await`.

Basic Future:
```sdoctest
>>> val f = future(42)
>>> await f
42
```

Future with Computation:
```sdoctest
>>> val f = future(10 + 20 + 30)
>>> await f
60
```

Multiple Futures:
```sdoctest
>>> val f1 = future(10)
>>> val f2 = future(20)
>>> await f1 + await f2
30
```
*/

/**
Create a future from a value (immediately resolved)

```sdoctest
>>> val f = resolved(42)
>>> await f
42
```
*/
fn resolved(value):
    return future(value)

/**
Map a function over a future's result

```sdoctest
>>> val f = future(21)
>>> val doubled = map_future(f, \x: x * 2)
>>> await doubled
42
```
*/
fn map_future(f, transform):
    return future(transform(await f))

/**
Chain two futures together

```sdoctest
>>> val f1 = future(10)
>>> val f2 = flat_map(f1, \x: future(x * 2))
>>> await f2
20
```
*/
fn flat_map(f, transform):
    return transform(await f)

/**
Wait for all futures to complete and collect results

```sdoctest
>>> val futures = [future(1), future(2), future(3)]
>>> all(futures)
[1, 2, 3]
```
*/
fn all(futures: List) -> List:
    val results = []
    for f in futures:
        results.push(await f)
    return results

/**
Wait for the first future to complete
Returns the value of the first completed future

Note: In eager evaluation mode, this returns the first in order.
With true async runtime, it would return the first to complete.
*/
fn race(futures: List):
    if futures.is_empty:
        return nil
    # In eager mode, just return first result
    return await futures[0]

/**
Create a future that completes after combining two futures

```sdoctest
>>> val f1 = future(10)
>>> val f2 = future(20)
>>> val combined = zip_future(f1, f2)
>>> await combined
(10, 20)
```
*/
fn zip_future(f1, f2):
    return future((await f1, await f2))

/**
Retry a future-producing function up to n times

Catches errors and retries until success or max_attempts reached.
*/
fn retry(make_future, max_attempts: i32):
    val attempt = 0
    while attempt < max_attempts:
        try:
            return await make_future()
        catch e:
            attempt += 1
            if attempt >= max_attempts:
                raise e
    return nil
