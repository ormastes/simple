/**
Generator Utilities

Generators are lazy sequences that produce values on demand.
They are created with `generator(\: ...)` and consumed with `next()`.

Basic Generator:
```sdoctest
>>> val gen = generator(\: yield 42)
>>> next(gen)
42
```

Multiple Yields:
```sdoctest
>>> val gen = generator(\: [yield 1, yield 2, yield 3])
>>> val a = next(gen)
>>> val b = next(gen)
>>> val c = next(gen)
>>> a + b + c
6
```

Generator with Captured Variables:
```sdoctest
>>> val base = 100
>>> val gen = generator(\: [yield base, yield (base + 1)])
>>> next(gen) + next(gen)
201
```
*/

/**
Collect all values from a generator into a list

```sdoctest
>>> val gen = generator(\: [yield 1, yield 2, yield 3])
>>> collect(gen)
[1, 2, 3]
```
*/
fn collect(gen) -> List:
    val result = []
    while true:
        val val = next(gen)
        if val == nil:
            break
        result.push(val)
    return result

/**
Take at most n values from a generator

```sdoctest
>>> val gen = generator(\: [yield 1, yield 2, yield 3, yield 4, yield 5])
>>> take(gen, 3)
[1, 2, 3]
```
*/
fn take(gen, n: i32) -> List:
    val result = []
    val i = 0
    while i < n:
        val val = next(gen)
        if val == nil:
            break
        result.push(val)
        i += 1
    return result

/**
Create a generator that yields values from start to end (exclusive)

```sdoctest
>>> val gen = range_gen(0, 5)
>>> collect(gen)
[0, 1, 2, 3, 4]
```
*/
fn range_gen(start: i32, end: i32):
    return generator(\:
        val i = start
        while i < end:
            yield i
            i += 1
    )

/**
Create a generator that maps a function over another generator

```sdoctest
>>> val gen = generator(\: [yield 1, yield 2, yield 3])
>>> val doubled = map_gen(gen, \x: x * 2)
>>> collect(doubled)
[2, 4, 6]
```
*/
fn map_gen(gen, f):
    return generator(\:
        while true:
            val val = next(gen)
            if val == nil:
                break
            yield f(val)
    )

/**
Create a generator that filters values from another generator

```sdoctest
>>> val gen = generator(\: [yield 1, yield 2, yield 3, yield 4])
>>> val evens = filter_gen(gen, \x: x % 2 == 0)
>>> collect(evens)
[2, 4]
```
*/
fn filter_gen(gen, pred):
    return generator(\:
        while true:
            val val = next(gen)
            if val == nil:
                break
            if pred(val):
                yield val
    )

/**
Zip two generators together

```sdoctest
>>> val gen1 = generator(\: [yield 1, yield 2])
>>> val gen2 = generator(\: [yield "a", yield "b"])
>>> collect(zip_gen(gen1, gen2))
[(1, "a"), (2, "b")]
```
*/
fn zip_gen(gen1, gen2):
    return generator(\:
        while true:
            val a = next(gen1)
            val b = next(gen2)
            if a == nil or b == nil:
                break
            yield (a, b)
    )
