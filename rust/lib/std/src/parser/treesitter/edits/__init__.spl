# Incremental editing support for tree-sitter
mod edits

pub struct Point:
    line: i64
    column: i64

impl Point:
    pub static fn new(line: i64, column: i64) -> Point:
        return Point(line: line, column: column)

    pub fn is_before(self, other: Point) -> bool:
        if self.line < other.line:
            return true
        if self.line == other.line and self.column < other.column:
            return true
        return false

    pub fn is_after(self, other: Point) -> bool:
        if self.line > other.line:
            return true
        if self.line == other.line and self.column > other.column:
            return true
        return false

    pub fn equals(self, other: Point) -> bool:
        return self.line == other.line and self.column == other.column

    pub fn compare(self, other: Point) -> i64:
        if self.line < other.line:
            return -1
        if self.line > other.line:
            return 1
        if self.column < other.column:
            return -1
        if self.column > other.column:
            return 1
        return 0

pub struct InputEdit:
    start_byte: i64
    old_end_byte: i64
    new_end_byte: i64
    start_point: Point
    old_end_point: Point
    new_end_point: Point

impl InputEdit:
    pub static fn new(start_byte: i64, old_end_byte: i64, new_end_byte: i64, start_point: Point, old_end_point: Point, new_end_point: Point) -> InputEdit:
        return InputEdit(
            start_byte: start_byte,
            old_end_byte: old_end_byte,
            new_end_byte: new_end_byte,
            start_point: start_point,
            old_end_point: old_end_point,
            new_end_point: new_end_point,
        )

    pub fn affects_span(self, span) -> bool:
        # Edit affects span if they overlap
        if self.old_end_byte <= span.start_byte:
            return false
        if self.start_byte >= span.end_byte:
            return false
        return true

    pub fn adjust_byte(self, byte_pos: i64) -> i64:
        if byte_pos < self.start_byte:
            return byte_pos
        if byte_pos >= self.start_byte and byte_pos < self.old_end_byte:
            return self.start_byte
        val delta = self.new_end_byte - self.old_end_byte
        return byte_pos + delta

    pub fn adjust_point(self, point: Point) -> Point:
        if point.is_before(self.start_point):
            return point
        if (point.is_after(self.start_point) or point.equals(self.start_point)) and point.is_before(self.old_end_point):
            return self.start_point
        # After edit: adjust by delta
        val line_delta = self.new_end_point.line - self.old_end_point.line
        var col = point.column
        if point.line == self.old_end_point.line:
            col = point.column - self.old_end_point.column + self.new_end_point.column
        return Point(line: point.line + line_delta, column: col)

pub enum DiffOp:
    Equal(start: i64, len: i64)
    Delete(start: i64, len: i64)
    Insert(start: i64, len: i64)

pub fn compute_edits(old_text: text, new_text: text) -> Vec<InputEdit>:
    if old_text == new_text:
        return []

    # Find common prefix
    var prefix_len = 0
    val min_len = if old_text.len() < new_text.len() { old_text.len() } else { new_text.len() }
    while prefix_len < min_len and old_text[prefix_len] == new_text[prefix_len]:
        prefix_len = prefix_len + 1

    # Find common suffix
    var suffix_len = 0
    while suffix_len < (min_len - prefix_len):
        val old_idx = old_text.len() - 1 - suffix_len
        val new_idx = new_text.len() - 1 - suffix_len
        if old_text[old_idx] == new_text[new_idx]:
            suffix_len = suffix_len + 1
        else:
            break

    val old_mid_end = old_text.len() - suffix_len
    val new_mid_end = new_text.len() - suffix_len

    val start_point = compute_end_point(old_text[0:prefix_len])
    val old_end_point = compute_end_point(old_text[0:old_mid_end])
    val new_end_point = compute_end_point(new_text[0:new_mid_end])

    val edit = InputEdit(
        start_byte: prefix_len,
        old_end_byte: old_mid_end,
        new_end_byte: new_mid_end,
        start_point: start_point,
        old_end_point: old_end_point,
        new_end_point: new_end_point,
    )
    return [edit]

pub fn count_lines(text_val: text) -> i64:
    if text_val.len() == 0:
        return 1
    var count = 1
    for ch in text_val:
        if ch == '\n':
            count = count + 1
    return count

pub fn compute_end_point(text_val: text) -> Point:
    var line = 1
    var column = 1
    for ch in text_val:
        if ch == '\n':
            line = line + 1
            column = 1
        else:
            column = column + 1
    return Point(line: line, column: column)
