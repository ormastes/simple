# VSCode Webview WASM Loader
# Load and run Simple WASM in webview context

use core.result.{Result, Ok, Err}

# External FFI declarations
extern fn vscode_webview_create_panel(view_type: text, title: text, show_options: i32): i64
extern fn vscode_webview_post_message(panel_id: i64, message: text): void
extern fn vscode_webview_set_html(panel_id: i64, html: text): void
extern fn vscode_webview_dispose(panel_id: i64): void
extern fn vscode_webview_on_message(panel_id: i64, callback_id: i64): void

# Message callback storage
var _webview_callbacks: Dict<i64, fn(text): void> = {}
var _next_webview_callback_id: i64 = 0

# Webview panel
pub class WebviewPanel:
    pub panel_id: i64
    pub view_type: text
    pub title: text
    pub on_message_callback: fn(message: text): void

    pub fn new(view_type: text, title: text): WebviewPanel =
        """Create webview panel.

        Args:
            view_type: Unique view type identifier
            title: Panel title

        Returns:
            Webview panel

        Example:
            val panel = WebviewPanel.new("simple.preview", "Simple Preview")
            panel.load_wasm("preview.wasm")
            panel.show()
        """
        val panel_id = vscode_webview_create_panel(view_type, title, 1)

        WebviewPanel {
            panel_id: panel_id,
            view_type: view_type,
            title: title,
            on_message_callback: fn(msg): pass
        }

    pub fn set_html(self, html: text):
        """Set webview HTML content.

        Args:
            html: HTML content with WASM loader script
        """
        vscode_webview_set_html(self.panel_id, html)

    pub fn post_message(self, message: text):
        """Send message to webview.

        Args:
            message: JSON message to send
        """
        vscode_webview_post_message(self.panel_id, message)

    pub fn on_message(self, callback: fn(message: text): void):
        """Register message handler.

        Args:
            callback: Function to handle messages from webview
        """
        self.on_message_callback = callback
        # Register callback with FFI
        val callback_id = _next_webview_callback_id
        _next_webview_callback_id = _next_webview_callback_id + 1
        _webview_callbacks[callback_id] = callback
        vscode_webview_on_message(self.panel_id, callback_id)

    pub fn dispose(self):
        """Dispose webview panel."""
        vscode_webview_dispose(self.panel_id)

    pub fn load_wasm(self, wasm_path: text):
        """Load Simple WASM in webview.

        Args:
            wasm_path: Path to .wasm file

        Generates HTML with WASM loader script and injects it into webview.
        """
        val html = self.generate_wasm_loader_html(wasm_path)
        self.set_html(html)

    pub fn show(self):
        """Show webview panel."""
        # Panel is shown by default when created
        pass

    fn generate_wasm_loader_html(wasm_path: text): text =
        """Generate HTML with WASM loader.

        Args:
            wasm_path: Path to WASM file

        Returns:
            HTML content with WASM loader script
        """
        """<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{self.title}</title>
</head>
<body>
    <div id="root"></div>
    <script>
        // VSCode API
        const vscode = acquireVsCodeApi();

        // WASM loader
        async function loadWasm() {{
            try {{
                const response = await fetch('{wasm_path}');
                const buffer = await response.arrayBuffer();
                const module = await WebAssembly.instantiate(buffer, {{
                    env: {{
                        log: (ptr, len) => {{
                            const mem = new Uint8Array(instance.exports.memory.buffer);
                            const msg = new TextDecoder().decode(mem.slice(ptr, ptr + len));
                            console.log(msg);
                        }},
                        post_message: (ptr, len) => {{
                            const mem = new Uint8Array(instance.exports.memory.buffer);
                            const msg = new TextDecoder().decode(mem.slice(ptr, ptr + len));
                            vscode.postMessage(JSON.parse(msg));
                        }}
                    }}
                }});

                const instance = module.instance;

                // Initialize WASM module
                if (instance.exports.init) {{
                    instance.exports.init();
                }}

                // Handle messages from extension
                window.addEventListener('message', event => {{
                    const message = event.data;

                    if (instance.exports.handle_message) {{
                        // Convert message to WASM memory
                        const json = JSON.stringify(message);
                        const encoder = new TextEncoder();
                        const bytes = encoder.encode(json);

                        // Allocate memory in WASM
                        const ptr = instance.exports.alloc(bytes.length);
                        const mem = new Uint8Array(instance.exports.memory.buffer);
                        mem.set(bytes, ptr);

                        // Call WASM handler
                        instance.exports.handle_message(ptr, bytes.length);

                        // Free memory
                        instance.exports.free(ptr);
                    }}
                }});

                console.log('WASM module loaded successfully');
            }} catch (error) {{
                console.error('Failed to load WASM:', error);
                vscode.postMessage({{ type: 'error', message: error.toString() }});
            }}
        }}

        loadWasm();
    </script>
</body>
</html>"""

# WASM webview options
pub class WasmWebviewOptions:
    pub enable_scripts: bool
    pub retain_context_when_hidden: bool
    pub local_resource_roots: List<text>

    pub fn new(): WasmWebviewOptions =
        """Create default WASM webview options."""
        WasmWebviewOptions {
            enable_scripts: true,
            retain_context_when_hidden: true,
            local_resource_roots: []
        }

# Helper: Create WASM-powered webview
pub fn create_wasm_webview(
    view_type: text,
    title: text,
    wasm_path: text
): WebviewPanel =
    """Create webview with WASM module loaded.

    Args:
        view_type: View type identifier
        title: Panel title
        wasm_path: Path to WASM file

    Returns:
        Webview panel with WASM loaded

    Example:
        val panel = create_wasm_webview(
            "simple.preview",
            "Simple Preview",
            "./out/preview.wasm"
        )

        # Send message to WASM
        panel.post_message("{\"type\": \"render\", \"data\": \"Hello\"}")

        # Receive messages from WASM
        panel.on_message(fn(msg):
            print("Received from webview: {msg}")
        )
    """
    val panel = WebviewPanel.new(view_type, title)
    panel.load_wasm(wasm_path)
    panel

# Helper: Create preview webview
pub fn create_preview_panel(content: text): WebviewPanel =
    """Create simple preview webview.

    Args:
        content: HTML/Markdown content to preview

    Returns:
        Preview webview panel

    Example:
        val panel = create_preview_panel("# Hello\\n\\nThis is markdown")
    """
    val panel = WebviewPanel.new("simple.preview", "Preview")

    val html = """<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <style>
        body {{
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
        }}
        pre {{
            background: #f4f4f4;
            padding: 10px;
            border-radius: 4px;
        }}
    </style>
</head>
<body>
    {content}
</body>
</html>"""

    panel.set_html(html)
    panel

# Message bridge between extension and webview
pub class WebviewBridge:
    pub panel: WebviewPanel
    pub handlers: Dict<text, fn(data: text): void>

    pub fn new(panel: WebviewPanel): WebviewBridge =
        """Create message bridge.

        Args:
            panel: Webview panel

        Returns:
            Bridge instance

        Example:
            val bridge = WebviewBridge.new(panel)
            bridge.on("render", fn(data):
                # Handle render request from webview
                print("Render: {data}")
            )
            bridge.post("update", "{\"count\": 42}")
        """
        val bridge = WebviewBridge {
            panel: panel,
            handlers: {}
        }

        # Register message handler
        panel.on_message(fn(msg):
            bridge.handle_message(msg)
        )

        bridge

    pub fn on(self, message_type: text, handler: fn(data: text): void):
        """Register message type handler.

        Args:
            message_type: Message type to handle
            handler: Handler function
        """
        self.handlers[message_type] = handler

    pub fn post(self, message_type: text, data: text):
        """Post message to webview.

        Args:
            message_type: Message type
            data: Message data (JSON)
        """
        val message = "{{\"type\": \"{message_type}\", \"data\": {data}}}"
        self.panel.post_message(message)

    fn handle_message(message: text):
        """Handle incoming message from webview.

        Args:
            message: JSON message
        """
        import core.json.{parse, JsonValue}

        # Parse JSON message and dispatch to handlers
        # Expected format: {"type": "...", "data": ...}
        match parse(message):
            case Ok(JsonValue.Object(obj)):
                # Extract message type
                if val Some(JsonValue.String(msg_type)) = obj.get("type"):
                    # Find and invoke handler for this message type
                    for (handler_type, handler) in self.handlers:
                        if handler_type == msg_type:
                            # Extract data portion and pass to handler
                            val data = match obj.get("data"):
                                Some(d): d.to_string()
                                None: "{}"
                            handler(data)
                            break
            case _:
                # Fallback: try string matching for backwards compatibility
                if message.contains("\"type\":"):
                    for (msg_type, handler) in self.handlers:
                        if message.contains("\"type\": \"{msg_type}\"") or message.contains("\"type\":\"{msg_type}\""):
                            handler(message)
                            break
