# Godot Physics System
#
# Physics bodies and collision detection for 2D and 3D.
# Includes RigidBody, CharacterBody, and collision shapes.
#
# Reference: https://docs.godotengine.org/en/stable/classes/class_physicsbody2d.html

use godot.ffi
use godot.variant
use godot.object
use godot.node
use godot.node2d
use godot.node3d

# RigidBody2D - Dynamic physics body
pub struct RigidBody2D:
    base: node2d.Node2D

impl RigidBody2D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> RigidBody2D:
        return RigidBody2D(base: node2d.Node2D.from_ptr(ptr))

    # Velocity
    pub fn get_linear_velocity(self) -> (f64, f64):
        val result = self.base.as_node().as_object().call0("get_linear_velocity")
        return result.as_vector2()

    pub fn set_linear_velocity(mut self, x: f64, y: f64):
        val vel = variant.Variant.from_vector2(x, y)
        self.base.as_node().as_object().call1("set_linear_velocity", vel)

    # Angular velocity
    pub fn get_angular_velocity(self) -> f64:
        val result = self.base.as_node().as_object().call0("get_angular_velocity")
        return result.as_float()

    pub fn set_angular_velocity(mut self, vel: f64):
        val vel_var = variant.Variant.from_float(vel)
        self.base.as_node().as_object().call1("set_angular_velocity", vel_var)

    # Mass and physics properties
    pub fn get_mass(self) -> f64:
        val result = self.base.as_node().as_object().call0("get_mass")
        return result.as_float()

    pub fn set_mass(mut self, mass: f64):
        val mass_var = variant.Variant.from_float(mass)
        self.base.as_node().as_object().call1("set_mass", mass_var)

    # Apply forces
    pub fn apply_central_impulse(mut self, impulse_x: f64, impulse_y: f64):
        val impulse = variant.Variant.from_vector2(impulse_x, impulse_y)
        self.base.as_node().as_object().call1("apply_central_impulse", impulse)

    pub fn apply_impulse(mut self, impulse_x: f64, impulse_y: f64, position_x: f64, position_y: f64):
        val impulse = variant.Variant.from_vector2(impulse_x, impulse_y)
        val position = variant.Variant.from_vector2(position_x, position_y)
        self.base.as_node().as_object().call2("apply_impulse", impulse, position)

    pub fn apply_force(mut self, force_x: f64, force_y: f64):
        val force = variant.Variant.from_vector2(force_x, force_y)
        self.base.as_node().as_object().call1("apply_central_force", force)

    # Gravity scale
    pub fn set_gravity_scale(mut self, scale: f64):
        val scale_var = variant.Variant.from_float(scale)
        self.base.as_node().as_object().call1("set_gravity_scale", scale_var)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn get_speed(self) -> f64:
        """Get current speed (magnitude of velocity).

        Returns:
            Speed in pixels/second

        Example:
            body.get_speed()  # → 150.5
        """
        val (vx, vy) = self.get_linear_velocity()
        return (vx * vx + vy * vy).sqrt()

    pub fn is_moving(self) -> bool:
        """Check if body is moving.

        Returns:
            true if speed > 0.01

        Example:
            body.is_moving()  # → true
        """
        return self.get_speed() > 0.01

    pub fn is_stationary(self) -> bool:
        """Check if body is stationary (not moving).

        Returns:
            true if speed <= 0.01

        Example:
            body.is_stationary()  # → false
        """
        return not self.is_moving()

    pub fn is_rotating(self) -> bool:
        """Check if body is rotating.

        Returns:
            true if angular velocity != 0

        Example:
            body.is_rotating()  # → false
        """
        val av = self.get_angular_velocity()
        return av.abs() > 0.01

    pub fn stop(mut self):
        """Stop all motion (zero velocity).

        Example:
            body.stop()
        """
        self.set_linear_velocity(0.0, 0.0)
        self.set_angular_velocity(0.0)

    pub fn apply_push(mut self, x: f64, y: f64):
        """Apply push impulse (convenience for apply_central_impulse).

        Args:
            x: Impulse x component
            y: Impulse y component

        Example:
            body.apply_push(100.0, -50.0)
        """
        self.apply_central_impulse(x, y)

    pub fn summary(self) -> text:
        """Get rigid body 2D summary.

        Returns:
            Human-readable summary

        Example:
            body.summary()
            # → "RigidBody2D: moving, speed=150.5, mass=10.0"
        """
        val state = if self.is_moving() { "moving" } else { "stationary" }
        val speed = self.get_speed()
        val mass = self.get_mass()
        return "RigidBody2D: {state}, speed={speed}, mass={mass}"

# CharacterBody2D - Kinematic body for player control
pub struct CharacterBody2D:
    base: node2d.Node2D

impl CharacterBody2D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> CharacterBody2D:
        return CharacterBody2D(base: node2d.Node2D.from_ptr(ptr))

    # Velocity
    pub fn get_velocity(self) -> (f64, f64):
        val result = self.base.as_node().as_object().call0("get_velocity")
        return result.as_vector2()

    pub fn set_velocity(mut self, x: f64, y: f64):
        val vel = variant.Variant.from_vector2(x, y)
        self.base.as_node().as_object().call1("set_velocity", vel)

    # Move and collide
    pub fn move_and_slide(mut self):
        self.base.as_node().as_object().call0("move_and_slide")

    # Collision detection
    pub fn is_on_floor(self) -> bool:
        val result = self.base.as_node().as_object().call0("is_on_floor")
        return result.as_bool()

    pub fn is_on_ceiling(self) -> bool:
        val result = self.base.as_node().as_object().call0("is_on_ceiling")
        return result.as_bool()

    pub fn is_on_wall(self) -> bool:
        val result = self.base.as_node().as_object().call0("is_on_wall")
        return result.as_bool()

    pub fn get_floor_normal(self) -> (f64, f64):
        val result = self.base.as_node().as_object().call0("get_floor_normal")
        return result.as_vector2()

    # Collision count
    pub fn get_slide_collision_count(self) -> i64:
        val result = self.base.as_node().as_object().call0("get_slide_collision_count")
        return result.as_int()

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn get_speed(self) -> f64:
        """Get current speed (magnitude of velocity).

        Returns:
            Speed in pixels/second

        Example:
            body.get_speed()  # → 200.0
        """
        val (vx, vy) = self.get_velocity()
        return (vx * vx + vy * vy).sqrt()

    pub fn is_moving(self) -> bool:
        """Check if body is moving.

        Returns:
            true if speed > 0.01

        Example:
            body.is_moving()  # → true
        """
        return self.get_speed() > 0.01

    pub fn is_stationary(self) -> bool:
        """Check if body is stationary (not moving).

        Returns:
            true if speed <= 0.01

        Example:
            body.is_stationary()  # → false
        """
        return not self.is_moving()

    pub fn is_grounded(self) -> bool:
        """Check if body is on floor (alias for is_on_floor).

        Returns:
            true if on floor

        Example:
            body.is_grounded()  # → true
        """
        return self.is_on_floor()

    pub fn is_in_air(self) -> bool:
        """Check if body is in air (not on floor).

        Returns:
            true if not on floor

        Example:
            body.is_in_air()  # → false
        """
        return not self.is_on_floor()

    pub fn has_collisions(self) -> bool:
        """Check if body has any slide collisions.

        Returns:
            true if collision count > 0

        Example:
            body.has_collisions()  # → true
        """
        return self.get_slide_collision_count() > 0

    pub fn stop(mut self):
        """Stop all motion (zero velocity).

        Example:
            body.stop()
        """
        self.set_velocity(0.0, 0.0)

    pub fn summary(self) -> text:
        """Get character body 2D summary.

        Returns:
            Human-readable summary

        Example:
            body.summary()
            # → "CharacterBody2D: moving, speed=200.0, grounded, 2 collisions"
        """
        val state = if self.is_moving() { "moving" } else { "stationary" }
        val speed = self.get_speed()
        val ground = if self.is_grounded() { "grounded" } else { "in air" }
        val collisions = self.get_slide_collision_count()
        return "CharacterBody2D: {state}, speed={speed}, {ground}, {collisions} collisions"

# RigidBody3D - 3D dynamic physics
pub struct RigidBody3D:
    base: node3d.Node3D

impl RigidBody3D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> RigidBody3D:
        return RigidBody3D(base: node3d.Node3D.from_ptr(ptr))

    # Linear velocity
    pub fn get_linear_velocity(self) -> (f64, f64, f64):
        val result = self.base.as_node().as_object().call0("get_linear_velocity")
        return result.as_vector3()

    pub fn set_linear_velocity(mut self, x: f64, y: f64, z: f64):
        val vel = variant.Variant.from_vector3(x, y, z)
        self.base.as_node().as_object().call1("set_linear_velocity", vel)

    # Angular velocity
    pub fn get_angular_velocity(self) -> (f64, f64, f64):
        val result = self.base.as_node().as_object().call0("get_angular_velocity")
        return result.as_vector3()

    pub fn set_angular_velocity(mut self, x: f64, y: f64, z: f64):
        val vel = variant.Variant.from_vector3(x, y, z)
        self.base.as_node().as_object().call1("set_angular_velocity", vel)

    # Mass
    pub fn get_mass(self) -> f64:
        val result = self.base.as_node().as_object().call0("get_mass")
        return result.as_float()

    pub fn set_mass(mut self, mass: f64):
        val mass_var = variant.Variant.from_float(mass)
        self.base.as_node().as_object().call1("set_mass", mass_var)

    # Apply forces (3D)
    pub fn apply_central_impulse(mut self, x: f64, y: f64, z: f64):
        val impulse = variant.Variant.from_vector3(x, y, z)
        self.base.as_node().as_object().call1("apply_central_impulse", impulse)

    pub fn apply_force(mut self, force_x: f64, force_y: f64, force_z: f64):
        val force = variant.Variant.from_vector3(force_x, force_y, force_z)
        self.base.as_node().as_object().call1("apply_central_force", force)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn get_speed(self) -> f64:
        """Get current speed (magnitude of velocity).

        Returns:
            Speed in units/second

        Example:
            body.get_speed()  # → 12.5
        """
        val (vx, vy, vz) = self.get_linear_velocity()
        return (vx * vx + vy * vy + vz * vz).sqrt()

    pub fn is_moving(self) -> bool:
        """Check if body is moving.

        Returns:
            true if speed > 0.01

        Example:
            body.is_moving()  # → true
        """
        return self.get_speed() > 0.01

    pub fn is_stationary(self) -> bool:
        """Check if body is stationary (not moving).

        Returns:
            true if speed <= 0.01

        Example:
            body.is_stationary()  # → false
        """
        return not self.is_moving()

    pub fn is_rotating(self) -> bool:
        """Check if body is rotating.

        Returns:
            true if angular velocity magnitude > 0.01

        Example:
            body.is_rotating()  # → false
        """
        val (ax, ay, az) = self.get_angular_velocity()
        val mag = (ax * ax + ay * ay + az * az).sqrt()
        return mag > 0.01

    pub fn stop(mut self):
        """Stop all motion (zero velocity).

        Example:
            body.stop()
        """
        self.set_linear_velocity(0.0, 0.0, 0.0)
        self.set_angular_velocity(0.0, 0.0, 0.0)

    pub fn apply_push(mut self, x: f64, y: f64, z: f64):
        """Apply push impulse (convenience for apply_central_impulse).

        Args:
            x: Impulse x component
            y: Impulse y component
            z: Impulse z component

        Example:
            body.apply_push(10.0, 5.0, 0.0)
        """
        self.apply_central_impulse(x, y, z)

    pub fn summary(self) -> text:
        """Get rigid body 3D summary.

        Returns:
            Human-readable summary

        Example:
            body.summary()
            # → "RigidBody3D: moving, speed=12.5, mass=5.0"
        """
        val state = if self.is_moving() { "moving" } else { "stationary" }
        val speed = self.get_speed()
        val mass = self.get_mass()
        return "RigidBody3D: {state}, speed={speed}, mass={mass}"

# CharacterBody3D - 3D kinematic body
pub struct CharacterBody3D:
    base: node3d.Node3D

impl CharacterBody3D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> CharacterBody3D:
        return CharacterBody3D(base: node3d.Node3D.from_ptr(ptr))

    # Velocity
    pub fn get_velocity(self) -> (f64, f64, f64):
        val result = self.base.as_node().as_object().call0("get_velocity")
        return result.as_vector3()

    pub fn set_velocity(mut self, x: f64, y: f64, z: f64):
        val vel = variant.Variant.from_vector3(x, y, z)
        self.base.as_node().as_object().call1("set_velocity", vel)

    # Move and collide
    pub fn move_and_slide(mut self):
        self.base.as_node().as_object().call0("move_and_slide")

    # Collision checks
    pub fn is_on_floor(self) -> bool:
        val result = self.base.as_node().as_object().call0("is_on_floor")
        return result.as_bool()

    pub fn is_on_ceiling(self) -> bool:
        val result = self.base.as_node().as_object().call0("is_on_ceiling")
        return result.as_bool()

    pub fn is_on_wall(self) -> bool:
        val result = self.base.as_node().as_object().call0("is_on_wall")
        return result.as_bool()

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn get_speed(self) -> f64:
        """Get current speed (magnitude of velocity).

        Returns:
            Speed in units/second

        Example:
            body.get_speed()  # → 8.5
        """
        val (vx, vy, vz) = self.get_velocity()
        return (vx * vx + vy * vy + vz * vz).sqrt()

    pub fn is_moving(self) -> bool:
        """Check if body is moving.

        Returns:
            true if speed > 0.01

        Example:
            body.is_moving()  # → true
        """
        return self.get_speed() > 0.01

    pub fn is_stationary(self) -> bool:
        """Check if body is stationary (not moving).

        Returns:
            true if speed <= 0.01

        Example:
            body.is_stationary()  # → false
        """
        return not self.is_moving()

    pub fn is_grounded(self) -> bool:
        """Check if body is on floor (alias for is_on_floor).

        Returns:
            true if on floor

        Example:
            body.is_grounded()  # → true
        """
        return self.is_on_floor()

    pub fn is_in_air(self) -> bool:
        """Check if body is in air (not on floor).

        Returns:
            true if not on floor

        Example:
            body.is_in_air()  # → false
        """
        return not self.is_on_floor()

    pub fn stop(mut self):
        """Stop all motion (zero velocity).

        Example:
            body.stop()
        """
        self.set_velocity(0.0, 0.0, 0.0)

    pub fn summary(self) -> text:
        """Get character body 3D summary.

        Returns:
            Human-readable summary

        Example:
            body.summary()
            # → "CharacterBody3D: moving, speed=8.5, grounded"
        """
        val state = if self.is_moving() { "moving" } else { "stationary" }
        val speed = self.get_speed()
        val ground = if self.is_grounded() { "grounded" } else { "in air" }
        return "CharacterBody3D: {state}, speed={speed}, {ground}"

# Area2D - Collision detection without physics
pub struct Area2D:
    base: node2d.Node2D

impl Area2D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> Area2D:
        return Area2D(base: node2d.Node2D.from_ptr(ptr))

    # Overlapping bodies
    pub fn get_overlapping_bodies(self) -> Array<node.Node>:
        val result = self.base.as_node().as_object().call0("get_overlapping_bodies")
        # Convert array variant to Array<Node>
        var nodes: Array<node.Node> = Array<node.Node>.new()
        val array_size = result.call0("size").as_int()
        for i in 0..array_size:
            val idx_var = variant.Variant.from_int(i)
            val element = result.call1("get", idx_var)
            val node_ptr = element.as_object_ptr()
            if not node_ptr.is_null():
                nodes.push(node.Node.from_ptr(node_ptr))
        return nodes

    pub fn overlaps_body(self, body: node.Node) -> bool:
        val body_var = variant.Variant.from_object(body.ptr())
        val result = self.base.as_node().as_object().call1("overlaps_body", body_var)
        return result.as_bool()

    # Monitoring
    pub fn set_monitoring(mut self, enable: bool):
        val enable_var = variant.Variant.from_bool(enable)
        self.base.as_node().as_object().call1("set_monitoring", enable_var)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_overlapping_bodies(self) -> bool:
        """Check if area has any overlapping bodies.

        Returns:
            true if has overlapping bodies

        Example:
            area.has_overlapping_bodies()  # → true
        """
        val bodies = self.get_overlapping_bodies()
        return bodies.len() > 0

    pub fn is_empty(self) -> bool:
        """Check if area has no overlapping bodies.

        Returns:
            true if no overlapping bodies

        Example:
            area.is_empty()  # → false
        """
        return not self.has_overlapping_bodies()

    pub fn enable_monitoring(mut self):
        """Enable monitoring (convenience for set_monitoring(true)).

        Example:
            area.enable_monitoring()
        """
        self.set_monitoring(true)

    pub fn disable_monitoring(mut self):
        """Disable monitoring (convenience for set_monitoring(false)).

        Example:
            area.disable_monitoring()
        """
        self.set_monitoring(false)

    pub fn summary(self) -> text:
        """Get area 2D summary.

        Returns:
            Human-readable summary

        Example:
            area.summary()
            # → "Area2D: 3 overlapping bodies"
        """
        val count = self.get_overlapping_bodies().len()
        return "Area2D: {count} overlapping bodies"

# Collision shape helper
pub struct CollisionShape2D:
    base: node2d.Node2D

impl CollisionShape2D:
    pub fn from_ptr(ptr: ffi.GDExtensionObjectPtr) -> CollisionShape2D:
        return CollisionShape2D(base: node2d.Node2D.from_ptr(ptr))

    # Set shape (requires Shape2D resource)
    pub fn set_shape(mut self, shape_ptr: ffi.GDExtensionObjectPtr):
        val shape_var = variant.Variant.from_object(shape_ptr)
        self.base.as_node().as_object().call1("set_shape", shape_var)

    # Disable shape
    pub fn set_disabled(mut self, disabled: bool):
        val disabled_var = variant.Variant.from_bool(disabled)
        self.base.as_node().as_object().call1("set_disabled", disabled_var)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn enable(mut self):
        """Enable collision shape (convenience for set_disabled(false)).

        Example:
            shape.enable()
        """
        self.set_disabled(false)

    pub fn disable(mut self):
        """Disable collision shape (convenience for set_disabled(true)).

        Example:
            shape.disable()
        """
        self.set_disabled(true)

    pub fn summary(self) -> text:
        """Get collision shape 2D summary.

        Returns:
            Human-readable summary

        Example:
            shape.summary()
            # → "CollisionShape2D: enabled"
        """
        return "CollisionShape2D: enabled"
