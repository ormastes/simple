# Grammar Expressions
#
# Expression rules: binary, unary, call, index, literals, etc.

use simple_grammar.{Grammar}
use tokens.{TokenKind, token, ref, seq, choice, optional, field, repeat, prec_left, prec_right, # Core keywords Fn, If, Then, Else, Match, True, False, Nil, And, Or, Not, To, NotTo, # Operators - Arithmetic Plus, Minus, Star, Slash, Percent, DoubleStar, DoubleSlash, # Operators - Comparison DoubleEq, NotEq, Lt, Gt, LtEq, GtEq, # Operators - Assignment Assign, PlusAssign, MinusAssign, StarAssign, SlashAssign, TildeAssign, TildePlusAssign, TildeMinusAssign, TildeStarAssign, TildeSlashAssign, # Operators - Bitwise Pipe, Ampersand, Caret, Tilde, LtLt, GtGt, DoublePipe, DoubleAmp, # Operators - Special DoubleDot, DoubleDotEq, FatArrow, ChannelArrow, DoubleColon, # Suspension AndSuspend, OrSuspend, # Delimiters LParen, RParen, LBracket, RBracket, LBrace, RBrace, Comma, Colon, Dot, Backslash, # Literals Integer, Float, TypedInteger, TypedFloat, text, RawString, Symbol, TypedString, TypedRawString, FStringStart, FStringText, FStringEnd, FStringFormatSpec, # Special tokens CustomBlock, Pointcut}

export add_expression_rules

# Add all expression rules to grammar
fn add_expression_rules(grammar: Grammar):
    # Expressions (Pratt parser priorities)
    grammar.add_rule("expression", choice([
        ref("binary_expr"),
        ref("unary_expr"),
        ref("call_expr"),
        ref("static_call_expr"),
        ref("index_expr"),
        ref("field_expr"),
        ref("lambda_expr"),
        ref("if_expr"),
        ref("match_expr"),
        ref("custom_block_expr"),
        ref("pointcut_expr"),
        ref("primary_expr")
    ]))

    # Binary expressions
    grammar.add_rule("binary_expr", prec_left(1, seq([
        field("left", ref("expression")),
        field("operator", choice([
            # Arithmetic
            token(Plus), token(Minus), token(Star), token(Slash),
            token(Percent), token(DoubleStar), token(DoubleSlash),
            # Comparison
            token(DoubleEq), token(NotEq),
            token(Lt), token(Gt), token(LtEq), token(GtEq),
            # Logical
            token(And), token(Or), token(DoublePipe), token(DoubleAmp),
            # Bitwise
            token(Pipe), token(Ampersand), token(Caret),
            token(LtLt), token(GtGt),
            # Range
            token(DoubleDot), token(DoubleDotEq),
            # Assignment
            token(Assign),
            token(PlusAssign), token(MinusAssign), token(StarAssign), token(SlashAssign),
            token(TildeAssign), token(TildePlusAssign), token(TildeMinusAssign),
            token(TildeStarAssign), token(TildeSlashAssign),
            # Suspension
            token(AndSuspend), token(OrSuspend),
            # Special
            token(FatArrow), token(ChannelArrow),
            # Infix keywords
            token(To), token(NotTo)
        ])),
        field("right", ref("expression"))
    ])))

    # Unary expressions
    grammar.add_rule("unary_expr", prec_right(2, seq([
        field("operator", choice([
            token(Minus), token(Not), token(Tilde)
        ])),
        field("operand", ref("expression"))
    ])))

    # Call expression
    grammar.add_rule("call_expr", prec_left(3, seq([
        field("callee", ref("expression")),
        token(LParen),
        optional(ref("argument_list")),
        token(RParen)
    ]))

    # Static method call: Type.method() or Type.method() (dot preferred)
    grammar.add_rule("static_call_expr", prec_left(3, seq([
        field("type", ref("type_identifier")),
        choice([token(DoubleColon), token(Dot)]),
        field("method", ref("identifier")),
        token(LParen),
        optional(ref("argument_list")),
        token(RParen)
    ])))

    # Argument list
    grammar.add_rule("argument_list", seq([
        ref("expression"),
        repeat(seq([token(Comma), ref("expression")]))
    ]))

    # Index expression
    grammar.add_rule("index_expr", prec_left(3, seq([
        field("value", ref("expression")),
        token(LBracket),
        field("index", ref("expression")),
        token(RBracket)
    ])))

    # Field expression
    grammar.add_rule("field_expr", prec_left(3, seq([
        field("value", ref("expression")),
        token(Dot),
        field("field", ref("identifier"))
    ])))

    # Lambda expressions (multiple syntaxes)
    grammar.add_rule("lambda_expr", choice([
        ref("fn_lambda"),      # fn(): expr or fn(x, y): expr
        ref("backslash_lambda"),  # \x: expr or \x, y: expr
        ref("pipe_lambda")     # |x| expr (Ruby/Rust style)
    ]))

    # Fn lambda: fn(): expr or fn(x, y): expr
    grammar.add_rule("fn_lambda", seq([
        token(Fn),
        token(LParen),
        optional(ref("parameter_list")),
        token(RParen),
        token(Colon),
        choice([
            ref("expression"),
            ref("block")
        ])
    ]))

    # Backslash lambda: \x: expr or \x, y: expr or \: expr
    grammar.add_rule("backslash_lambda", seq([
        token(Backslash),
        optional(ref("parameter_list")),
        token(Colon),
        choice([
            ref("expression"),
            ref("block")
        ])
    ]))

    # Pipe lambda: |x| expr or |x, y| expr
    grammar.add_rule("pipe_lambda", seq([
        token(Pipe),
        optional(ref("parameter_list")),
        token(Pipe),
        choice([
            ref("expression"),
            seq([token(Colon), ref("block")])
        ])
    ]))

    # If expression
    grammar.add_rule("if_expr", seq([
        token(If),
        field("condition", ref("expression")),
        token(Then),
        field("then_value", ref("expression")),
        token(Else),
        field("else_value", ref("expression"))
    ]))

    # Match expression
    grammar.add_rule("match_expr", seq([
        token(Match),
        field("value", ref("expression")),
        token(Colon),
        ref("match_expr_block")
    ]))

    # Match expression block (inline)
    grammar.add_rule("match_expr_block", seq([
        token(LBrace),
        ref("match_case"),
        repeat(seq([token(Comma), ref("match_case")])),
        optional(token(Comma)),
        token(RBrace)
    ]))

    # Custom block expression: m{...}, sh{...}, sql{...}, etc.
    grammar.add_rule("custom_block_expr", token(CustomBlock))

    # Pointcut expression: pc{...}
    grammar.add_rule("pointcut_expr", token(Pointcut))

    # Primary expressions
    grammar.add_rule("primary_expr", choice([
        ref("literal"),
        ref("identifier"),
        ref("array_literal"),
        ref("tuple_literal"),
        ref("dict_literal"),
        ref("struct_literal"),
        ref("paren_expr")
    ]))

    # Add literal rules
    add_literal_rules(grammar)

    # Expression list
    grammar.add_rule("expression_list", seq([
        ref("expression"),
        repeat(seq([token(Comma), ref("expression")])),
        optional(token(Comma))
    ]))

# Add literal rules
fn add_literal_rules(grammar: Grammar):
    # Literals
    grammar.add_rule("literal", choice([
        ref("integer_literal"),
        ref("typed_integer_literal"),
        ref("float_literal"),
        ref("typed_float_literal"),
        ref("string_literal"),
        ref("raw_string_literal"),
        ref("symbol_literal"),
        ref("typed_string_literal"),
        ref("typed_raw_string_literal"),
        ref("fstring_literal"),
        ref("boolean_literal"),
        ref("nil_literal")
    ]))

    grammar.add_rule("integer_literal", token(Integer))
    grammar.add_rule("typed_integer_literal", token(TypedInteger))
    grammar.add_rule("float_literal", token(Float))
    grammar.add_rule("typed_float_literal", token(TypedFloat))
    grammar.add_rule("string_literal", token(text))
    grammar.add_rule("raw_string_literal", token(RawString))
    grammar.add_rule("symbol_literal", token(Symbol))
    grammar.add_rule("typed_string_literal", token(TypedString))
    grammar.add_rule("typed_raw_string_literal", token(TypedRawString))

    # F-string literal
    grammar.add_rule("fstring_literal", seq([
        token(FStringStart),
        repeat(choice([
            token(FStringText),
            ref("fstring_interpolation")
        ])),
        token(FStringEnd)
    ]))

    grammar.add_rule("fstring_interpolation", seq([
        token(LBrace),
        ref("expression"),
        optional(seq([token(Colon), ref("format_spec")])),
        token(RBrace)
    ]))

    grammar.add_rule("format_spec", token(FStringFormatSpec))

    grammar.add_rule("boolean_literal", choice([
        token(True),
        token(False)
    ]))

    grammar.add_rule("nil_literal", token(Nil))

    # Array literal
    grammar.add_rule("array_literal", seq([
        token(LBracket),
        optional(ref("expression_list")),
        token(RBracket)
    ]))

    # Tuple literal
    grammar.add_rule("tuple_literal", seq([
        token(LParen),
        ref("expression"),
        token(Comma),
        optional(ref("expression_list")),
        token(RParen)
    ]))

    # Dict literal
    grammar.add_rule("dict_literal", seq([
        token(LBrace),
        optional(ref("dict_entry_list")),
        token(RBrace)
    ]))

    grammar.add_rule("dict_entry_list", seq([
        ref("dict_entry"),
        repeat(seq([token(Comma), ref("dict_entry")])),
        optional(token(Comma))
    ]))

    grammar.add_rule("dict_entry", seq([
        field("key", ref("expression")),
        token(Colon),
        field("value", ref("expression"))
    ]))

    # Struct literal
    grammar.add_rule("struct_literal", seq([
        field("name", ref("type_identifier")),
        token(LParen),
        optional(ref("field_init_list")),
        token(RParen)
    ]))

    grammar.add_rule("field_init_list", seq([
        ref("field_init"),
        repeat(seq([token(Comma), ref("field_init")])),
        optional(token(Comma))
    ]))

    grammar.add_rule("field_init", seq([
        field("name", ref("identifier")),
        token(Colon),
        field("value", ref("expression"))
    ]))

    # Parenthesized expression
    grammar.add_rule("paren_expr", seq([
        token(LParen),
        ref("expression"),
        token(RParen)
    ]))
