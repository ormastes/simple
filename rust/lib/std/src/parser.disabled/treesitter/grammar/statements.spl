# Grammar Statements
#
# Statement rules: val, return, if, match, for, while, loop, etc.

use simple_grammar.{Grammar}
use tokens.{TokenKind, token, ref, seq, choice, optional, field, repeat, # Variable keywords Val, Var, Let, Mut, Const, Static, Type, Where, # Control flow Return, If, Elif, Else, Match, Case, For, In, While, Loop, Break, Continue, # Contract keywords Requires, Ensures, Out, OutErr, Invariant, Decreases, Old, Result, Forall, Exists, Assert, Assume, Admit, Calc, # Operators Colon, Assign, TildeAssign, Comma, LParen, RParen, DoubleEq, Lt, Gt, LtEq, GtEq, # Delimiters Newline, Indent, Dedent}

export add_statement_rules

# Add all statement rules to grammar
fn add_statement_rules(grammar: Grammar):
    # Statements
    grammar.add_rule("statement", choice([
        # Variable declarations
        ref("val_stmt"),
        ref("var_stmt"),
        ref("let_stmt"),  # Legacy support
        ref("const_stmt"),
        ref("static_stmt"),
        ref("type_alias_stmt"),
        # Control flow
        ref("return_stmt"),
        ref("if_stmt"),
        ref("match_stmt"),
        ref("for_stmt"),
        ref("while_stmt"),
        ref("loop_stmt"),
        ref("break_stmt"),
        ref("continue_stmt"),
        # Contracts & Verification
        ref("requires_stmt"),
        ref("ensures_stmt"),
        ref("out_stmt"),
        ref("out_err_stmt"),
        ref("invariant_stmt"),
        ref("decreases_stmt"),
        ref("assert_stmt"),
        ref("assume_stmt"),
        ref("admit_stmt"),
        ref("calc_block"),
        ref("forall_stmt"),
        ref("exists_stmt"),
        # Expression
        ref("expression_stmt")
    ]))

    # Val statement (immutable variable, Scala-style)
    grammar.add_rule("val_stmt", seq([
        token(Val),
        field("pattern", ref("pattern")),
        optional(seq([token(Colon), field("type", ref("type"))])),
        choice([token(Assign), token(TildeAssign)]),
        field("value", ref("expression")),
        token(Newline)
    ]))

    # Var statement (mutable variable, Scala-style)
    grammar.add_rule("var_stmt", seq([
        token(Var),
        field("pattern", ref("pattern")),
        optional(seq([token(Colon), field("type", ref("type"))])),
        choice([token(Assign), token(TildeAssign)]),
        field("value", ref("expression")),
        token(Newline)
    ]))

    # Let statement (legacy support)
    grammar.add_rule("let_stmt", seq([
        token(Let),
        optional(token(Mut)),
        field("pattern", ref("pattern")),
        optional(seq([token(Colon), field("type", ref("type"))])),
        choice([token(Assign), token(TildeAssign)]),
        field("value", ref("expression")),
        token(Newline)
    ]))

    # Const statement
    grammar.add_rule("const_stmt", seq([
        token(Const),
        field("name", ref("identifier")),
        optional(seq([token(Colon), field("type", ref("type"))])),
        token(Assign),
        field("value", ref("expression")),
        token(Newline)
    ]))

    # Static statement
    grammar.add_rule("static_stmt", seq([
        token(Static),
        optional(token(Mut)),
        field("name", ref("identifier")),
        optional(seq([token(Colon), field("type", ref("type"))])),
        token(Assign),
        field("value", ref("expression")),
        token(Newline)
    ]))

    # Type alias statement
    grammar.add_rule("type_alias_stmt", seq([
        token(Type),
        field("name", ref("type_identifier")),
        token(Assign),
        field("type", ref("type")),
        optional(seq([token(Where), field("predicate", ref("expression"))])),
        token(Newline)
    ]))

    # Return statement
    grammar.add_rule("return_stmt", seq([
        token(Return),
        optional(ref("expression")),
        token(Newline)
    ]))

    # If statement
    grammar.add_rule("if_stmt", seq([
        token(If),
        field("condition", ref("expression")),
        token(Colon),
        ref("block"),
        repeat(ref("elif_clause")),
        optional(ref("else_clause"))
    ]))

    # Elif clause
    grammar.add_rule("elif_clause", seq([
        token(Elif),
        field("condition", ref("expression")),
        token(Colon),
        ref("block")
    ]))

    # Else clause
    grammar.add_rule("else_clause", seq([
        token(Else),
        token(Colon),
        ref("block")
    ]))

    # Match statement
    grammar.add_rule("match_stmt", seq([
        token(Match),
        field("value", ref("expression")),
        token(Colon),
        ref("match_block")
    ]))

    # Match block
    grammar.add_rule("match_block", seq([
        token(Newline),
        token(Indent),
        repeat(ref("match_case")),
        token(Dedent)
    ]))

    # Match case
    grammar.add_rule("match_case", seq([
        token(Case),
        field("pattern", ref("pattern")),
        optional(seq([token(If), field("guard", ref("expression"))])),
        token(Colon),
        choice([
            seq([ref("expression"), token(Newline)]),
            ref("block")
        ])
    ]))

    # For statement
    grammar.add_rule("for_stmt", seq([
        token(For),
        field("pattern", ref("pattern")),
        token(In),
        field("iterable", ref("expression")),
        token(Colon),
        ref("block")
    ]))

    # While statement
    grammar.add_rule("while_stmt", seq([
        token(While),
        field("condition", ref("expression")),
        token(Colon),
        ref("block")
    ]))

    # Loop statement
    grammar.add_rule("loop_stmt", seq([
        token(Loop),
        token(Colon),
        ref("block")
    ]))

    # Break statement
    grammar.add_rule("break_stmt", seq([
        token(Break),
        token(Newline)
    ]))

    # Continue statement
    grammar.add_rule("continue_stmt", seq([
        token(Continue),
        token(Newline)
    ]))

    # Assert statement
    grammar.add_rule("assert_stmt", seq([
        token(Assert),
        field("condition", ref("expression")),
        optional(seq([token(Comma), field("message", ref("expression"))])),
        token(Newline)
    ]))

    # Assume statement (verification)
    grammar.add_rule("assume_stmt", seq([
        token(Assume),
        field("condition", ref("expression")),
        optional(seq([token(Comma), field("reason", ref("expression"))])),
        token(Newline)
    ]))

    # Expression statement
    grammar.add_rule("expression_stmt", seq([
        ref("expression"),
        token(Newline)
    ]))

    # Block
    grammar.add_rule("block", seq([
        token(Newline),
        token(Indent),
        repeat(choice([
            ref("statement"),
            token(Newline)
        ])),
        token(Dedent)
    ]))

    # ========================================================================
    # Contract & Verification Statements
    # ========================================================================

    # Requires statement (precondition): requires expr
    grammar.add_rule("requires_stmt", seq([
        token(Requires),
        token(Colon),
        field("condition", ref("expression")),
        optional(seq([token(Comma), field("message", ref("expression"))])),
        token(Newline)
    ]))

    # Ensures statement (postcondition): ensures expr
    grammar.add_rule("ensures_stmt", seq([
        token(Ensures),
        token(Colon),
        field("condition", ref("expression")),
        optional(seq([token(Comma), field("message", ref("expression"))])),
        token(Newline)
    ]))

    # Out block (postcondition): out(ret):
    grammar.add_rule("out_stmt", seq([
        token(Out),
        token(LParen),
        field("result_binding", ref("identifier")),
        token(RParen),
        token(Colon),
        choice([
            seq([ref("expression"), token(Newline)]),
            ref("block")
        ])
    ]))

    # Out err block (error postcondition): out_err(err):
    grammar.add_rule("out_err_stmt", seq([
        token(OutErr),
        token(LParen),
        field("error_binding", ref("identifier")),
        token(RParen),
        token(Colon),
        choice([
            seq([ref("expression"), token(Newline)]),
            ref("block")
        ])
    ]))

    # Invariant statement: invariant expr
    grammar.add_rule("invariant_stmt", seq([
        token(Invariant),
        token(Colon),
        field("condition", ref("expression")),
        optional(seq([token(Comma), field("message", ref("expression"))])),
        token(Newline)
    ]))

    # Decreases statement (termination measure): decreases expr
    grammar.add_rule("decreases_stmt", seq([
        token(Decreases),
        token(Colon),
        field("measure", ref("expression")),
        token(Newline)
    ]))

    # Admit statement (skip proof): admit expr, "reason"
    grammar.add_rule("admit_stmt", seq([
        token(Admit),
        field("condition", ref("expression")),
        optional(seq([token(Comma), field("reason", ref("expression"))])),
        token(Newline)
    ]))

    # Calc block (calculational proof): calc:
    grammar.add_rule("calc_block", seq([
        token(Calc),
        token(Colon),
        ref("calc_steps")
    ]))

    # Calc steps
    grammar.add_rule("calc_steps", seq([
        token(Newline),
        token(Indent),
        repeat(ref("calc_step")),
        token(Dedent)
    ]))

    # Calc step: expr == expr
    grammar.add_rule("calc_step", seq([
        field("left", ref("expression")),
        field("operator", choice([
            token(DoubleEq), token(Lt), token(Gt), token(LtEq), token(GtEq)
        ])),
        field("right", ref("expression")),
        optional(seq([token(Comma), field("reason", ref("expression"))])),
        token(Newline)
    ]))

    # Forall quantifier: forall x in range: predicate
    grammar.add_rule("forall_stmt", seq([
        token(Forall),
        field("variable", ref("identifier")),
        token(In),
        field("range", ref("expression")),
        token(Colon),
        field("predicate", ref("expression")),
        token(Newline)
    ]))

    # Exists quantifier: exists x in range: predicate
    grammar.add_rule("exists_stmt", seq([
        token(Exists),
        field("variable", ref("identifier")),
        token(In),
        field("range", ref("expression")),
        token(Colon),
        field("predicate", ref("expression")),
        token(Newline)
    ]))
