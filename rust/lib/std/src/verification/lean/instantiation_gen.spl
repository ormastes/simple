# Instantiation Function Generator for Lean Code Generation
#
# Generates Lean instantiation functions for generic types.
# Part of Phase 7.2: Auto-generation of instantiation functions.
#
# Pattern: For a generic type with type parameters, generates:
#   - `instantiateX (x : XDef) (typeArgs : List Ty) : Option XDef`
#   - Applies type substitution to all fields containing type parameters
#
# Key principle: Generate scaffolding, not proofs. Never introduce `sorry` or `axiom`.

use verification.lean.naming as naming

# Field that needs type substitution
class SubstitutableField:
    name: text            # Field name in the structure
    is_direct: bool       # True if field is directly a type parameter
    is_list_of_types: bool  # True if field is List<Ty> or similar
    has_type_fields: bool   # True if field is a struct with .ty fields

    static fn direct(name: text) -> SubstitutableField:
        SubstitutableField(name, true, false, false)

    static fn list_of_types(name: text) -> SubstitutableField:
        SubstitutableField(name, false, true, false)

    static fn has_types(name: text) -> SubstitutableField:
        SubstitutableField(name, false, false, true)

# Definition of a generic type for instantiation
class GenericTypeDef:
    type_name: text                    # e.g., "Class"
    type_params_field: text            # Field containing type params, e.g., "type_params"
    substitutable_fields: List<SubstitutableField>  # Fields needing substitution

    static fn new(type_name: text) -> GenericTypeDef:
        GenericTypeDef(type_name, "type_params", [])

    me with_type_params_field(field: text) -> GenericTypeDef:
        self.type_params_field = field
        self

    me add_direct_field(field: text) -> GenericTypeDef:
        self.substitutable_fields = self.substitutable_fields + [SubstitutableField.direct(field)]
        self

    me add_list_field(field: text) -> GenericTypeDef:
        self.substitutable_fields = self.substitutable_fields + [SubstitutableField.list_of_types(field)]
        self

    me add_nested_field(field: text) -> GenericTypeDef:
        self.substitutable_fields = self.substitutable_fields + [SubstitutableField.has_types(field)]
        self

# Instantiation function generator
class InstantiationGenerator:
    generated_functions: List<text>

    static fn new() -> InstantiationGenerator:
        InstantiationGenerator([])

    # Generate instantiation function
    # Example output:
    # def instantiateClass (cls : ClassDef) (typeArgs : List Ty) : Option ClassDef :=
    #   if cls.type_params.length != typeArgs.length then
    #     none
    #   else
    #     let subst := cls.type_params.zip typeArgs
    #     some {
    #       cls with
    #       type_params := []
    #       fields := cls.fields.map (fun f => { f with ty := applySubst subst f.ty })
    #       ...
    #     }
    me generate_instantiate(generic_def: GenericTypeDef) -> text:
        val pascal_name = naming.to_pascal_case(generic_def.type_name)
        val camel_name = naming.to_camel_case(generic_def.type_name)
        val func_name = "instantiate{pascal_name}"
        val def_name = "{pascal_name}Def"

        self.generated_functions = self.generated_functions + [func_name]

        var out = "def {func_name} ({camel_name} : {def_name}) (typeArgs : List Ty) : Option {def_name} :=\n"
        out = out + "  if {camel_name}.{generic_def.type_params_field}.length != typeArgs.length then\n"
        out = out + "    none\n"
        out = out + "  else\n"
        out = out + "    let subst := {camel_name}.{generic_def.type_params_field}.zip typeArgs\n"
        out = out + "    some \{\n"
        out = out + "      {camel_name} with\n"
        out = out + "      {generic_def.type_params_field} := []\n"

        # Generate field substitutions
        for field in generic_def.substitutable_fields:
            val field_subst = self.generate_field_substitution(camel_name, field)
            out = out + "      {field_subst}\n"

        out = out + "    \}\n"
        out

    # Generate substitution code for a single field
    fn generate_field_substitution(struct_name: text, field: SubstitutableField) -> text:
        if field.is_direct:
            # Direct type field: field := applySubst subst struct.field
            "{field.name} := applySubst subst {struct_name}.{field.name}"
        else if field.is_list_of_types:
            # List of types: field := struct.field.map (applySubst subst)
            "{field.name} := {struct_name}.{field.name}.map (applySubst subst)"
        else:
            # Nested structure with .ty field
            "{field.name} := {struct_name}.{field.name}.map (fun f => \{ f with ty := applySubst subst f.ty \})"

    # Generate applySubst helper if needed
    fn generate_apply_subst_helper() -> text:
        var out = "-- Type substitution helper\n"
        out = out + "def Subst := List (TyVar x Ty)\n\n"
        out = out + "def applySubst (subst : Subst) (ty : Ty) : Ty :=\n"
        out = out + "  match ty with\n"
        out = out + "  | Ty.var v =>\n"
        out = out + "      match subst.find? (fun (v', _) => v == v') with\n"
        out = out + "      | some (_, ty') => ty'\n"
        out = out + "      | none => Ty.var v\n"
        out = out + "  | Ty.arrow params ret =>\n"
        out = out + "      Ty.arrow (params.map (applySubst subst)) (applySubst subst ret)\n"
        out = out + "  | Ty.generic name args =>\n"
        out = out + "      Ty.generic name (args.map (applySubst subst))\n"
        out = out + "  | ty => ty\n"
        out

    # Generate instantiation functions for multiple types
    me generate_all(generic_defs: List<GenericTypeDef>) -> text:
        var out = "-- Auto-generated Lean instantiation functions\n"
        out = out + "-- Generated by instantiation_gen.spl\n\n"

        for def in generic_defs:
            out = out + self.generate_instantiate(def) + "\n"

        out

    # Get generated function names
    fn get_generated_functions() -> List<text>:
        self.generated_functions

# Convenience function to generate standard instantiation for a type
fn generate_standard_instantiation(type_name: text, type_param_fields: List<text>) -> text:
    var def = GenericTypeDef.new(type_name)
    for field in type_param_fields:
        def = def.add_nested_field(field)

    var generator = InstantiationGenerator.new()
    generator.generate_instantiate(def)

# Pre-configured instantiation for ClassDef (common pattern)
fn generate_class_instantiation() -> text:
    var def = GenericTypeDef.new("Class")
    def = def.add_nested_field("fields")   # fields.ty needs substitution
    def = def.add_nested_field("methods")  # methods.self_ty, params, ret need substitution

    var generator = InstantiationGenerator.new()
    generator.generate_instantiate(def)

# Pre-configured instantiation for TraitDef (common pattern)
fn generate_trait_instantiation() -> text:
    var def = GenericTypeDef.new("Trait")
    def = def.add_nested_field("methods")  # methods.self_ty, params, ret need substitution

    var generator = InstantiationGenerator.new()
    generator.generate_instantiate(def)

# Export public API
export SubstitutableField, GenericTypeDef, InstantiationGenerator
export generate_standard_instantiation, generate_class_instantiation, generate_trait_instantiation
