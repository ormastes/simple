# Lean Type Translation
#
# Translates Simple types to Lean 4 syntax:
# - class -> structure
# - enum -> inductive
# - primitive types -> Lean builtins (Int, Bool, String)
# - mixin -> structure with methods
# - subtype -> refinement type

use verification.lean.naming as naming
use verification.lean.emitter as emitter

# Lean type representation
enum LeanType:
    # Primitive Lean type (Int, Nat, Bool, String)
    Primitive(text)
    # Named type reference
    Named(text)
    # Structure definition (name, fields, deriving)
    Structure(text, List<(text, LeanType)>, List<text>)
    # Inductive type definition (enum) (name, variants, deriving)
    Inductive(text, List<(text, List<LeanType>)>, List<text>)
    # Function type (A -> B) (params, result)
    Function(List<LeanType>, LeanType)
    # Optional type (Option A)
    Optional(LeanType)
    # List type (List A)
    ListType(LeanType)
    # Tuple type (A x B)
    Tuple(List<LeanType>)
    # Mixin definition (name, fields, methods, type_params)
    Mixin(text, List<(text, LeanType)>, List<(text, LeanType)>, List<text>)
    # Subtype/Refinement type (name, base_type, predicate)
    Subtype(text, LeanType, text)

impl LeanType:
    # Convert to Lean syntax string
    fn to_lean() -> text:
        match self:
            case LeanType.Primitive(name): name
            case LeanType.Named(name): name
            case LeanType.Structure(name, _, _): name
            case LeanType.Inductive(name, _, _): name
            case LeanType.Mixin(name, _, _, _): name
            case LeanType.Subtype(name, _, _): name
            case LeanType.Function(params, result):
                var parts: List<text> = []
                for p in params:
                    parts = parts + [p.to_lean()]
                parts = parts + [result.to_lean()]
                parts.join(" -> ")
            case LeanType.Optional(inner):
                "Option {inner.to_lean()}"
            case LeanType.ListType(inner):
                "List {inner.to_lean()}"
            case LeanType.Tuple(elems):
                var parts: List<text> = []
                for e in elems:
                    parts = parts + [e.to_lean()]
                "(" + parts.join(" x ") + ")"

    # Emit structure definition
    fn emit_structure() -> Option<text>:
        match self:
            case LeanType.Structure(name, fields, deriving):
                var out = "structure {name} where\n"
                for (field_name, field_type) in fields:
                    out = out + "  {field_name} : {field_type.to_lean()}\n"
                if deriving.len() > 0:
                    val comma = ", "
                    out = out + "deriving " + deriving.join(comma) + "\n"
                Some(out)
            case _:
                nil

    # Emit inductive definition
    fn emit_inductive() -> Option<text>:
        match self:
            case LeanType.Inductive(name, variants, deriving):
                var out = "inductive {name} where\n"
                for (variant_name, variant_types) in variants:
                    if variant_types.len() == 0:
                        out = out + "  | {variant_name} : {name}\n"
                    else:
                        var types_str: List<text> = []
                        for t in variant_types:
                            types_str = types_str + [t.to_lean()]
                        val arrow = " -> "
                        out = out + "  | {variant_name} : " + types_str.join(arrow) + " -> {name}\n"
                if deriving.len() > 0:
                    val comma = ", "
                    out = out + "deriving " + deriving.join(comma) + "\n"
                Some(out)
            case _:
                nil

    # Emit mixin definition
    fn emit_mixin() -> Option<text>:
        match self:
            case LeanType.Mixin(name, fields, methods, type_params):
                var out = ""
                # Generate type parameter list
                var params = ""
                if type_params.len() > 0:
                    var param_strs: List<text> = []
                    for p in type_params:
                        param_strs = param_strs + ["({p} : Type)"]
                    params = " " + param_strs.join(" ")

                out = out + "/-- Mixin: {name} --/\n"
                out = out + "structure {name}{params} where\n"

                # Emit fields
                for (field_name, field_type) in fields:
                    out = out + "  {field_name} : {field_type.to_lean()}\n"

                # Emit method signatures as function fields
                for (method_name, method_type) in methods:
                    out = out + "  {method_name} : {method_type.to_lean()}\n"

                out = out + "deriving Repr\n"
                Some(out)
            case _:
                nil

    # Emit subtype definition
    fn emit_subtype() -> Option<text>:
        match self:
            case LeanType.Subtype(name, base_type, predicate):
                # Build the subtype syntax: {x : Type // predicate}
                val subtype_str = String.from_char_code(123) + "x : " + base_type.to_lean() + " // " + predicate + String.from_char_code(125)
                Some("/-- Refinement type: {name} --/\ndef {name} : Type := " + subtype_str + "\n")
            case _:
                nil

    # Check if this is a primitive type
    fn is_primitive() -> bool:
        match self:
            case LeanType.Primitive(_): true
            case _: false

    # Check if this is a structure
    fn is_structure() -> bool:
        match self:
            case LeanType.Structure(_, _, _): true
            case _: false

    # Check if this is an inductive
    fn is_inductive() -> bool:
        match self:
            case LeanType.Inductive(_, _, _): true
            case _: false

# Simple type representation for translation (high-level)
enum SimpleType:
    IntType
    BoolType
    StringType
    UnitType
    NatType
    FloatType
    ListType(SimpleType)
    OptionType(SimpleType)
    TupleType(List<SimpleType>)
    FunctionType(List<SimpleType>, SimpleType)
    NamedType(text)

impl SimpleType:
    fn to_lean() -> text:
        match self:
            case SimpleType.IntType: "Int"
            case SimpleType.BoolType: "Bool"
            case SimpleType.StringType: "String"
            case SimpleType.UnitType: "Unit"
            case SimpleType.NatType: "Nat"
            case SimpleType.FloatType: "Float"
            case SimpleType.ListType(e): "List ({e.to_lean()})"
            case SimpleType.OptionType(i): "Option ({i.to_lean()})"
            case SimpleType.TupleType(es):
                var parts: List<text> = []
                for e in es:
                    parts = parts + [e.to_lean()]
                "(" + parts.join(" x ") + ")"
            case SimpleType.FunctionType(ps, r):
                var p_strs: List<text> = []
                for p in ps:
                    p_strs = p_strs + [p.to_lean()]
                p_strs = p_strs + [r.to_lean()]
                p_strs.join(" -> ")
            case SimpleType.NamedType(n): n

    fn to_lean_type() -> LeanType:
        match self:
            case SimpleType.IntType: LeanType.Primitive("Int")
            case SimpleType.BoolType: LeanType.Primitive("Bool")
            case SimpleType.StringType: LeanType.Primitive("String")
            case SimpleType.UnitType: LeanType.Primitive("Unit")
            case SimpleType.NatType: LeanType.Primitive("Nat")
            case SimpleType.FloatType: LeanType.Primitive("Float")
            case SimpleType.ListType(e): LeanType.ListType(e.to_lean_type())
            case SimpleType.OptionType(i): LeanType.Optional(i.to_lean_type())
            case SimpleType.TupleType(es):
                var lean_elems: List<LeanType> = []
                for e in es:
                    lean_elems = lean_elems + [e.to_lean_type()]
                LeanType.Tuple(lean_elems)
            case SimpleType.FunctionType(ps, r):
                var lean_params: List<LeanType> = []
                for p in ps:
                    lean_params = lean_params + [p.to_lean_type()]
                LeanType.Function(lean_params, r.to_lean_type())
            case SimpleType.NamedType(n): LeanType.Named(n)

# Field definition
class FieldDef:
    name: text
    field_type: SimpleType
    default_value: Option<text>

    static fn create(name: text, field_type: SimpleType, default_value: Option<text>) -> FieldDef:
        FieldDef(name: name, field_type: field_type, default_value: default_value)

    fn to_lean_decl() -> text:
        "{self.name} : {self.field_type.to_lean()}"

    fn to_lean_pair() -> (text, text):
        (self.name, self.field_type.to_lean())

# Class definition (translates to structure)
class ClassDef:
    name: text
    fields: List<FieldDef>
    deriving: List<text>

    static fn create(name: text, fields: List<FieldDef>, deriving: List<text>) -> ClassDef:
        ClassDef(name: name, fields: fields, deriving: deriving)

    static fn new(name: text) -> ClassDef:
        ClassDef(name: name, fields: [], deriving: ["Repr"])

    me add_field(field: FieldDef) -> ClassDef:
        self.fields = self.fields + [field]
        self

    me with_deriving(derives: List<text>) -> ClassDef:
        self.deriving = derives
        self

    fn to_lean_type() -> LeanType:
        var field_pairs: List<(text, LeanType)> = []
        for f in self.fields:
            field_pairs = field_pairs + [(f.name, f.field_type.to_lean_type())]
        LeanType.Structure(naming.to_pascal_case(self.name), field_pairs, self.deriving)

    fn emit(emit: emitter.LeanEmitter):
        var field_pairs: List<(text, text)> = []
        for f in self.fields:
            field_pairs = field_pairs + [f.to_lean_pair()]
        emit.emit_structure_data(naming.to_pascal_case(self.name), field_pairs, self.deriving)

# Enum variant
class EnumVariant:
    name: text
    params: List<(text, SimpleType)>

    static fn create(name: text, params: List<(text, SimpleType)>) -> EnumVariant:
        EnumVariant(name: name, params: params)

    static fn unit(name: text) -> EnumVariant:
        EnumVariant(name: name, params: [])

    fn to_lean_params() -> List<(text, text)>:
        var result: List<(text, text)> = []
        for (n, t) in self.params:
            result = result + [(n, t.to_lean())]
        result

    fn to_lean_types() -> List<LeanType>:
        var result: List<LeanType> = []
        for (_, t) in self.params:
            result = result + [t.to_lean_type()]
        result

# Enum definition (translates to inductive)
class EnumDef:
    name: text
    variants: List<EnumVariant>
    deriving: List<text>

    static fn create(name: text, variants: List<EnumVariant>, deriving: List<text>) -> EnumDef:
        EnumDef(name: name, variants: variants, deriving: deriving)

    static fn new(name: text) -> EnumDef:
        EnumDef(name: name, variants: [], deriving: ["DecidableEq", "Repr"])

    me add_variant(variant: EnumVariant) -> EnumDef:
        self.variants = self.variants + [variant]
        self

    me with_deriving(derives: List<text>) -> EnumDef:
        self.deriving = derives
        self

    fn to_lean_type() -> LeanType:
        var lean_variants: List<(text, List<LeanType>)> = []
        for v in self.variants:
            lean_variants = lean_variants + [(naming.to_pascal_case(v.name), v.to_lean_types())]
        LeanType.Inductive(naming.to_pascal_case(self.name), lean_variants, self.deriving)

    fn emit(emit: emitter.LeanEmitter):
        var constructors: List<(text, List<text>)> = []
        for v in self.variants:
            var type_strs: List<text> = []
            for (_, t) in v.params:
                type_strs = type_strs + [t.to_lean()]
            constructors = constructors + [(naming.to_pascal_case(v.name), type_strs)]
        emit.emit_inductive_data(naming.to_pascal_case(self.name), constructors, self.deriving)

# Function parameter
class ParamDef:
    name: text
    param_type: SimpleType

    static fn create(name: text, param_type: SimpleType) -> ParamDef:
        ParamDef(name: name, param_type: param_type)

    fn to_lean() -> (text, text):
        (self.name, self.param_type.to_lean())

    fn to_lean_type_pair() -> (text, LeanType):
        (self.name, self.param_type.to_lean_type())

# Function definition
class FunctionDef:
    name: text
    params: List<ParamDef>
    return_type: SimpleType
    body: text
    is_partial: bool

    static fn create(name: text, params: List<ParamDef>, return_type: SimpleType, body: text, is_partial: bool) -> FunctionDef:
        FunctionDef(name: name, params: params, return_type: return_type, body: body, is_partial: is_partial)

    fn emit(emit: emitter.LeanEmitter):
        var param_pairs: List<(text, text)> = []
        for p in self.params:
            param_pairs = param_pairs + [p.to_lean()]
        emit.emit_function_data(
            naming.to_camel_case(self.name),
            param_pairs,
            self.return_type.to_lean(),
            self.body,
            self.is_partial,
            nil,
            true
        )

# Type abbreviation
class AbbrevDef:
    name: text
    type_expr: text

    static fn create(name: text, type_expr: text) -> AbbrevDef:
        AbbrevDef(name: name, type_expr: type_expr)

    fn to_lean() -> text:
        "abbrev {naming.to_pascal_case(self.name)} := {self.type_expr}"

# Type translator for Simple -> Lean conversion
class TypeTranslator:
    # Type mappings from Simple primitives to Lean
    static fn translate_primitive(type_name: text) -> LeanType:
        match type_name:
            case "i32": LeanType.Primitive("Int")
            case "i64": LeanType.Primitive("Int")
            case "u32": LeanType.Primitive("Nat")
            case "u64": LeanType.Primitive("Nat")
            case "f32": LeanType.Primitive("Float")
            case "f64": LeanType.Primitive("Float")
            case "bool": LeanType.Primitive("Bool")
            case "text": LeanType.Primitive("String")
            case "String": LeanType.Primitive("String")
            case "()": LeanType.Primitive("Unit")
            case "Nil": LeanType.Primitive("Unit")
            case _: LeanType.Named(naming.to_pascal_case(type_name))

    # Convert a Simple name to Lean naming convention (PascalCase for types)
    static fn to_lean_name(name: text) -> text:
        naming.to_pascal_case(name)

    # Convert a Simple function name to Lean naming convention (camelCase)
    static fn to_lean_func_name(name: text) -> text:
        naming.to_camel_case(name)

# Convenience functions for creating SimpleType instances
fn make_simple_type(name: text) -> SimpleType:
    SimpleType.NamedType(name)

fn make_int_type() -> SimpleType:
    SimpleType.IntType

fn make_nat_type() -> SimpleType:
    SimpleType.NatType

fn make_bool_type() -> SimpleType:
    SimpleType.BoolType

fn make_string_type() -> SimpleType:
    SimpleType.StringType

fn make_unit_type() -> SimpleType:
    SimpleType.UnitType

fn make_float_type() -> SimpleType:
    SimpleType.FloatType

fn make_list_type(elem: SimpleType) -> SimpleType:
    SimpleType.ListType(elem)

fn make_option_type(inner: SimpleType) -> SimpleType:
    SimpleType.OptionType(inner)

fn make_tuple_type(elems: List<SimpleType>) -> SimpleType:
    SimpleType.TupleType(elems)

fn make_function_type(params: List<SimpleType>, ret: SimpleType) -> SimpleType:
    SimpleType.FunctionType(params, ret)

# Export public API
export LeanType, SimpleType
export FieldDef, ClassDef, EnumVariant, EnumDef, ParamDef, FunctionDef, AbbrevDef
export TypeTranslator
export make_simple_type, make_int_type, make_nat_type, make_bool_type
export make_string_type, make_unit_type, make_float_type
export make_list_type, make_option_type, make_tuple_type, make_function_type
