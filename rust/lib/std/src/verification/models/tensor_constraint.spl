enum DimConstraint:
    # Two dimensions must be equal
    Equal(d1: Dim, d2: Dim)
    # Dimension must be greater than value
    GreaterThan(d: Dim, min: i32)
    # Dimension must be less than value
    LessThan(d: Dim, max: i32)
    # Dimension must be in range
    InRange(d: Dim, min: i32, max: i32)
    # Product of dimensions must equal value
    ProductEquals(dims: List<Dim>, value: i32)
    # Two products must be equal (for reshape)
    ProductsEqual(dims1: List<Dim>, dims2: List<Dim>)

    fn to_string(self) -> text:
        match self:
            case Equal(d1, d2): "{d1.to_string()} = {d2.to_string()}"
            case GreaterThan(d, min): "{d.to_string()} > {min}"
            case LessThan(d, max): "{d.to_string()} < {max}"
            case InRange(d, min, max): "{min} <= {d.to_string()} <= {max}"
            case ProductEquals(dims, value):
                val dims_str = dims.mapped(\d: d.to_string()).join(" * ")
                "{dims_str} = {value}"
            case ProductsEqual(d1s, d2s):
                val s1 = d1s.mapped(|d| d.to_string()).join(" * ")
                val s2 = d2s.mapped(|d| d.to_string()).join(" * ")
                "{s1} = {s2}"

    fn is_equal(self) -> bool:
        """Check if this is Equal constraint.
        Returns: true for Equal
        Example: DimConstraint.Equal(d1: d1, d2: d2).is_equal()  # → True
        """
        match self:
            case Equal(_, _): true
            case _: false

    fn is_greater_than(self) -> bool:
        """Check if this is GreaterThan constraint.
        Returns: true for GreaterThan
        Example: DimConstraint.GreaterThan(d: d, min: 1).is_greater_than()  # → True
        """
        match self:
            case GreaterThan(_, _): true
            case _: false

    fn is_less_than(self) -> bool:
        """Check if this is LessThan constraint.
        Returns: true for LessThan
        Example: DimConstraint.LessThan(d: d, max: 100).is_less_than()  # → True
        """
        match self:
            case LessThan(_, _): true
            case _: false

    fn is_in_range(self) -> bool:
        """Check if this is InRange constraint.
        Returns: true for InRange
        Example: DimConstraint.InRange(d: d, min: 1, max: 100).is_in_range()  # → True
        """
        match self:
            case InRange(_, _, _): true
            case _: false

    fn is_product_equals(self) -> bool:
        """Check if this is ProductEquals constraint.
        Returns: true for ProductEquals
        Example: DimConstraint.ProductEquals(dims: ds, value: 100).is_product_equals()  # → True
        """
        match self:
            case ProductEquals(_, _): true
            case _: false

    fn is_products_equal(self) -> bool:
        """Check if this is ProductsEqual constraint.
        Returns: true for ProductsEqual
        Example: DimConstraint.ProductsEqual(dims1: d1s, dims2: d2s).is_products_equal()  # → True
        """
        match self:
            case ProductsEqual(_, _): true
            case _: false

    fn is_equality_constraint(self) -> bool:
        """Check if constraint enforces equality.
        Returns: true for Equal or ProductsEqual
        Example: DimConstraint.Equal(d1: d1, d2: d2).is_equality_constraint()  # → True
        """
        match self:
            case Equal(_, _): true
            case ProductsEqual(_, _): true
            case _: false

    fn is_range_constraint(self) -> bool:
        """Check if constraint enforces range bounds.
        Returns: true for GreaterThan, LessThan, or InRange
        Example: DimConstraint.InRange(d: d, min: 1, max: 100).is_range_constraint()  # → True
        """
        match self:
            case GreaterThan(_, _): true
            case LessThan(_, _): true
            case InRange(_, _, _): true
            case _: false

    fn is_product_constraint(self) -> bool:
        """Check if constraint involves product of dimensions.
        Returns: true for ProductEquals or ProductsEqual
        Example: DimConstraint.ProductEquals(dims: ds, value: 100).is_product_constraint()  # → True
        """
        match self:
            case ProductEquals(_, _): true
            case ProductsEqual(_, _): true
            case _: false

    fn description(self) -> text:
        """Get human-readable description of the constraint.
        Returns: descriptive explanation
        Example: DimConstraint.Equal(d1: d1, d2: d2).description()
                # → "Equality constraint: two dimensions must be equal"
        """
        match self:
            case Equal(_, _): "Equality constraint: two dimensions must be equal"
            case GreaterThan(_, _): "Lower bound constraint: dimension must exceed minimum"
            case LessThan(_, _): "Upper bound constraint: dimension must not exceed maximum"
            case InRange(_, _, _): "Range constraint: dimension must be within bounds"
            case ProductEquals(_, _): "Product constraint: product of dimensions must equal value"
            case ProductsEqual(_, _): "Product equality constraint: two products must be equal"

    fn summary(self) -> text:
        """Get comprehensive summary of the constraint.
        Returns: summary with constraint expression, description, and category
        Example: DimConstraint.InRange(d: d, min: 1, max: 100).summary()
                # → "DimConstraint: 1 <= d <= 100 (Range constraint: dimension must be within bounds, range constraint)"
        """
        val expr = self.to_string()
        val desc = self.description()
        var category = "other"

        if self.is_equality_constraint():
            category = "equality constraint"
        elif self.is_range_constraint():
            category = "range constraint"
        elif self.is_product_constraint():
            category = "product constraint"

        "DimConstraint: {expr} ({desc}, {category})"

# ============================================================================
# Tensor Shape
# ============================================================================

# Tensor shape: list of dimensions
class TensorShape:
    dims: List<Dim>

    fn new(dims: List<Dim>) -> TensorShape:
        TensorShape(dims: dims)

    fn from_literals(sizes: List<i32>) -> TensorShape:
        TensorShape(dims: sizes.mapped(|s| Dim.Literal(value: s)))

    fn ndim() -> i32:
        self.dims.len()

    fn to_string() -> text:
        val dim_strs = self.dims.mapped(|d| d.to_string())
        "[" + dim_strs.join(", ") + "]"

    fn get(idx: i32) -> Option<Dim>:
        if idx >= 0 and idx < self.dims.len():
            Some(self.dims[idx])
        else if idx < 0 and -idx <= self.dims.len():
            Some(self.dims[self.dims.len() + idx])
        else:
            nil

    fn is_concrete() -> bool:
        self.dims.all(|d| d.is_concrete())

    # Get minimum total elements (from range minimums)
    fn min_elements() -> Option<i32>:
        var product = 1
        for d in self.dims:
            match d.get_range():
                case Some((lo, _)):
                    product = product * lo
                case nil:
                    return nil
        Some(product)

    # Get maximum total elements (from range maximums)
    fn max_elements() -> Option<i32>:
        var product = 1
        for d in self.dims:
            match d.get_range():
                case Some((_, hi)):
                    product = product * hi
                case nil:
                    return nil
        Some(product)

# ============================================================================
# Shape Environment
# ============================================================================

# Environment tracking dimension bindings and constraints
class ShapeEnv:
    bindings: Dict<i32, Dim>       # Variable ID -> bound dimension
    named_dims: Dict<text, Dim>  # Named dimension -> value/range
    constraints: List<DimConstraint>

    static fn new() -> ShapeEnv:
        ShapeEnv(bindings: {}, named_dims: {}, constraints: [])

    me bind_var(var_id: i32, dim: Dim):
        self.bindings[var_id] = dim

    me bind_named(name: text, dim: Dim):
        self.named_dims[name] = dim

    me add_constraint(c: DimConstraint):
        self.constraints.push(c)

    fn lookup_var(var_id: i32) -> Option<Dim>:
        self.bindings.get(var_id)

    fn lookup_named(name: text) -> Option<Dim>:
        self.named_dims.get(name)

    fn apply(dim: Dim) -> Dim:
        match dim:
            case Dim.Var(v):
                match self.lookup_var(v.id):
                    case Some(bound):
                        self.apply(bound)
                    case nil:
                        dim
            case Dim.Named(n, _):
                match self.lookup_named(n):
                    case Some(bound):
                        self.apply(bound)
                    case nil:
                        dim
            case _:
                dim

    fn apply_shape(shape: TensorShape) -> TensorShape:
        TensorShape(dims: shape.dims.mapped(|d| self.apply(d)))

# ============================================================================
# Shape Errors
# ============================================================================

