# Memory Capabilities Model
# Formal model for reference capabilities matching Lean 4 definitions.
#
# This implements the reference capability system for Simple:
# - `mut T` - Mutable, exclusive reference
# - `iso T` - Isolated, transferable ownership  
# - `T` - Immutable, shared reference
#
# ## Capability Rules
#
# | From | To | Allowed |
# |------|-----|---------|
# | mut | iso | Yes (consume) |
# | mut | imm | Yes (freeze) |
# | iso | mut | Yes (recover) |
# | iso | imm | Yes (share) |
# | imm | mut | No |
# | imm | iso | No |

# Reference capability enum
# Matches Lean: inductive RefCapability
pub enum RefCapability:
    Mut    # Mutable, exclusive access
    Iso    # Isolated, transferable ownership
    Imm    # Immutable, shared read-only

    # Get string representation
    fn to_string() -> text:
        match self:
            case Mut: "mut"
            case Iso: "iso"
            case Imm: "imm"

    # Check if this capability allows mutation
    fn allows_mutation() -> bool:
        match self:
            case Mut: true
            case Iso: true
            case Imm: false

    # Check if this capability can be aliased
    fn allows_aliasing() -> bool:
        match self:
            case Mut: false
            case Iso: false
            case Imm: true

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_mut() -> bool:
        """Check if this is Mut capability.

        Returns:
            true for Mut

        Example:
            RefCapability.Mut.is_mut()  # → true
        """
        match self:
            case Mut: true
            case _: false

    fn is_iso() -> bool:
        """Check if this is Iso capability.

        Returns:
            true for Iso

        Example:
            RefCapability.Iso.is_iso()  # → true
        """
        match self:
            case Iso: true
            case _: false

    fn is_imm() -> bool:
        """Check if this is Imm capability.

        Returns:
            true for Imm

        Example:
            RefCapability.Imm.is_imm()  # → true
        """
        match self:
            case Imm: true
            case _: false

    fn is_exclusive() -> bool:
        """Check if capability is exclusive (no aliasing).

        Returns:
            true for Mut or Iso

        Example:
            RefCapability.Mut.is_exclusive()  # → true
            RefCapability.Imm.is_exclusive()  # → false
        """
        not self.allows_aliasing()

    fn is_transferable() -> bool:
        """Check if ownership can be transferred.

        Returns:
            true for Iso

        Example:
            RefCapability.Iso.is_transferable()  # → true
        """
        match self:
            case Iso: true
            case _: false

    fn is_shared() -> bool:
        """Check if capability allows sharing.

        Returns:
            true for Imm

        Example:
            RefCapability.Imm.is_shared()  # → true
        """
        self.allows_aliasing()

    fn description() -> text:
        """Get capability description.

        Returns:
            Human-readable description

        Example:
            RefCapability.Mut.description()
            # → "Mutable, exclusive access"
        """
        match self:
            case Mut: "Mutable, exclusive access"
            case Iso: "Isolated, transferable ownership"
            case Imm: "Immutable, shared read-only"

    fn summary() -> text:
        """Get summary of reference capability.

        Returns:
            Human-readable summary

        Example:
            RefCapability.Mut.summary()
            # → "RefCapability: mut (exclusive, mutable)"
        """
        val name = self.to_string()
        var attrs: List<text> = []

        if self.allows_mutation():
            attrs.push("mutable")
        else:
            attrs.push("immutable")

        if self.is_exclusive():
            attrs.push("exclusive")

        if self.is_transferable():
            attrs.push("transferable")

        if self.is_shared():
            attrs.push("shared")

        val attrs_str = attrs.join(", ")
        return "RefCapability: {name} ({attrs_str})"

    fn to_lean_name() -> text:
        """Convert capability to Lean name.

        Returns:
            Lean representation of capability

        Example:
            RefCapability.Imm.to_lean_name()  # → "Shared"
            RefCapability.Mut.to_lean_name()  # → "Exclusive"
            RefCapability.Iso.to_lean_name()  # → "Isolated"
        """
        match self:
            case Imm: "Shared"
            case Mut: "Exclusive"
            case Iso: "Isolated"

# Capability type - combines a capability with a type name
# Matches Lean: structure CapType
pub class CapType:
    cap: RefCapability
    type_name: text

    fn new(cap: RefCapability, type_name: text) -> CapType:
        CapType(cap: cap, type_name: type_name)

    fn mut_type(type_name: text) -> CapType:
        CapType(cap: RefCapability.Mut, type_name: type_name)

    fn iso_type(type_name: text) -> CapType:
        CapType(cap: RefCapability.Iso, type_name: type_name)

    fn imm_type(type_name: text) -> CapType:
        CapType(cap: RefCapability.Imm, type_name: type_name)

    fn to_string() -> text:
        if self.cap == RefCapability.Imm:
            self.type_name
        else:
            "{self.cap.to_string()} {self.type_name}"

    fn to_lean() -> text:
        """Convert capability type to Lean syntax.

        Returns:
            Lean representation of CapType

        Example:
            CapType.imm_type("Int").to_lean()
            # → "CapType.mk \"Int\" RefCapability.Shared"
        """
        val cap_lean = self.cap.to_lean_name()
        "CapType.mk \"{self.type_name}\" RefCapability.{cap_lean}"

# Reference in the environment
# Matches Lean: structure Reference
pub class Reference:
    name: text
    cap_type: CapType
    is_consumed: bool

    fn new(name: text, cap_type: CapType) -> Reference:
        Reference(name: name, cap_type: cap_type, is_consumed: false)

    me consume():
        self.is_consumed = true

    fn is_available() -> bool:
        not self.is_consumed

# Reference environment for tracking capabilities
# Matches Lean: structure RefEnv
pub class RefEnv:
    refs: Dict<text, Reference>

    static fn new() -> RefEnv:
        RefEnv(refs: {})

    me add(name: text, cap_type: CapType):
        self.refs[name] = Reference.new(name, cap_type)

    fn get(name: text) -> Option<Reference>:
        self.refs.get(name)

    me consume(name: text) -> Result<Nil, text>:
        match self.refs.get(name):
            case Some(ref):
                if ref.is_consumed:
                    Err("Reference '{name}' already consumed")
                else:
                    ref.consume()
                    Ok(nil)
            case None:
                Err("Reference '{name}' not found")

    fn is_available(name: text) -> bool:
        match self.refs.get(name):
            case Some(ref):
                ref.is_available()
            case None:
                false

# Check if a reference can be created from a source capability
# Matches Lean: def canCreateRef
fn can_create_ref(source: RefCapability, target: RefCapability) -> bool:
    match (source, target):
        # mut can create anything (with restrictions)
        case (RefCapability.Mut, RefCapability.Mut): true
        case (RefCapability.Mut, RefCapability.Iso): false
        case (RefCapability.Mut, RefCapability.Imm): true  # freeze

        # iso can create mut or imm
        case (RefCapability.Iso, RefCapability.Mut): true  # recover
        case (RefCapability.Iso, RefCapability.Iso): true
        case (RefCapability.Iso, RefCapability.Imm): true  # share

        # imm can only create imm (aliasing)
        case (RefCapability.Imm, RefCapability.Mut): false
        case (RefCapability.Imm, RefCapability.Iso): false
        case (RefCapability.Imm, RefCapability.Imm): true

# Check if capability conversion is allowed
# Matches Lean: def canConvert
fn can_convert(from_cap: RefCapability, to_cap: RefCapability) -> bool:
    can_create_ref(from_cap, to_cap)

# Conversion kind - how a capability conversion happens
pub enum ConversionKind:
    Identity   # Same capability
    Consume    # mut -> iso
    Freeze     # mut -> imm
    Recover    # iso -> mut
    Share      # iso -> imm
    Invalid    # Not allowed

    fn to_string() -> text:
        match self:
            case Identity: "identity"
            case Consume: "consume"
            case Freeze: "freeze"
            case Recover: "recover"
            case Share: "share"
            case Invalid: "invalid"

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_identity() -> bool:
        """Check if this is Identity conversion.

        Returns:
            true for Identity

        Example:
            ConversionKind.Identity.is_identity()  # → true
        """
        match self:
            case Identity: true
            case _: false

    fn is_consume() -> bool:
        """Check if this is Consume conversion (mut -> iso).

        Returns:
            true for Consume

        Example:
            ConversionKind.Consume.is_consume()  # → true
        """
        match self:
            case Consume: true
            case _: false

    fn is_freeze() -> bool:
        """Check if this is Freeze conversion (mut -> imm).

        Returns:
            true for Freeze

        Example:
            ConversionKind.Freeze.is_freeze()  # → true
        """
        match self:
            case Freeze: true
            case _: false

    fn is_recover() -> bool:
        """Check if this is Recover conversion (iso -> mut).

        Returns:
            true for Recover

        Example:
            ConversionKind.Recover.is_recover()  # → true
        """
        match self:
            case Recover: true
            case _: false

    fn is_share() -> bool:
        """Check if this is Share conversion (iso -> imm).

        Returns:
            true for Share

        Example:
            ConversionKind.Share.is_share()  # → true
        """
        match self:
            case Share: true
            case _: false

    fn is_invalid() -> bool:
        """Check if this is Invalid conversion.

        Returns:
            true for Invalid

        Example:
            ConversionKind.Invalid.is_invalid()  # → true
        """
        match self:
            case Invalid: true
            case _: false

    fn is_valid() -> bool:
        """Check if conversion is valid.

        Returns:
            false for Invalid, true otherwise

        Example:
            ConversionKind.Consume.is_valid()  # → true
            ConversionKind.Invalid.is_valid()  # → false
        """
        not self.is_invalid()

    fn changes_capability() -> bool:
        """Check if conversion changes capability.

        Returns:
            false for Identity, true for others (except Invalid)

        Example:
            ConversionKind.Identity.changes_capability()  # → false
            ConversionKind.Freeze.changes_capability()  # → true
        """
        match self:
            case Identity: false
            case Invalid: false
            case _: true

    static fn from_capability() -> text:
        """Get source capability name.

        Returns:
            Source capability type

        Example:
            ConversionKind.Consume.from_capability()  # → "mut"
        """
        match self:
            case Identity: "any"
            case Consume: "mut"
            case Freeze: "mut"
            case Recover: "iso"
            case Share: "iso"
            case Invalid: "none"

    fn to_capability() -> text:
        """Get target capability name.

        Returns:
            Target capability type

        Example:
            ConversionKind.Consume.to_capability()  # → "iso"
        """
        match self:
            case Identity: "same"
            case Consume: "iso"
            case Freeze: "imm"
            case Recover: "mut"
            case Share: "imm"
            case Invalid: "none"

    fn description() -> text:
        """Get conversion description.

        Returns:
            Human-readable description

        Example:
            ConversionKind.Consume.description()
            # → "Consume mutable reference into isolated"
        """
        match self:
            case Identity: "Keep same capability"
            case Consume: "Consume mutable reference into isolated"
            case Freeze: "Freeze mutable reference into immutable"
            case Recover: "Recover isolated reference into mutable"
            case Share: "Share isolated reference as immutable"
            case Invalid: "Invalid conversion (not allowed)"

    fn summary() -> text:
        """Get summary of conversion kind.

        Returns:
            Human-readable summary

        Example:
            ConversionKind.Consume.summary()
            # → "ConversionKind: consume (mut → iso, valid, changes capability)"
        """
        val name = self.to_string()
        val from_cap = self.from_capability()
        val to_cap = self.to_capability()
        val valid = if self.is_valid(): "valid" else: "invalid"
        val changes = if self.changes_capability(): "changes capability" else: "no change"

        return if self.is_identity():
            "ConversionKind: {name} ({valid}, {changes})"
        else:
            "ConversionKind: {name} ({from_cap} → {to_cap}, {valid}, {changes})"

# Get the kind of conversion between capabilities
fn get_conversion_kind(from_cap: RefCapability, to_cap: RefCapability) -> ConversionKind:
    match (from_cap, to_cap):
        case (RefCapability.Mut, RefCapability.Mut): ConversionKind.Identity
        case (RefCapability.Mut, RefCapability.Iso): ConversionKind.Consume
        case (RefCapability.Mut, RefCapability.Imm): ConversionKind.Freeze

        case (RefCapability.Iso, RefCapability.Mut): ConversionKind.Recover
        case (RefCapability.Iso, RefCapability.Iso): ConversionKind.Identity
        case (RefCapability.Iso, RefCapability.Imm): ConversionKind.Share

        case (RefCapability.Imm, RefCapability.Imm): ConversionKind.Identity
        case _: ConversionKind.Invalid

# Concurrency mode for capability checking
pub enum ConcurrencyMode:
    Actor      # Imm + Iso only (no shared mutable state)
    LockBase   # All allowed (locks protect access)
    Unsafe     # All allowed (no safety)

    fn to_string() -> text:
        match self:
            case Actor: "actor"
            case LockBase: "lock-based"
            case Unsafe: "unsafe"

# Check if capability is allowed in concurrency mode
fn capability_allowed_in_mode(cap: RefCapability, mode: ConcurrencyMode) -> bool:
    """Check if capability allowed in concurrency mode.

    Parameters:
        cap: Reference capability
        mode: Concurrency mode

    Returns:
        true if capability is allowed in mode

    Example:
        capability_allowed_in_mode(RefCapability.Imm, ConcurrencyMode.Actor)  # → true
        capability_allowed_in_mode(RefCapability.Mut, ConcurrencyMode.Actor)  # → false
    """
    match mode:
        case ConcurrencyMode.Actor:
            cap == RefCapability.Imm or cap == RefCapability.Iso
        case ConcurrencyMode.LockBase:
            true
        case ConcurrencyMode.Unsafe:
            true

# Check if reference allows specific access type
fn allows_access(ref: Reference, access_type: text) -> bool:
    """Check if reference allows specific access type.

    Parameters:
        ref: Reference to check
        access_type: Type of access ("read" or "write")

    Returns:
        true if access is allowed

    Example:
        val ref = Reference.new("x", CapType.imm_type("Int"))
        allows_access(ref, "read")    # → true
        allows_access(ref, "write")   # → false
    """
    match access_type:
        case "read":
            true
        case "write":
            ref.cap_type.cap == RefCapability.Mut or
            ref.cap_type.cap == RefCapability.Iso
        case _:
            false

# Capability checking result
pub class CapabilityCheckResult:
    is_valid: bool
    errors: List<text>
    warnings: List<text>

    static fn new() -> CapabilityCheckResult:
        CapabilityCheckResult(is_valid: true, errors: [], warnings: [])

    me add_error(msg: text):
        self.is_valid = false
        self.errors.push(msg)

    me add_warning(msg: text):
        self.warnings.push(msg)

# Check capability usage in an expression
fn check_capability_usage(env: RefEnv, name: text, required: RefCapability) -> CapabilityCheckResult:
    var result = CapabilityCheckResult.new()

    match env.get(name):
        case None:
            result.add_error("Reference '{name}' not in scope")
        case Some(ref):
            if not ref.is_available():
                result.add_error("Reference '{name}' has been consumed")
            else if not can_create_ref(ref.cap_type.cap, required):
                result.add_error(
                    "Cannot use '{name}' with capability {ref.cap_type.cap.to_string()} " +
                    "where {required.to_string()} is required"
                )

    result

