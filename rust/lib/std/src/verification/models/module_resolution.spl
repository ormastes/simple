# Module Resolution Model
#
# Formal model for module path resolution.
# Mirrors: verification/module_resolution/src/ModuleResolution.lean

# Module path component
class PathComponent:
    name: text
    is_package: bool

    fn create(name: text, is_package: bool = False) -> PathComponent:
        return PathComponent(name, is_package)

    fn to_lean() -> text:
        pkg = "false"
        if self.is_package:
            pkg = "true"
        return "{{ name := \"" + self.name + "\", isPackage := " + pkg + " }}"

# Full module path
class ModulePath:
    components: List<PathComponent>

    fn create(components: List<PathComponent> = []) -> ModulePath:
        return ModulePath(components)

    fn from_string(path: text) -> ModulePath:
        parts = path.split(".")
        components = [PathComponent.create(p) for p in parts]
        return ModulePath(components)

    fn to_string() -> text:
        return ".".join([c.name for c in self.components])

    fn to_lean() -> text:
        comps = "[" + ", ".join([c.to_lean() for c in self.components]) + "]"
        return "ModulePath.mk " + comps

    fn parent() -> ModulePath | None:
        if len(self.components) <= 1:
            return None
        return ModulePath(self.components[:-1])

    fn child(name: text) -> ModulePath:
        new_comps = self.components.append(PathComponent.create(name))
        return ModulePath(new_comps)

# Module entry in the module graph
class ModuleEntry:
    path: ModulePath
    file_path: text
    exports: List<text>
    imports: List<ModulePath>

    fn create(path: ModulePath, file_path: text) -> ModuleEntry:
        return ModuleEntry(path, file_path, [], [])

    fn with_export(name: text) -> ModuleEntry:
        new_exports = self.exports.append(name)
        return ModuleEntry(self.path, self.file_path, new_exports, self.imports)

    fn with_import(import_mod: ModulePath) -> ModuleEntry:
        new_imports = self.imports.append(import_mod)
        return ModuleEntry(self.path, self.file_path, self.exports, new_imports)

# Module graph
class ModuleGraph:
    modules: List<ModuleEntry>

    fn create() -> ModuleGraph:
        return ModuleGraph([])

    fn add_module(entry: ModuleEntry) -> ModuleGraph:
        new_modules = self.modules.append(entry)
        return ModuleGraph(new_modules)

    fn find_module(path: ModulePath) -> ModuleEntry | None:
        path_str = path.to_string()
        for m in self.modules:
            if m.path.to_string() == path_str:
                return m
        return None

    fn resolve_import(from_module: ModulePath, import_path: ModulePath) -> ModulePath | None:
        # Absolute import
        if self.find_module(import_path) is not None:
            return import_path

        # Relative import (from parent)
        parent = from_module.parent()
        if parent is not None:
            # Combine parent components with import path components
            combined = parent.components
            for c in import_path.components:
                combined = combined.append(c)
            relative = ModulePath(combined)
            if self.find_module(relative) is not None:
                return relative

        return None

# Resolution result
enum ResolveResult:
    Found(entry: ModuleEntry)
    NotFound(path: ModulePath)
    Cycle(path: List<ModulePath>)

    fn to_lean(self) -> text:
        match self:
            case Found(e): return "ResolveResult.found " + e.path.to_lean()
            case NotFound(p): return "ResolveResult.notFound " + p.to_lean()
            case Cycle(ps):
                paths = "[" + ", ".join([p.to_lean() for p in ps]) + "]"
                return "ResolveResult.cycle " + paths

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_found(self) -> bool:
        """Check if this is Found result.

        Returns:
            true for Found

        Example:
            ResolveResult.Found(entry).is_found()  # → true
        """
        match self:
            case Found(_): true
            case _: false

    fn is_not_found(self) -> bool:
        """Check if this is NotFound result.

        Returns:
            true for NotFound

        Example:
            ResolveResult.NotFound(path).is_not_found()  # → true
        """
        match self:
            case NotFound(_): true
            case _: false

    fn is_cycle(self) -> bool:
        """Check if this is Cycle result.

        Returns:
            true for Cycle

        Example:
            ResolveResult.Cycle([path1, path2]).is_cycle()  # → true
        """
        match self:
            case Cycle(_): true
            case _: false

    fn is_success(self) -> bool:
        """Check if resolution succeeded.

        Returns:
            true for Found

        Example:
            ResolveResult.Found(entry).is_success()  # → true
        """
        self.is_found()

    fn is_error(self) -> bool:
        """Check if resolution failed.

        Returns:
            true for NotFound or Cycle

        Example:
            ResolveResult.NotFound(path).is_error()  # → true
        """
        not self.is_success()

    fn get_entry(self) -> Option<ModuleEntry>:
        """Get module entry if found.

        Returns:
            Some(entry) for Found, None otherwise

        Example:
            ResolveResult.Found(entry).get_entry()  # → Some(entry)
        """
        match self:
            case Found(e): Some(e)
            case _: None

    fn get_path(self) -> Option<ModulePath>:
        """Get module path for NotFound result.

        Returns:
            Some(path) for NotFound, None otherwise

        Example:
            ResolveResult.NotFound(path).get_path()  # → Some(path)
        """
        match self:
            case NotFound(p): Some(p)
            case _: None

    fn get_cycle_path(self) -> Option<List<ModulePath>>:
        """Get cycle path if cycle detected.

        Returns:
            Some(paths) for Cycle, None otherwise

        Example:
            ResolveResult.Cycle([p1, p2]).get_cycle_path()  # → Some([p1, p2])
        """
        match self:
            case Cycle(ps): Some(ps)
            case _: None

    fn cycle_length(self) -> i32:
        """Get length of cycle if detected.

        Returns:
            Number of modules in cycle, 0 if not a cycle

        Example:
            ResolveResult.Cycle([p1, p2, p3]).cycle_length()  # → 3
        """
        match self:
            case Cycle(ps): ps.len()
            case _: 0

    fn to_string(self) -> text:
        """Convert result to string.

        Returns:
            Result representation

        Example:
            ResolveResult.Found(entry).to_string()  # → "found: module.path"
        """
        match self:
            case Found(e): "found: {e.path.to_string()}"
            case NotFound(p): "not-found: {p.to_string()}"
            case Cycle(ps):
                val paths = " -> ".join([p.to_string() for p in ps])
                "cycle: {paths}"

    fn description(self) -> text:
        """Get result description.

        Returns:
            Human-readable description

        Example:
            ResolveResult.Cycle([p1, p2]).description()
            # → "Import cycle detected: p1 -> p2"
        """
        match self:
            case Found(e): "Module found: {e.path.to_string()}"
            case NotFound(p): "Module not found: {p.to_string()}"
            case Cycle(ps):
                val paths = " -> ".join([p.to_string() for p in ps])
                "Import cycle detected: {paths}"

    fn summary(self) -> text:
        """Get summary of resolve result.

        Returns:
            Human-readable summary

        Example:
            ResolveResult.Found(entry).summary()
            # → "ResolveResult: found (success, module: module.path)"
        """
        match self:
            case Found(e):
                val path = e.path.to_string()
                return "ResolveResult: found (success, module: {path})"
            case NotFound(p):
                val path = p.to_string()
                return "ResolveResult: not-found (error, searched: {path})"
            case Cycle(ps):
                val length = ps.len()
                return "ResolveResult: cycle (error, {length} modules in cycle)"

# Check for import cycles
fn has_cycle(graph: ModuleGraph, start: ModulePath, visited: List<ModulePath> = []) -> bool:
    start_str = start.to_string()
    for v in visited:
        if v.to_string() == start_str:
            return True

    entry = graph.find_module(start)
    if entry is None:
        return False

    new_visited = visited.append(start)
    for imp in entry.imports:
        if has_cycle(graph, imp, new_visited):
            return True

    return False

# Specification functions

fn resolution_deterministic_spec() -> text:
    return "theorem resolution_deterministic : ∀ graph from path, resolve graph from path = resolve graph from path"

fn no_cycles_spec() -> text:
    return "theorem no_cycles : ∀ graph, well_formed graph → ¬∃ path, has_cycle graph path"

fn import_exists_spec() -> text:
    return "theorem import_exists : ∀ graph mod imp, imp ∈ mod.imports → ∃ entry, resolve graph mod.path imp = found entry"
