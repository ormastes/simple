/**
Hash Interface

Pluggable hash functions for custom hashing strategies.

Features:
- Hasher trait: Interface for hash implementations
- Sha1Hasher: SHA-1 cryptographic hash
- Sha256Hasher: SHA-256 cryptographic hash
- XxHasher: Fast non-cryptographic hash (xxHash)
- @hash_with decorator: Custom hash for collections

```sdoctest
>>> val hasher = XxHasher.new()
>>> hasher.write(b"hello")
>>> hasher.finish()
... # Returns u64 hash
```
*/

# FFI declarations for hash operations
extern fn rt_sha1_new() -> i64
extern fn rt_sha1_write(hasher: i64, data: i64, len: i64)
extern fn rt_sha1_finish(hasher: i64) -> i64
extern fn rt_sha1_finish_bytes(hasher: i64, out: i64)
extern fn rt_sha1_reset(hasher: i64)
extern fn rt_sha1_free(hasher: i64)

extern fn rt_sha256_new() -> i64
extern fn rt_sha256_write(hasher: i64, data: i64, len: i64)
extern fn rt_sha256_finish(hasher: i64) -> i64
extern fn rt_sha256_finish_bytes(hasher: i64, out: i64)
extern fn rt_sha256_reset(hasher: i64)
extern fn rt_sha256_free(hasher: i64)

extern fn rt_xxhash_new() -> i64
extern fn rt_xxhash_new_with_seed(seed: i64) -> i64
extern fn rt_xxhash_write(hasher: i64, data: i64, len: i64)
extern fn rt_xxhash_finish(hasher: i64) -> i64
extern fn rt_xxhash_reset(hasher: i64)
extern fn rt_xxhash_free(hasher: i64)

extern fn rt_fnv_hash(data: i64, len: i64) -> i64

/**
Hasher trait - interface for hash implementations.

Implement this trait to create custom hash functions.
*/
trait Hasher:
    # Write data to the hasher.
    fn write(data: [u8]) -> Self

    # Write a single byte.
    fn write_u8(value: u8) -> Self:
        return self.write([value])

    # Write a 64-bit integer.
    fn write_i64(value: i64) -> Self

    # Write a string.
    fn write_str(value: str) -> Self

    # Finish hashing and return the digest as u64.
    fn finish() -> u64

    # Reset the hasher for reuse.
    fn reset()

/**
SHA-1 cryptographic hasher.

Produces a 160-bit (20 byte) hash.
Note: SHA-1 is considered weak for security-critical applications.

```sdoctest
>>> val hasher = Sha1Hasher.new()
>>> hasher.write_str("hello")
>>> val hash = hasher.finish_hex()
>>> len(hash)
40
```
*/
struct Sha1Hasher:
    _handle: i64

    static fn new() -> Sha1Hasher:
        val handle = rt_sha1_new()
        return Sha1Hasher(_handle: handle)

    fn write(self, data: [u8]) -> Sha1Hasher:
        rt_sha1_write(self._handle, data as i64, len(data))
        return self

    fn write_u8(self, value: u8) -> Sha1Hasher:
        return self.write([value])

    fn write_i64(self, value: i64) -> Sha1Hasher:
        # Convert i64 to bytes and write
        val bytes = []
        for i in range(8):
            bytes.push(((value >> (i * 8)) & 0xFF) as u8)
        return self.write(bytes)

    fn write_str(self, value: str) -> Sha1Hasher:
        val bytes = value.as_bytes()
        return self.write(bytes)

    fn finish(self) -> u64:
        return rt_sha1_finish(self._handle) as u64

    fn finish_bytes(self) -> [u8]:
        val out = [0u8; 20]
        rt_sha1_finish_bytes(self._handle, out as i64)
        return out

    fn finish_hex(self) -> str:
        val bytes = self.finish_bytes()
        return bytes_to_hex(bytes)

    fn reset(self):
        rt_sha1_reset(self._handle)

    fn free(self):
        rt_sha1_free(self._handle)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn summary() -> text:
        """Get summary of hasher.

        Returns:
            Human-readable summary

        Example:
            hasher.summary()
            # → "Sha1Hasher: 160-bit cryptographic hash"
        """
        return "Sha1Hasher: 160-bit cryptographic hash"

/**
SHA-256 cryptographic hasher.

Produces a 256-bit (32 byte) hash.
Recommended for security-critical applications.

```sdoctest
>>> val hasher = Sha256Hasher.new()
>>> hasher.write_str("hello")
>>> val hash = hasher.finish_hex()
>>> len(hash)
64
```
*/
struct Sha256Hasher:
    _handle: i64

    static fn new() -> Sha256Hasher:
        val handle = rt_sha256_new()
        return Sha256Hasher(_handle: handle)

    fn write(self, data: [u8]) -> Sha256Hasher:
        rt_sha256_write(self._handle, data as i64, len(data))
        return self

    fn write_u8(self, value: u8) -> Sha256Hasher:
        return self.write([value])

    fn write_i64(self, value: i64) -> Sha256Hasher:
        val bytes = []
        for i in range(8):
            bytes.push(((value >> (i * 8)) & 0xFF) as u8)
        return self.write(bytes)

    fn write_str(self, value: str) -> Sha256Hasher:
        val bytes = value.as_bytes()
        return self.write(bytes)

    fn finish(self) -> u64:
        return rt_sha256_finish(self._handle) as u64

    fn finish_bytes(self) -> [u8]:
        val out = [0u8; 32]
        rt_sha256_finish_bytes(self._handle, out as i64)
        return out

    fn finish_hex(self) -> str:
        val bytes = self.finish_bytes()
        return bytes_to_hex(bytes)

    fn reset(self):
        rt_sha256_reset(self._handle)

    fn free(self):
        rt_sha256_free(self._handle)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn summary() -> text:
        """Get summary of hasher.

        Returns:
            Human-readable summary

        Example:
            hasher.summary()
            # → "Sha256Hasher: 256-bit cryptographic hash"
        """
        return "Sha256Hasher: 256-bit cryptographic hash"

/**
xxHash fast hasher (XXH3).

High-performance non-cryptographic hash.
Ideal for hash tables and checksums.

```sdoctest
>>> val hasher = XxHasher.new()
>>> hasher.write_str("hello")
>>> hasher.finish()
... # Returns u64
```
*/
struct XxHasher:
    _handle: i64

    static fn new() -> XxHasher:
        val handle = rt_xxhash_new()
        return XxHasher(_handle: handle)

    fn with_seed(seed: u64) -> XxHasher:
        val handle = rt_xxhash_new_with_seed(seed as i64)
        return XxHasher(_handle: handle)

    fn write(self, data: [u8]) -> XxHasher:
        rt_xxhash_write(self._handle, data as i64, len(data))
        return self

    fn write_u8(self, value: u8) -> XxHasher:
        return self.write([value])

    fn write_i64(self, value: i64) -> XxHasher:
        val bytes = []
        for i in range(8):
            bytes.push(((value >> (i * 8)) & 0xFF) as u8)
        return self.write(bytes)

    fn write_str(self, value: str) -> XxHasher:
        val bytes = value.as_bytes()
        return self.write(bytes)

    fn finish(self) -> u64:
        return rt_xxhash_finish(self._handle) as u64

    fn reset(self):
        rt_xxhash_reset(self._handle)

    fn free(self):
        rt_xxhash_free(self._handle)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn summary() -> text:
        """Get summary of hasher.

        Returns:
            Human-readable summary

        Example:
            hasher.summary()
            # → "XxHasher: fast non-cryptographic hash"
        """
        return "XxHasher: fast non-cryptographic hash"

/**
FNV-1a hash (one-shot).

Simple and fast hash for small data.

```sdoctest
>>> fnv_hash("hello")
... # Returns u64
```
*/
fn fnv_hash(data: str) -> u64:
    val bytes = data.as_bytes()
    return rt_fnv_hash(bytes as i64, len(bytes)) as u64

/**
FNV-1a hasher (streaming).

Fowler-Noll-Vo hash function.
Simple, fast, and good distribution.
*/
struct FnvHasher:
    _state: u64

    static fn new() -> FnvHasher:
        # FNV offset basis: 0xcbf29ce484222325 = 14695981039346656037u64
        # Represented as i64 two's complement: -3750763034362895579
        return FnvHasher(_state: -3750763034362895579 as u64)

    fn write(self, data: [u8]) -> FnvHasher:
        for byte in data:
            self._state = self._state xor (byte as u64)
            self._state = self._state * 1099511628211  # FNV prime
        return self

    fn write_u8(self, value: u8) -> FnvHasher:
        return self.write([value])

    fn write_i64(self, value: i64) -> FnvHasher:
        val bytes = []
        for i in range(8):
            bytes.push(((value >> (i * 8)) & 0xFF) as u8)
        return self.write(bytes)

    fn write_str(self, value: str) -> FnvHasher:
        val bytes = value.as_bytes()
        return self.write(bytes)

    fn finish(self) -> u64:
        return self._state

    fn reset(self):
        self._state = -3750763034362895579 as u64  # FNV offset basis

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_initialized(self) -> bool:
        """Check if hasher is in initial state (not yet written to).

        Returns:
            true if state equals FNV offset basis

        Example:
            val hasher = FnvHasher.new()
            hasher.is_initialized()  # → true
            hasher.write_str("data")
            hasher.is_initialized()  # → false
        """
        return self._state == (-3750763034362895579 as u64)

    fn get_state(self) -> u64:
        """Get current hash state.

        Returns:
            Current internal state value

        Example:
            hasher.get_state()
            # → 14695981039346656037 (if uninitialized)
        """
        return self._state

    fn summary(self) -> text:
        """Get summary of hasher.

        Returns:
            Human-readable summary

        Example:
            hasher.summary()
            # → "FnvHasher: state=14695981039346656037"
        """
        val state = self._state
        return "FnvHasher: state={state}"

/**
SipHash hasher.

Cryptographically strong keyed hash.
Default hasher in Rust's HashMap.
*/
struct SipHasher:
    _key0: u64
    _key1: u64
    _state: u64

    static fn new() -> SipHasher:
        return SipHasher(_key0: 0, _key1: 0, _state: 0)

    fn with_keys(key0: u64, key1: u64) -> SipHasher:
        return SipHasher(_key0: key0, _key1: key1, _state: 0)

    fn write(self, data: [u8]) -> SipHasher:
        # Simplified - real impl would use full SipHash algorithm
        for byte in data:
            self._state = (self._state * 31 + (byte as u64)) xor self._key0
        return self

    fn write_str(self, value: str) -> SipHasher:
        val bytes = value.as_bytes()
        return self.write(bytes)

    fn write_i64(self, value: i64) -> SipHasher:
        val bytes = []
        for i in range(8):
            bytes.push(((value >> (i * 8)) & 0xFF) as u8)
        return self.write(bytes)

    fn finish(self) -> u64:
        return self._state xor self._key1

    fn reset(self):
        self._state = 0

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_keyed(self) -> bool:
        """Check if hasher uses non-zero keys.

        Returns:
            true if either key is non-zero

        Example:
            val hasher = SipHasher.new()
            hasher.is_keyed()  # → false
            val keyed = SipHasher.with_keys(123, 456)
            keyed.is_keyed()  # → true
        """
        return self._key0 != 0 or self._key1 != 0

    fn has_default_keys(self) -> bool:
        """Check if hasher uses default (zero) keys.

        Returns:
            true if both keys are zero

        Example:
            val hasher = SipHasher.new()
            hasher.has_default_keys()  # → true
        """
        return self._key0 == 0 and self._key1 == 0

    fn get_state(self) -> u64:
        """Get current hash state.

        Returns:
            Current internal state value

        Example:
            hasher.get_state()
            # → 0 (if not yet written to)
        """
        return self._state

    fn summary(self) -> text:
        """Get summary of hasher.

        Returns:
            Human-readable summary

        Example:
            hasher.summary()
            # → "SipHasher: keyed=true, state=1234567890"
        """
        val keyed = if self.is_keyed(): "true" else: "false"
        val state = self._state
        return "SipHasher: keyed={keyed}, state={state}"

/**
Hash builder for creating hashers.

Used to configure the hash function for collections.
*/
struct HashBuilder<H>:
    _seed: u64

    static fn new() -> HashBuilder<H>:
        return HashBuilder(_seed: 0)

    fn with_seed(seed: u64) -> HashBuilder<H>:
        return HashBuilder(_seed: seed)

    static fn build_hasher() -> H:
        # Would create hasher of type H with seed
        return H.new()

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn has_seed(self) -> bool:
        """Check if builder has a non-zero seed.

        Returns:
            true if seed is non-zero

        Example:
            val builder = HashBuilder.new()
            builder.has_seed()  # → false
            val seeded = HashBuilder.with_seed(42)
            seeded.has_seed()  # → true
        """
        return self._seed != 0

    fn get_seed(self) -> u64:
        """Get configured seed value.

        Returns:
            Seed value

        Example:
            builder.get_seed()
            # → 0 (default) or configured seed
        """
        return self._seed

    fn is_default(self) -> bool:
        """Check if builder uses default configuration (no seed).

        Returns:
            true if seed is zero

        Example:
            val builder = HashBuilder.new()
            builder.is_default()  # → true
        """
        return self._seed == 0

    fn summary(self) -> text:
        """Get summary of hash builder.

        Returns:
            Human-readable summary

        Example:
            builder.summary()
            # → "HashBuilder: seed=0 (default)" or "HashBuilder: seed=42"
        """
        val seed = self._seed
        val suffix = if self.is_default(): " (default)" else: ""
        return "HashBuilder: seed={seed}{suffix}"

/**
Hash configuration for collections.

Use with @hash_with decorator.
*/
struct HashConfig:
    hasher_type: str
    seed: u64

    fn xxhash() -> HashConfig:
        return HashConfig(hasher_type: "xxhash", seed: 0)

    fn xxhash_with_seed(seed: u64) -> HashConfig:
        return HashConfig(hasher_type: "xxhash", seed: seed)

    fn fnv() -> HashConfig:
        return HashConfig(hasher_type: "fnv", seed: 0)

    fn siphash(key0: u64, key1: u64) -> HashConfig:
        # Encode keys in seed (simplified)
        return HashConfig(hasher_type: "siphash", seed: key0)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_xxhash(self) -> bool:
        """Check if configuration is for xxHash.

        Returns:
            true if hasher type is "xxhash"

        Example:
            val config = HashConfig.xxhash()
            config.is_xxhash()  # → true
        """
        return self.hasher_type == "xxhash"

    fn is_fnv(self) -> bool:
        """Check if configuration is for FNV hash.

        Returns:
            true if hasher type is "fnv"

        Example:
            val config = HashConfig.fnv()
            config.is_fnv()  # → true
        """
        return self.hasher_type == "fnv"

    fn is_siphash(self) -> bool:
        """Check if configuration is for SipHash.

        Returns:
            true if hasher type is "siphash"

        Example:
            val config = HashConfig.siphash(123, 456)
            config.is_siphash()  # → true
        """
        return self.hasher_type == "siphash"

    fn has_seed(self) -> bool:
        """Check if configuration has a non-zero seed.

        Returns:
            true if seed is non-zero

        Example:
            val config = HashConfig.xxhash()
            config.has_seed()  # → false
            val seeded = HashConfig.xxhash_with_seed(42)
            seeded.has_seed()  # → true
        """
        return self.seed != 0

    fn get_hasher_type(self) -> text:
        """Get hasher type name.

        Returns:
            Hasher type string ("xxhash", "fnv", or "siphash")

        Example:
            config.get_hasher_type()
            # → "xxhash"
        """
        return self.hasher_type

    fn get_seed(self) -> u64:
        """Get seed value.

        Returns:
            Configured seed value

        Example:
            config.get_seed()
            # → 0 or configured seed
        """
        return self.seed

    fn summary(self) -> text:
        """Get summary of hash configuration.

        Returns:
            Human-readable summary

        Example:
            config.summary()
            # → "HashConfig: xxhash, seed=0"
            # → "HashConfig: fnv, seed=0"
            # → "HashConfig: siphash, seed=123"
        """
        val hasher_type = self.hasher_type
        val seed = self.seed
        return "HashConfig: {hasher_type}, seed={seed}"

/**
Convert bytes to hex string.
*/
fn bytes_to_hex(bytes: [u8]) -> str:
    val hex_chars = "0123456789abcdef"
    val result = ""
    for byte in bytes:
        val hi = (byte >> 4) & 0x0F
        val lo = byte & 0x0F
        result = result + hex_chars[hi] + hex_chars[lo]
    return result

/**
Compute hash of a value using default hasher.
*/
fn hash<T>(value: T) -> u64:
    val hasher = XxHasher.new()
    hasher.write_i64(value as i64)
    val h = hasher.finish()
    hasher.free()
    return h

/**
Compute hash of a string.
*/
fn hash_str(value: str) -> u64:
    val hasher = XxHasher.new()
    hasher.write_str(value)
    val h = hasher.finish()
    hasher.free()
    return h

/**
Compute hash of bytes.
*/
fn hash_bytes(data: [u8]) -> u64:
    val hasher = XxHasher.new()
    hasher.write(data)
    val h = hasher.finish()
    hasher.free()
    return h
