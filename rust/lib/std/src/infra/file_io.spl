# File I/O operations for Simple
# Wrappers around runtime FFI functions

use core.option.{Option, Some}
use core.result.{Result, Ok, Err}

# =====================================
# File Metadata Operations
# =====================================

# Check if a file exists
extern fn rt_file_exists(path: text) -> bool

# Check if a file exists
pub fn file_exist(path: text) -> bool:
    rt_file_exists(path)

# Alias for file_exist (for convenience)
pub fn file_exists(path: text) -> bool:
    rt_file_exists(path)

# Get file metadata (returns encoded stat info as i32)
extern fn rt_file_stat(path: text) -> i32

# Get file size in bytes
pub fn file_size(path: text) -> Option<i32>:
    val stat = rt_file_stat(path)
    if stat >= 0:
        Some(stat)
    else:
        nil

# =====================================
# File Reading Operations
# =====================================

# Read entire file as text
extern fn rt_file_read_text(path: text) -> text

# Read file contents as text
pub fn read_file(path: text) -> Result<text, text>:
    if not file_exist(path):
        return Err("File does not exist: " + path)

    val content = rt_file_read_text(path)
    Ok(content)

# Read file contents as text (unsafe, panics if file doesn't exist)
pub fn read_file_unsafe(path: text) -> text:
    rt_file_read_text(path)

# Read file as array of lines
extern fn rt_file_read_lines(path: text) -> List<text>

# Read file contents as array of lines
pub fn read_lines(path: text) -> Result<List<text>, text>:
    if not file_exist(path):
        return Err("File does not exist: " + path)
    val lines = rt_file_read_lines(path)
    Ok(lines)

# Read file contents as array of lines (unsafe)
pub fn read_lines_unsafe(path: text) -> List<text>:
    rt_file_read_lines(path)

# Read file as raw bytes (array of integers 0-255)
extern fn rt_file_read_bytes(path: text) -> List<i32>

# Read file contents as bytes
pub fn read_bytes(path: text) -> Result<List<i32>, text>:
    if not file_exist(path):
        return Err("File does not exist: " + path)
    val bytes = rt_file_read_bytes(path)
    Ok(bytes)

# Read file contents as bytes (unsafe)
pub fn read_bytes_unsafe(path: text) -> List<i32>:
    rt_file_read_bytes(path)

# =====================================
# File Writing Operations
# =====================================

# Write text to file (creates or overwrites)
extern fn rt_file_write_text(path: text, content: text) -> bool

# Write text to file
pub fn write_file(path: text, content: text) -> Result<(), text>:
    val success = rt_file_write_text(path, content)
    if success:
        Ok(())
    else:
        Err("Failed to write file: " + path)

# Write text to file (unsafe, doesn't check for errors)
pub fn write_file_unsafe(path: text, content: text):
    rt_file_write_text(path, content)

# Atomically write text to file (write to temp, then rename)
#
# This provides atomic writes by writing to a temporary file and then
# atomically renaming it to the target path. This ensures readers never
# see partial writes.
#
# Note: This does NOT provide file locking. For concurrent access with
# locking, use a higher-level database API.
extern fn rt_file_atomic_write(path: text, content: text) -> bool

# Atomically write text to file
pub fn atomic_write_file(path: text, content: text) -> Result<(), text>:
    val success = rt_file_atomic_write(path, content)
    if success:
        Ok(())
    else:
        Err("Failed to atomically write file: " + path)

# Atomically write text to file (unsafe)
pub fn atomic_write_file_unsafe(path: text, content: text):
    rt_file_atomic_write(path, content)

# Append text to file (creates if not exists)
extern fn rt_file_append_text(path: text, content: text) -> bool

# Append text to file
pub fn append_file(path: text, content: text) -> Result<(), text>:
    val success = rt_file_append_text(path, content)
    if success:
        Ok(())
    else:
        Err("Failed to append to file: " + path)

# Append text to file (unsafe)
pub fn append_file_unsafe(path: text, content: text):
    rt_file_append_text(path, content)

# Write raw bytes to file
extern fn rt_file_write_bytes(path: text, data: List<i32>) -> bool

# Write bytes to file
pub fn write_bytes(path: text, data: List<i32>) -> Result<(), text>:
    val success = rt_file_write_bytes(path, data)
    if success:
        Ok(())
    else:
        Err("Failed to write bytes to file: " + path)

# Write bytes to file (unsafe)
pub fn write_bytes_unsafe(path: text, data: List<i32>):
    rt_file_write_bytes(path, data)

# =====================================
# File Operations
# =====================================

# Copy file from source to destination
extern fn rt_file_copy(source: text, dest: text) -> bool

# Copy a file
pub fn copy_file(source: text, dest: text) -> Result<(), text>:
    if not file_exist(source):
        return Err("Source file does not exist: " + source)

    val success = rt_file_copy(source, dest)
    if success:
        Ok(())
    else:
        Err("Failed to copy file from " + source + " to " + dest)

# Remove/delete a file
extern fn rt_file_remove(path: text) -> bool

# Remove a file
pub fn remove_file(path: text) -> Result<(), text>:
    val success = rt_file_remove(path)
    if success:
        Ok(())
    else:
        Err("Failed to remove file: " + path)

# Rename/move a file
extern fn rt_file_rename(old_path: text, new_path: text) -> bool

# Rename or move a file
pub fn rename_file(old_path: text, new_path: text) -> Result<(), text>:
    val success = rt_file_rename(old_path, new_path)
    if success:
        Ok(())
    else:
        Err("Failed to rename file from " + old_path + " to " + new_path)

# Move file (works across filesystems)
extern fn rt_file_move(source: text, dest: text) -> bool

# Move a file to a new location
pub fn move_file(source: text, dest: text) -> Result<(), text>:
    if not file_exist(source):
        return Err("Source file does not exist: " + source)
    val success = rt_file_move(source, dest)
    if success:
        Ok(())
    else:
        Err("Failed to move file from " + source + " to " + dest)

# Get canonical absolute path
extern fn rt_file_canonicalize(path: text) -> text

# Get canonical absolute path of a file
pub fn canonicalize(path: text) -> text:
    rt_file_canonicalize(path)

# =====================================
# Directory Operations
# =====================================

# Create a directory
extern fn rt_dir_create(path: text) -> bool

# Create a directory
pub fn create_dir(path: text) -> Result<(), text>:
    val success = rt_dir_create(path)
    if success:
        Ok(())
    else:
        Err("Failed to create directory: " + path)

# List directory contents (returns list of file/dir names)
extern fn rt_dir_list(path: text) -> List<text>

# List files and directories in a directory
pub fn list_dir(path: text) -> Result<List<text>, text>:
    if not file_exist(path):
        return Err("Directory does not exist: " + path)

    val entries = rt_dir_list(path)
    Ok(entries)

# List directory contents (unsafe)
pub fn list_dir_unsafe(path: text) -> List<text>:
    rt_dir_list(path)

# Remove a directory
extern fn rt_dir_remove(path: text) -> bool

# Remove a directory
pub fn remove_dir(path: text) -> Result<(), text>:
    val success = rt_dir_remove(path)
    if success:
        Ok(())
    else:
        Err("Failed to remove directory: " + path)

# Find files matching a pattern in a directory
extern fn rt_file_find(dir: text, pattern: text) -> List<text>

# Find files matching pattern
pub fn find_files(dir: text, pattern: text) -> List<text>:
    rt_file_find(dir, pattern)

# List files matching glob pattern
extern fn rt_dir_glob(pattern: text) -> List<text>

# Glob - find files matching pattern
pub fn glob(pattern: text) -> List<text>:
    rt_dir_glob(pattern)

# Create directory with all parent directories
extern fn rt_dir_create_all(path: text) -> bool

# Create directory with all parents (like mkdir -p)
pub fn create_dir_all(path: text) -> Result<(), text>:
    val success = rt_dir_create_all(path)
    if success:
        Ok(())
    else:
        Err("Failed to create directory tree: " + path)

# Walk directory recursively
extern fn rt_dir_walk(path: text) -> List<text>

# Walk directory tree recursively
pub fn walk_dir(path: text) -> Result<List<text>, text>:
    if not file_exist(path):
        return Err("Directory does not exist: " + path)
    val entries = rt_dir_walk(path)
    Ok(entries)

# Walk directory (unsafe)
pub fn walk_dir_unsafe(path: text) -> List<text>:
    rt_dir_walk(path)

# Get current working directory
extern fn rt_current_dir() -> text

# Get current working directory
pub fn current_dir() -> text:
    rt_current_dir()

# Set current working directory
extern fn rt_set_current_dir(path: text) -> bool

# Change current working directory
pub fn set_current_dir(path: text) -> Result<(), text>:
    val success = rt_set_current_dir(path)
    if success:
        Ok(())
    else:
        Err("Failed to change directory to: " + path)

# Remove directory and all contents recursively (with safety checks)
extern fn rt_dir_remove_all(path: text) -> bool

# Remove directory and all contents
pub fn remove_dir_all(path: text) -> Result<(), text>:
    val success = rt_dir_remove_all(path)
    if success:
        Ok(())
    else:
        Err("Failed to remove directory: " + path + " (may be protected)")

# =====================================
# Path Operations
# =====================================

# Get basename (filename) from path
extern fn rt_path_basename(path: text) -> text

# Get the basename (filename) from a path
pub fn basename(path: text) -> text:
    rt_path_basename(path)

# Get dirname (directory) from path
extern fn rt_path_dirname(path: text) -> text

# Get the directory name from a path
pub fn dirname(path: text) -> text:
    rt_path_dirname(path)

# Get file extension from path
extern fn rt_path_ext(path: text) -> text

# Get the file extension from a path (short form)
pub fn ext(path: text) -> text:
    rt_path_ext(path)

# Get the file extension from a path
@deprecated("Use 'ext' instead of 'extension'")
pub fn extension(path: text) -> text:
    ext(path)

# Convert path to absolute path
extern fn rt_path_absolute(path: text) -> text

# Convert to absolute path
pub fn absolute_path(path: text) -> text:
    rt_path_absolute(path)

# Get platform-specific path separator
extern fn rt_path_separator() -> text

# Get the path separator for this platform
pub fn path_separator() -> text:
    rt_path_separator()

# Get file stem (filename without extension)
extern fn rt_path_stem(path: text) -> text

# Get filename without extension
pub fn stem(path: text) -> text:
    rt_path_stem(path)

# Compute relative path from base
extern fn rt_path_relative(path: text, base: text) -> text

# Get relative path from base directory
pub fn relative_path(path: text, base: text) -> text:
    rt_path_relative(path, base)

# Join two paths
extern fn rt_path_join(path1: text, path2: text) -> text

# Join two path segments
pub fn path_join(path1: text, path2: text) -> text:
    rt_path_join(path1, path2)

# =====================================
# Low-Level File Descriptor Operations
# =====================================

# Open a file and return file descriptor
extern fn rt_file_open(path: text, mode: text) -> i32

# Open a file (returns file descriptor or -1 on error)
pub fn open_file(path: text, mode: text) -> Result<i32, text>:
    val fd = rt_file_open(path, mode)
    if fd >= 0:
        Ok(fd)
    else:
        Err("Failed to open file: " + path)

# Get file size using file descriptor
extern fn rt_file_get_size(fd: i32) -> i32

# Get file size from file descriptor
pub fn fd_get_size(fd: i32) -> Option<i32>:
    val size = rt_file_get_size(fd)
    if size >= 0:
        Some(size)
    else:
        nil

# Close a file descriptor
extern fn rt_file_close(fd: i32) -> bool

# Close a file descriptor
pub fn close_file(fd: i32) -> Result<(), text>:
    val success = rt_file_close(fd)
    if success:
        Ok(())
    else:
        Err("Failed to close file descriptor")

# =====================================
# Utility Functions
# =====================================

# Check if path is a file
pub fn is_file(path: text) -> bool:
    file_exist(path)

# Check if path is a directory
pub fn is_dir(path: text) -> bool:
    # Try listing - if it works, it's a directory
    val entries = rt_dir_list(path)
    entries.len() >= 0  # Will return empty list for empty dirs

# Join path components with separator
pub fn join_path(parts: List<text>) -> text:
    val sep = path_separator()
    parts.join(sep)

# Split path into components
pub fn split_path(path: text) -> List<text>:
    val sep = path_separator()
    path.split(sep)
