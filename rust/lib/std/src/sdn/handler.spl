# SDN Handler Trait Definitions (Simple language wrappers)
#
# This module provides Simple language wrappers for the Rust SDN handler traits.
# The actual implementation is in the Rust crate (rust/sdn/).

# Handler result type
type HandlerResult<T> = Result<T, text>

# Data handler trait for primitive values
trait DataHandler:
    fn on_null(span: Span) -> HandlerResult<()>
    fn on_bool(value: bool, span: Span) -> HandlerResult<()>
    fn on_int(value: i64, span: Span) -> HandlerResult<()>
    fn on_float(value: f64, span: Span) -> HandlerResult<()>
    fn on_string(value: text, span: Span) -> HandlerResult<()>

# Operation handler trait for structural operations
trait OpHandler:
    fn begin_dict(span: Span) -> HandlerResult<()>
    fn dict_key(key: text, span: Span) -> HandlerResult<()>
    fn end_dict() -> HandlerResult<()>

    fn begin_array(span: Span) -> HandlerResult<()>
    fn end_array() -> HandlerResult<()>

    fn begin_table(fields: Option<List<text>>, types: Option<List<text>>, span: Span) -> HandlerResult<()>
    fn begin_row() -> HandlerResult<()>
    fn end_row() -> HandlerResult<()>
    fn end_table() -> HandlerResult<()>

# Combined handler trait
trait SdnHandler extends DataHandler, OpHandler:
    type Output
    fn finish(self) -> HandlerResult<Output>

# Span type for source location
struct Span:
    start: i64
    end: i64
    line: i64
    column: i64

impl Span:
    static fn default() -> Span:
        Span(start: 0, end: 0, line: 1, column: 1)

    fn merge(self, other: Span) -> Span:
        Span(
            start: if self.start < other.start: self.start else: other.start,
            end: if self.end > other.end: self.end else: other.end,
            line: self.line,
            column: self.column
        )

# Security validation handler (noop - no allocation)
struct NoopHandler:
    depth: i64
    max_depth: i64
    max_string_len: i64
    max_cell_count: i64
    cell_count: i64

impl NoopHandler:
    static fn new() -> NoopHandler:
        NoopHandler.with_limits(100, 1_048_576, 10_000_000)

    static fn with_limits(max_depth: i64, max_string_len: i64, max_cell_count: i64) -> NoopHandler:
        NoopHandler(
            depth: 0,
            max_depth: max_depth,
            max_string_len: max_string_len,
            max_cell_count: max_cell_count,
            cell_count: 0
        )

    me check_cell_count(span: Span) -> HandlerResult<()>:
        self.cell_count = self.cell_count + 1
        if self.cell_count > self.max_cell_count:
            Err("Cell count exceeds limit: {self.max_cell_count}")
        else:
            Ok(())

    fn check_depth(span: Span) -> HandlerResult<()>:
        if self.depth > self.max_depth:
            Err("Nesting depth exceeds limit: {self.max_depth}")
        else:
            Ok(())

impl DataHandler for NoopHandler:
    fn on_null(span: Span) -> HandlerResult<()>:
        self.check_cell_count(span)

    fn on_bool(value: bool, span: Span) -> HandlerResult<()>:
        self.check_cell_count(span)

    fn on_int(value: i64, span: Span) -> HandlerResult<()>:
        self.check_cell_count(span)

    fn on_float(value: f64, span: Span) -> HandlerResult<()>:
        self.check_cell_count(span)

    fn on_string(value: text, span: Span) -> HandlerResult<()>:
        if value.len() > self.max_string_len:
            Err("String exceeds max length: {value.len()} > {self.max_string_len}")
        else:
            self.check_cell_count(span)

impl OpHandler for NoopHandler:
    fn begin_dict(span: Span) -> HandlerResult<()>:
        self.depth = self.depth + 1
        self.check_depth(span)

    fn end_dict() -> HandlerResult<()>:
        self.depth = self.depth - 1
        Ok(())

    fn begin_array(span: Span) -> HandlerResult<()>:
        self.depth = self.depth + 1
        self.check_depth(span)

    fn end_array() -> HandlerResult<()>:
        self.depth = self.depth - 1
        Ok(())

    fn begin_table(fields: Option<List<text>>, types: Option<List<text>>, span: Span) -> HandlerResult<()>:
        self.depth = self.depth + 1
        self.check_depth(span)

    fn end_table() -> HandlerResult<()>:
        self.depth = self.depth - 1
        Ok(())

    fn begin_row() -> HandlerResult<()>:
        Ok(())

    fn end_row() -> HandlerResult<()>:
        Ok(())

    fn dict_key(key: text, span: Span) -> HandlerResult<()>:
        Ok(())

impl SdnHandler for NoopHandler:
    type Output = ()

    fn finish(self) -> HandlerResult<()>:
        Ok(())

# Restricted handler for policy enforcement
struct RestrictedHandler:
    allow_tables: bool
    allow_arrays: bool
    allow_nesting: bool
    depth: i64

impl RestrictedHandler:
    static fn new() -> RestrictedHandler:
        RestrictedHandler(
            allow_tables: true,
            allow_arrays: true,
            allow_nesting: true,
            depth: 0
        )

    static fn flat_dict_only() -> RestrictedHandler:
        RestrictedHandler(
            allow_tables: false,
            allow_arrays: false,
            allow_nesting: false,
            depth: 0
        )

    fn without_tables(self) -> RestrictedHandler:
        RestrictedHandler(
            allow_tables: false,
            allow_arrays: self.allow_arrays,
            allow_nesting: self.allow_nesting,
            depth: self.depth
        )

    fn without_arrays(self) -> RestrictedHandler:
        RestrictedHandler(
            allow_tables: self.allow_tables,
            allow_arrays: false,
            allow_nesting: self.allow_nesting,
            depth: self.depth
        )

# Safe key handler for validation
struct SafeKeyHandler:
    pass  # Implementation delegates to Rust

impl SafeKeyHandler:
    static fn new() -> SafeKeyHandler:
        SafeKeyHandler()

    fn validate_key(key: text, span: Span) -> HandlerResult<()>:
        # Reject prototype pollution
        if key == "__proto__" or key == "constructor" or key == "prototype":
            Err("Unsafe key rejected: {key}")
        else if key.contains("..") or key.starts_with("/") or key.starts_with("\\"):
            Err("Path traversal rejected: {key}")
        else:
            Ok(())

# TODO: Implement ValueBuilder and complete handler integration
# This requires FFI bindings to Rust implementation
