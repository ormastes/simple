# Layout - Layout Widgets (Column, Row, Stack, Container, Grid)
#
# Provides composable layout widgets using the builder pattern.
# Based on: doc/research/ui_framework_unified.md

use core.*
use ui.element.*
use ui.widget.*

# Column - Vertical flex container
pub struct Column:
    children: Array<Box<Widget>>
    spacing: i32
    align: Align
    padding: EdgeInsets

impl Column:
    # Create a new column
    pub fn new() -> Column:
        return Column {children: [], spacing: 0, align: Align.Start, padding: EdgeInsets.zero()}

    # Set spacing between children
    pub fn spacing(mut self, px: i32) -> Column:
        self.spacing = px
        return self

    # Set cross-axis alignment
    pub fn align(mut self, align: Align) -> Column:
        self.align = align
        return self

    # Set padding
    pub fn padding(mut self, insets: EdgeInsets) -> Column:
        self.padding = insets
        return self

    # Add a child widget
    pub fn child(mut self, widget: impl Widget) -> Column:
        self.children.push(Box.new(widget))
        return self

    # Add multiple children
    pub fn children(mut self, widgets: Array<Box<Widget>>) -> Column:
        for widget in widgets:
            self.children.push(widget)
        return self

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_children(self) -> bool:
        """Check if column has children.

        Returns:
            true if children exist

        Example:
            column.has_children()  # → true
        """
        return not self.children.is_empty()

    pub fn child_count(self) -> u64:
        """Get number of children.

        Returns:
            Count of children

        Example:
            column.child_count()  # → 3
        """
        return self.children.len()

    pub fn has_spacing(self) -> bool:
        """Check if spacing is set.

        Returns:
            true if spacing > 0

        Example:
            column.has_spacing()  # → false
        """
        return self.spacing > 0

    pub fn has_padding(self) -> bool:
        """Check if padding is set.

        Returns:
            true if any padding

        Example:
            column.has_padding()  # → false
        """
        return not (self.padding.top == 0 and self.padding.right == 0 and
                    self.padding.bottom == 0 and self.padding.left == 0)

    pub fn summary(self) -> text:
        """Get column summary.

        Returns:
            Human-readable summary

        Example:
            column.summary()  # → "Column: children=3, spacing=8"
        """
        val count = self.child_count()
        return "Column: children={count}, spacing={self.spacing}"

impl Widget for Column:
    fn build(ctx: &mut BuildContext) -> WidgetNode:
        val id = ctx.alloc_id()
        var elem = Element.new(id, ElementKind.Column)
            .with_class("flex flex-col")

        # Apply alignment
        val align_items = match self.align:
            case Align.Start: "flex-start"
            case Align.Center: "center"
            case Align.End: "flex-end"
            case Align.Stretch: "stretch"

        elem = elem
            .with_style("display", "flex")
            .with_style("flex-direction", "column")
            .with_style("align-items", align_items)

        # Apply spacing
        if self.spacing > 0:
            elem = elem.with_style("gap", &"{self.spacing}px")

        # Apply padding
        if not (self.padding.top == 0 and self.padding.right == 0 and
                self.padding.bottom == 0 and self.padding.left == 0):
            elem = elem.with_style("padding", &self.padding.to_css())

        # Build children
        var child_ctx = ctx.with_parent(id)
        for child in &self.children:
            val child_node = child.build(&mut child_ctx)
            elem = elem.with_child(child_node.to_element())

        return WidgetNode.new(elem)

# Row - Horizontal flex container
pub struct Row:
    children: Array<Box<Widget>>
    spacing: i32
    justify: Justify
    align: Align
    padding: EdgeInsets

impl Row:
    # Create a new row
    pub fn new() -> Row:
        return Row {
            children: [],
            spacing: 0,
            justify: Justify.Start,
            align: Align.Center,
            padding: EdgeInsets.zero()
        }

    # Set spacing between children
    pub fn spacing(mut self, px: i32) -> Row:
        self.spacing = px
        return self

    # Set main-axis justification
    pub fn justify(mut self, justify: Justify) -> Row:
        self.justify = justify
        return self

    # Set cross-axis alignment
    pub fn align(mut self, align: Align) -> Row:
        self.align = align
        return self

    # Set padding
    pub fn padding(mut self, insets: EdgeInsets) -> Row:
        self.padding = insets
        return self

    # Add a child widget
    pub fn child(mut self, widget: impl Widget) -> Row:
        self.children.push(Box.new(widget))
        return self

    # Add multiple children
    pub fn children(mut self, widgets: Array<Box<Widget>>) -> Row:
        for widget in widgets:
            self.children.push(widget)
        return self

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_children(self) -> bool:
        """Check if row has children.

        Returns:
            true if children exist

        Example:
            row.has_children()  # → true
        """
        return not self.children.is_empty()

    pub fn child_count(self) -> u64:
        """Get number of children.

        Returns:
            Count of children

        Example:
            row.child_count()  # → 4
        """
        return self.children.len()

    pub fn has_spacing(self) -> bool:
        """Check if spacing is set.

        Returns:
            true if spacing > 0

        Example:
            row.has_spacing()  # → true
        """
        return self.spacing > 0

    pub fn has_padding(self) -> bool:
        """Check if padding is set.

        Returns:
            true if any padding

        Example:
            row.has_padding()  # → false
        """
        return not (self.padding.top == 0 and self.padding.right == 0 and
                    self.padding.bottom == 0 and self.padding.left == 0)

    pub fn summary(self) -> text:
        """Get row summary.

        Returns:
            Human-readable summary

        Example:
            row.summary()  # → "Row: children=4, spacing=16"
        """
        val count = self.child_count()
        return "Row: children={count}, spacing={self.spacing}"

impl Widget for Row:
    fn build(ctx: &mut BuildContext) -> WidgetNode:
        val id = ctx.alloc_id()
        var elem = Element.new(id, ElementKind.Row)
            .with_class("flex flex-row")

        # Apply justification
        val justify_content = match self.justify:
            case Justify.Start: "flex-start"
            case Justify.Center: "center"
            case Justify.End: "flex-end"
            case Justify.SpaceBetween: "space-between"
            case Justify.SpaceAround: "space-around"
            case Justify.SpaceEvenly: "space-evenly"

        # Apply alignment
        val align_items = match self.align:
            case Align.Start: "flex-start"
            case Align.Center: "center"
            case Align.End: "flex-end"
            case Align.Stretch: "stretch"

        elem = elem
            .with_style("display", "flex")
            .with_style("flex-direction", "row")
            .with_style("justify-content", justify_content)
            .with_style("align-items", align_items)

        # Apply spacing
        if self.spacing > 0:
            elem = elem.with_style("gap", &"{self.spacing}px")

        # Apply padding
        if not (self.padding.top == 0 and self.padding.right == 0 and
                self.padding.bottom == 0 and self.padding.left == 0):
            elem = elem.with_style("padding", &self.padding.to_css())

        # Build children
        var child_ctx = ctx.with_parent(id)
        for child in &self.children:
            val child_node = child.build(&mut child_ctx)
            elem = elem.with_child(child_node.to_element())

        return WidgetNode.new(elem)

# Stack - Layered/absolute positioned container
pub struct Stack:
    children: Array<Box<Widget>>
    alignment: Alignment

impl Stack:
    # Create a new stack
    pub fn new() -> Stack:
        return Stack {
            children: [],
            alignment: Alignment.TopLeft
        }

    # Set alignment for children
    pub fn alignment(mut self, alignment: Alignment) -> Stack:
        self.alignment = alignment
        return self

    # Add a child widget
    pub fn child(mut self, widget: impl Widget) -> Stack:
        self.children.push(Box.new(widget))
        return self

    # Add multiple children
    pub fn children(mut self, widgets: Array<Box<Widget>>) -> Stack:
        for widget in widgets:
            self.children.push(widget)
        return self

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_children(self) -> bool:
        """Check if stack has children.

        Returns:
            true if children exist

        Example:
            stack.has_children()  # → true
        """
        return not self.children.is_empty()

    pub fn child_count(self) -> u64:
        """Get number of children (layers).

        Returns:
            Count of children

        Example:
            stack.child_count()  # → 2
        """
        return self.children.len()

    pub fn summary(self) -> text:
        """Get stack summary.

        Returns:
            Human-readable summary

        Example:
            stack.summary()  # → "Stack: layers=2"
        """
        val count = self.child_count()
        return "Stack: layers={count}"

impl Widget for Stack:
    fn build(ctx: &mut BuildContext) -> WidgetNode:
        val id = ctx.alloc_id()
        var elem = Element.new(id, ElementKind.Div)
            .with_class("stack")
            .with_style("position", "relative")

        # Build children with absolute positioning
        var child_ctx = ctx.with_parent(id)
        for child in &self.children:
            val child_node = child.build(&mut child_ctx)
            var child_elem = child_node.to_element()

            # Apply absolute positioning
            child_elem = child_elem.with_style("position", "absolute")

            # Apply alignment
            match self.alignment:
                case Alignment.TopLeft:
                    child_elem = child_elem
                        .with_style("top", "0")
                        .with_style("left", "0")
                case Alignment.TopCenter:
                    child_elem = child_elem
                        .with_style("top", "0")
                        .with_style("left", "50%")
                        .with_style("transform", "translateX(-50%)")
                case Alignment.TopRight:
                    child_elem = child_elem
                        .with_style("top", "0")
                        .with_style("right", "0")
                case Alignment.CenterLeft:
                    child_elem = child_elem
                        .with_style("top", "50%")
                        .with_style("left", "0")
                        .with_style("transform", "translateY(-50%)")
                case Alignment.Center:
                    child_elem = child_elem
                        .with_style("top", "50%")
                        .with_style("left", "50%")
                        .with_style("transform", "translate(-50%, -50%)")
                case Alignment.CenterRight:
                    child_elem = child_elem
                        .with_style("top", "50%")
                        .with_style("right", "0")
                        .with_style("transform", "translateY(-50%)")
                case Alignment.BottomLeft:
                    child_elem = child_elem
                        .with_style("bottom", "0")
                        .with_style("left", "0")
                case Alignment.BottomCenter:
                    child_elem = child_elem
                        .with_style("bottom", "0")
                        .with_style("left", "50%")
                        .with_style("transform", "translateX(-50%)")
                case Alignment.BottomRight:
                    child_elem = child_elem
                        .with_style("bottom", "0")
                        .with_style("right", "0")

            elem = elem.with_child(child_elem)

        return WidgetNode.new(elem)

# Container - Box with padding, margin, and decoration
pub struct Container:
    child: Option<Box<Widget>>
    padding: EdgeInsets
    margin: EdgeInsets
    width: Option<i32>
    height: Option<i32>
    background_color: Option<Color>
    border_radius: Option<i32>
    border_width: Option<i32>
    border_color: Option<Color>

impl Container:
    # Create a new container
    pub fn new() -> Container:
        return Container {
            child: None,
            padding: EdgeInsets.zero(),
            margin: EdgeInsets.zero(),
            width: None,
            height: None,
            background_color: None,
            border_radius: None,
            border_width: None,
            border_color: None
        }

    # Set child widget
    pub fn child(mut self, widget: impl Widget) -> Container:
        self.child = Some(Box.new(widget))
        return self

    # Set padding
    pub fn padding(mut self, insets: EdgeInsets) -> Container:
        self.padding = insets
        return self

    # Set margin
    pub fn margin(mut self, insets: EdgeInsets) -> Container:
        self.margin = insets
        return self

    # Set width
    pub fn width(mut self, width: i32) -> Container:
        self.width = Some(width)
        return self

    # Set height
    pub fn height(mut self, height: i32) -> Container:
        self.height = Some(height)
        return self

    # Set background color
    pub fn background(mut self, color: Color) -> Container:
        self.background_color = Some(color)
        return self

    # Set border radius
    pub fn border_radius(mut self, radius: i32) -> Container:
        self.border_radius = Some(radius)
        return self

    # Set border
    pub fn border(mut self, width: i32, color: Color) -> Container:
        self.border_width = Some(width)
        self.border_color = Some(color)
        return self

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_child(self) -> bool:
        """Check if container has a child.

        Returns:
            true if child is set

        Example:
            container.has_child()  # → true
        """
        return self.child.is_some()

    pub fn is_empty(self) -> bool:
        """Check if container has no child.

        Returns:
            true if no child

        Example:
            container.is_empty()  # → false
        """
        return self.child.is_none()

    pub fn has_width(self) -> bool:
        """Check if width is set.

        Returns:
            true if width is set

        Example:
            container.has_width()  # → true
        """
        return self.width.is_some()

    pub fn has_height(self) -> bool:
        """Check if height is set.

        Returns:
            true if height is set

        Example:
            container.has_height()  # → false
        """
        return self.height.is_some()

    pub fn has_background(self) -> bool:
        """Check if background color is set.

        Returns:
            true if background is set

        Example:
            container.has_background()  # → true
        """
        return self.background_color.is_some()

    pub fn has_border(self) -> bool:
        """Check if border is set.

        Returns:
            true if border configured

        Example:
            container.has_border()  # → false
        """
        return self.border_width.is_some() and self.border_color.is_some()

    pub fn has_border_radius(self) -> bool:
        """Check if border radius is set.

        Returns:
            true if border radius set

        Example:
            container.has_border_radius()  # → true
        """
        return self.border_radius.is_some()

    pub fn has_padding(self) -> bool:
        """Check if padding is set.

        Returns:
            true if any padding

        Example:
            container.has_padding()  # → false
        """
        return not (self.padding.top == 0 and self.padding.right == 0 and
                    self.padding.bottom == 0 and self.padding.left == 0)

    pub fn has_margin(self) -> bool:
        """Check if margin is set.

        Returns:
            true if any margin

        Example:
            container.has_margin()  # → false
        """
        return not (self.margin.top == 0 and self.margin.right == 0 and
                    self.margin.bottom == 0 and self.margin.left == 0)

    pub fn summary(self) -> text:
        """Get container summary.

        Returns:
            Human-readable summary

        Example:
            container.summary()
            # → "Container: has_child=true, width=Some, height=Some"
        """
        val child = if self.has_child() { "true" } else { "false" }
        val width = if self.has_width() { "Some" } else { "None" }
        val height = if self.has_height() { "Some" } else { "None" }
        return "Container: has_child={child}, width={width}, height={height}"

impl Widget for Container:
    fn build(ctx: &mut BuildContext) -> WidgetNode:
        val id = ctx.alloc_id()
        var elem = Element.new(id, ElementKind.Div)
            .with_class("container")

        # Apply padding
        if not (self.padding.top == 0 and self.padding.right == 0 and
                self.padding.bottom == 0 and self.padding.left == 0):
            elem = elem.with_style("padding", &self.padding.to_css())

        # Apply margin
        if not (self.margin.top == 0 and self.margin.right == 0 and
                self.margin.bottom == 0 and self.margin.left == 0):
            elem = elem.with_style("margin", &self.margin.to_css())

        # Apply width/height
        if val Some(w) = self.width:
            elem = elem.with_style("width", &"{w}px")
        if val Some(h) = self.height:
            elem = elem.with_style("height", &"{h}px")

        # Apply background color
        if val Some(color) = &self.background_color:
            elem = elem.with_style("background-color", &color.to_css())

        # Apply border radius
        if val Some(radius) = self.border_radius:
            elem = elem.with_style("border-radius", &"{radius}px")

        # Apply border
        if val Some(width) = self.border_width:
            if val Some(color) = &self.border_color:
                elem = elem.with_style("border", &"{width}px solid {color.to_css()}")

        # Build child
        if val Some(child) = &self.child:
            var child_ctx = ctx.with_parent(id)
            val child_node = child.build(&mut child_ctx)
            elem = elem.with_child(child_node.to_element())

        return WidgetNode.new(elem)

# Grid - CSS Grid container
pub struct Grid:
    children: Array<Box<Widget>>
    columns: u32
    rows: Option<u32>
    gap: i32
    column_gap: Option<i32>
    row_gap: Option<i32>

impl Grid:
    # Create a new grid with specified columns
    pub fn new(columns: u32) -> Grid:
        return Grid {
            children: [],
            columns: columns,
            rows: None,
            gap: 0,
            column_gap: None,
            row_gap: None
        }

    # Set number of rows
    pub fn rows(mut self, rows: u32) -> Grid:
        self.rows = Some(rows)
        return self

    # Set gap (both column and row)
    pub fn gap(mut self, gap: i32) -> Grid:
        self.gap = gap
        return self

    # Set column gap
    pub fn column_gap(mut self, gap: i32) -> Grid:
        self.column_gap = Some(gap)
        return self

    # Set row gap
    pub fn row_gap(mut self, gap: i32) -> Grid:
        self.row_gap = Some(gap)
        return self

    # Add a child widget
    pub fn child(mut self, widget: impl Widget) -> Grid:
        self.children.push(Box.new(widget))
        return self

    # Add multiple children
    pub fn children(mut self, widgets: Array<Box<Widget>>) -> Grid:
        for widget in widgets:
            self.children.push(widget)
        return self

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_children(self) -> bool:
        """Check if grid has children.

        Returns:
            true if children exist

        Example:
            grid.has_children()  # → true
        """
        return not self.children.is_empty()

    pub fn child_count(self) -> u64:
        """Get number of children.

        Returns:
            Count of children

        Example:
            grid.child_count()  # → 6
        """
        return self.children.len()

    pub fn has_rows(self) -> bool:
        """Check if row count is specified.

        Returns:
            true if rows is set

        Example:
            grid.has_rows()  # → false
        """
        return self.rows.is_some()

    pub fn has_gap(self) -> bool:
        """Check if gap is set.

        Returns:
            true if gap > 0

        Example:
            grid.has_gap()  # → true
        """
        return self.gap > 0

    pub fn has_custom_gaps(self) -> bool:
        """Check if custom column/row gaps set.

        Returns:
            true if column_gap or row_gap set

        Example:
            grid.has_custom_gaps()  # → false
        """
        return self.column_gap.is_some() or self.row_gap.is_some()

    pub fn get_columns(self) -> u32:
        """Get number of columns.

        Returns:
            Column count

        Example:
            grid.get_columns()  # → 3
        """
        return self.columns

    pub fn summary(self) -> text:
        """Get grid summary.

        Returns:
            Human-readable summary

        Example:
            grid.summary()  # → "Grid: cols=3, children=6, gap=8"
        """
        val count = self.child_count()
        return "Grid: cols={self.columns}, children={count}, gap={self.gap}"

impl Widget for Grid:
    fn build(ctx: &mut BuildContext) -> WidgetNode:
        val id = ctx.alloc_id()
        var elem = Element.new(id, ElementKind.Grid)
            .with_class("grid")
            .with_style("display", "grid")
            .with_style("grid-template-columns", &"repeat({self.columns}, 1fr)")

        # Apply rows if specified
        if val Some(rows) = self.rows:
            elem = elem.with_style("grid-template-rows", &"repeat({rows}, 1fr)")

        # Apply gap
        val col_gap = self.column_gap.unwrap_or(self.gap)
        val row_gap = self.row_gap.unwrap_or(self.gap)

        if col_gap > 0:
            elem = elem.with_style("column-gap", &"{col_gap}px")
        if row_gap > 0:
            elem = elem.with_style("row-gap", &"{row_gap}px")

        # Build children
        var child_ctx = ctx.with_parent(id)
        for child in &self.children:
            val child_node = child.build(&mut child_ctx)
            elem = elem.with_child(child_node.to_element())

        return WidgetNode.new(elem)

# Spacer - Flexible space filler
pub struct Spacer:
    flex: f64

impl Spacer:
    # Create a flexible spacer (default flex = 1.0)
    pub fn new() -> Spacer:
        return Spacer { flex: 1.0 }

    # Create a spacer with specific flex value
    pub fn flex(flex: f64) -> Spacer:
        return Spacer { flex: flex }

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn get_flex(self) -> f64:
        """Get flex value.

        Returns:
            Flex value

        Example:
            spacer.get_flex()  # → 1.0
        """
        return self.flex

    pub fn is_default_flex(self) -> bool:
        """Check if using default flex (1.0).

        Returns:
            true if flex is 1.0

        Example:
            spacer.is_default_flex()  # → true
        """
        return self.flex == 1.0

    pub fn summary(self) -> text:
        """Get spacer summary.

        Returns:
            Human-readable summary

        Example:
            spacer.summary()  # → "Spacer: flex=1.0"
        """
        return "Spacer: flex={self.flex}"

impl Widget for Spacer:
    fn build(ctx: &mut BuildContext) -> WidgetNode:
        val id = ctx.alloc_id()
        val elem = Element.new(id, ElementKind.Div)
            .with_class("spacer")
            .with_style("flex", &"{self.flex}")

        return WidgetNode.new(elem)
