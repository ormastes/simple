# Async Layout Engine
#
# CPU-side layout computation with parallel processing.

use core.*
use concurrency.*
use ui.element.*

use types.{BoxConstraints, LayoutResult, LayoutCache, DirtyRegion}

export AsyncLayoutEngine

# ============================================================================
# Async Layout Engine
# ============================================================================

struct AsyncLayoutEngine:
    cache: LayoutCache

impl AsyncLayoutEngine:
    static fn new() -> AsyncLayoutEngine:
        return AsyncLayoutEngine {cache: LayoutCache.new()}

    # Compute layout asynchronously (can parallelize children)
    async fn compute_layout_async(self, elem: &Element, constraints: BoxConstraints)
        -> Future<LayoutResult>:
        # Check cache (fast path)
        if val Some(cached) = self.cache.get(elem.id):
            if cached.constraints == constraints:
                return Future.ready(cached.result)

        # For complex layouts with many children, parallelize
        if elem.children.len() > 4:
            return await self.parallel_layout(elem, constraints)
        else:
            return await self.sequential_layout(elem, constraints)

    # Layout children in parallel
    async fn parallel_layout(self, elem: &Element, constraints: BoxConstraints)
        -> Future<LayoutResult>:
        val children_futures: Array<Future<LayoutResult>> = []

        for child in &elem.children:
            val child_constraints = self.compute_child_constraints(child, constraints)
            val future = async {
                self.compute_layout_async(child, child_constraints)
            }
            children_futures.push(future)

        # Wait for all children in parallel
        val children_results = await Future.all(children_futures)

        # Combine results
        val result = self.combine_layout_results(elem, &children_results)

        # Cache
        self.cache.set(elem.id, constraints, result)

        return Future.ready(result)

    # Layout children sequentially (for small trees)
    async fn sequential_layout(self, elem: &Element, constraints: BoxConstraints)
        -> Future<LayoutResult>:
        # Dispatch to appropriate layout algorithm based on element kind
        val result = match elem.kind:
            case ElementKind.Row:
                self.layout_flexbox_row(elem, constraints)
            case ElementKind.Column:
                self.layout_flexbox_column(elem, constraints)
            case ElementKind.Grid:
                self.layout_grid(elem, constraints)
            case _:
                self.layout_block(elem, constraints)

        return Future.ready(result)

    fn layout_flexbox_row(elem: &Element, constraints: BoxConstraints) -> LayoutResult:
        # Horizontal flexbox layout
        var child_layouts: Array<ChildLayout> = []
        var x_offset: f32 = 0.0
        val child_width = constraints.max_width / elem.children.len().max(1) as f32

        for child in elem.children:
            child_layouts.push(ChildLayout {
                id: child.id,
                position: Point { x: x_offset, y: 0.0 },
                size: Size { width: child_width, height: constraints.max_height }
            })
            x_offset += child_width

        return LayoutResult {
            size: Size { width: constraints.max_width, height: constraints.max_height },
            children: child_layouts
        }

    fn layout_flexbox_column(elem: &Element, constraints: BoxConstraints) -> LayoutResult:
        # Vertical flexbox layout
        var child_layouts: Array<ChildLayout> = []
        var y_offset: f32 = 0.0
        val child_height = constraints.max_height / elem.children.len().max(1) as f32

        for child in elem.children:
            child_layouts.push(ChildLayout {
                id: child.id,
                position: Point { x: 0.0, y: y_offset },
                size: Size { width: constraints.max_width, height: child_height }
            })
            y_offset += child_height

        return LayoutResult {
            size: Size { width: constraints.max_width, height: constraints.max_height },
            children: child_layouts
        }

    fn layout_grid(elem: &Element, constraints: BoxConstraints) -> LayoutResult:
        # Simple grid layout (2 columns by default)
        val cols = 2
        var child_layouts: Array<ChildLayout> = []
        val cell_width = constraints.max_width / cols as f32
        val cell_height = constraints.max_height / ((elem.children.len() + 1) / cols) as f32

        for (i, child) in elem.children.iter().enumerate():
            val col = i % cols
            val row = i / cols
            child_layouts.push(ChildLayout {
                id: child.id,
                position: Point { x: col as f32 * cell_width, y: row as f32 * cell_height },
                size: Size { width: cell_width, height: cell_height }
            })

        return LayoutResult {
            size: Size { width: constraints.max_width, height: constraints.max_height },
            children: child_layouts
        }

    fn layout_block(elem: &Element, constraints: BoxConstraints) -> LayoutResult:
        # Block layout: stack children vertically
        var child_layouts: Array<ChildLayout> = []
        var y_offset: f32 = 0.0
        val child_height = constraints.max_height / elem.children.len().max(1) as f32

        for child in elem.children:
            child_layouts.push(ChildLayout {
                id: child.id,
                position: Point { x: 0.0, y: y_offset },
                size: Size { width: constraints.max_width, height: child_height }
            })
            y_offset += child_height

        return LayoutResult {
            size: Size { width: constraints.max_width, height: y_offset },
            children: child_layouts
        }

    async fn recompute_region_async(self, region: &DirtyRegion) -> Future<LayoutResult>:
        # Only recompute elements that fall within the dirty region
        # This is an optimization for partial updates

        # Get the root element for this dirty region
        val root_elem = match region.root_element:
            case Some(elem): elem
            case None: return Future.ready(LayoutResult.default())

        # Compute constraints based on dirty region bounds
        val constraints = BoxConstraints {
            min_width: 0.0,
            max_width: region.bounds.width,
            min_height: 0.0,
            max_height: region.bounds.height
        }

        # Recompute layout starting from the dirty root
        # Invalidate cache for this subtree first
        self.invalidate_subtree(root_elem)

        return await self.compute_layout_async(root_elem, constraints)

    fn invalidate_subtree(elem: &Element):
        # Remove this element from cache
        self.cache.remove(elem.id)
        # Recursively invalidate children
        for child in &elem.children:
            self.invalidate_subtree(child)

    fn compute_child_constraints(child: &Element, parent: BoxConstraints) -> BoxConstraints:
        # Compute constraints based on child's style properties
        var min_w: f32 = 0.0
        var max_w: f32 = parent.max_width
        var min_h: f32 = 0.0
        var max_h: f32 = parent.max_height

        # Check for explicit width style
        if val Some(width_str) = child.styles.get("width"):
            if width_str.ends_with("px"):
                val w = parse_float(width_str.trim_end_matches("px")).unwrap_or(0.0)
                min_w = w
                max_w = w
            elif width_str.ends_with("%"):
                val pct = parse_float(width_str.trim_end_matches("%")).unwrap_or(100.0)
                val w = parent.max_width * (pct / 100.0)
                min_w = w
                max_w = w

        # Check for explicit height style
        if val Some(height_str) = child.styles.get("height"):
            if height_str.ends_with("px"):
                val h = parse_float(height_str.trim_end_matches("px")).unwrap_or(0.0)
                min_h = h
                max_h = h
            elif height_str.ends_with("%"):
                val pct = parse_float(height_str.trim_end_matches("%")).unwrap_or(100.0)
                val h = parent.max_height * (pct / 100.0)
                min_h = h
                max_h = h

        # Check for min/max constraints
        if val Some(min_width_str) = child.styles.get("min-width"):
            min_w = parse_dimension(min_width_str, parent.max_width).max(min_w)
        if val Some(max_width_str) = child.styles.get("max-width"):
            max_w = parse_dimension(max_width_str, parent.max_width).min(max_w)
        if val Some(min_height_str) = child.styles.get("min-height"):
            min_h = parse_dimension(min_height_str, parent.max_height).max(min_h)
        if val Some(max_height_str) = child.styles.get("max-height"):
            max_h = parse_dimension(max_height_str, parent.max_height).min(max_h)

        # Handle flex properties
        if val Some(flex_str) = child.styles.get("flex"):
            # flex: N means flexible sizing - don't constrain max
            max_w = parent.max_width
            max_h = parent.max_height

        return BoxConstraints {
            min_width: min_w.max(0.0),
            max_width: max_w.max(min_w),
            min_height: min_h.max(0.0),
            max_height: max_h.max(min_h)
        }

    fn combine_layout_results(elem: &Element, children: &Array<LayoutResult>) -> LayoutResult:
        # Combine child results based on element's layout direction

        var child_layouts: Array<ChildLayout> = []
        var total_width: f32 = 0.0
        var total_height: f32 = 0.0
        var x_offset: f32 = 0.0
        var y_offset: f32 = 0.0

        # Determine layout direction from element kind or style
        val is_row = match elem.kind:
            case ElementKind.Row: true
            case _:
                elem.styles.get("flex-direction").map(|d| d == "row").unwrap_or(false)

        for (i, child_result) in children.iter().enumerate():
            val child_elem = &elem.children[i]

            if is_row:
                # Horizontal arrangement
                child_layouts.push(ChildLayout {
                    id: child_elem.id,
                    position: Point { x: x_offset, y: 0.0 },
                    size: child_result.size
                })
                x_offset += child_result.size.width
                total_width = x_offset
                total_height = total_height.max(child_result.size.height)
            else:
                # Vertical arrangement (default)
                child_layouts.push(ChildLayout {
                    id: child_elem.id,
                    position: Point { x: 0.0, y: y_offset },
                    size: child_result.size
                })
                y_offset += child_result.size.height
                total_width = total_width.max(child_result.size.width)
                total_height = y_offset

        return LayoutResult {
            size: Size { width: total_width, height: total_height },
            children: child_layouts
        }

# Helper function to parse dimension values (px, %, em)
fn parse_dimension(value: &str, reference: f32) -> f32:
    if value.ends_with("px"):
        return parse_float(value.trim_end_matches("px")).unwrap_or(0.0)
    elif value.ends_with("%"):
        val pct = parse_float(value.trim_end_matches("%")).unwrap_or(0.0)
        return reference * (pct / 100.0)
    elif value.ends_with("em"):
        val em = parse_float(value.trim_end_matches("em")).unwrap_or(0.0)
        return em * 16.0  # Assume 16px base font size
    else:
        return parse_float(value).unwrap_or(0.0)

fn parse_float(s: &str) -> Option<f32>:
    # Simple float parsing
    match s.parse.<f32>():
        case Ok(v): Some(v)
        case Err(_): None
