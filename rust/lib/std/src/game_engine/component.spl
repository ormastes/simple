# Common Component Trait
#
# Engine-agnostic component interface
# Provides trait-only interfaces (no FFI adapter implementations)
#
# Features:
# - Component lifecycle (init, update, destroy)
# - Owner access
# - Enable/disable state
# - Component queries
# - Engine-agnostic API

use math

mod component

# ComponentType
# Standard component categories
pub enum ComponentType:
    Transform = 0
    Render = 1
    Physics = 2
    Audio = 3
    Script = 4
    Custom = 5

impl ComponentType:
    pub fn to_string(self) -> text:
        if self == ComponentType.Transform:
            return "Transform"
        elif self == ComponentType.Render:
            return "Render"
        elif self == ComponentType.Physics:
            return "Physics"
        elif self == ComponentType.Audio:
            return "Audio"
        elif self == ComponentType.Script:
            return "Script"
        else:
            return "Custom"

    pub fn description(self) -> text:
        """Get component type description."""
        if self == ComponentType.Transform:
            return "Position, rotation, and scale"
        elif self == ComponentType.Render:
            return "Visual rendering (meshes, sprites)"
        elif self == ComponentType.Physics:
            return "Physics simulation and collision"
        elif self == ComponentType.Audio:
            return "Audio playback and spatial sound"
        elif self == ComponentType.Script:
            return "Scripting and logic behavior"
        else:
            return "Custom component type"

    pub fn is_transform(self) -> bool:
        return self == ComponentType.Transform

    pub fn is_render(self) -> bool:
        return self == ComponentType.Render

    pub fn is_physics(self) -> bool:
        return self == ComponentType.Physics

    pub fn is_audio(self) -> bool:
        return self == ComponentType.Audio

    pub fn is_script(self) -> bool:
        return self == ComponentType.Script

    pub fn is_custom(self) -> bool:
        return self == ComponentType.Custom

    pub fn is_visual(self) -> bool:
        """Check if component type affects visual output."""
        return self == ComponentType.Render

    pub fn is_simulation(self) -> bool:
        """Check if component type affects physics simulation."""
        return self == ComponentType.Physics or self == ComponentType.Transform

    pub fn is_output(self) -> bool:
        """Check if component type produces output (visual or audio)."""
        return self == ComponentType.Render or self == ComponentType.Audio

    pub fn summary(self) -> text:
        """Get component type summary."""
        val name = self.to_string()
        val desc = self.description()
        var props = []

        if self.is_visual():
            props.push("visual")
        if self.is_simulation():
            props.push("simulation")
        if self.is_output():
            props.push("output")

        if props.len() > 0:
            val props_str = ", ".join(props)
            return "ComponentType: {name} ({desc}, {props_str})"
        else:
            return "ComponentType: {name} ({desc})"


# Component trait
# Common interface for all components
pub trait Component:
    # Lifecycle
    me init()
    me update(delta: f32)
    me destroy()

    # State
    fn is_enabled() -> bool
    me set_enabled(enabled: bool)
    fn is_initialized() -> bool

    # Metadata
    fn get_component_type() -> ComponentType
    fn get_component_name() -> text


# ComponentManager
# Manages components on an entity
pub struct ComponentManager:
    components: Vec<Component>

impl ComponentManager:
    pub static fn create() -> ComponentManager:
        return ComponentManager(components: [])

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn count(self) -> i32:
        """Get number of components."""
        return self.components.len()

    pub fn is_empty(self) -> bool:
        """Check if manager has no components."""
        return self.components.len() == 0

    pub fn has_components(self) -> bool:
        """Check if manager has any components."""
        return self.components.len() > 0

    pub fn has_component_type(self, component_type: ComponentType) -> bool:
        """Check if has component of given type."""
        for component in self.components:
            if component.get_component_type() == component_type:
                return true
        return false

    pub fn count_by_type(self, component_type: ComponentType) -> i32:
        """Count components of given type."""
        var count = 0
        for component in self.components:
            if component.get_component_type() == component_type:
                count += 1
        return count

    pub fn count_enabled(self) -> i32:
        """Count enabled components."""
        var count = 0
        for component in self.components:
            if component.is_enabled():
                count += 1
        return count

    pub fn count_initialized(self) -> i32:
        """Count initialized components."""
        var count = 0
        for component in self.components:
            if component.is_initialized():
                count += 1
        return count

    pub fn all_initialized(self) -> bool:
        """Check if all components are initialized."""
        for component in self.components:
            if not component.is_initialized():
                return false
        return true

    pub fn summary(self) -> text:
        """Get component manager summary."""
        val total = self.count()
        val enabled = self.count_enabled()
        val initialized = self.count_initialized()
        return "ComponentManager: {total} components, {enabled} enabled, {initialized} initialized"

    # Add component
    pub fn add_component(mut self, component: Component):
        self.components.push(component)

    # Remove component by index
    pub fn remove_component(mut self, index: i32):
        if index >= 0 and index < self.components.len():
            var new_components = Vec.new()
            for i in 0..self.components.len():
                if i != index:
                    new_components.push(self.components[i])
            self.components = new_components

    # Get component by type
    pub fn get_component_by_type(self, component_type: ComponentType) -> Option<Component>:
        for component in self.components:
            if component.get_component_type() == component_type:
                return Some(component)
        return None

    # Get all components
    pub fn get_all_components(self) -> Vec<Component>:
        return self.components

    # Update all components
    pub fn update_all(mut self, delta: f32):
        for mut component in self.components:
            if component.is_enabled():
                component.update(delta)

    # Initialize all components
    pub fn init_all(mut self):
        for mut component in self.components:
            if not component.is_initialized():
                component.init()

    # Destroy all components
    pub fn destroy_all(mut self):
        for mut component in self.components:
            component.destroy()
        self.components = []


# RenderComponent trait
# Specialized component for rendering
pub trait RenderComponent: Component:
    fn is_visible() -> bool
    me set_visible(visible: bool)


# PhysicsComponent trait
# Specialized component for physics
pub trait PhysicsComponent: Component:
    fn get_mass() -> f32
    me set_mass(mass: f32)
    fn get_velocity() -> math.Vec3
    me set_velocity(vel: math.Vec3)
    me apply_force(force: math.Vec3)
    me apply_impulse(impulse: math.Vec3)


# AudioComponent trait
# Specialized component for audio
pub trait AudioComponent: Component:
    me play()
    me stop()
    me pause()
    me resume()
    fn is_playing() -> bool
    fn get_volume() -> f32
    me set_volume(volume: f32)
    fn get_pitch() -> f32
    me set_pitch(pitch: f32)
