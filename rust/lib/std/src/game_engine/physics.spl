# Common Physics Abstraction
#
# Engine-agnostic physics interface
# Provides trait-only interfaces (no FFI adapter implementations)
#
# Features:
# - Rigidbody simulation traits
# - Collision detection
# - Ray casting
# - Physics materials
# - Constraints and joints

use math

mod physics

# RigidBodyType
# Type of rigidbody simulation
pub enum RigidBodyType:
    Static = 0      # Does not move
    Kinematic = 1   # Moves via script, no physics
    Dynamic = 2     # Full physics simulation

impl RigidBodyType:
    pub fn to_int(self) -> i32:
        if self == RigidBodyType.Static:
            return 0
        elif self == RigidBodyType.Kinematic:
            return 1
        else:
            return 2

    pub fn to_string(self) -> text:
        """Convert rigid body type to string."""
        match self:
            case Static: "static"
            case Kinematic: "kinematic"
            case Dynamic: "dynamic"

    pub fn description(self) -> text:
        """Get rigid body type description."""
        match self:
            case Static: "Does not move"
            case Kinematic: "Moves via script, no physics"
            case Dynamic: "Full physics simulation"

    pub fn is_static(self) -> bool:
        match self:
            case Static: true
            case _: false

    pub fn is_kinematic(self) -> bool:
        match self:
            case Kinematic: true
            case _: false

    pub fn is_dynamic(self) -> bool:
        match self:
            case Dynamic: true
            case _: false

    pub fn is_movable(self) -> bool:
        """Check if body can move."""
        match self:
            case Static: false
            case _: true

    pub fn is_physics_driven(self) -> bool:
        """Check if body is driven by physics."""
        match self:
            case Dynamic: true
            case _: false

    pub fn summary(self) -> text:
        """Get rigid body type summary."""
        val name = self.to_string()
        val desc = self.description()
        var props = []

        if self.is_movable():
            props.push("movable")
        else:
            props.push("static")

        if self.is_physics_driven():
            props.push("physics-driven")

        val props_str = props.join(", ")
        return "RigidBodyType: {name} ({desc}, {props_str})"


# CollisionShape
# Common collision shape types
pub enum CollisionShape:
    Box(f32, f32, f32)          # Half extents
    Sphere(f32)                 # Radius
    Capsule(f32, f32)          # Radius, height
    Cylinder(f32, f32)         # Radius, height

impl CollisionShape:
    pub fn to_string(self) -> text:
        match self:
            case Box(_, _, _): "box"
            case Sphere(_): "sphere"
            case Capsule(_, _): "capsule"
            case Cylinder(_, _): "cylinder"

    pub fn description(self) -> text:
        match self:
            case Box(x, y, z): "Box collision shape (half extents: {x}, {y}, {z})"
            case Sphere(r): "Sphere collision shape (radius: {r})"
            case Capsule(r, h): "Capsule collision shape (radius: {r}, height: {h})"
            case Cylinder(r, h): "Cylinder collision shape (radius: {r}, height: {h})"

    pub fn is_box(self) -> bool:
        match self:
            case Box(_, _, _): true
            case _: false

    pub fn is_sphere(self) -> bool:
        match self:
            case Sphere(_): true
            case _: false

    pub fn is_capsule(self) -> bool:
        match self:
            case Capsule(_, _): true
            case _: false

    pub fn is_cylinder(self) -> bool:
        match self:
            case Cylinder(_, _): true
            case _: false

    pub fn is_primitive(self) -> bool:
        """All shapes are primitives."""
        true

    pub fn is_convex(self) -> bool:
        """All shapes are convex."""
        true

    pub fn summary(self) -> text:
        val name = self.to_string()
        val desc = self.description()
        return "CollisionShape: {name} ({desc}, primitive, convex)"


# RaycastHit
# Result of a raycast query
pub struct RaycastHit:
    hit: bool
    position: math.Vec3
    normal: math.Vec3
    distance: f32

impl RaycastHit:
    pub fn did_hit(self) -> bool:
        return self.hit

    pub fn get_position(self) -> math.Vec3:
        return self.position

    pub fn get_normal(self) -> math.Vec3:
        return self.normal

    pub fn get_distance(self) -> f32:
        return self.distance

    pub fn has_hit(self) -> bool:
        """Alias for did_hit."""
        return self.did_hit()

    pub fn get_hit_distance(self) -> f32:
        """Alias for get_distance."""
        return self.get_distance()

    pub fn summary(self) -> text:
        if not self.hit:
            return "RaycastHit: no hit"
        val dist = self.distance
        return "RaycastHit: hit at distance {dist}, normal=({self.normal.x}, {self.normal.y}, {self.normal.z})"


# RigidBody trait
# Common interface for rigidbodies
pub trait RigidBody:
    # Type and state
    fn get_body_type() -> RigidBodyType
    me set_body_type(body_type: RigidBodyType)
    fn is_sleeping() -> bool
    me wake_up()

    # Mass and inertia
    fn get_mass() -> f32
    me set_mass(mass: f32)

    # Velocity
    fn get_linear_velocity() -> math.Vec3
    me set_linear_velocity(vel: math.Vec3)
    fn get_angular_velocity() -> math.Vec3
    me set_angular_velocity(vel: math.Vec3)

    # Forces
    me apply_force(force: math.Vec3)
    me apply_impulse(impulse: math.Vec3)
    me apply_torque(torque: math.Vec3)

    # Damping
    fn get_linear_damping() -> f32
    me set_linear_damping(damping: f32)
    fn get_angular_damping() -> f32
    me set_angular_damping(damping: f32)

    # Gravity
    fn uses_gravity() -> bool
    me set_use_gravity(use_gravity: bool)


# PhysicsWorld trait
# Common interface for physics simulation
pub trait PhysicsWorld:
    # Simulation
    me step(delta: f32)
    fn get_gravity() -> math.Vec3
    me set_gravity(gravity: math.Vec3)

    # Raycasting
    fn raycast(from: math.Vec3, to: math.Vec3) -> RaycastHit
    fn raycast_all(from: math.Vec3, to: math.Vec3) -> Vec<RaycastHit>

    # Overlap queries
    fn overlap_sphere(center: math.Vec3, radius: f32) -> Vec<i32>
    fn overlap_box(center: math.Vec3, half_extents: math.Vec3) -> Vec<i32>
