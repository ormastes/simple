# File I/O Library - Async Memory-Mapped File Access
#
# High-performance async file I/O using memory-mapped files.
# Default mode is ASYNC with background loading.
#
# Quick Start:
#   use file
#
#   # Async loading (default)
#   async with await file.open("data.txt") as mmap:
#       val content = mmap.as_str()?
#       process(content)
#
#   # Sync loading (blocks until ready)
#   with file.open_sync("data.txt") as mmap:
#       val content = mmap.as_str()?
#       process(content)
#
# See also: cli.file for sync-only file validation

# Extern declarations for FFI
extern fn rt_check_file_path(path: text) -> bool
extern fn rt_file_open(path: text, mode: i32) -> i32
extern fn rt_file_get_size(fd: i32) -> i32
extern fn rt_file_close(fd: i32) -> void
extern fn rt_file_mmap(addr: *void, length: i32, prot: i32, flags: i32, fd: i32, offset: i32) -> *u8
extern fn rt_file_munmap(addr: *u8, length: i32) -> i32
extern fn rt_file_madvise(addr: *u8, length: i32, advice: i32) -> i32

# Re-export public API
export file.mmap.*
export file.async_handle.*
export file.context.*

# Public API functions

# Async file opening (default) - returns immediately, loads in background
pub async fn open(path: text) -> Result<AsyncFileHandle, FileError>:
    val handle = AsyncFileHandle.new(path)
    handle.start_loading()
    return Ok(handle)

# Async file opening with options
pub async fn open_with(path: text, opts: OpenOptions) -> Result<AsyncFileHandle, FileError>:
    val handle = AsyncFileHandle.with_options(path, opts)
    handle.start_loading()
    return Ok(handle)

# Sync file opening - blocks until file is loaded
pub fn open_sync(path: text) -> Result<MmapRegion, FileError>:
    val opts = OpenOptions.new()
    return open_sync_with(path, opts)

# Sync file opening with options
pub fn open_sync_with(path: text, opts: OpenOptions) -> Result<MmapRegion, FileError>:
    # Validate path
    if not check_file_path(path):
        return Err(FileError.NotFound(path))

    # Open file and mmap
    val fd = sys_open(path, OpenMode.ReadOnly)?
    val file_size = sys_file_size(fd)?

    # Create mmap
    val mmap_ptr = sys_mmap(
        addr: null,
        length: file_size,
        prot: opts.get_prot_flags(),
        flags: opts.get_map_flags(),
        fd: fd,
        offset: 0
    )?

    if mmap_ptr == null:
        sys_close(fd)
        return Err(FileError.MmapFailed("mmap returned null"))

    # Create region
    val region = MmapRegion {data: mmap_ptr, length: file_size, mode: opts.mode, fd: fd, path: path}

    # Apply advice if specified
    if opts.advice != MmapAdvice.Normal:
        region.advise(opts.advice)

    return Ok(region)

# Check if file exists (sync)
# Note: named `is_file` to avoid conflict with `exists` keyword
pub fn is_file(path: text) -> bool:
    return check_file_path(path)

# Get file size (sync)
pub fn size(path: text) -> Result<usize, FileError>:
    if not check_file_path(path):
        return Err(FileError.NotFound(path))

    val fd = sys_open(path, OpenMode.ReadOnly)?
    val size = sys_file_size(fd)?
    sys_close(fd)
    return Ok(size)

# FFI Placeholders (to be implemented in Rust runtime)

# Check if file exists
fn check_file_path(path: text) -> bool:
    return rt_check_file_path(path)

# Open file and return file descriptor
fn sys_open(path: text, mode: OpenMode) -> Result<i32, FileError>:
    val mode_int = match mode:
        case ReadOnly: 0
        case ReadWrite: 1
        case WriteOnly: 2
    val fd = rt_file_open(path, mode_int)
    if fd == -1:
        return Err(FileError.OpenFailed)
    return Ok(fd)

# Get file size
fn sys_file_size(fd: i32) -> Result<usize, FileError>:
    val size = rt_file_get_size(fd)
    if size == 0:
        return Err(FileError.IoError("Failed to get file size"))
    return Ok(size as usize)

# Close file descriptor
fn sys_close(fd: i32):
    rt_file_close(fd)

# Memory map a file
fn sys_mmap(addr: *void, length: usize, prot: i32, flags: i32, fd: i32, offset: usize) -> Result<*u8, FileError>:
    val ptr = rt_file_mmap(addr, length as i32, prot, flags, fd, offset as i32)
    if ptr == null:
        return Err(FileError.MmapFailed("mmap failed"))
    return Ok(ptr)

# Unmap memory region
fn sys_munmap(addr: *u8, length: usize) -> Result<void, FileError>:
    val result = rt_file_munmap(addr, length as i32)
    if result == -1:
        return Err(FileError.IoError("munmap failed"))
    return Ok(void)

# Advise kernel on memory access pattern
fn sys_madvise(addr: *u8, length: usize, advice: i32) -> Result<void, FileError>:
    val result = rt_file_madvise(addr, length as i32, advice)
    if result == -1:
        return Err(FileError.IoError("madvise failed"))
    return Ok(void)

# File opening mode
enum OpenMode:
    ReadOnly
    ReadWrite
    WriteOnly

impl OpenMode:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_read_only() -> bool:
        """Check if this is ReadOnly mode.

        Returns:
            true for ReadOnly

        Example:
            OpenMode.ReadOnly.is_read_only()  # → true
        """
        match self:
            case ReadOnly: true
            case _: false

    fn is_read_write() -> bool:
        """Check if this is ReadWrite mode.

        Returns:
            true for ReadWrite

        Example:
            OpenMode.ReadWrite.is_read_write()  # → true
        """
        match self:
            case ReadWrite: true
            case _: false

    fn is_write_only() -> bool:
        """Check if this is WriteOnly mode.

        Returns:
            true for WriteOnly

        Example:
            OpenMode.WriteOnly.is_write_only()  # → true
        """
        match self:
            case WriteOnly: true
            case _: false

    fn can_read() -> bool:
        """Check if mode allows reading.

        Returns:
            true for ReadOnly and ReadWrite

        Example:
            OpenMode.ReadOnly.can_read()  # → true
            OpenMode.WriteOnly.can_read()  # → false
        """
        match self:
            case ReadOnly: true
            case ReadWrite: true
            case WriteOnly: false

    fn can_write() -> bool:
        """Check if mode allows writing.

        Returns:
            true for ReadWrite and WriteOnly

        Example:
            OpenMode.ReadWrite.can_write()  # → true
            OpenMode.ReadOnly.can_write()  # → false
        """
        match self:
            case ReadWrite: true
            case WriteOnly: true
            case ReadOnly: false

    fn is_mutable() -> bool:
        """Check if mode allows mutation (alias for can_write).

        Returns:
            true for ReadWrite and WriteOnly

        Example:
            OpenMode.ReadWrite.is_mutable()  # → true
        """
        return self.can_write()

    fn to_string() -> text:
        """Convert mode to string.

        Returns:
            Mode name

        Example:
            OpenMode.ReadOnly.to_string()  # → "read_only"
        """
        match self:
            case ReadOnly: "read_only"
            case ReadWrite: "read_write"
            case WriteOnly: "write_only"

    fn summary() -> text:
        """Get summary of open mode.

        Returns:
            Human-readable summary

        Example:
            OpenMode.ReadWrite.summary()
            # → "OpenMode: read_write (can read, can write)"
        """
        val name = self.to_string()
        val caps = if self.can_read() and self.can_write():
                       "can read, can write"
                   else if self.can_read():
                       "can read only"
                   else:
                       "can write only"
        return "OpenMode: {name} ({caps})"
