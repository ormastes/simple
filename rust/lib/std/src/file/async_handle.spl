# Async File Handle - Background File Loading
#
# Provides async file loading with JavaScript-style async/await.
# Files load in background (worker thread/process) while code continues.

use file.mmap

# Extern FFI declarations for async file operations
extern fn native_async_file_create(path: text, mode: i32, prefault: i32) -> i64
extern fn native_async_file_start_loading(handle_id: i64) -> ()
extern fn native_async_file_is_ready(handle_id: i64) -> i32
extern fn native_async_file_get_state(handle_id: i64) -> i32
extern fn native_async_file_wait(handle_id: i64) -> Any
extern fn async_yield() -> ()

# File loading state
pub enum FileState:
    Pending             # Not yet started loading
    Loading             # Currently loading in background
    Ready(MmapRegion)   # Successfully loaded
    Failed(FileError)   # Loading failed

impl FileState:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_pending(self) -> bool:
        """Check if state is Pending."""
        match self:
            case Pending: true
            case _: false

    pub fn is_loading(self) -> bool:
        """Check if state is Loading."""
        match self:
            case Loading: true
            case _: false

    pub fn is_ready(self) -> bool:
        """Check if state is Ready."""
        match self:
            case Ready(_): true
            case _: false

    pub fn is_failed(self) -> bool:
        """Check if state is Failed."""
        match self:
            case Failed(_): true
            case _: false

    pub fn is_done(self) -> bool:
        """Check if state is done (Ready or Failed)."""
        match self:
            case Ready(_): true
            case Failed(_): true
            case _: false

    pub fn is_in_progress(self) -> bool:
        """Check if loading is in progress (Pending or Loading)."""
        match self:
            case Pending: true
            case Loading: true
            case _: false

    pub fn to_string(self) -> text:
        """Convert state to string."""
        match self:
            case Pending: return "Pending"
            case Loading: return "Loading"
            case Ready(_): return "Ready"
            case Failed(_): return "Failed"

    pub fn get_region(self) -> Option<MmapRegion>:
        """Get region if ready."""
        match self:
            case Ready(region): Some(region)
            case _: nil

    pub fn get_error(self) -> Option<FileError>:
        """Get error if failed."""
        match self:
            case Failed(error): Some(error)
            case _: nil

    pub fn description(self) -> text:
        """Get detailed state description.

        Returns:
            Human-readable description

        Example:
            FileState.Loading.description()  # → "File is currently loading in background"
        """
        match self:
            case Pending: "File is not yet started loading"
            case Loading: "File is currently loading in background"
            case Ready(_): "File has been successfully loaded"
            case Failed(_): "File loading failed with error"

    pub fn summary(self) -> text:
        """Get file state summary.

        Returns:
            Human-readable summary

        Example:
            FileState.Ready(region).summary()
            # → "FileState: Ready (File has been successfully loaded, done)"
        """
        val name = self.to_string()
        val desc = self.description()
        val status = if self.is_done(): "done" else: "in progress"
        return "FileState: {name} ({desc}, {status})"

# Async file handle - represents a file being loaded asynchronously
pub struct AsyncFileHandle:
    path: text        # File path
    state: FileState    # Current loading state
    options: OpenOptions # Opening options
    handle_id: i64      # Runtime handle ID

    # Create a new async handle (doesn't start loading)
    pub fn new(path: text) -> AsyncFileHandle:
        val handle_id = native_async_file_create(path, 0, 0)
        return AsyncFileHandle {
            path: path,
            state: FileState.Pending,
            options: OpenOptions.new(),
            handle_id: handle_id
        }

    # Create handle with custom options
    pub fn with_options(path: text, opts: OpenOptions) -> AsyncFileHandle:
        var mode = 0
        if opts.mode != MmapMode.Private:
            mode = 1
        
        var prefault = 0
        if opts.prefault:
            prefault = 1
        
        val handle_id = native_async_file_create(path, mode, prefault)
        return AsyncFileHandle {
            path: path,
            state: FileState.Pending,
            options: opts,
            handle_id: handle_id
        }

    # Start loading the file in background
    pub fn start_loading(mut self):
        native_async_file_start_loading(self.handle_id)
        self.state = FileState.Loading

    # Check if file is ready (non-blocking)
    pub fn is_ready(self) -> bool:
        val ready = native_async_file_is_ready(self.handle_id)
        return ready == 1

    # Check if loading failed
    pub fn is_failed(self) -> bool:
        match self.state:
            case FileState.Failed(_):
                return true
            case _:
                return false

    # Get the current state
    pub fn get_state(self) -> FileState:
        return self.state

    # Wait for file to load (async, blocks until ready)
    pub fn wait(self) -> Result<MmapRegion, FileError>:
        val result = native_async_file_wait(self.handle_id)
        # Convert result to MmapRegion or FileError
        # Assuming result is the MmapRegion on success or error on failure
        if result != nil:
            return Ok(result as MmapRegion)
        else:
            return Err(FileError.IoError("Failed to load file"))

    # Get the loaded region (blocks if not ready)
    pub fn get(self) -> Result<MmapRegion, FileError>:
        # Block until file is ready
        val result = native_async_file_wait(self.handle_id)
        if result != nil:
            return Ok(result as MmapRegion)
        else:
            return Err(FileError.IoError("Failed to load file"))

    # Try to get the region without blocking
    pub fn try_get(self) -> Option<MmapRegion>:
        match self.state:
            case FileState.Ready(region):
                return Some(region)
            case _:
                return None

    # Cancel loading (if still in progress)
    pub fn cancel(mut self):
        # Note: Currently marks as failed; actual background thread cancellation
        # would require additional FFI support
        match self.state:
            case FileState.Loading:
                self.state = FileState.Failed(FileError.IoError("Cancelled"))
            case _:
                pass

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_pending(self) -> bool:
        """Check if handle is pending."""
        return self.state.is_pending()

    pub fn is_loading(self) -> bool:
        """Check if handle is loading."""
        return self.state.is_loading()

    pub fn is_done(self) -> bool:
        """Check if loading is done (ready or failed)."""
        return self.state.is_done()

    pub fn has_path(self) -> bool:
        """Check if path is set."""
        return not self.path.is_empty()

    pub fn is_async(self) -> bool:
        """Check if async loading is enabled."""
        return self.options.is_async_enabled()

    pub fn has_error(self) -> bool:
        """Check if loading failed."""
        return self.is_failed()

    pub fn get_error(self) -> Option<FileError>:
        """Get error if failed."""
        return self.state.get_error()

    pub fn summary(self) -> text:
        """Get summary of async file handle."""
        val state_str = self.state.to_string()
        val async_str = if self.is_async(): "async" else: "sync"
        return "AsyncFileHandle: {self.path} ({state_str}, {async_str})"

# Helper function to wait for multiple handles in parallel
pub fn wait_all(handles: Array<AsyncFileHandle>) -> Result<Array<MmapRegion>, FileError>:
    val regions = []
    for handle in handles:
        val region = await handle.wait()?
        regions.push(region)
    return Ok(regions)

# Helper function to get all ready handles (non-blocking)
pub fn ready_handles(handles: Array<AsyncFileHandle>) -> Array<AsyncFileHandle>:
    val ready = []
    for handle in handles:
        if handle.is_ready():
            ready.push(handle)
    return ready
