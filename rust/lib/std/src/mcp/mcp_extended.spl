# #1291-1294: Semantic highlighting, caching, indexing, filtering
# =============================================================================

pub fn add_semantic_tokens(output: &mut McpOutput) -> Result<(), McpError>:
    # Add semantic token information to the MCP output
    # Semantic tokens provide syntax highlighting hints for editors

    # Token types following LSP SemanticTokenTypes
    val token_types = [
        "namespace", "type", "class", "enum", "interface",
        "struct", "typeParameter", "parameter", "variable",
        "property", "enumMember", "function", "method",
        "keyword", "modifier", "comment", "string", "number", "operator"
    ]

    # Add semantic tokens legend to output metadata
    if output.items.len() > 0:
        for item in output.items:
            # Assign token type based on item kind
            val token_type = match item.kind:
                ItemKind.Function: "function"
                ItemKind.Struct: "struct"
                ItemKind.Enum: "enum"
                ItemKind.Import: "namespace"
                ItemKind.Marker: "comment"
                _: "variable"

            # Assign modifiers based on visibility
            var modifiers: Array<text> = []
            if item.metadata.visibility == "pub":
                modifiers.push("declaration")
            if item.metadata.visibility == "static":
                modifiers.push("static")

            # Store token info in item
            item.semantic_token_type = token_type
            item.semantic_token_modifiers = modifiers

    return Ok(())

pub struct McpCache:
    entries: Dict<text, CacheEntry>

struct CacheEntry:
    output: McpOutput
    timestamp: u64

impl McpCache:
    pub fn get(self, key: &str) -> Option<McpOutput>:
        if val Some(entry) = self.entries.get(key):
            return Some(entry.output.clone())
        return None

    pub fn set(self, key: &str, output: McpOutput):
        @extern("runtime", "rt_time_now_unix_micros")
        fn _rt_time_now_unix_micros() -> i64

        self.entries.insert(key.to_string(), CacheEntry {
            output: output,
            timestamp: _rt_time_now_unix_micros() / 1000  # Convert microseconds to milliseconds
        })

pub struct SymbolIndex:
    symbols: Dict<text, Array<SymbolLocation>>

struct SymbolLocation:
    file: text
    location: SourceLocation

impl SymbolIndex:
    pub fn find(self, name: &str) -> Option<Array<SymbolLocation>>:
        return self.symbols.get(name).cloned()

pub fn filter_by_relevance(output: &McpOutput, query: &str) -> McpOutput:
    var filtered = McpOutput.new()

    for item in &output.items:
        val score = relevance_score(&item.metadata.name, query)
        if score > 0.5:
            filtered.add_item(item.clone())

    return filtered

fn relevance_score(name: &str, query: &str) -> f32:
    if name.contains(query):
        return 1.0
    return 0.0

# =============================================================================
# #1295-1299: Metadata, profiling, plugins, pipeline, formats
# =============================================================================

pub struct MetadataConfig:
    pub fields: Array<text>
    pub custom: Dict<text, text>

pub struct ProfileData:
    pub parse_time_ms: u64
    pub format_time_ms: u64
    pub total_time_ms: u64

pub struct PluginRegistry:
    plugins: Dict<text, Box<McpPlugin>>

pub trait McpPlugin:
    fn name() -> text
    fn transform(output: &mut McpOutput) -> Result<(), McpError>

pub struct TransformPipeline:
    stages: Array<Box<McpPlugin>>

impl TransformPipeline:
    pub fn apply(self, output: &mut McpOutput) -> Result<(), McpError>:
        for plugin in &self.stages:
            plugin.transform(output)?
        return Ok(())

pub enum OutputFormat:
    Json
    Markdown
    Plain
    Html
    Protobuf

impl OutputFormat:
    pub fn to_string(self) -> text:
        """Convert output format to string."""
        match self:
            case Json: "json"
            case Markdown: "markdown"
            case Plain: "plain"
            case Html: "html"
            case Protobuf: "protobuf"

    pub fn description(self) -> text:
        """Get output format description."""
        match self:
            case Json: "JSON structured output format"
            case Markdown: "Markdown documentation format"
            case Plain: "Plain text format"
            case Html: "HTML web format"
            case Protobuf: "Protocol Buffers binary format"

    pub fn is_json(self) -> bool:
        """Check if format is JSON."""
        match self:
            case Json: true
            case _: false

    pub fn is_markdown(self) -> bool:
        """Check if format is Markdown."""
        match self:
            case Markdown: true
            case _: false

    pub fn is_plain(self) -> bool:
        """Check if format is Plain."""
        match self:
            case Plain: true
            case _: false

    pub fn is_html(self) -> bool:
        """Check if format is HTML."""
        match self:
            case Html: true
            case _: false

    pub fn is_protobuf(self) -> bool:
        """Check if format is Protobuf."""
        match self:
            case Protobuf: true
            case _: false

    pub fn is_binary(self) -> bool:
        """Check if format is binary."""
        match self:
            case Protobuf: true
            case _: false

    pub fn is_text(self) -> bool:
        """Check if format is text-based."""
        match self:
            case Json: true
            case Markdown: true
            case Plain: true
            case Html: true
            case _: false

    pub fn is_structured(self) -> bool:
        """Check if format supports structured data."""
        match self:
            case Json: true
            case Protobuf: true
            case Html: true
            case _: false

    pub fn is_human_readable(self) -> bool:
        """Check if format is primarily human-readable."""
        match self:
            case Markdown: true
            case Plain: true
            case Html: true
            case _: false

    pub fn summary(self) -> text:
        """Get comprehensive output format summary."""
        val name = self.to_string()
        val desc = self.description()
        var props = []
        if self.is_binary():
            props.push("binary")
        if self.is_text():
            props.push("text")
        if self.is_structured():
            props.push("structured")
        if self.is_human_readable():
            props.push("human-readable")
        if props.len() > 0:
            val props_str = ", ".join(props)
            return "OutputFormat: {name} ({desc}, {props_str})"
        else:
            return "OutputFormat: {name} ({desc})"

# Helper extensions
impl McpMetadata:
    fn empty() -> McpMetadata:
        return McpMetadata {
            visibility: "".to_string(),
            name: "".to_string(),
            location: SourceLocation { line: 0, column: 0, offset: 0 }
        }

    fn add_overlay(key: &str, value: &str):
        # Store overlay data in module-level storage
        val meta_key = get_metadata_key(&self)

        # Get or create overlay dict for this metadata
        if not _metadata_overlays.contains_key(meta_key):
            _metadata_overlays.insert(meta_key, {})

        # Store the overlay key-value pair
        _metadata_overlays.get_mut(meta_key).unwrap().insert(key.to_string(), value.to_string())

    fn get_overlay(key: &str) -> Option<text>:
        # Retrieve overlay data from module-level storage
        val meta_key = get_metadata_key(&self)

        if val Some(overlays) = _metadata_overlays.get(meta_key):
            return overlays.get(key).cloned()
        return None

    fn get_all_overlays() -> Dict<text, text>:
        # Get all overlays for this metadata
        val meta_key = get_metadata_key(&self)

        if val Some(overlays) = _metadata_overlays.get(meta_key):
            return overlays.clone()
        return {}

impl McpOutput:
    fn find_symbol(name: &str) -> Option<&McpItem>:
        for item in &self.items:
            if item.metadata.name == name:
                return Some(item)
        return None

enum ItemKind:
    Function
    Struct
    Enum
    Import
    Marker

impl ItemKind:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_function() -> bool:
        """Check if item is Function.

        Returns:
            true for Function

        Example:
            ItemKind.Function.is_function()  # → true
        """
        match self:
            case Function: true
            case _: false

    fn is_struct() -> bool:
        """Check if item is Struct.

        Returns:
            true for Struct

        Example:
            ItemKind.Struct.is_struct()  # → true
        """
        match self:
            case Struct: true
            case _: false

    fn is_enum() -> bool:
        """Check if item is Enum.

        Returns:
            true for Enum

        Example:
            ItemKind.Enum.is_enum()  # → true
        """
        match self:
            case Enum: true
            case _: false

    fn is_import() -> bool:
        """Check if item is Import.

        Returns:
            true for Import

        Example:
            ItemKind.Import.is_import()  # → true
        """
        match self:
            case Import: true
            case _: false

    fn is_marker() -> bool:
        """Check if item is Marker.

        Returns:
            true for Marker

        Example:
            ItemKind.Marker.is_marker()  # → true
        """
        match self:
            case Marker: true
            case _: false

    fn is_type_definition() -> bool:
        """Check if item is a type definition (Struct or Enum).

        Returns:
            true for Struct or Enum

        Example:
            ItemKind.Struct.is_type_definition()  # → true
            ItemKind.Function.is_type_definition()  # → false
        """
        match self:
            case Struct: true
            case Enum: true
            case _: false

    fn is_code() -> bool:
        """Check if item is executable code.

        Returns:
            true for Function

        Example:
            ItemKind.Function.is_code()  # → true
            ItemKind.Struct.is_code()  # → false
        """
        match self:
            case Function: true
            case _: false

    fn is_structural() -> bool:
        """Check if item is structural (not executable).

        Returns:
            true for Struct, Enum, Import, Marker

        Example:
            ItemKind.Struct.is_structural()  # → true
            ItemKind.Function.is_structural()  # → false
        """
        match self:
            case Function: false
            case _: true

    fn is_meta() -> bool:
        """Check if item is meta-information (Marker).

        Returns:
            true for Marker

        Example:
            ItemKind.Marker.is_meta()  # → true
        """
        return self.is_marker()

    fn to_string() -> text:
        """Convert item kind to string.

        Returns:
            Kind name

        Example:
            ItemKind.Function.to_string()  # → "function"
        """
        match self:
            case Function: "function"
            case Struct: "struct"
            case Enum: "enum"
            case Import: "import"
            case Marker: "marker"

    fn description() -> text:
        """Get item kind description.

        Returns:
            Human-readable description

        Example:
            ItemKind.Function.description()
            # → "Function definition"
        """
        match self:
            case Function: "Function definition"
            case Struct: "Structure definition"
            case Enum: "Enumeration definition"
            case Import: "Import statement"
            case Marker: "Block marker (guide)"

    fn summary() -> text:
        """Get summary of item kind.

        Returns:
            Human-readable summary

        Example:
            ItemKind.Function.summary()
            # → "ItemKind: function (code, executable)"
        """
        val name = self.to_string()
        val category = if self.is_code():
                           "code, executable"
                       else if self.is_type_definition():
                           "type definition"
                       else if self.is_meta():
                           "meta-information"
                       else:
                           "structural"
        return "ItemKind: {name} ({category})"

enum McpError:
    NotImplemented(text)
    ParseError(text)

impl McpError:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_not_implemented() -> bool:
        """Check if error is NotImplemented.

        Returns:
            true for NotImplemented

        Example:
            McpError.NotImplemented("feature").is_not_implemented()  # → true
        """
        match self:
            case NotImplemented(_): true
            case _: false

    fn is_parse_error() -> bool:
        """Check if error is ParseError.

        Returns:
            true for ParseError

        Example:
            McpError.ParseError("syntax").is_parse_error()  # → true
        """
        match self:
            case ParseError(_): true
            case _: false

    fn get_message() -> text:
        """Get error message.

        Returns:
            Error message string

        Example:
            McpError.NotImplemented("caching").get_message()  # → "caching"
        """
        match self:
            case NotImplemented(msg): msg
            case ParseError(msg): msg

    fn is_recoverable() -> bool:
        """Check if error might be recoverable.

        Returns:
            true for ParseError (can retry), false for NotImplemented

        Example:
            McpError.ParseError("bad syntax").is_recoverable()  # → true
            McpError.NotImplemented("feature").is_recoverable()  # → false
        """
        match self:
            case ParseError(_): true
            case NotImplemented(_): false

    fn severity() -> text:
        """Get error severity level.

        Returns:
            Severity: "error" or "fatal"

        Example:
            McpError.ParseError("syntax").severity()  # → "error"
            McpError.NotImplemented("feature").severity()  # → "fatal"
        """
        match self:
            case ParseError(_): "error"
            case NotImplemented(_): "fatal"

    fn to_string() -> text:
        """Convert error to string.

        Returns:
            Error type name

        Example:
            McpError.ParseError("msg").to_string()  # → "parse_error"
        """
        match self:
            case NotImplemented(_): "not_implemented"
            case ParseError(_): "parse_error"

    fn description() -> text:
        """Get detailed error description.

        Returns:
            Human-readable description with message

        Example:
            McpError.NotImplemented("caching").description()
            # → "Feature not implemented: caching"
        """
        match self:
            case NotImplemented(msg): "Feature not implemented: {msg}"
            case ParseError(msg): "Parse error: {msg}"

    fn summary() -> text:
        """Get summary of MCP error.

        Returns:
            Human-readable summary

        Example:
            McpError.ParseError("syntax error").summary()
            # → "McpError: parse_error (error severity, recoverable)"
        """
        val name = self.to_string()
        val sev = self.severity()
        val recoverable = if self.is_recoverable(): "recoverable" else: "not recoverable"
        return "McpError: {name} ({sev} severity, {recoverable})"
