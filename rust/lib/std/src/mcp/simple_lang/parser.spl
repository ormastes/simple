# MCP Parser - Extract symbols from Simple source code

use core.*
use mcp.simple_lang.types.*

# Parse Simple source code and extract symbols
pub fn parse_file(source: text) -> List<Symbol>:
    var symbols = []
    val lines = source.split("\n")

    var i = 0
    while i < lines.len():
        val line = lines[i]
        val stripped = line.strip()

        # Parse class/struct definitions
        if stripped.starts_with("pub class ") or stripped.starts_with("class "):
            val symbol = parse_class(lines, i)
            symbols.append(symbol)
            i = symbol.line_end

        # Parse function definitions (including static, async, and me variations)
        elif (stripped.starts_with("pub static async fn ") or stripped.starts_with("pub static fn ") or stripped.starts_with("pub async fn ") or stripped.starts_with("pub me ") or stripped.starts_with("pub fn ") or stripped.starts_with("static async fn ") or stripped.starts_with("static fn ") or stripped.starts_with("async fn ") or stripped.starts_with("me ") or stripped.starts_with("fn ")):
            val symbol = parse_function(lines, i)
            symbols.append(symbol)
            i = symbol.line_end

        # Parse trait definitions
        elif stripped.starts_with("pub trait ") or stripped.starts_with("trait "):
            val symbol = parse_trait(lines, i)
            symbols.append(symbol)
            i = symbol.line_end

        # Parse pointcut definitions
        elif stripped.starts_with("pointcut "):
            val symbol = parse_pointcut(lines, i)
            symbols.append(symbol)
            i = symbol.line_end

        else:
            i = i + 1

    return symbols

# Parse a class definition
fn parse_class(lines: List<text>, start_idx: i64) -> Symbol:
    val line = lines[start_idx]
    val stripped = line.strip()

    # Determine visibility
    var vis = Visibility.Private
    if stripped.starts_with("pub "):
        vis = Visibility.Public

    # Extract class name (simple version)
    val parts = stripped.split(" ")
    var name = "Unknown"
    var i = 0
    while i < parts.len():
        if parts[i] == "class" and i + 1 < parts.len():
            val name_part = parts[i + 1]
            # Remove colon if present
            if name_part.ends_with(":"):
                name = name_part.substring(0, name_part.len() - 1)
            else:
                name = name_part
            break
        i = i + 1

    # Find end of class
    val end_idx = find_block_end(lines, start_idx)

    # Extract body
    var body_lines = []
    var j = start_idx + 1
    while j <= end_idx and j < lines.len():
        body_lines.append(lines[j])
        j = j + 1

    var symbol = Symbol.new(SymbolKind.Class, name, vis)
    symbol.signature = stripped
    symbol.body = "\n".join(body_lines)
    symbol.line_start = start_idx
    symbol.line_end = end_idx
    symbol.is_collapsed = true

    return symbol

# Parse a function definition
fn parse_function(lines: List<text>, start_idx: i64) -> Symbol:
    val line = lines[start_idx]
    val stripped = line.strip()

    # Determine visibility
    var vis = Visibility.Private
    if stripped.starts_with("pub "):
        vis = Visibility.Public

    # Extract function name (handle pub, static, async, me keywords)
    val parts = stripped.split(" ")
    var name = "unknown"
    var i = 0
    while i < parts.len():
        # Look for fn or me keyword
        if (parts[i] == "fn" or parts[i] == "me") and i + 1 < parts.len():
            val name_part = parts[i + 1]
            # Extract name before parenthesis or colon
            var paren_idx = 0
            while paren_idx < name_part.len():
                val ch = name_part.char_at(paren_idx)
                if ch == "(" or ch == ":":
                    break
                paren_idx = paren_idx + 1

            if paren_idx > 0:
                name = name_part.substring(0, paren_idx)
            else:
                name = name_part
            break
        i = i + 1

    # Find end of function
    val end_idx = find_block_end(lines, start_idx)

    # Extract body
    var body_lines = []
    var j = start_idx + 1
    while j <= end_idx and j < lines.len():
        body_lines.append(lines[j])
        j = j + 1

    var symbol = Symbol.new(SymbolKind.Function, name, vis)
    symbol.signature = stripped
    symbol.body = "\n".join(body_lines)
    symbol.line_start = start_idx
    symbol.line_end = end_idx
    symbol.is_collapsed = true

    return symbol

# Parse a trait definition
fn parse_trait(lines: List<text>, start_idx: i64) -> Symbol:
    val line = lines[start_idx]
    val stripped = line.strip()

    # Determine visibility
    var vis = Visibility.Private
    if stripped.starts_with("pub "):
        vis = Visibility.Public

    # Extract trait name
    val parts = stripped.split(" ")
    var name = "Unknown"
    var i = 0
    while i < parts.len():
        if parts[i] == "trait" and i + 1 < parts.len():
            val name_part = parts[i + 1]
            if name_part.ends_with(":"):
                name = name_part.substring(0, name_part.len() - 1)
            else:
                name = name_part
            break
        i = i + 1

    # Find end of trait
    val end_idx = find_block_end(lines, start_idx)

    var symbol = Symbol.new(SymbolKind.Trait, name, vis)
    symbol.signature = stripped
    symbol.line_start = start_idx
    symbol.line_end = end_idx
    symbol.is_collapsed = true

    return symbol

# Parse a pointcut definition
fn parse_pointcut(lines: List<text>, start_idx: i64) -> Symbol:
    val line = lines[start_idx]
    val stripped = line.strip()

    # Extract pointcut pattern (everything after "pointcut ")
    var pattern = stripped
    if stripped.starts_with("pointcut "):
        pattern = stripped.substring(9, stripped.len())

    # Find end of pointcut
    val end_idx = find_block_end(lines, start_idx)

    var symbol = Symbol.new(SymbolKind.Pointcut, pattern, Visibility.Public)
    symbol.signature = stripped
    symbol.line_start = start_idx
    symbol.line_end = end_idx
    symbol.is_collapsed = true

    return symbol

# Find the end of an indented block
fn find_block_end(lines: List<text>, start_idx: i64) -> i64:
    if start_idx >= lines.len():
        return start_idx

    # Get indentation of the definition line
    val def_line = lines[start_idx]
    val base_indent = count_leading_spaces(def_line)

    # Find first line with same or less indentation
    var i = start_idx + 1
    while i < lines.len():
        val line = lines[i]

        # Skip empty lines
        if line.strip() == "":
            i = i + 1
            continue

        # Check indentation
        val indent = count_leading_spaces(line)
        if indent <= base_indent:
            return i - 1

        i = i + 1

    return lines.len() - 1

# Count leading spaces in a line
fn count_leading_spaces(line: text) -> i64:
    var count = 0
    var i = 0
    while i < line.len():
        val ch = line.char_at(i)
        if ch == " ":
            count = count + 1
        elif ch == "\t":
            count = count + 4
        else:
            break
        i = i + 1

    return count

# Filter symbols by visibility
pub fn filter_public_symbols(symbols: List<Symbol>) -> List<Symbol>:
    var result = []
    for symbol in symbols:
        if symbol.visibility.is_public():
            result.append(symbol)

    return result

# Find symbol by name
pub fn find_symbol(symbols: List<Symbol>, name: text) -> Option<Symbol>:
    for symbol in symbols:
        if symbol.name == name:
            return Some(symbol)

    return None

# Find symbol by line number
pub fn find_symbol_at_line(symbols: List<Symbol>, line: i64) -> Option<Symbol>:
    for symbol in symbols:
        if line >= symbol.line_start and line <= symbol.line_end:
            return Some(symbol)

    return None
