# Coverage Metric Overlays for Simple Language
# Displays test coverage, branch coverage, and condition coverage

use core.*
use mcp.simple_lang.types.*

# Coverage type
pub enum CoverageType:
    Line         # Line coverage
    Branch       # Branch coverage
    Condition    # Condition coverage
    Function     # Function coverage

impl CoverageType:
    pub fn is_line(self) -> bool:
        """Check if this is Line coverage.
        Returns: true for Line
        Example: CoverageType.Line.is_line()  # → true
        """
        match self:
            case Line: true
            case _: false

    pub fn is_branch(self) -> bool:
        """Check if this is Branch coverage.
        Returns: true for Branch
        Example: CoverageType.Branch.is_branch()  # → true
        """
        match self:
            case Branch: true
            case _: false

    pub fn is_condition(self) -> bool:
        """Check if this is Condition coverage.
        Returns: true for Condition
        Example: CoverageType.Condition.is_condition()  # → true
        """
        match self:
            case Condition: true
            case _: false

    pub fn is_function(self) -> bool:
        """Check if this is Function coverage.
        Returns: true for Function
        Example: CoverageType.Function.is_function()  # → true
        """
        match self:
            case Function: true
            case _: false

    pub fn is_detailed(self) -> bool:
        """Check if this is detailed coverage (branch or condition).
        Returns: true for Branch or Condition
        Example: CoverageType.Branch.is_detailed()  # → true
        """
        match self:
            case Branch: true
            case Condition: true
            case _: false

    pub fn is_basic(self) -> bool:
        """Check if this is basic coverage (line or function).
        Returns: true for Line or Function
        Example: CoverageType.Line.is_basic()  # → true
        """
        match self:
            case Line: true
            case Function: true
            case _: false

    pub fn to_string(self) -> text:
        """Convert CoverageType to string representation.
        Returns: lowercase coverage type name
        Example: CoverageType.Branch.to_string()  # → "branch"
        """
        match self:
            case Line: "line"
            case Branch: "branch"
            case Condition: "condition"
            case Function: "function"

    pub fn description(self) -> text:
        """Get human-readable description of the coverage type.
        Returns: descriptive explanation
        Example: CoverageType.Branch.description()  # → "Branch coverage (if/else paths)"
        """
        match self:
            case Line: "Line coverage (executed lines)"
            case Branch: "Branch coverage (if/else paths)"
            case Condition: "Condition coverage (boolean sub-expressions)"
            case Function: "Function coverage (called functions)"

    pub fn summary(self) -> text:
        """Get comprehensive summary of the coverage type.
        Returns: summary with name, description, and category
        Example: CoverageType.Branch.summary()
                # → "CoverageType: branch (Branch coverage (if/else paths), detailed)"
        """
        val name = self.to_string()
        val desc = self.description()
        val category = if self.is_detailed():
            "detailed"
        else:
            "basic"

        "CoverageType: {name} ({desc}, {category})"

# Coverage data for a symbol
pub class SymbolCoverage:
    pub symbol_name: text
    pub line_coverage: f64      # 0.0 - 1.0
    pub branch_coverage: f64    # 0.0 - 1.0
    pub condition_coverage: f64 # 0.0 - 1.0
    pub covered_lines: i64
    pub total_lines: i64
    pub covered_branches: i64
    pub total_branches: i64

# Coverage report
pub class CoverageReport:
    pub file_path: text
    pub overall_coverage: f64
    pub symbol_coverage: Dict<text, SymbolCoverage>
    pub uncovered_lines: List<i64>

# Parse coverage data (simplified - would integrate with actual coverage tool)
pub fn parse_coverage_data(coverage_json: text) -> CoverageReport:
    use core.json.{parse, JsonValue}

    symbol_coverage = {}
    var file_path = ""
    var overall_coverage = 0.0
    var uncovered_lines: List<i64> = []

    # Parse coverage JSON format:
    # {
    #   "file": "path/to/file.spl",
    #   "overall": 0.82,
    #   "symbols": {
    #     "main": { "line": 0.85, "branch": 0.75, "condition": 0.80, ... }
    #   },
    #   "uncovered": [15, 23, 47]
    # }
    match parse(coverage_json):
        case Ok(JsonValue.Object(obj)):
            if val Some(JsonValue.String(path)) = obj.get("file"):
                file_path = path

            if val Some(JsonValue.Number(cov)) = obj.get("overall"):
                overall_coverage = cov

            if val Some(JsonValue.Object(symbols)) = obj.get("symbols"):
                for (name, data) in symbols.entries():
                    if val JsonValue.Object(sym_data) = data:
                        var sym_cov = SymbolCoverage(symbol_name: name, line_coverage: 0.0, branch_coverage: 0.0, condition_coverage: 0.0, covered_lines: 0, total_lines: 0, covered_branches: 0, total_branches: 0)

                        if val Some(JsonValue.Number(v)) = sym_data.get("line"):
                            sym_cov.line_coverage = v
                        if val Some(JsonValue.Number(v)) = sym_data.get("branch"):
                            sym_cov.branch_coverage = v
                        if val Some(JsonValue.Number(v)) = sym_data.get("condition"):
                            sym_cov.condition_coverage = v
                        if val Some(JsonValue.Number(v)) = sym_data.get("covered_lines"):
                            sym_cov.covered_lines = v as i64
                        if val Some(JsonValue.Number(v)) = sym_data.get("total_lines"):
                            sym_cov.total_lines = v as i64
                        if val Some(JsonValue.Number(v)) = sym_data.get("covered_branches"):
                            sym_cov.covered_branches = v as i64
                        if val Some(JsonValue.Number(v)) = sym_data.get("total_branches"):
                            sym_cov.total_branches = v as i64

                        symbol_coverage.set(name, sym_cov)

            if val Some(JsonValue.Array(lines)) = obj.get("uncovered"):
                for line in lines:
                    if val JsonValue.Number(n) = line:
                        uncovered_lines.append(n as i64)

        case _:
            # Fallback to mock data for backwards compatibility
            val main_cov = SymbolCoverage(symbol_name: "main", line_coverage: 0.85, branch_coverage: 0.75, condition_coverage: 0.80, covered_lines: 17, total_lines: 20, covered_branches: 6, total_branches: 8)
            symbol_coverage.set("main", main_cov)
            overall_coverage = 0.82
            uncovered_lines = [15, 23, 47]

    return CoverageReport(file_path: file_path, overall_coverage: overall_coverage, symbol_coverage: symbol_coverage, uncovered_lines: uncovered_lines)

# Format coverage overlay for MCP
pub fn format_coverage_overlay(symbols: List<Symbol>, coverage: CoverageReport) -> text:
    result = ""

    for symbol in symbols:
        # Get coverage for this symbol
        cov_opt = None
        if coverage.symbol_coverage.has_key(symbol.name):
            cov_opt = Some(coverage.symbol_coverage.get(symbol.name))

        if cov_opt.is_some():
            cov = cov_opt.unwrap()
            result = result + format_symbol_with_coverage(symbol, cov) + "\n"
        else:
            # No coverage data - show symbol without coverage
            result = result + format_symbol_no_coverage(symbol) + "\n"

    return result

# Format symbol with coverage data
fn format_symbol_with_coverage(symbol: Symbol, coverage: SymbolCoverage) -> text:
    # Get coverage indicator
    indicator = get_coverage_indicator(coverage.line_coverage)

    # Format: C> pub class User { … } [85% ●]
    mark = get_block_mark_collapsed(symbol.kind)
    vis = get_visibility_prefix(symbol.visibility)

    result = mark + " " + vis + symbol.signature + " { … }"

    # Add coverage overlay
    coverage_pct = (coverage.line_coverage * 100.0).to_i64()
    result = result + " [" + coverage_pct.to_string() + "% " + indicator + "]"

    return result

# Format symbol without coverage
fn format_symbol_no_coverage(symbol: Symbol) -> text:
    mark = get_block_mark_collapsed(symbol.kind)
    vis = get_visibility_prefix(symbol.visibility)
    return mark + " " + vis + symbol.signature + " { … } [no coverage]"

# Get coverage indicator symbol
fn get_coverage_indicator(coverage: f64) -> text:
    if coverage >= 0.9:
        return "●"  # Full coverage (green)
    elif coverage >= 0.7:
        return "◐"  # Partial coverage (yellow)
    elif coverage >= 0.5:
        return "◑"  # Half coverage (orange)
    else:
        return "○"  # Low coverage (red)

# Format detailed coverage for expanded symbol
pub fn format_detailed_coverage(symbol: Symbol, coverage: SymbolCoverage) -> text:
    result = "Coverage Details for " + symbol.name + ":\n"

    line_pct = (coverage.line_coverage * 100.0).to_i64()
    branch_pct = (coverage.branch_coverage * 100.0).to_i64()
    condition_pct = (coverage.condition_coverage * 100.0).to_i64()

    result = result + "  Line Coverage:      " + line_pct.to_string() + "% "
    result = result + "(" + coverage.covered_lines.to_string() + "/" + coverage.total_lines.to_string() + ")\n"

    result = result + "  Branch Coverage:    " + branch_pct.to_string() + "% "
    result = result + "(" + coverage.covered_branches.to_string() + "/" + coverage.total_branches.to_string() + ")\n"

    result = result + "  Condition Coverage: " + condition_pct.to_string() + "%\n"

    return result

# Format coverage summary for entire file
pub fn format_coverage_summary(coverage: CoverageReport) -> text:
    overall_pct = (coverage.overall_coverage * 100.0).to_i64()
    indicator = get_coverage_indicator(coverage.overall_coverage)

    result = "COV> Coverage Summary " + indicator + " {\n"
    result = result + "  Overall: " + overall_pct.to_string() + "%\n"
    result = result + "  Symbols covered: " + coverage.symbol_coverage.len().to_string() + "\n"
    result = result + "  Uncovered lines: " + coverage.uncovered_lines.len().to_string() + "\n"

    if coverage.uncovered_lines.len() > 0 and coverage.uncovered_lines.len() < 10:
        result = result + "  Lines: "
        for i in range(coverage.uncovered_lines.len()):
            if i > 0:
                result = result + ", "
            result = result + coverage.uncovered_lines[i].to_string()
        result = result + "\n"

    result = result + "}\n"
    return result

# Helper: Get block mark for collapsed symbol
fn get_block_mark_collapsed(kind: SymbolKind) -> text:
    if kind == SymbolKind.Class:
        return "C>"
    elif kind == SymbolKind.Function:
        return "F>"
    elif kind == SymbolKind.Trait:
        return "T>"
    else:
        return "P>"

# Helper: Get visibility prefix
fn get_visibility_prefix(vis: Visibility) -> text:
    if vis == Visibility.Public:
        return "pub "
    else:
        return ""

# Find symbols with low coverage
pub fn find_low_coverage_symbols(coverage: CoverageReport, threshold: f64) -> List<text>:
    low_coverage = []

    for symbol_name in coverage.symbol_coverage.keys():
        cov = coverage.symbol_coverage.get(symbol_name)
        if cov.line_coverage < threshold:
            low_coverage.append(symbol_name)

    return low_coverage

# Calculate coverage by category
pub fn calculate_category_coverage(coverage: CoverageReport) -> Dict<text, f64>:
    # Categories: classes, functions, total
    categories = {}

    class_count = 0
    class_coverage_sum = 0.0
    func_count = 0
    func_coverage_sum = 0.0

    for symbol_name in coverage.symbol_coverage.keys():
        cov = coverage.symbol_coverage.get(symbol_name)

        # Heuristic: if name starts with uppercase, it's a class
        if symbol_name[0].is_upper():
            class_count = class_count + 1
            class_coverage_sum = class_coverage_sum + cov.line_coverage
        else:
            func_count = func_count + 1
            func_coverage_sum = func_coverage_sum + cov.line_coverage

    if class_count > 0:
        categories.set("classes", class_coverage_sum / class_count.to_f64())
    if func_count > 0:
        categories.set("functions", func_coverage_sum / func_count.to_f64())

    categories.set("overall", coverage.overall_coverage)

    return categories
