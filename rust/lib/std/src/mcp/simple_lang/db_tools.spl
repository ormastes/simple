# MCP Database Query Tools
# Provides tools to query all SDN databases (tests, features, bugs, TODOs, qualified ignores)

use infra.file_io.read_file
use sdn.*
use mcp.core.*

# Helper: format rows as a markdown table
fn format_markdown_table(headers: List<text>, rows: List<List<text>>) -> text:
    if rows.len() == 0:
        return "(no results)"

    # Header row
    var result = "| " + headers.join(" | ") + " |\n"
    result = result + "| " + headers.map(\h: "---").join(" | ") + " |\n"

    # Data rows
    for row in rows:
        result = result + "| " + row.join(" | ") + " |\n"

    result

# Helper: apply limit to rows
fn apply_limit(rows: List<List<text>>, limit: i64) -> List<List<text>>:
    if limit <= 0:
        rows
    else:
        rows[0:limit]

# Tool: query_tests - Query test execution database
fn create_query_tests_tool() -> ToolHandler:
    val handler = \args:
        val status_filter = args.get("status")
        val category_filter = args.get("category")
        val limit = args.get("limit") ?? 50

        match read_file("doc/test/test_db.sdn"):
            case Err(e): "Error reading test database: {e}"
            case Ok(content):
                val doc = parse(content)
                val table = doc.get_table("tests")
                if not table.?:
                    return "No tests table found in test_db.sdn"

                val headers = ["test_id", "test_name", "status", "category", "last_run"]
                var rows = []

                for record in table.rows():
                    val status = record.get("status")
                    val category = record.get("category")

                    # Apply filters
                    if status_filter.? and status != status_filter:
                        continue
                    if category_filter.? and category != category_filter:
                        continue

                    rows.append([
                        record.get("test_id"),
                        record.get("test_name"),
                        status,
                        category,
                        record.get("last_run")
                    ])

                rows = apply_limit(rows, limit)
                format_markdown_table(headers, rows)

    create_text_tool("query_tests", "Query test execution database. Params: status (passed/failed/ignored/skipped), category, limit", handler)

# Tool: query_features - Query feature database
fn create_query_features_tool() -> ToolHandler:
    val handler = \args:
        val status_filter = args.get("status")
        val category_filter = args.get("category")
        val limit = args.get("limit") ?? 50

        match read_file("doc/feature/feature_db.sdn"):
            case Err(e): "Error reading feature database: {e}"
            case Ok(content):
                val doc = parse(content)
                val table = doc.get_table("features")
                if not table.?:
                    return "No features table found in feature_db.sdn"

                val headers = ["feature_id", "name", "status", "category"]
                var rows = []

                for record in table.rows():
                    val status = record.get("status")
                    val category = record.get("category")

                    if status_filter.? and status != status_filter:
                        continue
                    if category_filter.? and category != category_filter:
                        continue

                    rows.append([
                        record.get("feature_id"),
                        record.get("name"),
                        status,
                        category
                    ])

                rows = apply_limit(rows, limit)
                format_markdown_table(headers, rows)

    create_text_tool("query_features", "Query feature database. Params: status (complete/in_progress/planned), category, limit", handler)

# Tool: query_bugs - Query bug database
fn create_query_bugs_tool() -> ToolHandler:
    val handler = \args:
        val severity_filter = args.get("severity")
        val status_filter = args.get("status")
        val limit = args.get("limit") ?? 50

        match read_file("doc/bug/bug_db.sdn"):
            case Err(e): "Error reading bug database: {e}"
            case Ok(content):
                val doc = parse(content)
                val table = doc.get_table("bugs")
                if not table.?:
                    return "No bugs table found in bug_db.sdn"

                val headers = ["bug_id", "description", "severity", "status"]
                var rows = []

                for record in table.rows():
                    val severity = record.get("severity")
                    val status = record.get("status")

                    if severity_filter.? and severity != severity_filter:
                        continue
                    if status_filter.? and status != status_filter:
                        continue

                    rows.append([
                        record.get("bug_id"),
                        record.get("description"),
                        severity,
                        status
                    ])

                rows = apply_limit(rows, limit)
                format_markdown_table(headers, rows)

    create_text_tool("query_bugs", "Query bug database. Params: severity (P0-P3), status, limit", handler)

# Tool: query_todos - Query TODO database
fn create_query_todos_tool() -> ToolHandler:
    val handler = \args:
        val area_filter = args.get("area")
        val priority_filter = args.get("priority")
        val keyword_filter = args.get("keyword")
        val limit = args.get("limit") ?? 50

        match read_file("doc/todo/todo_db.sdn"):
            case Err(e): "Error reading TODO database: {e}"
            case Ok(content):
                val doc = parse(content)
                val table = doc.get_table("todos")
                if not table.?:
                    return "No todos table found in todo_db.sdn"

                val headers = ["id", "keyword", "area", "priority", "description", "file"]
                var rows = []

                for record in table.rows():
                    val area = record.get("area")
                    val priority = record.get("priority")
                    val keyword = record.get("keyword")

                    if area_filter.? and area != area_filter:
                        continue
                    if priority_filter.? and priority != priority_filter:
                        continue
                    if keyword_filter.? and keyword != keyword_filter:
                        continue

                    rows.append([
                        record.get("id"),
                        keyword,
                        area,
                        priority,
                        record.get("description"),
                        record.get("file")
                    ])

                rows = apply_limit(rows, limit)
                format_markdown_table(headers, rows)

    create_text_tool("query_todos", "Query TODO database. Params: area, priority (P0-P3), keyword (TODO/FIXME), limit", handler)

# Tool: query_qualified_ignores - Query qualified ignore records
fn create_query_qualified_ignores_tool() -> ToolHandler:
    val handler = \args:
        val limit = args.get("limit") ?? 50

        match read_file("doc/test/test_db.sdn"):
            case Err(e): "Error reading test database: {e}"
            case Ok(content):
                val doc = parse(content)
                val table = doc.get_table("tests")
                if not table.?:
                    return "No tests table found in test_db.sdn"

                val headers = ["test_id", "test_name", "status", "qualified_by", "qualified_at", "qualified_reason"]
                var rows = []

                for record in table.rows():
                    val status = record.get("status")
                    val qualified_by = record.get("qualified_by")

                    # Show ignored/qualified_ignore tests, especially those with qualification info
                    if status != "ignored" and status != "qualified_ignore" and status != "qualifiedignore":
                        continue

                    rows.append([
                        record.get("test_id"),
                        record.get("test_name"),
                        status,
                        qualified_by ?? "-",
                        record.get("qualified_at") ?? "-",
                        record.get("qualified_reason") ?? "-"
                    ])

                rows = apply_limit(rows, limit)
                format_markdown_table(headers, rows)

    create_text_tool("query_qualified_ignores", "Query qualified ignore records from test database. Params: limit", handler)

# Helper: classify error type from error message
fn classify_error(error_msg: text) -> text:
    if error_msg.contains("parse error") or error_msg.contains("Unexpected token"):
        return "parse_error"
    elif error_msg.contains("semantic:") or error_msg.contains("not found") or error_msg.contains("cannot modify"):
        return "semantic_error"
    elif error_msg.contains("No such file or directory"):
        return "file_not_found"
    elif error_msg.contains("timed out") or error_msg.contains("timeout"):
        return "timeout"
    elif error_msg.contains("stream did not contain valid UTF-8"):
        return "utf8_error"
    else:
        return "unknown_error"

# Helper: extract needed features from error message
fn extract_needed_features(error_msg: text) -> List<text>:
    var features = []

    # Parser feature patterns
    if error_msg.contains("expected Fn, found Static"):
        features.append("static_fields")
    if error_msg.contains("expected expression, found Default"):
        features.append("default_parameters")
    if error_msg.contains("expected expression, found Assign"):
        features.append("implicit_val_var")
    if error_msg.contains("expected expression, found At"):
        features.append("matrix_multiplication")
    if error_msg.contains("expected identifier, found Xor"):
        features.append("xor_keyword")
    if error_msg.contains("expected Comma, found Colon"):
        features.append("dict_literal_syntax")
    if error_msg.contains("expected pattern, found Val"):
        features.append("val_pattern_matching")
    if error_msg.contains("expected identifier, found Where"):
        features.append("where_clause")
    if error_msg.contains("expected expression, found For"):
        features.append("list_comprehension")
    if error_msg.contains("expected fn, struct, class") and error_msg.contains("found Val"):
        features.append("pub_val_declaration")
    if error_msg.contains("expected expression, found Slash"):
        features.append("parallel_operator")
    if error_msg.contains("expected pattern, found From"):
        features.append("from_pattern")
    if error_msg.contains("expected expression, found Return"):
        features.append("return_expression")
    if error_msg.contains("expected Fn, found Var"):
        features.append("class_var_fields")
    if error_msg.contains("expected RBracket, found Comma"):
        features.append("array_literal_syntax")
    if error_msg.contains("expected expression, found Indent"):
        features.append("indented_block_expression")
    if error_msg.contains("Unexpected character: '`'"):
        features.append("backtick_in_docstring")

    # Semantic feature patterns
    if error_msg.contains("method `char_at` not found"):
        features.append("string_char_at_method")
    if error_msg.contains("cannot modify") and error_msg.contains("immutable fn"):
        features.append("mutability_checking")

    features

# Helper: truncate text to max length
fn truncate_text(text: text, max_len: i64) -> text:
    if text.len() <= max_len:
        text
    else:
        text[0:max_len] + "..."

# Tool: query_failed_test_details - Get detailed information about failed tests
fn create_query_failed_test_details_tool() -> ToolHandler:
    val handler = \args:
        val limit = args.get("limit") ?? 50
        val include_error = args.get("include_error") ?? true
        val include_features = args.get("include_features") ?? false
        val category_filter = args.get("category")

        match read_file("doc/test/test_db.sdn"):
            case Err(e): "Error reading test database: {e}"
            case Ok(content):
                val doc = parse(content)
                val table = doc.get_table("tests")
                if not table.?:
                    return "No tests table found in test_db.sdn"

                var headers = ["test_name", "file", "category", "error_type"]
                if include_error:
                    headers.append("error_msg")
                if include_features:
                    headers.append("needed_features")

                var rows = []

                for record in table.rows():
                    val status = record.get("status")
                    val category = record.get("category")

                    if status != "failed":
                        continue

                    if category_filter.? and category != category_filter:
                        continue

                    val error_msg = record.get("error_message") ?? ""
                    val error_type = classify_error(error_msg)

                    var row = [
                        record.get("test_name"),
                        record.get("file"),
                        category,
                        error_type
                    ]

                    if include_error:
                        row.append(truncate_text(error_msg, 100))

                    if include_features:
                        val features = extract_needed_features(error_msg)
                        row.append(features.join(", "))

                    rows.append(row)

                rows = apply_limit(rows, limit)
                format_markdown_table(headers, rows)

    create_text_tool("query_failed_test_details", "Query failed tests with error details and needed features. Params: limit, include_error (bool), include_features (bool), category", handler)

# Tool: analyze_failures - Analyze failed test patterns
fn create_analyze_failures_tool() -> ToolHandler:
    val handler = \args:
        match read_file("doc/test/test_db.sdn"):
            case Err(e): "Error reading test database: {e}"
            case Ok(content):
                val doc = parse(content)
                val table = doc.get_table("tests")
                if not table.?:
                    return "No tests table found in test_db.sdn"

                # Group by error type
                var error_groups = {}
                var feature_counts = {}
                var total_failed = 0

                for record in table.rows():
                    if record.get("status") == "failed":
                        total_failed = total_failed + 1
                        val error_msg = record.get("error_message") ?? ""
                        val error_type = classify_error(error_msg)

                        # Count error types
                        if not error_groups.has_key(error_type):
                            error_groups[error_type] = 0
                        error_groups[error_type] = error_groups[error_type] + 1

                        # Count needed features
                        val features = extract_needed_features(error_msg)
                        for feature in features:
                            if not feature_counts.has_key(feature):
                                feature_counts[feature] = 0
                            feature_counts[feature] = feature_counts[feature] + 1

                # Format output
                var result = "# Failed Test Analysis\n\n"
                result = result + "**Total Failed Tests:** " + total_failed.to_string() + "\n\n"

                result = result + "## Failures by Error Type\n\n"
                result = result + "| Error Type | Count | Percentage |\n"
                result = result + "| --- | --- | --- |\n"
                for error_type in error_groups.keys():
                    val count = error_groups[error_type]
                    val pct = (count * 100) / total_failed
                    result = result + "| " + error_type + " | " + count.to_string() + " | " + pct.to_string() + "% |\n"

                result = result + "\n## Most Needed Features\n\n"
                result = result + "| Feature | Tests Blocked | Priority |\n"
                result = result + "| --- | --- | --- |\n"

                # Sort features by count (descending)
                var feature_list = []
                for feature in feature_counts.keys():
                    feature_list.append([feature, feature_counts[feature]])

                # Sort by count descending (manual bubble sort)
                var n = feature_list.len()
                for i in 0..n:
                    for j in 0..(n - i - 1):
                        if feature_list[j][1] < feature_list[j + 1][1]:
                            val temp = feature_list[j]
                            feature_list[j] = feature_list[j + 1]
                            feature_list[j + 1] = temp

                # Output top features
                var rank = 0
                for item in feature_list:
                    rank = rank + 1
                    val feature = item[0]
                    val count = item[1]
                    val priority = if count >= 10:
                        "ðŸ”´ Critical"
                    elif count >= 5:
                        "ðŸŸ  High"
                    elif count >= 2:
                        "ðŸŸ¡ Medium"
                    else:
                        "ðŸŸ¢ Low"

                    result = result + "| " + feature + " | " + count.to_string() + " | " + priority + " |\n"

                    if rank >= 20:
                        break

                result

    create_text_tool("analyze_failures", "Analyze failed test patterns and identify most needed features", handler)

# Tool: find_features_for_failed_tests - Cross-reference with feature database
fn create_find_features_for_failed_tests_tool() -> ToolHandler:
    val handler = \args:
        # Read test database
        val test_content = match read_file("doc/test/test_db.sdn"):
            case Err(e): return "Error reading test database: {e}"
            case Ok(c): c

        # Read feature database
        val feature_content = match read_file("doc/feature/feature_db.sdn"):
            case Err(e): return "Error reading feature database: {e}"
            case Ok(c): c

        val test_doc = parse(test_content)
        val feature_doc = parse(feature_content)

        val test_table = test_doc.get_table("tests")
        val feature_table = feature_doc.get_table("features")

        if not test_table.?:
            return "No tests table found"
        if not feature_table.?:
            return "No features table found"

        # Build feature map
        var feature_map = {}
        for feature in feature_table.rows():
            val name = feature.get("name").lower()
            val status = feature.get("status")
            val category = feature.get("category")
            val feature_id = feature.get("id")

            var feature_info = {}
            feature_info = feature_info.set("status", status)
            feature_info = feature_info.set("category", category)
            feature_info = feature_info.set("id", feature_id)

            feature_map = feature_map.set(name, feature_info)

        # Analyze failed tests
        var needed_features = {}
        var feature_tests = {}  # Map feature -> List of test names
        var feature_status = {}  # Map feature -> status
        var feature_category = {}  # Map feature -> category

        for test in test_table.rows():
            if test.get("status") == "failed":
                val error_msg = test.get("error_message") ?? ""
                val features = extract_needed_features(error_msg)

                for feature in features:
                    # Initialize test list for this feature
                    if not feature_tests.has_key(feature):
                        feature_tests = feature_tests.set(feature, [])
                        feature_status = feature_status.set(feature, "unknown")
                        feature_category = feature_category.set(feature, "unknown")

                    # Add test to feature's list
                    var tests = feature_tests.get(feature)
                    tests = tests.append(test.get("test_name"))
                    feature_tests = feature_tests.set(feature, tests)

                    # Try to match with feature database
                    if feature_map.has_key(feature.lower()):
                        val feature_info = feature_map.get(feature.lower())
                        feature_status = feature_status.set(feature, feature_info.get("status"))
                        feature_category = feature_category.set(feature, feature_info.get("category"))

        # Format output
        var result = "# Features Needed for Failed Tests\n\n"

        for feature in feature_tests.keys():
            val tests = feature_tests.get(feature)
            val test_count = tests.len()
            val status = feature_status.get(feature)
            val category = feature_category.get(feature)

            result = result + "## " + feature + "\n"
            result = result + "- **Status:** " + status + "\n"
            result = result + "- **Category:** " + category + "\n"
            result = result + "- **Tests Blocked:** " + test_count.to_string() + "\n"

            # Show first 5 tests
            var test_list = if test_count > 5:
                tests[0:5]
            else:
                tests

            result = result + "- **Tests:** " + test_list.join(", ")

            if test_count > 5:
                result = result + " (+" + (test_count - 5).to_string() + " more)"

            result = result + "\n\n"

        result

    create_text_tool("find_features_for_failed_tests", "Find which features are needed to fix failed tests", handler)

# Create all database query tools
pub fn create_db_query_tools() -> List<ToolHandler>:
    [
        create_query_tests_tool(),
        create_query_features_tool(),
        create_query_bugs_tool(),
        create_query_todos_tool(),
        create_query_qualified_ignores_tool(),
        create_query_failed_test_details_tool(),
        create_analyze_failures_tool(),
        create_find_features_for_failed_tests_tool()
    ]
