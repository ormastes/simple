# #1283: Context pack integration
# =============================================================================

pub fn extract_context_pack(output: &McpOutput, symbols: &Array<text>) -> ContextPack:
    var pack = ContextPack.new()

    for symbol in symbols:
        if val Some(item) = output.find_symbol(symbol):
            pack.add_symbol(item.clone())

    return pack

pub struct ContextPack:
    symbols: Array<McpItem>
    dependencies: Array<text>

impl ContextPack:
    static fn new() -> ContextPack:
        return ContextPack { symbols: [], dependencies: [] }

    fn add_symbol(symbol: McpItem):
        self.symbols.push(symbol)

# =============================================================================
# #1284: Dependency symbol extraction
# =============================================================================

pub fn extract_dependencies(output: &McpOutput) -> Array<Dependency>:
    var deps: Array<Dependency> = []

    for item in &output.items:
        if item.kind == ItemKind.Import:
            deps.push(Dependency {
                name: item.metadata.name.clone(),
                kind: DependencyKind.External
            })

    return deps

pub struct Dependency:
    pub name: text
    pub kind: DependencyKind

pub enum DependencyKind:
    External
    Internal

impl DependencyKind:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_external() -> bool:
        """Check if dependency is External.

        Returns:
            true for External

        Example:
            DependencyKind.External.is_external()  # → true
        """
        match self:
            case External: true
            case _: false

    fn is_internal() -> bool:
        """Check if dependency is Internal.

        Returns:
            true for Internal

        Example:
            DependencyKind.Internal.is_internal()  # → true
        """
        match self:
            case Internal: true
            case _: false

    fn is_local() -> bool:
        """Check if dependency is local (internal).

        Returns:
            true for Internal

        Example:
            DependencyKind.Internal.is_local()  # → true
        """
        return self.is_internal()

    fn requires_download() -> bool:
        """Check if dependency might require downloading.

        Returns:
            true for External

        Example:
            DependencyKind.External.requires_download()  # → true
            DependencyKind.Internal.requires_download()  # → false
        """
        match self:
            case External: true
            case Internal: false

    fn to_string() -> text:
        """Convert dependency kind to string.

        Returns:
            Kind name

        Example:
            DependencyKind.External.to_string()  # → "external"
        """
        match self:
            case External: "external"
            case Internal: "internal"

    fn description() -> text:
        """Get dependency kind description.

        Returns:
            Human-readable description

        Example:
            DependencyKind.External.description()
            # → "External dependency (third-party)"
        """
        match self:
            case External: "External dependency (third-party)"
            case Internal: "Internal dependency (local project)"

    fn summary() -> text:
        """Get summary of dependency kind.

        Returns:
            Human-readable summary

        Example:
            DependencyKind.External.summary()
            # → "DependencyKind: external (third-party, may require download)"
        """
        val name = self.to_string()
        match self:
            case External:
                "DependencyKind: {name} (third-party, may require download)"
            case Internal:
                "DependencyKind: {name} (local project)"

# =============================================================================
