# #1285-1286: Minimal context bundling & Diff mode
# =============================================================================

pub fn minimal_bundle(output: &McpOutput, only_public: bool) -> McpOutput:
    var minimal = McpOutput.new()

    for item in &output.items:
        if only_public and item.metadata.visibility != "public":
            continue
        minimal.add_item(item.clone())

    return minimal

pub fn diff_mode(old_output: &McpOutput, new_output: &McpOutput) -> McpOutput:
    var diff = McpOutput.new()

    # Find changed symbols
    for new_item in &new_output.items:
        val changed = if val Some(old_item) = old_output.find_symbol(&new_item.metadata.name):
            old_item.line != new_item.line
        else:
            true  # New symbol

        if changed:
            diff.add_item(new_item.clone())

    return diff

# =============================================================================
# #1287-1288: Blame integration & Cross-reference inlining
# =============================================================================

pub fn add_blame_info(output: &mut McpOutput, git_repo: &str) -> Result<(), McpError>:
    for item in &mut output.items:
        # Get git blame info for each item's location
        val file_path = item.metadata.location.file
        val line = item.metadata.location.line

        val cmd = "git"
        val args = "-C {git_repo} blame -L {line},{line} --porcelain {file_path}"
        val (exit_code, stdout, stderr) = _rt_process_run(cmd.ptr(), cmd.len(), args.ptr(), args.len())

        if exit_code == 0 and not stdout.is_empty():
            # Parse porcelain output
            var author = "unknown"
            var commit = "unknown"

            for blame_line in stdout.lines():
                if blame_line.starts_with("author "):
                    author = blame_line.substring(7, blame_line.len())
                elif blame_line.len() == 40 and not blame_line.contains(" "):
                    commit = blame_line.substring(0, 8)  # Short commit hash

            item.metadata.add_overlay("author", author)
            item.metadata.add_overlay("commit", commit)
        else:
            item.metadata.add_overlay("author", "unknown")
            item.metadata.add_overlay("commit", "unknown")
    return Ok(())

pub fn inline_call_sites(output: &mut McpOutput, call_graph: &CallGraph) -> Result<(), McpError>:
    for item in &mut output.items:
        if item.kind == ItemKind.Function:
            if val Some(callers) = call_graph.get_callers(&item.metadata.name):
                for caller in callers:
                    item.metadata.add_overlay("caller", caller)
    return Ok(())

pub struct CallGraph:
    edges: Dict<text, Array<text>>

impl CallGraph:
    fn get_callers(name: &str) -> Option<Array<text>>:
        return self.edges.get(name).cloned()

# =============================================================================
