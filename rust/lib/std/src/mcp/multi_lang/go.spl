# Go Language MCP-MCP Provider

use core.*
use mcp.core.protocol.*
use mcp.multi_lang.*
use mcp.multi_lang.base_provider.*

pub struct GoProvider:
    parser: TreeSitterParser

impl GoProvider:
    pub fn new() -> GoProvider:
        return GoProvider { parser: create_parser("go") }

impl LanguageProvider for GoProvider:
    fn name() -> text:
        return "go".to_string()

    fn extensions() -> Array<text>:
        return ["go".to_string()]

    fn fold(source: &str, opts: &FoldOptions) -> Result<McpOutput, McpError>:
        var output = McpOutput.new()

        # Parse Go code patterns for functions, structs, interfaces
        var current_line = 0
        for line in source.lines():
            current_line += 1
            val trimmed = line.trim()

            # Function: func name(...) ... {
            if trimmed.starts_with("func "):
                val parts = trimmed.substring(5, trimmed.len()).split("(")
                if parts.len() > 0:
                    val func_name = parts[0].trim()
                    output.add_symbol(Symbol.new(func_name, SymbolKind.Function, current_line))

            # Struct: type Name struct {
            elif trimmed.starts_with("type ") and trimmed.contains("struct"):
                val parts = trimmed.split(" ")
                if parts.len() >= 2:
                    val struct_name = parts[1]
                    output.add_symbol(Symbol.new(struct_name, SymbolKind.Struct, current_line))

            # Interface: type Name interface {
            elif trimmed.starts_with("type ") and trimmed.contains("interface"):
                val parts = trimmed.split(" ")
                if parts.len() >= 2:
                    val iface_name = parts[1]
                    output.add_symbol(Symbol.new(iface_name, SymbolKind.Interface, current_line))

            # Package: package name
            elif trimmed.starts_with("package "):
                val pkg_name = trimmed.substring(8, trimmed.len()).trim()
                output.add_symbol(Symbol.new(pkg_name, SymbolKind.Package, current_line))

        return Ok(output)

    fn get_symbols(source: &str) -> Result<Array<Symbol>, McpError>:
        return default_get_symbols(source)

    fn get_diagnostics(source: &str) -> Result<Array<Diagnostic>, McpError>:
        return default_get_diagnostics(source)
