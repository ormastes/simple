# Rust Language MCP-MCP Provider
#
# Provides MCP-MCP folding for Rust source code.
# Uses Tree-sitter for parsing and analysis.

use core.*
use mcp.core.protocol.*
use mcp.multi_lang.*

pub struct RustProvider:
    parser: TreeSitterParser

impl RustProvider:
    pub fn new() -> RustProvider:
        return RustProvider {parser: TreeSitterParser.new("rust")}

impl LanguageProvider for RustProvider:
    fn name() -> text:
        return "rust".to_string()

    fn extensions() -> Array<text>:
        return ["rs".to_string()]

    fn fold(source: &str, opts: &FoldOptions) -> Result<McpOutput, McpError>:
        val tree = self.parser.parse(source)?
        var output = McpOutput.new()

        # Process top-level items
        for node in tree.root_node().children():
            match node.kind():
                case "function_item":
                    output.add_item(self.format_function(&node, source, opts))
                case "struct_item":
                    output.add_item(self.format_struct(&node, source, opts))
                case "enum_item":
                    output.add_item(self.format_enum(&node, source, opts))
                case "impl_item":
                    output.add_item(self.format_impl(&node, source, opts))
                case "trait_item":
                    output.add_item(self.format_trait(&node, source, opts))
                case "mod_item":
                    output.add_item(self.format_module(&node, source, opts))
                case "use_declaration":
                    if opts.show_imports:
                        output.add_item(self.format_use(&node, source))
                case _:
                    pass  # Skip other nodes

        return Ok(output)

    fn get_symbols(source: &str) -> Result<Array<Symbol>, McpError>:
        val tree = self.parser.parse(source)?
        var symbols: Array<Symbol> = []

        for node in tree.root_node().children():
            if val Some(symbol) = self.node_to_symbol(&node, source):
                symbols.push(symbol)

        return Ok(symbols)

    fn get_diagnostics(source: &str) -> Result<Array<Diagnostic>, McpError>:
        # Rust diagnostics would come from rustc/clippy
        # This is a placeholder
        return Ok([])

impl RustProvider:
    fn format_function(node: &TreeNode, source: &str, opts: &FoldOptions) -> McpItem:
        val name = self.get_function_name(node, source)
        val visibility = self.get_visibility(node, source)
        val signature = self.get_function_signature(node, source)

        val prefix = if visibility == "pub" { "pub " } else { "" }
        val marker = if opts.use_markers { "F> " } else { "" }

        return McpItem {
            kind: ItemKind.Function,
            line: format!("{}{}{}", marker, prefix, signature),
            children: if opts.collapse_bodies { [] } else {
                self.get_function_body_items(node, source, opts)
            },
            metadata: McpMetadata {
                visibility: visibility,
                name: name,
                location: self.get_location(node)
            }
        }

    fn format_struct(node: &TreeNode, source: &str, opts: &FoldOptions) -> McpItem:
        val name = self.get_struct_name(node, source)
        val visibility = self.get_visibility(node, source)
        val generics = self.get_generics(node, source)

        val prefix = if visibility == "pub" { "pub " } else { "" }
        val gen_str = if generics.is_empty() { "" } else { format!("<{}>", generics) }
        val marker = if opts.use_markers { "T> " } else { "" }

        var children: Array<McpItem> = []
        if val Some(fields_node) = self.get_struct_fields(node):
            for field in fields_node.children():
                children.push(self.format_struct_field(&field, source, opts))

        return McpItem {
            kind: ItemKind.Struct,
            line: format!("{}{}struct {}{}", marker, prefix, name, gen_str),
            children: if opts.collapse_bodies { [] } else { children },
            metadata: McpMetadata {
                visibility: visibility,
                name: name,
                location: self.get_location(node)
            }
        }

    fn format_struct_field(node: &TreeNode, source: &str, opts: &FoldOptions) -> McpItem:
        val name = self.get_field_name(node, source)
        val field_type = self.get_field_type(node, source)
        val visibility = self.get_visibility(node, source)

        val prefix = if visibility == "pub" { "pub " } else { "" }
        val marker = if opts.use_markers { "V• " } else { "  " }

        return McpItem {
            kind: ItemKind.Field,
            line: format!("{}{}{}: {}", marker, prefix, name, field_type),
            children: [],
            metadata: McpMetadata {
                visibility: visibility,
                name: name,
                location: self.get_location(node)
            }
        }

    fn format_enum(node: &TreeNode, source: &str, opts: &FoldOptions) -> McpItem:
        val name = self.get_enum_name(node, source)
        val visibility = self.get_visibility(node, source)
        val marker = if opts.use_markers { "T> " } else { "" }

        var children: Array<McpItem> = []
        if val Some(variants) = self.get_enum_variants(node):
            for variant in variants.children():
                children.push(self.format_enum_variant(&variant, source, opts))

        return McpItem {
            kind: ItemKind.Enum,
            line: format!("{}{}enum {}", marker, if visibility == "pub" { "pub " } else { "" }, name),
            children: if opts.collapse_bodies { [] } else { children },
            metadata: McpMetadata {
                visibility: visibility,
                name: name,
                location: self.get_location(node)
            }
        }

    fn format_enum_variant(node: &TreeNode, source: &str, opts: &FoldOptions) -> McpItem:
        val name = self.get_variant_name(node, source)
        val marker = if opts.use_markers { "V• " } else { "  " }

        return McpItem {
            kind: ItemKind.EnumVariant,
            line: format!("{}{}", marker, name),
            children: [],
            metadata: McpMetadata {
                visibility: "public".to_string(),
                name: name,
                location: self.get_location(node)
            }
        }

    fn format_impl(node: &TreeNode, source: &str, opts: &FoldOptions) -> McpItem:
        val type_name = self.get_impl_type(node, source)
        val trait_name = self.get_impl_trait(node, source)
        val marker = if opts.use_markers { "I> " } else { "" }

        val header = if trait_name.is_empty():
            format("{}impl {}", marker, type_name)
        else:
            format("{}impl {} for {}", marker, trait_name, type_name)

        var children: Array<McpItem> = []
        for method in self.get_impl_methods(node):
            children.push(self.format_function(&method, source, opts))

        return McpItem {
            kind: ItemKind.Impl,
            line: header,
            children: if opts.collapse_bodies { [] } else { children },
            metadata: McpMetadata {
                visibility: "public".to_string(),
                name: type_name,
                location: self.get_location(node)
            }
        }

    fn format_trait(node: &TreeNode, source: &str, opts: &FoldOptions) -> McpItem:
        val name = self.get_trait_name(node, source)
        val visibility = self.get_visibility(node, source)
        val marker = if opts.use_markers { "T> " } else { "" }

        return McpItem {
            kind: ItemKind.Trait,
            line: format("{}{}trait {}", marker, if visibility == "pub" { "pub " } else { "" }, name),
            children: self.extract_trait_methods(node, source, opts)
            metadata: McpMetadata {
                visibility: visibility,
                name: name,
                location: self.get_location(node)
            }
        }

    fn format_module(node: &TreeNode, source: &str, opts: &FoldOptions) -> McpItem:
        val name = self.get_module_name(node, source)
        val visibility = self.get_visibility(node, source)
        val marker = if opts.use_markers { "M> " } else { "" }

        return McpItem {
            kind: ItemKind.Module,
            line: format("{}{}mod {}", marker, if visibility == "pub" { "pub " } else { "" }, name),
            children: [],
            metadata: McpMetadata {
                visibility: visibility,
                name: name,
                location: self.get_location(node)
            }
        }

    fn format_use(node: &TreeNode, source: &str) -> McpItem:
        val path = self.get_use_path(node, source)

        return McpItem {
            kind: ItemKind.Import,
            line: format("use {}", path),
            children: [],
            metadata: McpMetadata {
                visibility: "public".to_string(),
                name: path.clone(),
                location: self.get_location(node)
            }
        }

    # Helper methods for extracting information from tree-sitter nodes
    fn get_function_name(node: &TreeNode, source: &str) -> text:
        # Extract function name from tree-sitter node
        # Look for 'identifier' child node that follows 'fn' keyword
        for child in node.child_nodes:
            if child.kind_str == "identifier":
                return child.text_slice.clone()
        # Fallback: try to extract from source text
        val node_text = source[node.start_pos as usize..node.end_pos as usize]
        if val Some(fn_idx) = node_text.find("fn "):
            val after_fn = node_text[fn_idx + 3..]
            if val Some(paren_idx) = after_fn.find("("):
                return after_fn[..paren_idx].trim().to_string()
        return "unknown".to_string()

    fn get_function_signature(node: &TreeNode, source: &str) -> text:
        # Extract full function signature from tree-sitter node
        val node_text = source[node.start_pos as usize..node.end_pos as usize]

        # Find the signature (everything before the body '{')
        if val Some(brace_idx) = node_text.find("{"):
            return node_text[..brace_idx].trim().to_string()

        # If no brace, might be a declaration - return full text
        # But limit to first line for cleaner output
        if val Some(newline_idx) = node_text.find("\n"):
            return node_text[..newline_idx].trim().to_string()

        return node_text.trim().to_string()

    fn get_visibility(node: &TreeNode, source: &str) -> text:
        # Check for pub keyword in the node
        for child in node.child_nodes:
            if child.kind_str == "visibility_modifier":
                val vis_text = child.text_slice.trim()
                if vis_text.starts_with("pub"):
                    return "pub".to_string()
        # Also check the node text directly
        val node_text = source[node.start_pos as usize..node.end_pos as usize]
        if node_text.trim().starts_with("pub "):
            return "pub".to_string()
        return "private".to_string()

    fn get_generics(node: &TreeNode, source: &str) -> text:
        # Extract generic parameters from tree-sitter node
        for child in node.child_nodes:
            if child.kind_str == "type_parameters" or child.kind_str == "generic_parameters":
                return child.text_slice.clone()
        # Try to extract from source text
        val node_text = source[node.start_pos as usize..node.end_pos as usize]
        if val Some(lt_idx) = node_text.find("<"):
            var depth = 0
            var end_idx = lt_idx
            for (i, ch) in node_text[lt_idx..].chars().enumerate():
                if ch == '<':
                    depth += 1
                elif ch == '>':
                    depth -= 1
                    if depth == 0:
                        end_idx = lt_idx + i + 1
                        break
            if end_idx > lt_idx:
                return node_text[lt_idx..end_idx].to_string()
        return "".to_string()

    fn extract_trait_methods(node: &TreeNode, source: &str, opts: &FoldOptions) -> Array<McpItem>:
        # Extract methods from a trait definition
        var methods: Array<McpItem> = []

        for child in node.child_nodes:
            if child.kind_str == "declaration_list" or child.kind_str == "trait_body":
                for item in child.child_nodes:
                    if item.kind_str == "function_signature_item" or item.kind_str == "function_item":
                        val method_name = self.get_function_name(&item, source)
                        val signature = self.get_function_signature(&item, source)

                        methods.push(McpItem {
                            kind: ItemKind.Function,
                            line: format("  fn {}", method_name),
                            children: [],
                            metadata: McpMetadata {
                                visibility: "public".to_string(),
                                name: method_name,
                                location: self.get_location(&item)
                            }
                        })

        return methods

    fn get_struct_name(node: &TreeNode, source: &str) -> text:
        return "StructName".to_string()

    fn get_struct_fields(node: &TreeNode) -> Option<TreeNode>:
        return None

    fn get_field_name(node: &TreeNode, source: &str) -> text:
        return "field".to_string()

    fn get_field_type(node: &TreeNode, source: &str) -> text:
        return "Type".to_string()

    fn get_enum_name(node: &TreeNode, source: &str) -> text:
        return "EnumName".to_string()

    fn get_enum_variants(node: &TreeNode) -> Option<TreeNode>:
        return None

    fn get_variant_name(node: &TreeNode, source: &str) -> text:
        return "Variant".to_string()

    fn get_impl_type(node: &TreeNode, source: &str) -> text:
        return "Type".to_string()

    fn get_impl_trait(node: &TreeNode, source: &str) -> text:
        return "".to_string()

    fn get_impl_methods(node: &TreeNode) -> Array<TreeNode>:
        return []

    fn get_trait_name(node: &TreeNode, source: &str) -> text:
        return "TraitName".to_string()

    fn get_module_name(node: &TreeNode, source: &str) -> text:
        return "module_name".to_string()

    fn get_use_path(node: &TreeNode, source: &str) -> text:
        return "std.*".to_string()

    fn get_function_body_items(node: &TreeNode, source: &str, opts: &FoldOptions) -> Array<McpItem>:
        return []

    fn get_location(node: &TreeNode) -> SourceLocation:
        return SourceLocation {
            line: 0,
            column: 0,
            offset: 0
        }

    fn node_to_symbol(node: &TreeNode, source: &str) -> Option<Symbol>:
        match node.kind():
            case "function_item":
                return Some(Symbol {
                    name: self.get_function_name(node, source),
                    kind: SymbolKind.Function,
                    range: self.node_to_range(node),
                    signature: Some(self.get_function_signature(node, source)),
                    visibility: self.visibility_from_str(&self.get_visibility(node, source))
                })
            case _:
                return None

    fn node_to_range(node: &TreeNode) -> Range:
        return Range {
            start: Position { line: 0, column: 0 },
            end: Position { line: 0, column: 0 }
        }

    fn visibility_from_str(s: &str) -> Visibility:
        match s:
            case "pub": return Visibility.Public
            case _: return Visibility.Private

# Tree-sitter FFI declarations (requires tree-sitter runtime)
extern fn ts_parser_new() -> i64
extern fn ts_parser_set_language(parser: i64, lang_ptr: i64) -> bool
extern fn ts_parser_parse_string(parser: i64, old_tree: i64, source: *const u8, len: u64) -> i64
extern fn ts_tree_root_node(tree: i64) -> i64
extern fn ts_node_type(node: i64) -> *const u8
extern fn ts_node_child_count(node: i64) -> u32
extern fn ts_node_child(node: i64, index: u32) -> i64
extern fn ts_node_start_byte(node: i64) -> u32
extern fn ts_node_end_byte(node: i64) -> u32
extern fn ts_tree_delete(tree: i64)
extern fn ts_parser_delete(parser: i64)
extern fn tree_sitter_rust() -> i64

# Tree-sitter parser wrapper
