# MCP Secrets Management
# Secure storage and redaction of sensitive information
# Follows MCP specification 2025-11-25

use core.*
use std.mcp.core.error_handler.*
use std.mcp.core.logger.*

# Secret error
pub enum SecretErrorKind:
    NotFound
    AccessDenied
    StorageError
    InvalidKey
    Expired

    pub fn to_string() -> text:
        match self:
            case NotFound: "not_found"
            case AccessDenied: "access_denied"
            case StorageError: "storage_error"
            case InvalidKey: "invalid_key"
            case Expired: "expired"

pub class SecretError:
    pub kind: SecretErrorKind
    pub message: text

    static fn new(kind: SecretErrorKind, message: text) -> SecretError:
        return SecretError(kind: kind, message: message)

    pub fn to_mcp_error() -> McpError:
        return McpError.new(
            ErrorCategory.Internal,
            "Secret error ({self.kind.to_string()}): {self.message}",
            -32603
        )

# Secret metadata
pub class SecretMetadata:
    pub key: text
    pub created_at: i64
    pub updated_at: i64
    pub expires_at: Option<i64>
    pub description: text
    pub tags: List<text>

    static fn new(key: text) -> SecretMetadata:
        val now = current_time_ms()
        return SecretMetadata(
            key: key,
            created_at: now,
            updated_at: now,
            expires_at: nil,
            description: "",
            tags: []
        )

    pub fn with_expiry(self, expires_at: i64) -> SecretMetadata:
        return SecretMetadata(
            key: self.key,
            created_at: self.created_at,
            updated_at: self.updated_at,
            expires_at: Some(expires_at),
            description: self.description,
            tags: self.tags
        )

    pub fn with_description(self, desc: text) -> SecretMetadata:
        return SecretMetadata(
            key: self.key,
            created_at: self.created_at,
            updated_at: self.updated_at,
            expires_at: self.expires_at,
            description: desc,
            tags: self.tags
        )

    pub fn is_expired() -> bool:
        match self.expires_at:
            case Some(exp):
                return current_time_ms() >= exp
            case nil:
                return false

# Secret store trait
pub trait SecretStore:
    # Get a secret value
    fn get(key: text) -> Result<text, SecretError>

    # Set a secret value
    fn set(key: text, value: text) -> Result<(), SecretError>

    # Delete a secret
    fn delete(key: text) -> Result<(), SecretError>

    # Check if secret exists
    fn exists(key: text) -> bool

    # List all secret keys (not values!)
    fn list_keys() -> List<text>

    # Get secret metadata
    fn get_metadata(key: text) -> Option<SecretMetadata>

# In-memory secret store (for development/testing)
pub class InMemorySecretStore:
    pub secrets: Dict<text, text>
    pub metadata: Dict<text, SecretMetadata>
    pub debug_mode: bool

    static fn new() -> InMemorySecretStore:
        return InMemorySecretStore(
            secrets: {},
            metadata: {},
            debug_mode: false
        )

    pub me enable_debug():
        self.debug_mode = true

    fn log_debug(msg: text):
        if self.debug_mode:
            log_debug("InMemorySecretStore: {msg}")

impl SecretStore for InMemorySecretStore:
    fn get(key: text) -> Result<text, SecretError>:
        self.log_debug("Getting secret: {key}")

        # Check if expired
        match self.metadata.get(key):
            case Some(meta):
                if meta.is_expired():
                    return Err(SecretError.new(
                        SecretErrorKind.Expired,
                        "Secret has expired: {key}"
                    ))
            case nil:
                pass

        match self.secrets.get(key):
            case Some(value):
                return Ok(value)
            case nil:
                return Err(SecretError.new(
                    SecretErrorKind.NotFound,
                    "Secret not found: {key}"
                ))

    fn set(key: text, value: text) -> Result<(), SecretError>:
        self.log_debug("Setting secret: {key}")

        self.secrets.set(key, value)

        # Update or create metadata
        match self.metadata.get(key):
            case Some(meta):
                val updated = SecretMetadata(
                    key: meta.key,
                    created_at: meta.created_at,
                    updated_at: current_time_ms(),
                    expires_at: meta.expires_at,
                    description: meta.description,
                    tags: meta.tags
                )
                self.metadata.set(key, updated)
            case nil:
                self.metadata.set(key, SecretMetadata.new(key))

        return Ok(())

    fn delete(key: text) -> Result<(), SecretError>:
        self.log_debug("Deleting secret: {key}")

        if not self.secrets.has_key(key):
            return Err(SecretError.new(
                SecretErrorKind.NotFound,
                "Secret not found: {key}"
            ))

        self.secrets.remove(key)
        self.metadata.remove(key)
        return Ok(())

    fn exists(key: text) -> bool:
        return self.secrets.has_key(key)

    fn list_keys() -> List<text>:
        return self.secrets.keys()

    fn get_metadata(key: text) -> Option<SecretMetadata>:
        return self.metadata.get(key)

# Secret manager with redaction support
pub class SecretManager:
    pub store: SecretStore
    pub redaction_patterns: List<RedactionPattern>
    pub redaction_placeholder: text
    pub debug_mode: bool

    static fn new(store: SecretStore) -> SecretManager:
        return SecretManager(
            store: store,
            redaction_patterns: get_default_redaction_patterns(),
            redaction_placeholder: "[REDACTED]",
            debug_mode: false
        )

    pub me enable_debug():
        self.debug_mode = true

    fn log_debug(msg: text):
        if self.debug_mode:
            log_debug("SecretManager: {msg}")

    # Get a secret
    pub fn get(key: text) -> Result<text, SecretError>:
        return self.store.get(key)

    # Set a secret
    pub me set(key: text, value: text) -> Result<(), SecretError>:
        return self.store.set(key, value)

    # Delete a secret
    pub me delete(key: text) -> Result<(), SecretError>:
        return self.store.delete(key)

    # Redact secrets from text
    pub fn redact_secrets(text: text) -> text:
        var result = text

        # Redact stored secrets
        for key in self.store.list_keys():
            match self.store.get(key):
                case Ok(value):
                    if value.len() >= 4:  # Only redact non-trivial values
                        result = result.replace(value, self.redaction_placeholder)
                case Err(_):
                    pass

        # Apply pattern-based redaction
        for pattern in self.redaction_patterns:
            result = pattern.redact(result, self.redaction_placeholder)

        return result

    # Check if text contains any secrets
    pub fn contains_secrets(text: text) -> bool:
        # Check stored secrets
        for key in self.store.list_keys():
            match self.store.get(key):
                case Ok(value):
                    if value.len() >= 4 and text.contains(value):
                        return true
                case Err(_):
                    pass

        # Check patterns
        for pattern in self.redaction_patterns:
            if pattern.matches(text):
                return true

        return false

    # Add custom redaction pattern
    pub me add_redaction_pattern(pattern: RedactionPattern):
        self.redaction_patterns.append(pattern)

    # Set redaction placeholder
    pub me set_placeholder(placeholder: text):
        self.redaction_placeholder = placeholder

# Redaction pattern
pub class RedactionPattern:
    pub name: text
    pub prefix: text
    pub suffix: Option<text>
    pub min_length: i64
    pub max_length: i64

    static fn new(name: text, prefix: text) -> RedactionPattern:
        return RedactionPattern(
            name: name,
            prefix: prefix,
            suffix: nil,
            min_length: 8,
            max_length: 256
        )

    pub fn with_suffix(self, suffix: text) -> RedactionPattern:
        return RedactionPattern(
            name: self.name,
            prefix: self.prefix,
            suffix: Some(suffix),
            min_length: self.min_length,
            max_length: self.max_length
        )

    pub fn with_length_range(self, min_len: i64, max_len: i64) -> RedactionPattern:
        return RedactionPattern(
            name: self.name,
            prefix: self.prefix,
            suffix: self.suffix,
            min_length: min_len,
            max_length: max_len
        )

    # Check if text matches this pattern
    pub fn matches(text: text) -> bool:
        var idx = 0
        while idx < text.len():
            match text.index_of_from(self.prefix, idx):
                case Some(start):
                    # Found prefix, look for suffix or end of token
                    val after_prefix = start + self.prefix.len()

                    match self.suffix:
                        case Some(suf):
                            match text.index_of_from(suf, after_prefix):
                                case Some(end):
                                    val token_len = end - after_prefix
                                    if token_len >= self.min_length and token_len <= self.max_length:
                                        return true
                                    idx = end + suf.len()
                                case nil:
                                    idx = after_prefix
                        case nil:
                            # No suffix, check for reasonable token end
                            var end = after_prefix
                            while end < text.len():
                                val ch = text.char_at(end)
                                if not ch.is_alphanumeric() and ch != "_" and ch != "-":
                                    break
                                end = end + 1

                            val token_len = end - after_prefix
                            if token_len >= self.min_length and token_len <= self.max_length:
                                return true
                            idx = end
                case nil:
                    break
        return false

    # Redact matching patterns in text
    pub fn redact(text: text, placeholder: text) -> text:
        var result = text
        var idx = 0

        while idx < result.len():
            match result.index_of_from(self.prefix, idx):
                case Some(start):
                    val after_prefix = start + self.prefix.len()

                    match self.suffix:
                        case Some(suf):
                            match result.index_of_from(suf, after_prefix):
                                case Some(end):
                                    val token_len = end - after_prefix
                                    if token_len >= self.min_length and token_len <= self.max_length:
                                        # Redact the token (keep prefix and suffix visible)
                                        val before = result.substring(0, after_prefix)
                                        val after = result.substring(end)
                                        result = before + placeholder + after
                                        idx = after_prefix + placeholder.len() + suf.len()
                                    else:
                                        idx = end + suf.len()
                                case nil:
                                    idx = after_prefix
                        case nil:
                            # No suffix, find token end
                            var end = after_prefix
                            while end < result.len():
                                val ch = result.char_at(end)
                                if not ch.is_alphanumeric() and ch != "_" and ch != "-":
                                    break
                                end = end + 1

                            val token_len = end - after_prefix
                            if token_len >= self.min_length and token_len <= self.max_length:
                                val before = result.substring(0, after_prefix)
                                val after = result.substring(end)
                                result = before + placeholder + after
                                idx = after_prefix + placeholder.len()
                            else:
                                idx = end
                case nil:
                    break

        return result

# Default redaction patterns for common secrets
fn get_default_redaction_patterns() -> List<RedactionPattern>:
    return [
        # API Keys
        RedactionPattern.new("api_key", "api_key=").with_length_range(16, 128),
        RedactionPattern.new("api_key_header", "X-API-Key: ").with_length_range(16, 128),
        RedactionPattern.new("apikey", "apikey=").with_length_range(16, 128),

        # Bearer tokens
        RedactionPattern.new("bearer", "Bearer ").with_length_range(20, 2048),
        RedactionPattern.new("authorization", "Authorization: ").with_length_range(10, 2048),

        # AWS
        RedactionPattern.new("aws_access_key", "AKIA").with_length_range(16, 20),
        RedactionPattern.new("aws_secret_key", "aws_secret_access_key=").with_length_range(32, 64),

        # GitHub
        RedactionPattern.new("github_token", "ghp_").with_length_range(36, 40),
        RedactionPattern.new("github_oauth", "gho_").with_length_range(36, 40),
        RedactionPattern.new("github_pat", "github_pat_").with_length_range(40, 100),

        # Slack
        RedactionPattern.new("slack_token", "xoxb-").with_length_range(40, 80),
        RedactionPattern.new("slack_user_token", "xoxp-").with_length_range(40, 80),

        # Database URLs
        RedactionPattern.new("postgres_url", "postgres://").with_suffix("@").with_length_range(1, 256),
        RedactionPattern.new("mysql_url", "mysql://").with_suffix("@").with_length_range(1, 256),
        RedactionPattern.new("mongodb_url", "mongodb+srv://").with_suffix("@").with_length_range(1, 256),

        # SSH private keys
        RedactionPattern.new("ssh_private_key", "-----BEGIN").with_suffix("-----END").with_length_range(100, 10000),

        # Passwords in URLs
        RedactionPattern.new("password_in_url", "password=").with_length_range(1, 256),
        RedactionPattern.new("passwd", "passwd=").with_length_range(1, 256),
        RedactionPattern.new("secret", "secret=").with_length_range(1, 256),

        # Generic tokens
        RedactionPattern.new("token", "token=").with_length_range(16, 512),
        RedactionPattern.new("access_token", "access_token=").with_length_range(16, 2048),
        RedactionPattern.new("refresh_token", "refresh_token=").with_length_range(16, 2048)
    ]

# Environment-based secret store
pub class EnvSecretStore:
    pub prefix: text
    pub cache: Dict<text, text>
    pub debug_mode: bool

    static fn new(prefix: text) -> EnvSecretStore:
        return EnvSecretStore(
            prefix: prefix,
            cache: {},
            debug_mode: false
        )

    pub me enable_debug():
        self.debug_mode = true

    fn log_debug(msg: text):
        if self.debug_mode:
            log_debug("EnvSecretStore: {msg}")

    fn env_key(key: text) -> text:
        return self.prefix + key.to_uppercase().replace("-", "_")

impl SecretStore for EnvSecretStore:
    fn get(key: text) -> Result<text, SecretError>:
        val env_key = self.env_key(key)
        self.log_debug("Getting env var: {env_key}")

        # Check cache first
        match self.cache.get(key):
            case Some(value):
                return Ok(value)
            case nil:
                pass

        # Read from environment
        match env_get(env_key):
            case Some(value):
                self.cache.set(key, value)
                return Ok(value)
            case nil:
                return Err(SecretError.new(
                    SecretErrorKind.NotFound,
                    "Environment variable not set: {env_key}"
                ))

    fn set(key: text, value: text) -> Result<(), SecretError>:
        # Environment variables can't be set at runtime in most cases
        # Just update cache
        self.cache.set(key, value)
        return Ok(())

    fn delete(key: text) -> Result<(), SecretError>:
        self.cache.remove(key)
        return Ok(())

    fn exists(key: text) -> bool:
        val env_key = self.env_key(key)
        match env_get(env_key):
            case Some(_): true
            case nil: false

    fn list_keys() -> List<text>:
        return self.cache.keys()

    fn get_metadata(key: text) -> Option<SecretMetadata>:
        if self.exists(key):
            return Some(SecretMetadata.new(key))
        return nil

# Helper functions
fn current_time_ms() -> i64:
    return time_now_ms()

extern fn time_now_ms() -> i64
extern fn env_get(key: text) -> Option<text>
