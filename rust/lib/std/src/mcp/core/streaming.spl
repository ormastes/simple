# MCP Streaming Support
# Enhanced streaming for large responses and binary data
# Follows MCP specification 2025-11-25

use core.*
use std.mcp.core.protocol.*
use std.mcp.core.transport.*
use std.mcp.core.logger.*
use std.mcp.core.error_handler.*

# Stream state
pub enum StreamState:
    Idle
    Streaming
    Paused
    Completed
    Error

    pub fn to_string() -> text:
        match self:
            case Idle: "idle"
            case Streaming: "streaming"
            case Paused: "paused"
            case Completed: "completed"
            case Error: "error"

# Stream chunk
pub class StreamChunk:
    pub sequence: i64
    pub data: text
    pub is_final: bool
    pub metadata: Dict<text, Any>

    static fn new(sequence: i64, data: text) -> StreamChunk:
        return StreamChunk(
            sequence: sequence,
            data: data,
            is_final: false,
            metadata: {}
        )

    pub fn as_final(self) -> StreamChunk:
        return StreamChunk(
            sequence: self.sequence,
            data: self.data,
            is_final: true,
            metadata: self.metadata
        )

    pub fn with_metadata(self, key: text, value: Any) -> StreamChunk:
        var new_meta = self.metadata.clone()
        new_meta.set(key, value)
        return StreamChunk(
            sequence: self.sequence,
            data: self.data,
            is_final: self.is_final,
            metadata: new_meta
        )

    pub fn to_dict() -> Dict<text, Any>:
        var result: Dict<text, Any> = {
            "sequence": self.sequence,
            "data": self.data,
            "isFinal": self.is_final
        }

        if self.metadata.len() > 0:
            result.set("metadata", self.metadata)

        return result

# Stream configuration
pub class StreamConfig:
    pub chunk_size: i64
    pub buffer_size: i64
    pub timeout_ms: i64
    pub enable_compression: bool
    pub enable_checksum: bool

    static fn default() -> StreamConfig:
        return StreamConfig(
            chunk_size: 64 * 1024,      # 64KB chunks
            buffer_size: 1024 * 1024,   # 1MB buffer
            timeout_ms: 30000,          # 30 second timeout
            enable_compression: false,
            enable_checksum: true
        )

    static fn small_chunks() -> StreamConfig:
        return StreamConfig(
            chunk_size: 8 * 1024,       # 8KB chunks
            buffer_size: 256 * 1024,    # 256KB buffer
            timeout_ms: 30000,
            enable_compression: false,
            enable_checksum: true
        )

    static fn large_chunks() -> StreamConfig:
        return StreamConfig(
            chunk_size: 256 * 1024,     # 256KB chunks
            buffer_size: 4 * 1024 * 1024,  # 4MB buffer
            timeout_ms: 60000,
            enable_compression: true,
            enable_checksum: true
        )

# Stream writer
pub class StreamWriter:
    pub stream_id: text
    pub config: StreamConfig
    pub state: StreamState
    pub sequence: i64
    pub bytes_written: i64
    pub chunks_sent: i64
    pub started_at: i64
    pub transport: Option<Transport>
    pub on_chunk_sent: Option<fn(StreamChunk)>
    pub debug_mode: bool

    static fn new(stream_id: text, config: StreamConfig) -> StreamWriter:
        return StreamWriter(
            stream_id: stream_id,
            config: config,
            state: StreamState.Idle,
            sequence: 0,
            bytes_written: 0,
            chunks_sent: 0,
            started_at: 0,
            transport: nil,
            on_chunk_sent: nil,
            debug_mode: false
        )

    pub me enable_debug():
        self.debug_mode = true

    fn log_debug(msg: text):
        if self.debug_mode:
            log_debug("StreamWriter[{self.stream_id}]: {msg}")

    pub me set_transport(transport: Transport):
        self.transport = Some(transport)

    pub me set_on_chunk_sent(callback: fn(StreamChunk)):
        self.on_chunk_sent = Some(callback)

    # Start streaming
    pub me start() -> Result<(), McpError>:
        if self.state != StreamState.Idle:
            return Err(McpError.new(
                ErrorCategory.Validation,
                "Stream already started",
                -32602
            ))

        self.state = StreamState.Streaming
        self.started_at = current_time_ms()
        self.log_debug("Stream started")
        return Ok(())

    # Write data to stream
    pub me write(data: text) -> Result<i64, McpError>:
        if self.state != StreamState.Streaming:
            return Err(McpError.new(
                ErrorCategory.Validation,
                "Stream not in streaming state",
                -32602
            ))

        # Split data into chunks
        var offset: i64 = 0
        var chunks_written: i64 = 0

        while offset < data.len():
            val chunk_end = if offset + self.config.chunk_size > data.len():
                data.len()
            else:
                offset + self.config.chunk_size

            val chunk_data = data.substring(offset, chunk_end)
            match self.write_chunk(chunk_data, false):
                case Ok(_):
                    chunks_written = chunks_written + 1
                case Err(e):
                    return Err(e)

            offset = chunk_end

        return Ok(chunks_written)

    # Write a single chunk
    fn write_chunk(data: text, is_final: bool) -> Result<(), McpError>:
        var chunk = StreamChunk.new(self.sequence, data)

        if is_final:
            chunk = chunk.as_final()

        if self.config.enable_checksum:
            val checksum = calculate_checksum(data)
            chunk = chunk.with_metadata("checksum", checksum)

        # Send chunk via transport
        match self.transport:
            case Some(t):
                self.send_chunk(t, chunk)
            case nil:
                pass

        # Update state
        self.sequence = self.sequence + 1
        self.bytes_written = self.bytes_written + data.len()
        self.chunks_sent = self.chunks_sent + 1

        # Notify callback
        match self.on_chunk_sent:
            case Some(callback):
                callback(chunk)
            case nil:
                pass

        self.log_debug("Sent chunk {self.sequence - 1}, {data.len()} bytes")
        return Ok(())

    fn send_chunk(transport: Transport, chunk: StreamChunk):
        # Would serialize and send via transport
        pass

    # Finish streaming
    pub me finish() -> Result<(), McpError>:
        if self.state != StreamState.Streaming:
            return Err(McpError.new(
                ErrorCategory.Validation,
                "Stream not in streaming state",
                -32602
            ))

        # Send final empty chunk
        match self.write_chunk("", true):
            case Ok(_):
                pass
            case Err(e):
                return Err(e)

        self.state = StreamState.Completed
        self.log_debug("Stream completed: {self.bytes_written} bytes in {self.chunks_sent} chunks")
        return Ok(())

    # Cancel streaming
    pub me cancel():
        self.state = StreamState.Error
        self.log_debug("Stream cancelled")

    # Pause streaming
    pub me pause():
        if self.state == StreamState.Streaming:
            self.state = StreamState.Paused
            self.log_debug("Stream paused")

    # Resume streaming
    pub me resume():
        if self.state == StreamState.Paused:
            self.state = StreamState.Streaming
            self.log_debug("Stream resumed")

    # Get statistics
    pub fn stats() -> StreamStats:
        val elapsed = current_time_ms() - self.started_at
        val throughput = if elapsed > 0:
            (self.bytes_written as f64 / elapsed as f64) * 1000.0
        else:
            0.0

        return StreamStats(
            stream_id: self.stream_id,
            bytes_written: self.bytes_written,
            chunks_sent: self.chunks_sent,
            elapsed_ms: elapsed,
            throughput_bps: throughput,
            state: self.state
        )

# Stream reader
pub class StreamReader:
    pub stream_id: text
    pub config: StreamConfig
    pub state: StreamState
    pub buffer: text
    pub expected_sequence: i64
    pub bytes_read: i64
    pub chunks_received: i64
    pub started_at: i64
    pub last_chunk_at: i64
    pub on_chunk_received: Option<fn(StreamChunk)>
    pub on_complete: Option<fn(text)>
    pub debug_mode: bool

    static fn new(stream_id: text, config: StreamConfig) -> StreamReader:
        return StreamReader(
            stream_id: stream_id,
            config: config,
            state: StreamState.Idle,
            buffer: "",
            expected_sequence: 0,
            bytes_read: 0,
            chunks_received: 0,
            started_at: 0,
            last_chunk_at: 0,
            on_chunk_received: nil,
            on_complete: nil,
            debug_mode: false
        )

    pub me enable_debug():
        self.debug_mode = true

    fn log_debug(msg: text):
        if self.debug_mode:
            log_debug("StreamReader[{self.stream_id}]: {msg}")

    pub me set_on_chunk_received(callback: fn(StreamChunk)):
        self.on_chunk_received = Some(callback)

    pub me set_on_complete(callback: fn(text)):
        self.on_complete = Some(callback)

    # Start reading
    pub me start():
        self.state = StreamState.Streaming
        self.started_at = current_time_ms()
        self.log_debug("Started reading")

    # Receive a chunk
    pub me receive_chunk(chunk: StreamChunk) -> Result<(), McpError>:
        if self.state != StreamState.Streaming:
            return Err(McpError.new(
                ErrorCategory.Validation,
                "Stream not ready to receive",
                -32602
            ))

        # Verify sequence
        if chunk.sequence != self.expected_sequence:
            return Err(McpError.new(
                ErrorCategory.Protocol,
                "Unexpected chunk sequence: expected {self.expected_sequence}, got {chunk.sequence}",
                -32600
            ))

        # Verify checksum if enabled
        if self.config.enable_checksum:
            match chunk.metadata.get("checksum"):
                case Some(expected_checksum):
                    val actual_checksum = calculate_checksum(chunk.data)
                    if actual_checksum != expected_checksum:
                        return Err(McpError.new(
                            ErrorCategory.Protocol,
                            "Checksum mismatch",
                            -32600
                        ))
                case nil:
                    pass

        # Append to buffer
        self.buffer = self.buffer + chunk.data
        self.expected_sequence = self.expected_sequence + 1
        self.bytes_read = self.bytes_read + chunk.data.len()
        self.chunks_received = self.chunks_received + 1
        self.last_chunk_at = current_time_ms()

        self.log_debug("Received chunk {chunk.sequence}, {chunk.data.len()} bytes")

        # Notify callback
        match self.on_chunk_received:
            case Some(callback):
                callback(chunk)
            case nil:
                pass

        # Check if final
        if chunk.is_final:
            self.state = StreamState.Completed
            self.log_debug("Stream complete: {self.bytes_read} bytes")

            match self.on_complete:
                case Some(callback):
                    callback(self.buffer)
                case nil:
                    pass

        return Ok(())

    # Check for timeout
    pub fn is_timed_out() -> bool:
        if self.state != StreamState.Streaming:
            return false

        val elapsed = current_time_ms() - self.last_chunk_at
        return elapsed > self.config.timeout_ms

    # Get accumulated data
    pub fn get_data() -> text:
        return self.buffer

    # Get statistics
    pub fn stats() -> StreamStats:
        val elapsed = current_time_ms() - self.started_at
        val throughput = if elapsed > 0:
            (self.bytes_read as f64 / elapsed as f64) * 1000.0
        else:
            0.0

        return StreamStats(
            stream_id: self.stream_id,
            bytes_written: self.bytes_read,
            chunks_sent: self.chunks_received,
            elapsed_ms: elapsed,
            throughput_bps: throughput,
            state: self.state
        )

# Stream statistics
pub class StreamStats:
    pub stream_id: text
    pub bytes_written: i64
    pub chunks_sent: i64
    pub elapsed_ms: i64
    pub throughput_bps: f64
    pub state: StreamState

    pub fn to_dict() -> Dict<text, Any>:
        return {
            "streamId": self.stream_id,
            "bytesWritten": self.bytes_written,
            "chunksSent": self.chunks_sent,
            "elapsedMs": self.elapsed_ms,
            "throughputBps": self.throughput_bps,
            "state": self.state.to_string()
        }

# Stream manager
pub class StreamManager:
    pub writers: Dict<text, StreamWriter>
    pub readers: Dict<text, StreamReader>
    pub config: StreamConfig
    pub next_stream_id: i64
    pub debug_mode: bool

    static fn new(config: StreamConfig) -> StreamManager:
        return StreamManager(
            writers: {},
            readers: {},
            config: config,
            next_stream_id: 1,
            debug_mode: false
        )

    pub me enable_debug():
        self.debug_mode = true

    fn log_debug(msg: text):
        if self.debug_mode:
            log_debug("StreamManager: {msg}")

    fn generate_stream_id() -> text:
        val id = self.next_stream_id
        self.next_stream_id = self.next_stream_id + 1
        return "stream_{id}_{current_time_ms()}"

    # Create a new stream writer
    pub me create_writer() -> StreamWriter:
        val stream_id = self.generate_stream_id()
        val writer = StreamWriter.new(stream_id, self.config)
        self.writers.set(stream_id, writer)
        self.log_debug("Created writer: {stream_id}")
        return writer

    # Create a new stream reader
    pub me create_reader(stream_id: text) -> StreamReader:
        val reader = StreamReader.new(stream_id, self.config)
        self.readers.set(stream_id, reader)
        self.log_debug("Created reader: {stream_id}")
        return reader

    # Get writer by ID
    pub fn get_writer(stream_id: text) -> Option<StreamWriter>:
        return self.writers.get(stream_id)

    # Get reader by ID
    pub fn get_reader(stream_id: text) -> Option<StreamReader>:
        return self.readers.get(stream_id)

    # Remove writer
    pub me remove_writer(stream_id: text):
        self.writers.remove(stream_id)
        self.log_debug("Removed writer: {stream_id}")

    # Remove reader
    pub me remove_reader(stream_id: text):
        self.readers.remove(stream_id)
        self.log_debug("Removed reader: {stream_id}")

    # Cleanup completed streams
    pub me cleanup():
        var to_remove_writers: List<text> = []
        var to_remove_readers: List<text> = []

        for id in self.writers.keys():
            match self.writers.get(id):
                case Some(writer):
                    if writer.state == StreamState.Completed or writer.state == StreamState.Error:
                        to_remove_writers.append(id)
                case nil:
                    pass

        for id in self.readers.keys():
            match self.readers.get(id):
                case Some(reader):
                    if reader.state == StreamState.Completed or reader.state == StreamState.Error:
                        to_remove_readers.append(id)
                case nil:
                    pass

        for id in to_remove_writers:
            self.writers.remove(id)

        for id in to_remove_readers:
            self.readers.remove(id)

        self.log_debug("Cleaned up {to_remove_writers.len()} writers, {to_remove_readers.len()} readers")

    # Check for timed out streams
    pub me check_timeouts():
        for id in self.readers.keys():
            match self.readers.get(id):
                case Some(reader):
                    if reader.is_timed_out():
                        self.log_debug("Stream timed out: {id}")
                        reader.state = StreamState.Error
                case nil:
                    pass

    # Get all stream statistics
    pub fn get_all_stats() -> List<StreamStats>:
        var result: List<StreamStats> = []

        for id in self.writers.keys():
            match self.writers.get(id):
                case Some(writer):
                    result.append(writer.stats())
                case nil:
                    pass

        for id in self.readers.keys():
            match self.readers.get(id):
                case Some(reader):
                    result.append(reader.stats())
                case nil:
                    pass

        return result

# Binary stream support
pub class BinaryStreamWriter:
    pub writer: StreamWriter
    pub encoder: BinaryEncoder

    static fn new(stream_id: text, config: StreamConfig) -> BinaryStreamWriter:
        return BinaryStreamWriter(
            writer: StreamWriter.new(stream_id, config),
            encoder: BinaryEncoder.new()
        )

    pub me write_bytes(data: List<u8>) -> Result<i64, McpError>:
        val encoded = self.encoder.encode(data)
        return self.writer.write(encoded)

    pub me start() -> Result<(), McpError>:
        return self.writer.start()

    pub me finish() -> Result<(), McpError>:
        return self.writer.finish()

# Binary encoder (base64)
pub class BinaryEncoder:
    static fn new() -> BinaryEncoder:
        return BinaryEncoder()

    pub fn encode(data: List<u8>) -> text:
        # Simple base64 encoding
        val chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
        var result = ""
        var i: i64 = 0

        while i < data.len():
            val b0 = data[i]
            val b1 = if i + 1 < data.len(): data[i + 1] else: 0
            val b2 = if i + 2 < data.len(): data[i + 2] else: 0

            val c0 = (b0 >> 2) & 0x3F
            val c1 = ((b0 << 4) | (b1 >> 4)) & 0x3F
            val c2 = ((b1 << 2) | (b2 >> 6)) & 0x3F
            val c3 = b2 & 0x3F

            result = result + chars.char_at(c0)
            result = result + chars.char_at(c1)
            result = result + if i + 1 < data.len(): chars.char_at(c2) else: "="
            result = result + if i + 2 < data.len(): chars.char_at(c3) else: "="

            i = i + 3

        return result

    pub fn decode(encoded: text) -> List<u8>:
        val chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
        var result: List<u8> = []
        var i: i64 = 0

        while i < encoded.len():
            val c0 = chars.index_of(encoded.char_at(i)).unwrap_or(0)
            val c1 = chars.index_of(encoded.char_at(i + 1)).unwrap_or(0)
            val c2 = if encoded.char_at(i + 2) != "=": chars.index_of(encoded.char_at(i + 2)).unwrap_or(0) else: 0
            val c3 = if encoded.char_at(i + 3) != "=": chars.index_of(encoded.char_at(i + 3)).unwrap_or(0) else: 0

            result.append(((c0 << 2) | (c1 >> 4)) as u8)

            if encoded.char_at(i + 2) != "=":
                result.append(((c1 << 4) | (c2 >> 2)) as u8)

            if encoded.char_at(i + 3) != "=":
                result.append(((c2 << 6) | c3) as u8)

            i = i + 4

        return result

# Helper functions
fn calculate_checksum(data: text) -> text:
    # Simple checksum (would use CRC32 or similar in production)
    var sum: i64 = 0
    for ch in data:
        sum = (sum + ch.ord()) % 0xFFFFFFFF
    return sum.to_hex()

fn current_time_ms() -> i64:
    return time_now_ms()

extern fn time_now_ms() -> i64
