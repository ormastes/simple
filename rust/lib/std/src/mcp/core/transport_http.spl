# MCP HTTP/SSE Transport Layer
# Implements HTTP and Server-Sent Events (SSE) transport for MCP
# Follows MCP specification 2025-11-25

use core.*
use core.json.*
use std.mcp.core.protocol.*
use std.mcp.core.transport.*
use std.mcp.core.logger.*
use std.mcp.core.error_handler.*

# SSE Event structure
pub class SseEvent:
    pub event_type: text       # Event type (e.g., "message", "endpoint")
    pub data: text             # Event data (JSON payload)
    pub id: Option<text>       # Optional event ID
    pub retry: Option<i64>     # Optional retry time in ms

    static fn new(event_type: text, data: text) -> SseEvent:
        return SseEvent(
            event_type: event_type,
            data: data,
            id: nil,
            retry: nil
        )

    static fn message(data: text) -> SseEvent:
        return SseEvent.new("message", data)

    pub fn with_id(self, id: text) -> SseEvent:
        return SseEvent(
            event_type: self.event_type,
            data: self.data,
            id: Some(id),
            retry: self.retry
        )

    pub fn with_retry(self, retry_ms: i64) -> SseEvent:
        return SseEvent(
            event_type: self.event_type,
            data: self.data,
            id: self.id,
            retry: Some(retry_ms)
        )

    # Format as SSE wire format
    pub fn to_wire_format() -> text:
        var result = ""

        match self.id:
            case Some(id):
                result = result + "id: {id}\n"
            case nil:
                pass

        match self.retry:
            case Some(retry_ms):
                result = result + "retry: {retry_ms}\n"
            case nil:
                pass

        if self.event_type != "message":
            result = result + "event: {self.event_type}\n"

        # Data may contain multiple lines, each needs "data: " prefix
        val lines = self.data.split("\n")
        for line in lines:
            result = result + "data: {line}\n"

        # SSE events end with double newline
        result = result + "\n"
        return result

# SSE Connection state
pub enum SseConnectionState:
    Disconnected
    Connecting
    Connected
    Reconnecting

    pub fn to_string() -> text:
        match self:
            case Disconnected: "disconnected"
            case Connecting: "connecting"
            case Connected: "connected"
            case Reconnecting: "reconnecting"

# HTTP request for MCP
pub class HttpRequest:
    pub method: text           # "GET", "POST"
    pub path: text             # Request path
    pub headers: Dict<text, text>
    pub body: Option<text>

    static fn get(path: text) -> HttpRequest:
        return HttpRequest(
            method: "GET",
            path: path,
            headers: {},
            body: nil
        )

    static fn post(path: text, body: text) -> HttpRequest:
        return HttpRequest(
            method: "POST",
            path: path,
            headers: {},
            body: Some(body)
        )

    pub fn with_header(self, key: text, value: text) -> HttpRequest:
        var new_headers = self.headers.clone()
        new_headers.set(key, value)
        return HttpRequest(
            method: self.method,
            path: self.path,
            headers: new_headers,
            body: self.body
        )

# HTTP response
pub class HttpResponse:
    pub status_code: i64
    pub status_text: text
    pub headers: Dict<text, text>
    pub body: text

    static fn ok(body: text) -> HttpResponse:
        return HttpResponse(
            status_code: 200,
            status_text: "OK",
            headers: {},
            body: body
        )

    static fn error(code: i64, message: text) -> HttpResponse:
        return HttpResponse(
            status_code: code,
            status_text: message,
            headers: {},
            body: message
        )

    pub fn is_success() -> bool:
        return self.status_code >= 200 and self.status_code < 300

    pub fn is_sse() -> bool:
        match self.headers.get("content-type"):
            case Some(content_type):
                return content_type.contains("text/event-stream")
            case nil:
                return false

# HTTP transport configuration
pub class HttpTransportConfig:
    pub base_url: text
    pub sse_endpoint: text     # SSE endpoint path (e.g., "/sse")
    pub message_endpoint: text # Message endpoint path (e.g., "/message")
    pub timeout_ms: i64
    pub max_reconnect_attempts: i64
    pub reconnect_delay_ms: i64

    static fn default(base_url: text) -> HttpTransportConfig:
        return HttpTransportConfig(
            base_url: base_url,
            sse_endpoint: "/sse",
            message_endpoint: "/message",
            timeout_ms: 30000,
            max_reconnect_attempts: 5,
            reconnect_delay_ms: 1000
        )

# HTTP/SSE transport for MCP
# Supports both client and server modes
pub class HttpTransport:
    pub config: HttpTransportConfig
    pub state: SseConnectionState
    pub session_id: Option<text>
    pub last_event_id: Option<text>
    pub pending_requests: List<JsonRpcRequest>
    pub pending_responses: List<JsonRpcResponse>
    pub error_count: i64
    pub debug_mode: bool
    pub validator: InputValidator

    static fn new(config: HttpTransportConfig) -> HttpTransport:
        return HttpTransport(
            config: config,
            state: SseConnectionState.Disconnected,
            session_id: nil,
            last_event_id: nil,
            pending_requests: [],
            pending_responses: [],
            error_count: 0,
            debug_mode: false,
            validator: InputValidator.default()
        )

    static fn with_url(base_url: text) -> HttpTransport:
        return HttpTransport.new(HttpTransportConfig.default(base_url))

    pub me enable_debug():
        self.debug_mode = true

    fn log_debug(msg: text):
        log_debug("HttpTransport: {msg}")
        if self.debug_mode:
            stderr_write("[MCP-HTTP] {msg}\n")
            stderr_flush()

    me log_error(msg: text):
        log_error("HttpTransport: {msg}")
        self.error_count = self.error_count + 1

    # Connect to SSE endpoint
    pub me connect() -> Result<(), text>:
        self.state = SseConnectionState.Connecting
        self.log_debug("Connecting to SSE endpoint: {self.config.base_url}{self.config.sse_endpoint}")

        # Build SSE connection request
        var request = HttpRequest.get(self.config.sse_endpoint)
        request = request.with_header("Accept", "text/event-stream")
        request = request.with_header("Cache-Control", "no-cache")

        # Add last event ID for reconnection
        match self.last_event_id:
            case Some(id):
                request = request.with_header("Last-Event-ID", id)
            case nil:
                pass

        # Make HTTP request (would use actual HTTP client in real impl)
        match self.http_request(request):
            case Ok(response):
                if response.is_sse():
                    self.state = SseConnectionState.Connected
                    self.log_debug("Connected to SSE endpoint")
                    return Ok(())
                else:
                    self.state = SseConnectionState.Disconnected
                    return Err("Server did not return SSE content type")
            case Err(e):
                self.state = SseConnectionState.Disconnected
                self.log_error("Failed to connect: {e}")
                return Err(e)

    # Disconnect from SSE endpoint
    pub me disconnect():
        self.state = SseConnectionState.Disconnected
        self.session_id = nil
        self.log_debug("Disconnected from SSE endpoint")

    # Handle incoming SSE event
    pub me handle_sse_event(event: SseEvent) -> Option<JsonRpcRequest>:
        self.log_debug("Received SSE event: type={event.event_type}")

        # Update last event ID
        match event.id:
            case Some(id):
                self.last_event_id = Some(id)
            case nil:
                pass

        # Parse event based on type
        if event.event_type == "endpoint":
            # Server sent message endpoint URL
            self.log_debug("Received endpoint URL: {event.data}")
            return nil
        elif event.event_type == "message":
            # Parse JSON-RPC request from data
            match self.parse_request(event.data):
                case Ok(request):
                    return Some(request)
                case Err(e):
                    self.log_error("Failed to parse SSE message: {e}")
                    return nil
        else:
            # Unknown event type
            self.log_debug("Unknown event type: {event.event_type}")
            return nil

    # Parse SSE event from wire format
    pub fn parse_sse_event(data: text) -> Option<SseEvent>:
        var event_type = "message"
        var event_data = ""
        var event_id: Option<text> = nil
        var retry: Option<i64> = nil

        val lines = data.split("\n")
        for line in lines:
            if line.starts_with("event:"):
                event_type = line.substring(6).trim()
            elif line.starts_with("data:"):
                val data_line = line.substring(5)
                if event_data != "":
                    event_data = event_data + "\n"
                event_data = event_data + data_line
            elif line.starts_with("id:"):
                event_id = Some(line.substring(3).trim())
            elif line.starts_with("retry:"):
                val retry_str = line.substring(6).trim()
                # Parse retry value
                var retry_val: i64 = 0
                for ch in retry_str:
                    if ch >= "0" and ch <= "9":
                        val digit = ch.ord() - "0".ord()
                        retry_val = retry_val * 10 + digit
                    else:
                        break
                retry = Some(retry_val)

        if event_data == "":
            return nil

        return Some(SseEvent(
            event_type: event_type,
            data: event_data,
            id: event_id,
            retry: retry
        ))

    # Send JSON-RPC request via HTTP POST
    pub me send_request(request: JsonRpcRequest) -> Result<JsonRpcResponse, text>:
        # Serialize request to JSON
        val json_body = self.serialize_request(request)

        # Build HTTP request
        var http_request = HttpRequest.post(self.config.message_endpoint, json_body)
        http_request = http_request.with_header("Content-Type", "application/json")

        # Add session ID if available
        match self.session_id:
            case Some(id):
                http_request = http_request.with_header("X-Session-ID", id)
            case nil:
                pass

        # Send request
        match self.http_request(http_request):
            case Ok(response):
                if response.is_success():
                    # Parse response
                    match self.parse_response(response.body):
                        case Ok(rpc_response):
                            return Ok(rpc_response)
                        case Err(e):
                            return Err("Failed to parse response: {e}")
                else:
                    return Err("HTTP error {response.status_code}: {response.status_text}")
            case Err(e):
                return Err("HTTP request failed: {e}")

    # Parse JSON into JsonRpcRequest
    fn parse_request(json_str: text) -> Result<JsonRpcRequest, text>:
        # Validate JSON string length
        match self.validator.validate_string(json_str, "request_body"):
            case Ok(_):
                pass
            case Err(error):
                self.log_error("Request validation failed: {error.message}")
                return Err(error.message)

        match json.parse(json_str):
            case Ok(JsonValue.Object(obj)):
                var id: i64 = 0
                var method = ""
                var params: Dict<text, Any> = {}

                match obj.get("id"):
                    case Some(JsonValue.Integer(i)):
                        id = i
                    case _:
                        pass

                match obj.get("method"):
                    case Some(JsonValue.text(m)):
                        method = m
                    case _:
                        return Err("method must be string")

                match obj.get("params"):
                    case Some(JsonValue.Object(p)):
                        params = json_object_to_dict(p)
                    case _:
                        pass

                return Ok(JsonRpcRequest.new(id, method, params))

            case Ok(_):
                return Err("request must be object")
            case Err(e):
                return Err("JSON parse error: {e}")

    # Parse JSON-RPC response
    fn parse_response(json_str: text) -> Result<JsonRpcResponse, text>:
        match json.parse(json_str):
            case Ok(JsonValue.Object(obj)):
                var id: i64 = 0
                var result: Any = {}

                match obj.get("id"):
                    case Some(JsonValue.Integer(i)):
                        id = i
                    case _:
                        pass

                match obj.get("result"):
                    case Some(value):
                        result = json_value_to_any(value)
                    case nil:
                        pass

                return Ok(JsonRpcResponse.new(id, result))

            case Ok(_):
                return Err("response must be object")
            case Err(e):
                return Err("JSON parse error: {e}")

    # Serialize request to JSON
    fn serialize_request(request: JsonRpcRequest) -> text:
        var builder = JsonBuilder.new()
        builder.set_string("jsonrpc", "2.0")
        builder.set_int("id", request.id)
        builder.set_string("method", request.method)

        # Serialize params
        val params_json = dict_to_json_value(request.params)
        builder.set("params", params_json)

        return json.stringify(builder.build())

    # Serialize response to JSON
    fn serialize_response(response: JsonRpcResponse) -> text:
        var builder = JsonBuilder.new()
        builder.set_string("jsonrpc", "2.0")
        builder.set_int("id", response.id)
        val result_json = any_to_json(response.result)
        builder.set("result", result_json)
        return json.stringify(builder.build())

    # HTTP request implementation (stub - would use actual HTTP client)
    fn http_request(request: HttpRequest) -> Result<HttpResponse, text>:
        # This would use actual HTTP client in real implementation
        # For now, return error indicating not implemented
        self.log_debug("HTTP {request.method} {request.path}")
        return Err("HTTP client not implemented - use network transport")

    # Queue a request for later processing
    me queue_request(request: JsonRpcRequest):
        self.pending_requests.append(request)

    # Get next pending request
    me next_pending_request() -> Option<JsonRpcRequest>:
        if self.pending_requests.len() > 0:
            val request = self.pending_requests[0]
            self.pending_requests = self.pending_requests.slice(1)
            return Some(request)
        return nil

impl Transport for HttpTransport:
    me read_message() -> Option<JsonRpcRequest>:
        # Check pending requests first
        match self.next_pending_request():
            case Some(request):
                return Some(request)
            case nil:
                pass

        # Would read from SSE stream in real implementation
        # For now, return nil to indicate no message
        return nil

    me write_response(response: JsonRpcResponse):
        # In HTTP/SSE mode, responses are sent via HTTP POST
        # Queue for later sending
        self.pending_responses.append(response)
        self.log_debug("Response queued: id={response.id}")

    me write_error(id: i64, code: i64, message: text):
        self.log_debug("Error queued: id={id}, code={code}, message={message}")

    fn is_alive() -> bool:
        return self.state == SseConnectionState.Connected or
               self.state == SseConnectionState.Connecting or
               self.state == SseConnectionState.Reconnecting

# HTTP server handler for MCP
# Handles incoming HTTP requests and dispatches to MCP server
pub class HttpServerHandler:
    pub sse_clients: List<SseClient>
    pub next_client_id: i64
    pub debug_mode: bool

    static fn new() -> HttpServerHandler:
        return HttpServerHandler(
            sse_clients: [],
            next_client_id: 1,
            debug_mode: false
        )

    pub me enable_debug():
        self.debug_mode = true

    fn log_debug(msg: text):
        if self.debug_mode:
            stderr_write("[MCP-HTTP-Server] {msg}\n")
            stderr_flush()

    # Handle incoming HTTP request
    pub me handle_request(request: HttpRequest) -> HttpResponse:
        self.log_debug("Handling {request.method} {request.path}")

        if request.path == "/sse" and request.method == "GET":
            return self.handle_sse_connect(request)
        elif request.path == "/message" and request.method == "POST":
            return self.handle_message(request)
        else:
            return HttpResponse.error(404, "Not Found")

    # Handle SSE connection request
    fn handle_sse_connect(request: HttpRequest) -> HttpResponse:
        # Create new SSE client
        val client_id = self.next_client_id
        self.next_client_id = self.next_client_id + 1

        val client = SseClient.new(client_id)
        self.sse_clients.append(client)

        self.log_debug("New SSE client connected: {client_id}")

        # Return SSE response
        var response = HttpResponse.ok("")
        response.headers.set("Content-Type", "text/event-stream")
        response.headers.set("Cache-Control", "no-cache")
        response.headers.set("Connection", "keep-alive")

        return response

    # Handle message POST request
    fn handle_message(request: HttpRequest) -> HttpResponse:
        match request.body:
            case Some(body):
                # Parse JSON-RPC request
                match json.parse(body):
                    case Ok(JsonValue.Object(obj)):
                        # Process request and return response
                        var response_body = "{\"jsonrpc\":\"2.0\",\"id\":1,\"result\":{}}"
                        return HttpResponse.ok(response_body)
                    case _:
                        return HttpResponse.error(400, "Invalid JSON")
            case nil:
                return HttpResponse.error(400, "Missing body")

    # Broadcast event to all SSE clients
    pub me broadcast_event(event: SseEvent):
        self.log_debug("Broadcasting event to {self.sse_clients.len()} clients")
        for client in self.sse_clients:
            client.send_event(event)

    # Remove disconnected clients
    pub me cleanup_clients():
        var active_clients: List<SseClient> = []
        for client in self.sse_clients:
            if client.is_connected():
                active_clients.append(client)
        self.sse_clients = active_clients

# SSE client connection
pub class SseClient:
    pub id: i64
    pub connected: bool
    pub event_queue: List<SseEvent>

    static fn new(id: i64) -> SseClient:
        return SseClient(
            id: id,
            connected: true,
            event_queue: []
        )

    pub fn is_connected() -> bool:
        return self.connected

    pub me disconnect():
        self.connected = false

    pub me send_event(event: SseEvent):
        if self.connected:
            self.event_queue.append(event)

    pub me get_pending_events() -> List<SseEvent>:
        val events = self.event_queue
        self.event_queue = []
        return events

# Helper functions
fn json_object_to_dict(obj: Dict<text, JsonValue>) -> Dict<text, Any>:
    var result: Dict<text, Any> = {}
    for key in obj.keys():
        match obj.get(key):
            case Some(value):
                result.set(key, json_value_to_any(value))
            case nil:
                pass
    return result

fn json_value_to_any(value: JsonValue) -> Any:
    match value:
        case JsonValue.Null:
            return nil
        case JsonValue.bool(b):
            return b
        case JsonValue.Integer(i):
            return i
        case JsonValue.Number(n):
            return n
        case JsonValue.text(s):
            return s
        case JsonValue.Array(arr):
            var result: List<Any> = []
            for item in arr:
                result.append(json_value_to_any(item))
            return result
        case JsonValue.Object(obj):
            return json_object_to_dict(obj)

fn dict_to_json_value(dict: Dict<text, Any>) -> JsonValue:
    var obj: Dict<text, JsonValue> = {}
    for key in dict.keys():
        match dict.get(key):
            case Some(value):
                obj.set(key, any_to_json(value))
            case nil:
                pass
    return JsonValue.Object(obj)

fn any_to_json(value: Any) -> JsonValue:
    if value == nil:
        return JsonValue.Null
    # Simplified conversion
    return JsonValue.text("{value}")

# Extern functions
extern fn stderr_write(s: text)
extern fn stderr_flush()
