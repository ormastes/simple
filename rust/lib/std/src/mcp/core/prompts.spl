# MCP Prompts Manager
# Full prompt management with argument handling
# Follows MCP specification 2025-11-25

use core.*
use std.mcp.core.protocol.*
use std.mcp.core.pagination.*
use std.mcp.core.logger.*
use std.mcp.core.error_handler.*

# Prompt argument definition
pub class PromptArgumentDef:
    pub name: text
    pub description: text
    pub required: bool

    static fn new(name: text, description: text, required: bool) -> PromptArgumentDef:
        return PromptArgumentDef(
            name: name,
            description: description,
            required: required
        )

    static fn required_arg(name: text, description: text) -> PromptArgumentDef:
        return PromptArgumentDef.new(name, description, true)

    static fn optional_arg(name: text, description: text) -> PromptArgumentDef:
        return PromptArgumentDef.new(name, description, false)

    pub fn to_dict() -> Dict<text, Any>:
        return {
            "name": self.name,
            "description": self.description,
            "required": self.required
        }

# Prompt message role
pub enum PromptMessageRole:
    User
    Assistant
    System

    pub fn to_string() -> text:
        match self:
            case User: "user"
            case Assistant: "assistant"
            case System: "system"

    static fn from_string(s: text) -> PromptMessageRole:
        if s == "assistant":
            return PromptMessageRole.Assistant
        elif s == "system":
            return PromptMessageRole.System
        else:
            return PromptMessageRole.User

# Prompt message content
pub enum PromptContent:
    Text(text)
    Image(ImageContent)
    Resource(ResourceContent)

    pub fn to_dict() -> Dict<text, Any>:
        match self:
            case Text(t):
                return {"type": "text", "text": t}
            case Image(img):
                return {
                    "type": "image",
                    "data": img.data,
                    "mimeType": img.mime_type
                }
            case Resource(res):
                return {
                    "type": "resource",
                    "resource": {
                        "uri": res.uri,
                        "mimeType": res.mime_type,
                        "text": res.text
                    }
                }

pub class ImageContent:
    pub data: text       # Base64 encoded
    pub mime_type: text

    static fn new(data: text, mime_type: text) -> ImageContent:
        return ImageContent(data: data, mime_type: mime_type)

pub class ResourceContent:
    pub uri: text
    pub mime_type: text
    pub text: text

    static fn new(uri: text, mime_type: text, text: text) -> ResourceContent:
        return ResourceContent(uri: uri, mime_type: mime_type, text: text)

# Prompt message
pub class PromptMessage:
    pub role: PromptMessageRole
    pub content: PromptContent

    static fn user(content: text) -> PromptMessage:
        return PromptMessage(
            role: PromptMessageRole.User,
            content: PromptContent.Text(content)
        )

    static fn assistant(content: text) -> PromptMessage:
        return PromptMessage(
            role: PromptMessageRole.Assistant,
            content: PromptContent.Text(content)
        )

    static fn system(content: text) -> PromptMessage:
        return PromptMessage(
            role: PromptMessageRole.System,
            content: PromptContent.Text(content)
        )

    pub fn to_dict() -> Dict<text, Any>:
        return {
            "role": self.role.to_string(),
            "content": self.content.to_dict()
        }

# Prompt definition
pub class PromptDef:
    pub name: text
    pub description: text
    pub arguments: List<PromptArgumentDef>

    static fn new(name: text, description: text) -> PromptDef:
        return PromptDef(
            name: name,
            description: description,
            arguments: []
        )

    pub fn with_argument(self, arg: PromptArgumentDef) -> PromptDef:
        var new_args = self.arguments.clone()
        new_args.append(arg)
        return PromptDef(
            name: self.name,
            description: self.description,
            arguments: new_args
        )

    pub fn with_required_arg(self, name: text, description: text) -> PromptDef:
        return self.with_argument(PromptArgumentDef.required_arg(name, description))

    pub fn with_optional_arg(self, name: text, description: text) -> PromptDef:
        return self.with_argument(PromptArgumentDef.optional_arg(name, description))

    pub fn to_dict() -> Dict<text, Any>:
        var args_list: List<Dict<text, Any>> = []
        for arg in self.arguments:
            args_list.append(arg.to_dict())

        return {
            "name": self.name,
            "description": self.description,
            "arguments": args_list
        }

    pub fn to_prompt() -> Prompt:
        var prompt_args: List<PromptArgument> = []
        for arg in self.arguments:
            prompt_args.append(PromptArgument.new(arg.name, arg.description, arg.required))

        return Prompt(
            name: self.name,
            description: self.description,
            arguments: prompt_args
        )

# Get prompt result
pub class GetPromptResult:
    pub description: Option<text>
    pub messages: List<PromptMessage>

    static fn new(messages: List<PromptMessage>) -> GetPromptResult:
        return GetPromptResult(
            description: nil,
            messages: messages
        )

    pub fn with_description(self, desc: text) -> GetPromptResult:
        return GetPromptResult(
            description: Some(desc),
            messages: self.messages
        )

    pub fn to_dict() -> Dict<text, Any>:
        var msgs_list: List<Dict<text, Any>> = []
        for msg in self.messages:
            msgs_list.append(msg.to_dict())

        var result: Dict<text, Any> = {"messages": msgs_list}

        match self.description:
            case Some(desc):
                result.set("description", desc)
            case nil:
                pass

        return result

# Prompt handler interface
pub trait PromptHandler:
    # Get the prompt definition
    fn get_definition() -> PromptDef

    # Execute the prompt with arguments
    fn execute(arguments: Dict<text, text>) -> Result<GetPromptResult, McpError>

# Simple prompt handler that uses a function
pub class FunctionPromptHandler:
    pub definition: PromptDef
    pub handler_fn: fn(Dict<text, text>) -> Result<GetPromptResult, McpError>

    static fn new(
        definition: PromptDef,
        handler_fn: fn(Dict<text, text>) -> Result<GetPromptResult, McpError>
    ) -> FunctionPromptHandler:
        return FunctionPromptHandler(
            definition: definition,
            handler_fn: handler_fn
        )

impl PromptHandler for FunctionPromptHandler:
    fn get_definition() -> PromptDef:
        return self.definition

    fn execute(arguments: Dict<text, text>) -> Result<GetPromptResult, McpError>:
        return self.handler_fn(arguments)

# Prompt manager
pub class PromptManager:
    pub prompts: Dict<text, PromptHandler>
    pub pagination_config: PaginationConfig
    pub debug_mode: bool

    static fn new() -> PromptManager:
        return PromptManager(
            prompts: {},
            pagination_config: PaginationConfig.new(),
            debug_mode: false
        )

    pub me enable_debug():
        self.debug_mode = true

    fn log_debug(msg: text):
        if self.debug_mode:
            log_debug("PromptManager: {msg}")

    # Register a prompt handler
    pub me register_prompt(handler: PromptHandler):
        val def = handler.get_definition()
        self.prompts.set(def.name, handler)
        self.log_debug("Registered prompt: {def.name}")

    # Register a simple prompt with function
    pub me register_simple_prompt(
        name: text,
        description: text,
        handler_fn: fn(Dict<text, text>) -> Result<GetPromptResult, McpError>
    ):
        val def = PromptDef.new(name, description)
        val handler = FunctionPromptHandler.new(def, handler_fn)
        self.register_prompt(handler)

    # Register a prompt with arguments
    pub me register_prompt_with_args(
        name: text,
        description: text,
        args: List<PromptArgumentDef>,
        handler_fn: fn(Dict<text, text>) -> Result<GetPromptResult, McpError>
    ):
        var def = PromptDef.new(name, description)
        for arg in args:
            def = def.with_argument(arg)

        val handler = FunctionPromptHandler.new(def, handler_fn)
        self.register_prompt(handler)

    # List all prompts with pagination
    pub fn list_prompts(cursor: Option<text>) -> PaginatedResponse<PromptDef>:
        var all_prompts: List<PromptDef> = []

        for name in self.prompts.keys():
            match self.prompts.get(name):
                case Some(handler):
                    all_prompts.append(handler.get_definition())
                case nil:
                    pass

        return paginate_prompts(all_prompts, cursor, self.pagination_config.default_page_size)

    # Get a specific prompt
    pub fn get_prompt(name: text, arguments: Dict<text, text>) -> Result<GetPromptResult, McpError>:
        self.log_debug("Getting prompt: {name}")

        match self.prompts.get(name):
            case Some(handler):
                # Validate required arguments
                val def = handler.get_definition()
                match self.validate_arguments(def, arguments):
                    case Ok(_):
                        pass
                    case Err(e):
                        return Err(e)

                return handler.execute(arguments)

            case nil:
                return Err(McpError.new(
                    ErrorCategory.Validation,
                    "Prompt not found: {name}",
                    -32602
                ))

    # Validate prompt arguments
    fn validate_arguments(def: PromptDef, arguments: Dict<text, text>) -> Result<(), McpError>:
        for arg in def.arguments:
            if arg.required:
                if not arguments.has_key(arg.name):
                    return Err(McpError.new(
                        ErrorCategory.Validation,
                        "Missing required argument: {arg.name}",
                        -32602
                    ))

                match arguments.get(arg.name):
                    case Some(val):
                        if val == "":
                            return Err(McpError.new(
                                ErrorCategory.Validation,
                                "Required argument is empty: {arg.name}",
                                -32602
                            ))
                    case nil:
                        return Err(McpError.new(
                            ErrorCategory.Validation,
                            "Missing required argument: {arg.name}",
                            -32602
                        ))

        return Ok(())

    # Check if prompt exists
    pub fn has_prompt(name: text) -> bool:
        return self.prompts.has_key(name)

    # Remove a prompt
    pub me remove_prompt(name: text):
        self.prompts.remove(name)
        self.log_debug("Removed prompt: {name}")

    # Get prompt count
    pub fn count() -> i64:
        return self.prompts.len()

# Template-based prompt
pub class TemplatePrompt:
    pub name: text
    pub description: text
    pub template: text
    pub arguments: List<PromptArgumentDef>

    static fn new(name: text, description: text, template: text) -> TemplatePrompt:
        return TemplatePrompt(
            name: name,
            description: description,
            template: template,
            arguments: []
        )

    pub fn with_argument(self, arg: PromptArgumentDef) -> TemplatePrompt:
        var new_args = self.arguments.clone()
        new_args.append(arg)
        return TemplatePrompt(
            name: self.name,
            description: self.description,
            template: self.template,
            arguments: new_args
        )

    # Render template with arguments
    pub fn render(arguments: Dict<text, text>) -> text:
        var result = self.template

        # Replace placeholders {{name}} with argument values
        for arg in self.arguments:
            val placeholder = "{{" + arg.name + "}}"
            match arguments.get(arg.name):
                case Some(value):
                    result = result.replace(placeholder, value)
                case nil:
                    # Leave placeholder if argument not provided
                    pass

        return result

    # Convert to handler
    pub fn to_handler() -> PromptHandler:
        var def = PromptDef.new(self.name, self.description)
        for arg in self.arguments:
            def = def.with_argument(arg)

        val template = self.template
        val template_prompt = self

        val handler_fn = \args:
            val rendered = template_prompt.render(args)
            val messages = [PromptMessage.user(rendered)]
            Ok(GetPromptResult.new(messages))

        return FunctionPromptHandler.new(def, handler_fn)

# Built-in prompts
pub fn create_code_review_prompt() -> TemplatePrompt:
    return TemplatePrompt.new(
        "code_review",
        "Review code for issues and improvements",
        "Please review the following code and provide feedback on:\n1. Code quality\n2. Potential bugs\n3. Performance issues\n4. Suggested improvements\n\n```{{language}}\n{{code}}\n```"
    )
    .with_argument(PromptArgumentDef.required_arg("code", "The code to review"))
    .with_argument(PromptArgumentDef.optional_arg("language", "Programming language"))

pub fn create_explain_code_prompt() -> TemplatePrompt:
    return TemplatePrompt.new(
        "explain_code",
        "Explain what code does",
        "Please explain what the following code does:\n\n```{{language}}\n{{code}}\n```"
    )
    .with_argument(PromptArgumentDef.required_arg("code", "The code to explain"))
    .with_argument(PromptArgumentDef.optional_arg("language", "Programming language"))

pub fn create_write_tests_prompt() -> TemplatePrompt:
    return TemplatePrompt.new(
        "write_tests",
        "Generate test cases for code",
        "Please write comprehensive test cases for the following code:\n\n```{{language}}\n{{code}}\n```\n\nConsider edge cases and error conditions."
    )
    .with_argument(PromptArgumentDef.required_arg("code", "The code to test"))
    .with_argument(PromptArgumentDef.optional_arg("language", "Programming language"))

pub fn create_debug_prompt() -> TemplatePrompt:
    return TemplatePrompt.new(
        "debug",
        "Help debug an issue",
        "I'm seeing the following error:\n\n```\n{{error}}\n```\n\nIn this code:\n\n```{{language}}\n{{code}}\n```\n\nPlease help me understand and fix this issue."
    )
    .with_argument(PromptArgumentDef.required_arg("error", "The error message"))
    .with_argument(PromptArgumentDef.required_arg("code", "The code with the issue"))
    .with_argument(PromptArgumentDef.optional_arg("language", "Programming language"))

# Register built-in prompts with a manager
pub fn register_builtin_prompts(manager: PromptManager):
    manager.register_prompt(create_code_review_prompt().to_handler())
    manager.register_prompt(create_explain_code_prompt().to_handler())
    manager.register_prompt(create_write_tests_prompt().to_handler())
    manager.register_prompt(create_debug_prompt().to_handler())
