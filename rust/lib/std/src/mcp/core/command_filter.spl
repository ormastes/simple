# MCP Command Filter
# Security filtering for shell commands and dangerous operations
# Follows MCP specification 2025-11-25

use core.*
use std.mcp.core.error_handler.*
use std.mcp.core.logger.*

# Command risk level
pub enum CommandRiskLevel:
    Safe           # Read-only, no side effects
    Low            # Minor modifications, easily reversible
    Medium         # Moderate changes, may affect files
    High           # Significant changes, potentially destructive
    Critical       # Extremely dangerous, system-level impact

    pub fn to_string() -> text:
        match self:
            case Safe: "safe"
            case Low: "low"
            case Medium: "medium"
            case High: "high"
            case Critical: "critical"

    pub fn to_i64() -> i64:
        match self:
            case Safe: 0
            case Low: 1
            case Medium: 2
            case High: 3
            case Critical: 4

# Security violation type
pub enum SecurityViolation:
    BlockedCommand
    DangerousPattern
    PathTraversal
    ShellInjection
    PrivilegeEscalation
    NetworkAccess
    SystemModification

    pub fn to_string() -> text:
        match self:
            case BlockedCommand: "blocked_command"
            case DangerousPattern: "dangerous_pattern"
            case PathTraversal: "path_traversal"
            case ShellInjection: "shell_injection"
            case PrivilegeEscalation: "privilege_escalation"
            case NetworkAccess: "network_access"
            case SystemModification: "system_modification"

# Security error
pub class SecurityError:
    pub violation: SecurityViolation
    pub message: text
    pub command: text
    pub matched_pattern: Option<text>

    static fn new(violation: SecurityViolation, message: text, command: text) -> SecurityError:
        return SecurityError(
            violation: violation,
            message: message,
            command: command,
            matched_pattern: nil
        )

    pub fn with_pattern(self, pattern: text) -> SecurityError:
        return SecurityError(
            violation: self.violation,
            message: self.message,
            command: self.command,
            matched_pattern: Some(pattern)
        )

    pub fn to_mcp_error() -> McpError:
        return McpError.new(
            ErrorCategory.Validation,
            "Security violation ({self.violation.to_string()}): {self.message}",
            -32002
        ).unrecoverable()

# Command filter configuration
pub class CommandFilterConfig:
    pub max_risk_level: CommandRiskLevel
    pub allow_network: bool
    pub allow_sudo: bool
    pub allow_rm: bool
    pub allowed_paths: List<text>
    pub blocked_paths: List<text>
    pub custom_blocked_patterns: List<text>
    pub custom_allowed_commands: List<text>

    static fn default() -> CommandFilterConfig:
        return CommandFilterConfig(
            max_risk_level: CommandRiskLevel.Medium,
            allow_network: true,
            allow_sudo: false,
            allow_rm: false,
            allowed_paths: [],
            blocked_paths: ["/etc", "/boot", "/sys", "/proc", "/dev"],
            custom_blocked_patterns: [],
            custom_allowed_commands: []
        )

    static fn strict() -> CommandFilterConfig:
        return CommandFilterConfig(
            max_risk_level: CommandRiskLevel.Low,
            allow_network: false,
            allow_sudo: false,
            allow_rm: false,
            allowed_paths: [],
            blocked_paths: ["/etc", "/boot", "/sys", "/proc", "/dev", "/root", "/home"],
            custom_blocked_patterns: [],
            custom_allowed_commands: []
        )

    static fn permissive() -> CommandFilterConfig:
        return CommandFilterConfig(
            max_risk_level: CommandRiskLevel.High,
            allow_network: true,
            allow_sudo: false,
            allow_rm: true,
            allowed_paths: [],
            blocked_paths: ["/etc", "/boot", "/sys"],
            custom_blocked_patterns: [],
            custom_allowed_commands: []
        )

# Command filter
pub class CommandFilter:
    pub config: CommandFilterConfig
    pub blocked_commands: List<text>
    pub blocked_patterns: List<text>
    pub dangerous_patterns: List<text>
    pub debug_mode: bool

    static fn new(config: CommandFilterConfig) -> CommandFilter:
        return CommandFilter(
            config: config,
            blocked_commands: get_default_blocked_commands(),
            blocked_patterns: get_default_blocked_patterns(),
            dangerous_patterns: get_default_dangerous_patterns(),
            debug_mode: false
        )

    static fn default() -> CommandFilter:
        return CommandFilter.new(CommandFilterConfig.default())

    static fn strict() -> CommandFilter:
        return CommandFilter.new(CommandFilterConfig.strict())

    pub me enable_debug():
        self.debug_mode = true

    fn log_debug(msg: text):
        if self.debug_mode:
            log_debug("CommandFilter: {msg}")

    # Check if command is dangerous
    pub fn is_dangerous(command: text) -> bool:
        match self.check_command(command):
            case Ok(_): false
            case Err(_): true

    # Check command and return error if dangerous
    pub fn check_command(command: text) -> Result<(), SecurityError>:
        val normalized = normalize_command(command)
        self.log_debug("Checking command: {normalized}")

        # Check blocked commands
        match self.check_blocked_commands(normalized):
            case Ok(_):
                pass
            case Err(e):
                return Err(e)

        # Check blocked patterns
        match self.check_blocked_patterns(normalized):
            case Ok(_):
                pass
            case Err(e):
                return Err(e)

        # Check dangerous patterns
        match self.check_dangerous_patterns(normalized):
            case Ok(_):
                pass
            case Err(e):
                return Err(e)

        # Check path traversal
        match self.check_path_traversal(normalized):
            case Ok(_):
                pass
            case Err(e):
                return Err(e)

        # Check shell injection
        match self.check_shell_injection(normalized):
            case Ok(_):
                pass
            case Err(e):
                return Err(e)

        # Check privilege escalation
        match self.check_privilege_escalation(normalized):
            case Ok(_):
                pass
            case Err(e):
                return Err(e)

        # Check network access
        if not self.config.allow_network:
            match self.check_network_access(normalized):
                case Ok(_):
                    pass
                case Err(e):
                    return Err(e)

        self.log_debug("Command approved")
        return Ok(())

    # Sanitize command (remove dangerous parts)
    pub fn sanitize(command: text) -> Result<text, SecurityError>:
        var sanitized = command

        # Remove shell metacharacters
        sanitized = sanitized.replace(";", "")
        sanitized = sanitized.replace("|", "")
        sanitized = sanitized.replace("&", "")
        sanitized = sanitized.replace("`", "")
        sanitized = sanitized.replace("$(", "")
        sanitized = sanitized.replace(")", "")
        sanitized = sanitized.replace(">", "")
        sanitized = sanitized.replace("<", "")

        # Verify the sanitized command is safe
        match self.check_command(sanitized):
            case Ok(_):
                return Ok(sanitized)
            case Err(e):
                return Err(e)

    # Get risk level for command
    pub fn get_risk_level(command: text) -> CommandRiskLevel:
        val normalized = normalize_command(command)

        # Critical commands
        if contains_any(normalized, ["rm -rf /", "mkfs", "dd if=", ":(){ :|:& };:", "chmod -R 777 /"]):
            return CommandRiskLevel.Critical

        # High risk commands
        if contains_any(normalized, ["rm -rf", "rm -r", "chmod", "chown", "kill -9", "pkill", "shutdown", "reboot"]):
            return CommandRiskLevel.High

        # Medium risk commands
        if contains_any(normalized, ["rm", "mv", "cp", "mkdir", "touch", "echo", "cat >"]):
            return CommandRiskLevel.Medium

        # Low risk commands
        if contains_any(normalized, ["git", "npm", "pip", "cargo"]):
            return CommandRiskLevel.Low

        # Safe commands
        if contains_any(normalized, ["ls", "cat", "head", "tail", "grep", "find", "which", "pwd", "whoami"]):
            return CommandRiskLevel.Safe

        # Default to medium for unknown commands
        return CommandRiskLevel.Medium

    fn check_blocked_commands(command: text) -> Result<(), SecurityError>:
        for blocked in self.blocked_commands:
            if command.starts_with(blocked + " ") or command == blocked:
                return Err(SecurityError.new(
                    SecurityViolation.BlockedCommand,
                    "Command '{blocked}' is blocked",
                    command
                ).with_pattern(blocked))

        # Check custom blocked
        for blocked in self.config.custom_blocked_patterns:
            if command.contains(blocked):
                return Err(SecurityError.new(
                    SecurityViolation.BlockedCommand,
                    "Command contains blocked pattern",
                    command
                ).with_pattern(blocked))

        return Ok(())

    fn check_blocked_patterns(command: text) -> Result<(), SecurityError>:
        for pattern in self.blocked_patterns:
            if command.contains(pattern):
                return Err(SecurityError.new(
                    SecurityViolation.DangerousPattern,
                    "Command contains blocked pattern",
                    command
                ).with_pattern(pattern))
        return Ok(())

    fn check_dangerous_patterns(command: text) -> Result<(), SecurityError>:
        for pattern in self.dangerous_patterns:
            if command.contains(pattern):
                val risk = self.get_risk_level(command)
                if risk.to_i64() > self.config.max_risk_level.to_i64():
                    return Err(SecurityError.new(
                        SecurityViolation.DangerousPattern,
                        "Command risk level ({risk.to_string()}) exceeds maximum allowed ({self.config.max_risk_level.to_string()})",
                        command
                    ).with_pattern(pattern))
        return Ok(())

    fn check_path_traversal(command: text) -> Result<(), SecurityError>:
        # Check for path traversal attempts
        if command.contains(".."):
            # Allow if it doesn't try to escape to blocked paths
            for blocked_path in self.config.blocked_paths:
                if command.contains(blocked_path):
                    return Err(SecurityError.new(
                        SecurityViolation.PathTraversal,
                        "Path traversal to blocked path",
                        command
                    ).with_pattern(blocked_path))

        # Check direct access to blocked paths
        for blocked_path in self.config.blocked_paths:
            if command.contains(blocked_path):
                return Err(SecurityError.new(
                    SecurityViolation.PathTraversal,
                    "Access to blocked path",
                    command
                ).with_pattern(blocked_path))

        return Ok(())

    fn check_shell_injection(command: text) -> Result<(), SecurityError>:
        val injection_patterns = [
            "$(", "`", "${", ";", "&&", "||", "|", ">", "<", ">>", "<<",
            "\n", "\r", "\\x", "\\0"
        ]

        for pattern in injection_patterns:
            if command.contains(pattern):
                # Some patterns are allowed in certain contexts
                if pattern == "&&" or pattern == "||":
                    # Allow chaining for build commands
                    if command.starts_with("make") or command.starts_with("npm") or command.starts_with("cargo"):
                        continue

                if pattern == "|":
                    # Allow piping for grep/awk/etc
                    if command.contains("grep") or command.contains("awk") or command.contains("sort"):
                        continue

                if pattern == ">" or pattern == ">>":
                    # Allow output redirection for logs
                    if command.contains(".log") or command.contains(".txt"):
                        continue

                return Err(SecurityError.new(
                    SecurityViolation.ShellInjection,
                    "Potential shell injection detected",
                    command
                ).with_pattern(pattern))

        return Ok(())

    fn check_privilege_escalation(command: text) -> Result<(), SecurityError>:
        if not self.config.allow_sudo:
            if command.starts_with("sudo ") or command.contains(" sudo "):
                return Err(SecurityError.new(
                    SecurityViolation.PrivilegeEscalation,
                    "sudo is not allowed",
                    command
                ))

            if command.starts_with("su ") or command.contains(" su "):
                return Err(SecurityError.new(
                    SecurityViolation.PrivilegeEscalation,
                    "su is not allowed",
                    command
                ))

            if command.starts_with("doas "):
                return Err(SecurityError.new(
                    SecurityViolation.PrivilegeEscalation,
                    "doas is not allowed",
                    command
                ))

        return Ok(())

    fn check_network_access(command: text) -> Result<(), SecurityError>:
        val network_commands = ["curl", "wget", "nc", "netcat", "ssh", "scp", "rsync", "ftp", "telnet"]

        for cmd in network_commands:
            if command.starts_with(cmd + " ") or command.contains(" " + cmd + " "):
                return Err(SecurityError.new(
                    SecurityViolation.NetworkAccess,
                    "Network access is not allowed",
                    command
                ).with_pattern(cmd))

        return Ok(())

# Helper functions
fn normalize_command(command: text) -> text:
    # Remove extra whitespace
    var result = command.trim()

    # Normalize multiple spaces to single space
    while result.contains("  "):
        result = result.replace("  ", " ")

    return result.to_lowercase()

fn contains_any(text: text, patterns: List<text>) -> bool:
    for pattern in patterns:
        if text.contains(pattern):
            return true
    return false

fn get_default_blocked_commands() -> List<text>:
    return [
        "rm -rf /",
        "rm -rf /*",
        "mkfs",
        "dd",
        "shutdown",
        "reboot",
        "halt",
        "poweroff",
        "init 0",
        "init 6",
        ":(){ :|:& };:",  # Fork bomb
        "chmod -R 777 /",
        "chown -R",
        "format",
        "fdisk"
    ]

fn get_default_blocked_patterns() -> List<text>:
    return [
        "/dev/sd",       # Raw disk access
        "/dev/hd",       # Raw disk access
        "/dev/null",     # Can be used for data destruction
        ">/dev/",        # Device redirection
        "| sh",          # Piping to shell
        "| bash",        # Piping to shell
        "| zsh",         # Piping to shell
        "base64 -d",     # Can hide malicious commands
        "eval ",         # Code execution
        "exec "          # Process replacement
    ]

fn get_default_dangerous_patterns() -> List<text>:
    return [
        "rm -rf",
        "rm -r",
        "chmod 777",
        "chmod -R",
        "chown -R",
        "kill -9",
        "pkill -9",
        "killall",
        "> /dev/",
        ">> /dev/",
        "2>&1",          # Can hide error messages
        "/etc/passwd",
        "/etc/shadow",
        ".ssh/",
        "id_rsa",
        "authorized_keys"
    ]

# Security context
pub class SecurityContext:
    pub user: text
    pub allowed_paths: List<text>
    pub denied_paths: List<text>
    pub max_risk_level: CommandRiskLevel
    pub filter: CommandFilter

    static fn new(user: text) -> SecurityContext:
        return SecurityContext(
            user: user,
            allowed_paths: [],
            denied_paths: [],
            max_risk_level: CommandRiskLevel.Medium,
            filter: CommandFilter.default()
        )

    pub fn with_filter(self, filter: CommandFilter) -> SecurityContext:
        return SecurityContext(
            user: self.user,
            allowed_paths: self.allowed_paths,
            denied_paths: self.denied_paths,
            max_risk_level: self.max_risk_level,
            filter: filter
        )

    pub fn check_command(command: text) -> Result<(), SecurityError>:
        return self.filter.check_command(command)

    pub fn is_path_allowed(path: text) -> bool:
        # Check denied paths first
        for denied in self.denied_paths:
            if path.starts_with(denied):
                return false

        # If allowed paths specified, check against them
        if self.allowed_paths.len() > 0:
            for allowed in self.allowed_paths:
                if path.starts_with(allowed):
                    return true
            return false

        return true
