# MCP WebSocket Transport Layer
# Implements WebSocket transport for MCP
# Follows MCP specification 2025-11-25

use core.*
use core.json.*
use std.mcp.core.protocol.*
use std.mcp.core.transport.*
use std.mcp.core.logger.*
use std.mcp.core.error_handler.*

# WebSocket message types
pub enum WsMessageType:
    Text
    Binary
    Ping
    Pong
    Close

    pub fn to_string() -> text:
        match self:
            case Text: "text"
            case Binary: "binary"
            case Ping: "ping"
            case Pong: "pong"
            case Close: "close"

# WebSocket frame
pub class WsFrame:
    pub message_type: WsMessageType
    pub payload: text
    pub is_final: bool

    static fn text_frame(payload: text) -> WsFrame:
        return WsFrame(
            message_type: WsMessageType.Text,
            payload: payload,
            is_final: true
        )

    static fn binary_frame(payload: text) -> WsFrame:
        return WsFrame(
            message_type: WsMessageType.Binary,
            payload: payload,
            is_final: true
        )

    static fn ping() -> WsFrame:
        return WsFrame(
            message_type: WsMessageType.Ping,
            payload: "",
            is_final: true
        )

    static fn pong(payload: text) -> WsFrame:
        return WsFrame(
            message_type: WsMessageType.Pong,
            payload: payload,
            is_final: true
        )

    static fn close(code: i64, reason: text) -> WsFrame:
        return WsFrame(
            message_type: WsMessageType.Close,
            payload: "{code}:{reason}",
            is_final: true
        )

# WebSocket connection state
pub enum WsConnectionState:
    Connecting
    Open
    Closing
    Closed

    pub fn to_string() -> text:
        match self:
            case Connecting: "connecting"
            case Open: "open"
            case Closing: "closing"
            case Closed: "closed"

# WebSocket close codes
pub val WS_CLOSE_NORMAL: i64 = 1000
pub val WS_CLOSE_GOING_AWAY: i64 = 1001
pub val WS_CLOSE_PROTOCOL_ERROR: i64 = 1002
pub val WS_CLOSE_UNSUPPORTED_DATA: i64 = 1003
pub val WS_CLOSE_NO_STATUS: i64 = 1005
pub val WS_CLOSE_ABNORMAL: i64 = 1006
pub val WS_CLOSE_INVALID_PAYLOAD: i64 = 1007
pub val WS_CLOSE_POLICY_VIOLATION: i64 = 1008
pub val WS_CLOSE_MESSAGE_TOO_BIG: i64 = 1009
pub val WS_CLOSE_INTERNAL_ERROR: i64 = 1011

# WebSocket transport configuration
pub class WsTransportConfig:
    pub url: text
    pub subprotocol: text          # MCP subprotocol
    pub ping_interval_ms: i64
    pub pong_timeout_ms: i64
    pub max_message_size: i64
    pub max_reconnect_attempts: i64
    pub reconnect_delay_ms: i64

    static fn default(url: text) -> WsTransportConfig:
        return WsTransportConfig(
            url: url,
            subprotocol: "mcp",
            ping_interval_ms: 30000,
            pong_timeout_ms: 10000,
            max_message_size: 10_000_000,  # 10MB
            max_reconnect_attempts: 5,
            reconnect_delay_ms: 1000
        )

# WebSocket transport for MCP
pub class WebSocketTransport:
    pub config: WsTransportConfig
    pub state: WsConnectionState
    pub handle: i64                # WebSocket handle from FFI
    pub pending_requests: List<JsonRpcRequest>
    pub pending_responses: List<JsonRpcResponse>
    pub fragment_buffer: text      # For fragmented messages
    pub last_ping_time: i64
    pub awaiting_pong: bool
    pub reconnect_attempts: i64
    pub error_count: i64
    pub debug_mode: bool
    pub validator: InputValidator

    static fn new(config: WsTransportConfig) -> WebSocketTransport:
        return WebSocketTransport(
            config: config,
            state: WsConnectionState.Closed,
            handle: -1,
            pending_requests: [],
            pending_responses: [],
            fragment_buffer: "",
            last_ping_time: 0,
            awaiting_pong: false,
            reconnect_attempts: 0,
            error_count: 0,
            debug_mode: false,
            validator: InputValidator.default()
        )

    static fn with_url(url: text) -> WebSocketTransport:
        return WebSocketTransport.new(WsTransportConfig.default(url))

    pub me enable_debug():
        self.debug_mode = true

    fn log_debug(msg: text):
        log_debug("WebSocketTransport: {msg}")
        if self.debug_mode:
            stderr_write("[MCP-WS] {msg}\n")
            stderr_flush()

    me log_error(msg: text):
        log_error("WebSocketTransport: {msg}")
        self.error_count = self.error_count + 1

    # Connect to WebSocket server
    pub me connect() -> Result<(), text>:
        if self.state == WsConnectionState.Open:
            return Ok(())

        self.state = WsConnectionState.Connecting
        self.log_debug("Connecting to WebSocket: {self.config.url}")

        # Perform WebSocket handshake
        match self.perform_handshake():
            case Ok(handle):
                self.handle = handle
                self.state = WsConnectionState.Open
                self.reconnect_attempts = 0
                self.log_debug("WebSocket connected")
                return Ok(())
            case Err(e):
                self.state = WsConnectionState.Closed
                self.log_error("WebSocket handshake failed: {e}")
                return Err(e)

    # Disconnect from WebSocket server
    pub me disconnect():
        self.disconnect_with_code(WS_CLOSE_NORMAL, "Normal closure")

    pub me disconnect_with_code(code: i64, reason: text):
        if self.state != WsConnectionState.Open:
            return

        self.state = WsConnectionState.Closing
        self.log_debug("Closing WebSocket: code={code}, reason={reason}")

        # Send close frame
        val close_frame = WsFrame.close(code, reason)
        self.send_frame(close_frame)

        # Close connection
        if self.handle >= 0:
            ws_close(self.handle)
            self.handle = -1

        self.state = WsConnectionState.Closed
        self.log_debug("WebSocket closed")

    # Perform WebSocket handshake
    fn perform_handshake() -> Result<i64, text>:
        # Parse URL to get host and port
        val url = self.config.url
        var host = ""
        var port: i64 = 80
        var path = "/"

        if url.starts_with("wss://"):
            port = 443
            val rest = url.substring(6)
            match parse_url_parts(rest):
                case (h, p, pa):
                    host = h
                    port = p
                    path = pa
        elif url.starts_with("ws://"):
            port = 80
            val rest = url.substring(5)
            match parse_url_parts(rest):
                case (h, p, pa):
                    host = h
                    port = p
                    path = pa
        else:
            return Err("Invalid WebSocket URL: must start with ws:// or wss://")

        # Connect to server
        val handle = ws_connect(host, port, path, self.config.subprotocol)
        if handle < 0:
            return Err("Failed to connect to WebSocket server")

        return Ok(handle)

    # Send a WebSocket frame
    me send_frame(frame: WsFrame):
        if self.handle < 0:
            self.log_error("Cannot send frame: not connected")
            return

        val opcode = match frame.message_type:
            case WsMessageType.Text: 1
            case WsMessageType.Binary: 2
            case WsMessageType.Close: 8
            case WsMessageType.Ping: 9
            case WsMessageType.Pong: 10

        val result = ws_send(self.handle, opcode, frame.payload)
        if result < 0:
            self.log_error("Failed to send frame")

    # Receive a WebSocket frame
    me receive_frame() -> Option<WsFrame>:
        if self.handle < 0:
            return nil

        val frame_data = ws_receive(self.handle)
        if frame_data == "":
            return nil

        # Parse frame data (format: "opcode:payload")
        val colon_idx = frame_data.index_of(":")
        match colon_idx:
            case Some(idx):
                val opcode_str = frame_data.substring(0, idx)
                val payload = frame_data.substring(idx + 1)

                var opcode: i64 = 0
                for ch in opcode_str:
                    if ch >= "0" and ch <= "9":
                        opcode = opcode * 10 + (ch.ord() - "0".ord())

                val message_type = match opcode:
                    case 1: WsMessageType.Text
                    case 2: WsMessageType.Binary
                    case 8: WsMessageType.Close
                    case 9: WsMessageType.Ping
                    case 10: WsMessageType.Pong
                    case _: WsMessageType.Text

                return Some(WsFrame(
                    message_type: message_type,
                    payload: payload,
                    is_final: true
                ))
            case nil:
                return nil

    # Handle incoming frame
    me handle_frame(frame: WsFrame) -> Option<JsonRpcRequest>:
        match frame.message_type:
            case WsMessageType.Text:
                # Parse JSON-RPC request
                match self.parse_request(frame.payload):
                    case Ok(request):
                        return Some(request)
                    case Err(e):
                        self.log_error("Failed to parse message: {e}")
                        return nil

            case WsMessageType.Binary:
                # MCP typically uses text, but handle binary
                self.log_debug("Received binary frame ({frame.payload.len()} bytes)")
                return nil

            case WsMessageType.Ping:
                # Respond with pong
                self.log_debug("Received ping, sending pong")
                val pong = WsFrame.pong(frame.payload)
                self.send_frame(pong)
                return nil

            case WsMessageType.Pong:
                # Pong received
                self.log_debug("Received pong")
                self.awaiting_pong = false
                return nil

            case WsMessageType.Close:
                # Close received
                self.log_debug("Received close frame")
                self.state = WsConnectionState.Closed
                return nil

    # Send ping to keep connection alive
    pub me send_ping():
        if self.state != WsConnectionState.Open:
            return

        self.log_debug("Sending ping")
        val ping = WsFrame.ping()
        self.send_frame(ping)
        self.awaiting_pong = true
        self.last_ping_time = current_time_ms()

    # Check if pong is overdue
    pub fn is_pong_overdue() -> bool:
        if not self.awaiting_pong:
            return false

        val now = current_time_ms()
        return (now - self.last_ping_time) > self.config.pong_timeout_ms

    # Attempt reconnection
    pub me try_reconnect() -> Result<(), text>:
        if self.reconnect_attempts >= self.config.max_reconnect_attempts:
            return Err("Max reconnect attempts exceeded")

        self.reconnect_attempts = self.reconnect_attempts + 1
        self.log_debug("Reconnect attempt {self.reconnect_attempts}/{self.config.max_reconnect_attempts}")

        # Wait before reconnecting
        sleep_ms(self.config.reconnect_delay_ms)

        return self.connect()

    # Parse JSON into JsonRpcRequest
    fn parse_request(json_str: text) -> Result<JsonRpcRequest, text>:
        # Validate message size
        if json_str.len() > self.config.max_message_size:
            return Err("Message too large: {json_str.len()} bytes")

        # Validate JSON string length
        match self.validator.validate_string(json_str, "request_body"):
            case Ok(_):
                pass
            case Err(error):
                return Err(error.message)

        match json.parse(json_str):
            case Ok(JsonValue.Object(obj)):
                var id: i64 = 0
                var method = ""
                var params: Dict<text, Any> = {}

                match obj.get("id"):
                    case Some(JsonValue.Integer(i)):
                        id = i
                    case _:
                        pass

                match obj.get("method"):
                    case Some(JsonValue.text(m)):
                        method = m
                    case _:
                        return Err("method must be string")

                match obj.get("params"):
                    case Some(JsonValue.Object(p)):
                        params = json_object_to_dict(p)
                    case _:
                        pass

                return Ok(JsonRpcRequest.new(id, method, params))

            case Ok(_):
                return Err("request must be object")
            case Err(e):
                return Err("JSON parse error: {e}")

    # Serialize request to JSON
    fn serialize_request(request: JsonRpcRequest) -> text:
        var builder = JsonBuilder.new()
        builder.set_string("jsonrpc", "2.0")
        builder.set_int("id", request.id)
        builder.set_string("method", request.method)
        val params_json = dict_to_json_value(request.params)
        builder.set("params", params_json)
        return json.stringify(builder.build())

    # Serialize response to JSON
    fn serialize_response(response: JsonRpcResponse) -> text:
        var builder = JsonBuilder.new()
        builder.set_string("jsonrpc", "2.0")
        builder.set_int("id", response.id)
        val result_json = any_to_json(response.result)
        builder.set("result", result_json)
        return json.stringify(builder.build())

    # Send JSON-RPC request
    pub me send_request(request: JsonRpcRequest):
        if self.state != WsConnectionState.Open:
            self.log_error("Cannot send request: not connected")
            return

        val json_str = self.serialize_request(request)
        val frame = WsFrame.text_frame(json_str)
        self.send_frame(frame)
        self.log_debug("Sent request: method={request.method}")

impl Transport for WebSocketTransport:
    me read_message() -> Option<JsonRpcRequest>:
        if self.state != WsConnectionState.Open:
            return nil

        # Check for pong timeout
        if self.is_pong_overdue():
            self.log_error("Pong timeout, connection may be dead")
            self.state = WsConnectionState.Closed
            return nil

        # Receive and handle frame
        match self.receive_frame():
            case Some(frame):
                return self.handle_frame(frame)
            case nil:
                return nil

    me write_response(response: JsonRpcResponse):
        if self.state != WsConnectionState.Open:
            self.log_error("Cannot write response: not connected")
            return

        val json_str = self.serialize_response(response)
        self.log_debug("Sending response: {json_str}")

        val frame = WsFrame.text_frame(json_str)
        self.send_frame(frame)

    me write_error(id: i64, code: i64, message: text):
        if self.state != WsConnectionState.Open:
            return

        # Build error response JSON
        var error_obj = JsonBuilder.new()
        error_obj.set_int("code", code)
        error_obj.set_string("message", message)

        var builder = JsonBuilder.new()
        builder.set_string("jsonrpc", "2.0")
        builder.set_int("id", id)
        builder.set("error", error_obj.build())

        val json_str = json.stringify(builder.build())
        self.log_debug("Sending error: {json_str}")

        val frame = WsFrame.text_frame(json_str)
        self.send_frame(frame)

    fn is_alive() -> bool:
        return self.state == WsConnectionState.Open or
               self.state == WsConnectionState.Connecting

# WebSocket server for accepting connections
pub class WebSocketServer:
    pub port: i64
    pub clients: List<WebSocketClient>
    pub next_client_id: i64
    pub handle: i64
    pub debug_mode: bool

    static fn new(port: i64) -> WebSocketServer:
        return WebSocketServer(
            port: port,
            clients: [],
            next_client_id: 1,
            handle: -1,
            debug_mode: false
        )

    pub me enable_debug():
        self.debug_mode = true

    fn log_debug(msg: text):
        if self.debug_mode:
            stderr_write("[MCP-WS-Server] {msg}\n")
            stderr_flush()

    # Start listening for connections
    pub me start() -> Result<(), text>:
        self.handle = ws_listen(self.port)
        if self.handle < 0:
            return Err("Failed to start WebSocket server on port {self.port}")

        self.log_debug("WebSocket server started on port {self.port}")
        return Ok(())

    # Stop the server
    pub me stop():
        # Close all client connections
        for client in self.clients:
            client.disconnect()

        if self.handle >= 0:
            ws_stop(self.handle)
            self.handle = -1

        self.log_debug("WebSocket server stopped")

    # Accept new connection
    pub me accept() -> Option<WebSocketClient>:
        if self.handle < 0:
            return nil

        val client_handle = ws_accept(self.handle)
        if client_handle < 0:
            return nil

        val client_id = self.next_client_id
        self.next_client_id = self.next_client_id + 1

        val client = WebSocketClient.new(client_id, client_handle)
        self.clients.append(client)

        self.log_debug("New client connected: id={client_id}")
        return Some(client)

    # Broadcast message to all clients
    pub me broadcast(message: text):
        self.log_debug("Broadcasting to {self.clients.len()} clients")
        for client in self.clients:
            if client.is_connected():
                client.send_text(message)

    # Remove disconnected clients
    pub me cleanup_clients():
        var active: List<WebSocketClient> = []
        for client in self.clients:
            if client.is_connected():
                active.append(client)
        self.clients = active

# WebSocket client (server-side representation)
pub class WebSocketClient:
    pub id: i64
    pub handle: i64
    pub connected: bool

    static fn new(id: i64, handle: i64) -> WebSocketClient:
        return WebSocketClient(
            id: id,
            handle: handle,
            connected: true
        )

    pub fn is_connected() -> bool:
        return self.connected and self.handle >= 0

    pub me disconnect():
        if self.handle >= 0:
            ws_close(self.handle)
            self.handle = -1
        self.connected = false

    pub me send_text(message: text):
        if not self.is_connected():
            return
        ws_send(self.handle, 1, message)

    pub me send_binary(data: text):
        if not self.is_connected():
            return
        ws_send(self.handle, 2, data)

# Helper functions
fn parse_url_parts(url: text) -> (text, i64, text):
    var host = ""
    var port: i64 = 80
    var path = "/"

    # Find path separator
    val path_idx = url.index_of("/")
    var host_port = ""

    match path_idx:
        case Some(idx):
            host_port = url.substring(0, idx)
            path = url.substring(idx)
        case nil:
            host_port = url

    # Find port separator
    val port_idx = host_port.index_of(":")
    match port_idx:
        case Some(idx):
            host = host_port.substring(0, idx)
            val port_str = host_port.substring(idx + 1)
            port = parse_int(port_str)
        case nil:
            host = host_port

    return (host, port, path)

fn parse_int(s: text) -> i64:
    var result: i64 = 0
    for ch in s:
        if ch >= "0" and ch <= "9":
            result = result * 10 + (ch.ord() - "0".ord())
        else:
            break
    return result

fn json_object_to_dict(obj: Dict<text, JsonValue>) -> Dict<text, Any>:
    var result: Dict<text, Any> = {}
    for key in obj.keys():
        match obj.get(key):
            case Some(value):
                result.set(key, json_value_to_any(value))
            case nil:
                pass
    return result

fn json_value_to_any(value: JsonValue) -> Any:
    match value:
        case JsonValue.Null:
            return nil
        case JsonValue.bool(b):
            return b
        case JsonValue.Integer(i):
            return i
        case JsonValue.Number(n):
            return n
        case JsonValue.text(s):
            return s
        case JsonValue.Array(arr):
            var result: List<Any> = []
            for item in arr:
                result.append(json_value_to_any(item))
            return result
        case JsonValue.Object(obj):
            return json_object_to_dict(obj)

fn dict_to_json_value(dict: Dict<text, Any>) -> JsonValue:
    var obj: Dict<text, JsonValue> = {}
    for key in dict.keys():
        match dict.get(key):
            case Some(value):
                obj.set(key, any_to_json(value))
            case nil:
                pass
    return JsonValue.Object(obj)

fn any_to_json(value: Any) -> JsonValue:
    if value == nil:
        return JsonValue.Null
    return JsonValue.text("{value}")

fn current_time_ms() -> i64:
    return time_now_ms()

fn sleep_ms(ms: i64):
    thread_sleep_ms(ms)

# FFI declarations for WebSocket operations
extern fn ws_connect(host: text, port: i64, path: text, protocol: text) -> i64
extern fn ws_send(handle: i64, opcode: i64, data: text) -> i64
extern fn ws_receive(handle: i64) -> text
extern fn ws_close(handle: i64)
extern fn ws_listen(port: i64) -> i64
extern fn ws_accept(server_handle: i64) -> i64
extern fn ws_stop(handle: i64)
extern fn time_now_ms() -> i64
extern fn thread_sleep_ms(ms: i64)
extern fn stderr_write(s: text)
extern fn stderr_flush()
