# MCP Capability Negotiation
# Dynamic capability negotiation between MCP clients and servers
# Follows MCP specification 2025-11-25

use core.*

# Client capabilities - what the client supports
pub class ClientCapabilities:
    pub roots: Option<RootsCapability>
    pub sampling: Option<SamplingCapability>
    pub experimental: Dict<text, Any>

    static fn new() -> ClientCapabilities:
        return ClientCapabilities(
            roots: nil,
            sampling: nil,
            experimental: {}
        )

    static fn full() -> ClientCapabilities:
        return ClientCapabilities(
            roots: Some(RootsCapability.new(true)),
            sampling: Some(SamplingCapability.new()),
            experimental: {}
        )

    pub fn has_roots() -> bool:
        match self.roots:
            case Some(_): true
            case nil: false

    pub fn has_sampling() -> bool:
        match self.sampling:
            case Some(_): true
            case nil: false

    pub fn supports_list_changed() -> bool:
        match self.roots:
            case Some(roots):
                return roots.list_changed
            case nil:
                return false

    pub fn to_dict() -> Dict<text, Any>:
        var result: Dict<text, Any> = {}

        match self.roots:
            case Some(roots):
                result.set("roots", roots.to_dict())
            case nil:
                pass

        match self.sampling:
            case Some(sampling):
                result.set("sampling", sampling.to_dict())
            case nil:
                pass

        if self.experimental.len() > 0:
            result.set("experimental", self.experimental)

        return result

    static fn from_dict(dict: Dict<text, Any>) -> ClientCapabilities:
        var caps = ClientCapabilities.new()

        match dict.get("roots"):
            case Some(roots_val):
                match roots_val:
                    case Dict<text, Any> as roots_dict:
                        caps.roots = Some(RootsCapability.from_dict(roots_dict))
                    case _:
                        pass
            case nil:
                pass

        match dict.get("sampling"):
            case Some(sampling_val):
                match sampling_val:
                    case Dict<text, Any> as sampling_dict:
                        caps.sampling = Some(SamplingCapability.from_dict(sampling_dict))
                    case _:
                        pass
            case nil:
                pass

        match dict.get("experimental"):
            case Some(exp_val):
                match exp_val:
                    case Dict<text, Any> as exp_dict:
                        caps.experimental = exp_dict
                    case _:
                        pass
            case nil:
                pass

        return caps

# Roots capability (client's file system roots)
pub class RootsCapability:
    pub list_changed: bool

    static fn new(list_changed: bool) -> RootsCapability:
        return RootsCapability(list_changed: list_changed)

    pub fn to_dict() -> Dict<text, Any>:
        return {"listChanged": self.list_changed}

    static fn from_dict(dict: Dict<text, Any>) -> RootsCapability:
        var list_changed = false
        match dict.get("listChanged"):
            case Some(val):
                match val:
                    case bool as b:
                        list_changed = b
                    case _:
                        pass
            case nil:
                pass
        return RootsCapability.new(list_changed)

# Sampling capability (LLM sampling)
pub class SamplingCapability:
    # Empty for now, but can be extended

    static fn new() -> SamplingCapability:
        return SamplingCapability()

    pub fn to_dict() -> Dict<text, Any>:
        return {}

    static fn from_dict(dict: Dict<text, Any>) -> SamplingCapability:
        return SamplingCapability.new()

# Server capabilities - what the server supports
pub class ServerCapabilities:
    pub resources: Option<ResourceCapabilities>
    pub tools: Option<ToolCapabilities>
    pub prompts: Option<PromptCapabilities>
    pub logging: Option<LoggingCapabilities>
    pub experimental: Dict<text, Any>

    static fn new() -> ServerCapabilities:
        return ServerCapabilities(
            resources: nil,
            tools: nil,
            prompts: nil,
            logging: nil,
            experimental: {}
        )

    static fn default() -> ServerCapabilities:
        return ServerCapabilities(
            resources: Some(ResourceCapabilities.default()),
            tools: Some(ToolCapabilities.default()),
            prompts: Some(PromptCapabilities.default()),
            logging: Some(LoggingCapabilities.default()),
            experimental: {}
        )

    static fn full() -> ServerCapabilities:
        return ServerCapabilities(
            resources: Some(ResourceCapabilities.full()),
            tools: Some(ToolCapabilities.full()),
            prompts: Some(PromptCapabilities.full()),
            logging: Some(LoggingCapabilities.default()),
            experimental: {}
        )

    pub fn has_resources() -> bool:
        match self.resources:
            case Some(_): true
            case nil: false

    pub fn has_tools() -> bool:
        match self.tools:
            case Some(_): true
            case nil: false

    pub fn has_prompts() -> bool:
        match self.prompts:
            case Some(_): true
            case nil: false

    pub fn has_logging() -> bool:
        match self.logging:
            case Some(_): true
            case nil: false

    pub fn supports_resource_subscribe() -> bool:
        match self.resources:
            case Some(res):
                return res.subscribe
            case nil:
                return false

    pub fn supports_resource_list_changed() -> bool:
        match self.resources:
            case Some(res):
                return res.list_changed
            case nil:
                return false

    pub fn supports_tool_list_changed() -> bool:
        match self.tools:
            case Some(tools):
                return tools.list_changed
            case nil:
                return false

    pub fn supports_prompt_list_changed() -> bool:
        match self.prompts:
            case Some(prompts):
                return prompts.list_changed
            case nil:
                return false

    pub fn to_dict() -> Dict<text, Any>:
        var result: Dict<text, Any> = {}

        match self.resources:
            case Some(res):
                result.set("resources", res.to_dict())
            case nil:
                pass

        match self.tools:
            case Some(tools):
                result.set("tools", tools.to_dict())
            case nil:
                pass

        match self.prompts:
            case Some(prompts):
                result.set("prompts", prompts.to_dict())
            case nil:
                pass

        match self.logging:
            case Some(logging):
                result.set("logging", logging.to_dict())
            case nil:
                pass

        if self.experimental.len() > 0:
            result.set("experimental", self.experimental)

        return result

    static fn from_dict(dict: Dict<text, Any>) -> ServerCapabilities:
        var caps = ServerCapabilities.new()

        match dict.get("resources"):
            case Some(res_val):
                match res_val:
                    case Dict<text, Any> as res_dict:
                        caps.resources = Some(ResourceCapabilities.from_dict(res_dict))
                    case _:
                        pass
            case nil:
                pass

        match dict.get("tools"):
            case Some(tools_val):
                match tools_val:
                    case Dict<text, Any> as tools_dict:
                        caps.tools = Some(ToolCapabilities.from_dict(tools_dict))
                    case _:
                        pass
            case nil:
                pass

        match dict.get("prompts"):
            case Some(prompts_val):
                match prompts_val:
                    case Dict<text, Any> as prompts_dict:
                        caps.prompts = Some(PromptCapabilities.from_dict(prompts_dict))
                    case _:
                        pass
            case nil:
                pass

        match dict.get("logging"):
            case Some(logging_val):
                match logging_val:
                    case Dict<text, Any> as logging_dict:
                        caps.logging = Some(LoggingCapabilities.from_dict(logging_dict))
                    case _:
                        pass
            case nil:
                pass

        match dict.get("experimental"):
            case Some(exp_val):
                match exp_val:
                    case Dict<text, Any> as exp_dict:
                        caps.experimental = exp_dict
                    case _:
                        pass
            case nil:
                pass

        return caps

# Resource capabilities
pub class ResourceCapabilities:
    pub subscribe: bool
    pub list_changed: bool

    static fn new(subscribe: bool, list_changed: bool) -> ResourceCapabilities:
        return ResourceCapabilities(
            subscribe: subscribe,
            list_changed: list_changed
        )

    static fn default() -> ResourceCapabilities:
        return ResourceCapabilities.new(false, false)

    static fn full() -> ResourceCapabilities:
        return ResourceCapabilities.new(true, true)

    pub fn to_dict() -> Dict<text, Any>:
        return {
            "subscribe": self.subscribe,
            "listChanged": self.list_changed
        }

    static fn from_dict(dict: Dict<text, Any>) -> ResourceCapabilities:
        var subscribe = false
        var list_changed = false

        match dict.get("subscribe"):
            case Some(val):
                match val:
                    case bool as b:
                        subscribe = b
                    case _:
                        pass
            case nil:
                pass

        match dict.get("listChanged"):
            case Some(val):
                match val:
                    case bool as b:
                        list_changed = b
                    case _:
                        pass
            case nil:
                pass

        return ResourceCapabilities.new(subscribe, list_changed)

# Tool capabilities
pub class ToolCapabilities:
    pub list_changed: bool

    static fn new(list_changed: bool) -> ToolCapabilities:
        return ToolCapabilities(list_changed: list_changed)

    static fn default() -> ToolCapabilities:
        return ToolCapabilities.new(false)

    static fn full() -> ToolCapabilities:
        return ToolCapabilities.new(true)

    pub fn to_dict() -> Dict<text, Any>:
        return {"listChanged": self.list_changed}

    static fn from_dict(dict: Dict<text, Any>) -> ToolCapabilities:
        var list_changed = false
        match dict.get("listChanged"):
            case Some(val):
                match val:
                    case bool as b:
                        list_changed = b
                    case _:
                        pass
            case nil:
                pass
        return ToolCapabilities.new(list_changed)

# Prompt capabilities
pub class PromptCapabilities:
    pub list_changed: bool

    static fn new(list_changed: bool) -> PromptCapabilities:
        return PromptCapabilities(list_changed: list_changed)

    static fn default() -> PromptCapabilities:
        return PromptCapabilities.new(false)

    static fn full() -> PromptCapabilities:
        return PromptCapabilities.new(true)

    pub fn to_dict() -> Dict<text, Any>:
        return {"listChanged": self.list_changed}

    static fn from_dict(dict: Dict<text, Any>) -> PromptCapabilities:
        var list_changed = false
        match dict.get("listChanged"):
            case Some(val):
                match val:
                    case bool as b:
                        list_changed = b
                    case _:
                        pass
            case nil:
                pass
        return PromptCapabilities.new(list_changed)

# Logging capabilities
pub class LoggingCapabilities:
    # Empty for now, presence indicates logging is supported

    static fn new() -> LoggingCapabilities:
        return LoggingCapabilities()

    static fn default() -> LoggingCapabilities:
        return LoggingCapabilities.new()

    pub fn to_dict() -> Dict<text, Any>:
        return {}

    static fn from_dict(dict: Dict<text, Any>) -> LoggingCapabilities:
        return LoggingCapabilities.new()

# Negotiated capabilities after initialize handshake
pub class NegotiatedCapabilities:
    pub client: ClientCapabilities
    pub server: ServerCapabilities
    pub protocol_version: text

    static fn new(client: ClientCapabilities, server: ServerCapabilities, version: text) -> NegotiatedCapabilities:
        return NegotiatedCapabilities(
            client: client,
            server: server,
            protocol_version: version
        )

    # Check if a feature is available (both sides support it)
    pub fn can_subscribe_resources() -> bool:
        return self.server.supports_resource_subscribe()

    pub fn can_use_roots() -> bool:
        return self.client.has_roots()

    pub fn can_use_sampling() -> bool:
        return self.client.has_sampling()

    pub fn can_notify_resource_changes() -> bool:
        return self.server.supports_resource_list_changed() and
               self.client.supports_list_changed()

    pub fn can_notify_tool_changes() -> bool:
        return self.server.supports_tool_list_changed()

    pub fn can_notify_prompt_changes() -> bool:
        return self.server.supports_prompt_list_changed()

# Capability negotiator
pub class CapabilityNegotiator:
    pub server_capabilities: ServerCapabilities
    pub min_protocol_version: text
    pub max_protocol_version: text

    static fn new(server_caps: ServerCapabilities) -> CapabilityNegotiator:
        return CapabilityNegotiator(
            server_capabilities: server_caps,
            min_protocol_version: "2024-11-05",
            max_protocol_version: "2025-11-25"
        )

    # Negotiate capabilities with client
    pub fn negotiate(client_caps: ClientCapabilities, requested_version: text) -> Result<NegotiatedCapabilities, text>:
        # Validate protocol version
        if not self.is_version_supported(requested_version):
            return Err("Unsupported protocol version: {requested_version}")

        # Use the minimum of requested and max supported version
        val negotiated_version = self.negotiate_version(requested_version)

        return Ok(NegotiatedCapabilities.new(
            client_caps,
            self.server_capabilities,
            negotiated_version
        ))

    fn is_version_supported(version: text) -> bool:
        # Simple version comparison (versions are date-based: YYYY-MM-DD)
        return version >= self.min_protocol_version and
               version <= self.max_protocol_version

    fn negotiate_version(requested: text) -> text:
        if requested > self.max_protocol_version:
            return self.max_protocol_version
        return requested

# Initialize request/response types
pub class InitializeRequest:
    pub protocol_version: text
    pub capabilities: ClientCapabilities
    pub client_info: ClientInfo

    static fn new(version: text, caps: ClientCapabilities, info: ClientInfo) -> InitializeRequest:
        return InitializeRequest(
            protocol_version: version,
            capabilities: caps,
            client_info: info
        )

    pub fn to_dict() -> Dict<text, Any>:
        return {
            "protocolVersion": self.protocol_version,
            "capabilities": self.capabilities.to_dict(),
            "clientInfo": self.client_info.to_dict()
        }

    static fn from_dict(dict: Dict<text, Any>) -> InitializeRequest:
        var version = "2024-11-05"
        var caps = ClientCapabilities.new()
        var info = ClientInfo.new("unknown", "0.0.0")

        match dict.get("protocolVersion"):
            case Some(val):
                match val:
                    case text as v:
                        version = v
                    case _:
                        pass
            case nil:
                pass

        match dict.get("capabilities"):
            case Some(val):
                match val:
                    case Dict<text, Any> as caps_dict:
                        caps = ClientCapabilities.from_dict(caps_dict)
                    case _:
                        pass
            case nil:
                pass

        match dict.get("clientInfo"):
            case Some(val):
                match val:
                    case Dict<text, Any> as info_dict:
                        info = ClientInfo.from_dict(info_dict)
                    case _:
                        pass
            case nil:
                pass

        return InitializeRequest.new(version, caps, info)

pub class InitializeResponse:
    pub protocol_version: text
    pub capabilities: ServerCapabilities
    pub server_info: ServerInfo
    pub instructions: Option<text>

    static fn new(version: text, caps: ServerCapabilities, info: ServerInfo) -> InitializeResponse:
        return InitializeResponse(
            protocol_version: version,
            capabilities: caps,
            server_info: info,
            instructions: nil
        )

    pub fn with_instructions(self, instructions: text) -> InitializeResponse:
        return InitializeResponse(
            protocol_version: self.protocol_version,
            capabilities: self.capabilities,
            server_info: self.server_info,
            instructions: Some(instructions)
        )

    pub fn to_dict() -> Dict<text, Any>:
        var result: Dict<text, Any> = {
            "protocolVersion": self.protocol_version,
            "capabilities": self.capabilities.to_dict(),
            "serverInfo": self.server_info.to_dict()
        }

        match self.instructions:
            case Some(inst):
                result.set("instructions", inst)
            case nil:
                pass

        return result

# Client info
pub class ClientInfo:
    pub name: text
    pub version: text

    static fn new(name: text, version: text) -> ClientInfo:
        return ClientInfo(name: name, version: version)

    pub fn to_dict() -> Dict<text, Any>:
        return {
            "name": self.name,
            "version": self.version
        }

    static fn from_dict(dict: Dict<text, Any>) -> ClientInfo:
        var name = "unknown"
        var version = "0.0.0"

        match dict.get("name"):
            case Some(val):
                match val:
                    case text as n:
                        name = n
                    case _:
                        pass
            case nil:
                pass

        match dict.get("version"):
            case Some(val):
                match val:
                    case text as v:
                        version = v
                    case _:
                        pass
            case nil:
                pass

        return ClientInfo.new(name, version)

# Server info
pub class ServerInfo:
    pub name: text
    pub version: text

    static fn new(name: text, version: text) -> ServerInfo:
        return ServerInfo(name: name, version: version)

    pub fn to_dict() -> Dict<text, Any>:
        return {
            "name": self.name,
            "version": self.version
        }

    static fn from_dict(dict: Dict<text, Any>) -> ServerInfo:
        var name = "unknown"
        var version = "0.0.0"

        match dict.get("name"):
            case Some(val):
                match val:
                    case text as n:
                        name = n
                    case _:
                        pass
            case nil:
                pass

        match dict.get("version"):
            case Some(val):
                match val:
                    case text as v:
                        version = v
                    case _:
                        pass
            case nil:
                pass

        return ServerInfo.new(name, version)
