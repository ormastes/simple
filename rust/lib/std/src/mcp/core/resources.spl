# MCP Resource Manager
# Full resource management with subscription support
# Follows MCP specification 2025-11-25

use core.*
use std.mcp.core.protocol.*
use std.mcp.core.pagination.*
use std.mcp.core.logger.*
use std.mcp.core.error_handler.*

# Resource subscription callback
pub trait ResourceSubscriber:
    # Called when a subscribed resource changes
    fn on_resource_changed(uri: text)

    # Called when a subscribed resource is deleted
    fn on_resource_deleted(uri: text)

    # Get subscriber ID
    fn subscriber_id() -> text

# Resource subscription
pub class ResourceSubscription:
    pub subscriber_id: text
    pub uri: text
    pub created_at: i64

    static fn new(subscriber_id: text, uri: text) -> ResourceSubscription:
        return ResourceSubscription(
            subscriber_id: subscriber_id,
            uri: uri,
            created_at: current_time_ms()
        )

# Resource change event
pub enum ResourceChangeType:
    Created
    Updated
    Deleted

    pub fn to_string() -> text:
        match self:
            case Created: "created"
            case Updated: "updated"
            case Deleted: "deleted"

pub class ResourceChange:
    pub uri: text
    pub change_type: ResourceChangeType
    pub timestamp: i64

    static fn created(uri: text) -> ResourceChange:
        return ResourceChange(
            uri: uri,
            change_type: ResourceChangeType.Created,
            timestamp: current_time_ms()
        )

    static fn updated(uri: text) -> ResourceChange:
        return ResourceChange(
            uri: uri,
            change_type: ResourceChangeType.Updated,
            timestamp: current_time_ms()
        )

    static fn deleted(uri: text) -> ResourceChange:
        return ResourceChange(
            uri: uri,
            change_type: ResourceChangeType.Deleted,
            timestamp: current_time_ms()
        )

# Resource provider trait (interface for resource sources)
pub trait ResourceProvider:
    # List all resources (may be filtered)
    fn list_resources() -> List<Resource>

    # Read a specific resource
    fn read_resource(uri: text) -> Option<ResourceContents>

    # Check if resource exists
    fn resource_exists(uri: text) -> bool

    # Get resource metadata
    fn get_resource_metadata(uri: text) -> Option<ResourceMetadata>

# Resource metadata
pub class ResourceMetadata:
    pub uri: text
    pub name: text
    pub description: text
    pub mime_type: text
    pub size: Option<i64>
    pub modified_at: Option<i64>
    pub created_at: Option<i64>
    pub annotations: Dict<text, text>

    static fn new(uri: text, name: text, mime_type: text) -> ResourceMetadata:
        return ResourceMetadata(
            uri: uri,
            name: name,
            description: "",
            mime_type: mime_type,
            size: nil,
            modified_at: nil,
            created_at: nil,
            annotations: {}
        )

    pub fn with_description(self, desc: text) -> ResourceMetadata:
        return ResourceMetadata(
            uri: self.uri,
            name: self.name,
            description: desc,
            mime_type: self.mime_type,
            size: self.size,
            modified_at: self.modified_at,
            created_at: self.created_at,
            annotations: self.annotations
        )

    pub fn with_size(self, size: i64) -> ResourceMetadata:
        return ResourceMetadata(
            uri: self.uri,
            name: self.name,
            description: self.description,
            mime_type: self.mime_type,
            size: Some(size),
            modified_at: self.modified_at,
            created_at: self.created_at,
            annotations: self.annotations
        )

    pub fn to_resource() -> Resource:
        return Resource(
            uri: self.uri,
            name: self.name,
            description: self.description,
            mime_type: self.mime_type
        )

# Resource manager with full subscription support
pub class ResourceManager:
    pub providers: List<ResourceProvider>
    pub subscriptions: Dict<text, List<ResourceSubscription>>  # uri -> subscriptions
    pub subscribers: Dict<text, ResourceSubscriber>            # subscriber_id -> subscriber
    pub change_log: List<ResourceChange>
    pub max_change_log_size: i64
    pub pagination_config: PaginationConfig
    pub debug_mode: bool

    static fn new() -> ResourceManager:
        return ResourceManager(
            providers: [],
            subscriptions: {},
            subscribers: {},
            change_log: [],
            max_change_log_size: 1000,
            pagination_config: PaginationConfig.new(),
            debug_mode: false
        )

    pub me enable_debug():
        self.debug_mode = true

    fn log_debug(msg: text):
        if self.debug_mode:
            log_debug("ResourceManager: {msg}")

    # Register a resource provider
    pub me register_provider(provider: ResourceProvider):
        self.providers.append(provider)
        self.log_debug("Registered provider")

    # List all resources with pagination
    pub fn list_resources(cursor: Option<text>) -> PaginatedResponse<Resource>:
        var all_resources: List<Resource> = []

        # Collect from all providers
        for provider in self.providers:
            val resources = provider.list_resources()
            for res in resources:
                all_resources.append(res)

        return paginate_resources(all_resources, cursor, self.pagination_config.default_page_size)

    # Read a resource
    pub fn read_resource(uri: text) -> Result<ResourceContents, McpError>:
        self.log_debug("Reading resource: {uri}")

        for provider in self.providers:
            match provider.read_resource(uri):
                case Some(contents):
                    return Ok(contents)
                case nil:
                    continue

        return Err(McpError.new(
            ErrorCategory.Resource,
            "Resource not found: {uri}",
            -32602
        ))

    # Check if resource exists
    pub fn exists(uri: text) -> bool:
        for provider in self.providers:
            if provider.resource_exists(uri):
                return true
        return false

    # Subscribe to resource changes
    pub me subscribe(uri: text, subscriber: ResourceSubscriber) -> Result<(), McpError>:
        val subscriber_id = subscriber.subscriber_id()
        self.log_debug("Subscribe: uri={uri}, subscriber={subscriber_id}")

        # Check if resource exists
        if not self.exists(uri):
            return Err(McpError.new(
                ErrorCategory.Resource,
                "Cannot subscribe to non-existent resource: {uri}",
                -32602
            ))

        # Register subscriber if not already registered
        if not self.subscribers.has_key(subscriber_id):
            self.subscribers.set(subscriber_id, subscriber)

        # Add subscription
        val subscription = ResourceSubscription.new(subscriber_id, uri)

        match self.subscriptions.get(uri):
            case Some(subs):
                # Check for duplicate subscription
                var already_subscribed = false
                for sub in subs:
                    if sub.subscriber_id == subscriber_id:
                        already_subscribed = true
                        break

                if not already_subscribed:
                    subs.append(subscription)
                    self.subscriptions.set(uri, subs)
            case nil:
                self.subscriptions.set(uri, [subscription])

        return Ok(())

    # Unsubscribe from resource changes
    pub me unsubscribe(uri: text, subscriber_id: text) -> Result<(), McpError>:
        self.log_debug("Unsubscribe: uri={uri}, subscriber={subscriber_id}")

        match self.subscriptions.get(uri):
            case Some(subs):
                var new_subs: List<ResourceSubscription> = []
                for sub in subs:
                    if sub.subscriber_id != subscriber_id:
                        new_subs.append(sub)

                if new_subs.len() > 0:
                    self.subscriptions.set(uri, new_subs)
                else:
                    self.subscriptions.remove(uri)

                return Ok(())
            case nil:
                return Err(McpError.new(
                    ErrorCategory.Resource,
                    "No subscription found for uri: {uri}",
                    -32602
                ))

    # Notify subscribers of resource change
    pub me notify_changed(uri: text):
        self.log_debug("Resource changed: {uri}")
        self.record_change(ResourceChange.updated(uri))
        self.notify_subscribers(uri, ResourceChangeType.Updated)

    # Notify subscribers of resource creation
    pub me notify_created(uri: text):
        self.log_debug("Resource created: {uri}")
        self.record_change(ResourceChange.created(uri))
        self.notify_subscribers(uri, ResourceChangeType.Created)

    # Notify subscribers of resource deletion
    pub me notify_deleted(uri: text):
        self.log_debug("Resource deleted: {uri}")
        self.record_change(ResourceChange.deleted(uri))
        self.notify_subscribers(uri, ResourceChangeType.Deleted)

        # Remove all subscriptions for this resource
        self.subscriptions.remove(uri)

    fn notify_subscribers(uri: text, change_type: ResourceChangeType):
        match self.subscriptions.get(uri):
            case Some(subs):
                for sub in subs:
                    match self.subscribers.get(sub.subscriber_id):
                        case Some(subscriber):
                            match change_type:
                                case ResourceChangeType.Deleted:
                                    subscriber.on_resource_deleted(uri)
                                case _:
                                    subscriber.on_resource_changed(uri)
                        case nil:
                            pass
            case nil:
                pass

    me record_change(change: ResourceChange):
        self.change_log.append(change)

        # Trim change log if too large
        if self.change_log.len() > self.max_change_log_size:
            self.change_log = self.change_log.slice(self.change_log.len() - self.max_change_log_size)

    # Get recent changes
    pub fn get_recent_changes(since: i64) -> List<ResourceChange>:
        var result: List<ResourceChange> = []
        for change in self.change_log:
            if change.timestamp >= since:
                result.append(change)
        return result

    # Get subscriptions for a resource
    pub fn get_subscriptions(uri: text) -> List<ResourceSubscription>:
        match self.subscriptions.get(uri):
            case Some(subs): subs
            case nil: []

    # Get all subscribed URIs for a subscriber
    pub fn get_subscriber_uris(subscriber_id: text) -> List<text>:
        var result: List<text> = []
        for uri in self.subscriptions.keys():
            match self.subscriptions.get(uri):
                case Some(subs):
                    for sub in subs:
                        if sub.subscriber_id == subscriber_id:
                            result.append(uri)
                            break
                case nil:
                    pass
        return result

    # Unsubscribe all for a subscriber (e.g., when client disconnects)
    pub me unsubscribe_all(subscriber_id: text):
        self.log_debug("Unsubscribe all for: {subscriber_id}")

        var uris_to_update: List<text> = []
        for uri in self.subscriptions.keys():
            uris_to_update.append(uri)

        for uri in uris_to_update:
            match self.subscriptions.get(uri):
                case Some(subs):
                    var new_subs: List<ResourceSubscription> = []
                    for sub in subs:
                        if sub.subscriber_id != subscriber_id:
                            new_subs.append(sub)

                    if new_subs.len() > 0:
                        self.subscriptions.set(uri, new_subs)
                    else:
                        self.subscriptions.remove(uri)
                case nil:
                    pass

        self.subscribers.remove(subscriber_id)

# Simple in-memory resource provider
pub class InMemoryResourceProvider:
    pub resources: Dict<text, ResourceContents>
    pub metadata: Dict<text, ResourceMetadata>

    static fn new() -> InMemoryResourceProvider:
        return InMemoryResourceProvider(
            resources: {},
            metadata: {}
        )

    pub me add_resource(meta: ResourceMetadata, contents: ResourceContents):
        self.resources.set(meta.uri, contents)
        self.metadata.set(meta.uri, meta)

    pub me remove_resource(uri: text):
        self.resources.remove(uri)
        self.metadata.remove(uri)

    pub me update_resource(uri: text, contents: ResourceContents):
        self.resources.set(uri, contents)
        # Update modification time
        match self.metadata.get(uri):
            case Some(meta):
                val new_meta = ResourceMetadata(
                    uri: meta.uri,
                    name: meta.name,
                    description: meta.description,
                    mime_type: meta.mime_type,
                    size: Some(contents.text.len()),
                    modified_at: Some(current_time_ms()),
                    created_at: meta.created_at,
                    annotations: meta.annotations
                )
                self.metadata.set(uri, new_meta)
            case nil:
                pass

impl ResourceProvider for InMemoryResourceProvider:
    fn list_resources() -> List<Resource>:
        var result: List<Resource> = []
        for uri in self.metadata.keys():
            match self.metadata.get(uri):
                case Some(meta):
                    result.append(meta.to_resource())
                case nil:
                    pass
        return result

    fn read_resource(uri: text) -> Option<ResourceContents>:
        return self.resources.get(uri)

    fn resource_exists(uri: text) -> bool:
        return self.resources.has_key(uri)

    fn get_resource_metadata(uri: text) -> Option<ResourceMetadata>:
        return self.metadata.get(uri)

# File system resource provider
pub class FileSystemResourceProvider:
    pub root_path: text
    pub file_extensions: List<text>
    pub max_file_size: i64

    static fn new(root_path: text) -> FileSystemResourceProvider:
        return FileSystemResourceProvider(
            root_path: root_path,
            file_extensions: [".spl", ".rs", ".py", ".js", ".ts", ".md", ".txt"],
            max_file_size: 10_000_000  # 10MB
        )

    pub fn with_extensions(self, extensions: List<text>) -> FileSystemResourceProvider:
        return FileSystemResourceProvider(
            root_path: self.root_path,
            file_extensions: extensions,
            max_file_size: self.max_file_size
        )

    fn file_uri(path: text) -> text:
        return "file://{path}"

    fn uri_to_path(uri: text) -> Option<text>:
        if uri.starts_with("file://"):
            return Some(uri.substring(7))
        return nil

impl ResourceProvider for FileSystemResourceProvider:
    fn list_resources() -> List<Resource>:
        var result: List<Resource> = []
        # Would use file system operations in real implementation
        # For now, return empty list
        return result

    fn read_resource(uri: text) -> Option<ResourceContents>:
        match self.uri_to_path(uri):
            case Some(path):
                # Would read file in real implementation
                return nil
            case nil:
                return nil

    fn resource_exists(uri: text) -> bool:
        match self.uri_to_path(uri):
            case Some(path):
                # Would check file exists in real implementation
                return false
            case nil:
                return false

    fn get_resource_metadata(uri: text) -> Option<ResourceMetadata>:
        match self.uri_to_path(uri):
            case Some(path):
                # Would get file metadata in real implementation
                return nil
            case nil:
                return nil

# Helper function
fn current_time_ms() -> i64:
    return time_now_ms()

extern fn time_now_ms() -> i64
