# SmallVec - Stack-allocated small vector
#
# A vector that stores small numbers of elements inline on the stack,
# only spilling to heap allocation when capacity is exceeded.

# Small vector with inline storage for up to N elements
struct SmallVec<T, const N: i32>:
    inline_data: [T; N]
    heap_data: Option<List<T>>
    len: i32
    inline_capacity: i32

    static fn new() -> SmallVec<T, N>:
        return SmallVec(
            inline_data: [T; N].default(),
            heap_data: Option.none(),
            len: 0,
            inline_capacity: N
        )

    static fn with_capacity(capacity: i32) -> SmallVec<T, N>:
        if capacity <= N:
            return SmallVec.new()
        return SmallVec(
            inline_data: [T; N].default(),
            heap_data: Option.some(List.with_capacity(capacity)),
            len: 0,
            inline_capacity: N
        )

    fn len() -> i32:
        return self.len

    fn capacity() -> i32:
        match self.heap_data:
            Option.Some(list):
                return list.capacity()
            nil:
                return self.inline_capacity

    fn is_empty() -> bool:
        return self.len == 0

    fn is_inline() -> bool:
        return self.heap_data.is_none()

    me push(value: T):
        if self.heap_data.is_some():
            self.heap_data.unwrap().push(value)
            self.len = self.len + 1
        elif self.len < self.inline_capacity:
            self.inline_data[self.len] = value
            self.len = self.len + 1
        else:
            # Spill to heap
            var list: List<T> = []
            for i in 0..self.len:
                list.push(self.inline_data[i])
            list.push(value)
            self.heap_data = Option.some(list)
            self.len = self.len + 1

    fn pop() -> Option<T>:
        if self.len == 0:
            return Option.none()
        self.len = self.len - 1
        match self.heap_data:
            Option.Some(list):
                return list.pop()
            nil:
                return Option.some(self.inline_data[self.len])

    fn get(index: i32) -> Option<T>:
        if index < 0 or index >= self.len:
            return Option.none()
        match self.heap_data:
            Option.Some(list):
                return Option.some(list[index])
            nil:
                return Option.some(self.inline_data[index])

    fn first() -> Option<T>:
        return self.get(0)

    fn last() -> Option<T>:
        if self.len == 0:
            return Option.none()
        return self.get(self.len - 1)

    me clear():
        self.len = 0
        self.heap_data = Option.none()

    fn to_list() -> List<T>:
        var result: List<T> = []
        for i in 0..self.len:
            match self.get(i):
                Option.Some(v):
                    result.push(v)
                nil:
                    pass
        return result

# Common type aliases
type SmallVec4<T> = SmallVec<T, 4>
type SmallVec8<T> = SmallVec<T, 8>
type SmallVec16<T> = SmallVec<T, 16>
type SmallVec32<T> = SmallVec<T, 32>

export SmallVec, SmallVec4, SmallVec8, SmallVec16, SmallVec32
