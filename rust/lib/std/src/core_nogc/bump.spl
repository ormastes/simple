# Bump Allocator - Simple, fast, linear allocator
# Allocations cannot be freed individually; only the entire allocator can be reset

use units.size.*

# Bump allocator for fast sequential allocations
pub struct BumpAllocator:
    start: *mut u8
    end: *mut u8
    ptr: *mut u8
    owned: bool

impl BumpAllocator:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_empty(self) -> bool:
        """Check if no allocations have been made."""
        self.ptr == self.start

    pub fn is_full(self) -> bool:
        """Check if no space remaining."""
        self.ptr >= self.end

    pub fn utilization(self) -> f64:
        """Calculate allocator utilization (0.0 to 1.0)."""
        val cap = self.capacity() as u64
        if cap > 0:
            (self.used() as u64) as f64 / cap as f64
        else:
            0.0

    pub fn is_owned(self) -> bool:
        """Check if allocator owns its memory (will free on drop)."""
        self.owned

    pub fn has_space_for(self, size: ByteCount, align: u64) -> bool:
        """Check if allocation would fit (alias for can_alloc)."""
        self.can_alloc(size, align)

    pub fn available(self) -> ByteCount:
        """Get available bytes (alias for remaining)."""
        self.remaining()

    pub fn wasted(self) -> ByteCount:
        """Get wasted bytes due to alignment padding."""
        # In a bump allocator, wasted space is minimal (only alignment padding)
        # This is a conservative estimate
        val cap = self.capacity() as u64
        val used = self.used() as u64
        val rem = self.remaining() as u64
        if cap > (used + rem):
            (cap - used - rem)_bytes
        else:
            0_bytes

    pub fn summary(self) -> text:
        """Get summary of bump allocator state."""
        val util = (self.utilization() * 100.0) as u64
        val ownership = if self.owned: "owned" else: "borrowed"
        return "BumpAllocator: {self.used()}/{self.capacity()} ({util}% used, {ownership})"

    # =========================================================================
    # Constructor
    # =========================================================================

    # Create bump allocator with given capacity
    pub fn new(capacity: ByteCount) -> BumpAllocator:
        val size = capacity as u64
        val start = native_alloc(size, 16)
        return BumpAllocator {
            start: start,
            end: start.offset(size as isize),
            ptr: start,
            owned: true
        }

    # Create bump allocator from existing buffer (doesn't own memory)
    pub fn from_buffer(buffer: *mut u8, size: ByteCount) -> BumpAllocator:
        return BumpAllocator {
            start: buffer,
            end: buffer.offset((size as u64) as isize),
            ptr: buffer,
            owned: false
        }

    # Allocate memory
    pub fn alloc(self, size: ByteCount, align: u64) -> Option<*mut u8>:
        val current = self.ptr as u64
        val aligned = (current + align - 1) & ~(align - 1)
        val new_ptr = aligned + (size as u64)

        if new_ptr > self.end as u64:
            return None

        self.ptr = new_ptr as *mut u8
        return Some(aligned as *mut u8)

    # Allocate and zero memory
    pub fn alloc_zeroed(self, size: ByteCount, align: u64) -> Option<*mut u8>:
        match self.alloc(size, align):
            case Some(ptr):
                native_memset(ptr, 0, size as u64)
                return Some(ptr)
            case None:
                return None

    # Allocate typed value
    pub fn alloc_val<T>(self) -> Option<*mut T>:
        val size = size_of<T>()_bytes
        val align = align_of<T>()
        match self.alloc(size, align):
            case Some(ptr): return Some(ptr as *mut T)
            case None: return None

    # Allocate and initialize typed value
    pub fn alloc_init<T>(self, value: T) -> Option<*mut T>:
        match self.alloc_val<T>():
            case Some(ptr):
                *ptr = value
                return Some(ptr)
            case None:
                return None

    # Allocate array
    pub fn alloc_array<T>(self, count: u64) -> Option<*mut T>:
        val size = (size_of<T>() * count)_bytes
        val align = align_of<T>()
        match self.alloc(size, align):
            case Some(ptr): return Some(ptr as *mut T)
            case None: return None

    # Allocate slice (array with known length)
    pub fn alloc_slice<T>(self, count: u64) -> Option<&mut <T>>:
        match self.alloc_array<T>(count):
            case Some(ptr):
                return Some(slice.from_raw_parts_mut(ptr, count))
            case None:
                return None

    # Allocate and copy slice
    pub fn alloc_slice_copy<T: Copy>(self, src: &<T>) -> Option<&mut <T>>:
        match self.alloc_slice<T>(src.len()):
            case Some(dst):
                for i in 0..src.len():
                    dst[i] = src[i]
                return Some(dst)
            case None:
                return None

    # Allocate string
    pub fn alloc_str(self, s: &str) -> Option<&str>:
        val len = s.len()
        match self.alloc((len)_bytes, 1):
            case Some(ptr):
                native_memcpy(ptr, s.as_ptr(), len)
                return Some(str.from_raw_parts(ptr, len))
            case None:
                return None

    # Get total capacity
    pub fn capacity(self) -> ByteCount:
        return ((self.end as u64) - (self.start as u64))_bytes

    # Get used bytes
    pub fn used(self) -> ByteCount:
        return ((self.ptr as u64) - (self.start as u64))_bytes

    # Get remaining bytes
    pub fn remaining(self) -> ByteCount:
        return ((self.end as u64) - (self.ptr as u64))_bytes

    # Check if allocation would fit
    pub fn can_alloc(self, size: ByteCount, align: u64) -> bool:
        val current = self.ptr as u64
        val aligned = (current + align - 1) & ~(align - 1)
        val new_ptr = aligned + (size as u64)
        return new_ptr <= self.end as u64

    # Reset allocator (invalidates all previous allocations!)
    pub fn reset(self):
        self.ptr = self.start

    # Create checkpoint for partial reset
    pub fn checkpoint(self) -> BumpCheckpoint:
        return BumpCheckpoint { ptr: self.ptr }

    # Reset to checkpoint
    pub fn reset_to(self, checkpoint: BumpCheckpoint):
        if checkpoint.ptr >= self.start and checkpoint.ptr <= self.ptr:
            self.ptr = checkpoint.ptr

    # Drop - free memory if owned
    fn drop():
        if self.owned:
            native_free(self.start)

# Checkpoint for partial reset
pub struct BumpCheckpoint:
    ptr: *mut u8

impl BumpCheckpoint:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn get_ptr(self) -> *mut u8:
        """Get the saved pointer."""
        self.ptr

    pub fn is_valid_for(self, allocator: &BumpAllocator) -> bool:
        """Check if this checkpoint is valid for the given allocator."""
        self.ptr >= allocator.start and self.ptr <= allocator.ptr

    pub fn summary(self) -> text:
        """Get summary of checkpoint."""
        return "BumpCheckpoint: ptr={self.ptr as u64}"

# Scoped bump allocator - resets on scope exit
pub struct ScopedBump:
    allocator: &mut BumpAllocator
    checkpoint: BumpCheckpoint

impl ScopedBump:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn get_checkpoint(self) -> &BumpCheckpoint:
        """Get the saved checkpoint (will be restored on drop)."""
        &self.checkpoint

    pub fn current_usage(self) -> ByteCount:
        """Get current allocator usage."""
        self.allocator.used()

    pub fn capacity(self) -> ByteCount:
        """Get allocator capacity."""
        self.allocator.capacity()

    pub fn remaining(self) -> ByteCount:
        """Get remaining bytes."""
        self.allocator.remaining()

    pub fn summary(self) -> text:
        """Get summary of scoped bump allocator."""
        return "ScopedBump: will restore to ptr={self.checkpoint.ptr as u64}, current usage={self.current_usage()}"

    # =========================================================================
    # Methods
    # =========================================================================

    pub fn new(allocator: &mut BumpAllocator) -> ScopedBump:
        return ScopedBump {
            allocator: allocator,
            checkpoint: allocator.checkpoint()
        }

    pub fn alloc(self, size: ByteCount, align: u64) -> Option<*mut u8>:
        return self.allocator.alloc(size, align)

    pub fn alloc_val<T>(self) -> Option<*mut T>:
        return self.allocator.alloc_val<T>()

    pub fn alloc_init<T>(self, value: T) -> Option<*mut T>:
        return self.allocator.alloc_init(value)

    fn drop():
        self.allocator.reset_to(self.checkpoint)

# Bump allocator pool - manages multiple bump allocators
pub struct BumpPool:
    allocators: Array<BumpAllocator>
    current: u64
    chunk_size: ByteCount

impl BumpPool:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_allocators(self) -> bool:
        """Check if any allocators exist."""
        self.allocators.len() > 0

    pub fn allocator_count(self) -> usize:
        """Get number of allocators."""
        self.allocators.len()

    pub fn is_empty(self) -> bool:
        """Check if no allocators exist."""
        self.allocators.len() == 0

    pub fn get_chunk_size(self) -> ByteCount:
        """Get default chunk size for new allocators."""
        self.chunk_size

    pub fn get_current_index(self) -> u64:
        """Get index of current allocator."""
        self.current

    pub fn total_capacity(self) -> ByteCount:
        """Get total capacity across all allocators."""
        var total: u64 = 0
        for alloc in &self.allocators:
            total = total + (alloc.capacity() as u64)
        return total_bytes

    pub fn total_used(self) -> ByteCount:
        """Get total used bytes across all allocators."""
        var total: u64 = 0
        for alloc in &self.allocators:
            total = total + (alloc.used() as u64)
        return total_bytes

    pub fn total_remaining(self) -> ByteCount:
        """Get total remaining bytes across all allocators."""
        var total: u64 = 0
        for alloc in &self.allocators:
            total = total + (alloc.remaining() as u64)
        return total_bytes

    pub fn utilization(self) -> f64:
        """Calculate overall pool utilization (0.0 to 1.0)."""
        val cap = self.total_capacity() as u64
        if cap > 0:
            (self.total_used() as u64) as f64 / cap as f64
        else:
            0.0

    pub fn summary(self) -> text:
        """Get summary of bump pool state."""
        val util = (self.utilization() * 100.0) as u64
        return "BumpPool: {self.total_used()}/{self.total_capacity()} ({util}% used), {self.allocator_count()} allocators, chunk_size={self.chunk_size}"

    # =========================================================================
    # Constructor
    # =========================================================================

    pub fn new(chunk_size: ByteCount) -> BumpPool:
        val pool = BumpPool {
            allocators: [],
            current: 0,
            chunk_size: chunk_size
        }
        pool.grow()
        return pool

    pub fn alloc(self, size: ByteCount, align: u64) -> *mut u8:
        # Try current allocator
        if self.current < self.allocators.len():
            match self.allocators[self.current].alloc(size, align):
                case Some(ptr): return ptr
                case None: pass

        # Try to find allocator with space
        for i in 0..self.allocators.len():
            if i != self.current:
                match self.allocators[i].alloc(size, align):
                    case Some(ptr):
                        self.current = i
                        return ptr
                    case None:
                        pass

        # Need new allocator
        val alloc_size = size.max(self.chunk_size)
        self.grow_with_size(alloc_size)
        return self.allocators[self.current].alloc(size, align).expect("fresh allocator should have space")

    pub fn reset(self):
        for alloc in &mut self.allocators:
            alloc.reset()
        self.current = 0

    fn grow():
        self.grow_with_size(self.chunk_size)

    fn grow_with_size(size: ByteCount):
        val allocator = BumpAllocator.new(size)
        self.allocators.push(allocator)
        self.current = self.allocators.len() - 1

# Native function declarations
extern fn native_alloc(size: u64, align: u64) -> *mut u8
extern fn native_free(ptr: *mut u8)
extern fn native_memset(ptr: *mut u8, value: u8, size: u64)
extern fn native_memcpy(dst: *mut u8, src: *const u8, size: u64)
extern fn size_of<T>() -> u64
extern fn align_of<T>() -> u64
