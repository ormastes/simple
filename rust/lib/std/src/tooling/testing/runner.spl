# Multi-Language Test Runner
# Run tests across all languages in a project

use tooling.core.project.{Language, ProjectContext, LanguageConfig}
use tooling.testing.discovery.{TestDiscovery, TestSuite}
use tooling.testing.aggregation.TestAggregator
use core.result.{Result, Ok, Err}

# Extern declaration for time FFI
extern fn rt_time_now_seconds() -> f64

# Test run configuration
pub class TestConfig:
    pub parallel: bool
    pub fail_fast: bool
    pub verbose: bool
    pub coverage: bool
    pub timeout_seconds: i32
    pub filter_pattern: text

    pub fn new() -> TestConfig:
        """Create default test configuration.

        Returns:
            Default test config
        """
        TestConfig {
            parallel: false,
            fail_fast: false,
            verbose: false,
            coverage: false,
            timeout_seconds: 300,  # 5 minutes
            filter_pattern: ""
        }

    pub fn with_parallel(self, enabled: bool) -> TestConfig:
        """Set parallel execution (fluent API).

        Args:
            enabled: True to run tests in parallel

        Returns:
            Modified config
        """
        self.parallel = enabled
        self

    pub fn with_fail_fast(self, enabled: bool) -> TestConfig:
        """Set fail-fast mode (fluent API).

        Args:
            enabled: True to stop on first failure

        Returns:
            Modified config
        """
        self.fail_fast = enabled
        self

    pub fn with_verbose(self, enabled: bool) -> TestConfig:
        """Set verbose output (fluent API).

        Args:
            enabled: True for detailed logs

        Returns:
            Modified config
        """
        self.verbose = enabled
        self

    pub fn with_coverage(self, enabled: bool) -> TestConfig:
        """Set coverage collection (fluent API).

        Args:
            enabled: True to collect coverage

        Returns:
            Modified config
        """
        self.coverage = enabled
        self

    pub fn with_timeout(self, seconds: i32) -> TestConfig:
        """Set timeout (fluent API).

        Args:
            seconds: Timeout in seconds

        Returns:
            Modified config
        """
        self.timeout_seconds = seconds
        self

    pub fn with_filter(self, pattern: text) -> TestConfig:
        """Set filter pattern (fluent API).

        Args:
            pattern: Filter pattern

        Returns:
            Modified config
        """
        self.filter_pattern = pattern
        self

    pub fn is_parallel(self) -> bool:
        """Check if parallel execution enabled.

        Returns:
            True if parallel
        """
        self.parallel

    pub fn has_filter(self) -> bool:
        """Check if filter is set.

        Returns:
            True if filter pattern exists
        """
        self.filter_pattern != ""

# Test run result
pub class TestRunResult:
    pub total_tests: i32
    pub passed: i32
    pub failed: i32
    pub skipped: i32
    pub duration_ms: i64
    pub failures: List<TestFailure>

    pub fn new() -> TestRunResult:
        """Create empty test result."""
        TestRunResult {
            total_tests: 0,
            passed: 0,
            failed: 0,
            skipped: 0,
            duration_ms: 0,
            failures: []
        }

    pub fn is_success(self) -> bool:
        """Check if all tests passed.

        Returns:
            True if no failures
        """
        self.failed == 0

    pub fn summary(self) -> text:
        """Get result summary.

        Returns:
            Human-readable summary
        """
        if self.is_success():
            "✓ {self.passed}/{self.total_tests} tests passed in {self.duration_ms}ms"
        else:
            "✗ {self.failed}/{self.total_tests} tests failed, {self.passed} passed, {self.skipped} skipped"

    pub fn pass_rate(self) -> f64:
        """Get pass rate as percentage.

        Returns:
            Pass rate (0.0 to 100.0)

        Example:
            result.pass_rate()  # → 85.5 (85.5% of tests passed)
        """
        if self.total_tests == 0:
            return 0.0
        ((self.passed as f64) / (self.total_tests as f64)) * 100.0

    pub fn failure_rate(self) -> f64:
        """Get failure rate as percentage.

        Returns:
            Failure rate (0.0 to 100.0)
        """
        if self.total_tests == 0:
            return 0.0
        ((self.failed as f64) / (self.total_tests as f64)) * 100.0

    pub fn duration_seconds(self) -> f64:
        """Get duration in seconds.

        Returns:
            Duration in seconds
        """
        (self.duration_ms as f64) / 1000.0

    pub fn has_failures(self) -> bool:
        """Check if there are test failures.

        Returns:
            True if any tests failed
        """
        self.failed > 0

    pub fn has_skipped(self) -> bool:
        """Check if there are skipped tests.

        Returns:
            True if any tests skipped
        """
        self.skipped > 0

    pub fn get_failure_count(self) -> i32:
        """Get number of failures.

        Returns:
            Failure count
        """
        self.failures.len()

# Test failure
pub class TestFailure:
    pub test_name: text
    pub language: Language
    pub error_message: text
    pub file: text
    pub line: i32

    pub fn new(
        test_name: text,
        language: Language,
        error_message: text
    ) -> TestFailure:
        """Create test failure.

        Args:
            test_name: Name of failed test
            language: Test language
            error_message: Failure message

        Returns:
            Test failure instance
        """
        TestFailure {
            test_name: test_name,
            language: language,
            error_message: error_message,
            file: "",
            line: 0
        }

    pub fn format(self) -> text:
        """Format failure for display.

        Returns:
            Formatted failure string

        Example:
            failure.format()
            # → "test_user_login failed: Expected 200, got 404"
        """
        "{self.test_name} failed: {self.error_message}"

    pub fn format_with_location(self) -> text:
        """Format failure with file location.

        Returns:
            Formatted failure with location

        Example:
            failure.format_with_location()
            # → "test_user_login (src/auth_test.spl:42): Expected 200, got 404"
        """
        if self.file != "" and self.line > 0:
            "{self.test_name} ({self.file}:{self.line}): {self.error_message}"
        else:
            self.format()

    pub fn has_location(self) -> bool:
        """Check if failure has location information.

        Returns:
            True if file and line are set
        """
        self.file != "" and self.line > 0

# Multi-language test runner
pub class TestRunner:
    pub project: ProjectContext
    pub config: TestConfig
    pub discovery: TestDiscovery

    pub fn new(root: text) -> TestRunner:
        """Create test runner for project.

        Args:
            root: Project root directory

        Returns:
            Test runner with auto-detected test suites

        Example:
            val runner = TestRunner.new(".")

            val result = runner.run_all(
                parallel: true,
                verbose: true
            )

            print(result.summary())
        """
        val project = ProjectContext.new(root)
        val discovery = TestDiscovery.new(root)

        TestRunner {
            project: project,
            config: TestConfig.new(),
            discovery: discovery
        }

    pub fn set_parallel(self, enabled: bool):
        """Enable parallel test execution.

        Args:
            enabled: True to run tests in parallel
        """
        self.config.parallel = enabled

    pub fn set_fail_fast(self, enabled: bool):
        """Enable fail-fast mode.

        Args:
            enabled: True to stop on first failure
        """
        self.config.fail_fast = enabled

    pub fn set_verbose(self, enabled: bool):
        """Enable verbose output.

        Args:
            enabled: True for detailed logs
        """
        self.config.verbose = enabled

    pub fn set_coverage(self, enabled: bool):
        """Enable coverage collection.

        Args:
            enabled: True to collect coverage
        """
        self.config.coverage = enabled

    pub fn discover_tests(self) -> List<TestSuite>:
        """Discover all test suites in project.

        Returns:
            List of test suites

        Example:
            val runner = TestRunner.new(".")
            val suites = runner.discover_tests()

            for suite in suites:
                print("{suite.language}: {suite.test_count} tests")
        """
        self.discovery.discover_all()

    pub fn run_all(
        self,
        parallel: bool,
        fail_fast: bool,
        verbose: bool
    ) -> TestRunResult:
        """Run all tests in project.

        Args:
            parallel: Run tests in parallel
            fail_fast: Stop on first failure
            verbose: Enable verbose output

        Returns:
            Test run result

        Example:
            val result = runner.run_all(
                parallel: true,
                fail_fast: false,
                verbose: true
            )

            if result.is_success():
                print("All tests passed!")
            else:
                for failure in result.failures:
                    print("Failed: {failure.test_name}")
                    print("  {failure.error_message}")
        """
        self.config.parallel = parallel
        self.config.fail_fast = fail_fast
        self.config.verbose = verbose

        val result = TestRunResult.new()
        val start_time = self.get_time_ms()

        if verbose:
            print("Running tests...")

        # Discover test suites
        val suites = self.discover_tests()

        if verbose:
            print("Found {suites.len()} test suites")

        # Run each test suite
        for suite in suites:
            if verbose:
                print("Running {suite.language} tests...")

            val suite_result = self.run_suite(suite)

            # Aggregate results
            result.total_tests += suite_result.total_tests
            result.passed += suite_result.passed
            result.failed += suite_result.failed
            result.skipped += suite_result.skipped
            result.failures.extend(suite_result.failures)

            # Fail fast
            if fail_fast and suite_result.failed > 0:
                break

        val end_time = self.get_time_ms()
        result.duration_ms = end_time - start_time

        if verbose:
            print(result.summary())

        result

    fn get_time_ms() -> i64:
        """Get current time in milliseconds.

        Returns:
            Current timestamp in milliseconds
        """
        # Convert seconds to milliseconds
        (rt_time_now_seconds() * 1000.0) as i64

    fn run_suite(suite: TestSuite) -> TestRunResult:
        """Run single test suite.

        Args:
            suite: Test suite to run

        Returns:
            Test result for suite
        """
        match suite.language:
            Language.Simple:
                self.run_simple_tests(suite)
            Language.Rust:
                self.run_rust_tests(suite)
            Language.Python:
                self.run_python_tests(suite)
            Language.JavaScript:
                self.run_javascript_tests(suite)
            Language.TypeScript:
                self.run_javascript_tests(suite)  # Same runner
            _:
                # Unsupported language
                TestRunResult.new()

    fn run_simple_tests(suite: TestSuite) -> TestRunResult:
        """Run Simple language tests.

        Args:
            suite: Test suite

        Returns:
            Test result
        """
        @extern("runtime", "rt_process_run")
        fn _rt_process_run(cmd_ptr: &u8, cmd_len: u64, args_ptr: &u8, args_len: u64) -> (i32, text, text)

        val result = TestRunResult.new()
        result.language = Language.Simple

        # Execute Simple spec framework: simple test <path>
        val cmd = "simple"
        val args = "test {suite.path}"
        val (exit_code, stdout, stderr) = _rt_process_run(cmd.ptr(), cmd.len(), args.ptr(), args.len())

        # Parse output for test counts
        # Expected format: "X tests passed, Y failed, Z skipped"
        for line in stdout.lines():
            if line.contains("tests passed") or line.contains("test passed"):
                val parts = line.split(",")
                for part in parts:
                    val trimmed = part.trim()
                    if trimmed.contains("passed"):
                        val num = trimmed.split(" ")[0]
                        result.passed = num.parse_i32().unwrap_or(0)
                    elif trimmed.contains("failed"):
                        val num = trimmed.split(" ")[0]
                        result.failed = num.parse_i32().unwrap_or(0)
                    elif trimmed.contains("skipped"):
                        val num = trimmed.split(" ")[0]
                        result.skipped = num.parse_i32().unwrap_or(0)

        result.total_tests = result.passed + result.failed + result.skipped
        result.exit_code = exit_code
        result

    fn run_rust_tests(suite: TestSuite) -> TestRunResult:
        """Run Rust tests via cargo test.

        Args:
            suite: Test suite

        Returns:
            Test result
        """
        @extern("runtime", "rt_process_run")
        fn _rt_process_run(cmd_ptr: &u8, cmd_len: u64, args_ptr: &u8, args_len: u64) -> (i32, text, text)

        val result = TestRunResult.new()
        result.language = Language.Rust

        # Execute cargo test --manifest-path <path>
        val cmd = "cargo"
        val args = "test --manifest-path {suite.path}"
        val (exit_code, stdout, stderr) = _rt_process_run(cmd.ptr(), cmd.len(), args.ptr(), args.len())

        # Parse cargo test output
        # Format: "test result: ok. X passed; Y failed; Z ignored"
        for line in stdout.lines():
            if line.starts_with("test result:"):
                val parts = line.split(";")
                for part in parts:
                    val trimmed = part.trim()
                    if trimmed.contains("passed"):
                        val num = trimmed.split(" ")[0]
                        result.passed = num.parse_i32().unwrap_or(0)
                    elif trimmed.contains("failed"):
                        val num = trimmed.split(" ")[0]
                        result.failed = num.parse_i32().unwrap_or(0)
                    elif trimmed.contains("ignored"):
                        val num = trimmed.split(" ")[0]
                        result.skipped = num.parse_i32().unwrap_or(0)

        result.total_tests = result.passed + result.failed + result.skipped
        result.exit_code = exit_code
        result

    fn run_python_tests(suite: TestSuite) -> TestRunResult:
        """Run Python tests via pytest.

        Args:
            suite: Test suite

        Returns:
            Test result
        """
        import core.json.{parse, JsonValue}

        @extern("runtime", "rt_process_run")
        fn _rt_process_run(cmd_ptr: &u8, cmd_len: u64, args_ptr: &u8, args_len: u64) -> (i32, text, text)

        val result = TestRunResult.new()
        result.language = Language.Python

        # Execute pytest with JSON output
        val cmd = "pytest"
        val args = "{suite.path} --json-report --json-report-file=/dev/stdout -q"
        val (exit_code, stdout, stderr) = _rt_process_run(cmd.ptr(), cmd.len(), args.ptr(), args.len())

        # Parse pytest JSON report
        match parse(stdout):
            case Ok(JsonValue.Object(obj)):
                if val Some(JsonValue.Object(summary)) = obj.get("summary"):
                    if val Some(JsonValue.Number(passed)) = summary.get("passed"):
                        result.passed = passed as i32
                    if val Some(JsonValue.Number(failed)) = summary.get("failed"):
                        result.failed = failed as i32
                    if val Some(JsonValue.Number(skipped)) = summary.get("skipped"):
                        result.skipped = skipped as i32
            case _:
                # Fallback: parse plain text output
                for line in stdout.lines():
                    if line.contains("passed") or line.contains("failed"):
                        val parts = line.split(",")
                        for part in parts:
                            val trimmed = part.trim()
                            if trimmed.contains("passed"):
                                val num = trimmed.split(" ")[0]
                                result.passed = num.parse_i32().unwrap_or(0)
                            elif trimmed.contains("failed"):
                                val num = trimmed.split(" ")[0]
                                result.failed = num.parse_i32().unwrap_or(0)
                            elif trimmed.contains("skipped"):
                                val num = trimmed.split(" ")[0]
                                result.skipped = num.parse_i32().unwrap_or(0)

        result.total_tests = result.passed + result.failed + result.skipped
        result.exit_code = exit_code
        result

    fn run_javascript_tests(suite: TestSuite) -> TestRunResult:
        """Run JavaScript tests via jest.

        Args:
            suite: Test suite

        Returns:
            Test result
        """
        import core.json.{parse, JsonValue}

        @extern("runtime", "rt_process_run")
        fn _rt_process_run(cmd_ptr: &u8, cmd_len: u64, args_ptr: &u8, args_len: u64) -> (i32, text, text)

        val result = TestRunResult.new()
        result.language = Language.JavaScript

        # Execute jest with JSON output
        val cmd = "npx"
        val args = "jest {suite.path} --json"
        val (exit_code, stdout, stderr) = _rt_process_run(cmd.ptr(), cmd.len(), args.ptr(), args.len())

        # Parse jest JSON output
        # Format: {"numPassedTests": X, "numFailedTests": Y, "numPendingTests": Z, ...}
        match parse(stdout):
            case Ok(JsonValue.Object(obj)):
                if val Some(JsonValue.Number(passed)) = obj.get("numPassedTests"):
                    result.passed = passed as i32
                if val Some(JsonValue.Number(failed)) = obj.get("numFailedTests"):
                    result.failed = failed as i32
                if val Some(JsonValue.Number(pending)) = obj.get("numPendingTests"):
                    result.skipped = pending as i32
                if val Some(JsonValue.Number(total)) = obj.get("numTotalTests"):
                    result.total_tests = total as i32
            case _:
                # Jest output not parseable - use exit code
                if exit_code == 0:
                    result.passed = suite.test_count
                else:
                    result.failed = suite.test_count

        if result.total_tests == 0:
            result.total_tests = result.passed + result.failed + result.skipped

        result.exit_code = exit_code
        result

    pub fn run_by_language(self, language: Language) -> TestRunResult:
        """Run tests for specific language.

        Args:
            language: Language to run tests for

        Returns:
            Test result
        """
        val suites = self.discovery.discover_by_language(language)
        val result = TestRunResult.new()

        for suite in suites:
            val suite_result = self.run_suite(suite)

            result.total_tests += suite_result.total_tests
            result.passed += suite_result.passed
            result.failed += suite_result.failed
            result.skipped += suite_result.skipped
            result.failures.extend(suite_result.failures)

        result

    pub fn run_by_pattern(self, pattern: text) -> TestRunResult:
        """Run tests matching pattern.

        Args:
            pattern: Test name pattern

        Returns:
            Test result
        """
        val suites = self.discovery.discover_by_pattern(pattern)
        val result = TestRunResult.new()

        for suite in suites:
            val suite_result = self.run_suite(suite)

            result.total_tests += suite_result.total_tests
            result.passed += suite_result.passed
            result.failed += suite_result.failed
            result.skipped += suite_result.skipped
            result.failures.extend(suite_result.failures)

        result
