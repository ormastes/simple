# Lint configuration and level management
# Migrated from: src/compiler/src/lint/config.rs
# Purpose: Parse and manage lint configuration from simple.sdn files
#
# Note: Using List<(LintName, LintLevel)> instead of HashMap for lint level storage.
# This provides O(n) lookup but is sufficient for the small number of lints.

use fs.{read_text}

# ============================================================================
# AST Types (mirrors src/parser/src/ast/nodes/core.rs)
# ============================================================================

# Represents a source code location
struct Span:
    start: u64
    end: u64
    file: text

impl Span:
    static fn new(start: u64, end: u64, file: text) -> Span:
        Span(start: start, end: end, file: file)

    static fn empty() -> Span:
        Span(start: 0, end: 0, file: "")

# Attribute applied to an item: #[name] or #[name(args)]
# Examples:
#   #[allow(primitive_api)]
#   #[deny(bare_bool, todo_format)]
#   #[deprecated = "Use new_function instead"]
struct Attribute:
    span: Span
    name: text              # The attribute name (e.g., "allow", "deny", "warn")
    args: List<text>        # Arguments as identifiers: #[name(arg1, arg2)]
    value: Option<text>     # Optional value: #[name = "value"]

impl Attribute:
    # Create a simple attribute with just a name
    static fn simple(name: text) -> Attribute:
        Attribute(
            span: Span.empty(),
            name: name,
            args: [],
            value: None
        )

    # Create an attribute with arguments (e.g., #[allow(lint1, lint2)])
    static fn with_args(name: text, args: List<text>) -> Attribute:
        Attribute(
            span: Span.empty(),
            name: name,
            args: args,
            value: None
        )

    # Create an attribute with a value (e.g., #[deprecated = "message"])
    static fn with_value(name: text, value: text) -> Attribute:
        Attribute(
            span: Span.empty(),
            name: name,
            args: [],
            value: Some(value)
        )

    # Check if this is a lint-related attribute
    fn is_lint_attribute() -> bool:
        self.name == "allow" or self.name == "warn" or self.name == "deny"

# ============================================================================
# Lint Configuration
# ============================================================================

# Lint severity level
enum LintLevel:
    Allow    # Suppress the lint entirely
    Warn     # Emit a warning (default for most lints)
    Deny     # Treat as a compile error

impl LintLevel:
    # Parse lint level from string (attribute value)
    static fn from_str(s: text) -> Option<LintLevel>:
        val lower = s.lower()
        if lower == "allow":
            Some(LintLevel.Allow)
        elif lower == "warn":
            Some(LintLevel.Warn)
        elif lower == "deny":
            Some(LintLevel.Deny)
        else:
            None

    # Convert to string representation
    fn to_str() -> text:
        match self:
            LintLevel.Allow: "allow"
            LintLevel.Warn: "warn"
            LintLevel.Deny: "deny"

# Known lint names
enum LintName:
    PrimitiveApi             # Bare primitives in public API signatures
    BareBool                 # Bare bool parameters (suggest enum)
    PrintInTestSpec          # Print calls in test spec files
    TodoFormat               # Improperly formatted TODO/FIXME comments
    SSpecNoPrintBasedTests   # Print-based BDD tests (use proper SSpec syntax)
    SSpecMissingDocstrings   # Missing docstrings in describe/context/it blocks
    SSpecMinimalDocstrings   # Files with minimal docstring usage
    SSpecManualAssertions    # Manual pass/fail tracking instead of expect()

impl LintName:
    # Get the string name of the lint
    fn as_str() -> text:
        match self:
            LintName.PrimitiveApi: "primitive_api"
            LintName.BareBool: "bare_bool"
            LintName.PrintInTestSpec: "print_in_test_spec"
            LintName.TodoFormat: "todo_format"
            LintName.SSpecNoPrintBasedTests: "sspec_no_print_based_tests"
            LintName.SSpecMissingDocstrings: "sspec_missing_docstrings"
            LintName.SSpecMinimalDocstrings: "sspec_minimal_docstrings"
            LintName.SSpecManualAssertions: "sspec_manual_assertions"

    # Parse lint name from string
    static fn from_str(s: text) -> Option<LintName>:
        if s == "primitive_api":
            Some(LintName.PrimitiveApi)
        elif s == "bare_bool":
            Some(LintName.BareBool)
        elif s == "print_in_test_spec":
            Some(LintName.PrintInTestSpec)
        elif s == "todo_format":
            Some(LintName.TodoFormat)
        elif s == "sspec_no_print_based_tests":
            Some(LintName.SSpecNoPrintBasedTests)
        elif s == "sspec_missing_docstrings":
            Some(LintName.SSpecMissingDocstrings)
        elif s == "sspec_minimal_docstrings":
            Some(LintName.SSpecMinimalDocstrings)
        elif s == "sspec_manual_assertions":
            Some(LintName.SSpecManualAssertions)
        else:
            None

    # Get the default level for this lint
    fn default_level() -> LintLevel:
        match self:
            LintName.PrimitiveApi: LintLevel.Warn
            LintName.BareBool: LintLevel.Warn
            LintName.PrintInTestSpec: LintLevel.Warn
            LintName.TodoFormat: LintLevel.Warn
            LintName.SSpecNoPrintBasedTests: LintLevel.Deny
            LintName.SSpecMissingDocstrings: LintLevel.Warn
            LintName.SSpecMinimalDocstrings: LintLevel.Warn
            LintName.SSpecManualAssertions: LintLevel.Warn

    # Get all available lint names
    static fn all_lints() -> List<LintName>:
        [
            LintName.PrimitiveApi,
            LintName.BareBool,
            LintName.PrintInTestSpec,
            LintName.TodoFormat,
            LintName.SSpecNoPrintBasedTests,
            LintName.SSpecMissingDocstrings,
            LintName.SSpecMinimalDocstrings,
            LintName.SSpecManualAssertions
        ]

# Lint configuration for a scope (module, function, etc.)
struct LintConfig:
    # Overridden lint levels (using List instead of HashMap)
    levels: List<(LintName, LintLevel)>

impl LintConfig:
    # Create a new empty lint configuration
    static fn new() -> LintConfig:
        LintConfig(levels: [])

    # Load lint configuration from a simple.sdn file
    # Expected format:
    # ```sdn
    # [lints]
    # primitive_api = "deny"
    # bare_bool = "warn"
    # ```
    static fn from_sdn_file(path: text) -> Result<LintConfig, text>:
        match read_text(path):
            Ok(content): LintConfig.from_sdn_string(content)
            Err(e): Err("Failed to read lint config: {e}")

    # Parse lint configuration from SDN string
    static fn from_sdn_string(content: text) -> Result<LintConfig, text>:
        var config = LintConfig.new()
        var in_lints_section = false

        val lines = content.split("\n")
        var i = 0
        while i < lines.len():
            val line = lines[i].trim()

            # Skip empty lines and comments
            if line.is_empty() or line.starts_with("#"):
                i = i + 1
                continue

            # Check for [lints] section
            if line == "[lints]":
                in_lints_section = true
                i = i + 1
                continue

            # Check for other sections (exit lints section)
            if line.starts_with("[") and line.ends_with("]"):
                in_lints_section = false
                i = i + 1
                continue

            # Parse lint = "level" entries
            if in_lints_section:
                match split_once(line, "="):
                    Some((lint_name_raw, level_str_raw)):
                        val lint_name = lint_name_raw.trim()
                        # Remove quotes from level string
                        var level_str = level_str_raw.trim()
                        level_str = remove_quotes(level_str)

                        match LintName.from_str(lint_name):
                            Some(lint):
                                match LintLevel.from_str(level_str):
                                    Some(level):
                                        config.set_level(lint, level)
                                    None:
                                        return Err("Invalid lint level '{level_str}' for lint '{lint_name}'")
                            None:
                                # Unknown lint name - warning
                                print "Warning: Unknown lint name '{lint_name}'"
                    None:
                        pass

            i = i + 1

        Ok(config)

    # Set the level for a specific lint
    me set_level(lint: LintName, level: LintLevel):
        # Find existing entry and replace, or append new
        var found = false
        var new_levels: List<(LintName, LintLevel)> = []

        var i = 0
        while i < self.levels.len():
            val (existing_lint, existing_level) = self.levels[i]
            if existing_lint == lint:
                new_levels.append((lint, level))
                found = true
            else:
                new_levels.append((existing_lint, existing_level))
            i = i + 1

        if not found:
            new_levels.append((lint, level))

        self.levels = new_levels

    # Get the effective level for a lint
    fn get_level(lint: LintName) -> LintLevel:
        # Search for override
        var i = 0
        while i < self.levels.len():
            val (existing_lint, existing_level) = self.levels[i]
            if existing_lint == lint:
                return existing_level
            i = i + 1

        # Return default if not found
        lint.default_level()

    # Parse lint attributes and update config
    # Handles: #[allow(lint)], #[warn(lint)], #[deny(lint)]
    me apply_attributes(attributes: List<Attribute>):
        for attr in attributes:
            # Determine lint level from attribute name
            val level = match attr.name:
                "allow": Some(LintLevel.Allow)
                "warn": Some(LintLevel.Warn)
                "deny": Some(LintLevel.Deny)
                _: None

            match level:
                Some(lint_level):
                    # Apply level to all lint names in args
                    for arg in attr.args:
                        match LintName.from_str(arg):
                            Some(lint):
                                self.set_level(lint, lint_level)
                            None:
                                # Unknown lint name, silently ignore
                                pass
                None:
                    # Not a lint attribute, skip
                    pass

    # Create a child config that inherits from this one
    fn child() -> LintConfig:
        LintConfig(levels: self.levels.clone())

# Helper: Split string once by delimiter
# use super.string_utils.split_once  # TODO: Import string utils module

# Helper: Remove surrounding quotes from string
fn remove_quotes(s: text) -> text:
    var result = s
    # Remove double quotes
    if result.starts_with("\"") and result.ends_with("\"") and result.len() >= 2:
        result = result.slice(1, result.len() - 1)
    # Remove single quotes
    if result.starts_with("'") and result.ends_with("'") and result.len() >= 2:
        result = result.slice(1, result.len() - 1)
    result

# ============================================================================
# Attribute Parsing
# ============================================================================

use regex.{regex_captures, regex_find_all}

# Parse a single attribute from string like "#[allow(lint1, lint2)]"
fn parse_attribute(attr_str: text) -> Option<Attribute>:
    val trimmed = attr_str.trim()

    # Must start with #[
    if not trimmed.starts_with("#["):
        return None

    # Must end with ]
    if not trimmed.ends_with("]"):
        return None

    # Extract content between #[ and ]
    val content = trimmed.slice(2, trimmed.len() - 1).trim()

    if content.is_empty():
        return None

    # Check for attribute with value: name = "value"
    match regex_captures(r"^(\w+)\s*=\s*(.+)$", content):
        Some(caps):
            match caps.groups[0]:
                Some(name):
                    match caps.groups[1]:
                        Some(value):
                            return Some(Attribute.with_value(name, remove_quotes(value)))
                        None: pass
                None: pass
        None: pass

    # Check for attribute with args: name(arg1, arg2)
    match regex_captures(r"^(\w+)\s*\(([^)]*)\)$", content):
        Some(caps):
            match caps.groups[0]:
                Some(name):
                    match caps.groups[1]:
                        Some(args_str):
                            # Parse comma-separated args
                            var args: List<text> = []
                            for arg in args_str.split(","):
                                val trimmed_arg = arg.trim()
                                if not trimmed_arg.is_empty():
                                    args.push(trimmed_arg)
                            return Some(Attribute.with_args(name, args))
                        None:
                            return Some(Attribute.with_args(name, []))
                None: pass
        None: pass

    # Simple attribute: just name
    match regex_captures(r"^(\w+)$", content):
        Some(caps):
            match caps.groups[0]:
                Some(name):
                    return Some(Attribute.simple(name))
                None: pass
        None: pass

    None

# Parse all attributes from source code
fn parse_attributes_from_source(source: text) -> List<Attribute>:
    var attributes: List<Attribute> = []

    # Find all #[...] patterns
    val matches = regex_find_all(r"#\[[^\]]+\]", source)
    for match_ in matches:
        match parse_attribute(match_.text):
            Some(attr):
                attributes.push(attr)
            None:
                pass

    attributes

# Extract lint attributes from a list of attributes
fn filter_lint_attributes(attributes: List<Attribute>) -> List<Attribute>:
    var lint_attrs: List<Attribute> = []
    for attr in attributes:
        if attr.is_lint_attribute():
            lint_attrs.push(attr)
    lint_attrs

# ============================================================================
# Exports
# ============================================================================

export Span, Attribute
export LintLevel, LintName, LintConfig
export parse_attribute, parse_attributes_from_source, filter_lint_attributes
