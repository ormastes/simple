# Simple Language Spec Migration Tool - markdown to spl
# Migrated from: scripts/migrate_spec_to_spl.py
# Purpose: Convert doc/spec/*.md to tests/specs/*_spec.spl

use fs.{read_text, write_text}
use regex.{captures, find_all, replace_all}

# Migration statistics
struct SpecMigrationStats:
    files_processed: u64
    files_migrated: u64
    examples_extracted: u64

impl SpecMigrationStats:
    # Create empty stats
    static fn new() -> SpecMigrationStats:
        SpecMigrationStats(files_processed: 0, files_migrated: 0, examples_extracted: 0)

    # Record processed file
    me add_processed():
        self.files_processed = self.files_processed + 1

    # Record migrated file
    me add_migrated(examples: u64):
        self.files_migrated = self.files_migrated + 1
        self.examples_extracted = self.examples_extracted + examples

    # Generate summary report
    fn summary() -> text:
        var report = ""
        report = report + "=== Spec Migration Complete ===\n"
        report = report + "Files processed: {self.files_processed}\n"
        report = report + "Files migrated: {self.files_migrated}\n"
        report = report + "Examples extracted: {self.examples_extracted}\n"
        report

# Spec metadata
struct SpecMetadata:
    status: text
    feature_ids: text
    keywords: text
    last_updated: text
    topics: text

impl SpecMetadata:
    # Create empty metadata
    static fn new() -> SpecMetadata:
        SpecMetadata(status: "Draft", feature_ids: "", keywords: "", last_updated: "", topics: "")

# Code example from markdown
struct CodeExample:
    context: text
    code: text
    section: text

impl CodeExample:
    # Create code example
    static fn new(context: text, code: text, section: text) -> CodeExample:
        CodeExample(context: context, code: code, section: section)

# Category A file mapping
struct CategoryAFile:
    md_file: text
    spl_file: text
    feature_ids: text

impl CategoryAFile:
    # Create file mapping
    static fn new(md: text, spl: text, ids: text) -> CategoryAFile:
        CategoryAFile(md_file: md, spl_file: spl, feature_ids: ids)

# Get Category A files for migration
fn get_category_a_files() -> List<CategoryAFile>:
    [
        CategoryAFile.new("syntax.md", "syntax_spec.spl", "#10-19"),
        CategoryAFile.new("types.md", "types_spec.spl", "#20-29"),
        CategoryAFile.new("type_inference.md", "type_inference_spec.spl", "#13"),
        CategoryAFile.new("async_default.md", "async_default_spec.spl", "#276-285"),
        CategoryAFile.new("suspension_operator.md", "suspension_operator_spec.spl", "#270-275"),
        CategoryAFile.new("capability_effects.md", "capability_effects_spec.spl", "#880-884"),
        CategoryAFile.new("sandboxing.md", "sandboxing_spec.spl", "#916-923")
    ]

# Extract metadata from markdown
fn extract_metadata(md_content: text) -> SpecMetadata:
    var metadata = SpecMetadata.new()

    # Extract Status: - **Status:** Draft
    val status_caps = captures(r"\*\*Status:\*\*\s*([^\n]+)", md_content)
    if status_caps.len() > 1:
        metadata.status = status_caps[1].trim()

    # Extract Feature IDs: - **Feature IDs:** #10-19
    val ids_caps = captures(r"\*\*Feature IDs?:\*\*\s*([^\n]+)", md_content)
    if ids_caps.len() > 1:
        metadata.feature_ids = ids_caps[1].trim()

    # Extract Keywords: - **Keywords:** syntax, parser
    val keywords_caps = captures(r"\*\*Keywords:\*\*\s*([^\n]+)", md_content)
    if keywords_caps.len() > 1:
        metadata.keywords = keywords_caps[1].trim()

    # Extract Last Updated: - **Last Updated:** 2024-01-15
    val date_caps = captures(r"\*\*Last Updated:\*\*\s*([^\n]+)", md_content)
    if date_caps.len() > 1:
        metadata.last_updated = date_caps[1].trim()

    # Extract Topics: - **Topics:** control-flow, syntax
    val topics_caps = captures(r"\*\*Topics:\*\*\s*([^\n]+)", md_content)
    if topics_caps.len() > 1:
        metadata.topics = topics_caps[1].trim()

    metadata

# Extract title from markdown
fn extract_title(md_content: text) -> text:
    # Match first heading: # Title (#10-19)
    val title_caps = captures(r"^#\s+([^\n]+)", md_content)
    if title_caps.len() > 1:
        val title = title_caps[1]
        # Remove feature ID suffix like (#10-19)
        val cleaned = replace_all(r"\s*\(#[\d,-]+\)\s*$", title, "")
        cleaned.trim()
    else:
        "Untitled Specification"

# Extract overview section
fn extract_overview(md_content: text) -> text:
    # Look for ## Overview section
    val lines = md_content.split("\n")
    var in_overview = false
    var result_lines: List<text> = []

    for line in lines:
        if line.starts_with("## "):
            val header = line.slice(3, line.len()).trim()
            if header == "Overview":
                in_overview = true
                continue
            elif in_overview:
                # Found next section, stop
                break

        if in_overview:
            result_lines.push(line)

    val overview = result_lines.join("\n").trim()
    if overview.is_empty():
        "Specification overview from markdown"
    else:
        overview

# Extract code examples from markdown
fn extract_code_examples(md_content: text) -> List<CodeExample>:
    var examples: List<CodeExample> = []
    val lines = md_content.split("\n")
    var current_section = "General"
    var in_code_block = false
    var code_lines: List<text> = []
    var context = ""
    var prev_line = ""

    for line in lines:
        # Track current section
        if line.starts_with("## "):
            current_section = line.slice(3, line.len()).trim()
            continue

        # Detect code block start
        if line.trim().starts_with("```simple"):
            in_code_block = true
            code_lines = []
            # Use previous non-empty line as context
            context = prev_line.trim()
            if context.starts_with("#"):
                context = context.slice(1, context.len()).trim()
            continue

        # Detect code block end
        if line.trim() == "```" and in_code_block:
            in_code_block = false
            if code_lines.len() > 0:
                val code = code_lines.join("\n")
                examples.push(CodeExample.new(context, code, current_section))
            continue

        # Collect code lines
        if in_code_block:
            code_lines.push(line)
        else:
            # Track previous non-empty line for context
            if not line.trim().is_empty():
                prev_line = line

    examples

# Generate _spec.spl content
fn generate_spec_spl(md_path: text, spl_path: text, metadata: SpecMetadata, title: text, overview: text, examples: List<CodeExample>) -> text:
    var output = ""

    # Header comment with metadata
    output = output + "# {title}\n"
    output = output + "# Migrated from: {md_path}\n"
    output = output + "#\n"
    output = output + "# Status: {metadata.status}\n"
    if not metadata.feature_ids.is_empty():
        output = output + "# Feature IDs: {metadata.feature_ids}\n"
    if not metadata.keywords.is_empty():
        output = output + "# Keywords: {metadata.keywords}\n"
    if not metadata.last_updated.is_empty():
        output = output + "# Last Updated: {metadata.last_updated}\n"
    output = output + "\n"

    # Import SSpec framework
    output = output + "use spec.{describe, context, it, expect, skip}\n\n"

    # Main describe block
    output = output + "describe \"{title}\":\n"

    # Overview docstring
    output = output + "    \"\"\"\n"
    for line in overview.split("\n"):
        output = output + "    {line}\n"
    output = output + "    \"\"\"\n\n"

    # Group examples by section
    var sections_seen: List<text> = []
    for example in examples:
        if not sections_seen.contains(example.section):
            sections_seen.push(example.section)

    for section in sections_seen:
        output = output + "    context \"{section}\":\n"

        # Add examples for this section
        var example_count = 0
        for example in examples:
            if example.section == section:
                example_count = example_count + 1
                val example_name = if example.context.is_empty():
                    "example {example_count}"
                else:
                    example.context

                output = output + "        it \"{example_name}\":\n"
                output = output + "            # Code from markdown:\n"
                for line in example.code.split("\n"):
                    output = output + "            # {line}\n"
                output = output + "            skip \"Migrated from markdown - needs test implementation\"\n\n"

    # If no examples, add a placeholder
    if examples.is_empty():
        output = output + "    context \"Specification\":\n"
        output = output + "        it \"follows the specification\":\n"
        output = output + "            skip \"TODO: Add test implementation\"\n"

    output

# Migrate single spec file
fn migrate_spec_file(md_path: text, spl_path: text) -> Result<u64, text>:
    # Read markdown file
    match read_text(md_path):
        Ok(md_content):
            # Extract metadata, title, and overview from markdown
            val metadata = extract_metadata(md_content)
            val title = extract_title(md_content)
            val overview = extract_overview(md_content)

            # Extract code examples from markdown
            val examples = extract_code_examples(md_content)

            # Generate _spec.spl content
            val spl_content = generate_spec_spl(
                md_path,
                spl_path,
                metadata,
                title,
                overview,
                examples
            )

            # Write to output file
            match write_text(spl_path, spl_content):
                Ok(_):
                    Ok(examples.len() as u64)
                Err(e):
                    Err("Failed to write spec file: {e}")
        Err(e):
            Err("Failed to read markdown file: {e}")

# Migrate all Category A files
fn migrate_all_category_a() -> SpecMigrationStats:
    var stats = SpecMigrationStats.new()

    # Get Category A files
    val files = get_category_a_files()

    # Process each file
    var i = 0
    while i < files.len():
        val file = files[i]
        stats.add_processed()

        # Construct full paths
        val md_path = "doc/spec/{file.md_file}"
        val spl_path = "tests/specs/{file.spl_file}"

        match migrate_spec_file(md_path, spl_path):
            Ok(examples_count):
                stats.add_migrated(examples_count)
                print "Migrated: {file.md_file} -> {file.spl_file} ({examples_count} examples)"
            Err(e):
                print "Error migrating {file.md_file}: {e}"

        i = i + 1

    stats

# Print Category A files
fn print_category_a_files() -> text:
    var output = ""
    output = output + "=== Category A Files for Migration ===\n\n"

    val files = get_category_a_files()
    var i = 0
    while i < files.len():
        val file = files[i]
        output = output + "{i + 1}. {file.md_file} -> {file.spl_file}\n"
        output = output + "   Feature IDs: {file.feature_ids}\n\n"
        i = i + 1

    output

# CLI options for migrate_spec_to_spl command
struct MigrateSpecOptions:
    all_files: bool
    dry_run: bool
    list_files: bool
    md_path: Option<text>
    spl_path: Option<text>
    show_help: bool

impl MigrateSpecOptions:
    # Create default options
    static fn default() -> MigrateSpecOptions:
        MigrateSpecOptions(
            all_files: false,
            dry_run: false,
            list_files: false,
            md_path: None,
            spl_path: None,
            show_help: false
        )

    # Parse CLI arguments
    static fn parse(args: List<text>) -> MigrateSpecOptions:
        var options = MigrateSpecOptions.default()
        var positional_count = 0
        var i = 0

        while i < args.len():
            val arg = args[i]

            if arg == "--all" or arg == "-a":
                options.all_files = true
            elif arg == "--dry-run" or arg == "-n":
                options.dry_run = true
            elif arg == "--list" or arg == "-l":
                options.list_files = true
            elif arg == "--help" or arg == "-h":
                options.show_help = true
            elif not arg.starts_with("-"):
                # Positional arguments: md_path and spl_path
                if positional_count == 0:
                    options.md_path = Some(arg)
                elif positional_count == 1:
                    options.spl_path = Some(arg)
                positional_count = positional_count + 1

            i = i + 1

        options

# Print usage help for migrate_spec_to_spl
fn print_migrate_spec_help() -> text:
    var help = ""
    help = help + "Usage: simple migrate-spec-to-spl [OPTIONS] [MD_PATH] [SPL_PATH]\n\n"
    help = help + "Convert doc/spec/*.md to tests/specs/*_spec.spl test files.\n\n"
    help = help + "Arguments:\n"
    help = help + "  MD_PATH          Input markdown specification file\n"
    help = help + "  SPL_PATH         Output _spec.spl test file\n\n"
    help = help + "Options:\n"
    help = help + "  -a, --all        Migrate all Category A files\n"
    help = help + "  -n, --dry-run    Preview migration without writing files\n"
    help = help + "  -l, --list       List Category A files for migration\n"
    help = help + "  -h, --help       Show this help message\n\n"
    help = help + "Examples:\n"
    help = help + "  simple migrate-spec-to-spl doc/spec/syntax.md tests/specs/syntax_spec.spl\n"
    help = help + "  simple migrate-spec-to-spl --all             # Migrate all Category A files\n"
    help = help + "  simple migrate-spec-to-spl --list            # List files to migrate\n"
    help

# Main entry point
fn main_migrate_spec_to_spl(args: List<text>) -> Result<(), text>:
    val options = MigrateSpecOptions.parse(args)

    # Show help if requested
    if options.show_help:
        print print_migrate_spec_help()
        return Ok(())

    # List Category A files if requested
    if options.list_files:
        print print_category_a_files()
        return Ok(())

    # Determine mode: all files or single file
    if options.all_files:
        # Migrate all Category A files
        print "Migrating all Category A specification files..."
        if options.dry_run:
            print "=== Dry Run Mode - No files will be written ===\n"

        val stats = migrate_all_category_a()

        # Print summary
        print stats.summary()

        Ok(())
    else:
        # Single file migration
        match (options.md_path, options.spl_path):
            (Some(md), Some(spl)):
                print "Migrating: {md}"
                print "Output: {spl}"

                if options.dry_run:
                    print "=== Dry Run Mode - No files will be written ===\n"

                match migrate_spec_file(md, spl):
                    Ok(examples_count):
                        print "\n=== Migration Complete ==="
                        print "Examples extracted: {examples_count}"
                        Ok(())
                    Err(e):
                        Err(e)
            _:
                Err("Missing required arguments. Use --all or provide MD_PATH SPL_PATH.\nRun with --help for usage information.")
