# Code analysis commands: query generated code, show provenance info
# Migrated from: src/driver/src/cli/analysis.rs
# Purpose: Query for generated code in the codebase

# Query for generated code in the codebase
fn run_query(args: List<text>) -> i32:
    # Parse arguments
    val show_generated = args.contains("--generated")
    val show_unverified = args.contains("--unverified")
    val generated_by_tool = args
        .iter()
        .find(\a: a.starts_with("--generated-by="))
        .and_then(\a: strip_prefix(a, "--generated-by="))

    if not show_generated and generated_by_tool.is_none():
        eprint "error: query requires --generated or --generated-by=<tool>"
        eprint "Usage:"
        eprint "  simple query --generated"
        eprint "  simple query --generated --unverified"
        eprint "  simple query --generated-by=<tool>"
        return 1

    # Get the path to search (default to current directory)
    val search_path = args
        .iter()
        .skip(1)
        .find(\a: not a.starts_with("--"))
        .unwrap_or(".")

    # Collect all .spl files
    var spl_files = []
    if is_file(search_path):
        spl_files.push(search_path)
    elif is_directory(search_path):
        spl_files = walk_directory_recursive(search_path, ".spl")

    if spl_files.is_empty():
        eprint "error: no .spl files found in {search_path}"
        return 1

    # Search for generated functions
    var found_any = false
    for file_path in spl_files:
        match read_file_content(file_path):
            Err(_): continue
            Ok(source):
                match parse_module(source):
                    Err(_): continue
                    Ok(module):
                        # Search for generated functions
                        for item in module.items:
                            if not is_generated_function(item):
                                continue

                            val metadata = get_generated_metadata(item)

                            # Apply filters
                            match generated_by_tool:
                                Some(tool_filter):
                                    # Check if tool matches
                                    val matches_tool = metadata
                                        .map(\args:
                                            args.iter().any(\arg:
                                                arg.name == Some("tool") and
                                                arg.value == tool_filter
                                            )
                                        )
                                        .unwrap_or(false)

                                    if not matches_tool:
                                        continue
                                None:
                                    {}

                            # Print found function
                            if not found_any:
                                println "Generated functions:"
                                found_any = true

                            val func_name = get_function_name(item)
                            val tool_name = metadata
                                .and_then(\args:
                                    args.iter()
                                        .find(\arg: arg.name == Some("tool"))
                                        .map(\arg: arg.value)
                                )
                                .unwrap_or("unknown")

                            println "  {file_path}:{func_name} [generated by: {tool_name}]"

                            # Show verification status if --unverified flag is set
                            if show_unverified:
                                val is_verified = is_function_verified(item)
                                if not is_verified:
                                    println "    ⚠ UNVERIFIED"

    if not found_any:
        println "No generated functions found."
        if generated_by_tool.is_some():
            println "Try without --generated-by filter to see all generated code."
    else:
        println ""
        println "Total: {found_count} generated functions"

    0

# Show provenance information for a file or function
fn run_provenance(args: List<text>) -> i32:
    if args.len() < 2:
        eprint "error: provenance requires a file or function path"
        eprint "Usage:"
        eprint "  simple provenance <file.spl>"
        eprint "  simple provenance <file.spl>:<function>"
        return 1

    val target = args[1]

    # Parse target into file and optional function
    val parts = target.split(":")
    val file_path = parts[0]
    val func_name = if parts.len() > 1:
        Some(parts[1])
    else:
        None

    # Read and parse file
    match read_file_content(file_path):
        Err(e):
            eprint "error: cannot read {file_path}: {e}"
            return 1
        Ok(source):
            match parse_module(source):
                Err(e):
                    eprint "error: cannot parse {file_path}: {e}"
                    return 1
                Ok(module):
                    # Show provenance
                    match func_name:
                        Some(name):
                            # Show function provenance
                            show_function_provenance(file_path, module, name)
                        None:
                            # Show file provenance
                            show_file_provenance(file_path, module)

    0

# Show provenance for an entire file
fn show_file_provenance(file_path: text, module: Module):
    println "File: {file_path}"
    println ""

    # Count generated vs manual functions
    var total_funcs = 0
    var generated_funcs = 0
    var verified_funcs = 0

    for item in module.items:
        if is_function(item):
            total_funcs = total_funcs + 1

            if is_generated_function(item):
                generated_funcs = generated_funcs + 1

                if is_function_verified(item):
                    verified_funcs = verified_funcs + 1

    println "Functions:"
    println "  Total:      {total_funcs}"
    println "  Generated:  {generated_funcs}"
    println "  Verified:   {verified_funcs}"
    println ""

    if generated_funcs > 0:
        println "Generated functions:"
        for item in module.items:
            if is_generated_function(item):
                val func_name = get_function_name(item)
                val metadata = get_generated_metadata(item)
                val tool = metadata
                    .and_then(\args:
                        args.iter()
                            .find(\arg: arg.name == Some("tool"))
                            .map(\arg: arg.value)
                    )
                    .unwrap_or("unknown")

                val verified_mark = if is_function_verified(item):
                    "✓"
                else:
                    " "

                println "  [{verified_mark}] {func_name} (by: {tool})"

# Show provenance for a specific function
fn show_function_provenance(file_path: text, module: Module, func_name: text):
    # Find the function
    val func_item = module.items
        .iter()
        .find(\item: is_function(item) and get_function_name(item) == func_name)

    match func_item:
        None:
            eprint "error: function '{func_name}' not found in {file_path}"
        Some(item):
            println "Function: {func_name}"
            println "File:     {file_path}"
            println ""

            if is_generated_function(item):
                println "Status:   Generated"

                val metadata = get_generated_metadata(item)
                match metadata:
                    Some(args):
                        for arg in args:
                            match arg.name:
                                Some(key):
                                    println "  {key}: {arg.value}"
                                None:
                                    {}
                    None:
                        println "  (no metadata)"

                println ""
                println "Verified: {if is_function_verified(item) then \"Yes\" else \"No\"}"
            else:
                println "Status:   Manually written"


# ===================================================================
# Stub functions and types
# ===================================================================

struct Module:
    items: List<Item>

enum Item:
    Function(FunctionData)
    Other

struct FunctionData:
    name: text
    is_generated: bool
    metadata: Option<List<MetadataArg>>
    is_verified: bool

struct MetadataArg:
    name: Option<text>
    value: text

fn is_file(path: text) -> bool:
    # Stub: would check if path is a file
    path.contains(".")

fn is_directory(path: text) -> bool:
    # Stub: would check if path is a directory
    not path.contains(".")

fn walk_directory_recursive(path: text, extension: text) -> List<text>:
    # Stub: would walk directory recursively
    []

fn read_file_content(path: text) -> Result<text, text>:
    # Stub: would read file content
    Err("File I/O not implemented")

fn parse_module(source: text) -> Result<Module, text>:
    # Stub: would parse source into AST module
    Err("Parser not implemented")

fn is_function(item: Item) -> bool:
    match item:
        Item.Function(_): true
        Item.Other: false

fn is_generated_function(item: Item) -> bool:
    match item:
        Item.Function(func): func.is_generated
        Item.Other: false

fn get_function_name(item: Item) -> text:
    match item:
        Item.Function(func): func.name
        Item.Other: "<unknown>"

fn get_generated_metadata(item: Item) -> Option<List<MetadataArg>>:
    match item:
        Item.Function(func): func.metadata
        Item.Other: None

fn is_function_verified(item: Item) -> bool:
    match item:
        Item.Function(func): func.is_verified
        Item.Other: false

fn strip_prefix(s: text, prefix: text) -> Option<text>:
    if s.starts_with(prefix):
        Some(s.substring(prefix.len(), s.len()))
    else:
        None
