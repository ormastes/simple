# Dashboard Notification Triggers
#
# Automatically triggers notifications based on alerts, thresholds, or schedules.
# Supports periodic checks, regression detection, and threshold-based alerts.

use tooling.dashboard.types.{DashboardData}
use tooling.dashboard.alerts.{Alert}
use tooling.dashboard.notify.{NotificationMessage, NotificationChannel, send_notification, NotificationConfig}
use tooling.dashboard.snapshots.{SnapshotData}
use core.time.{now_iso8601}

# =========================================================================
# Trigger Types
# =========================================================================

enum TriggerType:
    Threshold      # Alert when metric crosses threshold
    Regression     # Alert when metric gets worse
    Improvement    # Alert when metric gets better
    Schedule       # Alert at specific times
    Manual         # Triggered manually

class NotificationTrigger:
    """Automated notification trigger."""
    id: i32
    name: text
    trigger_type: TriggerType
    metric: text
    threshold: Option<f64>
    enabled: bool
    channels: List<NotificationChannel>
    last_fired: Option<text>
    schedule: Option<text>  # Cron-like schedule (e.g., "0 9 * * *" or "daily")

    static fn new(id: i32, name: text, trigger_type: TriggerType, metric: text) -> NotificationTrigger:
        return NotificationTrigger {
            id: id,
            name: name,
            trigger_type: trigger_type,
            metric: metric,
            threshold: nil,
            enabled: true,
            channels: [],
            last_fired: nil,
            schedule: nil
        }

    fn with_threshold(threshold: f64) -> NotificationTrigger:
        self.threshold = Some(threshold)
        return self

    fn with_channel(channel: NotificationChannel) -> NotificationTrigger:
        self.channels.append(channel)
        return self

    fn with_schedule(schedule: text) -> NotificationTrigger:
        """Set a cron-like schedule (e.g., "daily", "hourly", or "0 9 * * *")."""
        self.schedule = Some(schedule)
        return self

    fn should_fire(current_value: f64, previous_value: f64) -> bool:
        """Check if trigger should fire based on current values."""
        if not self.enabled:
            return false

        match self.trigger_type:
            | TriggerType ->:Threshold:
                match self.threshold:
                    | Some(threshold) ->
                        # For some metrics, fire when below; for others, above
                        current_value < threshold
                    | nil -> false
            | TriggerType ->:Regression:
                # Fire when metric gets worse (lower for coverage/features, higher for TODOs)
                current_value < previous_value
            | TriggerType ->:Improvement:
                # Fire when metric gets better
                current_value > previous_value
            | TriggerType ->:Schedule:
                # Check if schedule-based trigger should fire
                match self.schedule:
                    Some(schedule):
                        should_fire_on_schedule(schedule, self.last_fired)
                    nil:
                        false
            | TriggerType ->:Manual: false

    fn to_string() -> text:
        var s = "#{self.id}: {self.name} ({trigger_type_to_string(self.trigger_type)})"
        match self.threshold:
            | Some(t) -> s = "{s} - Threshold: {t}"
            | nil -> pass
        return s

# =========================================================================
# Trigger Manager
# =========================================================================

class TriggerManager:
    """Manages notification triggers."""
    triggers: List<NotificationTrigger>
    next_id: i32

    static fn new() -> TriggerManager:
        return TriggerManager {
            triggers: [],
            next_id: 1
        }

    fn add_trigger(trigger: NotificationTrigger) -> NotificationTrigger:
        """Add a new trigger."""
        self.triggers.append(trigger)
        self.next_id = self.next_id + 1
        return trigger

    fn remove_trigger(id: i32) -> Result<(), text>:
        """Remove a trigger by ID."""
        for i in 0..self.triggers.len():
            if self.triggers[i].id == id:
                self.triggers.remove(i)
                Ok(())
        return Err("Trigger not found: {id}")

    fn get_trigger(id: i32) -> Option<NotificationTrigger>:
        """Get a trigger by ID."""
        for trigger in self.triggers:
            if trigger.id == id:
                Some(trigger)
        return nil

    fn list_triggers() -> List<NotificationTrigger>:
        """Get all triggers."""
        return self.triggers

    fn enable_trigger(id: i32) -> Result<(), text>:
        """Enable a trigger."""
        match self.get_trigger(id):
            | Some(trigger) ->
                trigger.enabled = true
                Ok(())
            | nil -> Err("Trigger not found: {id}")

    fn disable_trigger(id: i32) -> Result<(), text>:
        """Disable a trigger."""
        match self.get_trigger(id):
            | Some(trigger) ->
                trigger.enabled = false
                Ok(())
            | nil -> Err("Trigger not found: {id}")

# =========================================================================
# Trigger Evaluation
# =========================================================================

fn evaluate_triggers(
    triggers: List<NotificationTrigger>,
    current_data: DashboardData,
    previous_snapshot: Option<SnapshotData>,
    config: NotificationConfig
) -> List<tuple<NotificationTrigger, NotificationMessage>>:
    """Evaluate all triggers and return messages for those that fired.

    Args:
        triggers: List of triggers to evaluate
        current_data: Current dashboard data
        previous_snapshot: Previous snapshot for comparison (nil = no comparison)
        config: Notification configuration

    Returns:
        List of (trigger, message) tuples for fired triggers
    """
    var fired: List<tuple<NotificationTrigger, NotificationMessage>> = []

    for trigger in triggers:
        if not trigger.enabled:
            continue

        # Get metric values
        val current_value = get_trigger_metric_value(trigger.metric, current_data)
        val previous_value = match previous_snapshot:
            | Some(snapshot) -> get_snapshot_metric_value(trigger.metric, snapshot)
            | nil -> current_value

        # Check if trigger should fire
        if trigger.should_fire(current_value=current_value, previous_value=previous_value):
            # Create notification message
            val msg = create_trigger_message(trigger=trigger, current_value=current_value, previous_value=previous_value)
            fired.append((trigger, msg))

    return fired

# =========================================================================
# Helper Functions
# =========================================================================

fn get_trigger_metric_value(metric: text, data: DashboardData) -> f64:
    """Extract metric value from dashboard data."""
    match metric:
        | "coverage" -> data.overall_coverage()
        | "features" -> (data.completed_features() as f64) / (data.total_features() as f64) * 100.0
        | "todos" -> data.total_todos() as f64
        | "todos.p0" -> data.critical_todos() as f64
        | "tests" -> data.sspec_tests.len() as f64
        | _ -> 0.0

fn get_snapshot_metric_value(metric: text, snapshot: SnapshotData) -> f64:
    """Extract metric value from snapshot data."""
    match metric:
        | "coverage" -> snapshot.coverage_percent
        | "features" -> snapshot.feature_completion_percent()
        | "todos" -> snapshot.todos_total as f64
        | "todos.p0" -> snapshot.todos_critical as f64
        | "tests" -> snapshot.sspec_tests as f64
        | _ -> 0.0

fn create_trigger_message(
    trigger: NotificationTrigger,
    current_value: f64,
    previous_value: f64
) -> NotificationMessage:
    """Create a notification message for a fired trigger."""
    val change = current_value - previous_value
    val change_percent = if previous_value != 0.0:
        (change / previous_value) * 100.0
    else:
        0.0

    var title = "{trigger.name}"
    var body = "Metric '{trigger.metric}' changed from {previous_value:.1f} to {current_value:.1f}"

    match trigger.trigger_type:
        | TriggerType ->:Threshold:
            title = "Alert: {trigger.name}"
            body = "{body}\nValue crossed threshold"
        | TriggerType ->:Regression:
            title = "Regression: {trigger.name}"
            body = "{body}\nMetric degraded ({change_percent:.1f}%)"
        | TriggerType ->:Improvement:
            title = "Improvement: {trigger.name}"
            body = "{body}\nMetric improved (+{change_percent:.1f}%)"
        | _ ->
            pass

    val severity = match trigger.trigger_type:
        | TriggerType ->:Threshold: "warning"
        | TriggerType ->:Regression: "critical"
        | TriggerType ->:Improvement: "info"
        | _ -> "info"

    return NotificationMessage.new(title, body, severity)

fn get_day_of_week(date: text) -> i32:
    """Get day of week from date string (YYYY-MM-DD).

    Returns:
        0 = Sunday
        1 = Monday
        2 = Tuesday
        3 = Wednesday
        4 = Thursday
        5 = Friday
        6 = Saturday
    """
    if date.len() < 10:
        return 0

    # Parse date components
    val year = parse_int_from_string(s=date, start=0, end=4)
    val month = parse_int_from_string(s=date, start=5, end=7)
    val day = parse_int_from_string(s=date, start=8, end=10)

    # Use Zeller's congruence algorithm
    # Adjust month and year for algorithm (January and February are treated as 13 and 14 of previous year)
    var m = month as i32
    var y = year as i32

    if m < 3:
        m = m + 12
        y = y - 1

    # Zeller's formula: h = (q + floor(13(m+1)/5) + K + floor(K/4) + floor(J/4) - 2J) mod 7
    val q = day
    val K = y % 100      # year of the century
    val J = y / 100      # zero-based century

    val h = (q + (13 * (m + 1)) / 5 + K + K / 4 + J / 4 - 2 * J) % 7

    # Convert to 0=Sunday format
    val dow = (h + 6) % 7  # Adjust so 0=Sunday

    return dow

fn parse_int_from_string(s: text, start: i32, end: i32) -> i32:
    """Parse integer from substring."""
    var result = 0
    for i in start..end:
        if i < s.len():
            val ch = s[i]
            if ch >= "0" and ch <= "9":
                result = result * 10 + (ch.to_i32() - "0".to_i32())
    return result

fn trigger_type_to_string(trigger_type: TriggerType) -> text:
    match trigger_type:
        | TriggerType ->:Threshold: return "threshold"
        | TriggerType ->:Regression: return "regression"
        | TriggerType ->:Improvement: return "improvement"
        | TriggerType ->:Schedule: return "schedule"
        | TriggerType ->:Manual: return "manual"

fn should_fire_on_schedule(schedule: text, last_fired: Option<text>) -> bool:
    """Check if a schedule-based trigger should fire.

    Supports:
    - "hourly": Fire every hour
    - "daily": Fire every day at 00:00
    - "weekly": Fire every Monday at 00:00
    - "HH:MM": Fire at specific time of day

    Args:
        schedule: Schedule specification
        last_fired: Last time trigger fired (ISO 8601 format)

    Returns:
        true if trigger should fire based on schedule
    """
    match schedule:
        "hourly":
            # Fire if never fired or more than 60 minutes have passed
            match last_fired:
                Some(last):
                    # Check if more than 60 minutes have passed
                    # For now, use a simple check: fire if timestamp differs by hour
                    val last_hour = last.substring(0, 13)  # Extract "YYYY-MM-DD HH"
                    val now = now_iso8601()
                    val curr_hour = now.substring(0, 13)
                    last_hour != curr_hour
                nil:
                    true  # Fire on first run
        "daily":
            # Fire once per day
            match last_fired:
                Some(last):
                    # Check if different calendar day
                    val last_date = last.substring(0, 10)  # Extract "YYYY-MM-DD"
                    val now = now_iso8601()
                    val curr_date = now.substring(0, 10)
                    last_date != curr_date
                nil:
                    true  # Fire on first run
        "weekly":
            # Fire once per week (Monday)
            match last_fired:
                Some(last):
                    # Check if current day is Monday and last_fired was on different week
                    val last_date = last.substring(0, 10)  # YYYY-MM-DD
                    val now = now_iso8601()
                    val curr_date = now.substring(0, 10)

                    # Get day of week (0=Sunday, 1=Monday, etc.)
                    val last_dow = get_day_of_week(last_date)
                    val curr_dow = get_day_of_week(curr_date)

                    # Fire if current is Monday (dow=1) and last was not Monday
                    curr_dow == 1 and last_dow != 1
                nil:
                    true  # Fire on first run
        _:
            # Try to parse as time of day (HH:MM format)
            if schedule.contains(":"):
                # Fire if current hour matches scheduled hour and hasn't fired this hour
                match last_fired:
                    Some(last):
                        val last_hour = last.substring(11, 13)  # Extract hour from HH:MM:SS
                        val now = now_iso8601()
                        val curr_hour = now.substring(11, 13)
                        val scheduled_hour = schedule.substring(0, 2)

                        # Fire if we're in the correct hour and last_fired was in different hour
                        curr_hour == scheduled_hour and last_hour != scheduled_hour
                    nil:
                        val now = now_iso8601()
                        val curr_hour = now.substring(11, 13)
                        val scheduled_hour = schedule.substring(0, 2)
                        curr_hour == scheduled_hour
            else:
                false  # Unknown schedule format

# =========================================================================
# Preset Triggers
# =========================================================================

fn create_default_triggers() -> TriggerManager:
    """Create default notification triggers."""
    var manager = TriggerManager.new()

    # Coverage regression alert
    var coverage_regression = NotificationTrigger.new(
        manager.next_id,
        "Coverage Regression",
        TriggerType.Regression,
        "coverage"
    )
    coverage_regression.with_channel(NotificationChannel.Slack)
    manager.add_trigger(coverage_regression)

    # Critical coverage threshold
    var coverage_threshold = NotificationTrigger.new(
        manager.next_id,
        "Low Coverage",
        TriggerType.Threshold,
        "coverage"
    ).with_threshold(75.0)
    coverage_threshold.with_channel(NotificationChannel.Slack)
    manager.add_trigger(coverage_threshold)

    # Features regression
    var features_regression = NotificationTrigger.new(
        manager.next_id,
        "Features Regression",
        TriggerType.Regression,
        "features"
    )
    features_regression.with_channel(NotificationChannel.Webhook)
    manager.add_trigger(features_regression)

    # P0 TODO threshold
    var todos_alert = NotificationTrigger.new(
        manager.next_id,
        "Critical TODOs",
        TriggerType.Threshold,
        "todos.p0"
    ).with_threshold(10.0)
    todos_alert.with_channel(NotificationChannel.Slack)
    manager.add_trigger(todos_alert)

    return manager

# =========================================================================
# Exports
# =========================================================================

