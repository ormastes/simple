# Context Pack Generator for LLM Integration
# Migrated from: src/compiler/src/context_pack.rs
# Purpose: Generate minimal context for LLM tools by extracting only used symbols

use data.json.{json_object, json_array, json_parse, JsonObject, JsonArray}
use collections.{BTreeMap, BTreeSet}

# FFI declarations for parser and API surface extraction
extern fn rt_parse_simple_file(path: text) -> text
extern fn rt_api_surface_extract(path: text) -> text
extern fn rt_symbol_usage_find(path: text, target: text) -> text

# Function parameter signature
struct FunctionParam:
    name: text
    type_name: Option<text>

# Function signature from API surface
struct FunctionSignature:
    name: text
    params: List<FunctionParam>
    return_type: Option<text>
    is_async: bool
    is_public: bool

# Symbol usage information
struct SymbolUsage:
    used_functions: List<text>
    used_types: List<text>
    required_imports: List<text>

# A minimal context pack for LLM consumption
struct ContextPack:
    target: text                       # Target module/function being analyzed
    functions: BTreeMap                # Functions used by the target (name -> FunctionSignature)
    types: BTreeSet                    # Types used by the target (ordered set)
    imports: BTreeSet                  # Imports required (ordered set)
    symbol_count: u64                  # Total symbols in context

impl ContextPack:
    # Create a new empty context pack
    static fn new(target: text) -> ContextPack:
        ContextPack(
            target: target,
            functions: BTreeMap.new(),
            types: BTreeSet.new(),
            imports: BTreeSet.new(),
            symbol_count: 0
        )

    # Extract context from a module, focusing on symbols used by target
    # Uses Parser and ApiSurface via FFI
    static fn from_target(target: text, source_file: text) -> ContextPack:
        # Extract API surface from source file
        val api_json = rt_api_surface_extract(source_file)

        # Find symbols used by target function
        val usage_json = rt_symbol_usage_find(source_file, target)

        # Create context pack
        var pack = ContextPack.new(target)

        # Parse symbol usage from JSON array
        # Format: ["symbol1", "symbol2", ...]
        val symbols = parse_json_string_array(usage_json)

        # Add symbols to the pack
        for symbol in symbols:
            # Add to types set (we treat all symbols as types for now)
            pack.types.insert(symbol)
            pack.symbol_count = pack.symbol_count + 1

        pack

    # Extract context with minimal mode (only directly used symbols, no transitive deps)
    # Uses Parser and ApiSurface via FFI - same as from_target but minimal mode
    static fn from_target_minimal(target: text, source_file: text) -> ContextPack:
        # For minimal mode, we return only the symbols directly used by the target
        # (same as from_target for now, since rt_symbol_usage_find already returns direct deps)
        ContextPack.from_target(target, source_file)

    # Export as JSON (for LLM API consumption)
    fn to_json() -> Result<text, text>:
        var obj = json_object()
        obj.add_string("target", self.target)
        obj.add_number("symbol_count", self.symbol_count as f64)

        # Add types array
        var types_arr = json_array()
        val types_array = self.types.to_array()
        var i = 0
        while i < types_array.len():
            types_arr.push_string(types_array[i].as_text())
            i = i + 1
        obj.add_array("types", types_arr)

        # Add functions array
        var funcs_arr = json_array()
        val func_entries = self.functions.entries()
        i = 0
        while i < func_entries.len():
            val entry = func_entries[i]
            val name = entry[0].as_text()
            val sig = entry[1]  # FunctionSignature stored as RuntimeValue
            var func_obj = json_object()
            func_obj.add_string("name", name)
            func_obj.add_bool("is_public", sig.is_public)
            func_obj.add_bool("is_async", sig.is_async)

            # Add parameters
            var params_arr = json_array()
            var j = 0
            while j < sig.params.len():
                val param = sig.params[j]
                var param_obj = json_object()
                param_obj.add_string("name", param.name)
                match param.type_name:
                    Some(t):
                        param_obj.add_string("type", t)
                    nil:
                        param_obj.add_null("type")
                params_arr.push_object(param_obj)
                j = j + 1
            func_obj.add_array("params", params_arr)

            # Add return type
            match sig.return_type:
                Some(ret):
                    func_obj.add_string("return_type", ret)
                nil:
                    func_obj.add_null("return_type")

            funcs_arr.push_object(func_obj)
            i = i + 1
        obj.add_array("functions", funcs_arr)

        # Add imports array
        var imports_arr = json_array()
        val imports_array = self.imports.to_array()
        i = 0
        while i < imports_array.len():
            imports_arr.push_string(imports_array[i].as_text())
            i = i + 1
        obj.add_array("imports", imports_arr)

        Ok(obj.to_pretty_string())

    # Export as compact JSON (single line)
    fn to_json_compact() -> Result<text, text>:
        var obj = json_object()
        obj.add_string("target", self.target)
        obj.add_number("symbol_count", self.symbol_count as f64)

        # Add types array
        var types_arr = json_array()
        val types_array = self.types.to_array()
        var i = 0
        while i < types_array.len():
            types_arr.push_string(types_array[i].as_text())
            i = i + 1
        obj.add_array("types", types_arr)

        # Add functions array
        var funcs_arr = json_array()
        val func_entries = self.functions.entries()
        i = 0
        while i < func_entries.len():
            val entry = func_entries[i]
            val name = entry[0].as_text()
            val sig = entry[1]  # FunctionSignature stored as RuntimeValue
            var func_obj = json_object()
            func_obj.add_string("name", name)
            func_obj.add_bool("is_public", sig.is_public)
            func_obj.add_bool("is_async", sig.is_async)

            # Add parameters
            var params_arr = json_array()
            var j = 0
            while j < sig.params.len():
                val param = sig.params[j]
                var param_obj = json_object()
                param_obj.add_string("name", param.name)
                match param.type_name:
                    Some(t):
                        param_obj.add_string("type", t)
                    nil:
                        param_obj.add_null("type")
                params_arr.push_object(param_obj)
                j = j + 1
            func_obj.add_array("params", params_arr)

            # Add return type
            match sig.return_type:
                Some(ret):
                    func_obj.add_string("return_type", ret)
                nil:
                    func_obj.add_null("return_type")

            funcs_arr.push_object(func_obj)
            i = i + 1
        obj.add_array("functions", funcs_arr)

        # Add imports array
        var imports_arr = json_array()
        val imports_array = self.imports.to_array()
        i = 0
        while i < imports_array.len():
            imports_arr.push_string(imports_array[i].as_text())
            i = i + 1
        obj.add_array("imports", imports_arr)

        Ok(obj.to_string())

    # Export as Markdown (human-readable documentation)
    fn to_markdown() -> text:
        var md = ""

        md = md + "# Context Pack: {self.target}\n\n"
        md = md + "**Symbols:** {self.symbol_count}\n\n"

        # Types section
        if not self.types.is_empty():
            md = md + "## Types Used\n\n"
            val types_array = self.types.to_array()
            var i = 0
            while i < types_array.len():
                val ty = types_array[i].as_text()
                md = md + "- `{ty}`\n"
                i = i + 1
            md = md + "\n"

        # Functions section
        if not self.functions.is_empty():
            md = md + "## Functions\n\n"
            val func_entries = self.functions.entries()
            var i = 0
            while i < func_entries.len():
                val entry = func_entries[i]
                val name = entry[0].as_text()
                val sig = entry[1]
                md = md + "### `{name}`\n\n"

                # Parameters
                if not sig.params.is_empty():
                    md = md + "**Parameters:**\n"
                    var j = 0
                    while j < sig.params.len():
                        val param = sig.params[j]
                        val type_str = match param.type_name:
                            Some(t): t
                            nil: "any"
                        md = md + "- `{param.name}`: {type_str}\n"
                        j = j + 1
                    md = md + "\n"

                # Return type
                match sig.return_type:
                    Some(ret):
                        md = md + "**Returns:** `{ret}`\n\n"
                    nil:
                        pass

                # Async marker
                if sig.is_async:
                    md = md + "*Async function*\n\n"

                i = i + 1

        # Imports section
        if not self.imports.is_empty():
            md = md + "## Required Imports\n\n"
            md = md + "```simple\n"
            val imports_array = self.imports.to_array()
            var i = 0
            while i < imports_array.len():
                val import_path = imports_array[i].as_text()
                md = md + "use {import_path}\n"
                i = i + 1
            md = md + "```\n\n"

        md = md + "---\n"
        md = md + "*Generated by Simple Context Pack Generator*\n"

        md

    # Export as plain text (for LLM prompts)
    fn to_text() -> text:
        var text = ""

        text = text + "Context for: {self.target}\n"
        text = text + "Symbols: {self.symbol_count}\n\n"

        # Types section
        if not self.types.is_empty():
            text = text + "Types:\n"
            val types_array = self.types.to_array()
            var i = 0
            while i < types_array.len():
                val ty = types_array[i].as_text()
                text = text + "  {ty}\n"
                i = i + 1
            text = text + "\n"

        # Functions section
        if not self.functions.is_empty():
            text = text + "Functions:\n"
            val func_entries = self.functions.entries()
            var i = 0
            while i < func_entries.len():
                val entry = func_entries[i]
                val name = entry[0].as_text()
                val sig = entry[1]

                # Build parameters string
                var params_str = ""
                var j = 0
                while j < sig.params.len():
                    val param = sig.params[j]
                    val type_str = match param.type_name:
                        Some(t): t
                        None: "any"
                    if j > 0:
                        params_str = params_str + ", "
                    params_str = params_str + "{param.name}: {type_str}"
                    j = j + 1

                # Return type
                val ret = match sig.return_type:
                    Some(t): t
                    nil: "void"

                text = text + "  {name} ({params_str}) -> {ret}\n"
                i = i + 1

        text

    # Calculate token reduction estimate
    # Returns percentage of tokens saved (0-100)
    fn token_savings(full_context_symbols: u64) -> f64:
        if full_context_symbols == 0:
            return 0.0

        val reduction = if full_context_symbols >= self.symbol_count:
            (full_context_symbols - self.symbol_count) as f64
        else:
            0.0

        (reduction / (full_context_symbols as f64)) * 100.0

# Statistics about context generation
struct ContextStats:
    full_symbol_count: u64
    extracted_symbol_count: u64
    reduction_percentage: f64
    estimated_tokens_saved: u64

impl ContextStats:
    # Create stats from full and extracted symbol counts
    static fn new(full: u64, extracted: u64) -> ContextStats:
        val reduction = if full > 0:
            (((full - extracted) as f64) / (full as f64)) * 100.0
        else:
            0.0

        # Rough estimate: ~3 tokens per symbol
        val tokens_saved = (full - extracted) * 3

        ContextStats(
            full_symbol_count: full,
            extracted_symbol_count: extracted,
            reduction_percentage: reduction,
            estimated_tokens_saved: tokens_saved
        )

# Helper: Parse JSON array of strings
# Input: '["symbol1", "symbol2", "symbol3"]'
# Output: ["symbol1", "symbol2", "symbol3"]
fn parse_json_string_array(json: text) -> List<text>:
    var result = []

    # Remove whitespace, brackets
    var trimmed = json.trim()
    if trimmed.len() < 2:
        return result

    # Remove leading [ and trailing ]
    if trimmed.starts_with("["):
        trimmed = trimmed.substring(1, trimmed.len())
    if trimmed.ends_with("]"):
        trimmed = trimmed.substring(0, trimmed.len() - 1)

    # Split by comma
    val parts = trimmed.split(",")

    for part in parts:
        var cleaned = part.trim()

        # Remove quotes
        if cleaned.starts_with("\""):
            cleaned = cleaned.substring(1, cleaned.len())
        if cleaned.ends_with("\""):
            cleaned = cleaned.substring(0, cleaned.len() - 1)

        if cleaned.len() > 0:
            result.append(cleaned)

    result

