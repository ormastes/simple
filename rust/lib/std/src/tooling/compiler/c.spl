# C/C++ Compiler Adapter
# Wrapper around gcc/clang/make/cmake

use tooling.core.project.{Language, LanguageConfig}
use tooling.compiler.compiler_interface.{LanguageCompiler, CompilationMode, CompilationResult}
use core.result.{Result, Ok, Err}

# FFI for process execution
@extern("runtime", "rt_process_run")
fn _rt_process_run(cmd_ptr: &u8, cmd_len: u64, args_ptr: &u8, args_len: u64) -> (i32, text, text)

# C/C++ compiler adapter
pub class CCompiler:
    pub language: Language
    pub compiler_cmd: text  # gcc or clang
    pub use_cmake: bool

    pub fn new(is_cpp: bool, use_cmake: bool) -> CCompiler:
        """Create C/C++ compiler.

        Args:
            is_cpp: True for C++, false for C
            use_cmake: Use CMake build system

        Returns:
            Compiler instance
        """
        CCompiler {
            language: if is_cpp then Language.Cpp else Language.C,
            compiler_cmd: if is_cpp then "g++" else "gcc",
            use_cmake: use_cmake
        }

    pub fn compile(
        self,
        config: LanguageConfig,
        mode: CompilationMode,
        incremental: bool
    ) -> CompilationResult:
        """Compile C/C++ project.

        Uses gcc/clang directly or via CMake.

        Args:
            config: Language configuration
            mode: Debug or Release
            incremental: Use incremental compilation (via make)

        Returns:
            Compilation result
        """
        start_time = time.now()

        # Determine build command
        build_cmd = if self.use_cmake:
            self.get_cmake_command(mode, config)
        else:
            self.get_compiler_command(mode, config)

        # Execute build command
        val cmd = if self.use_cmake: "cmake" else: self.compiler_cmd
        val args = if self.use_cmake:
            "-B {config.output_dir} && cmake --build {config.output_dir}"
        else:
            build_cmd.substring(cmd.len() + 1, build_cmd.len())
        val (exit_code, stdout, stderr) = _rt_process_run(cmd.ptr(), cmd.len(), args.ptr(), args.len())

        # Parse errors and warnings from output
        var errors: List<text> = []
        var warnings: List<text> = []
        for line in stderr.lines():
            if line.contains("error:"):
                errors.append(line)
            elif line.contains("warning:"):
                warnings.append(line)

        CompilationResult {
            status: if exit_code == 0 { "success" } else { "failed" },
            output_path: config.output_dir + "/" + config.name,
            duration_ms: time.now() - start_time,
            errors: errors,
            warnings: warnings
        }

    fn get_compiler_command(mode: CompilationMode, config: LanguageConfig) -> text:
        """Get direct compiler command.

        Args:
            mode: Compilation mode
            config: Language configuration

        Returns:
            Compiler command string
        """
        # Base command
        cmd = self.compiler_cmd

        # Add source files (assuming all .c or .cpp in src/)
        src_ext = if self.language == Language.Cpp then "cpp" else "c"
        cmd = cmd + " src/*.{src_ext}"

        # Add output flag
        cmd = cmd + " -o {config.output_dir}/{config.name}"

        # Add mode-specific flags
        cmd = match mode:
            CompilationMode.Debug ->
                # Debug: include debug symbols, no optimization
                cmd + " -g -O0 -Wall -Wextra"
            CompilationMode.Release ->
                # Release: optimize, strip symbols
                cmd + " -O3 -DNDEBUG -s"

        cmd

    fn get_cmake_command(mode: CompilationMode, config: LanguageConfig) -> text:
        """Get CMake build command.

        Args:
            mode: Compilation mode
            config: Language configuration

        Returns:
            CMake command string
        """
        # Configure step
        build_type = match mode:
            CompilationMode.Debug -> "Debug"
            CompilationMode.Release -> "Release"

        cmake_config = "cmake -B {config.output_dir} -DCMAKE_BUILD_TYPE={build_type}"

        # Build step
        cmake_build = "cmake --build {config.output_dir}"

        # Return both commands (would need to execute sequentially)
        cmake_config + " && " + cmake_build

    pub fn supports_incremental(self) -> bool:
        """Check if incremental compilation is supported.

        Supported when using Make or CMake.

        Returns:
            True if using build system
        """
        self.use_cmake  # Also true for Makefile projects

    pub fn get_default_output_dir(self) -> text:
        """Get default output directory.

        Returns:
            Default output path
        """
        if self.use_cmake:
            "build"
        else:
            "bin"

    pub fn is_cpp(self) -> bool:
        """Check if this is a C++ compiler.

        Returns:
            True if language is C++
        """
        self.language == Language.Cpp

    pub fn is_c(self) -> bool:
        """Check if this is a C compiler.

        Returns:
            True if language is C
        """
        self.language == Language.C

    pub fn is_cmake(self) -> bool:
        """Check if using CMake build system.

        Returns:
            True if CMake is enabled
        """
        self.use_cmake

    pub fn is_direct_compile(self) -> bool:
        """Check if using direct compiler invocation.

        Returns:
            True if not using CMake
        """
        not self.use_cmake

    pub fn get_compiler_name(self) -> text:
        """Get compiler executable name.

        Returns:
            Compiler command (gcc/g++/clang/clang++)

        Example:
            compiler.get_compiler_name()  # → "gcc" or "g++"
        """
        self.compiler_cmd

    pub fn get_build_tool(self) -> text:
        """Get build tool name.

        Returns:
            "cmake" or compiler name

        Example:
            compiler.get_build_tool()  # → "cmake" or "gcc"
        """
        if self.use_cmake:
            "cmake"
        else:
            self.compiler_cmd

    pub fn summary(self) -> text:
        """Get compiler summary.

        Returns:
            Human-readable summary

        Example:
            compiler.summary()
            # → "CCompiler: gcc (cmake)" or "CCompiler: g++ (direct)"
        """
        val build_system = if self.use_cmake: "cmake" else: "direct"
        "CCompiler: {self.compiler_cmd} ({build_system})"

    pub fn run_tests(self, config: LanguageConfig) -> CompilationResult:
        """Run C/C++ tests.

        Assumes tests are built as executables.

        Args:
            config: Language configuration

        Returns:
            Test result
        """
        start_time = time.now()

        # Execute test runner - ctest if cmake, or test_runner binary
        val cmd = if self.use_cmake: "ctest" else: "./test_runner"
        val args = if self.use_cmake: "--test-dir {config.output_dir}" else: ""
        val (exit_code, stdout, stderr) = _rt_process_run(cmd.ptr(), cmd.len(), args.ptr(), args.len())

        var errors: List<text> = []
        for line in stderr.lines():
            if line.contains("FAIL") or line.contains("error"):
                errors.append(line)

        CompilationResult {
            status: if exit_code == 0 { "success" } else { "failed" },
            output_path: "",
            duration_ms: time.now() - start_time,
            errors: errors,
            warnings: []
        }

    pub fn lint(self, config: LanguageConfig) -> List<text>:
        """Run clang-tidy for linting.

        Args:
            config: Language configuration

        Returns:
            List of lint warnings
        """
        val src_ext = if self.language == Language.Cpp then "cpp" else "c"
        val cmd = "clang-tidy"
        val args = "src/*.{src_ext}"
        val (exit_code, stdout, stderr) = _rt_process_run(cmd.ptr(), cmd.len(), args.ptr(), args.len())

        var warnings: List<text> = []
        for line in stdout.lines():
            if not line.trim().is_empty():
                warnings.append(line)
        warnings

    pub fn format(self, config: LanguageConfig) -> bool:
        """Format code using clang-format.

        Args:
            config: Language configuration

        Returns:
            True if successful
        """
        val src_ext = if self.language == Language.Cpp then "cpp" else "c"
        val cmd = "clang-format"
        val args = "-i src/*.{src_ext}"
        val (exit_code, stdout, stderr) = _rt_process_run(cmd.ptr(), cmd.len(), args.ptr(), args.len())

        exit_code == 0

# Trait implementation
impl LanguageCompiler for CCompiler:
    fn compile(config: LanguageConfig, mode: CompilationMode, incremental: bool) -> CompilationResult:
        self.compile(config, mode, incremental)

    fn supports_incremental() -> bool:
        self.supports_incremental()

    fn get_default_output_dir() -> text:
        self.get_default_output_dir()
