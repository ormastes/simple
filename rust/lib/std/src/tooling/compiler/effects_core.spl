# Effect Tracking Core (Lean-Aligned)
#
# Pure effect tracking for formal verification.
# This module maps EXACTLY to Lean 4 formal models in verification/
#
# Sections:
# - AsyncEffect: Async safety tracking (→ verification/async_compile/)
# - NogcInstr: GC allocation tracking (→ verification/nogc_compile/)
#
# Lean-friendly: Pure functions with provable properties,
# corresponds 1:1 with Lean theorems

#=============================================================================
# AsyncEffect - Exact match to AsyncCompile.lean
#=============================================================================
# Lean equivalent:
# inductive Effect
#   | compute
#   | io
#   | wait

# Effect type matching AsyncCompile.lean exactly (3 variants)
enum AsyncEffect:
    # Pure computation
    Compute
    # I/O operation (non-blocking)
    Io
    # Blocking wait operation
    Wait

impl AsyncEffect:
    # Lean: def is_async (e : Effect) : Bool
    # Returns true if effect is non-blocking (compute or io)
    fn is_async() -> bool:
        match self:
            AsyncEffect.Wait -> false
            AsyncEffect.Compute | AsyncEffect.Io -> true

    # Get string name
    fn name() -> text:
        match self:
            AsyncEffect.Compute -> "compute"
            AsyncEffect.Io -> "io"
            AsyncEffect.Wait -> "wait"

# Lean: def pipelineSafe (es : List Effect) : Prop
# Returns true if all effects in list are async-safe
fn pipeline_safe(effects: [AsyncEffect]) -> bool:
    for e in effects:
        if not e.is_async():
            return false
    true

# Lean: theorem append_safe {a b : List Effect} :
#   pipelineSafe a → pipelineSafe b → pipelineSafe (a ++ b)
#
# Appends two effect lists preserving pipeline safety
fn append_safe(a: [AsyncEffect], b: [AsyncEffect]) -> [AsyncEffect]:
    # Precondition: both lists must be pipeline safe
    assert pipeline_safe(a), "Precondition: a must be pipeline safe"
    assert pipeline_safe(b), "Precondition: b must be pipeline safe"

    val result = a + b

    # Postcondition: result must be pipeline safe
    assert pipeline_safe(result), "Postcondition: result must be pipeline safe"
    result

# Lean: theorem wait_detected (e : Effect) : pipelineSafe [e] → e ≠ Effect.wait
#
# If a singleton list is pipeline safe, it cannot contain wait
fn wait_detected(e: AsyncEffect) -> bool:
    if pipeline_safe([e]):
        e != AsyncEffect.Wait
    else:
        true  # vacuously true if not safe

# Check if any effect in list is blocking (contains Wait)
fn has_blocking_effects(effects: [AsyncEffect]) -> bool:
    for e in effects:
        if e == AsyncEffect.Wait:
            return true
    false

# Count number of blocking effects
fn count_blocking(effects: [AsyncEffect]) -> i32:
    var count = 0
    for e in effects:
        if e == AsyncEffect.Wait:
            count = count + 1
    count

# Filter out blocking effects, keeping only async-safe ones
fn filter_async(effects: [AsyncEffect]) -> [AsyncEffect]:
    [for e in effects if e.is_async(): e]

#=============================================================================
# NogcInstr - Exact match to NogcCompile.lean
#=============================================================================
# Lean equivalent:
# inductive Instr
#   | const (n : Nat)
#   | add
#   | gcAlloc

# Instruction type matching NogcCompile.lean exactly (3 variants)
enum NogcInstr:
    # Load constant
    Const(i64)
    # Addition
    Add
    # GC allocation (forbidden in nogc mode)
    GcAlloc

impl NogcInstr:
    # Check if instruction is GC allocation
    fn is_gc_alloc() -> bool:
        match self:
            NogcInstr.GcAlloc -> true
            _ -> false

    # Check if instruction is nogc (not GC allocation)
    fn is_nogc() -> bool:
        not self.is_gc_alloc()

    # Get string name
    fn name() -> text:
        match self:
            NogcInstr.Const(n) -> "const({n})"
            NogcInstr.Add -> "add"
            NogcInstr.GcAlloc -> "gc_alloc"

# Lean: def nogc (p : List Instr) : Prop
# Returns true if no instruction in list is GC allocation
fn nogc(instrs: [NogcInstr]) -> bool:
    for i in instrs:
        if i.is_gc_alloc():
            return false
    true

# Lean: theorem nogc_append {a b : List Instr} :
#   nogc a → nogc b → nogc (append a b)
#
# Appends two instruction lists preserving nogc property
fn nogc_append(a: [NogcInstr], b: [NogcInstr]) -> [NogcInstr]:
    # Precondition: both lists must be nogc
    assert nogc(a), "Precondition: a must be nogc"
    assert nogc(b), "Precondition: b must be nogc"

    val result = a + b

    # Postcondition: result must be nogc
    assert nogc(result), "Postcondition: result must be nogc"
    result

# Lean: theorem nogc_singleton {i : Instr} (h : i ≠ Instr.gcAlloc) : nogc [i]
#
# A singleton list is nogc if and only if the instruction is not gcAlloc
fn nogc_singleton(i: NogcInstr) -> bool:
    not i.is_gc_alloc()

# Check if any instruction allocates on GC heap
fn has_gc_alloc(instrs: [NogcInstr]) -> bool:
    for i in instrs:
        if i.is_gc_alloc():
            return true
    false

# Count number of GC allocations
fn count_gc_allocs(instrs: [NogcInstr]) -> i32:
    var count = 0
    for i in instrs:
        if i.is_gc_alloc():
            count = count + 1
    count

# Filter out GC allocations, keeping only nogc instructions
fn filter_nogc(instrs: [NogcInstr]) -> [NogcInstr]:
    [for i in instrs if i.is_nogc(): i]

#=============================================================================
# Combined Effect Analysis
#=============================================================================

# Combined effect properties for instruction sequences
struct EffectProperties:
    is_pipeline_safe: bool  # No blocking (all async)
    is_nogc: bool           # No GC allocations
    blocking_count: i32     # Number of blocking operations
    gc_alloc_count: i32     # Number of GC allocations

impl EffectProperties:
    # Create properties for async effects
    static fn from_async(effects: [AsyncEffect]) -> EffectProperties:
        EffectProperties(
            is_pipeline_safe: pipeline_safe(effects),
            is_nogc: true,  # Async effects don't track GC
            blocking_count: count_blocking(effects),
            gc_alloc_count: 0
        )

    # Create properties for nogc instructions
    static fn from_nogc(instrs: [NogcInstr]) -> EffectProperties:
        EffectProperties(
            is_pipeline_safe: true,  # Nogc doesn't track blocking
            is_nogc: nogc(instrs),
            blocking_count: 0,
            gc_alloc_count: count_gc_allocs(instrs)
        )

    # Check if effects are safe for optimization
    fn is_optimizable() -> bool:
        self.is_pipeline_safe and self.is_nogc

    # Get severity of effects (0 = pure, higher = more effects)
    fn severity() -> i32:
        self.blocking_count + self.gc_alloc_count
