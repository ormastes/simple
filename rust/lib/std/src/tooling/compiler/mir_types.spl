# MIR Supporting Types
#
# Pure enum types and utilities for MIR instructions.
# Self-contained type definitions with no runtime dependencies.
#
# Lean-friendly: Simple enums with pure predicates, no complex state

# Backend preference for parallel operations
enum ParallelBackend:
    # CPU parallel threads
    Cpu
    # CPU SIMD vectorization
    Simd
    # GPU compute
    Gpu

impl ParallelBackend:
    # Get string name
    fn name() -> text:
        match self:
            ParallelBackend.Cpu -> "cpu"
            ParallelBackend.Simd -> "simd"
            ParallelBackend.Gpu -> "gpu"

    # Check if this uses GPU
    fn is_gpu() -> bool:
        match self:
            ParallelBackend.Gpu -> true
            _ -> false

    # Check if this uses CPU
    fn is_cpu() -> bool:
        match self:
            ParallelBackend.Cpu | ParallelBackend.Simd -> true
            _ -> false

# Kind of contract being checked
enum ContractKind:
    # Precondition (in:/requires:) - checked at function entry
    Precondition
    # Postcondition (out(ret):/ensures:) - checked on success return
    Postcondition
    # Error postcondition (out_err(err):) - checked on error return
    ErrorPostcondition
    # Invariant at function entry
    InvariantEntry
    # Invariant at function exit
    InvariantExit
    # Inline assertion (assert/check statement)
    Assertion

impl ContractKind:
    # Get string name
    fn name() -> text:
        match self:
            ContractKind.Precondition -> "precondition"
            ContractKind.Postcondition -> "postcondition"
            ContractKind.ErrorPostcondition -> "error_postcondition"
            ContractKind.InvariantEntry -> "invariant_entry"
            ContractKind.InvariantExit -> "invariant_exit"
            ContractKind.Assertion -> "assertion"

    # Check if this is a precondition
    fn is_precondition() -> bool:
        match self:
            ContractKind.Precondition -> true
            _ -> false

    # Check if this is a postcondition (any kind)
    fn is_postcondition() -> bool:
        match self:
            ContractKind.Postcondition | ContractKind.ErrorPostcondition -> true
            _ -> false

    # Check if this is an invariant (any kind)
    fn is_invariant() -> bool:
        match self:
            ContractKind.InvariantEntry | ContractKind.InvariantExit -> true
            _ -> false

    # Check if this is checked at function entry
    fn checked_at_entry() -> bool:
        match self:
            ContractKind.Precondition | ContractKind.InvariantEntry -> true
            _ -> false

    # Check if this is checked at function exit
    fn checked_at_exit() -> bool:
        match self:
            ContractKind.Postcondition | ContractKind.ErrorPostcondition | ContractKind.InvariantExit -> true
            _ -> false

# Overflow behavior for unit bound checks
enum UnitOverflowBehavior:
    # Default: panic in debug mode, no-op in release mode
    Default
    # Always panic on overflow (checked arithmetic)
    Checked
    # Clamp to range bounds
    Saturate
    # Wrap around (modulo range)
    Wrap

impl UnitOverflowBehavior:
    # Get string name
    fn name() -> text:
        match self:
            UnitOverflowBehavior.Default -> "default"
            UnitOverflowBehavior.Checked -> "checked"
            UnitOverflowBehavior.Saturate -> "saturate"
            UnitOverflowBehavior.Wrap -> "wrap"

    # Check if this is the default behavior
    fn is_default() -> bool:
        match self:
            UnitOverflowBehavior.Default -> true
            _ -> false

    # Check if this always checks for overflow
    fn is_checked() -> bool:
        match self:
            UnitOverflowBehavior.Checked -> true
            _ -> false

# GPU memory fence scope
enum GpuMemoryScope:
    # Work group local memory only
    WorkGroup
    # Global device memory
    Device
    # All memory (work group + device)
    All

impl GpuMemoryScope:
    # Get string name
    fn name() -> text:
        match self:
            GpuMemoryScope.WorkGroup -> "workgroup"
            GpuMemoryScope.Device -> "device"
            GpuMemoryScope.All -> "all"

    # Check if includes work group memory
    fn includes_workgroup() -> bool:
        match self:
            GpuMemoryScope.WorkGroup | GpuMemoryScope.All -> true
            _ -> false

    # Check if includes device memory
    fn includes_device() -> bool:
        match self:
            GpuMemoryScope.Device | GpuMemoryScope.All -> true
            _ -> false

# GPU atomic operation type
enum GpuAtomicOp:
    # Atomic add
    Add
    # Atomic subtract
    Sub
    # Atomic minimum
    Min
    # Atomic maximum
    Max
    # Atomic bitwise AND
    And
    # Atomic bitwise OR
    Or
    # Atomic bitwise XOR
    Xor
    # Atomic exchange
    Xchg

impl GpuAtomicOp:
    # Get string name
    fn name() -> text:
        match self:
            GpuAtomicOp.Add -> "add"
            GpuAtomicOp.Sub -> "sub"
            GpuAtomicOp.Min -> "min"
            GpuAtomicOp.Max -> "max"
            GpuAtomicOp.And -> "and"
            GpuAtomicOp.Or -> "or"
            GpuAtomicOp.Xor -> "xor"
            GpuAtomicOp.Xchg -> "xchg"

    # Check if this is an arithmetic operation
    fn is_arithmetic() -> bool:
        match self:
            GpuAtomicOp.Add | GpuAtomicOp.Sub -> true
            _ -> false

    # Check if this is a comparison operation
    fn is_comparison() -> bool:
        match self:
            GpuAtomicOp.Min | GpuAtomicOp.Max -> true
            _ -> false

    # Check if this is a bitwise operation
    fn is_bitwise() -> bool:
        match self:
            GpuAtomicOp.And | GpuAtomicOp.Or | GpuAtomicOp.Xor -> true
            _ -> false

# How a variable is captured by a closure
enum CaptureMode:
    # Capture by value (copy)
    ByValue
    # Capture by reference (borrow)
    ByRef
    # Capture by mutable reference
    ByMutRef

impl CaptureMode:
    # Get string name
    fn name() -> text:
        match self:
            CaptureMode.ByValue -> "by_value"
            CaptureMode.ByRef -> "by_ref"
            CaptureMode.ByMutRef -> "by_mut_ref"

    # Check if this is by value
    fn is_by_value() -> bool:
        match self:
            CaptureMode.ByValue -> true
            _ -> false

    # Check if this is a reference (any kind)
    fn is_reference() -> bool:
        match self:
            CaptureMode.ByRef | CaptureMode.ByMutRef -> true
            _ -> false

    # Check if this is mutable
    fn is_mutable() -> bool:
        match self:
            CaptureMode.ByMutRef -> true
            _ -> false

# Literal value for pattern matching
enum MirLiteral:
    Int(i64)
    Float(f64)
    Bool(bool)
    String(text)
    Nil

impl MirLiteral:
    # Get type name
    fn type_name() -> text:
        match self:
            MirLiteral.Int(_) -> "int"
            MirLiteral.Float(_) -> "float"
            MirLiteral.Bool(_) -> "bool"
            MirLiteral.String(_) -> "string"
            MirLiteral.Nil -> "nil"

    # Check if this is a number (int or float)
    fn is_number() -> bool:
        match self:
            MirLiteral.Int(_) | MirLiteral.Float(_) -> true
            _ -> false

    # Check if this is nil
    fn is_nil() -> bool:
        match self:
            MirLiteral.Nil -> true
            _ -> false

    # Convert to boolean for truthiness
    fn to_bool() -> bool:
        match self:
            MirLiteral.Bool(b) -> b
            MirLiteral.Nil -> false
            MirLiteral.Int(0) -> false
            MirLiteral.Float(0.0) -> false
            MirLiteral.String("") -> false
            _ -> true

# Step in a pattern binding path
enum BindingStep:
    # Tuple index
    TupleIndex(i32)
    # Struct field
    FieldName(text)
    # Enum payload
    EnumPayload

impl BindingStep:
    # Get string representation
    fn to_string() -> text:
        match self:
            BindingStep.TupleIndex(i) -> ".{i}"
            BindingStep.FieldName(n) -> ".{n}"
            BindingStep.EnumPayload -> ".payload"

    # Check if this is a tuple index
    fn is_tuple_index() -> bool:
        match self:
            BindingStep.TupleIndex(_) -> true
            _ -> false

    # Check if this is a field access
    fn is_field() -> bool:
        match self:
            BindingStep.FieldName(_) -> true
            _ -> false

# Pattern binding with path
struct PatternBinding:
    name: text
    path: [BindingStep]

impl PatternBinding:
    # Create new binding
    static fn new(name: text) -> PatternBinding:
        PatternBinding(name: name, path: [])

    # Add a step to the path
    me add_step(step: BindingStep):
        self.path = self.path + [step]

    # Get full path as string
    fn path_string() -> text:
        var result = self.name
        for step in self.path:
            result = result + step.to_string()
        result

    # Get path depth
    fn depth() -> i32:
        self.path.length()

# F-string part (literal or expression placeholder)
enum FStringPart:
    # Literal string part
    Literal(text)
    # Expression placeholder (register index)
    Expr(i32)

impl FStringPart:
    # Check if this is a literal
    fn is_literal() -> bool:
        match self:
            FStringPart.Literal(_) -> true
            _ -> false

    # Check if this is an expression
    fn is_expr() -> bool:
        match self:
            FStringPart.Expr(_) -> true
            _ -> false

    # Get total literal length from parts list
    static fn total_literal_length(parts: [FStringPart]) -> i32:
        var length = 0
        for part in parts:
            match part:
                FStringPart.Literal(s) -> length = length + s.length()
                FStringPart.Expr(_) -> ()  # Skip expressions
        length

    # Count expressions in parts list
    static fn count_expressions(parts: [FStringPart]) -> i32:
        var count = 0
        for part in parts:
            if part.is_expr():
                count = count + 1
        count
