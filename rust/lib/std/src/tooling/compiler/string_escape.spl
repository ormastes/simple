# String Escape Processing
#
# Pure functional escape sequence processing for lexer.
# Handles standard escape sequences (\n, \t, etc.) with optional brace escaping.
#
# Lean-friendly: Pure functions, bijective escape/unescape mappings,
# provable properties (e.g., unescape(escape(s)) = s)

# Result of processing an escape sequence
enum EscapeResult:
    # Successfully processed escape, contains the character
    Char(char)
    # Invalid escape sequence error with message
    Error(text)
    # Unterminated string (EOF after backslash)
    Unterminated

# Process a single escape sequence character
# Input: the character after the backslash
# allow_braces: whether to allow \{ and \} escapes (for interpolation)
fn process_escape(c: char, allow_braces: bool) -> EscapeResult:
    if c == 'n':
        EscapeResult.Char('\n')
    else if c == 't':
        EscapeResult.Char('\t')
    else if c == 'r':
        EscapeResult.Char('\r')
    else if c == '\\':
        EscapeResult.Char('\\')
    else if c == '"':
        EscapeResult.Char('"')
    else if c == '0':
        EscapeResult.Char('\0')
    else if c == '{' and allow_braces:
        EscapeResult.Char('{')
    else if c == '}' and allow_braces:
        EscapeResult.Char('}')
    else:
        EscapeResult.Error("Invalid escape sequence: \\{c}")

# Escape a string for display (inverse of unescape)
# Converts special characters to escape sequences
fn escape_string(s: text) -> text:
    var result = ""
    for c in s:
        if c == '\n':
            result = result + "\\n"
        else if c == '\t':
            result = result + "\\t"
        else if c == '\r':
            result = result + "\\r"
        else if c == '\\':
            result = result + "\\\\"
        else if c == '"':
            result = result + "\\\""
        else if c == '\0':
            result = result + "\\0"
        else:
            result = result + c.to_string()
    result

# Unescape a string (inverse of escape_string)
# Converts escape sequences to their actual characters
# Returns None if the string contains invalid escapes
fn unescape_string(s: text) -> Option<text>:
    var result = ""
    var i = 0
    while i < s.length():
        val c = s[i]
        if c == '\\':
            if i + 1 >= s.length():
                return None  # Unterminated escape
            val next = s[i + 1]
            val escape_result = process_escape(next, allow_braces: false)
            match escape_result:
                EscapeResult.Char(ch) ->
                    result = result + ch.to_string()
                    i = i + 2
                EscapeResult.Error(_) | EscapeResult.Unterminated ->
                    return None
        else:
            result = result + c.to_string()
            i = i + 1
    Some(result)

# Escape a character for display
fn escape_char(c: char) -> text:
    if c == '\n':
        "\\n"
    else if c == '\t':
        "\\t"
    else if c == '\r':
        "\\r"
    else if c == '\\':
        "\\\\"
    else if c == '"':
        "\\\""
    else if c == '\0':
        "\\0"
    else:
        c.to_string()

# Check if a character needs escaping
fn needs_escape(c: char) -> bool:
    c == '\n' or c == '\t' or c == '\r' or c == '\\' or c == '"' or c == '\0'

# Count escape sequences in a string
fn count_escapes(s: text) -> i32:
    var count = 0
    for c in s:
        if needs_escape(c):
            count = count + 1
    count

# Get the expected length of an escaped string
fn escaped_length(s: text) -> i32:
    var length = 0
    for c in s:
        if needs_escape(c):
            length = length + 2  # Backslash + character
        else:
            length = length + 1
    length
