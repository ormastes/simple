# Spec Generator - Generate markdown documentation from _spec.spl files
# Migrated from: scripts/spec_gen.py
# Purpose: Convert executable specification files to formatted documentation

use fs.{read_text, write_text, list_dir}
use regex.{captures, find_all}

# use time_utils.{current_timestamp_string}  # TODO: Import time utils module

# Represents a parsed _spec.spl file
struct SpecFile:
    path: text
    header_docstring: text
    metadata: List<(text, text)>      # HashMap replacement
    test_cases: List<TestCase>

# Represents a test case from a spec file
struct TestCase:
    name: text
    section: text
    line_number: u64
    docstring: text
    code: text
    symbols: List<text>
    related_tests: List<text>

impl SpecFile:
    # Create a new empty spec file
    static fn new(path: text) -> SpecFile:
        SpecFile(
            path: path,
            header_docstring: "",
            metadata: [],
            test_cases: []
        )

impl TestCase:
    # Create a new test case
    static fn new(name: text, section: text, line_num: u64) -> TestCase:
        TestCase(
            name: name,
            section: section,
            line_number: line_num,
            docstring: "",
            code: "",
            symbols: [],
            related_tests: []
        )

# Parse a _spec.spl file and extract documentation
fn parse_spec_file(filepath: text) -> Result<SpecFile, text>:
    match read_text(filepath):
        Ok(content):
            var spec = SpecFile.new(filepath)
            val lines = content.split("\n")
            var current_section = "General"
            var current_test: Option<TestCase> = None
            var in_docstring = false
            var docstring_lines: List<text> = []
            var code_lines: List<text> = []
            var line_num: u64 = 0

            for line in lines:
                line_num = line_num + 1
                val trimmed = line.trim()

                # Track docstrings (""" ... """)
                if trimmed.starts_with("\"\"\""):
                    if in_docstring:
                        in_docstring = false
                        val docstring = docstring_lines.join("\n")
                        match current_test:
                            Some(test):
                                test.docstring = docstring
                            None:
                                # This is the header docstring
                                spec.header_docstring = docstring
                                # Extract metadata from header
                                spec.metadata = extract_metadata_from_header(docstring)
                        docstring_lines = []
                    else:
                        in_docstring = true
                    continue

                if in_docstring:
                    docstring_lines.push(trimmed)
                    continue

                # Track sections: context "Section Name":
                val section_caps = captures(r"context\s+\"([^\"]+)\":", line)
                if section_caps.len() > 1:
                    current_section = section_caps[1]

                # Track test cases: it "test name":
                val test_caps = captures(r"it\s+\"([^\"]+)\":", line)
                if test_caps.len() > 1:
                    val test_name = test_caps[1]
                    # Save previous test if exists
                    match current_test:
                        Some(test):
                            test.code = code_lines.join("\n")
                            spec.test_cases.push(test)
                        None: pass

                    # Start new test
                    current_test = Some(TestCase.new(test_name, current_section, line_num))
                    code_lines = []

                # Collect code for current test
                match current_test:
                    Some(_):
                        if not trimmed.is_empty() and not trimmed.starts_with("#"):
                            code_lines.push(line)
                    None: pass

            # Save last test if exists
            match current_test:
                Some(test):
                    test.code = code_lines.join("\n")
                    spec.test_cases.push(test)
                None: pass

            Ok(spec)
        Err(e):
            Err("Failed to read file: {e}")

# Helper: Extract metadata from header docstring
fn extract_metadata_from_header(header: text) -> List<(text, text)>:
    var metadata: List<(text, text)> = []

    # Look for patterns like **Key:** Value
    val matches = find_all(r"\*\*([^*]+)\*\*:\s*([^\n]+)", header)
    var i = 0
    while i < matches.len():
        val match_ = matches[i]
        val caps = captures(r"\*\*([^*]+)\*\*:\s*([^\n]+)", match_.text)
        if caps.len() > 2:
            val key = caps[1].trim()
            val value = caps[2].trim()
            metadata.push((key, value))
        i = i + 1

    metadata

# Convert test name to potential symbol names
# Example: "type_inference_basic" -> ["type_inference", "TypeInference", "type_inference_basic"]
# use string_utils.{to_snake_case, to_kebab_case}  # TODO: Import string utils module

fn convert_test_name_to_symbols(test_name: text) -> List<text>:
    var symbols = []

    # Add original name
    symbols.push(test_name)

    # Add snake_case version
    val snake = to_snake_case(test_name)
    if snake != test_name:
        symbols.push(snake)

    # Add kebab-case version
    val kebab = to_kebab_case(test_name)
    if kebab != test_name:
        symbols.push(kebab)

    # Add PascalCase version (capitalize each word after split by _ or -)
    val words = test_name.split("_")
    if words.len() > 1:
        var pascal = ""
        for word in words:
            if word.len() > 0:
                # Capitalize first letter
                val first = word.chars()[0].upper()
                val rest = if word.len() > 1:
                    word.substring(1, word.len())
                else:
                    ""
                pascal = pascal + first + rest
        if pascal.len() > 0:
            symbols.push(pascal)

    # Remove duplicates
        # use list_utils.dedup  # TODO: Import list utils module
    dedup(symbols)

# Extract explicit symbol links from docstring
fn extract_symbols_from_docstring(docstring: text) -> (List<text>, List<text>):
    var symbols: List<text> = []
    var related_tests: List<text> = []

    # Look for **Symbols:** or **Links:** sections
    val symbols_caps = captures(r"\*\*(?:Symbols?|Links?):\*\*\s*([^\n]+)", docstring)
    if symbols_caps.len() > 1:
        val symbols_str = symbols_caps[1]
        # Split by comma and extract each symbol
        val parts = symbols_str.split(",")
        var i = 0
        while i < parts.len():
            val symbol = parts[i].trim().replace("`", "")
            if not symbol.is_empty():
                symbols.push(symbol)
            i = i + 1

    # Look for **Related Tests:** section (use ** instead of ^ in regex)
    val tests_caps = captures(r"\*\*Related Tests?:\*\*\s*([^\n]+)", docstring)
    if tests_caps.len() > 1:
        val tests_str = tests_caps[1]
        val parts = tests_str.split(",")
        var j = 0
        while j < parts.len():
            val test = parts[j].trim().replace("[", "").replace("]", "")
            if not test.is_empty():
                related_tests.push(test)
            j = j + 1

    (symbols, related_tests)

# Scan code for potential symbol references
fn scan_code_for_symbols(code: text) -> List<text>:
    var symbols: List<text> = []

    # Find function calls: identifier()
    val fn_calls = find_all(r"\b([a-zA-Z_][a-zA-Z0-9_]*)\s*\(", code)
    var i = 0
    while i < fn_calls.len():
        val match_ = fn_calls[i]
        val caps = captures(r"\b([a-zA-Z_][a-zA-Z0-9_]*)\s*\(", match_.text)
        if caps.len() > 1:
            val fn_name = caps[1]
            if not symbols.contains(fn_name):
                symbols.push(fn_name)
        i = i + 1

    # Find method calls: object.method()
    val method_calls = find_all(r"\.([a-zA-Z_][a-zA-Z0-9_]*)\s*\(", code)
    var j = 0
    while j < method_calls.len():
        val match_ = method_calls[j]
        val caps = captures(r"\.([a-zA-Z_][a-zA-Z0-9_]*)\s*\(", match_.text)
        if caps.len() > 1:
            val method_name = caps[1]
            if not symbols.contains(method_name):
                symbols.push(method_name)
        j = j + 1

    # Find type usage: Type.variant or Type.method (avoid special chars)
    val type_refs = find_all(r"\b([A-Z][a-zA-Z0-9_]*).", code)
    var k = 0
    while k < type_refs.len():
        val match_ = type_refs[k]
        val caps = captures(r"\b([A-Z][a-zA-Z0-9_]*).", match_.text)
        if caps.len() > 1:
            val type_name = caps[1]
            if not symbols.contains(type_name):
                symbols.push(type_name)
        k = k + 1

    symbols

# Generate markdown documentation from parsed spec
fn generate_markdown(spec: SpecFile, current_time: text) -> text:
    var md = ""

    # Extract title from header or use filename
    val title = extract_title_or_default(spec.header_docstring, spec.path)

    # Header
    md = md + "# {title}\n\n"
    md = md + "> **⚠️ GENERATED FILE** - Do not edit directly!\n"
    md = md + "> **Source:** `{spec.path}`\n"
    md = md + "> **Generated:** {current_time}\n"
    md = md + ">\n"
    md = md + "> To update this file, edit the source _spec.spl file and run:\n"
    md = md + "> ```bash\n"
    md = md + "> simple run spec_gen.spl --input {spec.path}\n"
    md = md + "> ```\n\n"

    # Metadata
    if not spec.metadata.is_empty():
        var i = 0
        while i < spec.metadata.len():
            val (key, value) = spec.metadata[i]
            # Skip certain metadata that goes in header
            if key != "Migrated From" and key != "Source" and key != "Type":
                md = md + "**{key}:** {value}\n"
            i = i + 1
        md = md + "\n"

    # Quick Navigation TOC
    md = md + "## Quick Navigation\n\n"
    md = md + "- [Overview](#overview)\n"
    md = md + "- [Test Cases](#test-cases) ({spec.test_cases.len()} tests)\n"
    md = md + "- [Source Code](#source-code)\n\n"

    md = md + "---\n\n"

    # Test cases summary table
    if not spec.test_cases.is_empty():
        md = md + "## Test Cases ({spec.test_cases.len()} total)\n\n"
        md = md + "| # | Test | Section | Description |\n"
        md = md + "|---|------|---------|-------------|\n"

        var i = 0
        while i < spec.test_cases.len():
            val tc = spec.test_cases[i]
            val num = i + 1

            # Get first line of docstring as description
            val desc = get_first_line(tc.docstring, 40)
            val escaped_desc = escape_markdown_table(desc)

            md = md + "| {num} | [{tc.name}](#test-{num}) | {tc.section} | {escaped_desc} |\n"
            i = i + 1

        md = md + "\n---\n\n"

    # Detailed test cases
    var i = 0
    while i < spec.test_cases.len():
        val tc = spec.test_cases[i]
        val num = i + 1

        md = md + "### Test {num}: {tc.section}\n\n"

        if tc.line_number > 0:
            md = md + "*Source line: ~{tc.line_number}*\n\n"

        md = md + "**Test name:** `{tc.name}`\n\n"

        if not tc.docstring.is_empty():
            md = md + "**Description:**\n\n"
            md = md + "{tc.docstring}\n\n"

        # Linked symbols (if any)
        if not tc.symbols.is_empty():
            md = md + "**Linked Symbols:**\n"
            var j = 0
            val max_symbols = if tc.symbols.len() < 10: tc.symbols.len() else: 10
            while j < max_symbols:
                md = md + "- `{tc.symbols[j]}`\n"
                j = j + 1
            if tc.symbols.len() > 10:
                val remaining = tc.symbols.len() - 10
                md = md + "- ... and {remaining} more\n"
            md = md + "\n"

        # Related tests (if any)
        if not tc.related_tests.is_empty():
            md = md + "**Related Tests:**\n"
            var j = 0
            while j < tc.related_tests.len():
                val related = tc.related_tests[j]
                md = md + "- [{related}](#{related})\n"
                j = j + 1
            md = md + "\n"

        # Code block
        md = md + "**Code:**\n\n"
        md = md + "```simple\n"
        md = md + "{tc.code}\n"
        md = md + "```\n\n"

        i = i + 1

    # Source code section
    md = md + "---\n\n"
    md = md + "## Source Code\n\n"
    md = md + "**View full specification:** [{spec.path}]({spec.path})\n\n"

    # Footer
    md = md + "---\n\n"
    md = md + "*This file was auto-generated from the executable specification.*\n"
    md = md + "*Source: `{spec.path}`*\n\n"

    md

# Helper: Extract title from header docstring or generate from filename
fn extract_title_or_default(header: text, path: text) -> text:
    # Try to extract title from header: # Title
    val title_caps = captures(r"^#\s+(.+)", header)
    if title_caps.len() > 1:
        return title_caps[1].trim()

    # Fallback: generate from filename
    val parts = path.split("/")
    val filename = if parts.len() > 0: parts[parts.len() - 1] else: path
    filename.replace("_spec.spl", "").replace("_spec", "").replace("_", " ")

# Helper: Get first line or N chars of text
fn get_first_line(text: text, max_len: u64) -> text:
    if text.is_empty():
        return ""

    # Find first newline
    var first_line = text
    val lines = text.split("\n")
    if lines.len() > 0:
        first_line = lines[0]

    # Truncate if too long
    if first_line.len() > max_len:
        first_line.slice(0, max_len) + "..."
    else:
        first_line

# Helper: Escape markdown table special characters
fn escape_markdown_table(text: text) -> text:
    # Replace | with \| and newlines with spaces
    text.replace("|", "\\|").replace("\n", " ")

# Write markdown to file
fn write_markdown_file(markdown: text, output_path: text) -> Result<(), text>:
    match write_text(output_path, markdown):
        Ok(_): Ok(())
        Err(e): Err("Failed to write markdown: {e}")

# Generate markdown for all _spec.spl files in directory
fn generate_all(specs_dir: text, output_dir: text) -> Result<(u64, u64), text>:
    var success_count: u64 = 0
    var total_count: u64 = 0

    # List all files in directory
    match list_dir(specs_dir):
        Ok(files):
            for file in files:
                # Only process _spec.spl files
                if file.ends_with("_spec.spl"):
                    total_count = total_count + 1
                    val input_path = "{specs_dir}/{file}"
                    val output_file = file.replace("_spec.spl", "_spec.md")
                    val output_path = "{output_dir}/{output_file}"

                    # Parse and generate
                    match parse_spec_file(input_path):
                        Ok(spec):
                            val md = generate_markdown(spec, current_timestamp_string())
                            match write_markdown_file(md, output_path):
                                Ok(_):
                                    success_count = success_count + 1
                                    print "Generated: {output_path}"
                                Err(e):
                                    print "Error writing {output_path}: {e}"
                        Err(e):
                            print "Error parsing {input_path}: {e}"

            Ok((success_count, total_count))
        Err(e):
            Err("Failed to list directory: {e}")

# Statistics about spec generation
struct SpecStats:
    total_specs: u64
    total_tests: u64
    success_count: u64
    failed_count: u64

impl SpecStats:
    # Create empty stats
    static fn new() -> SpecStats:
        SpecStats(
            total_specs: 0,
            total_tests: 0,
            success_count: 0,
            failed_count: 0
        )

    # Add a successful spec
    me add_success(test_count: u64):
        self.total_specs = self.total_specs + 1
        self.success_count = self.success_count + 1
        self.total_tests = self.total_tests + test_count

    # Add a failed spec
    me add_failure():
        self.total_specs = self.total_specs + 1
        self.failed_count = self.failed_count + 1

    # Generate summary report
    fn summary() -> text:
        var report = ""
        report = report + "Spec Generation Summary:\n"
        report = report + "  Total Specs: {self.total_specs}\n"
        report = report + "  Successful: {self.success_count}\n"
        report = report + "  Failed: {self.failed_count}\n"
        report = report + "  Total Tests: {self.total_tests}\n"
        report

# Main entry point
fn main_spec_gen(args: List<text>) -> Result<(), text>:
    var input_file: Option<text> = None
    var output_file: Option<text> = None
    var all_mode = false
    var specs_dir = "tests/specs"
    var output_dir = "doc/specs"
    var show_help = false

    # Parse arguments
    var i = 0
    while i < args.len():
        val arg = args[i]
        if arg == "--input" or arg == "-i":
            if i + 1 < args.len():
                i = i + 1
                input_file = Some(args[i])
        elif arg == "--output" or arg == "-o":
            if i + 1 < args.len():
                i = i + 1
                output_file = Some(args[i])
        elif arg == "--specs-dir":
            if i + 1 < args.len():
                i = i + 1
                specs_dir = args[i]
        elif arg == "--output-dir":
            if i + 1 < args.len():
                i = i + 1
                output_dir = args[i]
        elif arg == "--all" or arg == "-a":
            all_mode = true
        elif arg == "--help" or arg == "-h":
            show_help = true
        elif not arg.starts_with("-"):
            input_file = Some(arg)
        i = i + 1

    if show_help:
        print "spec-gen: Generate markdown from _spec.spl files"
        print "Usage: simple spec-gen [OPTIONS] [INPUT_FILE]"
        print "Options:"
        print "  -i, --input <FILE>   Input _spec.spl file"
        print "  -o, --output <FILE>  Output .md file"
        print "  -a, --all            Generate all specs in directory"
        print "  --specs-dir <DIR>    Specs directory (default: tests/specs)"
        print "  --output-dir <DIR>   Output directory (default: doc/specs)"
        print "  -h, --help           Show this help"
        return Ok(())

    if all_mode:
        print "Generating all specs from {specs_dir} to {output_dir}..."
        match generate_all(specs_dir, output_dir):
            Ok((success, total)):
                print "Generated {success}/{total} spec files"
                Ok(())
            Err(e): Err(e)
    else:
        match input_file:
            Some(input):
                match parse_spec_file(input):
                    Ok(spec):
                        val md = generate_markdown(spec, current_timestamp_string())
                        val output = match output_file:
                            Some(o): o
                            None: input.replace("_spec.spl", "_spec.md")
                        match write_markdown_file(md, output):
                            Ok(_):
                                print "Generated: {output}"
                                Ok(())
                            Err(e): Err(e)
                    Err(e): Err(e)
            None:
                Err("No input file. Use --input <file> or --all")
