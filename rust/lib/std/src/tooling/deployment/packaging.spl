# Multi-Language Packaging
# Package artifacts from multiple languages into deployable units

use tooling.core.project.{Language, ProjectContext}
use tooling.compiler.compiler_interface.Artifact
use core.result.{Result, Ok, Err}

# Package format
pub enum PackageFormat:
    Tarball     # .tar.gz archive
    Zip         # .zip archive
    Deb         # Debian package
    Rpm         # RPM package
    NuGet       # NuGet package
    Npm         # NPM package
    PyPI        # Python wheel/sdist

    pub fn get_extension(self) -> text:
        """Get file extension for package format.

        Returns:
            File extension

        Example:
            PackageFormat.Tarball.get_extension()  # → ".tar.gz"
        """
        match self:
            PackageFormat.Tarball: ".tar.gz"
            PackageFormat.Zip: ".zip"
            PackageFormat.Deb: ".deb"
            PackageFormat.Rpm: ".rpm"
            PackageFormat.NuGet: ".nupkg"
            PackageFormat.Npm: ".tgz"
            PackageFormat.PyPI: ".whl"

    pub fn to_string(self) -> text:
        """Convert package format to string.

        Returns:
            Format name

        Example:
            PackageFormat.Deb.to_string()  # → "debian"
        """
        match self:
            PackageFormat.Tarball: "tarball"
            PackageFormat.Zip: "zip"
            PackageFormat.Deb: "debian"
            PackageFormat.Rpm: "rpm"
            PackageFormat.NuGet: "nuget"
            PackageFormat.Npm: "npm"
            PackageFormat.PyPI: "python"

    pub fn description(self) -> text:
        """Get package format description.

        Returns:
            Human-readable description

        Example:
            PackageFormat.Deb.description()
            # → "Debian package (.deb)"
        """
        match self:
            PackageFormat.Tarball: "Tarball archive (.tar.gz)"
            PackageFormat.Zip: "Zip archive (.zip)"
            PackageFormat.Deb: "Debian package (.deb)"
            PackageFormat.Rpm: "RPM package (.rpm)"
            PackageFormat.NuGet: "NuGet package (.nupkg)"
            PackageFormat.Npm: "NPM package (.tgz)"
            PackageFormat.PyPI: "Python wheel (.whl)"

    pub fn is_archive(self) -> bool:
        """Check if format is a generic archive.

        Returns:
            True for tarball/zip

        Example:
            PackageFormat.Tarball.is_archive()  # → true
            PackageFormat.Deb.is_archive()  # → false
        """
        match self:
            PackageFormat.Tarball: true
            PackageFormat.Zip: true
            PackageFormat.Deb: false
            PackageFormat.Rpm: false
            PackageFormat.NuGet: false
            PackageFormat.Npm: false
            PackageFormat.PyPI: false

    pub fn is_linux_package(self) -> bool:
        """Check if format is a Linux package.

        Returns:
            True for deb/rpm
        """
        match self:
            PackageFormat.Tarball: false
            PackageFormat.Zip: false
            PackageFormat.Deb: true
            PackageFormat.Rpm: true
            PackageFormat.NuGet: false
            PackageFormat.Npm: false
            PackageFormat.PyPI: false

    pub fn is_language_package(self) -> bool:
        """Check if format is language-specific.

        Returns:
            True for npm/pypi/nuget
        """
        match self:
            PackageFormat.Tarball: false
            PackageFormat.Zip: false
            PackageFormat.Deb: false
            PackageFormat.Rpm: false
            PackageFormat.NuGet: true
            PackageFormat.Npm: true
            PackageFormat.PyPI: true

    pub fn is_tarball(self) -> bool:
        """Check if format is Tarball.

        Returns:
            True for Tarball variant
        """
        match self:
            PackageFormat.Tarball: true
            _: false

    pub fn is_zip(self) -> bool:
        """Check if format is Zip.

        Returns:
            True for Zip variant
        """
        match self:
            PackageFormat.Zip: true
            _: false

    pub fn is_deb(self) -> bool:
        """Check if format is Deb.

        Returns:
            True for Deb variant
        """
        match self:
            PackageFormat.Deb: true
            _: false

    pub fn is_rpm(self) -> bool:
        """Check if format is Rpm.

        Returns:
            True for Rpm variant
        """
        match self:
            PackageFormat.Rpm: true
            _: false

    pub fn is_nuget(self) -> bool:
        """Check if format is NuGet.

        Returns:
            True for NuGet variant
        """
        match self:
            PackageFormat.NuGet: true
            _: false

    pub fn is_npm(self) -> bool:
        """Check if format is Npm.

        Returns:
            True for Npm variant
        """
        match self:
            PackageFormat.Npm: true
            _: false

    pub fn is_pypi(self) -> bool:
        """Check if format is PyPI.

        Returns:
            True for PyPI variant
        """
        match self:
            PackageFormat.PyPI: true
            _: false

    pub fn summary(self) -> text:
        """Get package format summary.

        Returns:
            Human-readable summary

        Example:
            PackageFormat.Deb.summary()
            # → "PackageFormat: debian (Debian package (.deb), linux package)"
        """
        val name = self.to_string()
        val desc = self.description()
        var props = []

        if self.is_archive():
            props.append("archive")
        if self.is_linux_package():
            props.append("linux package")
        if self.is_language_package():
            props.append("language package")

        if props.len() > 0:
            val props_str = props.join(", ")
            "PackageFormat: {name} ({desc}, {props_str})"
        else:
            "PackageFormat: {name} ({desc})"

# Package metadata
pub class PackageMetadata:
    pub name: text
    pub version: text
    pub description: text
    pub author: text
    pub license: text
    pub homepage: text
    pub dependencies: List<text>

    pub fn new(name: text, version: text) -> PackageMetadata:
        """Create package metadata.

        Args:
            name: Package name
            version: Package version

        Returns:
            Package metadata
        """
        PackageMetadata {
            name: name,
            version: version,
            description: "",
            author: "",
            license: "MIT",
            homepage: "",
            dependencies: []
        }

    pub fn has_description(self) -> bool:
        """Check if description is set.

        Returns:
            True if description is non-empty
        """
        not self.description.is_empty()

    pub fn has_author(self) -> bool:
        """Check if author is set.

        Returns:
            True if author is non-empty
        """
        not self.author.is_empty()

    pub fn has_homepage(self) -> bool:
        """Check if homepage is set.

        Returns:
            True if homepage is non-empty
        """
        not self.homepage.is_empty()

    pub fn has_license(self) -> bool:
        """Check if license is set.

        Returns:
            True if license is non-empty
        """
        not self.license.is_empty()

    pub fn has_dependencies(self) -> bool:
        """Check if package has dependencies.

        Returns:
            True if dependencies exist
        """
        self.dependencies.len() > 0

    pub fn get_dependency_count(self) -> i32:
        """Get number of dependencies.

        Returns:
            Dependency count

        Example:
            metadata.get_dependency_count()  # → 5
        """
        self.dependencies.len()

    pub fn is_complete(self) -> bool:
        """Check if metadata is complete.

        Returns:
            True if name, version, description, and author are set
        """
        not self.name.is_empty() and
        not self.version.is_empty() and
        self.has_description() and
        self.has_author()

    pub fn summary(self) -> text:
        """Get metadata summary.

        Returns:
            Human-readable summary

        Example:
            metadata.summary()
            # → "my-app v1.0.0 (MIT, 3 dependencies)"
        """
        val license_str = if self.has_license(): self.license else: "no license"
        "{self.name} v{self.version} ({license_str}, {self.get_dependency_count()} dependencies)"

# Package manifest
pub class PackageManifest:
    pub metadata: PackageMetadata
    pub files: List<PackageFile>
    pub scripts: Dict<text, text>  # install, uninstall, etc.

    pub fn new(metadata: PackageMetadata) -> PackageManifest:
        """Create package manifest.

        Args:
            metadata: Package metadata

        Returns:
            Package manifest
        """
        PackageManifest {
            metadata: metadata,
            files: [],
            scripts: {}
        }

    pub fn add_file(self, source: text, destination: text):
        """Add file to package.

        Args:
            source: Source file path
            destination: Destination path in package
        """
        self.files.append(PackageFile.new(source, destination))

    pub fn add_script(self, name: text, script: text):
        """Add installation script.

        Args:
            name: Script name (install, uninstall, pre-install, post-install)
            script: Script contents
        """
        self.scripts[name] = script

    pub fn get_file_count(self) -> i32:
        """Get file count in package.

        Returns:
            Number of files
        """
        self.files.len()

    pub fn has_script(self, name: text) -> bool:
        """Check if manifest has script.

        Args:
            name: Script name

        Returns:
            True if script exists
        """
        self.scripts.contains_key(name)

    pub fn has_files(self) -> bool:
        """Check if manifest has files.

        Returns:
            True if files exist
        """
        self.files.len() > 0

    pub fn has_scripts(self) -> bool:
        """Check if manifest has any scripts.

        Returns:
            True if scripts exist
        """
        self.scripts.len() > 0

    pub fn get_script_count(self) -> i32:
        """Get number of scripts.

        Returns:
            Script count
        """
        self.scripts.len()

    pub fn is_valid(self) -> bool:
        """Check if manifest is valid.

        Returns:
            True if metadata is complete and has files
        """
        self.metadata.is_complete() and self.has_files()

    pub fn summary(self) -> text:
        """Get manifest summary.

        Returns:
            Human-readable summary

        Example:
            manifest.summary()
            # → "Manifest: my-app v1.0.0 (10 files, 2 scripts)"
        """
        "{self.metadata.name} v{self.metadata.version} ({self.get_file_count()} files, {self.get_script_count()} scripts)"

# Package file entry
pub class PackageFile:
    pub source: text
    pub destination: text
    pub mode: i32  # Unix file permissions

    pub fn new(source: text, destination: text) -> PackageFile:
        """Create package file entry.

        Args:
            source: Source file path
            destination: Destination path

        Returns:
            Package file entry
        """
        PackageFile {
            source: source,
            destination: destination,
            mode: 0o644  # rw-r--r--
        }

    pub fn is_executable(self) -> bool:
        """Check if file is executable.

        Returns:
            True if executable bit is set

        Example:
            file.is_executable()  # → true if mode has execute bit
        """
        (self.mode & 0o111) != 0

    pub fn is_readable(self) -> bool:
        """Check if file is readable.

        Returns:
            True if readable bit is set
        """
        (self.mode & 0o444) != 0

    pub fn is_writable(self) -> bool:
        """Check if file is writable.

        Returns:
            True if writable bit is set
        """
        (self.mode & 0o222) != 0

    pub fn set_executable(self):
        """Make file executable (add execute bit)."""
        self.mode = self.mode | 0o111

    pub fn summary(self) -> text:
        """Get file summary.

        Returns:
            Human-readable summary

        Example:
            file.summary()
            # → "src/main.spl → bin/main.spl (mode: 0644)"
        """
        "{self.source} → {self.destination} (mode: {self.mode:o})"

# Package builder
pub class Packager:
    pub root: text
    pub manifest: PackageManifest
    pub verbose: bool

    pub fn new(root: text) -> Packager:
        """Create packager.

        Args:
            root: Project root

        Returns:
            Packager instance

        Example:
            val packager = Packager.new(".")

            val package = packager.create_package(
                name: "my-app",
                version: "1.0.0",
                include: [Language.Simple, Language.Rust],
                format: PackageFormat.Tarball
            )

            package.write("my-app-1.0.0.tar.gz")
        """
        val metadata = PackageMetadata.new("unnamed", "0.1.0")
        val manifest = PackageManifest.new(metadata)

        Packager {
            root: root,
            manifest: manifest,
            verbose: false
        }

    pub fn set_verbose(self, enabled: bool):
        """Enable verbose logging."""
        self.verbose = enabled

    pub fn is_verbose(self) -> bool:
        """Check if verbose logging is enabled.

        Returns:
            True if verbose mode is on
        """
        self.verbose

    pub fn with_verbose(self, enabled: bool) -> Packager:
        """Set verbose logging (fluent API).

        Args:
            enabled: Verbose flag

        Returns:
            Self for chaining

        Example:
            val packager = Packager.new(".").with_verbose(true)
        """
        self.verbose = enabled
        self

    pub fn set_metadata(self, metadata: PackageMetadata):
        """Set package metadata.

        Args:
            metadata: Package metadata
        """
        self.manifest.metadata = metadata

    pub fn get_file_count(self) -> i32:
        """Get number of files in package.

        Returns:
            File count
        """
        self.manifest.get_file_count()

    pub fn has_files(self) -> bool:
        """Check if package has files.

        Returns:
            True if files exist
        """
        self.manifest.has_files()

    pub fn summary(self) -> text:
        """Get packager summary.

        Returns:
            Human-readable summary

        Example:
            packager.summary()
            # → "Packager: . (10 files, verbose: true)"
        """
        val verbose_str = if self.verbose: "true" else: "false"
        "Packager: {self.root} ({self.get_file_count()} files, verbose: {verbose_str})"

    pub fn create_package(
        self,
        name: text,
        version: text,
        include: List<Language>,
        format: PackageFormat
    ) -> Package:
        """Create package from multi-language artifacts.

        Args:
            name: Package name
            version: Package version
            include: Languages to include
            format: Package format

        Returns:
            Package ready to write

        Example:
            val package = packager.create_package(
                name: "my-app",
                version: "1.0.0",
                include: [Language.Simple, Language.Rust, Language.Python],
                format: PackageFormat.Tarball
            )

            print("Package size: {package.size_mb}MB")
            package.write("my-app-1.0.0.tar.gz")
        """
        if self.verbose:
            print("Creating package {name} v{version}")

        # Update metadata
        self.manifest.metadata.name = name
        self.manifest.metadata.version = version

        # Collect artifacts for each language
        for language in include:
            self.collect_language_artifacts(language)

        # Create package
        val package = Package.new(self.manifest, format)

        if self.verbose:
            print("Package contains {package.file_count} files")

        package

    fn collect_language_artifacts(language: Language):
        """Collect artifacts for language.

        Args:
            language: Language to collect artifacts for
        """
        match language:
            Language.Simple:
                self.collect_simple_artifacts()
            Language.Rust:
                self.collect_rust_artifacts()
            Language.Python:
                self.collect_python_artifacts()
            Language.JavaScript:
                self.collect_javascript_artifacts()
            _:
                pass

    fn collect_simple_artifacts():
        """Collect Simple language artifacts."""
        @extern("runtime", "rt_glob")
        fn _rt_glob(pattern_ptr: &u8, pattern_len: u64) -> text

        # Find .smf compiled files in .simple/build/
        val smf_pattern = ".simple/build/**/*.smf"
        val smf_files = _rt_glob(smf_pattern.ptr(), smf_pattern.len())
        for file in smf_files.split("\n"):
            if not file.is_empty():
                self.manifest.add_file(file, "lib/{self.get_filename(file)}")

        # Find executables in .simple/build/
        val exe_pattern = ".simple/build/**/bin/*"
        val exe_files = _rt_glob(exe_pattern.ptr(), exe_pattern.len())
        for file in exe_files.split("\n"):
            if not file.is_empty():
                self.manifest.add_file(file, "bin/{self.get_filename(file)}")

    fn collect_rust_artifacts():
        """Collect Rust artifacts."""
        @extern("runtime", "rt_glob")
        fn _rt_glob(pattern_ptr: &u8, pattern_len: u64) -> text

        @extern("runtime", "rt_file_stat")
        fn _rt_file_stat(path_ptr: &u8, path_len: u64, out_exists: &mut bool, out_is_file: &mut bool, out_is_dir: &mut bool, out_is_readable: &mut bool, out_is_writable: &mut bool, out_size: &mut i64)

        # Find binaries in target/release/
        val bin_pattern = "target/release/*"
        val bin_files = _rt_glob(bin_pattern.ptr(), bin_pattern.len())
        for file in bin_files.split("\n"):
            if file.is_empty():
                continue
            # Skip directories and deps folder
            if file.contains("/deps/") or file.contains("/build/") or file.contains("/."):
                continue
            var exists = false
            var is_file = false
            var is_dir = false
            var is_readable = false
            var is_writable = false
            var size: i64 = 0
            _rt_file_stat(file.ptr(), file.len(), &mut exists, &mut is_file, &mut is_dir, &mut is_readable, &mut is_writable, &mut size)
            if is_file and not file.ends_with(".d"):
                # Check if it's likely an executable or library
                if file.ends_with(".so") or file.ends_with(".dylib") or file.ends_with(".dll") or file.ends_with(".a"):
                    self.manifest.add_file(file, "lib/{self.get_filename(file)}")
                else:
                    self.manifest.add_file(file, "bin/{self.get_filename(file)}")

    fn collect_python_artifacts():
        """Collect Python artifacts."""
        @extern("runtime", "rt_glob")
        fn _rt_glob(pattern_ptr: &u8, pattern_len: u64) -> text

        # Find Python source files
        val py_pattern = "src/**/*.py"
        val py_files = _rt_glob(py_pattern.ptr(), py_pattern.len())
        for file in py_files.split("\n"):
            if not file.is_empty() and not file.contains("__pycache__"):
                # Preserve directory structure under src/
                val dest = file.replace("src/", "lib/")
                self.manifest.add_file(file, dest)

        # Find wheels in dist/
        val wheel_pattern = "dist/*.whl"
        val wheel_files = _rt_glob(wheel_pattern.ptr(), wheel_pattern.len())
        for file in wheel_files.split("\n"):
            if not file.is_empty():
                self.manifest.add_file(file, "dist/{self.get_filename(file)}")

    fn collect_javascript_artifacts():
        """Collect JavaScript artifacts."""
        @extern("runtime", "rt_glob")
        fn _rt_glob(pattern_ptr: &u8, pattern_len: u64) -> text

        # Find built bundles in dist/
        val dist_pattern = "dist/**/*.js"
        val dist_files = _rt_glob(dist_pattern.ptr(), dist_pattern.len())
        for file in dist_files.split("\n"):
            if not file.is_empty():
                val dest = file.replace("dist/", "lib/")
                self.manifest.add_file(file, dest)

        # Find CSS bundles
        val css_pattern = "dist/**/*.css"
        val css_files = _rt_glob(css_pattern.ptr(), css_pattern.len())
        for file in css_files.split("\n"):
            if not file.is_empty():
                val dest = file.replace("dist/", "lib/")
                self.manifest.add_file(file, dest)

        # Find source maps if needed
        val map_pattern = "dist/**/*.map"
        val map_files = _rt_glob(map_pattern.ptr(), map_pattern.len())
        for file in map_files.split("\n"):
            if not file.is_empty():
                val dest = file.replace("dist/", "lib/")
                self.manifest.add_file(file, dest)

    pub fn add_binary(self, binary_path: text):
        """Add binary to package.

        Args:
            binary_path: Path to binary
        """
        self.manifest.add_file(binary_path, "bin/{self.get_filename(binary_path)}")

    pub fn add_library(self, lib_path: text):
        """Add library to package.

        Args:
            lib_path: Path to library
        """
        self.manifest.add_file(lib_path, "lib/{self.get_filename(lib_path)}")

    pub fn add_resource(self, resource_path: text, dest: text):
        """Add resource file to package.

        Args:
            resource_path: Path to resource
            dest: Destination path in package
        """
        self.manifest.add_file(resource_path, dest)

    fn get_filename(path: text) -> text:
        """Extract filename from path.

        Args:
            path: File path

        Returns:
            Filename

        Examples:
        - "/path/to/file.txt" → "file.txt"
        - "file.txt" → "file.txt"
        - "/path/to/" → ""
        """
        # Find last slash
        val last_slash = path.rfind("/")
        if last_slash >= 0:
            path[last_slash+1:]
        else:
            # No slash, return whole path
            path

# Package
pub class Package:
    pub manifest: PackageManifest
    pub format: PackageFormat
    pub file_count: i32
    pub size_mb: f64

    pub fn new(manifest: PackageManifest, format: PackageFormat) -> Package:
        """Create package.

        Args:
            manifest: Package manifest
            format: Package format

        Returns:
            Package
        """
        # Calculate total size of all files
        @extern("runtime", "rt_file_size")
        fn _rt_file_size(path_ptr: &u8, path_len: u64) -> i64

        var total_bytes: i64 = 0
        for (src_path, _) in manifest.files.items():
            val size = _rt_file_size(src_path.ptr(), src_path.len())
            if size > 0:
                total_bytes = total_bytes + size

        val size_mb = (total_bytes as f64) / (1024.0 * 1024.0)

        Package {
            manifest: manifest,
            format: format,
            file_count: manifest.files.len(),
            size_mb: size_mb
        }

    pub fn write(self, output_path: text) -> Result<(), text>:
        """Write package to file.

        Args:
            output_path: Output file path

        Returns:
            Ok if successful

        Example:
            package.write("my-app-1.0.0.tar.gz")
        """
        match self.format:
            PackageFormat.Tarball:
                self.write_tarball(output_path)
            PackageFormat.Zip:
                self.write_zip(output_path)
            PackageFormat.Deb:
                self.write_deb(output_path)
            PackageFormat.Rpm:
                self.write_rpm(output_path)
            PackageFormat.NuGet:
                self.write_nuget(output_path)
            PackageFormat.Npm:
                self.write_npm(output_path)
            PackageFormat.PyPI:
                self.write_pypi(output_path)

    fn write_tarball(output_path: text) -> Result<(), text>:
        """Write tarball (.tar.gz).

        Args:
            output_path: Output file

        Returns:
            Ok if successful
        """
        @extern("runtime", "rt_process_run")
        fn _rt_process_run(cmd_ptr: &u8, cmd_len: u64, args_ptr: &u8, args_len: u64) -> (i32, text, text)

        # Build file list for tar command
        var file_args = ""
        for (src_path, dest_path) in self.manifest.files.items():
            file_args = file_args + " " + src_path

        # Create tarball using tar command
        val cmd = "tar"
        val args = "czf {output_path} {file_args}"
        val (exit_code, stdout, stderr) = _rt_process_run(cmd.ptr(), cmd.len(), args.ptr(), args.len())

        if exit_code == 0:
            Ok(())
        else:
            Err("Failed to create tarball: {stderr}")

    fn write_zip(output_path: text) -> Result<(), text>:
        """Write zip archive.

        Args:
            output_path: Output file

        Returns:
            Ok if successful
        """
        @extern("runtime", "rt_process_run")
        fn _rt_process_run(cmd_ptr: &u8, cmd_len: u64, args_ptr: &u8, args_len: u64) -> (i32, text, text)

        # Build file list for zip command
        var file_args = ""
        for (src_path, dest_path) in self.manifest.files.items():
            file_args = file_args + " " + src_path

        # Create zip archive using zip command
        val cmd = "zip"
        val args = "-r {output_path} {file_args}"
        val (exit_code, stdout, stderr) = _rt_process_run(cmd.ptr(), cmd.len(), args.ptr(), args.len())

        if exit_code == 0:
            Ok(())
        else:
            Err("Failed to create zip: {stderr}")

    fn write_deb(output_path: text) -> Result<(), text>:
        """Write Debian package.

        Args:
            output_path: Output file

        Returns:
            Ok if successful
        """
        @extern("runtime", "rt_process_run")
        fn _rt_process_run(cmd_ptr: &u8, cmd_len: u64, args_ptr: &u8, args_len: u64) -> (i32, text, text)

        @extern("runtime", "rt_file_write_text")
        fn _rt_file_write_text(path_ptr: &u8, path_len: u64, content_ptr: &u8, content_len: u64) -> bool

        @extern("runtime", "rt_mkdir")
        fn _rt_mkdir(path_ptr: &u8, path_len: u64) -> bool

        # Create temporary package structure
        val pkg_name = self.manifest.metadata.name
        val pkg_dir = "/tmp/deb_pkg_{pkg_name}"
        _rt_mkdir(pkg_dir.ptr(), pkg_dir.len())

        val debian_dir = "{pkg_dir}/DEBIAN"
        _rt_mkdir(debian_dir.ptr(), debian_dir.len())

        # Generate control file
        val control_content = """Package: {self.manifest.metadata.name}
Version: {self.manifest.metadata.version}
Architecture: amd64
Maintainer: {self.manifest.metadata.author}
Description: {self.manifest.metadata.description}
"""
        val control_path = "{debian_dir}/control"
        _rt_file_write_text(control_path.ptr(), control_path.len(), control_content.ptr(), control_content.len())

        # Copy files to package directory
        for (src_path, dest_path) in self.manifest.files.items():
            val full_dest = "{pkg_dir}/{dest_path}"
            val cp_cmd = "cp"
            val cp_args = "-r {src_path} {full_dest}"
            _rt_process_run(cp_cmd.ptr(), cp_cmd.len(), cp_args.ptr(), cp_args.len())

        # Build .deb using dpkg-deb
        val cmd = "dpkg-deb"
        val args = "--build {pkg_dir} {output_path}"
        val (exit_code, stdout, stderr) = _rt_process_run(cmd.ptr(), cmd.len(), args.ptr(), args.len())

        if exit_code == 0:
            Ok(())
        else:
            Err("Failed to create deb: {stderr}")

    fn write_rpm(output_path: text) -> Result<(), text>:
        """Write RPM package.

        Args:
            output_path: Output file

        Returns:
            Ok if successful
        """
        @extern("runtime", "rt_process_run")
        fn _rt_process_run(cmd_ptr: &u8, cmd_len: u64, args_ptr: &u8, args_len: u64) -> (i32, text, text)

        @extern("runtime", "rt_file_write_text")
        fn _rt_file_write_text(path_ptr: &u8, path_len: u64, content_ptr: &u8, content_len: u64) -> bool

        @extern("runtime", "rt_mkdir")
        fn _rt_mkdir(path_ptr: &u8, path_len: u64) -> bool

        # Create RPM build directory structure
        val rpmbuild_dir = "/tmp/rpmbuild_{self.manifest.metadata.name}"
        _rt_mkdir(rpmbuild_dir.ptr(), rpmbuild_dir.len())

        val specs_dir = "{rpmbuild_dir}/SPECS"
        _rt_mkdir(specs_dir.ptr(), specs_dir.len())

        val sources_dir = "{rpmbuild_dir}/SOURCES"
        _rt_mkdir(sources_dir.ptr(), sources_dir.len())

        # Generate .spec file
        val spec_content = """Name: {self.manifest.metadata.name}
Version: {self.manifest.metadata.version}
Release: 1
Summary: {self.manifest.metadata.description}
License: MIT

%description
{self.manifest.metadata.description}

%install
mkdir -p %{buildroot}

%files
"""
        val spec_path = "{specs_dir}/{self.manifest.metadata.name}.spec"
        _rt_file_write_text(spec_path.ptr(), spec_path.len(), spec_content.ptr(), spec_content.len())

        # Build RPM using rpmbuild
        val cmd = "rpmbuild"
        val args = "-bb --define '_topdir {rpmbuild_dir}' {spec_path}"
        val (exit_code, stdout, stderr) = _rt_process_run(cmd.ptr(), cmd.len(), args.ptr(), args.len())

        if exit_code == 0:
            Ok(())
        else:
            Err("Failed to create rpm: {stderr}")

    fn write_nuget(output_path: text) -> Result<(), text>:
        """Write NuGet package.

        Args:
            output_path: Output file

        Returns:
            Ok if successful
        """
        @extern("runtime", "rt_process_run")
        fn _rt_process_run(cmd_ptr: &u8, cmd_len: u64, args_ptr: &u8, args_len: u64) -> (i32, text, text)

        @extern("runtime", "rt_file_write_text")
        fn _rt_file_write_text(path_ptr: &u8, path_len: u64, content_ptr: &u8, content_len: u64) -> bool

        # Generate .nuspec file
        val nuspec_content = """<?xml version="1.0"?>
<package>
  <metadata>
    <id>{self.manifest.metadata.name}</id>
    <version>{self.manifest.metadata.version}</version>
    <authors>{self.manifest.metadata.author}</authors>
    <description>{self.manifest.metadata.description}</description>
  </metadata>
</package>
"""
        val nuspec_path = "{self.manifest.metadata.name}.nuspec"
        _rt_file_write_text(nuspec_path.ptr(), nuspec_path.len(), nuspec_content.ptr(), nuspec_content.len())

        # Build NuGet package using nuget or dotnet pack
        val cmd = "nuget"
        val args = "pack {nuspec_path} -OutputDirectory ."
        val (exit_code, stdout, stderr) = _rt_process_run(cmd.ptr(), cmd.len(), args.ptr(), args.len())

        if exit_code == 0:
            Ok(())
        else:
            Err("Failed to create nupkg: {stderr}")

    fn write_npm(output_path: text) -> Result<(), text>:
        """Write NPM package.

        Args:
            output_path: Output file

        Returns:
            Ok if successful
        """
        @extern("runtime", "rt_process_run")
        fn _rt_process_run(cmd_ptr: &u8, cmd_len: u64, args_ptr: &u8, args_len: u64) -> (i32, text, text)

        @extern("runtime", "rt_file_write_text")
        fn _rt_file_write_text(path_ptr: &u8, path_len: u64, content_ptr: &u8, content_len: u64) -> bool

        # Generate package.json if it doesn't exist
        val pkg_json_content = """{
  "name": "{self.manifest.metadata.name}",
  "version": "{self.manifest.metadata.version}",
  "description": "{self.manifest.metadata.description}",
  "author": "{self.manifest.metadata.author}",
  "main": "index.js"
}
"""
        val pkg_json_path = "package.json"
        _rt_file_write_text(pkg_json_path.ptr(), pkg_json_path.len(), pkg_json_content.ptr(), pkg_json_content.len())

        # Create npm tarball using npm pack
        val cmd = "npm"
        val args = "pack"
        val (exit_code, stdout, stderr) = _rt_process_run(cmd.ptr(), cmd.len(), args.ptr(), args.len())

        if exit_code == 0:
            Ok(())
        else:
            Err("Failed to create npm package: {stderr}")

    fn write_pypi(output_path: text) -> Result<(), text>:
        """Write Python package (wheel or sdist).

        Args:
            output_path: Output file

        Returns:
            Ok if successful
        """
        @extern("runtime", "rt_process_run")
        fn _rt_process_run(cmd_ptr: &u8, cmd_len: u64, args_ptr: &u8, args_len: u64) -> (i32, text, text)

        @extern("runtime", "rt_file_write_text")
        fn _rt_file_write_text(path_ptr: &u8, path_len: u64, content_ptr: &u8, content_len: u64) -> bool

        # Generate setup.py if it doesn't exist
        val setup_content = """from setuptools import setup, find_packages

setup(
    name="{self.manifest.metadata.name}",
    version="{self.manifest.metadata.version}",
    description="{self.manifest.metadata.description}",
    author="{self.manifest.metadata.author}",
    packages=find_packages(),
)
"""
        val setup_path = "setup.py"
        _rt_file_write_text(setup_path.ptr(), setup_path.len(), setup_content.ptr(), setup_content.len())

        # Build wheel using python -m build
        val cmd = "python"
        val args = "-m build --wheel"
        val (exit_code, stdout, stderr) = _rt_process_run(cmd.ptr(), cmd.len(), args.ptr(), args.len())

        if exit_code == 0:
            Ok(())
        else:
            Err("Failed to create wheel: {stderr}")

    pub fn get_name(self) -> text:
        """Get package name with version.

        Returns:
            Package name

        Example:
            # manifest.metadata.name = "my-app"
            # manifest.metadata.version = "1.0.0"
            package.get_name()  # → "my-app-1.0.0"
        """
        "{self.manifest.metadata.name}-{self.manifest.metadata.version}"

    pub fn validate(self) -> Result<(), text>:
        """Validate package configuration.

        Returns:
            Ok if valid, Err with message otherwise

        Checks:
        - Name and version are set
        - At least one file
        - File paths exist (when possible)
        """
        if self.manifest.metadata.name == "":
            return Err("Package name is required")

        if self.manifest.metadata.version == "":
            return Err("Package version is required")

        if self.manifest.files.len() == 0:
            return Err("Package must contain at least one file")

        Ok(())

    pub fn is_valid(self) -> bool:
        """Check if package is valid.

        Returns:
            True if validation passes

        Example:
            if package.is_valid():
                package.write("output.tar.gz")
        """
        match self.validate():
            Ok(_): true
            Err(_): false

    pub fn has_files(self) -> bool:
        """Check if package has files.

        Returns:
            True if file count > 0
        """
        self.file_count > 0

    pub fn is_archive(self) -> bool:
        """Check if package format is a generic archive.

        Returns:
            True for tarball/zip
        """
        self.format.is_archive()

    pub fn is_linux_package(self) -> bool:
        """Check if package format is a Linux package.

        Returns:
            True for deb/rpm
        """
        self.format.is_linux_package()

    pub fn is_language_package(self) -> bool:
        """Check if package format is language-specific.

        Returns:
            True for npm/pypi/nuget
        """
        self.format.is_language_package()

    pub fn get_filename(self) -> text:
        """Get suggested output filename.

        Returns:
            Filename with appropriate extension

        Example:
            package.get_filename()
            # → "my-app-1.0.0.tar.gz"
        """
        "{self.get_name()}{self.format.get_extension()}"

    pub fn summary(self) -> text:
        """Get package summary.

        Returns:
            Human-readable summary

        Example:
            package.summary()
            # → "Package: my-app-1.0.0.tar.gz (10 files, 5.2 MB)"
        """
        "Package: {self.get_filename()} ({self.file_count} files, {self.size_mb:.1f} MB)"
