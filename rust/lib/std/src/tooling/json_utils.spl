# JSON utilities
# Simplified JSON generation (no parsing without regex)

use super.string_utils.{trim}
use super.list_utils.{map_list}

# =====================================
# JSON Value Formatting
# =====================================

# Format string as JSON string with escaping
fn json_string(value: text) -> text:
    val escaped = value
        .replace("\\", "\\\\")
        .replace("\"", "\\\"")
        .replace("\n", "\\n")
        .replace("\r", "\\r")
        .replace("\t", "\\t")

    "\"{escaped}\""

# Format number as JSON number
fn json_number(value: i32) -> text:
    value.to_string()

# Format float as JSON number
fn json_float(value: f64) -> text:
    value.to_string()

# Format boolean as JSON boolean
fn json_bool(value: bool) -> text:
    if value: "true" else: "false"

# Format null
fn json_null() -> text:
    "null"

# =====================================
# JSON Array Formatting
# =====================================

# Format list of strings as JSON array
fn json_array_strings(values: List<text>) -> text:
    val items = map_list(values, \v: json_string(v))
    "[" + items.join(", ") + "]"

# Format list of numbers as JSON array
fn json_array_numbers(values: List<i32>) -> text:
    val items = map_list(values, \v: json_number(v))
    "[" + items.join(", ") + "]"

# Format list of already-formatted JSON values
fn json_array(items: List<text>) -> text:
    "[" + items.join(", ") + "]"

# =====================================
# JSON Object Formatting
# =====================================

# Format key-value pair
fn json_pair(key: text, value: text) -> text:
    json_string(key) + ": " + value

# Format object from key-value pairs
fn json_object(pairs: List<(text, text)>) -> text:
    var items = []

    for (key, value) in pairs:
        items.push(json_pair(key, value))

    "{" + items.join(", ") + "}"

# Format object from map-like structure
fn json_object_from_map(entries: List<(text, text)>) -> text:
    json_object(entries)

# =====================================
# Pretty Printing
# =====================================

# Add indentation to JSON (simple approach)
fn json_pretty_indent(json: text, indent_size: i32) -> text:
    var result = ""
    var indent_level = 0
    var in_string = false
    var prev_char = ""

    for ch in json.chars():
        if ch == "\"" and prev_char != "\\":
            in_string = not in_string

        if not in_string:
            if ch == "{" or ch == "[":
                result = result + ch + "\n"
                indent_level = indent_level + 1
                result = result + make_indent(indent_level, indent_size)
            elif ch == "}" or ch == "]":
                result = result + "\n"
                indent_level = indent_level - 1
                result = result + make_indent(indent_level, indent_size) + ch
            elif ch == ",":
                result = result + ch + "\n"
                result = result + make_indent(indent_level, indent_size)
            else:
                result = result + ch
        else:
            result = result + ch

        prev_char = ch

    result

# Create indentation string
fn make_indent(level: i32, size: i32) -> text:
    var indent = ""
    for _ in 0..(level * size):
        indent = indent + " "
    indent

# =====================================
# Common Structures
# =====================================

# Create JSON for success response
fn json_success(message: text) -> text:
    json_object([
        ("status", json_string("success")),
        ("message", json_string(message))
    ])

# Create JSON for error response
fn json_error(message: text, code: i32) -> text:
    json_object([
        ("status", json_string("error")),
        ("message", json_string(message)),
        ("code", json_number(code))
    ])

# Create JSON for data response
fn json_data(data: text) -> text:
    json_object([
        ("status", json_string("success")),
        ("data", data)
    ])

# =====================================
# Builder Pattern
# =====================================

# JSON object builder
struct JsonBuilder:
    pairs: List<(text, text)>

impl JsonBuilder:
    # Create new builder
    static fn new() -> JsonBuilder:
        JsonBuilder(pairs: [])

    # Add string field
    me add_string(key: text, value: text):
        self.pairs.push((key, json_string(value)))

    # Add number field
    me add_number(key: text, value: i32):
        self.pairs.push((key, json_number(value)))

    # Add boolean field
    me add_bool(key: text, value: bool):
        self.pairs.push((key, json_bool(value)))

    # Add null field
    me add_null(key: text):
        self.pairs.push((key, json_null()))

    # Add raw JSON value
    me add_raw(key: text, json_value: text):
        self.pairs.push((key, json_value))

    # Add array field
    me add_array(key: text, items: List<text>):
        self.pairs.push((key, json_array(items)))

    # Add object field
    me add_object(key: text, object: text):
        self.pairs.push((key, object))

    # Build final JSON string
    fn build() -> text:
        json_object(self.pairs)

    # Build with pretty printing
    fn build_pretty(indent_size: i32) -> text:
        json_pretty_indent(self.build(), indent_size)

# =====================================
# Array Builder
# =====================================

struct JsonArrayBuilder:
    items: List<text>

impl JsonArrayBuilder:
    static fn new() -> JsonArrayBuilder:
        JsonArrayBuilder(items: [])

    me add_string(value: text):
        self.items.push(json_string(value))

    me add_number(value: i32):
        self.items.push(json_number(value))

    me add_bool(value: bool):
        self.items.push(json_bool(value))

    me add_null():
        self.items.push(json_null())

    me add_raw(json_value: text):
        self.items.push(json_value)

    fn build() -> text:
        json_array(self.items)

# =====================================
# Validation Helpers
# =====================================

# Check if string looks like valid JSON (basic check)
fn looks_like_json(text: text) -> bool:
    val trimmed = trim(text)

    if trimmed.is_empty():
        return false

    val first = trimmed.chars()[0]
    val last = trimmed.chars()[trimmed.len() - 1]

    # Check for object or array
    (first == "{" and last == "}") or
    (first == "[" and last == "]")

# Count braces/brackets (for validation)
fn count_braces(json: text) -> (i32, i32, i32, i32):
    var open_brace = 0
    var close_brace = 0
    var open_bracket = 0
    var close_bracket = 0
    var in_string = false
    var prev_char = ""

    for ch in json.chars():
        if ch == "\"" and prev_char != "\\":
            in_string = not in_string

        if not in_string:
            if ch == "{":
                open_brace = open_brace + 1
            elif ch == "}":
                close_brace = close_brace + 1
            elif ch == "[":
                open_bracket = open_bracket + 1
            elif ch == "]":
                close_bracket = close_bracket + 1

        prev_char = ch

    (open_brace, close_brace, open_bracket, close_bracket)

# Check if braces are balanced
fn has_balanced_braces(json: text) -> bool:
    val (open_brace, close_brace, open_bracket, close_bracket) = count_braces(json)
    open_brace == close_brace and open_bracket == close_bracket

# =====================================
# Common Patterns
# =====================================

# Create API response
fn api_response(success: bool, message: text, data: Option<text>) -> text:
    var builder = JsonBuilder.new()
    builder.add_bool("success", success)
    builder.add_string("message", message)

    match data:
        Some(d) => builder.add_raw("data", d)
        None => builder.add_null("data")

    builder.build()

# Create pagination metadata
fn pagination_meta(page: i32, per_page: i32, total: i32) -> text:
    var builder = JsonBuilder.new()
    builder.add_number("page", page)
    builder.add_number("per_page", per_page)
    builder.add_number("total", total)
    builder.add_number("total_pages", (total + per_page - 1) / per_page)
    builder.build()

# Create timestamp object
fn timestamp_json(unix_timestamp: i32, iso_string: text) -> text:
    var builder = JsonBuilder.new()
    builder.add_number("unix", unix_timestamp)
    builder.add_string("iso", iso_string)
    builder.build()
