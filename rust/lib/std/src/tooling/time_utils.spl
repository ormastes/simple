# Time and Duration utilities
# Parse, format, and manipulate time durations

use super.parse_utils.{parse_int}

# Import datetime from host for current time operations
extern fn rt_time_now_unix_micros() -> i32
extern fn rt_timestamp_get_year(micros: i32) -> i32
extern fn rt_timestamp_get_month(micros: i32) -> i32
extern fn rt_timestamp_get_day(micros: i32) -> i32
extern fn rt_timestamp_get_hour(micros: i32) -> i32
extern fn rt_timestamp_get_minute(micros: i32) -> i32
extern fn rt_timestamp_get_second(micros: i32) -> i32

# =====================================
# Duration Structure
# =====================================

# Represents a duration in milliseconds
struct Duration:
    milliseconds: i32

impl Duration:
    # Create duration from milliseconds
    static fn from_millis(ms: i32) -> Duration:
        Duration(milliseconds: ms)

    # Create duration from seconds
    static fn from_seconds(secs: i32) -> Duration:
        Duration(milliseconds: secs * 1000)

    # Create duration from minutes
    static fn from_minutes(mins: i32) -> Duration:
        Duration(milliseconds: mins * 60 * 1000)

    # Create duration from hours
    static fn from_hours(hours: i32) -> Duration:
        Duration(milliseconds: hours * 60 * 60 * 1000)

    # Create duration from days
    static fn from_days(days: i32) -> Duration:
        Duration(milliseconds: days * 24 * 60 * 60 * 1000)

    # Get total milliseconds
    fn total_millis() -> i32:
        self.milliseconds

    # Get total seconds
    fn total_seconds() -> i32:
        self.milliseconds / 1000

    # Get total minutes
    fn total_minutes() -> i32:
        self.milliseconds / (60 * 1000)

    # Get total hours
    fn total_hours() -> i32:
        self.milliseconds / (60 * 60 * 1000)

    # Get total days
    fn total_days() -> i32:
        self.milliseconds / (24 * 60 * 60 * 1000)

    # Get components (days, hours, minutes, seconds, millis)
    fn components() -> (i32, i32, i32, i32, i32):
        var remaining = self.milliseconds

        val days = remaining / (24 * 60 * 60 * 1000)
        remaining = remaining % (24 * 60 * 60 * 1000)

        val hours = remaining / (60 * 60 * 1000)
        remaining = remaining % (60 * 60 * 1000)

        val minutes = remaining / (60 * 1000)
        remaining = remaining % (60 * 1000)

        val seconds = remaining / 1000
        val millis = remaining % 1000

        (days, hours, minutes, seconds, millis)

    # Add two durations
    fn add(other: Duration) -> Duration:
        Duration(milliseconds: self.milliseconds + other.milliseconds)

    # Subtract duration
    fn subtract(other: Duration) -> Duration:
        Duration(milliseconds: self.milliseconds - other.milliseconds)

    # Multiply duration by scalar
    fn multiply(factor: i32) -> Duration:
        Duration(milliseconds: self.milliseconds * factor)

    # Divide duration by scalar
    fn divide(divisor: i32) -> Duration:
        Duration(milliseconds: self.milliseconds / divisor)

# =====================================
# Duration Parsing
# =====================================

# Parse duration string (e.g., "1h30m", "45s", "2d")
fn parse_duration(text: text) -> Option<Duration>:
    var total_ms = 0
    var current_num = ""
    var i = 0

    while i < text.len():
        val ch = text.chars()[i]

        if is_digit(ch):
            current_num = current_num + ch
        elif is_unit_char(ch):
            if current_num.is_empty():
                return None

            match parse_int(current_num):
                Some(num) =>
                    match unit_to_millis(ch, num):
                        Some(ms) => total_ms = total_ms + ms
                        None => return None
                None => return None

            current_num = ""
        elif ch != " ":  # Ignore spaces
            return None

        i = i + 1

    # Handle trailing number with no unit (assume seconds)
    if not current_num.is_empty():
        match parse_int(current_num):
            Some(num) => total_ms = total_ms + (num * 1000)
            None => return None

    Some(Duration(milliseconds: total_ms))

# Check if character is a digit
fn is_digit(ch: text) -> bool:
    val c = ch.chars()[0] if ch.len() > 0 else: ""
    c >= "0" and c <= "9"

# Check if character is a time unit
fn is_unit_char(ch: text) -> bool:
    ch == "d" or ch == "h" or ch == "m" or ch == "s"

# Convert unit and number to milliseconds
fn unit_to_millis(unit: text, num: i32) -> Option<i32>:
    match unit:
        "d" => Some(num * 24 * 60 * 60 * 1000)  # days
        "h" => Some(num * 60 * 60 * 1000)       # hours
        "m" => Some(num * 60 * 1000)            # minutes
        "s" => Some(num * 1000)                 # seconds
        _ => None

# =====================================
# Duration Formatting
# =====================================

# Format duration as human-readable string
fn format_duration(duration: Duration) -> text:
    val (days, hours, minutes, seconds, millis) = duration.components()

    var parts = []

    if days > 0:
        parts.push(days.to_string() + "d")

    if hours > 0:
        parts.push(hours.to_string() + "h")

    if minutes > 0:
        parts.push(minutes.to_string() + "m")

    if seconds > 0:
        parts.push(seconds.to_string() + "s")

    if millis > 0 and parts.len() == 0:
        # Only show millis if no larger units
        parts.push(millis.to_string() + "ms")

    if parts.len() == 0:
        return "0s"

    parts.join(" ")

# Format duration as compact string (no spaces)
fn format_duration_compact(duration: Duration) -> text:
    val (days, hours, minutes, seconds, millis) = duration.components()

    var result = ""

    if days > 0:
        result = result + days.to_string() + "d"

    if hours > 0:
        result = result + hours.to_string() + "h"

    if minutes > 0:
        result = result + minutes.to_string() + "m"

    if seconds > 0:
        result = result + seconds.to_string() + "s"

    if millis > 0 and result.is_empty():
        result = millis.to_string() + "ms"

    if result.is_empty():
        return "0s"

    result

# Format as seconds with decimals
fn format_as_seconds(duration: Duration) -> text:
    val total_secs = duration.milliseconds / 1000
    val remaining_ms = duration.milliseconds % 1000

    if remaining_ms == 0:
        total_secs.to_string() + "s"
    else:
        # Approximate decimal representation
        total_secs.to_string() + "." + (remaining_ms / 100).to_string() + "s"

# Format as minutes with decimals
fn format_as_minutes(duration: Duration) -> text:
    val total_mins = duration.milliseconds / (60 * 1000)
    val remaining_secs = (duration.milliseconds % (60 * 1000)) / 1000

    if remaining_secs == 0:
        total_mins.to_string() + "m"
    else:
        total_mins.to_string() + "m " + remaining_secs.to_string() + "s"

# Format as hours with minutes
fn format_as_hours(duration: Duration) -> text:
    val total_hours = duration.milliseconds / (60 * 60 * 1000)
    val remaining_mins = (duration.milliseconds % (60 * 60 * 1000)) / (60 * 1000)

    if remaining_mins == 0:
        total_hours.to_string() + "h"
    else:
        total_hours.to_string() + "h " + remaining_mins.to_string() + "m"

# =====================================
# Time Units Conversion
# =====================================

# Convert milliseconds to seconds
fn millis_to_seconds(ms: i32) -> i32:
    ms / 1000

# Convert seconds to milliseconds
fn seconds_to_millis(secs: i32) -> i32:
    secs * 1000

# Convert minutes to seconds
fn minutes_to_seconds(mins: i32) -> i32:
    mins * 60

# Convert hours to minutes
fn hours_to_minutes(hours: i32) -> i32:
    hours * 60

# Convert days to hours
fn days_to_hours(days: i32) -> i32:
    days * 24

# Convert hours to seconds
fn hours_to_seconds(hours: i32) -> i32:
    hours * 60 * 60

# Convert days to seconds
fn days_to_seconds(days: i32) -> i32:
    days * 24 * 60 * 60

# =====================================
# Timestamp Structure
# =====================================

# Simple timestamp (seconds since epoch)
struct Timestamp:
    seconds: i32

impl Timestamp:
    # Create from seconds since epoch
    static fn from_seconds(secs: i32) -> Timestamp:
        Timestamp(seconds: secs)

    # Get seconds
    fn get_seconds() -> i32:
        self.seconds

    # Add duration to timestamp
    fn add_duration(duration: Duration) -> Timestamp:
        Timestamp(seconds: self.seconds + duration.total_seconds())

    # Subtract duration from timestamp
    fn subtract_duration(duration: Duration) -> Timestamp:
        Timestamp(seconds: self.seconds - duration.total_seconds())

    # Get duration between two timestamps
    fn duration_since(other: Timestamp) -> Duration:
        val diff = self.seconds - other.seconds
        Duration.from_seconds(diff)

# =====================================
# Time Comparisons
# =====================================

# Compare two durations
fn duration_equals(a: Duration, b: Duration) -> bool:
    a.milliseconds == b.milliseconds

# Check if duration is greater than another
fn duration_greater_than(a: Duration, b: Duration) -> bool:
    a.milliseconds > b.milliseconds

# Check if duration is less than another
fn duration_less_than(a: Duration, b: Duration) -> bool:
    a.milliseconds < b.milliseconds

# Get maximum of two durations
fn duration_max(a: Duration, b: Duration) -> Duration:
    if a.milliseconds > b.milliseconds:
        a
    else:
        b

# Get minimum of two durations
fn duration_min(a: Duration, b: Duration) -> Duration:
    if a.milliseconds < b.milliseconds:
        a
    else:
        b

# =====================================
# Common Durations
# =====================================

# One millisecond
fn one_millisecond() -> Duration:
    Duration.from_millis(1)

# One second
fn one_second() -> Duration:
    Duration.from_seconds(1)

# One minute
fn one_minute() -> Duration:
    Duration.from_minutes(1)

# One hour
fn one_hour() -> Duration:
    Duration.from_hours(1)

# One day
fn one_day() -> Duration:
    Duration.from_days(1)

# =====================================
# Duration Utilities
# =====================================

# Check if duration is zero
fn is_zero_duration(duration: Duration) -> bool:
    duration.milliseconds == 0

# Check if duration is negative
fn is_negative_duration(duration: Duration) -> bool:
    duration.milliseconds < 0

# Absolute value of duration
fn duration_abs(duration: Duration) -> Duration:
    if duration.milliseconds < 0:
        Duration(milliseconds: -duration.milliseconds)
    else:
        duration

# Negate duration
fn duration_negate(duration: Duration) -> Duration:
    Duration(milliseconds: -duration.milliseconds)

# Sum list of durations
fn sum_durations(durations: List<Duration>) -> Duration:
    var total = 0

    for duration in durations:
        total = total + duration.milliseconds

    Duration(milliseconds: total)

# Average of durations
fn average_duration(durations: List<Duration>) -> Option<Duration>:
    if durations.len() == 0:
        return None

    val sum = sum_durations(durations)
    Some(sum.divide(durations.len()))

# =====================================
# Time Range
# =====================================

struct TimeRange:
    start: Timestamp
    end: Timestamp

impl TimeRange:
    # Create time range
    static fn new(start: Timestamp, end: Timestamp) -> TimeRange:
        TimeRange(start: start, end: end)

    # Get duration of range
    fn duration() -> Duration:
        self.end.duration_since(self.start)

    # Check if timestamp is in range
    fn contains(timestamp: Timestamp) -> bool:
        timestamp.seconds >= self.start.seconds and
        timestamp.seconds <= self.end.seconds

    # Check if ranges overlap
    fn overlaps(other: TimeRange) -> bool:
        self.start.seconds <= other.end.seconds and
        self.end.seconds >= other.start.seconds

# =====================================
# Current Time Functions
# =====================================

# Get current timestamp as formatted string (YYYY-MM-DD_HH-MM-SS)
fn current_timestamp_string() -> text:
    val micros = rt_time_now_unix_micros()
    val year = rt_timestamp_get_year(micros)
    val month = rt_timestamp_get_month(micros)
    val day = rt_timestamp_get_day(micros)
    val hour = rt_timestamp_get_hour(micros)
    val minute = rt_timestamp_get_minute(micros)
    val second = rt_timestamp_get_second(micros)

    val m = if month < 10: "0{month}" else: "{month}"
    val d = if day < 10: "0{day}" else: "{day}"
    val h = if hour < 10: "0{hour}" else: "{hour}"
    val min = if minute < 10: "0{minute}" else: "{minute}"
    val s = if second < 10: "0{second}" else: "{second}"

    "{year}-{m}-{d}_{h}-{min}-{s}"

# Get current date as formatted string (YYYY-MM-DD)
fn current_date_string() -> text:
    val micros = rt_time_now_unix_micros()
    val year = rt_timestamp_get_year(micros)
    val month = rt_timestamp_get_month(micros)
    val day = rt_timestamp_get_day(micros)

    val m = if month < 10: "0{month}" else: "{month}"
    val d = if day < 10: "0{day}" else: "{day}"

    "{year}-{m}-{d}"

# Generate backup directory name with timestamp
fn generate_backup_dir(prefix: text) -> text:
    val timestamp = current_timestamp_string()
    "{prefix}_{timestamp}"

# Generate migration backup directory name
fn migration_backup_dir(migration_name: text) -> text:
    generate_backup_dir(".migration_backup_{migration_name}")
