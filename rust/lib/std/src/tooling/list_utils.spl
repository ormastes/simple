# List utilities for collection operations

# Remove duplicates from list (keeps first occurrence)
fn dedup<T>(list: List<T>) -> List<T>:
    var seen = []
    var result = []

    for item in list:
        var is_duplicate = false
        for s in seen:
            if item == s:
                is_duplicate = true
                break

        if not is_duplicate:
            result.push(item)
            seen.push(item)

    result

# Remove duplicates from sorted list (more efficient)
fn dedup_sorted<T>(list: List<T>) -> List<T>:
    if list.is_empty():
        return []

    var result = [list[0]]

    for i in 1..list.len():
        if list[i] != list[i-1]:
            result.push(list[i])

    result

# Find index of first element matching predicate
fn find_index<T>(list: List<T>, predicate: fn(T) -> bool) -> Option<i32>:
    for i in 0..list.len():
        if predicate(list[i]):
            return Some(i)

    None

# Check if all elements match predicate
fn all<T>(list: List<T>, predicate: fn(T) -> bool) -> bool:
    for item in list:
        if not predicate(item):
            return false
    true

# Check if any element matches predicate
fn any<T>(list: List<T>, predicate: fn(T) -> bool) -> bool:
    for item in list:
        if predicate(item):
            return true
    false

# Partition list into two lists based on predicate
fn partition<T>(list: List<T>, predicate: fn(T) -> bool) -> (List<T>, List<T>):
    var matched = []
    var unmatched = []

    for item in list:
        if predicate(item):
            matched.push(item)
        else:
            unmatched.push(item)

    (matched, unmatched)

# Take first N elements
fn take<T>(list: List<T>, n: i32) -> List<T>:
    if n >= list.len():
        return list

    list[0..n]

# Skip first N elements
fn skip<T>(list: List<T>, n: i32) -> List<T>:
    if n >= list.len():
        return []

    list[n..list.len()]

# Take last N elements
fn take_last<T>(list: List<T>, n: i32) -> List<T>:
    if n >= list.len():
        return list

    list[list.len()-n..list.len()]

# Group consecutive elements by a key function
fn group_by<T, K>(list: List<T>, key_fn: fn(T) -> K) -> List<(K, List<T>)>:
    if list.is_empty():
        return []

    var groups = []
    var current_key = key_fn(list[0])
    var current_group = [list[0]]

    for i in 1..list.len():
        val item_key = key_fn(list[i])
        if item_key == current_key:
            current_group.push(list[i])
        else:
            groups.push((current_key, current_group))
            current_key = item_key
            current_group = [list[i]]

    groups.push((current_key, current_group))
    groups

# Flatten nested lists
fn flatten<T>(lists: List<List<T>>) -> List<T>:
    var result = []
    for list in lists:
        result = result.merge(list)
    result

# Zip two lists together
fn zip<A, B>(list_a: List<A>, list_b: List<B>) -> List<(A, B)>:
    val min_len = if list_a.len() < list_b.len():
        list_a.len()
    else:
        list_b.len()

    var result = []
    for i in 0..min_len:
        result.push((list_a[i], list_b[i]))

    result

# Chunk list into sublists of size n
fn chunk<T>(list: List<T>, chunk_size: i32) -> List<List<T>>:
    if chunk_size <= 0:
        return []

    var chunks = []
    var current_chunk = []

    for item in list:
        current_chunk.push(item)
        if current_chunk.len() >= chunk_size:
            chunks.push(current_chunk)
            current_chunk = []

    if current_chunk.len() > 0:
        chunks.push(current_chunk)

    chunks

# Intersperse separator between list elements
fn intersperse<T>(list: List<T>, separator: T) -> List<T>:
    if list.len() <= 1:
        return list

    var result = [list[0]]

    for i in 1..list.len():
        result.push(separator)
        result.push(list[i])

    result

# Get unique elements (preserving order)
fn unique<T>(list: List<T>) -> List<T>:
    dedup(list)

# Count occurrences of each element
fn count_occurrences<T>(list: List<T>) -> List<(T, i32)>:
    var counts = []

    for item in list:
        var found = false
        for i in 0..counts.len():
            if counts[i].0 == item:
                counts[i] = (item, counts[i].1 + 1)
                found = true
                break

        if not found:
            counts.push((item, 1))

    counts

# Find maximum element by comparison function
fn max_by<T>(list: List<T>, compare: fn(T, T) -> i32) -> Option<T>:
    if list.is_empty():
        return None

    var max_item = list[0]

    for i in 1..list.len():
        if compare(list[i], max_item) > 0:
            max_item = list[i]

    Some(max_item)

# Find minimum element by comparison function
fn min_by<T>(list: List<T>, compare: fn(T, T) -> i32) -> Option<T>:
    if list.is_empty():
        return None

    var min_item = list[0]

    for i in 1..list.len():
        if compare(list[i], min_item) < 0:
            min_item = list[i]

    Some(min_item)

# Reverse a list
fn reverse<T>(list: List<T>) -> List<T>:
    if list.is_empty():
        return []

    var result = []
    var i = list.len() - 1

    while i >= 0:
        result.push(list[i])
        i = i - 1

    result

# Chunk list into sublists of size n
fn chunk<T>(list: List<T>, size: i32) -> List<List<T>>:
    if size <= 0:
        return []

    var result: List<List<T>> = []
    var current_chunk: List<T> = []
    var count = 0

    for item in list:
        current_chunk.push(item)
        count = count + 1

        if count >= size:
            result.push(current_chunk)
            current_chunk = []
            count = 0

    # Add remaining items if any
    if not current_chunk.is_empty():
        result.push(current_chunk)

    result

# Interleave two lists
fn interleave<T>(list1: List<T>, list2: List<T>) -> List<T>:
    var result = []
    val max_len = if list1.len() > list2.len():
        list1.len()
    else:
        list2.len()

    var i = 0
    while i < max_len:
        if i < list1.len():
            result.push(list1[i])
        if i < list2.len():
            result.push(list2[i])
        i = i + 1

    result

# Zip two lists into list of pairs
fn zip<T, U>(list1: List<T>, list2: List<U>) -> List<(T, U)>:
    var result = []
    val min_len = if list1.len() < list2.len():
        list1.len()
    else:
        list2.len()

    var i = 0
    while i < min_len:
        result.push((list1[i], list2[i]))
        i = i + 1

    result

# Unzip list of pairs into two lists
fn unzip<T, U>(list: List<(T, U)>) -> (List<T>, List<U>):
    var first_list = []
    var second_list = []

    for (first, second) in list:
        first_list.push(first)
        second_list.push(second)

    (first_list, second_list)

# Rotate list left by n positions
fn rotate_left<T>(list: List<T>, n: i32) -> List<T>:
    if list.is_empty() or n <= 0:
        return list.clone()

    val len = list.len()
    val rotation = n % len

    if rotation == 0:
        return list.clone()

    var result = []

    # Add elements from rotation point to end
    for i in rotation..len:
        result.push(list[i])

    # Add elements from start to rotation point
    for i in 0..rotation:
        result.push(list[i])

    result

# Rotate list right by n positions
fn rotate_right<T>(list: List<T>, n: i32) -> List<T>:
    if list.is_empty() or n <= 0:
        return list.clone()

    val len = list.len()
    val rotation = len - (n % len)

    rotate_left(list, rotation)

# Find all indices where predicate is true
fn find_indices<T>(list: List<T>, predicate: fn(T) -> bool) -> List<i32>:
    var indices = []
    var i = 0

    for item in list:
        if predicate(item):
            indices.push(i)
        i = i + 1

    indices

# Group consecutive equal elements
fn group<T>(list: List<T>) -> List<List<T>>:
    if list.is_empty():
        return []

    var groups: List<List<T>> = []
    var current_group: List<T> = [list[0]]

    for i in 1..list.len():
        if list[i] == list[i - 1]:
            current_group.push(list[i])
        else:
            groups.push(current_group)
            current_group = [list[i]]

    # Add last group
    groups.push(current_group)

    groups

# Sliding window of size n
fn windows<T>(list: List<T>, size: i32) -> List<List<T>>:
    if size <= 0 or size > list.len():
        return []

    var result: List<List<T>> = []

    for i in 0..(list.len() - size + 1):
        var window: List<T> = []
        for j in 0..size:
            window.push(list[i + j])
        result.push(window)

    result
