# Data Structure utilities
# Queue, Stack, Deque (double-ended queue) implementations

# =====================================
# Stack (LIFO - Last In First Out)
# =====================================

struct Stack<T>:
    items: List<T>

impl Stack<T>:
    # Create new empty stack
    static fn new() -> Stack<T>:
        Stack(items: [])

    # Push item onto stack
    me push(item: T):
        self.items.push(item)

    # Pop item from stack
    me pop() -> Option<T>:
        if self.items.len() == 0:
            return None

        val last_idx = self.items.len() - 1
        val item = self.items[last_idx]
        self.items = self.items.slice(0, last_idx)
        Some(item)

    # Peek at top item without removing
    fn peek() -> Option<T>:
        if self.items.len() == 0:
            return None

        Some(self.items[self.items.len() - 1])

    # Check if stack is empty
    fn is_empty() -> bool:
        self.items.len() == 0

    # Get size of stack
    fn size() -> i32:
        self.items.len()

    # Clear all items
    me clear():
        self.items = []

    # Convert to list
    fn to_list() -> List<T>:
        self.items

# =====================================
# Queue (FIFO - First In First Out)
# =====================================

struct Queue<T>:
    items: List<T>

impl Queue<T>:
    # Create new empty queue
    static fn new() -> Queue<T>:
        Queue(items: [])

    # Enqueue (add to back)
    me enqueue(item: T):
        self.items.push(item)

    # Dequeue (remove from front)
    me dequeue() -> Option<T>:
        if self.items.len() == 0:
            return None

        val item = self.items[0]
        self.items = self.items.slice(1, self.items.len())
        Some(item)

    # Peek at front item without removing
    fn peek() -> Option<T>:
        if self.items.len() == 0:
            return None

        Some(self.items[0])

    # Check if queue is empty
    fn is_empty() -> bool:
        self.items.len() == 0

    # Get size of queue
    fn size() -> i32:
        self.items.len()

    # Clear all items
    me clear():
        self.items = []

    # Convert to list
    fn to_list() -> List<T>:
        self.items

# =====================================
# Deque (Double-Ended Queue)
# =====================================

struct Deque<T>:
    items: List<T>

impl Deque<T>:
    # Create new empty deque
    static fn new() -> Deque<T>:
        Deque(items: [])

    # Add to front
    me push_front(item: T):
        var new_items = [item]
        for existing in self.items:
            new_items.push(existing)
        self.items = new_items

    # Add to back
    me push_back(item: T):
        self.items.push(item)

    # Remove from front
    me pop_front() -> Option<T>:
        if self.items.len() == 0:
            return None

        val item = self.items[0]
        self.items = self.items.slice(1, self.items.len())
        Some(item)

    # Remove from back
    me pop_back() -> Option<T>:
        if self.items.len() == 0:
            return None

        val last_idx = self.items.len() - 1
        val item = self.items[last_idx]
        self.items = self.items.slice(0, last_idx)
        Some(item)

    # Peek at front
    fn peek_front() -> Option<T>:
        if self.items.len() == 0:
            return None

        Some(self.items[0])

    # Peek at back
    fn peek_back() -> Option<T>:
        if self.items.len() == 0:
            return None

        Some(self.items[self.items.len() - 1])

    # Check if deque is empty
    fn is_empty() -> bool:
        self.items.len() == 0

    # Get size of deque
    fn size() -> i32:
        self.items.len()

    # Clear all items
    me clear():
        self.items = []

    # Convert to list
    fn to_list() -> List<T>:
        self.items

# =====================================
# Priority Queue (Min-Heap)
# =====================================

struct PriorityQueue<T>:
    items: List<(i32, T)>  # (priority, value) pairs

impl PriorityQueue<T>:
    # Create new empty priority queue
    static fn new() -> PriorityQueue<T>:
        PriorityQueue(items: [])

    # Insert item with priority (lower number = higher priority)
    me insert(priority: i32, item: T):
        self.items.push((priority, item))
        self.bubble_up(self.items.len() - 1)

    # Extract minimum (highest priority) item
    me extract_min() -> Option<T>:
        if self.items.len() == 0:
            return None

        val min_item = self.items[0].1

        # Replace root with last item
        val last_idx = self.items.len() - 1
        self.items[0] = self.items[last_idx]
        self.items = self.items.slice(0, last_idx)

        # Bubble down
        if self.items.len() > 0:
            self.bubble_down(0)

        Some(min_item)

    # Peek at minimum without removing
    fn peek_min() -> Option<T>:
        if self.items.len() == 0:
            return None

        Some(self.items[0].1)

    # Check if empty
    fn is_empty() -> bool:
        self.items.len() == 0

    # Get size
    fn size() -> i32:
        self.items.len()

    # Bubble up from index
    me bubble_up(idx: i32):
        if idx == 0:
            return

        val parent_idx = (idx - 1) / 2
        if self.items[idx].0 < self.items[parent_idx].0:
            # Swap with parent
            val temp = self.items[idx]
            self.items[idx] = self.items[parent_idx]
            self.items[parent_idx] = temp
            self.bubble_up(parent_idx)

    # Bubble down from index
    me bubble_down(idx: i32):
        val left_idx = 2 * idx + 1
        val right_idx = 2 * idx + 2
        var smallest = idx

        if left_idx < self.items.len() and self.items[left_idx].0 < self.items[smallest].0:
            smallest = left_idx

        if right_idx < self.items.len() and self.items[right_idx].0 < self.items[smallest].0:
            smallest = right_idx

        if smallest != idx:
            # Swap
            val temp = self.items[idx]
            self.items[idx] = self.items[smallest]
            self.items[smallest] = temp
            self.bubble_down(smallest)

# =====================================
# Circular Buffer (Ring Buffer)
# =====================================

struct CircularBuffer<T>:
    buffer: List<Option<T>>
    capacity: i32
    head: i32      # read position
    tail: i32      # write position
    count: i32     # number of items

impl CircularBuffer<T>:
    # Create new circular buffer with capacity
    static fn new(capacity: i32) -> CircularBuffer<T>:
        var buffer = []
        for _ in 0..capacity:
            buffer.push(None)

        CircularBuffer(
            buffer: buffer,
            capacity: capacity,
            head: 0,
            tail: 0,
            count: 0
        )

    # Write item to buffer (overwrites oldest if full)
    me write(item: T):
        self.buffer[self.tail] = Some(item)
        self.tail = (self.tail + 1) % self.capacity

        if self.count < self.capacity:
            self.count = self.count + 1
        else:
            # Overwritten oldest, move head forward
            self.head = (self.head + 1) % self.capacity

    # Read item from buffer
    me read() -> Option<T>:
        if self.count == 0:
            return None

        match self.buffer[self.head]:
            Some(item) =>
                self.buffer[self.head] = None
                self.head = (self.head + 1) % self.capacity
                self.count = self.count - 1
                Some(item)
            None => None

    # Peek at next item without removing
    fn peek() -> Option<T>:
        if self.count == 0:
            return None

        self.buffer[self.head]

    # Check if buffer is empty
    fn is_empty() -> bool:
        self.count == 0

    # Check if buffer is full
    fn is_full() -> bool:
        self.count == self.capacity

    # Get current size
    fn size() -> i32:
        self.count

    # Get capacity
    fn get_capacity() -> i32:
        self.capacity

    # Clear buffer
    me clear():
        for i in 0..self.capacity:
            self.buffer[i] = None
        self.head = 0
        self.tail = 0
        self.count = 0

# =====================================
# Linked List Node
# =====================================

struct ListNode<T>:
    value: T
    next: Option<i32>  # Index of next node (simplified, not true pointer)

# =====================================
# Helper Functions
# =====================================

# Create stack from list
fn stack_from_list<T>(items: List<T>) -> Stack<T>:
    Stack(items: items)

# Create queue from list
fn queue_from_list<T>(items: List<T>) -> Queue<T>:
    Queue(items: items)

# Create deque from list
fn deque_from_list<T>(items: List<T>) -> Deque<T>:
    Deque(items: items)

# Reverse stack (in place)
fn reverse_stack<T>(stack: Stack<T>) -> Stack<T>:
    var reversed_items = []
    for item in stack.items:
        reversed_items = [item] + reversed_items
    Stack(items: reversed_items)

# Merge two queues
fn merge_queues<T>(q1: Queue<T>, q2: Queue<T>) -> Queue<T>:
    var merged = []
    for item in q1.items:
        merged.push(item)
    for item in q2.items:
        merged.push(item)
    Queue(items: merged)

# Get nth element from stack (0 = top)
fn stack_get<T>(stack: Stack<T>, n: i32) -> Option<T>:
    val idx = stack.items.len() - 1 - n
    if idx < 0 or idx >= stack.items.len():
        return None

    Some(stack.items[idx])

# Get nth element from queue (0 = front)
fn queue_get<T>(queue: Queue<T>, n: i32) -> Option<T>:
    if n < 0 or n >= queue.items.len():
        return None

    Some(queue.items[n])
