# Error Aggregation Across Languages
# Collect and normalize errors from multiple language compilers

use tooling.core.project.Language
use tooling.compiler.compiler_interface.{CompilationError, ErrorSeverity}
use sdn.{SdnValue, to_sdn}

# Error output format
pub enum ErrorFormat:
    Terminal    # Human-readable terminal output
    JSON        # JSON array of errors
    XML         # JUnit XML format
    VSCode      # VS Code problem matcher format

    pub fn to_string(self) -> text:
        """Convert format to string.

        Returns:
            Format name

        Example:
            ErrorFormat.JSON.to_string()  # → "json"
        """
        match self:
            ErrorFormat.Terminal: "terminal"
            ErrorFormat.JSON: "json"
            ErrorFormat.XML: "xml"
            ErrorFormat.VSCode: "vscode"

    pub fn description(self) -> text:
        """Get format description.

        Returns:
            Human-readable description
        """
        match self:
            ErrorFormat.Terminal: "Human-readable terminal output"
            ErrorFormat.JSON: "JSON array for tools and CI"
            ErrorFormat.XML: "JUnit XML for CI systems"
            ErrorFormat.VSCode: "VS Code problem matcher format"

    pub fn is_machine_readable(self) -> bool:
        """Check if format is machine-readable.

        Returns:
            True if JSON or XML
        """
        match self:
            ErrorFormat.Terminal: false
            ErrorFormat.JSON: true
            ErrorFormat.XML: true
            ErrorFormat.VSCode: true

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_terminal(self) -> bool:
        """Check if format is Terminal.

        Returns:
            True if Terminal format
        """
        match self:
            ErrorFormat.Terminal: true
            _: false

    pub fn is_json(self) -> bool:
        """Check if format is JSON.

        Returns:
            True if JSON format
        """
        match self:
            ErrorFormat.JSON: true
            _: false

    pub fn is_xml(self) -> bool:
        """Check if format is XML.

        Returns:
            True if XML format
        """
        match self:
            ErrorFormat.XML: true
            _: false

    pub fn is_vscode(self) -> bool:
        """Check if format is VSCode.

        Returns:
            True if VSCode format
        """
        match self:
            ErrorFormat.VSCode: true
            _: false

    pub fn is_human_readable(self) -> bool:
        """Check if format is human-readable.

        Returns:
            True if Terminal format
        """
        match self:
            ErrorFormat.Terminal: true
            _: false

    pub fn is_ci_compatible(self) -> bool:
        """Check if format is compatible with CI systems.

        Returns:
            True if XML or JSON
        """
        match self:
            ErrorFormat.XML: true
            ErrorFormat.JSON: true
            _: false

    pub fn supports_structured_data(self) -> bool:
        """Check if format supports structured data.

        Returns:
            True if JSON, XML, or VSCode format
        """
        self.is_machine_readable()

    pub fn file_extension(self) -> text:
        """Get typical file extension for this format.

        Returns:
            File extension (with dot)

        Example:
            ErrorFormat.JSON.file_extension()  # → ".json"
        """
        match self:
            ErrorFormat.Terminal: ".txt"
            ErrorFormat.JSON: ".json"
            ErrorFormat.XML: ".xml"
            ErrorFormat.VSCode: ".txt"

    pub fn mime_type(self) -> text:
        """Get MIME type for this format.

        Returns:
            MIME type string

        Example:
            ErrorFormat.JSON.mime_type()  # → "application/json"
        """
        match self:
            ErrorFormat.Terminal: "text/plain"
            ErrorFormat.JSON: "application/json"
            ErrorFormat.XML: "application/xml"
            ErrorFormat.VSCode: "text/plain"

    pub fn summary(self) -> text:
        """Get summary of error format.

        Returns:
            Human-readable summary

        Example:
            ErrorFormat.JSON.summary()
            # → "ErrorFormat: json (machine-readable, CI-compatible)"
        """
        val name = self.to_string()
        val readable = if self.is_machine_readable(): "machine-readable" else: "human-readable"
        val ci = if self.is_ci_compatible(): ", CI-compatible" else: ""
        "ErrorFormat: {name} ({readable}{ci})"

# Error aggregator - collects and normalizes errors
pub class ErrorAggregator:
    pub errors: List<CompilationError>
    pub warnings: List<CompilationError>
    pub infos: List<CompilationError>
    pub dedup_enabled: bool

    pub fn new() -> ErrorAggregator:
        """Create error aggregator.

        Returns:
            Empty aggregator

        Example:
            val aggregator = ErrorAggregator.new()

            aggregator.add_simple_errors(simple_errors)
            aggregator.add_rust_errors(cargo_output)
            aggregator.add_python_errors(mypy_output)

            for error in aggregator.get_all():
                print(error.format())
        """
        ErrorAggregator {
            errors: [],
            warnings: [],
            infos: [],
            dedup_enabled: true
        }

    pub fn set_deduplication(self, enabled: bool):
        """Enable/disable error deduplication.

        Args:
            enabled: True to remove duplicate errors
        """
        self.dedup_enabled = enabled

    pub fn add_error(self, error: CompilationError):
        """Add compilation error.

        Args:
            error: Error to add
        """
        # Check for duplicate
        if self.dedup_enabled and self.is_duplicate(error):
            return

        match error.severity:
            ErrorSeverity.Error:
                self.errors.append(error)
            ErrorSeverity.Warning:
                self.warnings.append(error)
            ErrorSeverity.Info:
                self.infos.append(error)

    pub fn add_errors(self, errors: List<CompilationError>):
        """Add multiple errors.

        Args:
            errors: List of errors
        """
        for error in errors:
            self.add_error(error)

    pub fn add_simple_errors(self, errors: List<CompilationError>):
        """Add Simple compiler errors.

        Args:
            errors: Simple compiler errors
        """
        self.add_errors(errors)

    pub fn add_rust_errors(self, cargo_output: text):
        """Parse and add Rust/cargo errors.

        Args:
            cargo_output: Cargo JSON output
        """
        val errors = self.parse_cargo_json(cargo_output)
        self.add_errors(errors)

    pub fn add_python_errors(self, mypy_output: text):
        """Parse and add Python/mypy errors.

        Args:
            mypy_output: Mypy text output
        """
        val errors = self.parse_mypy_output(mypy_output)
        self.add_errors(errors)

    pub fn add_javascript_errors(self, eslint_output: text):
        """Parse and add JavaScript/ESLint errors.

        Args:
            eslint_output: ESLint JSON output
        """
        val errors = self.parse_eslint_json(eslint_output)
        self.add_errors(errors)

    fn is_duplicate(error: CompilationError) -> bool:
        """Check if error is duplicate.

        Args:
            error: Error to check

        Returns:
            True if duplicate exists
        """
        val all_errors = self.get_all()

        for existing in all_errors:
            if self.errors_equal(existing, error):
                return true

        false

    fn errors_equal(a: CompilationError, b: CompilationError) -> bool:
        """Check if two errors are equal.

        Args:
            a: First error
            b: Second error

        Returns:
            True if same file, line, column, and message
        """
        a.file == b.file and a.line == b.line and a.column == b.column and a.message == b.message

    pub fn get_all(self) -> List<CompilationError>:
        """Get all errors, warnings, and infos.

        Returns:
            Combined list sorted by severity
        """
        var all: List<CompilationError> = []
        all.extend(self.errors)
        all.extend(self.warnings)
        all.extend(self.infos)
        all

    pub fn get_by_severity(self, severity: ErrorSeverity) -> List<CompilationError>:
        """Get errors of specific severity.

        Args:
            severity: Error severity

        Returns:
            Filtered error list
        """
        match severity:
            ErrorSeverity.Error:
                self.errors.clone()
            ErrorSeverity.Warning:
                self.warnings.clone()
            ErrorSeverity.Info:
                self.infos.clone()

    pub fn group_by_file(self): Dict<text, List<CompilationError>>:
        """Group errors by file.

        Returns:
            Map from file to errors in that file

        Example:
            val by_file = aggregator.group_by_file()
            for (file, errors) in by_file:
                print("{file}: {errors.len()} errors")
        """
        val groups: Dict<text, List<CompilationError>> = {}

        for error in self.get_all():
            if not groups.contains_key(error.file):
                groups[error.file] = []

            groups[error.file].append(error)

        groups

    pub fn group_by_language(self): Dict<Language, List<CompilationError>>:
        """Group errors by language.

        Returns:
            Map from language to errors in that language
        """
        val groups: Dict<Language, List<CompilationError>> = {}

        for error in self.get_all():
            if not groups.contains_key(error.language):
                groups[error.language] = []

            groups[error.language].append(error)

        groups

    pub fn format_output(self, format: ErrorFormat) -> text:
        """Format errors for output.

        Args:
            format: Output format

        Returns:
            Formatted error string

        Example:
            # Terminal output
            print(aggregator.format_output(ErrorFormat.Terminal))

            # JSON for tools
            val json = aggregator.format_output(ErrorFormat.JSON)
        """
        match format:
            ErrorFormat.Terminal:
                self.format_terminal()
            ErrorFormat.JSON:
                self.format_json()
            ErrorFormat.XML:
                self.format_xml()
            ErrorFormat.VSCode:
                self.format_vscode()

    fn format_terminal() -> text:
        """Format errors for terminal display.

        Returns:
            Human-readable error list
        """
        var output = ""

        if self.errors.len() > 0:
            output += "Errors:\n"
            for error in self.errors:
                output += "  {error.format()}\n"

        if self.warnings.len() > 0:
            output += "\nWarnings:\n"
            for warning in self.warnings:
                output += "  {warning.format()}\n"

        if self.infos.len() > 0:
            output += "\nInfo:\n"
            for info in self.infos:
                output += "  {info.format()}\n"

        if output.is_empty():
            output = "No errors\n"

        output

    fn format_json() -> text:
        """Format errors as JSON array (using SDN).

        Returns:
            JSON-compatible string

        Format:
            [
              {
                "file": "app.spl",
                "line": 10,
                "column": 5,
                "severity": "error",
                "message": "Type mismatch",
                "language": "Simple"
              }
            ]
        """
        # Build SDN array of error objects
        var errors_array: List<SdnValue> = []

        for error in self.get_all():
            var error_dict: Dict<text, SdnValue> = {}

            error_dict["file"] = SdnValue.text(error.file)
            error_dict["line"] = SdnValue.i32(error.line as i64)
            error_dict["column"] = SdnValue.i32(error.column as i64)
            error_dict["severity"] = SdnValue.text(self.severity_to_string(error.severity))
            error_dict["message"] = SdnValue.text(error.message)
            error_dict["language"] = SdnValue.text(self.language_to_string(error.language))

            errors_array.append(SdnValue.Dict(error_dict))

        # Serialize to SDN (which is JSON-compatible for arrays)
        val sdn_array = SdnValue.Array(errors_array)
        to_sdn(sdn_array)

    fn severity_to_string(severity: ErrorSeverity) -> text:
        """Convert severity to string.

        Args:
            severity: Error severity

        Returns:
            Severity string
        """
        match severity:
            ErrorSeverity.Error: "error"
            ErrorSeverity.Warning: "warning"
            ErrorSeverity.Info: "info"

    fn language_to_string(language: Language) -> text:
        """Convert language to string.

        Args:
            language: Language enum

        Returns:
            Language name
        """
        match language:
            Language.Simple: "Simple"
            Language.Rust: "Rust"
            Language.Python: "Python"
            Language.JavaScript: "JavaScript"
            Language.TypeScript: "TypeScript"
            Language.Go: "Go"
            Language.C: "C"
            Language.Cpp: "Cpp"

    fn format_xml() -> text:
        """Format errors as JUnit XML.

        Returns:
            XML string for CI systems

        Format:
            <testsuites>
              <testsuite name="compilation" tests="1" errors="3" failures="0">
                <testcase name="build" classname="compilation">
                  <error message="Type mismatch" type="error">
                    app.spl:10:5: Type mismatch
                  </error>
                </testcase>
              </testsuite>
            </testsuites>
        """
        val total_errors = self.errors.len()
        val total_warnings = self.warnings.len()

        var xml = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
        xml += "<testsuites>\n"
        xml += "  <testsuite name=\"compilation\" tests=\"1\" "
        xml += "errors=\"{total_errors}\" failures=\"{total_warnings}\" skipped=\"0\">\n"
        xml += "    <testcase name=\"build\" classname=\"compilation\">\n"

        # Add errors
        for error in self.errors:
            xml += "      <error message=\"{self.escape_xml(error.message)}\" type=\"error\">\n"
            xml += "        {self.escape_xml(error.file)}:{error.line}:{error.column}: {self.escape_xml(error.message)}\n"
            xml += "      </error>\n"

        # Add warnings as failures
        for warning in self.warnings:
            xml += "      <failure message=\"{self.escape_xml(warning.message)}\" type=\"warning\">\n"
            xml += "        {self.escape_xml(warning.file)}:{warning.line}:{warning.column}: {self.escape_xml(warning.message)}\n"
            xml += "      </failure>\n"

        xml += "    </testcase>\n"
        xml += "  </testsuite>\n"
        xml += "</testsuites>\n"

        xml

    fn escape_xml(text: text) -> text:
        """Escape XML special characters.

        Args:
            text: Text to escape

        Returns:
            Escaped text
        """
        var result = text
        result = result.replace("&", "&amp;")
        result = result.replace("<", "&lt;")
        result = result.replace(">", "&gt;")
        result = result.replace("\"", "&quot;")
        result = result.replace("'", "&apos;")
        result

    fn format_vscode() -> text:
        """Format errors for VS Code problem matcher.

        Returns:
            VS Code problem format
        """
        # VS Code format: file(line,col) -> severity: message
        var output = ""

        for error in self.get_all():
            val severity_str = match error.severity:
                ErrorSeverity.Error: "error"
                ErrorSeverity.Warning: "warning"
                ErrorSeverity.Info: "info"

            output += "{error.file}({error.line},{error.column}): {severity_str}: {error.message}\n"

        output

    # Language-specific parsers

    fn parse_cargo_json(json_output: text) -> List<CompilationError>:
        """Parse Cargo JSON diagnostic output.

        Args:
            json_output: Cargo --message-format=json output

        Returns:
            List of errors
        """
        import core.json.{parse, JsonValue}

        val errors: List<CompilationError> = []

        # Cargo outputs one JSON object per line
        val lines = json_output.split("\n")
        for line in lines:
            if line.trim().is_empty():
                continue

            match parse(line):
                Ok(JsonValue.Object(obj)) ->
                    # Check if this is a compiler message
                    match obj.get("reason"):
                        Some(JsonValue.String("compiler-message")) ->
                            # Extract the message object
                            match obj.get("message"):
                                Some(JsonValue.Object(msg)) ->
                                    val error = self.extract_cargo_message(msg)
                                    if error.is_some():
                                        errors.append(error.unwrap())
                                _ -> pass
                        _ -> pass
                _ -> pass

        errors

    fn extract_cargo_message(msg: Dict<text, JsonValue>) -> Option<CompilationError>:
        """Extract error from Cargo message object."""
        import core.json.{JsonValue}

        # Get severity
        val level = match msg.get("level"):
            Some(JsonValue.String(s)) -> s
            _ -> return None

        val severity = match level:
            "error" -> ErrorSeverity.Error
            "warning" -> ErrorSeverity.Warning
            _ -> ErrorSeverity.Info

        # Get message text
        val message_text = match msg.get("message"):
            Some(JsonValue.String(s)) -> s
            _ -> return None

        # Get span info (file, line, column)
        var file_path = ""
        var line: i32 = 0
        var column: i32 = 0

        match msg.get("spans"):
            Some(JsonValue.Array(spans)) ->
                if spans.len() > 0:
                    match spans[0]:
                        JsonValue.Object(span) ->
                            file_path = match span.get("file_name"):
                                Some(JsonValue.String(s)) -> s
                                _ -> ""
                            line = match span.get("line_start"):
                                Some(JsonValue.Number(n)) -> n as i32
                                _ -> 0
                            column = match span.get("column_start"):
                                Some(JsonValue.Number(n)) -> n as i32
                                _ -> 0
                        _ -> pass
            _ -> pass

        Some(CompilationError {
            file: file_path,
            line: line,
            column: column,
            severity: severity,
            code: "",
            message: message_text,
            context: []
        })

    fn parse_mypy_output(output: text) -> List<CompilationError>:
        """Parse mypy text output.

        Args:
            output: Mypy stdout

        Returns:
            List of errors

        Format: file:line: error: message
        """
        val errors: List<CompilationError> = []

        val lines = output.split("\n")
        for line in lines:
            if line.trim().is_empty():
                continue

            # Try to parse error line
            match self.try_parse_mypy_line(line):
                some(error):
                    errors.append(error)
                none:
                    pass  # Skip non-error lines

        errors

    fn try_parse_mypy_line(line: text) -> Option<CompilationError>:
        """Try to parse single mypy error line.

        Args:
            line: Error line

        Returns:
            Parsed error or none

        Format: file.py:line: severity: message
        Example: app.py:10: error: Type mismatch
        """
        # Find first colon (after filename)
        val first_colon = line.find(":")
        if first_colon < 0:
            return none

        val file = line[0:first_colon].trim()

        # Find second colon (after line number)
        val rest = line[first_colon+1:]
        val second_colon = rest.find(":")
        if second_colon < 0:
            return none

        val line_str = rest[0:second_colon].trim()
        val line_num = self.parse_int_safe(line_str)

        # Find third colon (after severity)
        val rest2 = rest[second_colon+1:]
        val third_colon = rest2.find(":")
        if third_colon < 0:
            return none

        val severity_str = rest2[0:third_colon].trim()
        val message = rest2[third_colon+1:].trim()

        # Parse severity
        val severity = match severity_str:
            "error": ErrorSeverity.Error
            "warning": ErrorSeverity.Warning
            "note": ErrorSeverity.Info
            "info": ErrorSeverity.Info
            _: ErrorSeverity.Error

        some(CompilationError {
            file: file,
            line: line_num,
            column: 0,  # mypy doesn't always provide column
            message: message,
            severity: severity,
            language: Language.Python
        })

    fn parse_int_safe(s: text) -> i32:
        """Parse integer safely, returning 0 on error.

        Args:
            s: text to parse

        Returns:
            Parsed integer or 0
        """
        val trimmed = s.trim()
        if trimmed.is_empty():
            return 0

        var result = 0
        for i in 0..trimmed.len():
            val ch = trimmed[i]
            if ch >= '0' and ch <= '9':
                val digit = (ch as i32) - ('0' as i32)
                result = result * 10 + digit
            else:
                return 0  # Non-digit found

        result

    fn parse_eslint_json(json_output: text) -> List<CompilationError>:
        """Parse ESLint JSON output.

        Args:
            json_output: ESLint --format=json output

        Returns:
            List of errors

        ESLint JSON format:
        [{
            "filePath": "/path/to/file.js",
            "messages": [{
                "ruleId": "no-unused-vars",
                "severity": 2,
                "message": "'x' is defined but never used",
                "line": 10,
                "column": 5
            }]
        }]
        """
        import core.json.{parse, JsonValue}

        val errors: List<CompilationError> = []

        match parse(json_output):
            Ok(JsonValue.Array(files)) ->
                for file_result in files:
                    match file_result:
                        JsonValue.Object(file_obj) ->
                            val file_path = match file_obj.get("filePath"):
                                Some(JsonValue.String(s)) -> s
                                _ -> ""

                            match file_obj.get("messages"):
                                Some(JsonValue.Array(messages)) ->
                                    for msg in messages:
                                        match msg:
                                            JsonValue.Object(msg_obj) ->
                                                val error = self.extract_eslint_message(file_path, msg_obj)
                                                if error.is_some():
                                                    errors.append(error.unwrap())
                                            _ -> pass
                                _ -> pass
                        _ -> pass
            _ -> pass

        errors

    fn extract_eslint_message(file_path: text, msg: Dict<text, JsonValue>) -> Option<CompilationError>:
        """Extract error from ESLint message object."""
        import core.json.{JsonValue}

        # Get message text
        val message_text = match msg.get("message"):
            Some(JsonValue.String(s)) -> s
            _ -> return None

        # Get severity (1=warning, 2=error)
        val severity = match msg.get("severity"):
            Some(JsonValue.Number(n)) ->
                if n >= 2.0:
                    ErrorSeverity.Error
                else:
                    ErrorSeverity.Warning
            _ -> ErrorSeverity.Warning

        # Get location
        val line = match msg.get("line"):
            Some(JsonValue.Number(n)) -> n as i32
            _ -> 0

        val column = match msg.get("column"):
            Some(JsonValue.Number(n)) -> n as i32
            _ -> 0

        # Get rule ID as error code
        val code = match msg.get("ruleId"):
            Some(JsonValue.String(s)) -> s
            Some(JsonValue.Null) -> ""
            _ -> ""

        Some(CompilationError {
            file: file_path,
            line: line,
            column: column,
            severity: severity,
            code: code,
            message: message_text,
            context: []
        })

    pub fn print_summary(self):
        """Print error summary.

        Example:
            aggregator.print_summary()
            # → "3 errors, 5 warnings, 2 infos"
        """
        val total_errors = self.errors.len()
        val total_warnings = self.warnings.len()
        val total_infos = self.infos.len()

        print("{total_errors} errors, {total_warnings} warnings, {total_infos} infos")

    pub fn has_errors(self) -> bool:
        """Check if any errors exist.

        Returns:
            True if errors (not warnings) exist
        """
        self.errors.len() > 0

    pub fn total_count(self) -> i32:
        """Get total error/warning/info count.

        Returns:
            Total count across all severities
        """
        self.errors.len() + self.warnings.len() + self.infos.len()

    pub fn is_empty(self) -> bool:
        """Check if aggregator has no errors/warnings/infos.

        Returns:
            True if empty
        """
        self.total_count() == 0

    pub fn summary(self) -> text:
        """Get error summary.

        Returns:
            Human-readable summary

        Example:
            aggregator.summary()
            # → "3 errors, 5 warnings, 2 infos"
        """
        "{self.errors.len()} errors, {self.warnings.len()} warnings, {self.infos.len()} infos"

    pub fn error_count(self) -> i32:
        """Get error count.

        Returns:
            Number of errors
        """
        self.errors.len()

    pub fn warning_count(self) -> i32:
        """Get warning count.

        Returns:
            Number of warnings
        """
        self.warnings.len()

    pub fn info_count(self) -> i32:
        """Get info count.

        Returns:
            Number of infos
        """
        self.infos.len()
