# Multi-Language Project Detection & Configuration
# Detects language roots, reads config files, manages project structure

use host.async_nogc_mut.io.fs
use host.common.io.types.{FileType, DirEntry, FilePath, DirPath}
use sdn.{SdnDocument, SdnValue}
use core.result.{Result, Ok, Err}

# Project language type
pub enum Language:
    Simple
    Rust
    Python
    JavaScript
    TypeScript
    Go
    C
    Cpp

    pub fn to_string(self) -> text:
        """Convert language to string.

        Returns:
            Language name

        Example:
            Language.Rust.to_string()  # -> "Rust"
        """
        match self:
            Language.Simple: "Simple"
            Language.Rust: "Rust"
            Language.Python: "Python"
            Language.JavaScript: "JavaScript"
            Language.TypeScript: "TypeScript"
            Language.Go: "Go"
            Language.C: "C"
            Language.Cpp: "C++"

    pub fn description(self) -> text:
        """Get language description.

        Returns:
            Human-readable description

        Example:
            Language.Rust.description()
            # -> "Systems programming language with memory safety"
        """
        match self:
            Language.Simple: "Simple programming language (this project)"
            Language.Rust: "Systems programming language with memory safety"
            Language.Python: "High-level interpreted scripting language"
            Language.JavaScript: "Dynamic scripting language for web"
            Language.TypeScript: "Typed superset of JavaScript"
            Language.Go: "Compiled language with goroutines and channels"
            Language.C: "Low-level systems programming language"
            Language.Cpp: "C++ systems programming with object-oriented features"

    pub fn get_extension(self) -> text:
        """Get file extension for language.

        Returns:
            File extension with dot

        Example:
            Language.Rust.get_extension()  # -> ".rs"
        """
        match self:
            Language.Simple: ".spl"
            Language.Rust: ".rs"
            Language.Python: ".py"
            Language.JavaScript: ".js"
            Language.TypeScript: ".ts"
            Language.Go: ".go"
            Language.C: ".c"
            Language.Cpp: ".cpp"

    pub fn is_compiled(self) -> bool:
        """Check if language is compiled.

        Returns:
            True if compiled language

        Example:
            Language.Rust.is_compiled()  # -> true
            Language.Python.is_compiled()  # -> false
        """
        match self:
            Language.Simple: true
            Language.Rust: true
            Language.Go: true
            Language.C: true
            Language.Cpp: true
            Language.Python: false
            Language.JavaScript: false
            Language.TypeScript: false  # TypeScript transpiles, not compiles to machine code

    pub fn is_interpreted(self) -> bool:
        """Check if language is interpreted.

        Returns:
            True if interpreted language
        """
        not self.is_compiled()

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_simple(self) -> bool:
        """Check if language is Simple.

        Returns:
            True if Simple
        """
        match self:
            Language.Simple: true
            _: false

    pub fn is_rust(self) -> bool:
        """Check if language is Rust.

        Returns:
            True if Rust
        """
        match self:
            Language.Rust: true
            _: false

    pub fn is_python(self) -> bool:
        """Check if language is Python.

        Returns:
            True if Python
        """
        match self:
            Language.Python: true
            _: false

    pub fn is_javascript(self) -> bool:
        """Check if language is JavaScript.

        Returns:
            True if JavaScript
        """
        match self:
            Language.JavaScript: true
            _: false

    pub fn is_typescript(self) -> bool:
        """Check if language is TypeScript.

        Returns:
            True if TypeScript
        """
        match self:
            Language.TypeScript: true
            _: false

    pub fn is_go(self) -> bool:
        """Check if language is Go.

        Returns:
            True if Go
        """
        match self:
            Language.Go: true
            _: false

    pub fn is_c(self) -> bool:
        """Check if language is C.

        Returns:
            True if C
        """
        match self:
            Language.C: true
            _: false

    pub fn is_cpp(self) -> bool:
        """Check if language is C++.

        Returns:
            True if C++
        """
        match self:
            Language.Cpp: true
            _: false

    pub fn is_scripting_language(self) -> bool:
        """Check if language is a scripting language.

        Returns:
            True if Python or JavaScript
        """
        match self:
            Language.Python: true
            Language.JavaScript: true
            _: false

    pub fn is_systems_language(self) -> bool:
        """Check if language is a systems programming language.

        Returns:
            True if Rust, C, C++, or Go
        """
        match self:
            Language.Rust: true
            Language.C: true
            Language.Cpp: true
            Language.Go: true
            _: false

    pub fn supports_type_annotations(self) -> bool:
        """Check if language supports type annotations.

        Returns:
            True if language has type system
        """
        match self:
            Language.Simple: true
            Language.Rust: true
            Language.TypeScript: true
            Language.Go: true
            Language.C: true
            Language.Cpp: true
            Language.Python: true  # Python has optional type hints
            Language.JavaScript: false

    pub fn is_statically_typed(self) -> bool:
        """Check if language is statically typed.

        Returns:
            True if static typing
        """
        match self:
            Language.Simple: true
            Language.Rust: true
            Language.TypeScript: true
            Language.Go: true
            Language.C: true
            Language.Cpp: true
            _: false

    pub fn is_dynamically_typed(self) -> bool:
        """Check if language is dynamically typed.

        Returns:
            True if dynamic typing
        """
        not self.is_statically_typed()

    pub fn has_package_manager(self) -> bool:
        """Check if language has a standard package manager.

        Returns:
            True if package manager exists
        """
        match self:
            Language.Simple: true   # spm
            Language.Rust: true     # cargo
            Language.Python: true   # pip
            Language.JavaScript: true  # npm
            Language.TypeScript: true  # npm
            Language.Go: true       # go mod
            _: false

    pub fn get_package_manager(self) -> text:
        """Get name of package manager.

        Returns:
            Package manager name or empty string

        Example:
            Language.Rust.get_package_manager()  # -> "cargo"
        """
        match self:
            Language.Simple: "spm"
            Language.Rust: "cargo"
            Language.Python: "pip"
            Language.JavaScript: "npm"
            Language.TypeScript: "npm"
            Language.Go: "go"
            Language.C: ""
            Language.Cpp: ""

    pub fn summary(self) -> text:
        """Get summary of language.

        Returns:
            Human-readable summary

        Example:
            Language.Rust.summary()
            # -> "Language: Rust (compiled, static typing, cargo)"
        """
        val name = self.to_string()
        val compilation = if self.is_compiled():
            "compiled"
        else:
            "interpreted"
        val typing = if self.is_statically_typed():
            "static typing"
        else:
            "dynamic typing"
        val pm = self.get_package_manager()
        val pm_str = if pm.is_empty():
            ""
        else:
            ", {pm}"
        "Language: {name} ({compilation}, {typing}{pm_str})"

# Project configuration
pub class ProjectConfig:
    pub name: text
    pub version: text
    pub root: text
    pub languages: List<LanguageConfig>
    pub build_dir: text
    pub test_dir: text
    pub deploy_dir: text

    pub fn new(root: text) -> ProjectConfig:
        """Create default project configuration.

        Args:
            root: Project root directory

        Returns:
            Default configuration
        """
        ProjectConfig {
            name: "unnamed",
            version: "0.1.0",
            root: root,
            languages: [],
            build_dir: "target",
            test_dir: "tests",
            deploy_dir: "dist"
        }

    pub fn load_from_file(path: text) -> Result<ProjectConfig, text>:
        """Load project config from simple.sdn.

        Args:
            path: Path to simple.sdn file

        Returns:
            Loaded configuration or error

        Example simple.sdn format:
            name: my-project
            version: 1.0.0

            languages:
              - language: Simple
                root: .
                source_dirs: [src, lib]

              - language: Rust
                root: ./backend
                source_dirs: [src]
                exclude_patterns: [target]

            build_dir: target
            test_dir: tests
            deploy_dir: dist
        """
        # Try to read the file
        match fs.read_text_sync(path as FilePath):
            Ok(content):
                # Parse SDN
                match SdnDocument.parse(content):
                    Ok(doc):
                        # Extract configuration from SDN document
                        val config = self.parse_sdn_config(doc, path)
                        Ok(config)
                    Err(err):
                        Err("Failed to parse SDN config: " + err.to_string())
            Err(_):
                # File doesn't exist, return default
                val config = ProjectConfig.new(".")
                Ok(config)

    fn parse_sdn_config(doc: SdnDocument, path: text) -> ProjectConfig:
        """Parse SDN document into project configuration.

        Args:
            doc: Parsed SDN document
            path: Original file path for root extraction

        Returns:
            Project configuration
        """
        val root_path = self.get_parent_dir_static(path)
        var config = ProjectConfig.new(root_path)

        # Extract name
        match doc.get("name"):
            some(SdnValue.text(name)):
                config.name = name
            _:
                pass

        # Extract version
        match doc.get("version"):
            some(SdnValue.text(version)):
                config.version = version
            _:
                pass

        # Extract build_dir
        match doc.get("build_dir"):
            some(SdnValue.text(dir)):
                config.build_dir = dir
            _:
                pass

        # Extract test_dir
        match doc.get("test_dir"):
            some(SdnValue.text(dir)):
                config.test_dir = dir
            _:
                pass

        # Extract deploy_dir
        match doc.get("deploy_dir"):
            some(SdnValue.text(dir)):
                config.deploy_dir = dir
            _:
                pass

        # Extract language configurations
        match doc.get("languages"):
            some(SdnValue.Array(langs)):
                for lang_val in langs:
                    match self.parse_language_config(lang_val):
                        some(lang_config):
                            config.languages.append(lang_config)
                        none:
                            pass
            _:
                pass

        config

    fn parse_language_config(value: SdnValue) -> Option<LanguageConfig>:
        """Parse language configuration from SDN value.

        Args:
            value: SDN value representing language config

        Returns:
            Language configuration if valid
        """
        match value:
            SdnValue.Dict(dict):
                # Get language type
                val lang_type = match dict.get("language"):
                    some(SdnValue.text(lang_str)):
                        self.parse_language_string(lang_str)
                    _:
                        return none

                # Get root path
                val root = match dict.get("root"):
                    some(SdnValue.text(r)):
                        r
                    _:
                        "."

                # Create config
                var config = LanguageConfig.new(lang_type, root)

                # Get source directories
                match dict.get("source_dirs"):
                    some(SdnValue.Array(dirs)):
                        config.source_dirs = []
                        for dir_val in dirs:
                            match dir_val:
                                SdnValue.text(dir):
                                    config.source_dirs.append(dir)
                                _:
                                    pass
                    _:
                        pass

                # Get exclude patterns
                match dict.get("exclude_patterns"):
                    some(SdnValue.Array(patterns)):
                        config.exclude_patterns = []
                        for pat_val in patterns:
                            match pat_val:
                                SdnValue.text(pat):
                                    config.exclude_patterns.append(pat)
                                _:
                                    pass
                    _:
                        pass

                # Get compiler flags
                match dict.get("compiler_flags"):
                    some(SdnValue.Array(flags)):
                        config.compiler_flags = []
                        for flag_val in flags:
                            match flag_val:
                                SdnValue.text(flag):
                                    config.compiler_flags.append(flag)
                                _:
                                    pass
                    _:
                        pass

                # Get test command
                match dict.get("test_command"):
                    some(SdnValue.text(cmd)):
                        config.test_command = cmd
                    _:
                        pass

                some(config)
            _:
                none

    fn parse_language_string(lang_str: text) -> Language:
        """Parse language string to Language enum.

        Args:
            lang_str: Language name

        Returns:
            Language enum value
        """
        match lang_str:
            "Simple": Language.Simple
            "Rust": Language.Rust
            "Python": Language.Python
            "JavaScript": Language.JavaScript
            "TypeScript": Language.TypeScript
            "Go": Language.Go
            "C": Language.C
            "Cpp": Language.Cpp
            "C++": Language.Cpp
            _: Language.Simple  # Default

    fn get_parent_dir_static(path: text) -> text:
        """Get parent directory from path (static method).

        Args:
            path: File path

        Returns:
            Parent directory
        """
        val last_slash = path.rfind("/")
        if last_slash >= 0:
            path[0:last_slash]
        else:
            "."

    pub fn add_language(self, lang_config: LanguageConfig):
        """Add language configuration.

        Args:
            lang_config: Language configuration to add
        """
        self.languages.append(lang_config)

    pub fn get_language_config(self, language: Language) -> Option<LanguageConfig>:
        """Get configuration for specific language.

        Args:
            language: Language to get config for

        Returns:
            Language config if found
        """
        for config in self.languages:
            if config.language == language:
                return some(config)
        none

    pub fn has_language(self, language: Language) -> bool:
        """Check if project uses specific language.

        Args:
            language: Language to check

        Returns:
            True if language is configured
        """
        for config in self.languages:
            if config.language == language:
                return true
        false

    pub fn language_count(self) -> i32:
        """Get number of configured languages.

        Returns:
            Language count
        """
        self.languages.len()

    pub fn is_multi_language(self) -> bool:
        """Check if project uses multiple languages.

        Returns:
            True if 2+ languages
        """
        self.languages.len() >= 2

    pub fn summary(self) -> text:
        """Get project summary.

        Returns:
            Human-readable summary

        Example:
            config.summary()
            # -> "my-project v1.0.0 (3 languages: Simple, Rust, Python)"
        """
        val lang_names: List<text> = []
        for config in self.languages:
            lang_names.append(config.language.to_string())

        "{self.name} v{self.version} ({self.language_count()} languages: {lang_names.join(', ')})"

# Language-specific configuration
pub class LanguageConfig:
    pub language: Language
    pub root: text
    pub source_dirs: List<text>
    pub exclude_patterns: List<text>
    pub compiler_flags: List<text>
    pub test_command: text

    pub fn new(language: Language, root: text) -> LanguageConfig:
        """Create language configuration.

        Args:
            language: Language type
            root: Language root directory

        Returns:
            Default language configuration
        """
        LanguageConfig {
            language: language,
            root: root,
            source_dirs: ["src"],
            exclude_patterns: ["target", "node_modules", "__pycache__", ".git"],
            compiler_flags: [],
            test_command: ""
        }

    pub fn has_compiler_flags(self) -> bool:
        """Check if compiler flags are set.

        Returns:
            True if custom flags exist
        """
        self.compiler_flags.len() > 0

    pub fn has_test_command(self) -> bool:
        """Check if test command is set.

        Returns:
            True if test command exists
        """
        self.test_command != ""

    pub fn summary(self) -> text:
        """Get language config summary.

        Returns:
            Human-readable summary

        Example:
            config.summary()
            # -> "Rust at ./backend (src dirs: src, lib)"
        """
        "{self.language.to_string()} at {self.root} (src dirs: {self.source_dirs.join(', ')})"

# Project detector - finds language roots in project
pub class ProjectDetector:
    pub root: text

    pub fn new(root: text) -> ProjectDetector:
        """Create project detector.

        Args:
            root: Project root directory
        """
        ProjectDetector { root: root }

    pub fn detect_all_languages(self) -> List<LanguageConfig>:
        """Detect all languages in project.

        Returns:
            List of detected language configurations

        Example:
            val detector = ProjectDetector.new(".")
            val languages = detector.detect_all_languages()
            for config in languages:
                print("Found {config.language} at {config.root}")
        """
        val configs: List<LanguageConfig> = []

        # Detect Simple
        if self.has_simple_project():
            configs.append(LanguageConfig.new(Language.Simple, self.root))

        # Detect Rust
        val rust_roots = self.find_cargo_projects()
        for root in rust_roots:
            configs.append(LanguageConfig.new(Language.Rust, root))

        # Detect Python
        val python_roots = self.find_python_projects()
        for root in python_roots:
            configs.append(LanguageConfig.new(Language.Python, root))

        # Detect JavaScript/TypeScript
        val js_roots = self.find_javascript_projects()
        for root in js_roots:
            if self.has_typescript(root):
                configs.append(LanguageConfig.new(Language.TypeScript, root))
            else:
                configs.append(LanguageConfig.new(Language.JavaScript, root))

        # Detect Go
        val go_roots = self.find_go_projects()
        for root in go_roots:
            configs.append(LanguageConfig.new(Language.Go, root))

        configs

    pub fn has_simple_project(self) -> bool:
        """Check if directory contains Simple project.

        Returns:
            True if simple.sdn or .spl files exist
        """
        self.file_exists("simple.sdn") or self.has_files_with_extension(".spl")

    pub fn find_cargo_projects(self) -> List<text>:
        """Find all Rust/Cargo projects.

        Returns:
            List of directories containing Cargo.toml
        """
        self.find_files_named("Cargo.toml")

    pub fn find_python_projects(self) -> List<text>:
        """Find all Python projects.

        Returns:
            List of directories containing setup.py, pyproject.toml, or requirements.txt
        """
        val roots: List<text> = []

        roots.extend(self.find_files_named("setup.py"))
        roots.extend(self.find_files_named("pyproject.toml"))
        roots.extend(self.find_files_named("requirements.txt"))

        # Deduplicate
        self.deduplicate_paths(roots)

    pub fn find_javascript_projects(self) -> List<text>:
        """Find all JavaScript/Node projects.

        Returns:
            List of directories containing package.json
        """
        self.find_files_named("package.json")

    pub fn find_go_projects(self) -> List<text>:
        """Find all Go projects.

        Returns:
            List of directories containing go.mod
        """
        self.find_files_named("go.mod")

    pub fn has_typescript(self, root: text) -> bool:
        """Check if project uses TypeScript.

        Args:
            root: Project root to check

        Returns:
            True if tsconfig.json exists
        """
        self.file_exists_in(root, "tsconfig.json")

    # Helper methods - File system operations

    fn file_exists(name: text) -> bool:
        """Check if file exists in project root."""
        val path = self.root + "/" + name
        fs.exists_sync(path as FilePath)

    fn file_exists_in(dir: text, name: text) -> bool:
        """Check if file exists in directory."""
        val path = dir + "/" + name
        fs.exists_sync(path as FilePath)

    fn has_files_with_extension(ext: text) -> bool:
        """Check if any files with extension exist."""
        # Recursively search for files with extension
        self.scan_for_extension(self.root, ext)

    fn scan_for_extension(dir: text, ext: text) -> bool:
        """Recursively scan directory for files with extension."""
        match fs.read_dir(dir as DirPath):
            Ok(entries):
                for entry in entries:
                    val name = entry.name() as text

                    # Check if file has the extension
                    if name.ends_with(ext):
                        return true

                    # Recursively search subdirectories
                    if entry.file_type() == FileType.Directory:
                        val subdir_path = entry.path() as text
                        if self.scan_for_extension(subdir_path, ext):
                            return true

                false
            Err(_):
                false

    fn find_files_named(name: text) -> List<text>:
        """Find all files with given name recursively."""
        val results: List<text> = []
        self.find_files_named_recursive(self.root, name, results)
        results

    fn find_files_named_recursive(dir: text,
        name: text,
        results: List<text>
    ):
        """Recursively find files with given name."""
        match fs.read_dir(dir as DirPath):
            Ok(entries):
                for entry in entries:
                    val entry_name = entry.name() as text

                    # If this is the file we're looking for, extract its directory
                    if entry_name == name:
                        val file_path = entry.path() as text
                        # Get the directory containing this file
                        val dir_path = self.get_parent_dir(file_path)
                        results.append(dir_path)

                    # Recursively search subdirectories
                    if entry.file_type() == FileType.Directory:
                        val subdir = entry.path() as text
                        # Skip common exclude patterns
                        if not self.should_skip_dir(entry_name):
                            self.find_files_named_recursive(subdir, name, results)
            Err(_):
                # Ignore errors (permission denied, etc.)
                pass

    fn should_skip_dir(name: text) -> bool:
        """Check if directory should be skipped."""
        name == "node_modules" or name == "target" or name == "__pycache__" or name == ".git" or name == ".venv" or name == "venv" or name.starts_with(".")

    fn get_parent_dir(path: text) -> text:
        """Get parent directory from path."""
        # Find last slash
        val last_slash = path.rfind("/")
        if last_slash >= 0:
            path[0:last_slash]
        else:
            "."

    fn deduplicate_paths(paths: List<text>) -> List<text>:
        """Remove duplicate paths."""
        val unique: List<text> = []
        for path in paths:
            if not self.contains_path(unique, path):
                unique.append(path)
        unique

    fn contains_path(paths: List<text>, target: text) -> bool:
        """Check if path is in list."""
        for path in paths:
            if path == target:
                return true
        false

# Project context - unified view of multi-language project
pub class ProjectContext:
    pub config: ProjectConfig
    pub languages: List<LanguageConfig>

    pub fn new(root: text) -> ProjectContext:
        """Create project context.

        Args:
            root: Project root directory

        Returns:
            Project context with auto-detected languages

        Example:
            val project = ProjectContext.new(".")
            for lang_config in project.languages:
                print("Language: {lang_config.language}")
                print("Root: {lang_config.root}")
        """
        val detector = ProjectDetector.new(root)
        val languages = detector.detect_all_languages()

        val config = ProjectConfig.new(root)
        for lang_config in languages:
            config.add_language(lang_config)

        ProjectContext {
            config: config,
            languages: languages
        }

    pub fn from_config_file(path: text) -> Result<ProjectContext, text>:
        """Load project from simple.sdn.

        Args:
            path: Path to simple.sdn config file

        Returns:
            Project context or error
        """
        match ProjectConfig.load_from_file(path):
            Ok(config):
                Ok(ProjectContext {
                    config: config,
                    languages: config.languages
                })
            Err(err):
                Err(err)

    pub fn get_build_dir(self) -> text:
        """Get build output directory.

        Returns:
            Build directory path
        """
        self.config.build_dir

    pub fn get_test_dir(self) -> text:
        """Get test directory.

        Returns:
            Test directory path
        """
        self.config.test_dir

    pub fn get_language_roots(self) -> Dict<Language, text>:
        """Get map of languages to their root directories.

        Returns:
            Dictionary mapping languages to roots
        """
        val roots: Dict<Language, text> = {}
        for lang_config in self.languages:
            roots[lang_config.language] = lang_config.root
        roots

    pub fn has_language(self, language: Language) -> bool:
        """Check if project uses given language.

        Args:
            language: Language to check

        Returns:
            True if language is used in project
        """
        for lang_config in self.languages:
            if lang_config.language == language:
                return true
        false

    pub fn get_all_source_files(self, language: Language) -> List<text>:
        """Get all source files for given language.

        Args:
            language: Language to get files for

        Returns:
            List of source file paths
        """
        # Get language configuration
        match self.config.get_language_config(language):
            some(lang_config):
                val files: List<text> = []
                # Scan each source directory
                for src_dir in lang_config.source_dirs:
                    val full_path = lang_config.root + "/" + src_dir
                    val ext = self.get_extension_for_language(language)
                    self.collect_files_with_extension(full_path, ext, lang_config.exclude_patterns, files)
                files
            none:
                []

    fn get_extension_for_language(language: Language) -> text:
        """Get file extension for language."""
        match language:
            Language.Simple: ".spl"
            Language.Rust: ".rs"
            Language.Python: ".py"
            Language.JavaScript: ".js"
            Language.TypeScript: ".ts"
            Language.Go: ".go"
            Language.C: ".c"
            Language.Cpp: ".cpp"

    fn collect_files_with_extension(dir: text,
        ext: text,
        exclude_patterns: List<text>,
        results: List<text>
    ):
        """Recursively collect files with given extension."""
        match fs.read_dir(dir as DirPath):
            Ok(entries):
                for entry in entries:
                    val name = entry.name() as text
                    val path = entry.path() as text

                    # Skip excluded directories
                    if self.is_excluded(name, exclude_patterns):
                        continue

                    match entry.file_type():
                        FileType.File:
                            # Add file if it matches extension
                            if name.ends_with(ext):
                                results.append(path)
                        FileType.Directory:
                            # Recursively scan subdirectories
                            self.collect_files_with_extension(path, ext, exclude_patterns, results)
                        _:
                            # Skip symlinks and other types
                            pass
            Err(_):
                # Ignore errors
                pass

    fn is_excluded(name: text, patterns: List<text>) -> bool:
        """Check if name matches any exclusion pattern."""
        for pattern in patterns:
            if name == pattern or name.starts_with(pattern):
                return true
        false
