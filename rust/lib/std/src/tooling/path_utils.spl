# Path utilities for Simple
# Pure string-based path manipulation (no filesystem access needed)

# Extract filename from path
fn get_filename(path: text) -> text:
    if path.is_empty():
        return ""

    # Handle Windows and Unix paths
    val unix_parts = path.split("/")
    val win_parts = path.split("\\")

    # Use whichever split produced more parts
    val parts = if unix_parts.len() >= win_parts.len():
        unix_parts
    else:
        win_parts

    if parts.len() > 0:
        parts[parts.len() - 1]
    else:
        path

# Extract directory name from path (last component of directory)
fn get_dir_name(path: text) -> text:
    val normalized = path.trim_end("/").trim_end("\\")
    get_filename(normalized)

# Get parent directory path
fn get_parent_dir(path: text) -> text:
    if path.is_empty():
        return ""

    val normalized = path.trim_end("/").trim_end("\\")
    val parts = normalized.split("/")

    if parts.len() <= 1:
        # Try Windows-style path
        val win_parts = normalized.split("\\")
        if win_parts.len() <= 1:
            return ""
        return win_parts[0..win_parts.len()-1].join("\\")

    parts[0..parts.len()-1].join("/")

# Get parent directory as Option
fn get_parent_dir_option(path: text) -> Option<text>:
    val parent = get_parent_dir(path)
    if parent.len() > 0:
        Some(parent)
    else:
        None

# Join path components
fn join_path(dir: text, file: text) -> text:
    if dir.is_empty():
        return file
    if file.is_empty():
        return dir

    # Determine separator based on existing path
    val separator = if dir.contains("\\"):
        "\\"
    else:
        "/"

    val trimmed_dir = dir.trim_end("/").trim_end("\\")
    val trimmed_file = file.trim_start("/").trim_start("\\")

    "{trimmed_dir}{separator}{trimmed_file}"

# Get file extension (without dot)
fn get_extension(path: text) -> text:
    val filename = get_filename(path)
    val parts = filename.split(".")

    if parts.len() > 1:
        parts[parts.len() - 1]
    else:
        ""

# Get file stem (filename without extension)
fn get_stem(path: text) -> text:
    val filename = get_filename(path)
    val parts = filename.split(".")

    if parts.len() > 1:
        parts[0..parts.len()-1].join(".")
    else:
        filename

# Check if path has a specific extension
fn has_extension(path: text, ext: text) -> bool:
    val actual_ext = get_extension(path)
    val clean_ext = ext.trim_start(".")
    actual_ext.lower() == clean_ext.lower()

# Normalize path separators to Unix style
fn normalize_path(path: text) -> text:
    path.replace("\\", "/")

# Check if path is absolute
fn is_absolute_path(path: text) -> bool:
    if path.is_empty():
        return false

    # Unix absolute path
    if path.starts_with("/"):
        return true

    # Windows absolute path (C:\ or C:/)
    if path.len() >= 3:
        val first = path.chars()[0]
        val second = path.chars()[1]
        val third = path.chars()[2]
        if first.is_alphabetic() and second == ":" and (third == "\\" or third == "/"):
            return true

    false

# Make path relative by removing common prefix
fn make_relative(path: text, base: text) -> text:
    val norm_path = normalize_path(path)
    val norm_base = normalize_path(base).trim_end("/")

    if norm_path.starts_with(norm_base):
        val relative = norm_path.substring(norm_base.len(), norm_path.len())
        relative.trim_start("/")
    else:
        path

# Split path into components
fn split_path(path: text) -> List<text>:
    val normalized = normalize_path(path)
    normalized.split("/").filter(\p: p.len() > 0)
