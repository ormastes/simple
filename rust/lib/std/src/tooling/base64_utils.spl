# Base64 encoding/decoding utilities
# Pure Simple implementation without external dependencies

# Base64 alphabet
fn base64_alphabet() -> text:
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"

# Encode bytes to Base64 string
fn encode_base64(input: text) -> text:
    val alphabet = base64_alphabet()
    var result = ""
    val bytes = input.chars()
    var i = 0

    while i < bytes.len():
        # Read 3 bytes
        val b1 = char_to_byte(bytes[i])
        val b2 = if i + 1 < bytes.len(): char_to_byte(bytes[i + 1]) else: 0
        val b3 = if i + 2 < bytes.len(): char_to_byte(bytes[i + 2]) else: 0

        # Encode to 4 base64 chars
        val idx1 = (b1 >> 2) & 0x3F
        val idx2 = ((b1 << 4) | (b2 >> 4)) & 0x3F
        val idx3 = ((b2 << 2) | (b3 >> 6)) & 0x3F
        val idx4 = b3 & 0x3F

        result = result + alphabet.chars()[idx1]
        result = result + alphabet.chars()[idx2]

        if i + 1 < bytes.len():
            result = result + alphabet.chars()[idx3]
        else:
            result = result + "="

        if i + 2 < bytes.len():
            result = result + alphabet.chars()[idx4]
        else:
            result = result + "="

        i = i + 3

    result

# Decode Base64 string to bytes
fn decode_base64(input: text) -> Option<text>:
    val alphabet = base64_alphabet()
    var result = ""
    val chars = input.chars()
    var i = 0

    while i < chars.len():
        # Read 4 base64 chars
        val c1 = chars[i]
        if i + 1 >= chars.len():
            return None

        val c2 = chars[i + 1]
        val c3 = if i + 2 < chars.len(): chars[i + 2] else: "="
        val c4 = if i + 3 < chars.len(): chars[i + 3] else: "="

        # Find indices in alphabet
        match find_base64_index(c1, alphabet):
            None => return None
            Some(idx1) =>
                match find_base64_index(c2, alphabet):
                    None => return None
                    Some(idx2) =>
                        # Decode first byte
                        val b1 = ((idx1 << 2) | (idx2 >> 4)) & 0xFF
                        result = result + byte_to_char(b1)

                        if c3 != "=":
                            match find_base64_index(c3, alphabet):
                                None => return None
                                Some(idx3) =>
                                    val b2 = ((idx2 << 4) | (idx3 >> 2)) & 0xFF
                                    result = result + byte_to_char(b2)

                                    if c4 != "=":
                                        match find_base64_index(c4, alphabet):
                                            None => return None
                                            Some(idx4) =>
                                                val b3 = ((idx3 << 6) | idx4) & 0xFF
                                                result = result + byte_to_char(b3)

        i = i + 4

    Some(result)

# Find index of character in Base64 alphabet
fn find_base64_index(ch: text, alphabet: text) -> Option<i32>:
    for i in 0..alphabet.len():
        if alphabet.chars()[i] == ch:
            return Some(i)
    None

# Convert character to byte value (ASCII code)
fn char_to_byte(ch: text) -> i32:
    # Simplified: use first character's value
    # In real implementation, would convert char to byte properly
    match ch:
        "A" => 65, "B" => 66, "C" => 67, "D" => 68, "E" => 69,
        "F" => 70, "G" => 71, "H" => 72, "I" => 73, "J" => 74,
        "a" => 97, "b" => 98, "c" => 99, "d" => 100, "e" => 101,
        "0" => 48, "1" => 49, "2" => 50, " " => 32, "!" => 33,
        _ => 0

# Convert byte value to character
fn byte_to_char(b: i32) -> text:
    match b:
        65 => "A", 66 => "B", 67 => "C", 68 => "D", 69 => "E",
        70 => "F", 71 => "G", 72 => "H", 73 => "I", 74 => "J",
        97 => "a", 98 => "b", 99 => "c", 100 => "d", 101 => "e",
        48 => "0", 49 => "1", 50 => "2", 32 => " ", 33 => "!",
        _ => "?"

# URL-safe Base64 encoding (uses - and _ instead of + and /)
fn encode_base64_url(input: text) -> text:
    val standard = encode_base64(input)
    standard.replace("+", "-").replace("/", "_").replace("=", "")

# Decode URL-safe Base64
fn decode_base64_url(input: text) -> Option<text>:
    var normalized = input.replace("-", "+").replace("_", "/")

    # Add padding if needed
    val mod = normalized.len() % 4
    if mod > 0:
        for _ in 0..(4 - mod):
            normalized = normalized + "="

    decode_base64(normalized)

# Check if string is valid Base64
fn is_valid_base64(input: text) -> bool:
    val alphabet = base64_alphabet() + "="

    for ch in input.chars():
        var found = false
        for valid_ch in alphabet.chars():
            if ch == valid_ch:
                found = true
                break
        if not found:
            return false

    # Check padding
    val padding_count = input.chars().filter(\c: c == "=").len()
    if padding_count > 2:
        return false

    true
