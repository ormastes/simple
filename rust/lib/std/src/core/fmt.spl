# Formatting - Formatting traits and utilities
#
# Provides traits for converting values to formatted strings.

# Display trait for user-facing string representation
trait Display:
    fn fmt() -> text

# Debug trait for developer-facing string representation
trait Debug:
    fn debug_fmt() -> text

# Binary formatting trait
trait Binary:
    fn binary_fmt() -> text

# Hexadecimal formatting trait
trait Hex:
    fn hex_fmt() -> text
    fn hex_upper_fmt() -> text:
        return self.hex_fmt().upper()

# Octal formatting trait
trait Octal:
    fn octal_fmt() -> text

# Format specifier
enum FormatSpec:
    Default
    Debug
    Binary
    Hex
    HexUpper
    Octal
    Precision(i32)
    Width(i32)
    LeftAlign
    RightAlign
    Center

# String builder for efficient string construction
struct StringBuilder:
    parts: List<text>

    static fn new() -> StringBuilder:
        return StringBuilder(parts: [])

    me push(self, s: text):
        self.parts.push(s)

    me push_char(self, c: char):
        self.parts.push(c.to_string())

    me push_line(self, s: text):
        self.parts.push(s)
        self.parts.push("\n")

    fn build(self) -> text:
        return self.parts.join("")

    fn len(self) -> i64:
        var total: i64 = 0
        for part in self.parts:
            total = total + part.len()
        return total

    fn is_empty(self) -> bool:
        return self.parts.len() == 0

# Formatting utilities
fn pad_left(s: text, width: i64, fill: char) -> text:
    val current_len = s.len()
    if current_len >= width:
        return s
    val padding = fill.to_string().repeat(width - current_len)
    return padding + s

fn pad_right(s: text, width: i64, fill: char) -> text:
    val current_len = s.len()
    if current_len >= width:
        return s
    val padding = fill.to_string().repeat(width - current_len)
    return s + padding

fn pad_center(s: text, width: i64, fill: char) -> text:
    val current_len = s.len()
    if current_len >= width:
        return s
    val total_padding = width - current_len
    val left_padding = total_padding / 2
    val right_padding = total_padding - left_padding
    val fill_str = fill.to_string()
    return fill_str.repeat(left_padding) + s + fill_str.repeat(right_padding)

# Integer formatting
fn format_int_binary(n: i64) -> text:
    if n == 0:
        return "0"
    var result = ""
    var value = n
    if value < 0:
        value = -value
    while value > 0:
        result = (if value % 2 == 0: "0" else: "1") + result
        value = value / 2
    if n < 0:
        result = "-" + result
    return result

fn format_int_hex(n: i64) -> text:
    if n == 0:
        return "0"
    val digits = "0123456789abcdef"
    var result = ""
    var value = n
    if value < 0:
        value = -value
    while value > 0:
        val digit = value % 16
        result = digits[digit:digit+1] + result
        value = value / 16
    if n < 0:
        result = "-" + result
    return result

fn format_int_octal(n: i64) -> text:
    if n == 0:
        return "0"
    var result = ""
    var value = n
    if value < 0:
        value = -value
    while value > 0:
        result = (value % 8).to_string() + result
        value = value / 8
    if n < 0:
        result = "-" + result
    return result

# Float formatting with precision
fn format_float(n: f64, precision: i32) -> text:
    # Simple implementation - proper formatting would use sprintf-like FFI
    val int_part = n as i64
    val frac = n - int_part as f64
    if precision <= 0:
        return int_part.to_string()
    var multiplier: f64 = 1.0
    for i in 0..precision:
        multiplier = multiplier * 10.0
    val frac_int = (frac * multiplier + 0.5) as i64
    val frac_str = frac_int.to_string().pad_left(precision, '0')
    return "{int_part}.{frac_str}"

export Display, Debug, Binary, Hex, Octal, FormatSpec, StringBuilder
export pad_left, pad_right, pad_center
export format_int_binary, format_int_hex, format_int_octal, format_float
