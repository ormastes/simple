# text Traits - Standard trait implementations
use core.traits.*
use core.collections.*

# ============================================
# Standard trait implementations
# ============================================

impl Clone for text:
    fn clone() -> Self:
        if self.len == 0:
            return text.new()
        val data = alloc[u8](self.len)
        danger:
            copy_mem(data, self.data, self.len)
        text { data: data, len: self.len, cap: self.len }

impl Default for text:
    static fn default() -> Self:
        text.new()

impl Eq for text:
    fn eq(other: &Self) -> bool:
        if self.len != other.len:
            return false
        danger:
            for i in 0..self.len:
                if self.data.offset(i as isize).read() != other.data.offset(i as isize).read():
                    return false
        true

impl Ord for text:
    fn cmp(other: &Self) -> Ordering:
        val min_len = if self.len < other.len: self.len else: other.len
        danger:
            for i in 0..min_len:
                val a = self.data.offset(i as isize).read()
                val b = other.data.offset(i as isize).read()
                if a < b:
                    return Ordering.Less
                if a > b:
                    return Ordering.Greater
        if self.len < other.len:
            Ordering.Less
        else if self.len > other.len:
            Ordering.Greater
        else:
            Ordering.Equal

impl Hash for text:
    fn hash() -> u64:
        var h: u64 = 0
        danger:
            for i in 0..self.len:
                h = h * 31 + (self.data.offset(i as isize).read() as u64)
        h

impl Display for text:
    fn fmt() -> str:
        self.as_str()

impl Drop for text:
    fn drop():
        if self.data != nil:
            danger:
                dealloc(self.data)

impl Add<&str> for text:
    type Output = text

    fn add(rhs: &str) -> Self.Output:
        var result = self.clone()
        result.push_str(rhs)
        result

impl Add<text> for text:
    type Output = text

    fn add(rhs: text) -> Self.Output:
        var result = self.clone()
        result.push_str(rhs.as_str())
        result

# ============================================
# text Character Iterator
# ============================================

struct StringCharIter:
    string: text
    byte_index: usize

impl Iterator for StringCharIter:
    type Item = char

    fn next() -> Option<Self.Item>:
        if self.byte_index >= self.string.len:
            return None
        val c = self.string.char_at_byte(self.byte_index)
        self.byte_index = self.byte_index + self.string.char_width_at(self.byte_index)
        Some(c)

impl ExactSizeIterator for StringCharIter:
    fn len() -> usize:
        # Count remaining characters
        var count: usize = 0
        var i = self.byte_index
        while i < self.string.len:
            i = i + self.string.char_width_at(i)
            count = count + 1
        count

