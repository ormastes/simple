# ============================================================================
# Regex Library - Parser and AST
# ============================================================================
#
# Regular expression parser and abstract syntax tree (AST) representation.
#
# Contains:
# - AST node types (RegexNode subclasses)
# - NFA (Non-deterministic Finite Automaton) structures
# - RegexParser for converting pattern strings to AST
#
# ============================================================================

class RegexNode:
    """Base class for regex AST nodes."""
    node_type: text  # For debugging

class LiteralNode(RegexNode):
    char: text  # Single character

    fn new(c: text) -> LiteralNode:
        return LiteralNode { char: c, node_type: "literal" }

class CharClassNode(RegexNode):
    chars: List<text>   # Individual characters
    ranges: List<(text, text)>  # Character ranges like a-z
    negated: bool         # True for [^...]

    static fn new() -> CharClassNode:
        return CharClassNode { chars: [], ranges: [], negated: false, node_type: "charclass" }

    fn matches(c: text) -> bool:
        var found = false

        # Check individual characters
        for ch in self.chars:
            if ch == c:
                found = true
                break

        # Check ranges
        if not found:
            for range in self.ranges:
                val start = range[0]
                val end = range[1]
                if c >= start and c <= end:
                    found = true
                    break

        return if self.negated: not found else: found

class ConcatNode(RegexNode):
    left: RegexNode
    right: RegexNode

    fn new(l: RegexNode, r: RegexNode) -> ConcatNode:
        return ConcatNode { left: l, right: r, node_type: "concat" }

class AltNode(RegexNode):
    left: RegexNode
    right: RegexNode

    fn new(l: RegexNode, r: RegexNode) -> AltNode:
        return AltNode { left: l, right: r, node_type: "alt" }

class StarNode(RegexNode):
    child: RegexNode
    greedy: bool

    fn new(c: RegexNode, g: bool = true) -> StarNode:
        return StarNode { child: c, greedy: g, node_type: "star" }

class PlusNode(RegexNode):
    child: RegexNode
    greedy: bool

    fn new(c: RegexNode, g: bool = true) -> PlusNode:
        return PlusNode { child: c, greedy: g, node_type: "plus" }

class QuestionNode(RegexNode):
    child: RegexNode
    greedy: bool

    fn new(c: RegexNode, g: bool = true) -> QuestionNode:
        return QuestionNode { child: c, greedy: g, node_type: "question" }

class QuantNode(RegexNode):
    child: RegexNode
    min: i32
    max: i32  # -1 for infinity
    greedy: bool

    fn new(c: RegexNode, min_v: i32, max_v: i32, g: bool = true) -> QuantNode:
        return QuantNode { child: c, min: min_v, max: max_v, greedy: g, node_type: "quant" }

class GroupNode(RegexNode):
    child: RegexNode
    group_id: i32  # Capture group number

    fn new(c: RegexNode, gid: i32) -> GroupNode:
        return GroupNode { child: c, group_id: gid, node_type: "group" }

class AnchorNode(RegexNode):
    anchor_type: text  # "start" or "end" or "word_boundary"

    fn new(t: text) -> AnchorNode:
        return AnchorNode { anchor_type: t, node_type: "anchor" }

# NFA State
class NFAState:
    state_id: i32
    transitions: List<(text, i32)>  # (char, target_state_id)
    epsilon_transitions: List<i32>    # epsilon transitions (no input consumed)
    is_accept: bool
    group_start: i32  # -1 if not a group start, else group id
    group_end: i32    # -1 if not a group end, else group id

    fn new(sid: i32) -> NFAState:
        return NFAState {
            state_id: sid,
            transitions: [],
            epsilon_transitions: [],
            is_accept: false,
            group_start: -1,
            group_end: -1
        }

    fn add_transition(char: text, target: i32) -> NFAState:
        var new_transitions = self.transitions
        new_transitions.append((char, target))
        return NFAState {
            state_id: self.state_id,
            transitions: new_transitions,
            epsilon_transitions: self.epsilon_transitions,
            is_accept: self.is_accept,
            group_start: self.group_start,
            group_end: self.group_end
        }

    fn add_epsilon(target: i32) -> NFAState:
        var new_eps = self.epsilon_transitions
        new_eps.append(target)
        return NFAState {
            state_id: self.state_id,
            transitions: self.transitions,
            epsilon_transitions: new_eps,
            is_accept: self.is_accept,
            group_start: self.group_start,
            group_end: self.group_end
        }

# NFA Fragment (used during construction)
class NFAFragment:
    start: i32      # Start state ID
    end: i32        # End state ID (dangling, needs to be connected)

    fn new(s: i32, e: i32) -> NFAFragment:
        return NFAFragment { start: s, end: e }

# Complete NFA
class NFA:
    states: List<NFAState>
    start_state: i32
    num_groups: i32
    char_classes: List<CharClassNode>  # Store character classes for matching

    static fn new() -> NFA:
        return NFA { states: [], start_state: 0, num_groups: 0, char_classes: [] }

    fn add_state() -> (NFA, i32):
        val sid = self.states.len()
        var new_states = self.states
        new_states.append(NFAState.new(sid))
        val new_nfa = NFA { states: new_states, start_state: self.start_state, num_groups: self.num_groups, char_classes: self.char_classes }
        return (new_nfa, sid)

    fn get_state(sid: i32) -> NFAState:
        return self.states[sid]

    fn update_state(sid: i32, new_state: NFAState) -> NFA:
        var new_states = []
        for i in range(0, self.states.len()):
            if i == sid:
                new_states.append(new_state)
            else:
                new_states.append(self.states[i])
        return NFA { states: new_states, start_state: self.start_state, num_groups: self.num_groups, char_classes: self.char_classes }

    fn set_accept(sid: i32) -> NFA:
        var state = self.states[sid]
        val new_state = NFAState {
            state_id: state.state_id,
            transitions: state.transitions,
            epsilon_transitions: state.epsilon_transitions,
            is_accept: true,
            group_start: state.group_start,
            group_end: state.group_end
        }
        return self.update_state(sid, new_state)

    fn set_group_start(sid: i32, group_id: i32) -> NFA:
        var state = self.states[sid]
        val new_state = NFAState {
            state_id: state.state_id,
            transitions: state.transitions,
            epsilon_transitions: state.epsilon_transitions,
            is_accept: state.is_accept,
            group_start: group_id,
            group_end: state.group_end
        }
        return self.update_state(sid, new_state)

    fn set_group_end(sid: i32, group_id: i32) -> NFA:
        var state = self.states[sid]
        val new_state = NFAState {
            state_id: state.state_id,
            transitions: state.transitions,
            epsilon_transitions: state.epsilon_transitions,
            is_accept: state.is_accept,
            group_start: state.group_start,
            group_end: group_id
        }
        return self.update_state(sid, new_state)

    fn set_num_groups(ng: i32) -> NFA:
        return NFA { states: self.states, start_state: self.start_state, num_groups: ng, char_classes: self.char_classes }

    fn add_char_class(cc: CharClassNode) -> (NFA, i32):
        """Add a character class and return updated NFA with the class index."""
        val idx = self.char_classes.len()
        var new_classes = self.char_classes
        new_classes.append(cc)
        val new_nfa = NFA { states: self.states, start_state: self.start_state, num_groups: self.num_groups, char_classes: new_classes }
        return (new_nfa, idx)

    fn add_transition_to(sid: i32, char: text, target: i32) -> NFA:
        val state = self.states[sid]
        val new_state = state.add_transition(char, target)
        return self.update_state(sid, new_state)

    fn add_epsilon_to(sid: i32, target: i32) -> NFA:
        val state = self.states[sid]
        val new_state = state.add_epsilon(target)
        return self.update_state(sid, new_state)

# Regex Parser - redesigned for pass-by-value semantics
class RegexParser:
    pattern: text

    fn new(p: text) -> RegexParser:
        return RegexParser { pattern: p }

    fn peek_at(pos: i32) -> Option<text>:
        if pos >= self.pattern.len():
            return nil
        return Some(self.pattern[pos])

    fn advance_from(pos: i32) -> (Option<text>, i32):
        val c = self.peek_at(pos)
        if c!= nil:
            return (c, pos + 1)
        return (nil, pos)

    fn parse() -> RegexNode:
        val (node, _final_pos, _group_count) = self.parse_alternation(0, 0)
        return node

    fn parse_alternation(pos: i32, group_count: i32) -> (RegexNode, i32, i32):
        val (mut left, mut current_pos, mut gc) = self.parse_concat(pos, group_count)

        while self.peek_at(current_pos) == Some("|"):
            current_pos = current_pos + 1  # consume |
            val (right, new_pos, new_gc) = self.parse_concat(current_pos, gc)
            left = AltNode.new(left, right)
            current_pos = new_pos
            gc = new_gc

        return (left, current_pos, gc)

    fn parse_concat(pos: i32, group_count: i32) -> (RegexNode, i32, i32):
        var nodes = []
        var current_pos = pos
        var gc = group_count

        while true:
            val c = self.peek_at(current_pos)
            if c== nil or c == Some("|") or c == Some(")"):
                break

            val (node, new_pos, new_gc) = self.parse_quantified(current_pos, gc)
            nodes.append(node)
            current_pos = new_pos
            gc = new_gc

        if nodes.len() == 0:
            # Empty pattern - match empty string
            return (LiteralNode.new(""), current_pos, gc)

        if nodes.len() == 1:
            return (nodes[0], current_pos, gc)

        # Build concatenation tree (left-associative)
        var result = nodes[0]
        for i in range(1, nodes.len()):
            result = ConcatNode.new(result, nodes[i])

        return (result, current_pos, gc)

    fn parse_quantified(pos: i32, group_count: i32) -> (RegexNode, i32, i32):
        val (mut node, mut current_pos, mut gc) = self.parse_atom(pos, group_count)

        # Check for quantifiers
        val c = self.peek_at(current_pos)
        if c == Some("*"):
            current_pos = current_pos + 1
            val greedy = self.peek_at(current_pos) != Some("?")
            if not greedy:
                current_pos = current_pos + 1
            node = StarNode.new(node, greedy)
        elif c == Some("+"):
            current_pos = current_pos + 1
            val greedy = self.peek_at(current_pos) != Some("?")
            if not greedy:
                current_pos = current_pos + 1
            node = PlusNode.new(node, greedy)
        elif c == Some("?"):
            current_pos = current_pos + 1
            val greedy = self.peek_at(current_pos) != Some("?")
            if not greedy:
                current_pos = current_pos + 1
            node = QuestionNode.new(node, greedy)
        elif c == Some("{{"):
            # Quantifier {n,m}
            current_pos = current_pos + 1
            val (min_v, max_v, new_pos) = self.parse_quantifier_range(current_pos)
            current_pos = new_pos
            val greedy = self.peek_at(current_pos) != Some("?")
            if not greedy:
                current_pos = current_pos + 1
            node = QuantNode.new(node, min_v, max_v, greedy)

        return (node, current_pos, gc)

    fn parse_quantifier_range(pos: i32) -> (i32, i32, i32):
        # Parse {n}, {n,}, or {n,m}
        var num_str = ""
        var current_pos = pos

        while self.peek_at(current_pos) != Some(",") and self.peek_at(current_pos) != Some("}}"):
            val (ch, new_pos) = self.advance_from(current_pos)
            num_str = num_str + ch.unwrap()
            current_pos = new_pos

        val min_v = num_str.to_int()

        if self.peek_at(current_pos) == Some(","):
            current_pos = current_pos + 1  # consume ,

            if self.peek_at(current_pos) == Some("}}"):
                # {n,} - n or more
                current_pos = current_pos + 1  # consume }
                return (min_v, -1, current_pos)

            num_str = ""
            while self.peek_at(current_pos) != Some("}}"):
                val (ch, new_pos) = self.advance_from(current_pos)
                num_str = num_str + ch.unwrap()
                current_pos = new_pos

            current_pos = current_pos + 1  # consume }
            return (min_v, num_str.to_int(), current_pos)

        current_pos = current_pos + 1  # consume }
        return (min_v, min_v, current_pos)  # {n} - exactly n

    fn parse_atom(pos: i32, group_count: i32) -> (RegexNode, i32, i32):
        val c = self.peek_at(pos)

        if c== nil:
            # Empty - shouldn't happen in well-formed regex
            return (LiteralNode.new(""), pos, group_count)

        val ch = c.unwrap()
        var current_pos = pos
        var gc = group_count

        # Anchors
        if ch == "^":
            current_pos = current_pos + 1
            return (AnchorNode.new("start"), current_pos, gc)

        if ch == "$":
            current_pos = current_pos + 1
            return (AnchorNode.new("end"), current_pos, gc)

        # Groups
        if ch == "(":
            current_pos = current_pos + 1

            # Check for non-capturing group
            if self.peek_at(current_pos) == Some("?") and self.peek_at(current_pos + 1) == Some(":"):
                current_pos = current_pos + 2  # skip ?:
                val (child, new_pos, new_gc) = self.parse_alternation(current_pos, gc)
                current_pos = new_pos
                if self.peek_at(current_pos) == Some(")"):
                    current_pos = current_pos + 1
                return (child, current_pos, new_gc)  # Non-capturing group

            # Capturing group
            gc = gc + 1
            val gid = gc
            val (child, new_pos, new_gc) = self.parse_alternation(current_pos, gc)
            current_pos = new_pos
            gc = new_gc
            if self.peek_at(current_pos) == Some(")"):
                current_pos = current_pos + 1
            return (GroupNode.new(child, gid), current_pos, gc)

        # Character classes
        if ch == "[":
            val (cc, new_pos) = self.parse_char_class(current_pos)
            return (cc, new_pos, gc)

        # Escaped characters
        if ch == "\\":
            current_pos = current_pos + 1
            val (node, new_pos) = self.parse_escape(current_pos)
            return (node, new_pos, gc)

        # Wildcard
        if ch == ".":
            current_pos = current_pos + 1
            # Match any character except newline
            val cc = CharClassNode.new()
            cc.negated = true
            cc.chars.append("\n")
            return (cc, current_pos, gc)

        # Literal character
        current_pos = current_pos + 1
        return (LiteralNode.new(ch), current_pos, gc)

    fn parse_char_class(pos: i32) -> (CharClassNode, i32):
        var current_pos = pos + 1  # consume [
        val cc = CharClassNode.new()

        # Check for negation
        if self.peek_at(current_pos) == Some("^"):
            current_pos = current_pos + 1
            cc.negated = true

        while self.peek_at(current_pos) != Some("]") and self.peek_at(current_pos)!= nil:
            val (c_opt, new_pos) = self.advance_from(current_pos)
            val c = c_opt.unwrap()
            current_pos = new_pos

            # Check for range
            if self.peek_at(current_pos) == Some("-") and self.peek_at(current_pos + 1) != Some("]"):
                current_pos = current_pos + 1  # consume -
                val (end_char_opt, new_pos2) = self.advance_from(current_pos)
                val end_char = end_char_opt.unwrap()
                current_pos = new_pos2
                cc.ranges.append((c, end_char))
            else:
                cc.chars.append(c)

        if self.peek_at(current_pos) == Some("]"):
            current_pos = current_pos + 1  # consume ]

        return (cc, current_pos)

    fn parse_escape(pos: i32) -> (RegexNode, i32):
        val (c, new_pos) = self.advance_from(pos)

        if c== nil:
            return (LiteralNode.new("\\"), pos)

        val ch = c.unwrap()

        # Predefined character classes
        if ch == "d":
            # Digits [0-9]
            val cc = CharClassNode.new()
            cc.ranges.append(("0", "9"))
            return (cc, new_pos)

        if ch == "D":
            # Non-digits
            val cc = CharClassNode.new()
            cc.ranges.append(("0", "9"))
            cc.negated = true
            return (cc, new_pos)

        if ch == "w":
            # Word characters [a-zA-Z0-9_]
            val cc = CharClassNode.new()
            cc.ranges.append(("a", "z"))
            cc.ranges.append(("A", "Z"))
            cc.ranges.append(("0", "9"))
            cc.chars.append("_")
            return (cc, new_pos)

        if ch == "W":
            # Non-word characters
            val cc = CharClassNode.new()
            cc.ranges.append(("a", "z"))
            cc.ranges.append(("A", "Z"))
            cc.ranges.append(("0", "9"))
            cc.chars.append("_")
            cc.negated = true
            return (cc, new_pos)

        if ch == "s":
            # Whitespace
            val cc = CharClassNode.new()
            cc.chars.append(" ")
            cc.chars.append("\t")
            cc.chars.append("\n")
            cc.chars.append("\r")
            return (cc, new_pos)

        if ch == "S":
            # Non-whitespace
            val cc = CharClassNode.new()
            cc.chars.append(" ")
            cc.chars.append("\t")
            cc.chars.append("\n")
            cc.chars.append("\r")
            cc.negated = true
            return (cc, new_pos)

        if ch == "b":
            # Word boundary
            return (AnchorNode.new("word_boundary"), new_pos)

        if ch == "B":
            # Non-word boundary
            return (AnchorNode.new("non_word_boundary"), new_pos)

        if ch == "n":
            return (LiteralNode.new("\n"), new_pos)

        if ch == "t":
            return (LiteralNode.new("\t"), new_pos)

        if ch == "r":
            return (LiteralNode.new("\r"), new_pos)

        # Escaped special character - treat as literal
        return (LiteralNode.new(ch), new_pos)

# NFA Builder using Thompson's construction

# ============================================================================
# Exports
# ============================================================================

export RegexNode, LiteralNode, CharClassNode, ConcatNode, AltNode
export StarNode, PlusNode, QuestionNode, QuantNode, GroupNode, AnchorNode
export NFAState, NFAFragment, NFA
export RegexParser
