# DSL Features Module
# Provides DSL building blocks for domain-specific languages
#
# Features:
# - #1066: context blocks
# - #1067: method_missing handler
# - #1068: Fluent interface support

# Context Block Support (#1066)
#
# Context blocks allow temporarily changing the receiver for method calls
# Syntax: context obj: ...

struct ContextBuilder:
    """
    Helper for building objects with context blocks.

    Example:
        builder = ContextBuilder()
        context builder:
            set_name("Alice")
            set_age(30)
            add_tag("developer")
        # All methods called on builder
    """

    fn __init__(self):
        self.data = {}

    fn set(self, key, value):
        self.data[key] = value
        return self  # Fluent interface

    fn get(self, key):
        return self.data.get(key)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn has(self, key) -> bool:
        """Check if key exists.

        Args:
            key: Key to check

        Returns:
            true if key exists

        Example:
            builder.set("name", "Alice")
            builder.has("name")  # → true
        """
        return key in self.data

    fn is_empty(self) -> bool:
        """Check if no data stored.

        Returns:
            true if data is empty

        Example:
            builder = ContextBuilder()
            builder.is_empty()  # → true
        """
        return len(self.data) == 0

    fn size(self) -> i32:
        """Get number of entries.

        Returns:
            Entry count

        Example:
            builder.set("a", 1).set("b", 2)
            builder.size()  # → 2
        """
        return len(self.data)

    fn clear(self):
        """Clear all data.

        Returns:
            self for chaining

        Example:
            builder.clear()
        """
        self.data = {}
        return self

    fn keys(self) -> list:
        """Get all keys.

        Returns:
            List of keys

        Example:
            builder.keys()  # → ["name", "age"]
        """
        return list(self.data.keys())

    fn values(self) -> list:
        """Get all values.

        Returns:
            List of values

        Example:
            builder.values()  # → ["Alice", 30]
        """
        return list(self.data.values())


# Method Missing Handler (#1067)
#
# Allows objects to handle undefined method calls dynamically

trait MethodMissing:
    """
    Trait for handling missing methods dynamically.

    Implementers can intercept calls to undefined methods.

    Example:
        class DynamicObject:
            fn method_missing(name, args):
                print("Called {name} with {args}")
                return nil

        obj = DynamicObject()
        obj.unknown_method(1, 2, 3)
        # Prints: Called unknown_method with (1, 2, 3)
    """

    fn method_missing(method_name: str, args):
        """
        Handle a call to an undefined method.

        Args:
            method_name: Name of the missing method
            args: Arguments passed to the method

        Returns:
            The value to return from the method call
        """
        pass


struct DynamicProxy:
    """
    Proxy that delegates all method calls to a handler.

    Example:
        def handler(name, args):
            print("Method {name} called")
            return 42

        proxy = DynamicProxy(handler)
        result = proxy.anything(1, 2, 3)
        # Prints: Method anything called
        # Returns: 42
    """

    fn __init__(self, handler):
        self.handler = handler

    fn method_missing(self, name, args):
        return self.handler(name, args)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn has_handler(self) -> bool:
        """Check if handler is set.

        Returns:
            true if handler exists

        Example:
            proxy.has_handler()  # → true
        """
        return self.handler is not nil

    fn set_handler(self, handler):
        """Set new handler function.

        Args:
            handler: Handler function

        Returns:
            self for chaining

        Example:
            proxy.set_handler(lambda name, args: 42)
        """
        self.handler = handler
        return self

    fn call_handler(self, name, args):
        """Explicitly call handler.

        Args:
            name: Method name
            args: Arguments

        Returns:
            Handler result

        Example:
            proxy.call_handler("test", [1, 2])
        """
        return self.handler(name, args)


struct AttributeDict:
    """
    Dictionary that allows attribute-style access.

    Example:
        obj = AttributeDict()
        obj.name = "Alice"
        obj.age = 30
        print(obj.name)  # "Alice"
    """

    fn __init__(self):
        self.data = {}

    fn __getattr__(self, name):
        return self.data.get(name)

    fn __setattr__(self, name, value):
        if name == "data":
            # Special case for internal data storage
            self.data = value
        else:
            self.data[name] = value

    fn method_missing(self, name, args):
        # Allow method calls to be stored as well
        self.data[name] = args
        return self

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn has_attr(self, name) -> bool:
        """Check if attribute exists.

        Args:
            name: Attribute name

        Returns:
            true if attribute exists

        Example:
            obj.name = "Alice"
            obj.has_attr("name")  # → true
        """
        return name in self.data

    fn get_attr(self, name, default=nil):
        """Get attribute with default.

        Args:
            name: Attribute name
            default: Default value if not found

        Returns:
            Attribute value or default

        Example:
            obj.get_attr("missing", "default")  # → "default"
        """
        return self.data.get(name, default)

    fn del_attr(self, name):
        """Delete attribute.

        Args:
            name: Attribute name

        Returns:
            self for chaining

        Example:
            obj.del_attr("name")
        """
        if name in self.data:
            del self.data[name]
        return self

    fn attr_count(self) -> i32:
        """Get number of attributes.

        Returns:
            Attribute count

        Example:
            obj.attr_count()  # → 3
        """
        return len(self.data)

    fn attr_names(self) -> list:
        """Get all attribute names.

        Returns:
            List of attribute names

        Example:
            obj.attr_names()  # → ["name", "age"]
        """
        return list(self.data.keys())

    fn clear_attrs(self):
        """Clear all attributes.

        Returns:
            self for chaining

        Example:
            obj.clear_attrs()
        """
        self.data = {}
        return self


# Fluent Interface Support (#1068)
#
# Patterns for building fluent/chainable APIs

struct FluentBuilder:
    """
    Base class for fluent/builder pattern.

    Methods return self to enable chaining.

    Example:
        class PersonBuilder(FluentBuilder):
            fn with_name(name):
                self.name = name
                return self

            fn with_age(age):
                self.age = age
                return self

            fn build():
                return Person(self.name, self.age)

        person = PersonBuilder()
            .with_name("Alice")
            .with_age(30)
            .build()
    """

    fn __init__():
        pass


struct QueryBuilder:
    """
    Example of fluent interface for building queries.

    Example:
        query = QueryBuilder()
            .select("name", "age")
            .from_table("users")
            .where_filter("age > 18")
            .order_by("name")
            .limit(10)

        sql = query.to_sql()
    """

    fn __init__(self):
        self.select_fields = []
        self.table = nil
        self.where_clause = nil
        self.order_field = nil
        self.limit_count = nil

    fn select(self, fields):
        self.select_fields = fields
        return self  # Fluent chaining

    fn from_table(self, table):
        self.table = table
        return self

    fn where_filter(self, condition):
        self.where_clause = condition
        return self

    fn order_by(self, field):
        self.order_field = field
        return self

    fn limit(self, count):
        self.limit_count = count
        return self

    fn to_sql(self):
        fields = ", ".join(self.select_fields)
        sql = "SELECT {fields} FROM {self.table}"

        if self.where_clause:
            sql = sql + " WHERE {self.where_clause}"

        if self.order_field:
            sql = sql + " ORDER BY {self.order_field}"

        if self.limit_count:
            sql = sql + " LIMIT {self.limit_count}"

        return sql

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn has_table(self) -> bool:
        """Check if table is set.

        Returns:
            true if table is set

        Example:
            query.from_table("users")
            query.has_table()  # → true
        """
        return self.table is not nil

    fn has_where(self) -> bool:
        """Check if WHERE clause is set.

        Returns:
            true if where clause exists

        Example:
            query.where_filter("age > 18")
            query.has_where()  # → true
        """
        return self.where_clause is not nil

    fn has_order(self) -> bool:
        """Check if ORDER BY is set.

        Returns:
            true if order is set

        Example:
            query.order_by("name")
            query.has_order()  # → true
        """
        return self.order_field is not nil

    fn has_limit(self) -> bool:
        """Check if LIMIT is set.

        Returns:
            true if limit is set

        Example:
            query.limit(10)
            query.has_limit()  # → true
        """
        return self.limit_count is not nil

    fn field_count(self) -> i32:
        """Get number of selected fields.

        Returns:
            Field count

        Example:
            query.select("name", "age")
            query.field_count()  # → 2
        """
        return len(self.select_fields)

    fn reset(self):
        """Reset query to initial state.

        Returns:
            self for chaining

        Example:
            query.reset()
        """
        self.select_fields = []
        self.table = nil
        self.where_clause = nil
        self.order_field = nil
        self.limit_count = nil
        return self

    fn is_valid(self) -> bool:
        """Check if query is valid (has table and fields).

        Returns:
            true if query is valid

        Example:
            query.select("name").from_table("users")
            query.is_valid()  # → true
        """
        return self.table is not nil and len(self.select_fields) > 0


struct Pipeline:
    """
    Fluent pipeline for data transformation.

    Example:
        result = Pipeline([1, 2, 3, 4, 5])
            .map(fn(x): x * 2)
            .filter(fn(x): x > 5)
            .reduce(fn(a, b): a + b)

        # result = 18 (6 + 8 + 10)
    """

    fn __init__(self, data):
        self.data = data

    fn map(self, mapper):
        self.data = [mapper(x) for x in self.data]
        return self

    fn filter(self, predicate):
        self.data = [for x in self.data if predicate(x): x]
        return self

    fn reduce(self, reducer):
        result = self.data[0]
        for item in self.data[1:]:
            result = reducer(result, item)
        return result

    fn collect(self):
        return self.data

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_empty(self) -> bool:
        """Check if pipeline data is empty.

        Returns:
            true if data is empty

        Example:
            pipe = Pipeline([])
            pipe.is_empty()  # → true
        """
        return len(self.data) == 0

    fn size(self) -> i32:
        """Get number of items in pipeline.

        Returns:
            Item count

        Example:
            pipe = Pipeline([1, 2, 3])
            pipe.size()  # → 3
        """
        return len(self.data)

    fn first(self):
        """Get first item.

        Returns:
            First item or nil if empty

        Example:
            pipe.first()  # → 1
        """
        return if len(self.data) > 0: self.data[0] else: nil

    fn last(self):
        """Get last item.

        Returns:
            Last item or nil if empty

        Example:
            pipe.last()  # → 3
        """
        return if len(self.data) > 0: self.data[-1] else: nil

    fn take(self, n):
        """Take first n items.

        Args:
            n: Number of items

        Returns:
            self with first n items

        Example:
            pipe.take(2)  # keeps first 2 items
        """
        self.data = self.data[:n]
        return self

    fn skip(self, n):
        """Skip first n items.

        Args:
            n: Number of items to skip

        Returns:
            self with items after n

        Example:
            pipe.skip(2)  # removes first 2 items
        """
        self.data = self.data[n:]
        return self

    fn reverse(self):
        """Reverse the pipeline data.

        Returns:
            self with reversed data

        Example:
            pipe.reverse()
        """
        self.data = list(reversed(self.data))
        return self

    fn sort(self, key=nil):
        """Sort pipeline data.

        Args:
            key: Optional key function

        Returns:
            self with sorted data

        Example:
            pipe.sort()
        """
        if key:
            self.data = sorted(self.data, key=key)
        else:
            self.data = sorted(self.data)
        return self


# DSL Helper Functions

fn dsl_builder(initial_context = nil):
    """
    Create a context-aware DSL builder.

    Example:
        builder = dsl_builder()
        context builder:
            add("item1")
            add("item2")
            set_title("My List")
    """
    return ContextBuilder()


fn fluent(obj):
    """
    Wrap an object to make all methods return self (fluent interface).

    Example:
        class Config:
            fn set_host(host):
                self.host = host

            fn set_port(port):
                self.port = port

        config = fluent(Config())
            .set_host("localhost")
            .set_port(8080)
    """
    # In a full implementation, this would wrap methods
    return obj


# Exports
export ContextBuilder
export MethodMissing
export DynamicProxy
export AttributeDict
export FluentBuilder
export QueryBuilder
export Pipeline
export dsl_builder
export fluent
