# Type Inference Engine - Version 2
# Expanded working implementation with more type support

# Type representation with essential variants
enum Type:
    # Primitive types
    Int
    Bool
    Str
    Float
    Unit

    # Type variables for inference
    Var(id: i64)

    # Compound types (represented by type IDs for simplicity)
    Function(param_count: i64, return_id: i64)
    Generic(name: str, arg_count: i64)

impl Type:
    fn to_string() -> str:
        match self:
            Type.Int -> "Int"
            Type.Bool -> "Bool"
            Type.Str -> "Str"
            Type.Float -> "Float"
            Type.Unit -> "Unit"
            Type.Var(id) -> "T{id}"
            Type.Function(params, ret) -> "fn({params} params) -> T{ret}"
            Type.Generic(name, args) -> "{name}<{args} args>"

    fn is_primitive() -> bool:
        match self:
            Type.Int -> true
            Type.Bool -> true
            Type.Str -> true
            Type.Float -> true
            Type.Unit -> true
            _ -> false

# Type unification for Hindley-Milner inference
class TypeUnifier:
    substitution: any              # Dict mapping type IDs to types
    next_var: i64                  # Counter for fresh variables

impl TypeUnifier:
    static fn create() -> TypeUnifier:
        TypeUnifier(
            substitution: {},
            next_var: 0
        )

    me fresh_var() -> Type:
        """Generate a fresh type variable"""
        val var_id = self.next_var
        self.next_var = self.next_var + 1
        Type.Var(var_id)

    fn resolve(ty: Type) -> Type:
        """Follow substitution chain to get concrete type"""
        match ty:
            Type.Var(id) ->
                val sub = self.substitution.get(id)
                if sub.?:
                    self.resolve(sub)
                else:
                    ty
            _ -> ty

    me unify(t1: Type, t2: Type) -> bool:
        """
        Unify two types, updating substitutions.
        Returns true on success, false on failure.
        """
        val resolved_t1 = self.resolve(t1)
        val resolved_t2 = self.resolve(t2)

        # Same type - trivially unify
        if resolved_t1 == resolved_t2:
            return true

        match (resolved_t1, resolved_t2):
            # Type variable unification
            (Type.Var(id1), Type.Var(id2)) ->
                if id1 == id2:
                    true
                else:
                    self.substitution[id1] = Type.Var(id2)
                    true

            (Type.Var(id), other) ->
                if self.occurs_check(id, other):
                    false
                else:
                    self.substitution[id] = other
                    true

            (other, Type.Var(id)) ->
                if self.occurs_check(id, other):
                    false
                else:
                    self.substitution[id] = other
                    true

            # Function unification
            (Type.Function(params1, ret1), Type.Function(params2, ret2)) ->
                if params1 != params2:
                    false
                else:
                    # In real implementation, would unify param types and return type
                    ret1 == ret2

            # Generic type unification
            (Type.Generic(name1, args1), Type.Generic(name2, args2)) ->
                if name1 != name2:
                    false
                else:
                    args1 == args2

            # Base type mismatch
            _ -> false

    fn occurs_check(var_id: i64, ty: Type) -> bool:
        """
        Check if type variable occurs in type (prevents infinite types).
        """
        match self.resolve(ty):
            Type.Var(id) -> id == var_id
            # TODO: Recursively check compound types
            _ -> false

    fn get_substitution_count() -> i64:
        """Get the number of type substitutions recorded"""
        val count = 0
        # Would iterate over self.substitution in real impl
        count

# Comprehensive test suite
fn test_type_inference() -> bool:
    print "=== Type Inference Test Suite ==="

    var unifier = TypeUnifier.create()
    var all_passed = true

    # Test 1: Primitive type unification
    print "\nTest 1: Primitive types"
    val test1a = unifier.unify(Type.Int, Type.Int)
    val test1b = not unifier.unify(Type.Int, Type.Bool)
    val test1c = unifier.unify(Type.Str, Type.Str)
    if test1a and test1b and test1c:
        print "  ✅ Primitive unification works"
    else:
        print "  ❌ Primitive unification failed"
        all_passed = false

    # Test 2: Type variable generation
    print "\nTest 2: Fresh type variables"
    val tv1 = unifier.fresh_var()
    val tv2 = unifier.fresh_var()
    match (tv1, tv2):
        (Type.Var(id1), Type.Var(id2)) ->
            if id1 != id2:
                print "  ✅ Fresh variables are unique"
            else:
                print "  ❌ Fresh variables have same ID"
                all_passed = false
        _ ->
            print "  ❌ fresh_var didn't return Var"
            all_passed = false

    # Test 3: Unifying type variable with concrete type
    print "\nTest 3: Type variable binding"
    var unifier2 = TypeUnifier.create()
    val tv3 = unifier2.fresh_var()
    val test3 = unifier2.unify(tv3, Type.Int)
    if test3:
        val resolved = unifier2.resolve(tv3)
        match resolved:
            Type.Int ->
                print "  ✅ Type variable binds to concrete type"
            _ ->
                print "  ❌ Type variable didn't resolve correctly"
                all_passed = false
    else:
        print "  ❌ Type variable unification failed"
        all_passed = false

    # Test 4: Transitive substitution
    print "\nTest 4: Transitive substitution"
    var unifier3 = TypeUnifier.create()
    val tv4 = unifier3.fresh_var()
    val tv5 = unifier3.fresh_var()
    unifier3.unify(tv4, tv5)
    unifier3.unify(tv5, Type.Bool)
    val resolved4 = unifier3.resolve(tv4)
    match resolved4:
        Type.Bool ->
            print "  ✅ Transitive substitution works"
        _ ->
            print "  ❌ Transitive substitution failed"
            all_passed = false

    # Test 5: Function types
    print "\nTest 5: Function types"
    val fn1 = Type.Function(2, 0)  # fn(T0, T1) -> T0
    val fn2 = Type.Function(2, 0)  # fn(T0, T1) -> T0
    val fn3 = Type.Function(1, 0)  # fn(T0) -> T0
    val test5a = unifier.unify(fn1, fn2)
    val test5b = not unifier.unify(fn1, fn3)
    if test5a and test5b:
        print "  ✅ Function type unification works"
    else:
        print "  ❌ Function type unification failed"
        all_passed = false

    # Test 6: Generic types
    print "\nTest 6: Generic types"
    val list_int = Type.Generic("List", 1)
    val list_int2 = Type.Generic("List", 1)
    val list_bool = Type.Generic("List", 2)
    val test6a = unifier.unify(list_int, list_int2)
    val test6b = not unifier.unify(list_int, list_bool)
    if test6a and test6b:
        print "  ✅ Generic type unification works"
    else:
        print "  ❌ Generic type unification failed"
        all_passed = false

    # Test 7: Type.to_string()
    print "\nTest 7: Type string representation"
    val int_str = Type.Int.to_string()
    val var_str = Type.Var(42).to_string()
    if int_str == "Int" and var_str == "T42":
        print "  ✅ Type.to_string() works"
    else:
        print "  ❌ Type.to_string() failed"
        print "    Expected: Int, T42"
        print "    Got: {int_str}, {var_str}"
        all_passed = false

    # Test 8: Type.is_primitive()
    print "\nTest 8: Type classification"
    if Type.Int.is_primitive() and not Type.Var(0).is_primitive():
        print "  ✅ Type.is_primitive() works"
    else:
        print "  ❌ Type.is_primitive() failed"
        all_passed = false

    print "\n=== Summary ==="
    if all_passed:
        print "✅ All tests passed!"
    else:
        print "❌ Some tests failed"

    all_passed

# Run tests
val test_result = test_type_inference()
if not test_result:
    print "\n⚠️  Module loaded with test failures"
