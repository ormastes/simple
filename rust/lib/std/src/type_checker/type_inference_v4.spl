# Type Inference Engine - Version 4
# Fixed: Occurs check, function unification, generic unification

"""
# Type Inference Engine - Version 4

**Status:** Fixed Critical Bugs (Educational / Prototyping Use)
**Production Use:** See Rust implementation in rust/type/

## Fixes in V4

‚úÖ **Fixed occurs check** - Now recursive, detects infinite types correctly
‚úÖ **Fixed function unification** - Deep unification of all parameters
‚úÖ **Fixed generic unification** - Deep unification of all type arguments
‚úÖ **Extended Type enum** - Stores full structures instead of counts

## Changes from V3

1. Type.Function now stores `params: [Type]` instead of `param_count: i64`
2. Type.Generic now stores `args: [Type]` instead of `arg_count: i64`
3. occurs_check() is now recursive
4. unify() properly checks all nested types

## Limitations

This implementation is NOT suitable for production use:
- ‚ùå No expression inference (can only unify explicit types)
- ‚ùå No integration with parser/compiler
- ‚ùå Limited type system (no arrays, tuples, optionals, dicts, unions)
- ‚ùå No error messages (returns bool only)
- ‚ùå 15-40x slower than Rust implementation
- ‚ùå Missing advanced features (effects, traits, macros)

## For Production

Use the Rust implementation:
- rust/type/src/checker_infer.rs - Expression inference
- rust/type/src/checker_unify.rs - Unification
- rust/type/src/checker_check.rs - Type checking
"""

# Type representation with full structures
enum Type:
    # Primitive types
    Int
    Bool
    Str
    Float
    Unit

    # Type variables for inference
    Var(id: i64)

    # Compound types (now store full structures)
    Function(params: [Type], ret: Type)
    Generic(name: str, args: [Type])

impl Type:
    fn to_string() -> str:
        match self:
            Type.Int -> "Int"
            Type.Bool -> "Bool"
            Type.Str -> "Str"
            Type.Float -> "Float"
            Type.Unit -> "Unit"
            Type.Var(id) -> "T{id}"
            Type.Function(params, ret) ->
                val param_strs = params.map(\p: p.to_string())
                "fn({param_strs}) -> {ret.to_string()}"
            Type.Generic(name, args) ->
                val arg_strs = args.map(\a: a.to_string())
                "{name}<{arg_strs}>"

    fn is_primitive() -> bool:
        match self:
            Type.Int -> true
            Type.Bool -> true
            Type.Str -> true
            Type.Float -> true
            Type.Unit -> true
            _ -> false

# Type unification for Hindley-Milner inference
class TypeUnifier:
    substitution: any              # Dict mapping type IDs to types
    next_var: i64                  # Counter for fresh variables

impl TypeUnifier:
    static fn create() -> TypeUnifier:
        TypeUnifier(
            substitution: {},
            next_var: 0
        )

    me fresh_var() -> Type:
        """Generate a fresh type variable"""
        val var_id = self.next_var
        self.next_var = self.next_var + 1
        Type.Var(var_id)

    fn resolve(ty: Type) -> Type:
        """Follow substitution chain to get concrete type"""
        match ty:
            Type.Var(id) ->
                val sub = self.substitution.get(id)
                if sub.?:
                    self.resolve(sub)
                else:
                    ty
            _ -> ty

    me unify(t1: Type, t2: Type) -> bool:
        """
        Unify two types, updating substitutions.
        Returns true on success, false on failure.
        """
        val resolved_t1 = self.resolve(t1)
        val resolved_t2 = self.resolve(t2)

        # Same type - trivially unify
        if resolved_t1 == resolved_t2:
            return true

        match (resolved_t1, resolved_t2):
            # Type variable unification
            (Type.Var(id1), Type.Var(id2)) ->
                if id1 == id2:
                    true
                else:
                    self.substitution[id1] = Type.Var(id2)
                    true

            (Type.Var(id), other) ->
                if self.occurs_check(id, other):
                    false  # Infinite type detected
                else:
                    self.substitution[id] = other
                    true

            (other, Type.Var(id)) ->
                if self.occurs_check(id, other):
                    false  # Infinite type detected
                else:
                    self.substitution[id] = other
                    true

            # Function unification (FIXED: deep unification)
            (Type.Function(params1, ret1), Type.Function(params2, ret2)) ->
                # Check arity
                if params1.len() != params2.len():
                    return false

                # Unify all parameters (deep check)
                var i = 0
                while i < params1.len():
                    if not self.unify(params1[i], params2[i]):
                        return false
                    i = i + 1

                # Unify return types
                self.unify(ret1, ret2)

            # Generic type unification (FIXED: deep unification)
            (Type.Generic(name1, args1), Type.Generic(name2, args2)) ->
                # Check name
                if name1 != name2:
                    return false

                # Check arity
                if args1.len() != args2.len():
                    return false

                # Unify all type arguments (deep check)
                var i = 0
                while i < args1.len():
                    if not self.unify(args1[i], args2[i]):
                        return false
                    i = i + 1

                true

            # Base type mismatch
            _ -> false

    fn occurs_check(var_id: i64, ty: Type) -> bool:
        """
        Check if type variable occurs in type (prevents infinite types).
        FIXED: Now recursive for compound types.
        """
        match self.resolve(ty):
            Type.Var(id) -> id == var_id

            # FIXED: Recursive check in function types
            Type.Function(params, ret) ->
                # Check if var occurs in any parameter
                var occurs_in_params = false
                var i = 0
                while i < params.len():
                    if self.occurs_check(var_id, params[i]):
                        occurs_in_params = true
                        break
                    i = i + 1

                # Check if var occurs in return type
                occurs_in_params or self.occurs_check(var_id, ret)

            # FIXED: Recursive check in generic types
            Type.Generic(name, args) ->
                # Check if var occurs in any type argument
                var occurs_in_args = false
                var i = 0
                while i < args.len():
                    if self.occurs_check(var_id, args[i]):
                        occurs_in_args = true
                        break
                    i = i + 1

                occurs_in_args

            # Primitives don't contain variables
            _ -> false

# Comprehensive test suite - Version 4 with bug fix tests
fn test_type_inference_v4() -> bool:
    print "=== Type Inference Test Suite V4 (Bug Fixes) ==="
    var all_passed = true
    var test_count = 0
    var passed_count = 0

    # Helper function to track test results
    fn check_test(name: str, condition: bool):
        test_count = test_count + 1
        if condition:
            passed_count = passed_count + 1
            print "  ‚úÖ {name}"
        else:
            print "  ‚ùå {name}"
            all_passed = false

    # Test Suite 1: Type Representation
    print "\n[1/15] Type Representation:"
    check_test("Int type toString", Type.Int.to_string() == "Int")
    check_test("Bool type toString", Type.Bool.to_string() == "Bool")
    check_test("Str type toString", Type.Str.to_string() == "Str")
    check_test("Float type toString", Type.Float.to_string() == "Float")
    check_test("Unit type toString", Type.Unit.to_string() == "Unit")
    check_test("Var(0) toString", Type.Var(0).to_string() == "T0")
    check_test("Var(42) toString", Type.Var(42).to_string() == "T42")

    val fn_ty = Type.Function([Type.Int, Type.Bool], Type.Str)
    check_test("Function toString contains params", fn_ty.to_string().contains("Int"))

    val gen_ty = Type.Generic("List", [Type.Int])
    check_test("Generic toString contains args", gen_ty.to_string().contains("Int"))

    # Test Suite 2: Type Classification
    print "\n[2/15] Type Classification:"
    check_test("Int is primitive", Type.Int.is_primitive())
    check_test("Bool is primitive", Type.Bool.is_primitive())
    check_test("Str is primitive", Type.Str.is_primitive())
    check_test("Float is primitive", Type.Float.is_primitive())
    check_test("Unit is primitive", Type.Unit.is_primitive())
    check_test("Var is not primitive", not Type.Var(0).is_primitive())
    check_test("Function is not primitive", not Type.Function([], Type.Int).is_primitive())
    check_test("Generic is not primitive", not Type.Generic("List", []).is_primitive())

    # Test Suite 3: TypeUnifier Creation
    print "\n[3/15] TypeUnifier Creation:"
    var unifier1 = TypeUnifier.create()
    check_test("Unifier created", true)
    val first_var = unifier1.fresh_var()
    match first_var:
        Type.Var(id) -> check_test("First fresh var is Var(0)", id == 0)
        _ -> check_test("First fresh var is Var(0)", false)

    # Test Suite 4: Fresh Variable Generation
    print "\n[4/15] Fresh Variable Generation:"
    var unifier2 = TypeUnifier.create()
    val v1 = unifier2.fresh_var()
    val v2 = unifier2.fresh_var()
    val v3 = unifier2.fresh_var()
    match (v1, v2, v3):
        (Type.Var(id1), Type.Var(id2), Type.Var(id3)) ->
            check_test("Three unique IDs", id1 != id2 and id2 != id3 and id1 != id3)
            check_test("Sequential IDs", id1 == 0 and id2 == 1 and id3 == 2)
        _ ->
            check_test("All fresh_var return Var", false)

    # Test Suite 5: Primitive Type Unification
    print "\n[5/15] Primitive Type Unification:"
    var unifier3 = TypeUnifier.create()
    check_test("Int unifies with Int", unifier3.unify(Type.Int, Type.Int))
    check_test("Bool unifies with Bool", unifier3.unify(Type.Bool, Type.Bool))
    check_test("Str unifies with Str", unifier3.unify(Type.Str, Type.Str))
    check_test("Float unifies with Float", unifier3.unify(Type.Float, Type.Float))
    check_test("Unit unifies with Unit", unifier3.unify(Type.Unit, Type.Unit))
    check_test("Int fails with Bool", not unifier3.unify(Type.Int, Type.Bool))
    check_test("Int fails with Str", not unifier3.unify(Type.Int, Type.Str))
    check_test("Bool fails with Float", not unifier3.unify(Type.Bool, Type.Float))
    check_test("Str fails with Unit", not unifier3.unify(Type.Str, Type.Unit))

    # Test Suite 6: Var-Var Unification
    print "\n[6/15] Var-Var Unification:"
    var unifier4 = TypeUnifier.create()
    val v4 = unifier4.fresh_var()
    val v5 = unifier4.fresh_var()
    check_test("Different vars unify", unifier4.unify(v4, v5))
    check_test("Same var unifies with itself", unifier4.unify(v4, v4))

    # Test Suite 7: Var-Concrete Unification
    print "\n[7/15] Var-Concrete Unification:"
    var unifier5 = TypeUnifier.create()
    val v6 = unifier5.fresh_var()
    val v7 = unifier5.fresh_var()
    val v8 = unifier5.fresh_var()
    val v9 = unifier5.fresh_var()
    val v10 = unifier5.fresh_var()
    check_test("Var unifies with Int", unifier5.unify(v6, Type.Int))
    check_test("Var unifies with Bool", unifier5.unify(v7, Type.Bool))
    check_test("Var unifies with Str", unifier5.unify(v8, Type.Str))
    check_test("Int unifies with Var (reverse)", unifier5.unify(Type.Float, v9))
    check_test("Unit unifies with Var (reverse)", unifier5.unify(Type.Unit, v10))

    # Test Suite 8: Substitution Resolution
    print "\n[8/15] Substitution Resolution:"
    var unifier6 = TypeUnifier.create()
    val v11 = unifier6.fresh_var()
    unifier6.unify(v11, Type.Int)
    val resolved = unifier6.resolve(v11)
    match resolved:
        Type.Int -> check_test("Var resolves to Int after unification", true)
        _ -> check_test("Var resolves to Int after unification", false)

    check_test("Primitive resolves to itself", unifier6.resolve(Type.Bool) == Type.Bool)

    val v12 = unifier6.fresh_var()
    check_test("Unsubstituted var resolves to itself", unifier6.resolve(v12) == v12)

    # Test Suite 9: Transitive Substitution
    print "\n[9/15] Transitive Substitution:"
    var unifier7 = TypeUnifier.create()
    val v13 = unifier7.fresh_var()
    val v14 = unifier7.fresh_var()
    val v15 = unifier7.fresh_var()
    unifier7.unify(v13, v14)
    unifier7.unify(v14, v15)
    unifier7.unify(v15, Type.Str)
    val resolved_chain = unifier7.resolve(v13)
    match resolved_chain:
        Type.Str -> check_test("3-hop chain resolves correctly", true)
        _ -> check_test("3-hop chain resolves correctly", false)

    # Test Suite 10: Function Type Unification (FIXED)
    print "\n[10/15] Function Type Unification (Fixed):"
    var unifier8 = TypeUnifier.create()
    val fn1 = Type.Function([Type.Int, Type.Bool], Type.Str)
    val fn2 = Type.Function([Type.Int, Type.Bool], Type.Str)
    val fn3 = Type.Function([Type.Float], Type.Str)
    val fn4 = Type.Function([Type.Int, Type.Bool], Type.Float)
    val fn5 = Type.Function([Type.Float, Type.Int], Type.Str)

    check_test("Same function types unify", unifier8.unify(fn1, fn2))
    check_test("Different arity fails", not unifier8.unify(fn1, fn3))
    check_test("Different return type fails", not unifier8.unify(fn1, fn4))
    check_test("Different param types fail", not unifier8.unify(fn1, fn5))
    check_test("Function fails with Int", not unifier8.unify(fn1, Type.Int))

    # Test Suite 11: Generic Type Unification (FIXED)
    print "\n[11/15] Generic Type Unification (Fixed):"
    var unifier9 = TypeUnifier.create()
    val list_int1 = Type.Generic("List", [Type.Int])
    val list_int2 = Type.Generic("List", [Type.Int])
    val list_bool = Type.Generic("List", [Type.Bool])
    val set_int = Type.Generic("Set", [Type.Int])
    val list_int_bool = Type.Generic("List", [Type.Int, Type.Bool])

    check_test("Same generic types unify", unifier9.unify(list_int1, list_int2))
    check_test("Different generic names fail", not unifier9.unify(list_int1, set_int))
    check_test("Different type arguments fail", not unifier9.unify(list_int1, list_bool))
    check_test("Different arg counts fail", not unifier9.unify(list_int1, list_int_bool))
    check_test("Generic fails with Int", not unifier9.unify(list_int1, Type.Int))

    # Test Suite 12: Occurs Check (FIXED)
    print "\n[12/15] Occurs Check (Fixed):"
    var unifier10 = TypeUnifier.create()
    val v16 = unifier10.fresh_var()
    match v16:
        Type.Var(id) ->
            check_test("Var occurs in itself", unifier10.occurs_check(id, v16))
            check_test("Var doesn't occur in Int", not unifier10.occurs_check(id, Type.Int))
            val v17 = unifier10.fresh_var()
            check_test("Var doesn't occur in different var", not unifier10.occurs_check(id, v17))
        _ ->
            check_test("fresh_var returns Var", false)

    # Test Suite 13: Occurs Check in Functions (NEW - Bug Fix Test)
    print "\n[13/15] Occurs Check in Functions (New):"
    var unifier11 = TypeUnifier.create()
    val v18 = unifier11.fresh_var()
    match v18:
        Type.Var(id) ->
            # Test: T0 = fn(T0) -> Int (infinite type)
            val fn_with_var = Type.Function([Type.Var(id)], Type.Int)
            check_test("Detects var in function param", unifier11.occurs_check(id, fn_with_var))

            # Test: T0 = fn(Int) -> T0 (infinite type)
            val fn_with_var_ret = Type.Function([Type.Int], Type.Var(id))
            check_test("Detects var in function return", unifier11.occurs_check(id, fn_with_var_ret))

            # Test: T0 = fn(Int) -> Bool (not infinite)
            val fn_without_var = Type.Function([Type.Int], Type.Bool)
            check_test("No var in function", not unifier11.occurs_check(id, fn_without_var))
        _ ->
            check_test("fresh_var returns Var", false)

    # Test Suite 14: Occurs Check in Generics (NEW - Bug Fix Test)
    print "\n[14/15] Occurs Check in Generics (New):"
    var unifier12 = TypeUnifier.create()
    val v19 = unifier12.fresh_var()
    match v19:
        Type.Var(id) ->
            # Test: T0 = List<T0> (infinite type)
            val list_with_var = Type.Generic("List", [Type.Var(id)])
            check_test("Detects var in generic arg", unifier12.occurs_check(id, list_with_var))

            # Test: T0 = Dict<T0, Int> (infinite type)
            val dict_with_var_key = Type.Generic("Dict", [Type.Var(id), Type.Int])
            check_test("Detects var in first generic arg", unifier12.occurs_check(id, dict_with_var_key))

            # Test: T0 = Dict<Int, T0> (infinite type)
            val dict_with_var_val = Type.Generic("Dict", [Type.Int, Type.Var(id)])
            check_test("Detects var in second generic arg", unifier12.occurs_check(id, dict_with_var_val))

            # Test: T0 = List<Int> (not infinite)
            val list_without_var = Type.Generic("List", [Type.Int])
            check_test("No var in generic", not unifier12.occurs_check(id, list_without_var))
        _ ->
            check_test("fresh_var returns Var", false)

    # Test Suite 15: Infinite Type Prevention (NEW - Integration Test)
    print "\n[15/15] Infinite Type Prevention (New):"
    var unifier13 = TypeUnifier.create()
    val v20 = unifier13.fresh_var()

    # These should all fail (infinite types)
    match v20:
        Type.Var(id) ->
            val fn_recursive = Type.Function([Type.Var(id)], Type.Int)
            check_test("Rejects T = fn(T) -> Int", not unifier13.unify(v20, fn_recursive))

            var unifier14 = TypeUnifier.create()
            val v21 = unifier14.fresh_var()
            val list_recursive = Type.Generic("List", [v21])
            check_test("Rejects T = List<T>", not unifier14.unify(v21, list_recursive))

            var unifier15 = TypeUnifier.create()
            val v22 = unifier15.fresh_var()
            val nested_recursive = Type.Generic("List", [Type.Generic("List", [v22])])
            check_test("Rejects T = List<List<T>>", not unifier15.unify(v22, nested_recursive))
        _ ->
            check_test("fresh_var returns Var", false)

    # Final Summary
    print "\n=== Final Results ==="
    print "Total tests: {test_count}"
    print "Passed: {passed_count}"
    print "Failed: {test_count - passed_count}"

    if all_passed:
        print "‚úÖ All tests passed!"
    else:
        print "‚ùå Some tests failed"

    all_passed

# Run comprehensive tests
val test_result = test_type_inference_v4()
if not test_result:
    print "\n‚ö†Ô∏è  Module loaded with test failures"
else:
    print "\nüéâ All critical bugs fixed!"
