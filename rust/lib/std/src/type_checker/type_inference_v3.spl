# Type Inference Engine - Version 3
# Enhanced with comprehensive test coverage

# Type representation with essential variants
enum Type:
    # Primitive types
    Int
    Bool
    Str
    Float
    Unit

    # Type variables for inference
    Var(id: i64)

    # Compound types (represented by type IDs for simplicity)
    Function(param_count: i64, return_id: i64)
    Generic(name: str, arg_count: i64)

impl Type:
    fn to_string() -> str:
        match self:
            Type.Int -> "Int"
            Type.Bool -> "Bool"
            Type.Str -> "Str"
            Type.Float -> "Float"
            Type.Unit -> "Unit"
            Type.Var(id) -> "T{id}"
            Type.Function(params, ret) -> "fn({params} params) -> T{ret}"
            Type.Generic(name, args) -> "{name}<{args} args>"

    fn is_primitive() -> bool:
        match self:
            Type.Int -> true
            Type.Bool -> true
            Type.Str -> true
            Type.Float -> true
            Type.Unit -> true
            _ -> false

# Type unification for Hindley-Milner inference
class TypeUnifier:
    substitution: any              # Dict mapping type IDs to types
    next_var: i64                  # Counter for fresh variables

impl TypeUnifier:
    static fn create() -> TypeUnifier:
        TypeUnifier(
            substitution: {},
            next_var: 0
        )

    me fresh_var() -> Type:
        """Generate a fresh type variable"""
        val var_id = self.next_var
        self.next_var = self.next_var + 1
        Type.Var(var_id)

    fn resolve(ty: Type) -> Type:
        """Follow substitution chain to get concrete type"""
        match ty:
            Type.Var(id) ->
                val sub = self.substitution.get(id)
                if sub.?:
                    self.resolve(sub)
                else:
                    ty
            _ -> ty

    me unify(t1: Type, t2: Type) -> bool:
        """
        Unify two types, updating substitutions.
        Returns true on success, false on failure.
        """
        val resolved_t1 = self.resolve(t1)
        val resolved_t2 = self.resolve(t2)

        # Same type - trivially unify
        if resolved_t1 == resolved_t2:
            return true

        match (resolved_t1, resolved_t2):
            # Type variable unification
            (Type.Var(id1), Type.Var(id2)) ->
                if id1 == id2:
                    true
                else:
                    self.substitution[id1] = Type.Var(id2)
                    true

            (Type.Var(id), other) ->
                if self.occurs_check(id, other):
                    false
                else:
                    self.substitution[id] = other
                    true

            (other, Type.Var(id)) ->
                if self.occurs_check(id, other):
                    false
                else:
                    self.substitution[id] = other
                    true

            # Function unification
            (Type.Function(params1, ret1), Type.Function(params2, ret2)) ->
                if params1 != params2:
                    false
                else:
                    ret1 == ret2

            # Generic type unification
            (Type.Generic(name1, args1), Type.Generic(name2, args2)) ->
                if name1 != name2:
                    false
                else:
                    args1 == args2

            # Base type mismatch
            _ -> false

    fn occurs_check(var_id: i64, ty: Type) -> bool:
        """
        Check if type variable occurs in type (prevents infinite types).
        """
        match self.resolve(ty):
            Type.Var(id) -> id == var_id
            _ -> false

# Comprehensive test suite - Version 3 with expanded coverage
fn test_type_inference_v3() -> bool:
    print "=== Type Inference Test Suite V3 (Comprehensive) ==="
    var all_passed = true
    var test_count = 0
    var passed_count = 0

    # Helper function to track test results
    fn check_test(name: str, condition: bool):
        test_count = test_count + 1
        if condition:
            passed_count = passed_count + 1
            print "  ✅ {name}"
        else:
            print "  ❌ {name}"
            all_passed = false

    # Test Suite 1: Type Representation
    print "\n[1/12] Type Representation:"
    check_test("Int type toString", Type.Int.to_string() == "Int")
    check_test("Bool type toString", Type.Bool.to_string() == "Bool")
    check_test("Str type toString", Type.Str.to_string() == "Str")
    check_test("Float type toString", Type.Float.to_string() == "Float")
    check_test("Unit type toString", Type.Unit.to_string() == "Unit")
    check_test("Var(0) toString", Type.Var(0).to_string() == "T0")
    check_test("Var(42) toString", Type.Var(42).to_string() == "T42")
    check_test("Function toString", Type.Function(2, 0).to_string() == "fn(2 params) -> T0")
    check_test("Generic toString", Type.Generic("List", 1).to_string() == "List<1 args>")

    # Test Suite 2: Type Classification
    print "\n[2/12] Type Classification:"
    check_test("Int is primitive", Type.Int.is_primitive())
    check_test("Bool is primitive", Type.Bool.is_primitive())
    check_test("Str is primitive", Type.Str.is_primitive())
    check_test("Float is primitive", Type.Float.is_primitive())
    check_test("Unit is primitive", Type.Unit.is_primitive())
    check_test("Var is not primitive", not Type.Var(0).is_primitive())
    check_test("Function is not primitive", not Type.Function(1, 0).is_primitive())
    check_test("Generic is not primitive", not Type.Generic("List", 1).is_primitive())

    # Test Suite 3: TypeUnifier Creation
    print "\n[3/12] TypeUnifier Creation:"
    var unifier1 = TypeUnifier.create()
    check_test("Unifier created", true)
    val first_var = unifier1.fresh_var()
    match first_var:
        Type.Var(id) -> check_test("First fresh var is Var(0)", id == 0)
        _ -> check_test("First fresh var is Var(0)", false)

    # Test Suite 4: Fresh Variable Generation
    print "\n[4/12] Fresh Variable Generation:"
    var unifier2 = TypeUnifier.create()
    val v1 = unifier2.fresh_var()
    val v2 = unifier2.fresh_var()
    val v3 = unifier2.fresh_var()
    match (v1, v2, v3):
        (Type.Var(id1), Type.Var(id2), Type.Var(id3)) ->
            check_test("Three unique IDs", id1 != id2 and id2 != id3 and id1 != id3)
            check_test("Sequential IDs", id1 == 0 and id2 == 1 and id3 == 2)
        _ ->
            check_test("All fresh_var return Var", false)

    # Test Suite 5: Primitive Type Unification
    print "\n[5/12] Primitive Type Unification:"
    var unifier3 = TypeUnifier.create()
    check_test("Int unifies with Int", unifier3.unify(Type.Int, Type.Int))
    check_test("Bool unifies with Bool", unifier3.unify(Type.Bool, Type.Bool))
    check_test("Str unifies with Str", unifier3.unify(Type.Str, Type.Str))
    check_test("Float unifies with Float", unifier3.unify(Type.Float, Type.Float))
    check_test("Unit unifies with Unit", unifier3.unify(Type.Unit, Type.Unit))
    check_test("Int fails with Bool", not unifier3.unify(Type.Int, Type.Bool))
    check_test("Int fails with Str", not unifier3.unify(Type.Int, Type.Str))
    check_test("Bool fails with Float", not unifier3.unify(Type.Bool, Type.Float))
    check_test("Str fails with Unit", not unifier3.unify(Type.Str, Type.Unit))

    # Test Suite 6: Var-Var Unification
    print "\n[6/12] Var-Var Unification:"
    var unifier4 = TypeUnifier.create()
    val v4 = unifier4.fresh_var()
    val v5 = unifier4.fresh_var()
    check_test("Different vars unify", unifier4.unify(v4, v5))
    check_test("Same var unifies with itself", unifier4.unify(v4, v4))

    # Test Suite 7: Var-Concrete Unification
    print "\n[7/12] Var-Concrete Unification:"
    var unifier5 = TypeUnifier.create()
    val v6 = unifier5.fresh_var()
    val v7 = unifier5.fresh_var()
    val v8 = unifier5.fresh_var()
    val v9 = unifier5.fresh_var()
    val v10 = unifier5.fresh_var()
    check_test("Var unifies with Int", unifier5.unify(v6, Type.Int))
    check_test("Var unifies with Bool", unifier5.unify(v7, Type.Bool))
    check_test("Var unifies with Str", unifier5.unify(v8, Type.Str))
    check_test("Int unifies with Var (reverse)", unifier5.unify(Type.Float, v9))
    check_test("Unit unifies with Var (reverse)", unifier5.unify(Type.Unit, v10))

    # Test Suite 8: Substitution Resolution
    print "\n[8/12] Substitution Resolution:"
    var unifier6 = TypeUnifier.create()
    val v11 = unifier6.fresh_var()
    unifier6.unify(v11, Type.Int)
    val resolved = unifier6.resolve(v11)
    match resolved:
        Type.Int -> check_test("Var resolves to Int after unification", true)
        _ -> check_test("Var resolves to Int after unification", false)

    check_test("Primitive resolves to itself", unifier6.resolve(Type.Bool) == Type.Bool)

    val v12 = unifier6.fresh_var()
    check_test("Unsubstituted var resolves to itself", unifier6.resolve(v12) == v12)

    # Test Suite 9: Transitive Substitution
    print "\n[9/12] Transitive Substitution:"
    var unifier7 = TypeUnifier.create()
    val v13 = unifier7.fresh_var()
    val v14 = unifier7.fresh_var()
    val v15 = unifier7.fresh_var()
    unifier7.unify(v13, v14)
    unifier7.unify(v14, v15)
    unifier7.unify(v15, Type.Str)
    val resolved_chain = unifier7.resolve(v13)
    match resolved_chain:
        Type.Str -> check_test("3-hop chain resolves correctly", true)
        _ -> check_test("3-hop chain resolves correctly", false)

    # Test Suite 10: Function Type Unification
    print "\n[10/12] Function Type Unification:"
    var unifier8 = TypeUnifier.create()
    val fn1 = Type.Function(2, 0)
    val fn2 = Type.Function(2, 0)
    val fn3 = Type.Function(1, 0)
    val fn4 = Type.Function(2, 1)
    check_test("Same function types unify", unifier8.unify(fn1, fn2))
    check_test("Different arity fails", not unifier8.unify(fn1, fn3))
    check_test("Different return fails", not unifier8.unify(fn1, fn4))
    check_test("Function fails with Int", not unifier8.unify(fn1, Type.Int))

    # Test Suite 11: Generic Type Unification
    print "\n[11/12] Generic Type Unification:"
    var unifier9 = TypeUnifier.create()
    val list1 = Type.Generic("List", 1)
    val list2 = Type.Generic("List", 1)
    val set1 = Type.Generic("Set", 1)
    val list_diff = Type.Generic("List", 2)
    check_test("Same generic types unify", unifier9.unify(list1, list2))
    check_test("Different generic names fail", not unifier9.unify(list1, set1))
    check_test("Different arg counts fail", not unifier9.unify(list1, list_diff))
    check_test("Generic fails with Int", not unifier9.unify(list1, Type.Int))

    # Test Suite 12: Occurs Check
    print "\n[12/12] Occurs Check:"
    var unifier10 = TypeUnifier.create()
    val v16 = unifier10.fresh_var()
    match v16:
        Type.Var(id) ->
            check_test("Var occurs in itself", unifier10.occurs_check(id, v16))
            check_test("Var doesn't occur in Int", not unifier10.occurs_check(id, Type.Int))
            val v17 = unifier10.fresh_var()
            check_test("Var doesn't occur in different var", not unifier10.occurs_check(id, v17))
        _ ->
            check_test("fresh_var returns Var", false)

    # Final Summary
    print "\n=== Final Results ==="
    print "Total tests: {test_count}"
    print "Passed: {passed_count}"
    print "Failed: {test_count - passed_count}"

    if all_passed:
        print "✅ All tests passed!"
    else:
        print "❌ Some tests failed"

    all_passed

# Run comprehensive tests
val test_result = test_type_inference_v3()
if not test_result:
    print "\n⚠️  Module loaded with test failures"
