# Math Tensor Bridge - Conversions between math types and tensors
#
# Provides TensorConvertible implementations and batch conversion utilities.
# TODO: Enable when torch imports work

export vecs_to_tensor, tensor_to_vecs, vecs3d_to_tensor, tensor_to_vecs3d

# TODO: Re-enable after torch parse issues are fixed
# import ml.torch as torch

use .vec3
use .vec4
use .mat4
use .quat
use .transform


# ============================================================================
# Batch conversion utilities (placeholder until torch is available)
# ============================================================================

# TODO: Uncomment when torch imports work
#
# impl TensorConvertible for vec3.Vec3:
#     fn to_tensor(device: torch.Device) -> torch.Tensor:
#         torch.tensor([self.x, self.y, self.z], dtype: torch.DType.Float32, device: device)
#
#     static fn from_tensor(t: torch.Tensor) -> vec3.Vec3:
#         vec3.Vec3(x: t[0].item(), y: t[1].item(), z: t[2].item())
#
# fn vecs_to_tensor(vecs: [vec3.Vec3], device: torch.Device) -> torch.Tensor:
#     """Convert list of Vec3 to [N, 3] tensor."""
#     var data = []
#     for v in vecs:
#         data.append([v.x, v.y, v.z])
#     torch.tensor(data, dtype: torch.DType.Float32, device: device)
#
# fn tensor_to_vecs(t: torch.Tensor) -> [vec3.Vec3]:
#     """Convert [N, 3] tensor to list of Vec3."""
#     var result = []
#     for i in 0..t.shape()[0]:
#         result.append(vec3.Vec3(t[i, 0].item(), t[i, 1].item(), t[i, 2].item()))
#     result
#
# fn vecs3d_to_tensor(vecs: [vec3.Vec3d], device: torch.Device) -> torch.Tensor:
#     """Convert list of Vec3d to [N, 3] tensor."""
#     var data = []
#     for v in vecs:
#         data.append([v.x, v.y, v.z])
#     torch.tensor(data, dtype: torch.DType.Float64, device: device)
#
# fn tensor_to_vecs3d(t: torch.Tensor) -> [vec3.Vec3d]:
#     """Convert [N, 3] tensor to list of Vec3d."""
#     var result = []
#     for i in 0..t.shape()[0]:
#         result.append(vec3.Vec3d(t[i, 0].item(), t[i, 1].item(), t[i, 2].item()))
#     result

# Placeholder functions until torch is available
fn vecs_to_tensor(vecs: [vec3.Vec3]) -> [f32]:
    """Placeholder: flatten Vec3 list to f32 array."""
    var result: [f32] = []
    for v in vecs:
        result.append(v.x)
        result.append(v.y)
        result.append(v.z)
    result

fn tensor_to_vecs(data: [f32]) -> [vec3.Vec3]:
    """Placeholder: unflatten f32 array to Vec3 list."""
    var result: [vec3.Vec3] = []
    var i = 0
    while i + 2 < data.len():
        result.append(vec3.Vec3(data[i], data[i + 1], data[i + 2]))
        i = i + 3
    result

fn vecs3d_to_tensor(vecs: [vec3.Vec3d]) -> [f64]:
    """Placeholder: flatten Vec3d list to f64 array."""
    var result: [f64] = []
    for v in vecs:
        result.append(v.x)
        result.append(v.y)
        result.append(v.z)
    result

fn tensor_to_vecs3d(data: [f64]) -> [vec3.Vec3d]:
    """Placeholder: unflatten f64 array to Vec3d list."""
    var result: [vec3.Vec3d] = []
    var i = 0
    while i + 2 < data.len():
        result.append(vec3.Vec3d(data[i], data[i + 1], data[i + 2]))
        i = i + 3
    result
