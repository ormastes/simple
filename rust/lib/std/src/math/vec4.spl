# Math Vec4 - 4D Vectors
#
# Vec4 (f32) and Vec4d (f64) for 4D math operations.

export Vec4, Vec4d


# ============================================================================
# Vec4 - 4D Vector (f32)
# ============================================================================

class Vec4:
    """4D vector with f32 precision."""
    x: f32
    y: f32
    z: f32
    w: f32

    fn __init__(x: f32, y: f32, z: f32, w: f32):
        self.x = x
        self.y = y
        self.z = z
        self.w = w

    static fn zero() -> Vec4:
        Vec4(0.0, 0.0, 0.0, 0.0)

    static fn one() -> Vec4:
        Vec4(1.0, 1.0, 1.0, 1.0)

    fn add(other: Vec4) -> Vec4:
        Vec4(self.x + other.x, self.y + other.y, self.z + other.z, self.w + other.w)

    fn sub(other: Vec4) -> Vec4:
        Vec4(self.x - other.x, self.y - other.y, self.z - other.z, self.w - other.w)

    fn scale(scalar: f32) -> Vec4:
        Vec4(self.x * scalar, self.y * scalar, self.z * scalar, self.w * scalar)

    fn dot(other: Vec4) -> f32:
        self.x * other.x + self.y * other.y + self.z * other.z + self.w * other.w

    fn magnitude() -> f32:
        (self.x * self.x + self.y * self.y + self.z * self.z + self.w * self.w).sqrt()

    fn length() -> f32:
        self.magnitude()

    fn length_squared() -> f32:
        self.x * self.x + self.y * self.y + self.z * self.z + self.w * self.w

    fn normalize() -> Vec4:
        val mag = self.magnitude()
        if mag > 0.0:
            return self.scale(1.0 / mag)
        Vec4(0.0, 0.0, 0.0, 0.0)

    fn lerp(other: Vec4, t: f32) -> Vec4:
        Vec4(
            self.x + (other.x - self.x) * t,
            self.y + (other.y - self.y) * t,
            self.z + (other.z - self.z) * t,
            self.w + (other.w - self.w) * t
        )

    fn is_zero() -> bool:
        self.x == 0.0 and self.y == 0.0 and self.z == 0.0 and self.w == 0.0

    fn is_near_zero(epsilon: f32 = 1e-6) -> bool:
        self.magnitude() < epsilon

    fn is_finite() -> bool:
        self.x.is_finite() and self.y.is_finite() and self.z.is_finite() and self.w.is_finite()

    fn to_f64() -> Vec4d:
        Vec4d(self.x as f64, self.y as f64, self.z as f64, self.w as f64)


# ============================================================================
# Vec4d - 4D Vector (f64)
# ============================================================================

class Vec4d:
    """4D vector with f64 precision."""
    x: f64
    y: f64
    z: f64
    w: f64

    fn __init__(x: f64, y: f64, z: f64, w: f64):
        self.x = x
        self.y = y
        self.z = z
        self.w = w

    static fn zero() -> Vec4d:
        Vec4d(0.0, 0.0, 0.0, 0.0)

    static fn one() -> Vec4d:
        Vec4d(1.0, 1.0, 1.0, 1.0)

    fn add(other: Vec4d) -> Vec4d:
        Vec4d(self.x + other.x, self.y + other.y, self.z + other.z, self.w + other.w)

    fn sub(other: Vec4d) -> Vec4d:
        Vec4d(self.x - other.x, self.y - other.y, self.z - other.z, self.w - other.w)

    fn scale(scalar: f64) -> Vec4d:
        Vec4d(self.x * scalar, self.y * scalar, self.z * scalar, self.w * scalar)

    fn dot(other: Vec4d) -> f64:
        self.x * other.x + self.y * other.y + self.z * other.z + self.w * other.w

    fn magnitude() -> f64:
        (self.x * self.x + self.y * self.y + self.z * self.z + self.w * self.w).sqrt()

    fn length() -> f64:
        self.magnitude()

    fn length_squared() -> f64:
        self.x * self.x + self.y * self.y + self.z * self.z + self.w * self.w

    fn normalize() -> Vec4d:
        val mag = self.magnitude()
        if mag > 0.0:
            return self.scale(1.0 / mag)
        Vec4d(0.0, 0.0, 0.0, 0.0)

    fn lerp(other: Vec4d, t: f64) -> Vec4d:
        Vec4d(
            self.x + (other.x - self.x) * t,
            self.y + (other.y - self.y) * t,
            self.z + (other.z - self.z) * t,
            self.w + (other.w - self.w) * t
        )

    fn is_zero() -> bool:
        self.x == 0.0 and self.y == 0.0 and self.z == 0.0 and self.w == 0.0

    fn is_near_zero(epsilon: f64 = 1e-12) -> bool:
        self.magnitude() < epsilon

    fn is_finite() -> bool:
        self.x.is_finite() and self.y.is_finite() and self.z.is_finite() and self.w.is_finite()

    fn to_f32() -> Vec4:
        Vec4(self.x as f32, self.y as f32, self.z as f32, self.w as f32)
