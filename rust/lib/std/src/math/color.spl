# Math Color - Color types
#
# Color (f32 RGBA) and Color32 (u8 RGBA) for rendering.

export Color, Color32


# ============================================================================
# Color - RGBA (f32, 0.0-1.0)
# ============================================================================

class Color:
    """RGBA color with f32 components (0.0 to 1.0)."""
    r: f32
    g: f32
    b: f32
    a: f32

    fn __init__(r: f32, g: f32, b: f32, a: f32 = 1.0):
        self.r = r
        self.g = g
        self.b = b
        self.a = a

    static fn red() -> Color:
        Color(1.0, 0.0, 0.0, 1.0)

    static fn green() -> Color:
        Color(0.0, 1.0, 0.0, 1.0)

    static fn blue() -> Color:
        Color(0.0, 0.0, 1.0, 1.0)

    static fn white() -> Color:
        Color(1.0, 1.0, 1.0, 1.0)

    static fn black() -> Color:
        Color(0.0, 0.0, 0.0, 1.0)

    static fn transparent() -> Color:
        Color(0.0, 0.0, 0.0, 0.0)

    fn lerp(other: Color, t: f32) -> Color:
        Color(
            self.r + (other.r - self.r) * t,
            self.g + (other.g - self.g) * t,
            self.b + (other.b - self.b) * t,
            self.a + (other.a - self.a) * t
        )

    fn to_hex() -> text:
        """Convert to hex string (e.g., '#FF0000FF')."""
        val ri = (self.r * 255.0) as u8
        val gi = (self.g * 255.0) as u8
        val bi = (self.b * 255.0) as u8
        val ai = (self.a * 255.0) as u8
        "#{ri:02X}{gi:02X}{bi:02X}{ai:02X}"

    static fn from_hex(hex: text) -> Color:
        """Parse hex color string (e.g., '#FF0000' or '#FF0000FF')."""
        # Strip leading #
        val h = if hex[0] == '#' { hex[1:] } else { hex }
        val r = i64.from_hex(h[0:2]) as f32 / 255.0
        val g = i64.from_hex(h[2:4]) as f32 / 255.0
        val b = i64.from_hex(h[4:6]) as f32 / 255.0
        val a = if h.len() >= 8 { i64.from_hex(h[6:8]) as f32 / 255.0 } else { 1.0 }
        Color(r, g, b, a)

    fn to_color32() -> Color32:
        Color32(
            (self.r * 255.0) as u8,
            (self.g * 255.0) as u8,
            (self.b * 255.0) as u8,
            (self.a * 255.0) as u8
        )


# ============================================================================
# Color32 - RGBA (u8, 0-255)
# ============================================================================

class Color32:
    """RGBA color with u8 components (0 to 255)."""
    r: u8
    g: u8
    b: u8
    a: u8

    fn __init__(r: u8, g: u8, b: u8, a: u8 = 255):
        self.r = r
        self.g = g
        self.b = b
        self.a = a

    static fn red() -> Color32:
        Color32(255, 0, 0, 255)

    static fn green() -> Color32:
        Color32(0, 255, 0, 255)

    static fn blue() -> Color32:
        Color32(0, 0, 255, 255)

    static fn white() -> Color32:
        Color32(255, 255, 255, 255)

    static fn black() -> Color32:
        Color32(0, 0, 0, 255)

    fn to_color() -> Color:
        Color(
            self.r as f32 / 255.0,
            self.g as f32 / 255.0,
            self.b as f32 / 255.0,
            self.a as f32 / 255.0
        )
