# Math - Unified Math Module
#
# Shared math types for physics, game engine, graphics, and ML.
# All types are available in both f32 and f64 precision.
#
# ## Types
# - `Vec2` / `Vec2d`: 2D vectors
# - `Vec3` / `Vec3d`: 3D vectors
# - `Vec4` / `Vec4d`: 4D vectors
# - `Mat3` / `Mat3d`: 3x3 matrices (column-major)
# - `Mat4` / `Mat4d`: 4x4 matrices (column-major)
# - `Quat` / `Quatd`: Quaternions
# - `Transform` / `Transformd`: Position + rotation + scale
# - `Color` / `Color32`: RGBA colors
#
# ## Aliases (backward compat with physics)
# - `Vector2` = `Vec2d`, `Vector3` = `Vec3d`
# - `Matrix3` = `Mat3d`, `Matrix4` = `Mat4d`
# - `Quaternion` = `Quatd`
#
# ## Design Decisions
# - Column-major matrices (GPU/Vulkan standard)
# - Operators primary, named methods as aliases
# - Approximate float equality (epsilon = 1e-6 for f32, 1e-12 for f64)
#
# ## Example
# ```simple
# use math
#
# val pos = math.Vec3(1.0, 2.0, 3.0)
# val dir = math.Vec3.forward()
# val rot = math.Quat.from_axis_angle(math.Vec3.up(), 1.57)
# val rotated = rot.rotate_vector(pos)
#
# val t = math.Transform.identity()
# val mat = t.to_mat4()
# ```

export Vec2, Vec2d, Vec3, Vec3d, Vec4, Vec4d, Mat3, Mat3d, Mat4, Mat4d, Quat, Quatd, Transform, Transformd, Color, Color32, vecs_to_tensor, tensor_to_vecs, vecs3d_to_tensor, tensor_to_vecs3d


# ============================================================================
# Traits - Common interfaces for math types
# ============================================================================

# VecLike trait
# Common interface for vector types
# TODO: Traits disabled - interpreter doesn't support trait definitions yet
# trait VecLike:
#     fn magnitude() -> f64
#     fn normalize() -> Self
#     fn dot(other: Self) -> f64
#     fn lerp(other: Self, t: f64) -> Self
#     fn is_zero() -> bool
#     fn is_near_zero(epsilon: f64) -> bool
#     fn is_finite() -> bool
#
# trait TensorConvertible:
#     fn to_tensor(device: torch.Device) -> torch.Tensor
#     static fn from_tensor(t: torch.Tensor) -> Self


# ============================================================================
# Vec2 - 2D Vector (f32)
# ============================================================================

class Vec2:
    """2D vector with f32 precision."""
    x: f32
    y: f32

    fn __init__(x: f32, y: f32):
        self.x = x
        self.y = y

    static fn zero() -> Vec2:
        Vec2(0.0, 0.0)

    static fn one() -> Vec2:
        Vec2(1.0, 1.0)

    me add(other: Vec2) -> Vec2:
        Vec2(self.x + other.x, self.y + other.y)

    me sub(other: Vec2) -> Vec2:
        Vec2(self.x - other.x, self.y - other.y)

    me scale(scalar: f32) -> Vec2:
        Vec2(self.x * scalar, self.y * scalar)

    fn dot(other: Vec2) -> f32:
        self.x * other.x + self.y * other.y

    fn magnitude() -> f32:
        (self.x * self.x + self.y * self.y).sqrt()

    fn length() -> f32:
        """Alias for magnitude."""
        self.magnitude()

    fn length_squared() -> f32:
        self.x * self.x + self.y * self.y

    me normalize() -> Vec2:
        val mag = self.magnitude()
        if mag > 0.0:
            return self.scale(1.0 / mag)
        Vec2(0.0, 0.0)

    me distance(other: Vec2) -> f32:
        self.sub(other).magnitude()

    me distance_to(other: Vec2) -> f32:
        """Alias for distance."""
        self.distance(other)

    me lerp(other: Vec2, t: f32) -> Vec2:
        Vec2(
            self.x + (other.x - self.x) * t,
            self.y + (other.y - self.y) * t
        )

    fn is_zero() -> bool:
        self.x == 0.0 and self.y == 0.0

    fn is_near_zero(epsilon: f32 = 1e-6) -> bool:
        self.magnitude() < epsilon

    fn is_finite() -> bool:
        self.x.is_finite() and self.y.is_finite()

    me component_min(other: Vec2) -> Vec2:
        Vec2(
            if self.x < other.x { self.x } else { other.x },
            if self.y < other.y { self.y } else { other.y }
        )

    me component_max(other: Vec2) -> Vec2:
        Vec2(
            if self.x > other.x { self.x } else { other.x },
            if self.y > other.y { self.y } else { other.y }
        )

    me to_f64() -> Vec2d:
        Vec2d(self.x as f64, self.y as f64)


# ============================================================================
# Vec2d - 2D Vector (f64)
# ============================================================================

class Vec2d:
    """2D vector with f64 precision."""
    x: f64
    y: f64

    fn __init__(x: f64, y: f64):
        self.x = x
        self.y = y

    static fn zero() -> Vec2d:
        Vec2d(0.0, 0.0)

    static fn one() -> Vec2d:
        Vec2d(1.0, 1.0)

    me add(other: Vec2d) -> Vec2d:
        Vec2d(self.x + other.x, self.y + other.y)

    me sub(other: Vec2d) -> Vec2d:
        Vec2d(self.x - other.x, self.y - other.y)

    me scale(scalar: f64) -> Vec2d:
        Vec2d(self.x * scalar, self.y * scalar)

    fn dot(other: Vec2d) -> f64:
        self.x * other.x + self.y * other.y

    fn magnitude() -> f64:
        (self.x * self.x + self.y * self.y).sqrt()

    fn length() -> f64:
        self.magnitude()

    fn length_squared() -> f64:
        self.x * self.x + self.y * self.y

    me normalize() -> Vec2d:
        val mag = self.magnitude()
        if mag > 0.0:
            return self.scale(1.0 / mag)
        Vec2d(0.0, 0.0)

    me distance(other: Vec2d) -> f64:
        self.sub(other).magnitude()

    me distance_to(other: Vec2d) -> f64:
        self.distance(other)

    me lerp(other: Vec2d, t: f64) -> Vec2d:
        Vec2d(
            self.x + (other.x - self.x) * t,
            self.y + (other.y - self.y) * t
        )

    fn is_zero() -> bool:
        self.x == 0.0 and self.y == 0.0

    fn is_near_zero(epsilon: f64 = 1e-12) -> bool:
        self.magnitude() < epsilon

    fn is_finite() -> bool:
        self.x.is_finite() and self.y.is_finite()

    me component_min(other: Vec2d) -> Vec2d:
        Vec2d(
            if self.x < other.x { self.x } else { other.x },
            if self.y < other.y { self.y } else { other.y }
        )

    me component_max(other: Vec2d) -> Vec2d:
        Vec2d(
            if self.x > other.x { self.x } else { other.x },
            if self.y > other.y { self.y } else { other.y }
        )

    me to_f32() -> Vec2:
        Vec2(self.x as f32, self.y as f32)


# ============================================================================
# Vec3 - 3D Vector (f32)
# ============================================================================

class Vec3:
    """3D vector with f32 precision."""
    x: f32
    y: f32
    z: f32

    fn __init__(x: f32, y: f32, z: f32):
        self.x = x
        self.y = y
        self.z = z

    # Statics
    static fn zero() -> Vec3:
        Vec3(0.0, 0.0, 0.0)

    static fn one() -> Vec3:
        Vec3(1.0, 1.0, 1.0)

    static fn up() -> Vec3:
        Vec3(0.0, 1.0, 0.0)

    static fn down() -> Vec3:
        Vec3(0.0, -1.0, 0.0)

    static fn left() -> Vec3:
        Vec3(-1.0, 0.0, 0.0)

    static fn right() -> Vec3:
        Vec3(1.0, 0.0, 0.0)

    static fn forward() -> Vec3:
        Vec3(0.0, 0.0, 1.0)

    static fn back() -> Vec3:
        Vec3(0.0, 0.0, -1.0)

    # Arithmetic
    me add(other: Vec3) -> Vec3:
        Vec3(self.x + other.x, self.y + other.y, self.z + other.z)

    me sub(other: Vec3) -> Vec3:
        Vec3(self.x - other.x, self.y - other.y, self.z - other.z)

    me scale(scalar: f32) -> Vec3:
        Vec3(self.x * scalar, self.y * scalar, self.z * scalar)

    fn dot(other: Vec3) -> f32:
        self.x * other.x + self.y * other.y + self.z * other.z

    me cross(other: Vec3) -> Vec3:
        Vec3(
            self.y * other.z - self.z * other.y,
            self.z * other.x - self.x * other.z,
            self.x * other.y - self.y * other.x
        )

    fn magnitude() -> f32:
        (self.x * self.x + self.y * self.y + self.z * self.z).sqrt()

    fn length() -> f32:
        self.magnitude()

    fn length_squared() -> f32:
        self.x * self.x + self.y * self.y + self.z * self.z

    me normalize() -> Vec3:
        val mag = self.magnitude()
        if mag > 0.0:
            return self.scale(1.0 / mag)
        Vec3(0.0, 0.0, 0.0)

    me distance(other: Vec3) -> f32:
        self.sub(other).magnitude()

    me distance_to(other: Vec3) -> f32:
        self.distance(other)

    me lerp(other: Vec3, t: f32) -> Vec3:
        Vec3(
            self.x + (other.x - self.x) * t,
            self.y + (other.y - self.y) * t,
            self.z + (other.z - self.z) * t
        )

    fn is_zero() -> bool:
        self.x == 0.0 and self.y == 0.0 and self.z == 0.0

    fn is_near_zero(epsilon: f32 = 1e-6) -> bool:
        self.magnitude() < epsilon

    fn is_finite() -> bool:
        self.x.is_finite() and self.y.is_finite() and self.z.is_finite()

    fn is_unit(epsilon: f32 = 1e-6) -> bool:
        (self.length_squared() - 1.0).abs() < epsilon

    fn has_nan() -> bool:
        self.x.is_nan() or self.y.is_nan() or self.z.is_nan()

    me component_min(other: Vec3) -> Vec3:
        Vec3(
            if self.x < other.x { self.x } else { other.x },
            if self.y < other.y { self.y } else { other.y },
            if self.z < other.z { self.z } else { other.z }
        )

    me component_max(other: Vec3) -> Vec3:
        Vec3(
            if self.x > other.x { self.x } else { other.x },
            if self.y > other.y { self.y } else { other.y },
            if self.z > other.z { self.z } else { other.z }
        )

    me to_f64() -> Vec3d:
        Vec3d(self.x as f64, self.y as f64, self.z as f64)


# ============================================================================
# Vec3d - 3D Vector (f64)
# ============================================================================

class Vec3d:
    """3D vector with f64 precision."""
    x: f64
    y: f64
    z: f64

    fn __init__(x: f64, y: f64, z: f64):
        self.x = x
        self.y = y
        self.z = z

    static fn zero() -> Vec3d:
        Vec3d(0.0, 0.0, 0.0)

    static fn create(x: f64, y: f64, z: f64) -> Vec3d:
        Vec3d(x, y, z)

    static fn one() -> Vec3d:
        Vec3d(1.0, 1.0, 1.0)

    static fn up() -> Vec3d:
        Vec3d(0.0, 1.0, 0.0)

    static fn down() -> Vec3d:
        Vec3d(0.0, -1.0, 0.0)

    static fn left() -> Vec3d:
        Vec3d(-1.0, 0.0, 0.0)

    static fn right() -> Vec3d:
        Vec3d(1.0, 0.0, 0.0)

    static fn forward() -> Vec3d:
        Vec3d(0.0, 0.0, 1.0)

    static fn back() -> Vec3d:
        Vec3d(0.0, 0.0, -1.0)

    me add(other: Vec3d) -> Vec3d:
        Vec3d(self.x + other.x, self.y + other.y, self.z + other.z)

    me sub(other: Vec3d) -> Vec3d:
        Vec3d(self.x - other.x, self.y - other.y, self.z - other.z)

    me scale(scalar: f64) -> Vec3d:
        Vec3d(self.x * scalar, self.y * scalar, self.z * scalar)

    fn dot(other: Vec3d) -> f64:
        self.x * other.x + self.y * other.y + self.z * other.z

    me cross(other: Vec3d) -> Vec3d:
        Vec3d(
            self.y * other.z - self.z * other.y,
            self.z * other.x - self.x * other.z,
            self.x * other.y - self.y * other.x
        )

    fn magnitude() -> f64:
        (self.x * self.x + self.y * self.y + self.z * self.z).sqrt()

    fn length() -> f64:
        self.magnitude()

    fn length_squared() -> f64:
        self.x * self.x + self.y * self.y + self.z * self.z

    me normalize() -> Vec3d:
        val mag = self.magnitude()
        if mag > 0.0:
            return self.scale(1.0 / mag)
        Vec3d(0.0, 0.0, 0.0)

    me distance(other: Vec3d) -> f64:
        self.sub(other).magnitude()

    me distance_to(other: Vec3d) -> f64:
        self.distance(other)

    me lerp(other: Vec3d, t: f64) -> Vec3d:
        Vec3d(
            self.x + (other.x - self.x) * t,
            self.y + (other.y - self.y) * t,
            self.z + (other.z - self.z) * t
        )

    fn is_zero() -> bool:
        self.x == 0.0 and self.y == 0.0 and self.z == 0.0

    fn is_near_zero(epsilon: f64 = 1e-12) -> bool:
        self.magnitude() < epsilon

    fn is_finite() -> bool:
        self.x.is_finite() and self.y.is_finite() and self.z.is_finite()

    fn is_unit(epsilon: f64 = 1e-12) -> bool:
        (self.length_squared() - 1.0).abs() < epsilon

    fn has_nan() -> bool:
        self.x.is_nan() or self.y.is_nan() or self.z.is_nan()

    me component_min(other: Vec3d) -> Vec3d:
        Vec3d(
            if self.x < other.x { self.x } else { other.x },
            if self.y < other.y { self.y } else { other.y },
            if self.z < other.z { self.z } else { other.z }
        )

    me component_max(other: Vec3d) -> Vec3d:
        Vec3d(
            if self.x > other.x { self.x } else { other.x },
            if self.y > other.y { self.y } else { other.y },
            if self.z > other.z { self.z } else { other.z }
        )

    me to_f32() -> Vec3:
        Vec3(self.x as f32, self.y as f32, self.z as f32)


# ============================================================================
# Vec4 - 4D Vector (f32)
# ============================================================================

class Vec4:
    """4D vector with f32 precision."""
    x: f32
    y: f32
    z: f32
    w: f32

    fn __init__(x: f32, y: f32, z: f32, w: f32):
        self.x = x
        self.y = y
        self.z = z
        self.w = w

    static fn zero() -> Vec4:
        Vec4(0.0, 0.0, 0.0, 0.0)

    static fn one() -> Vec4:
        Vec4(1.0, 1.0, 1.0, 1.0)

    me add(other: Vec4) -> Vec4:
        Vec4(self.x + other.x, self.y + other.y, self.z + other.z, self.w + other.w)

    me sub(other: Vec4) -> Vec4:
        Vec4(self.x - other.x, self.y - other.y, self.z - other.z, self.w - other.w)

    me scale(scalar: f32) -> Vec4:
        Vec4(self.x * scalar, self.y * scalar, self.z * scalar, self.w * scalar)

    fn dot(other: Vec4) -> f32:
        self.x * other.x + self.y * other.y + self.z * other.z + self.w * other.w

    fn magnitude() -> f32:
        (self.x * self.x + self.y * self.y + self.z * self.z + self.w * self.w).sqrt()

    fn length() -> f32:
        self.magnitude()

    fn length_squared() -> f32:
        self.x * self.x + self.y * self.y + self.z * self.z + self.w * self.w

    me normalize() -> Vec4:
        val mag = self.magnitude()
        if mag > 0.0:
            return self.scale(1.0 / mag)
        Vec4(0.0, 0.0, 0.0, 0.0)

    me lerp(other: Vec4, t: f32) -> Vec4:
        Vec4(
            self.x + (other.x - self.x) * t,
            self.y + (other.y - self.y) * t,
            self.z + (other.z - self.z) * t,
            self.w + (other.w - self.w) * t
        )

    fn is_zero() -> bool:
        self.x == 0.0 and self.y == 0.0 and self.z == 0.0 and self.w == 0.0

    fn is_near_zero(epsilon: f32 = 1e-6) -> bool:
        self.magnitude() < epsilon

    fn is_finite() -> bool:
        self.x.is_finite() and self.y.is_finite() and self.z.is_finite() and self.w.is_finite()

    me to_f64() -> Vec4d:
        Vec4d(self.x as f64, self.y as f64, self.z as f64, self.w as f64)


# ============================================================================
# Vec4d - 4D Vector (f64)
# ============================================================================

class Vec4d:
    """4D vector with f64 precision."""
    x: f64
    y: f64
    z: f64
    w: f64

    fn __init__(x: f64, y: f64, z: f64, w: f64):
        self.x = x
        self.y = y
        self.z = z
        self.w = w

    static fn zero() -> Vec4d:
        Vec4d(0.0, 0.0, 0.0, 0.0)

    static fn one() -> Vec4d:
        Vec4d(1.0, 1.0, 1.0, 1.0)

    me add(other: Vec4d) -> Vec4d:
        Vec4d(self.x + other.x, self.y + other.y, self.z + other.z, self.w + other.w)

    me sub(other: Vec4d) -> Vec4d:
        Vec4d(self.x - other.x, self.y - other.y, self.z - other.z, self.w - other.w)

    me scale(scalar: f64) -> Vec4d:
        Vec4d(self.x * scalar, self.y * scalar, self.z * scalar, self.w * scalar)

    fn dot(other: Vec4d) -> f64:
        self.x * other.x + self.y * other.y + self.z * other.z + self.w * other.w

    fn magnitude() -> f64:
        (self.x * self.x + self.y * self.y + self.z * self.z + self.w * self.w).sqrt()

    fn length() -> f64:
        self.magnitude()

    fn length_squared() -> f64:
        self.x * self.x + self.y * self.y + self.z * self.z + self.w * self.w

    me normalize() -> Vec4d:
        val mag = self.magnitude()
        if mag > 0.0:
            return self.scale(1.0 / mag)
        Vec4d(0.0, 0.0, 0.0, 0.0)

    me lerp(other: Vec4d, t: f64) -> Vec4d:
        Vec4d(
            self.x + (other.x - self.x) * t,
            self.y + (other.y - self.y) * t,
            self.z + (other.z - self.z) * t,
            self.w + (other.w - self.w) * t
        )

    fn is_zero() -> bool:
        self.x == 0.0 and self.y == 0.0 and self.z == 0.0 and self.w == 0.0

    fn is_near_zero(epsilon: f64 = 1e-12) -> bool:
        self.magnitude() < epsilon

    fn is_finite() -> bool:
        self.x.is_finite() and self.y.is_finite() and self.z.is_finite() and self.w.is_finite()

    me to_f32() -> Vec4:
        Vec4(self.x as f32, self.y as f32, self.z as f32, self.w as f32)


# ============================================================================
# Mat3 - 3x3 Matrix (f32, column-major)
# ============================================================================

class Mat3:
    """3x3 matrix for 2D transformations. Column-major storage."""
    fn __init__(data):
        self.data = data

    static fn identity() -> Mat3:
        Mat3([
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
        ])

    static fn rotation_z(angle: f32) -> Mat3:
        """Create rotation matrix around Z-axis (column-major)."""
        val c = angle.cos()
        val s = angle.sin()
        Mat3([
            c,   s,   0.0,
            -s,  c,   0.0,
            0.0, 0.0, 1.0
        ])

    static fn scale(sx: f32, sy: f32) -> Mat3:
        Mat3([
            sx,  0.0, 0.0,
            0.0, sy,  0.0,
            0.0, 0.0, 1.0
        ])

    me mul(other: Mat3) -> Mat3:
        """Matrix multiplication (self * other)."""
        var result = [0.0; 9]
        for col in 0..3:
            for row in 0..3:
                var sum: f32 = 0.0
                for k in 0..3:
                    sum = sum + self.data[k * 3 + row] * other.data[col * 3 + k]
                result[col * 3 + row] = sum
        Mat3(result)

    me transpose() -> Mat3:
        Mat3([
            self.data[0], self.data[3], self.data[6],
            self.data[1], self.data[4], self.data[7],
            self.data[2], self.data[5], self.data[8]
        ])

    fn determinant() -> f32:
        val a = self.data[0]
        val b = self.data[3]
        val c = self.data[6]
        val d = self.data[1]
        val e = self.data[4]
        val f = self.data[7]
        val g = self.data[2]
        val h = self.data[5]
        val i = self.data[8]
        a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g)

    me transform_vec2(v: Vec2) -> Vec2:
        """Transform a Vec2 (treats as homogeneous [x, y, 1])."""
        val x = self.data[0] * v.x + self.data[3] * v.y + self.data[6]
        val y = self.data[1] * v.x + self.data[4] * v.y + self.data[7]
        Vec2(x, y)


# ============================================================================
# Mat3d - 3x3 Matrix (f64, column-major)
# ============================================================================

class Mat3d:
    """3x3 matrix for 2D transformations. Column-major storage, f64 precision."""
    fn __init__(data):
        self.data = data

    static fn identity() -> Mat3d:
        Mat3d([
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
        ])

    static fn rotation_z(angle: f64) -> Mat3d:
        val c = angle.cos()
        val s = angle.sin()
        Mat3d([
            c,   s,   0.0,
            -s,  c,   0.0,
            0.0, 0.0, 1.0
        ])

    static fn scale(sx: f64, sy: f64) -> Mat3d:
        Mat3d([
            sx,  0.0, 0.0,
            0.0, sy,  0.0,
            0.0, 0.0, 1.0
        ])

    me mul(other: Mat3d) -> Mat3d:
        var result = [0.0; 9]
        for col in 0..3:
            for row in 0..3:
                var sum: f64 = 0.0
                for k in 0..3:
                    sum = sum + self.data[k * 3 + row] * other.data[col * 3 + k]
                result[col * 3 + row] = sum
        Mat3d(result)

    me transpose() -> Mat3d:
        Mat3d([
            self.data[0], self.data[3], self.data[6],
            self.data[1], self.data[4], self.data[7],
            self.data[2], self.data[5], self.data[8]
        ])

    fn determinant() -> f64:
        val a = self.data[0]
        val b = self.data[3]
        val c = self.data[6]
        val d = self.data[1]
        val e = self.data[4]
        val f = self.data[7]
        val g = self.data[2]
        val h = self.data[5]
        val i = self.data[8]
        a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g)


# ============================================================================
# Mat4 - 4x4 Matrix (f32, column-major)
# ============================================================================

class Mat4:
    """4x4 matrix for 3D transformations. Column-major storage."""
    fn __init__(data):
        self.data = data

    static fn identity() -> Mat4:
        Mat4([
            1.0, 0.0, 0.0, 0.0,
            0.0, 1.0, 0.0, 0.0,
            0.0, 0.0, 1.0, 0.0,
            0.0, 0.0, 0.0, 1.0
        ])

    static fn translation(x: f32, y: f32, z: f32) -> Mat4:
        """Create translation matrix (column-major)."""
        Mat4([
            1.0, 0.0, 0.0, 0.0,
            0.0, 1.0, 0.0, 0.0,
            0.0, 0.0, 1.0, 0.0,
            x,   y,   z,   1.0
        ])

    static fn rotation_x(angle: f32) -> Mat4:
        val c = angle.cos()
        val s = angle.sin()
        Mat4([
            1.0, 0.0, 0.0, 0.0,
            0.0, c,   s,   0.0,
            0.0, -s,  c,   0.0,
            0.0, 0.0, 0.0, 1.0
        ])

    static fn rotation_y(angle: f32) -> Mat4:
        val c = angle.cos()
        val s = angle.sin()
        Mat4([
            c,   0.0, -s,  0.0,
            0.0, 1.0, 0.0, 0.0,
            s,   0.0, c,   0.0,
            0.0, 0.0, 0.0, 1.0
        ])

    static fn rotation_z(angle: f32) -> Mat4:
        val c = angle.cos()
        val s = angle.sin()
        Mat4([
            c,   s,   0.0, 0.0,
            -s,  c,   0.0, 0.0,
            0.0, 0.0, 1.0, 0.0,
            0.0, 0.0, 0.0, 1.0
        ])

    static fn scale(sx: f32, sy: f32, sz: f32) -> Mat4:
        Mat4([
            sx,  0.0, 0.0, 0.0,
            0.0, sy,  0.0, 0.0,
            0.0, 0.0, sz,  0.0,
            0.0, 0.0, 0.0, 1.0
        ])

    static fn perspective(fov_y: f32, aspect: f32, near: f32, far: f32) -> Mat4:
        """Create perspective projection matrix."""
        val f = 1.0 / (fov_y * 0.5).tan()
        val nf = 1.0 / (near - far)
        Mat4([
            f / aspect, 0.0, 0.0,                    0.0,
            0.0,        f,   0.0,                    0.0,
            0.0,        0.0, (far + near) * nf,      -1.0,
            0.0,        0.0, 2.0 * far * near * nf,  0.0
        ])

    static fn ortho(left: f32, right: f32, bottom: f32, top: f32, near: f32, far: f32) -> Mat4:
        """Create orthographic projection matrix."""
        val rl = 1.0 / (right - left)
        val tb = 1.0 / (top - bottom)
        val fn_ = 1.0 / (far - near)
        Mat4([
            2.0 * rl,                  0.0,                      0.0,                      0.0,
            0.0,                       2.0 * tb,                 0.0,                      0.0,
            0.0,                       0.0,                      -2.0 * fn_,               0.0,
            -(right + left) * rl,      -(top + bottom) * tb,     -(far + near) * fn_,      1.0
        ])

    static fn look_at(eye: Vec3, center: Vec3, up: Vec3) -> Mat4:
        """Create look-at view matrix."""
        val f = center.sub(eye).normalize()
        val s = f.cross(up).normalize()
        val u = s.cross(f)
        Mat4([
            s.x,             u.x,             -f.x,            0.0,
            s.y,             u.y,             -f.y,            0.0,
            s.z,             u.z,             -f.z,            0.0,
            -s.dot(eye),     -u.dot(eye),     f.dot(eye),      1.0
        ])

    me mul(other: Mat4) -> Mat4:
        """Matrix multiplication (self * other)."""
        var result = [0.0; 16]
        for col in 0..4:
            for row in 0..4:
                var sum: f32 = 0.0
                for k in 0..4:
                    sum = sum + self.data[k * 4 + row] * other.data[col * 4 + k]
                result[col * 4 + row] = sum
        Mat4(result)

    me transpose() -> Mat4:
        var result = [0.0; 16]
        for col in 0..4:
            for row in 0..4:
                result[col * 4 + row] = self.data[row * 4 + col]
        Mat4(result)

    me transform_point(p: Vec3) -> Vec3:
        """Transform a point (w=1)."""
        val x = self.data[0] * p.x + self.data[4] * p.y + self.data[8]  * p.z + self.data[12]
        val y = self.data[1] * p.x + self.data[5] * p.y + self.data[9]  * p.z + self.data[13]
        val z = self.data[2] * p.x + self.data[6] * p.y + self.data[10] * p.z + self.data[14]
        Vec3(x, y, z)

    me transform_vec3(v: Vec3) -> Vec3:
        """Transform a direction vector (w=0)."""
        val x = self.data[0] * v.x + self.data[4] * v.y + self.data[8]  * v.z
        val y = self.data[1] * v.x + self.data[5] * v.y + self.data[9]  * v.z
        val z = self.data[2] * v.x + self.data[6] * v.y + self.data[10] * v.z
        Vec3(x, y, z)

    me to_mat3() -> Mat3:
        """Extract upper-left 3x3 submatrix."""
        Mat3([
            self.data[0], self.data[1], self.data[2],
            self.data[4], self.data[5], self.data[6],
            self.data[8], self.data[9], self.data[10]
        ])

    me inverse() -> Mat4:
        """Compute matrix inverse using cofactor expansion."""
        val d = self.data
        # Compute cofactors for first row
        val c00 = d[5]*(d[10]*d[15]-d[11]*d[14]) - d[9]*(d[6]*d[15]-d[7]*d[14]) + d[13]*(d[6]*d[11]-d[7]*d[10])
        val c01 = -(d[1]*(d[10]*d[15]-d[11]*d[14]) - d[9]*(d[2]*d[15]-d[3]*d[14]) + d[13]*(d[2]*d[11]-d[3]*d[10]))
        val c02 = d[1]*(d[6]*d[15]-d[7]*d[14]) - d[5]*(d[2]*d[15]-d[3]*d[14]) + d[13]*(d[2]*d[7]-d[3]*d[6])
        val c03 = -(d[1]*(d[6]*d[11]-d[7]*d[10]) - d[5]*(d[2]*d[11]-d[3]*d[10]) + d[9]*(d[2]*d[7]-d[3]*d[6]))

        val det = d[0]*c00 + d[4]*c01 + d[8]*c02 + d[12]*c03
        if det.abs() < 1e-10:
            return Mat4.identity()

        val inv_det = 1.0 / det

        # For brevity, return identity if singular; full inverse is complex
        # TODO: Full 4x4 inverse computation
        val c10 = -(d[4]*(d[10]*d[15]-d[11]*d[14]) - d[8]*(d[6]*d[15]-d[7]*d[14]) + d[12]*(d[6]*d[11]-d[7]*d[10]))
        val c11 = d[0]*(d[10]*d[15]-d[11]*d[14]) - d[8]*(d[2]*d[15]-d[3]*d[14]) + d[12]*(d[2]*d[11]-d[3]*d[10])
        val c12 = -(d[0]*(d[6]*d[15]-d[7]*d[14]) - d[4]*(d[2]*d[15]-d[3]*d[14]) + d[12]*(d[2]*d[7]-d[3]*d[6]))
        val c13 = d[0]*(d[6]*d[11]-d[7]*d[10]) - d[4]*(d[2]*d[11]-d[3]*d[10]) + d[8]*(d[2]*d[7]-d[3]*d[6])

        val c20 = d[4]*(d[9]*d[15]-d[11]*d[13]) - d[8]*(d[5]*d[15]-d[7]*d[13]) + d[12]*(d[5]*d[11]-d[7]*d[9])
        val c21 = -(d[0]*(d[9]*d[15]-d[11]*d[13]) - d[8]*(d[1]*d[15]-d[3]*d[13]) + d[12]*(d[1]*d[11]-d[3]*d[9]))
        val c22 = d[0]*(d[5]*d[15]-d[7]*d[13]) - d[4]*(d[1]*d[15]-d[3]*d[13]) + d[12]*(d[1]*d[7]-d[3]*d[5])
        val c23 = -(d[0]*(d[5]*d[11]-d[7]*d[9]) - d[4]*(d[1]*d[11]-d[3]*d[9]) + d[8]*(d[1]*d[7]-d[3]*d[5]))

        val c30 = -(d[4]*(d[9]*d[14]-d[10]*d[13]) - d[8]*(d[5]*d[14]-d[6]*d[13]) + d[12]*(d[5]*d[10]-d[6]*d[9]))
        val c31 = d[0]*(d[9]*d[14]-d[10]*d[13]) - d[8]*(d[1]*d[14]-d[2]*d[13]) + d[12]*(d[1]*d[10]-d[2]*d[9])
        val c32 = -(d[0]*(d[5]*d[14]-d[6]*d[13]) - d[4]*(d[1]*d[14]-d[2]*d[13]) + d[12]*(d[1]*d[6]-d[2]*d[5]))
        val c33 = d[0]*(d[5]*d[10]-d[6]*d[9]) - d[4]*(d[1]*d[10]-d[2]*d[9]) + d[8]*(d[1]*d[6]-d[2]*d[5])

        Mat4([
            c00*inv_det, c01*inv_det, c02*inv_det, c03*inv_det,
            c10*inv_det, c11*inv_det, c12*inv_det, c13*inv_det,
            c20*inv_det, c21*inv_det, c22*inv_det, c23*inv_det,
            c30*inv_det, c31*inv_det, c32*inv_det, c33*inv_det
        ])


# ============================================================================
# Mat4d - 4x4 Matrix (f64, column-major)
# ============================================================================

class Mat4d:
    """4x4 matrix for 3D transformations. Column-major storage, f64 precision."""
    fn __init__(data):
        self.data = data

    static fn identity() -> Mat4d:
        Mat4d([
            1.0, 0.0, 0.0, 0.0,
            0.0, 1.0, 0.0, 0.0,
            0.0, 0.0, 1.0, 0.0,
            0.0, 0.0, 0.0, 1.0
        ])

    static fn translation(x: f64, y: f64, z: f64) -> Mat4d:
        Mat4d([
            1.0, 0.0, 0.0, 0.0,
            0.0, 1.0, 0.0, 0.0,
            0.0, 0.0, 1.0, 0.0,
            x,   y,   z,   1.0
        ])

    static fn rotation_x(angle: f64) -> Mat4d:
        val c = angle.cos()
        val s = angle.sin()
        Mat4d([
            1.0, 0.0, 0.0, 0.0,
            0.0, c,   s,   0.0,
            0.0, -s,  c,   0.0,
            0.0, 0.0, 0.0, 1.0
        ])

    static fn rotation_y(angle: f64) -> Mat4d:
        val c = angle.cos()
        val s = angle.sin()
        Mat4d([
            c,   0.0, -s,  0.0,
            0.0, 1.0, 0.0, 0.0,
            s,   0.0, c,   0.0,
            0.0, 0.0, 0.0, 1.0
        ])

    static fn rotation_z(angle: f64) -> Mat4d:
        val c = angle.cos()
        val s = angle.sin()
        Mat4d([
            c,   s,   0.0, 0.0,
            -s,  c,   0.0, 0.0,
            0.0, 0.0, 1.0, 0.0,
            0.0, 0.0, 0.0, 1.0
        ])

    static fn scale(sx: f64, sy: f64, sz: f64) -> Mat4d:
        Mat4d([
            sx,  0.0, 0.0, 0.0,
            0.0, sy,  0.0, 0.0,
            0.0, 0.0, sz,  0.0,
            0.0, 0.0, 0.0, 1.0
        ])

    me mul(other: Mat4d) -> Mat4d:
        var result = [0.0; 16]
        for col in 0..4:
            for row in 0..4:
                var sum: f64 = 0.0
                for k in 0..4:
                    sum = sum + self.data[k * 4 + row] * other.data[col * 4 + k]
                result[col * 4 + row] = sum
        Mat4d(result)

    me transpose() -> Mat4d:
        var result = [0.0; 16]
        for col in 0..4:
            for row in 0..4:
                result[col * 4 + row] = self.data[row * 4 + col]
        Mat4d(result)

    me transform_point(p: Vec3d) -> Vec3d:
        val x = self.data[0] * p.x + self.data[4] * p.y + self.data[8]  * p.z + self.data[12]
        val y = self.data[1] * p.x + self.data[5] * p.y + self.data[9]  * p.z + self.data[13]
        val z = self.data[2] * p.x + self.data[6] * p.y + self.data[10] * p.z + self.data[14]
        Vec3d(x, y, z)

    me transform_vec3(v: Vec3d) -> Vec3d:
        val x = self.data[0] * v.x + self.data[4] * v.y + self.data[8]  * v.z
        val y = self.data[1] * v.x + self.data[5] * v.y + self.data[9]  * v.z
        val z = self.data[2] * v.x + self.data[6] * v.y + self.data[10] * v.z
        Vec3d(x, y, z)

    me to_mat3() -> Mat3d:
        Mat3d([
            self.data[0], self.data[1], self.data[2],
            self.data[4], self.data[5], self.data[6],
            self.data[8], self.data[9], self.data[10]
        ])


# ============================================================================
# Quat - Quaternion (f32)
# ============================================================================

class Quat:
    """Quaternion for 3D rotations (f32 precision).

    Quaternions avoid gimbal lock and interpolate smoothly.
    Convention: (w, x, y, z) where w is scalar.
    """
    w: f32
    x: f32
    y: f32
    z: f32

    fn __init__(w: f32, x: f32, y: f32, z: f32):
        self.w = w
        self.x = x
        self.y = y
        self.z = z

    static fn identity() -> Quat:
        Quat(1.0, 0.0, 0.0, 0.0)

    static fn from_axis_angle(axis: Vec3, angle: f32) -> Quat:
        val half_angle = angle * 0.5
        val s = half_angle.sin()
        val c = half_angle.cos()
        val n = axis.normalize()
        Quat(c, n.x * s, n.y * s, n.z * s)

    static fn from_euler(pitch: f32, yaw: f32, roll: f32) -> Quat:
        """Create quaternion from Euler angles (radians)."""
        val cp = (pitch * 0.5).cos()
        val sp = (pitch * 0.5).sin()
        val cy = (yaw * 0.5).cos()
        val sy = (yaw * 0.5).sin()
        val cr = (roll * 0.5).cos()
        val sr = (roll * 0.5).sin()
        Quat(
            cr * cp * cy + sr * sp * sy,
            sr * cp * cy - cr * sp * sy,
            cr * sp * cy + sr * cp * sy,
            cr * cp * sy - sr * sp * cy
        )

    fn magnitude() -> f32:
        (self.w * self.w + self.x * self.x + self.y * self.y + self.z * self.z).sqrt()

    me normalize() -> Quat:
        val mag = self.magnitude()
        if mag > 0.0:
            return Quat(self.w / mag, self.x / mag, self.y / mag, self.z / mag)
        Quat.identity()

    me conjugate() -> Quat:
        Quat(self.w, -self.x, -self.y, -self.z)

    me inverse() -> Quat:
        val mag_sq = self.w * self.w + self.x * self.x + self.y * self.y + self.z * self.z
        if mag_sq > 0.0:
            val inv = 1.0 / mag_sq
            return Quat(self.w * inv, -self.x * inv, -self.y * inv, -self.z * inv)
        Quat.identity()

    me mul(other: Quat) -> Quat:
        """Quaternion multiplication (composition of rotations)."""
        Quat(
            self.w * other.w - self.x * other.x - self.y * other.y - self.z * other.z,
            self.w * other.x + self.x * other.w + self.y * other.z - self.z * other.y,
            self.w * other.y - self.x * other.z + self.y * other.w + self.z * other.x,
            self.w * other.z + self.x * other.y - self.y * other.x + self.z * other.w
        )

    me rotate_vector(v: Vec3) -> Vec3:
        """Rotate vector by this quaternion."""
        val qv = Vec3(self.x, self.y, self.z)
        val t = qv.cross(v).scale(2.0)
        v.add(t.scale(self.w)).add(qv.cross(t))

    me slerp(other: Quat, t: f32) -> Quat:
        """Spherical linear interpolation."""
        var cos_half = self.w * other.w + self.x * other.x + self.y * other.y + self.z * other.z
        var target = other
        if cos_half < 0.0:
            target = Quat(-other.w, -other.x, -other.y, -other.z)
            cos_half = -cos_half

        if cos_half > 0.9995:
            # Very close - use linear interpolation
            val result = Quat(
                self.w + (target.w - self.w) * t,
                self.x + (target.x - self.x) * t,
                self.y + (target.y - self.y) * t,
                self.z + (target.z - self.z) * t
            )
            return result.normalize()

        val half_angle = cos_half.acos()
        val sin_half = (1.0 - cos_half * cos_half).sqrt()
        val a = ((1.0 - t) * half_angle).sin() / sin_half
        val b = (t * half_angle).sin() / sin_half

        Quat(
            self.w * a + target.w * b,
            self.x * a + target.x * b,
            self.y * a + target.y * b,
            self.z * a + target.z * b
        )

    me to_mat3() -> Mat3:
        """Convert to 3x3 rotation matrix (column-major)."""
        val xx = self.x * self.x
        val yy = self.y * self.y
        val zz = self.z * self.z
        val xy = self.x * self.y
        val xz = self.x * self.z
        val yz = self.y * self.z
        val wx = self.w * self.x
        val wy = self.w * self.y
        val wz = self.w * self.z
        Mat3([
            1.0 - 2.0 * (yy + zz), 2.0 * (xy + wz),       2.0 * (xz - wy),
            2.0 * (xy - wz),       1.0 - 2.0 * (xx + zz), 2.0 * (yz + wx),
            2.0 * (xz + wy),       2.0 * (yz - wx),       1.0 - 2.0 * (xx + yy)
        ])

    me to_mat4() -> Mat4:
        """Convert to 4x4 rotation matrix (column-major)."""
        val m3 = self.to_mat3()
        Mat4([
            m3.data[0], m3.data[1], m3.data[2], 0.0,
            m3.data[3], m3.data[4], m3.data[5], 0.0,
            m3.data[6], m3.data[7], m3.data[8], 0.0,
            0.0,        0.0,        0.0,        1.0
        ])

    me to_f64() -> Quatd:
        Quatd(self.w as f64, self.x as f64, self.y as f64, self.z as f64)


# ============================================================================
# Quatd - Quaternion (f64)
# ============================================================================

class Quatd:
    """Quaternion for 3D rotations (f64 precision)."""
    w: f64
    x: f64
    y: f64
    z: f64

    fn __init__(w: f64, x: f64, y: f64, z: f64):
        self.w = w
        self.x = x
        self.y = y
        self.z = z

    static fn identity() -> Quatd:
        Quatd(1.0, 0.0, 0.0, 0.0)

    static fn from_axis_angle(axis: Vec3d, angle: f64) -> Quatd:
        val half_angle = angle * 0.5
        val s = half_angle.sin()
        val c = half_angle.cos()
        val n = axis.normalize()
        Quatd(c, n.x * s, n.y * s, n.z * s)

    static fn from_euler(pitch: f64, yaw: f64, roll: f64) -> Quatd:
        val cp = (pitch * 0.5).cos()
        val sp = (pitch * 0.5).sin()
        val cy = (yaw * 0.5).cos()
        val sy = (yaw * 0.5).sin()
        val cr = (roll * 0.5).cos()
        val sr = (roll * 0.5).sin()
        Quatd(
            cr * cp * cy + sr * sp * sy,
            sr * cp * cy - cr * sp * sy,
            cr * sp * cy + sr * cp * sy,
            cr * cp * sy - sr * sp * cy
        )

    fn magnitude() -> f64:
        (self.w * self.w + self.x * self.x + self.y * self.y + self.z * self.z).sqrt()

    me normalize() -> Quatd:
        val mag = self.magnitude()
        if mag > 0.0:
            return Quatd(self.w / mag, self.x / mag, self.y / mag, self.z / mag)
        Quatd.identity()

    me conjugate() -> Quatd:
        Quatd(self.w, -self.x, -self.y, -self.z)

    me inverse() -> Quatd:
        val mag_sq = self.w * self.w + self.x * self.x + self.y * self.y + self.z * self.z
        if mag_sq > 0.0:
            val inv = 1.0 / mag_sq
            return Quatd(self.w * inv, -self.x * inv, -self.y * inv, -self.z * inv)
        Quatd.identity()

    me mul(other: Quatd) -> Quatd:
        Quatd(
            self.w * other.w - self.x * other.x - self.y * other.y - self.z * other.z,
            self.w * other.x + self.x * other.w + self.y * other.z - self.z * other.y,
            self.w * other.y - self.x * other.z + self.y * other.w + self.z * other.x,
            self.w * other.z + self.x * other.y - self.y * other.x + self.z * other.w
        )

    me rotate_vector(v: Vec3d) -> Vec3d:
        val qv = Vec3d(self.x, self.y, self.z)
        val t = qv.cross(v).scale(2.0)
        v.add(t.scale(self.w)).add(qv.cross(t))

    me slerp(other: Quatd, t: f64) -> Quatd:
        var cos_half = self.w * other.w + self.x * other.x + self.y * other.y + self.z * other.z
        var target = other
        if cos_half < 0.0:
            target = Quatd(-other.w, -other.x, -other.y, -other.z)
            cos_half = -cos_half

        if cos_half > 0.9995:
            val result = Quatd(
                self.w + (target.w - self.w) * t,
                self.x + (target.x - self.x) * t,
                self.y + (target.y - self.y) * t,
                self.z + (target.z - self.z) * t
            )
            return result.normalize()

        val half_angle = cos_half.acos()
        val sin_half = (1.0 - cos_half * cos_half).sqrt()
        val a = ((1.0 - t) * half_angle).sin() / sin_half
        val b = (t * half_angle).sin() / sin_half

        Quatd(
            self.w * a + target.w * b,
            self.x * a + target.x * b,
            self.y * a + target.y * b,
            self.z * a + target.z * b
        )

    me to_mat3() -> Mat3d:
        val xx = self.x * self.x
        val yy = self.y * self.y
        val zz = self.z * self.z
        val xy = self.x * self.y
        val xz = self.x * self.z
        val yz = self.y * self.z
        val wx = self.w * self.x
        val wy = self.w * self.y
        val wz = self.w * self.z
        Mat3d([
            1.0 - 2.0 * (yy + zz), 2.0 * (xy + wz),       2.0 * (xz - wy),
            2.0 * (xy - wz),       1.0 - 2.0 * (xx + zz), 2.0 * (yz + wx),
            2.0 * (xz + wy),       2.0 * (yz - wx),       1.0 - 2.0 * (xx + yy)
        ])

    me to_mat4() -> Mat4d:
        val m3 = self.to_mat3()
        Mat4d([
            m3.data[0], m3.data[1], m3.data[2], 0.0,
            m3.data[3], m3.data[4], m3.data[5], 0.0,
            m3.data[6], m3.data[7], m3.data[8], 0.0,
            0.0,        0.0,        0.0,        1.0
        ])

    me to_f32() -> Quat:
        Quat(self.w as f32, self.x as f32, self.y as f32, self.z as f32)


# ============================================================================
# Transform - 3D Transform (f32)
# ============================================================================

class Transform:
    """3D transform combining position, rotation, and scale (f32)."""
    position: Vec3
    rotation: Quat
    scale: Vec3

    fn __init__(position: Vec3, rotation: Quat, scale: Vec3):
        self.position = position
        self.rotation = rotation
        self.scale = scale

    static fn identity() -> Transform:
        Transform(
            position: Vec3.zero(),
            rotation: Quat.identity(),
            scale: Vec3.one()
        )

    me to_mat4() -> Mat4:
        """Convert to 4x4 transformation matrix."""
        val rot_mat = self.rotation.to_mat4()
        val scale_mat = Mat4.scale(self.scale.x, self.scale.y, self.scale.z)
        val trans_mat = Mat4.translation(self.position.x, self.position.y, self.position.z)
        trans_mat.mul(rot_mat.mul(scale_mat))

    me forward() -> Vec3:
        self.rotation.rotate_vector(Vec3.forward())

    me right() -> Vec3:
        self.rotation.rotate_vector(Vec3.right())

    me up() -> Vec3:
        self.rotation.rotate_vector(Vec3.up())

    me inverse() -> Transform:
        val inv_rot = self.rotation.inverse()
        val inv_scale = Vec3(1.0 / self.scale.x, 1.0 / self.scale.y, 1.0 / self.scale.z)
        val inv_pos = inv_rot.rotate_vector(self.position.scale(-1.0))
        Transform(
            position: Vec3(inv_pos.x * inv_scale.x, inv_pos.y * inv_scale.y, inv_pos.z * inv_scale.z),
            rotation: inv_rot,
            scale: inv_scale
        )

    me lerp(other: Transform, t: f32) -> Transform:
        Transform(
            position: self.position.lerp(other.position, t),
            rotation: self.rotation.slerp(other.rotation, t),
            scale: self.scale.lerp(other.scale, t)
        )

    me combine(child: Transform) -> Transform:
        """Combine transforms (parent * child)."""
        val new_rot = self.rotation.mul(child.rotation)
        val scaled_pos = Vec3(
            child.position.x * self.scale.x,
            child.position.y * self.scale.y,
            child.position.z * self.scale.z
        )
        val new_pos = self.position.add(self.rotation.rotate_vector(scaled_pos))
        val new_scale = Vec3(
            self.scale.x * child.scale.x,
            self.scale.y * child.scale.y,
            self.scale.z * child.scale.z
        )
        Transform(position: new_pos, rotation: new_rot, scale: new_scale)

    me transform_point(p: Vec3) -> Vec3:
        val scaled = Vec3(p.x * self.scale.x, p.y * self.scale.y, p.z * self.scale.z)
        self.position.add(self.rotation.rotate_vector(scaled))

    me transform_vector(v: Vec3) -> Vec3:
        val scaled = Vec3(v.x * self.scale.x, v.y * self.scale.y, v.z * self.scale.z)
        self.rotation.rotate_vector(scaled)


# ============================================================================
# Transformd - 3D Transform (f64)
# ============================================================================

class Transformd:
    """3D transform combining position, rotation, and scale (f64)."""
    position: Vec3d
    rotation: Quatd
    scale: Vec3d

    fn __init__(position: Vec3d, rotation: Quatd, scale: Vec3d):
        self.position = position
        self.rotation = rotation
        self.scale = scale

    static fn identity() -> Transformd:
        Transformd(
            position: Vec3d.zero(),
            rotation: Quatd.identity(),
            scale: Vec3d.one()
        )

    me to_mat4() -> Mat4d:
        val rot_mat = self.rotation.to_mat4()
        val scale_mat = Mat4d.scale(self.scale.x, self.scale.y, self.scale.z)
        val trans_mat = Mat4d.translation(self.position.x, self.position.y, self.position.z)
        trans_mat.mul(rot_mat.mul(scale_mat))

    me forward() -> Vec3d:
        self.rotation.rotate_vector(Vec3d.forward())

    me right() -> Vec3d:
        self.rotation.rotate_vector(Vec3d.right())

    me up() -> Vec3d:
        self.rotation.rotate_vector(Vec3d.up())

    me inverse() -> Transformd:
        val inv_rot = self.rotation.inverse()
        val inv_scale = Vec3d(1.0 / self.scale.x, 1.0 / self.scale.y, 1.0 / self.scale.z)
        val inv_pos = inv_rot.rotate_vector(self.position.scale(-1.0))
        Transformd(
            position: Vec3d(inv_pos.x * inv_scale.x, inv_pos.y * inv_scale.y, inv_pos.z * inv_scale.z),
            rotation: inv_rot,
            scale: inv_scale
        )

    me lerp(other: Transformd, t: f64) -> Transformd:
        Transformd(
            position: self.position.lerp(other.position, t),
            rotation: self.rotation.slerp(other.rotation, t),
            scale: self.scale.lerp(other.scale, t)
        )

    me combine(child: Transformd) -> Transformd:
        val new_rot = self.rotation.mul(child.rotation)
        val scaled_pos = Vec3d(
            child.position.x * self.scale.x,
            child.position.y * self.scale.y,
            child.position.z * self.scale.z
        )
        val new_pos = self.position.add(self.rotation.rotate_vector(scaled_pos))
        val new_scale = Vec3d(
            self.scale.x * child.scale.x,
            self.scale.y * child.scale.y,
            self.scale.z * child.scale.z
        )
        Transformd(position: new_pos, rotation: new_rot, scale: new_scale)

    me transform_point(p: Vec3d) -> Vec3d:
        val scaled = Vec3d(p.x * self.scale.x, p.y * self.scale.y, p.z * self.scale.z)
        self.position.add(self.rotation.rotate_vector(scaled))

    me transform_vector(v: Vec3d) -> Vec3d:
        val scaled = Vec3d(v.x * self.scale.x, v.y * self.scale.y, v.z * self.scale.z)
        self.rotation.rotate_vector(scaled)


# ============================================================================
# Color - RGBA (f32, 0.0-1.0)
# ============================================================================

class Color:
    """RGBA color with f32 components (0.0 to 1.0)."""
    r: f32
    g: f32
    b: f32
    a: f32

    fn __init__(r: f32, g: f32, b: f32, a: f32 = 1.0):
        self.r = r
        self.g = g
        self.b = b
        self.a = a

    static fn red() -> Color:
        Color(1.0, 0.0, 0.0, 1.0)

    static fn green() -> Color:
        Color(0.0, 1.0, 0.0, 1.0)

    static fn blue() -> Color:
        Color(0.0, 0.0, 1.0, 1.0)

    static fn white() -> Color:
        Color(1.0, 1.0, 1.0, 1.0)

    static fn black() -> Color:
        Color(0.0, 0.0, 0.0, 1.0)

    static fn transparent() -> Color:
        Color(0.0, 0.0, 0.0, 0.0)

    me lerp(other: Color, t: f32) -> Color:
        Color(
            self.r + (other.r - self.r) * t,
            self.g + (other.g - self.g) * t,
            self.b + (other.b - self.b) * t,
            self.a + (other.a - self.a) * t
        )

    fn to_hex() -> text:
        """Convert to hex string (e.g., '#FF0000FF')."""
        val ri = (self.r * 255.0) as u8
        val gi = (self.g * 255.0) as u8
        val bi = (self.b * 255.0) as u8
        val ai = (self.a * 255.0) as u8
        "#{ri:02X}{gi:02X}{bi:02X}{ai:02X}"

    static fn from_hex(hex: text) -> Color:
        """Parse hex color string (e.g., '#FF0000' or '#FF0000FF')."""
        # Strip leading #
        val h = if hex[0] == '#' { hex[1:] } else { hex }
        val r = i64.from_hex(h[0:2]) as f32 / 255.0
        val g = i64.from_hex(h[2:4]) as f32 / 255.0
        val b = i64.from_hex(h[4:6]) as f32 / 255.0
        val a = if h.len() >= 8 { i64.from_hex(h[6:8]) as f32 / 255.0 } else { 1.0 }
        Color(r, g, b, a)

    me to_color32() -> Color32:
        Color32(
            (self.r * 255.0) as u8,
            (self.g * 255.0) as u8,
            (self.b * 255.0) as u8,
            (self.a * 255.0) as u8
        )


# ============================================================================
# Color32 - RGBA (u8, 0-255)
# ============================================================================

class Color32:
    """RGBA color with u8 components (0 to 255)."""
    r: u8
    g: u8
    b: u8
    a: u8

    fn __init__(r: u8, g: u8, b: u8, a: u8 = 255):
        self.r = r
        self.g = g
        self.b = b
        self.a = a

    static fn red() -> Color32:
        Color32(255, 0, 0, 255)

    static fn green() -> Color32:
        Color32(0, 255, 0, 255)

    static fn blue() -> Color32:
        Color32(0, 0, 255, 255)

    static fn white() -> Color32:
        Color32(255, 255, 255, 255)

    static fn black() -> Color32:
        Color32(0, 0, 0, 255)

    me to_color() -> Color:
        Color(
            self.r as f32 / 255.0,
            self.g as f32 / 255.0,
            self.b as f32 / 255.0,
            self.a as f32 / 255.0
        )


# ============================================================================
# Aliases - Backward compatibility type aliases
# ============================================================================

# Physics module backward compatibility aliases (f64 precision)
# TODO: type aliases not yet supported in interpreter
# type Vector2 = Vec2d
# type Vector3 = Vec3d
# type Matrix3 = Mat3d
# type Matrix4 = Mat4d
# type Quaternion = Quatd


# ============================================================================
# Tensor Bridge - Conversions between math types and tensors
# ============================================================================

# TODO: Re-enable after torch parse issues are fixed
# import ml.torch as torch

# TODO: Uncomment when torch imports work
#
# impl TensorConvertible for Vec3:
#     fn to_tensor(device: torch.Device) -> torch.Tensor:
#         torch.tensor([self.x, self.y, self.z], dtype: torch.DType.Float32, device: device)
#
#     static fn from_tensor(t: torch.Tensor) -> Vec3:
#         Vec3(x: t[0].item(), y: t[1].item(), z: t[2].item())
#
# fn vecs_to_tensor(vecs: [Vec3], device: torch.Device) -> torch.Tensor:
#     """Convert list of Vec3 to [N, 3] tensor."""
#     var data = []
#     for v in vecs:
#         data.append([v.x, v.y, v.z])
#     torch.tensor(data, dtype: torch.DType.Float32, device: device)
#
# fn tensor_to_vecs(t: torch.Tensor) -> [Vec3]:
#     """Convert [N, 3] tensor to list of Vec3."""
#     var result = []
#     for i in 0..t.shape()[0]:
#         result.append(Vec3(t[i, 0].item(), t[i, 1].item(), t[i, 2].item()))
#     result
#
# fn vecs3d_to_tensor(vecs: [Vec3d], device: torch.Device) -> torch.Tensor:
#     """Convert list of Vec3d to [N, 3] tensor."""
#     var data = []
#     for v in vecs:
#         data.append([v.x, v.y, v.z])
#     torch.tensor(data, dtype: torch.DType.Float64, device: device)
#
# fn tensor_to_vecs3d(t: torch.Tensor) -> [Vec3d]:
#     """Convert [N, 3] tensor to list of Vec3d."""
#     var result = []
#     for i in 0..t.shape()[0]:
#         result.append(Vec3d(t[i, 0].item(), t[i, 1].item(), t[i, 2].item()))
#     result

# Placeholder functions until torch is available
fn vecs_to_tensor(vecs):
    """Placeholder: flatten Vec3 list to f32 array."""
    var result = []
    for v in vecs:
        result.append(v.x)
        result.append(v.y)
        result.append(v.z)
    result

fn tensor_to_vecs(data):
    """Placeholder: unflatten f32 array to Vec3 list."""
    var result = []
    var i = 0
    while i + 2 < data.len():
        result.append(Vec3(data[i], data[i + 1], data[i + 2]))
        i = i + 3
    result

fn vecs3d_to_tensor(vecs):
    """Placeholder: flatten Vec3d list to f64 array."""
    var result = []
    for v in vecs:
        result.append(v.x)
        result.append(v.y)
        result.append(v.z)
    result

fn tensor_to_vecs3d(data):
    """Placeholder: unflatten f64 array to Vec3d list."""
    var result = []
    var i = 0
    while i + 2 < data.len():
        result.append(Vec3d(data[i], data[i + 1], data[i + 2]))
        i = i + 3
    result
