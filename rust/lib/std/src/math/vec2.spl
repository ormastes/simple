# Math Vec2 - 2D Vectors
#
# Vec2 (f32) and Vec2d (f64) for 2D math operations.

export Vec2, Vec2d


# ============================================================================
# Vec2 - 2D Vector (f32)
# ============================================================================

class Vec2:
    """2D vector with f32 precision."""
    x: f32
    y: f32

    fn __init__(x: f32, y: f32):
        self.x = x
        self.y = y

    static fn zero() -> Vec2:
        Vec2(0.0, 0.0)

    static fn one() -> Vec2:
        Vec2(1.0, 1.0)

    fn add(other: Vec2) -> Vec2:
        Vec2(self.x + other.x, self.y + other.y)

    fn sub(other: Vec2) -> Vec2:
        Vec2(self.x - other.x, self.y - other.y)

    fn scale(scalar: f32) -> Vec2:
        Vec2(self.x * scalar, self.y * scalar)

    fn dot(other: Vec2) -> f32:
        self.x * other.x + self.y * other.y

    fn magnitude() -> f32:
        (self.x * self.x + self.y * self.y).sqrt()

    fn length() -> f32:
        """Alias for magnitude."""
        self.magnitude()

    fn length_squared() -> f32:
        self.x * self.x + self.y * self.y

    fn normalize() -> Vec2:
        val mag = self.magnitude()
        if mag > 0.0:
            return self.scale(1.0 / mag)
        Vec2(0.0, 0.0)

    fn distance(other: Vec2) -> f32:
        self.sub(other).magnitude()

    fn distance_to(other: Vec2) -> f32:
        """Alias for distance."""
        self.distance(other)

    fn lerp(other: Vec2, t: f32) -> Vec2:
        Vec2(
            self.x + (other.x - self.x) * t,
            self.y + (other.y - self.y) * t
        )

    fn is_zero() -> bool:
        self.x == 0.0 and self.y == 0.0

    fn is_near_zero(epsilon: f32 = 1e-6) -> bool:
        self.magnitude() < epsilon

    fn is_finite() -> bool:
        self.x.is_finite() and self.y.is_finite()

    fn component_min(other: Vec2) -> Vec2:
        Vec2(
            if self.x < other.x { self.x } else { other.x },
            if self.y < other.y { self.y } else { other.y }
        )

    fn component_max(other: Vec2) -> Vec2:
        Vec2(
            if self.x > other.x { self.x } else { other.x },
            if self.y > other.y { self.y } else { other.y }
        )

    fn to_f64() -> Vec2d:
        Vec2d(self.x as f64, self.y as f64)


# ============================================================================
# Vec2d - 2D Vector (f64)
# ============================================================================

class Vec2d:
    """2D vector with f64 precision."""
    x: f64
    y: f64

    fn __init__(x: f64, y: f64):
        self.x = x
        self.y = y

    static fn zero() -> Vec2d:
        Vec2d(0.0, 0.0)

    static fn one() -> Vec2d:
        Vec2d(1.0, 1.0)

    fn add(other: Vec2d) -> Vec2d:
        Vec2d(self.x + other.x, self.y + other.y)

    fn sub(other: Vec2d) -> Vec2d:
        Vec2d(self.x - other.x, self.y - other.y)

    fn scale(scalar: f64) -> Vec2d:
        Vec2d(self.x * scalar, self.y * scalar)

    fn dot(other: Vec2d) -> f64:
        self.x * other.x + self.y * other.y

    fn magnitude() -> f64:
        (self.x * self.x + self.y * self.y).sqrt()

    fn length() -> f64:
        self.magnitude()

    fn length_squared() -> f64:
        self.x * self.x + self.y * self.y

    fn normalize() -> Vec2d:
        val mag = self.magnitude()
        if mag > 0.0:
            return self.scale(1.0 / mag)
        Vec2d(0.0, 0.0)

    fn distance(other: Vec2d) -> f64:
        self.sub(other).magnitude()

    fn distance_to(other: Vec2d) -> f64:
        self.distance(other)

    fn lerp(other: Vec2d, t: f64) -> Vec2d:
        Vec2d(
            self.x + (other.x - self.x) * t,
            self.y + (other.y - self.y) * t
        )

    fn is_zero() -> bool:
        self.x == 0.0 and self.y == 0.0

    fn is_near_zero(epsilon: f64 = 1e-12) -> bool:
        self.magnitude() < epsilon

    fn is_finite() -> bool:
        self.x.is_finite() and self.y.is_finite()

    fn component_min(other: Vec2d) -> Vec2d:
        Vec2d(
            if self.x < other.x { self.x } else { other.x },
            if self.y < other.y { self.y } else { other.y }
        )

    fn component_max(other: Vec2d) -> Vec2d:
        Vec2d(
            if self.x > other.x { self.x } else { other.x },
            if self.y > other.y { self.y } else { other.y }
        )

    fn to_f32() -> Vec2:
        Vec2(self.x as f32, self.y as f32)
