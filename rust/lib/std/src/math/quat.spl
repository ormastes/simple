# Math Quat - Quaternions
#
# Quat (f32) and Quatd (f64) for 3D rotations.

export Quat, Quatd


# ============================================================================
# Quat - Quaternion (f32)
# ============================================================================

class Quat:
    """Quaternion for 3D rotations (f32 precision).

    Quaternions avoid gimbal lock and interpolate smoothly.
    Convention: (w, x, y, z) where w is scalar.
    """
    w: f32
    x: f32
    y: f32
    z: f32

    fn __init__(w: f32, x: f32, y: f32, z: f32):
        self.w = w
        self.x = x
        self.y = y
        self.z = z

    static fn identity() -> Quat:
        Quat(1.0, 0.0, 0.0, 0.0)

    static fn from_axis_angle(axis: Vec3, angle: f32) -> Quat:
        use .vec3.Vec3
        val half_angle = angle * 0.5
        val s = half_angle.sin()
        val c = half_angle.cos()
        val n = axis.normalize()
        Quat(c, n.x * s, n.y * s, n.z * s)

    static fn from_euler(pitch: f32, yaw: f32, roll: f32) -> Quat:
        """Create quaternion from Euler angles (radians)."""
        val cp = (pitch * 0.5).cos()
        val sp = (pitch * 0.5).sin()
        val cy = (yaw * 0.5).cos()
        val sy = (yaw * 0.5).sin()
        val cr = (roll * 0.5).cos()
        val sr = (roll * 0.5).sin()
        Quat(
            cr * cp * cy + sr * sp * sy,
            sr * cp * cy - cr * sp * sy,
            cr * sp * cy + sr * cp * sy,
            cr * cp * sy - sr * sp * cy
        )

    fn magnitude() -> f32:
        (self.w * self.w + self.x * self.x + self.y * self.y + self.z * self.z).sqrt()

    fn normalize() -> Quat:
        val mag = self.magnitude()
        if mag > 0.0:
            return Quat(self.w / mag, self.x / mag, self.y / mag, self.z / mag)
        Quat.identity()

    fn conjugate() -> Quat:
        Quat(self.w, -self.x, -self.y, -self.z)

    fn inverse() -> Quat:
        val mag_sq = self.w * self.w + self.x * self.x + self.y * self.y + self.z * self.z
        if mag_sq > 0.0:
            val inv = 1.0 / mag_sq
            return Quat(self.w * inv, -self.x * inv, -self.y * inv, -self.z * inv)
        Quat.identity()

    fn mul(other: Quat) -> Quat:
        """Quaternion multiplication (composition of rotations)."""
        Quat(
            self.w * other.w - self.x * other.x - self.y * other.y - self.z * other.z,
            self.w * other.x + self.x * other.w + self.y * other.z - self.z * other.y,
            self.w * other.y - self.x * other.z + self.y * other.w + self.z * other.x,
            self.w * other.z + self.x * other.y - self.y * other.x + self.z * other.w
        )

    fn rotate_vector(v: Vec3) -> Vec3:
        """Rotate vector by this quaternion."""
        use .vec3.Vec3
        val qv = Vec3(self.x, self.y, self.z)
        val t = qv.cross(v).scale(2.0)
        v.add(t.scale(self.w)).add(qv.cross(t))

    fn slerp(other: Quat, t: f32) -> Quat:
        """Spherical linear interpolation."""
        var cos_half = self.w * other.w + self.x * other.x + self.y * other.y + self.z * other.z
        var target = other
        if cos_half < 0.0:
            target = Quat(-other.w, -other.x, -other.y, -other.z)
            cos_half = -cos_half

        if cos_half > 0.9995:
            # Very close - use linear interpolation
            val result = Quat(
                self.w + (target.w - self.w) * t,
                self.x + (target.x - self.x) * t,
                self.y + (target.y - self.y) * t,
                self.z + (target.z - self.z) * t
            )
            return result.normalize()

        val half_angle = cos_half.acos()
        val sin_half = (1.0 - cos_half * cos_half).sqrt()
        val a = ((1.0 - t) * half_angle).sin() / sin_half
        val b = (t * half_angle).sin() / sin_half

        Quat(
            self.w * a + target.w * b,
            self.x * a + target.x * b,
            self.y * a + target.y * b,
            self.z * a + target.z * b
        )

    fn to_mat3() -> Mat3:
        """Convert to 3x3 rotation matrix (column-major)."""
        use .mat3.Mat3
        val xx = self.x * self.x
        val yy = self.y * self.y
        val zz = self.z * self.z
        val xy = self.x * self.y
        val xz = self.x * self.z
        val yz = self.y * self.z
        val wx = self.w * self.x
        val wy = self.w * self.y
        val wz = self.w * self.z
        Mat3([
            1.0 - 2.0 * (yy + zz), 2.0 * (xy + wz),       2.0 * (xz - wy),
            2.0 * (xy - wz),       1.0 - 2.0 * (xx + zz), 2.0 * (yz + wx),
            2.0 * (xz + wy),       2.0 * (yz - wx),       1.0 - 2.0 * (xx + yy)
        ])

    fn to_mat4() -> Mat4:
        """Convert to 4x4 rotation matrix (column-major)."""
        use .mat4.Mat4
        val m3 = self.to_mat3()
        Mat4([
            m3.data[0], m3.data[1], m3.data[2], 0.0,
            m3.data[3], m3.data[4], m3.data[5], 0.0,
            m3.data[6], m3.data[7], m3.data[8], 0.0,
            0.0,        0.0,        0.0,        1.0
        ])

    fn to_f64() -> Quatd:
        Quatd(self.w as f64, self.x as f64, self.y as f64, self.z as f64)


# ============================================================================
# Quatd - Quaternion (f64)
# ============================================================================

class Quatd:
    """Quaternion for 3D rotations (f64 precision)."""
    w: f64
    x: f64
    y: f64
    z: f64

    fn __init__(w: f64, x: f64, y: f64, z: f64):
        self.w = w
        self.x = x
        self.y = y
        self.z = z

    static fn identity() -> Quatd:
        Quatd(1.0, 0.0, 0.0, 0.0)

    static fn from_axis_angle(axis: Vec3d, angle: f64) -> Quatd:
        use .vec3.Vec3d
        val half_angle = angle * 0.5
        val s = half_angle.sin()
        val c = half_angle.cos()
        val n = axis.normalize()
        Quatd(c, n.x * s, n.y * s, n.z * s)

    static fn from_euler(pitch: f64, yaw: f64, roll: f64) -> Quatd:
        val cp = (pitch * 0.5).cos()
        val sp = (pitch * 0.5).sin()
        val cy = (yaw * 0.5).cos()
        val sy = (yaw * 0.5).sin()
        val cr = (roll * 0.5).cos()
        val sr = (roll * 0.5).sin()
        Quatd(
            cr * cp * cy + sr * sp * sy,
            sr * cp * cy - cr * sp * sy,
            cr * sp * cy + sr * cp * sy,
            cr * cp * sy - sr * sp * cy
        )

    fn magnitude() -> f64:
        (self.w * self.w + self.x * self.x + self.y * self.y + self.z * self.z).sqrt()

    fn normalize() -> Quatd:
        val mag = self.magnitude()
        if mag > 0.0:
            return Quatd(self.w / mag, self.x / mag, self.y / mag, self.z / mag)
        Quatd.identity()

    fn conjugate() -> Quatd:
        Quatd(self.w, -self.x, -self.y, -self.z)

    fn inverse() -> Quatd:
        val mag_sq = self.w * self.w + self.x * self.x + self.y * self.y + self.z * self.z
        if mag_sq > 0.0:
            val inv = 1.0 / mag_sq
            return Quatd(self.w * inv, -self.x * inv, -self.y * inv, -self.z * inv)
        Quatd.identity()

    fn mul(other: Quatd) -> Quatd:
        Quatd(
            self.w * other.w - self.x * other.x - self.y * other.y - self.z * other.z,
            self.w * other.x + self.x * other.w + self.y * other.z - self.z * other.y,
            self.w * other.y - self.x * other.z + self.y * other.w + self.z * other.x,
            self.w * other.z + self.x * other.y - self.y * other.x + self.z * other.w
        )

    fn rotate_vector(v: Vec3d) -> Vec3d:
        use .vec3.Vec3d
        val qv = Vec3d(self.x, self.y, self.z)
        val t = qv.cross(v).scale(2.0)
        v.add(t.scale(self.w)).add(qv.cross(t))

    fn slerp(other: Quatd, t: f64) -> Quatd:
        var cos_half = self.w * other.w + self.x * other.x + self.y * other.y + self.z * other.z
        var target = other
        if cos_half < 0.0:
            target = Quatd(-other.w, -other.x, -other.y, -other.z)
            cos_half = -cos_half

        if cos_half > 0.9995:
            val result = Quatd(
                self.w + (target.w - self.w) * t,
                self.x + (target.x - self.x) * t,
                self.y + (target.y - self.y) * t,
                self.z + (target.z - self.z) * t
            )
            return result.normalize()

        val half_angle = cos_half.acos()
        val sin_half = (1.0 - cos_half * cos_half).sqrt()
        val a = ((1.0 - t) * half_angle).sin() / sin_half
        val b = (t * half_angle).sin() / sin_half

        Quatd(
            self.w * a + target.w * b,
            self.x * a + target.x * b,
            self.y * a + target.y * b,
            self.z * a + target.z * b
        )

    fn to_mat3() -> Mat3d:
        use .mat3.Mat3d
        val xx = self.x * self.x
        val yy = self.y * self.y
        val zz = self.z * self.z
        val xy = self.x * self.y
        val xz = self.x * self.z
        val yz = self.y * self.z
        val wx = self.w * self.x
        val wy = self.w * self.y
        val wz = self.w * self.z
        Mat3d([
            1.0 - 2.0 * (yy + zz), 2.0 * (xy + wz),       2.0 * (xz - wy),
            2.0 * (xy - wz),       1.0 - 2.0 * (xx + zz), 2.0 * (yz + wx),
            2.0 * (xz + wy),       2.0 * (yz - wx),       1.0 - 2.0 * (xx + yy)
        ])

    fn to_mat4() -> Mat4d:
        use .mat4.Mat4d
        val m3 = self.to_mat3()
        Mat4d([
            m3.data[0], m3.data[1], m3.data[2], 0.0,
            m3.data[3], m3.data[4], m3.data[5], 0.0,
            m3.data[6], m3.data[7], m3.data[8], 0.0,
            0.0,        0.0,        0.0,        1.0
        ])

    fn to_f32() -> Quat:
        Quat(self.w as f32, self.x as f32, self.y as f32, self.z as f32)
