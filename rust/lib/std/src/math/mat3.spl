# Math Mat3 - 3x3 Matrices
#
# Mat3 (f32) and Mat3d (f64) for 2D transformations.
# Column-major storage (GPU/Vulkan standard).

export Mat3, Mat3d


# ============================================================================
# Mat3 - 3x3 Matrix (f32, column-major)
# ============================================================================

class Mat3:
    """3x3 matrix for 2D transformations. Column-major storage."""
    data: [f32; 9]

    fn __init__(data: [f32; 9]):
        self.data = data

    static fn identity() -> Mat3:
        Mat3([
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
        ])

    static fn rotation_z(angle: f32) -> Mat3:
        """Create rotation matrix around Z-axis (column-major)."""
        val c = angle.cos()
        val s = angle.sin()
        Mat3([
            c,   s,   0.0,
            -s,  c,   0.0,
            0.0, 0.0, 1.0
        ])

    static fn scale(sx: f32, sy: f32) -> Mat3:
        Mat3([
            sx,  0.0, 0.0,
            0.0, sy,  0.0,
            0.0, 0.0, 1.0
        ])

    fn mul(other: Mat3) -> Mat3:
        """Matrix multiplication (self * other)."""
        var result = [0.0; 9]
        for col in 0..3:
            for row in 0..3:
                var sum: f32 = 0.0
                for k in 0..3:
                    sum = sum + self.data[k * 3 + row] * other.data[col * 3 + k]
                result[col * 3 + row] = sum
        Mat3(result)

    fn transpose() -> Mat3:
        Mat3([
            self.data[0], self.data[3], self.data[6],
            self.data[1], self.data[4], self.data[7],
            self.data[2], self.data[5], self.data[8]
        ])

    fn determinant() -> f32:
        val a = self.data[0]
        val b = self.data[3]
        val c = self.data[6]
        val d = self.data[1]
        val e = self.data[4]
        val f = self.data[7]
        val g = self.data[2]
        val h = self.data[5]
        val i = self.data[8]
        a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g)

    fn transform_vec2(v: Vec2) -> Vec2:
        """Transform a Vec2 (treats as homogeneous [x, y, 1])."""
        use .vec2.Vec2
        val x = self.data[0] * v.x + self.data[3] * v.y + self.data[6]
        val y = self.data[1] * v.x + self.data[4] * v.y + self.data[7]
        Vec2(x, y)


# ============================================================================
# Mat3d - 3x3 Matrix (f64, column-major)
# ============================================================================

class Mat3d:
    """3x3 matrix for 2D transformations. Column-major storage, f64 precision."""
    data: [f64; 9]

    fn __init__(data: [f64; 9]):
        self.data = data

    static fn identity() -> Mat3d:
        Mat3d([
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
        ])

    static fn rotation_z(angle: f64) -> Mat3d:
        val c = angle.cos()
        val s = angle.sin()
        Mat3d([
            c,   s,   0.0,
            -s,  c,   0.0,
            0.0, 0.0, 1.0
        ])

    static fn scale(sx: f64, sy: f64) -> Mat3d:
        Mat3d([
            sx,  0.0, 0.0,
            0.0, sy,  0.0,
            0.0, 0.0, 1.0
        ])

    fn mul(other: Mat3d) -> Mat3d:
        var result = [0.0; 9]
        for col in 0..3:
            for row in 0..3:
                var sum: f64 = 0.0
                for k in 0..3:
                    sum = sum + self.data[k * 3 + row] * other.data[col * 3 + k]
                result[col * 3 + row] = sum
        Mat3d(result)

    fn transpose() -> Mat3d:
        Mat3d([
            self.data[0], self.data[3], self.data[6],
            self.data[1], self.data[4], self.data[7],
            self.data[2], self.data[5], self.data[8]
        ])

    fn determinant() -> f64:
        val a = self.data[0]
        val b = self.data[3]
        val c = self.data[6]
        val d = self.data[1]
        val e = self.data[4]
        val f = self.data[7]
        val g = self.data[2]
        val h = self.data[5]
        val i = self.data[8]
        a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g)
