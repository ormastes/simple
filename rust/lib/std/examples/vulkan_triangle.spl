# Vulkan Triangle Example - Phase 2 Integration Demo
#
# Complete end-to-end example demonstrating all Phase 2 components:
# - Device initialization (Phase 1)
# - Vertex buffers (Phase 2)
# - Graphics pipeline (Phase 1)
# - Command recording (Phase 2)
# - Render loop with while-with pattern (Phase 2)

use ui.gui.*
use core.*

# =============================================================================
# Vertex Definition
# =============================================================================

pub struct Vertex:
    position: [f32; 3]
    color: [f32; 4]

# =============================================================================
# Triangle Data
# =============================================================================

static fn create_triangle_vertices() -> Array<Vertex>:
    [
        Vertex {
            position: [0.0, -0.5, 0.0],
            color: [1.0, 0.0, 0.0, 1.0],  # Red
        },
        Vertex {
            position: [0.5, 0.5, 0.0],
            color: [0.0, 1.0, 0.0, 1.0],  # Green
        },
        Vertex {
            position: [-0.5, 0.5, 0.0],
            color: [0.0, 0.0, 1.0, 1.0],  # Blue
        },
    ]

# =============================================================================
# Main Application
# =============================================================================

async fn main() -> Result<(), text>:
    println("=== Vulkan Triangle Demo ===")
    println("Phase 2 Integration Test")
    println()

    # Phase 1: Initialize Vulkan
    println("1. Initializing Vulkan device...")
    val window_handle = create_window("Vulkan Triangle", 800, 600)?
    val device = VulkanDevice::new(window_handle)?
    println("   ✓ Device created: {device.get_device_name()}")

    # Phase 1: Create swapchain
    println("2. Creating swapchain...")
    val swapchain = Swapchain::new(&device, window_handle, 800, 600)?
    println("   ✓ Swapchain created: {}x{}", swapchain.extent.width, swapchain.extent.height)

    # Phase 1: Create render pass
    println("3. Creating render pass...")
    val render_pass = RenderPass::new(&device, swapchain.format)?
    println("   ✓ Render pass created")

    # Phase 1: Load shaders
    println("4. Loading shaders...")
    val shaders = ShaderBuilder::new(&device)
        .default_vertex()?
        .default_fragment()?
        .build()?
    println("   ✓ Shaders loaded (vertex + fragment)")

    # Phase 1: Create graphics pipeline
    println("5. Creating graphics pipeline...")
    val pipeline_info = PipelineBuilder::new()
        .shaders(&shaders)
        .vertex_input_auto()  # Position + color
        .input_assembly_triangles()
        .rasterization_default()
        .viewport_dynamic()
        .multisample_4x()
        .color_blend_alpha()
        .build()

    val pipeline = GraphicsPipeline::new(&device, &render_pass, &pipeline_info)?
    println("   ✓ Graphics pipeline created")

    # Phase 2: Create vertex buffer
    println("6. Creating vertex buffer...")
    val vertices = create_triangle_vertices()
    val vertex_buffer = VertexBuffer::new(&device, &vertices)?
    println("   ✓ Vertex buffer created ({} vertices)", vertex_buffer.vertex_count)

    # Phase 2: Create render loop
    println("7. Creating render loop...")
    var render_loop = RenderLoop::new(&device, &swapchain, &render_pass)?
    println("   ✓ Render loop created (triple buffering)")

    # Phase 2: Main render loop
    println("8. Starting render loop...")
    println("   Press Ctrl+C to exit")
    println()

    var frame_count = 0
    val start_time = get_time()

    # Phase 2: Render loop using while-with pattern
    while with await render_loop.frame() as frame:
        # Clear to black
        frame.clear([0.0, 0.0, 0.0, 1.0])?

        # Bind pipeline
        frame.bind(&pipeline)?

        # Draw triangle
        frame.draw(&vertex_buffer, vertex_count: 3)?

        # Frame automatically submitted and presented on exit

        frame_count += 1

        # FPS counter every 60 frames
        if frame_count % 60 == 0:
            val elapsed = get_time() - start_time
            val fps = frame_count as f64 / elapsed
            println("Frame {}: {:.1} FPS", frame_count, fps)

        # Exit after 600 frames (10 seconds at 60 FPS)
        if frame_count >= 600:
            break

    # Cleanup
    println()
    println("9. Cleaning up...")
    await render_loop.wait_idle()
    await render_loop.destroy()
    await vertex_buffer.destroy()
    await pipeline.destroy()
    await shaders.destroy()
    await render_pass.destroy()
    await swapchain.destroy()
    await device.destroy()
    println("   ✓ All resources destroyed")

    println()
    println("=== Demo Complete ===")
    println("Total frames rendered: {}", frame_count)
    val total_time = get_time() - start_time
    val avg_fps = frame_count as f64 / total_time
    println("Average FPS: {:.1}", avg_fps)

    Ok(())

# =============================================================================
# Window Management (Placeholder FFI)
# =============================================================================

extern fn create_window(title: &str, width: u32, height: u32) -> Result<i64, text>
extern fn get_time() -> f64

# =============================================================================
# Expected Output
# =============================================================================

# === Vulkan Triangle Demo ===
# Phase 2 Integration Test
#
# 1. Initializing Vulkan device...
#    ✓ Device created: NVIDIA GeForce RTX 3080
# 2. Creating swapchain...
#    ✓ Swapchain created: 800x600
# 3. Creating render pass...
#    ✓ Render pass created
# 4. Loading shaders...
#    ✓ Shaders loaded (vertex + fragment)
# 5. Creating graphics pipeline...
#    ✓ Graphics pipeline created
# 6. Creating vertex buffer...
#    ✓ Vertex buffer created (3 vertices)
# 7. Creating render loop...
#    ✓ Render loop created (triple buffering)
# 8. Starting render loop...
#    Press Ctrl+C to exit
#
# Frame 60: 60.0 FPS
# Frame 120: 60.0 FPS
# Frame 180: 60.0 FPS
# Frame 240: 60.0 FPS
# Frame 300: 60.0 FPS
# Frame 360: 60.0 FPS
# Frame 420: 60.0 FPS
# Frame 480: 60.0 FPS
# Frame 540: 60.0 FPS
# Frame 600: 60.0 FPS
#
# 9. Cleaning up...
#    ✓ All resources destroyed
#
# === Demo Complete ===
# Total frames rendered: 600
# Average FPS: 60.0
