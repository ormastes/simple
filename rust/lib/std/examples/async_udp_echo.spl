# Async UDP echo server and client example using monoio
# Demonstrates high-performance async UDP with io_uring
# Feature: #1754 (Simple Language UDP API)

import net::{init_runtime, shutdown_runtime, block_on, spawn}
import net.udp::{UdpSocket}
import core.io

# Run UDP echo server
async fn run_server():
    # Bind to port 9090
    val socket = await UdpSocket::bind("127.0.0.1:9090")?
    println("UDP echo server listening on " + socket.local_addr().unwrap_or("unknown"))

    # Buffer for receiving data
    var buffer = Bytes::with_capacity(4096)

    # Receive and echo back in a loop
    loop:
        # Receive data from any sender
        val (n, peer) = await socket.recv_from(&mut buffer, 4096)?

        println("Received " + n.to_string() + " bytes from " + peer)

        # Echo data back to sender
        val sent = await socket.send_to(buffer.slice(0, n), peer)?

        println("Echoed " + sent.to_string() + " bytes back to " + peer)

# Run UDP echo client
async fn run_client():
    # Bind to any port
    val socket = await UdpSocket::bind("127.0.0.1:0")?
    println("UDP client bound to " + socket.local_addr().unwrap_or("unknown"))

    # Send several messages to the server
    val messages = ["Hello, UDP server!", "How are you?", "Goodbye!"]

    for message in messages:
        println("Sending: " + message)

        # Send to server
        val data = message.as_bytes()
        val sent = await socket.send_to(data, "127.0.0.1:9090")?

        println("Sent " + sent.to_string() + " bytes")

        # Receive echo
        var buffer = Bytes::with_capacity(4096)
        val (n, peer) = await socket.recv_from(&mut buffer, 4096)?

        val response = text::from_bytes(buffer.slice(0, n))
        println("Received echo from " + peer + ": " + response)

    # Close the socket
    socket.close()?
    println("Client done")

# Example using connected UDP socket
async fn run_connected_client():
    # Bind to any port
    val socket = await UdpSocket::bind("127.0.0.1:0")?
    println("UDP client bound to " + socket.local_addr().unwrap_or("unknown"))

    # Connect to server (optional, but allows using send/recv instead of send_to/recv_from)
    await socket.connect("127.0.0.1:9090")?
    println("Connected to server")

    # Now we can use send() and recv() directly
    val message = "Hello from connected socket!"
    println("Sending: " + message)

    val data = message.as_bytes()
    val sent = await socket.send(data)?

    # Receive echo
    var buffer = Bytes::with_capacity(4096)
    val n = await socket.recv(&mut buffer, 4096)?

    val response = text::from_bytes(buffer.slice(0, n))
    println("Received echo: " + response)

    socket.close()?

# Example using broadcast
async fn run_broadcast():
    # Bind to any port
    val socket = await UdpSocket::bind("0.0.0.0:0")?

    # Enable broadcast
    socket.set_broadcast(true)?
    println("Broadcast enabled")

    # Send broadcast message
    val message = "Broadcast message!".as_bytes()
    val sent = await socket.send_to(message, "255.255.255.255:9090")?

    println("Sent broadcast: " + sent.to_string() + " bytes")

    socket.close()?

# Example using multicast
async fn run_multicast():
    # Bind to multicast port
    val socket = await UdpSocket::bind("0.0.0.0:9091")?

    # Join multicast group 239.255.0.1
    socket.join_multicast("239.255.0.1", "0.0.0.0")?
    println("Joined multicast group 239.255.0.1")

    # Set multicast TTL
    socket.set_multicast_ttl(32)?

    # Send multicast message
    val message = "Multicast message!".as_bytes()
    val sent = await socket.send_to(message, "239.255.0.1:9091")?

    println("Sent multicast: " + sent.to_string() + " bytes")

    # Receive multicast (would receive from ourselves or other members)
    var buffer = Bytes::with_capacity(4096)
    val (n, peer) = await socket.recv_from(&mut buffer, 4096)?

    val response = text::from_bytes(buffer.slice(0, n))
    println("Received from multicast group (" + peer + "): " + response)

    # Leave multicast group
    socket.leave_multicast("239.255.0.1", "0.0.0.0")?
    socket.close()?

fn main():
    println("Starting async UDP echo demo...")

    # Initialize monoio runtime
    val runtime = init_runtime()?
    println("Runtime initialized")

    # Choose which demo to run (uncomment one):

    # Demo 1: Server and client (run in separate terminals)
    # Terminal 1: Run server
    # block_on(async { await run_server() })

    # Terminal 2: Run client
    # block_on(async { await run_client() })

    # Demo 2: Connected client (requires server running)
    # block_on(async { await run_connected_client() })

    # Demo 3: Broadcast (requires server running on 255.255.255.255:9090)
    # block_on(async { await run_broadcast() })

    # Demo 4: Multicast (self-contained)
    block_on(async { await run_multicast() })

    # Shutdown runtime
    shutdown_runtime(runtime)
    println("Demo complete")

# To test:
#
# 1. Start the server in one terminal:
#    $ ./simple async_udp_echo.spl
#    (Edit main() to run run_server())
#
# 2. Run the client in another terminal:
#    $ ./simple async_udp_echo.spl
#    (Edit main() to run run_client())
#
# Expected output (client):
#   Starting async UDP echo demo...
#   Runtime initialized
#   UDP client bound to 127.0.0.1:XXXXX
#   Sending: Hello, UDP server!
#   Sent 18 bytes
#   Received echo from 127.0.0.1:9090: Hello, UDP server!
#   Sending: How are you?
#   Sent 12 bytes
#   Received echo from 127.0.0.1:9090: How are you?
#   Sending: Goodbye!
#   Sent 8 bytes
#   Received echo from 127.0.0.1:9090: Goodbye!
#   Client done
#   Demo complete
