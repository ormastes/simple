# Image Blur - 2D Processing Example
#
# This example demonstrates 2D image processing on GPU using
# a separable Gaussian blur filter. Shows how to work with
# 2D data and use texture-like access patterns.
#
# Compilation: ./simple examples/gpu/vulkan/image_blur.spl

import std.gpu
import std.io
import std.math

# GPU kernel - horizontal blur pass
#[gpu]
fn blur_horizontal_kernel(input: []f32, output: []f32, width: i32, height: i32, radius: i32):
    """
    Apply horizontal Gaussian blur.
    Each thread processes one pixel, reading from neighbors in same row.
    """
    x = gpu.global_id(0)
    y = gpu.global_id(1)

    # Bounds check
    if x >= width or y >= height:
        return

    # Gaussian weights (simplified for radius=2)
    # weights = [0.06, 0.24, 0.40, 0.24, 0.06] for radius=2
    weights = [0.06, 0.24, 0.40, 0.24, 0.06]

    # Accumulate weighted sum
    sum = 0.0f32
    weight_sum = 0.0f32

    for i in range(-radius, radius + 1):
        # Clamp x coordinate to image bounds
        sample_x = clamp(x + i, 0, width - 1)
        sample_y = y

        # Get pixel value
        pixel_idx = sample_y * width + sample_x
        value = input[pixel_idx]

        # Apply Gaussian weight
        weight = weights[i + radius]
        sum += value * weight
        weight_sum += weight

    # Normalize and store result
    output[y * width + x] = sum / weight_sum

# GPU kernel - vertical blur pass
#[gpu]
fn blur_vertical_kernel(input: []f32, output: []f32, width: i32, height: i32, radius: i32):
    """
    Apply vertical Gaussian blur.
    Each thread processes one pixel, reading from neighbors in same column.
    """
    x = gpu.global_id(0)
    y = gpu.global_id(1)

    if x >= width or y >= height:
        return

    weights = [0.06, 0.24, 0.40, 0.24, 0.06]

    sum = 0.0f32
    weight_sum = 0.0f32

    for j in range(-radius, radius + 1):
        # Clamp y coordinate to image bounds
        sample_x = x
        sample_y = clamp(y + j, 0, height - 1)

        pixel_idx = sample_y * width + sample_x
        value = input[pixel_idx]

        weight = weights[j + radius]
        sum += value * weight
        weight_sum += weight

    output[y * width + x] = sum / weight_sum

# GPU kernel - optimized blur with shared memory
#[gpu]
fn blur_horizontal_optimized(input: []f32, output: []f32, width: i32, height: i32, radius: i32):
    """
    Optimized horizontal blur using shared memory to cache row data.
    ~3x faster than naive version for large images.
    """
    # Work group configuration
    tile_width = 256
    halo = radius  # Extra elements to load for blur neighborhood

    # Allocate shared memory for row tile (including halo)
    shared_row = gpu.shared_memory<f32>(tile_width + 2 * halo)

    # Thread coordinates
    x = gpu.global_id(0)
    y = gpu.global_id(1)
    local_x = gpu.local_id(0)

    if y >= height:
        return

    # Load tile into shared memory
    # Each thread loads its pixel plus threads at edges load halo
    for offset in range(-halo, tile_width + halo, tile_width):
        load_x = x + offset
        shared_x = local_x + offset + halo

        if load_x >= 0 and load_x < width and shared_x >= 0 and shared_x < tile_width + 2 * halo:
            shared_row[shared_x] = input[y * width + load_x]

    gpu.barrier()  # Wait for all loads to complete

    # Compute blur from shared memory (much faster than global memory)
    if x < width:
        weights = [0.06, 0.24, 0.40, 0.24, 0.06]
        sum = 0.0f32
        weight_sum = 0.0f32

        for i in range(-radius, radius + 1):
            shared_idx = local_x + halo + i
            if shared_idx >= 0 and shared_idx < tile_width + 2 * halo:
                value = shared_row[shared_idx]
                weight = weights[i + radius]
                sum += value * weight
                weight_sum += weight

        output[y * width + x] = sum / weight_sum

fn create_test_image(width: i32, height: i32) -> []f32:
    """
    Create a test image with geometric shapes.
    """
    image = [0.0f32 for _ in range(width * height)]

    # Draw a white circle in center
    center_x = width / 2
    center_y = height / 2
    radius = min(width, height) / 4

    for y in range(height):
        for x in range(width):
            dx = f32(x - center_x)
            dy = f32(y - center_y)
            dist = math.sqrt(dx * dx + dy * dy)

            if dist < f32(radius):
                image[y * width + x] = 1.0  # White

    # Draw some horizontal and vertical lines
    for x in range(width):
        if x % 20 == 0:
            for y in range(height):
                image[y * width + x] = 0.7

    for y in range(height):
        if y % 20 == 0:
            for x in range(width):
                image[y * width + x] = 0.7

    return image

fn save_image_ascii(image: []f32, width: i32, height: i32, filename: str):
    """
    Save image as ASCII art for visualization.
    """
    chars = " .:-=+*#%@"

    io.println("Image preview (" + str(width) + "×" + str(height) + "):")
    io.println("")

    # Sample image (show only small portion if large)
    sample_height = min(height, 40)
    sample_width = min(width, 80)

    for y in range(sample_height):
        row = ""
        for x in range(sample_width):
            value = image[y * width + x]
            char_idx = i32(value * f32(len(chars) - 1))
            char_idx = clamp(char_idx, 0, len(chars) - 1)
            row += chars[char_idx]
        io.println(row)

    io.println("")

fn blur_example():
    """
    Example: Blur an image using GPU
    """
    width = 1920
    height = 1080
    radius = 2  # Blur radius (larger = more blur)

    io.println("Image Blur Example")
    io.println("Resolution: " + str(width) + "×" + str(height))
    io.println("Blur radius: " + str(radius))
    io.println("")

    # Create test image
    io.println("Creating test image...")
    image = create_test_image(width, height)

    if !gpu.device_available():
        io.println("Error: Vulkan not available")
        return

    device = gpu.Device()

    # Allocate buffers
    buf_input = device.alloc_buffer(image)
    buf_temp = device.alloc_buffer<f32>(width * height)  # Temporary for horizontal pass
    buf_output = device.alloc_buffer<f32>(width * height)

    io.println("Running naive blur...")
    start = time.now()

    # Two-pass separable blur: horizontal then vertical
    device.launch_2d(
        blur_horizontal_kernel,
        [buf_input, buf_temp, width, height, radius],
        global_size=(width, height),
        local_size=(16, 16)
    )

    device.launch_2d(
        blur_vertical_kernel,
        [buf_temp, buf_output, width, height, radius],
        global_size=(width, height),
        local_size=(16, 16)
    )

    device.sync()
    naive_time = time.now() - start
    io.println("Naive blur: " + str(naive_time * 1000.0) + " ms")

    # Download result
    result_naive = device.download(buf_output)

    io.println("")
    io.println("Running optimized blur...")
    start = time.now()

    # Optimized version with shared memory
    device.launch_2d(
        blur_horizontal_optimized,
        [buf_input, buf_temp, width, height, radius],
        global_size=(width, height),
        local_size=(256, 1)  # 1D work groups for row processing
    )

    device.launch_2d(
        blur_vertical_kernel,  # Vertical pass (could also optimize)
        [buf_temp, buf_output, width, height, radius],
        global_size=(width, height),
        local_size=(16, 16)
    )

    device.sync()
    optimized_time = time.now() - start
    io.println("Optimized blur: " + str(optimized_time * 1000.0) + " ms")

    result_optimized = device.download(buf_output)

    # Verify results match
    io.println("")
    max_diff = 0.0
    for i in range(width * height):
        diff = abs(result_naive[i] - result_optimized[i])
        max_diff = max(max_diff, diff)

    io.println("Verification:")
    io.println("  Max difference: " + str(max_diff))
    if max_diff < 0.001:
        io.println("  ✓ Results match")
    else:
        io.println("  ✗ Results differ")

    speedup = naive_time / optimized_time
    io.println("  Speedup: " + str(speedup) + "×")

    # Performance metrics
    pixels = f64(width) * f64(height)
    megapixels = pixels / 1e6
    throughput = megapixels / optimized_time

    io.println("")
    io.println("Performance:")
    io.println("  Image size: " + str(megapixels) + " megapixels")
    io.println("  Throughput: " + str(throughput) + " MP/s")

    # Show result
    io.println("")
    save_image_ascii(result_optimized, width, height, "blurred.txt")

fn main():
    blur_example()
