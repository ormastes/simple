#!/bin/bash
# Simple Language CLI - Multi-Platform Bootstrap Loader
#
# Startup optimization: If a compiled C binary exists at build/simple,
# route commands directly through it (3ms vs 130ms+ interpreter path).

set -e

# Get script directory
DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# ── Fast path: compiled C binary handles commands natively ──
# build/simple is a fully compiled CLI dispatcher (~3ms startup).
# It handles --help, --version, compile, test, lint, etc. without
# loading .spl files through the interpreter.
COMPILED_BIN="$DIR/../build/simple"
if [ -x "$COMPILED_BIN" ]; then
    export SIMPLE_LIB="$DIR/../src"
    export SIMPLE_VERSION=$(cat "$DIR/../VERSION" 2>/dev/null || echo "unknown")
    # Compiled binary doesn't emit [DEBUG] noise — no filtering needed.
    exec "$COMPILED_BIN" "$@"
fi

# ── Fallback: interpreter-based execution ──

detect_platform() {
    local arch=$(uname -m)
    local os=$(uname -s | tr '[:upper:]' '[:lower:]')

    case "$arch" in
        x86_64|amd64) arch="x86_64" ;;
        aarch64|arm64) arch="arm64" ;;
        riscv64) arch="riscv64" ;;
        *)
            echo "Error: Unsupported architecture: $arch" >&2
            exit 1
            ;;
    esac

    case "$os" in
        linux) os="linux" ;;
        darwin) os="macos" ;;
        freebsd) os="freebsd" ;;
        mingw*|msys*|cygwin*) os="windows" ;;
        *)
            echo "Error: Unsupported OS: $os" >&2
            exit 1
            ;;
    esac

    echo "${os}-${arch}"
}

find_bootstrap() {
    local platform="$1"
    local release_dir="$DIR/release"

    local release_bin="$release_dir/$platform/simple"
    case "$platform" in
        *windows*) release_bin="$release_bin.exe" ;;
    esac

    if [ -x "$release_bin" ]; then
        echo "$release_bin"
        return 0
    fi

    if [ -x "$release_dir/simple" ]; then
        echo "$release_dir/simple"
        return 0
    fi

    if [ "$platform" = "freebsd-x86_64" ] && [ -x "$release_dir/linux-x86_64/simple" ]; then
        echo "$release_dir/linux-x86_64/simple"
        return 0
    fi

    echo "Error: No Simple runtime found for platform: $platform" >&2
    echo "Please download the release binary for your platform" >&2
    echo "  https://github.com/simple-lang/simple/releases" >&2
    exit 1
}

detect_fast_path() {
    local first_cmd=""
    for arg in "$@"; do
        [[ "$arg" == --* ]] && continue
        first_cmd="$arg"
        break
    done

    case "$first_cmd" in
        test)
            local spl_arg="" past_test=false has_heavy=false has_mem_check=false
            for arg in "$@"; do
                if [ "$arg" = "test" ]; then past_test=true; continue; fi
                [ "$past_test" = "false" ] && continue
                case "$arg" in
                    --coverage|--sdoctest*|--container*|--chaos|--fuzz|--deploy|--security|--resume|--parallel)
                        has_heavy=true; break ;;
                    --mem-check)
                        has_mem_check=true ;;
                    --*) continue ;;
                    *) [ -z "$spl_arg" ] && spl_arg="$arg" ;;
                esac
            done
            if [ "$has_heavy" = "false" ] && { [[ "$spl_arg" == *.spl ]] || { [ "$has_mem_check" = "true" ] && [ -n "$spl_arg" ]; }; }; then
                echo "../test_runner_new/test_runner_single.spl"
            else
                echo "../test_runner_new/test_runner_main.spl"
            fi
            return 0
            ;;
        compile)
            for arg in "$@"; do
                case "$arg" in
                    --backend=c|--backend=cpp|--backend=ccodegen)
                        echo "compile_c_entry.spl"; return 0 ;;
                esac
            done
            echo "compile_entry.spl"; return 0
            ;;
        bootstrap-check) echo "bootstrap_check.spl"; return 0 ;;
        lint|fmt|fix) echo "lint_entry.spl"; return 0 ;;
        leak-check) echo "leak_check_entry.spl"; return 0 ;;
        stats) echo "stats_entry.spl"; return 0 ;;
        *) return 1 ;;
    esac
}

# Pipe-based stderr filtering (no temp file creation).
run_filtered() {
    "$@" 2>&1 1>&3 | grep -v \
        -e '^\[DEBUG\]' \
        -e '^\[WARNING\] Failed to load test database' \
        -e '^\[WARNING\] Existing records will be preserved' \
        -e '^\[INFO\] Backup created at:' \
        -e '^Warning: Failed to update.*test database' \
        >&2 || true
    return "${PIPESTATUS[0]}"
} 3>&1

main() {
    local platform=$(detect_platform)
    local bootstrap=$(find_bootstrap "$platform")

    export SIMPLE_LIB="$DIR/../src"
    export SIMPLE_VERSION=$(cat "$DIR/../VERSION" 2>/dev/null || echo "unknown")

    case "$1" in
        --version)
            echo "Simple Language v${SIMPLE_VERSION}"
            exit 0
            ;;
        --help)
            run_filtered "$bootstrap" "$@"
            exit $?
            ;;
        -c)
            if [ -z "$2" ]; then
                echo "Error: -c requires a code argument" >&2
                exit 1
            fi
            local tmp
            tmp=$(mktemp "$DIR/../.simple_eval_XXXXXX.spl")
            printf '%s\n' "$2" | sed 's/; */\n/g' > "$tmp"
            run_filtered "$bootstrap" "$tmp"
            local rc=$?
            rm -f "$tmp"
            exit $rc
            ;;
        *.spl|*.smf)
            run_filtered "$bootstrap" "$@"
            exit $?
            ;;
    esac

    local fast_entry
    if fast_entry=$(detect_fast_path "$@"); then
        local fast_rc=0
        run_filtered "$bootstrap" "$DIR/../src/app/cli/$fast_entry" "$@" || fast_rc=$?
        if [ $fast_rc -ne 0 ] && [ "$fast_entry" = "compile_c_entry.spl" ]; then
            local codegen_bin="$DIR/bootstrap/cpp/simple_codegen"
            if [ -x "$codegen_bin" ]; then
                local c_source="" c_output=""
                local past_compile=false
                for arg in "$@"; do
                    case "$arg" in
                        compile) past_compile=true; continue ;;
                        --backend=*|--verbose|-v) continue ;;
                        -o) c_output="__NEXT__"; continue ;;
                        --emit-c) continue ;;
                    esac
                    if [ "$c_output" = "__NEXT__" ]; then
                        c_output="$arg"; continue
                    fi
                    if [ "$past_compile" = "true" ] && [[ "$arg" != -* ]]; then
                        c_source="$arg"
                    fi
                done
                if [ -z "$c_output" ]; then
                    c_output="${c_source%.spl}.c"
                fi
                if [ -n "$c_source" ]; then
                    "$codegen_bin" compile "$c_source" "$c_output"
                    local cg_rc=$?
                    if [ $cg_rc -eq 0 ]; then
                        echo "Output: $c_output"
                        echo "Build with: clang -std=gnu11 -O2 $c_output -lm -o output"
                    fi
                    exit $cg_rc
                fi
            fi
        fi
        exit $fast_rc
    fi

    run_filtered "$bootstrap" "$DIR/../src/app/cli/main.spl" "$@"
    exit $?
}

main "$@"
