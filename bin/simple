#!/bin/bash
# Simple Language CLI - Multi-Platform Bootstrap Loader
# Automatically detects platform and uses appropriate bootstrap binary

set -e

# Get script directory
DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Detect platform
detect_platform() {
    local arch=$(uname -m)
    local os=$(uname -s | tr '[:upper:]' '[:lower:]')

    # Normalize architecture
    case "$arch" in
        x86_64|amd64) arch="x86_64" ;;
        aarch64|arm64) arch="arm64" ;;
        riscv64) arch="riscv64" ;;
        *)
            echo "Error: Unsupported architecture: $arch" >&2
            echo "Supported: x86_64, arm64, riscv64" >&2
            exit 1
            ;;
    esac

    # Normalize OS
    case "$os" in
        linux) os="linux" ;;
        darwin) os="macos" ;;
        freebsd) os="freebsd" ;;
        mingw*|msys*|cygwin*) os="windows" ;;
        *)
            echo "Error: Unsupported OS: $os" >&2
            echo "Supported: linux, macos, freebsd, windows" >&2
            exit 1
            ;;
    esac

    echo "${os}-${arch}"
}

# Find release binary
find_bootstrap() {
    local platform="$1"
    local release_dir="$DIR/release"

    # Try platform-specific binary first
    local release_bin="$release_dir/$platform/simple"
    case "$platform" in
        *windows*) release_bin="$release_bin.exe" ;;
    esac

    if [ -x "$release_bin" ]; then
        echo "$release_bin"
        return 0
    fi

    # Try main release binary (linux-x86_64)
    if [ -x "$release_dir/simple" ]; then
        echo "$release_dir/simple"
        return 0
    fi

    # FreeBSD: fall back to linux binary (runs via Linuxulator)
    if [ "$platform" = "freebsd-x86_64" ] && [ -x "$release_dir/linux-x86_64/simple" ]; then
        echo "$release_dir/linux-x86_64/simple"
        return 0
    fi

    echo "Error: No Simple runtime found for platform: $platform" >&2
    echo "Please download the release binary for your platform" >&2
    echo "  https://github.com/simple-lang/simple/releases" >&2
    exit 1
}

# Check if first non-flag argument is a known fast-path command.
# Each fast-path command has a lightweight entry point that only
# imports what it needs, saving ~160ms of module loading overhead.
detect_fast_path() {
    for arg in "$@"; do
        case "$arg" in
            --*) continue ;;  # Skip flags
            test) echo "../test_runner_new/test_runner_main.spl"; return 0 ;;
            compile) echo "compile_entry.spl"; return 0 ;;
            bootstrap-check) echo "bootstrap_check.spl"; return 0 ;;
            lint|fmt|fix) echo "lint_entry.spl"; return 0 ;;
            *) return 1 ;;    # First non-flag arg is not a fast-path command
        esac
    done
    return 1
}

# Run command with noisy stderr lines filtered out.
# The runtime emits hundreds of [DEBUG] register_definitions lines
# per invocation that are hardcoded eprintln! calls in the binary.
# It also emits [WARNING]/Warning about test_db.sdn parse failures
# due to a binary-internal writer/reader incompatibility (the binary
# writes unquoted strings with colons that its own parser rejects).
# Filtering these reduces noise and saves I/O overhead.
run_filtered() {
    "$@" 2> >(grep -v -e '^\[DEBUG\]' \
                       -e '^\[WARNING\] Failed to load test database' \
                       -e '^\[WARNING\] Existing records will be preserved' \
                       -e '^\[INFO\] Backup created at:' \
                       -e '^Warning: Failed to update.*test database' >&2)
}

# Main execution
main() {
    local platform=$(detect_platform)
    local bootstrap=$(find_bootstrap "$platform")

    # Set stdlib path to eliminate directory walk-up probing.
    # Without this, module resolution tries 78+ paths per import,
    # walking from the file directory up to / trying 6 stdlib patterns.
    export SIMPLE_LIB="$DIR/../src"

    # Export version from VERSION file so Simple code can access it
    export SIMPLE_VERSION=$(cat "$DIR/../VERSION" 2>/dev/null || echo "unknown")

    # Handle flags/modes that bootstrap binary supports natively
    case "$1" in
        --version)
            echo "Simple Language v${SIMPLE_VERSION}"
            exit 0
            ;;
        --help)
            run_filtered "$bootstrap" "$@"
            exit $?
            ;;
        -c)
            # Write code to temp file for full module support (use, etc.)
            # Bootstrap binary's native -c only handles single expressions.
            # Semicolons are converted to newlines for CLI convenience.
            # File is created in project dir so module resolution works.
            if [ -z "$2" ]; then
                echo "Error: -c requires a code argument" >&2
                exit 1
            fi
            local tmp
            tmp=$(mktemp "$DIR/../.simple_eval_XXXXXX.spl")
            printf '%s\n' "$2" | sed 's/; */\n/g' > "$tmp"
            run_filtered "$bootstrap" "$tmp"
            local rc=$?
            rm -f "$tmp"
            exit $rc
            ;;
        *.spl|*.smf)
            # Run source/binary files directly through bootstrap
            run_filtered "$bootstrap" "$@"
            exit $?
            ;;
    esac

    # Use lightweight entry point for known commands (saves ~160ms)
    local fast_entry
    if fast_entry=$(detect_fast_path "$@"); then
        if [ "$fast_entry" = "compile_entry.spl" ]; then
            # Compile command: check for --native flag which needs the interpreter
            local has_native=false
            for arg in "$@"; do
                if [ "$arg" = "--native" ]; then
                    has_native=true
                    break
                fi
            done
            if [ "$has_native" = "true" ]; then
                # --native: use interpreter path (compile_entry.spl → native.spl → C → gcc)
                run_filtered "$bootstrap" "$DIR/../src/app/cli/$fast_entry" "$@"
            else
                # Regular compile: call bootstrap binary directly in native compile mode.
                # SIMPLE_COMPILE_RUST=1 tells the binary to use its Cranelift backend
                # instead of trying to interpret compile_entry.spl (which would fail
                # because rt_cli_handle_compile is only available in native mode).
                SIMPLE_COMPILE_RUST=1 run_filtered "$bootstrap" "$@"
            fi
            exit $?
        fi
        run_filtered "$bootstrap" "$DIR/../src/app/cli/$fast_entry" "$@"
        exit $?
    fi

    # Fall back to full CLI for all other commands
    run_filtered "$bootstrap" "$DIR/../src/app/cli/main.spl" "$@"
    exit $?
}

main "$@"
