#!/bin/bash
# Simple Language CLI - Multi-Platform Bootstrap Loader
# Automatically detects platform and uses appropriate bootstrap binary

set -e

# Get script directory
DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Detect platform
detect_platform() {
    local arch=$(uname -m)
    local os=$(uname -s | tr '[:upper:]' '[:lower:]')

    # Normalize architecture
    case "$arch" in
        x86_64|amd64) arch="x86_64" ;;
        aarch64|arm64) arch="arm64" ;;
        riscv64) arch="riscv64" ;;
        *)
            echo "Error: Unsupported architecture: $arch" >&2
            echo "Supported: x86_64, arm64, riscv64" >&2
            exit 1
            ;;
    esac

    # Normalize OS
    case "$os" in
        linux) os="linux" ;;
        darwin) os="macos" ;;
        freebsd) os="freebsd" ;;
        mingw*|msys*|cygwin*) os="windows" ;;
        *)
            echo "Error: Unsupported OS: $os" >&2
            echo "Supported: linux, macos, freebsd, windows" >&2
            exit 1
            ;;
    esac

    echo "${os}-${arch}"
}

# Find release binary
find_bootstrap() {
    local platform="$1"
    local release_dir="$DIR/release"

    # Try platform-specific binary first
    local release_bin="$release_dir/$platform/simple"
    case "$platform" in
        *windows*) release_bin="$release_bin.exe" ;;
    esac

    if [ -x "$release_bin" ]; then
        echo "$release_bin"
        return 0
    fi

    # Try main release binary (linux-x86_64)
    if [ -x "$release_dir/simple" ]; then
        echo "$release_dir/simple"
        return 0
    fi

    # FreeBSD: fall back to linux binary (runs via Linuxulator)
    if [ "$platform" = "freebsd-x86_64" ] && [ -x "$release_dir/linux-x86_64/simple" ]; then
        echo "$release_dir/linux-x86_64/simple"
        return 0
    fi

    echo "Error: No Simple runtime found for platform: $platform" >&2
    echo "Please download the release binary for your platform" >&2
    echo "  https://github.com/simple-lang/simple/releases" >&2
    exit 1
}

# Check if first non-flag argument is a known fast-path command.
# Each fast-path command has a lightweight entry point that only
# imports what it needs, saving ~160ms of module loading overhead.
detect_fast_path() {
    # Find the first non-flag positional argument (the command)
    local first_cmd=""
    for arg in "$@"; do
        [[ "$arg" == --* ]] && continue
        first_cmd="$arg"
        break
    done

    case "$first_cmd" in
        test)
            # Single .spl file with no heavy flags → lightweight entry (saves ~54s startup)
            local spl_arg="" past_test=false has_heavy=false has_mem_check=false
            for arg in "$@"; do
                if [ "$arg" = "test" ]; then past_test=true; continue; fi
                [ "$past_test" = "false" ] && continue
                case "$arg" in
                    --coverage|--sdoctest*|--container*|--chaos|--fuzz|--deploy|--security|--resume|--parallel)
                        has_heavy=true; break ;;
                    --mem-check)
                        has_mem_check=true ;;
                    --*) continue ;;
                    *) [ -z "$spl_arg" ] && spl_arg="$arg" ;;
                esac
            done
            # Mem-check path prefers lightweight runner for fast per-file checkpoints.
            # Keep heavy feature combinations on the full runner.
            if [ "$has_heavy" = "false" ] && { [[ "$spl_arg" == *.spl ]] || { [ "$has_mem_check" = "true" ] && [ -n "$spl_arg" ]; }; }; then
                echo "../test_runner_new/test_runner_single.spl"
            else
                echo "../test_runner_new/test_runner_main.spl"
            fi
            return 0
            ;;
        compile)
            # Check if --backend=c is specified → use dedicated C backend entry
            for arg in "$@"; do
                case "$arg" in
                    --backend=c|--backend=cpp|--backend=ccodegen)
                        echo "compile_c_entry.spl"; return 0 ;;
                esac
            done
            echo "compile_entry.spl"; return 0
            ;;
        bootstrap-check) echo "bootstrap_check.spl"; return 0 ;;
        lint|fmt|fix) echo "lint_entry.spl"; return 0 ;;
        leak-check) echo "leak_check_entry.spl"; return 0 ;;
        stats) echo "stats_entry.spl"; return 0 ;;
        *) return 1 ;;
    esac
}

# Run command with noisy stderr lines filtered out.
# The runtime emits hundreds of [DEBUG] register_definitions lines
# per invocation that are hardcoded eprintln! calls in the binary.
# It also emits [WARNING]/Warning about test_db.sdn parse failures
# due to a binary-internal writer/reader incompatibility (the binary
# writes unquoted strings with colons that its own parser rejects).
# Filtering these reduces noise and saves I/O overhead.
run_filtered() {
    local _err_file
    _err_file=$(mktemp)
    "$@" 2>"$_err_file"
    local _rc=$?
    grep -v -e '^\[DEBUG\]' \
            -e '^\[WARNING\] Failed to load test database' \
            -e '^\[WARNING\] Existing records will be preserved' \
            -e '^\[INFO\] Backup created at:' \
            -e '^Warning: Failed to update.*test database' \
            "$_err_file" >&2 || true
    rm -f "$_err_file"
    return $_rc
}

# Main execution
main() {
    local platform=$(detect_platform)
    local bootstrap=$(find_bootstrap "$platform")

    # Set stdlib path to eliminate directory walk-up probing.
    # Without this, module resolution tries 78+ paths per import,
    # walking from the file directory up to / trying 6 stdlib patterns.
    export SIMPLE_LIB="$DIR/../src"

    # Export version from VERSION file so Simple code can access it
    export SIMPLE_VERSION=$(cat "$DIR/../VERSION" 2>/dev/null || echo "unknown")

    # Handle flags/modes that bootstrap binary supports natively
    case "$1" in
        --version)
            echo "Simple Language v${SIMPLE_VERSION}"
            exit 0
            ;;
        --help)
            run_filtered "$bootstrap" "$@"
            exit $?
            ;;
        -c)
            # Write code to temp file for full module support (use, etc.)
            # Bootstrap binary's native -c only handles single expressions.
            # Semicolons are converted to newlines for CLI convenience.
            # File is created in project dir so module resolution works.
            if [ -z "$2" ]; then
                echo "Error: -c requires a code argument" >&2
                exit 1
            fi
            local tmp
            tmp=$(mktemp "$DIR/../.simple_eval_XXXXXX.spl")
            printf '%s\n' "$2" | sed 's/; */\n/g' > "$tmp"
            run_filtered "$bootstrap" "$tmp"
            local rc=$?
            rm -f "$tmp"
            exit $rc
            ;;
        *.spl|*.smf)
            # Run source/binary files directly through bootstrap
            run_filtered "$bootstrap" "$@"
            exit $?
            ;;
    esac

    # Use lightweight entry point for known commands (saves ~160ms)
    local fast_entry
    if fast_entry=$(detect_fast_path "$@"); then
        run_filtered "$bootstrap" "$DIR/../src/app/cli/$fast_entry" "$@"
        exit $?
    fi

    # Fall back to full CLI for all other commands
    run_filtered "$bootstrap" "$DIR/../src/app/cli/main.spl" "$@"
    exit $?
}

main "$@"
