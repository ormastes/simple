# Common Component Trait
#
# Engine-agnostic component interface
# Works with both Godot Node components and Unreal UActorComponent
#
# Features:
# - Component lifecycle (init, update, destroy)
# - Owner access
# - Enable/disable state
# - Component queries
# - Engine-agnostic API

import sys.ffi

mod component

# ComponentType
# Standard component categories
pub enum ComponentType:
    Transform = 0
    Render = 1
    Physics = 2
    Audio = 3
    Script = 4
    Custom = 5

impl ComponentType:
    pub fn to_string(self) -> String:
        if self == ComponentType::Transform:
            return "Transform"
        elif self == ComponentType::Render:
            return "Render"
        elif self == ComponentType::Physics:
            return "Physics"
        elif self == ComponentType::Audio:
            return "Audio"
        elif self == ComponentType::Script:
            return "Script"
        else:
            return "Custom"

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_transform(self) -> bool:
        """Check if component type is Transform."""
        return self == ComponentType::Transform

    pub fn is_render(self) -> bool:
        """Check if component type is Render."""
        return self == ComponentType::Render

    pub fn is_physics(self) -> bool:
        """Check if component type is Physics."""
        return self == ComponentType::Physics

    pub fn is_audio(self) -> bool:
        """Check if component type is Audio."""
        return self == ComponentType::Audio

    pub fn is_script(self) -> bool:
        """Check if component type is Script."""
        return self == ComponentType::Script

    pub fn is_custom(self) -> bool:
        """Check if component type is Custom."""
        return self == ComponentType::Custom

    pub fn description(self) -> String:
        """Get component type description.

        Returns:
            Human-readable description

        Example:
            ComponentType::Physics.description()
            # → "Physics simulation and collision"
        """
        if self == ComponentType::Transform:
            return "Position, rotation, and scale"
        elif self == ComponentType::Render:
            return "Visual rendering (meshes, sprites)"
        elif self == ComponentType::Physics:
            return "Physics simulation and collision"
        elif self == ComponentType::Audio:
            return "Audio playback and spatial sound"
        elif self == ComponentType::Script:
            return "Scripting and logic behavior"
        else:
            return "Custom component type"

    pub fn is_transform(self) -> bool:
        """Check if type is Transform.

        Returns:
            True if Transform
        """
        return self == ComponentType::Transform

    pub fn is_render(self) -> bool:
        """Check if type is Render.

        Returns:
            True if Render
        """
        return self == ComponentType::Render

    pub fn is_physics(self) -> bool:
        """Check if type is Physics.

        Returns:
            True if Physics
        """
        return self == ComponentType::Physics

    pub fn is_audio(self) -> bool:
        """Check if type is Audio.

        Returns:
            True if Audio
        """
        return self == ComponentType::Audio

    pub fn is_script(self) -> bool:
        """Check if type is Script.

        Returns:
            True if Script
        """
        return self == ComponentType::Script

    pub fn is_custom(self) -> bool:
        """Check if type is Custom.

        Returns:
            True if Custom
        """
        return self == ComponentType::Custom

    pub fn is_visual(self) -> bool:
        """Check if component type affects visual output.

        Returns:
            True for Render

        Example:
            ComponentType::Render.is_visual()  # → true
        """
        return self == ComponentType::Render

    pub fn is_simulation(self) -> bool:
        """Check if component type affects physics simulation.

        Returns:
            True for Physics or Transform

        Example:
            ComponentType::Physics.is_simulation()  # → true
        """
        return self == ComponentType::Physics or self == ComponentType::Transform

    pub fn is_output(self) -> bool:
        """Check if component type produces output (visual or audio).

        Returns:
            True for Render or Audio

        Example:
            ComponentType::Audio.is_output()  # → true
        """
        return self == ComponentType::Render or self == ComponentType::Audio

    pub fn summary(self) -> String:
        """Get component type summary.

        Returns:
            Human-readable summary

        Example:
            ComponentType::Physics.summary()
            # → "ComponentType: Physics (Physics simulation and collision, simulation)"
        """
        val name = self.to_string()
        val desc = self.description()
        var props = []

        if self.is_visual():
            props.push("visual")
        if self.is_simulation():
            props.push("simulation")
        if self.is_output():
            props.push("output")

        if props.len() > 0:
            val props_str = ", ".join(props)
            return "ComponentType: {name} ({desc}, {props_str})"
        else:
            return "ComponentType: {name} ({desc})"


# Component trait
# Common interface for all components
pub trait Component:
    # Lifecycle
    var fn init()
    var fn update(delta: f32)
    var fn destroy()

    # State
    fn is_enabled() -> bool
    var fn set_enabled(enabled: bool)
    fn is_initialized() -> bool

    # Owner
    fn get_owner_ptr() -> ffi.VoidPtr
    fn has_owner() -> bool

    # Metadata
    fn get_component_type() -> ComponentType
    fn get_component_name() -> String


# GodotComponentAdapter
# Adapts Godot Node (used as component) to Component trait
pub struct GodotComponentAdapter:
    component_ptr: ffi.VoidPtr
    component_type: ComponentType
    initialized: bool

impl GodotComponentAdapter:
    pub fn new(component_ptr: ffi.VoidPtr, component_type: ComponentType) -> GodotComponentAdapter:
        return GodotComponentAdapter(
            component_ptr: component_ptr,
            component_type: component_type,
            initialized: false,
        )

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn get_component_ptr(self) -> ffi.VoidPtr:
        """Get component pointer.

        Returns:
            Component pointer

        Example:
            adapter.get_component_ptr()
        """
        return self.component_ptr

    pub fn get_type(self) -> ComponentType:
        """Get component type (alias for get_component_type).

        Returns:
            Component type

        Example:
            adapter.get_type()  # → ComponentType::Physics
        """
        return self.component_type

    pub fn has_component(self) -> bool:
        """Check if has valid component pointer.

        Returns:
            true if pointer is not null

        Example:
            adapter.has_component()  # → true
        """
        return not ffi.is_null_ptr(self.component_ptr)

    pub fn is_ready(self) -> bool:
        """Check if component is initialized and ready.

        Returns:
            true if initialized

        Example:
            adapter.is_ready()  # → true
        """
        return self.initialized

    pub fn summary(self) -> String:
        """Get component adapter summary.

        Returns:
            Human-readable summary

        Example:
            adapter.summary()
            # → "GodotComponentAdapter: Physics, initialized"
        """
        val type_name = self.component_type.to_string()
        val status = if self.initialized { "initialized" } else { "not initialized" }
        return "GodotComponentAdapter: {type_name}, {status}"

impl Component for GodotComponentAdapter:
    var fn init():
        if not self.initialized:
            godot_component_init(self.component_ptr)
            self.initialized = true

    var fn update(delta: f32):
        godot_component_update(self.component_ptr, delta)

    var fn destroy():
        godot_component_destroy(self.component_ptr)
        self.initialized = false

    fn is_enabled() -> bool:
        return godot_component_is_enabled(self.component_ptr)

    var fn set_enabled(enabled: bool):
        godot_component_set_enabled(self.component_ptr, enabled)

    fn is_initialized() -> bool:
        return self.initialized

    fn get_owner_ptr() -> ffi.VoidPtr:
        return godot_component_get_owner(self.component_ptr)

    fn has_owner() -> bool:
        val owner = self.get_owner_ptr()
        return not ffi.is_null_ptr(owner)

    fn get_component_type() -> ComponentType:
        return self.component_type

    fn get_component_name() -> String:
        val name_ptr = godot_component_get_name(self.component_ptr)
        return ffi.string_from_ptr(name_ptr)


# UnrealComponentAdapter
# Adapts Unreal UActorComponent to Component trait
pub struct UnrealComponentAdapter:
    component_ptr: ffi.VoidPtr
    component_type: ComponentType
    initialized: bool

impl UnrealComponentAdapter:
    pub fn new(component_ptr: ffi.VoidPtr, component_type: ComponentType) -> UnrealComponentAdapter:
        return UnrealComponentAdapter(
            component_ptr: component_ptr,
            component_type: component_type,
            initialized: false,
        )

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn get_component_ptr(self) -> ffi.VoidPtr:
        """Get component pointer.

        Returns:
            Component pointer

        Example:
            adapter.get_component_ptr()
        """
        return self.component_ptr

    pub fn get_type(self) -> ComponentType:
        """Get component type (alias for get_component_type).

        Returns:
            Component type

        Example:
            adapter.get_type()  # → ComponentType::Render
        """
        return self.component_type

    pub fn has_component(self) -> bool:
        """Check if has valid component pointer.

        Returns:
            true if pointer is not null

        Example:
            adapter.has_component()  # → true
        """
        return not ffi.is_null_ptr(self.component_ptr)

    pub fn is_ready(self) -> bool:
        """Check if component is initialized and ready.

        Returns:
            true if initialized

        Example:
            adapter.is_ready()  # → false
        """
        return self.initialized

    pub fn summary(self) -> String:
        """Get component adapter summary.

        Returns:
            Human-readable summary

        Example:
            adapter.summary()
            # → "UnrealComponentAdapter: Render, not initialized"
        """
        val type_name = self.component_type.to_string()
        val status = if self.initialized { "initialized" } else { "not initialized" }
        return "UnrealComponentAdapter: {type_name}, {status}"

impl Component for UnrealComponentAdapter:
    var fn init():
        if not self.initialized:
            unreal_component_init(self.component_ptr)
            self.initialized = true

    var fn update(delta: f32):
        unreal_component_tick(self.component_ptr, delta)

    var fn destroy():
        unreal_component_destroy(self.component_ptr)
        self.initialized = false

    fn is_enabled() -> bool:
        return unreal_component_is_active(self.component_ptr)

    var fn set_enabled(enabled: bool):
        unreal_component_set_active(self.component_ptr, enabled)

    fn is_initialized() -> bool:
        return self.initialized

    fn get_owner_ptr() -> ffi.VoidPtr:
        return unreal_component_get_owner(self.component_ptr)

    fn has_owner() -> bool:
        val owner = self.get_owner_ptr()
        return not ffi.is_null_ptr(owner)

    fn get_component_type() -> ComponentType:
        return self.component_type

    fn get_component_name() -> String:
        val name_ptr = unreal_component_get_name(self.component_ptr)
        return ffi.string_from_ptr(name_ptr)


# ComponentManager
# Manages components on an entity
pub struct ComponentManager:
    components: Vec[Component]

impl ComponentManager:
    pub fn new() -> ComponentManager:
        return ComponentManager(components: [])

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn count(self) -> i32:
        """Get number of components (alias for components.len()).

        Returns:
            Component count

        Example:
            manager.count()  # → 5
        """
        return self.components.len()

    pub fn is_empty(self) -> bool:
        """Check if manager has no components.

        Returns:
            true if empty

        Example:
            manager.is_empty()  # → false
        """
        return self.components.len() == 0

    pub fn has_components(self) -> bool:
        """Check if manager has any components.

        Returns:
            true if has components

        Example:
            manager.has_components()  # → true
        """
        return self.components.len() > 0

    pub fn has_component_type(self, component_type: ComponentType) -> bool:
        """Check if has component of given type.

        Args:
            component_type: Component type to check

        Returns:
            true if type exists

        Example:
            manager.has_component_type(ComponentType::Physics)  # → true
        """
        for component in self.components:
            if component.get_component_type() == component_type:
                return true
        return false

    pub fn count_by_type(self, component_type: ComponentType) -> i32:
        """Count components of given type.

        Args:
            component_type: Component type to count

        Returns:
            Number of components of type

        Example:
            manager.count_by_type(ComponentType::Render)  # → 2
        """
        var count = 0
        for component in self.components:
            if component.get_component_type() == component_type:
                count += 1
        return count

    pub fn count_enabled(self) -> i32:
        """Count enabled components.

        Returns:
            Number of enabled components

        Example:
            manager.count_enabled()  # → 3
        """
        var count = 0
        for component in self.components:
            if component.is_enabled():
                count += 1
        return count

    pub fn count_initialized(self) -> i32:
        """Count initialized components.

        Returns:
            Number of initialized components

        Example:
            manager.count_initialized()  # → 4
        """
        var count = 0
        for component in self.components:
            if component.is_initialized():
                count += 1
        return count

    pub fn all_initialized(self) -> bool:
        """Check if all components are initialized.

        Returns:
            true if all initialized

        Example:
            manager.all_initialized()  # → true
        """
        for component in self.components:
            if not component.is_initialized():
                return false
        return true

    pub fn summary(self) -> String:
        """Get component manager summary.

        Returns:
            Human-readable summary

        Example:
            manager.summary()
            # → "ComponentManager: 5 components, 4 enabled, 4 initialized"
        """
        val total = self.count()
        val enabled = self.count_enabled()
        val initialized = self.count_initialized()
        return "ComponentManager: {total} components, {enabled} enabled, {initialized} initialized"

    # Add component
    pub fn add_component(mut self, component: Component):
        self.components.push(component)

    # Remove component by index
    pub fn remove_component(mut self, index: i32):
        if index >= 0 and index < self.components.len():
            var new_components = Vec::new()
            for i in 0..self.components.len():
                if i != index:
                    new_components.push(self.components[i])
            self.components = new_components

    # Get component by type
    pub fn get_component_by_type(self, component_type: ComponentType) -> Option[Component]:
        for component in self.components:
            if component.get_component_type() == component_type:
                return Some(component)
        return None

    # Get all components
    pub fn get_all_components(self) -> Vec[Component]:
        return self.components

    # Update all components
    pub fn update_all(mut self, delta: f32):
        for mut component in self.components:
            if component.is_enabled():
                component.update(delta)

    # Initialize all components
    pub fn init_all(mut self):
        for mut component in self.components:
            if not component.is_initialized():
                component.init()

    # Destroy all components
    pub fn destroy_all(mut self):
        for mut component in self.components:
            component.destroy()
        self.components = []


# RenderComponent trait
# Specialized component for rendering
pub trait RenderComponent: Component:
    fn get_mesh() -> ffi.VoidPtr
    var fn set_mesh(mesh_ptr: ffi.VoidPtr)
    fn get_material() -> ffi.VoidPtr
    var fn set_material(material_ptr: ffi.VoidPtr)
    fn is_visible() -> bool
    var fn set_visible(visible: bool)


# PhysicsComponent trait
# Specialized component for physics
pub trait PhysicsComponent: Component:
    fn get_mass() -> f32
    var fn set_mass(mass: f32)
    fn get_velocity() -> (f32, f32, f32)
    var fn set_velocity(vx: f32, vy: f32, vz: f32)
    var fn apply_force(fx: f32, fy: f32, fz: f32)
    var fn apply_impulse(ix: f32, iy: f32, iz: f32)


# AudioComponent trait
# Specialized component for audio
pub trait AudioComponent: Component:
    var fn play()
    me stop(self)
    var fn pause()
    me resume(self)
    fn is_playing() -> bool
    fn get_volume() -> f32
    var fn set_volume(volume: f32)
    fn get_pitch() -> f32
    var fn set_pitch(pitch: f32)


# FFI declarations for Godot components
extern "C":
    fn godot_component_init(component: ffi.VoidPtr)
    fn godot_component_update(component: ffi.VoidPtr, delta: f32)
    fn godot_component_destroy(component: ffi.VoidPtr)
    fn godot_component_is_enabled(component: ffi.VoidPtr) -> bool
    fn godot_component_set_enabled(component: ffi.VoidPtr, enabled: bool)
    fn godot_component_get_owner(component: ffi.VoidPtr) -> ffi.VoidPtr
    fn godot_component_get_name(component: ffi.VoidPtr) -> ffi.VoidPtr

# FFI declarations for Unreal components
extern "C":
    fn unreal_component_init(component: ffi.VoidPtr)
    fn unreal_component_tick(component: ffi.VoidPtr, delta: f32)
    fn unreal_component_destroy(component: ffi.VoidPtr)
    fn unreal_component_is_active(component: ffi.VoidPtr) -> bool
    fn unreal_component_set_active(component: ffi.VoidPtr, active: bool)
    fn unreal_component_get_owner(component: ffi.VoidPtr) -> ffi.VoidPtr
    fn unreal_component_get_name(component: ffi.VoidPtr) -> ffi.VoidPtr


# Example usage:
#
# # Create component manager
# var manager = ComponentManager::new()
#
# # Add Godot component
# val godot_comp = GodotComponentAdapter::new(godot_ptr, ComponentType::Render)
# manager.add_component(godot_comp)
#
# # Add Unreal component
# val unreal_comp = UnrealComponentAdapter::new(unreal_ptr, ComponentType::Physics)
# manager.add_component(unreal_comp)
#
# # Initialize and update
# manager.init_all()
# manager.update_all(0.016)  # 60 FPS
#
# # Query by type
# val render_comp = manager.get_component_by_type(ComponentType::Render)
# if render_comp.is_some():
#     val comp = render_comp.unwrap()
#     comp.set_enabled(true)
