"""
# Simple Language Metaprogramming - Test Specification

**Status:** Reference
**Feature IDs:** 
**Source:** metaprogramming.md
**Type:** Extracted Examples (Category B)

## Overview

This file contains executable test cases extracted from metaprogramming.md.
The original specification file remains as architectural reference documentation.

**Note:** This is a test extraction file. For complete specification text,
design rationale, and architecture, see doc/spec/metaprogramming.md

## Extracted Test Cases

24 test cases extracted covering:
- Core functionality examples
- Edge cases and validation
- Integration patterns
"""

## Test: DSL Features (Line ~9)

"""
A context block changes the method lookup context for a section of code:
"""
test "dsl_features_1":
    class HTMLBuilder:
        fn tag(name: String, content: String):
            print "<{name}>{content}</{name}>"

        fn method_missing(meth: Symbol, args: [Any], block: Fn):
            let tag_name = meth.name
            if block != nil:
                print "<{tag_name}>"
                block()
                print "</{tag_name}>"
            else:
                let content = args.size > 0 ? args[0] : ""
                print "<{tag_name}>{content}</{tag_name}>"

    let html = HTMLBuilder()
    context html:
        tag("h1", "Welcome")
        p "This is a DSL example."
        div:
            p "Inside a div."
            span "Nice!"
    assert_compiles()

## Test: DSL Features (Line ~39)

"""
If an object receives a call for a method it doesn't have, it can override `method_missing`:
"""
test "dsl_features_2":
    class ConfigDSL:
        data: Map<String, String> = {}

        fn method_missing(key: Symbol, args: [Any], block: Fn):
            if args.size == 1:
                data[key.name] = toString(args[0])
            elif args.size == 0 and block != nil:
                block()

    let config = ConfigDSL()
    context config:
        database "postgres"
        host "localhost"
        port 5432
    assert_compiles()

## Test: Decorators and Attributes (Line ~7)

"""
Decorators are functions that transform other functions at compile time:
"""
test "decorators_and_attributes_3":
    @cached
    fn expensive_calculation(x: i64) -> i64:
        return result

    @logged
    @retry(attempts: 3)
    fn fetch_data(url: str) -> Data:
        return http_get(url)

    @timeout(seconds: 30)
    fn slow_operation():
        # ...
    assert_compiles()

## Test: Decorators and Attributes (Line ~35)

"""
Attributes are passive metadata:
"""
test "decorators_and_attributes_4":
    #[inline]
    fn hot_path(x: i64) -> i64:
        return x * 2

    #[deprecated(since: "0.2", reason: "Use new_api instead")]
    fn old_api():
        # ...

    #[derive(Debug, Clone, Eq)]
    struct Point:
        x: f64
        y: f64

    #[test]
    fn test_addition():
        assert_eq(1 + 1, 2)
    assert_compiles()

## Test: Decorators and Attributes (Line ~69)

"""
The `#[allow(...)]` and `#[deny(...)]` attributes control compiler lint behavior:
"""
test "decorators_and_attributes_5":
    # Directory-level (in __init__.spl, inherits to all children)
    #[deny(primitive_api)]
    mod my_strict_module

    # Item-level
    #[allow(primitive_api)]
    pub fn low_level_function(x: i64) -> i64:   # No warning
        ...

    #[deny(primitive_api)]
    pub fn strict_function(x: i64) -> i64:      # Error
        ...
    assert_compiles()

## Test: Comprehensions (Line ~7)

"""
Simple supports Python-style comprehensions for concise collection construction.
"""
test "comprehensions_6":
    # Basic
    let squares = [x * x for x in 0..10]

    # With filter
    let evens = [for x in 0..20 if x % 2 == 0: x]

    # Nested
    let pairs = [(x, y) for x in 0..3 for y in 0..3]

    # Complex
    let names = [user.name.upper() for user in users if user.active]
    assert_compiles()

## Test: Comprehensions (Line ~23)

"""
```simple
# Basic
let squares = [x * x for x in 0..10]
"""
test "comprehensions_7":
    let squares = {x: x * x for x in 0..10}
    let active_users = {u.id: u for u in users if u.active}
    let inverted = {v: k for k, v in original}
    assert_compiles()

## Test: Slicing and Indexing (Line ~5)

test "slicing_and_indexing_8":
    let items = [1, 2, 3, 4, 5]
    items[-1]     # 5 (last element)
    items[-2]     # 4 (second to last)
    assert_compiles()

## Test: Slicing and Indexing (Line ~13)

"""
```simple
let items = [1, 2, 3, 4, 5]
items[-1]     # 5 (last element)
items[-2]     # 4 (second to ...
"""
test "slicing_and_indexing_9":
    let items = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

    items[2:5]      # [2, 3, 4]
    items[:3]       # [0, 1, 2]
    items[7:]       # [7, 8, 9]
    items[::2]      # [0, 2, 4, 6, 8]
    items[::-1]     # [9, 8, ..., 0] (reversed)
    items[-3:]      # [7, 8, 9] (last 3)
    assert_compiles()

## Test: Slicing and Indexing (Line ~26)

"""
items[2:5]      # [2, 3, 4]
items[:3]       # [0, 1, 2]
items[7:]       # [7, 8, 9]
items[::2]      ...
"""
test "slicing_and_indexing_10":
    let a, b = (1, 2)
    a, b = b, a           # Swap

    let first, *rest = [1, 2, 3, 4, 5]
    # first = 1, rest = [2, 3, 4, 5]
    assert_compiles()

## Test: Slicing and Indexing (Line ~36)

"""
let first, *rest = [1, 2, 3, 4, 5]
# first = 1, rest = [2, 3, 4, 5]
```
"""
test "slicing_and_indexing_11":
    let a = [1, 2, 3]
    let b = [4, 5, 6]
    let combined = [*a, *b]        # [1, 2, 3, 4, 5, 6]

    let d1 = {"a": 1}
    let d2 = {"b": 2}
    let merged = {**d1, **d2}      # {"a": 1, "b": 2}
    assert_compiles()

## Test: Enhanced Pattern Matching (Line ~5)

"""
Enhanced Pattern Matching
"""
test "enhanced_pattern_matching_12":
    match value:
        case x if x > 0:
            print "positive"
        case x if x < 0:
            print "negative"
        case 0:
            print "zero"
    assert_compiles()

## Test: Enhanced Pattern Matching (Line ~17)

"""
```simple
match value:
    case x if x > 0:
        print "positive"
    case x if x < 0:
        pr...
"""
test "enhanced_pattern_matching_13":
    match command:
        case "quit" | "exit" | "q":
            shutdown()
        case "help" | "h" | "?":
            show_help()
    assert_compiles()

## Test: Enhanced Pattern Matching (Line ~27)

"""
```simple
match command:
    case "quit" | "exit" | "q":
        shutdown()
    case "help" | "h" | ...
"""
test "enhanced_pattern_matching_14":
    match score:
        case 90..100: "A"
        case 80..90: "B"
        case 70..80: "C"
        case _: "F"
    assert_compiles()

## Test: Enhanced Pattern Matching (Line ~37)

"""
```simple
match score:
    case 90..100: "A"
    case 80..90: "B"
    case 70..80: "C"
    case _: "...
"""
test "enhanced_pattern_matching_15":
    if let Some(value) = optional:
        print "got {value}"

    while let Some(item) = iterator.next():
        process(item)
    assert_compiles()

## Test: Enhanced Pattern Matching (Line ~49)

"""
The `while with` construct combines a `while` loop condition with a context manager, useful for rend...
"""
test "enhanced_pattern_matching_16":
    # Render loop: continues while window is open, frame context managed per iteration
    while with window.frame() as frame:
        frame.clear([0.0, 0.0, 0.0, 1.0])
        frame.draw(pipeline, vertices)
    # Window closed, loop exits

    # Streaming: continues while data available
    while with stream.next_chunk() as chunk:
        process(chunk)
    # Stream exhausted
    assert_compiles()

## Test: Enhanced Pattern Matching (Line ~78)

"""
Comparison with nested `while`/`with`:
"""
test "enhanced_pattern_matching_17":
    # Traditional nested approach
    while !window.should_close():
        with window.frame() as frame:
            frame.draw(...)

    # Unified while-with approach (condition implied by context manager)
    while with window.frame() as frame:
        frame.draw(...)
    assert_compiles()

## Test: Enhanced Pattern Matching (Line ~98)

"""
Implementation Note: The context manager must implement `ContextManager` trait and optionally return...
"""
test "enhanced_pattern_matching_18":
    if 0 < x < 10:
        print "single digit"
    assert_compiles()

## Test: Context Managers (Line ~5)

"""
Context managers ensure proper resource cleanup:
"""
test "context_managers_19":
    with open("file.txt") as file:
        let content = file.read()
    # file is automatically closed

    with open("in.txt") as input, open("out.txt", "w") as output:
        output.write(transform(input.read()))
    assert_compiles()

## Test: Context Managers (Line ~16)

"""
with open("in.txt") as input, open("out.txt", "w") as output:
    output.write(transform(input.read(...
"""
test "context_managers_20":
    trait ContextManager:
        fn enter() -> Self
        fn exit(error: Option<Error>)

    impl ContextManager for File:
        fn enter() -> File:
            return self

        fn exit(error: Option<Error>):
            self.close()
    assert_compiles()

## Test: Move Closures (Line ~5)

"""
By default, closures capture variables by reference. Use `move` to capture by value:
"""
fn create_counter(start: i64) -> Fn() -> i64:
    let count = start
    return move \:
        count = count + 1
        count

let counter = create_counter(0)
counter()  # 1
counter()  # 2

## Test: Move Closures (Line ~22)

"""
Move closures are essential for:
- Sending closures to other actors
- Storing closures that outlive ...
"""
test "move_closures_22":
    actor.send(move \: process(captured_data))
    items.par_map(move \x: expensive_compute(x, config))
    assert_compiles()

## Test: Error Handling (Line ~7)

"""
Simple uses explicit error handling with Result types and the `?` operator.
"""
test "error_handling_23":
    enum Result<T, E>:
        Ok(value: T)
        Err(error: E)

    fn divide(a: i64, b: i64) -> Result<i64, str>:
        if b == 0:
            return Err("division by zero")
        return Ok(a / b)
    assert_compiles()

## Test: Error Handling (Line ~20)

"""
fn divide(a: i64, b: i64) -> Result<i64, str>:
    if b == 0:
        return Err("division by zero")...
"""
fn process_file(path: str) -> Result<Data, Error>:
    let file = open(path)?           # Returns Err if open fails
    let content = file.read_all()?   # Returns Err if read fails
    let data = parse(content)?       # Returns Err if parse fails
    return Ok(data)

