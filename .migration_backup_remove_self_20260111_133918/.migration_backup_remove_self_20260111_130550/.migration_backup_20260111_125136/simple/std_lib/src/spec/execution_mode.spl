# Execution Mode API (#2050)
# Core API for defining and managing execution modes in spec tests

## ExecutionMode Enum
# Defines the available execution modes for test execution
enum ExecutionMode:
    # Interpreter mode - Direct execution without compilation
    Interpreter

    # JIT mode - Runtime compilation to native code in memory
    JIT

    # SMF Standalone (Cranelift) - AOT compilation to .smf binary
    SMF_Cranelift

    # SMF Standalone (LLVM) - AOT compilation to .smf binary via LLVM
    SMF_LLVM

impl ExecutionMode:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_interpreter() -> Bool:
        """Check if this is Interpreter mode."""
        match self:
            case Interpreter: true
            case _: false

    fn is_jit() -> Bool:
        """Check if this is JIT mode."""
        match self:
            case JIT: true
            case _: false

    fn is_smf_cranelift() -> Bool:
        """Check if this is SMF Cranelift mode."""
        match self:
            case SMF_Cranelift: true
            case _: false

    fn is_smf_llvm() -> Bool:
        """Check if this is SMF LLVM mode."""
        match self:
            case SMF_LLVM: true
            case _: false

    fn is_compiled() -> Bool:
        """Check if this is a compiled mode (JIT or SMF)."""
        match self:
            case Interpreter: false
            case _: true

    fn is_aot() -> Bool:
        """Check if this is an AOT (ahead-of-time) compiled mode."""
        match self:
            case SMF_Cranelift: true
            case SMF_LLVM: true
            case _: false

    fn is_smf() -> Bool:
        """Check if this is any SMF standalone mode."""
        match self:
            case SMF_Cranelift: true
            case SMF_LLVM: true
            case _: false

    fn uses_cranelift() -> Bool:
        """Check if this mode uses Cranelift backend."""
        match self:
            case JIT: true
            case SMF_Cranelift: true
            case _: false

    fn uses_llvm() -> Bool:
        """Check if this mode uses LLVM backend."""
        match self:
            case SMF_LLVM: true
            case _: false

    fn to_string() -> String:
        """Convert to string representation."""
        return mode_to_string(self)

    fn is_available() -> Bool:
        """Check if this mode is currently available."""
        return is_mode_available(self)

    fn summary() -> String:
        """Get summary of execution mode."""
        let name = self.to_string()
        let available = if self.is_available(): "available" else: "unavailable"
        let mode_type = if self.is_interpreter(): "interpreted"
                        else if self.is_jit(): "JIT-compiled"
                        else: "AOT-compiled"
        return "ExecutionMode: {name} ({mode_type}, {available})"

## ModeSet Type
# Set of execution modes with set operations
struct ModeSet:
    modes: List<ExecutionMode>

## ModeSet Implementation
# Factory methods and set operations
impl ModeSet:
    # Create a new ModeSet from a list of modes
    fn new(modes: List<ExecutionMode>) -> ModeSet:
        ModeSet { modes: modes }

    # Create a ModeSet with all available modes
    fn all() -> ModeSet:
        ModeSet {
            modes: [
                ExecutionMode.Interpreter,
                ExecutionMode.JIT,
                ExecutionMode.SMF_Cranelift,
                ExecutionMode.SMF_LLVM
            ]
        }

    # Create a ModeSet with only interpreter mode
    fn interpreter_only() -> ModeSet:
        ModeSet { modes: [ExecutionMode.Interpreter] }

    # Create a ModeSet with only compiled modes (no interpreter)
    fn compiled_only() -> ModeSet:
        ModeSet {
            modes: [
                ExecutionMode.JIT,
                ExecutionMode.SMF_Cranelift,
                ExecutionMode.SMF_LLVM
            ]
        }

    # Check if a mode is in the set
    fn contains(mode: ExecutionMode) -> Bool:
        for m in self.modes:
            if m == mode:
                return true
        return false

    # Add a mode to the set
    fn add(mode: ExecutionMode) -> ModeSet:
        if self.contains(mode):
            return self
        let mut new_modes = []
        for m in self.modes:
            new_modes.push(m)
        new_modes.push(mode)
        ModeSet.new(new_modes)

    # Remove a mode from the set
    fn remove(mode: ExecutionMode) -> ModeSet:
        let mut new_modes = []
        for m in self.modes:
            if m != mode:
                new_modes.push(m)
        ModeSet.new(new_modes)

    # Union of two mode sets
    fn union_with(other: ModeSet) -> ModeSet:
        let mut result_modes = []
        # Add all modes from self
        for mode in self.modes:
            result_modes.push(mode)
        # Add modes from other that aren't already present
        for mode in other.modes:
            let mut found = false
            for existing in result_modes:
                if existing == mode:
                    found = true
                    break
            if not found:
                result_modes.push(mode)
        ModeSet.new(result_modes)

    # Intersection of two mode sets
    fn intersect(other: ModeSet) -> ModeSet:
        let mut result_modes = []
        for mode in self.modes:
            if other.contains(mode):
                result_modes.push(mode)
        ModeSet.new(result_modes)

    # Difference of two mode sets (modes in self but not in other)
    fn difference(other: ModeSet) -> ModeSet:
        let mut result_modes = []
        for mode in self.modes:
            if not other.contains(mode):
                result_modes.push(mode)
        ModeSet.new(result_modes)

    # Check if mode set is empty
    fn is_empty() -> Bool:
        len(self.modes) == 0

    # Get the number of modes in the set
    fn size() -> Int:
        len(self.modes)

    # Get a list of modes
    fn to_list() -> List<ExecutionMode>:
        self.modes

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn has_interpreter() -> Bool:
        """Check if set contains Interpreter mode."""
        return self.contains(ExecutionMode.Interpreter)

    fn has_jit() -> Bool:
        """Check if set contains JIT mode."""
        return self.contains(ExecutionMode.JIT)

    fn has_smf_cranelift() -> Bool:
        """Check if set contains SMF Cranelift mode."""
        return self.contains(ExecutionMode.SMF_Cranelift)

    fn has_smf_llvm() -> Bool:
        """Check if set contains SMF LLVM mode."""
        return self.contains(ExecutionMode.SMF_LLVM)

    fn has_compiled_modes() -> Bool:
        """Check if set contains any compiled modes."""
        for mode in self.modes:
            if mode.is_compiled():
                return true
        return false

    fn has_aot_modes() -> Bool:
        """Check if set contains any AOT modes."""
        for mode in self.modes:
            if mode.is_aot():
                return true
        return false

    fn has_smf_modes() -> Bool:
        """Check if set contains any SMF modes."""
        return self.has_smf_cranelift() or self.has_smf_llvm()

    fn has_available_modes() -> Bool:
        """Check if set contains any available modes."""
        for mode in self.modes:
            if mode.is_available():
                return true
        return false

    fn count_available() -> Int:
        """Count number of available modes in set."""
        let mut count = 0
        for mode in self.modes:
            if mode.is_available():
                count += 1
        return count

    fn filter_available() -> ModeSet:
        """Get a new ModeSet with only available modes."""
        let mut available = []
        for mode in self.modes:
            if mode.is_available():
                available.push(mode)
        return ModeSet.new(available)

    fn is_single_mode() -> Bool:
        """Check if set contains exactly one mode."""
        return self.size() == 1

    fn is_subset_of(other: ModeSet) -> Bool:
        """Check if this set is a subset of another."""
        for mode in self.modes:
            if not other.contains(mode):
                return false
        return true

    fn is_superset_of(other: ModeSet) -> Bool:
        """Check if this set is a superset of another."""
        return other.is_subset_of(self)

    fn equals(other: ModeSet) -> Bool:
        """Check if two mode sets are equal."""
        return self.is_subset_of(other) and other.is_subset_of(self)

    fn summary() -> String:
        """Get summary of mode set."""
        if self.is_empty():
            return "ModeSet: empty"
        let count = self.size()
        let available_count = self.count_available()
        let mode_names = []
        for mode in self.modes:
            mode_names.push(mode.to_string())
        let names_str = mode_names.join(", ")
        return "ModeSet: {count} modes ({available_count} available) - [{names_str}]"

## Execution Mode Names
# Convert ExecutionMode to string representation
fn mode_to_string(mode: ExecutionMode) -> String:
    match mode:
        case ExecutionMode.Interpreter => "interpreter"
        case ExecutionMode.JIT => "jit"
        case ExecutionMode.SMF_Cranelift => "smf_cranelift"
        case ExecutionMode.SMF_LLVM => "smf_llvm"

# Parse string to ExecutionMode
fn string_to_mode(s: String) -> Option<ExecutionMode>:
    match s:
        case "interpreter" => Some(ExecutionMode.Interpreter)
        case "jit" => Some(ExecutionMode.JIT)
        case "smf_cranelift" => Some(ExecutionMode.SMF_Cranelift)
        case "smf_llvm" => Some(ExecutionMode.SMF_LLVM)
        case _ => None

# Check if a mode is currently available for execution
fn is_mode_available(mode: ExecutionMode) -> Bool:
    match mode:
        case ExecutionMode.Interpreter => true  # Always available
        case ExecutionMode.JIT => true          # Cranelift JIT available
        case ExecutionMode.SMF_Cranelift => true # Cranelift AOT available
        case ExecutionMode.SMF_LLVM => false    # LLVM not yet implemented

# Get all currently available modes
fn get_available_modes() -> ModeSet:
    let mut modes = []
    for mode in ModeSet.all().to_list():
        if is_mode_available(mode):
            modes.push(mode)
    ModeSet.new(modes)

## Exports
export ExecutionMode
export ModeSet
export mode_to_string
export string_to_mode
export is_mode_available
export get_available_modes
