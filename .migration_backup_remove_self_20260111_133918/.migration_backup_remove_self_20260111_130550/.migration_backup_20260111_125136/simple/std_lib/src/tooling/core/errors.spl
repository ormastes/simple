# Error Aggregation Across Languages
# Collect and normalize errors from multiple language compilers

use tooling.core.project.Language
use tooling.compiler.interface.{CompilationError, ErrorSeverity}
use sdn.{SdnValue, to_sdn}

# Error output format
pub enum ErrorFormat:
    Terminal    # Human-readable terminal output
    JSON        # JSON array of errors
    XML         # JUnit XML format
    VSCode      # VS Code problem matcher format

    pub fn to_string(self): String =
        """Convert format to string.

        Returns:
            Format name

        Example:
            ErrorFormat::JSON.to_string()  # → "json"
        """
        match self:
            ErrorFormat::Terminal: "terminal"
            ErrorFormat::JSON: "json"
            ErrorFormat::XML: "xml"
            ErrorFormat::VSCode: "vscode"

    pub fn description(self): String =
        """Get format description.

        Returns:
            Human-readable description
        """
        match self:
            ErrorFormat::Terminal: "Human-readable terminal output"
            ErrorFormat::JSON: "JSON array for tools and CI"
            ErrorFormat::XML: "JUnit XML for CI systems"
            ErrorFormat::VSCode: "VS Code problem matcher format"

    pub fn is_machine_readable(self): bool =
        """Check if format is machine-readable.

        Returns:
            True if JSON or XML
        """
        match self:
            ErrorFormat::Terminal: false
            ErrorFormat::JSON: true
            ErrorFormat::XML: true
            ErrorFormat::VSCode: true

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_terminal(self): bool =
        """Check if format is Terminal.

        Returns:
            True if Terminal format
        """
        match self:
            ErrorFormat::Terminal: true
            _: false

    pub fn is_json(self): bool =
        """Check if format is JSON.

        Returns:
            True if JSON format
        """
        match self:
            ErrorFormat::JSON: true
            _: false

    pub fn is_xml(self): bool =
        """Check if format is XML.

        Returns:
            True if XML format
        """
        match self:
            ErrorFormat::XML: true
            _: false

    pub fn is_vscode(self): bool =
        """Check if format is VSCode.

        Returns:
            True if VSCode format
        """
        match self:
            ErrorFormat::VSCode: true
            _: false

    pub fn is_human_readable(self): bool =
        """Check if format is human-readable.

        Returns:
            True if Terminal format
        """
        match self:
            ErrorFormat::Terminal: true
            _: false

    pub fn is_ci_compatible(self): bool =
        """Check if format is compatible with CI systems.

        Returns:
            True if XML or JSON
        """
        match self:
            ErrorFormat::XML: true
            ErrorFormat::JSON: true
            _: false

    pub fn supports_structured_data(self): bool =
        """Check if format supports structured data.

        Returns:
            True if JSON, XML, or VSCode format
        """
        self.is_machine_readable()

    pub fn file_extension(self): String =
        """Get typical file extension for this format.

        Returns:
            File extension (with dot)

        Example:
            ErrorFormat::JSON.file_extension()  # → ".json"
        """
        match self:
            ErrorFormat::Terminal: ".txt"
            ErrorFormat::JSON: ".json"
            ErrorFormat::XML: ".xml"
            ErrorFormat::VSCode: ".txt"

    pub fn mime_type(self): String =
        """Get MIME type for this format.

        Returns:
            MIME type string

        Example:
            ErrorFormat::JSON.mime_type()  # → "application/json"
        """
        match self:
            ErrorFormat::Terminal: "text/plain"
            ErrorFormat::JSON: "application/json"
            ErrorFormat::XML: "application/xml"
            ErrorFormat::VSCode: "text/plain"

    pub fn summary(self): String =
        """Get summary of error format.

        Returns:
            Human-readable summary

        Example:
            ErrorFormat::JSON.summary()
            # → "ErrorFormat: json (machine-readable, CI-compatible)"
        """
        let name = self.to_string()
        let readable = if self.is_machine_readable(): "machine-readable" else: "human-readable"
        let ci = if self.is_ci_compatible(): ", CI-compatible" else: ""
        "ErrorFormat: {name} ({readable}{ci})"

# Error aggregator - collects and normalizes errors
pub class ErrorAggregator:
    pub errors: List<CompilationError>
    pub warnings: List<CompilationError>
    pub infos: List<CompilationError>
    pub dedup_enabled: bool

    pub fn new(): ErrorAggregator =
        """Create error aggregator.

        Returns:
            Empty aggregator

        Example:
            let aggregator = ErrorAggregator.new()

            aggregator.add_simple_errors(simple_errors)
            aggregator.add_rust_errors(cargo_output)
            aggregator.add_python_errors(mypy_output)

            for error in aggregator.get_all():
                print(error.format())
        """
        ErrorAggregator {
            errors: [],
            warnings: [],
            infos: [],
            dedup_enabled: true
        }

    pub fn set_deduplication(self, enabled: bool):
        """Enable/disable error deduplication.

        Args:
            enabled: True to remove duplicate errors
        """
        self.dedup_enabled = enabled

    pub fn add_error(self, error: CompilationError):
        """Add compilation error.

        Args:
            error: Error to add
        """
        # Check for duplicate
        if self.dedup_enabled and self.is_duplicate(error):
            return

        match error.severity:
            ErrorSeverity::Error:
                self.errors.append(error)
            ErrorSeverity::Warning:
                self.warnings.append(error)
            ErrorSeverity::Info:
                self.infos.append(error)

    pub fn add_errors(self, errors: List<CompilationError>):
        """Add multiple errors.

        Args:
            errors: List of errors
        """
        for error in errors:
            self.add_error(error)

    pub fn add_simple_errors(self, errors: List<CompilationError>):
        """Add Simple compiler errors.

        Args:
            errors: Simple compiler errors
        """
        self.add_errors(errors)

    pub fn add_rust_errors(self, cargo_output: String):
        """Parse and add Rust/cargo errors.

        Args:
            cargo_output: Cargo JSON output
        """
        let errors = self.parse_cargo_json(cargo_output)
        self.add_errors(errors)

    pub fn add_python_errors(self, mypy_output: String):
        """Parse and add Python/mypy errors.

        Args:
            mypy_output: Mypy text output
        """
        let errors = self.parse_mypy_output(mypy_output)
        self.add_errors(errors)

    pub fn add_javascript_errors(self, eslint_output: String):
        """Parse and add JavaScript/ESLint errors.

        Args:
            eslint_output: ESLint JSON output
        """
        let errors = self.parse_eslint_json(eslint_output)
        self.add_errors(errors)

    fn is_duplicate(error: CompilationError): bool =
        """Check if error is duplicate.

        Args:
            error: Error to check

        Returns:
            True if duplicate exists
        """
        let all_errors = self.get_all()

        for existing in all_errors:
            if self.errors_equal(existing, error):
                return true

        false

    fn errors_equal(a: CompilationError, b: CompilationError): bool =
        """Check if two errors are equal.

        Args:
            a: First error
            b: Second error

        Returns:
            True if same file, line, column, and message
        """
        a.file == b.file and
        a.line == b.line and
        a.column == b.column and
        a.message == b.message

    pub fn get_all(self): List<CompilationError> =
        """Get all errors, warnings, and infos.

        Returns:
            Combined list sorted by severity
        """
        let mut all: List<CompilationError> = []
        all.extend(self.errors)
        all.extend(self.warnings)
        all.extend(self.infos)
        all

    pub fn get_by_severity(self, severity: ErrorSeverity): List<CompilationError> =
        """Get errors of specific severity.

        Args:
            severity: Error severity

        Returns:
            Filtered error list
        """
        match severity:
            ErrorSeverity::Error:
                self.errors.clone()
            ErrorSeverity::Warning:
                self.warnings.clone()
            ErrorSeverity::Info:
                self.infos.clone()

    pub fn group_by_file(self): Dict<String, List<CompilationError>> =
        """Group errors by file.

        Returns:
            Map from file to errors in that file

        Example:
            let by_file = aggregator.group_by_file()
            for (file, errors) in by_file:
                print("{file}: {errors.len()} errors")
        """
        let groups: Dict<String, List<CompilationError>> = {}

        for error in self.get_all():
            if not groups.contains_key(error.file):
                groups[error.file] = []

            groups[error.file].append(error)

        groups

    pub fn group_by_language(self): Dict<Language, List<CompilationError>> =
        """Group errors by language.

        Returns:
            Map from language to errors in that language
        """
        let groups: Dict<Language, List<CompilationError>> = {}

        for error in self.get_all():
            if not groups.contains_key(error.language):
                groups[error.language] = []

            groups[error.language].append(error)

        groups

    pub fn format_output(self, format: ErrorFormat): String =
        """Format errors for output.

        Args:
            format: Output format

        Returns:
            Formatted error string

        Example:
            # Terminal output
            print(aggregator.format_output(ErrorFormat::Terminal))

            # JSON for tools
            let json = aggregator.format_output(ErrorFormat::JSON)
        """
        match format:
            ErrorFormat::Terminal:
                self.format_terminal()
            ErrorFormat::JSON:
                self.format_json()
            ErrorFormat::XML:
                self.format_xml()
            ErrorFormat::VSCode:
                self.format_vscode()

    fn format_terminal(): String =
        """Format errors for terminal display.

        Returns:
            Human-readable error list
        """
        let mut output = ""

        if self.errors.len() > 0:
            output += "Errors:\n"
            for error in self.errors:
                output += "  {error.format()}\n"

        if self.warnings.len() > 0:
            output += "\nWarnings:\n"
            for warning in self.warnings:
                output += "  {warning.format()}\n"

        if self.infos.len() > 0:
            output += "\nInfo:\n"
            for info in self.infos:
                output += "  {info.format()}\n"

        if output.is_empty():
            output = "No errors\n"

        output

    fn format_json(): String =
        """Format errors as JSON array (using SDN).

        Returns:
            JSON-compatible string

        Format:
            [
              {
                "file": "app.spl",
                "line": 10,
                "column": 5,
                "severity": "error",
                "message": "Type mismatch",
                "language": "Simple"
              }
            ]
        """
        # Build SDN array of error objects
        let mut errors_array: List<SdnValue> = []

        for error in self.get_all():
            let mut error_dict: Dict<String, SdnValue> = {}

            error_dict["file"] = SdnValue::String(error.file)
            error_dict["line"] = SdnValue::Int(error.line as i64)
            error_dict["column"] = SdnValue::Int(error.column as i64)
            error_dict["severity"] = SdnValue::String(self.severity_to_string(error.severity))
            error_dict["message"] = SdnValue::String(error.message)
            error_dict["language"] = SdnValue::String(self.language_to_string(error.language))

            errors_array.append(SdnValue::Dict(error_dict))

        # Serialize to SDN (which is JSON-compatible for arrays)
        let sdn_array = SdnValue::Array(errors_array)
        to_sdn(sdn_array)

    fn severity_to_string(severity: ErrorSeverity): String =
        """Convert severity to string.

        Args:
            severity: Error severity

        Returns:
            Severity string
        """
        match severity:
            ErrorSeverity::Error: "error"
            ErrorSeverity::Warning: "warning"
            ErrorSeverity::Info: "info"

    fn language_to_string(language: Language): String =
        """Convert language to string.

        Args:
            language: Language enum

        Returns:
            Language name
        """
        match language:
            Language::Simple: "Simple"
            Language::Rust: "Rust"
            Language::Python: "Python"
            Language::JavaScript: "JavaScript"
            Language::TypeScript: "TypeScript"
            Language::Go: "Go"
            Language::C: "C"
            Language::Cpp: "Cpp"

    fn format_xml(): String =
        """Format errors as JUnit XML.

        Returns:
            XML string for CI systems

        Format:
            <testsuites>
              <testsuite name="compilation" tests="1" errors="3" failures="0">
                <testcase name="build" classname="compilation">
                  <error message="Type mismatch" type="error">
                    app.spl:10:5: Type mismatch
                  </error>
                </testcase>
              </testsuite>
            </testsuites>
        """
        let total_errors = self.errors.len()
        let total_warnings = self.warnings.len()

        let mut xml = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
        xml += "<testsuites>\n"
        xml += "  <testsuite name=\"compilation\" tests=\"1\" "
        xml += "errors=\"{total_errors}\" failures=\"{total_warnings}\" skipped=\"0\">\n"
        xml += "    <testcase name=\"build\" classname=\"compilation\">\n"

        # Add errors
        for error in self.errors:
            xml += "      <error message=\"{self.escape_xml(error.message)}\" type=\"error\">\n"
            xml += "        {self.escape_xml(error.file)}:{error.line}:{error.column}: {self.escape_xml(error.message)}\n"
            xml += "      </error>\n"

        # Add warnings as failures
        for warning in self.warnings:
            xml += "      <failure message=\"{self.escape_xml(warning.message)}\" type=\"warning\">\n"
            xml += "        {self.escape_xml(warning.file)}:{warning.line}:{warning.column}: {self.escape_xml(warning.message)}\n"
            xml += "      </failure>\n"

        xml += "    </testcase>\n"
        xml += "  </testsuite>\n"
        xml += "</testsuites>\n"

        xml

    fn escape_xml(text: String): String =
        """Escape XML special characters.

        Args:
            text: Text to escape

        Returns:
            Escaped text
        """
        let mut result = text
        result = result.replace("&", "&amp;")
        result = result.replace("<", "&lt;")
        result = result.replace(">", "&gt;")
        result = result.replace("\"", "&quot;")
        result = result.replace("'", "&apos;")
        result

    fn format_vscode(): String =
        """Format errors for VS Code problem matcher.

        Returns:
            VS Code problem format
        """
        # VS Code format: file(line,col): severity: message
        let mut output = ""

        for error in self.get_all():
            let severity_str = match error.severity:
                ErrorSeverity::Error: "error"
                ErrorSeverity::Warning: "warning"
                ErrorSeverity::Info: "info"

            output += "{error.file}({error.line},{error.column}): {severity_str}: {error.message}\n"

        output

    # Language-specific parsers

    fn parse_cargo_json(json_output: String): List<CompilationError> =
        """Parse Cargo JSON diagnostic output.

        Args:
            json_output: Cargo --message-format=json output

        Returns:
            List of errors
        """
        # TODO: [stdlib][P1] Implement JSON parsing
        []

    fn parse_mypy_output(output: String): List<CompilationError> =
        """Parse mypy text output.

        Args:
            output: Mypy stdout

        Returns:
            List of errors

        Format: file:line: error: message
        """
        let errors: List<CompilationError> = []

        let lines = output.split("\n")
        for line in lines:
            if line.trim().is_empty():
                continue

            # Try to parse error line
            match self.try_parse_mypy_line(line):
                some(error):
                    errors.append(error)
                none:
                    pass  # Skip non-error lines

        errors

    fn try_parse_mypy_line(line: String): Option<CompilationError> =
        """Try to parse single mypy error line.

        Args:
            line: Error line

        Returns:
            Parsed error or none

        Format: file.py:line: severity: message
        Example: app.py:10: error: Type mismatch
        """
        # Find first colon (after filename)
        let first_colon = line.find(":")
        if first_colon < 0:
            return none

        let file = line[0:first_colon].trim()

        # Find second colon (after line number)
        let rest = line[first_colon+1:]
        let second_colon = rest.find(":")
        if second_colon < 0:
            return none

        let line_str = rest[0:second_colon].trim()
        let line_num = self.parse_int_safe(line_str)

        # Find third colon (after severity)
        let rest2 = rest[second_colon+1:]
        let third_colon = rest2.find(":")
        if third_colon < 0:
            return none

        let severity_str = rest2[0:third_colon].trim()
        let message = rest2[third_colon+1:].trim()

        # Parse severity
        let severity = match severity_str:
            "error": ErrorSeverity::Error
            "warning": ErrorSeverity::Warning
            "note": ErrorSeverity::Info
            "info": ErrorSeverity::Info
            _: ErrorSeverity::Error

        some(CompilationError {
            file: file,
            line: line_num,
            column: 0,  # mypy doesn't always provide column
            message: message,
            severity: severity,
            language: Language::Python
        })

    fn parse_int_safe(s: String): i32 =
        """Parse integer safely, returning 0 on error.

        Args:
            s: String to parse

        Returns:
            Parsed integer or 0
        """
        let trimmed = s.trim()
        if trimmed.is_empty():
            return 0

        let mut result = 0
        for i in 0..trimmed.len():
            let ch = trimmed[i]
            if ch >= '0' and ch <= '9':
                let digit = (ch as i32) - ('0' as i32)
                result = result * 10 + digit
            else:
                return 0  # Non-digit found

        result

    fn parse_eslint_json(json_output: String): List<CompilationError> =
        """Parse ESLint JSON output.

        Args:
            json_output: ESLint --format=json output

        Returns:
            List of errors
        """
        # TODO: [stdlib][P1] Implement JSON parsing
        []

    pub fn print_summary(self):
        """Print error summary.

        Example:
            aggregator.print_summary()
            # → "3 errors, 5 warnings, 2 infos"
        """
        let total_errors = self.errors.len()
        let total_warnings = self.warnings.len()
        let total_infos = self.infos.len()

        print("{total_errors} errors, {total_warnings} warnings, {total_infos} infos")

    pub fn has_errors(self): bool =
        """Check if any errors exist.

        Returns:
            True if errors (not warnings) exist
        """
        self.errors.len() > 0

    pub fn total_count(self): i32 =
        """Get total error/warning/info count.

        Returns:
            Total count across all severities
        """
        self.errors.len() + self.warnings.len() + self.infos.len()

    pub fn is_empty(self): bool =
        """Check if aggregator has no errors/warnings/infos.

        Returns:
            True if empty
        """
        self.total_count() == 0

    pub fn summary(self): String =
        """Get error summary.

        Returns:
            Human-readable summary

        Example:
            aggregator.summary()
            # → "3 errors, 5 warnings, 2 infos"
        """
        "{self.errors.len()} errors, {self.warnings.len()} warnings, {self.infos.len()} infos"

    pub fn error_count(self): i32 =
        """Get error count.

        Returns:
            Number of errors
        """
        self.errors.len()

    pub fn warning_count(self): i32 =
        """Get warning count.

        Returns:
            Number of warnings
        """
        self.warnings.len()

    pub fn info_count(self): i32 =
        """Get info count.

        Returns:
            Number of infos
        """
        self.infos.len()
