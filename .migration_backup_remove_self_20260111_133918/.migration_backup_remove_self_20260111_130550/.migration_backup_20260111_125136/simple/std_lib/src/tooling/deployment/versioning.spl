# Version Management
# Manage versioning across multi-language projects

use core.result.{Result, Ok, Err}

# Semantic version
pub class SemVer:
    pub major: i32
    pub minor: i32
    pub patch: i32
    pub prerelease: String
    pub build_metadata: String

    pub fn new(major: i32, minor: i32, patch: i32): SemVer =
        """Create semantic version.

        Args:
            major: Major version
            minor: Minor version
            patch: Patch version

        Returns:
            Semantic version

        Example:
            let v = SemVer.new(1, 2, 3)
            print(v.to_string())  # → "1.2.3"
        """
        SemVer {
            major: major,
            minor: minor,
            patch: patch,
            prerelease: "",
            build_metadata: ""
        }

    pub fn parse(version_str: String): Result<SemVer, String> =
        """Parse version string.

        Args:
            version_str: Version string (e.g., "1.2.3", "2.0.0-beta.1")

        Returns:
            Parsed version or error

        Supports:
        - Basic: "1.2.3"
        - Prerelease: "1.2.3-beta.1", "1.2.3-alpha"
        - Build metadata: "1.2.3+20240110"
        - Combined: "1.2.3-beta.1+build.123"

        Example:
            match SemVer.parse("1.2.3"):
                Ok(v):
                    print("Version: {v.major}.{v.minor}.{v.patch}")
                Err(e):
                    print("Parse error: {e}")
        """
        # Clean version string
        let trimmed = version_str.trim()

        # Extract build metadata (after '+')
        let (core_and_pre, build_meta) = self.split_on_plus(trimmed)

        # Extract prerelease (after '-')
        let (core, prerelease) = self.split_on_dash(core_and_pre)

        # Parse core version (MAJOR.MINOR.PATCH)
        let parts = core.split(".")
        if parts.len() != 3:
            return Err("Invalid version format: expected MAJOR.MINOR.PATCH, got '" + core + "'")

        # Parse major
        let major = self.parse_int(parts[0])?

        # Parse minor
        let minor = self.parse_int(parts[1])?

        # Parse patch
        let patch = self.parse_int(parts[2])?

        # Build version
        let mut version = SemVer.new(major, minor, patch)
        version.prerelease = prerelease
        version.build_metadata = build_meta

        Ok(version)

    fn split_on_plus(text: String): (String, String) =
        """Split on '+' for build metadata.

        Args:
            text: Version string

        Returns:
            (core_and_prerelease, build_metadata)
        """
        let plus_idx = text.find("+")
        if plus_idx >= 0:
            let before = text[0:plus_idx]
            let after = text[plus_idx+1:]
            (before, after)
        else:
            (text, "")

    fn split_on_dash(text: String): (String, String) =
        """Split on '-' for prerelease.

        Args:
            text: Version string

        Returns:
            (core, prerelease)
        """
        let dash_idx = text.find("-")
        if dash_idx >= 0:
            let before = text[0:dash_idx]
            let after = text[dash_idx+1:]
            (before, after)
        else:
            (text, "")

    fn parse_int(s: String): Result<i32, String> =
        """Parse integer from string.

        Args:
            s: String to parse

        Returns:
            Parsed integer or error
        """
        # Simple integer parsing
        let trimmed = s.trim()
        if trimmed.is_empty():
            return Err("Empty string cannot be parsed as integer")

        let mut result = 0
        let mut negative = false
        let mut start_idx = 0

        # Check for negative sign
        if trimmed[0] == '-':
            negative = true
            start_idx = 1

        # Parse digits
        for i in start_idx..trimmed.len():
            let ch = trimmed[i]
            if ch >= '0' and ch <= '9':
                let digit = (ch as i32) - ('0' as i32)
                result = result * 10 + digit
            else:
                return Err("Invalid character in number: '" + ch + "'")

        if negative:
            result = -result

        Ok(result)

    pub fn to_string(self): String =
        """Convert to string.

        Returns:
            Version string

        Example:
            SemVer.new(1, 2, 3).to_string()  # → "1.2.3"
        """
        let mut version = "{self.major}.{self.minor}.{self.patch}"

        if not self.prerelease.is_empty():
            version += "-{self.prerelease}"

        if not self.build_metadata.is_empty():
            version += "+{self.build_metadata}"

        version

    pub fn bump_major(self): SemVer =
        """Bump major version.

        Returns:
            New version with major incremented

        Example:
            SemVer.new(1, 2, 3).bump_major()  # → 2.0.0
        """
        SemVer.new(self.major + 1, 0, 0)

    pub fn bump_minor(self): SemVer =
        """Bump minor version.

        Returns:
            New version with minor incremented

        Example:
            SemVer.new(1, 2, 3).bump_minor()  # → 1.3.0
        """
        SemVer.new(self.major, self.minor + 1, 0)

    pub fn bump_patch(self): SemVer =
        """Bump patch version.

        Returns:
            New version with patch incremented

        Example:
            SemVer.new(1, 2, 3).bump_patch()  # → 1.2.4
        """
        SemVer.new(self.major, self.minor, self.patch + 1)

    pub fn bump_prerelease(self): SemVer =
        """Bump prerelease version.

        Returns:
            New version with prerelease incremented

        Example:
            SemVer.new(1, 2, 3).bump_prerelease()  # → 1.2.3-alpha.0
            v.prerelease = "beta.1"
            v.bump_prerelease()  # → 1.2.3-beta.2
        """
        let mut new_version = SemVer.new(self.major, self.minor, self.patch)
        new_version.build_metadata = self.build_metadata

        if self.prerelease.is_empty():
            # No prerelease yet, start with alpha.0
            new_version.prerelease = "alpha.0"
        else:
            # Try to find and increment numeric suffix
            let dot_idx = self.prerelease.rfind(".")
            if dot_idx >= 0:
                # Has a dot, try to parse number after it
                let prefix = self.prerelease[0:dot_idx]
                let suffix = self.prerelease[dot_idx+1:]

                # Try to parse suffix as integer
                let num = self.parse_prerelease_num(suffix)
                if num >= 0:
                    # Successfully parsed, increment
                    new_version.prerelease = "{prefix}.{num + 1}"
                else:
                    # Not a number, append .1
                    new_version.prerelease = "{self.prerelease}.1"
            else:
                # No dot, append .1
                new_version.prerelease = "{self.prerelease}.1"

        new_version

    fn parse_prerelease_num(s: String): i32 =
        """Parse prerelease number.

        Args:
            s: String to parse

        Returns:
            Parsed number or -1 on error
        """
        if s.is_empty():
            return -1

        var result = 0
        for i in 0..s.len():
            let ch = s[i]
            if ch >= '0' and ch <= '9':
                let digit = (ch as i32) - ('0' as i32)
                result = result * 10 + digit
            else:
                # Not a valid number
                return -1

        result

    pub fn is_prerelease(self): bool =
        """Check if this is a prerelease version.

        Returns:
            True if prerelease tag exists

        Example:
            SemVer.new(1, 2, 3).is_prerelease()  # → false
            v.prerelease = "beta.1"
            v.is_prerelease()  # → true
        """
        not self.prerelease.is_empty()

    pub fn is_stable(self): bool =
        """Check if this is a stable release.

        Returns:
            True if no prerelease tag

        Example:
            SemVer.new(1, 0, 0).is_stable()  # → true
        """
        not self.is_prerelease()

    pub fn compare(self, other: SemVer): i32 =
        """Compare two versions.

        Args:
            other: Version to compare with

        Returns:
            -1 if self < other, 0 if equal, 1 if self > other

        Example:
            SemVer.new(1, 2, 3).compare(SemVer.new(1, 2, 4))  # → -1
            SemVer.new(2, 0, 0).compare(SemVer.new(1, 9, 9))  # → 1
        """
        # Compare major
        if self.major < other.major:
            return -1
        elif self.major > other.major:
            return 1

        # Compare minor
        if self.minor < other.minor:
            return -1
        elif self.minor > other.minor:
            return 1

        # Compare patch
        if self.patch < other.patch:
            return -1
        elif self.patch > other.patch:
            return 1

        # Equal
        0

# Version bump type
pub enum BumpType:
    Major
    Minor
    Patch
    PreRelease

    pub fn to_string(self): String =
        """Convert bump type to string.

        Returns:
            Bump type name

        Example:
            BumpType::Major.to_string()  # → "major"
        """
        match self:
            BumpType::Major: "major"
            BumpType::Minor: "minor"
            BumpType::Patch: "patch"
            BumpType::PreRelease: "prerelease"

    pub fn description(self): String =
        """Get bump type description.

        Returns:
            Human-readable description
        """
        match self:
            BumpType::Major: "Major version (breaking changes)"
            BumpType::Minor: "Minor version (new features)"
            BumpType::Patch: "Patch version (bug fixes)"
            BumpType::PreRelease: "Prerelease version"

    pub fn is_major(self): bool =
        """Check if bump type is Major.

        Returns:
            True if Major variant
        """
        match self:
            BumpType::Major: true
            _: false

    pub fn is_minor(self): bool =
        """Check if bump type is Minor.

        Returns:
            True if Minor variant
        """
        match self:
            BumpType::Minor: true
            _: false

    pub fn is_patch(self): bool =
        """Check if bump type is Patch.

        Returns:
            True if Patch variant
        """
        match self:
            BumpType::Patch: true
            _: false

    pub fn is_prerelease(self): bool =
        """Check if bump type is PreRelease.

        Returns:
            True if PreRelease variant
        """
        match self:
            BumpType::PreRelease: true
            _: false

    pub fn is_breaking(self): bool =
        """Check if bump introduces breaking changes.

        Returns:
            True if Major bump

        Example:
            BumpType::Major.is_breaking()  # → true
            BumpType::Minor.is_breaking()  # → false
        """
        match self:
            BumpType::Major: true
            _: false

    pub fn is_stable(self): bool =
        """Check if bump is for stable release (not prerelease).

        Returns:
            True if not PreRelease

        Example:
            BumpType::Minor.is_stable()  # → true
            BumpType::PreRelease.is_stable()  # → false
        """
        match self:
            BumpType::PreRelease: false
            _: true

    pub fn resets_lower_versions(self): bool =
        """Check if bump resets lower version components.

        Returns:
            True if Major or Minor

        Example:
            BumpType::Major.resets_lower_versions()  # → true (resets minor and patch to 0)
            BumpType::Minor.resets_lower_versions()  # → true (resets patch to 0)
            BumpType::Patch.resets_lower_versions()  # → false
        """
        match self:
            BumpType::Major: true
            BumpType::Minor: true
            _: false

    pub fn summary(self): String =
        """Get bump type summary.

        Returns:
            Human-readable summary

        Example:
            BumpType::Major.summary()
            # → "BumpType: major (Major version (breaking changes), breaking, resets lower)"
        """
        let name = self.to_string()
        let desc = self.description()
        let mut props = []

        if self.is_breaking():
            props.append("breaking")
        if self.is_stable():
            props.append("stable")
        if self.resets_lower_versions():
            props.append("resets lower")

        if props.len() > 0:
            let props_str = props.join(", ")
            "BumpType: {name} ({desc}, {props_str})"
        else:
            "BumpType: {name} ({desc})"

# Version manager
pub class VersionManager:
    pub root: String
    pub current_version: SemVer
    pub verbose: bool

    pub fn new(root: String): VersionManager =
        """Create version manager.

        Args:
            root: Project root

        Returns:
            Version manager

        Example:
            let version = VersionManager.new(".")

            # Current version
            print("Current: {version.get_current()}")  # → "1.0.0"

            # Bump version
            version.bump(BumpType::Minor)  # → "1.1.0"

            # Update all version files
            version.sync_all([
                "Cargo.toml",
                "package.json",
                "pyproject.toml",
                "simple.sdn"
            ])
        """
        VersionManager {
            root: root,
            current_version: SemVer.new(0, 1, 0),
            verbose: false
        }

    pub fn set_verbose(self, enabled: bool):
        """Enable verbose logging."""
        self.verbose = enabled

    pub fn get_current(self): String =
        """Get current version.

        Returns:
            Current version string

        Example:
            let v = version.get_current()  # → "1.0.0"
        """
        self.current_version.to_string()

    pub fn bump(self, bump_type: BumpType): String =
        """Bump version.

        Args:
            bump_type: Type of bump

        Returns:
            New version string

        Example:
            version.bump(BumpType::Major)  # 1.0.0 → 2.0.0
            version.bump(BumpType::Minor)  # 1.0.0 → 1.1.0
            version.bump(BumpType::Patch)  # 1.0.0 → 1.0.1
        """
        self.current_version = match bump_type:
            BumpType::Major:
                self.current_version.bump_major()
            BumpType::Minor:
                self.current_version.bump_minor()
            BumpType::Patch:
                self.current_version.bump_patch()
            BumpType::PreRelease:
                self.current_version.bump_prerelease()

        if self.verbose:
            print("Bumped version to {self.current_version.to_string()}")

        self.current_version.to_string()

    pub fn sync_all(self, files: List<String>): Result[(), String> =
        """Update version in all files.

        Args:
            files: List of version files

        Returns:
            Ok if successful

        Updates version in:
        - Cargo.toml: version = "1.0.0"
        - package.json: "version": "1.0.0"
        - pyproject.toml: version = "1.0.0"
        - simple.sdn: version: 1.0.0

        Example:
            version.sync_all([
                "Cargo.toml",
                "package.json",
                "simple.sdn"
            ])
        """
        let version_str = self.current_version.to_string()

        if self.verbose:
            print("Syncing version {version_str} to {files.len()} files")

        for file in files:
            match self.update_version_file(file, version_str):
                Ok(_):
                    if self.verbose:
                        print("Updated {file}")
                Err(err):
                    return Err("Failed to update {file}: {err}")

        Ok(())

    fn update_version_file(file: String, version: String): Result[(), String> =
        """Update version in single file.

        Args:
            file: File to update
            version: New version

        Returns:
            Ok if successful
        """
        # TODO: [stdlib][P3] Read file
        # TODO: [stdlib][P3] Update version line based on file type
        # TODO: [stdlib][P3] Write file back
        Ok(())

    pub fn validate(self, version: String): Result[(), String> =
        """Validate version string.

        Args:
            version: Version string

        Returns:
            Ok if valid SemVer

        Example:
            match version.validate("1.2.3"):
                Ok(_):
                    print("Valid version")
                Err(err):
                    print("Invalid: {err}")
        """
        match SemVer.parse(version):
            Ok(_):
                Ok(())
            Err(err):
                Err(err)
