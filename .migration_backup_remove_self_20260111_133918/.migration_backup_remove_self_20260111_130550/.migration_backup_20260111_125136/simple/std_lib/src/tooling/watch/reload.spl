# Hot Module Replacement (HMR)
# Reload code without restarting application

use core.result.{Result, Ok, Err}

# Reload strategy
pub enum ReloadStrategy:
    Full        # Full application restart
    Incremental # Reload only changed modules
    HotSwap     # Hot-swap functions without restart

    pub fn to_string(self): String =
        """Convert reload strategy to string.

        Returns:
            Strategy name

        Example:
            ReloadStrategy::HotSwap.to_string()  # → "hot-swap"
        """
        match self:
            ReloadStrategy::Full: "full"
            ReloadStrategy::Incremental: "incremental"
            ReloadStrategy::HotSwap: "hot-swap"

    pub fn description(self): String =
        """Get strategy description.

        Returns:
            Human-readable description

        Example:
            ReloadStrategy::HotSwap.description()
            # → "Hot-swap functions without application restart"
        """
        match self:
            ReloadStrategy::Full:
                "Full application restart with state loss"
            ReloadStrategy::Incremental:
                "Reload only changed modules, preserve app state"
            ReloadStrategy::HotSwap:
                "Hot-swap functions without application restart"

    pub fn preserves_state(self): bool =
        """Check if strategy preserves application state.

        Returns:
            True if state is preserved

        Example:
            ReloadStrategy::Full.preserves_state()  # → false
            ReloadStrategy::HotSwap.preserves_state()  # → true
        """
        match self:
            ReloadStrategy::Full: false
            ReloadStrategy::Incremental: true
            ReloadStrategy::HotSwap: true

    pub fn is_full(self): bool =
        """Check if full restart."""
        match self:
            ReloadStrategy::Full: true
            _: false

    pub fn is_incremental(self): bool =
        """Check if incremental."""
        match self:
            ReloadStrategy::Incremental: true
            _: false

    pub fn is_hot_swap(self): bool =
        """Check if hot-swap."""
        match self:
            ReloadStrategy::HotSwap: true
            _: false

# Reload event
pub class ReloadEvent:
    pub modules: List[String]
    pub timestamp: i64
    pub strategy: ReloadStrategy

    pub fn new(modules: List[String], strategy: ReloadStrategy): ReloadEvent =
        """Create reload event.

        Args:
            modules: Modules to reload
            strategy: Reload strategy

        Returns:
            Reload event
        """
        @extern("runtime", "rt_time_now_unix_micros")
        fn _rt_time_now_unix_micros() -> i64

        ReloadEvent {
            modules: modules,
            timestamp: _rt_time_now_unix_micros() / 1000,  # Convert microseconds to milliseconds
            strategy: strategy
        }

    pub fn module_count(self): i32 =
        """Get number of modules to reload.

        Returns:
            Module count
        """
        self.modules.len()

    pub fn contains_module(self, module: String): bool =
        """Check if event contains specific module.

        Args:
            module: Module path to check

        Returns:
            True if module is in list
        """
        for m in self.modules:
            if m == module:
                return true
        false

    pub fn summary(self): String =
        """Get event summary.

        Returns:
            Human-readable summary

        Example:
            event.summary()
            # → "Reloading 3 modules (incremental)"
        """
        "Reloading {self.module_count()} modules ({self.strategy.to_string()})"

    pub fn is_single_module(self): bool =
        """Check if single module reload."""
        self.module_count() == 1

    pub fn is_batch_reload(self): bool =
        """Check if batch reload."""
        self.module_count() > 1

# HMR client - receives reload notifications
pub class HMRClient:
    pub on_reload_callback: (ReloadEvent) -> ()
    pub connected: bool

    pub fn new(): HMRClient =
        """Create HMR client.

        Returns:
            Client ready to receive reload events

        Example:
            let client = HMRClient.new()

            client.on_reload(fn(event):
                print("Reloading modules: {event.modules}")
                # Reload application state
            )

            client.connect()
        """
        HMRClient {
            on_reload_callback: fn(event): pass,
            connected: false
        }

    pub fn on_reload(self, callback: (ReloadEvent) -> ()):
        """Set reload callback.

        Args:
            callback: Function to call on reload event
        """
        self.on_reload_callback = callback

    pub fn connect(self):
        """Connect to HMR server.

        Establishes connection for receiving reload events.
        """
        # TODO: [stdlib][P1] Implement WebSocket or HTTP connection
        self.connected = true

    pub fn disconnect(self):
        """Disconnect from HMR server."""
        self.connected = false

    pub fn is_connected(self): bool =
        """Check if client is connected.

        Returns:
            True if connected
        """
        self.connected

    pub fn summary(self): String =
        """Get client summary."""
        let status = if self.connected: "connected" else: "disconnected"
        "HMRClient: {status}"

# HMR server - sends reload notifications
pub class HMRServer:
    pub clients: List[HMRClient]
    pub running: bool
    pub port: i32

    pub fn new(port: i32): HMRServer =
        """Create HMR server.

        Args:
            port: Server port

        Returns:
            HMR server

        Example:
            let server = HMRServer.new(3000)
            server.start()

            # In watch callback:
            server.notify_reload(["app.spl", "lib.spl"])
        """
        HMRServer {
            clients: [],
            running: false,
            port: port
        }

    pub fn start(self):
        """Start HMR server.

        Listens for client connections.
        """
        # TODO: [stdlib][P1] Implement WebSocket server
        self.running = true

    pub fn stop(self):
        """Stop HMR server."""
        self.running = false

    pub fn client_count(self): i32 =
        """Get number of connected clients.

        Returns:
            Client count
        """
        self.clients.len()

    pub fn is_running(self): bool =
        """Check if server is running.

        Returns:
            True if running
        """
        self.running

    pub fn has_clients(self): bool =
        """Check if has connected clients."""
        self.client_count() > 0

    pub fn summary(self): String =
        """Get server summary."""
        let status = if self.running: "running" else: "stopped"
        "HMRServer: port {self.port}, {self.client_count()} clients ({status})"

    pub fn notify_reload(self, modules: List[String]):
        """Notify all clients to reload modules.

        Args:
            modules: Modules that changed
        """
        let event = ReloadEvent.new(modules, ReloadStrategy::Incremental)

        for client in self.clients:
            self.send_reload_event(client, event)

    fn send_reload_event(self, client: HMRClient, event: ReloadEvent):
        """Send reload event to client.

        Args:
            client: HMR client
            event: Reload event
        """
        # TODO: [stdlib][P3] Send via WebSocket
        client.on_reload_callback(event)

# Module reloader - handles actual module reloading
pub class ModuleReloader:
    pub loaded_modules: Dict[String, i64]  # module -> mtime
    pub verbose: bool

    pub fn new(): ModuleReloader =
        """Create module reloader.

        Returns:
            Module reloader
        """
        ModuleReloader {
            loaded_modules: {},
            verbose: false
        }

    pub fn set_verbose(self, enabled: bool):
        """Enable verbose logging.

        Args:
            enabled: True for detailed logs
        """
        self.verbose = enabled

    pub fn is_verbose(self): bool =
        """Check if verbose."""
        self.verbose

    pub fn with_verbose(self, enabled: bool): ModuleReloader =
        """Set verbose (fluent API)."""
        self.verbose = enabled
        self

    pub fn has_loaded_modules(self): bool =
        """Check if has loaded modules."""
        self.get_loaded_count() > 0

    pub fn summary(self): String =
        """Get reloader summary."""
        let verbose_str = if self.verbose: "true" else: "false"
        "ModuleReloader: {self.get_loaded_count()} loaded modules (verbose: {verbose_str})"

    pub fn reload_module(self, module_path: String): Result[(), String] =
        """Reload a module from disk.

        Args:
            module_path: Path to module file

        Returns:
            Ok if successful, Err with error message

        Example:
            let reloader = ModuleReloader.new()

            match reloader.reload_module("lib.spl"):
                Ok(_):
                    print("Module reloaded successfully")
                Err(err):
                    print("Reload failed: {err}")
        """
        if self.verbose:
            print("Reloading module: {module_path}")

        # TODO: [stdlib][P1] Implement actual module reloading
        # Steps:
        # 1. Unload old module
        # 2. Re-compile module
        # 3. Load new module
        # 4. Update function pointers
        # 5. Preserve application state

        self.loaded_modules[module_path] = 0  # TODO: [stdlib][P3] Get file mtime

        Ok(())

    pub fn reload_modules(self, modules: List[String]): Result[(), String] =
        """Reload multiple modules.

        Args:
            modules: Module paths to reload

        Returns:
            Ok if all successful
        """
        for module in modules:
            match self.reload_module(module):
                Ok(_):
                    pass
                Err(err):
                    return Err("Failed to reload {module}: {err}")

        Ok(())

    pub fn can_hot_reload(self, module_path: String): bool =
        """Check if module can be hot-reloaded.

        Args:
            module_path: Module to check

        Returns:
            True if hot-reloadable

        Not all code can be safely hot-reloaded:
        - Pure functions: Safe
        - Stateful code: Requires state preservation
        - Type definitions: May require full restart
        """
        # TODO: [stdlib][P3] Analyze module for hot-reload safety
        # For now, assume all modules are reloadable
        true

    pub fn get_loaded_count(self): i32 =
        """Get number of loaded modules.

        Returns:
            Count of loaded modules
        """
        self.loaded_modules.len()

    pub fn is_loaded(self, module_path: String): bool =
        """Check if module is currently loaded.

        Args:
            module_path: Module to check

        Returns:
            True if loaded
        """
        self.loaded_modules.contains_key(module_path)

    pub fn clear_cache(self):
        """Clear loaded module cache.

        Forces full reload on next request.
        """
        self.loaded_modules = {}

# Watch mode integration - combines watching + reloading
pub class WatchReloadIntegration:
    pub watcher: Watcher
    pub reloader: ModuleReloader
    pub hmr_server: HMRServer?
    pub auto_reload: bool

    pub fn new(root: String): WatchReloadIntegration =
        """Create integrated watch + reload system.

        Args:
            root: Project root

        Returns:
            Integrated system

        Example:
            let watch_reload = WatchReloadIntegration.new(".")
            watch_reload.set_auto_reload(true)
            watch_reload.start_hmr_server(3000)

            watch_reload.start()  # Watch + auto-reload
        """
        WatchReloadIntegration {
            watcher: Watcher.new(root),
            reloader: ModuleReloader.new(),
            hmr_server: none,
            auto_reload: false
        }

    pub fn set_auto_reload(self, enabled: bool):
        """Enable automatic module reloading.

        Args:
            enabled: True to auto-reload on file changes
        """
        self.auto_reload = enabled

    pub fn start_hmr_server(self, port: i32):
        """Start HMR server for client notifications.

        Args:
            port: Server port
        """
        let server = HMRServer.new(port)
        server.start()
        self.hmr_server = some(server)

    pub fn start(self):
        """Start watching and reloading.

        Blocks until stopped.
        """
        # Set up watch callback
        self.watcher.on_change(fn(files):
            print("Files changed: {files.len()}")

            if self.auto_reload:
                # Reload modules
                match self.reloader.reload_modules(files):
                    Ok(_):
                        print("✓ Modules reloaded successfully")

                        # Notify HMR clients
                        match self.hmr_server:
                            some(server):
                                server.notify_reload(files)
                            none:
                                pass
                    Err(err):
                        print("✗ Reload failed: {err}")
        )

        # Start watching
        self.watcher.start()

    pub fn stop(self):
        """Stop watching and reloading."""
        self.watcher.stop()

        match self.hmr_server:
            some(server):
                server.stop()
            none:
                pass

    pub fn is_auto_reload_enabled(self): bool =
        """Check if auto-reload enabled."""
        self.auto_reload

    pub fn has_hmr_server(self): bool =
        """Check if HMR server is configured."""
        match self.hmr_server:
            some(_): true
            none: false

    pub fn is_running(self): bool =
        """Check if watching is active."""
        self.watcher.is_running()

    pub fn summary(self): String =
        """Get integration summary."""
        let auto_str = if self.auto_reload: "enabled" else: "disabled"
        let hmr_str = if self.has_hmr_server(): "yes" else: "no"
        "WatchReloadIntegration: auto-reload {auto_str}, HMR server: {hmr_str}, {self.reloader.get_loaded_count()} loaded modules"
