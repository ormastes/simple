# Persistent (immutable) data structures
# Structural sharing for efficient updates

# Persistent list (cons list)
enum List<T>:
    Nil
    Cons(T, Box<List<T>>)

impl List<T>:
    fn empty() -> List<T>:
        List.Nil

    fn prepend(x: T) -> List<T>:
        List.Cons(x, Box.new(self))

    fn head() -> Option<T>:
        match self:
            List.Cons(x, _) => Some(x)
            List.Nil => None

    fn tail() -> Option<List<T>>:
        match self:
            List.Cons(_, xs) => Some(*xs)
            List.Nil => None

    fn is_empty() -> bool:
        match self:
            List.Nil => true
            _ => false

    fn len() -> u64:
        match self:
            List.Nil => 0
            List.Cons(_, xs) => 1 + xs.len()

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_singleton() -> bool:
        """Check if list has exactly one element."""
        match self:
            List.Cons(_, xs) =>
                match *xs:
                    List.Nil => true
                    _ => false
            List.Nil => false

    fn has_tail() -> bool:
        """Check if list has a tail (not Nil)."""
        return self.tail().is_some()

    fn has_head() -> bool:
        """Check if list has a head (not Nil)."""
        return self.head().is_some()

    fn contains(value: T) -> bool where T: Eq:
        """Check if list contains a value."""
        match self:
            List.Nil => false
            List.Cons(x, xs) =>
                if x == value:
                    true
                else:
                    xs.contains(value)

    fn count_matching(predicate: fn(T) -> bool) -> u64:
        """Count elements matching a predicate."""
        match self:
            List.Nil => 0
            List.Cons(x, xs) =>
                let count = if predicate(x): 1 else: 0
                return count + xs.count_matching(predicate)

    fn all(predicate: fn(T) -> bool) -> bool:
        """Check if all elements match a predicate."""
        match self:
            List.Nil => true
            List.Cons(x, xs) =>
                if predicate(x):
                    xs.all(predicate)
                else:
                    false

    fn any(predicate: fn(T) -> bool) -> bool:
        """Check if any element matches a predicate."""
        match self:
            List.Nil => false
            List.Cons(x, xs) =>
                if predicate(x):
                    true
                else:
                    xs.any(predicate)

    fn reverse() -> List<T>:
        """Reverse the list."""
        let rec reverse_helper(list: List<T>, acc: List<T>) -> List<T>:
            match list:
                List.Nil => acc
                List.Cons(x, xs) =>
                    reverse_helper(*xs, acc.prepend(x))
        return reverse_helper(self, List.Nil)

    fn take(n: u64) -> List<T>:
        """Take the first n elements."""
        if n == 0:
            return List.Nil
        match self:
            List.Nil => List.Nil
            List.Cons(x, xs) =>
                List.Cons(x, Box.new(xs.take(n - 1)))

    fn drop(n: u64) -> List<T>:
        """Drop the first n elements."""
        if n == 0:
            return self
        match self:
            List.Nil => List.Nil
            List.Cons(_, xs) =>
                xs.drop(n - 1)

    fn summary() -> String:
        """Get summary of persistent list."""
        let len = self.len()
        let empty = if self.is_empty(): "empty" else: "non-empty"
        return "List<T>: {len} elements ({empty})"

# Fold operations
fn fold_left<T, U>(list: List<T>, init: U, f: fn(U, T) -> U) -> U:
    match list:
        List.Nil => init
        List.Cons(x, xs) => fold_left(*xs, f(init, x), f)

fn fold_right<T, U>(list: List<T>, init: U, f: fn(T, U) -> U) -> U:
    match list:
        List.Nil => init
        List.Cons(x, xs) => f(x, fold_right(*xs, init, f))
