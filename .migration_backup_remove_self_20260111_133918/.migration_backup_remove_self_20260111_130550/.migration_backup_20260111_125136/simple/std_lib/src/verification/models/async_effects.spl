# Async Effects Model
# Effect tracking for async operations and concurrency.

# Effect kinds
enum EffectKind:
    Pure       # No effects
    IO         # I/O operations
    Async      # Async/await
    Spawn      # Thread/actor spawning
    Send       # Channel send
    Recv       # Channel receive
    Lock       # Mutex/lock operations
    Alloc      # Memory allocation
    FFI        # Foreign function calls
    Panic      # May panic
    Diverge    # May not terminate

    fn is_pure(self) -> Bool:
        """Check if this is Pure effect kind.

        Returns: true for Pure

        Example:
            EffectKind.Pure.is_pure()  # → true
        """
        match self:
            case Pure: true
            case _: false

    fn is_io(self) -> Bool:
        """Check if this is IO effect kind.

        Returns: true for IO

        Example:
            EffectKind.IO.is_io()  # → true
        """
        match self:
            case IO: true
            case _: false

    fn is_async(self) -> Bool:
        """Check if this is Async effect kind.

        Returns: true for Async

        Example:
            EffectKind.Async.is_async()  # → true
        """
        match self:
            case Async: true
            case _: false

    fn is_spawn(self) -> Bool:
        """Check if this is Spawn effect kind.

        Returns: true for Spawn

        Example:
            EffectKind.Spawn.is_spawn()  # → true
        """
        match self:
            case Spawn: true
            case _: false

    fn is_send(self) -> Bool:
        """Check if this is Send effect kind.

        Returns: true for Send

        Example:
            EffectKind.Send.is_send()  # → true
        """
        match self:
            case Send: true
            case _: false

    fn is_recv(self) -> Bool:
        """Check if this is Recv effect kind.

        Returns: true for Recv

        Example:
            EffectKind.Recv.is_recv()  # → true
        """
        match self:
            case Recv: true
            case _: false

    fn is_lock(self) -> Bool:
        """Check if this is Lock effect kind.

        Returns: true for Lock

        Example:
            EffectKind.Lock.is_lock()  # → true
        """
        match self:
            case Lock: true
            case _: false

    fn is_alloc(self) -> Bool:
        """Check if this is Alloc effect kind.

        Returns: true for Alloc

        Example:
            EffectKind.Alloc.is_alloc()  # → true
        """
        match self:
            case Alloc: true
            case _: false

    fn is_ffi(self) -> Bool:
        """Check if this is FFI effect kind.

        Returns: true for FFI

        Example:
            EffectKind.FFI.is_ffi()  # → true
        """
        match self:
            case FFI: true
            case _: false

    fn is_panic(self) -> Bool:
        """Check if this is Panic effect kind.

        Returns: true for Panic

        Example:
            EffectKind.Panic.is_panic()  # → true
        """
        match self:
            case Panic: true
            case _: false

    fn is_diverge(self) -> Bool:
        """Check if this is Diverge effect kind.

        Returns: true for Diverge

        Example:
            EffectKind.Diverge.is_diverge()  # → true
        """
        match self:
            case Diverge: true
            case _: false

    fn is_concurrency_effect(self) -> Bool:
        """Check if this is a concurrency-related effect.

        Concurrency effects include async operations, spawning, messaging, and locking.

        Returns: true for Async, Spawn, Send, Recv, or Lock

        Example:
            EffectKind.Async.is_concurrency_effect()  # → true
            EffectKind.IO.is_concurrency_effect()     # → false
        """
        match self:
            case Async: true
            case Spawn: true
            case Send: true
            case Recv: true
            case Lock: true
            case _: false

    fn is_resource_effect(self) -> Bool:
        """Check if this is a resource management effect.

        Resource effects include I/O and memory allocation.

        Returns: true for IO or Alloc

        Example:
            EffectKind.IO.is_resource_effect()  # → true
            EffectKind.Async.is_resource_effect()  # → false
        """
        match self:
            case IO: true
            case Alloc: true
            case _: false

    fn is_error_effect(self) -> Bool:
        """Check if this is an error/control-flow effect.

        Error effects include panic and divergence (non-termination).

        Returns: true for Panic or Diverge

        Example:
            EffectKind.Panic.is_error_effect()  # → true
            EffectKind.Pure.is_error_effect()   # → false
        """
        match self:
            case Panic: true
            case Diverge: true
            case _: false

    fn requires_async_context(self) -> Bool:
        """Check if this effect requires an async context.

        Returns: true for Async (await requires async fn)

        Example:
            EffectKind.Async.requires_async_context()  # → true
            EffectKind.Spawn.requires_async_context()  # → false
        """
        match self:
            case Async: true
            case _: false

    fn is_safe(self) -> Bool:
        """Check if this effect is safe (allowed in pure contexts).

        Safe effects include Pure and Alloc (allocation is safe in Simple).

        Returns: true for Pure or Alloc

        Example:
            EffectKind.Pure.is_safe()  # → true
            EffectKind.IO.is_safe()    # → false
        """
        match self:
            case Pure: true
            case Alloc: true
            case _: false

    fn to_string(self) -> String:
        """Convert EffectKind to string representation.

        Returns: lowercase string name of the effect

        Example:
            EffectKind.IO.to_string()    # → "io"
            EffectKind.Async.to_string() # → "async"
        """
        match self:
            case Pure: "pure"
            case IO: "io"
            case Async: "async"
            case Spawn: "spawn"
            case Send: "send"
            case Recv: "recv"
            case Lock: "lock"
            case Alloc: "alloc"
            case FFI: "ffi"
            case Panic: "panic"
            case Diverge: "diverge"

    fn description(self) -> String:
        """Get human-readable description of the effect kind.

        Returns: descriptive explanation of what this effect represents

        Example:
            EffectKind.IO.description()    # → "I/O operations"
            EffectKind.Async.description() # → "Async/await operations"
        """
        match self:
            case Pure: "No effects"
            case IO: "I/O operations"
            case Async: "Async/await operations"
            case Spawn: "Thread/actor spawning"
            case Send: "Channel send operations"
            case Recv: "Channel receive operations"
            case Lock: "Mutex/lock operations"
            case Alloc: "Memory allocation"
            case FFI: "Foreign function calls"
            case Panic: "May panic"
            case Diverge: "May not terminate"

    fn summary(self) -> String:
        """Get comprehensive summary of the effect kind.

        Returns: multi-line summary with name, description, and categorization

        Example:
            EffectKind.Async.summary()
            # → "EffectKind: async (Async/await operations, concurrency effect, requires async context)"
        """
        let name = self.to_string()
        let desc = self.description()
        let mut attrs = []

        if self.is_concurrency_effect():
            attrs.push("concurrency effect")
        if self.is_resource_effect():
            attrs.push("resource effect")
        if self.is_error_effect():
            attrs.push("error effect")
        if self.is_safe():
            attrs.push("safe")
        if self.requires_async_context():
            attrs.push("requires async context")

        let attrs_str = if attrs.len() > 0:
            ", " + attrs.join(", ")
        else:
            ""

        "EffectKind: {name} ({desc}{attrs_str})"

# Effect set
class Effects:
    effects: List<EffectKind>

    fn new() -> Effects:
        Effects(effects: [])

    fn pure() -> Effects:
        Effects(effects: [EffectKind.Pure])

    fn io() -> Effects:
        Effects(effects: [EffectKind.IO])

    fn async_() -> Effects:
        Effects(effects: [EffectKind.Async])

    me add(self, effect: EffectKind) -> Effects:
        if not self.effects.contains(effect):
            self.effects.push(effect)
        self

    fn union(self, other: Effects) -> Effects:
        let mut result = Effects.new()
        for e in self.effects:
            result.add(e)
        for e in other.effects:
            result.add(e)
        result

    fn contains(self, effect: EffectKind) -> Bool:
        self.effects.contains(effect)

    fn is_pure(self) -> Bool:
        self.effects.len() == 0 or 
        (self.effects.len() == 1 and self.effects[0] == EffectKind.Pure)

    fn is_async(self) -> Bool:
        self.contains(EffectKind.Async)

    fn has_io(self) -> Bool:
        self.contains(EffectKind.IO)

    fn to_string(self) -> String:
        if self.is_pure():
            "pure"
        else:
            self.effects.map(|e| e.to_string()).join(" + ")

# Effect constraint
class EffectConstraint:
    required: Effects
    forbidden: Effects
    message: String

    fn new() -> EffectConstraint:
        EffectConstraint(
            required: Effects.new(),
            forbidden: Effects.new(),
            message: ""
        )

    me require(self, effect: EffectKind) -> EffectConstraint:
        self.required.add(effect)
        self

    me forbid(self, effect: EffectKind) -> EffectConstraint:
        self.forbidden.add(effect)
        self

    me with_message(self, msg: String) -> EffectConstraint:
        self.message = msg
        self

    fn check(self, actual: Effects) -> Result<Nil, String>:
        # Check required effects are present
        for req in self.required.effects:
            if not actual.contains(req):
                return Err("Missing required effect: {req.to_string()}")

        # Check forbidden effects are absent
        for forbid in self.forbidden.effects:
            if actual.contains(forbid):
                return Err("Forbidden effect present: {forbid.to_string()}")

        Ok(nil)

# Async context - where async operations are valid
enum AsyncContext:
    Sync           # Synchronous context (no async)
    AsyncFn        # Inside async function
    ActorBody      # Inside actor message handler
    SpawnBlock     # Inside spawn { } block

    fn is_sync(self) -> Bool:
        """Check if this is Sync context.

        Returns: true for Sync

        Example:
            AsyncContext.Sync.is_sync()  # → true
        """
        match self:
            case Sync: true
            case _: false

    fn is_async_fn(self) -> Bool:
        """Check if this is AsyncFn context.

        Returns: true for AsyncFn

        Example:
            AsyncContext.AsyncFn.is_async_fn()  # → true
        """
        match self:
            case AsyncFn: true
            case _: false

    fn is_actor_body(self) -> Bool:
        """Check if this is ActorBody context.

        Returns: true for ActorBody

        Example:
            AsyncContext.ActorBody.is_actor_body()  # → true
        """
        match self:
            case ActorBody: true
            case _: false

    fn is_spawn_block(self) -> Bool:
        """Check if this is SpawnBlock context.

        Returns: true for SpawnBlock

        Example:
            AsyncContext.SpawnBlock.is_spawn_block()  # → true
        """
        match self:
            case SpawnBlock: true
            case _: false

    fn is_async_context(self) -> Bool:
        """Check if this is an async-capable context.

        Async-capable contexts allow await operations.

        Returns: true for AsyncFn or ActorBody

        Example:
            AsyncContext.AsyncFn.is_async_context()  # → true
            AsyncContext.Sync.is_async_context()     # → false
        """
        match self:
            case AsyncFn: true
            case ActorBody: true
            case _: false

    fn supports_concurrency(self) -> Bool:
        """Check if this context supports any form of concurrency.

        All non-Sync contexts support some form of concurrent operations.

        Returns: true for AsyncFn, ActorBody, or SpawnBlock

        Example:
            AsyncContext.AsyncFn.supports_concurrency()  # → true
            AsyncContext.Sync.supports_concurrency()     # → false
        """
        match self:
            case Sync: false
            case _: true

    fn allows_await(self) -> Bool:
        """Check if this context allows await operations.

        Returns: true for AsyncFn or ActorBody

        Example:
            AsyncContext.AsyncFn.allows_await()  # → true
            AsyncContext.Sync.allows_await()     # → false
        """
        match self:
            case AsyncFn: true
            case ActorBody: true
            case _: false

    fn allows_spawn(self) -> Bool:
        """Check if this context allows spawn operations.

        Spawn is allowed in all contexts in Simple's model.

        Returns: true for all variants

        Example:
            AsyncContext.Sync.allows_spawn()  # → true
        """
        match self:
            case Sync: true
            case AsyncFn: true
            case ActorBody: true
            case SpawnBlock: true

    fn to_string(self) -> String:
        """Convert AsyncContext to string representation.

        Returns: lowercase string name of the context

        Example:
            AsyncContext.Sync.to_string()       # → "sync"
            AsyncContext.AsyncFn.to_string()    # → "async_fn"
        """
        match self:
            case Sync: "sync"
            case AsyncFn: "async_fn"
            case ActorBody: "actor_body"
            case SpawnBlock: "spawn_block"

    fn description(self) -> String:
        """Get human-readable description of the async context.

        Returns: descriptive explanation of the context

        Example:
            AsyncContext.Sync.description()     # → "Synchronous context"
            AsyncContext.AsyncFn.description()  # → "Inside async function"
        """
        match self:
            case Sync: "Synchronous context"
            case AsyncFn: "Inside async function"
            case ActorBody: "Inside actor message handler"
            case SpawnBlock: "Inside spawn block"

    fn summary(self) -> String:
        """Get comprehensive summary of the async context.

        Returns: multi-line summary with name, description, and capabilities

        Example:
            AsyncContext.AsyncFn.summary()
            # → "AsyncContext: async_fn (Inside async function, async context, allows await, allows spawn)"
        """
        let name = self.to_string()
        let desc = self.description()
        let mut caps = []

        if self.is_async_context():
            caps.push("async context")
        if self.supports_concurrency():
            caps.push("supports concurrency")
        if self.allows_await():
            caps.push("allows await")
        if self.allows_spawn():
            caps.push("allows spawn")

        let caps_str = if caps.len() > 0:
            ", " + caps.join(", ")
        else:
            ""

        "AsyncContext: {name} ({desc}{caps_str})"

# Effect checker for async safety
class AsyncEffectChecker:
    context: AsyncContext
    effects: Effects
    errors: List<String>

    fn new(context: AsyncContext) -> AsyncEffectChecker:
        AsyncEffectChecker(
            context: context,
            effects: Effects.new(),
            errors: []
        )

    me record_effect(self, effect: EffectKind):
        self.effects.add(effect)

    me check_await(self) -> Result<Nil, String>:
        if not self.context.allows_await():
            self.errors.push("await used outside async context")
            Err("await used outside async context")
        else:
            self.record_effect(EffectKind.Async)
            Ok(nil)

    me check_spawn(self) -> Result<Nil, String>:
        if not self.context.allows_spawn():
            self.errors.push("spawn used in invalid context")
            Err("spawn used in invalid context")
        else:
            self.record_effect(EffectKind.Spawn)
            Ok(nil)

    me check_io(self) -> Result<Nil, String>:
        self.record_effect(EffectKind.IO)
        Ok(nil)

    me check_channel_send(self) -> Result<Nil, String>:
        self.record_effect(EffectKind.Send)
        Ok(nil)

    me check_channel_recv(self) -> Result<Nil, String>:
        self.record_effect(EffectKind.Recv)
        Ok(nil)

    fn get_effects(self) -> Effects:
        self.effects

    fn has_errors(self) -> Bool:
        self.errors.len() > 0

    fn get_errors(self) -> List<String>:
        self.errors

# Effect inference for functions
class EffectInference:
    function_effects: Dict<String, Effects>

    fn new() -> EffectInference:
        EffectInference(function_effects: {})

    me set_function_effect(self, name: String, effects: Effects):
        self.function_effects[name] = effects

    fn get_function_effect(self, name: String) -> Effects:
        self.function_effects.get(name).unwrap_or(Effects.pure())

    fn infer_call_effect(self, func_name: String, arg_effects: List<Effects>) -> Effects:
        let func_effect = self.get_function_effect(func_name)
        let mut result = func_effect
        for arg_eff in arg_effects:
            result = result.union(arg_eff)
        result

# Verified context effect rules
class VerifiedEffectRules:
    fn check_verified_function(effects: Effects) -> List<String>:
        let mut errors: List<String> = []

        # V-EFFECT: No IO in verified
        if effects.has_io():
            errors.push("V-EFFECT-001: IO effects not allowed in verified function")

        # V-EFFECT: No async in verified (unless explicitly proven)
        if effects.is_async():
            errors.push("V-EFFECT-002: Async effects not allowed in verified function")

        # V-EFFECT: No spawn in verified
        if effects.contains(EffectKind.Spawn):
            errors.push("V-EFFECT-003: Spawn not allowed in verified function")

        # V-EFFECT: No FFI in verified
        if effects.contains(EffectKind.FFI):
            errors.push("V-EFFECT-004: FFI not allowed in verified function")

        errors

    fn check_trusted_function(effects: Effects) -> List<String>:
        # Trusted functions can have any effects (they're axioms)
        []

    fn check_pure_contract(effects: Effects) -> List<String>:
        let mut errors: List<String> = []

        if not effects.is_pure():
            errors.push("Contract expressions must be pure")

        errors
