# ContextManager trait for with-statement support
# Feature #1092: ContextManager trait
#
# Provides a standard interface for resources that need setup/teardown
# Compatible with Python-style context managers

# Extern declarations for FFI
extern fn rt_time_now_seconds() -> Float
extern fn rt_file_open(path: String, mode: Int) -> Int
extern fn rt_file_close(fd: Int) -> Void

trait ContextManager:
    """
    Protocol for context management (with statement support).

    Implementing this trait allows objects to be used in with statements:
    ```
    with open("file.txt") as f:
        # f.__enter__() called here
        data = f.read()
    # f.__exit__(None, None, None) called here automatically
    ```
    """

    fn __enter__(self) -> Any:
        """
        Called when entering the with block.
        Returns the resource to be bound to the target variable.
        """
        pass

    fn __exit__(self, exc_type: Option[Type], exc_value: Option[Any], traceback: Option[Any]) -> bool:
        """
        Called when exiting the with block.

        Parameters:
        - exc_type: The exception type if an exception occurred, None otherwise
        - exc_value: The exception value if an exception occurred, None otherwise
        - traceback: The traceback if an exception occurred, None otherwise

        Returns:
        - True to suppress the exception (mark it as handled)
        - False to propagate the exception
        """
        pass


# Example: File context manager
class FileContext implements ContextManager:
    """
    File context manager that automatically closes files.

    Example:
    ```
    with FileContext.open("data.txt") as f:
        content = f.read()
    # File is automatically closed here
    ```
    """

    file_handle: Any
    path: str
    mode: str
    closed: bool

    @static
    fn open(path: str, mode: str = "r") -> FileContext:
        return FileContext(path: path, mode: mode, closed: False)

    fn __enter__(self) -> Any:
        # Open the file and return the handle
        self.file_handle = open_file(self.path, self.mode)
        return self.file_handle

    fn __exit__(self, exc_type: Option[Type], exc_value: Option[Any], traceback: Option[Any]) -> bool:
        # Always close the file, even if an exception occurred
        if not self.closed:
            close_file(self.file_handle)
            self.closed = True
        # Don't suppress exceptions - return False
        return False


# Example: Lock context manager
class LockContext implements ContextManager:
    """
    Lock context manager that automatically acquires and releases locks.

    Example:
    ```
    with LockContext(my_lock) as lock:
        # Critical section - lock is held
        shared_data.update()
    # Lock is automatically released here
    ```
    """

    lock: Any
    acquired: bool

    fn new(lock: Any) -> LockContext:
        return LockContext(lock: lock, acquired: False)

    fn __enter__(self) -> Any:
        self.lock.acquire()
        self.acquired = True
        return self.lock

    fn __exit__(self, exc_type: Option[Type], exc_value: Option[Any], traceback: Option[Any]) -> bool:
        if self.acquired:
            self.lock.release()
            self.acquired = False
        return False


# Example: Timer context manager
class TimerContext implements ContextManager:
    """
    Timer context manager that measures execution time.

    Example:
    ```
    with TimerContext("database query") as timer:
        result = db.query("SELECT * FROM users")
    # Prints: "database query took 0.123s"
    ```
    """

    name: str
    start_time: f64
    end_time: f64

    fn new(name: str) -> TimerContext:
        return TimerContext(name: name, start_time: 0.0, end_time: 0.0)

    fn __enter__(self) -> TimerContext:
        self.start_time = time_now()
        return self

    fn __exit__(self, exc_type: Option[Type], exc_value: Option[Any], traceback: Option[Any]) -> bool:
        self.end_time = time_now()
        let elapsed = self.end_time - self.start_time
        println("{} took {}s".format(self.name, elapsed))
        return False

    fn elapsed(self) -> f64:
        if self.end_time > 0.0:
            return self.end_time - self.start_time
        else:
            return time_now() - self.start_time


# Example: Suppress exceptions context manager
class suppress implements ContextManager:
    """
    Context manager that suppresses specified exceptions.

    Example:
    ```
    with suppress(ValueError, KeyError):
        # These exceptions will be silently caught
        risky_operation()
    ```
    """

    exceptions: [Type]

    fn new(*exceptions: Type) -> suppress:
        return suppress(exceptions: list(exceptions))

    fn __enter__(self) -> suppress:
        return self

    fn __exit__(self, exc_type: Option[Type], exc_value: Option[Any], traceback: Option[Any]) -> bool:
        # Suppress exception if it matches any of our exception types
        match exc_type:
            case Some(et):
                for exception_class in self.exceptions:
                    if et == exception_class:
                        return True  # Suppress this exception
                return False  # Don't suppress
            case None:
                return False  # No exception to suppress


# Helper functions for file operations
fn open_file(path: str, mode: str) -> Any:
    # Convert mode string to integer
    # "r" = 0 (ReadOnly), "rw" = 1 (ReadWrite), "w" = 2 (WriteOnly)
    let mode_int = match mode:
        case "r": 0
        case "rw": 1
        case "w": 2
        case _: 0  # Default to read-only
    let fd = rt_file_open(path, mode_int)
    return fd

fn close_file(handle: Any):
    # Handle is expected to be a file descriptor (Int)
    rt_file_close(handle as Int)

fn time_now() -> f64:
    return rt_time_now_seconds()
