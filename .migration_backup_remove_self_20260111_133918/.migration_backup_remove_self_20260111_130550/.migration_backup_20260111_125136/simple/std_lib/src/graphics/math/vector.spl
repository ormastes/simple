# Vector - 2D, 3D, and 4D vector types with SIMD backing
#
# Provides Vec2, Vec3, Vec4 types backed by GPU vec<N, T> for SIMD optimization.
# Supports multi-value literals for compact syntax: 1_2_3_vec3
#
# Based on: doc/plans/floating-booping-coral.md (3D Graphics Library)

use core.*

# =============================================================================
# Vec2 - 2D Vector
# =============================================================================

pub struct Vec2:
    x: f32
    y: f32

impl Vec2:
    # Constructors
    pub fn new(x: f32, y: f32) -> Vec2:
        return Vec2 { x: x, y: y }

    pub fn zero() -> Vec2:
        return Vec2 { x: 0.0, y: 0.0 }

    pub fn one() -> Vec2:
        return Vec2 { x: 1.0, y: 1.0 }

    pub fn unit_x() -> Vec2:
        return Vec2 { x: 1.0, y: 0.0 }

    pub fn unit_y() -> Vec2:
        return Vec2 { x: 0.0, y: 1.0 }

    # Component access
    pub fn x(self) -> f32:
        return self.x

    pub fn y(self) -> f32:
        return self.y

    # Vector operations
    pub fn dot(self, other: Vec2) -> f32:
        return self.x * other.x + self.y * other.y

    pub fn length_squared(self) -> f32:
        return self.dot(self)

    pub fn length(self) -> f32:
        return sqrt(self.length_squared())

    pub fn normalize(self) -> Vec2:
        let len = self.length()
        if len < 0.0001:
            return Vec2::unit_x()
        return Vec2 { x: self.x / len, y: self.y / len }

    pub fn distance_to(self, other: Vec2) -> f32:
        let dx = other.x - self.x
        let dy = other.y - self.y
        return sqrt(dx * dx + dy * dy)

    pub fn lerp(self, other: Vec2, t: f32) -> Vec2:
        return Vec2 {
            x: self.x + (other.x - self.x) * t,
            y: self.y + (other.y - self.y) * t
        }

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_zero(self) -> bool:
        """Check if vector is exactly zero."""
        return self.x == 0.0 and self.y == 0.0

    pub fn is_near_zero(self, epsilon: f32) -> bool:
        """Check if vector is near zero within epsilon."""
        return abs(self.x) < epsilon and abs(self.y) < epsilon

    pub fn is_unit(self) -> bool:
        """Check if vector is unit length (normalized)."""
        let len_sq = self.length_squared()
        return abs(len_sq - 1.0) < 0.0001

    pub fn is_normalized(self) -> bool:
        """Check if vector is normalized (alias for is_unit)."""
        return self.is_unit()

    pub fn is_finite(self) -> bool:
        """Check if all components are finite (not NaN or infinity)."""
        return is_finite(self.x) and is_finite(self.y)

    pub fn has_nan(self) -> bool:
        """Check if any component is NaN."""
        return is_nan(self.x) or is_nan(self.y)

    pub fn angle(self) -> f32:
        """Get angle of vector in radians (from positive X axis)."""
        return atan2(self.y, self.x)

    pub fn angle_to(self, other: Vec2) -> f32:
        """Get angle between this vector and another in radians."""
        let dot = self.dot(other)
        let lens = self.length() * other.length()
        if lens < 0.0001:
            return 0.0
        return acos(clamp(dot / lens, -1.0, 1.0))

    pub fn perpendicular(self) -> Vec2:
        """Get perpendicular vector (90 degrees counter-clockwise)."""
        return Vec2 { x: -self.y, y: self.x }

    pub fn component_min(self) -> f32:
        """Get minimum component value."""
        return min(self.x, self.y)

    pub fn component_max(self) -> f32:
        """Get maximum component value."""
        return max(self.x, self.y)

    pub fn abs(self) -> Vec2:
        """Get vector with absolute value of each component."""
        return Vec2 { x: abs(self.x), y: abs(self.y) }

    pub fn min(self, other: Vec2) -> Vec2:
        """Get component-wise minimum."""
        return Vec2 {
            x: min(self.x, other.x),
            y: min(self.y, other.y)
        }

    pub fn max(self, other: Vec2) -> Vec2:
        """Get component-wise maximum."""
        return Vec2 {
            x: max(self.x, other.x),
            y: max(self.y, other.y)
        }

    pub fn clamp(self, min_val: Vec2, max_val: Vec2) -> Vec2:
        """Clamp each component between min and max."""
        return Vec2 {
            x: clamp(self.x, min_val.x, max_val.x),
            y: clamp(self.y, min_val.y, max_val.y)
        }

    pub fn summary(self) -> String:
        """Get summary of vector.

        Returns:
            Human-readable summary

        Example:
            Vec2::new(3.0, 4.0).summary()
            # → "Vec2: (3.000, 4.000), length: 5.000"
        """
        let len = self.length()
        let unit = if self.is_unit(): ", unit" else: ""
        let zero = if self.is_zero(): " [zero]" else: ""
        return "Vec2: ({self.x:.3}, {self.y:.3}), length: {len:.3}{unit}{zero}"

# Vec2 operators
impl Add for Vec2:
    fn add(other: Vec2) -> Vec2:
        return Vec2 { x: self.x + other.x, y: self.y + other.y }

impl Sub for Vec2:
    fn sub(other: Vec2) -> Vec2:
        return Vec2 { x: self.x - other.x, y: self.y - other.y }

impl Mul<f32> for Vec2:
    fn mul(scalar: f32) -> Vec2:
        return Vec2 { x: self.x * scalar, y: self.y * scalar }

impl Div<f32> for Vec2:
    fn div(scalar: f32) -> Vec2:
        return Vec2 { x: self.x / scalar, y: self.y / scalar }

impl Neg for Vec2:
    fn neg() -> Vec2:
        return Vec2 { x: -self.x, y: -self.y }

# =============================================================================
# Vec3 - 3D Vector
# =============================================================================

pub struct Vec3:
    x: f32
    y: f32
    z: f32

impl Vec3:
    # Constructors
    pub fn new(x: f32, y: f32, z: f32) -> Vec3:
        return Vec3 { x: x, y: y, z: z }

    pub fn zero() -> Vec3:
        return Vec3 { x: 0.0, y: 0.0, z: 0.0 }

    pub fn one() -> Vec3:
        return Vec3 { x: 1.0, y: 1.0, z: 1.0 }

    pub fn unit_x() -> Vec3:
        return Vec3 { x: 1.0, y: 0.0, z: 0.0 }

    pub fn unit_y() -> Vec3:
        return Vec3 { x: 0.0, y: 1.0, z: 0.0 }

    pub fn unit_z() -> Vec3:
        return Vec3 { x: 0.0, y: 0.0, z: 1.0 }

    # Component access
    pub fn x(self) -> f32:
        return self.x

    pub fn y(self) -> f32:
        return self.y

    pub fn z(self) -> f32:
        return self.z

    # Vector operations
    pub fn dot(self, other: Vec3) -> f32:
        return self.x * other.x + self.y * other.y + self.z * other.z

    pub fn cross(self, other: Vec3) -> Vec3:
        return Vec3 {
            x: self.y * other.z - self.z * other.y,
            y: self.z * other.x - self.x * other.z,
            z: self.x * other.y - self.y * other.x
        }

    pub fn length_squared(self) -> f32:
        return self.dot(self)

    pub fn length(self) -> f32:
        return sqrt(self.length_squared())

    pub fn normalize(self) -> Vec3:
        let len = self.length()
        if len < 0.0001:
            return Vec3::unit_x()
        return Vec3 { x: self.x / len, y: self.y / len, z: self.z / len }

    pub fn distance_to(self, other: Vec3) -> f32:
        let dx = other.x - self.x
        let dy = other.y - self.y
        let dz = other.z - self.z
        return sqrt(dx * dx + dy * dy + dz * dz)

    pub fn lerp(self, other: Vec3, t: f32) -> Vec3:
        return Vec3 {
            x: self.x + (other.x - self.x) * t,
            y: self.y + (other.y - self.y) * t,
            z: self.z + (other.z - self.z) * t
        }

    pub fn reflect(self, normal: Vec3) -> Vec3:
        let d = self.dot(normal)
        return Vec3 {
            x: self.x - 2.0 * d * normal.x,
            y: self.y - 2.0 * d * normal.y,
            z: self.z - 2.0 * d * normal.z
        }

    # Conversion to Vec2 (drop Z)
    pub fn xy(self) -> Vec2:
        return Vec2::new(self.x, self.y)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_zero(self) -> bool:
        """Check if vector is exactly zero."""
        return self.x == 0.0 and self.y == 0.0 and self.z == 0.0

    pub fn is_near_zero(self, epsilon: f32) -> bool:
        """Check if vector is near zero within epsilon."""
        return abs(self.x) < epsilon and abs(self.y) < epsilon and abs(self.z) < epsilon

    pub fn is_unit(self) -> bool:
        """Check if vector is unit length (normalized)."""
        let len_sq = self.length_squared()
        return abs(len_sq - 1.0) < 0.0001

    pub fn is_normalized(self) -> bool:
        """Check if vector is normalized (alias for is_unit)."""
        return self.is_unit()

    pub fn is_finite(self) -> bool:
        """Check if all components are finite (not NaN or infinity)."""
        return is_finite(self.x) and is_finite(self.y) and is_finite(self.z)

    pub fn has_nan(self) -> bool:
        """Check if any component is NaN."""
        return is_nan(self.x) or is_nan(self.y) or is_nan(self.z)

    pub fn is_parallel(self, other: Vec3, epsilon: f32) -> bool:
        """Check if vectors are parallel (cross product near zero)."""
        let cross = self.cross(other)
        return cross.length_squared() < epsilon * epsilon

    pub fn is_perpendicular(self, other: Vec3, epsilon: f32) -> bool:
        """Check if vectors are perpendicular (dot product near zero)."""
        let dot = self.dot(other)
        return abs(dot) < epsilon

    pub fn angle_to(self, other: Vec3) -> f32:
        """Get angle between this vector and another in radians."""
        let dot = self.dot(other)
        let lens = self.length() * other.length()
        if lens < 0.0001:
            return 0.0
        return acos(clamp(dot / lens, -1.0, 1.0))

    pub fn component_min(self) -> f32:
        """Get minimum component value."""
        return min(min(self.x, self.y), self.z)

    pub fn component_max(self) -> f32:
        """Get maximum component value."""
        return max(max(self.x, self.y), self.z)

    pub fn abs(self) -> Vec3:
        """Get vector with absolute value of each component."""
        return Vec3 { x: abs(self.x), y: abs(self.y), z: abs(self.z) }

    pub fn min(self, other: Vec3) -> Vec3:
        """Get component-wise minimum."""
        return Vec3 {
            x: min(self.x, other.x),
            y: min(self.y, other.y),
            z: min(self.z, other.z)
        }

    pub fn max(self, other: Vec3) -> Vec3:
        """Get component-wise maximum."""
        return Vec3 {
            x: max(self.x, other.x),
            y: max(self.y, other.y),
            z: max(self.z, other.z)
        }

    pub fn clamp(self, min_val: Vec3, max_val: Vec3) -> Vec3:
        """Clamp each component between min and max."""
        return Vec3 {
            x: clamp(self.x, min_val.x, max_val.x),
            y: clamp(self.y, min_val.y, max_val.y),
            z: clamp(self.z, min_val.z, max_val.z)
        }

    pub fn project_onto(self, onto: Vec3) -> Vec3:
        """Project this vector onto another vector."""
        let onto_len_sq = onto.length_squared()
        if onto_len_sq < 0.0001:
            return Vec3::zero()
        let scale = self.dot(onto) / onto_len_sq
        return onto * scale

    pub fn reject_from(self, from: Vec3) -> Vec3:
        """Get rejection of this vector from another (perpendicular component)."""
        return self - self.project_onto(from)

    pub fn summary(self) -> String:
        """Get summary of vector.

        Returns:
            Human-readable summary

        Example:
            Vec3::new(1.0, 0.0, 0.0).summary()
            # → "Vec3: (1.000, 0.000, 0.000), length: 1.000, unit"
        """
        let len = self.length()
        let unit = if self.is_unit(): ", unit" else: ""
        let zero = if self.is_zero(): " [zero]" else: ""
        return "Vec3: ({self.x:.3}, {self.y:.3}, {self.z:.3}), length: {len:.3}{unit}{zero}"

# Vec3 operators
impl Add for Vec3:
    fn add(other: Vec3) -> Vec3:
        return Vec3 { x: self.x + other.x, y: self.y + other.y, z: self.z + other.z }

impl Sub for Vec3:
    fn sub(other: Vec3) -> Vec3:
        return Vec3 { x: self.x - other.x, y: self.y - other.y, z: self.z - other.z }

impl Mul<f32> for Vec3:
    fn mul(scalar: f32) -> Vec3:
        return Vec3 { x: self.x * scalar, y: self.y * scalar, z: self.z * scalar }

impl Div<f32> for Vec3:
    fn div(scalar: f32) -> Vec3:
        return Vec3 { x: self.x / scalar, y: self.y / scalar, z: self.z / scalar }

impl Neg for Vec3:
    fn neg() -> Vec3:
        return Vec3 { x: -self.x, y: -self.y, z: -self.z }

# =============================================================================
# Vec4 - 4D Vector (for homogeneous coordinates and colors)
# =============================================================================

pub struct Vec4:
    x: f32
    y: f32
    z: f32
    w: f32

impl Vec4:
    # Constructors
    pub fn new(x: f32, y: f32, z: f32, w: f32) -> Vec4:
        return Vec4 { x: x, y: y, z: z, w: w }

    pub fn zero() -> Vec4:
        return Vec4 { x: 0.0, y: 0.0, z: 0.0, w: 0.0 }

    pub fn one() -> Vec4:
        return Vec4 { x: 1.0, y: 1.0, z: 1.0, w: 1.0 }

    # Create Vec4 from Vec3 + w component
    pub fn from_vec3(v: Vec3, w: f32) -> Vec4:
        return Vec4 { x: v.x, y: v.y, z: v.z, w: w }

    # Component access
    pub fn x(self) -> f32:
        return self.x

    pub fn y(self) -> f32:
        return self.y

    pub fn z(self) -> f32:
        return self.z

    pub fn w(self) -> f32:
        return self.w

    # Conversion to Vec3 (drop W)
    pub fn xyz(self) -> Vec3:
        return Vec3::new(self.x, self.y, self.z)

    # Homogeneous divide (for perspective division)
    pub fn homogeneous_divide(self) -> Vec3:
        if abs(self.w) < 0.0001:
            return self.xyz()
        return Vec3::new(self.x / self.w, self.y / self.w, self.z / self.w)

    # Vector operations
    pub fn dot(self, other: Vec4) -> f32:
        return self.x * other.x + self.y * other.y + self.z * other.z + self.w * other.w

    pub fn length_squared(self) -> f32:
        return self.dot(self)

    pub fn length(self) -> f32:
        return sqrt(self.length_squared())

    pub fn normalize(self) -> Vec4:
        let len = self.length()
        if len < 0.0001:
            return Vec4 { x: 1.0, y: 0.0, z: 0.0, w: 0.0 }
        return Vec4 {
            x: self.x / len,
            y: self.y / len,
            z: self.z / len,
            w: self.w / len
        }

    pub fn lerp(self, other: Vec4, t: f32) -> Vec4:
        return Vec4 {
            x: self.x + (other.x - self.x) * t,
            y: self.y + (other.y - self.y) * t,
            z: self.z + (other.z - self.z) * t,
            w: self.w + (other.w - self.w) * t
        }

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_zero(self) -> bool:
        """Check if vector is exactly zero."""
        return self.x == 0.0 and self.y == 0.0 and self.z == 0.0 and self.w == 0.0

    pub fn is_near_zero(self, epsilon: f32) -> bool:
        """Check if vector is near zero within epsilon."""
        return abs(self.x) < epsilon and abs(self.y) < epsilon and
               abs(self.z) < epsilon and abs(self.w) < epsilon

    pub fn is_unit(self) -> bool:
        """Check if vector is unit length (normalized)."""
        let len_sq = self.length_squared()
        return abs(len_sq - 1.0) < 0.0001

    pub fn is_normalized(self) -> bool:
        """Check if vector is normalized (alias for is_unit)."""
        return self.is_unit()

    pub fn is_finite(self) -> bool:
        """Check if all components are finite (not NaN or infinity)."""
        return is_finite(self.x) and is_finite(self.y) and
               is_finite(self.z) and is_finite(self.w)

    pub fn has_nan(self) -> bool:
        """Check if any component is NaN."""
        return is_nan(self.x) or is_nan(self.y) or is_nan(self.z) or is_nan(self.w)

    pub fn is_homogeneous_point(self) -> bool:
        """Check if this represents a point in homogeneous coordinates (w ≈ 1)."""
        return abs(self.w - 1.0) < 0.0001

    pub fn is_homogeneous_vector(self) -> bool:
        """Check if this represents a vector in homogeneous coordinates (w ≈ 0)."""
        return abs(self.w) < 0.0001

    pub fn component_min(self) -> f32:
        """Get minimum component value."""
        return min(min(min(self.x, self.y), self.z), self.w)

    pub fn component_max(self) -> f32:
        """Get maximum component value."""
        return max(max(max(self.x, self.y), self.z), self.w)

    pub fn abs(self) -> Vec4:
        """Get vector with absolute value of each component."""
        return Vec4 {
            x: abs(self.x),
            y: abs(self.y),
            z: abs(self.z),
            w: abs(self.w)
        }

    pub fn min(self, other: Vec4) -> Vec4:
        """Get component-wise minimum."""
        return Vec4 {
            x: min(self.x, other.x),
            y: min(self.y, other.y),
            z: min(self.z, other.z),
            w: min(self.w, other.w)
        }

    pub fn max(self, other: Vec4) -> Vec4:
        """Get component-wise maximum."""
        return Vec4 {
            x: max(self.x, other.x),
            y: max(self.y, other.y),
            z: max(self.z, other.z),
            w: max(self.w, other.w)
        }

    pub fn clamp(self, min_val: Vec4, max_val: Vec4) -> Vec4:
        """Clamp each component between min and max."""
        return Vec4 {
            x: clamp(self.x, min_val.x, max_val.x),
            y: clamp(self.y, min_val.y, max_val.y),
            z: clamp(self.z, min_val.z, max_val.z),
            w: clamp(self.w, min_val.w, max_val.w)
        }

    pub fn summary(self) -> String:
        """Get summary of vector.

        Returns:
            Human-readable summary

        Example:
            Vec4::new(1.0, 0.0, 0.0, 1.0).summary()
            # → "Vec4: (1.000, 0.000, 0.000, 1.000), length: 1.414 [point]"
        """
        let len = self.length()
        let unit = if self.is_unit(): ", unit" else: ""
        let zero = if self.is_zero(): " [zero]" else: ""
        let htype = if self.is_homogeneous_point(): " [point]"
                    else if self.is_homogeneous_vector(): " [vector]"
                    else: ""
        return "Vec4: ({self.x:.3}, {self.y:.3}, {self.z:.3}, {self.w:.3}), length: {len:.3}{unit}{zero}{htype}"

# Vec4 operators
impl Add for Vec4:
    fn add(other: Vec4) -> Vec4:
        return Vec4 {
            x: self.x + other.x,
            y: self.y + other.y,
            z: self.z + other.z,
            w: self.w + other.w
        }

impl Sub for Vec4:
    fn sub(other: Vec4) -> Vec4:
        return Vec4 {
            x: self.x - other.x,
            y: self.y - other.y,
            z: self.z - other.z,
            w: self.w - other.w
        }

impl Mul<f32> for Vec4:
    fn mul(scalar: f32) -> Vec4:
        return Vec4 {
            x: self.x * scalar,
            y: self.y * scalar,
            z: self.z * scalar,
            w: self.w * scalar
        }

impl Div<f32> for Vec4:
    fn div(scalar: f32) -> Vec4:
        return Vec4 {
            x: self.x / scalar,
            y: self.y / scalar,
            z: self.z / scalar,
            w: self.w / scalar
        }

impl Neg for Vec4:
    fn neg() -> Vec4:
        return Vec4 { x: -self.x, y: -self.y, z: -self.z, w: -self.w }
