# Terminal I/O - Async terminal input/output operations
# Provides cross-platform terminal handling with ANSI support

use units.size.*
use core.*
use host.common.io.term_types.*
use host.common.io.term_ffi.*

# Terminal handle for I/O operations
pub struct Terminal:
    stdin: RawHandle
    stdout: RawHandle
    stderr: RawHandle
    is_tty: bool
    raw_mode: bool

impl Terminal:
    # Get the default terminal
    @io
    pub async fn default() -> Terminal:
        return Terminal {
            stdin: native_stdin(),
            stdout: native_stdout(),
            stderr: native_stderr(),
            is_tty: native_is_tty(native_stdout()),
            raw_mode: false
        }

    # Check if stdout is a TTY
    @pure
    pub fn is_tty(self) -> bool:
        return self.is_tty

    # Check if raw mode is enabled
    @pure
    pub fn is_raw_mode(self) -> bool:
        return self.raw_mode

    # Enable raw mode (no line buffering, no echo)
    @io
    pub async fn enable_raw_mode(self) -> Result<(), TermError>:
        if self.raw_mode:
            return Ok(())
        match native_enable_raw_mode(self.stdin):
            case 0:
                self.raw_mode = true
                return Ok(())
            case e: return Err(TermError::from_code(e))

    # Disable raw mode (restore normal terminal)
    @io
    pub async fn disable_raw_mode(self) -> Result<(), TermError>:
        if not self.raw_mode:
            return Ok(())
        match native_disable_raw_mode(self.stdin):
            case 0:
                self.raw_mode = false
                return Ok(())
            case e: return Err(TermError::from_code(e))

    # Get terminal size
    @io
    pub async fn size(self) -> Result<TermSize, TermError>:
        let mut rows: u16 = 0
        let mut cols: u16 = 0
        match native_get_term_size(self.stdout, &mut rows, &mut cols):
            case 0: return Ok(TermSize { rows: rows, cols: cols })
            case e: return Err(TermError::from_code(e))

    # Write string to stdout
    @io
    pub async fn write(self, s: &str) -> Result<ByteCount, TermError>:
        let written = native_term_write(self.stdout, s.as_ptr(), s.len())
        if written < 0:
            return Err(TermError::from_code(written as i32))
        return Ok((written as u64)_bytes)

    # Write line to stdout (with newline)
    @io
    pub async fn writeln(self, s: &str) -> Result<ByteCount, TermError>:
        let total = self.write(s).await?
        let nl = self.write("\n").await?
        return Ok(total + nl)

    # Write to stderr
    @io
    pub async fn write_err(self, s: &str) -> Result<ByteCount, TermError>:
        let written = native_term_write(self.stderr, s.as_ptr(), s.len())
        if written < 0:
            return Err(TermError::from_code(written as i32))
        return Ok((written as u64)_bytes)

    # Flush stdout
    @io
    pub async fn flush(self) -> Result<(), TermError>:
        match native_term_flush(self.stdout):
            case 0: return Ok(())
            case e: return Err(TermError::from_code(e))

    # Read a single byte from stdin
    @io
    pub async fn read_byte(self) -> Result<u8, TermError>:
        let mut buf: [u8; 1] = [0]
        let n = native_term_read(self.stdin, &mut buf[0], 1)
        if n < 0:
            return Err(TermError::from_code(n as i32))
        if n == 0:
            return Err(TermError::Eof)
        return Ok(buf[0])

    # Read bytes into buffer
    @io
    pub async fn read(self, buf: &mut [u8]) -> Result<ByteCount, TermError>:
        let n = native_term_read(self.stdin, buf.as_mut_ptr(), buf.len())
        if n < 0:
            return Err(TermError::from_code(n as i32))
        return Ok((n as u64)_bytes)

    # Read a line from stdin
    pub async fn read_line(self) -> Result<String, TermError>:
        let mut line = String::new()
        loop:
            let byte = self.read_byte().await?
            if byte == '\n' as u8:
                break
            if byte == '\r' as u8:
                # Handle CRLF
                continue
            line.push(byte as char)
        return Ok(line)

    # Read with timeout (milliseconds)
    pub async fn read_timeout(self, buf: &mut [u8], timeout_ms: u64) -> Result<ByteCount, TermError>:
        let n = native_term_read_timeout(self.stdin, buf.as_mut_ptr(), buf.len(), timeout_ms)
        if n < 0:
            return Err(TermError::from_code(n as i32))
        return Ok((n as u64)_bytes)

    # Check if input is available (non-blocking)
    pub async fn poll_input(self, timeout_ms: u64) -> Result<bool, TermError>:
        match native_term_poll(self.stdin, timeout_ms):
            case 1: return Ok(true)
            case 0: return Ok(false)
            case e: return Err(TermError::from_code(e))

    # Clear screen
    pub async fn clear(self) -> Result<(), TermError>:
        return self.write("\x1b[2J\x1b[H").await.map(|_| ())

    # Clear line
    pub async fn clear_line(self) -> Result<(), TermError>:
        return self.write("\x1b[2K").await.map(|_| ())

    # Move cursor to position (1-indexed)
    pub async fn move_to(self, row: u16, col: u16) -> Result<(), TermError>:
        return self.write("\x1b[{row};{col}H").await.map(|_| ())

    # Move cursor up
    pub async fn move_up(self, n: u16) -> Result<(), TermError>:
        if n > 0:
            return self.write("\x1b[{n}A").await.map(|_| ())
        return Ok(())

    # Move cursor down
    pub async fn move_down(self, n: u16) -> Result<(), TermError>:
        if n > 0:
            return self.write("\x1b[{n}B").await.map(|_| ())
        return Ok(())

    # Move cursor right
    pub async fn move_right(self, n: u16) -> Result<(), TermError>:
        if n > 0:
            return self.write("\x1b[{n}C").await.map(|_| ())
        return Ok(())

    # Move cursor left
    pub async fn move_left(self, n: u16) -> Result<(), TermError>:
        if n > 0:
            return self.write("\x1b[{n}D").await.map(|_| ())
        return Ok(())

    # Hide cursor
    pub async fn hide_cursor(self) -> Result<(), TermError>:
        return self.write("\x1b[?25l").await.map(|_| ())

    # Show cursor
    pub async fn show_cursor(self) -> Result<(), TermError>:
        return self.write("\x1b[?25h").await.map(|_| ())

    # Save cursor position
    pub async fn save_cursor(self) -> Result<(), TermError>:
        return self.write("\x1b[s").await.map(|_| ())

    # Restore cursor position
    pub async fn restore_cursor(self) -> Result<(), TermError>:
        return self.write("\x1b[u").await.map(|_| ())

    # Get cursor position
    pub async fn cursor_position(self) -> Result<CursorPos, TermError>:
        # Send position query
        self.write("\x1b[6n").await?
        self.flush().await?

        # Read response: ESC [ rows ; cols R
        let mut buf: [u8; 32] = [0; 32]
        let mut idx: u64 = 0

        # Read until 'R'
        loop:
            let byte = self.read_byte().await?
            if idx >= 32:
                return Err(TermError::InvalidResponse)
            buf[idx] = byte
            idx = idx + 1
            if byte == 'R' as u8:
                break

        # Parse response
        return parse_cursor_response(&buf[0..idx])

    # Set terminal title
    pub async fn set_title(self, title: &str) -> Result<(), TermError>:
        return self.write("\x1b]0;{title}\x07").await.map(|_| ())

    # Ring bell
    pub async fn bell(self) -> Result<(), TermError>:
        return self.write("\x07").await.map(|_| ())

    # Drop - restore terminal state
    fn drop():
        if self.raw_mode:
            native_disable_raw_mode(self.stdin)

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_interactive(self) -> bool:
        """Check if terminal is interactive (alias for is_tty).

        Returns:
            true if terminal is TTY

        Example:
            terminal.is_interactive()  # → true
        """
        return self.is_tty()

    pub fn has_raw_mode(self) -> bool:
        """Check if raw mode is enabled (alias for is_raw_mode).

        Returns:
            true if raw mode enabled

        Example:
            terminal.has_raw_mode()  # → false
        """
        return self.is_raw_mode()

    pub fn can_use_ansi(self) -> bool:
        """Check if terminal supports ANSI escape codes.

        Returns:
            true if ANSI supported (same as is_tty)

        Example:
            terminal.can_use_ansi()  # → true
        """
        return self.is_tty

    pub fn is_piped(self) -> bool:
        """Check if output is piped (not a TTY).

        Returns:
            true if piped

        Example:
            terminal.is_piped()  # → false
        """
        return not self.is_tty

    pub fn supports_color(self) -> bool:
        """Check if terminal likely supports color output.

        Returns:
            true if color supported

        Example:
            terminal.supports_color()  # → true
        """
        return self.is_tty

    pub async fn width(self) -> Result<u16, TermError>:
        """Get terminal width in columns.

        Returns:
            Column count

        Example:
            terminal.width()  # → Ok(80)
        """
        let size = self.size().await?
        return Ok(size.cols)

    pub async fn height(self) -> Result<u16, TermError>:
        """Get terminal height in rows.

        Returns:
            Row count

        Example:
            terminal.height()  # → Ok(24)
        """
        let size = self.size().await?
        return Ok(size.rows)

    pub async fn area(self) -> Result<u32, TermError>:
        """Get terminal area (width * height).

        Returns:
            Total character cells

        Example:
            terminal.area()  # → Ok(1920)
        """
        let size = self.size().await?
        return Ok((size.rows as u32) * (size.cols as u32))

    pub async fn print(self, s: &str) -> Result<(), TermError>:
        """Print string to stdout and flush (convenience method).

        Args:
            s: String to print

        Returns:
            Ok on success

        Example:
            terminal.print("Hello")
        """
        self.write(s).await?
        return self.flush().await

    pub async fn print_err(self, s: &str) -> Result<(), TermError>:
        """Print string to stderr (convenience method).

        Args:
            s: String to print

        Returns:
            Ok on success

        Example:
            terminal.print_err("Error message")
        """
        return self.write_err(s).await.map(|_| ())

    pub fn summary(self) -> String:
        """Get terminal summary.

        Returns:
            Human-readable summary

        Example:
            terminal.summary()
            # → "Terminal: tty, raw_mode=false"
        """
        let tty_str = if self.is_tty { "tty" } else { "piped" }
        let raw_str = if self.raw_mode { "true" } else { "false" }
        return "Terminal: {tty_str}, raw_mode={raw_str}"

# Parse cursor position response
fn parse_cursor_response(buf: &[u8]) -> Result<CursorPos, TermError>:
    # Format: ESC [ rows ; cols R
    if buf.len() < 6:
        return Err(TermError::InvalidResponse)

    # Find positions
    let mut row: u16 = 0
    let mut col: u16 = 0
    let mut parsing_row = true

    for i in 2..buf.len():  # Skip ESC [
        let c = buf[i]
        if c == ';' as u8:
            parsing_row = false
        else if c == 'R' as u8:
            break
        else if c >= '0' as u8 and c <= '9' as u8:
            let digit = (c - '0' as u8) as u16
            if parsing_row:
                row = row * 10 + digit
            else:
                col = col * 10 + digit

    return Ok(CursorPos { row: row, col: col })

# Read and parse a key event
pub async fn read_key(term: &mut Terminal) -> Result<KeyEvent, TermError>:
    let byte = term.read_byte().await?

    # Escape sequence
    if byte == 0x1b:
        # Check if more bytes available
        if term.poll_input(50).await? == false:
            return Ok(KeyEvent {
                code: KeyCode::Escape,
                modifiers: KeyModifiers::none()
            })

        let byte2 = term.read_byte().await?
        if byte2 == '[' as u8:
            return parse_csi_sequence(term).await
        else if byte2 == 'O' as u8:
            return parse_ss3_sequence(term).await
        else:
            # Alt + key
            return Ok(KeyEvent {
                code: KeyCode::Char(byte2 as char),
                modifiers: KeyModifiers::alt()
            })

    # Ctrl characters
    if byte < 32:
        match byte:
            case 0: return Ok(KeyEvent { code: KeyCode::Null, modifiers: KeyModifiers::none() })
            case 9: return Ok(KeyEvent { code: KeyCode::Tab, modifiers: KeyModifiers::none() })
            case 10: return Ok(KeyEvent { code: KeyCode::Enter, modifiers: KeyModifiers::none() })
            case 13: return Ok(KeyEvent { code: KeyCode::Enter, modifiers: KeyModifiers::none() })
            case 27: return Ok(KeyEvent { code: KeyCode::Escape, modifiers: KeyModifiers::none() })
            case _:
                # Ctrl+A through Ctrl+Z
                let ch = ('a' as u8 + byte - 1) as char
                return Ok(KeyEvent {
                    code: KeyCode::Char(ch),
                    modifiers: KeyModifiers::ctrl()
                })

    # Backspace
    if byte == 127:
        return Ok(KeyEvent { code: KeyCode::Backspace, modifiers: KeyModifiers::none() })

    # Regular character
    return Ok(KeyEvent {
        code: KeyCode::Char(byte as char),
        modifiers: KeyModifiers::none()
    })

# Parse CSI (Control Sequence Introducer) sequence: ESC [
async fn parse_csi_sequence(term: &mut Terminal) -> Result<KeyEvent, TermError>:
    let byte = term.read_byte().await?

    match byte:
        case 'A' as u8: return Ok(KeyEvent { code: KeyCode::Up, modifiers: KeyModifiers::none() })
        case 'B' as u8: return Ok(KeyEvent { code: KeyCode::Down, modifiers: KeyModifiers::none() })
        case 'C' as u8: return Ok(KeyEvent { code: KeyCode::Right, modifiers: KeyModifiers::none() })
        case 'D' as u8: return Ok(KeyEvent { code: KeyCode::Left, modifiers: KeyModifiers::none() })
        case 'H' as u8: return Ok(KeyEvent { code: KeyCode::Home, modifiers: KeyModifiers::none() })
        case 'F' as u8: return Ok(KeyEvent { code: KeyCode::End, modifiers: KeyModifiers::none() })
        case '1' as u8:
            let next = term.read_byte().await?
            if next == '~' as u8:
                return Ok(KeyEvent { code: KeyCode::Home, modifiers: KeyModifiers::none() })
            # F1-F4: ESC [ 1 1 ~ through ESC [ 1 4 ~
            if next >= '1' as u8 and next <= '5' as u8:
                term.read_byte().await?  # Read ~
                let fn_num = next - '0' as u8
                return Ok(KeyEvent { code: KeyCode::F(fn_num), modifiers: KeyModifiers::none() })
            return Ok(KeyEvent { code: KeyCode::Null, modifiers: KeyModifiers::none() })
        case '2' as u8:
            let next = term.read_byte().await?
            if next == '~' as u8:
                return Ok(KeyEvent { code: KeyCode::Insert, modifiers: KeyModifiers::none() })
            # F9-F12: ESC [ 2 0 ~ through ESC [ 2 4 ~
            return Ok(KeyEvent { code: KeyCode::Null, modifiers: KeyModifiers::none() })
        case '3' as u8:
            term.read_byte().await?  # Read ~
            return Ok(KeyEvent { code: KeyCode::Delete, modifiers: KeyModifiers::none() })
        case '4' as u8:
            term.read_byte().await?  # Read ~
            return Ok(KeyEvent { code: KeyCode::End, modifiers: KeyModifiers::none() })
        case '5' as u8:
            term.read_byte().await?  # Read ~
            return Ok(KeyEvent { code: KeyCode::PageUp, modifiers: KeyModifiers::none() })
        case '6' as u8:
            term.read_byte().await?  # Read ~
            return Ok(KeyEvent { code: KeyCode::PageDown, modifiers: KeyModifiers::none() })
        case _:
            return Ok(KeyEvent { code: KeyCode::Null, modifiers: KeyModifiers::none() })

# Parse SS3 sequence: ESC O
async fn parse_ss3_sequence(term: &mut Terminal) -> Result<KeyEvent, TermError>:
    let byte = term.read_byte().await?

    match byte:
        case 'P' as u8: return Ok(KeyEvent { code: KeyCode::F(1), modifiers: KeyModifiers::none() })
        case 'Q' as u8: return Ok(KeyEvent { code: KeyCode::F(2), modifiers: KeyModifiers::none() })
        case 'R' as u8: return Ok(KeyEvent { code: KeyCode::F(3), modifiers: KeyModifiers::none() })
        case 'S' as u8: return Ok(KeyEvent { code: KeyCode::F(4), modifiers: KeyModifiers::none() })
        case 'H' as u8: return Ok(KeyEvent { code: KeyCode::Home, modifiers: KeyModifiers::none() })
        case 'F' as u8: return Ok(KeyEvent { code: KeyCode::End, modifiers: KeyModifiers::none() })
        case _: return Ok(KeyEvent { code: KeyCode::Null, modifiers: KeyModifiers::none() })

# ============================================================================
# Print Functions - Python-style print (parentheses optional at statement level)
# ============================================================================
# Usage (parentheses optional):
#   print "hello"           # prints: hello (no newline)
#   print("hello")          # same as above
#   println "hello"         # prints: hello\n
#   println("hello")        # same as above
#   print "a", "b", "c"     # prints: a b c
#   println "x =", x        # prints: x = 42\n
# ============================================================================

# Print to stdout (no newline)
pub fn print(args: ..any):
    let stdout = native_stdout()
    let mut first = true
    for arg in args:
        if not first:
            native_term_write(stdout, " ".as_ptr(), 1)
        native_term_write(stdout, arg.to_string().as_ptr(), arg.to_string().len())
        first = false
    native_term_flush(stdout)

# Print to stdout with newline
pub fn println(args: ..any):
    let stdout = native_stdout()
    let mut first = true
    for arg in args:
        if not first:
            native_term_write(stdout, " ".as_ptr(), 1)
        native_term_write(stdout, arg.to_string().as_ptr(), arg.to_string().len())
        first = false
    native_term_write(stdout, "\n".as_ptr(), 1)
    native_term_flush(stdout)

# Print to stderr (no newline)
pub fn eprint(args: ..any):
    let stderr = native_stderr()
    let mut first = true
    for arg in args:
        if not first:
            native_term_write(stderr, " ".as_ptr(), 1)
        native_term_write(stderr, arg.to_string().as_ptr(), arg.to_string().len())
        first = false
    native_term_flush(stderr)

# Print to stderr with newline
pub fn eprintln(args: ..any):
    let stderr = native_stderr()
    let mut first = true
    for arg in args:
        if not first:
            native_term_write(stderr, " ".as_ptr(), 1)
        native_term_write(stderr, arg.to_string().as_ptr(), arg.to_string().len())
        first = false
    native_term_write(stderr, "\n".as_ptr(), 1)
    native_term_flush(stderr)

# Print with custom separator
pub fn print_sep(sep: &str, args: ..any):
    let stdout = native_stdout()
    let mut first = true
    for arg in args:
        if not first:
            native_term_write(stdout, sep.as_ptr(), sep.len())
        native_term_write(stdout, arg.to_string().as_ptr(), arg.to_string().len())
        first = false
    native_term_flush(stdout)

# Print with custom separator and newline
pub fn println_sep(sep: &str, args: ..any):
    let stdout = native_stdout()
    let mut first = true
    for arg in args:
        if not first:
            native_term_write(stdout, sep.as_ptr(), sep.len())
        native_term_write(stdout, arg.to_string().as_ptr(), arg.to_string().len())
        first = false
    native_term_write(stdout, "\n".as_ptr(), 1)
    native_term_flush(stdout)

# Debug print with location info (like Rust's dbg!)
pub macro dbg(expr: Any) -> (returns result: Any):
    emit result:
        let val = expr
        eprintln "[{__FILE__}:{__LINE__}] {stringify!(expr)} = {val}"
        return val

# Read line from stdin (like Python's input())
pub fn input(prompt: &str = "") -> String:
    if prompt.len() > 0:
        print prompt
    let stdin = native_stdin()
    let mut line = String::new()
    let mut buf: [u8; 1] = [0]
    loop:
        let n = native_term_read(stdin, &mut buf[0], 1)
        if n <= 0:
            break
        let byte = buf[0]
        if byte == '\n' as u8:
            break
        if byte == '\r' as u8:
            continue
        line.push(byte as char)
    return line

# Read line with default value
pub fn input_or(prompt: &str, default: &str) -> String:
    let result = input(prompt)
    if result.is_empty():
        return default.to_string()
    return result

# Read integer from stdin
pub fn input_int(prompt: &str = "") -> Result<i64, ParseError>:
    let s = input(prompt)
    return s.parse_int()

# Read float from stdin
pub fn input_float(prompt: &str = "") -> Result<f64, ParseError>:
    let s = input(prompt)
    return s.parse_float()

# Yes/No prompt
pub fn confirm(prompt: &str, default: Option<bool> = None) -> bool:
    let suffix = match default:
        case Some(true): " [Y/n] "
        case Some(false): " [y/N] "
        case None: " [y/n] "

    loop:
        let response = input(prompt + suffix).trim().to_lowercase()
        if response.is_empty():
            match default:
                case Some(val): return val
                case None: continue
        if response == "y" or response == "yes":
            return true
        if response == "n" or response == "no":
            return false
        println "Please enter 'y' or 'n'"
