# TUI Renderer - Terminal UI Rendering Implementation
#
# Renders UI elements to the terminal using ANSI escape codes
# and box-drawing characters. Uses the terminal primitives from
# host/io/term.spl.

use core.*
use host.async_nogc_mut.io.term.*
use host.async_nogc_mut.io.term_style.*
use ui.element.*
use ui.attrs.*
use ui.patchset.*
use ui.renderer.*
use ui.common.colors.parse_color

# TUI Renderer state
pub struct TuiRenderer:
    terminal: Terminal
    width: u16
    height: u16
    layout_cache: LayoutCache
    initialized: bool
    # Screen buffer for rendering
    screen: ScreenBuffer
    # Box drawing style
    box_style: BoxChars

# Simple screen buffer (array of cells)
struct ScreenBuffer:
    width: u16
    height: u16
    cells: Array[Cell]
    dirty: Array[bool]

struct Cell:
    ch: char
    fg: Color
    bg: Color
    style: TextStyle

impl Cell:
    fn default() -> Cell:
        return Cell {
            ch: ' ',
            fg: Color::Default,
            bg: Color::Default,
            style: TextStyle::new()
        }

impl ScreenBuffer:
    fn new(width: u16, height: u16) -> ScreenBuffer:
        let size = (width as u64) * (height as u64)
        let mut cells: Array[Cell] = []
        let mut dirty: Array[bool] = []
        for _ in 0..size:
            cells.push(Cell::default())
            dirty.push(false)
        return ScreenBuffer {
            width: width,
            height: height,
            cells: cells,
            dirty: dirty
        }

    fn resize(self, width: u16, height: u16):
        let new_size = (width as u64) * (height as u64)
        self.width = width
        self.height = height
        self.cells.clear()
        self.dirty.clear()
        for _ in 0..new_size:
            self.cells.push(Cell::default())
            self.dirty.push(true)

    fn set(self, x: u16, y: u16, cell: Cell):
        if x < self.width and y < self.height:
            let idx = (y as u64) * (self.width as u64) + (x as u64)
            self.cells[idx] = cell
            self.dirty[idx] = true

    fn get(self, x: u16, y: u16) -> &Cell:
        let idx = (y as u64) * (self.width as u64) + (x as u64)
        return &self.cells[idx]

    fn mark_all_dirty(self):
        for i in 0..self.dirty.len():
            self.dirty[i] = true

    fn clear_dirty(self):
        for i in 0..self.dirty.len():
            self.dirty[i] = false

impl TuiRenderer:
    # Create a new TUI renderer
    pub async fn new() -> TuiRenderer:
        let term = Terminal::default().await
        let size = term.size().await.unwrap_or(TermSize { rows: 24, cols: 80 })
        return TuiRenderer {
            terminal: term,
            width: size.cols(),
            height: size.rows(),
            layout_cache: LayoutCache::new(),
            initialized: false,
            screen: ScreenBuffer::new(size.cols(), size.rows()),
            box_style: BoxChars::rounded()
        }

    # Set box drawing style
    pub fn set_box_style(self, style: BoxChars):
        self.box_style = style

impl RenderBackend for TuiRenderer:
    fn init(self) -> Result[(), RenderError]:
        if self.initialized:
            return Err(RenderError::AlreadyInitialized)

        # Enable raw mode
        match self.terminal.enable_raw_mode().await:
            case Ok(_): pass
            case Err(e): return Err(RenderError::IoError(e.message()))

        # Hide cursor
        self.terminal.hide_cursor().await.ok()

        # Clear screen
        self.terminal.clear().await.ok()

        self.initialized = true
        return Ok(())

    fn shutdown(self) -> Result[(), RenderError]:
        if not self.initialized:
            return Err(RenderError::NotInitialized)

        # Show cursor
        self.terminal.show_cursor().await.ok()

        # Disable raw mode
        self.terminal.disable_raw_mode().await.ok()

        # Clear screen
        self.terminal.clear().await.ok()

        self.initialized = false
        return Ok(())

    fn dimensions(self) -> (u16, u16):
        return (self.width, self.height)

    fn render(self, tree: &ElementTree) -> Result[(), RenderError]:
        if not self.initialized:
            return Err(RenderError::NotInitialized)

        # Clear layout cache
        self.layout_cache.clear()

        # Layout and render root element
        let root_layout = Layout::new(0, 0, self.width, self.height)
        self.render_element(tree.root(), root_layout)

        # Flush screen buffer
        return self.flush()

    fn apply_patches(self, patches: &PatchSet) -> Result[(), RenderError]:
        if not self.initialized:
            return Err(RenderError::NotInitialized)

        # For now, just mark dirty and re-render affected areas
        # A more sophisticated implementation would handle each patch type
        for patch in patches.iter():
            match patch:
                case SetText { node_id, text }:
                    # Mark node layout as dirty
                    if let Some(layout) = self.layout_cache.get(node_id):
                        self.mark_dirty_rect(layout.x, layout.y, layout.width, layout.height)
                case _:
                    # For structural changes, mark entire screen dirty
                    self.screen.mark_all_dirty()
                    break

        return self.flush()

    fn clear(self) -> Result[(), RenderError]:
        if not self.initialized:
            return Err(RenderError::NotInitialized)

        # Clear screen buffer
        for y in 0..self.height:
            for x in 0..self.width:
                self.screen.set(x, y, Cell::default())

        # Clear actual terminal
        match self.terminal.clear().await:
            case Ok(_): return Ok(())
            case Err(e): return Err(RenderError::IoError(e.message()))

    fn flush(self) -> Result[(), RenderError]:
        if not self.initialized:
            return Err(RenderError::NotInitialized)

        # Render dirty cells to terminal
        for y in 0..self.height:
            for x in 0..self.width:
                let idx = (y as u64) * (self.width as u64) + (x as u64)
                if self.screen.dirty[idx]:
                    let cell = &self.screen.cells[idx]

                    # Move cursor
                    self.terminal.move_to(y + 1, x + 1).await.ok()

                    # Build style
                    let mut style = Style::new()
                    if cell.fg != Color::Default:
                        style = style.fg(cell.fg)
                    if cell.bg != Color::Default:
                        style = style.bg(cell.bg)

                    # Apply text style
                    let styled = style.apply(&cell.ch.to_string())
                    self.terminal.write(&styled).await.ok()

        # Clear dirty flags
        self.screen.clear_dirty()

        # Flush terminal
        match self.terminal.flush().await:
            case Ok(_): return Ok(())
            case Err(e): return Err(RenderError::IoError(e.message()))

    fn poll_event(self, timeout_ms: u64) -> Result[Option[Event], RenderError]:
        if not self.initialized:
            return Err(RenderError::NotInitialized)

        match self.terminal.poll_input(timeout_ms).await:
            case Ok(true):
                return self.read_event().map(|e| Some(e))
            case Ok(false):
                return Ok(None)
            case Err(e):
                return Err(RenderError::IoError(e.message()))

    fn read_event(self) -> Result[Event, RenderError]:
        if not self.initialized:
            return Err(RenderError::NotInitialized)

        match read_key(&mut self.terminal).await:
            case Ok(key):
                let event = Event::Key(KeyEvent {
                    code: convert_key_code(key.code),
                    modifiers: KeyModifiers {
                        shift: key.modifiers.shift,
                        ctrl: key.modifiers.ctrl,
                        alt: key.modifiers.alt
                    }
                })
                return Ok(event)
            case Err(e):
                return Err(RenderError::IoError(e.message()))

impl TuiRenderer:
    # Render a single element
    fn render_element(self, elem: &Element, layout: Layout):
        # Store layout for later hit testing
        self.layout_cache.set(elem.id, layout)

        # Render based on element kind
        match elem.kind:
            case ElementKind::Text:
                self.render_text(elem, layout)
            case ElementKind::Box:
                self.render_box(elem, layout)
            case ElementKind::Button:
                self.render_button(elem, layout)
            case ElementKind::Input:
                self.render_input(elem, layout)
            case ElementKind::Div | ElementKind::Row | ElementKind::Column:
                self.render_container(elem, layout)
            case ElementKind::List:
                self.render_list(elem, layout)
            case ElementKind::Table:
                self.render_table(elem, layout)
            case _:
                # Default: render as container
                self.render_container(elem, layout)

    # Render text element
    fn render_text(self, elem: &Element, layout: Layout):
        if let Some(text) = &elem.text:
            let fg = self.get_fg_color(elem)
            let bg = self.get_bg_color(elem)
            let style = self.get_text_style(elem)

            let mut x = layout.content_x
            for ch in text.chars():
                if x >= layout.content_x + layout.content_width:
                    break
                self.screen.set(x, layout.content_y, Cell {
                    ch: ch,
                    fg: fg,
                    bg: bg,
                    style: style
                })
                x = x + 1

    # Render box with border
    fn render_box(self, elem: &Element, layout: Layout):
        let fg = self.get_fg_color(elem)
        let bg = self.get_bg_color(elem)

        # Draw border
        let box_chars = &self.box_style

        # Top border
        self.set_cell(layout.x, layout.y, box_chars.top_left, fg, bg)
        for x in (layout.x + 1)..(layout.x + layout.width - 1):
            self.set_cell(x, layout.y, box_chars.horizontal, fg, bg)
        self.set_cell(layout.x + layout.width - 1, layout.y, box_chars.top_right, fg, bg)

        # Side borders
        for y in (layout.y + 1)..(layout.y + layout.height - 1):
            self.set_cell(layout.x, y, box_chars.vertical, fg, bg)
            self.set_cell(layout.x + layout.width - 1, y, box_chars.vertical, fg, bg)

        # Bottom border
        self.set_cell(layout.x, layout.y + layout.height - 1, box_chars.bottom_left, fg, bg)
        for x in (layout.x + 1)..(layout.x + layout.width - 1):
            self.set_cell(x, layout.y + layout.height - 1, box_chars.horizontal, fg, bg)
        self.set_cell(layout.x + layout.width - 1, layout.y + layout.height - 1, box_chars.bottom_right, fg, bg)

        # Render content area
        let content_layout = Layout::new(
            layout.x + 1,
            layout.y + 1,
            if layout.width > 2 { layout.width - 2 } else { 0 },
            if layout.height > 2 { layout.height - 2 } else { 0 }
        )

        # Render children
        self.render_children(elem, content_layout)

    # Render button
    fn render_button(self, elem: &Element, layout: Layout):
        let fg = if elem.focused {
            Color::Black
        } else {
            self.get_fg_color(elem)
        }
        let bg = if elem.focused {
            Color::Cyan
        } else {
            self.get_bg_color(elem)
        }

        # Draw button brackets
        self.set_cell(layout.x, layout.y, '[', fg, bg)
        self.set_cell(layout.x + layout.width - 1, layout.y, ']', fg, bg)

        # Draw label
        if let Some(text) = &elem.text:
            let mut x = layout.x + 1
            for ch in text.chars():
                if x >= layout.x + layout.width - 1:
                    break
                self.set_cell(x, layout.y, ch, fg, bg)
                x = x + 1

            # Fill remaining space
            while x < layout.x + layout.width - 1:
                self.set_cell(x, layout.y, ' ', fg, bg)
                x = x + 1

    # Render input field
    fn render_input(self, elem: &Element, layout: Layout):
        let fg = self.get_fg_color(elem)
        let bg = if elem.focused {
            Color::BrightBlack
        } else {
            self.get_bg_color(elem)
        }

        # Draw input field
        self.set_cell(layout.x, layout.y, '[', fg, bg)
        self.set_cell(layout.x + layout.width - 1, layout.y, ']', fg, bg)

        # Draw current value or placeholder
        let value = elem.attrs.get("value").unwrap_or(&"")
        let mut x = layout.x + 1
        for ch in value.chars():
            if x >= layout.x + layout.width - 1:
                break
            self.set_cell(x, layout.y, ch, fg, bg)
            x = x + 1

        # Fill with underscores
        while x < layout.x + layout.width - 1:
            self.set_cell(x, layout.y, '_', fg, bg)
            x = x + 1

    # Render container (div, row, column)
    fn render_container(self, elem: &Element, layout: Layout):
        self.render_children(elem, layout)

    # Render list
    fn render_list(self, elem: &Element, layout: Layout):
        let mut y = layout.y
        for child in &elem.children:
            if y >= layout.y + layout.height:
                break

            # Add bullet
            self.set_cell(layout.x, y, '*', Color::Default, Color::Default)

            # Render list item
            let item_layout = Layout::new(
                layout.x + 2,
                y,
                if layout.width > 2 { layout.width - 2 } else { 0 },
                1
            )
            self.render_element(child, item_layout)

            y = y + 1

    # Render table
    fn render_table(self, elem: &Element, layout: Layout):
        # Simple table rendering - one row per child
        let mut y = layout.y
        let box_chars = &self.box_style

        for (row_idx, row) in elem.children.iter().enumerate():
            if y >= layout.y + layout.height:
                break

            # Render row cells
            let cell_width = layout.width / (row.children.len() as u16).max(1)
            let mut x = layout.x

            for (col_idx, cell) in row.children.iter().enumerate():
                let cell_layout = Layout::new(x, y, cell_width, 1)
                self.render_element(cell, cell_layout)

                # Draw vertical separator
                if col_idx < row.children.len() - 1:
                    self.set_cell(x + cell_width, y, box_chars.vertical, Color::Default, Color::Default)

                x = x + cell_width + 1

            y = y + 1

            # Draw horizontal separator
            if row_idx < elem.children.len() - 1 and y < layout.y + layout.height:
                for x in layout.x..(layout.x + layout.width):
                    self.set_cell(x, y, box_chars.horizontal, Color::Default, Color::Default)
                y = y + 1

    # Render children with layout
    fn render_children(self, elem: &Element, layout: Layout):
        if elem.children.is_empty():
            return

        # Simple vertical stacking for now
        let child_height = layout.height / (elem.children.len() as u16).max(1)
        let mut y = layout.y

        for child in &elem.children:
            if y >= layout.y + layout.height:
                break

            let child_layout = Layout::new(layout.x, y, layout.width, child_height)
            self.render_element(child, child_layout)

            y = y + child_height

    # Helper: set a cell
    fn set_cell(self, x: u16, y: u16, ch: char, fg: Color, bg: Color):
        if x < self.width and y < self.height:
            self.screen.set(x, y, Cell {
                ch: ch,
                fg: fg,
                bg: bg,
                style: TextStyle::new()
            })

    # Helper: mark rectangle as dirty
    fn mark_dirty_rect(self, x: u16, y: u16, width: u16, height: u16):
        for dy in 0..height:
            for dx in 0..width:
                let px = x + dx
                let py = y + dy
                if px < self.width and py < self.height:
                    let idx = (py as u64) * (self.width as u64) + (px as u64)
                    self.screen.dirty[idx] = true

    # Helper: get foreground color from element
    fn get_fg_color(self, elem: &Element) -> Color:
        # Check for style attribute
        if let Some(color) = elem.styles.get("color"):
            return parse_color(color)
        return Color::Default

    # Helper: get background color from element
    fn get_bg_color(self, elem: &Element) -> Color:
        if let Some(color) = elem.styles.get("background-color"):
            return parse_color(color)
        return Color::Default

    # Helper: get text style from element
    fn get_text_style(self, elem: &Element) -> TextStyle:
        let mut style = TextStyle::new()
        if elem.classes.contains(&"bold".to_string()):
            style = style.bold()
        if elem.classes.contains(&"italic".to_string()):
            style = style.italic()
        if elem.classes.contains(&"underline".to_string()):
            style = style.underline()
        return style

# Convert terminal KeyCode to UI KeyCode
fn convert_key_code(code: term.KeyCode) -> KeyCode:
    match code:
        case term.KeyCode::Char(c): return KeyCode::Char(c)
        case term.KeyCode::Enter: return KeyCode::Enter
        case term.KeyCode::Escape: return KeyCode::Escape
        case term.KeyCode::Backspace: return KeyCode::Backspace
        case term.KeyCode::Tab: return KeyCode::Tab
        case term.KeyCode::Delete: return KeyCode::Delete
        case term.KeyCode::Insert: return KeyCode::Insert
        case term.KeyCode::Home: return KeyCode::Home
        case term.KeyCode::End: return KeyCode::End
        case term.KeyCode::PageUp: return KeyCode::PageUp
        case term.KeyCode::PageDown: return KeyCode::PageDown
        case term.KeyCode::Up: return KeyCode::Up
        case term.KeyCode::Down: return KeyCode::Down
        case term.KeyCode::Left: return KeyCode::Left
        case term.KeyCode::Right: return KeyCode::Right
        case term.KeyCode::F(n): return KeyCode::F(n)
        case _: return KeyCode::Null
