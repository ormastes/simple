# Sample Simple Code for LSP Testing
# Contains various language constructs for semantic token validation

import std.io
import std.collections as coll
from std.math import sqrt, pow

# Global constants
let PI: f64 = 3.14159
let MAX_SIZE: i32 = 1000

# Simple function
fn add(x: i32, y: i32): i32 = x + y

# Function with control flow
fn fibonacci(n: i32): i32 =
    if n <= 1:
        n
    else:
        fibonacci(n - 1) + fibonacci(n - 2)

# Function with pattern matching
fn classify(value: i32): String =
    match value:
        case 0:
            "zero"
        case n if n > 0:
            "positive"
        case _:
            "negative"

# Class definition
class Point:
    x: i32
    y: i32

    fn new(x: i32, y: i32): Point =
        Point(x: x, y: y)

    fn distance(self): f64 =
        sqrt(pow(self.x, 2) + pow(self.y, 2))

    fn add(self, other: Point): Point =
        Point.new(self.x + other.x, self.y + other.y)

# Enum definition
enum Color:
    Red
    Green
    Blue
    RGB(r: i32, g: i32, b: i32)

# Trait definition
trait Drawable:
    fn draw(self): void

# Implementation
impl Drawable for Point:
    fn draw(self):
        print("Point({self.x}, {self.y})")

# Generic function
fn identity<T>(value: T): T = value

# Async function
async fn fetch_data(url: String): Result<String, String> =
    # Simulated async operation
    await io.read_file(url)

# Function with error handling
fn safe_divide(a: f64, b: f64): Result<f64, String> =
    if b == 0.0:
        Err("Division by zero")
    else:
        Ok(a / b)

# Function with loops
fn sum_range(start: i32, end: i32): i32 =
    let mut total = 0
    for i in range(start, end):
        total += i
    total

# Function with while loop
fn countdown(n: i32): void =
    let mut count = n
    while count > 0:
        print("{count}...")
        count -= 1
    print("Done!")

# Function with string interpolation
fn greet(name: String): String =
    "Hello, {name}! Welcome to Simple."

# Function with collections
fn process_list(items: List[i32]): List[i32] =
    let mut result: List[i32] = []
    for item in items:
        if item % 2 == 0:
            result.append(item * 2)
    result

# Main entry point
fn main():
    # Variable declarations
    let x: i32 = 10
    let y = 20  # Type inferred
    let name = "Alice"

    # Function calls
    let sum = add(x, y)
    let fib10 = fibonacci(10)

    # Object creation
    let p1 = Point.new(3, 4)
    let p2 = Point.new(5, 12)
    let p3 = p1.add(p2)

    # Pattern matching
    let category = classify(-5)

    # Error handling
    match safe_divide(10.0, 2.0):
        case Ok(result):
            print("Result: {result}")
        case Err(error):
            print("Error: {error}")

    # Collections
    let numbers = [1, 2, 3, 4, 5]
    let doubled = process_list(numbers)

    # String operations
    let greeting = greet(name)
    print(greeting)

    # Async call (in async context)
    # let data = await fetch_data("data.txt")

    # Comments work
    countdown(3)  # This is an inline comment

    """
    This is a doc comment
    It can span multiple lines
    """
