# HIR Feature Specification
# Feature #4: High-level Intermediate Representation
# Category: Infrastructure | Difficulty: 3 | Status: Complete

# =====================================================
# Feature Metadata
# =====================================================

class FeatureMetadata:
    id: Int
    name: String
    category: String
    difficulty: Int
    status: String
    impl_type: String
    spec_ref: String
    files: List<String>
    tests: List<String>
    description: String
    code_examples: List<String>
    dependencies: List<Int>
    required_by: List<Int>
    notes: String

# Feature Definition
let FEATURE = FeatureMetadata {
    id: 4,
    name: 'HIR',
    category: 'Infrastructure',
    difficulty: 3,
    status: 'Complete',
    impl_type: 'Rust',
    spec_ref: 'doc/architecture/README.md',
    files: [
        'src/compiler/src/hir/mod.rs',
        'src/compiler/src/hir/types.rs',
        'src/compiler/src/hir/lower.rs'
    ],
    tests: [
        'src/driver/tests/runner_tests.rs'
    ],
    description: 'High-level IR for type checking and semantic analysis. Performs type inference, mutability checking, and capability verification after AST parsing.',
    code_examples: [],
    dependencies: [3],
    required_by: [5],
    notes: 'HIR preserves source structure while adding type information. Validates semantic correctness before MIR lowering.'
}

# =====================================================
# BDD Specification Tests
# =====================================================

print('============================================================')
print('  HIR FEATURE SPECIFICATION (#4)')
print('  Category: Infrastructure | Difficulty: 3 | Status: Complete')
print('============================================================')
print('')

let mut passed = 0
let mut failed = 0

# -----------------------------------------------------
# Type Inference
# -----------------------------------------------------

print('describe Type inference:')
print('  context integer inference:')
print('    it infers integer type:')

let inferred_int = 42
if inferred_int + 1 == 43:
    print('      [PASS] infers integer')
    passed = passed + 1
else:
    print('      [FAIL] infers integer')
    failed = failed + 1

print('')
print('  context string inference:')
print('    it infers string type:')

let inferred_str = "hello"
if inferred_str.len() == 5:
    print('      [PASS] infers string')
    passed = passed + 1
else:
    print('      [FAIL] infers string')
    failed = failed + 1

print('')
print('  context collection inference:')
print('    it infers array element type:')

let nums = [1, 2, 3]
if nums[0] + nums[1] == 3:
    print('      [PASS] infers array type')
    passed = passed + 1
else:
    print('      [FAIL] infers array type')
    failed = failed + 1

print('')
print('  context function return inference:')
print('    it infers return type:')

fn get_value():
    return 42

let val = get_value()
if val == 42:
    print('      [PASS] infers function return')
    passed = passed + 1
else:
    print('      [FAIL] infers function return')
    failed = failed + 1

# -----------------------------------------------------
# Mutability Checking
# -----------------------------------------------------

print('')
print('describe Mutability checking:')
print('  context mutable bindings:')
print('    it allows mutation with mut:')

let mut counter = 0
counter = counter + 1
counter = counter + 1
if counter == 2:
    print('      [PASS] mutable binding')
    passed = passed + 1
else:
    print('      [FAIL] mutable binding')
    failed = failed + 1

print('    it allows reassignment:')

let mut x = 10
x = 20
x = 30
if x == 30:
    print('      [PASS] reassignment')
    passed = passed + 1
else:
    print('      [FAIL] reassignment')
    failed = failed + 1

print('')
print('  context immutable bindings:')
print('    it preserves immutable values:')

let immut = 100
if immut == 100:
    print('      [PASS] immutable preserved')
    passed = passed + 1
else:
    print('      [FAIL] immutable preserved')
    failed = failed + 1

# -----------------------------------------------------
# Type Annotations
# -----------------------------------------------------

print('')
print('describe Type annotations:')
print('  context explicit types:')
print('    it respects type annotations:')

let typed: i64 = 42
if typed == 42:
    print('      [PASS] explicit type')
    passed = passed + 1
else:
    print('      [FAIL] explicit type')
    failed = failed + 1

print('    it works with function params:')

fn typed_add(a: i64, b: i64) -> i64:
    return a + b

if typed_add(20, 22) == 42:
    print('      [PASS] typed function params')
    passed = passed + 1
else:
    print('      [FAIL] typed function params')
    failed = failed + 1

print('')
print('  context generic type annotations:')
print('    it handles generic types:')

let list: List<i64> = [10, 20, 30]
if list.len() == 3:
    print('      [PASS] generic type annotation')
    passed = passed + 1
else:
    print('      [FAIL] generic type annotation')
    failed = failed + 1

# -----------------------------------------------------
# Type Narrowing
# -----------------------------------------------------

print('')
print('describe Type narrowing:')
print('  context pattern matching:')
print('    it narrows Option type:')

let opt = Some(42)
let mut result = 0
match opt:
    Some(v) =>
        result = v
    None =>
        result = -1

if result == 42:
    print('      [PASS] Option type narrowing')
    passed = passed + 1
else:
    print('      [FAIL] Option type narrowing')
    failed = failed + 1

print('    it narrows Result type:')

let res = Ok(100)
let mut value = 0
match res:
    Ok(v) =>
        value = v
    Err(e) =>
        value = -1

if value == 100:
    print('      [PASS] Result type narrowing')
    passed = passed + 1
else:
    print('      [FAIL] Result type narrowing')
    failed = failed + 1

# -----------------------------------------------------
# Struct Type Checking
# -----------------------------------------------------

print('')
print('describe Struct type checking:')
print('  context struct fields:')
print('    it verifies field types:')

struct Point:
    x: i64
    y: i64

let p = Point { x: 10, y: 20 }
if p.x + p.y == 30:
    print('      [PASS] struct field types')
    passed = passed + 1
else:
    print('      [FAIL] struct field types')
    failed = failed + 1

print('    it allows nested structs:')

struct Rect:
    width: i64
    height: i64

let r = Rect { width: 5, height: 10 }
if r.width * r.height == 50:
    print('      [PASS] nested struct access')
    passed = passed + 1
else:
    print('      [FAIL] nested struct access')
    failed = failed + 1

# -----------------------------------------------------
# Method Resolution
# -----------------------------------------------------

print('')
print('describe Method resolution:')
print('  context impl methods:')
print('    it resolves struct methods:')

struct Counter:
    value: i64

impl Counter:
    fn get() -> i64:
        return self.value

let c = Counter { value: 42 }
if c.get() == 42:
    print('      [PASS] method resolution')
    passed = passed + 1
else:
    print('      [FAIL] method resolution')
    failed = failed + 1

# =====================================================
# Documentation Output
# =====================================================

print('')
print('============================================================')
print('  GENERATED DOCUMENTATION')
print('============================================================')
print('')
print('# HIR')
print('')
print('**Feature ID:** #4')
print('**Category:** Infrastructure')
print('**Difficulty:** Level 3/5')
print('**Status:** Complete')
print('**Implementation:** Rust')
print('')
print('## Description')
print('')
print(FEATURE.description)
print('')
print('## HIR Phases')
print('')
print('| Phase | Purpose |')
print('|-------|---------|')
print('| Type Inference | Determine types from usage |')
print('| Mutability Check | Verify mut/immut semantics |')
print('| Type Narrowing | Refine types in branches |')
print('| Method Resolution | Find impl methods |')
print('')
print('## Notes')
print('')
print(FEATURE.notes)

# Summary
print('')
print('============================================================')
print('  TEST SUMMARY')
print('============================================================')
let total = passed + failed
print("Passed: {passed}")
print("Failed: {failed}")
print("Total:  {total}")
if failed == 0:
    print('All tests PASSED!')
print('============================================================')
