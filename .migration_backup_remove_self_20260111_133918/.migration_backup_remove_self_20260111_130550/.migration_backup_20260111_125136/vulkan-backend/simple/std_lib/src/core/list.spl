# List[T] - Dynamic growable sequence
# Syntax: [] creates a List
# Implements all collection traits including Growable

use core.traits.*
use core.collections.*

# ============================================
# List Type Definition
# ============================================

struct List[T]:
    data: *T
    len: usize
    cap: usize

# ============================================
# Constructors
# ============================================

impl List[T]:
    # Create empty list
    fn new() -> List[T]:
        List { data: nil, len: 0, cap: 0 }

    # Create with pre-allocated capacity
    fn with_capacity(cap: usize) -> List[T]:
        if cap == 0:
            return List::new()
        let data = alloc[T](cap)
        List { data: data, len: 0, cap: cap }

    # Create from variadic arguments
    fn of(items: T...) -> List[T]:
        var list = List::with_capacity(items.len())
        for item in items:
            list.push(item)
        list

    # Create filled with value
    fn filled(value: T, count: usize) -> List[T] where T: Clone:
        var list = List::with_capacity(count)
        for _ in 0..count:
            list.push(value.clone())
        list

    # Create filled with function
    fn filled_with(f: fn(usize) -> T, count: usize) -> List[T]:
        var list = List::with_capacity(count)
        for i in 0..count:
            list.push(f(i))
        list

    # Create from iterator
    fn from_iter[I: Iterator[Item=T]](iter: I) -> List[T]:
        var list = List::new()
        for item in iter:
            list.push(item)
        list

    # Create from slice
    fn from_slice(slice: Slice[T]) -> List[T] where T: Clone:
        var list = List::with_capacity(slice.len())
        for item in slice:
            list.push(item.clone())
        list

# ============================================
# Internal helpers
# ============================================

impl List[T]:
    # Ensure capacity for at least `additional` more elements
    fn reserve(self, additional: usize):
        let required = self.len + additional
        if required <= self.cap:
            return

        # Grow by doubling or to required, whichever is larger
        var new_cap = if self.cap == 0: 4 else: self.cap * 2
        while new_cap < required:
            new_cap = new_cap * 2

        let new_data = alloc[T](new_cap)
        if self.data != nil:
            danger:
                copy_mem(new_data, self.data, self.len)
                dealloc(self.data)
        self.data = new_data
        self.cap = new_cap

    fn shrink_to_fit(self):
        if self.len == self.cap:
            return
        if self.len == 0:
            if self.data != nil:
                danger:
                    dealloc(self.data)
            self.data = nil
            self.cap = 0
            return

        let new_data = alloc[T](self.len)
        danger:
            copy_mem(new_data, self.data, self.len)
            dealloc(self.data)
        self.data = new_data
        self.cap = self.len

# ============================================
# Capacity trait
# ============================================

impl Capacity for List[T]:
    fn capacity(self) -> usize:
        self.cap

    fn is_full(self) -> bool:
        false  # List can always grow

# ============================================
# Len trait
# ============================================

impl Len for List[T]:
    fn len(self) -> usize:
        self.len

# ============================================
# Iterable trait
# ============================================

impl Iterable[T] for List[T]:
    type Iter = ListIter[T]

    fn iter(self) -> Self::Iter:
        ListIter { list: self, index: 0 }

    fn into_iter(self) -> Self::Iter:
        self.iter()

# ============================================
# Collection trait
# ============================================

impl Collection[T] for List[T]

# ============================================
# Sequence trait
# ============================================

impl Sequence[T] for List[T]:
    fn get(self, idx: usize) -> Option[T]:
        if idx < self.len:
            danger:
                Some(self.data.offset(idx as isize).read())
        else:
            None

    fn slice(self, start: usize, end: usize) -> Slice[T]:
        if start > end or end > self.len:
            Slice::empty()
        else:
            danger:
                Slice::new(self.data.offset(start as isize), end - start)

# ============================================
# MutSequence trait
# ============================================

impl MutSequence[T] for List[T]:
    fn get_mut(self, idx: usize) -> Option[&mut T]:
        if idx < self.len:
            danger:
                Some(&mut *self.data.offset(idx as isize))
        else:
            None

    fn set(self, idx: usize, value: T) -> Result[(), IndexError]:
        if idx >= self.len:
            return Err(IndexError::OutOfBounds(idx, self.len))
        danger:
            self.data.offset(idx as isize).write(value)
        Ok(())

    fn sort(self) where T: Ord:
        # Insertion sort for small lists, could use quicksort for larger
        for i in 1..self.len:
            var j = i
            while j > 0:
                let curr = self.get(j).expect("valid")
                let prev = self.get(j - 1).expect("valid")
                if curr.lt(&prev):
                    self.swap(j, j - 1).expect("valid")
                    j = j - 1
                else:
                    break

    fn retain(self, predicate: fn(&T) -> bool):
        var write: usize = 0
        for read in 0..self.len:
            let item = self.get(read).expect("valid")
            if predicate(&item):
                if write != read:
                    self.set(write, item).expect("valid")
                write = write + 1
        self.len = write

    fn as_mut_slice(self) -> MutSlice[T]:
        MutSlice::new(self.data, self.len)

# ============================================
# ImmutSequence trait
# ============================================

impl ImmutSequence[T] for List[T] where T: Clone:
    type Output = List[T]

    fn with_index(self, idx: usize, value: T) -> Option[Self::Output]:
        if idx >= self.len:
            return None
        var new_list = self.clone()
        new_list.set(idx, value).expect("valid")
        Some(new_list)

    fn sorted(self) -> Self::Output where T: Ord:
        var new_list = self.clone()
        new_list.sort()
        new_list

    fn reversed(self) -> Self::Output:
        var new_list = self.clone()
        new_list.reverse()
        new_list

    fn filtered(self, predicate: fn(&T) -> bool) -> Self::Output:
        var new_list = List::new()
        for item in self.iter():
            if predicate(&item):
                new_list.push(item.clone())
        new_list

    fn mapped[U](self, f: fn(T) -> U) -> List[U]:
        var new_list = List::with_capacity(self.len)
        for item in self.iter():
            new_list.push(f(item.clone()))
        new_list

    fn appended(self, item: T) -> Self::Output:
        var new_list = self.clone()
        new_list.push(item)
        new_list

    fn prepended(self, item: T) -> Self::Output:
        var new_list = self.clone()
        new_list.push_front(item)
        new_list

    fn taken(self, n: usize) -> Self::Output:
        var new_list = List::new()
        for (i, item) in self.enumerate():
            if i >= n:
                break
            new_list.push(item.clone())
        new_list

    fn dropped(self, n: usize) -> Self::Output:
        var new_list = List::new()
        for (i, item) in self.enumerate():
            if i >= n:
                new_list.push(item.clone())
        new_list

    fn taken_while(self, predicate: fn(&T) -> bool) -> Self::Output:
        var new_list = List::new()
        for item in self.iter():
            if not predicate(&item):
                break
            new_list.push(item.clone())
        new_list

    fn dropped_while(self, predicate: fn(&T) -> bool) -> Self::Output:
        var new_list = List::new()
        var dropping = true
        for item in self.iter():
            if dropping and predicate(&item):
                continue
            dropping = false
            new_list.push(item.clone())
        new_list

# ============================================
# Growable trait
# ============================================

impl Growable[T] for List[T]:
    fn push(self, item: T):
        self.reserve(1)
        danger:
            self.data.offset(self.len as isize).write(item)
        self.len = self.len + 1

    fn pop(self) -> Option[T]:
        if self.len == 0:
            return None
        self.len = self.len - 1
        danger:
            Some(self.data.offset(self.len as isize).read())

    fn push_front(self, item: T):
        self.reserve(1)
        # Shift all elements right
        if self.len > 0:
            danger:
                var i = self.len
                while i > 0:
                    let src = self.data.offset((i - 1) as isize)
                    let dst = self.data.offset(i as isize)
                    dst.write(src.read())
                    i = i - 1
        danger:
            self.data.write(item)
        self.len = self.len + 1

    fn pop_front(self) -> Option[T]:
        if self.len == 0:
            return None
        danger:
            let item = self.data.read()
            # Shift all elements left
            for i in 0..(self.len - 1):
                let src = self.data.offset((i + 1) as isize)
                let dst = self.data.offset(i as isize)
                dst.write(src.read())
            self.len = self.len - 1
            Some(item)

    fn insert(self, idx: usize, item: T) -> Result[(), IndexError]:
        if idx > self.len:
            return Err(IndexError::OutOfBounds(idx, self.len))
        self.reserve(1)
        # Shift elements right from idx
        danger:
            var i = self.len
            while i > idx:
                let src = self.data.offset((i - 1) as isize)
                let dst = self.data.offset(i as isize)
                dst.write(src.read())
                i = i - 1
            self.data.offset(idx as isize).write(item)
        self.len = self.len + 1
        Ok(())

    fn remove(self, idx: usize) -> Option[T]:
        if idx >= self.len:
            return None
        danger:
            let item = self.data.offset(idx as isize).read()
            # Shift elements left
            for i in idx..(self.len - 1):
                let src = self.data.offset((i + 1) as isize)
                let dst = self.data.offset(i as isize)
                dst.write(src.read())
            self.len = self.len - 1
            Some(item)

    fn clear(self):
        # Drop all elements if T has Drop
        self.len = 0

# ============================================
# Sliceable trait
# ============================================

impl Sliceable[T] for List[T]:
    fn as_slice(self) -> Slice[T]:
        Slice::new(self.data, self.len)

impl MutSliceable[T] for List[T]:
    fn as_mut_slice(self) -> MutSlice[T]:
        MutSlice::new(self.data, self.len)

# ============================================
# Standard trait implementations
# ============================================

impl Clone for List[T] where T: Clone:
    fn clone(self) -> Self:
        var new_list = List::with_capacity(self.len)
        for item in self.iter():
            new_list.push(item.clone())
        new_list

impl Default for List[T]:
    fn default() -> Self:
        List::new()

impl Eq for List[T] where T: Eq:
    fn eq(self, other: &Self) -> bool:
        if self.len != other.len:
            return false
        for i in 0..self.len:
            let a = self.get(i).expect("valid")
            let b = other.get(i).expect("valid")
            if not a.eq(&b):
                return false
        true

impl Hash for List[T] where T: Hash:
    fn hash(self) -> u64:
        var h: u64 = 0
        for item in self.iter():
            h = h * 31 + item.hash()
        h

impl Display for List[T] where T: Display:
    fn fmt(self) -> str:
        var s = "["
        for (i, item) in self.enumerate():
            if i > 0:
                s = s + ", "
            s = s + item.fmt()
        s + "]"

impl Index[usize] for List[T]:
    type Output = T

    fn index(self, idx: usize) -> &Self::Output:
        if idx >= self.len:
            panic(f"index {idx} out of bounds (len={self.len})")
        danger:
            &*self.data.offset(idx as isize)

impl IndexMut[usize] for List[T]:
    fn index_mut(self, idx: usize) -> &mut Self::Output:
        if idx >= self.len:
            panic(f"index {idx} out of bounds (len={self.len})")
        danger:
            &mut *self.data.offset(idx as isize)

impl FromIterator[T] for List[T]:
    fn from_iter[I: Iterator[Item=T]](iter: I) -> Self:
        List::from_iter(iter)

impl IntoIterator for List[T]:
    type Item = T
    type IntoIter = ListIter[T]
    fn into_iter(self) -> Self::IntoIter:
        self.iter()

impl Drop for List[T]:
    fn drop(self):
        if self.data != nil:
            danger:
                dealloc(self.data)

# ============================================
# List Iterator
# ============================================

struct ListIter[T]:
    list: List[T]
    index: usize

impl Iterator for ListIter[T]:
    type Item = T

    fn next(self) -> Option[Self::Item]:
        if self.index < self.list.len:
            let item = self.list.get(self.index).expect("valid")
            self.index = self.index + 1
            Some(item)
        else:
            None

impl ExactSizeIterator for ListIter[T]:
    fn len(self) -> usize:
        self.list.len - self.index

impl DoubleEndedIterator for ListIter[T]:
    fn next_back(self) -> Option[Self::Item]:
        if self.index < self.list.len:
            let idx = self.list.len - 1
            let item = self.list.get(idx).expect("valid")
            # Shrink effective length (can't modify list, but we track via index math)
            Some(item)
        else:
            None

# ============================================
# Convenience methods (Ruby/Python inspired)
# ============================================

impl List[T]:
    # Ruby-style select (alias for filtered)
    fn select(self, predicate: fn(&T) -> bool) -> List[T] where T: Clone:
        self.filtered(predicate)

    # Ruby-style reject (opposite of filter)
    fn reject(self, predicate: fn(&T) -> bool) -> List[T] where T: Clone:
        self.filtered(|x| not predicate(x))

    # Ruby-style partition
    fn partition(self, predicate: fn(&T) -> bool) -> (List[T], List[T]) where T: Clone:
        var yes = List::new()
        var no = List::new()
        for item in self.iter():
            if predicate(&item):
                yes.push(item.clone())
            else:
                no.push(item.clone())
        (yes, no)

    # Ruby-style compact (remove None from Option list)
    fn compact[U](self) -> List[U] where T = Option[U]:
        var result = List::new()
        for item in self.iter():
            match item:
                case Some(v): result.push(v)
                case None: pass
        result

    # Ruby-style flatten (one level)
    fn flatten[U](self) -> List[U] where T: Iterable[U], U: Clone:
        var result = List::new()
        for inner in self.iter():
            for item in inner.iter():
                result.push(item.clone())
        result

    # Python-style chunks
    fn chunks(self, size: usize) -> List[List[T]] where T: Clone:
        var result = List::new()
        var chunk = List::new()
        for item in self.iter():
            chunk.push(item.clone())
            if chunk.len() == size:
                result.push(chunk)
                chunk = List::new()
        if not chunk.is_empty():
            result.push(chunk)
        result

    # Sliding windows
    fn windows(self, size: usize) -> List[List[T]] where T: Clone:
        if size == 0 or size > self.len:
            return List::new()
        var result = List::new()
        for i in 0..(self.len - size + 1):
            var window = List::new()
            for j in 0..size:
                window.push(self.get(i + j).expect("valid").clone())
            result.push(window)
        result

    # Dedup consecutive duplicates
    fn dedup(self) where T: Eq:
        if self.len < 2:
            return
        var write: usize = 1
        for read in 1..self.len:
            let curr = self.get(read).expect("valid")
            let prev = self.get(write - 1).expect("valid")
            if not curr.eq(&prev):
                if write != read:
                    self.set(write, curr).expect("valid")
                write = write + 1
        self.len = write

    # Join elements into string
    fn join(self, sep: str) -> String where T: Display:
        var s = String::new()
        for (i, item) in self.enumerate():
            if i > 0:
                s.push_str(sep)
            s.push_str(item.fmt())
        s

    # Map with index
    fn map_with_index[U](self, f: fn(usize, T) -> U) -> List[U] where T: Clone:
        var result = List::with_capacity(self.len)
        for (i, item) in self.enumerate():
            result.push(f(i, item.clone()))
        result

    # Ruby-style tap (execute function, return self)
    fn tap(self, f: fn(&List[T])) -> List[T]:
        f(&self)
        self

    # Ruby-style then (transform self)
    fn then[U](self, f: fn(List[T]) -> U) -> U:
        f(self)

# ============================================
# Type aliases
# ============================================

# Common list sizes (for documentation, lists are always dynamic)
type IntList = List[i64]
type FloatList = List[f64]
type StringList = List[String]
