# Persistent List - Simple Implementation
# Feature #1385: Immutable List<T> with structural sharing

use core.traits.*
use core.list.*

# ============================================
# Persistent List (Immutable)
# ============================================

"""
Immutable persistent list using structural sharing.

This is a functional linked list where operations return new lists
that share structure with the original. Modifications are O(1) for
prepend and O(n) for append/access.

Example:
    let list1 = PList.of([1, 2, 3])
    let list2 = list1.prepend(0)  # [0, 1, 2, 3]
    # list1 still [1, 2, 3], shares nodes with list2
"""

enum PList<T>:
    Empty
    Cons(head: T, tail: PList<T>)

impl PList<T>:
    # Create empty persistent list
    fn empty() -> PList<T>:
        PList::Empty

    # Create from array/list
    fn of(items: [T]) -> PList<T>:
        var result = PList::Empty
        for i in items.len() - 1 .. 0 by -1:
            result = PList::Cons(items[i], result)
        result

    # Prepend element (O(1), structural sharing)
    fn prepend(item: T) -> PList<T>:
        PList::Cons(item, self)

    # Get head element
    fn head() -> Option<T>:
        match self:
            case Cons(h, _): Some(h)
            case Empty: None

    # Get tail (all but first)
    fn tail() -> Option<PList<T>>:
        match self:
            case Cons(_, t): Some(t)
            case Empty: None

    # Get length (O(n))
    fn len() -> usize:
        match self:
            case Empty: 0
            case Cons(_, t): 1 + t.len()

    # Check if empty
    fn is_empty() -> bool:
        match self:
            case Empty: true
            case _: false

    # Get nth element (O(n))
    fn get(index: usize) -> Option<T>:
        if index == 0:
            return self.head()
        match self.tail():
            case Some(t): t.get(index - 1)
            case None: None

    # Append element (O(n), creates new list)
    fn append(item: T) -> PList<T>:
        match self:
            case Empty: PList::Cons(item, PList::Empty)
            case Cons(h, t): PList::Cons(h, t.append(item))

    # Map function over list (O(n))
    fn map<U>(self, f: fn(T) -> U) -> PList<U>:
        match self:
            case Empty: PList::Empty
            case Cons(h, t): PList::Cons(f(h), t.map(f))

    # Filter elements (O(n))
    fn filter(pred: fn(T) -> bool) -> PList<T>:
        match self:
            case Empty: PList::Empty
            case Cons(h, t):
                let rest = t.filter(pred)
                if pred(h):
                    PList::Cons(h, rest)
                else:
                    rest

    # Fold/reduce (O(n))
    fn fold<U>(self, init: U, f: fn(U, T) -> U) -> U:
        match self:
            case Empty: init
            case Cons(h, t): t.fold(f(init, h), f)

    # Reverse (O(n))
    fn reverse() -> PList<T>:
        self.fold(PList::Empty, \acc, x: acc.prepend(x))

    # Convert to mutable List
    fn to_list() -> List<T>:
        var result = List.new()
        var current = self
        while not current.is_empty():
            match current:
                case Cons(h, t):
                    result.push(h)
                    current = t
                case Empty:
                    break
        result

# ============================================
# Display Implementation
# ============================================

impl Display for PList<T> where T: Display:
    fn fmt() -> str:
        let items = self.to_list().map(\x: x.to_string()).join(", ")
        f"PList<{items}>"

# ============================================
# Iteration Support
# ============================================

impl Iterator<T> for PList<T>:
    type Item = T

    fn next() -> Option<(T, Self)>:
        match self:
            case Cons(h, t): Some((h, t))
            case Empty: None

# ============================================
# Example Usage
# ============================================

"""
Example usage of persistent list:

    # Create from array
    let list1 = PList.of([1, 2, 3])
    
    # Prepend (O(1), shares structure)
    let list2 = list1.prepend(0)
    # list1: [1, 2, 3]
    # list2: [0, 1, 2, 3]
    
    # Map
    let list3 = list1.map(\x: x * 2)  # [2, 4, 6]
    
    # Filter
    let list4 = list1.filter(\x: x > 1)  # [2, 3]
    
    # Fold
    let sum = list1.fold(0, \acc, x: acc + x)  # 6
    
    # All operations preserve immutability
    # Original list1 unchanged throughout
"""
