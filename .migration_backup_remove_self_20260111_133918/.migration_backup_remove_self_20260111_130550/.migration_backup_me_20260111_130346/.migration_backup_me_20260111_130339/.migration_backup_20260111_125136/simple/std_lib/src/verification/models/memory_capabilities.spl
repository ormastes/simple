# Memory Capabilities Model
# Formal model for reference capabilities matching Lean 4 definitions.
#
# This implements the reference capability system for Simple:
# - `mut T` - Mutable, exclusive reference
# - `iso T` - Isolated, transferable ownership  
# - `T` - Immutable, shared reference
#
# ## Capability Rules
#
# | From | To | Allowed |
# |------|-----|---------|
# | mut | iso | Yes (consume) |
# | mut | imm | Yes (freeze) |
# | iso | mut | Yes (recover) |
# | iso | imm | Yes (share) |
# | imm | mut | No |
# | imm | iso | No |

# Reference capability enum
# Matches Lean: inductive RefCapability
enum RefCapability:
    Mut    # Mutable, exclusive access
    Iso    # Isolated, transferable ownership
    Imm    # Immutable, shared read-only

    # Get string representation
    fn to_string() -> String:
        match self:
            case Mut: "mut"
            case Iso: "iso"
            case Imm: "imm"

    # Check if this capability allows mutation
    fn allows_mutation() -> Bool:
        match self:
            case Mut: true
            case Iso: true
            case Imm: false

    # Check if this capability can be aliased
    fn allows_aliasing() -> Bool:
        match self:
            case Mut: false
            case Iso: false
            case Imm: true

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_mut() -> Bool:
        """Check if this is Mut capability.

        Returns:
            true for Mut

        Example:
            RefCapability.Mut.is_mut()  # → true
        """
        match self:
            case Mut: true
            case _: false

    fn is_iso() -> Bool:
        """Check if this is Iso capability.

        Returns:
            true for Iso

        Example:
            RefCapability.Iso.is_iso()  # → true
        """
        match self:
            case Iso: true
            case _: false

    fn is_imm() -> Bool:
        """Check if this is Imm capability.

        Returns:
            true for Imm

        Example:
            RefCapability.Imm.is_imm()  # → true
        """
        match self:
            case Imm: true
            case _: false

    fn is_exclusive() -> Bool:
        """Check if capability is exclusive (no aliasing).

        Returns:
            true for Mut or Iso

        Example:
            RefCapability.Mut.is_exclusive()  # → true
            RefCapability.Imm.is_exclusive()  # → false
        """
        not self.allows_aliasing()

    fn is_transferable() -> Bool:
        """Check if ownership can be transferred.

        Returns:
            true for Iso

        Example:
            RefCapability.Iso.is_transferable()  # → true
        """
        match self:
            case Iso: true
            case _: false

    fn is_shared() -> Bool:
        """Check if capability allows sharing.

        Returns:
            true for Imm

        Example:
            RefCapability.Imm.is_shared()  # → true
        """
        self.allows_aliasing()

    fn description() -> String:
        """Get capability description.

        Returns:
            Human-readable description

        Example:
            RefCapability.Mut.description()
            # → "Mutable, exclusive access"
        """
        match self:
            case Mut: "Mutable, exclusive access"
            case Iso: "Isolated, transferable ownership"
            case Imm: "Immutable, shared read-only"

    fn summary() -> String:
        """Get summary of reference capability.

        Returns:
            Human-readable summary

        Example:
            RefCapability.Mut.summary()
            # → "RefCapability: mut (exclusive, mutable)"
        """
        let name = self.to_string()
        let mut attrs: List<String> = []

        if self.allows_mutation():
            attrs.push("mutable")
        else:
            attrs.push("immutable")

        if self.is_exclusive():
            attrs.push("exclusive")

        if self.is_transferable():
            attrs.push("transferable")

        if self.is_shared():
            attrs.push("shared")

        let attrs_str = attrs.join(", ")
        return "RefCapability: {name} ({attrs_str})"

# Capability type - combines a capability with a type name
# Matches Lean: structure CapType
class CapType:
    cap: RefCapability
    type_name: String

    fn new(cap: RefCapability, type_name: String) -> CapType:
        CapType(cap: cap, type_name: type_name)

    fn mut_type(type_name: String) -> CapType:
        CapType(cap: RefCapability.Mut, type_name: type_name)

    fn iso_type(type_name: String) -> CapType:
        CapType(cap: RefCapability.Iso, type_name: type_name)

    fn imm_type(type_name: String) -> CapType:
        CapType(cap: RefCapability.Imm, type_name: type_name)

    fn to_string() -> String:
        if self.cap == RefCapability.Imm:
            self.type_name
        else:
            "{self.cap.to_string()} {self.type_name}"

# Reference in the environment
# Matches Lean: structure Reference
class Reference:
    name: String
    cap_type: CapType
    is_consumed: Bool

    fn new(name: String, cap_type: CapType) -> Reference:
        Reference(name: name, cap_type: cap_type, is_consumed: false)

    fn consume(mut self):
        self.is_consumed = true

    fn is_available() -> Bool:
        not self.is_consumed

# Reference environment for tracking capabilities
# Matches Lean: structure RefEnv
class RefEnv:
    refs: Dict<String, Reference>

    fn new() -> RefEnv:
        RefEnv(refs: {})

    fn add(mut self, name: String, cap_type: CapType):
        self.refs[name] = Reference.new(name, cap_type)

    fn get(name: String) -> Option<Reference>:
        self.refs.get(name)

    fn consume(mut self, name: String) -> Result<Nil, String>:
        match self.refs.get(name):
            case Some(ref):
                if ref.is_consumed:
                    Err("Reference '{name}' already consumed")
                else:
                    ref.consume()
                    Ok(nil)
            case None:
                Err("Reference '{name}' not found")

    fn is_available(name: String) -> Bool:
        match self.refs.get(name):
            case Some(ref):
                ref.is_available()
            case None:
                false

# Check if a reference can be created from a source capability
# Matches Lean: def canCreateRef
fn can_create_ref(source: RefCapability, target: RefCapability) -> Bool:
    match (source, target):
        # mut can create anything (with restrictions)
        case (RefCapability.Mut, RefCapability.Mut): true
        case (RefCapability.Mut, RefCapability.Iso): true  # consume
        case (RefCapability.Mut, RefCapability.Imm): true  # freeze

        # iso can create mut or imm
        case (RefCapability.Iso, RefCapability.Mut): true  # recover
        case (RefCapability.Iso, RefCapability.Iso): true
        case (RefCapability.Iso, RefCapability.Imm): true  # share

        # imm can only create imm (aliasing)
        case (RefCapability.Imm, RefCapability.Mut): false
        case (RefCapability.Imm, RefCapability.Iso): false
        case (RefCapability.Imm, RefCapability.Imm): true

# Check if capability conversion is allowed
# Matches Lean: def canConvert
fn can_convert(from_cap: RefCapability, to_cap: RefCapability) -> Bool:
    can_create_ref(from_cap, to_cap)

# Conversion kind - how a capability conversion happens
enum ConversionKind:
    Identity   # Same capability
    Consume    # mut -> iso
    Freeze     # mut -> imm
    Recover    # iso -> mut
    Share      # iso -> imm
    Invalid    # Not allowed

    fn to_string() -> String:
        match self:
            case Identity: "identity"
            case Consume: "consume"
            case Freeze: "freeze"
            case Recover: "recover"
            case Share: "share"
            case Invalid: "invalid"

    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_identity() -> Bool:
        """Check if this is Identity conversion.

        Returns:
            true for Identity

        Example:
            ConversionKind.Identity.is_identity()  # → true
        """
        match self:
            case Identity: true
            case _: false

    fn is_consume() -> Bool:
        """Check if this is Consume conversion (mut -> iso).

        Returns:
            true for Consume

        Example:
            ConversionKind.Consume.is_consume()  # → true
        """
        match self:
            case Consume: true
            case _: false

    fn is_freeze() -> Bool:
        """Check if this is Freeze conversion (mut -> imm).

        Returns:
            true for Freeze

        Example:
            ConversionKind.Freeze.is_freeze()  # → true
        """
        match self:
            case Freeze: true
            case _: false

    fn is_recover() -> Bool:
        """Check if this is Recover conversion (iso -> mut).

        Returns:
            true for Recover

        Example:
            ConversionKind.Recover.is_recover()  # → true
        """
        match self:
            case Recover: true
            case _: false

    fn is_share() -> Bool:
        """Check if this is Share conversion (iso -> imm).

        Returns:
            true for Share

        Example:
            ConversionKind.Share.is_share()  # → true
        """
        match self:
            case Share: true
            case _: false

    fn is_invalid() -> Bool:
        """Check if this is Invalid conversion.

        Returns:
            true for Invalid

        Example:
            ConversionKind.Invalid.is_invalid()  # → true
        """
        match self:
            case Invalid: true
            case _: false

    fn is_valid() -> Bool:
        """Check if conversion is valid.

        Returns:
            false for Invalid, true otherwise

        Example:
            ConversionKind.Consume.is_valid()  # → true
            ConversionKind.Invalid.is_valid()  # → false
        """
        not self.is_invalid()

    fn changes_capability() -> Bool:
        """Check if conversion changes capability.

        Returns:
            false for Identity, true for others (except Invalid)

        Example:
            ConversionKind.Identity.changes_capability()  # → false
            ConversionKind.Freeze.changes_capability()  # → true
        """
        match self:
            case Identity: false
            case Invalid: false
            case _: true

    fn from_capability() -> String:
        """Get source capability name.

        Returns:
            Source capability type

        Example:
            ConversionKind.Consume.from_capability()  # → "mut"
        """
        match self:
            case Identity: "any"
            case Consume: "mut"
            case Freeze: "mut"
            case Recover: "iso"
            case Share: "iso"
            case Invalid: "none"

    fn to_capability() -> String:
        """Get target capability name.

        Returns:
            Target capability type

        Example:
            ConversionKind.Consume.to_capability()  # → "iso"
        """
        match self:
            case Identity: "same"
            case Consume: "iso"
            case Freeze: "imm"
            case Recover: "mut"
            case Share: "imm"
            case Invalid: "none"

    fn description() -> String:
        """Get conversion description.

        Returns:
            Human-readable description

        Example:
            ConversionKind.Consume.description()
            # → "Consume mutable reference into isolated"
        """
        match self:
            case Identity: "Keep same capability"
            case Consume: "Consume mutable reference into isolated"
            case Freeze: "Freeze mutable reference into immutable"
            case Recover: "Recover isolated reference into mutable"
            case Share: "Share isolated reference as immutable"
            case Invalid: "Invalid conversion (not allowed)"

    fn summary() -> String:
        """Get summary of conversion kind.

        Returns:
            Human-readable summary

        Example:
            ConversionKind.Consume.summary()
            # → "ConversionKind: consume (mut → iso, valid, changes capability)"
        """
        let name = self.to_string()
        let from = self.from_capability()
        let to = self.to_capability()
        let valid = if self.is_valid(): "valid" else: "invalid"
        let changes = if self.changes_capability(): "changes capability" else: "no change"

        return if self.is_identity():
            "ConversionKind: {name} ({valid}, {changes})"
        else:
            "ConversionKind: {name} ({from} → {to}, {valid}, {changes})"

# Get the kind of conversion between capabilities
fn get_conversion_kind(from_cap: RefCapability, to_cap: RefCapability) -> ConversionKind:
    match (from_cap, to_cap):
        case (RefCapability.Mut, RefCapability.Mut): ConversionKind.Identity
        case (RefCapability.Mut, RefCapability.Iso): ConversionKind.Consume
        case (RefCapability.Mut, RefCapability.Imm): ConversionKind.Freeze

        case (RefCapability.Iso, RefCapability.Mut): ConversionKind.Recover
        case (RefCapability.Iso, RefCapability.Iso): ConversionKind.Identity
        case (RefCapability.Iso, RefCapability.Imm): ConversionKind.Share

        case (RefCapability.Imm, RefCapability.Imm): ConversionKind.Identity
        case _: ConversionKind.Invalid

# Capability checking result
class CapabilityCheckResult:
    is_valid: Bool
    errors: List<String>
    warnings: List<String>

    fn new() -> CapabilityCheckResult:
        CapabilityCheckResult(is_valid: true, errors: [], warnings: [])

    fn add_error(mut self, msg: String):
        self.is_valid = false
        self.errors.push(msg)

    fn add_warning(mut self, msg: String):
        self.warnings.push(msg)

# Check capability usage in an expression
fn check_capability_usage(env: RefEnv, name: String, required: RefCapability) -> CapabilityCheckResult:
    let mut result = CapabilityCheckResult.new()

    match env.get(name):
        case None:
            result.add_error("Reference '{name}' not in scope")
        case Some(ref):
            if not ref.is_available():
                result.add_error("Reference '{name}' has been consumed")
            else if not can_create_ref(ref.cap_type.cap, required):
                result.add_error(
                    "Cannot use '{name}' with capability {ref.cap_type.cap.to_string()} " +
                    "where {required.to_string()} is required"
                )

    result
