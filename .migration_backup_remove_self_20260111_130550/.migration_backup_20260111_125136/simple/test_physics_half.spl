# Physics - GPU-Accelerated Physics Engine
#
# Provides real-time physics simulation with GPU acceleration via PyTorch.
# Supports rigid body dynamics, collision detection, and constraints.
#
# ## Modules
# - `core`: Vector/matrix math (GPU-accelerated)
# - `dynamics`: Rigid body physics and integration
# - `collision`: Collision detection and response
# - `constraints`: Joint constraints and solvers
#
# ## Classes
# - `World`: Physics world/scene manager
# - `RigidBody`: Rigid body with mass, velocity, forces
# - `Vector2`, `Vector3`: 2D/3D vectors
# - `Matrix3`, `Matrix4`: Transformation matrices
#
# ## Example
# ```simple
# import physics
#
# # Create physics world on GPU
# let world = physics.World(gravity=physics.Vector3(0, -9.81, 0), device="cuda")
#
# # Add rigid bodies
# for i in range(1000):
#     let body = physics.RigidBody(
#         mass=1.0,
#         position=physics.Vector3(randn(), randn(), randn())
#     )
#     world.add_body(body)
#
# # Run simulation (60 FPS)
# for step in range(1000):
#     world.step(dt=0.016)
#     # Render or process physics results
# ```

export World
export core, dynamics, collision, constraints, gpu_batch

import core
import dynamics
import collision
import constraints
import gpu_batch

# Re-export commonly used types
export Vector2, Vector3, Matrix3, Matrix4 from core
export RigidBody, Force from dynamics
export AABB, Shape from collision


import ml.torch as torch


# ============================================================================
# Physics World
# ============================================================================

class World:
    """Physics world for managing simulation.

    Manages rigid bodies, collision detection, and physics integration.
    All computations are batched on GPU for performance.

    Attributes:
        gravity: Gravitational acceleration vector
        device: Compute device (CPU or CUDA)
        bodies: List of rigid bodies in the world
        dt: Time step for integration

    Example:
        ```simple
        # Create world on GPU
        let world = physics.World(
            gravity=physics.Vector3(0, -9.81, 0),
            device=torch.Device::CUDA(0)
        )

        # Add bodies
        let body1 = physics.RigidBody(mass=1.0, position=physics.Vector3(0, 10, 0))
        world.add_body(body1)

        # Simulate
        world.step(dt=0.016)  # 60 FPS
        print("Position: {body1.position}")
        ```
    """
    gravity: core.Vector3
    device: torch.Device
    bodies: [dynamics.RigidBody]
    time: f64
    substeps: i32

    fn __init__(gravity: core.Vector3 = core.Vector3(0.0, -9.81, 0.0),
        device: torch.Device = torch.Device::CPU,
        substeps: i32 = 1
    ):
        """Initialize physics world.

        Args:
            gravity: Gravitational acceleration (default: Earth gravity)
            device: Compute device for GPU acceleration (default: CPU)
            substeps: Number of substeps per step for stability (default: 1)
        """
        self.gravity = gravity
        self.device = device
        self.bodies = []
        self.time = 0.0
        self.substeps = substeps

    fn add_body(body: dynamics.RigidBody):
        """Add rigid body to world.

        Args:
            body: Rigid body to add
        """
        # Transfer body tensors to world device
        body.to_device(self.device)
        self.bodies.append(body)

    fn remove_body(body: dynamics.RigidBody):
        """Remove rigid body from world.
