# Completion Handler
# Provides auto-completion suggestions based on context

import lsp.protocol as protocol
import lsp.transport as transport
import parser.treesitter.{Tree, Node, NodeId, Span}

# Completion item kinds (LSP standard)
enum CompletionItemKind:
    Text = 1
    Method = 2
    Function = 3
    Constructor = 4
    Field = 5
    Variable = 6
    Class = 7
    Interface = 8
    Module = 9
    Property = 10
    Unit = 11
    Value = 12
    Enum = 13
    Keyword = 14
    Snippet = 15
    Color = 16
    File = 17
    Reference = 18
    Folder = 19
    EnumMember = 20
    Constant = 21
    Struct = 22
    Event = 23
    Operator = 24
    TypeParameter = 25

# Completion item
class CompletionItem:
    label: String
    kind: Int
    detail: Option<String>
    documentation: Option<String>
    insert_text: Option<String>

    fn new(label: String, kind: Int) -> CompletionItem:
        CompletionItem(
            label: label,
            kind: kind,
            detail: None,
            documentation: None,
            insert_text: None
        )

    fn with_detail(self, detail: String) -> CompletionItem:
        CompletionItem(
            label: self.label,
            kind: self.kind,
            detail: Some(detail),
            documentation: self.documentation,
            insert_text: self.insert_text
        )

    fn with_documentation(self, doc: String) -> CompletionItem:
        CompletionItem(
            label: self.label,
            kind: self.kind,
            detail: self.detail,
            documentation: Some(doc),
            insert_text: self.insert_text
        )

    fn with_insert_text(self, text: String) -> CompletionItem:
        CompletionItem(
            label: self.label,
            kind: self.kind,
            detail: self.detail,
            documentation: self.documentation,
            insert_text: Some(text)
        )

    fn to_json(self) -> Dict:
        let mut item = {
            "label": self.label,
            "kind": self.kind
        }

        match self.detail:
            case Some(d):
                item["detail"] = d
            case None:
                pass

        match self.documentation:
            case Some(doc):
                item["documentation"] = doc
            case None:
                pass

        match self.insert_text:
            case Some(text):
                item["insertText"] = text
            case None:
                pass

        item

# Simple language keywords
fn get_keyword_completions() -> List<CompletionItem>:
    [
        # Control flow
        CompletionItem.new("fn", CompletionItemKind.Keyword)
            .with_documentation("Function definition"),
        CompletionItem.new("return", CompletionItemKind.Keyword)
            .with_documentation("Return statement"),
        CompletionItem.new("if", CompletionItemKind.Keyword)
            .with_documentation("Conditional expression"),
        CompletionItem.new("else", CompletionItemKind.Keyword)
            .with_documentation("Alternative branch"),
        CompletionItem.new("elif", CompletionItemKind.Keyword)
            .with_documentation("Else-if branch"),
        CompletionItem.new("match", CompletionItemKind.Keyword)
            .with_documentation("Pattern matching"),
        CompletionItem.new("case", CompletionItemKind.Keyword)
            .with_documentation("Match arm"),

        # Loops
        CompletionItem.new("for", CompletionItemKind.Keyword)
            .with_documentation("For loop"),
        CompletionItem.new("while", CompletionItemKind.Keyword)
            .with_documentation("While loop"),
        CompletionItem.new("loop", CompletionItemKind.Keyword)
            .with_documentation("Infinite loop"),
        CompletionItem.new("break", CompletionItemKind.Keyword)
            .with_documentation("Break from loop"),
        CompletionItem.new("continue", CompletionItemKind.Keyword)
            .with_documentation("Continue to next iteration"),

        # Declarations
        CompletionItem.new("let", CompletionItemKind.Keyword)
            .with_documentation("Variable declaration"),
        CompletionItem.new("mut", CompletionItemKind.Keyword)
            .with_documentation("Mutable binding"),
        CompletionItem.new("struct", CompletionItemKind.Keyword)
            .with_documentation("Struct definition"),
        CompletionItem.new("class", CompletionItemKind.Keyword)
            .with_documentation("Class definition"),
        CompletionItem.new("enum", CompletionItemKind.Keyword)
            .with_documentation("Enum definition"),
        CompletionItem.new("trait", CompletionItemKind.Keyword)
            .with_documentation("Trait definition"),
        CompletionItem.new("impl", CompletionItemKind.Keyword)
            .with_documentation("Implementation block"),

        # Import/export
        CompletionItem.new("import", CompletionItemKind.Keyword)
            .with_documentation("Import module"),
        CompletionItem.new("export", CompletionItemKind.Keyword)
            .with_documentation("Export symbol"),
        CompletionItem.new("from", CompletionItemKind.Keyword)
            .with_documentation("Import from module"),

        # Special
        CompletionItem.new("async", CompletionItemKind.Keyword)
            .with_documentation("Async function"),
        CompletionItem.new("await", CompletionItemKind.Keyword)
            .with_documentation("Await async result"),
        CompletionItem.new("yield", CompletionItemKind.Keyword)
            .with_documentation("Yield value in generator"),
    ]

# Built-in type completions
fn get_type_completions() -> List<CompletionItem>:
    [
        CompletionItem.new("Int", CompletionItemKind.Class)
            .with_detail("64-bit signed integer"),
        CompletionItem.new("Float", CompletionItemKind.Class)
            .with_detail("64-bit floating point"),
        CompletionItem.new("String", CompletionItemKind.Class)
            .with_detail("UTF-8 string"),
        CompletionItem.new("Bool", CompletionItemKind.Class)
            .with_detail("Boolean (true/false)"),
        CompletionItem.new("List", CompletionItemKind.Class)
            .with_detail("Dynamic array"),
        CompletionItem.new("Dict", CompletionItemKind.Class)
            .with_detail("Hash map"),
        CompletionItem.new("Option", CompletionItemKind.Class)
            .with_detail("Optional value (Some/None)"),
        CompletionItem.new("Result", CompletionItemKind.Class)
            .with_detail("Result type (Ok/Err)"),
        CompletionItem.new("Tuple", CompletionItemKind.Class)
            .with_detail("Fixed-size tuple"),
    ]

# Collect symbols from tree
fn collect_symbols(tree: Tree) -> List<CompletionItem>:
    let mut symbols: List<CompletionItem> = []

    fn traverse(node_id: NodeId):
        match tree.arena.get(node_id):
            case None:
                return
            case Some(node):
                # Collect function definitions
                if node.kind == "function_def":
                    match node.fields.get("name"):
                        case Some(name_id):
                            match tree.arena.get(name_id):
                                case Some(name_node):
                                    let item = CompletionItem.new(name_node.text, CompletionItemKind.Function)
                                        .with_detail("function")
                                    symbols.push(item)
                                case None:
                                    pass
                        case None:
                            pass

                # Collect variable declarations
                if node.kind == "let_stmt":
                    match node.fields.get("pattern"):
                        case Some(pattern_id):
                            match tree.arena.get(pattern_id):
                                case Some(pattern_node):
                                    if pattern_node.kind == "identifier":
                                        let item = CompletionItem.new(pattern_node.text, CompletionItemKind.Variable)
                                            .with_detail("variable")
                                        symbols.push(item)
                                case None:
                                    pass
                        case None:
                            pass

                # Collect struct/class definitions
                if node.kind == "struct_def" or node.kind == "class_def":
                    match node.fields.get("name"):
                        case Some(name_id):
                            match tree.arena.get(name_id):
                                case Some(name_node):
                                    let item = CompletionItem.new(name_node.text, CompletionItemKind.Struct)
                                        .with_detail("type")
                                    symbols.push(item)
                                case None:
                                    pass
                        case None:
                            pass

                # Traverse children
                for child_id in node.children:
                    traverse(child_id)

    traverse(tree.root_node)
    symbols

# Determine completion context
fn get_completion_context(tree: Tree, line: Int, column: Int) -> String:
    # Simplified context detection
    # TODO: [stdlib][P1] Implement sophisticated context analysis
    # - After "fn " → function name
    # - After "let " → variable name
    # - After ": " → type name
    # - In expression → keywords + symbols

    "expression"  # Default context

# Generate completions based on context
fn generate_completions(tree: Tree, context: String) -> List<CompletionItem>:
    let mut completions: List<CompletionItem> = []

    # Always include keywords
    completions.extend(get_keyword_completions())

    # Always include types
    completions.extend(get_type_completions())

    # Include symbols from tree
    completions.extend(collect_symbols(tree))

    completions

# Filter completions by prefix
fn filter_by_prefix(completions: List<CompletionItem>, prefix: String) -> List<CompletionItem>:
    if prefix.len() == 0:
        return completions

    let mut filtered: List<CompletionItem> = []

    for completion in completions:
        if completion.label.starts_with(prefix):
            filtered.push(completion)

    filtered

# Handle textDocument/completion request
fn handle_completion(tree: Tree, source: String, line: Int, column: Int) -> Result<Option<List<Dict>>, String>:
    # Determine completion context
    let context = get_completion_context(tree, line, column)

    # Generate completions
    let completions = generate_completions(tree, context)

    # TODO: [stdlib][P1] Extract prefix at cursor position
    # For now, return all completions
    let prefix = ""

    # Filter by prefix
    let filtered = filter_by_prefix(completions, prefix)

    if filtered.len() == 0:
        return Ok(None)

    # Convert to JSON
    let mut items: List<Dict> = []
    for completion in filtered:
        items.push(completion.to_json())

    Ok(Some(items))
