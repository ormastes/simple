# String Traits - Standard trait implementations
use core.traits.*
use core.collections.*

# ============================================
# Standard trait implementations
# ============================================

impl Clone for String:
    fn clone() -> Self:
        if self.len == 0:
            return String::new()
        let data = alloc[u8](self.len)
        danger:
            copy_mem(data, self.data, self.len)
        String { data: data, len: self.len, cap: self.len }

impl Default for String:
    fn default() -> Self:
        String::new()

impl Eq for String:
    fn eq(other: &Self) -> bool:
        if self.len != other.len:
            return false
        danger:
            for i in 0..self.len:
                if self.data.offset(i as isize).read() != other.data.offset(i as isize).read():
                    return false
        true

impl Ord for String:
    fn cmp(other: &Self) -> Ordering:
        let min_len = if self.len < other.len: self.len else: other.len
        danger:
            for i in 0..min_len:
                let a = self.data.offset(i as isize).read()
                let b = other.data.offset(i as isize).read()
                if a < b:
                    return Ordering::Less
                if a > b:
                    return Ordering::Greater
        if self.len < other.len:
            Ordering::Less
        else if self.len > other.len:
            Ordering::Greater
        else:
            Ordering::Equal

impl Hash for String:
    fn hash() -> u64:
        var h: u64 = 0
        danger:
            for i in 0..self.len:
                h = h * 31 + (self.data.offset(i as isize).read() as u64)
        h

impl Display for String:
    fn fmt() -> str:
        self.as_str()

impl Drop for String:
    fn drop():
        if self.data != nil:
            danger:
                dealloc(self.data)

impl Add<&str> for String:
    type Output = String

    fn add(rhs: &str) -> Self::Output:
        var result = self.clone()
        result.push_str(rhs)
        result

impl Add<String> for String:
    type Output = String

    fn add(rhs: String) -> Self::Output:
        var result = self.clone()
        result.push_str(rhs.as_str())
        result

# ============================================
# String Character Iterator
# ============================================

struct StringCharIter:
    string: String
    byte_index: usize

impl Iterator for StringCharIter:
    type Item = char

    fn next() -> Option<Self::Item>:
        if self.byte_index >= self.string.len:
            return None
        let c = self.string.char_at_byte(self.byte_index)
        self.byte_index = self.byte_index + self.string.char_width_at(self.byte_index)
        Some(c)

impl ExactSizeIterator for StringCharIter:
    fn len() -> usize:
        # Count remaining characters
        var count: usize = 0
        var i = self.byte_index
        while i < self.string.len:
            i = i + self.string.char_width_at(i)
            count = count + 1
        count

