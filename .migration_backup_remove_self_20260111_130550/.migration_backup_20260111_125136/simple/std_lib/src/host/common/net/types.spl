# Common Network Types
# Shared across all host variants (async_nogc_mut, async_gc_immut, etc.)

use core.traits.*

# Shutdown modes for TCP connections
pub enum Shutdown:
    Read
    Write
    Both

impl Display for Shutdown:
    fn fmt(self) -> str:
        match self:
            case Read: "read"
            case Write: "write"
            case Both: "both"

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_read(self) -> bool:
        """Check if shutdown mode is Read.

        Returns:
            True if Read
        """
        match self:
            case Read: true
            case _: false

    pub fn is_write(self) -> bool:
        """Check if shutdown mode is Write.

        Returns:
            True if Write
        """
        match self:
            case Write: true
            case _: false

    pub fn is_both(self) -> bool:
        """Check if shutdown mode is Both.

        Returns:
            True if Both
        """
        match self:
            case Both: true
            case _: false

    pub fn affects_reading(self) -> bool:
        """Check if shutdown affects reading.

        Returns:
            True for Read or Both
        """
        match self:
            case Read: true
            case Both: true
            case _: false

    pub fn affects_writing(self) -> bool:
        """Check if shutdown affects writing.

        Returns:
            True for Write or Both
        """
        match self:
            case Write: true
            case Both: true
            case _: false

    pub fn is_partial(self) -> bool:
        """Check if shutdown is partial (not Both).

        Returns:
            True if Read or Write only
        """
        match self:
            case Both: false
            case _: true

    pub fn is_complete(self) -> bool:
        """Check if shutdown is complete (Both).

        Returns:
            True if Both
        """
        return self.is_both()

    pub fn to_int(self) -> i64:
        """Convert to integer for FFI.

        Returns:
            Integer value (0=read, 1=write, 2=both)
        """
        match self:
            case Read: 0
            case Write: 1
            case Both: 2

    pub fn from_int(value: i64) -> Option[Shutdown]:
        """Create from integer value.

        Args:
            value: Integer (0=read, 1=write, 2=both)

        Returns:
            Shutdown mode or None if invalid
        """
        match value:
            case 0: Some(Read)
            case 1: Some(Write)
            case 2: Some(Both)
            case _: None

    pub fn to_string(self) -> String:
        """Convert shutdown mode to string.

        Returns:
            Mode name

        Example:
            Shutdown::Both.to_string()  # → "both"
        """
        match self:
            case Read: "read"
            case Write: "write"
            case Both: "both"

    pub fn description(self) -> String:
        """Get shutdown mode description.

        Returns:
            Human-readable description

        Example:
            Shutdown::Both.description()
            # → "Shutdown both read and write operations"
        """
        match self:
            case Read: "Shutdown read operations only"
            case Write: "Shutdown write operations only"
            case Both: "Shutdown both read and write operations"

    pub fn summary(self) -> str:
        """Get summary of shutdown mode.

        Returns:
            Human-readable summary

        Example:
            Shutdown::Both.summary()
            # → "Shutdown: both (affects read and write, complete)"
        """
        let name = self.fmt()
        let props = []
        if self.affects_reading():
            props.push("affects read")
        if self.affects_writing():
            props.push("affects write")
        if self.is_complete():
            props.push("complete")
        else:
            props.push("partial")
        let props_str = if props.len() > 0: " ({props.join(\", \")})" else: ""
        return "Shutdown: {name}{props_str}"

# HTTP Methods
pub enum HttpMethod:
    Get
    Post
    Put
    Delete
    Patch
    Head
    Options
    Connect
    Trace

impl HttpMethod:
    pub fn as_str(self) -> &str:
        match self:
            case Get: "GET"
            case Post: "POST"
            case Put: "PUT"
            case Delete: "DELETE"
            case Patch: "PATCH"
            case Head: "HEAD"
            case Options: "OPTIONS"
            case Connect: "CONNECT"
            case Trace: "TRACE"

impl Display for HttpMethod:
    fn fmt(self) -> str:
        match self:
            case Get: "GET"
            case Post: "POST"
            case Put: "PUT"
            case Delete: "DELETE"
            case Patch: "PATCH"
            case Head: "HEAD"
            case Options: "OPTIONS"
            case Connect: "CONNECT"
            case Trace: "TRACE"

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_get(self) -> bool:
        """Check if method is GET.

        Returns:
            True if GET
        """
        match self:
            case Get: true
            case _: false

    pub fn is_post(self) -> bool:
        """Check if method is POST.

        Returns:
            True if POST
        """
        match self:
            case Post: true
            case _: false

    pub fn is_put(self) -> bool:
        """Check if method is PUT.

        Returns:
            True if PUT
        """
        match self:
            case Put: true
            case _: false

    pub fn is_delete(self) -> bool:
        """Check if method is DELETE.

        Returns:
            True if DELETE
        """
        match self:
            case Delete: true
            case _: false

    pub fn is_patch(self) -> bool:
        """Check if method is PATCH.

        Returns:
            True if PATCH
        """
        match self:
            case Patch: true
            case _: false

    pub fn is_head(self) -> bool:
        """Check if method is HEAD.

        Returns:
            True if HEAD
        """
        match self:
            case Head: true
            case _: false

    pub fn is_safe(self) -> bool:
        """Check if method is safe (GET, HEAD, OPTIONS, TRACE).

        Returns:
            True if safe method
        """
        match self:
            case Get: true
            case Head: true
            case Options: true
            case Trace: true
            case _: false

    pub fn is_idempotent(self) -> bool:
        """Check if method is idempotent (GET, HEAD, PUT, DELETE, OPTIONS, TRACE).

        Returns:
            True if idempotent method
        """
        match self:
            case Get: true
            case Head: true
            case Put: true
            case Delete: true
            case Options: true
            case Trace: true
            case _: false

    pub fn has_request_body(self) -> bool:
        """Check if method typically has a request body.

        Returns:
            True if POST, PUT, or PATCH
        """
        match self:
            case Post: true
            case Put: true
            case Patch: true
            case _: false

    pub fn to_string(self) -> String:
        """Convert HTTP method to string.

        Returns:
            Method name in uppercase

        Example:
            HttpMethod::Post.to_string()  # → "POST"
        """
        match self:
            case Get: "GET"
            case Post: "POST"
            case Put: "PUT"
            case Delete: "DELETE"
            case Patch: "PATCH"
            case Head: "HEAD"
            case Options: "OPTIONS"
            case Connect: "CONNECT"
            case Trace: "TRACE"

    pub fn description(self) -> String:
        """Get HTTP method description.

        Returns:
            Human-readable description

        Example:
            HttpMethod::Post.description()
            # → "POST: Create or submit data"
        """
        match self:
            case Get: "GET: Retrieve resource"
            case Post: "POST: Create or submit data"
            case Put: "PUT: Update or replace resource"
            case Delete: "DELETE: Remove resource"
            case Patch: "PATCH: Partially update resource"
            case Head: "HEAD: Retrieve headers only"
            case Options: "OPTIONS: Query supported methods"
            case Connect: "CONNECT: Establish tunnel"
            case Trace: "TRACE: Echo request for debugging"

    pub fn summary(self) -> str:
        """Get summary of HTTP method.

        Returns:
            Human-readable summary

        Example:
            HttpMethod::Get.summary()
            # → "HttpMethod: GET (safe, idempotent)"
        """
        let name = self.as_str()
        let props = []
        if self.is_safe():
            props.push("safe")
        if self.is_idempotent():
            props.push("idempotent")
        if self.has_request_body():
            props.push("has body")
        let props_str = if props.len() > 0: " ({props.join(\", \")})" else: ""
        return "HttpMethod: {name}{props_str}"

# HTTP status code
pub unit StatusCode: u16 as status

impl StatusCode:
    pub fn from_u16(code: u16) -> StatusCode:
        return code_status

    pub fn as_u16(self) -> u16:
        return self as u16

    pub fn is_informational(self) -> bool:
        let code = self as u16
        return code >= 100 and code < 200

    pub fn is_success(self) -> bool:
        let code = self as u16
        return code >= 200 and code < 300

    pub fn is_redirect(self) -> bool:
        let code = self as u16
        return code >= 300 and code < 400

    pub fn is_client_error(self) -> bool:
        let code = self as u16
        return code >= 400 and code < 500

    pub fn is_server_error(self) -> bool:
        let code = self as u16
        return code >= 500 and code < 600

    pub fn reason_phrase(self) -> str:
        match self as u16:
            case 200: return "OK"
            case 201: return "Created"
            case 204: return "No Content"
            case 301: return "Moved Permanently"
            case 302: return "Found"
            case 304: return "Not Modified"
            case 400: return "Bad Request"
            case 401: return "Unauthorized"
            case 403: return "Forbidden"
            case 404: return "Not Found"
            case 405: return "Method Not Allowed"
            case 408: return "Request Timeout"
            case 429: return "Too Many Requests"
            case 500: return "Internal Server Error"
            case 502: return "Bad Gateway"
            case 503: return "Service Unavailable"
            case 504: return "Gateway Timeout"
            case _: return "Unknown"

    # Common status codes
    pub fn ok() -> StatusCode:
        return 200_status

    pub fn created() -> StatusCode:
        return 201_status

    pub fn no_content() -> StatusCode:
        return 204_status

    pub fn bad_request() -> StatusCode:
        return 400_status

    pub fn unauthorized() -> StatusCode:
        return 401_status

    pub fn forbidden() -> StatusCode:
        return 403_status

    pub fn not_found() -> StatusCode:
        return 404_status

    pub fn internal_server_error() -> StatusCode:
        return 500_status

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_error(self) -> bool:
        """Check if status is an error (4xx or 5xx).

        Returns:
            True if client or server error
        """
        return self.is_client_error() or self.is_server_error()

    pub fn is_ok(self) -> bool:
        """Check if status is 200 OK.

        Returns:
            True if 200
        """
        return (self as u16) == 200

    pub fn is_created(self) -> bool:
        """Check if status is 201 Created.

        Returns:
            True if 201
        """
        return (self as u16) == 201

    pub fn is_not_found(self) -> bool:
        """Check if status is 404 Not Found.

        Returns:
            True if 404
        """
        return (self as u16) == 404

    pub fn is_unauthorized(self) -> bool:
        """Check if status is 401 Unauthorized.

        Returns:
            True if 401
        """
        return (self as u16) == 401

    pub fn is_forbidden(self) -> bool:
        """Check if status is 403 Forbidden.

        Returns:
            True if 403
        """
        return (self as u16) == 403

    pub fn allows_body(self) -> bool:
        """Check if status code typically has a response body.

        Returns:
            True if status usually includes body (not 1xx, 204, 304)
        """
        let code = self as u16
        return not (self.is_informational() or code == 204 or code == 304)

    pub fn requires_location_header(self) -> bool:
        """Check if status requires Location header.

        Returns:
            True for 201, 301, 302, 303, 307, 308
        """
        let code = self as u16
        match code:
            case 201: true
            case 301: true
            case 302: true
            case 303: true
            case 307: true
            case 308: true
            case _: false

    pub fn is_cacheable(self) -> bool:
        """Check if response is cacheable by default.

        Returns:
            True for 200, 203, 204, 206, 300, 301, 404, 405, 410, 414, 501
        """
        let code = self as u16
        match code:
            case 200: true
            case 203: true
            case 204: true
            case 206: true
            case 300: true
            case 301: true
            case 404: true
            case 405: true
            case 410: true
            case 414: true
            case 501: true
            case _: false

    pub fn summary(self) -> str:
        """Get summary of status code.

        Returns:
            Human-readable summary

        Example:
            StatusCode::ok().summary()
            # → "StatusCode: 200 OK (success, cacheable)"
        """
        let code = self as u16
        let phrase = self.reason_phrase()
        let category = if self.is_informational(): "informational"
                       else if self.is_success(): "success"
                       else if self.is_redirect(): "redirect"
                       else if self.is_client_error(): "client error"
                       else if self.is_server_error(): "server error"
                       else: "unknown"
        let props = []
        if self.is_cacheable():
            props.push("cacheable")
        if not self.allows_body():
            props.push("no body")
        let props_str = if props.len() > 0: ", {props.join(\", \")}" else: ""
        return "StatusCode: {code} {phrase} ({category}{props_str})"

impl Display for StatusCode:
    fn fmt(self) -> str:
        "{self as u16} {self.reason_phrase()}"

# HTTP header name (case-insensitive)
pub unit HeaderName: str as header

impl HeaderName:
    pub fn from_str(s: str) -> HeaderName:
        return s.to_lower()_header

    # Common headers
    pub fn content_type() -> HeaderName:
        return "content-type"_header

    pub fn content_length() -> HeaderName:
        return "content-length"_header

    pub fn authorization() -> HeaderName:
        return "authorization"_header

    pub fn user_agent() -> HeaderName:
        return "user-agent"_header

    pub fn accept() -> HeaderName:
        return "accept"_header

    pub fn host() -> HeaderName:
        return "host"_header

    pub fn connection() -> HeaderName:
        return "connection"_header

    pub fn cache_control() -> HeaderName:
        return "cache-control"_header

    pub fn cookie() -> HeaderName:
        return "cookie"_header

    pub fn set_cookie() -> HeaderName:
        return "set-cookie"_header

impl Display for HeaderName:
    fn fmt(self) -> str:
        self as str

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn as_str(self) -> str:
        """Get header name as string.

        Returns:
            Header name string
        """
        return self as str

    pub fn is_empty(self) -> bool:
        """Check if header name is empty.

        Returns:
            True if empty
        """
        return (self as str).is_empty()

    pub fn len(self) -> usize:
        """Get length of header name.

        Returns:
            Character count
        """
        return (self as str).len()

    pub fn is_content_type(self) -> bool:
        """Check if header is Content-Type.

        Returns:
            True if content-type
        """
        return (self as str) == "content-type"

    pub fn is_authorization(self) -> bool:
        """Check if header is Authorization.

        Returns:
            True if authorization
        """
        return (self as str) == "authorization"

    pub fn is_cookie(self) -> bool:
        """Check if header is Cookie or Set-Cookie.

        Returns:
            True if cookie-related
        """
        let name = self as str
        return name == "cookie" or name == "set-cookie"

    pub fn is_standard(self) -> bool:
        """Check if header is a standard HTTP header.

        Returns:
            True if standard header
        """
        let name = self as str
        match name:
            case "content-type": true
            case "content-length": true
            case "authorization": true
            case "user-agent": true
            case "accept": true
            case "host": true
            case "connection": true
            case "cache-control": true
            case "cookie": true
            case "set-cookie": true
            case _: false

    pub fn is_custom(self) -> bool:
        """Check if header is a custom (non-standard) header.

        Returns:
            True if custom header
        """
        return not self.is_standard()

    pub fn summary(self) -> str:
        """Get summary of header name.

        Returns:
            Human-readable summary

        Example:
            HeaderName::content_type().summary()
            # → "HeaderName: content-type (standard)"
        """
        let name = self as str
        let kind = if self.is_standard(): "standard" else: "custom"
        return "HeaderName: {name} ({kind})"

# HTTP header value
pub unit HeaderValue: str as hval

impl HeaderValue:
    pub fn from_str(s: str) -> HeaderValue:
        return s_hval

    # Common content types
    pub fn json() -> HeaderValue:
        return "application/json"_hval

    pub fn form() -> HeaderValue:
        return "application/x-www-form-urlencoded"_hval

    pub fn multipart() -> HeaderValue:
        return "multipart/form-data"_hval

    pub fn text() -> HeaderValue:
        return "text/plain"_hval

    pub fn html() -> HeaderValue:
        return "text/html"_hval

    pub fn xml() -> HeaderValue:
        return "application/xml"_hval

impl Display for HeaderValue:
    fn fmt(self) -> str:
        self as str

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn as_str(self) -> str:
        """Get header value as string.

        Returns:
            Header value string
        """
        return self as str

    pub fn is_empty(self) -> bool:
        """Check if header value is empty.

        Returns:
            True if empty
        """
        return (self as str).is_empty()

    pub fn len(self) -> usize:
        """Get length of header value.

        Returns:
            Character count
        """
        return (self as str).len()

    pub fn is_json(self) -> bool:
        """Check if value is JSON content type.

        Returns:
            True if application/json
        """
        return (self as str).contains("application/json")

    pub fn is_form(self) -> bool:
        """Check if value is form content type.

        Returns:
            True if form-urlencoded or multipart
        """
        let val = self as str
        return val.contains("application/x-www-form-urlencoded") or
               val.contains("multipart/form-data")

    pub fn is_text(self) -> bool:
        """Check if value is text content type.

        Returns:
            True if text/* content type
        """
        return (self as str).starts_with("text/")

    pub fn is_binary(self) -> bool:
        """Check if value is binary content type.

        Returns:
            True if application/octet-stream or similar
        """
        let val = self as str
        return val.contains("application/octet-stream") or
               val.contains("application/pdf") or
               val.contains("image/") or
               val.contains("video/") or
               val.contains("audio/")

    pub fn content_type_base(self) -> str:
        """Extract base content type (without charset, etc.).

        Returns:
            Base content type

        Example:
            "text/html; charset=utf-8".content_type_base()
            # → "text/html"
        """
        let val = self as str
        let parts = val.split(";")
        if parts.len() > 0:
            return parts[0].trim()
        return val

    pub fn summary(self) -> str:
        """Get summary of header value.

        Returns:
            Human-readable summary

        Example:
            HeaderValue::json().summary()
            # → "HeaderValue: application/json (JSON, 16 chars)"
        """
        let val = self as str
        let len = self.len()
        let types = []
        if self.is_json():
            types.push("JSON")
        if self.is_text():
            types.push("text")
        if self.is_binary():
            types.push("binary")
        if self.is_form():
            types.push("form")
        let types_str = if types.len() > 0: types.join("/") + ", " else: ""
        return "HeaderValue: {val} ({types_str}{len} chars)"

# HTTP error type
pub enum HttpError:
    ConnectionFailed(IoError)
    Timeout
    InvalidUrl
    TooManyRedirects
    InvalidResponse
    InvalidHeader
    BodyTooLarge
    Cancelled
    TlsError(str)
    Other(str)

use host.common.io.error.IoError

impl HttpError:
    pub fn message(self) -> str:
        match self:
            case ConnectionFailed(e): return "connection failed: {e.message()}"
            case Timeout: return "request timed out"
            case InvalidUrl: return "invalid URL"
            case TooManyRedirects: return "too many redirects"
            case InvalidResponse: return "invalid response"
            case InvalidHeader: return "invalid header"
            case BodyTooLarge: return "response body too large"
            case Cancelled: return "request cancelled"
            case TlsError(msg): return "TLS error: {msg}"
            case Other(msg): return msg

impl Display for HttpError:
    fn fmt(self) -> str:
        self.message()

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_connection_failed(self) -> bool:
        """Check if error is ConnectionFailed.

        Returns:
            True if ConnectionFailed
        """
        match self:
            case ConnectionFailed(_): true
            case _: false

    pub fn is_timeout(self) -> bool:
        """Check if error is Timeout.

        Returns:
            True if Timeout
        """
        match self:
            case Timeout: true
            case _: false

    pub fn is_invalid_url(self) -> bool:
        """Check if error is InvalidUrl.

        Returns:
            True if InvalidUrl
        """
        match self:
            case InvalidUrl: true
            case _: false

    pub fn is_tls_error(self) -> bool:
        """Check if error is TlsError.

        Returns:
            True if TlsError
        """
        match self:
            case TlsError(_): true
            case _: false

    pub fn is_network_error(self) -> bool:
        """Check if error is network-related.

        Returns:
            True if ConnectionFailed, Timeout, or TlsError
        """
        match self:
            case ConnectionFailed(_): true
            case Timeout: true
            case TlsError(_): true
            case _: false

    pub fn is_protocol_error(self) -> bool:
        """Check if error is protocol-related.

        Returns:
            True if InvalidResponse, InvalidHeader, BodyTooLarge
        """
        match self:
            case InvalidResponse: true
            case InvalidHeader: true
            case BodyTooLarge: true
            case _: false

    pub fn is_retryable(self) -> bool:
        """Check if error might be retryable.

        Returns:
            True if Timeout or ConnectionFailed
        """
        match self:
            case Timeout: true
            case ConnectionFailed(_): true
            case _: false

    pub fn to_string(self) -> String:
        """Convert HTTP error to string.

        Returns:
            Error type name

        Example:
            HttpError::Timeout.to_string()  # → "timeout"
        """
        match self:
            case ConnectionFailed(_): "connection-failed"
            case Timeout: "timeout"
            case InvalidUrl: "invalid-url"
            case TooManyRedirects: "too-many-redirects"
            case InvalidResponse: "invalid-response"
            case InvalidHeader: "invalid-header"
            case BodyTooLarge: "body-too-large"
            case Cancelled: "cancelled"
            case TlsError(_): "tls-error"
            case Other(_): "other"

    pub fn description(self) -> String:
        """Get HTTP error description.

        Returns:
            Human-readable description

        Example:
            HttpError::Timeout.description()
            # → "Request operation timed out"
        """
        match self:
            case ConnectionFailed(_): "Failed to establish connection"
            case Timeout: "Request operation timed out"
            case InvalidUrl: "URL format is invalid"
            case TooManyRedirects: "Too many redirects encountered"
            case InvalidResponse: "Server response is invalid"
            case InvalidHeader: "HTTP header is malformed"
            case BodyTooLarge: "Response body exceeds size limit"
            case Cancelled: "Request was cancelled"
            case TlsError(_): "TLS/SSL error occurred"
            case Other(_): "Other HTTP error"

    pub fn summary(self) -> str:
        """Get summary of HTTP error.

        Returns:
            Human-readable summary

        Example:
            HttpError::Timeout.summary()
            # → "HttpError: request timed out (retryable)"
        """
        let msg = self.message()
        let props = []
        if self.is_retryable():
            props.push("retryable")
        if self.is_network_error():
            props.push("network")
        if self.is_protocol_error():
            props.push("protocol")
        let props_str = if props.len() > 0: " ({props.join(\", \")})" else: ""
        return "HttpError: {msg}{props_str}"

impl Error for HttpError

# Network error types
pub enum NetError:
    IoError(message: String)
    AddrParseError(message: String)
    ConnectionRefused
    ConnectionReset
    TimedOut
    WouldBlock
    NotConnected
    AlreadyConnected
    InvalidData
    PermissionDenied

impl NetError:
    # Convert from error code
    pub fn from_code(code: i64) -> NetError:
        match code:
            case -1: return NetError::IoError("I/O operation failed")
            case -2: return NetError::ConnectionRefused
            case -3: return NetError::ConnectionReset
            case -4: return NetError::TimedOut
            case -5: return NetError::WouldBlock
            case -6: return NetError::NotConnected
            case -7: return NetError::AlreadyConnected
            case -8: return NetError::InvalidData
            case -9: return NetError::PermissionDenied
            case _: return NetError::IoError("Unknown error")

    # Convert to string message
    pub fn to_string(self) -> String:
        match self:
            case NetError::IoError(msg): return msg
            case NetError::AddrParseError(msg): return "Address parse error: {msg}"
            case NetError::ConnectionRefused: return "Connection refused"
            case NetError::ConnectionReset: return "Connection reset"
            case NetError::TimedOut: return "Operation timed out"
            case NetError::WouldBlock: return "Operation would block"
            case NetError::NotConnected: return "Not connected"
            case NetError::AlreadyConnected: return "Already connected"
            case NetError::InvalidData: return "Invalid data"
            case NetError::PermissionDenied: return "Permission denied"

impl Display for NetError:
    fn fmt(self) -> str:
        self.to_string()

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_io_error(self) -> bool:
        """Check if error is IoError.

        Returns:
            True if IoError
        """
        match self:
            case IoError(_): true
            case _: false

    pub fn is_connection_refused(self) -> bool:
        """Check if error is ConnectionRefused.

        Returns:
            True if ConnectionRefused
        """
        match self:
            case ConnectionRefused: true
            case _: false

    pub fn is_connection_reset(self) -> bool:
        """Check if error is ConnectionReset.

        Returns:
            True if ConnectionReset
        """
        match self:
            case ConnectionReset: true
            case _: false

    pub fn is_timed_out(self) -> bool:
        """Check if error is TimedOut.

        Returns:
            True if TimedOut
        """
        match self:
            case TimedOut: true
            case _: false

    pub fn is_would_block(self) -> bool:
        """Check if error is WouldBlock.

        Returns:
            True if WouldBlock
        """
        match self:
            case WouldBlock: true
            case _: false

    pub fn is_not_connected(self) -> bool:
        """Check if error is NotConnected.

        Returns:
            True if NotConnected
        """
        match self:
            case NotConnected: true
            case _: false

    pub fn is_permission_denied(self) -> bool:
        """Check if error is PermissionDenied.

        Returns:
            True if PermissionDenied
        """
        match self:
            case PermissionDenied: true
            case _: false

    pub fn is_connection_error(self) -> bool:
        """Check if error is connection-related.

        Returns:
            True if ConnectionRefused, ConnectionReset, or NotConnected
        """
        match self:
            case ConnectionRefused: true
            case ConnectionReset: true
            case NotConnected: true
            case _: false

    pub fn is_transient(self) -> bool:
        """Check if error is transient (temporary).

        Returns:
            True if WouldBlock or TimedOut
        """
        match self:
            case WouldBlock: true
            case TimedOut: true
            case _: false

    pub fn is_retryable(self) -> bool:
        """Check if error might be retryable.

        Returns:
            True if transient or ConnectionRefused
        """
        match self:
            case WouldBlock: true
            case TimedOut: true
            case ConnectionRefused: true
            case _: false

    pub fn is_fatal(self) -> bool:
        """Check if error is likely fatal (non-retryable).

        Returns:
            True if PermissionDenied or InvalidData
        """
        match self:
            case PermissionDenied: true
            case InvalidData: true
            case _: false

    pub fn description(self) -> String:
        """Get network error description.

        Returns:
            Human-readable description

        Example:
            NetError::TimedOut.description()
            # → "Network operation timed out"
        """
        match self:
            case IoError(_): "Low-level I/O error"
            case AddrParseError(_): "Failed to parse network address"
            case ConnectionRefused: "Connection refused by remote host"
            case ConnectionReset: "Connection reset by peer"
            case TimedOut: "Network operation timed out"
            case WouldBlock: "Operation would block (non-blocking mode)"
            case NotConnected: "Socket is not connected"
            case AlreadyConnected: "Socket is already connected"
            case InvalidData: "Invalid network data received"
            case PermissionDenied: "Permission denied for network operation"

    pub fn summary(self) -> String:
        """Get summary of network error.

        Returns:
            Human-readable summary

        Example:
            NetError::TimedOut.summary()
            # → "NetError: Operation timed out (transient, retryable)"
        """
        let msg = self.to_string()
        let props = []
        if self.is_transient():
            props.push("transient")
        if self.is_retryable():
            props.push("retryable")
        if self.is_fatal():
            props.push("fatal")
        if self.is_connection_error():
            props.push("connection")
        let props_str = if props.len() > 0: " ({props.join(\", \")})" else: ""
        return "NetError: {msg}{props_str}"

impl Error for NetError
