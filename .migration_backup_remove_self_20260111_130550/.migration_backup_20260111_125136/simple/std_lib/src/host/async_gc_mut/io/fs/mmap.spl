# Memory-Mapped File Operations (GC Mutable Variant)
#
# Zero-copy file access via memory mapping.

use units.file.*
use units.size.*
use host.common.io.*

export MmapRegion
export open_mmap, open_mmap_with, open_mmap_sync, open_mmap_sync_with

# Re-export MmapRegion from common module
pub use host.common.io.mmap_common.MmapRegion

# ===============================
# Async Mmap Functions
# ===============================

# Open file as memory-mapped region (async, returns immediately)
pub async fn open_mmap(path: FilePath) -> Result<MmapRegion, IoError>:
    return open_mmap_with(path, MmapMode::ReadOnly, MmapAdvice::Normal)

# Open file as memory-mapped region with mode and advice
pub async fn open_mmap_with(path: FilePath, mode: MmapMode, advice: MmapAdvice) -> Result<MmapRegion, IoError>:
    # Resolve path
    let resolved_path = native_path_resolve(path)?

    # Check file existence
    if not await exists(resolved_path):
        return Err(IoError::NotFound)

    # Open file
    let open_mode = mmap_mode_to_open_mode(mode)
    let fd = native_fs_open(resolved_path, open_mode)?

    # Get file size
    let size = native_file_get_size(fd)?

    # Create memory mapping
    let mmap_ptr = create_mmap_ptr(fd, size, mode)?

    # Create region
    let region = create_mmap_region(mmap_ptr, size, mode, fd, resolved_path)

    # Apply advice
    if advice != MmapAdvice::Normal:
        region.advise(advice)?

    return Ok(region)

# ===============================
# Sync Mmap Functions
# ===============================

# Open file as memory-mapped region (sync, blocks until ready)
pub fn open_mmap_sync(path: FilePath) -> Result<MmapRegion, IoError>:
    return open_mmap_sync_with(path, MmapMode::ReadOnly, MmapAdvice::Normal)

# Open file as memory-mapped region (sync) with mode and advice
pub fn open_mmap_sync_with(path: FilePath, mode: MmapMode, advice: MmapAdvice) -> Result<MmapRegion, IoError>:
    return open_mmap_impl(path, mode, advice)

# ===============================
# Context Manager Implementations
# ===============================

impl ContextManager<MmapRegion> for MmapRegion:
    fn __enter__() -> MmapRegion:
        return self

    fn __exit__(exc: Option<Exception>) -> bool:
        let _ = self.close()
        return false

impl AsyncContextManager<MmapRegion> for MmapRegion:
    async fn __aenter__(self) -> MmapRegion:
        return self

    async fn __aexit__(self, exc: Option<Exception>) -> bool:
        let _ = self.close()
        return false

# Helper to check existence (used internally)
async fn exists(path: FilePath) -> bool:
    match native_fs_metadata(path):
        case Ok(_): return true
        case Err(_): return false

