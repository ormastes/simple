# Godot Networking System
#
# Type-safe wrappers for Godot's multiplayer networking
#
# Features:
# - MultiplayerAPI (high-level networking)
# - RPC (Remote Procedure Calls)
# - ENetConnection (low-level networking)
# - SceneMultiplayer (scene replication)
#
# Based on: https://docs.godotengine.org/en/stable/classes/class_multiplayerapi.html

import godot.ffi
import godot.variant
import godot.node

mod networking

# Multiplayer API
# High-level multiplayer management
pub struct MultiplayerAPI:
    singleton_ptr: ffi.GDExtensionObjectPtr

impl MultiplayerAPI:
    # Get MultiplayerAPI singleton
    pub fn get_singleton() -> MultiplayerAPI:
        # TODO: [stdlib][P3] Get from SceneTree
        let ptr = ffi.godot_get_singleton("MultiplayerAPI")
        return MultiplayerAPI(singleton_ptr: ptr)

    # Check if server
    pub fn is_server(self) -> bool:
        let obj = variant.Object::from_ptr(self.singleton_ptr)
        let result = obj.call0("is_server")
        return result.as_bool()

    # Get unique peer ID
    pub fn get_unique_id(self) -> i32:
        let obj = variant.Object::from_ptr(self.singleton_ptr)
        let result = obj.call0("get_unique_id")
        return result.as_int() as i32

    # Get remote sender ID (in RPC context)
    pub fn get_remote_sender_id(self) -> i32:
        let obj = variant.Object::from_ptr(self.singleton_ptr)
        let result = obj.call0("get_remote_sender_id")
        return result.as_int() as i32

    # Get list of connected peer IDs
    pub fn get_peers(self) -> Array[i32]:
        let obj = variant.Object::from_ptr(self.singleton_ptr)
        let result = obj.call0("get_peers")
        # TODO: [stdlib][P2] Parse PackedInt32Array
        return []  # Placeholder

    # Poll for network events
    pub fn poll(mut self):
        let obj = variant.Object::from_ptr(self.singleton_ptr)
        obj.call0("poll")

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_client(self) -> bool:
        """Check if this is a client (not server).

        Returns:
            true if client

        Example:
            api.is_client()  # → true
        """
        return not self.is_server()

    pub fn get_peer_id(self) -> i32:
        """Get unique peer ID (alias for get_unique_id).

        Returns:
            Peer identifier

        Example:
            api.get_peer_id()  # → 1
        """
        return self.get_unique_id()

    pub fn summary(self) -> String:
        """Get multiplayer API summary.

        Returns:
            Human-readable summary

        Example:
            api.summary()
            # → "MultiplayerAPI: server, peer_id=1"
        """
        let role = if self.is_server() { "server" } else { "client" }
        let peer_id = self.get_unique_id()
        return "MultiplayerAPI: {role}, peer_id={peer_id}"


# ENet Peer Connection
pub struct ENetConnection:
    ptr: ffi.GDExtensionObjectPtr

impl ENetConnection:
    # Create new connection
    pub fn new() -> ENetConnection:
        let ptr = ffi.godot_new_object("ENetConnection")
        return ENetConnection(ptr: ptr)

    # Create server
    pub fn create_host_bound(mut self, address: String, port: i32, max_peers: i32 = 32) -> Result[(), String]:
        let obj = variant.Object::from_ptr(self.ptr)
        let addr_var = variant.Variant::from_string(address)
        let port_var = variant.Variant::from_int(port as i64)
        let peers_var = variant.Variant::from_int(max_peers as i64)
        let result = obj.call3("create_host_bound", addr_var, port_var, peers_var)

        let error_code = result.as_int()
        if error_code == 0:  # OK
            return Ok(())
        else:
            return Err("Failed to create server: error {error_code}")

    # Connect to server
    pub fn connect_to_host(mut self, address: String, port: i32) -> Result[(), String]:
        let obj = variant.Object::from_ptr(self.ptr)
        let addr_var = variant.Variant::from_string(address)
        let port_var = variant.Variant::from_int(port as i64)
        let result = obj.call2("connect_to_host", addr_var, port_var)

        let error_code = result.as_int()
        if error_code == 0:
            return Ok(())
        else:
            return Err("Failed to connect: error {error_code}")

    # Service connection (poll for events)
    pub fn service(mut self, timeout: i32 = 0) -> Array[ENetEvent]:
        let obj = variant.Object::from_ptr(self.ptr)
        let timeout_var = variant.Variant::from_int(timeout as i64)
        let result = obj.call1("service", timeout_var)
        # TODO: [stdlib][P2] Parse events
        return []  # Placeholder

    # Close connection
    pub fn destroy(mut self):
        let obj = variant.Object::from_ptr(self.ptr)
        obj.call0("destroy")

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn create_server(mut self, address: String, port: i32, max_peers: i32 = 32) -> Result[(), String]:
        """Create server (alias for create_host_bound).

        Args:
            address: Bind address
            port: Port number
            max_peers: Maximum number of peers

        Returns:
            Result with unit or error message

        Example:
            conn.create_server("*", 9999, 32)
        """
        return self.create_host_bound(address, port, max_peers)

    pub fn close(mut self):
        """Close connection (alias for destroy).

        Example:
            conn.close()
        """
        self.destroy()

    pub fn summary(self) -> String:
        """Get ENet connection summary.

        Returns:
            Human-readable summary

        Example:
            conn.summary()
            # → "ENetConnection: active"
        """
        return "ENetConnection: active"


# ENet Event
pub struct ENetEvent:
    event_type: ENetEventType
    peer_id: i32
    data: Array[u8]

impl ENetEvent:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_connect(self) -> bool:
        """Check if event is a connection event.

        Returns:
            true if Connect event

        Example:
            event.is_connect()  # → true
        """
        return self.event_type.is_connect()

    pub fn is_disconnect(self) -> bool:
        """Check if event is a disconnection event.

        Returns:
            true if Disconnect event

        Example:
            event.is_disconnect()  # → false
        """
        return self.event_type.is_disconnect()

    pub fn is_receive(self) -> bool:
        """Check if event is a data receive event.

        Returns:
            true if Receive event

        Example:
            event.is_receive()  # → false
        """
        return self.event_type.is_receive()

    pub fn has_data(self) -> bool:
        """Check if event has data.

        Returns:
            true if data array is not empty

        Example:
            event.has_data()  # → false
        """
        return self.data.len() > 0

    pub fn summary(self) -> String:
        """Get ENet event summary.

        Returns:
            Human-readable summary

        Example:
            event.summary()
            # → "ENetEvent: connect from peer 2"
        """
        let type_name = self.event_type.to_string()
        return "ENetEvent: {type_name} from peer {self.peer_id}"

pub enum ENetEventType:
    None = 0
    Connect = 1
    Disconnect = 2
    Receive = 3

impl ENetEventType:
    pub fn to_string(self) -> String:
        """Convert event type to string."""
        match self:
            case None: "none"
            case Connect: "connect"
            case Disconnect: "disconnect"
            case Receive: "receive"

    pub fn description(self) -> String:
        """Get event type description."""
        match self:
            case None: "No event"
            case Connect: "Peer connected"
            case Disconnect: "Peer disconnected"
            case Receive: "Data received from peer"

    pub fn is_none(self) -> bool:
        """Check if event type is None."""
        match self:
            case None: true
            case _: false

    pub fn is_connect(self) -> bool:
        """Check if event type is Connect."""
        match self:
            case Connect: true
            case _: false

    pub fn is_disconnect(self) -> bool:
        """Check if event type is Disconnect."""
        match self:
            case Disconnect: true
            case _: false

    pub fn is_receive(self) -> bool:
        """Check if event type is Receive."""
        match self:
            case Receive: true
            case _: false

    pub fn is_connection_event(self) -> bool:
        """Check if event is connection-related."""
        match self:
            case Connect: true
            case Disconnect: true
            case _: false

    pub fn summary(self) -> String:
        """Get event type summary."""
        let name = self.to_string()
        let desc = self.description()
        return "ENetEventType: {name} ({desc})"


# Scene Multiplayer
# Automatic scene replication
pub struct SceneMultiplayer:
    ptr: ffi.GDExtensionObjectPtr

impl SceneMultiplayer:
    pub fn new() -> SceneMultiplayer:
        let ptr = ffi.godot_new_object("SceneMultiplayer")
        return SceneMultiplayer(ptr: ptr)

    # Set root path for replication
    pub fn set_root_path(mut self, path: String):
        let obj = variant.Object::from_ptr(self.ptr)
        let path_var = variant.Variant::from_string(path)
        obj.call1("set_root_path", path_var)

    # Clear all peers
    pub fn clear(mut self):
        let obj = variant.Object::from_ptr(self.ptr)
        obj.call0("clear")

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn reset(mut self):
        """Reset multiplayer (alias for clear).

        Example:
            scene.reset()
        """
        self.clear()

    pub fn summary(self) -> String:
        """Get scene multiplayer summary.

        Returns:
            Human-readable summary

        Example:
            scene.summary()
            # → "SceneMultiplayer: automatic scene replication"
        """
        return "SceneMultiplayer: automatic scene replication"


# RPC Helper Trait
# Add RPC capabilities to nodes
pub trait Networked:
    # Call RPC on all peers
    me rpc(method: String, args: Array[variant.Variant]):
        # TODO: [stdlib][P3] Call rpc method
        pass

    # Call RPC on specific peer
    me rpc_id(peer_id: i32, method: String, args: Array[variant.Variant]):
        # TODO: [stdlib][P3] Call rpc_id method
        pass


# Network Manager Helper
# High-level networking API
pub struct NetworkManager:
    multiplayer_api: MultiplayerAPI
    connection: Option[ENetConnection]
    is_server: bool
    peers: Array[i32]

impl NetworkManager:
    # Create new network manager
    pub fn new() -> NetworkManager:
        return NetworkManager(
            multiplayer_api: MultiplayerAPI::get_singleton(),
            connection: None,
            is_server: false,
            peers: []
        )

    # Host server
    pub fn host_server(mut self, port: i32, max_peers: i32 = 32) -> Result[(), String]:
        let mut conn = ENetConnection::new()
        let result = conn.create_host_bound("*", port, max_peers)

        if result.is_ok():
            self.connection = Some(conn)
            self.is_server = true
            println("Server started on port {port}")
            return Ok(())
        else:
            return Err(result.unwrap_err())

    # Join server
    pub fn join_server(mut self, address: String, port: i32) -> Result[(), String]:
        let mut conn = ENetConnection::new()
        let result = conn.connect_to_host(address, port)

        if result.is_ok():
            self.connection = Some(conn)
            self.is_server = false
            println("Connecting to {address}:{port}")
            return Ok(())
        else:
            return Err(result.unwrap_err())

    # Poll for network events
    pub fn poll(mut self):
        # Poll multiplayer API
        self.multiplayer_api.poll()

        # Service ENet connection if present
        if self.connection.is_some():
            let mut conn = self.connection.unwrap()
            let events = conn.service(0)

            for event in events:
                self.handle_event(event)

    # Handle network event
    me handle_event(event: ENetEvent):
        if event.event_type == ENetEventType::Connect:
            println("Peer {event.peer_id} connected")
            self.peers.push(event.peer_id)

        elif event.event_type == ENetEventType::Disconnect:
            println("Peer {event.peer_id} disconnected")
            self.remove_peer(event.peer_id)

        elif event.event_type == ENetEventType::Receive:
            println("Received data from peer {event.peer_id}")
            self.handle_data(event.peer_id, event.data)

    # Remove peer from list
    me remove_peer(peer_id: i32):
        # Filter out the peer to remove
        let mut new_peers: Array[i32] = []
        for id in self.peers:
            if id != peer_id:
                new_peers.push(id)

        self.peers = new_peers

    # Handle received data
    me handle_data(peer_id: i32, data: Array[u8]):
        # TODO: [stdlib][P3] Deserialize and process data
        pass

    # Disconnect
    pub fn disconnect(mut self):
        if self.connection.is_some():
            let mut conn = self.connection.unwrap()
            conn.destroy()
            self.connection = None

        self.peers.clear()
        println("Disconnected from network")

    # Check if connected
    pub fn is_connected(self) -> bool:
        return self.connection.is_some()

    # Get peer count
    pub fn get_peer_count(self) -> i32:
        return self.peers.len()

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_connection(self) -> bool:
        """Check if has connection (alias for is_connected).

        Returns:
            true if connected

        Example:
            manager.has_connection()  # → true
        """
        return self.is_connected()

    pub fn has_peers(self) -> bool:
        """Check if has any connected peers.

        Returns:
            true if peer count > 0

        Example:
            manager.has_peers()  # → true
        """
        return self.get_peer_count() > 0

    pub fn is_client(self) -> bool:
        """Check if this is a client (not server).

        Returns:
            true if client

        Example:
            manager.is_client()  # → false
        """
        return not self.is_server

    pub fn close(mut self):
        """Close connection (alias for disconnect).

        Example:
            manager.close()
        """
        self.disconnect()

    pub fn summary(self) -> String:
        """Get network manager summary.

        Returns:
            Human-readable summary

        Example:
            manager.summary()
            # → "NetworkManager: server, 3 peers connected"
        """
        let role = if self.is_server { "server" } else { "client" }
        let conn_status = if self.is_connected() { "connected" } else { "disconnected" }
        let peer_count = self.get_peer_count()
        return "NetworkManager: {role}, {conn_status}, {peer_count} peers"


# RPC Mode (for @rpc annotations)
pub enum RPCMode:
    Disabled = 0        # No RPC
    AnyPeer = 1         # Any peer can call
    Authority = 2       # Only authority can call

impl RPCMode:
    pub fn to_string(self) -> String:
        """Convert RPC mode to string."""
        match self:
            case Disabled: "disabled"
            case AnyPeer: "any_peer"
            case Authority: "authority"

    pub fn description(self) -> String:
        """Get RPC mode description."""
        match self:
            case Disabled: "RPC disabled (no remote calls)"
            case AnyPeer: "Any peer can call (permissive)"
            case Authority: "Only authority can call (secure)"

    pub fn is_disabled(self) -> bool:
        """Check if RPC is disabled."""
        match self:
            case Disabled: true
            case _: false

    pub fn is_any_peer(self) -> bool:
        """Check if mode is AnyPeer."""
        match self:
            case AnyPeer: true
            case _: false

    pub fn is_authority(self) -> bool:
        """Check if mode is Authority."""
        match self:
            case Authority: true
            case _: false

    pub fn is_enabled(self) -> bool:
        """Check if RPC is enabled."""
        match self:
            case Disabled: false
            case _: true

    pub fn is_secure(self) -> bool:
        """Check if mode is secure (Authority only)."""
        match self:
            case Authority: true
            case _: false

    pub fn summary(self) -> String:
        """Get RPC mode summary."""
        let name = self.to_string()
        let desc = self.description()
        let status = if self.is_enabled(): "enabled" else: "disabled"
        let security = if self.is_secure(): ", secure" else: if self.is_enabled(): ", permissive" else: ""
        return "RPCMode: {name} ({desc}, {status}{security})"

# Transfer Mode
pub enum TransferMode:
    Unreliable = 0      # UDP-like
    UnreliableOrdered = 1  # Ordered UDP
    Reliable = 2        # TCP-like

impl TransferMode:
    pub fn to_string(self) -> String:
        """Convert transfer mode to string."""
        match self:
            case Unreliable: "unreliable"
            case UnreliableOrdered: "unreliable_ordered"
            case Reliable: "reliable"

    pub fn description(self) -> String:
        """Get transfer mode description."""
        match self:
            case Unreliable: "Unreliable transfer (UDP-like, fast)"
            case UnreliableOrdered: "Unreliable ordered transfer (ordered but may drop)"
            case Reliable: "Reliable transfer (TCP-like, guaranteed delivery)"

    pub fn is_unreliable(self) -> bool:
        """Check if mode is Unreliable."""
        match self:
            case Unreliable: true
            case _: false

    pub fn is_unreliable_ordered(self) -> bool:
        """Check if mode is UnreliableOrdered."""
        match self:
            case UnreliableOrdered: true
            case _: false

    pub fn is_reliable(self) -> bool:
        """Check if mode is Reliable."""
        match self:
            case Reliable: true
            case _: false

    pub fn guarantees_delivery(self) -> bool:
        """Check if mode guarantees delivery."""
        match self:
            case Reliable: true
            case _: false

    pub fn is_ordered(self) -> bool:
        """Check if mode preserves order."""
        match self:
            case UnreliableOrdered: true
            case Reliable: true
            case _: false

    pub fn is_fast(self) -> bool:
        """Check if mode prioritizes speed."""
        match self:
            case Unreliable: true
            case UnreliableOrdered: true
            case _: false

    pub fn summary(self) -> String:
        """Get transfer mode summary."""
        let name = self.to_string()
        let desc = self.description()
        let mut props = []
        if self.guarantees_delivery():
            props.push("guaranteed")
        if self.is_ordered():
            props.push("ordered")
        if self.is_fast():
            props.push("fast")
        let props_str = if props.len() > 0: ", {props.join(', ')}" else: ""
        return "TransferMode: {name} ({desc}{props_str})"


# Array placeholders
pub struct Array[T]:
    items: Vec[T]

impl[T] Array[T]:
    pub fn push(mut self, item: T):
        pass

    pub fn len(self) -> i32:
        return 0

    pub fn clear(mut self):
        pass
