# HTTP Response Builder
#
# Fluent API for building HTTP responses.

use units.net.*
use units.size.*
use host.async_nogc_mut.net.tcp.TcpStream
use host.common.io.error.IoError
use web.http.request.HttpError

# HTTP Status Codes
pub enum StatusCode:
    # 2xx Success
    Ok
    Created
    Accepted
    NoContent

    # 3xx Redirect
    MovedPermanently
    Found
    SeeOther
    NotModified
    TemporaryRedirect
    PermanentRedirect

    # 4xx Client Error
    BadRequest
    Unauthorized
    Forbidden
    NotFound
    MethodNotAllowed
    Conflict
    Gone
    UnprocessableEntity
    TooManyRequests

    # 5xx Server Error
    InternalServerError
    NotImplemented
    BadGateway
    ServiceUnavailable
    GatewayTimeout

impl StatusCode:
    pub fn code(self) -> u16:
        match self:
            case Ok: 200
            case Created: 201
            case Accepted: 202
            case NoContent: 204
            case MovedPermanently: 301
            case Found: 302
            case SeeOther: 303
            case NotModified: 304
            case TemporaryRedirect: 307
            case PermanentRedirect: 308
            case BadRequest: 400
            case Unauthorized: 401
            case Forbidden: 403
            case NotFound: 404
            case MethodNotAllowed: 405
            case Conflict: 409
            case Gone: 410
            case UnprocessableEntity: 422
            case TooManyRequests: 429
            case InternalServerError: 500
            case NotImplemented: 501
            case BadGateway: 502
            case ServiceUnavailable: 503
            case GatewayTimeout: 504

    pub fn reason(self) -> &str:
        match self:
            case Ok: "OK"
            case Created: "Created"
            case Accepted: "Accepted"
            case NoContent: "No Content"
            case MovedPermanently: "Moved Permanently"
            case Found: "Found"
            case SeeOther: "See Other"
            case NotModified: "Not Modified"
            case TemporaryRedirect: "Temporary Redirect"
            case PermanentRedirect: "Permanent Redirect"
            case BadRequest: "Bad Request"
            case Unauthorized: "Unauthorized"
            case Forbidden: "Forbidden"
            case NotFound: "Not Found"
            case MethodNotAllowed: "Method Not Allowed"
            case Conflict: "Conflict"
            case Gone: "Gone"
            case UnprocessableEntity: "Unprocessable Entity"
            case TooManyRequests: "Too Many Requests"
            case InternalServerError: "Internal Server Error"
            case NotImplemented: "Not Implemented"
            case BadGateway: "Bad Gateway"
            case ServiceUnavailable: "Service Unavailable"
            case GatewayTimeout: "Gateway Timeout"

    pub fn is_success(self) -> bool:
        let c = self.code()
        return c >= 200 and c < 300

    pub fn is_redirect(self) -> bool:
        let c = self.code()
        return c >= 300 and c < 400

    pub fn is_client_error(self) -> bool:
        let c = self.code()
        return c >= 400 and c < 500

    pub fn is_server_error(self) -> bool:
        let c = self.code()
        return c >= 500 and c < 600

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn is_informational(self) -> bool:
        """Check if status is informational (1xx).

        Returns:
            true if 1xx status

        Example:
            StatusCode::Ok.is_informational()  # → false
        """
        let c = self.code()
        return c >= 100 and c < 200

    pub fn is_error(self) -> bool:
        """Check if status is any error (4xx or 5xx).

        Returns:
            true if error status

        Example:
            StatusCode::NotFound.is_error()  # → true
        """
        self.is_client_error() or self.is_server_error()

    pub fn is_ok(self) -> bool:
        """Check if status is 200 OK.

        Returns:
            true if 200 OK

        Example:
            StatusCode::Ok.is_ok()  # → true
        """
        match self:
            case Ok: true
            case _: false

    pub fn is_not_found(self) -> bool:
        """Check if status is 404 Not Found.

        Returns:
            true if 404

        Example:
            StatusCode::NotFound.is_not_found()  # → true
        """
        match self:
            case NotFound: true
            case _: false

    pub fn is_unauthorized(self) -> bool:
        """Check if status is 401 Unauthorized.

        Returns:
            true if 401

        Example:
            StatusCode::Unauthorized.is_unauthorized()  # → true
        """
        match self:
            case Unauthorized: true
            case _: false

    pub fn is_forbidden(self) -> bool:
        """Check if status is 403 Forbidden.

        Returns:
            true if 403

        Example:
            StatusCode::Forbidden.is_forbidden()  # → true
        """
        match self:
            case Forbidden: true
            case _: false

    pub fn requires_body(self) -> bool:
        """Check if status typically requires response body.

        Returns:
            true if body expected

        Example:
            StatusCode::Ok.requires_body()  # → true
            StatusCode::NoContent.requires_body()  # → false
        """
        match self:
            case NoContent | NotModified: false
            case _: true

    pub fn allows_redirect(self) -> bool:
        """Check if status is a redirect.

        Returns:
            true if redirect status

        Example:
            StatusCode::Found.allows_redirect()  # → true
        """
        self.is_redirect()

    pub fn category(self) -> &str:
        """Get status category name.

        Returns:
            Category string

        Example:
            StatusCode::Ok.category()  # → "Success"
        """
        let c = self.code()
        if c >= 100 and c < 200:
            return "Informational"
        if c >= 200 and c < 300:
            return "Success"
        if c >= 300 and c < 400:
            return "Redirect"
        if c >= 400 and c < 500:
            return "Client Error"
        if c >= 500 and c < 600:
            return "Server Error"
        return "Unknown"

    fn to_string() -> String:
        """Convert status code to string.

        Returns:
            Status code as string

        Example:
            StatusCode::Ok.to_string()  # → "200"
        """
        self.code().to_string()

    fn description() -> String:
        """Get status code description.

        Returns:
            Human-readable description

        Example:
            StatusCode::NotFound.description()
            # → "Resource not found (client error)"
        """
        match self:
            case Ok: "Request successful"
            case Created: "Resource successfully created"
            case Accepted: "Request accepted for processing"
            case NoContent: "Request successful, no content to return"
            case MovedPermanently: "Resource permanently moved to new URL"
            case Found: "Resource temporarily at different URL"
            case SeeOther: "See other resource for result"
            case NotModified: "Resource not modified since last request"
            case TemporaryRedirect: "Temporary redirect (preserve method)"
            case PermanentRedirect: "Permanent redirect (preserve method)"
            case BadRequest: "Malformed or invalid request"
            case Unauthorized: "Authentication required"
            case Forbidden: "Access denied (insufficient permissions)"
            case NotFound: "Resource not found"
            case MethodNotAllowed: "HTTP method not allowed for this resource"
            case Conflict: "Request conflicts with current state"
            case Gone: "Resource permanently deleted"
            case UnprocessableEntity: "Request semantically invalid"
            case TooManyRequests: "Rate limit exceeded"
            case InternalServerError: "Server encountered an error"
            case NotImplemented: "Server does not support this feature"
            case BadGateway: "Invalid response from upstream server"
            case ServiceUnavailable: "Server temporarily unavailable"
            case GatewayTimeout: "Upstream server timeout"

    pub fn summary(self) -> str:
        """Get summary of status code.

        Returns:
            Human-readable summary

        Example:
            StatusCode::Ok.summary()
            # → "200 OK (Success)"
        """
        let code = self.code()
        let reason = self.reason()
        let cat = self.category()
        return "{code} {reason} ({cat})"

# HTTP Response
pub struct HttpResponse:
    status: StatusCode
    headers: Dict<str, str>
    body: Option<Bytes>

impl HttpResponse:
    # Create response with status
    pub fn new(status: StatusCode) -> HttpResponse:
        return HttpResponse {
            status: status,
            headers: Dict::new(),
            body: None
        }

    # Common response constructors
    pub fn ok() -> HttpResponse:
        return HttpResponse::new(StatusCode::Ok)

    pub fn created() -> HttpResponse:
        return HttpResponse::new(StatusCode::Created)

    pub fn accepted() -> HttpResponse:
        return HttpResponse::new(StatusCode::Accepted)

    pub fn no_content() -> HttpResponse:
        return HttpResponse::new(StatusCode::NoContent)

    pub fn bad_request() -> HttpResponse:
        return HttpResponse::new(StatusCode::BadRequest)

    pub fn unauthorized() -> HttpResponse:
        return HttpResponse::new(StatusCode::Unauthorized)

    pub fn forbidden() -> HttpResponse:
        return HttpResponse::new(StatusCode::Forbidden)

    pub fn not_found() -> HttpResponse:
        return HttpResponse::new(StatusCode::NotFound)

    pub fn method_not_allowed() -> HttpResponse:
        return HttpResponse::new(StatusCode::MethodNotAllowed)

    pub fn internal_error() -> HttpResponse:
        return HttpResponse::new(StatusCode::InternalServerError)

    # Redirect helpers
    pub fn redirect(location: &str) -> HttpResponse:
        return HttpResponse::new(StatusCode::Found)
            .header("Location", location)

    pub fn redirect_permanent(location: &str) -> HttpResponse:
        return HttpResponse::new(StatusCode::MovedPermanently)
            .header("Location", location)

    pub fn redirect_see_other(location: &str) -> HttpResponse:
        return HttpResponse::new(StatusCode::SeeOther)
            .header("Location", location)

    # Builder methods (fluent API)
    pub fn status(self, status: StatusCode) -> HttpResponse:
        self.status = status
        return self

    pub fn header(self, name: &str, value: &str) -> HttpResponse:
        self.headers.insert(name.to_string(), value.to_string())
        return self

    pub fn content_type(self, mime: &str) -> HttpResponse:
        return self.header("Content-Type", mime)

    pub fn cache_control(self, value: &str) -> HttpResponse:
        return self.header("Cache-Control", value)

    pub fn no_cache(self) -> HttpResponse:
        return self.cache_control("no-cache, no-store, must-revalidate")

    # Body setters
    pub fn body(self, data: Bytes) -> HttpResponse:
        self.body = Some(data)
        return self

    pub fn text(self, text: &str) -> HttpResponse:
        return self
            .content_type("text/plain; charset=utf-8")
            .body(text.as_bytes().to_vec())

    pub fn html(self, html: &str) -> HttpResponse:
        return self
            .content_type("text/html; charset=utf-8")
            .body(html.as_bytes().to_vec())

    pub fn json_str(self, json: &str) -> HttpResponse:
        return self
            .content_type("application/json")
            .body(json.as_bytes().to_vec())

    pub fn css(self, css: &str) -> HttpResponse:
        return self
            .content_type("text/css; charset=utf-8")
            .body(css.as_bytes().to_vec())

    pub fn js(self, js: &str) -> HttpResponse:
        return self
            .content_type("application/javascript; charset=utf-8")
            .body(js.as_bytes().to_vec())

    # Accessors
    pub fn get_status(self) -> StatusCode:
        return self.status

    pub fn get_header(self, name: &str) -> Option<&str>:
        return self.headers.get(name)

    pub fn get_body(self) -> Option<&Bytes>:
        return self.body.as_ref()

    # Serialize response to bytes
    pub fn to_bytes(self) -> Bytes:
        let mut buf = String::new()

        # Status line
        buf.push_str(&"HTTP/1.1 {self.status.code()} {self.status.reason()}\r\n")

        # Headers
        for (name, value) in &self.headers:
            buf.push_str(&"{name}: {value}\r\n")

        # Content-Length if body present
        if let Some(body) = &self.body:
            buf.push_str(&"Content-Length: {body.len()}\r\n")
        else:
            buf.push_str("Content-Length: 0\r\n")

        # End headers
        buf.push_str("\r\n")

        # Convert header to bytes
        let mut result = buf.as_bytes().to_vec()

        # Append body
        if let Some(body) = &self.body:
            result.extend(body)

        return result

    # Send response to TCP stream
    pub async fn send(self, stream: &TcpStream) -> Result<(), IoError>:
        let bytes = self.to_bytes()
        await stream.write_all(&bytes)?
        await stream.flush()?
        return Ok(())

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_body(self) -> bool:
        """Check if response has body.

        Returns:
            true if body present

        Example:
            response.has_body()  # → true
        """
        self.body.is_some()

    pub fn has_header(self, name: &str) -> bool:
        """Check if header exists.

        Args:
            name: Header name

        Returns:
            true if header exists

        Example:
            response.has_header("Content-Type")  # → true
        """
        self.headers.contains_key(name)

    pub fn is_success(self) -> bool:
        """Check if response is successful (2xx).

        Returns:
            true if success status

        Example:
            response.is_success()  # → true
        """
        self.status.is_success()

    pub fn is_error(self) -> bool:
        """Check if response is error (4xx or 5xx).

        Returns:
            true if error status

        Example:
            response.is_error()  # → false
        """
        self.status.is_error()

    pub fn is_redirect(self) -> bool:
        """Check if response is redirect (3xx).

        Returns:
            true if redirect status

        Example:
            response.is_redirect()  # → false
        """
        self.status.is_redirect()

    pub fn get_content_type(self) -> Option<&str>:
        """Get Content-Type header.

        Returns:
            Content type

        Example:
            response.get_content_type()  # → Some("text/html")
        """
        self.get_header("Content-Type")

    pub fn get_location(self) -> Option<&str>:
        """Get Location header (for redirects).

        Returns:
            Location URL

        Example:
            response.get_location()  # → Some("/login")
        """
        self.get_header("Location")

    pub fn body_len(self) -> usize:
        """Get body length in bytes.

        Returns:
            Body size

        Example:
            response.body_len()  # → 1024
        """
        if let Some(body) = &self.body:
            return body.len()
        return 0

    pub fn header_count(self) -> usize:
        """Get number of headers.

        Returns:
            Header count

        Example:
            response.header_count()  # → 5
        """
        self.headers.len()

    pub fn is_json(self) -> bool:
        """Check if response content type is JSON.

        Returns:
            true if JSON

        Example:
            response.is_json()  # → true
        """
        if let Some(ct) = self.get_content_type():
            return ct.contains("application/json")
        return false

    pub fn is_html(self) -> bool:
        """Check if response content type is HTML.

        Returns:
            true if HTML

        Example:
            response.is_html()  # → true
        """
        if let Some(ct) = self.get_content_type():
            return ct.contains("text/html")
        return false

    pub fn is_text(self) -> bool:
        """Check if response content type is plain text.

        Returns:
            true if plain text

        Example:
            response.is_text()  # → true
        """
        if let Some(ct) = self.get_content_type():
            return ct.contains("text/plain")
        return false

    pub fn with_cors(self, origin: &str) -> HttpResponse:
        """Add CORS headers.

        Args:
            origin: Allowed origin

        Returns:
            self with CORS headers

        Example:
            response.with_cors("*")
        """
        return self
            .header("Access-Control-Allow-Origin", origin)
            .header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
            .header("Access-Control-Allow-Headers", "Content-Type, Authorization")

    pub fn summary(self) -> str:
        """Get summary of HTTP response.

        Returns:
            Human-readable summary

        Example:
            response.summary()
            # → "200 OK (5 headers, 1024 bytes)"
        """
        let status = self.status.summary()
        let headers = self.header_count()
        let body_size = self.body_len()
        return "{status} ({headers} headers, {body_size} bytes)"

# Error response helpers
pub fn error_response(status: StatusCode, message: &str) -> HttpResponse:
    let html = """<!DOCTYPE html>
<html>
<head>
    <title>{status.code()} {status.reason()}</title>
    <style>
        body {{ font-family: system-ui, sans-serif; padding: 40px; text-align: center; }}
        h1 {{ color: #c00; }}
    </style>
</head>
<body>
    <h1>{status.code()} {status.reason()}</h1>
    <p>{message}</p>
</body>
</html>"""
    return HttpResponse::new(status).html(&html)

pub fn not_found_page(path: &str) -> HttpResponse:
    return error_response(StatusCode::NotFound, &"The page '{path}' was not found.")

pub fn server_error_page(message: &str) -> HttpResponse:
    return error_response(StatusCode::InternalServerError, message)
