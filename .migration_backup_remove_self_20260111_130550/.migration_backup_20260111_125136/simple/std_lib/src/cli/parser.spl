# CLI ArgParser - Main argument parser

export ArgParser, simple_parser

use file::{OpenOptions, AsyncFileHandle}
import cli.file as file
import types.{ArgType, ArgSpec}
import parsed_args.ParsedArgs

# Main argument parser
pub struct ArgParser:
    program_name: String
    description: String
    args: Array[ArgSpec]
    auto_stage_files: bool  # Global auto-staging toggle
    async_loading: bool     # Enable background file loading during parse
    mmap_options: OpenOptions  # Options for memory-mapped file I/O

    # =========================================================================
    # Helper Methods
    # =========================================================================

    pub fn has_args(self) -> bool:
        """Check if parser has any argument specs."""
        return self.args.len() > 0

    pub fn is_empty(self) -> bool:
        """Check if parser has no argument specs."""
        return self.args.len() == 0

    pub fn arg_count(self) -> usize:
        """Get number of argument specs."""
        return self.args.len()

    pub fn is_auto_stage_enabled(self) -> bool:
        """Check if auto-staging is enabled."""
        return self.auto_stage_files

    pub fn is_async_loading_enabled(self) -> bool:
        """Check if async loading is enabled."""
        return self.async_loading

    pub fn get_program_name(self) -> String:
        """Get program name."""
        return self.program_name

    pub fn get_description(self) -> String:
        """Get program description."""
        return self.description

    pub fn has_required_args(self) -> bool:
        """Check if parser has any required arguments."""
        for arg in &self.args:
            if arg.required:
                return true
        return false

    pub fn required_arg_count(self) -> usize:
        """Get count of required arguments."""
        let mut count: usize = 0
        for arg in &self.args:
            if arg.required:
                count = count + 1
        return count

    pub fn summary(self) -> String:
        """Get summary of argument parser state."""
        let auto = if self.auto_stage_files: "auto-stage on" else: "auto-stage off"
        let async_mode = if self.async_loading: "async" else: "sync"
        return "ArgParser: '{self.program_name}', {self.arg_count()} args, {auto}, {async_mode}"

    # =========================================================================
    # Constructor
    # =========================================================================

    # Create a new argument parser
    pub fn new(program_name: String, description: String) -> ArgParser:
        return ArgParser {
            program_name: program_name,
            description: description,
            args: [],
            auto_stage_files: true,  # Default: auto-stage enabled
            async_loading: false,    # Default: sync validation only
            mmap_options: OpenOptions::new()  # Default options
        }

    # Disable automatic file staging globally
    pub fn no_auto_stage(mut self) -> ArgParser:
        self.auto_stage_files = false
        return self

    # Enable async file loading (starts loading during argument parsing)
    pub fn with_async_loading(mut self, enable: bool) -> ArgParser:
        self.async_loading = enable
        return self

    # Configure memory-mapped I/O options
    pub fn with_mmap_options(mut self, opts: OpenOptions) -> ArgParser:
        self.mmap_options = opts
        return self

    # Add a boolean flag
    pub fn flag(mut self, name: String, short: String, help: String) -> ArgParser:
        let spec = ArgSpec {
            name: name,
            short: Some(short),
            long: name,
            help: help,
            required: false,
            default_value: None,
            arg_type: ArgType::Flag,
            auto_stage: false,
            must_exist: false,
            must_be_readable: false,
            must_be_writable: false,
            allowed_extensions: []
        }
        self.args.push(spec)
        return self

    # Add a string option
    pub fn option(mut self, name: String, short: String, help: String, required: bool, default: Option[String]) -> ArgParser:
        let spec = ArgSpec {
            name: name,
            short: Some(short),
            long: name,
            help: help,
            required: required,
            default_value: default,
            arg_type: ArgType::Option,
            auto_stage: false,
            must_exist: false,
            must_be_readable: false,
            must_be_writable: false,
            allowed_extensions: []
        }
        self.args.push(spec)
        return self

    # Add a required option
    pub fn required_option(mut self, name: String, short: String, help: String) -> ArgParser:
        return self.option(name, short, help, true, None)

    # Add an optional option with default
    pub fn optional_option(mut self, name: String, short: String, help: String, default: String) -> ArgParser:
        return self.option(name, short, help, false, Some(default))

    # Add a FILE option (automatically staged)
    pub fn file_option(mut self, name: String, short: String, help: String, required: bool, must_exist: bool) -> ArgParser:
        let spec = ArgSpec {
            name: name,
            short: Some(short),
            long: name,
            help: help,
            required: required,
            default_value: None,
            arg_type: ArgType::FileOption,
            auto_stage: true,
            must_exist: must_exist,
            must_be_readable: must_exist,
            must_be_writable: not must_exist,
            allowed_extensions: []
        }
        self.args.push(spec)
        return self

    # Add a file option with custom validation
    pub fn file_option_custom(mut self, name: String, short: String, help: String, required: bool,
                               must_exist: bool, must_be_readable: bool, must_be_writable: bool,
                               extensions: Array[String]) -> ArgParser:
        let spec = ArgSpec {
            name: name,
            short: Some(short),
            long: name,
            help: help,
            required: required,
            default_value: None,
            arg_type: ArgType::FileOption,
            auto_stage: true,
            must_exist: must_exist,
            must_be_readable: must_be_readable,
            must_be_writable: must_be_writable,
            allowed_extensions: extensions
        }
        self.args.push(spec)
        return self

    # Add a file positional (automatically staged)
    pub fn file_positional(mut self, name: String, help: String, required: bool) -> ArgParser:
        let spec = ArgSpec {
            name: name,
            short: None,
            long: name,
            help: help,
            required: required,
            default_value: None,
            arg_type: ArgType::FilePositional,
            auto_stage: true,
            must_exist: true,
            must_be_readable: true,
            must_be_writable: false,
            allowed_extensions: []
        }
        self.args.push(spec)
        return self

    # Add a positional argument (non-file)
    pub fn positional(mut self, name: String, help: String, required: bool) -> ArgParser:
        let spec = ArgSpec {
            name: name,
            short: None,
            long: name,
            help: help,
            required: required,
            default_value: None,
            arg_type: ArgType::Positional,
            auto_stage: false,
            must_exist: false,
            must_be_readable: false,
            must_be_writable: false,
            allowed_extensions: []
        }
        self.args.push(spec)
        return self

    # Add a required positional
    pub fn required_positional(mut self, name: String, help: String) -> ArgParser:
        return self.positional(name, help, true)

    # Parse command-line arguments with automatic file staging
    pub fn parse(self, args: Array[String]) -> Result[ParsedArgs, String]:
        let mut flags: Dict[String, bool] = {}
        let mut options: Dict[String, String] = {}
        let mut positionals: Array[String] = []
        let mut file_paths: Array[String] = []

        let mut i = 0
        while i < args.len():
            let arg = args[i]

            if arg == "--help" or arg == "-h":
                self.print_help()
                return Ok(ParsedArgs {
                    flags: flags,
                    options: options,
                    positionals: positionals,
                    files: file.StagedFiles { files: [], handles: [], errors: [] }
                })

            if arg.starts_with("--"):
                let processed = false

                if arg.contains("="):
                    let parts = arg.split("=")
                    if parts.len() == 2:
                        let name = parts[0].trim_start_matches("--")
                        let value = parts[1]

                        let mut found = false
                        for spec in self.args:
                            if spec.long == name:
                                match spec.arg_type:
                                    case ArgType::Flag:
                                        return Err("Flag --{name} does not take a value")
                                    case ArgType::Option:
                                        options.insert(name, value)
                                        found = true
                                    case ArgType::FileOption:
                                        options.insert(name, value)
                                        if spec.auto_stage and self.auto_stage_files:
                                            file_paths.push(value)
                                        found = true
                                    case _:
                                        pass

                        if not found:
                            return Err("Unknown option: --{name}")
                        processed = true

                if not processed:
                    let name = arg.trim_start_matches("--")
                    let mut found = false

                    for spec in self.args:
                        if spec.long == name:
                            match spec.arg_type:
                                case ArgType::Flag:
                                    flags.insert(name, true)
                                    found = true
                                case ArgType::Option:
                                    if i + 1 < args.len():
                                        i = i + 1
                                        options.insert(name, args[i])
                                        found = true
                                    else:
                                        return Err("Option --{name} requires a value")
                                case ArgType::FileOption:
                                    if i + 1 < args.len():
                                        i = i + 1
                                        let value = args[i]
                                        options.insert(name, value)
                                        if spec.auto_stage and self.auto_stage_files:
                                            file_paths.push(value)
                                        found = true
                                    else:
                                        return Err("Option --{name} requires a value")
                                case _:
                                    pass

                    if not found:
                        return Err("Unknown option: --{name}")

            else:
                if arg.starts_with("-") and arg.len() > 1:
                    let short = arg[1..2]
                    let mut found = false

                    for spec in self.args:
                        if spec.short.is_some() and spec.short.unwrap() == short:
                            match spec.arg_type:
                                case ArgType::Flag:
                                    flags.insert(spec.name, true)
                                    found = true
                                case ArgType::Option:
                                    if i + 1 < args.len():
                                        i = i + 1
                                        options.insert(spec.name, args[i])
                                        found = true
                                    else:
                                        return Err("Option -{short} requires a value")
                                case ArgType::FileOption:
                                    if i + 1 < args.len():
                                        i = i + 1
                                        let value = args[i]
                                        options.insert(spec.name, value)
                                        if spec.auto_stage and self.auto_stage_files:
                                            file_paths.push(value)
                                        found = true
                                    else:
                                        return Err("Option -{short} requires a value")
                                case _:
                                    pass

                    if not found:
                        return Err("Unknown option: -{short}")
                else:
                    positionals.push(arg)
                    if self.auto_stage_files:
                        file_paths.push(arg)

            i = i + 1

        # Apply defaults
        for spec in self.args:
            match spec.arg_type:
                case ArgType::Option:
                    if not options.contains_key(spec.name):
                        if spec.default_value.is_some():
                            options.insert(spec.name, spec.default_value.unwrap())
                        else:
                            if spec.required:
                                return Err("Required option --{spec.name} not provided")
                case _:
                    pass

        # Check required positionals
        let mut required_positional_count = 0
        for spec in self.args:
            match spec.arg_type:
                case ArgType::Positional:
                    if spec.required:
                        required_positional_count = required_positional_count + 1
                case ArgType::FilePositional:
                    if spec.required:
                        required_positional_count = required_positional_count + 1
                case _:
                    pass

        if positionals.len() < required_positional_count:
            return Err("Expected at least {required_positional_count} positional arguments, got {positionals.len()}")

        let staged_files = self.stage_files(file_paths)

        if staged_files.has_errors():
            let error_msg = "File validation errors:"
            for err in staged_files.get_errors():
                error_msg = "{error_msg}\n  - {err}"
            return Err(error_msg)

        return Ok(ParsedArgs {
            flags: flags,
            options: options,
            positionals: positionals,
            files: staged_files
        })

    # Stage files with validation
    fn stage_files(paths: Array[String]) -> file.StagedFiles:
        let mut all_files: Array[file.FileInfo] = []
        let mut all_handles: Array[file.AsyncFileHandle] = []
        let mut all_errors: Array[String] = []

        for path in paths:
            let validator = self.get_validator_for_path(path)

            match validator.validate(path):
                case Ok(info):
                    all_files.push(info)
                    if self.async_loading:
                        let handle = AsyncFileHandle::with_options(info.path, self.mmap_options)
                        handle.start_loading()
                        all_handles.push(handle)
                case Err(error):
                    all_errors.push(error)

        return file.StagedFiles {
            files: all_files,
            handles: all_handles,
            errors: all_errors
        }

    # Get validator for a file path based on arg specs
    fn get_validator_for_path(path: String) -> file.FileValidator:
        for spec in self.args:
            match spec.arg_type:
                case ArgType::FileOption:
                    let mut validator = file.FileValidator::new()
                    if spec.must_exist:
                        validator = validator.require_exists()
                    if spec.must_be_readable:
                        validator = validator.require_readable()
                    if spec.must_be_writable:
                        validator = validator.require_writable()
                    if spec.allowed_extensions.len() > 0:
                        validator = validator.with_extensions(spec.allowed_extensions)
                    return validator

                case ArgType::FilePositional:
                    let mut validator = file.FileValidator::new()
                    if spec.must_exist:
                        validator = validator.require_exists()
                    if spec.must_be_readable:
                        validator = validator.require_readable()
                    return validator

                case _:
                    pass

        return file.FileValidator::new().require_exists()

    # Print help message
    pub fn print_help(self):
        print("{self.program_name} - {self.description}")
        print("")
        print("USAGE:")

        let mut usage = "    {self.program_name}"

        for spec in self.args:
            match spec.arg_type:
                case ArgType::Flag:
                    if spec.short.is_some():
                        usage = "{usage} [-{spec.short.unwrap()}|--{spec.long}]"
                    else:
                        usage = "{usage} [--{spec.long}]"

                case ArgType::Option:
                    let opt_str = ""
                    if spec.short.is_some():
                        opt_str = "-{spec.short.unwrap()}|--{spec.long} <{spec.name}>"
                    else:
                        opt_str = "--{spec.long} <{spec.name}>"
                    if spec.required:
                        usage = "{usage} {opt_str}"
                    else:
                        usage = "{usage} [{opt_str}]"

                case ArgType::FileOption:
                    let opt_str = ""
                    if spec.short.is_some():
                        opt_str = "-{spec.short.unwrap()}|--{spec.long} <file>"
                    else:
                        opt_str = "--{spec.long} <file>"
                    if spec.required:
                        usage = "{usage} {opt_str}"
                    else:
                        usage = "{usage} [{opt_str}]"

                case ArgType::Positional:
                    if spec.required:
                        usage = "{usage} <{spec.name}>"
                    else:
                        usage = "{usage} [<{spec.name}>]"

                case ArgType::FilePositional:
                    if spec.required:
                        usage = "{usage} <file>"
                    else:
                        usage = "{usage} [<file>...]"

        print(usage)
        print("")
        print("OPTIONS:")

        for spec in self.args:
            match spec.arg_type:
                case ArgType::Flag:
                    if spec.short.is_some():
                        print("    -{spec.short.unwrap()}, --{spec.long:<20} {spec.help}")
                    else:
                        print("        --{spec.long:<20} {spec.help}")
                case _:
                    pass

        for spec in self.args:
            match spec.arg_type:
                case ArgType::Option:
                    let opt_name = "--{spec.long} <{spec.name}>"
                    if spec.short.is_some():
                        print("    -{spec.short.unwrap()}, {opt_name:<20} {spec.help}")
                    else:
                        print("        {opt_name:<20} {spec.help}")
                    if spec.default_value.is_some():
                        print("        {'':24} [default: {spec.default_value.unwrap()}]")
                    if spec.required:
                        print("        {'':24} [required]")

                case ArgType::FileOption:
                    let opt_name = "--{spec.long} <file>"
                    if spec.short.is_some():
                        print("    -{spec.short.unwrap()}, {opt_name:<20} {spec.help}")
                    else:
                        print("        {opt_name:<20} {spec.help}")
                    if spec.must_exist:
                        print("        {'':24} [must exist]")
                    if spec.required:
                        print("        {'':24} [required]")

                case _:
                    pass

        if self.has_positionals():
            print("")
            print("ARGS:")
            for spec in self.args:
                match spec.arg_type:
                    case ArgType::Positional:
                        print("    <{spec.name}>    {spec.help}")
                        if spec.required:
                            print("        {'':12} [required]")
                    case ArgType::FilePositional:
                        print("    <file>...    {spec.help}")
                        if spec.must_exist:
                            print("        {'':12} [files must exist]")
                    case _:
                        pass

        print("")
        print("    -h, --help               Print this help message")

    fn has_positionals() -> bool:
        for spec in self.args:
            match spec.arg_type:
                case ArgType::Positional:
                    return true
                case ArgType::FilePositional:
                    return true
                case _:
                    pass
        return false

# Helper function
pub fn simple_parser(program_name: String, description: String) -> ArgParser:
    return ArgParser::new(program_name, description)
