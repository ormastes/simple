# Multi-Language Test Runner
# Run tests across all languages in a project

use tooling.core.project.{Language, ProjectContext, LanguageConfig}
use tooling.testing.discovery.{TestDiscovery, TestSuite}
use tooling.testing.aggregation.TestAggregator
use core.result.{Result, Ok, Err}

# Extern declaration for time FFI
extern fn rt_time_now_seconds() -> Float

# Test run configuration
pub class TestConfig:
    pub parallel: bool
    pub fail_fast: bool
    pub verbose: bool
    pub coverage: bool
    pub timeout_seconds: i32
    pub filter_pattern: String

    pub fn new(): TestConfig =
        """Create default test configuration.

        Returns:
            Default test config
        """
        TestConfig {
            parallel: false,
            fail_fast: false,
            verbose: false,
            coverage: false,
            timeout_seconds: 300,  # 5 minutes
            filter_pattern: ""
        }

    pub fn with_parallel(self, enabled: bool): TestConfig =
        """Set parallel execution (fluent API).

        Args:
            enabled: True to run tests in parallel

        Returns:
            Modified config
        """
        self.parallel = enabled
        self

    pub fn with_fail_fast(self, enabled: bool): TestConfig =
        """Set fail-fast mode (fluent API).

        Args:
            enabled: True to stop on first failure

        Returns:
            Modified config
        """
        self.fail_fast = enabled
        self

    pub fn with_verbose(self, enabled: bool): TestConfig =
        """Set verbose output (fluent API).

        Args:
            enabled: True for detailed logs

        Returns:
            Modified config
        """
        self.verbose = enabled
        self

    pub fn with_coverage(self, enabled: bool): TestConfig =
        """Set coverage collection (fluent API).

        Args:
            enabled: True to collect coverage

        Returns:
            Modified config
        """
        self.coverage = enabled
        self

    pub fn with_timeout(self, seconds: i32): TestConfig =
        """Set timeout (fluent API).

        Args:
            seconds: Timeout in seconds

        Returns:
            Modified config
        """
        self.timeout_seconds = seconds
        self

    pub fn with_filter(self, pattern: String): TestConfig =
        """Set filter pattern (fluent API).

        Args:
            pattern: Filter pattern

        Returns:
            Modified config
        """
        self.filter_pattern = pattern
        self

    pub fn is_parallel(self): bool =
        """Check if parallel execution enabled.

        Returns:
            True if parallel
        """
        self.parallel

    pub fn has_filter(self): bool =
        """Check if filter is set.

        Returns:
            True if filter pattern exists
        """
        self.filter_pattern != ""

# Test run result
pub class TestRunResult:
    pub total_tests: i32
    pub passed: i32
    pub failed: i32
    pub skipped: i32
    pub duration_ms: i64
    pub failures: List[TestFailure]

    pub fn new(): TestRunResult =
        """Create empty test result."""
        TestRunResult {
            total_tests: 0,
            passed: 0,
            failed: 0,
            skipped: 0,
            duration_ms: 0,
            failures: []
        }

    pub fn is_success(self): bool =
        """Check if all tests passed.

        Returns:
            True if no failures
        """
        self.failed == 0

    pub fn summary(self): String =
        """Get result summary.

        Returns:
            Human-readable summary
        """
        if self.is_success():
            "✓ {self.passed}/{self.total_tests} tests passed in {self.duration_ms}ms"
        else:
            "✗ {self.failed}/{self.total_tests} tests failed, {self.passed} passed, {self.skipped} skipped"

    pub fn pass_rate(self): f64 =
        """Get pass rate as percentage.

        Returns:
            Pass rate (0.0 to 100.0)

        Example:
            result.pass_rate()  # → 85.5 (85.5% of tests passed)
        """
        if self.total_tests == 0:
            return 0.0
        ((self.passed as f64) / (self.total_tests as f64)) * 100.0

    pub fn failure_rate(self): f64 =
        """Get failure rate as percentage.

        Returns:
            Failure rate (0.0 to 100.0)
        """
        if self.total_tests == 0:
            return 0.0
        ((self.failed as f64) / (self.total_tests as f64)) * 100.0

    pub fn duration_seconds(self): f64 =
        """Get duration in seconds.

        Returns:
            Duration in seconds
        """
        (self.duration_ms as f64) / 1000.0

    pub fn has_failures(self): bool =
        """Check if there are test failures.

        Returns:
            True if any tests failed
        """
        self.failed > 0

    pub fn has_skipped(self): bool =
        """Check if there are skipped tests.

        Returns:
            True if any tests skipped
        """
        self.skipped > 0

    pub fn get_failure_count(self): i32 =
        """Get number of failures.

        Returns:
            Failure count
        """
        self.failures.len()

# Test failure
pub class TestFailure:
    pub test_name: String
    pub language: Language
    pub error_message: String
    pub file: String
    pub line: i32

    pub fn new(
        test_name: String,
        language: Language,
        error_message: String
    ): TestFailure =
        """Create test failure.

        Args:
            test_name: Name of failed test
            language: Test language
            error_message: Failure message

        Returns:
            Test failure instance
        """
        TestFailure {
            test_name: test_name,
            language: language,
            error_message: error_message,
            file: "",
            line: 0
        }

    pub fn format(self): String =
        """Format failure for display.

        Returns:
            Formatted failure string

        Example:
            failure.format()
            # → "test_user_login failed: Expected 200, got 404"
        """
        "{self.test_name} failed: {self.error_message}"

    pub fn format_with_location(self): String =
        """Format failure with file location.

        Returns:
            Formatted failure with location

        Example:
            failure.format_with_location()
            # → "test_user_login (src/auth_test.spl:42): Expected 200, got 404"
        """
        if self.file != "" and self.line > 0:
            "{self.test_name} ({self.file}:{self.line}): {self.error_message}"
        else:
            self.format()

    pub fn has_location(self): bool =
        """Check if failure has location information.

        Returns:
            True if file and line are set
        """
        self.file != "" and self.line > 0

# Multi-language test runner
pub class TestRunner:
    pub project: ProjectContext
    pub config: TestConfig
    pub discovery: TestDiscovery

    pub fn new(root: String): TestRunner =
        """Create test runner for project.

        Args:
            root: Project root directory

        Returns:
            Test runner with auto-detected test suites

        Example:
            let runner = TestRunner.new(".")

            let result = runner.run_all(
                parallel: true,
                verbose: true
            )

            print(result.summary())
        """
        let project = ProjectContext.new(root)
        let discovery = TestDiscovery.new(root)

        TestRunner {
            project: project,
            config: TestConfig.new(),
            discovery: discovery
        }

    pub fn set_parallel(self, enabled: bool):
        """Enable parallel test execution.

        Args:
            enabled: True to run tests in parallel
        """
        self.config.parallel = enabled

    pub fn set_fail_fast(self, enabled: bool):
        """Enable fail-fast mode.

        Args:
            enabled: True to stop on first failure
        """
        self.config.fail_fast = enabled

    pub fn set_verbose(self, enabled: bool):
        """Enable verbose output.

        Args:
            enabled: True for detailed logs
        """
        self.config.verbose = enabled

    pub fn set_coverage(self, enabled: bool):
        """Enable coverage collection.

        Args:
            enabled: True to collect coverage
        """
        self.config.coverage = enabled

    pub fn discover_tests(self): List[TestSuite] =
        """Discover all test suites in project.

        Returns:
            List of test suites

        Example:
            let runner = TestRunner.new(".")
            let suites = runner.discover_tests()

            for suite in suites:
                print("{suite.language}: {suite.test_count} tests")
        """
        self.discovery.discover_all()

    pub fn run_all(
        self,
        parallel: bool,
        fail_fast: bool,
        verbose: bool
    ): TestRunResult =
        """Run all tests in project.

        Args:
            parallel: Run tests in parallel
            fail_fast: Stop on first failure
            verbose: Enable verbose output

        Returns:
            Test run result

        Example:
            let result = runner.run_all(
                parallel: true,
                fail_fast: false,
                verbose: true
            )

            if result.is_success():
                print("All tests passed!")
            else:
                for failure in result.failures:
                    print("Failed: {failure.test_name}")
                    print("  {failure.error_message}")
        """
        self.config.parallel = parallel
        self.config.fail_fast = fail_fast
        self.config.verbose = verbose

        let result = TestRunResult.new()
        let start_time = self.get_time_ms()

        if verbose:
            print("Running tests...")

        # Discover test suites
        let suites = self.discover_tests()

        if verbose:
            print("Found {suites.len()} test suites")

        # Run each test suite
        for suite in suites:
            if verbose:
                print("Running {suite.language} tests...")

            let suite_result = self.run_suite(suite)

            # Aggregate results
            result.total_tests += suite_result.total_tests
            result.passed += suite_result.passed
            result.failed += suite_result.failed
            result.skipped += suite_result.skipped
            result.failures.extend(suite_result.failures)

            # Fail fast
            if fail_fast and suite_result.failed > 0:
                break

        let end_time = self.get_time_ms()
        result.duration_ms = end_time - start_time

        if verbose:
            print(result.summary())

        result

    fn get_time_ms(self): i64 =
        """Get current time in milliseconds.

        Returns:
            Current timestamp in milliseconds
        """
        # Convert seconds to milliseconds
        (rt_time_now_seconds() * 1000.0) as i64

    fn run_suite(self, suite: TestSuite): TestRunResult =
        """Run single test suite.

        Args:
            suite: Test suite to run

        Returns:
            Test result for suite
        """
        match suite.language:
            Language::Simple:
                self.run_simple_tests(suite)
            Language::Rust:
                self.run_rust_tests(suite)
            Language::Python:
                self.run_python_tests(suite)
            Language::JavaScript:
                self.run_javascript_tests(suite)
            Language::TypeScript:
                self.run_javascript_tests(suite)  # Same runner
            _:
                # Unsupported language
                TestRunResult.new()

    fn run_simple_tests(self, suite: TestSuite): TestRunResult =
        """Run Simple language tests.

        Args:
            suite: Test suite

        Returns:
            Test result
        """
        let result = TestRunResult.new()

        # TODO: [stdlib][P2] Execute Simple spec framework tests
        # Stub implementation - returns success for discovered tests
        result.total_tests = suite.test_count
        result.passed = suite.test_count
        result.failed = 0
        result.skipped = 0

        result

    fn run_rust_tests(self, suite: TestSuite): TestRunResult =
        """Run Rust tests via cargo test.

        Args:
            suite: Test suite

        Returns:
            Test result
        """
        let result = TestRunResult.new()

        # TODO: [stdlib][P2] Execute process and parse output
        # Command: cargo test --manifest-path {suite.path}
        # For now, return stub result
        result.total_tests = 0
        result.passed = 0
        result.failed = 0
        result.skipped = 0

        result

    fn run_python_tests(self, suite: TestSuite): TestRunResult =
        """Run Python tests via pytest.

        Args:
            suite: Test suite

        Returns:
            Test result
        """
        let result = TestRunResult.new()

        # TODO: [stdlib][P2] Execute process and parse JSON output
        # Command: pytest {suite.path} --json-report
        # For now, return stub result
        result.total_tests = suite.test_count
        result.passed = suite.test_count
        result.failed = 0
        result.skipped = 0

        result

    fn run_javascript_tests(self, suite: TestSuite): TestRunResult =
        """Run JavaScript tests via jest.

        Args:
            suite: Test suite

        Returns:
            Test result
        """
        let result = TestRunResult.new()

        # TODO: [stdlib][P2] Execute process and parse JSON output
        # Command: jest {suite.path} --json
        # For now, return stub result
        result.total_tests = suite.test_count
        result.passed = suite.test_count
        result.failed = 0
        result.skipped = 0

        result

    pub fn run_by_language(self, language: Language): TestRunResult =
        """Run tests for specific language.

        Args:
            language: Language to run tests for

        Returns:
            Test result
        """
        let suites = self.discovery.discover_by_language(language)
        let result = TestRunResult.new()

        for suite in suites:
            let suite_result = self.run_suite(suite)

            result.total_tests += suite_result.total_tests
            result.passed += suite_result.passed
            result.failed += suite_result.failed
            result.skipped += suite_result.skipped
            result.failures.extend(suite_result.failures)

        result

    pub fn run_by_pattern(self, pattern: String): TestRunResult =
        """Run tests matching pattern.

        Args:
            pattern: Test name pattern

        Returns:
            Test result
        """
        let suites = self.discovery.discover_by_pattern(pattern)
        let result = TestRunResult.new()

        for suite in suites:
            let suite_result = self.run_suite(suite)

            result.total_tests += suite_result.total_tests
            result.passed += suite_result.passed
            result.failed += suite_result.failed
            result.skipped += suite_result.skipped
            result.failures.extend(suite_result.failures)

        result
