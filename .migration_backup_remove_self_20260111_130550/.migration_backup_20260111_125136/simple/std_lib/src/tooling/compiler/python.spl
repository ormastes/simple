# Python Compiler Adapter
# Integrates Python compilation (bytecode + type checking) with tooling framework

use tooling.core.project.{Language, LanguageConfig}
use tooling.compiler.interface.{
    LanguageCompiler,
    CompilationMode,
    CompilationResult,
    Artifact,
    ArtifactType,
    CompilationError,
    ErrorSeverity
}

# Python compiler adapter (uses py_compile + mypy)
pub class PythonCompiler:
    pub python_path: String
    pub mypy_path: String
    pub run_type_checker: bool
    pub byte_compile: bool

    pub fn new(): PythonCompiler =
        """Create Python compiler adapter.

        Returns:
            Compiler with default settings

        Example:
            let compiler = PythonCompiler.new()
            compiler.set_type_checking(true)
            let result = compiler.compile(config, CompilationMode::Release, false)
        """
        PythonCompiler {
            python_path: "python3",  # Use 'python3' from PATH
            mypy_path: "mypy",
            run_type_checker: true,
            byte_compile: true
        }

    pub fn set_python_path(self, path: String):
        """Set path to Python interpreter.

        Args:
            path: Path to python3
        """
        self.python_path = path

    pub fn set_type_checking(self, enabled: bool):
        """Enable/disable mypy type checking.

        Args:
            enabled: True to run mypy
        """
        self.run_type_checker = enabled

    pub fn set_byte_compile(self, enabled: bool):
        """Enable/disable byte compilation.

        Args:
            enabled: True to compile .py to .pyc
        """
        self.byte_compile = enabled

    pub fn is_type_checking_enabled(self): bool =
        """Check if type checking is enabled.

        Returns:
            True if mypy will run
        """
        self.run_type_checker

    pub fn is_byte_compile_enabled(self): bool =
        """Check if byte compilation is enabled.

        Returns:
            True if .pyc files will be generated
        """
        self.byte_compile

    pub fn get_check_command(self): String =
        """Get mypy command for display.

        Returns:
            Command string

        Example:
            compiler.get_check_command()
            # → "mypy --no-color-output --no-error-summary"
        """
        "{self.mypy_path} --no-color-output --no-error-summary"

impl LanguageCompiler for PythonCompiler:
    fn compile(config: LanguageConfig,
        mode: CompilationMode,
        incremental: bool
    ): CompilationResult =
        """Compile Python code.

        Args:
            config: Language configuration
            mode: Compilation mode (Debug/Release/Profile)
            incremental: Enable incremental compilation

        Returns:
            Compilation result

        Compilation steps:
        1. Run mypy type checker (if enabled)
        2. Byte-compile .py files (if enabled)
        3. Return artifacts (.pyc files)
        """
        @extern("runtime", "rt_time_now_unix_micros")
        fn _rt_time_now_unix_micros() -> i64

        let result = CompilationResult.new()
        let start_time = _rt_time_now_unix_micros() / 1000  # Convert microseconds to milliseconds

        # Step 1: Type checking with mypy
        if self.run_type_checker:
            let type_errors = self.run_mypy(config.root)
            for error in type_errors:
                result.add_error(error)

        # Step 2: Byte compilation (if no type errors)
        if result.is_ok() and self.byte_compile:
            let artifacts = self.byte_compile_directory(config.root)
            for artifact in artifacts:
                result.add_artifact(artifact)

        let end_time = _rt_time_now_unix_micros() / 1000  # Convert microseconds to milliseconds
        result.duration_ms = end_time - start_time

        result

    fn get_language(): Language =
        """Get language type.

        Returns:
            Language::Python
        """
        Language::Python

    fn supports_incremental(): bool =
        """Check if incremental compilation is supported.

        Returns:
            True (only recompile changed .py files)
        """
        true

    fn get_executable_extension(): String =
        """Get executable file extension.

        Returns:
            ".py" (Python scripts)
        """
        ".py"

    fn get_library_extension(): String =
        """Get library file extension.

        Returns:
            ".pyc" (bytecode) or ".so" (C extensions)
        """
        ".pyc"

# Helper class for process execution
class ProcessOutput:
    pub exit_code: i32
    pub stdout: String
    pub stderr: String

    pub fn new(exit_code: i32, stdout: String, stderr: String): ProcessOutput =
        ProcessOutput {
            exit_code: exit_code,
            stdout: stdout,
            stderr: stderr
        }

    pub fn is_success(self): bool =
        """Check if process succeeded.

        Returns:
            True if exit code is 0
        """
        self.exit_code == 0

    pub fn is_failure(self): bool =
        """Check if process failed.

        Returns:
            True if exit code is non-zero
        """
        self.exit_code != 0

    pub fn has_stdout(self): bool =
        """Check if stdout is non-empty.

        Returns:
            True if stdout has content
        """
        not self.stdout.is_empty()

    pub fn has_stderr(self): bool =
        """Check if stderr is non-empty.

        Returns:
            True if stderr has content
        """
        not self.stderr.is_empty()

    pub fn summary(self): String =
        """Get process output summary.

        Returns:
            Human-readable summary

        Example:
            output.summary()
            # → "Exit code: 0, stdout: 1234 bytes, stderr: 0 bytes"
        """
        "Exit code: {self.exit_code}, stdout: {self.stdout.len()} bytes, stderr: {self.stderr.len()} bytes"

# Helper methods
impl PythonCompiler:
    fn run_mypy(root: String): List<CompilationError> =
        """Run mypy type checker.

        Args:
            root: Project root directory

        Returns:
            List of type errors
        """
        let errors: List<CompilationError> = []

        # Build mypy command
        let mut args: List<String> = []
        args.append(root)
        args.append("--no-color-output")
        args.append("--no-error-summary")

        # Execute mypy
        let output = self.execute_mypy(args)

        if output.exit_code != 0:
            # Parse mypy error output
            errors.extend(self.parse_mypy_errors(output.stdout))

        errors

    fn byte_compile_directory(root: String): List<Artifact> =
        """Byte-compile all .py files in directory.

        Args:
            root: Directory to compile

        Returns:
            List of .pyc artifacts
        """
        let artifacts: List<Artifact> = []

        # TODO: [stdlib][P3] Recursively find .py files and compile them
        # For now, return empty list
        artifacts

    fn execute_mypy(args: List<String>): ProcessOutput =
        """Execute mypy command.

        Args:
            args: Mypy arguments

        Returns:
            Process output
        """
        # TODO: [stdlib][P1] Implement actual process execution
        ProcessOutput.new(0, "", "")

    fn parse_mypy_errors(output: String): List<CompilationError> =
        """Parse mypy error output.

        Args:
            output: Mypy stdout

        Returns:
            List of type errors

        Mypy format: file:line: error: message
        Example: app.py:10: error: Incompatible types in assignment
        """
        let errors: List<CompilationError> = []

        let lines = output.split("\n")
        for line in lines:
            if line.trim().is_empty():
                continue

            # Parse error line
            let parts = line.split(":")
            if parts.len() >= 3:
                let file = parts[0].trim()
                let line_num = self.parse_int(parts[1].trim())
                let severity_and_msg = parts[2..].join(":").trim()

                # Extract severity (error/warning/note)
                let (severity, message) = self.parse_severity(severity_and_msg)

                let error = CompilationError.new(
                    file: file,
                    line: line_num,
                    column: 0,  # mypy doesn't always provide column
                    message: message,
                    severity: severity,
                    language: Language::Python
                )
                errors.append(error)

        errors

    fn parse_severity(text: String): (ErrorSeverity, String) =
        """Parse severity from mypy message.

        Args:
            text: Message with severity prefix

        Returns:
            (severity, message) tuple
        """
        if text.starts_with("error:"):
            (ErrorSeverity::Error, text[6..].trim())
        else if text.starts_with("warning:"):
            (ErrorSeverity::Warning, text[8..].trim())
        else if text.starts_with("note:"):
            (ErrorSeverity::Info, text[5..].trim())
        else:
            (ErrorSeverity::Error, text)

    fn parse_int(s: String): i32 =
        """Parse integer from string.

        Args:
            s: String to parse

        Returns:
            Parsed integer or 0
        """
        # Simple integer parsing implementation
        let trimmed = s.trim()
        if trimmed.is_empty():
            return 0

        var result: i32 = 0
        var negative = false
        var start_idx = 0

        # Check for sign
        if trimmed[0] == '-':
            negative = true
            start_idx = 1
        elif trimmed[0] == '+':
            start_idx = 1

        # Parse digits
        for i in start_idx..trimmed.len():
            let ch = trimmed[i]
            if ch >= '0' and ch <= '9':
                let digit = (ch as i32) - ('0' as i32)
                result = result * 10 + digit
            else:
                # Invalid character, return what we have so far
                break

        if negative:
            return -result
        else:
            return result
