# Vulkan Window Management
#
# High-level wrapper around Vulkan window FFI functions.
# Provides type-safe window creation, event handling, and fullscreen management.
#
# Implementation Status: Phase 5 - Event Handling Complete
# - Window creation and destruction
# - Window property queries (size)
# - Fullscreen mode control
# - Event polling and waiting (7 event types)

use core.*

# =============================================================================
# Window - High-Level Window Management
# =============================================================================

pub struct Window:
    handle: i64              # FFI window handle
    width: u32               # Current width
    height: u32              # Current height
    title: String            # Window title

impl Window:
    # Create a new window
    #
    # Example:
    #   let window = Window::new(1920, 1080, "My Application")?
    #
    pub fn new(width: u32, height: u32, title: &str) -> Result[Window, String]:
        let handle = rt_vk_window_create(0, width, height, title.as_ptr(), title.len() as u64)

        if handle < 0:
            return Err("Failed to create window: error code " + str(handle))

        return Ok(Window {
            handle: handle,
            width: width,
            height: height,
            title: title.to_string()
        })

    # Get window handle (for FFI operations)
    pub fn handle(self) -> i64:
        return self.handle

    # Get current window size
    #
    # Example:
    #   let (width, height) = window.get_size()?
    #
    pub fn get_size(self) -> Result[(u32, u32), String]:
        let mut width: u32 = 0
        let mut height: u32 = 0

        let result = rt_vk_window_get_size(self.handle, &mut width, &mut height)

        if result != 0:
            return Err("Failed to get window size: error code " + str(result))

        return Ok((width, height))

    # Update internal size cache (call after resize event)
    me update_size(self, width: u32, height: u32):
        self.width = width
        self.height = height

    # Set fullscreen mode
    #
    # Modes:
    # - Windowed: Normal window with title bar
    # - Borderless: Fullscreen without mode change
    # - Exclusive: Exclusive fullscreen (requires mode setting)
    #
    # Example:
    #   window.set_fullscreen(FullscreenMode::Borderless)?
    #
    pub fn set_fullscreen(self, mode: FullscreenMode) -> Result[(), String]:
        let mode_code = match mode:
            case FullscreenMode::Windowed: 0
            case FullscreenMode::Borderless: 1
            case FullscreenMode::Exclusive: 2

        let result = rt_vk_window_set_fullscreen(self.handle, mode_code)

        if result != 0:
            return Err("Failed to set fullscreen mode: error code " + str(result))

        return Ok(())

    # Poll for events (non-blocking)
    #
    # Returns Some(event) if event is available, None otherwise.
    #
    # Example:
    #   while let Some(event) = window.poll_event():
    #       match event:
    #           case WindowEvent::CloseRequested:
    #               return
    #           case WindowEvent::Resized(w, h):
    #               resize_swapchain(w, h)
    #
    pub fn poll_event(mut self) -> Option[WindowEvent]:
        let mut event_window: i64 = 0
        let mut event_type: i32 = 0
        let mut data = ByteArray::new(16)  # Max event data size

        let result = rt_vk_window_poll_event(
            &mut event_window,
            &mut event_type,
            data.as_mut_ptr(),
            16
        )

        if result <= 0:
            return None  # No event or error

        # Parse event based on type code
        return Some(Self::parse_event(event_type, &data))

    # Wait for event with timeout (blocking)
    #
    # timeout_ms: Maximum time to wait in milliseconds
    # Returns Some(event) if event received, None on timeout.
    #
    # Example:
    #   # Wait up to 16ms for event (60 FPS)
    #   if let Some(event) = window.wait_event(16):
    #       handle_event(event)
    #   else:
    #       render_frame()
    #
    pub fn wait_event(mut self, timeout_ms: u64) -> Option[WindowEvent]:
        let mut event_window: i64 = 0
        let mut event_type: i32 = 0
        let mut data = ByteArray::new(16)  # Max event data size

        let result = rt_vk_window_wait_event(
            timeout_ms,
            &mut event_window,
            &mut event_type,
            data.as_mut_ptr(),
            16
        )

        if result <= 0:
            return None  # Timeout or error

        # Parse event based on type code
        return Some(Self::parse_event(event_type, &data))

    # Parse event data based on type code
    fn parse_event(event_type: i32, data: &ByteArray) -> WindowEvent:
        match event_type:
            case 1:  # Resized
                let width = data.read_u32(0)
                let height = data.read_u32(4)
                return WindowEvent::Resized(width, height)

            case 2:  # CloseRequested
                return WindowEvent::CloseRequested

            case 3:  # Focused
                let focused = data.read_u8(0) != 0
                return WindowEvent::Focused(focused)

            case 4:  # Moved
                let x = data.read_i32(0)
                let y = data.read_i32(4)
                return WindowEvent::Moved(x, y)

            case 10:  # MouseMoved
                let x = data.read_f64(0)
                let y = data.read_f64(8)
                return WindowEvent::MouseMoved(x, y)

            case 11:  # MouseButton
                let button = data.read_u32(0)
                let pressed = data.read_u8(4) != 0
                return WindowEvent::MouseButton(button, pressed)

            case 20:  # KeyEvent
                let key_code = data.read_u32(0)
                let pressed = data.read_u8(4) != 0
                return WindowEvent::KeyEvent(key_code, pressed)

            case _:  # Unknown event type
                return WindowEvent::Unknown

impl Drop for Window:
    me drop(self):
        # Destroy window on drop
        let _ = rt_vk_window_destroy(self.handle)

impl Window:
    pub fn get_width(self) -> u32:
        """Get current width.

        Returns:
            Window width in pixels
        """
        self.width

    pub fn get_height(self) -> u32:
        """Get current height.

        Returns:
            Window height in pixels
        """
        self.height

    pub fn get_title(self) -> &String:
        """Get window title.

        Returns:
            Window title
        """
        &self.title

    pub fn aspect_ratio(self) -> f64:
        """Calculate window aspect ratio.

        Returns:
            Width divided by height
        """
        (self.width as f64) / (self.height as f64)

    pub fn is_landscape(self) -> bool:
        """Check if window is landscape orientation.

        Returns:
            True if wider than tall
        """
        self.width > self.height

    pub fn is_portrait(self) -> bool:
        """Check if window is portrait orientation.

        Returns:
            True if taller than wide
        """
        self.height > self.width

    pub fn is_square(self) -> bool:
        """Check if window is square.

        Returns:
            True if width equals height
        """
        self.width == self.height

    pub fn area(self) -> u64:
        """Get window area in pixels.

        Returns:
            Total area
        """
        (self.width as u64) * (self.height as u64)

    pub fn summary(self) -> String:
        """Get window summary.

        Returns:
            Human-readable summary
        """
        let orientation = if self.is_landscape(): "landscape" else if self.is_portrait(): "portrait" else: "square"
        return "Window: '{self.title}' {self.width}x{self.height} ({orientation})"

# =============================================================================
# Window Event Types
# =============================================================================

pub enum WindowEvent:
    # Window was resized (width, height)
    Resized(u32, u32)

    # User requested to close the window
    CloseRequested

    # Window gained or lost focus
    Focused(bool)

    # Window was moved to new position (x, y)
    Moved(i32, i32)

    # Mouse cursor moved (x, y)
    MouseMoved(f64, f64)

    # Mouse button pressed or released (button, pressed)
    MouseButton(u32, bool)

    # Keyboard key pressed or released (key_code, pressed)
    KeyEvent(u32, bool)

    # Unknown event type (should not occur)
    Unknown

impl WindowEvent:
    pub fn to_string(self) -> String:
        """Convert event to string.

        Returns:
            Event name

        Example:
            WindowEvent::CloseRequested.to_string()  # → "close-requested"
        """
        match self:
            case Resized(_, _): "resized"
            case CloseRequested: "close-requested"
            case Focused(_): "focused"
            case Moved(_, _): "moved"
            case MouseMoved(_, _): "mouse-moved"
            case MouseButton(_, _): "mouse-button"
            case KeyEvent(_, _): "key-event"
            case Unknown: "unknown"

    pub fn description(self) -> String:
        """Get event description.

        Returns:
            Human-readable description
        """
        match self:
            case Resized(w, h):
                "Window resized to {w}x{h}"
            case CloseRequested:
                "User requested to close window"
            case Focused(focused):
                if focused: "Window gained focus" else: "Window lost focus"
            case Moved(x, y):
                "Window moved to ({x},{y})"
            case MouseMoved(x, y):
                "Mouse moved to ({x},{y})"
            case MouseButton(button, pressed):
                let action = if pressed: "pressed" else: "released"
                "Mouse button {button} {action}"
            case KeyEvent(key, pressed):
                let action = if pressed: "pressed" else: "released"
                "Key {key} {action}"
            case Unknown:
                "Unknown event type"

    pub fn is_window_event(self) -> bool:
        """Check if this is a window state event.

        Returns:
            True for Resized, Focused, Moved, CloseRequested
        """
        match self:
            case Resized(_, _): true
            case CloseRequested: true
            case Focused(_): true
            case Moved(_, _): true
            case _: false

    pub fn is_input_event(self) -> bool:
        """Check if this is an input event.

        Returns:
            True for mouse and keyboard events
        """
        match self:
            case MouseMoved(_, _): true
            case MouseButton(_, _): true
            case KeyEvent(_, _): true
            case _: false

    pub fn is_mouse_event(self) -> bool:
        """Check if this is a mouse event.

        Returns:
            True for MouseMoved or MouseButton
        """
        match self:
            case MouseMoved(_, _): true
            case MouseButton(_, _): true
            case _: false

    pub fn is_keyboard_event(self) -> bool:
        """Check if this is a keyboard event.

        Returns:
            True for KeyEvent
        """
        match self:
            case KeyEvent(_, _): true
            case _: false

    pub fn is_close_request(self) -> bool:
        """Check if this is a close request.

        Returns:
            True for CloseRequested
        """
        match self:
            case CloseRequested: true
            case _: false

    pub fn summary(self) -> String:
        """Get comprehensive event summary.

        Returns:
            Summary with event type and category
        """
        let name = self.to_string()
        let desc = self.description()
        let mut props = []
        if self.is_window_event():
            props.push("window")
        if self.is_input_event():
            props.push("input")
        if self.is_mouse_event():
            props.push("mouse")
        if self.is_keyboard_event():
            props.push("keyboard")
        if props.len() > 0:
            let props_str = ", ".join(props)
            return "WindowEvent: {name} ({desc}, {props_str})"
        else:
            return "WindowEvent: {name} ({desc})"

# =============================================================================
# Fullscreen Modes
# =============================================================================

pub enum FullscreenMode:
    # Normal windowed mode with title bar
    Windowed

    # Borderless fullscreen (fast mode switch, no exclusive access)
    Borderless

    # Exclusive fullscreen (requires video mode setting)
    Exclusive

impl FullscreenMode:
    pub fn to_string(self) -> String:
        """Convert fullscreen mode to string.

        Returns:
            Mode name

        Example:
            FullscreenMode::Borderless.to_string()  # → "borderless"
        """
        match self:
            case Windowed: "windowed"
            case Borderless: "borderless"
            case Exclusive: "exclusive"

    pub fn description(self) -> String:
        """Get mode description.

        Returns:
            Human-readable description
        """
        match self:
            case Windowed:
                "Normal windowed mode with title bar"
            case Borderless:
                "Borderless fullscreen (fast, no exclusive access)"
            case Exclusive:
                "Exclusive fullscreen (requires mode setting)"

    pub fn is_fullscreen(self) -> bool:
        """Check if this is a fullscreen mode.

        Returns:
            True for Borderless or Exclusive
        """
        match self:
            case Windowed: false
            case Borderless: true
            case Exclusive: true

    pub fn is_windowed(self) -> bool:
        """Check if this is windowed mode.

        Returns:
            True for Windowed
        """
        match self:
            case Windowed: true
            case _: false

    pub fn requires_mode_change(self) -> bool:
        """Check if mode requires video mode change.

        Returns:
            True for Exclusive
        """
        match self:
            case Exclusive: true
            case _: false

    pub fn is_exclusive(self) -> bool:
        """Check if exclusive fullscreen.

        Returns:
            True for Exclusive
        """
        match self:
            case Exclusive: true
            case _: false

    pub fn is_borderless(self) -> bool:
        """Check if borderless fullscreen.

        Returns:
            True for Borderless
        """
        match self:
            case Borderless: true
            case _: false

    pub fn summary(self) -> String:
        """Get comprehensive fullscreen mode summary.

        Returns:
            Summary with mode name and characteristics
        """
        let name = self.to_string()
        let desc = self.description()
        let mut props = []
        if self.is_fullscreen():
            props.push("fullscreen")
        if self.is_windowed():
            props.push("windowed")
        if self.requires_mode_change():
            props.push("requires-mode-change")
        if self.is_exclusive():
            props.push("exclusive")
        if props.len() > 0:
            let props_str = ", ".join(props)
            return "FullscreenMode: {name} ({desc}, {props_str})"
        else:
            return "FullscreenMode: {name} ({desc})"

# =============================================================================
# Helper Types
# =============================================================================

# ByteArray for event data serialization
struct ByteArray:
    data: Array[u8]

impl ByteArray:
    fn new(size: u64) -> ByteArray:
        return ByteArray {
            data: Array::with_capacity(size as usize)
        }

    me as_mut_ptr(self) -> *mut u8:
        return self.data.as_mut_ptr()

    fn read_u8(self, offset: usize) -> u8:
        return self.data[offset]

    fn read_u32(self, offset: usize) -> u32:
        # Read little-endian u32
        let b0 = self.data[offset] as u32
        let b1 = self.data[offset + 1] as u32
        let b2 = self.data[offset + 2] as u32
        let b3 = self.data[offset + 3] as u32
        return b0 | (b1 << 8) | (b2 << 16) | (b3 << 24)

    fn read_i32(self, offset: usize) -> i32:
        return self.read_u32(offset) as i32

    fn read_f64(self, offset: usize) -> f64:
        # Read little-endian f64 (reinterpret u64 bits as f64)
        let b0 = self.data[offset] as u64
        let b1 = self.data[offset + 1] as u64
        let b2 = self.data[offset + 2] as u64
        let b3 = self.data[offset + 3] as u64
        let b4 = self.data[offset + 4] as u64
        let b5 = self.data[offset + 5] as u64
        let b6 = self.data[offset + 6] as u64
        let b7 = self.data[offset + 7] as u64

        let bits = b0 | (b1 << 8) | (b2 << 16) | (b3 << 24) |
                   (b4 << 32) | (b5 << 40) | (b6 << 48) | (b7 << 56)

        return f64::from_bits(bits)

# =============================================================================
# FFI Declarations - Window Management
# =============================================================================

# Create a Vulkan window with surface
#
# Returns window handle on success (positive i64), error code on failure (negative)
extern fn rt_vk_window_create(
    device_handle: u64,      # Currently unused (for future)
    width: u32,
    height: u32,
    title_ptr: *const u8,
    title_len: u64
) -> i64

# Destroy a window
#
# Returns 0 on success, error code on failure
extern fn rt_vk_window_destroy(window_handle: i64) -> i32

# Get window size
#
# Returns 0 on success, error code on failure
extern fn rt_vk_window_get_size(
    window_handle: i64,
    out_width: *mut u32,
    out_height: *mut u32
) -> i32

# Set window fullscreen mode
#
# mode: 0 = windowed, 1 = borderless, 2 = exclusive
# Returns 0 on success, error code on failure
extern fn rt_vk_window_set_fullscreen(window_handle: i64, mode: i32) -> i32

# Poll for window events (non-blocking)
#
# Returns event type (positive) if event available, 0 if no event, negative on error
# Event data is written to out parameters
#
# Event types:
# 1 = Resized (data: u32 width, u32 height)
# 2 = CloseRequested (no data)
# 3 = Focused (data: u8 focused)
# 4 = Moved (data: i32 x, i32 y)
# 10 = MouseMoved (data: f64 x, f64 y)
# 11 = MouseButton (data: u32 button, u8 pressed)
# 20 = KeyEvent (data: u32 key_code, u8 pressed)
extern fn rt_vk_window_poll_event(
    out_window: *mut i64,
    out_type: *mut i32,
    out_data_ptr: *mut u8,
    out_data_len: u64
) -> i32

# Wait for window event with timeout
#
# timeout_ms: timeout in milliseconds
# Returns event type (positive) if event available, 0 on timeout, negative on error
# Event types: same as rt_vk_window_poll_event
extern fn rt_vk_window_wait_event(
    timeout_ms: u64,
    out_window: *mut i64,
    out_type: *mut i32,
    out_data_ptr: *mut u8,
    out_data_len: u64
) -> i32

# =============================================================================
# Usage Examples
# =============================================================================

# Example 1: Basic window creation and event loop
#
# fn main():
#     let window = Window::new(1920, 1080, "My Application")?
#
#     let mut running = true
#     while running:
#         # Poll events
#         while let Some(event) = window.poll_event():
#             match event:
#                 case WindowEvent::CloseRequested:
#                     running = false
#                 case WindowEvent::Resized(width, height):
#                     print("Window resized to " + str(width) + "x" + str(height))
#                 case WindowEvent::KeyEvent(key, pressed):
#                     if pressed:
#                         handle_key_press(key)
#
#         # Render frame
#         render_frame()

# Example 2: Event-driven rendering with timeout
#
# fn game_loop(window: &mut Window):
#     let mut running = true
#
#     while running:
#         # Wait for event or 16ms timeout (60 FPS)
#         match window.wait_event(16):
#             case Some(WindowEvent::CloseRequested):
#                 running = false
#             case Some(WindowEvent::MouseMoved(x, y)):
#                 update_cursor_position(x, y)
#             case Some(event):
#                 handle_event(event)
#             case None:
#                 # Timeout - render frame
#                 render_frame()

# Example 3: Fullscreen toggle
#
# fn toggle_fullscreen(window: &mut Window, is_fullscreen: &mut bool):
#     if *is_fullscreen:
#         window.set_fullscreen(FullscreenMode::Windowed)?
#         *is_fullscreen = false
#     else:
#         window.set_fullscreen(FullscreenMode::Borderless)?
#         *is_fullscreen = true
