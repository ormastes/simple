# Simple Platformer Demo
#
# Demonstrates the 3D Game Engine Integration using Common Interface
# Works with both Godot and Unreal engines!
#
# Features:
# - Cross-engine scene graph (SceneNode trait)
# - Actor model for game logic
# - Effect system for async safety
# - Input abstraction
# - Physics abstraction
# - Audio abstraction

import game_engine.scene_node
import game_engine.actor_model
import game_engine.effects
import game_engine.input
import game_engine.physics
import game_engine.audio
import sys.ffi

# Player Entity
struct Player:
    entity_id: i32
    position: (f64, f64, f64)
    velocity: (f64, f64, f64)
    on_ground: bool
    health: i32
    score: i32

impl Player:
    fn new(entity_id: i32) -> Player:
        return Player(
            entity_id: entity_id,
            position: (0.0, 1.0, 0.0),
            velocity: (0.0, 0.0, 0.0),
            on_ground: false,
            health: 100,
            score: 0
        )

    me update(delta: f32, input: InputState):
        # Movement
        let move_speed = 5.0
        let (mut vx, vy, mut vz) = self.velocity

        # Left/Right movement
        if input.is_key_pressed(KeyCode::Left):
            vx = -move_speed
        elif input.is_key_pressed(KeyCode::Right):
            vx = move_speed
        else:
            vx = 0.0

        # Jumping
        if input.is_key_just_pressed(KeyCode::Space) and self.on_ground:
            vy = 10.0  # Jump velocity
            self.on_ground = false

        self.velocity = (vx, vy, vz)

        # Apply gravity if not on ground
        if not self.on_ground:
            let (vx, mut vy, vz) = self.velocity
            vy = vy - 9.8 * delta  # Gravity
            self.velocity = (vx, vy, vz)

        # Update position
        let (mut px, mut py, mut pz) = self.position
        let (vx, vy, vz) = self.velocity

        px = px + vx * delta
        py = py + vy * delta
        pz = pz + vz * delta

        self.position = (px, py, pz)

        # Check ground collision
        if py <= 0.0:
            py = 0.0
            self.on_ground = true
            self.velocity = (vx, 0.0, vz)
            self.position = (px, py, pz)

    me take_damage(amount: i32):
        self.health = self.health - amount
        if self.health < 0:
            self.health = 0

    me add_score(points: i32):
        self.score = self.score + points

# Game State
struct GameState:
    player: Player
    enemies: Vec[Enemy]
    collectibles: Vec[Collectible]
    level_complete: bool

impl GameState:
    fn new() -> GameState:
        let null_ptr: ffi.VoidPtr = 0 as ffi.VoidPtr
        let entity_id = spawn_game_entity(null_ptr)

        return GameState(
            player: Player::new(entity_id),
            enemies: [],
            collectibles: [],
            level_complete: false
        )

    me update(delta: f32, input: InputState):
        # Update player
        with_physics_effect("player_movement", fn():
            self.player.update(delta, input)
        )

        # Update player entity position
        let msg = GameMessage::SetPosition(self.player.position)
        send_entity_message(self.player.entity_id, msg)

        # Check collectibles
        for collectible in self.collectibles:
            if self.check_collision(self.player.position, collectible.position):
                self.player.add_score(collectible.points)

                # Play collection sound
                with_audio_effect("collect_sound", fn():
                    play_collect_sound()
                )

    fn check_collision(pos1: (f64, f64, f64), pos2: (f64, f64, f64)) -> bool:
        let (x1, y1, z1) = pos1
        let (x2, y2, z2) = pos2

        let dist = position_distance(pos1, pos2)
        return dist < 2.0  # Collision radius

# Enemy
struct Enemy:
    entity_id: i32
    position: (f64, f64, f64)
    patrol_start: (f64, f64, f64)
    patrol_end: (f64, f64, f64)
    direction: i32  # 1 or -1

impl Enemy:
    me update(delta: f32):
        # Simple patrol movement
        let (mut x, y, z) = self.position
        x = x + (2.0 * self.direction * delta)

        # Check patrol bounds
        let (start_x, _, _) = self.patrol_start
        let (end_x, _, _) = self.patrol_end

        if x <= start_x or x >= end_x:
            self.direction = -self.direction

        self.position = (x, y, z)

# Collectible
struct Collectible:
    position: (f64, f64, f64)
    points: i32
    collected: bool

# Input State Helper
struct InputState:
    pressed_keys: Vec[KeyCode]
    just_pressed_keys: Vec[KeyCode]

impl InputState:
    fn is_key_pressed(key: KeyCode) -> bool:
        for pressed in self.pressed_keys:
            if pressed is key:
                return true
        return false

    fn is_key_just_pressed(key: KeyCode) -> bool:
        for just_pressed in self.just_pressed_keys:
            if just_pressed is key:
                return true
        return false

# Audio Helper
fn play_collect_sound():
    # Use audio abstraction
    pass

fn play_jump_sound():
    # Use audio abstraction
    pass

fn play_damage_sound():
    # Use audio abstraction
    pass

# Main Game Loop
fn main():
    print("Simple Platformer Demo")
    print("======================")
    print("Controls:")
    print("  Arrow Keys: Move Left/Right")
    print("  Space: Jump")
    print("")

    # Initialize game state
    let mut game_state = GameState::new()

    # Add some collectibles
    game_state.collectibles.push(Collectible(
        position: (10.0, 1.0, 0.0),
        points: 10,
        collected: false
    ))

    game_state.collectibles.push(Collectible(
        position: (20.0, 1.0, 0.0),
        points: 20,
        collected: false
    ))

    # Game loop (60 FPS)
    let delta = 0.016

    # Simulate input
    let input = InputState(
        pressed_keys: [KeyCode::Right],
        just_pressed_keys: []
    )

    # Update game
    for frame in range(60):  # 1 second of gameplay
        game_state.update(delta, input)

        # Update all entities
        update_game_entities(delta)

        if frame == 30:  # Jump at half second
            input.just_pressed_keys.push(KeyCode::Space)

    print("Player Position: {game_state.player.position}")
    print("Player Score: {game_state.player.score}")
    print("Player Health: {game_state.player.health}")
    print("")
    print("Demo Complete!")
