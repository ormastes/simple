# MCP Generic Server Implementation
# Reusable server that can be extended for any language/tool

use core.*
use mcp.core.protocol.*
use mcp.core.provider.*

# Generic MCP server
pub class McpServer:
    pub name: String
    pub version: String
    pub provider: ResourceProvider
    pub tools: Dict[String, ToolHandler]
    
    pub fn new(name: String, version: String, provider: ResourceProvider) -> McpServer:
        return McpServer:
            name: name
            version: version
            provider: provider
            tools: {}
    
    # Register a tool handler
    pub fn register_tool(self, tool: Tool, handler: ToolHandler):
        self.tools.set(tool.name, handler)
    
    # Handle incoming JSON-RPC request
    pub fn handle_request(self, request: JsonRpcRequest) -> JsonRpcResponse:
        method = request.method
        
        # Standard protocol methods
        if method == "initialize":
            return self.handle_initialize(request)
        elif method == "ping":
            return self.handle_ping(request)
        elif method == "resources/list":
            return self.handle_list_resources(request)
        elif method == "resources/read":
            return self.handle_read_resource(request)
        elif method == "tools/list":
            return self.handle_list_tools(request)
        elif method == "tools/call":
            return self.handle_call_tool(request)
        else:
            # Unknown method
            error = ErrorObject.new(-32601, "Method not found: " + method)
            return JsonRpcError.new(request.id, error)
    
    # Handle initialize
    fn handle_initialize(request: JsonRpcRequest) -> JsonRpcResponse:
        result = InitializeResult.new(self.name, self.version)
        return JsonRpcResponse.new(request.id, result)
    
    # Handle ping
    fn handle_ping(request: JsonRpcRequest) -> JsonRpcResponse:
        return JsonRpcResponse.new(request.id, {})
    
    # Handle list resources
    fn handle_list_resources(request: JsonRpcRequest) -> JsonRpcResponse:
        resources = self.provider.list_resources()
        result = {"resources": resources}
        return JsonRpcResponse.new(request.id, result)
    
    # Handle read resource
    fn handle_read_resource(request: JsonRpcRequest) -> JsonRpcResponse:
        uri = request.params.get("uri")
        contents = self.provider.read_resource(uri)
        result = {"contents": [contents]}
        return JsonRpcResponse.new(request.id, result)
    
    # Handle list tools
    fn handle_list_tools(request: JsonRpcRequest) -> JsonRpcResponse:
        tool_list = []
        for tool_name in self.tools.keys():
            handler = self.tools.get(tool_name)
            tool_list.append(handler.tool)
        
        result = {"tools": tool_list}
        return JsonRpcResponse.new(request.id, result)
    
    # Handle call tool
    fn handle_call_tool(request: JsonRpcRequest) -> JsonRpcResponse:
        tool_name = request.params.get("name")
        arguments = request.params.get("arguments")
        
        if self.tools.has_key(tool_name):
            handler = self.tools.get(tool_name)
            tool_result = handler.execute(arguments)
            result = {"content": tool_result.content}
            return JsonRpcResponse.new(request.id, result)
        else:
            error = ErrorObject.new(-32602, "Tool not found: " + tool_name)
            return JsonRpcError.new(request.id, error)

# Tool handler interface - implement this for each tool
pub class ToolHandler:
    pub tool: Tool
    pub execute_fn: Fn(Dict[String, Any]) -> ToolResult
    
    pub fn new(tool: Tool, execute_fn: Fn(Dict[String, Any]) -> ToolResult) -> ToolHandler:
        return ToolHandler:
            tool: tool
            execute_fn: execute_fn
    
    pub fn execute(self, arguments: Dict[String, Any]) -> ToolResult:
        return self.execute_fn(arguments)

# Helper to create a simple text tool
pub fn create_text_tool(name: String, description: String, 
                        handler: Fn(Dict[String, Any]) -> String) -> ToolHandler:
    tool = Tool.new(name, description)
    
    execute_fn = fn(args: Dict[String, Any]) -> ToolResult:
        text = handler(args)
        return ToolResult.new(text)
    
    return ToolHandler.new(tool, execute_fn)
