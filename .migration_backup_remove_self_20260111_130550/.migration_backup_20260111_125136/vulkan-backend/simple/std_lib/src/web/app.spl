# WebApp - Application Builder
#
# Main entry point for creating web applications with routing,
# middleware, and static file serving.
#
# ## Example
#
# ```simple
# use web.*
# use ui.*
#
# async fn home_handler(ctx: Context) -> HttpResponse:
#     let tree = ElementTree::new(ElementKind::Main)
#     tree.root_mut()
#         .with_class("container")
#         .with_child(Element::heading(1, "Welcome"))
#
#     return render_to_response(&tree, "Home")
#
# async fn main() -> i32:
#     let app = WebApp::new()
#         .port(3000)
#         .use_logger()
#         .use_cors()
#         .get("/", home_handler)
#         .get("/users/:id", user_handler)
#         .static_files("/assets", "public/")
#
#     await app.run()?
#     return 0
# ```

use units.net.*
use units.time.*
use host.common.io.error.IoError
use web.http.request.*
use web.http.response.*
use web.http.server.*
use web.router.*
use web.middleware.*
use web.static.*
use web.ssr.*

# Handler type alias
pub type AppHandler = fn(Context) -> async HttpResponse

# WebApp - Application builder
pub struct WebApp:
    config: ServerConfig
    router: Router
    middleware_chain: MiddlewareChain
    static_routes: Array[StaticRoute]
    error_handlers: ErrorHandlers

impl WebApp:
    # Create new web application
    pub fn new() -> WebApp:
        return WebApp {
            config: ServerConfig::bind_local(8080),
            router: Router::new(),
            middleware_chain: MiddlewareChain::new(),
            static_routes: [],
            error_handlers: ErrorHandlers::default()
        }

    # ========================================================================
    # Configuration
    # ========================================================================

    # Set port
    pub fn port(self, port: u16) -> WebApp:
        self.config = ServerConfig::bind_local(port)
        return self

    # Set full address
    pub fn bind(self, addr: SocketAddr) -> WebApp:
        self.config = ServerConfig::new(addr)
        return self

    # Set keep-alive
    pub fn keep_alive(self, enabled: bool) -> WebApp:
        self.config = self.config.with_keep_alive(enabled)
        return self

    # Set keep-alive timeout
    pub fn keep_alive_timeout(self, timeout: Duration) -> WebApp:
        self.config = self.config.with_keep_alive_timeout(timeout)
        return self

    # Set max connections
    pub fn max_connections(self, max: u32) -> WebApp:
        self.config = self.config.with_max_connections(max)
        return self

    # Set read timeout
    pub fn read_timeout(self, timeout: Duration) -> WebApp:
        self.config = self.config.with_read_timeout(timeout)
        return self

    # Set write timeout
    pub fn write_timeout(self, timeout: Duration) -> WebApp:
        self.config = self.config.with_write_timeout(timeout)
        return self

    # ========================================================================
    # Routing
    # ========================================================================

    # Add GET route
    pub fn get(self, pattern: &str, handler: AppHandler) -> WebApp:
        self.router = self.router.get(pattern, handler)
        return self

    # Add POST route
    pub fn post(self, pattern: &str, handler: AppHandler) -> WebApp:
        self.router = self.router.post(pattern, handler)
        return self

    # Add PUT route
    pub fn put(self, pattern: &str, handler: AppHandler) -> WebApp:
        self.router = self.router.put(pattern, handler)
        return self

    # Add DELETE route
    pub fn delete(self, pattern: &str, handler: AppHandler) -> WebApp:
        self.router = self.router.delete(pattern, handler)
        return self

    # Add PATCH route
    pub fn patch(self, pattern: &str, handler: AppHandler) -> WebApp:
        self.router = self.router.patch(pattern, handler)
        return self

    # Add route with any method
    pub fn route(self, method: HttpMethod, pattern: &str, handler: AppHandler) -> WebApp:
        self.router = self.router.route(method, pattern, handler)
        return self

    # Add route group with prefix
    pub fn group(self, prefix: &str, builder: fn(&mut Router)) -> WebApp:
        self.router = self.router.group(prefix, builder)
        return self

    # ========================================================================
    # Middleware
    # ========================================================================

    # Add middleware
    pub fn use_middleware(self, mw: Box[dyn Middleware]) -> WebApp:
        self.middleware_chain = self.middleware_chain.add(mw)
        return self

    # Add logger middleware (convenience)
    pub fn use_logger(self) -> WebApp:
        return self.use_middleware(Box::new(LoggerMiddleware::new()))

    # Add CORS middleware (convenience)
    pub fn use_cors(self) -> WebApp:
        return self.use_middleware(Box::new(CorsMiddleware::permissive()))

    # Add CORS with specific origin
    pub fn use_cors_origin(self, origin: &str) -> WebApp:
        return self.use_middleware(Box::new(CorsMiddleware::with_origin(origin)))

    # Add request ID middleware
    pub fn use_request_id(self) -> WebApp:
        return self.use_middleware(Box::new(RequestIdMiddleware::new()))

    # Add rate limiter
    pub fn use_rate_limit(self, max_requests: u32, window_seconds: u32) -> WebApp:
        return self.use_middleware(Box::new(RateLimitMiddleware::new(max_requests, window_seconds)))

    # Add compression middleware
    pub fn use_compression(self) -> WebApp:
        return self.use_middleware(Box::new(CompressionMiddleware::new()))

    # Add auth middleware
    pub fn use_auth(self, realm: &str, validator: fn(&str, &str) -> bool) -> WebApp:
        return self.use_middleware(Box::new(AuthMiddleware::new(realm, validator)))

    # ========================================================================
    # Static Files
    # ========================================================================

    # Serve static files from directory
    pub fn static_files(self, prefix: &str, root: &str) -> WebApp:
        self.static_routes.push(StaticRoute::new(prefix, root))
        return self

    # Serve static files with config
    pub fn static_files_config(self, prefix: &str, config: StaticFileConfig) -> WebApp:
        self.static_routes.push(StaticRoute::with_config(prefix, config))
        return self

    # ========================================================================
    # Error Handlers
    # ========================================================================

    # Set custom 404 handler
    pub fn not_found_handler(self, handler: AppHandler) -> WebApp:
        self.error_handlers.not_found = handler
        self.router = self.router.not_found(handler)
        return self

    # Set custom error handler
    pub fn error_handler(self, handler: fn(HttpError) -> HttpResponse) -> WebApp:
        self.error_handlers.error = handler
        return self

    # ========================================================================
    # Running
    # ========================================================================

    # Get the server address
    pub fn addr(self) -> SocketAddr:
        return self.config.addr

    # Run the application (blocking)
    pub async fn run(self) -> Result[(), IoError]:
        println(f"Starting server on http://{self.config.addr}")

        let server = HttpServer::new(self.config)
            .handler(self.create_handler())

        return await server.run()

    # Create the combined handler
    fn create_handler() -> HttpHandler:
        let router = self.router
        let middleware = self.middleware_chain
        let static_routes = self.static_routes
        let error_handlers = self.error_handlers

        return async fn(request: HttpRequest) -> HttpResponse:
            # Create context
            let mut ctx = Context::new(request)

            # Run before middleware
            if let Some(response) = await middleware.run_before(&mut ctx):
                return response

            # Check static routes first
            let path = ctx.path()
            for static_route in &static_routes:
                if static_route.matches(path):
                    let mut response = await static_route.serve(path)
                    await middleware.run_after(&ctx, &mut response)
                    return response

            # Match route
            let route_match = router.match_route(ctx.request())

            # Set route params in context
            ctx.params = route_match.params

            # Call handler
            let mut response = await (route_match.handler)(ctx)

            # Run after middleware
            await middleware.run_after(&ctx, &mut response)

            return response

# Error handlers
pub struct ErrorHandlers:
    not_found: AppHandler
    error: fn(HttpError) -> HttpResponse

impl ErrorHandlers:
    pub fn default() -> ErrorHandlers:
        return ErrorHandlers {
            not_found: default_not_found_handler,
            error: default_error_handler
        }

fn default_not_found_handler(ctx: Context) -> async HttpResponse:
    return not_found_page(ctx.path())

fn default_error_handler(err: HttpError) -> HttpResponse:
    return server_error_page(&err.to_str())

# ============================================================================
# Quick Start Helpers
# ============================================================================

# Create and run a simple server
pub async fn serve(port: u16, handler: AppHandler) -> Result[(), IoError]:
    let app = WebApp::new()
        .port(port)
        .get("/", handler)
        .get("/*path", handler)

    return await app.run()

# Create a quick API server with common middleware
pub fn api_app(port: u16) -> WebApp:
    return WebApp::new()
        .port(port)
        .use_logger()
        .use_cors()
        .use_request_id()

# Create a quick web server with static files
pub fn web_app(port: u16, static_dir: &str) -> WebApp:
    return WebApp::new()
        .port(port)
        .use_logger()
        .static_files("/", static_dir)

# ============================================================================
# Route Builders (for complex routing)
# ============================================================================

# API route group builder
pub struct ApiBuilder:
    prefix: str
    routes: Router

impl ApiBuilder:
    pub fn new(prefix: &str) -> ApiBuilder:
        return ApiBuilder {
            prefix: prefix.to_string(),
            routes: Router::new()
        }

    pub fn get(self, pattern: &str, handler: AppHandler) -> ApiBuilder:
        self.routes = self.routes.get(pattern, handler)
        return self

    pub fn post(self, pattern: &str, handler: AppHandler) -> ApiBuilder:
        self.routes = self.routes.post(pattern, handler)
        return self

    pub fn put(self, pattern: &str, handler: AppHandler) -> ApiBuilder:
        self.routes = self.routes.put(pattern, handler)
        return self

    pub fn delete(self, pattern: &str, handler: AppHandler) -> ApiBuilder:
        self.routes = self.routes.delete(pattern, handler)
        return self

    pub fn build(self) -> fn(&mut Router):
        let routes = self.routes
        return fn(r: &mut Router):
            for route in routes.routes():
                r.route(route.method, &route.pattern, route.handler)

# Resource-style REST routes
pub struct Resource:
    name: str
    handlers: ResourceHandlers

pub struct ResourceHandlers:
    index: Option[AppHandler]    # GET /resources
    show: Option[AppHandler]     # GET /resources/:id
    create: Option[AppHandler]   # POST /resources
    update: Option[AppHandler]   # PUT /resources/:id
    delete: Option[AppHandler]   # DELETE /resources/:id

impl Resource:
    pub fn new(name: &str) -> Resource:
        return Resource {
            name: name.to_string(),
            handlers: ResourceHandlers {
                index: None,
                show: None,
                create: None,
                update: None,
                delete: None
            }
        }

    pub fn index(self, handler: AppHandler) -> Resource:
        self.handlers.index = Some(handler)
        return self

    pub fn show(self, handler: AppHandler) -> Resource:
        self.handlers.show = Some(handler)
        return self

    pub fn create(self, handler: AppHandler) -> Resource:
        self.handlers.create = Some(handler)
        return self

    pub fn update(self, handler: AppHandler) -> Resource:
        self.handlers.update = Some(handler)
        return self

    pub fn delete(self, handler: AppHandler) -> Resource:
        self.handlers.delete = Some(handler)
        return self

    # Apply resource routes to app
    pub fn apply(self, app: WebApp) -> WebApp:
        let base = f"/{self.name}"
        let item = f"/{self.name}/:id"

        let mut result = app

        if let Some(h) = self.handlers.index:
            result = result.get(&base, h)

        if let Some(h) = self.handlers.show:
            result = result.get(&item, h)

        if let Some(h) = self.handlers.create:
            result = result.post(&base, h)

        if let Some(h) = self.handlers.update:
            result = result.put(&item, h)

        if let Some(h) = self.handlers.delete:
            result = result.delete(&item, h)

        return result
