# String Matchers - include, start_with, end_with, match
# String-specific matchers for text validation

import matchers.{Matcher, MatchResult}

# Include matcher for strings: expect "hello world" to include "world"
export class IncludeStringMatcher:
    expected: String

    fn new(expected: String) -> IncludeStringMatcher:
        return IncludeStringMatcher { expected: expected }

impl Matcher[String] for IncludeStringMatcher:
    fn match(self, actual: String) -> MatchResult:
        if actual.includes?(self.expected):
            return MatchResult.success()
        else:
            return MatchResult.failure(
                "Expected \"${actual}\" to include \"${self.expected}\""
            )

export fn include_string(expected: String) -> IncludeStringMatcher:
    return IncludeStringMatcher.new(expected)

# Start with matcher: expect "hello" to start_with "hel"
export class StartWithMatcher:
    expected_prefix: String

    fn new(expected_prefix: String) -> StartWithMatcher:
        return StartWithMatcher { expected_prefix: expected_prefix }

impl Matcher[String] for StartWithMatcher:
    fn match(self, actual: String) -> MatchResult:
        if actual.starts_with?(self.expected_prefix):
            return MatchResult.success()
        else:
            return MatchResult.failure(
                "Expected \"${actual}\" to start with \"${self.expected_prefix}\""
            )

export fn start_with(expected_prefix: String) -> StartWithMatcher:
    return StartWithMatcher.new(expected_prefix)

# End with matcher: expect "hello" to end_with "lo"
export class EndWithMatcher:
    expected_suffix: String

    fn new(expected_suffix: String) -> EndWithMatcher:
        return EndWithMatcher { expected_suffix: expected_suffix }

impl Matcher[String] for EndWithMatcher:
    fn match(self, actual: String) -> MatchResult:
        if actual.ends_with?(self.expected_suffix):
            return MatchResult.success()
        else:
            return MatchResult.failure(
                "Expected \"${actual}\" to end with \"${self.expected_suffix}\""
            )

export fn end_with(expected_suffix: String) -> EndWithMatcher:
    return EndWithMatcher.new(expected_suffix)

# Empty string matcher: expect "" to be_blank
export class BeBlankMatcher:
    fn new() -> BeBlankMatcher:
        return BeBlankMatcher {}

impl Matcher[String] for BeBlankMatcher:
    fn match(self, actual: String) -> MatchResult:
        if actual.is_empty() or actual.trim().is_empty():
            return MatchResult.success()
        else:
            return MatchResult.failure(
                "Expected \"${actual}\" to be blank"
            )

export fn be_blank() -> BeBlankMatcher:
    return BeBlankMatcher.new()
