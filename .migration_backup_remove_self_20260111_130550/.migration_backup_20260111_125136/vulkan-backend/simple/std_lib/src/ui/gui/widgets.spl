# GUI Widgets - Graphical UI Components
#
# Pre-built widgets styled for graphical display.
# These widgets build on the shared Element types with
# GUI-specific styling and behavior.

use core.*
use ui.element.*
use ui.attrs.*
use ui.gui.theme.*

# Card component - elevated surface with content
pub struct Card:
    id: NodeId
    title: Option<String>
    content: Array<Element>
    elevation: u8  # 0-5, higher = more shadow
    padding: u16

impl Card:
    pub fn new(id: NodeId) -> Card:
        return Card {
            id: id,
            title: None,
            content: [],
            elevation: 1,
            padding: 16
        }

    pub fn with_title(self, title: &str) -> Card:
        self.title = Some(title.to_string())
        return self

    pub fn with_elevation(self, level: u8) -> Card:
        self.elevation = level.min(5)
        return self

    pub fn with_padding(self, padding: u16) -> Card:
        self.padding = padding
        return self

    pub fn add_content(self, elem: Element):
        self.content.push(elem)

    pub fn to_element(self, alloc: fn() -> NodeId, theme: &Theme) -> Element:
        let mut card = Element::new(self.id, ElementKind::Box)
            .with_class("card")
            .with_class(&f"elevation-{self.elevation}")
            .with_style("background-color", &color_to_style(&theme.palette.surface))
            .with_style("border-radius", &f"{theme.border_radius.md}px")
            .with_style("padding", &f"{self.padding}px")

        # Add title if present
        if let Some(title) = &self.title:
            let title_elem = Element::new(alloc(), ElementKind::Heading(2))
                .with_text(title)
                .with_class("card-title")
                .with_style("color", &color_to_style(&theme.palette.text_primary))
                .with_style("margin-bottom", &f"{theme.spacing.sm}px")
            card = card.with_child(title_elem)

        # Add content
        for elem in &self.content:
            card = card.with_child(elem.clone())

        return card

# Chip component - compact element for tags/selections
pub struct Chip:
    id: NodeId
    label: String
    icon: Option<String>
    deletable: bool
    selected: bool
    variant: ChipVariant

pub enum ChipVariant:
    Filled
    Outlined

impl Chip:
    pub fn new(id: NodeId, label: &str) -> Chip:
        return Chip {
            id: id,
            label: label.to_string(),
            icon: None,
            deletable: false,
            selected: false,
            variant: ChipVariant::Filled
        }

    pub fn with_icon(self, icon: &str) -> Chip:
        self.icon = Some(icon.to_string())
        return self

    pub fn deletable(self) -> Chip:
        self.deletable = true
        return self

    pub fn selected(self) -> Chip:
        self.selected = true
        return self

    pub fn outlined(self) -> Chip:
        self.variant = ChipVariant::Outlined
        return self

    pub fn to_element(self, alloc: fn() -> NodeId, theme: &Theme) -> Element:
        let bg_color = match self.variant:
            case ChipVariant::Filled:
                if self.selected { &theme.palette.primary } else { &theme.palette.hover }
            case ChipVariant::Outlined:
                &theme.palette.surface

        let text_color = match self.variant:
            case ChipVariant::Filled:
                if self.selected { &theme.palette.surface } else { &theme.palette.text_primary }
            case ChipVariant::Outlined:
                if self.selected { &theme.palette.primary } else { &theme.palette.text_primary }

        let mut chip = Element::new(self.id, ElementKind::Span)
            .with_class("chip")
            .with_style("display", "inline-flex")
            .with_style("align-items", "center")
            .with_style("padding", "4px 12px")
            .with_style("border-radius", &f"{theme.border_radius.full}px")
            .with_style("background-color", &color_to_style(bg_color))
            .with_style("color", &color_to_style(text_color))

        if self.variant == ChipVariant::Outlined:
            chip = chip.with_style("border", &f"1px solid {color_to_style(&theme.palette.border)}")

        # Add icon if present
        if let Some(icon) = &self.icon:
            let icon_elem = Element::new(alloc(), ElementKind::Span)
                .with_text(icon)
                .with_class("chip-icon")
                .with_style("margin-right", "4px")
            chip = chip.with_child(icon_elem)

        # Add label
        let label_elem = Element::new(alloc(), ElementKind::Span)
            .with_text(&self.label)
            .with_class("chip-label")
        chip = chip.with_child(label_elem)

        # Add delete button if deletable
        if self.deletable:
            let delete_elem = Element::new(alloc(), ElementKind::Span)
                .with_text("Ã—")
                .with_class("chip-delete")
                .with_style("margin-left", "4px")
                .with_style("cursor", "pointer")
            chip = chip.with_child(delete_elem)

        return chip

# Avatar component - user/entity image
pub struct Avatar:
    id: NodeId
    src: Option<String>  # Image URL
    alt: String
    initials: Option<String>
    size: AvatarSize

pub enum AvatarSize:
    Small   # 32px
    Medium  # 40px
    Large   # 56px

impl Avatar:
    pub fn new(id: NodeId, alt: &str) -> Avatar:
        return Avatar {
            id: id,
            src: None,
            alt: alt.to_string(),
            initials: None,
            size: AvatarSize::Medium
        }

    pub fn with_src(self, src: &str) -> Avatar:
        self.src = Some(src.to_string())
        return self

    pub fn with_initials(self, initials: &str) -> Avatar:
        self.initials = Some(initials.to_string())
        return self

    pub fn small(self) -> Avatar:
        self.size = AvatarSize::Small
        return self

    pub fn large(self) -> Avatar:
        self.size = AvatarSize::Large
        return self

    pub fn to_element(self, alloc: fn() -> NodeId, theme: &Theme) -> Element:
        let size_px = match self.size:
            case AvatarSize::Small: 32
            case AvatarSize::Medium: 40
            case AvatarSize::Large: 56

        let mut avatar = Element::new(self.id, ElementKind::Div)
            .with_class("avatar")
            .with_style("width", &f"{size_px}px")
            .with_style("height", &f"{size_px}px")
            .with_style("border-radius", "50%")
            .with_style("overflow", "hidden")
            .with_style("display", "flex")
            .with_style("align-items", "center")
            .with_style("justify-content", "center")
            .with_style("background-color", &color_to_style(&theme.palette.primary_light))

        if let Some(src) = &self.src:
            # Image avatar
            avatar = avatar.with_attr("style", &f"background-image: url({src}); background-size: cover;")
        else if let Some(initials) = &self.initials:
            # Initials avatar
            let text_elem = Element::new(alloc(), ElementKind::Span)
                .with_text(initials)
                .with_style("color", &color_to_style(&theme.palette.primary_dark))
                .with_style("font-weight", "500")
            avatar = avatar.with_child(text_elem)

        return avatar

# Badge component - small count/status indicator
pub struct Badge:
    id: NodeId
    content: String
    variant: BadgeVariant
    max: Option<u32>

pub enum BadgeVariant:
    Default
    Primary
    Secondary
    Error
    Success

impl Badge:
    pub fn new(id: NodeId, content: &str) -> Badge:
        return Badge {
            id: id,
            content: content.to_string(),
            variant: BadgeVariant::Default,
            max: None
        }

    pub fn count(id: NodeId, count: u32) -> Badge:
        return Badge {
            id: id,
            content: count.to_string(),
            variant: BadgeVariant::Default,
            max: None
        }

    pub fn with_max(self, max: u32) -> Badge:
        self.max = Some(max)
        if let Ok(count) = self.content.parse_int():
            if (count as u32) > max:
                self.content = f"{max}+"
        return self

    pub fn primary(self) -> Badge:
        self.variant = BadgeVariant::Primary
        return self

    pub fn error(self) -> Badge:
        self.variant = BadgeVariant::Error
        return self

    pub fn success(self) -> Badge:
        self.variant = BadgeVariant::Success
        return self

    pub fn to_element(self, alloc: fn() -> NodeId, theme: &Theme) -> Element:
        let bg_color = match self.variant:
            case BadgeVariant::Default: &theme.palette.secondary
            case BadgeVariant::Primary: &theme.palette.primary
            case BadgeVariant::Secondary: &theme.palette.secondary
            case BadgeVariant::Error: &theme.palette.error
            case BadgeVariant::Success: &theme.palette.success

        return Element::new(self.id, ElementKind::Span)
            .with_class("badge")
            .with_text(&self.content)
            .with_style("display", "inline-flex")
            .with_style("align-items", "center")
            .with_style("justify-content", "center")
            .with_style("min-width", "20px")
            .with_style("height", "20px")
            .with_style("padding", "0 6px")
            .with_style("border-radius", "10px")
            .with_style("background-color", &color_to_style(bg_color))
            .with_style("color", &color_to_style(&theme.palette.surface))
            .with_style("font-size", "12px")
            .with_style("font-weight", "500")

# Tooltip component - hover information
pub struct Tooltip:
    id: NodeId
    content: String
    position: TooltipPosition

pub enum TooltipPosition:
    Top
    Bottom
    Left
    Right

impl Tooltip:
    pub fn new(id: NodeId, content: &str) -> Tooltip:
        return Tooltip {
            id: id,
            content: content.to_string(),
            position: TooltipPosition::Top
        }

    pub fn bottom(self) -> Tooltip:
        self.position = TooltipPosition::Bottom
        return self

    pub fn left(self) -> Tooltip:
        self.position = TooltipPosition::Left
        return self

    pub fn right(self) -> Tooltip:
        self.position = TooltipPosition::Right
        return self

    pub fn to_element(self, alloc: fn() -> NodeId, theme: &Theme) -> Element:
        return Element::new(self.id, ElementKind::Span)
            .with_class("tooltip")
            .with_attr("data-tooltip", &self.content)
            .with_attr("data-position", &self.position_str())
            .with_style("position", "relative")

    fn position_str() -> &str:
        match self.position:
            case TooltipPosition::Top: return "top"
            case TooltipPosition::Bottom: return "bottom"
            case TooltipPosition::Left: return "left"
            case TooltipPosition::Right: return "right"

# Divider component - visual separator
pub struct Divider:
    id: NodeId
    orientation: DividerOrientation
    variant: DividerVariant

pub enum DividerOrientation:
    Horizontal
    Vertical

pub enum DividerVariant:
    Full
    Inset
    Middle

impl Divider:
    pub fn horizontal(id: NodeId) -> Divider:
        return Divider {
            id: id,
            orientation: DividerOrientation::Horizontal,
            variant: DividerVariant::Full
        }

    pub fn vertical(id: NodeId) -> Divider:
        return Divider {
            id: id,
            orientation: DividerOrientation::Vertical,
            variant: DividerVariant::Full
        }

    pub fn inset(self) -> Divider:
        self.variant = DividerVariant::Inset
        return self

    pub fn middle(self) -> Divider:
        self.variant = DividerVariant::Middle
        return self

    pub fn to_element(self, theme: &Theme) -> Element:
        let mut divider = Element::new(self.id, ElementKind::Div)
            .with_class("divider")
            .with_style("background-color", &color_to_style(&theme.palette.border))

        match self.orientation:
            case DividerOrientation::Horizontal:
                divider = divider
                    .with_style("height", "1px")
                    .with_style("width", "100%")

                match self.variant:
                    case DividerVariant::Inset:
                        divider = divider.with_style("margin-left", "72px")
                    case DividerVariant::Middle:
                        divider = divider
                            .with_style("margin-left", "16px")
                            .with_style("margin-right", "16px")
                    case DividerVariant::Full: pass

            case DividerOrientation::Vertical:
                divider = divider
                    .with_style("width", "1px")
                    .with_style("height", "100%")
                    .with_style("align-self", "stretch")

        return divider

# Helper to convert Color to CSS style string
fn color_to_style(color: &Color) -> String:
    let rgba = color.to_rgba()
    let r = (rgba >> 16) & 0xFF
    let g = (rgba >> 8) & 0xFF
    let b = rgba & 0xFF
    return f"rgb({r}, {g}, {b})"
