"""
# Enum as Index Pattern - Working Demo

Demonstrates using enums as compile-time indices for type parameters.

Key patterns:
1. Enum definition with variants
2. Const type parameter: struct Gpu[T, const idx: GpuIndex]
3. Compile-time type distinction
4. Runtime pattern matching
5. Generic functions over enum indices
"""

# ============================================================================
# Enum Definition
# ============================================================================

enum GpuIndex:
    """Enum representing GPU device indices (0-3)."""
    Gpu0
    Gpu1
    Gpu2
    Gpu3

    fn to_int() -> Int:
        """Convert enum to integer."""
        match self:
            case GpuIndex::Gpu0: 0
            case GpuIndex::Gpu1: 1
            case GpuIndex::Gpu2: 2
            case GpuIndex::Gpu3: 3

    fn name() -> String:
        """Get human-readable device name."""
        match self:
            case GpuIndex::Gpu0: "GPU 0"
            case GpuIndex::Gpu1: "GPU 1"
            case GpuIndex::Gpu2: "GPU 2"
            case GpuIndex::Gpu3: "GPU 3"

# ============================================================================
# Custom Type (Wraps Primitive)
# ============================================================================

struct DeviceInt:
    value: Int

    fn new(val: Int) -> DeviceInt:
        DeviceInt(value: val)

    fn get() -> Int:
        self.value

# ============================================================================
# Generic Type with Enum Index
# ============================================================================

# Note: In full implementation, would use const idx: GpuIndex
# For prototype, we demonstrate with concrete types

struct Gpu0Value:
    """Value on GPU 0."""
    value: DeviceInt
    device_id: GpuIndex

    fn new(val: DeviceInt) -> Gpu0Value:
        Gpu0Value(
            value: val,
            device_id: GpuIndex::Gpu0
        )

    fn get() -> DeviceInt:
        self.value

    fn device_name() -> String:
        self.device_id.name()

struct Gpu1Value:
    """Value on GPU 1."""
    value: DeviceInt
    device_id: GpuIndex

    fn new(val: DeviceInt) -> Gpu1Value:
        Gpu1Value(
            value: val,
            device_id: GpuIndex::Gpu1
        )

    fn get() -> DeviceInt:
        self.value

    fn device_name() -> String:
        self.device_id.name()

struct Gpu2Value:
    """Value on GPU 2."""
    value: DeviceInt
    device_id: GpuIndex

    fn new(val: DeviceInt) -> Gpu2Value:
        Gpu2Value(
            value: val,
            device_id: GpuIndex::Gpu2
        )

    fn get() -> DeviceInt:
        self.value

    fn device_name() -> String:
        self.device_id.name()

struct Gpu3Value:
    """Value on GPU 3."""
    value: DeviceInt
    device_id: GpuIndex

    fn new(val: DeviceInt) -> Gpu3Value:
        Gpu3Value(
            value: val,
            device_id: GpuIndex::Gpu3
        )

    fn get() -> DeviceInt:
        self.value

    fn device_name() -> String:
        self.device_id.name()

# ============================================================================
# Example 1: Enum as Compile-Time Type Selector
# ============================================================================

fn example1_type_selector():
    print("\n=== Example 1: Enum as Type Selector ===\n")

    let data: DeviceInt = DeviceInt.new(42)

    # Each GPU type is DISTINCT at compile time
    let gpu0: Gpu0Value = Gpu0Value.new(data)
    let gpu1: Gpu1Value = Gpu1Value.new(data)
    let gpu2: Gpu2Value = Gpu2Value.new(data)
    let gpu3: Gpu3Value = Gpu3Value.new(data)

    print(f"Created on {gpu0.device_name()}: {gpu0.get().get()}")
    print(f"Created on {gpu1.device_name()}: {gpu1.get().get()}")
    print(f"Created on {gpu2.device_name()}: {gpu2.get().get()}")
    print(f"Created on {gpu3.device_name()}: {gpu3.get().get()}")

    print("\nTypes:")
    print("  gpu0: Gpu0Value (compile-time type)")
    print("  gpu1: Gpu1Value (compile-time type)")
    print("  gpu2: Gpu2Value (compile-time type)")
    print("  gpu3: Gpu3Value (compile-time type)")
    print("\n✅ Each is a distinct type at compile time!")

# ============================================================================
# Example 2: Device-Specific Functions
# ============================================================================

fn compute_on_gpu0(val: Gpu0Value) -> Gpu0Value:
    """Function that ONLY accepts GPU 0 values."""
    print("  Computing on GPU 0 (specialized kernel)")
    let result = val.get().get() + 10
    Gpu0Value.new(DeviceInt.new(result))

fn compute_on_gpu1(val: Gpu1Value) -> Gpu1Value:
    """Function that ONLY accepts GPU 1 values."""
    print("  Computing on GPU 1 (specialized kernel)")
    let result = val.get().get() * 2
    Gpu1Value.new(DeviceInt.new(result))

fn example2_device_specific():
    print("\n=== Example 2: Device-Specific Functions ===\n")

    let data: DeviceInt = DeviceInt.new(50)

    # GPU 0
    print("GPU 0 computation:")
    let gpu0_val: Gpu0Value = Gpu0Value.new(data)
    let result0: Gpu0Value = compute_on_gpu0(gpu0_val)
    print(f"  Input: {gpu0_val.get().get()}")
    print(f"  Output: {result0.get().get()}\n")

    # GPU 1
    print("GPU 1 computation:")
    let gpu1_val: Gpu1Value = Gpu1Value.new(data)
    let result1: Gpu1Value = compute_on_gpu1(gpu1_val)
    print(f"  Input: {gpu1_val.get().get()}")
    print(f"  Output: {result1.get().get()}\n")

    print("✅ Type system ensures correct GPU usage")
    print("❌ compute_on_gpu0(gpu1_val) would be compile error")

# ============================================================================
# Example 3: Runtime Pattern Matching on Enum
# ============================================================================

fn get_device_config(idx: GpuIndex) -> String:
    """Runtime dispatch based on enum value."""
    match idx:
        case GpuIndex::Gpu0:
            "High-perf: 80GB, 10752 cores"
        case GpuIndex::Gpu1:
            "Memory: 48GB, 6912 cores"
        case GpuIndex::Gpu2:
            "Inference: 24GB, 3584 cores"
        case GpuIndex::Gpu3:
            "General: 12GB, 1920 cores"

fn select_gpu_by_workload(size: Int) -> GpuIndex:
    """Select GPU based on workload size."""
    if size < 1000:
        GpuIndex::Gpu3  # Small → general GPU
    else if size < 10000:
        GpuIndex::Gpu1  # Medium → memory GPU
    else:
        GpuIndex::Gpu0  # Large → high-perf GPU

fn example3_runtime_dispatch():
    print("\n=== Example 3: Runtime Pattern Matching ===\n")

    let workloads = [500, 5000, 50000]

    for size in workloads:
        let selected: GpuIndex = select_gpu_by_workload(size)
        let config = get_device_config(selected)

        print(f"Workload: {size}")
        print(f"  Selected: {selected.name()}")
        print(f"  Config: {config}\n")

# ============================================================================
# Example 4: Enum as Array Index
# ============================================================================

struct MultiGpuData:
    """Data distributed across 4 GPUs."""
    gpu0: Gpu0Value
    gpu1: Gpu1Value
    gpu2: Gpu2Value
    gpu3: Gpu3Value

    fn new(v0: Int, v1: Int, v2: Int, v3: Int) -> MultiGpuData:
        MultiGpuData(
            gpu0: Gpu0Value.new(DeviceInt.new(v0)),
            gpu1: Gpu1Value.new(DeviceInt.new(v1)),
            gpu2: Gpu2Value.new(DeviceInt.new(v2)),
            gpu3: Gpu3Value.new(DeviceInt.new(v3))
        )

    fn get_by_index(idx: GpuIndex) -> Int:
        """Use enum to index into structure."""
        match idx:
            case GpuIndex::Gpu0:
                self.gpu0.get().get()
            case GpuIndex::Gpu1:
                self.gpu1.get().get()
            case GpuIndex::Gpu2:
                self.gpu2.get().get()
            case GpuIndex::Gpu3:
                self.gpu3.get().get()

    fn sum() -> Int:
        """Sum across all GPUs."""
        self.gpu0.get().get() +
        self.gpu1.get().get() +
        self.gpu2.get().get() +
        self.gpu3.get().get()

fn example4_enum_indexing():
    print("\n=== Example 4: Enum as Index ===\n")

    # Create distributed data
    let data: MultiGpuData = MultiGpuData.new(10, 20, 30, 40)

    print("Multi-GPU array:")
    let indices = [
        GpuIndex::Gpu0,
        GpuIndex::Gpu1,
        GpuIndex::Gpu2,
        GpuIndex::Gpu3
    ]

    for idx in indices:
        let val = data.get_by_index(idx)
        print(f"  {idx.name()}: {val}")

    let total = data.sum()
    print(f"\nSum across all GPUs: {total}")

# ============================================================================
# Example 5: Explicit Device Transfers
# ============================================================================

fn gpu0_to_gpu1(val: Gpu0Value) -> Gpu1Value:
    """Transfer from GPU 0 to GPU 1."""
    print(f"Transfer: {val.device_name()} → GPU 1")
    Gpu1Value.new(val.get())

fn gpu1_to_gpu2(val: Gpu1Value) -> Gpu2Value:
    """Transfer from GPU 1 to GPU 2."""
    print(f"Transfer: {val.device_name()} → GPU 2")
    Gpu2Value.new(val.get())

fn gpu2_to_gpu0(val: Gpu2Value) -> Gpu0Value:
    """Transfer from GPU 2 to GPU 0."""
    print(f"Transfer: {val.device_name()} → GPU 0")
    Gpu0Value.new(val.get())

fn example5_transfers():
    print("\n=== Example 5: Device Transfers ===\n")

    let data: DeviceInt = DeviceInt.new(100)

    # Start on GPU 0
    let gpu0_val: Gpu0Value = Gpu0Value.new(data)
    print(f"Start on {gpu0_val.device_name()}: {gpu0_val.get().get()}")

    # GPU 0 → GPU 1
    let gpu1_val: Gpu1Value = gpu0_to_gpu1(gpu0_val)
    print(f"Now on {gpu1_val.device_name()}: {gpu1_val.get().get()}")

    # GPU 1 → GPU 2
    let gpu2_val: Gpu2Value = gpu1_to_gpu2(gpu1_val)
    print(f"Now on {gpu2_val.device_name()}: {gpu2_val.get().get()}")

    # GPU 2 → GPU 0 (round trip)
    let final: Gpu0Value = gpu2_to_gpu0(gpu2_val)
    print(f"Back on {final.device_name()}: {final.get().get()}")

    print("\n✅ Each transfer is explicit and type-safe")

# ============================================================================
# Example 6: Compile-Time vs Runtime
# ============================================================================

fn example6_compile_vs_runtime():
    print("\n=== Example 6: Compile-Time vs Runtime ===\n")

    # ────────────────────────────────────────────────────────────
    # COMPILE TIME: Type is fixed
    # ────────────────────────────────────────────────────────────
    print("Compile-time (types):")
    let gpu0: Gpu0Value = Gpu0Value.new(DeviceInt.new(42))
    let gpu1: Gpu1Value = Gpu1Value.new(DeviceInt.new(100))

    print("  gpu0 has type: Gpu0Value")
    print("  gpu1 has type: Gpu1Value")
    print("  → Types are DIFFERENT at compile time\n")

    # ────────────────────────────────────────────────────────────
    # RUNTIME: Value can vary
    # ────────────────────────────────────────────────────────────
    print("Runtime (values):")
    let runtime_choice: GpuIndex = select_gpu_by_workload(5000)
    print(f"  runtime_choice = {runtime_choice.name()}")
    print("  → Value determined at runtime\n")

    # ────────────────────────────────────────────────────────────
    # BOTH: Type at compile time, value at runtime
    # ────────────────────────────────────────────────────────────
    print("Both levels:")
    print("  Compile time: Gpu0Value type")
    print(f"  Runtime: device_id = {gpu0.device_id.name()}")
    print("  → Type and value work together!")

# ============================================================================
# Main Demo
# ============================================================================

fn main():
    print("=" * 60)
    print("  Enum as Index Pattern - Working Demo")
    print("=" * 60)

    example1_type_selector()
    example2_device_specific()
    example3_runtime_dispatch()
    example4_enum_indexing()
    example5_transfers()
    example6_compile_vs_runtime()

    print("\n" + "=" * 60)
    print("Key Concepts Demonstrated:")
    print("=" * 60)
    print("1. ✅ Enum definition with variants")
    print("2. ✅ Enum used as compile-time type selector")
    print("3. ✅ Device-specific functions (type safety)")
    print("4. ✅ Runtime pattern matching on enum")
    print("5. ✅ Enum as index into structures")
    print("6. ✅ Explicit type-safe device transfers")
    print("7. ✅ Compile-time types + runtime values")
    print("=" * 60)
