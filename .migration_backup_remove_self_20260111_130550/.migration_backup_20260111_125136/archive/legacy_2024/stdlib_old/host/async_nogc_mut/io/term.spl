# Terminal I/O - Async terminal input/output operations
# Provides cross-platform terminal handling with ANSI support

use units.size.*
use core.*

# Terminal handle for I/O operations
pub struct Terminal:
    stdin: RawHandle
    stdout: RawHandle
    stderr: RawHandle
    is_tty: bool
    raw_mode: bool

impl Terminal:
    # Get the default terminal
    pub async fn default() -> Terminal:
        return Terminal {
            stdin: native_stdin(),
            stdout: native_stdout(),
            stderr: native_stderr(),
            is_tty: native_is_tty(native_stdout()),
            raw_mode: false
        }

    # Check if stdout is a TTY
    pub fn is_tty(self) -> bool:
        return self.is_tty

    # Check if raw mode is enabled
    pub fn is_raw_mode(self) -> bool:
        return self.raw_mode

    # Enable raw mode (no line buffering, no echo)
    pub async fn enable_raw_mode(self) -> Result[(), TermError]:
        if self.raw_mode:
            return Ok(())
        match native_enable_raw_mode(self.stdin):
            case 0:
                self.raw_mode = true
                return Ok(())
            case e: return Err(TermError::from_code(e))

    # Disable raw mode (restore normal terminal)
    pub async fn disable_raw_mode(self) -> Result[(), TermError]:
        if not self.raw_mode:
            return Ok(())
        match native_disable_raw_mode(self.stdin):
            case 0:
                self.raw_mode = false
                return Ok(())
            case e: return Err(TermError::from_code(e))

    # Get terminal size
    pub async fn size(self) -> Result[TermSize, TermError]:
        let mut rows: u16 = 0
        let mut cols: u16 = 0
        match native_get_term_size(self.stdout, &mut rows, &mut cols):
            case 0: return Ok(TermSize { rows: rows, cols: cols })
            case e: return Err(TermError::from_code(e))

    # Write string to stdout
    pub async fn write(self, s: &str) -> Result[ByteCount, TermError]:
        let written = native_term_write(self.stdout, s.as_ptr(), s.len())
        if written < 0:
            return Err(TermError::from_code(written as i32))
        return Ok((written as u64)_bytes)

    # Write line to stdout (with newline)
    pub async fn writeln(self, s: &str) -> Result[ByteCount, TermError]:
        let total = self.write(s).await?
        let nl = self.write("\n").await?
        return Ok(total + nl)

    # Write to stderr
    pub async fn write_err(self, s: &str) -> Result[ByteCount, TermError]:
        let written = native_term_write(self.stderr, s.as_ptr(), s.len())
        if written < 0:
            return Err(TermError::from_code(written as i32))
        return Ok((written as u64)_bytes)

    # Flush stdout
    pub async fn flush(self) -> Result[(), TermError]:
        match native_term_flush(self.stdout):
            case 0: return Ok(())
            case e: return Err(TermError::from_code(e))

    # Read a single byte from stdin
    pub async fn read_byte(self) -> Result[u8, TermError]:
        let mut buf: [u8; 1] = [0]
        let n = native_term_read(self.stdin, &mut buf[0], 1)
        if n < 0:
            return Err(TermError::from_code(n as i32))
        if n == 0:
            return Err(TermError::Eof)
        return Ok(buf[0])

    # Read bytes into buffer
    pub async fn read(self, buf: &mut [u8]) -> Result[ByteCount, TermError]:
        let n = native_term_read(self.stdin, buf.as_mut_ptr(), buf.len())
        if n < 0:
            return Err(TermError::from_code(n as i32))
        return Ok((n as u64)_bytes)

    # Read a line from stdin
    pub async fn read_line(self) -> Result[String, TermError]:
        let mut line = String::new()
        loop:
            let byte = self.read_byte().await?
            if byte == '\n' as u8:
                break
            if byte == '\r' as u8:
                # Handle CRLF
                continue
            line.push(byte as char)
        return Ok(line)

    # Read with timeout (milliseconds)
    pub async fn read_timeout(self, buf: &mut [u8], timeout_ms: u64) -> Result[ByteCount, TermError]:
        let n = native_term_read_timeout(self.stdin, buf.as_mut_ptr(), buf.len(), timeout_ms)
        if n < 0:
            return Err(TermError::from_code(n as i32))
        return Ok((n as u64)_bytes)

    # Check if input is available (non-blocking)
    pub async fn poll_input(self, timeout_ms: u64) -> Result[bool, TermError]:
        match native_term_poll(self.stdin, timeout_ms):
            case 1: return Ok(true)
            case 0: return Ok(false)
            case e: return Err(TermError::from_code(e))

    # Clear screen
    pub async fn clear(self) -> Result[(), TermError]:
        return self.write("\x1b[2J\x1b[H").await.map(|_| ())

    # Clear line
    pub async fn clear_line(self) -> Result[(), TermError]:
        return self.write("\x1b[2K").await.map(|_| ())

    # Move cursor to position (1-indexed)
    pub async fn move_to(self, row: u16, col: u16) -> Result[(), TermError]:
        return self.write(f"\x1b[{row};{col}H").await.map(|_| ())

    # Move cursor up
    pub async fn move_up(self, n: u16) -> Result[(), TermError]:
        if n > 0:
            return self.write(f"\x1b[{n}A").await.map(|_| ())
        return Ok(())

    # Move cursor down
    pub async fn move_down(self, n: u16) -> Result[(), TermError]:
        if n > 0:
            return self.write(f"\x1b[{n}B").await.map(|_| ())
        return Ok(())

    # Move cursor right
    pub async fn move_right(self, n: u16) -> Result[(), TermError]:
        if n > 0:
            return self.write(f"\x1b[{n}C").await.map(|_| ())
        return Ok(())

    # Move cursor left
    pub async fn move_left(self, n: u16) -> Result[(), TermError]:
        if n > 0:
            return self.write(f"\x1b[{n}D").await.map(|_| ())
        return Ok(())

    # Hide cursor
    pub async fn hide_cursor(self) -> Result[(), TermError]:
        return self.write("\x1b[?25l").await.map(|_| ())

    # Show cursor
    pub async fn show_cursor(self) -> Result[(), TermError]:
        return self.write("\x1b[?25h").await.map(|_| ())

    # Save cursor position
    pub async fn save_cursor(self) -> Result[(), TermError]:
        return self.write("\x1b[s").await.map(|_| ())

    # Restore cursor position
    pub async fn restore_cursor(self) -> Result[(), TermError]:
        return self.write("\x1b[u").await.map(|_| ())

    # Get cursor position
    pub async fn cursor_position(self) -> Result[CursorPos, TermError]:
        # Send position query
        self.write("\x1b[6n").await?
        self.flush().await?

        # Read response: ESC [ rows ; cols R
        let mut buf: [u8; 32] = [0; 32]
        let mut idx: u64 = 0

        # Read until 'R'
        loop:
            let byte = self.read_byte().await?
            if idx >= 32:
                return Err(TermError::InvalidResponse)
            buf[idx] = byte
            idx = idx + 1
            if byte == 'R' as u8:
                break

        # Parse response
        return parse_cursor_response(&buf[0..idx])

    # Set terminal title
    pub async fn set_title(self, title: &str) -> Result[(), TermError]:
        return self.write(f"\x1b]0;{title}\x07").await.map(|_| ())

    # Ring bell
    pub async fn bell(self) -> Result[(), TermError]:
        return self.write("\x07").await.map(|_| ())

    # Drop - restore terminal state
    fn drop():
        if self.raw_mode:
            native_disable_raw_mode(self.stdin)

# Terminal size
pub struct TermSize:
    rows: u16
    cols: u16

impl TermSize:
    pub fn rows(self) -> u16:
        return self.rows

    pub fn cols(self) -> u16:
        return self.cols

    pub fn area(self) -> u32:
        return (self.rows as u32) * (self.cols as u32)

# Cursor position
pub struct CursorPos:
    row: u16
    col: u16

impl CursorPos:
    pub fn row(self) -> u16:
        return self.row

    pub fn col(self) -> u16:
        return self.col

# Terminal error type
enum TermError:
    Io(i32)
    NotTty
    InvalidResponse
    Eof
    Timeout
    Interrupted
    Unknown

impl TermError:
    fn from_code(code: i32) -> TermError:
        match code:
            case -1: return TermError::Eof
            case -2: return TermError::NotTty
            case -3: return TermError::Timeout
            case -4: return TermError::Interrupted
            case _: return TermError::Io(code)

    pub fn message(self) -> &str:
        match self:
            case Io(code): return f"I/O error: {code}"
            case NotTty: return "not a tty"
            case InvalidResponse: return "invalid terminal response"
            case Eof: return "end of file"
            case Timeout: return "operation timed out"
            case Interrupted: return "operation interrupted"
            case Unknown: return "unknown error"

# Parse cursor position response
fn parse_cursor_response(buf: &[u8]) -> Result[CursorPos, TermError]:
    # Format: ESC [ rows ; cols R
    if buf.len() < 6:
        return Err(TermError::InvalidResponse)

    # Find positions
    let mut row: u16 = 0
    let mut col: u16 = 0
    let mut parsing_row = true

    for i in 2..buf.len():  # Skip ESC [
        let c = buf[i]
        if c == ';' as u8:
            parsing_row = false
        else if c == 'R' as u8:
            break
        else if c >= '0' as u8 and c <= '9' as u8:
            let digit = (c - '0' as u8) as u16
            if parsing_row:
                row = row * 10 + digit
            else:
                col = col * 10 + digit

    return Ok(CursorPos { row: row, col: col })

# Keyboard input handling
pub struct KeyEvent:
    code: KeyCode
    modifiers: KeyModifiers

pub enum KeyCode:
    Char(char)
    Enter
    Escape
    Backspace
    Tab
    Delete
    Insert
    Home
    End
    PageUp
    PageDown
    Up
    Down
    Left
    Right
    F(u8)  # F1-F12
    Null

pub struct KeyModifiers:
    shift: bool
    ctrl: bool
    alt: bool

impl KeyModifiers:
    pub fn none() -> KeyModifiers:
        return KeyModifiers { shift: false, ctrl: false, alt: false }

    pub fn shift() -> KeyModifiers:
        return KeyModifiers { shift: true, ctrl: false, alt: false }

    pub fn ctrl() -> KeyModifiers:
        return KeyModifiers { shift: false, ctrl: true, alt: false }

    pub fn alt() -> KeyModifiers:
        return KeyModifiers { shift: false, ctrl: false, alt: true }

# Read and parse a key event
pub async fn read_key(term: &mut Terminal) -> Result[KeyEvent, TermError]:
    let byte = term.read_byte().await?

    # Escape sequence
    if byte == 0x1b:
        # Check if more bytes available
        if term.poll_input(50).await? == false:
            return Ok(KeyEvent {
                code: KeyCode::Escape,
                modifiers: KeyModifiers::none()
            })

        let byte2 = term.read_byte().await?
        if byte2 == '[' as u8:
            return parse_csi_sequence(term).await
        else if byte2 == 'O' as u8:
            return parse_ss3_sequence(term).await
        else:
            # Alt + key
            return Ok(KeyEvent {
                code: KeyCode::Char(byte2 as char),
                modifiers: KeyModifiers::alt()
            })

    # Ctrl characters
    if byte < 32:
        match byte:
            case 0: return Ok(KeyEvent { code: KeyCode::Null, modifiers: KeyModifiers::none() })
            case 9: return Ok(KeyEvent { code: KeyCode::Tab, modifiers: KeyModifiers::none() })
            case 10: return Ok(KeyEvent { code: KeyCode::Enter, modifiers: KeyModifiers::none() })
            case 13: return Ok(KeyEvent { code: KeyCode::Enter, modifiers: KeyModifiers::none() })
            case 27: return Ok(KeyEvent { code: KeyCode::Escape, modifiers: KeyModifiers::none() })
            case _:
                # Ctrl+A through Ctrl+Z
                let ch = ('a' as u8 + byte - 1) as char
                return Ok(KeyEvent {
                    code: KeyCode::Char(ch),
                    modifiers: KeyModifiers::ctrl()
                })

    # Backspace
    if byte == 127:
        return Ok(KeyEvent { code: KeyCode::Backspace, modifiers: KeyModifiers::none() })

    # Regular character
    return Ok(KeyEvent {
        code: KeyCode::Char(byte as char),
        modifiers: KeyModifiers::none()
    })

# Parse CSI (Control Sequence Introducer) sequence: ESC [
async fn parse_csi_sequence(term: &mut Terminal) -> Result[KeyEvent, TermError]:
    let byte = term.read_byte().await?

    match byte:
        case 'A' as u8: return Ok(KeyEvent { code: KeyCode::Up, modifiers: KeyModifiers::none() })
        case 'B' as u8: return Ok(KeyEvent { code: KeyCode::Down, modifiers: KeyModifiers::none() })
        case 'C' as u8: return Ok(KeyEvent { code: KeyCode::Right, modifiers: KeyModifiers::none() })
        case 'D' as u8: return Ok(KeyEvent { code: KeyCode::Left, modifiers: KeyModifiers::none() })
        case 'H' as u8: return Ok(KeyEvent { code: KeyCode::Home, modifiers: KeyModifiers::none() })
        case 'F' as u8: return Ok(KeyEvent { code: KeyCode::End, modifiers: KeyModifiers::none() })
        case '1' as u8:
            let next = term.read_byte().await?
            if next == '~' as u8:
                return Ok(KeyEvent { code: KeyCode::Home, modifiers: KeyModifiers::none() })
            # F1-F4: ESC [ 1 1 ~ through ESC [ 1 4 ~
            if next >= '1' as u8 and next <= '5' as u8:
                term.read_byte().await?  # Read ~
                let fn_num = next - '0' as u8
                return Ok(KeyEvent { code: KeyCode::F(fn_num), modifiers: KeyModifiers::none() })
            return Ok(KeyEvent { code: KeyCode::Null, modifiers: KeyModifiers::none() })
        case '2' as u8:
            let next = term.read_byte().await?
            if next == '~' as u8:
                return Ok(KeyEvent { code: KeyCode::Insert, modifiers: KeyModifiers::none() })
            # F9-F12: ESC [ 2 0 ~ through ESC [ 2 4 ~
            return Ok(KeyEvent { code: KeyCode::Null, modifiers: KeyModifiers::none() })
        case '3' as u8:
            term.read_byte().await?  # Read ~
            return Ok(KeyEvent { code: KeyCode::Delete, modifiers: KeyModifiers::none() })
        case '4' as u8:
            term.read_byte().await?  # Read ~
            return Ok(KeyEvent { code: KeyCode::End, modifiers: KeyModifiers::none() })
        case '5' as u8:
            term.read_byte().await?  # Read ~
            return Ok(KeyEvent { code: KeyCode::PageUp, modifiers: KeyModifiers::none() })
        case '6' as u8:
            term.read_byte().await?  # Read ~
            return Ok(KeyEvent { code: KeyCode::PageDown, modifiers: KeyModifiers::none() })
        case _:
            return Ok(KeyEvent { code: KeyCode::Null, modifiers: KeyModifiers::none() })

# Parse SS3 sequence: ESC O
async fn parse_ss3_sequence(term: &mut Terminal) -> Result[KeyEvent, TermError]:
    let byte = term.read_byte().await?

    match byte:
        case 'P' as u8: return Ok(KeyEvent { code: KeyCode::F(1), modifiers: KeyModifiers::none() })
        case 'Q' as u8: return Ok(KeyEvent { code: KeyCode::F(2), modifiers: KeyModifiers::none() })
        case 'R' as u8: return Ok(KeyEvent { code: KeyCode::F(3), modifiers: KeyModifiers::none() })
        case 'S' as u8: return Ok(KeyEvent { code: KeyCode::F(4), modifiers: KeyModifiers::none() })
        case 'H' as u8: return Ok(KeyEvent { code: KeyCode::Home, modifiers: KeyModifiers::none() })
        case 'F' as u8: return Ok(KeyEvent { code: KeyCode::End, modifiers: KeyModifiers::none() })
        case _: return Ok(KeyEvent { code: KeyCode::Null, modifiers: KeyModifiers::none() })

# Raw handle type (platform-specific)
type RawHandle = i64

# Native function declarations
extern fn native_stdin() -> RawHandle
extern fn native_stdout() -> RawHandle
extern fn native_stderr() -> RawHandle
extern fn native_is_tty(handle: RawHandle) -> bool
extern fn native_enable_raw_mode(handle: RawHandle) -> i32
extern fn native_disable_raw_mode(handle: RawHandle) -> i32
extern fn native_get_term_size(handle: RawHandle, rows: *mut u16, cols: *mut u16) -> i32
extern fn native_term_write(handle: RawHandle, buf: *const u8, len: u64) -> i64
extern fn native_term_read(handle: RawHandle, buf: *mut u8, len: u64) -> i64
extern fn native_term_read_timeout(handle: RawHandle, buf: *mut u8, len: u64, timeout_ms: u64) -> i64
extern fn native_term_flush(handle: RawHandle) -> i32
extern fn native_term_poll(handle: RawHandle, timeout_ms: u64) -> i32

# ============================================================================
# Print Functions - Python-style print (parentheses optional at statement level)
# ============================================================================
# Usage (parentheses optional):
#   print "hello"           # prints: hello (no newline)
#   print("hello")          # same as above
#   println "hello"         # prints: hello\n
#   println("hello")        # same as above
#   print "a", "b", "c"     # prints: a b c
#   println "x =", x        # prints: x = 42\n
# ============================================================================

# Print to stdout (no newline)
pub fn print(args: ..any):
    let stdout = native_stdout()
    let mut first = true
    for arg in args:
        if not first:
            native_term_write(stdout, " ".as_ptr(), 1)
        native_term_write(stdout, arg.to_string().as_ptr(), arg.to_string().len())
        first = false
    native_term_flush(stdout)

# Print to stdout with newline
pub fn println(args: ..any):
    let stdout = native_stdout()
    let mut first = true
    for arg in args:
        if not first:
            native_term_write(stdout, " ".as_ptr(), 1)
        native_term_write(stdout, arg.to_string().as_ptr(), arg.to_string().len())
        first = false
    native_term_write(stdout, "\n".as_ptr(), 1)
    native_term_flush(stdout)

# Print to stderr (no newline)
pub fn eprint(args: ..any):
    let stderr = native_stderr()
    let mut first = true
    for arg in args:
        if not first:
            native_term_write(stderr, " ".as_ptr(), 1)
        native_term_write(stderr, arg.to_string().as_ptr(), arg.to_string().len())
        first = false
    native_term_flush(stderr)

# Print to stderr with newline
pub fn eprintln(args: ..any):
    let stderr = native_stderr()
    let mut first = true
    for arg in args:
        if not first:
            native_term_write(stderr, " ".as_ptr(), 1)
        native_term_write(stderr, arg.to_string().as_ptr(), arg.to_string().len())
        first = false
    native_term_write(stderr, "\n".as_ptr(), 1)
    native_term_flush(stderr)

# Print with custom separator
pub fn print_sep(sep: &str, args: ..any):
    let stdout = native_stdout()
    let mut first = true
    for arg in args:
        if not first:
            native_term_write(stdout, sep.as_ptr(), sep.len())
        native_term_write(stdout, arg.to_string().as_ptr(), arg.to_string().len())
        first = false
    native_term_flush(stdout)

# Print with custom separator and newline
pub fn println_sep(sep: &str, args: ..any):
    let stdout = native_stdout()
    let mut first = true
    for arg in args:
        if not first:
            native_term_write(stdout, sep.as_ptr(), sep.len())
        native_term_write(stdout, arg.to_string().as_ptr(), arg.to_string().len())
        first = false
    native_term_write(stdout, "\n".as_ptr(), 1)
    native_term_flush(stdout)

# Debug print with location info (like Rust's dbg!)
pub macro dbg(expr: Any) -> (returns result: Any):
    emit result:
        let val = expr
        eprintln "[{__FILE__}:{__LINE__}] {stringify!(expr)} = {val}"
        return val

# Read line from stdin (like Python's input())
pub fn input(prompt: &str = "") -> String:
    if prompt.len() > 0:
        print prompt
    let stdin = native_stdin()
    let mut line = String::new()
    let mut buf: [u8; 1] = [0]
    loop:
        let n = native_term_read(stdin, &mut buf[0], 1)
        if n <= 0:
            break
        let byte = buf[0]
        if byte == '\n' as u8:
            break
        if byte == '\r' as u8:
            continue
        line.push(byte as char)
    return line

# Read line with default value
pub fn input_or(prompt: &str, default: &str) -> String:
    let result = input(prompt)
    if result.is_empty():
        return default.to_string()
    return result

# Read integer from stdin
pub fn input_int(prompt: &str = "") -> Result[i64, ParseError]:
    let s = input(prompt)
    return s.parse_int()

# Read float from stdin
pub fn input_float(prompt: &str = "") -> Result[f64, ParseError]:
    let s = input(prompt)
    return s.parse_float()

# Yes/No prompt
pub fn confirm(prompt: &str, default: Option[bool] = None) -> bool:
    let suffix = match default:
        case Some(true): " [Y/n] "
        case Some(false): " [y/N] "
        case None: " [y/n] "

    loop:
        let response = input(prompt + suffix).trim().to_lowercase()
        if response.is_empty():
            match default:
                case Some(val): return val
                case None: continue
        if response == "y" or response == "yes":
            return true
        if response == "n" or response == "no":
            return false
        println "Please enter 'y' or 'n'"
