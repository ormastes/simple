# Diagram Configuration Module
# Configuration for diagram generation including output paths and options

import core.{Option, List, Path}
import filter.{DiagramFilter}

# Diagram type flags
struct DiagramTypes:
    sequence: Bool      # Generate sequence diagrams
    class_diagram: Bool # Generate class diagrams
    architecture: Bool  # Generate architecture diagrams

    fn new() -> DiagramTypes:
        return DiagramTypes {
            sequence: false,
            class_diagram: false,
            architecture: false,
        }

    fn all() -> DiagramTypes:
        return DiagramTypes {
            sequence: true,
            class_diagram: true,
            architecture: true,
        }

    fn any_enabled() -> Bool:
        return self.sequence or self.class_diagram or self.architecture

# Output format options
enum OutputFormat:
    Mermaid    # Mermaid markdown format
    PlantUML   # PlantUML format (future)
    Text       # Plain text (future)

impl OutputFormat:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_mermaid() -> bool:
        """Check if this is Mermaid format.

        Returns:
            true for Mermaid

        Example:
            OutputFormat::Mermaid.is_mermaid()  # → true
        """
        match self:
            case Mermaid: true
            case _: false

    fn is_plantuml() -> bool:
        """Check if this is PlantUML format.

        Returns:
            true for PlantUML

        Example:
            OutputFormat::PlantUML.is_plantuml()  # → true
        """
        match self:
            case PlantUML: true
            case _: false

    fn is_text() -> bool:
        """Check if this is Text format.

        Returns:
            true for Text

        Example:
            OutputFormat::Text.is_text()  # → true
        """
        match self:
            case Text: true
            case _: false

    fn is_markdown_based() -> bool:
        """Check if format uses markdown.

        Returns:
            true for Mermaid (embedded in markdown)

        Example:
            OutputFormat::Mermaid.is_markdown_based()  # → true
            OutputFormat::PlantUML.is_markdown_based()  # → false
        """
        match self:
            case Mermaid: true
            case _: false

    fn is_graphical() -> bool:
        """Check if format produces graphical output.

        Returns:
            true for Mermaid and PlantUML

        Example:
            OutputFormat::Mermaid.is_graphical()  # → true
            OutputFormat::Text.is_graphical()  # → false
        """
        match self:
            case Mermaid: true
            case PlantUML: true
            case Text: false

    fn supports_sequence_diagrams() -> bool:
        """Check if format supports sequence diagrams.

        Returns:
            true for all formats

        Example:
            OutputFormat::Mermaid.supports_sequence_diagrams()  # → true
        """
        true

    fn file_extension() -> String:
        """Get file extension for this format.

        Returns:
            File extension (without dot)

        Example:
            OutputFormat::Mermaid.file_extension()  # → "md"
            OutputFormat::PlantUML.file_extension()  # → "puml"
        """
        match self:
            case Mermaid: "md"
            case PlantUML: "puml"
            case Text: "txt"

    fn to_string() -> String:
        """Convert format to string.

        Returns:
            Format name

        Example:
            OutputFormat::Mermaid.to_string()  # → "mermaid"
        """
        match self:
            case Mermaid: "mermaid"
            case PlantUML: "plantuml"
            case Text: "text"

    fn description() -> String:
        """Get format description.

        Returns:
            Human-readable description

        Example:
            OutputFormat::Mermaid.description()
            # → "Mermaid markdown format"
        """
        match self:
            case Mermaid: "Mermaid markdown format"
            case PlantUML: "PlantUML format"
            case Text: "Plain text format"

    fn summary() -> String:
        """Get summary of output format.

        Returns:
            Human-readable summary

        Example:
            OutputFormat::Mermaid.summary()
            # → "OutputFormat: mermaid (graphical, markdown-based, .md)"
        """
        let name = self.to_string()
        let kind = if self.is_graphical(): "graphical" else: "text-only"
        let markdown = if self.is_markdown_based(): ", markdown-based" else: ""
        let ext = self.file_extension()
        return "OutputFormat: {name} ({kind}{markdown}, .{ext})"

# Configuration for diagram generation
class DiagramConfig:
    enabled: Bool                  # Master enable flag
    types: DiagramTypes            # Which diagram types to generate
    filter: DiagramFilter          # Include/exclude filter
    output_dir: Path               # Output directory
    output_format: OutputFormat    # Output format
    include_timing: Bool           # Include timing info in diagrams
    include_args: Bool             # Include argument values
    include_returns: Bool          # Include return values
    max_events: u32                # Max events to include (0 = unlimited)
    group_by_class: Bool           # Group participants by class

    fn new() -> DiagramConfig:
        return DiagramConfig {
            enabled: false,
            types: DiagramTypes.new(),
            filter: DiagramFilter.new(),
            output_dir: Path.from("target/diagrams"),
            output_format: OutputFormat.Mermaid,
            include_timing: true,
            include_args: true,
            include_returns: true,
            max_events: 0,
            group_by_class: true,
        }

    # Enable sequence diagrams
    fn with_sequence(mut self) -> DiagramConfig:
        self.enabled = true
        self.types.sequence = true
        return self

    # Enable class diagrams
    fn with_class_diagram(mut self) -> DiagramConfig:
        self.enabled = true
        self.types.class_diagram = true
        return self

    # Enable architecture diagrams
    fn with_architecture(mut self) -> DiagramConfig:
        self.enabled = true
        self.types.architecture = true
        return self

    # Enable all diagram types
    fn with_all(mut self) -> DiagramConfig:
        self.enabled = true
        self.types = DiagramTypes.all()
        return self

    # Set include filter
    fn with_include(mut self, patterns: String) -> DiagramConfig:
        self.filter.add_includes(patterns)
        return self

    # Set exclude filter
    fn with_exclude(mut self, patterns: String) -> DiagramConfig:
        self.filter.add_excludes(patterns)
        return self

    # Set output directory
    fn with_output_dir(mut self, dir: Path) -> DiagramConfig:
        self.output_dir = dir
        return self

    # Set output format
    fn with_format(mut self, format: OutputFormat) -> DiagramConfig:
        self.output_format = format
        return self

    # Disable timing info
    fn without_timing(mut self) -> DiagramConfig:
        self.include_timing = false
        return self

    # Disable argument values
    fn without_args(mut self) -> DiagramConfig:
        self.include_args = false
        return self

    # Disable return values
    fn without_returns(mut self) -> DiagramConfig:
        self.include_returns = false
        return self

    # Set max events limit
    fn with_max_events(mut self, max: u32) -> DiagramConfig:
        self.max_events = max
        return self

    # Check if any diagram generation is enabled
    fn is_enabled() -> Bool:
        return self.enabled and self.types.any_enabled()

    # Get output path for a specific test and diagram type
    fn get_output_path(test_name: String, diagram_type: String) -> Path:
        let filename = "${test_name}_${diagram_type}.md"
        return self.output_dir.join(filename)

# Parse config from CLI arguments
fn parse_cli_config(args: List[String]) -> DiagramConfig:
    let config = DiagramConfig.new()
    let i = 0

    while i < args.len():
        let arg = args[i]
        match arg:
            case "--seq-diagram":
                config = config.with_sequence()
            case "--class-diagram":
                config = config.with_class_diagram()
            case "--arch-diagram":
                config = config.with_architecture()
            case "--diagram-all":
                config = config.with_all()
            case "--seq-include":
                if i + 1 < args.len():
                    i += 1
                    config = config.with_include(args[i])
            case "--seq-exclude":
                if i + 1 < args.len():
                    i += 1
                    config = config.with_exclude(args[i])
            case "--diagram-output":
                if i + 1 < args.len():
                    i += 1
                    config = config.with_output_dir(Path.from(args[i]))
            case _:
                pass
        i += 1

    return config

# Global config instance
let _current_config: Option[DiagramConfig] = None

fn get_config() -> DiagramConfig:
    match _current_config:
        case Some(cfg):
            return cfg
        case None:
            return DiagramConfig.new()

fn set_config(config: DiagramConfig) -> Void:
    _current_config = Some(config)

fn clear_config() -> Void:
    _current_config = None

# Exports
export DiagramTypes, OutputFormat, DiagramConfig
export parse_cli_config, get_config, set_config, clear_config
