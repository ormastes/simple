# Query system for tree-sitter
# S-expression pattern matching for syntax highlighting and semantic analysis

import core.{Option, Result}
import parser.treesitter.tree.{Tree, Node, NodeId, Span}

# Captured node with name
struct Capture:
    name: str           # Capture name (e.g., "@keyword", "@function")
    node: Node          # Captured node
    index: i64          # Capture index in pattern

    fn new(name: str, node: Node, index: i64) -> Capture:
        return Capture(name: name, node: node, index: index)

# Query match result
struct QueryMatch:
    pattern_index: i64      # Which pattern matched
    captures: [Capture]     # All captured nodes in this match

    fn new(pattern_index: i64, captures: [Capture]) -> QueryMatch:
        return QueryMatch(pattern_index: pattern_index, captures: captures)

# Query pattern (simplified for Phase 4)
enum QueryPattern:
    # Match node by kind
    NodeKind(str)                           # (identifier)

    # Match with capture
    CaptureNode(str, str)                   # (identifier) @name

    # Match with field
    FieldNode(str, str, QueryPattern)       # name: (identifier)

    # Match with children
    ParentNode(str, [QueryPattern])         # (function_def ...)

    # Match keyword list
    KeywordList([str], str)                 # ["fn" "let" "return"] @keyword

impl QueryPattern:
    # =========================================================================
    # Helper Methods
    # =========================================================================

    fn is_node_kind() -> bool:
        """Check if this is NodeKind pattern.

        Returns:
            true for NodeKind

        Example:
            QueryPattern::NodeKind("id").is_node_kind()  # → true
        """
        match self:
            case NodeKind(_): true
            case _: false

    fn is_capture_node() -> bool:
        """Check if this is CaptureNode pattern.

        Returns:
            true for CaptureNode

        Example:
            QueryPattern::CaptureNode("id", "var").is_capture_node()  # → true
        """
        match self:
            case CaptureNode(_, _): true
            case _: false

    fn is_field_node() -> bool:
        """Check if this is FieldNode pattern.

        Returns:
            true for FieldNode

        Example:
            QueryPattern::FieldNode(...).is_field_node()  # → true
        """
        match self:
            case FieldNode(_, _, _): true
            case _: false

    fn is_parent_node() -> bool:
        """Check if this is ParentNode pattern.

        Returns:
            true for ParentNode

        Example:
            QueryPattern::ParentNode("func", []).is_parent_node()  # → true
        """
        match self:
            case ParentNode(_, _): true
            case _: false

    fn is_keyword_list() -> bool:
        """Check if this is KeywordList pattern.

        Returns:
            true for KeywordList

        Example:
            QueryPattern::KeywordList(["fn"], "kw").is_keyword_list()  # → true
        """
        match self:
            case KeywordList(_, _): true
            case _: false

    fn has_capture() -> bool:
        """Check if pattern captures nodes.

        Returns:
            true for CaptureNode or KeywordList

        Example:
            QueryPattern::CaptureNode("id", "v").has_capture()  # → true
            QueryPattern::NodeKind("id").has_capture()  # → false
        """
        match self:
            case CaptureNode(_, _): true
            case KeywordList(_, _): true
            case _: false

    fn is_nested() -> bool:
        """Check if pattern contains nested patterns.

        Returns:
            true for FieldNode or ParentNode

        Example:
            QueryPattern::ParentNode(...).is_nested()  # → true
        """
        match self:
            case FieldNode(_, _, _): true
            case ParentNode(_, _): true
            case _: false

    fn to_string() -> str:
        """Convert pattern to string.

        Returns:
            Pattern type name

        Example:
            QueryPattern::NodeKind("id").to_string()  # → "node_kind"
        """
        match self:
            case NodeKind(_): "node_kind"
            case CaptureNode(_, _): "capture_node"
            case FieldNode(_, _, _): "field_node"
            case ParentNode(_, _): "parent_node"
            case KeywordList(_, _): "keyword_list"

    fn description() -> String:
        """Get query pattern description.

        Returns:
            Human-readable description

        Example:
            QueryPattern::NodeKind("id").description()
            # → "Match node by kind"
        """
        match self:
            case NodeKind(_): "Match node by kind"
            case CaptureNode(_, _): "Match node with capture binding"
            case FieldNode(_, _, _): "Match node by field access"
            case ParentNode(_, _): "Match parent node with children"
            case KeywordList(_, _): "Match keyword list with capture"

    fn summary() -> str:
        """Get summary of query pattern.

        Returns:
            Human-readable summary

        Example:
            QueryPattern::NodeKind("identifier").summary()
            # → "QueryPattern: node_kind (no capture, simple)"
        """
        let name = self.to_string()
        let capture = if self.has_capture(): "capture" else: "no capture"
        let complexity = if self.is_nested(): "nested" else: "simple"
        return "QueryPattern: {name} ({capture}, {complexity})"

# Query struct
struct Query:
    patterns: [QueryPattern]        # List of patterns to match
    capture_names: [str]            # List of capture names (@keyword, @function, etc.)
    language: str                   # Language name

    fn new(language: str, query_str: str) -> Result<Query, str>:
        # Phase 4.1: Parse simple query strings
        # Phase 4.2: Full S-expression parser

        if language != "simple":
            return Err("Unsupported language: " + language)

        # For Phase 4.1: Pre-defined patterns for syntax highlighting
        let patterns = build_highlight_patterns()
        let capture_names = ["keyword", "function", "type", "number", "string", "comment", "operator"]

        return Ok(Query(
            patterns: patterns,
            capture_names: capture_names,
            language: language
        ))

# Build syntax highlighting patterns (Phase 4.1)
fn build_highlight_patterns() -> [QueryPattern]:
    return [
        # Keywords
        QueryPattern.KeywordList(
            ["fn", "let", "mut", "return", "if", "else", "elif", "struct", "class", "enum", "match", "case", "for", "while", "loop", "break", "continue"],
            "keyword"
        ),

        # Function names in definitions
        QueryPattern.FieldNode("function_def", "name",
            QueryPattern.CaptureNode("identifier", "function")),

        # Type identifiers
        QueryPattern.CaptureNode("type_identifier", "type"),

        # Numbers
        QueryPattern.CaptureNode("integer", "number"),
        QueryPattern.CaptureNode("float", "number"),

        # Strings
        QueryPattern.CaptureNode("string", "string"),
    ]

# Query cursor for executing queries
struct QueryCursor:
    query: Query
    tree: Tree
    matches: [QueryMatch]
    current_index: i64

    fn new(query: Query, tree: Tree) -> QueryCursor:
        let mut cursor = QueryCursor(
            query: query,
            tree: tree,
            matches: [],
            current_index: 0
        )

        # Execute query to find all matches
        cursor.execute()

        return cursor

    # Execute query on tree (find all matches)
    fn execute(mut self):
        # Walk tree and match patterns
        match self.tree.root():
            case Some(root):
                self.match_node(root, self.tree.root_node)
            case None:
                # Empty tree

    # Match patterns against a node and its children
    fn match_node(mut self, node: Node, node_id: NodeId):
        # Try to match each pattern against this node
        for i in range(self.query.patterns.len()):
            let pattern = self.query.patterns[i]
            match self.try_match_pattern(pattern, node, node_id):
                case Some(captures):
                    # Pattern matched - create QueryMatch
                    let match = QueryMatch.new(i, captures)
                    self.matches.push(match)
                case None:
                    # Pattern didn't match

        # Recursively match children
        for child_id in node.children:
            match self.tree.get_node(child_id):
                case Some(child):
                    self.match_node(child, child_id)
                case None:
                    # Invalid child ID

    # Try to match a pattern against a node
    fn try_match_pattern(pattern: QueryPattern, node: Node, node_id: NodeId) -> Option<[Capture>]:
        match pattern:
            case QueryPattern.NodeKind(kind):
                if node.kind == kind:
                    return Some([])
                else:
                    return None

            case QueryPattern.CaptureNode(kind, capture_name):
                if node.kind == kind:
                    let capture = Capture.new(capture_name, node, 0)
                    return Some([capture])
                else:
                    return None

            case QueryPattern.FieldNode(parent_kind, field_name, child_pattern):
                if node.kind == parent_kind:
                    # Try to find field
                    match node.child_by_field(field_name):
                        case Some(child_id):
                            # Match child pattern
                            match self.tree.get_node(child_id):
                                case Some(child_node):
                                    return self.try_match_pattern(child_pattern, child_node, child_id)
                                case None:
                                    return None
                        case None:
                            return None
                else:
                    return None

            case QueryPattern.KeywordList(keywords, capture_name):
                # Check if node is a keyword token
                for keyword in keywords:
                    if node.kind == keyword or node.text == keyword:
                        let capture = Capture.new(capture_name, node, 0)
                        return Some([capture])
                return None

            case _:
                return None

    # Get next match
    fn next_match(mut self) -> Option<QueryMatch>:
        if self.current_index < self.matches.len():
            let match = self.matches[self.current_index]
            self.current_index = self.current_index + 1
            return Some(match)
        else:
            return None

    # Reset cursor to beginning
    fn reset(mut self):
        self.current_index = 0

    # Get all matches
    fn all_matches() -> [QueryMatch]:
        return self.matches

# Helper: Convert capture name to semantic token type
fn capture_to_token_type(capture_name: str) -> str:
    match capture_name:
        case "keyword": return "keyword"
        case "function": return "function"
        case "type": return "type"
        case "number": return "number"
        case "string": return "string"
        case "comment": return "comment"
        case "operator": return "operator"
        case "variable": return "variable"
        case "parameter": return "parameter"
        case "property": return "property"
        case _: return "text"

# Syntax highlighting query (Phase 4.1)
const SYNTAX_HIGHLIGHTING_QUERY: str = """
[
  "fn" "let" "mut" "return" "if" "else" "elif"
  "struct" "class" "enum" "trait" "impl"
  "match" "case" "for" "while" "loop" "break" "continue"
] @keyword

(function_def name: (identifier) @function)
(struct_def name: (type_identifier) @type)
(class_def name: (type_identifier) @type)
(enum_def name: (type_identifier) @type)

(call callee: (identifier) @function.call)

(type_identifier) @type
(identifier) @variable

(integer) @number
(float) @number
(string) @string
(comment) @comment

["+", "-", "*", "/", "%", "==", "!=", "<", ">", "<=", ">="] @operator
"""

# Locals query for scoping (Phase 6)
const LOCALS_QUERY: str = """
(source_file) @scope
(function_def) @scope
(block) @scope

(function_def name: (identifier) @definition.function)
(let_stmt pattern: (identifier) @definition.var)
(parameter name: (identifier) @definition.parameter)

(identifier) @reference
"""
