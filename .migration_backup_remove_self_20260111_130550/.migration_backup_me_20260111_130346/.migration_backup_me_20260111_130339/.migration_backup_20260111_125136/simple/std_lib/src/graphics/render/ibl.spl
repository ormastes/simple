# Image-Based Lighting (IBL) - Environment-based illumination
#
# Implements diffuse irradiance and specular reflection from environment
# maps for realistic global illumination in PBR rendering.
#
# Based on: doc/spec/graphics_3d.md (Part 1.2: IBL)

use core.*
use graphics.math.*
use graphics.render.*

# =============================================================================
# IBL Configuration
# =============================================================================

pub struct IBLConfig:
    # Environment map resolution
    environment_resolution: i32        # Default: 2048 (HDR cubemap)
    irradiance_resolution: i32         # Default: 32 (diffuse)
    prefilter_resolution: i32          # Default: 512 (specular)
    brdf_lut_resolution: i32           # Default: 512

    # Mip levels for specular prefiltering
    prefilter_mip_levels: i32          # Default: 5

    # Quality settings
    irradiance_samples: i32            # Default: 1024 (convolution)
    prefilter_samples: i32             # Default: 128 (importance sampling)

impl IBLConfig:
    pub fn default() -> IBLConfig:
        return IBLConfig {
            environment_resolution: 2048,
            irradiance_resolution: 32,
            prefilter_resolution: 512,
            brdf_lut_resolution: 512,
            prefilter_mip_levels: 5,
            irradiance_samples: 1024,
            prefilter_samples: 128
        }

    pub fn high_quality() -> IBLConfig:
        return IBLConfig {
            environment_resolution: 4096,
            irradiance_resolution: 64,
            prefilter_resolution: 1024,
            brdf_lut_resolution: 512,
            prefilter_mip_levels: 6,
            irradiance_samples: 4096,
            prefilter_samples: 256
        }

    pub fn low_quality() -> IBLConfig:
        return IBLConfig {
            environment_resolution: 1024,
            irradiance_resolution: 16,
            prefilter_resolution: 256,
            brdf_lut_resolution: 256,
            prefilter_mip_levels: 4,
            irradiance_samples: 256,
            prefilter_samples: 64
        }

# =============================================================================
# Environment Map
# =============================================================================

pub struct EnvironmentMap:
    # Source environment cubemap (HDR)
    environment_cubemap_id: u64

    # IBL precomputed maps
    irradiance_map_id: u64             # Diffuse irradiance (32x32)
    prefiltered_map_id: u64            # Specular prefiltered (512x512, 5 mips)
    brdf_lut_id: u64                   # BRDF integration LUT (512x512)

    # Intensity modifiers
    diffuse_intensity: f32             # Default: 1.0
    specular_intensity: f32            # Default: 1.0

    # Rotation
    rotation: Quat

impl EnvironmentMap:
    # Create from HDR cubemap
    pub fn from_cubemap(
        cubemap_id: u64,
        config: IBLConfig
    ) -> EnvironmentMap:
        let mut env_map = EnvironmentMap {
            environment_cubemap_id: cubemap_id,
            irradiance_map_id: 0,
            prefiltered_map_id: 0,
            brdf_lut_id: 0,
            diffuse_intensity: 1.0,
            specular_intensity: 1.0,
            rotation: Quat::identity()
        }

        env_map.precompute_ibl_maps(config)
        return env_map

    # Create from equirectangular HDR image
    pub fn from_hdr(
        hdr_path: String,
        config: IBLConfig
    ) -> Result[EnvironmentMap, String]:
        # Load HDR image
        let hdr_texture_id = extern_load_hdr_image(hdr_path.as_ptr())

        if hdr_texture_id == 0:
            return Err("Failed to load HDR image: " + hdr_path)

        # Convert equirectangular to cubemap
        let cubemap_id = extern_equirect_to_cubemap(
            hdr_texture_id,
            config.environment_resolution
        )

        if cubemap_id == 0:
            return Err("Failed to convert HDR to cubemap")

        return Ok(EnvironmentMap::from_cubemap(cubemap_id, config))

    # Precompute IBL maps (diffuse, specular, BRDF LUT)
    fn precompute_ibl_maps(mut self, config: IBLConfig):
        # 1. Generate diffuse irradiance map (convolution)
        self.irradiance_map_id = self.generate_irradiance_map(config)

        # 2. Generate specular prefiltered environment
        self.prefiltered_map_id = self.generate_prefiltered_map(config)

        # 3. Generate BRDF integration LUT
        self.brdf_lut_id = self.generate_brdf_lut(config)

    # Generate diffuse irradiance map (convolution)
    fn generate_irradiance_map(config: IBLConfig) -> u64:
        # Create target cubemap
        let irradiance_map_id = extern_create_cubemap_texture(
            config.irradiance_resolution,
            TextureFormat::RGB16F
        )

        # Render to each face
        for face in 0..6:
            extern_bind_cubemap_face_framebuffer(irradiance_map_id, face)
            extern_set_viewport(0, 0, config.irradiance_resolution, config.irradiance_resolution)

            # Use irradiance convolution shader
            extern_use_shader("ibl_irradiance_convolution")
            extern_set_uniform_cubemap("u_EnvironmentMap", self.environment_cubemap_id)
            extern_set_uniform_int("u_Samples", config.irradiance_samples)
            extern_set_uniform_mat4("u_ViewMatrix", get_cubemap_view_matrix(face))
            extern_set_uniform_mat4("u_ProjectionMatrix", get_cubemap_projection_matrix())

            extern_render_fullscreen_quad()

        return irradiance_map_id

    # Generate specular prefiltered environment (importance sampling)
    fn generate_prefiltered_map(config: IBLConfig) -> u64:
        # Create target cubemap with mipmaps
        let prefiltered_map_id = extern_create_cubemap_texture_with_mips(
            config.prefilter_resolution,
            TextureFormat::RGB16F,
            config.prefilter_mip_levels
        )

        # Generate each mip level
        for mip in 0..config.prefilter_mip_levels:
            let mip_resolution = config.prefilter_resolution >> mip
            let roughness = mip as f32 / (config.prefilter_mip_levels - 1) as f32

            # Render to each face at this mip level
            for face in 0..6:
                extern_bind_cubemap_face_mip_framebuffer(prefiltered_map_id, face, mip)
                extern_set_viewport(0, 0, mip_resolution, mip_resolution)

                # Use prefilter shader
                extern_use_shader("ibl_prefilter")
                extern_set_uniform_cubemap("u_EnvironmentMap", self.environment_cubemap_id)
                extern_set_uniform_float("u_Roughness", roughness)
                extern_set_uniform_int("u_Samples", config.prefilter_samples)
                extern_set_uniform_mat4("u_ViewMatrix", get_cubemap_view_matrix(face))
                extern_set_uniform_mat4("u_ProjectionMatrix", get_cubemap_projection_matrix())

                extern_render_fullscreen_quad()

        return prefiltered_map_id

    # Generate BRDF integration lookup table
    fn generate_brdf_lut(config: IBLConfig) -> u64:
        # Create 2D texture (NdotV, roughness) -> (scale, bias)
        let brdf_lut_id = extern_create_2d_texture(
            config.brdf_lut_resolution,
            config.brdf_lut_resolution,
            TextureFormat::RG16F
        )

        # Render LUT
        extern_bind_texture_framebuffer(brdf_lut_id)
        extern_set_viewport(0, 0, config.brdf_lut_resolution, config.brdf_lut_resolution)

        extern_use_shader("ibl_brdf_lut")
        extern_set_uniform_int("u_Samples", 1024)

        extern_render_fullscreen_quad()

        return brdf_lut_id

    # Set intensity modifiers
    pub fn set_diffuse_intensity(mut self, intensity: f32):
        self.diffuse_intensity = intensity

    pub fn set_specular_intensity(mut self, intensity: f32):
        self.specular_intensity = intensity

    pub fn set_rotation(mut self, rotation: Quat):
        self.rotation = rotation

    # Bind IBL maps for rendering
    pub fn bind_for_rendering(self):
        extern_bind_cubemap_texture(3, self.irradiance_map_id)       # Slot 3
        extern_bind_cubemap_texture(4, self.prefiltered_map_id)      # Slot 4
        extern_bind_2d_texture(5, self.brdf_lut_id)                  # Slot 5

# =============================================================================
# IBL Manager - Scene-wide IBL management
# =============================================================================

pub struct IBLManager:
    active_environment: Option[EnvironmentMap]
    config: IBLConfig

impl IBLManager:
    pub fn new(config: IBLConfig) -> IBLManager:
        return IBLManager {
            active_environment: None,
            config: config
        }

    # Load environment from HDR file
    pub fn load_environment(mut self, hdr_path: String) -> Result[(), String]:
        let env_map = EnvironmentMap::from_hdr(hdr_path, self.config)?
        self.active_environment = Some(env_map)
        return Ok(())

    # Set environment from cubemap
    pub fn set_environment_cubemap(mut self, cubemap_id: u64):
        let env_map = EnvironmentMap::from_cubemap(cubemap_id, self.config)
        self.active_environment = Some(env_map)

    # Get active environment
    pub fn get_active_environment(self) -> Option[EnvironmentMap]:
        return self.active_environment

    # Bind for rendering
    pub fn bind_for_rendering(self):
        if self.active_environment.is_some():
            let env = self.active_environment.unwrap()
            env.bind_for_rendering()

# =============================================================================
# Cubemap Helper Functions
# =============================================================================

# Get view matrix for cubemap face
fn get_cubemap_view_matrix(face: i32) -> Mat4:
    # Cube face directions
    # 0: +X, 1: -X, 2: +Y, 3: -Y, 4: +Z, 5: -Z

    return if face == 0:
        Mat4::look_at(Vec3::zero(), Vec3::new( 1.0,  0.0,  0.0), Vec3::new(0.0, -1.0,  0.0))
    else if face == 1:
        Mat4::look_at(Vec3::zero(), Vec3::new(-1.0,  0.0,  0.0), Vec3::new(0.0, -1.0,  0.0))
    else if face == 2:
        Mat4::look_at(Vec3::zero(), Vec3::new( 0.0,  1.0,  0.0), Vec3::new(0.0,  0.0,  1.0))
    else if face == 3:
        Mat4::look_at(Vec3::zero(), Vec3::new( 0.0, -1.0,  0.0), Vec3::new(0.0,  0.0, -1.0))
    else if face == 4:
        Mat4::look_at(Vec3::zero(), Vec3::new( 0.0,  0.0,  1.0), Vec3::new(0.0, -1.0,  0.0))
    else:
        Mat4::look_at(Vec3::zero(), Vec3::new( 0.0,  0.0, -1.0), Vec3::new(0.0, -1.0,  0.0))

# Get projection matrix for cubemap (90Â° FOV, 1:1 aspect)
fn get_cubemap_projection_matrix() -> Mat4:
    return Mat4::perspective(
        90.0_deg.to_rad(),
        1.0,
        0.1,
        10.0
    )

# =============================================================================
# Texture Formats
# =============================================================================

pub enum TextureFormat:
    RGB16F       # HDR color (48-bit per pixel)
    RGBA16F      # HDR color + alpha
    RG16F        # 2-channel HDR
    RGB8         # LDR color
    RGBA8        # LDR color + alpha

impl TextureFormat:
    pub fn to_string(self) -> String:
        """Convert texture format to string."""
        match self:
            case RGB16F: "RGB16F"
            case RGBA16F: "RGBA16F"
            case RG16F: "RG16F"
            case RGB8: "RGB8"
            case RGBA8: "RGBA8"

    pub fn description(self) -> String:
        """Get texture format description."""
        match self:
            case RGB16F: "HDR color format (48-bit per pixel, 16-bit per channel)"
            case RGBA16F: "HDR color format with alpha (64-bit per pixel)"
            case RG16F: "2-channel HDR format (32-bit per pixel)"
            case RGB8: "LDR color format (24-bit per pixel, 8-bit per channel)"
            case RGBA8: "LDR color format with alpha (32-bit per pixel)"

    pub fn is_rgb16f(self) -> bool:
        """Check if format is RGB16F."""
        match self:
            case RGB16F: true
            case _: false

    pub fn is_rgba16f(self) -> bool:
        """Check if format is RGBA16F."""
        match self:
            case RGBA16F: true
            case _: false

    pub fn is_rg16f(self) -> bool:
        """Check if format is RG16F."""
        match self:
            case RG16F: true
            case _: false

    pub fn is_rgb8(self) -> bool:
        """Check if format is RGB8."""
        match self:
            case RGB8: true
            case _: false

    pub fn is_rgba8(self) -> bool:
        """Check if format is RGBA8."""
        match self:
            case RGBA8: true
            case _: false

    pub fn is_hdr(self) -> bool:
        """Check if format is HDR (high dynamic range)."""
        match self:
            case RGB16F: true
            case RGBA16F: true
            case RG16F: true
            case _: false

    pub fn is_ldr(self) -> bool:
        """Check if format is LDR (low dynamic range)."""
        match self:
            case RGB8: true
            case RGBA8: true
            case _: false

    pub fn has_alpha(self) -> bool:
        """Check if format has alpha channel."""
        match self:
            case RGBA16F: true
            case RGBA8: true
            case _: false

    pub fn channel_count(self) -> i32:
        """Get number of color channels."""
        match self:
            case RGB16F: 3
            case RGBA16F: 4
            case RG16F: 2
            case RGB8: 3
            case RGBA8: 4

    pub fn bytes_per_pixel(self) -> i32:
        """Get bytes per pixel."""
        match self:
            case RGB16F: 6
            case RGBA16F: 8
            case RG16F: 4
            case RGB8: 3
            case RGBA8: 4

    pub fn bits_per_channel(self) -> i32:
        """Get bits per color channel."""
        match self:
            case RGB16F: 16
            case RGBA16F: 16
            case RG16F: 16
            case RGB8: 8
            case RGBA8: 8

    pub fn is_floating_point(self) -> bool:
        """Check if format uses floating-point representation."""
        match self:
            case RGB16F: true
            case RGBA16F: true
            case RG16F: true
            case _: false

    pub fn summary(self) -> String:
        """Get texture format summary."""
        let name = self.to_string()
        let desc = self.description()
        let mut props = []
        if self.is_hdr():
            props.push("HDR")
        if self.is_ldr():
            props.push("LDR")
        if self.has_alpha():
            props.push("alpha")
        let channels = self.channel_count()
        props.push("{channels} channels")
        let bpp = self.bytes_per_pixel()
        props.push("{bpp} bytes/pixel")
        if props.len() > 0:
            let props_str = ", ".join(props)
            return "TextureFormat: {name} ({desc}, {props_str})"
        else:
            return "TextureFormat: {name} ({desc})"

# =============================================================================
# External FFI Functions
# =============================================================================

extern fn extern_load_hdr_image(path: *u8) -> u64
extern fn extern_equirect_to_cubemap(hdr_texture_id: u64, resolution: i32) -> u64
extern fn extern_create_cubemap_texture(resolution: i32, format: TextureFormat) -> u64
extern fn extern_create_cubemap_texture_with_mips(resolution: i32, format: TextureFormat, mip_levels: i32) -> u64
extern fn extern_create_2d_texture(width: i32, height: i32, format: TextureFormat) -> u64
extern fn extern_bind_cubemap_face_framebuffer(cubemap_id: u64, face: i32)
extern fn extern_bind_cubemap_face_mip_framebuffer(cubemap_id: u64, face: i32, mip: i32)
extern fn extern_bind_texture_framebuffer(texture_id: u64)
extern fn extern_set_viewport(x: i32, y: i32, width: i32, height: i32)
extern fn extern_use_shader(name: *u8)
extern fn extern_set_uniform_cubemap(name: *u8, cubemap_id: u64)
extern fn extern_set_uniform_int(name: *u8, value: i32)
extern fn extern_set_uniform_float(name: *u8, value: f32)
extern fn extern_set_uniform_mat4(name: *u8, matrix: Mat4)
extern fn extern_render_fullscreen_quad()
extern fn extern_bind_cubemap_texture(slot: i32, cubemap_id: u64)
extern fn extern_bind_2d_texture(slot: i32, texture_id: u64)
