/-
  Memory Safety Verification for Simple Language
  Generated by Simple Compiler

  This file contains Lean 4 formalizations of memory safety properties
  for the Main module.

  ## Verification Goals

  1. Reference Safety: All references point to valid memory
  2. Lifetime Safety: References don't outlive their referents
  3. Aliasing Control: Mutation respects aliasing rules
  4. Drop Safety: Resources are released correctly
-/

import Mathlib.Data.Set.Basic
import Mathlib.Order.Basic

namespace Main.MemorySafety


/-
  ## Core Memory Model Types
-/

-- Memory location (abstract address)
structure Loc where
  id : Nat
  deriving DecidableEq, Repr

-- Memory state (maps locations to values)
def MemState := Loc → Option Nat

-- Allocation status
inductive AllocStatus where
  | Allocated : AllocStatus
  | Freed : AllocStatus
  | Uninitialized : AllocStatus
  deriving DecidableEq, Repr

-- Heap representation
structure Heap where
  state : MemState
  alloc : Loc → AllocStatus

-- Initial empty heap
def Heap.empty : Heap := {
  state := fun _ => none,
  alloc := fun _ => AllocStatus.Uninitialized
}

-- Check if location is valid (allocated)
def Heap.isValid (h : Heap) (loc : Loc) : Bool :=
  h.alloc loc = AllocStatus.Allocated


/-
  ## Lifetime System
-/

-- Lifetime identifier
structure LifetimeId where
  id : Nat
  deriving DecidableEq, Repr, Ord

-- Static lifetime (lives forever)
def LifetimeId.static : LifetimeId := ⟨0⟩

-- Scope kind for lifetime tracking
inductive ScopeKind where
  | Module : ScopeKind
  | Function : ScopeKind
  | Block : ScopeKind
  | Expression : ScopeKind
  deriving DecidableEq, Repr

-- Scope with lifetime
structure Scope where
  lifetime : LifetimeId
  parent : Option LifetimeId
  kind : ScopeKind

-- Lifetime context
structure LifetimeCtx where
  scopes : List Scope
  current : LifetimeId

-- Check if a is an ancestor of b in the scope tree (helper)
-- Uses fuel-based recursion to enable termination proof
def isAncestorAux (scopes : List Scope) (ancestor child : LifetimeId) (fuel : Nat) : Bool :=
  if ancestor = child then true
  else if fuel = 0 then false
  else
    match scopes.find? (fun s => s.lifetime = child) with
    | some scope =>
      match scope.parent with
      | some parent => isAncestorAux scopes ancestor parent (fuel - 1)
      | none => false
    | none => false

def isAncestor (scopes : List Scope) (ancestor child : LifetimeId) : Bool :=
  isAncestorAux scopes ancestor child scopes.length

-- Outlives relation: a ≥ b means 'a outlives 'b
-- A lifetime outlives another if it is an ancestor in the scope tree
def outlives (ctx : LifetimeCtx) (a b : LifetimeId) : Bool :=
  if a = LifetimeId.static then true
  else if b = LifetimeId.static then false
  else
    -- Check if a is an ancestor of b (transitively) in the scope tree
    isAncestor ctx.scopes a b

-- Shorthand notation
notation:50 a " ≥ₗ " b => outlives _ a b

-- Static lifetime outlives all other lifetimes
theorem static_outlives_all (ctx : LifetimeCtx) (lt : LifetimeId) :
  outlives ctx LifetimeId.static lt = true := by
  simp [outlives]

-- Helper: isAncestorAux returns true when ancestor = child
theorem isAncestorAux_refl (scopes : List Scope) (lt : LifetimeId) (fuel : Nat) :
  isAncestorAux scopes lt lt fuel = true := by
  unfold isAncestorAux
  simp

-- Outlives is reflexive
theorem outlives_refl (ctx : LifetimeCtx) (lt : LifetimeId) :
  outlives ctx lt lt = true := by
  unfold outlives isAncestor
  by_cases h : lt = LifetimeId.static
  · simp [h]
  · simp [h]
    exact isAncestorAux_refl ctx.scopes lt ctx.scopes.length

-- Nothing outlives static (except static itself)
theorem nothing_outlives_static (ctx : LifetimeCtx) (lt : LifetimeId) :
  lt ≠ LifetimeId.static →
  outlives ctx lt LifetimeId.static = false := by
  intro h_ne
  simp only [outlives]
  simp [h_ne]


/-
  ## Reference Safety Predicates
-/

-- Reference origin (where a reference points)
inductive RefOrigin where
  | Local : String → LifetimeId → RefOrigin
  | Parameter : String → Nat → RefOrigin
  | Global : String → RefOrigin
  | Temporary : LifetimeId → RefOrigin
  | Field : RefOrigin → String → RefOrigin
  | Return : String → RefOrigin
  deriving Repr

-- Get the lifetime of a reference origin
def RefOrigin.lifetime : RefOrigin → LifetimeId
  | .Local _ lt => lt
  | .Parameter _ _ => LifetimeId.static  -- Params outlive function body
  | .Global _ => LifetimeId.static
  | .Temporary lt => lt
  | .Field base _ => base.lifetime
  | .Return _ => LifetimeId.static

-- A reference with lifetime tracking
structure Ref (α : Type) where
  value : α
  lifetime : LifetimeId
  origin : RefOrigin

-- Safe borrow predicate: borrow is valid if it doesn't outlive owner
def safeBorrow (ctx : LifetimeCtx) (borrowLt ownerLt : LifetimeId) : Prop :=
  outlives ctx ownerLt borrowLt = true

-- Reference escape check
def doesNotEscape (ctx : LifetimeCtx) (refLt targetLt : LifetimeId) : Prop :=
  outlives ctx refLt targetLt = true

-- Safe return predicate (reference doesn't escape function)
def safeReturn (origin : RefOrigin) : Prop :=
  match origin with
  | .Local _ _ => False  -- Cannot return local reference
  | .Temporary _ => False  -- Cannot return temporary
  | .Field base _ => safeReturn base
  | _ => True  -- Parameters and globals are safe to return

-- Global references are always safe to return
theorem global_safe_return (name : String) : safeReturn (RefOrigin.Global name) = True := rfl

-- Parameter references are always safe to return
theorem param_safe_return (name : String) (idx : Nat) : safeReturn (RefOrigin.Parameter name idx) = True := rfl

-- Return origins are safe to return
theorem return_safe_return (name : String) : safeReturn (RefOrigin.Return name) = True := rfl

-- Borrow from global is always safe (static lifetime)
theorem borrow_from_global_safe (ctx : LifetimeCtx) (name : String) (borrowLt : LifetimeId) :
    safeBorrow ctx borrowLt (RefOrigin.Global name).lifetime := by
  simp only [safeBorrow, RefOrigin.lifetime]
  exact static_outlives_all ctx borrowLt

-- Borrow from parameter is always safe (static lifetime in function body)
theorem borrow_from_param_safe (ctx : LifetimeCtx) (name : String) (idx : Nat) (borrowLt : LifetimeId) :
    safeBorrow ctx borrowLt (RefOrigin.Parameter name idx).lifetime := by
  simp only [safeBorrow, RefOrigin.lifetime]
  exact static_outlives_all ctx borrowLt


/-
  ## Pointer Types and Rules
-/

-- Pointer kind (matches Simple's memory model)
inductive PointerKind where
  | GC : PointerKind      -- T (GC-managed, default)
  | Unique : PointerKind  -- &T (unique/owned)
  | Shared : PointerKind  -- *T (reference-counted)
  | Weak : PointerKind    -- -T (weak reference)
  | Handle : PointerKind  -- +T (arena handle)
  deriving DecidableEq, Repr

-- Capability for mutation control
inductive Capability where
  | Shared : Capability   -- T (read-only, aliasable)
  | Exclusive : Capability -- mut T (mutable, exclusive)
  | Isolated : Capability  -- iso T (isolated, transferable)
  deriving DecidableEq, Repr

-- Typed pointer with capability
structure TypedPtr (α : Type) where
  kind : PointerKind
  capability : Capability
  loc : Loc

-- Aliasing rules
def canAlias (cap : Capability) : Bool :=
  match cap with
  | Capability.Shared => true
  | Capability.Exclusive => false
  | Capability.Isolated => false

def canMutate (cap : Capability) : Bool :=
  match cap with
  | Capability.Shared => false
  | Capability.Exclusive => true
  | Capability.Isolated => true

-- Basic capability properties
theorem shared_no_mut : canMutate Capability.Shared = false := rfl
theorem exclusive_allows_mut : canMutate Capability.Exclusive = true := rfl
theorem isolated_allows_mut : canMutate Capability.Isolated = true := rfl
theorem exclusive_no_alias : canAlias Capability.Exclusive = false := rfl
theorem isolated_no_alias : canAlias Capability.Isolated = false := rfl

-- Shared pointer is read-only (W1001 rule)
theorem shared_readonly : ∀ {α : Type} (ptr : TypedPtr α),
  ptr.capability = Capability.Shared →
  canMutate ptr.capability = false := by
  intro _ ptr hcap
  cases ptr with
  | mk _ capability _ =>
    cases hcap
    simp [canMutate]

-- Unique pointer has move semantics (W1002 rule)
def uniqueMoveOnly {α : Type} (ptr : TypedPtr α) : Prop :=
  ptr.kind = PointerKind.Unique → canAlias ptr.capability = false


/-
  ## Verification Obligations
-/

-- Compile-time warning counts (must be zero for Rust-level safety)
def sharedMutationWarnings : Nat := 0
def uniqueCopyWarnings : Nat := 0
def mutableSharedWarnings : Nat := 0
def escapingBorrowWarnings : Nat := 0
def potentialCycleWarnings : Nat := 0
def missingMutWarnings : Nat := 0
def lifetimeViolations : Nat := 0

-- Aggregated obligations (aliasing, move-only, and escape)
def aliasingWarnings : Nat := sharedMutationWarnings + mutableSharedWarnings
def moveOnlyWarnings : Nat := uniqueCopyWarnings
def escapeWarnings : Nat := escapingBorrowWarnings + lifetimeViolations

theorem aliasing_blocked : aliasingWarnings = 0 := by decide
theorem move_only_enforced : moveOnlyWarnings = 0 := by decide
theorem escape_blocked : escapeWarnings = 0 := by decide
theorem no_lifetime_violations : lifetimeViolations = 0 := by decide
theorem no_shared_mutation_warnings : sharedMutationWarnings = 0 := by decide
theorem no_mutable_shared_warnings : mutableSharedWarnings = 0 := by decide
theorem no_unique_copy_warnings : uniqueCopyWarnings = 0 := by decide
theorem no_escaping_borrow_warnings : escapingBorrowWarnings = 0 := by decide
theorem no_missing_mut_warnings : missingMutWarnings = 0 := by decide
theorem no_cycle_warnings : potentialCycleWarnings = 0 := by decide

-- Exclusive or isolated capabilities cannot alias
theorem no_alias_for_strong_caps {α : Type} (ptr : TypedPtr α) :
  (ptr.capability = Capability.Exclusive ∨ ptr.capability = Capability.Isolated) →
  canAlias ptr.capability = false := by
  intro h
  cases ptr with
  | mk _ capability _ =>
    cases h with
    | inl h_excl =>
        cases h_excl
        simp [canAlias]
    | inr h_iso =>
        cases h_iso
        simp [canAlias]

-- Compiler invariant: unique pointers have exclusive or isolated capability
def uniqueHasStrongCapability {α : Type} (ptr : TypedPtr α) : Prop :=
  ptr.kind = PointerKind.Unique →
  (ptr.capability = Capability.Exclusive ∨ ptr.capability = Capability.Isolated)

-- Move-only obligation for unique pointers (well-formed unique pointers)
-- This theorem proves that unique pointers with the compiler invariant cannot alias.
theorem unique_move_only {α : Type} (ptr : TypedPtr α)
    (h_invariant : uniqueHasStrongCapability ptr) :
    ptr.kind = PointerKind.Unique → canAlias ptr.capability = false := by
  intro h_unique
  have h_cap := h_invariant h_unique
  cases h_cap with
  | inl h_excl => simp [canAlias, h_excl]
  | inr h_iso => simp [canAlias, h_iso]

-- Corollary: Exclusive capability implies move-only for unique pointers
theorem unique_exclusive_move_only {α : Type} (ptr : TypedPtr α)
    (h_cap : ptr.capability = Capability.Exclusive) :
    ptr.kind = PointerKind.Unique → canAlias ptr.capability = false := by
  intro _
  simp [canAlias, h_cap]

-- Corollary: Isolated capability implies move-only for unique pointers
theorem unique_isolated_move_only {α : Type} (ptr : TypedPtr α)
    (h_cap : ptr.capability = Capability.Isolated) :
    ptr.kind = PointerKind.Unique → canAlias ptr.capability = false := by
  intro _
  simp [canAlias, h_cap]
            
end Main.MemorySafety

-- Lifetime-specific verification code from HIR lowering:
/-
  Lifetime verification generated from Simple compiler
  Scopes and lifetime relationships
-/

namespace LifetimeVerification

-- Lifetime identifiers
inductive Lifetime where
  | static : Lifetime
  | l1 : Lifetime
  | l2 : Lifetime
deriving DecidableEq, Repr

-- Outlives relation (a >= b means a outlives b)
def outlives : Lifetime → Lifetime → Bool
  | Lifetime.static, _ => true
  | _, Lifetime.static => false
  | Lifetime.l1, Lifetime.l2 => true
  | a, b => a == b

-- Verification theorems

-- Static outlives everything
theorem static_outlives_all (l : Lifetime) : outlives Lifetime.static l = true := by
  cases l <;> rfl

-- Outlives is reflexive
theorem outlives_refl (l : Lifetime) : outlives l l = true := by
  cases l <;> simp [outlives]

end LifetimeVerification
