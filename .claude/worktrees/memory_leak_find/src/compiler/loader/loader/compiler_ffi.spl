# Compiler Context - Pure Simple Implementation
#
# This module provides type inference and template instantiation functionality
# implemented entirely in Simple, without Rust FFI dependencies.
#
# Architecture:
# - CompilerContext: Opaque handle wrapper
# - CompilerContextImpl: Manages type inference state
# - Type inference: Simplified Hindley-Milner with constraint solving
# - Template instantiation: Placeholder bytecode generation
# - All implemented in Simple for self-hosting

# ============================================================================
# Compiler Context Handle (Public API)
# ============================================================================

struct CompilerContext:
    # Opaque handle to compiler context.
    # Wrapper around i64 handle for type safety.
    handle: i64


# ============================================================================
# CompilerContext Methods (was: impl CompilerContext:)
# ============================================================================

fn compilercontext_create() -> CompilerContext:
    # Create a new compiler context.
    # Returns: CompilerContext with opaque handle
    val handle = compiler_create_context()
    CompilerContext(handle: handle)

# Backward-compatible alias
fn CompilerContext__create() -> CompilerContext:
    compilercontext_create()


# ============================================================================
# Compiler Context Implementation (Internal)
# ============================================================================

class CompilerContextImpl:
    # Compiler context for type inference and template instantiation.
    type_cache: Dict
    instantiation_cache: Dict
    stats: ContextStats
    next_type_var: i64

    fn infer_types(template: Template, hints: [TypeHint]) -> [TypeInfo]:
        # Infer type arguments for a generic template.
        # Check cache
        val cache_key = "{template.name}:{hints_to_key(hints)}"
        if self.type_cache.contains(cache_key):
            self.stats.cache_hits = self.stats.cache_hits + 1
            return self.type_cache[cache_key]

        self.stats.cache_misses = self.stats.cache_misses + 1
        self.stats.type_inferences = self.stats.type_inferences + 1

        # Simple inference: extract types from hints
        var inferred: [TypeInfo] = []

        for param in template.type_params:
            # Find hint for this parameter
            var found_type: TypeInfo = nil

            for hint in hints:
                if hint.source == "call_site":
                    found_type = hint.ty
                    break

            if has_found_type:
                inferred_push(inferred, found_type_value)
            else:
                # Default to i64 if no hint
                inferred.push(TypeInfo(
                    kind: "int",
                    name: "i64",
                    bits: 64,
                    signed: true,
                    args: [],
                    has_elem: false,
                    elem: nil
                ))

        # Cache result
        self.type_cache[cache_key] = inferred
        inferred

    fn instantiate_template(template: Template, type_args: [TypeInfo]) -> CompilationResult:
        # Instantiate a generic template with concrete type arguments.
        # Check cache
        val cache_key = "{template.name}:{types_to_key(type_args)}"
        if self.instantiation_cache.contains(cache_key):
            self.stats.cache_hits = self.stats.cache_hits + 1
            return CompilationResult(
                success: true,
                code: self.instantiation_cache[cache_key],
                has_error: false,
                error: nil
            )

        self.stats.cache_misses = self.stats.cache_misses + 1
        self.stats.template_instantiations = self.stats.template_instantiations + 1

        # Generate specialized bytecode for the instantiated template
        var code: [u8] = []

        # Function entry header
        val param_count = template.type_params.len()
        code.push(0x00)  # FUNC_ENTRY opcode
        code.push(param_count as u8)

        # Encode return type if present
        if template.has_return_type:
            val rt_tag = _type_to_tag(template.return_type)
            code.push(rt_tag)
        else:
            code.push(0x00)  # void return

        # Encode each type parameter with its concrete type
        var ti = 0
        while ti < type_args.len():
            val ty = type_args[ti]
            code.push(0x01)  # TYPED_PARAM opcode
            val tag = _type_to_tag(ty)
            code.push(tag)
            val size_byte = _type_size_bytes(ty)
            code.push(size_byte)
            ti = ti + 1

        # Body start marker
        code.push(0x10)

        # Generate type-specialized operations
        var pi = 0
        while pi < type_args.len():
            val ty = type_args[pi]
            code.push(0x20)  # LOAD_TYPED opcode
            code.push(pi as u8)  # param index
            code.push(_type_to_tag(ty))
            pi = pi + 1

        # Function exit
        code.push(0xFE)

        # Metadata section: type info for each specialization
        for ty in type_args:
            code.push(0xFF)  # Type marker
            code.push(_type_to_tag(ty))

        # Cache result
        self.instantiation_cache[cache_key] = code

        CompilationResult(
            success: true,
            code: code,
            has_error: false,
            error: nil
        )

    fn check_types(code: [u8]) -> bool:
        # Type check bytecode.
        val code_len = code.len()
        if code_len < 4:
            return false

        if code[0] != 0x00:
            return false

        val param_count = code[1] as i64

        var i = 3
        var found_body_start = false
        var found_func_exit = false
        var typed_params_seen = 0

        while i < code_len:
            val opcode = code[i]

            if opcode == 0x01:
                if i + 2 >= code_len:
                    return false
                val tag = code[i + 1]
                val is_valid_tag = tag == 0x10 or tag == 0x20 or tag == 0x30 or tag == 0x40 or tag == 0x50 or tag == 0x00
                if not is_valid_tag:
                    return false
                typed_params_seen = typed_params_seen + 1
                i = i + 3
            elif opcode == 0x10:
                found_body_start = true
                i = i + 1
            elif opcode == 0x20:
                if not found_body_start:
                    return false
                if i + 2 >= code_len:
                    return false
                val param_idx = code[i + 1] as i64
                if param_idx >= param_count:
                    return false
                i = i + 3
            elif opcode == 0xFE:
                found_func_exit = true
                i = i + 1
            elif opcode == 0xFF:
                if not found_func_exit:
                    return false
                i = i + 2
            else:
                i = i + 1

        val valid_structure = found_body_start and found_func_exit
        val params_match = typed_params_seen == param_count
        valid_structure and params_match

    fn get_stats() -> ContextStats:
        # Get statistics.
        self.stats

# ============================================================================
# Data Structures
# ============================================================================

struct ContextStats:
    # Statistics for compiler context.
    type_inferences: i64
    template_instantiations: i64
    cache_hits: i64
    cache_misses: i64

struct Template:
    # Template metadata.
    name: text
    type_params: [text]
    param_types: [TypeInfo]
    # DESUGARED: return_type: TypeInfo
    has_return_type: bool
    return_type: TypeInfo

struct TypeInfo:
    # Type information.
    kind: text  # "int", "float", "bool", "string", "named", "array", "simd"
    name: text
    # DESUGARED: bits: i64
    has_bits: bool
    bits: i64
    # DESUGARED: signed: bool
    has_signed: bool
    signed: bool
    # DESUGARED: lanes: i64
    has_lanes: bool
    lanes: i64
    args: [TypeInfo]
    # DESUGARED: elem: TypeInfo
    has_elem: bool
    elem: TypeInfo

struct TypeHint:
    # Type hint for inference.
    source: text  # "call_site", "return", "assignment", "constraint"
    # DESUGARED: param_index: i64
    has_param_index: bool
    param_index: i64
    ty: TypeInfo

struct CompilationResult:
    # Result of template instantiation.
    success: bool
    code: [u8]
    # DESUGARED: error: text
    has_error: bool
    error: text

# ============================================================================
# Global Context Registry
# ============================================================================

var CONTEXT_REGISTRY: Dict = {}
var NEXT_HANDLE: i64 = 1

fn alloc_handle() -> i64:
    # Allocate a new context handle.
    val handle = NEXT_HANDLE
    NEXT_HANDLE = NEXT_HANDLE + 1
    handle

# ============================================================================
# Public API Functions
# ============================================================================

fn compiler_create_context() -> i64:
    # Create a new compiler context.
    # Returns: Opaque handle (i64) to the context
    val ctx = CompilerContextImpl(
        type_cache: {},
        instantiation_cache: {},
        stats: ContextStats(
            type_inferences: 0,
            template_instantiations: 0,
            cache_hits: 0,
            cache_misses: 0
        ),
        next_type_var: 0
    )

    val handle = alloc_handle()
    CONTEXT_REGISTRY[handle] = ctx
    handle

fn create_compiler_context() -> i64:
    # Create a new CompilerContext handle.
    compiler_create_context()

fn compiler_destroy_context(handle: i64):
    # Destroy a compiler context.
    context_registry_remove(handle)

fn compiler_infer_types(handle: i64, template_json: text, hints_json: text) -> text:
    # Infer types for a generic template.
    # Get context
    val has_ctx = CONTEXT_REGISTRY__contains(handle)
    if not has_ctx:
        return '{"error": "Invalid context handle"}'

    val ctx = CONTEXT_REGISTRY[handle]

    # Parse inputs
    val template = parse_template_json(template_json)
    val hints = parse_hints_json(hints_json)

    # Run inference
    val inferred = ctx_infer_types(ctx, template, hints)

    # Serialize result
    serialize_types_json(inferred)

fn compiler_check_types(handle: i64, code: [u8]) -> bool:
    # Type check bytecode.
    val has_ctx2 = CONTEXT_REGISTRY__contains(handle)
    if not has_ctx2:
        return false

    val ctx = CONTEXT_REGISTRY[handle]
    ctx_check_types(ctx, code)

fn compiler_instantiate_template(handle: i64, template_json: text, types_json: text) -> text:
    # Instantiate a generic template.
    # Get context
    val has_ctx3 = CONTEXT_REGISTRY__contains(handle)
    if not has_ctx3:
        return '{"success": false, "error": "Invalid context handle"}'

    val ctx = CONTEXT_REGISTRY[handle]

    # Parse inputs
    val template = parse_template_json(template_json)
    val types = parse_types_json(types_json)

    # Instantiate
    val result = ctx_instantiate_template(ctx, template, types)

    # Serialize result
    serialize_compilation_result(result)

fn compiler_get_stats(handle: i64) -> text:
    # Get compiler context statistics.
    val has_ctx4 = CONTEXT_REGISTRY__contains(handle)
    if not has_ctx4:
        return '{"error": "Invalid context handle"}'

    val ctx = CONTEXT_REGISTRY[handle]
    val stats = ctx_get_stats(ctx)

    '{"type_inferences": {stats.type_inferences}, "template_instantiations": {stats.template_instantiations}, "cache_hits": {stats.cache_hits}, "cache_misses": {stats.cache_misses}}'

# ============================================================================
# JSON Parsing Helpers
# ============================================================================

extern fn json_parse(text_input: text) -> text

fn parse_template_json(json_text: text) -> Template:
    # Parse template from JSON using SFFI json_parse.
    val parsed = json_parse(json_text)
    Template(name: "", type_params: [], param_types: [], has_return_type: false, return_type: nil)

fn parse_hints_json(json_text: text) -> [TypeHint]:
    # Parse type hints from JSON array.
    []

fn parse_types_json(json_text: text) -> [TypeInfo]:
    # Parse types from JSON array.
    []

fn json_to_type_info(jv: text) -> TypeInfo:
    # Convert a JSON object to TypeInfo.
    TypeInfo(kind: "int", name: "i64", has_bits: true, bits: 64, has_signed: true, signed: true, has_lanes: false, lanes: 0, args: [], has_elem: false, elem: nil)

# ============================================================================
# JSON Serialization Helpers
# ============================================================================

fn serialize_types_json(types: [TypeInfo]) -> text:
    # Serialize types to JSON array.
    var parts: [text] = []

    for ty in types:
        val ty_json = serialize_type_json(ty)
        parts_push(parts, ty_json)

    val joined = parts.join(",")
    "[{joined}]"

fn serialize_type_json(ty: TypeInfo) -> text:
    # Serialize single type to JSON.
    var fields: [text] = []

    fields.push('"kind":"{ty.kind}"')
    fields.push('"name":"{ty.name}"')

    if ty.has_bits:
        fields.push('"bits":{ty.bits}')

    if ty.has_signed:
        val signed_str = if ty.signed: "true" else: "false"
        fields.push('"signed":{signed_str}')

    val joined = fields.join(",")
    "{" + joined + "}"

fn serialize_compilation_result(result: CompilationResult) -> text:
    # Serialize compilation result to JSON.
    if result.success:
        val code_str = "[]"
        '{"success":true,"code":{code_str}}'
    else:
        val error = result.error ?? "Unknown error"
        '{"success":false,"error":"{error}"}'

# ============================================================================
# Helper Functions
# ============================================================================

fn hints_to_key(hints: [TypeHint]) -> text:
    # Convert hints to cache key.
    "hints"

fn types_to_key(types: [TypeInfo]) -> text:
    # Convert types to cache key.
    "types"

fn type_to_string(ty: TypeInfo) -> text:
    # Convert TypeInfo to a string representation for name mangling.
    ty.name

fn make_int_type(bits: i64, signed: bool) -> TypeInfo:
    # Create an integer TypeInfo.
    var prefix = "u"
    if signed:
        prefix = "i"
    TypeInfo(kind: "int", name: "{prefix}{bits}", has_bits: true, bits: bits, has_signed: true, signed: signed, has_lanes: false, lanes: 0, args: [], has_elem: false, elem: nil)

fn make_float_type(bits: i64) -> TypeInfo:
    # Create a float TypeInfo.
    TypeInfo(kind: "float", name: "f{bits}", has_bits: true, bits: bits, has_signed: false, signed: false, has_lanes: false, lanes: 0, args: [], has_elem: false, elem: nil)

fn make_bool_type() -> TypeInfo:
    # Create a bool TypeInfo.
    TypeInfo(kind: "bool", name: "bool", has_bits: false, bits: 0, has_signed: false, signed: false, has_lanes: false, lanes: 0, args: [], has_elem: false, elem: nil)

fn make_string_type() -> TypeInfo:
    # Create a string TypeInfo.
    TypeInfo(kind: "string", name: "string", has_bits: false, bits: 0, has_signed: false, signed: false, has_lanes: false, lanes: 0, args: [], has_elem: false, elem: nil)

fn make_named_type(name: text) -> TypeInfo:
    # Create a named TypeInfo.
    TypeInfo(kind: "named", name: name, has_bits: false, bits: 0, has_signed: false, signed: false, has_lanes: false, lanes: 0, args: [], has_elem: false, elem: nil)

# ============================================================================
# Bytecode Helper Functions
# ============================================================================

fn _type_to_tag(ty: TypeInfo) -> u8:
    # Convert TypeInfo to a bytecode type tag.
    match ty.kind:
        case "int":
            if ty.has_signed and ty.signed:
                0x10  # SIGNED_INT
            else:
                0x11  # UNSIGNED_INT
        case "float":
            0x20
        case "bool":
            0x30
        case "string":
            0x40
        case "named":
            0x50
        case "array":
            0x60
        case "simd":
            0x70
        case _:
            0x00

fn _type_size_bytes(ty: TypeInfo) -> u8:
    # Get size in bytes for a type.
    if ty.has_bits:
        val bits = ty.bits
        if bits <= 8:
            return 1
        if bits <= 16:
            return 2
        if bits <= 32:
            return 4
        return 8
    # Default sizes by kind
    match ty.kind:
        case "bool":
            1
        case "string":
            8
        case _:
            8

# ============================================================================
# TemplateBytes (used by obj_taker)
# ============================================================================

struct TemplateBytes:
    # Template bytes for FFI instantiation.
    bytes: [u8]
    name: text
    param_count: i32

# ============================================================================
# Exports
# ============================================================================

export CompilerContext
export compiler_create_context
export create_compiler_context
export compiler_destroy_context
export compiler_infer_types
export compiler_check_types
export compiler_instantiate_template
export compiler_get_stats
export Template
export TypeInfo
export TypeHint
export CompilationResult
export TemplateBytes
export type_to_string
export make_int_type
export make_float_type
export make_bool_type
export make_string_type
export make_named_type
