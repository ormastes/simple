# Resource Lifecycle Manager — unified deallocation for loader and JIT.
#
# Tracks per-module ownership of all resource classes:
# - Executable pages (RX mmap via SharedExecMapper)
# - JIT-triggered symbols (mapped under "__jit__" owner)
# - SMF file-backed mmaps (ref-counted via SmfCacheManager)
# - Template metadata (loaded_metadata dict entries)
#
# Both ModuleLoader and (future) interpreter delegate here for
# load-time registration and unload-time cleanup.

use .object_mapper.{SharedExecMapper}
use .smf_cache_manager.{SmfCacheManager}
use .generation_sweeper.{
    GenerationSweeper, SweeperConfig, SweeperStats,
    sweeperconfig_default, sweeper_new, sweeper_with_defaults,
    sweeper_advance_epoch, sweeper_mark_used, sweeper_sweep,
    sweeper_stale_count, sweeper_tracked_count, sweeper_stats,
    sweeper_reset
}

# ============================================================================
# Per-Module Resource Manifest
# ============================================================================

struct OwnedResources:
    """Everything a single module owns."""
    module_path: text
    exec_symbols: [text]       # symbols mapped in SharedExecMapper
    jit_symbols: [text]        # JIT symbols triggered by this module
    smf_cache_paths: [text]    # SMF file paths accessed by this module
    metadata_paths: [text]     # loaded_metadata dict keys for this module
    load_generation: i32       # exec_mapper.generation at load time
    load_time: i64             # timestamp (microseconds)

# ============================================================================
# Ownership Registry
# ============================================================================

struct OwnershipRegistry:
    """Central registry mapping modules to their owned resources."""
    owner_resources: Dict<text, OwnedResources>
    # Reverse map: jit_symbol -> triggering module path
    jit_origin: Dict<text, text>

fn ownershipregistry_new() -> OwnershipRegistry:
    OwnershipRegistry(
        owner_resources: {},
        jit_origin: {}
    )

# ============================================================================
# Lifecycle Configuration
# ============================================================================

struct LifecycleConfig:
    verbose: bool

fn lifecycleconfig_default() -> LifecycleConfig:
    LifecycleConfig(verbose: false)

# ============================================================================
# Resource Lifecycle Manager
# ============================================================================

struct ResourceLifecycleManager:
    """Central coordinator for resource tracking and deallocation."""
    registry: OwnershipRegistry
    smf_cache_mgr: SmfCacheManager
    sweeper: GenerationSweeper
    config: LifecycleConfig

fn lifecycle_new(config: LifecycleConfig, smf_cache_mgr: SmfCacheManager) -> ResourceLifecycleManager:
    val sweeper_cfg = SweeperConfig(max_age: 100, jit_only: true, verbose: config.verbose)
    ResourceLifecycleManager(
        registry: ownershipregistry_new(),
        smf_cache_mgr: smf_cache_mgr,
        sweeper: sweeper_new(sweeper_cfg),
        config: config
    )

fn lifecycle_new_with_sweeper(config: LifecycleConfig, smf_cache_mgr: SmfCacheManager, sweeper: GenerationSweeper) -> ResourceLifecycleManager:
    ResourceLifecycleManager(
        registry: ownershipregistry_new(),
        smf_cache_mgr: smf_cache_mgr,
        sweeper: sweeper,
        config: config
    )

fn lifecycle_with_defaults(smf_cache_mgr: SmfCacheManager) -> ResourceLifecycleManager:
    lifecycle_new(lifecycleconfig_default(), smf_cache_mgr)

# ============================================================================
# Registration — called during module load
# ============================================================================

fn lifecycle_on_module_load(self: ResourceLifecycleManager, module_path: text, generation: i32, load_time: i64):
    """Start tracking a new module."""
    self.registry.owner_resources[module_path] = OwnedResources(
        module_path: module_path,
        exec_symbols: [],
        jit_symbols: [],
        smf_cache_paths: [],
        metadata_paths: [],
        load_generation: generation,
        load_time: load_time
    )
    if self.config.verbose:
        print "[lifecycle] tracking module: {module_path}"

fn lifecycle_on_symbol_mapped(self: ResourceLifecycleManager, module_path: text, symbol: text):
    """Record that a symbol was mapped for a module."""
    if not self.registry.owner_resources.contains_key(module_path):
        return
    var owned = self.registry.owner_resources[module_path]
    owned.exec_symbols = owned.exec_symbols.push(symbol)
    self.registry.owner_resources[module_path] = owned

fn lifecycle_on_jit_triggered(self: ResourceLifecycleManager, triggering_module: text, jit_symbol: text):
    """Record JIT symbol origin so unload can find it."""
    self.registry.jit_origin[jit_symbol] = triggering_module
    if self.registry.owner_resources.contains_key(triggering_module):
        var owned = self.registry.owner_resources[triggering_module]
        owned.jit_symbols = owned.jit_symbols.push(jit_symbol)
        self.registry.owner_resources[triggering_module] = owned
    if self.config.verbose:
        print "[lifecycle] jit symbol {jit_symbol} -> module {triggering_module}"

fn lifecycle_on_smf_accessed(self: ResourceLifecycleManager, module_path: text, smf_path: text):
    """Track SMF cache usage per module (ref-counted)."""
    self.smf_cache_mgr.ref_count_inc(smf_path)
    if self.registry.owner_resources.contains_key(module_path):
        var owned = self.registry.owner_resources[module_path]
        owned.smf_cache_paths = owned.smf_cache_paths.push(smf_path)
        self.registry.owner_resources[module_path] = owned

fn lifecycle_on_metadata_loaded(self: ResourceLifecycleManager, module_path: text, metadata_path: text):
    """Track loaded_metadata dict entries for a module."""
    if self.registry.owner_resources.contains_key(module_path):
        var owned = self.registry.owner_resources[module_path]
        owned.metadata_paths = owned.metadata_paths.push(metadata_path)
        self.registry.owner_resources[module_path] = owned

# ============================================================================
# Unload — free all resources for a module
# ============================================================================

fn lifecycle_unload_module(self: ResourceLifecycleManager, exec_mapper: SharedExecMapper, module_path: text):
    """Free all resources owned by a module.

    The caller is responsible for cleaning up JIT bookkeeping
    (jit_cache, symbol_table, loaded_metadata) and the modules dict,
    since those live on ModuleLoader/JitInstantiator, not here.

    This method handles:
    1. Unmapping JIT-triggered symbols (owner '__jit__') via unmap_symbol
    2. Unmapping loader-owned symbols via unmap_owner
    3. Decrementing SMF cache ref counts (evicts on zero)
    4. Removing the ownership record
    """
    if not self.registry.owner_resources.contains_key(module_path):
        return

    val owned = self.registry.owner_resources[module_path]

    # 1. Free JIT symbols triggered by this module.
    #    These may have owner_id "__jit__" so unmap_owner(module_path) misses them.
    for jit_sym in owned.jit_symbols:
        _ = exec_mapper.unmap_symbol(jit_sym)
        if self.registry.jit_origin.contains_key(jit_sym):
            self.registry.jit_origin = self.registry.jit_origin.remove(jit_sym)

    # 2. Free loader-mapped exec pages for this module.
    _ = exec_mapper.unmap_owner(module_path)

    # 3. Decrement SMF cache ref counts.
    for smf_path in owned.smf_cache_paths:
        self.smf_cache_mgr.ref_count_dec(smf_path)

    # 4. Remove ownership record.
    self.registry.owner_resources = self.registry.owner_resources.remove(module_path)

    if self.config.verbose:
        val jit_count = owned.jit_symbols.len()
        val exec_count = owned.exec_symbols.len()
        val smf_count = owned.smf_cache_paths.len()
        print "[lifecycle] unloaded {module_path}: {exec_count} exec, {jit_count} jit, {smf_count} smf"

# ============================================================================
# Query
# ============================================================================

fn lifecycle_is_tracked(self: ResourceLifecycleManager, module_path: text) -> bool:
    self.registry.owner_resources.contains_key(module_path)

fn lifecycle_get_owned(self: ResourceLifecycleManager, module_path: text) -> OwnedResources?:
    if self.registry.owner_resources.contains_key(module_path):
        return Some(self.registry.owner_resources[module_path])
    nil

fn lifecycle_get_jit_origin(self: ResourceLifecycleManager, jit_symbol: text) -> text?:
    """Find which module triggered a JIT symbol."""
    if self.registry.jit_origin.contains_key(jit_symbol):
        return Some(self.registry.jit_origin[jit_symbol])
    nil

fn lifecycle_tracked_module_count(self: ResourceLifecycleManager) -> i32:
    self.registry.owner_resources.len()

fn lifecycle_tracked_jit_count(self: ResourceLifecycleManager) -> i32:
    self.registry.jit_origin.len()

# ============================================================================
# Sweep — epoch-based LRU eviction
# ============================================================================

fn lifecycle_mark_used(self: ResourceLifecycleManager, symbol: text):
    """Mark a symbol as used at the current epoch."""
    sweeper_mark_used(self.sweeper, symbol)

fn lifecycle_advance_epoch(self: ResourceLifecycleManager) -> i64:
    """Advance the sweep epoch. Returns the new epoch."""
    sweeper_advance_epoch(self.sweeper)

fn lifecycle_sweep_unused(self: ResourceLifecycleManager, exec_mapper: SharedExecMapper) -> i64:
    """Sweep stale symbols based on max_age. Returns count freed."""
    sweeper_sweep(self.sweeper, exec_mapper, self.registry.jit_origin)

fn lifecycle_sweeper_stats(self: ResourceLifecycleManager) -> SweeperStats:
    """Get sweep statistics."""
    sweeper_stats(self.sweeper)

# ============================================================================
# Stats / Diagnostics
# ============================================================================

struct LifecycleStats:
    tracked_modules: i64
    total_jit_symbols: i64
    smf_tracked_count: i64
    sweeper_epoch: i64
    sweeper_tracked: i64
    sweeper_stale: i64

fn lifecycle_stats(self: ResourceLifecycleManager) -> LifecycleStats:
    """Aggregate stats from registry, smf_cache_mgr, and sweeper."""
    val sw = sweeper_stats(self.sweeper)
    LifecycleStats(
        tracked_modules: self.registry.owner_resources.len(),
        total_jit_symbols: self.registry.jit_origin.len(),
        smf_tracked_count: self.smf_cache_mgr.ref_counts.len(),
        sweeper_epoch: sw.epoch,
        sweeper_tracked: sw.tracked_count,
        sweeper_stale: sw.stale_count
    )

# ============================================================================
# Full teardown
# ============================================================================

fn lifecycle_destroy(self: ResourceLifecycleManager, exec_mapper: SharedExecMapper):
    """Release all tracked resources (process exit or REPL restart)."""
    # Log stats before teardown if verbose.
    if self.config.verbose:
        val st = lifecycle_stats(self)
        print "[lifecycle] destroy: {st.tracked_modules} modules, {st.total_jit_symbols} jit, {st.smf_tracked_count} smf, epoch {st.sweeper_epoch}"

    var paths: [text] = []
    for (path, _) in self.registry.owner_resources:
        paths = paths.push(path)
    for path in paths:
        lifecycle_unload_module(self, exec_mapper, path)

    # Catch any orphaned symbols not tracked by ownership.
    exec_mapper.clear()

    # Force-close all SMF mmaps.
    self.smf_cache_mgr.force_clear()

    # Reset sweeper state.
    sweeper_reset(self.sweeper)

# ============================================================================
# Exports
# ============================================================================

export OwnedResources
export OwnershipRegistry
export LifecycleConfig
export LifecycleStats
export ResourceLifecycleManager
export lifecycle_new, lifecycle_new_with_sweeper, lifecycle_with_defaults
export lifecycle_on_module_load, lifecycle_on_symbol_mapped
export lifecycle_on_jit_triggered, lifecycle_on_smf_accessed
export lifecycle_on_metadata_loaded
export lifecycle_unload_module
export lifecycle_is_tracked, lifecycle_get_owned
export lifecycle_get_jit_origin
export lifecycle_tracked_module_count, lifecycle_tracked_jit_count
export lifecycle_mark_used, lifecycle_advance_epoch
export lifecycle_sweep_unused, lifecycle_sweeper_stats
export lifecycle_stats
export lifecycle_destroy
