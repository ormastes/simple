# Shared RISC-V Instruction Encoding Utilities
#
# Instruction format encoders, ALU dispatch helpers, and emit utility
# shared between riscv64 and riscv32 backends.
# The encoding formats are identical between RV32 and RV64.

use compiler.backend.native.mach_inst.{RV_OP_ADD, RV_OP_SUB, RV_OP_MUL, RV_OP_DIV, RV_OP_REM, RV_OP_AND, RV_OP_OR, RV_OP_XOR, RV_OP_SLL, RV_OP_SRA, RV_OP_SRL, RV_OP_SLT, RV_OP_SLTU, RV_OP_BEQ, RV_OP_BNE, RV_OP_BLT, RV_OP_BGE}

# ============================================================================
# Emit Helper
# ============================================================================

# Emit a 32-bit instruction as 4 little-endian bytes.
# Uses division/modulo to avoid issues with negative bit operations.
fn riscv_emit_u32_le(buf: [i64], instruction: i64) -> [i64]:
    var masked = instruction
    if masked < 0:
        masked = masked + 4294967296
    val b0 = masked % 256
    val b1 = (masked / 256) % 256
    val b2 = (masked / 65536) % 256
    val b3 = (masked / 16777216) % 256
    var result = buf
    result = result + [b0, b1, b2, b3]
    result

# ============================================================================
# Instruction Format Encoders
# ============================================================================

# R-type: funct7[31:25] | rs2[24:20] | rs1[19:15] | funct3[14:12] | rd[11:7] | opcode[6:0]
fn riscv_encode_r_type(funct7: i64, rs2: i64, rs1: i64, funct3: i64, rd: i64, opcode: i64) -> i64:
    val f7 = (funct7 and 0x7F) << 25
    val r2 = (rs2 and 0x1F) << 20
    val r1 = (rs1 and 0x1F) << 15
    val f3 = (funct3 and 0x7) << 12
    val d = (rd and 0x1F) << 7
    val op = opcode and 0x7F
    f7 or r2 or r1 or f3 or d or op

# I-type: imm[31:20] | rs1[19:15] | funct3[14:12] | rd[11:7] | opcode[6:0]
fn riscv_encode_i_type(imm12: i64, rs1: i64, funct3: i64, rd: i64, opcode: i64) -> i64:
    val im = (imm12 and 0xFFF) << 20
    val r1 = (rs1 and 0x1F) << 15
    val f3 = (funct3 and 0x7) << 12
    val d = (rd and 0x1F) << 7
    val op = opcode and 0x7F
    im or r1 or f3 or d or op

# S-type: imm[31:25] | rs2[24:20] | rs1[19:15] | funct3[14:12] | imm[11:7] | opcode[6:0]
fn riscv_encode_s_type(imm12: i64, rs2: i64, rs1: i64, funct3: i64, opcode: i64) -> i64:
    val imm_val = imm12 and 0xFFF
    val imm_hi = (bit_shr(imm_val, 5)) and 0x7F
    val imm_lo = imm_val and 0x1F
    val hi = bit_shl(imm_hi, 25)
    val r2 = (rs2 and 0x1F) << 20
    val r1 = (rs1 and 0x1F) << 15
    val f3 = (funct3 and 0x7) << 12
    val lo = bit_shl(imm_lo, 7)
    val op = opcode and 0x7F
    hi or r2 or r1 or f3 or lo or op

# B-type: imm[12|10:5] | rs2[24:20] | rs1[19:15] | funct3[14:12] | imm[4:1|11] | opcode[6:0]
# imm is a byte offset
fn riscv_encode_b_type(imm_offset: i64, rs2: i64, rs1: i64, funct3: i64, opcode: i64) -> i64:
    val imm = imm_offset and 0x1FFF
    # bit 12 -> bit 31
    val bit12 = (bit_shr(imm, 12)) and 0x1
    # bits 10:5 -> bits 30:25
    val bits_10_5 = (bit_shr(imm, 5)) and 0x3F
    # bits 4:1 -> bits 11:8
    val bits_4_1 = (bit_shr(imm, 1)) and 0xF
    # bit 11 -> bit 7
    val bit11 = (bit_shr(imm, 11)) and 0x1
    val hi = [bit_shl(bit12, 31)) or (bit_shl(bits_10_5, 25)]
    val r2 = (rs2 and 0x1F) << 20
    val r1 = (rs1 and 0x1F) << 15
    val f3 = (funct3 and 0x7) << 12
    val lo = [bit_shl(bits_4_1, 8)) or (bit_shl(bit11, 7)]
    val op = opcode and 0x7F
    hi or r2 or r1 or f3 or lo or op

# U-type: imm[31:12] | rd[11:7] | opcode[6:0]
fn riscv_encode_u_type(imm20: i64, rd: i64, opcode: i64) -> i64:
    val im = (imm20 and 0xFFFFF) << 12
    val d = (rd and 0x1F) << 7
    val op = opcode and 0x7F
    im or d or op

# J-type: imm[20|10:1|11|19:12] | rd[11:7] | opcode[6:0]
# imm is a byte offset
fn riscv_encode_j_type(imm_offset: i64, rd: i64, opcode: i64) -> i64:
    val imm = imm_offset and 0x1FFFFF
    # bit 20 -> bit 31
    val bit20 = (bit_shr(imm, 20)) and 0x1
    # bits 10:1 -> bits 30:21
    val bits_10_1 = (bit_shr(imm, 1)) and 0x3FF
    # bit 11 -> bit 20
    val bit11 = (bit_shr(imm, 11)) and 0x1
    # bits 19:12 -> bits 19:12
    val bits_19_12 = (bit_shr(imm, 12)) and 0xFF
    val hi = [bit_shl(bit20, 31)) or (bit_shl(bits_10_1, 21)) or (bit_shl(bit11, 20)) or (bit_shl(bits_19_12, 12)]
    val d = (rd and 0x1F) << 7
    val op = opcode and 0x7F
    hi or d or op

# ============================================================================
# R-type ALU Dispatch Helpers
# ============================================================================

# Get funct7 field for R-type ALU opcodes
fn riscv_alu_funct7(opcode: i64) -> i64:
    if opcode == RV_OP_SUB: 0x20
    elif opcode == RV_OP_SRA: 0x20
    elif opcode == RV_OP_MUL: 0x01
    elif opcode == RV_OP_DIV: 0x01
    elif opcode == RV_OP_REM: 0x01
    else: 0x00

# Get funct3 field for R-type ALU opcodes
fn riscv_alu_funct3(opcode: i64) -> i64:
    if opcode == RV_OP_ADD: 0
    elif opcode == RV_OP_SUB: 0
    elif opcode == RV_OP_MUL: 0
    elif opcode == RV_OP_DIV: 4
    elif opcode == RV_OP_REM: 6
    elif opcode == RV_OP_AND: 7
    elif opcode == RV_OP_OR: 6
    elif opcode == RV_OP_XOR: 4
    elif opcode == RV_OP_SLL: 1
    elif opcode == RV_OP_SRA: 5
    elif opcode == RV_OP_SRL: 5
    elif opcode == RV_OP_SLT: 2
    elif opcode == RV_OP_SLTU: 3
    else: 0

# Get funct3 for B-type branch opcodes
fn riscv_branch_funct3(opcode: i64) -> i64:
    if opcode == RV_OP_BEQ: 0
    elif opcode == RV_OP_BNE: 1
    elif opcode == RV_OP_BLT: 4
    elif opcode == RV_OP_BGE: 5
    else: 0

export riscv_emit_u32_le
export riscv_encode_r_type, riscv_encode_i_type, riscv_encode_s_type, riscv_encode_b_type, riscv_encode_u_type, riscv_encode_j_type
export riscv_alu_funct7, riscv_alu_funct3, riscv_branch_funct3
