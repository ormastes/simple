# RISC-V 64-bit Instruction Encoder
#
# Encodes MachInst to raw bytes for RISC-V 64-bit (RV64IMFD) architecture.
# All RISC-V instructions are fixed-length: exactly 4 bytes (32-bit), little-endian.
#
# Instruction formats:
#   R-type: funct7[31:25] | rs2[24:20] | rs1[19:15] | funct3[14:12] | rd[11:7] | opcode[6:0]
#   I-type: imm[31:20]   | rs1[19:15] | funct3[14:12] | rd[11:7]    | opcode[6:0]
#   S-type: imm[31:25]   | rs2[24:20] | rs1[19:15] | funct3[14:12] | imm[11:7] | opcode[6:0]
#   B-type: imm[12|10:5] | rs2[24:20] | rs1[19:15] | funct3[14:12] | imm[4:1|11] | opcode[6:0]
#   U-type: imm[31:12]   | rd[11:7]   | opcode[6:0]
#   J-type: imm[20|10:1|11|19:12] | rd[11:7] | opcode[6:0]

use compiler.backend.native.mach_inst.{MachReg, MachRegKind, physical_reg, reg_id, Operand, OperandKind, MachInst, MachBlock, MachFunction, MachModule, EncodedReloc, EncodedFunction, new_encoded_function}
use compiler.backend.native.mach_inst.{RV_X0, RV_X1, RV_X2, RV_X3, RV_X4, RV_X5, RV_X6, RV_X7, RV_X8, RV_X9, RV_X10, RV_X11, RV_X12, RV_X13, RV_X14, RV_X15, RV_X16, RV_X17, RV_X18, RV_X19, RV_X20, RV_X21, RV_X22, RV_X23, RV_X24, RV_X25, RV_X26, RV_X27, RV_X28, RV_X29, RV_X30, RV_X31}
use compiler.backend.native.mach_inst.{RV_OP_ADD, RV_OP_SUB, RV_OP_MUL, RV_OP_DIV, RV_OP_REM, RV_OP_AND, RV_OP_OR, RV_OP_XOR, RV_OP_SLL, RV_OP_SRA, RV_OP_SRL, RV_OP_SLT, RV_OP_SLTU, RV_OP_ADDI, RV_OP_LUI, RV_OP_AUIPC, RV_OP_JAL, RV_OP_JALR, RV_OP_BEQ, RV_OP_BNE, RV_OP_BLT, RV_OP_BGE, RV_OP_LD, RV_OP_SD, RV_OP_LW, RV_OP_SW, RV_OP_MV, RV_OP_LI, RV_OP_NOP, RV_OP_RET, RV_OP_CALL, RV_OP_NEG, RV_OP_NOT, RV_OP_SEQZ, RV_OP_SNEZ}
use compiler.backend.native.operand_utils.{get_phys_reg_id, get_mem_base_id, get_mem_offset, get_imm_value, get_label_id, get_sym_name}
use compiler.backend.native.riscv_encoding.{riscv_emit_u32_le, riscv_encode_r_type, riscv_encode_i_type, riscv_encode_s_type, riscv_encode_b_type, riscv_encode_u_type, riscv_encode_j_type, riscv_alu_funct7, riscv_alu_funct3, riscv_branch_funct3}

# ============================================================================
# Encode Context
# ============================================================================

struct Rv64EncodeContext:
    code: [i64]
    relocations: [EncodedReloc]
    block_offsets: Dict<i64, i64>
    pending_jumps: [Rv64PendingJump]

struct Rv64PendingJump:
    code_offset: i64
    target_block: i64
    jump_kind: i64

# Jump kinds
val JUMP_JAL = 0       # J-type (JAL)
val JUMP_BRANCH = 1    # B-type (BEQ/BNE/BLT/BGE)

fn rv64_new_encode_context() -> Rv64EncodeContext:
    Rv64EncodeContext(code: [], relocations: [], block_offsets: {}, pending_jumps: [])

# Relocation type for RISC-V CALL (AUIPC+JALR pair)
val R_RISCV_CALL_PLT = 19

# ============================================================================
# Load Immediate Helper
# ============================================================================

# Encode LI rd, imm - loads an arbitrary 64-bit immediate into rd.
# For small values (fits in 12-bit signed): ADDI rd, x0, imm
# For 32-bit values: LUI + ADDI
# For larger: LUI + ADDI + SLLI + ADDI sequences
fn encode_li_riscv64(code: [i64], rd: i64, imm: i64) -> [i64]:
    var result = code
    # Small immediate: fits in signed 12-bit [-2048, 2047]
    if imm >= -2048:
        if imm <= 2047:
            # ADDI rd, x0, imm
            val enc = riscv_encode_i_type(imm and 0xFFF, RV_X0, 0, rd, 0x13)
            result = riscv_emit_u32_le(result, enc)
            return result

    # 32-bit range: use LUI + ADDI
    # LUI loads imm[31:12], ADDI adds imm[11:0]
    # If bit 11 is set, LUI upper needs +1 to compensate for sign extension
    var upper = (bit_shr(imm, 12)) and 0xFFFFF
    val lower = imm and 0xFFF
    # Check if lower 12 bits are negative when sign-extended
    if lower >= 2048:
        upper = upper + 1
    val lui_enc = riscv_encode_u_type(upper and 0xFFFFF, rd, 0x37)
    result = riscv_emit_u32_le(result, lui_enc)
    # Only emit ADDI if lower bits are nonzero
    if lower != 0:
        val addi_enc = riscv_encode_i_type(lower, rd, 0, rd, 0x13)
        result = riscv_emit_u32_le(result, addi_enc)
    result

# ============================================================================
# Instruction Encoding
# ============================================================================

fn encode_inst_riscv64(ectx: Rv64EncodeContext, inst: MachInst) -> Rv64EncodeContext:
    var code = ectx.code
    var relocs = ectx.relocations
    var pending = ectx.pending_jumps

    if inst.opcode == RV_OP_NOP:
        # NOP = ADDI x0, x0, 0 = 0x00000013
        code = riscv_emit_u32_le(code, 0x00000013)

    elif inst.opcode == RV_OP_RET:
        # RET = JALR x0, x1, 0 = 0x00008067
        code = riscv_emit_u32_le(code, 0x00008067)

    elif inst.opcode == RV_OP_MV:
        # MV rd, rs = ADDI rd, rs, 0
        val rd = get_phys_reg_id(inst.operands[0])
        val rs = get_phys_reg_id(inst.operands[1])
        val enc = riscv_encode_i_type(0, rs, 0, rd, 0x13)
        code = riscv_emit_u32_le(code, enc)

    elif inst.opcode == RV_OP_LI:
        # LI rd, imm (pseudo-instruction, variable length)
        val rd = get_phys_reg_id(inst.operands[0])
        val imm = get_imm_value(inst.operands[1])
        code = encode_li_riscv64(code, rd, imm)

    elif inst.opcode == RV_OP_ADD or inst.opcode == RV_OP_SUB or inst.opcode == RV_OP_MUL or inst.opcode == RV_OP_DIV or inst.opcode == RV_OP_REM or inst.opcode == RV_OP_AND or inst.opcode == RV_OP_OR or inst.opcode == RV_OP_XOR or inst.opcode == RV_OP_SLL or inst.opcode == RV_OP_SRA or inst.opcode == RV_OP_SRL or inst.opcode == RV_OP_SLT or inst.opcode == RV_OP_SLTU:
        # R-type ALU: rd, rs1, rs2 with varying funct7/funct3
        val rd = get_phys_reg_id(inst.operands[0])
        val rs1 = get_phys_reg_id(inst.operands[1])
        val rs2 = get_phys_reg_id(inst.operands[2])
        val funct7 = riscv_alu_funct7(inst.opcode)
        val funct3 = riscv_alu_funct3(inst.opcode)
        val enc = riscv_encode_r_type(funct7, rs2, rs1, funct3, rd, 0x33)
        code = riscv_emit_u32_le(code, enc)

    elif inst.opcode == RV_OP_ADDI:
        # ADDI rd, rs1, imm12: I-type funct3=0x0, opcode=0x13
        val rd = get_phys_reg_id(inst.operands[0])
        val rs1 = get_phys_reg_id(inst.operands[1])
        val imm12 = get_imm_value(inst.operands[2])
        val enc = riscv_encode_i_type(imm12 and 0xFFF, rs1, 0, rd, 0x13)
        code = riscv_emit_u32_le(code, enc)

    elif inst.opcode == RV_OP_NEG:
        # NEG rd, rs = SUB rd, x0, rs
        val rd = get_phys_reg_id(inst.operands[0])
        val rs = get_phys_reg_id(inst.operands[1])
        val enc = riscv_encode_r_type(0x20, rs, RV_X0, 0, rd, 0x33)
        code = riscv_emit_u32_le(code, enc)

    elif inst.opcode == RV_OP_NOT:
        # NOT rd, rs = XORI rd, rs, -1
        val rd = get_phys_reg_id(inst.operands[0])
        val rs = get_phys_reg_id(inst.operands[1])
        val enc = riscv_encode_i_type(0xFFF, rs, 4, rd, 0x13)
        code = riscv_emit_u32_le(code, enc)

    elif inst.opcode == RV_OP_SEQZ:
        # SEQZ rd, rs = SLTIU rd, rs, 1
        val rd = get_phys_reg_id(inst.operands[0])
        val rs = get_phys_reg_id(inst.operands[1])
        val enc = riscv_encode_i_type(1, rs, 3, rd, 0x13)
        code = riscv_emit_u32_le(code, enc)

    elif inst.opcode == RV_OP_SNEZ:
        # SNEZ rd, rs = SLTU rd, x0, rs
        val rd = get_phys_reg_id(inst.operands[0])
        val rs = get_phys_reg_id(inst.operands[1])
        val enc = riscv_encode_r_type(0x00, rs, RV_X0, 3, rd, 0x33)
        code = riscv_emit_u32_le(code, enc)

    elif inst.opcode == RV_OP_LUI:
        # LUI rd, imm20: U-type opcode=0x37
        val rd = get_phys_reg_id(inst.operands[0])
        val imm20 = get_imm_value(inst.operands[1])
        val enc = riscv_encode_u_type(imm20, rd, 0x37)
        code = riscv_emit_u32_le(code, enc)

    elif inst.opcode == RV_OP_AUIPC:
        # AUIPC rd, imm20: U-type opcode=0x17
        val rd = get_phys_reg_id(inst.operands[0])
        match inst.operands[1].kind:
            case Sym(name):
                val reloc_offset = code_len(code)
                val enc = riscv_encode_u_type(0, rd, 0x17)
                code = riscv_emit_u32_le(code, enc)
                val reloc = EncodedReloc(
                    offset: reloc_offset,
                    symbol_name: name,
                    reloc_type: R_RISCV_CALL_PLT,
                    addend: 0
                )
                relocs = relocs + [reloc]
            case Imm(v):
                val enc = riscv_encode_u_type(v, rd, 0x17)
                code = riscv_emit_u32_le(code, enc)
            case _:
                val enc = riscv_encode_u_type(0, rd, 0x17)
                code = riscv_emit_u32_le(code, enc)

    elif inst.opcode == RV_OP_LD:
        # LD rd, offset(rs1): I-type funct3=0x3, opcode=0x03
        val rd = get_phys_reg_id(inst.operands[0])
        val base = get_mem_base_id(inst.operands[1])
        val offset = get_mem_offset(inst.operands[1])
        val enc = riscv_encode_i_type(offset and 0xFFF, base, 3, rd, 0x03)
        code = riscv_emit_u32_le(code, enc)

    elif inst.opcode == RV_OP_SD:
        # SD rs2, offset(rs1): S-type funct3=0x3, opcode=0x23
        val rs2 = get_phys_reg_id(inst.operands[0])
        val base = get_mem_base_id(inst.operands[1])
        val offset = get_mem_offset(inst.operands[1])
        val enc = riscv_encode_s_type(offset and 0xFFF, rs2, base, 3, 0x23)
        code = riscv_emit_u32_le(code, enc)

    elif inst.opcode == RV_OP_LW:
        # LW rd, offset(rs1): I-type funct3=0x2, opcode=0x03
        val rd = get_phys_reg_id(inst.operands[0])
        val base = get_mem_base_id(inst.operands[1])
        val offset = get_mem_offset(inst.operands[1])
        val enc = riscv_encode_i_type(offset and 0xFFF, base, 2, rd, 0x03)
        code = riscv_emit_u32_le(code, enc)

    elif inst.opcode == RV_OP_SW:
        # SW rs2, offset(rs1): S-type funct3=0x2, opcode=0x23
        val rs2 = get_phys_reg_id(inst.operands[0])
        val base = get_mem_base_id(inst.operands[1])
        val offset = get_mem_offset(inst.operands[1])
        val enc = riscv_encode_s_type(offset and 0xFFF, rs2, base, 2, 0x23)
        code = riscv_emit_u32_le(code, enc)

    elif inst.opcode == RV_OP_JAL:
        # JAL rd, offset: J-type opcode=0x6F
        val rd = get_phys_reg_id(inst.operands[0])
        match inst.operands[1].kind:
            case Label(block_id):
                val jump_offset = code_len(code)
                val enc = riscv_encode_j_type(0, rd, 0x6F)
                code = riscv_emit_u32_le(code, enc)
                pending = pending + [Rv64PendingJump(code_offset: jump_offset, target_block: block_id, jump_kind: JUMP_JAL)]
            case Imm(v):
                val enc = riscv_encode_j_type(v, rd, 0x6F)
                code = riscv_emit_u32_le(code, enc)
            case _:
                val enc = riscv_encode_j_type(0, rd, 0x6F)
                code = riscv_emit_u32_le(code, enc)

    elif inst.opcode == RV_OP_JALR:
        # JALR rd, rs1, imm12: I-type funct3=0x0, opcode=0x67
        val rd = get_phys_reg_id(inst.operands[0])
        val rs1 = get_phys_reg_id(inst.operands[1])
        val imm12 = get_imm_value(inst.operands[2])
        val enc = riscv_encode_i_type(imm12 and 0xFFF, rs1, 0, rd, 0x67)
        code = riscv_emit_u32_le(code, enc)

    elif inst.opcode == RV_OP_BEQ or inst.opcode == RV_OP_BNE or inst.opcode == RV_OP_BLT or inst.opcode == RV_OP_BGE:
        # B-type branches: BEQ(f3=0), BNE(f3=1), BLT(f3=4), BGE(f3=5)
        val rs1 = get_phys_reg_id(inst.operands[0])
        val rs2 = get_phys_reg_id(inst.operands[1])
        val funct3 = riscv_branch_funct3(inst.opcode)
        match inst.operands[2].kind:
            case Label(block_id):
                val jump_offset = code_len(code)
                val enc = riscv_encode_b_type(0, rs2, rs1, funct3, 0x63)
                code = riscv_emit_u32_le(code, enc)
                pending = pending + [Rv64PendingJump(code_offset: jump_offset, target_block: block_id, jump_kind: JUMP_BRANCH)]
            case _:
                val enc = riscv_encode_b_type(0, rs2, rs1, funct3, 0x63)
                code = riscv_emit_u32_le(code, enc)

    elif inst.opcode == RV_OP_CALL:
        # CALL symbol (pseudo): AUIPC x1, offset_hi; JALR x1, x1, offset_lo
        # Emits 8 bytes (2 instructions), with R_RISCV_CALL_PLT relocation on the pair
        match inst.operands[0].kind:
            case Sym(name):
                val reloc_offset = code_len(code)
                # AUIPC x1(ra), 0 - placeholder upper
                val auipc_enc = riscv_encode_u_type(0, RV_X1, 0x17)
                code = riscv_emit_u32_le(code, auipc_enc)
                # JALR x1(ra), x1(ra), 0 - placeholder lower
                val jalr_enc = riscv_encode_i_type(0, RV_X1, 0, RV_X1, 0x67)
                code = riscv_emit_u32_le(code, jalr_enc)
                # Record relocation for the AUIPC+JALR pair
                val reloc = EncodedReloc(
                    offset: reloc_offset,
                    symbol_name: name,
                    reloc_type: R_RISCV_CALL_PLT,
                    addend: 0
                )
                relocs = relocs + [reloc]
            case Label(block_id):
                # Intra-function call via JAL x1, offset
                val jump_offset = code_len(code)
                val enc = riscv_encode_j_type(0, RV_X1, 0x6F)
                code = riscv_emit_u32_le(code, enc)
                pending = pending + [Rv64PendingJump(code_offset: jump_offset, target_block: block_id, jump_kind: JUMP_JAL)]
            case _:
                # Fallback: emit NOP pair
                code = riscv_emit_u32_le(code, 0x00000013)
                code = riscv_emit_u32_le(code, 0x00000013)

    else:
        # Unknown opcode - emit EBREAK (0x00100073) for debug
        code = riscv_emit_u32_le(code, 0x00100073)

    Rv64EncodeContext(code: code, relocations: relocs, block_offsets: ectx.block_offsets, pending_jumps: pending)

# ============================================================================
# Jump Patching
# ============================================================================

# Patch a 32-bit instruction at byte_offset with a branch/jump displacement.
fn patch_jump_riscv64(code: [i64], byte_offset: i64, rel_offset: i64, kind: i64) -> [i64]:
    var patched = code
    # Read existing 4-byte LE instruction
    val b0 = patched[byte_offset]
    val b1 = patched[byte_offset + 1]
    val b2 = patched[byte_offset + 2]
    val b3 = patched[byte_offset + 3]
    val old_inst = b0 or (bit_shl(b1, 8)) or (bit_shl(b2, 16)) or (bit_shl(b3, 24))

    var new_inst = old_inst
    if kind == JUMP_JAL:
        # J-type: re-encode with the displacement
        # Extract rd and opcode from existing instruction
        val rd = (bit_shr(old_inst, 7)) and 0x1F
        val opcode = old_inst and 0x7F
        new_inst = riscv_encode_j_type(rel_offset, rd, opcode)
    elif kind == JUMP_BRANCH:
        # B-type: re-encode with the displacement
        # Extract rs1, rs2, funct3, opcode from existing instruction
        val rs1 = (bit_shr(old_inst, 15)) and 0x1F
        val rs2 = (bit_shr(old_inst, 20)) and 0x1F
        val funct3 = (bit_shr(old_inst, 12)) and 0x7
        val opcode = old_inst and 0x7F
        new_inst = riscv_encode_b_type(rel_offset, rs2, rs1, funct3, opcode)

    # Handle negative instruction values before byte extraction
    var unsigned_inst = new_inst
    if unsigned_inst < 0:
        unsigned_inst = unsigned_inst + 4294967296

    # Write back as 4 LE bytes using division/modulo
    patched[byte_offset] = unsigned_inst % 256
    patched[byte_offset + 1] = (unsigned_inst / 256) % 256
    patched[byte_offset + 2] = (unsigned_inst / 65536) % 256
    patched[byte_offset + 3] = (unsigned_inst / 16777216) % 256
    patched

# ============================================================================
# Function Encoding (two-pass)
# ============================================================================

fn encode_function_riscv64(func: MachFunction) -> EncodedFunction:
    var ectx = rv64_new_encode_context()

    # Pass 1: encode all instructions, record block offsets and pending jumps
    for block in func.blocks:
        var offsets = ectx.block_offsets
        offsets[block.block_id] = ectx.code_len(code)
        ectx = Rv64EncodeContext(code: ectx.code, relocations: ectx.relocations, block_offsets: offsets, pending_jumps: ectx.pending_jumps)

        for inst in block.insts:
            ectx = encode_inst_riscv64(ectx, inst)

    # Pass 2: patch branch/jump targets
    var final_code = ectx.code
    for i in 0..ectx.pending_jumps_len(pending_jumps):
        val pj = ectx.pending_jumps[i]
        val target_block = pj.target_block
        if ectx.block_offsets_contains(block_offsets, target_block):
            val target_offset = ectx.block_offsets[target_block]
            val rel_offset = target_offset - pj.code_offset
            final_code = patch_jump_riscv64(final_code, pj.code_offset, rel_offset, pj.jump_kind)

    EncodedFunction(name: func.name, code: final_code, relocations: ectx.relocations)

# ============================================================================
# Module Encoding
# ============================================================================

fn encode_module_riscv64(module: MachModule) -> [EncodedFunction]:
    var results: [EncodedFunction] = []
    for func in module.functions:
        val encoded = encode_function_riscv64(func)
        results = results + [encoded]
    results

# ============================================================================
# Exports
# ============================================================================

export Rv64EncodeContext, rv64_new_encode_context, Rv64PendingJump
export JUMP_JAL, JUMP_BRANCH, R_RISCV_CALL_PLT
export encode_function_riscv64, encode_inst_riscv64, encode_module_riscv64
