# Environment and Scoping Utilities
#
# Shared environment operations for backend implementations.
# This module provides variable scoping and environment management
# used by the interpreter and other backends.

use compiler.hir.hir.*
use backend_types.*

# ============================================================================
# Environment and Scoping
# ============================================================================

struct EvalContext:
    """Context for expression evaluation."""
    env: Environment
    module: HirModule
    backend: Backend

struct Environment:
    """Variable environment for evaluation."""
    scopes: [Dict<SymbolId, Value>]
    globals: Dict<SymbolId, Value>

fn empty_env_scope() -> Dict<SymbolId, Value>:
    """Create an empty scope dict (typed for bootstrap inference)."""
    var result: Dict<SymbolId, Value> = {}
    result

impl Environment:
    static fn new() -> Environment:
        Environment(scopes: [empty_env_scope()], globals: empty_env_scope())

    me push_scope():
        self.scopes = self.scopes.push(empty_env_scope())

    me pop_scope():
        if self.scopes.len() > 1:
            self.scopes = self.scopes[0:self.scopes.len() - 1]

    me define(symbol: SymbolId, value: Value):
        val scope = self.scopes[self.scopes.len() - 1]
        scope[symbol] = value

    me assign(symbol: SymbolId, value: Value) -> bool:
        # Search from innermost scope
        for i in (self.scopes.len() - 1)..=0:
            val scope = self.scopes[i]
            if scope.contains_key(symbol):
                scope[symbol] = value
                return true

        # Check globals
        if self.globals.contains_key(symbol):
            self.globals[symbol] = value
            return true

        false

    fn lookup(symbol: SymbolId) -> Value?:
        # Search from innermost scope
        for i in (self.scopes.len() - 1)..=0:
            val scope = self.scopes[i]
            if scope.contains_key(symbol):
                return Some(scope[symbol])

        # Check globals
        if self.globals.contains_key(symbol):
            return Some(self.globals[symbol])
        nil

    me define_global(symbol: SymbolId, value: Value):
        self.globals[symbol] = value

# ============================================================================
# HIR Visitor
# ============================================================================

struct HirVisitor:
    """Visitor that walks HIR and calls backend methods."""
    backend: Backend
    ctx: EvalContext

impl HirVisitor:
    static fn new(backend: Backend, module: HirModule) -> HirVisitor:
        HirVisitor(
            backend: backend,
            ctx: EvalContext(
                env: Environment__new(),
                module: module,
                backend: backend
            )
        )

    me visit_module() -> Result<BackendResult, BackendError>:
        """Visit entire module."""
        self.backend.process_module(self.ctx.module)

    me visit_function(fn_: HirFunction) -> Result<BackendResult, BackendError>:
        """Visit function definition."""
        self.backend.process_function(fn_)

    me visit_expr(expr: HirExpr) -> Result<Value, BackendError>:
        """Visit expression."""
        # Check if allowed
        if not self.backend.is_allowed(expr):
            return Err(BackendError__not_allowed(
                "expression not allowed in {self.backend.name()} mode",
                Some(expr.span)
            ))

        self.backend.eval_expr(expr, self.ctx)

    me visit_stmt(stmt: HirStmt) -> Result<(), BackendError>:
        """Visit statement."""
        if not self.backend.is_allowed_stmt(stmt):
            return Err(BackendError__not_allowed(
                "statement not allowed in {self.backend.name()} mode",
                Some(stmt.span)
            ))

        self.backend.exec_stmt(stmt, self.ctx)

    me visit_block(block: HirBlock) -> Result<Value, BackendError>:
        """Visit block."""
        self.ctx.env.push_scope()

        for stmt in block.stmts:
            self.visit_stmt(stmt)?

        val result = if block.value.?:
            self.visit_expr(block.value.unwrap())?
        else:
            Value__make_nil()

        self.ctx.env.pop_scope()
        Ok(result)

# ============================================================================
# Exports
# ============================================================================


# Auto-generated desugared static method wrappers
fn Environment__new() -> Environment:
    Environment(scopes: [empty_env_scope()], globals: empty_env_scope())


export EvalContext, Environment, empty_env_scope, HirVisitor
