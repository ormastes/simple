# WASM Control Flow - MIR basic blocks to WASM structured control flow
#
# WebAssembly requires structured control flow (block/loop/if), not arbitrary
# goto. This module translates MIR basic block graphs into WASM structured
# control flow using a simplified Relooper algorithm.
#
# Translation patterns:
# - MIR if/else (3 blocks: then/else/merge) -> (if (then) (else))
# - MIR while (3 blocks: cond/body/exit) -> (loop $L (block $exit ... br_if $exit ... br $L))
# - Fallthrough sequences -> sequential instructions
# - Complex graphs -> dispatcher loop with br_table
#
# Usage:
#   val translator = WasmControlFlow__create()
#   translator.translate_blocks(blocks, builder)

use compiler.backend.wasm_backend.{WatBuilder}

# ============================================================================
# Block Types
# ============================================================================

enum WasmBlockKind:
    """Classification of MIR basic block patterns."""
    Sequence     # Linear sequence (no branches)
    IfThenElse   # If-then-else pattern
    WhileLoop    # While loop pattern
    ForLoop      # For loop (sugar for while)
    Dispatcher   # Complex/irreducible (use br_table)

struct WasmBlock:
    """A WASM structured control flow block."""
    kind: WasmBlockKind
    label: text
    # For IfThenElse: condition block, then block, else block, merge block
    cond_idx: i64
    then_idx: i64
    else_idx: i64
    merge_idx: i64
    # For WhileLoop: condition block, body block, exit block
    body_idx: i64
    exit_idx: i64

# ============================================================================
# Control Flow Translator
# ============================================================================

class WasmControlFlow:
    """Translates MIR control flow to WASM structured control flow."""
    block_count: i64
    label_counter: i64

    static fn create() -> WasmControlFlow:
        WasmControlFlow(
            block_count: 0,
            label_counter: 0
        )

    me next_label() -> text:
        """Generate a unique label."""
        val label = "L{self.label_counter}"
        self.label_counter = self.label_counter + 1
        label

    fn emit_if_then_else(builder: WatBuilder, cond_local: text):
        """Emit WASM if-then-else structure.

        Assumes condition value is on the stack or in a local.

        Emits:
            local.get $cond
            (if
                (then ...)
                (else ...)
            )
        """
        builder.emit_local_named_get(cond_local)
        builder.emit("(if")
        builder.emit("  (then")

    fn emit_else_branch(builder: WatBuilder):
        """Emit else branch."""
        builder.emit("  )")  # close then
        builder.emit("  (else")

    fn emit_end_if(builder: WatBuilder):
        """Emit end of if-then-else."""
        builder.emit("  )")  # close else/then
        builder.emit(")")    # close if

    fn emit_while_loop(builder: WatBuilder, loop_label: text, exit_label: text):
        """Emit WASM while loop structure.

        Emits:
            (block $exit
                (loop $loop
                    ... condition ...
                    i32.eqz
                    br_if $exit    ;; exit if condition false
                    ... body ...
                    br $loop       ;; continue loop
                )
            )
        """
        builder.emit_block(exit_label)
        builder.emit_loop(loop_label)

    fn emit_loop_continue(builder: WatBuilder, loop_label: text):
        """Emit branch to loop start (continue)."""
        builder.emit_br(loop_label)

    fn emit_loop_break(builder: WatBuilder, exit_label: text):
        """Emit branch to loop exit (break)."""
        builder.emit_br(exit_label)

    fn emit_end_loop(builder: WatBuilder):
        """Emit end of while loop (close loop and block)."""
        builder.emit_end()  # close loop
        builder.emit_end()  # close block

    fn emit_dispatcher(builder: WatBuilder, block_count: i64, dispatch_local: text):
        """Emit a dispatcher loop for irreducible control flow.

        Uses br_table to jump to the correct block based on a dispatch variable.

        Emits:
            (block $b0
                (block $b1
                    (block $b2
                        ...
                        local.get $dispatch
                        br_table $b0 $b1 $b2 ... $default
                    )
                    ;; block b2 code
                )
                ;; block b1 code
            )
            ;; block b0 code
        """
        # Open nested blocks (outermost = block 0, innermost = dispatch)
        var labels: [text] = []
        for i in 0..block_count:
            val label = "b{i}"
            labels = labels.push(label)
            builder.emit_block(label)

        # br_table instruction
        builder.emit_local_named_get(dispatch_local)
        builder.emit_br_table(labels, labels[0])

        # Close blocks in reverse order
        for i in 0..block_count:
            builder.emit_end()

# ============================================================================
# Desugared static methods
# ============================================================================

fn WasmControlFlow__create() -> WasmControlFlow:
    WasmControlFlow__create()

# ============================================================================
# Exports
# ============================================================================

export WasmBlockKind, WasmBlock
export WasmControlFlow, WasmControlFlow__create
