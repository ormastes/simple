# Suffix Registry - Maps literal suffixes to their resolved types
#
# When the parser sees `42_uid` or `true_absolute`, it stores the suffix text.
# This registry resolves those suffixes to concrete type information during
# compilation, enabling type inference and conflict detection.

# --- SuffixEntry ---

class SuffixEntry:
    suffix: text          # "km" (without underscore)
    type_name: text       # "Km" or "length" (unit family)
    value_type: text      # "i64", "f64", "bool", "text"
    module_path: text     # source module for visibility
    is_public: bool       # whether the unit type is publicly exported

    fn fmt() -> text:
        val vis = if self.is_public: "pub" else: "pri"
        "SuffixEntry(_{self.suffix} -> {self.type_name} [{self.value_type}] {vis} from {self.module_path})"

# --- SuffixConflict ---

struct SuffixConflict:
    suffix: text
    existing: SuffixEntry
    new_entry: SuffixEntry

    fn fmt() -> text:
        "conflicting suffix '_{self.suffix}' from {self.existing.type_name} and {self.new_entry.type_name}"

# --- SuffixRegistry ---

class SuffixRegistry:
    entries: [SuffixEntry]
    suffix_map: [text]        # parallel array: suffix strings
    entry_map: [SuffixEntry]  # parallel array: corresponding entries
    conflicts_list: [SuffixConflict]

    me register(suffix: text, type_name: text, value_type: text, module_path: text):
        self.register_with_visibility(suffix, type_name, value_type, module_path, true)

    me register_with_visibility(suffix: text, type_name: text, value_type: text, module_path: text, is_public: bool):
        val entry = SuffixEntry(
            suffix: suffix,
            type_name: type_name,
            value_type: value_type,
            module_path: module_path,
            is_public: is_public
        )

        # Check for conflicts with existing entries
        val existing = self.resolve(suffix)
        if existing.?:
            val conflict = SuffixConflict(
                suffix: suffix,
                existing: existing,
                new_entry: entry
            )
            self.conflicts_list.push(conflict)

        self.entries.push(entry)
        self.suffix_map.push(suffix)
        self.entry_map.push(entry)

    fn resolve(suffix: text):
        var idx = 0
        for s in self.suffix_map:
            if s == suffix:
                return self.entry_map[idx]
            idx = idx + 1
        nil

    # Resolve suffix with visibility check - only returns entries visible from the given module
    fn resolve_visible(suffix: text, from_module: text):
        var idx = 0
        for s in self.suffix_map:
            if s == suffix:
                val entry = self.entry_map[idx]
                # Public entries are always visible
                if entry.is_public:
                    return entry
                # Private entries only visible within same module
                if entry.module_path == from_module:
                    return entry
            idx = idx + 1
        nil

    fn has(suffix: text) -> bool:
        for s in self.suffix_map:
            if s == suffix:
                return true
        false

    fn conflicts(suffix: text) -> [SuffixEntry]:
        var matches = []
        var idx = 0
        for s in self.suffix_map:
            if s == suffix:
                matches.push(self.entry_map[idx])
            idx = idx + 1
        matches

    fn get_conflicts() -> [SuffixConflict]:
        self.conflicts_list

    fn has_conflicts() -> bool:
        self.conflicts_list.len() > 0

    fn all_entries() -> [SuffixEntry]:
        self.entries

    fn fmt() -> text:
        "SuffixRegistry({self.entries.len()} entries)"

fn SuffixRegistry__new() -> SuffixRegistry:
    SuffixRegistry(entries: [], suffix_map: [], entry_map: [], conflicts_list: [])

export SuffixEntry, SuffixConflict, SuffixRegistry, SuffixRegistry__new
