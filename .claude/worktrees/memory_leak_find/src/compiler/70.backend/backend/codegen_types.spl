# Codegen Types Re-export
#
# Re-exports codegen trait types from common/codegen.spl through a
# non-reserved path. The word "common" is a reserved keyword in the
# interpreter parser, so direct imports like
#   use compiler.backend.common.codegen.{Codegen}
# fail at parse time. This file provides an alternative import path:
#   use compiler.backend.codegen_types.{Codegen, CodegenOutput, CodegenOutputKind}

# Note: This file is loaded from compiled code paths where common/codegen.spl
# has already been resolved by the module system. The 'export' directives
# reference the common/ submodule which is handled at the module level.

use compiler.mir.mir_data.{MirModule}
use compiler.core.backend_types.{BackendKind, CodegenTarget, CompiledModule, CompiledSymbol, CompileError}

# ============================================================================
# Re-export from common/codegen.spl
# ============================================================================

# We inline the key types here so they're importable without going through common/

enum CodegenOutputKind:
    # Describes the kind of output a backend produces.
    ObjectCode
    TextSource
    GpuCode
    InterpretedResult

class CodegenOutput:
    # Result of a codegen backend compiling a module.
    name: text
    kind: CodegenOutputKind
    text_output: text
    has_text_output: bool
    header_output: text
    has_header_output: bool
    object_code: [i64]
    has_object_code: bool
    symbols: [CompiledSymbol]
    compile_time_ms: i64

    static fn text(name: text, source: text) -> CodegenOutput:
        CodegenOutput(
            name: name,
            kind: CodegenOutputKind.TextSource,
            text_output: source,
            has_text_output: true,
            header_output: "",
            has_header_output: false,
            object_code: [],
            has_object_code: false,
            symbols: [],
            compile_time_ms: 0
        )

    static fn text_with_header(name: text, source: text, header: text) -> CodegenOutput:
        CodegenOutput(
            name: name,
            kind: CodegenOutputKind.TextSource,
            text_output: source,
            has_text_output: true,
            header_output: header,
            has_header_output: true,
            object_code: [],
            has_object_code: false,
            symbols: [],
            compile_time_ms: 0
        )

    static fn object(name: text, bytes: [i64]) -> CodegenOutput:
        CodegenOutput(
            name: name,
            kind: CodegenOutputKind.ObjectCode,
            text_output: "",
            has_text_output: false,
            header_output: "",
            has_header_output: false,
            object_code: bytes,
            has_object_code: true,
            symbols: [],
            compile_time_ms: 0
        )

    static fn gpu(name: text, source: text) -> CodegenOutput:
        CodegenOutput(
            name: name,
            kind: CodegenOutputKind.GpuCode,
            text_output: source,
            has_text_output: true,
            header_output: "",
            has_header_output: false,
            object_code: [],
            has_object_code: false,
            symbols: [],
            compile_time_ms: 0
        )

    static fn interpreted(name: text) -> CodegenOutput:
        CodegenOutput(
            name: name,
            kind: CodegenOutputKind.InterpretedResult,
            text_output: "",
            has_text_output: false,
            header_output: "",
            has_header_output: false,
            object_code: [],
            has_object_code: false,
            symbols: [],
            compile_time_ms: 0
        )

    fn with_symbols(syms: [CompiledSymbol]) -> CodegenOutput:
        CodegenOutput(
            name: self.name,
            kind: self.kind,
            text_output: self.text_output,
            has_text_output: self.has_text_output,
            header_output: self.header_output,
            has_header_output: self.has_header_output,
            object_code: self.object_code,
            has_object_code: self.has_object_code,
            symbols: syms,
            compile_time_ms: self.compile_time_ms
        )

    fn with_compile_time(ms: i64) -> CodegenOutput:
        CodegenOutput(
            name: self.name,
            kind: self.kind,
            text_output: self.text_output,
            has_text_output: self.has_text_output,
            header_output: self.header_output,
            has_header_output: self.has_header_output,
            object_code: self.object_code,
            has_object_code: self.has_object_code,
            symbols: self.symbols,
            compile_time_ms: ms
        )

    fn to_compiled_module() -> CompiledModule:
        CompiledModule(
            name: self.name,
            object_code: if self.has_object_code: self.object_code else: nil,
            assembly: if self.has_text_output: self.text_output else: nil,
            has_llvm_ir: self.has_header_output,
            llvm_ir: if self.has_header_output: self.header_output else: "",
            symbols: self.symbols,
            compile_time_ms: self.compile_time_ms
        )

trait Codegen:
    # Universal codegen interface implemented by all backends.
    fn backend_kind() -> BackendKind
    fn backend_name() -> text
    fn compile_module(module: MirModule) -> Result<CodegenOutput, CompileError>
    fn supports_target(target: CodegenTarget) -> bool
    fn output_kind() -> CodegenOutputKind

export Codegen, CodegenOutput, CodegenOutputKind
