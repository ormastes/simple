# MIR to LLVM IR Translation
#
# MirToLlvm class that translates MIR to LLVM IR.
# Implements MirTextCodegen trait for shared instruction dispatch.

use compiler.mir.mir_data.*
use compiler.backend.backend_api.*
use compiler.backend.llvm_target.{LlvmTargetTriple, LlvmTargetConfig, LlvmTargetTriple__from_target_with_mode, LlvmTargetConfig__for_target, LlvmTargetConfig__for_target_baremetal}
use compiler.backend.llvm_type_mapper.LlvmTypeMapper
use compiler.backend.llvm_ir_builder.{LlvmIRBuilder, LlvmIRBuilder__create, natural_alignment, is_integer_type, is_signed_int_type}
use compiler.backend.common.mir_text_codegen.MirTextCodegen

# ============================================================================
# MIR to LLVM IR Translation
# ============================================================================

class MirToLlvm:
    """Translates MIR to LLVM IR."""
    builder: LlvmIRBuilder
    local_map: Dict
    config: LlvmTargetConfig
    type_mapper: LlvmTypeMapper
    string_globals: [text]
    string_counter: i64
    local_types: Dict
    native_int_type: text      # "i32" for 32-bit targets, "i64" for 64-bit

    fn native_int() -> text:
        """Return the native integer type for the current target."""
        self.native_int_type

    static fn create(module_name: text, target: CodegenTarget, cpu_override: text?) -> MirToLlvm:
        val config = LlvmTargetConfig__for_target(target, cpu_override)
        val nit = if target.is_32bit(): "i32" else: "i64"
        MirToLlvm(
            builder: LlvmIRBuilder__create(module_name, config.triple),
            local_map: {},
            config: config,
            type_mapper: LlvmTypeMapper__create_for_target(target),
            string_globals: [],
            string_counter: 0,
            local_types: {},
            native_int_type: nit
        )

    static fn create_baremetal(module_name: text, target: CodegenTarget, cpu_override: text?) -> MirToLlvm:
        """Create MIR->LLVM translator for bare-metal targets."""
        val config = LlvmTargetConfig__for_target_baremetal(target, cpu_override)
        val builder = LlvmIRBuilder__create(module_name, config.triple)
        val nit = if target.is_32bit(): "i32" else: "i64"

        builder.emit_baremetal_attributes()

        MirToLlvm(
            builder: builder,
            local_map: {},
            config: config,
            type_mapper: LlvmTypeMapper__create_for_target(target),
            string_globals: [],
            string_counter: 0,
            local_types: {},
            native_int_type: nit
        )

# ============================================================================
# MirTextCodegen Trait Implementation
# ============================================================================

impl MirTextCodegen for MirToLlvm:

    # === Required: top-level translation ===

    me translate_module(module: MirModule) -> text:
        """Translate MIR module to LLVM IR."""
        self.builder.emit_module_header()
        self.emit_runtime_declarations()

        for name, body in module.functions:
            self.translate_function(name, body)

        if self.string_globals.len() > 0:
            self.builder.emit("")
            self.builder.emit("; String constants")
            for global_decl in self.string_globals:
                self.builder.emit(global_decl)

        self.builder.emit_tbaa_hierarchy()
        self.builder.build()

    me translate_function(name: text, body: MirBody):
        """Translate a MIR function with optimization attributes."""
        self.local_types = {}
        for local in body.locals:
            val llvm_ty = self.type_mapper.map_type(local.type_)
            self.local_types[local.id.id] = llvm_ty

        var params: [text] = []
        for i in 0..body.arg_count:
            val param_ty = self.get_local_type(i)
            params = params.push("{param_ty} %arg{i}")

        val ret_ty = self.type_mapper.map_type(body.return_ty)

        var has_store = false
        var has_call = false
        var inst_count = 0
        for block in body.blocks:
            for inst in block.instructions:
                inst_count = inst_count + 1
                match inst.kind:
                    case Store(_, _): has_store = true
                    case SetField(_, _, _): has_store = true
                    case Call(_, _, _): has_call = true
                    case CallIndirect(_, _, _, _): has_call = true
                    case Intrinsic(_, _, _): has_call = true
                    case Send(_, _): has_store = true
                    case _: ()

        val is_readonly = not has_store and not has_call
        val is_small = inst_count < 10

        self.builder.start_function_opt(name, params, ret_ty, is_readonly, is_small)

        for block in body.blocks:
            self.translate_block(block)

        self.builder.end_function()

    me translate_block(block: MirBasicBlock):
        """Translate a MIR basic block."""
        self.builder.emit_label("bb{block.id}")
        for inst in block.instructions:
            self.translate_instruction(inst)
        self.translate_terminator(block.terminator)

    me translate_terminator(term: MirTerminator):
        """Translate a block terminator."""
        match term:
            case Return(value):
                if value.?:
                    val val_str = self.translate_operand(value.unwrap())
                    val nit = self.native_int()
                    self.builder.emit_ret(nit, val_str)
                else:
                    self.builder.emit_ret_void()

            case Goto(target):
                self.builder.emit_br("bb{target}")

            case If(cond, then_, else_):
                val cond_val = self.translate_operand(cond)
                val nit = self.native_int()
                val i1_cond = self.builder.fresh_local()
                self.builder.emit("  {i1_cond} = icmp ne {nit} {cond_val}, 0")
                self.builder.emit_cond_br(i1_cond, "bb{then_}", "bb{else_}")

            case Switch(value, targets, default):
                val discr_val = self.translate_operand(value)
                val nit = self.native_int()
                var cases: [(text, text)] = []
                for switch_case in targets:
                    val case_value = "{switch_case.value}"
                    val case_label = "bb{switch_case.target}"
                    cases = cases.push((case_value, case_label))
                self.builder.emit_switch(discr_val, nit, "bb{default}", cases)

            case Unreachable:
                self.builder.emit("  unreachable")

            case Abort(message):
                self.builder.emit("  call void @abort()  ; {message}")
                self.builder.emit("  unreachable")

            case CallTerminator(dest, func, args, normal, unwind):
                val func_val = self.translate_operand(func)
                var arg_vals: [text] = []
                for arg in args:
                    arg_vals = arg_vals.push(self.translate_operand(arg))
                val args_str = arg_vals.join(", ")
                if dest.?:
                    val dest_name = self.get_local(dest.unwrap().id)
                    val ret_ty = self.get_local_type(dest.unwrap().id)
                    if unwind.?:
                        self.builder.emit("  {dest_name} = invoke {ret_ty} @{func_val}({args_str}) to label %bb{normal} unwind label %bb{unwind.unwrap()}")
                    else:
                        self.builder.emit("  {dest_name} = call {ret_ty} @{func_val}({args_str})")
                        self.builder.emit_br("bb{normal}")
                else:
                    if unwind.?:
                        self.builder.emit("  invoke void @{func_val}({args_str}) to label %bb{normal} unwind label %bb{unwind.unwrap()}")
                    else:
                        self.builder.emit("  call void @{func_val}({args_str})")
                        self.builder.emit_br("bb{normal}")

    # === Required: per-category instruction methods ===

    me translate_const(dest: LocalId, value: MirConstValue, ty: MirType):
        val dest_name = self.get_local(dest.id)
        val llvm_ty = self.type_mapper.map_type(ty)
        val const_val = self.translate_const_value(value)
        self.builder.emit("  {dest_name} = add {llvm_ty} {const_val}, 0  ; const load")

    me translate_copy_move(dest: LocalId, src: LocalId, is_move: bool):
        val dest_name = self.get_local(dest.id)
        val src_name = self.get_local(src.id)
        val ty = self.get_local_type(src.id)
        val comment = if is_move: "move" else: "copy"
        self.builder.emit("  {dest_name} = add {ty} {src_name}, 0  ; {comment}")

    me translate_binop(dest: LocalId, op: MirBinOp, left: MirOperand, right: MirOperand):
        """Translate binary operation. Uses nsw for signed int arithmetic."""
        val dest_name = self.get_local(dest.id)
        val left_val = self.translate_operand(left)
        val right_val = self.translate_operand(right)
        val ty = self.get_local_type(dest.id)

        match op:
            case Add:
                if is_signed_int_type(ty):
                    self.builder.emit_add_nsw(dest_name, ty, left_val, right_val)
                else:
                    self.builder.emit_add(dest_name, ty, left_val, right_val)
            case Sub:
                if is_signed_int_type(ty):
                    self.builder.emit_sub_nsw(dest_name, ty, left_val, right_val)
                else:
                    self.builder.emit_sub(dest_name, ty, left_val, right_val)
            case Mul:
                if is_signed_int_type(ty):
                    self.builder.emit_mul_nsw(dest_name, ty, left_val, right_val)
                else:
                    self.builder.emit_mul(dest_name, ty, left_val, right_val)
            case Div: self.builder.emit_div(dest_name, ty, left_val, right_val)
            case Rem: self.builder.emit_rem(dest_name, ty, left_val, right_val)
            case Pow:
                val nit = self.native_int()
                self.builder.emit("  {dest_name} = call {nit} @llvm.powi.{nit}.{nit}({nit} {left_val}, {nit} {right_val})")
            case BitAnd: self.builder.emit_and(dest_name, ty, left_val, right_val)
            case BitOr: self.builder.emit_or(dest_name, ty, left_val, right_val)
            case BitXor: self.builder.emit_xor(dest_name, ty, left_val, right_val)
            case Shl: self.builder.emit_shl(dest_name, ty, left_val, right_val)
            case Shr: self.builder.emit_ashr(dest_name, ty, left_val, right_val)
            case Eq: self.builder.emit_icmp_eq(dest_name, ty, left_val, right_val)
            case Ne: self.builder.emit_icmp_ne(dest_name, ty, left_val, right_val)
            case Lt: self.builder.emit_icmp_slt(dest_name, ty, left_val, right_val)
            case Le: self.builder.emit_icmp_sle(dest_name, ty, left_val, right_val)
            case Gt: self.builder.emit_icmp_sgt(dest_name, ty, left_val, right_val)
            case Ge: self.builder.emit_icmp_sge(dest_name, ty, left_val, right_val)
            case MatMul:
                self.builder.emit("  {dest_name} = call ptr @__simple_runtime_matmul(ptr {left_val}, ptr {right_val})  ; matrix multiply (@)")
            case BroadcastAdd:
                self.builder.emit("  {dest_name} = call ptr @__simple_runtime_broadcast_add(ptr {left_val}, ptr {right_val})  ; broadcast add (.+)")
            case BroadcastSub:
                self.builder.emit("  {dest_name} = call ptr @__simple_runtime_broadcast_sub(ptr {left_val}, ptr {right_val})  ; broadcast sub (.-)")
            case BroadcastMul:
                self.builder.emit("  {dest_name} = call ptr @__simple_runtime_broadcast_mul(ptr {left_val}, ptr {right_val})  ; broadcast mul (.*)")
            case BroadcastDiv:
                self.builder.emit("  {dest_name} = call ptr @__simple_runtime_broadcast_div(ptr {left_val}, ptr {right_val})  ; broadcast div (./)")
            case BroadcastPow:
                self.builder.emit("  {dest_name} = call ptr @__simple_runtime_broadcast_pow(ptr {left_val}, ptr {right_val})  ; broadcast pow (.^)")
            case Offset:
                val nit = self.native_int()
                val offset_ptr = self.builder.fresh_local()
                self.builder.emit("  {offset_ptr} = getelementptr i8, ptr {left_val}, {nit} {right_val}")
                self.builder.emit("  {dest_name} = ptrtoint ptr {offset_ptr} to {nit}")

    me translate_unaryop(dest: LocalId, op: MirUnaryOp, operand: MirOperand):
        """Translate unary operation."""
        val dest_name = self.get_local(dest.id)
        val operand_val = self.translate_operand(operand)
        val ty = self.get_local_type(dest.id)

        match op:
            case Neg: self.builder.emit_neg(dest_name, ty, operand_val)
            case Not:
                self.builder.emit_icmp_eq(dest_name, ty, operand_val, "0")
            case BitNot: self.builder.emit_not(dest_name, ty, operand_val)
            case Transpose:
                self.builder.emit("  {dest_name} = call ptr @__simple_runtime_transpose(ptr {operand_val})  ; transpose (')")

    me translate_call(dest: LocalId?, func: MirOperand, args: [MirOperand]):
        val dest_name = if dest.?: Some(self.get_local(dest.unwrap().id)) else: nil
        val func_name = self.translate_operand(func)
        var arg_parts: [text] = []
        for arg in args:
            val arg_val = self.translate_operand(arg)
            val arg_ty = self.get_operand_type(arg)
            arg_parts = arg_parts.push("{arg_ty} {arg_val}")
        val args_str = arg_parts.join(", ")
        var ret_ty = "void"
        if dest.?:
            ret_ty = self.get_local_type(dest.unwrap().id)
        if dest_name.?:
            self.builder.emit("  {dest_name.unwrap()} = call {ret_ty} {func_name}({args_str})")
        else:
            self.builder.emit("  call {ret_ty} {func_name}({args_str})")

    # === Required: helpers ===

    me translate_operand(operand: MirOperand) -> text:
        """Translate MIR operand to LLVM value."""
        match operand.kind:
            case Copy(local):
                self.get_local(local)
            case Move(local):
                self.get_local(local)
            case Const(value, type_):
                self.translate_const_value(value)

    me translate_const_value(value: MirConstValue) -> text:
        """Translate MIR constant value to LLVM constant."""
        match value:
            case Int(val): "{val}"
            case Float(val): "{val}"
            case Bool(val): if val: "1" else: "0"
            case Str(val):
                val global_name = self.add_string_global(val)
                val str_len = val.len() + 1
                val nit = self.native_int()
                "getelementptr inbounds ([{str_len} x i8], ptr {global_name}, {nit} 0, {nit} 0)"
            case Zero: "0"
            case Array(elements):
                val count = elements.len()
                "zeroinitializer  ; array ({count} elements)"
            case Tuple(elements):
                val count = elements.len()
                "zeroinitializer  ; tuple ({count} elements)"
            case Struct(fields):
                "zeroinitializer  ; struct"

    fn get_local(id: i64) -> text:
        """Get LLVM local name for MIR local."""
        match self.local_map.get(id):
            case Some(name): name
            case nil:
                val name = "%l{id}"
                self.local_map[id] = name
                name

    fn get_local_type(id: i64) -> text:
        """Get LLVM type for a local variable, falling back to native int type."""
        match self.local_types.get(id):
            case Some(ty): ty
            case nil: self.native_int()

    fn get_operand_type(operand: MirOperand) -> text:
        """Get the LLVM type string for an operand."""
        match operand.kind:
            case Copy(local):
                self.get_local_type(local)
            case Move(local):
                self.get_local_type(local)
            case Const(value, type_):
                self.type_mapper.map_type(type_)

    # === Overrides: memory ===

    me translate_alloc(dest: LocalId, ty: MirType):
        val dest_name = self.get_local(dest.id)
        val llvm_ty = self.type_mapper.map_type(ty)
        self.builder.emit_alloca(dest_name, llvm_ty)

    me translate_load(dest: LocalId, ptr: MirOperand):
        val dest_name = self.get_local(dest.id)
        val ptr_val = self.translate_operand(ptr)
        val load_ty = self.get_local_type(dest.id)
        self.builder.emit_load(dest_name, load_ty, ptr_val)

    me translate_store(ptr: MirOperand, value: MirOperand):
        val ptr_val = self.translate_operand(ptr)
        val value_val = self.translate_operand(value)
        val store_ty = self.get_operand_type(value)
        self.builder.emit_store(store_ty, value_val, ptr_val)

    me translate_gep(dest: LocalId, base: MirOperand, indices: [MirOperand]):
        val dest_name = self.get_local(dest.id)
        val base_val = self.translate_operand(base)
        var index_vals: [text] = []
        for idx in indices:
            index_vals = index_vals.push(self.translate_operand(idx))
        val base_ty = self.get_operand_type(base)
        self.builder.emit_gep(dest_name, base_ty, base_val, index_vals)

    # === Overrides: aggregates ===

    me translate_aggregate(dest: LocalId, kind: AggregateKind, operands: [MirOperand]):
        val dest_name = self.get_local(dest.id)
        val agg_ty = self.get_local_type(dest.id)
        val agg_ptr = self.builder.fresh_local()
        self.builder.emit_alloca(agg_ptr, agg_ty)
        for i in 0..operands.len():
            val elem_val = self.translate_operand(operands[i])
            val elem_ty = self.get_operand_type(operands[i])
            val elem_ptr = self.builder.fresh_local()
            self.builder.emit("  {elem_ptr} = getelementptr inbounds {agg_ty}, ptr {agg_ptr}, i32 0, i32 {i}")
            self.builder.emit_store(elem_ty, elem_val, elem_ptr)
        self.builder.emit_load(dest_name, agg_ty, agg_ptr)

    me translate_get_field(dest: LocalId, base: MirOperand, field: i64):
        val dest_name = self.get_local(dest.id)
        val base_val = self.translate_operand(base)
        val nit = self.native_int()
        val field_ptr = self.builder.fresh_local()
        self.builder.emit("  {field_ptr} = getelementptr inbounds {nit}, ptr {base_val}, i32 {field}")
        self.builder.emit_load(dest_name, nit, field_ptr)

    me translate_set_field(base: MirOperand, field: i64, value: MirOperand):
        val base_val = self.translate_operand(base)
        val value_val = self.translate_operand(value)
        val nit = self.native_int()
        val field_ptr = self.builder.fresh_local()
        self.builder.emit("  {field_ptr} = getelementptr inbounds {nit}, ptr {base_val}, i32 {field}")
        self.builder.emit_store(nit, value_val, field_ptr)

    # === Overrides: casts ===

    me translate_cast(dest: LocalId, operand: MirOperand, target: MirType):
        val dest_name = self.get_local(dest.id)
        val operand_val = self.translate_operand(operand)
        val src_ty = self.get_operand_type(operand)
        val target_ty = self.type_mapper.map_type(target)
        val cast_inst = self.select_cast_instruction(src_ty, target_ty)
        self.builder.emit("  {dest_name} = {cast_inst} {src_ty} {operand_val} to {target_ty}")

    me translate_bitcast(dest: LocalId, operand: MirOperand, target: MirType):
        val dest_name = self.get_local(dest.id)
        val operand_val = self.translate_operand(operand)
        val src_ty = self.get_operand_type(operand)
        val target_ty = self.type_mapper.map_type(target)
        self.builder.emit("  {dest_name} = bitcast {src_ty} {operand_val} to {target_ty}")

    # === Overrides: indirect calls / intrinsics ===

    me translate_call_indirect(dest: LocalId?, ptr: MirOperand, args: [MirOperand], sig: MirSignature):
        val dest_name = if dest.?: Some(self.get_local(dest.unwrap().id)) else: nil
        val ptr_val = self.translate_operand(ptr)
        var arg_vals: [text] = []
        for arg in args:
            arg_vals = arg_vals.push(self.translate_operand(arg))
        val ret_ty = self.type_mapper.map_type(sig.return_type)
        self.builder.emit_call_indirect(dest_name, ret_ty, ptr_val, arg_vals)

    me translate_intrinsic(dest: LocalId?, name: text, args: [MirOperand]):
        var arg_vals: [text] = []
        for arg in args:
            arg_vals = arg_vals.push("i64 " + self.translate_operand(arg))
        val args_str = arg_vals.join(", ")
        if dest.?:
            val dest_name = self.get_local(dest.unwrap().id)
            val ret_ty = self.get_local_type(dest.unwrap().id)
            self.builder.emit("  {dest_name} = call {ret_ty} @__simple_intrinsic_{name}({args_str})  ; intrinsic: {name}")
        else:
            self.builder.emit("  call void @__simple_intrinsic_{name}({args_str})  ; intrinsic: {name}")

    me translate_inline_asm(asm_template: text, is_volatile: bool, inputs: [MirAsmOperand], outputs: [MirAsmOperand], clobbers: [text]):
        """Translate inline assembly to LLVM inline asm call."""
        var constraint_parts: [text] = []
        var arg_values: [text] = []
        var arg_types: [text] = []

        for output in outputs:
            val constraint = self.build_output_constraint(output)
            constraint_parts.push(constraint)

        for input in inputs:
            val constraint = self.build_input_constraint(input)
            constraint_parts.push(constraint)
            val operand_value = self.translate_operand(input.operand)
            arg_values.push(operand_value)
            arg_types.push(self.native_int())

        for clobber in clobbers:
            constraint_parts.push("~{{clobber}}")

        val constraints = constraint_parts.join(",")

        var arg_list = ""
        for i in 0..arg_values.len():
            if i > 0:
                arg_list = arg_list + ", "
            arg_list = arg_list + "{arg_types[i]} {arg_values[i]}"

        val volatile_flag = if is_volatile: " sideeffect" else: ""
        val asm_call = "  call void asm{volatile_flag} \"{asm_template}\", \"{constraints}\"({arg_list})"
        self.builder.emit(asm_call)

    # === Overrides: pipeline operators ===

    me translate_pipe_forward(dest: LocalId, value: MirOperand, func: MirOperand):
        val dest_name = self.get_local(dest.id)
        val value_val = self.translate_operand(value)
        val func_val = self.translate_operand(func)
        val ret_ty = self.get_local_type(dest.id)
        self.builder.emit("  {dest_name} = call {ret_ty} {func_val}(i64 {value_val})  ; pipe forward")

    me translate_compose(dest: LocalId, f: MirOperand, g: MirOperand, forward: bool):
        val dest_name = self.get_local(dest.id)
        val f_val = self.translate_operand(f)
        val g_val = self.translate_operand(g)
        val dir = if forward: "forward" else: "backward"
        self.builder.emit("  {dest_name} = call ptr @__simple_runtime_compose(ptr {f_val}, ptr {g_val})  ; compose ({dir})")

    me translate_parallel(dest: LocalId, funcs: [MirOperand]):
        val dest_name = self.get_local(dest.id)
        val count = funcs.len()
        self.builder.emit("  {dest_name} = call ptr @__simple_runtime_parallel(i64 {count})  ; parallel ({count} functions)")

    me translate_layer_connect(dest: LocalId, l1: MirOperand, l2: MirOperand):
        val dest_name = self.get_local(dest.id)
        val l1_val = self.translate_operand(l1)
        val l2_val = self.translate_operand(l2)
        self.builder.emit("  {dest_name} = call ptr @__simple_runtime_layer_connect(ptr {l1_val}, ptr {l2_val})  ; layer connect")

    # === Overrides: borrow checking ===

    me translate_ref(dest: LocalId, kind: MirBorrowKind, place: MirPlace):
        val dest_name = self.get_local(dest.id)
        val place_val = self.get_local(place.local.id)
        val nit = self.native_int()
        self.builder.emit("  {dest_name} = add {nit} {place_val}, 0  ; Ref (borrow)")

    # === Overrides: async/actor stubs ===

    me translate_create_promise(dest: LocalId, body: LocalId, result_type: MirType):
        val dest_name = self.get_local(dest.id)
        self.builder.emit("  {dest_name} = call ptr @__simple_runtime_create_promise(ptr null)  ; CreatePromise (async)")

    me translate_await(dest: LocalId, promise: MirOperand):
        val dest_name = self.get_local(dest.id)
        val promise_val = self.translate_operand(promise)
        self.builder.emit("  {dest_name} = call i64 @__simple_runtime_await(ptr {promise_val})  ; Await")

    me translate_yield(value: MirOperand?):
        if value.?:
            val val_str = self.translate_operand(value.unwrap())
            self.builder.emit("  call void @__simple_runtime_yield(i64 {val_str})  ; Yield")
        else:
            self.builder.emit("  call void @__simple_runtime_yield(i64 0)  ; Yield (unit)")

    me translate_spawn(dest: LocalId, handler: MirOperand, args: [MirOperand]):
        val dest_name = self.get_local(dest.id)
        val handler_val = self.translate_operand(handler)
        self.builder.emit("  {dest_name} = call ptr @__simple_runtime_spawn(ptr {handler_val})  ; Spawn")

    me translate_send(target: MirOperand, message: MirOperand):
        val target_val = self.translate_operand(target)
        val msg_val = self.translate_operand(message)
        self.builder.emit("  call void @__simple_runtime_send(ptr {target_val}, i64 {msg_val})  ; Send")

    me translate_receive(dest: LocalId, timeout: MirOperand?):
        val dest_name = self.get_local(dest.id)
        if timeout.?:
            val timeout_val = self.translate_operand(timeout.unwrap())
            self.builder.emit("  {dest_name} = call i64 @__simple_runtime_receive(i64 {timeout_val})  ; Receive (with timeout)")
        else:
            self.builder.emit("  {dest_name} = call i64 @__simple_runtime_receive(i64 -1)  ; Receive (blocking)")

    # === Overrides: GPU stubs ===

    me translate_gpu_kernel_def(name: text):
        self.builder.emit("  ; GpuKernelDef: {name} (requires GPU backend)")

    me translate_gpu_launch(args: [text]):
        self.builder.emit("  ; GpuLaunch (requires GPU backend)")

    me translate_gpu_global_id(dest: LocalId, dim: i64):
        val dest_name = self.get_local(dest.id)
        self.builder.emit("  {dest_name} = add i64 0, 0  ; GpuGlobalId dim={dim} (stub)")

    me translate_gpu_local_id(dest: LocalId, dim: i64):
        val dest_name = self.get_local(dest.id)
        self.builder.emit("  {dest_name} = add i64 0, 0  ; GpuLocalId dim={dim} (stub)")

    me translate_gpu_block_id(dest: LocalId, dim: i64):
        val dest_name = self.get_local(dest.id)
        self.builder.emit("  {dest_name} = add i64 0, 0  ; GpuBlockId dim={dim} (stub)")

    me translate_gpu_block_dim(dest: LocalId, dim: i64):
        val dest_name = self.get_local(dest.id)
        self.builder.emit("  {dest_name} = add i64 0, 0  ; GpuBlockDim dim={dim} (stub)")

    me translate_gpu_grid_dim(dest: LocalId, dim: i64):
        val dest_name = self.get_local(dest.id)
        self.builder.emit("  {dest_name} = add i64 0, 0  ; GpuGridDim dim={dim} (stub)")

    me translate_gpu_barrier(scope: GpuBarrierScope):
        self.builder.emit("  ; GpuBarrier (requires GPU backend)")

    me translate_gpu_mem_fence(scope: GpuMemoryScope):
        self.builder.emit("  ; GpuMemFence (requires GPU backend)")

    me translate_gpu_shared_alloc(dest: LocalId, type_: MirType, size: i64):
        val dest_name = self.get_local(dest.id)
        self.builder.emit("  {dest_name} = alloca i8, i64 {size}  ; GpuSharedAlloc (stub)")

    me translate_gpu_atomic_op(dest: LocalId, op: GpuAtomicOpKind, ptr: MirOperand, value: MirOperand):
        val dest_name = self.get_local(dest.id)
        val ptr_val = self.translate_operand(ptr)
        val value_val = self.translate_operand(value)
        self.builder.emit("  {dest_name} = atomicrmw add ptr {ptr_val}, i64 {value_val} seq_cst  ; GpuAtomicOp (stub)")

    # === Overrides: VHDL stubs ===

    me translate_vhdl_process(kind: VhdlProcessKind, body_block: BlockId):
        self.builder.emit("  ; VhdlProcess (requires VHDL backend)")

    me translate_vhdl_signal_assign(target: MirOperand, value: MirOperand, delay_ns: i64?):
        self.builder.emit("  ; VhdlSignalAssign (requires VHDL backend)")

    me translate_vhdl_var_assign(target: MirOperand, value: MirOperand):
        self.builder.emit("  ; VhdlVarAssign (requires VHDL backend)")

    me translate_vhdl_port_map(entity: text, instance: text, connections: [(text, MirOperand)]):
        self.builder.emit("  ; VhdlPortMap: {entity}/{instance} (requires VHDL backend)")

    me translate_vhdl_resize(dest: LocalId, operand: MirOperand, new_width: i64, signed: bool):
        val dest_name = self.get_local(dest.id)
        self.builder.emit("  {dest_name} = add i64 0, 0  ; VhdlResize width={new_width} (requires VHDL backend)")

    me translate_vhdl_slice(dest: LocalId, signal: MirOperand, hi: i64, lo: i64):
        val dest_name = self.get_local(dest.id)
        self.builder.emit("  {dest_name} = add i64 0, 0  ; VhdlSlice [{hi}:{lo}] (requires VHDL backend)")

    me translate_vhdl_concat(dest: LocalId, parts: [MirOperand]):
        val dest_name = self.get_local(dest.id)
        self.builder.emit("  {dest_name} = add i64 0, 0  ; VhdlConcat (requires VHDL backend)")

    # === Overrides: SIMD stubs ===

    me translate_simd_binop(dest: LocalId, a: MirOperand, b: MirOperand, op_name: text):
        val dest_name = self.get_local(dest.id)
        self.builder.emit("  {dest_name} = add i64 0, 0  ; SIMD {op_name} (stub)")

    me translate_simd_fma(dest: LocalId, a: MirOperand, b: MirOperand, c: MirOperand, op_name: text):
        val dest_name = self.get_local(dest.id)
        self.builder.emit("  {dest_name} = add i64 0, 0  ; SIMD {op_name} (stub)")

    me translate_simd_horizontal(dest: LocalId, a: MirOperand, op_name: text):
        val dest_name = self.get_local(dest.id)
        self.builder.emit("  {dest_name} = add i64 0, 0  ; SIMD {op_name} (stub)")

# ============================================================================
# LLVM-Specific Helpers (not part of trait)
# ============================================================================

impl MirToLlvm:

    me emit_runtime_declarations():
        """Emit declarations for runtime intrinsics used by matrix/broadcast ops."""
        self.builder.emit("; Runtime intrinsic declarations")
        self.builder.emit("declare ptr @__simple_runtime_matmul(ptr, ptr)")
        self.builder.emit("declare ptr @__simple_runtime_transpose(ptr)")
        self.builder.emit("declare ptr @__simple_runtime_broadcast_add(ptr, ptr)")
        self.builder.emit("declare ptr @__simple_runtime_broadcast_sub(ptr, ptr)")
        self.builder.emit("declare ptr @__simple_runtime_broadcast_mul(ptr, ptr)")
        self.builder.emit("declare ptr @__simple_runtime_broadcast_div(ptr, ptr)")
        self.builder.emit("declare ptr @__simple_runtime_broadcast_pow(ptr, ptr)")
        self.builder.emit("")

    me add_string_global(value: text) -> text:
        """Register a string constant and return its LLVM global name."""
        val id = self.string_counter
        self.string_counter = self.string_counter + 1
        val global_name = "@.str.{id}"
        val str_len = value.len() + 1
        val decl = "{global_name} = private unnamed_addr constant [{str_len} x i8] c\"{value}\\00\""
        self.string_globals = self.string_globals.push(decl)
        global_name

    fn select_cast_instruction(src_ty: text, target_ty: text) -> text:
        """Select the appropriate LLVM cast instruction based on source and target types."""
        if src_ty == "i8" and (target_ty == "i16" or target_ty == "i32" or target_ty == "i64"):
            return "sext"
        if src_ty == "i16" and (target_ty == "i32" or target_ty == "i64"):
            return "sext"
        if src_ty == "i32" and target_ty == "i64":
            return "sext"
        if src_ty == "i64" and (target_ty == "i32" or target_ty == "i16" or target_ty == "i8"):
            return "trunc"
        if src_ty == "i32" and (target_ty == "i16" or target_ty == "i8"):
            return "trunc"
        if src_ty == "i16" and target_ty == "i8":
            return "trunc"
        if src_ty == "i1" and (target_ty == "i8" or target_ty == "i16" or target_ty == "i32" or target_ty == "i64"):
            return "zext"
        if (src_ty == "i8" or src_ty == "i16" or src_ty == "i32" or src_ty == "i64") and target_ty == "double":
            return "sitofp"
        if (src_ty == "i8" or src_ty == "i16" or src_ty == "i32" or src_ty == "i64") and target_ty == "float":
            return "sitofp"
        if (src_ty == "double" or src_ty == "float") and (target_ty == "i8" or target_ty == "i16" or target_ty == "i32" or target_ty == "i64"):
            return "fptosi"
        if src_ty == "float" and target_ty == "double":
            return "fpext"
        if src_ty == "double" and target_ty == "float":
            return "fptrunc"
        if src_ty == "ptr" and (target_ty == "i32" or target_ty == "i64"):
            return "ptrtoint"
        if (src_ty == "i32" or src_ty == "i64") and target_ty == "ptr":
            return "inttoptr"
        "bitcast"

    fn build_output_constraint(output: MirAsmOperand) -> text:
        """Build LLVM constraint string for output operand."""
        val prefix = match output.kind:
            case Out: "="
            case LateOut: "=&"
            case InOut: "+"
            case _: "="
        val location = self.constraint_location(output.location)
        "{prefix}{location}"

    fn build_input_constraint(input: MirAsmOperand) -> text:
        """Build LLVM constraint string for input operand."""
        self.constraint_location(input.location)

    fn constraint_location(location: AsmLocation) -> text:
        """Convert AsmLocation to LLVM constraint code."""
        match location:
            case Reg: "r"
            case Mem: "m"
            case Imm: "i"
            case RegSpec(name): "{{name}}"

# Desugared static methods
fn MirToLlvm__create(module_name: text, target: CodegenTarget, cpu_override: text?) -> MirToLlvm:
    MirToLlvm__create(module_name, target, cpu_override)

fn MirToLlvm__create_baremetal(module_name: text, target: CodegenTarget, cpu_override: text?) -> MirToLlvm:
    MirToLlvm__create_baremetal(module_name, target, cpu_override)

export MirToLlvm
export MirToLlvm__create, MirToLlvm__create_baremetal
