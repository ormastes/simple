# SDN Backend - SDN export backend
#
# This module implements the SDN backend that blocks all code execution
# and only allows literal data construction (for SDN file parsing).

use compiler.hir.hir.*
use backend_types.*
use backend.env.EvalContext

# ============================================================================
# SDN Backend Implementation
# ============================================================================

struct SdnBackendImpl:
    """No-op backend for SDN parsing.

    Blocks ALL code execution. Only allows:
    - Literal values (int, float, string, bool, nil)
    - Array and dict construction
    - No function calls, no control flow, no side effects
    """

impl Backend for SdnBackendImpl:
    fn name() -> text:
        "sdn"

    fn kind() -> BackendKind:
        BackendKind.Sdn

    fn process_module(module: HirModule) -> Result<BackendResult, BackendError>:
        # SDN modules can't have functions
        if not module.functions.is_empty():
            return Err(BackendError.not_allowed("functions not allowed in SDN mode", nil))
        Ok(BackendResult.Unit)

    fn process_function(fn_: HirFunction) -> Result<BackendResult, BackendError>:
        Err(BackendError.not_allowed("functions not allowed in SDN mode", Some(fn_.span)))

    fn process_class(class_: HirClass) -> Result<BackendResult, BackendError>:
        Err(BackendError.not_allowed("classes not allowed in SDN mode", Some(class_.span)))

    fn process_struct(struct_: HirStruct) -> Result<BackendResult, BackendError>:
        # Structs as data definitions are OK
        Ok(BackendResult.Unit)

    fn process_enum(enum_: HirEnum) -> Result<BackendResult, BackendError>:
        # Enums as data definitions are OK
        Ok(BackendResult.Unit)

    fn process_trait(trait_: HirTrait) -> Result<BackendResult, BackendError>:
        Err(BackendError.not_allowed("traits not allowed in SDN mode", Some(trait_.span)))

    fn process_impl(impl_: HirImpl) -> Result<BackendResult, BackendError>:
        Err(BackendError.not_allowed("impls not allowed in SDN mode", Some(impl_.span)))

    fn eval_expr(expr: HirExpr, ctx: EvalContext) -> Result<Value, BackendError>:
        if not self.is_allowed(expr):
            return Err(BackendError.not_allowed(
                "expression not allowed in SDN mode",
                Some(expr.span)
            ))

        match expr.kind:
            case IntLit(value, _):
                Ok(Value.int(value))
            case FloatLit(value, _):
                Ok(Value.float(value))
            case StringLit(value, _):
                Ok(Value.string(value))
            case BoolLit(value):
                Ok(Value.bool(value))
            case NilLit:
                Ok(Value.make_nil())
            case ArrayLit(elements, _):
                var values: [Value] = []
                for elem in elements:
                    val v = self.eval_expr(elem, ctx)?
                    values = values.push(v)
                Ok(Value.Array(values))
            case DictLit(entries, _, _):
                var dict: Dict<text, Value> = {}
                for (key_expr, value_expr) in entries:
                    val key = self.eval_expr(key_expr, ctx)?
                    val value = self.eval_expr(value_expr, ctx)?
                    match key:
                        case String(k):
                            dict[k] = value
                        case _:
                            return Err(BackendError.type_error("dict key must be string", Some(expr.span)))
                Ok(Value.Dict(dict))
            case TupleLit(elements):
                var values: [Value] = []
                for elem in elements:
                    val v = self.eval_expr(elem, ctx)?
                    values = values.push(v)
                Ok(Value.Tuple(values))
            case _:
                Err(BackendError.not_allowed("expression not allowed in SDN mode", Some(expr.span)))

    fn exec_stmt(stmt: HirStmt, ctx: EvalContext) -> Result<(), BackendError>:
        Err(BackendError.not_allowed("statements not allowed in SDN mode", Some(stmt.span)))

    fn is_allowed(expr: HirExpr) -> bool:
        """Check if expression is allowed in SDN mode."""
        match expr.kind:
            # Only literal data construction is allowed
            case IntLit(_, _) | FloatLit(_, _) | StringLit(_, _)
               | BoolLit(_) | NilLit | UnitLit:
                true
            case ArrayLit(elements, _):
                elements.all(\e: self.is_allowed(e))
            case TupleLit(elements):
                elements.all(\e: self.is_allowed(e))
            case DictLit(entries, _, _):
                self.all_dict_entries_allowed(entries)
            # Everything else is blocked
            case _:
                false

    fn all_dict_entries_allowed(entries: [(HirExpr, HirExpr)]) -> bool:
        """Check if all dict entries are allowed in SDN mode."""
        for entry in entries:
            val (key, value) = entry
            if not self.is_allowed(key) or not self.is_allowed(value):
                return false
        true

    fn is_allowed_stmt(stmt: HirStmt) -> bool:
        # No statements allowed in SDN mode
        false

# ============================================================================
# Exports
# ============================================================================

export SdnBackendImpl
