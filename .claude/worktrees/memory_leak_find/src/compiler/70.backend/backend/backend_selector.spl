# Backend Selector
#
# Selects which backend to use (JIT vs AOT) based on compilation options.
# All backend selection logic is in Simple - Rust only provides the execution.

use compiler.backend.backend_types.*
use compiler.backend.optimization_passes.*

# ============================================================================
# FFI Declarations
# ============================================================================

# Get host target architecture at runtime
extern fn rt_get_host_target_code() -> i64

# ============================================================================
# Backend Selection
# ============================================================================

enum BackendMode:
    """Which backend mode to use for compilation."""
    Jit         # Just-In-Time compilation (immediate execution)
    Aot         # Ahead-Of-Time compilation (object file output)
    Interpreter # Tree-walking interpreter (no native code)

enum TargetArch:
    """Target architecture."""
    X86_64
    Aarch64
    Riscv64
    Host       # Detect at runtime

struct BackendOptions:
    """Options for backend selection and configuration."""
    kind: BackendMode
    target: TargetArch
    optimization: OptimizationLevel
    # # DESUGARED: output_path: text
    has_output_path: bool
    output_path: text
    enable_profiling: bool
    enable_coverage: bool
    is_pic: bool  # Position-independent code (required for shared libs/PIE)
    interpreter_mode: text  # "optimized" (default), "classic" (legacy)


# ============================================================================
# BackendOptions Methods (was: impl BackendOptions:)
# ============================================================================

fn backendoptions_jit() -> BackendOptions:
        """Options for JIT compilation."""
        BackendOptions(
            kind: BackendMode.Jit,
            target: TargetArch.Host,
            optimization: OptimizationLevel.Speed,
            #  # DESUGARED: output_path: nil
            enable_profiling: false,
            enable_coverage: false,
            is_pic: true,  # JIT always uses PIC
            interpreter_mode: "optimized"
        )


fn backendoptions_aot(output: text) -> BackendOptions:
        """Options for AOT compilation."""
        BackendOptions(
            kind: BackendMode.Aot,
            target: TargetArch.Host,
            optimization: OptimizationLevel.Speed,
            # # DESUGARED: output_path: Some(output)
            output_path: output,
            enable_profiling: false,
            enable_coverage: false,
            is_pic: true,  # Default to PIC for compatibility with PIE/shared libs
            interpreter_mode: "optimized"
        )


fn backendoptions_interpreter() -> BackendOptions:
        """Options for interpreter mode (shared/default)."""
        BackendOptions(
            kind: BackendMode.Interpreter,
            target: TargetArch.Host,
            optimization: OptimizationLevel.None_,
            #  # DESUGARED: output_path: nil
            enable_profiling: false,
            enable_coverage: false,
            is_pic: false,  # Interpreter doesn't need PIC
            interpreter_mode: "optimized"
        )


fn backendoptions_interpreter_optimized() -> BackendOptions:
        """Options for optimized interpreter mode (no GC, direct computation)."""
        BackendOptions(
            kind: BackendMode.Interpreter,
            target: TargetArch.Host,
            optimization: OptimizationLevel.None_,
            #  # DESUGARED: output_path: nil
            enable_profiling: false,
            enable_coverage: false,
            is_pic: false,
            interpreter_mode: "optimized"
        )


fn backendoptions_with_target(self: BackendOptions, target: TargetArch) -> BackendOptions:
        """Set target architecture."""
        self.target = target
        self


fn backendoptions_with_optimization(self: BackendOptions, level: OptimizationLevel) -> BackendOptions:
        """Set optimization level."""
        self.optimization = level
        self


fn backendoptions_with_profiling(self: BackendOptions, enabled: bool) -> BackendOptions:
        """Enable profiling instrumentation."""
        self.enable_profiling = enabled
        self


fn backendoptions_with_coverage(self: BackendOptions, enabled: bool) -> BackendOptions:
        """Enable coverage instrumentation."""
        self.enable_coverage = enabled
        self


fn backendoptions_with_pic(self: BackendOptions, enabled: bool) -> BackendOptions:
        """Enable position-independent code generation."""
        self.is_pic = enabled
        self


fn backendoptions_with_interpreter_mode(self: BackendOptions, mode: text) -> BackendOptions:
        """Set interpreter mode ('optimized' default, 'classic' legacy)."""
        self.interpreter_mode = mode
        self


# ============================================================================
# Backend Selector
# ============================================================================

struct BackendSelector:
    """Selects and configures backend based on options."""
    options: BackendOptions
    pass_config: PassConfig


# ============================================================================
# BackendSelector Methods (was: impl BackendSelector:)
# ============================================================================

fn backendselector_new(options: BackendOptions) -> BackendSelector:
        """Create backend selector."""
        val pass_config = PassConfig__for_level(options.optimization)
        BackendSelector(
            options: options,
            pass_config: pass_config
        )


# ============================================================================
# Auto-Selection
# ============================================================================

fn select_backend_auto(has_output_file: bool, is_debug: bool) -> BackendOptions:
    """Automatically select backend based on compilation context."""
    if is_debug:
        # Debug mode: use interpreter or JIT with debug opts
        if has_output_file:
            BackendOptions__aot("output.o").with_optimization(OptimizationLevel.Debug)
        else:
            BackendOptions__jit().with_optimization(OptimizationLevel.Debug)
    else:
        # Release mode: use optimal backend
        if has_output_file:
            BackendOptions__aot("output.o").with_optimization(OptimizationLevel.Speed)
        else:
            BackendOptions__jit().with_optimization(OptimizationLevel.Speed)

fn select_backend_for_script() -> BackendOptions:
    """Select backend for running scripts (prefer JIT)."""
    BackendOptions__jit()

fn select_backend_for_build() -> BackendOptions:
    """Select backend for building executables (use AOT)."""
    BackendOptions__aot("output.o")

fn select_backend_for_test() -> BackendOptions:
    """Select backend for running tests (use JIT with coverage)."""
    BackendOptions__jit().with_coverage(true)

# ============================================================================
# Exports
# ============================================================================

export BackendMode, TargetArch, BackendOptions
export BackendSelector
export select_backend_auto, select_backend_for_script
export select_backend_for_build, select_backend_for_test
