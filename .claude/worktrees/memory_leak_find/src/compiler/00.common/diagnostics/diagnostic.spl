# Diagnostic Messages
#
# Core diagnostic type for compiler errors, warnings, and messages.

use severity.Severity
use span.Span
use label.Label

# A diagnostic message (error, warning, note, etc.)
struct Diagnostic:
    severity: Severity           # Diagnostic severity level
    code: text?                  # Error code (e.g., "E0001")
    message: text                # Primary message
    span: Span?                  # Primary source location
    labels: [Label]              # Additional labeled spans
    notes: [text]                # Additional notes
    help: text?                  # Help message

impl Diagnostic:
    # Create a new diagnostic with the given severity and message
    static fn new(severity: Severity, message: text) -> Diagnostic:
        Diagnostic(
            severity: severity,
            code: nil,
            message: message,
            span: nil,
            labels: [],
            notes: [],
            help: nil
        )

    # Create an error diagnostic
    static fn error(message: text) -> Diagnostic:
        Diagnostic.new(Severity.Error, message)

    # Create a warning diagnostic
    static fn warning(message: text) -> Diagnostic:
        Diagnostic.new(Severity.Warning, message)

    # Create a note diagnostic
    static fn note(message: text) -> Diagnostic:
        Diagnostic.new(Severity.Note, message)

    # Create a help diagnostic
    static fn help_msg(message: text) -> Diagnostic:
        Diagnostic.new(Severity.Help, message)

    # Create an info diagnostic
    static fn info(message: text) -> Diagnostic:
        Diagnostic.new(Severity.Info, message)

    # === Builder Methods ===

    # Set the error code (e.g., "E0001")
    fn with_code(code: text) -> Diagnostic:
        var result = self
        result.code = Some(code)
        result

    # Set the primary span
    fn with_span(span: Span) -> Diagnostic:
        var result = self
        result.span = Some(span)
        result

    # Add a labeled span
    fn with_label(span: Span, message: text) -> Diagnostic:
        var result = self
        result.labels.push(Label.new(span, message))
        result

    # Add a note
    fn with_note(note: text) -> Diagnostic:
        var result = self
        result.notes.push(note)
        result

    # Set the help message
    fn with_help(help: text) -> Diagnostic:
        var result = self
        result.help = Some(help)
        result

    # === Accessor Methods ===

    # Get the severity
    fn severity() -> Severity:
        self.severity

    # Get the message
    fn message() -> text:
        self.message

    # Get the code (if any)
    fn code() -> text?:
        self.code

    # Get the primary span (if any)
    fn span() -> Span?:
        self.span

    # Get all labels
    fn labels() -> [Label]:
        self.labels

    # Get all notes
    fn notes() -> [text]:
        self.notes

    # Get help message (if any)
    fn help() -> text?:
        self.help

    # Check if this is an error
    fn is_error() -> bool:
        self.severity.is_error()

    # Check if this is a warning
    fn is_warning() -> bool:
        self.severity.is_warning()

    # === Display Methods ===

    # Format as a simple string (severity: message)
    fn to_string() -> text:
        val severity_str = self.severity.to_string()
        if self.code.?:
            "{severity_str}[{self.code.unwrap()}]: {self.message}"
        else:
            "{severity_str}: {self.message}"

    # Format with span information
    fn to_string_with_span() -> text:
        if self.span.?:
            val span = self.span.unwrap()
            "{span.to_string()}: {self.to_string()}"
        else:
            self.to_string()

    # Count total items (for reporting)
    fn item_count() -> i64:
        var count = 1  # The diagnostic itself
        count = count + self.labels.len()
        count = count + self.notes.len()
        if self.help.?: count = count + 1
        count

# Public exports
export Diagnostic
