# Dependency Injection Container
#
# DI container with profile-based bindings for compiler services.
# Profiles: dev, test, prod, sdn â€” each binds different implementations.
#
# System Test Lock:
#   During system tests (SIMPLE_SYSTEM_TEST=1), DI modifications are blocked
#   to ensure tests run against production-default bindings.
#   Tests tagged with # @di_test bypass the lock (SIMPLE_DI_TEST=1).

use compiler.common.config (CompilerProfile)

extern fn rt_env_get(key: text) -> text

# Local panic function for DI errors
fn di_panic(msg: text):
    print "DI PANIC: {msg}"

fn di_warn(msg: text):
    print "DI WARN: {msg}"

# ============================================================================
# System Test Lock (env-var-based)
# ============================================================================

fn di_is_system_test_locked() -> bool:
    """Check if DI modifications are blocked by system test environment.

    Locked when SIMPLE_SYSTEM_TEST=1 AND SIMPLE_DI_TEST != 1.
    Set by test runner for test/system/ files.
    Tests with # @di_test tag set SIMPLE_DI_TEST=1 to bypass.
    """
    val sys_test = rt_env_get("SIMPLE_SYSTEM_TEST") ?? ""
    if sys_test != "1":
        return false
    val di_test = rt_env_get("SIMPLE_DI_TEST") ?? ""
    di_test != "1"

# ============================================================================
# Binding
# ============================================================================

struct Binding:
    """A named binding: factory + optional profile restriction."""
    factory: fn() -> Any
    profile: CompilerProfile?    # nil = all profiles
    tags: [text]

# ============================================================================
# DiContainer
# ============================================================================

class DiContainer:
    """Dependency injection container with profile-based bindings.

    Usage:
        val di = DiContainer(bindings: {}, singletons: {}, profile: "dev", all_bindings: [])
        di.bind("Backend", \: InterpreterBackendImpl.new())
        di.bind_for_profile("Backend", CompilerProfile.Prod, \: CompilerBackendImpl.jit())
        val backend = di.resolve("Backend")

    System Test Lock:
        When locked=true OR SIMPLE_SYSTEM_TEST=1 (without SIMPLE_DI_TEST=1),
        bind/bind_instance/bind_for_profile/bind_tagged are rejected.
        This prevents mock/stub injection during system tests.
        Use # @di_test tag in test file to bypass.
    """
    bindings: Dict<text, fn() -> Any>
    singletons: Dict<text, Any>
    profile: text
    all_bindings: [Binding]
    locked: bool

impl DiContainer:
    static fn for_profile(profile: CompilerProfile) -> DiContainer:
        """Create container configured for a specific profile."""
        DiContainer(
            bindings: {},
            singletons: {},
            profile: profile.to_text(),
            all_bindings: [],
            locked: false
        )

    fn is_locked() -> bool:
        """Check if container is locked (explicit lock OR env-var lock)."""
        if self.locked:
            return true
        di_is_system_test_locked()

    me lock():
        """Explicitly lock the container. Prevents all bind operations."""
        self.locked = true

    me unlock():
        """Explicitly unlock the container. Does NOT override env-var lock."""
        self.locked = false

    me bind(name: text, factory: fn() -> Any):
        """Bind a factory function to a name (all profiles).
        Rejected when container is locked (system test mode)."""
        if self.is_locked():
            di_warn("DI bind('{name}') rejected: container locked in system test mode. Add '# @di_test' tag to allow.")
            return
        var b = self.bindings
        b[name] = factory
        self.bindings = b
        self.all_bindings = self.all_bindings.push(Binding(
            factory: factory,
            profile: nil,
            tags: []
        ))

    me bind_for_profile(name: text, profile: CompilerProfile, factory: fn() -> Any):
        """Bind a factory that only activates for a specific profile.
        Rejected when container is locked (system test mode)."""
        if self.is_locked():
            di_warn("DI bind_for_profile('{name}') rejected: container locked in system test mode. Add '# @di_test' tag to allow.")
            return
        val binding = Binding(
            factory: factory,
            profile: Some(profile),
            tags: []
        )
        self.all_bindings = self.all_bindings.push(binding)
        # If current profile matches, register as active binding
        if profile.to_text() == self.profile:
            var b = self.bindings
            b[name] = factory
            self.bindings = b

    me bind_tagged(name: text, tags: [text], factory: fn() -> Any):
        """Bind with tags for filtered resolution.
        Rejected when container is locked (system test mode)."""
        if self.is_locked():
            di_warn("DI bind_tagged('{name}') rejected: container locked in system test mode. Add '# @di_test' tag to allow.")
            return
        var b = self.bindings
        b[name] = factory
        self.bindings = b
        self.all_bindings = self.all_bindings.push(Binding(
            factory: factory,
            profile: nil,
            tags: tags
        ))

    me bind_instance(name: text, instance: Any):
        """Bind an already-created instance directly (no closure needed).
        Rejected when container is locked (system test mode)."""
        if self.is_locked():
            di_warn("DI bind_instance('{name}') rejected: container locked in system test mode. Add '# @di_test' tag to allow.")
            return
        var s = self.singletons
        s[name] = instance
        self.singletons = s

    fn resolve(name: text) -> Any:
        """Resolve a binding by name. Singletons checked first."""
        if self.singletons.contains(name):
            return self.singletons[name]
        if self.bindings.contains(name):
            val instance = self.bindings[name]()
            return instance
        di_panic("No binding found for: {name}")
        nil

    fn resolve_or(name: text, default: Any) -> Any:
        """Resolve a binding, returning default if not found."""
        if self.singletons.contains(name):
            return self.singletons[name]
        if self.bindings.contains(name):
            return self.bindings[name]()
        default

    fn has(name: text) -> bool:
        """Check if a binding exists."""
        self.singletons.contains(name) or self.bindings.contains(name)

    me resolve_singleton(name: text) -> Any:
        """Resolve and cache as singleton for future calls."""
        if self.singletons.contains(name):
            return self.singletons[name]
        if self.bindings.contains(name):
            val instance = self.bindings[name]()
            var s = self.singletons
            s[name] = instance
            self.singletons = s
            return instance
        di_panic("No binding found for: {name}")
        nil

# ============================================================================
# Global container access
# ============================================================================

var _global_container: DiContainer? = nil

fn set_container(container: DiContainer):
    """Set the global DI container."""
    _global_container = Some(container)

fn get_container() -> DiContainer:
    """Get the global DI container (creates default if not set)."""
    if _global_container.?:
        return _global_container.unwrap()
    val default_container = DiContainer.for_profile(CompilerProfile.Dev)
    _global_container = Some(default_container)
    default_container

export DiContainer, Binding, di_is_system_test_locked
export set_container, get_container
