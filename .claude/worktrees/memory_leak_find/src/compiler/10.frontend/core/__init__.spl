# Core Simple Language Module
# @tag:api
#
# Provides fundamental language types, parsing, and AOP infrastructure.
# This is the foundation for the Simple compiler and runtime.
#
# Public API:
#   - AST types and parsing (ast, parser, lexer, tokens)
#   - Type system (types)
#   - AOP infrastructure (aop, aop_debug_log)
#   - Error handling (error)
#   - Backend types (hir_types, mir_types, backend_types)
#
# Internal Implementation:
#   - Compiler (moved to compiler for full version)
#   - Interpreter (REPL/runtime execution)
#   - HIR/MIR (intermediate representations)
#   - WFFI (wrapper FFI utilities)
#
# Example: Parsing Simple source code
#
#     use compiler.core.parser.{parse_module}
#     use compiler.core.lexer.{create_lexer, lex_all}
#
#     val source = """
#     fn add(x: i64, y: i64) -> i64:
#         x + y
#     """
#
#     # Tokenize source
#     val lexer = create_lexer(source)
#     val tokens = lex_all(lexer)
#
#     # Parse into AST
#     val module = parse_module(tokens)
#     print "Parsed {module.declarations.len()} declarations"
#
# Example: Working with AST nodes
#
#     use compiler.core.ast.{Expr, Stmt, Declaration}
#     use compiler.core.ast_types.{ExprKind, StmtKind}
#
#     # Create AST nodes programmatically
#     val int_literal = Expr(kind: ExprKind.IntLiteral(42))
#     val var_ref = Expr(kind: ExprKind.Identifier("x"))
#     val binary = Expr(
#         kind: ExprKind.Binary("+", int_literal, var_ref)
#     )
#
# Example: Using the type system
#
#     use compiler.core.types.{Type, TypeKind, TypeContext}
#
#     # Create type context for type checking
#     val ctx = TypeContext.new()
#
#     # Register type alias
#     ctx.add_alias("UserId", Type(kind: TypeKind.I64))
#
#     # Create function type: (i64, text) -> bool
#     val fn_type = Type(
#         kind: TypeKind.Function(
#             params: [
#                 Type(kind: TypeKind.I64),
#                 Type(kind: TypeKind.Text)
#             ],
#             return_type: Type(kind: TypeKind.Bool)
#         )
#     )
#
# Example: Aspect-Oriented Programming (AOP)
#
#     use compiler.core.aop.{Aspect, Pointcut, Advice}
#     use compiler.core.aop_debug_log.{log_function_entry, log_function_exit}
#
#     # Create aspect for logging all function calls
#     val logging_aspect = Aspect(
#         pointcut: Pointcut.FunctionCall("*"),  # Match all functions
#         before: log_function_entry,
#         after: log_function_exit
#     )
#
#     # Apply aspect to program
#     apply_aspect(program, logging_aspect)
#
# Example: Error handling with source locations
#
#     use compiler.core.error.{CompilerError, ErrorKind, SourceLocation}
#
#     # Create error with source location
#     val error = CompilerError(
#         kind: ErrorKind.TypeError,
#         message: "Expected i64, found text",
#         location: SourceLocation(
#             file: "src/main.spl",
#             line: 42,
#             column: 15
#         )
#     )
#
#     # Format error for display
#     print error.format()
#     # Output:
#     # src/main.spl:42:15: error: Expected i64, found text

# ============================================================================
# Public Modules
# ============================================================================

# Core language types
pub mod ast
pub mod ast_expr
pub mod ast_stmt
pub mod ast_types
pub mod tokens
pub mod types
pub mod error

# Parsing and lexing
pub mod lexer
pub mod lexer_struct
pub mod lexer_types
pub mod parser
pub mod frontend

# Aspect-Oriented Programming
pub mod aop
pub mod aop_debug_log

# Backend types (shared with compiler)
pub mod backend_types
pub mod hir_types
pub mod mir_types

# ============================================================================
# Internal Modules (Implementation Details)
# ============================================================================

mod compiler      # Basic compiler (full version in compiler)
mod interpreter   # Interpreter/REPL runtime
mod hir           # High-Level IR
mod mir           # Mid-Level IR
mod wffi          # Wrapper FFI utilities

# Note: AOP types and functions are available via core.aop.* and core.aop_debug_log.*
# AST, tokens, types, lexer, parser modules export their own types
# Import them directly: use compiler.core.ast.*, use compiler.core.tokens.*, etc.
