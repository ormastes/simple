# Module Path Resolution Logic
#
# This module handles resolving module paths to filesystem locations,
# including support for both absolute (crate.*) and relative paths.
#
# Port of: rust/compiler/src/module_resolver/resolution.rs (309 lines)

export resolve
export resolve_from_base
export get_exports
export get_common_uses
export find_numbered_dir

use parser.ast (ModulePath, ImportTarget, Visibility, Node)
use parser (Parser)
use compiler.module_resolver.types (
    ModuleResolver, ResolvedModule, DirectoryManifest
)
use compiler.common.error (CompileError, ErrorCode)

# ============================================================================
# Module Resolution
# ============================================================================

impl ModuleResolver:
    fn resolve(path: ModulePath, from_file: text) -> ResolvedModule | CompileError:
        """Resolve a module path to a filesystem path.

        Arguments:
        - path: The module path to resolve (e.g., crate.sys.http.router)
        - from_file: The file making the import (for relative resolution)

        Returns:
        - ResolvedModule: The resolved module information including filesystem path
        - CompileError: If the module cannot be found

        ROBUSTNESS:
        - Validates non-empty path
        - Tries absolute (crate.*) then relative resolution
        - Falls back to stdlib if relative fails
        """
        val segments = path.segments

        if segments.is_empty():
            return CompileError.semantic(
                "empty module path",
                ErrorCode.MODULE_NOT_FOUND,
                "provide at least one module path segment"
            )

        # Determine base directory
        val (base_dir, remaining) = if segments[0] == "crate":
            # Absolute path from project root
            (self.source_root.clone(), segments[1..])
        else:
            # Relative path from current file's directory
            val parent = path_parent(from_file)
            (parent, segments)

        # Try resolving from the base directory first
        match self.resolve_from_base(base_dir, remaining, path):
            Ok(resolved):
                return Ok(resolved)
            Err(err):
                # If relative resolution failed and stdlib is available, try stdlib
                if segments[0] != "crate":
                    if val Some(stdlib_root) = self.stdlib_root:
                        # If path starts with "std_lib", strip that prefix
                        val stdlib_segments = if segments.len() > 0 and segments[0] == "std_lib":
                            segments[1..]
                        else:
                            segments

                        if not stdlib_segments.is_empty():
                            match self.resolve_from_base(stdlib_root, stdlib_segments, path):
                                Ok(resolved):
                                    return Ok(resolved)
                                Err(_):
                                    # Stdlib resolution also failed, return original error
                                    pass

                # Rewrite std/lib → lib (std is a package alias, real code is in lib/)
                val is_std_or_lib = segments[0] == "std" or segments[0] == "lib"
                if is_std_or_lib:
                    val inner_segments = segments[1..]
                    # Try direct lib/ path first
                    var lib_segments = ["lib"]
                    lib_segments.extend(inner_segments)
                    match self.resolve_from_base(self.source_root.clone(), lib_segments, path):
                        Ok(resolved):
                            return Ok(resolved)
                        Err(_):
                            pass
                    # Try lib/*/ subdirectory search
                    val lib_dir = path_join(self.source_root.clone(), "lib")
                    if rt_dir_exists(lib_dir):
                        val subdirs = rt_dir_list(lib_dir)
                        for subdir in subdirs:
                            var sub_segments = ["lib", subdir]
                            sub_segments.extend(inner_segments)
                            match self.resolve_from_base(self.source_root.clone(), sub_segments, path):
                                Ok(resolved):
                                    return Ok(resolved)
                                Err(_):
                                    pass

                return Err(err)

    fn resolve_from_base(
        base: text,
        segments: [text],
        original_path: ModulePath
    ) -> ResolvedModule | CompileError:
        """Resolve from a base directory with remaining path segments.

        ROBUSTNESS:
        - Validates non-empty segments
        - Checks for __init__.spl in each directory
        - Tries multiple file extensions (.spl, .ssh)
        - Returns detailed error messages
        """
        if segments.is_empty():
            return CompileError.semantic(
                "empty module path segments",
                ErrorCode.MODULE_NOT_FOUND,
                "module path must contain at least one segment"
            )

        var current = base.clone()

        # Navigate through all but the last segment
        for segment in segments[0..segments.len()-1]:
            val direct = path_join(current, segment)

            # Check direct path first
            if path_exists(direct):
                current = direct
                # Check for __init__.spl in each directory
                val init_path = path_join(current, "__init__.spl")
                if file_exists(init_path) and is_file(init_path):
                    # Directory module - continue navigation
                    pass
            else:
                # Try numbered directory fallback (NN.segment pattern)
                val numbered = find_numbered_dir(current, segment)
                if numbered.?:
                    current = numbered ?? current
                else:
                    # E1034 - Unresolved Import
                    return CompileError.semantic(
                        "cannot resolve import: module path segment `{segment}` not found",
                        ErrorCode.UNRESOLVED_IMPORT,
                        "check that the module exists at {direct}"
                    ).with_note("ensure the module file or __init__.spl exists")

        # Resolve the last segment
        val last = segments[segments.len() - 1]

        # Try directory with __init__.spl first
        val dir_path = path_join(current, last)
        val init_path = path_join(dir_path, "__init__.spl")
        if file_exists(init_path) and is_file(init_path):
            return Ok(ResolvedModule.directory(
                init_path,
                original_path.clone(),
                nil  # Will be loaded on demand
            ))

        # Try .spl file
        val file_path = path_join(current, "{last}.spl")
        if file_exists(file_path) and is_file(file_path):
            return Ok(ResolvedModule.file(file_path, original_path.clone()))

        # Try .ssh file (Simple shell scripts)
        val ssh_path = path_join(current, "{last}.ssh")
        if file_exists(ssh_path) and is_file(ssh_path):
            return Ok(ResolvedModule.file(ssh_path, original_path.clone()))

        # Try numbered directory fallback for the last segment
        val numbered_dir = find_numbered_dir(current, last)
        if numbered_dir.?:
            val nd = numbered_dir ?? ""
            val nd_init = path_join(nd, "__init__.spl")
            if file_exists(nd_init) and is_file(nd_init):
                return Ok(ResolvedModule.directory(
                    nd_init,
                    original_path.clone(),
                    nil
                ))

        # Try numbered directory + .spl file fallback
        val numbered_parent = find_numbered_dir(current, last)
        if numbered_parent.? == false:
            # Also check if the last segment is a file inside a numbered dir
            # e.g., compiler.frontend.parser_types → 10.frontend/parser_types.spl
            pass

        # E1034 - Unresolved Import
        CompileError.semantic(
            "cannot resolve import: module `{last}` not found",
            ErrorCode.UNRESOLVED_IMPORT,
            "create either {file_path} or {init_path}"
        ).with_note("check for typos in the import path")

    fn get_exports(resolved: ResolvedModule) -> [text] | CompileError:
        """Get all symbols exported by a module.

        Returns:
        - List of exported symbol names
        - Empty list if no manifest or non-directory module

        ROBUSTNESS:
        - Handles all ImportTarget variants (Single, Aliased, Group, Glob)
        - Returns public child modules
        - For non-directory modules, parses file and extracts export statements
        """
        if val Some(manifest) = resolved.manifest:
            var exports: [text] = []

            # Add re-exported symbols
            for exported_item in manifest.exports:
                match exported_item.target:
                    ImportTarget.Single(name):
                        exports.push(name)

                    ImportTarget.Aliased(name, alias):
                        exports.push(alias)

                    ImportTarget.Group(targets):
                        for target in targets:
                            match target:
                                ImportTarget.Single(name):
                                    exports.push(name)
                                ImportTarget.Aliased(_, alias):
                                    exports.push(alias)
                                _:
                                    pass

                    ImportTarget.Glob:
                        # Glob exports - would need to resolve the target module
                        # For now, this is a placeholder
                        pass

            # Add public child modules
            for child in manifest.child_modules:
                if child.visibility == Visibility.Public:
                    exports.push(child.name)

            Ok(exports)
        else:
            # Non-directory module - parse file and extract export statements
            self.extract_file_exports(resolved.path)

    fn extract_file_exports(file_path: text) -> [text] | CompileError:
        """Extract exported symbols from a non-directory module (.spl file).

        Parses the file and extracts all symbols listed in export statements.

        Arguments:
        - file_path: Path to the .spl file

        Returns:
        - List of exported symbol names
        - CompileError if file cannot be read or parsed

        ROBUSTNESS:
        - Reads and parses the source file
        - Extracts all export declarations
        - Returns empty list if no exports found
        """
        # Read the file
        val source = match file_read(file_path):
            Some(content): content
            nil:
                return CompileError.io_error(
                    "cannot extract exports: failed to read file {file_path}",
                    ErrorCode.FILE_READ_ERROR
                ).with_note("ensure the file exists and is readable")

        # Parse the file
        var parser = Parser.new(source)
        val module = match parser.parse():
            Ok(m): m
            Err(err):
                return CompileError.parse_error(
                    "cannot extract exports from {file_path}: parse error",
                    ErrorCode.PARSE_ERROR
                ).with_note("parser error: {err.message}")
                 .with_note("file must be valid Simple syntax to extract exports")

        # Extract export statements
        var exports: [text] = []
        for item in module.items:
            match item:
                Node.ExportDecl(names):
                    # Export statement lists symbols to export
                    exports.extend(names)

                Node.FnDecl(decl):
                    # Public function declarations are implicitly exported
                    if decl.visibility == Visibility.Public:
                        exports.push(decl.name)

                Node.StructDecl(decl):
                    # Public struct declarations are implicitly exported
                    if decl.visibility == Visibility.Public:
                        exports.push(decl.name)

                Node.EnumDecl(decl):
                    # Public enum declarations are implicitly exported
                    if decl.visibility == Visibility.Public:
                        exports.push(decl.name)

                Node.ClassDecl(decl):
                    # Public class declarations are implicitly exported
                    if decl.visibility == Visibility.Public:
                        exports.push(decl.name)

                _:
                    # Other nodes don't contribute to exports
                    pass

        Ok(exports)

    fn get_common_uses(file_path: text) -> [CommonUseStmt]:
        """Get common use imports that apply to a file.

        Walks up the directory tree collecting common uses from __init__.spl files.

        ROBUSTNESS:
        - Walks up to source_root
        - Collects from all parent directories
        - Returns empty list if no manifests found
        """
        var uses: [CommonUseStmt] = []

        # Walk up the directory tree collecting common uses
        var current = Some(path_parent(file_path))
        while val Some(dir) = current:
            val init_path = path_join(dir, "__init__.spl")
            if val Some(manifest) = self.manifests.get(init_path):
                uses.extend(manifest.common_uses.clone())

            if dir == self.source_root:
                break

            current = Some(path_parent(dir))

        uses

# ============================================================================
# Helper Functions (FFI Wrappers)
# ============================================================================

extern fn rt_path_join(a: text, b: text) -> text
extern fn rt_path_parent(path: text) -> text
extern fn rt_file_exists(path: text) -> bool
extern fn rt_dir_exists(path: text) -> bool

fn path_join(base: text, segment: text) -> text:
    """Join two path segments."""
    rt_path_join(base, segment)

fn path_parent(path: text) -> text:
    """Get parent directory of a path."""
    rt_path_parent(path)

fn path_exists(path: text) -> bool:
    """Check if a path exists."""
    rt_file_exists(path) or rt_dir_exists(path)

fn is_file(path: text) -> bool:
    """Check if a path is a file (not directory)."""
    rt_file_exists(path) and not rt_dir_exists(path)

extern fn rt_dir_list(path: text) -> [text]

fn find_numbered_dir(parent: text, segment: text) -> text?:
    """Find a numbered directory matching a segment name.

    Scans the parent directory for entries matching the pattern NN.name
    where NN is a 1-3 digit numeric prefix and name matches the segment.
    Returns the full path if found, nil otherwise.

    Example: find_numbered_dir("/src/compiler", "frontend")
             finds "/src/compiler/10.frontend" and returns that path.
    """
    if not rt_dir_exists(parent):
        return nil

    val entries = rt_dir_list(parent)
    for entry in entries:
        val dot_idx = entry.index_of(".")
        if dot_idx.?:
            val idx = dot_idx ?? 0
            if idx >= 1 and idx <= 3:
                val prefix = entry.substring(0, idx)
                # Verify prefix is all digits
                var all_digits = true
                for ch in prefix:
                    if ch < "0" or ch > "9":
                        all_digits = false
                if all_digits:
                    val name = entry.substring(idx + 1)
                    if name == segment:
                        val full_path = path_join(parent, entry)
                        if rt_dir_exists(full_path):
                            return Some(full_path)
    nil

# ============================================================================
# Usage Examples
# ============================================================================
#
# # Create a resolver
# val resolver = ModuleResolver.new("/home/user/myproject", "/home/user/myproject/src")
#
# # Resolve an absolute path
# val result = resolver.resolve(
#     ModulePath(segments: ["crate", "sys", "http"]),
#     "/home/user/myproject/src/main.spl"
# )
#
# match result:
#     Ok(resolved):
#         print "Resolved to: {resolved.path}"
#         print "Is directory: {resolved.is_directory}"
#
#     Err(error):
#         print "Error: {error.message}"
#
# # Resolve a relative path
# val result = resolver.resolve(
#     ModulePath(segments: ["utils", "strings"]),
#     "/home/user/myproject/src/main.spl"
# )
#
# # Get exports from a module
# if val Ok(resolved) = result:
#     if val Ok(exports) = resolver.get_exports(resolved):
#         print "Exports: {exports.join(', ')}"
#
# # Get common uses for a file
# val common_uses = resolver.get_common_uses("/home/user/myproject/src/sys/http.spl")
# print "Common uses: {common_uses.len()}"
#
# ============================================================================
# Resolution Algorithm
# ============================================================================
#
# 1. Parse module path into segments
#    Example: crate.sys.http -> ["crate", "sys", "http"]
#
# 2. Determine base directory:
#    - If starts with "crate": use source_root
#    - Otherwise: use parent directory of from_file
#
# 3. Navigate through all but last segment:
#    - Join segment to current path
#    - Check for __init__.spl (directory module)
#    - If directory doesn't exist, return error
#
# 4. Resolve last segment (try in order):
#    a. Directory with __init__.spl
#    b. .spl file
#    c. .ssh file
#    d. Error if none found
#
# 5. If relative resolution fails:
#    - Try stdlib (if available)
#    - Strip "std_lib" prefix if present
#    - Resolve from stdlib_root
#
# 6. Return ResolvedModule with:
#    - Filesystem path
#    - Original module path
#    - Is directory flag
#    - Manifest (loaded on demand)
#
# ============================================================================
# Error Codes
# ============================================================================
#
# E1034 - Unresolved Import
#   - Module path segment not found
#   - Module file not found
#   - Includes filesystem path in error message
#
# MODULE_NOT_FOUND
#   - Empty module path
#   - No segments provided
#
# ============================================================================
# Performance Notes
# ============================================================================
#
# - resolve: O(n) where n = number of segments (filesystem lookups)
# - resolve_from_base: O(n) directory navigation + O(1) file checks
# - get_exports: O(m) where m = number of exports
# - get_common_uses: O(d) where d = directory depth
#
# Expected performance: Same as Rust (I/O bound, not CPU bound)
#
# Filesystem operations are the bottleneck:
# - file_exists: ~0.1-1ms per call (OS cache helps)
# - Multiple extension checks: ~0.3-3ms total
#
# ============================================================================
# Robustness Checklist
# ============================================================================
#
# Input Validation:
# - [x] Non-empty path segments
# - [x] Non-empty module path
# - [x] Valid filesystem paths
#
# Error Handling:
# - [x] Directory not found (E1034)
# - [x] Module not found (E1034)
# - [x] Empty path (MODULE_NOT_FOUND)
# - [x] Detailed error messages with filesystem paths
#
# Resolution Logic:
# - [x] Absolute paths (crate.*)
# - [x] Relative paths (from current file)
# - [x] Stdlib fallback
# - [x] Multiple file extensions (.spl, .ssh)
# - [x] Directory modules (__init__.spl)
#
# Export Extraction:
# - [x] Single exports
# - [x] Aliased exports
# - [x] Group exports
# - [x] Glob exports (placeholder)
# - [x] Public child modules
#
# Edge Cases:
# - [x] Empty exports (returns empty list)
# - [x] Non-directory module (returns empty exports)
# - [x] No common uses (returns empty list)
# - [x] Stdlib not found (fallback fails gracefully)
#
# Remaining work:
# - [x] Implement proper file I/O FFI (path_exists, is_file, is_directory)
# - [ ] Add glob export resolution (requires parsing target module)
# - [ ] Add import graph tracking (cycle detection)
# - [ ] Add manifest caching in resolve_from_base
#
