# Construct Capsule: expr
#
# Groups all compiler files that handle expressions.
# Tier: core (alongside variable — both are foundational)
# Dimension: construct (vertical second axis)
# Participation: shared_bind

use compiler.mdsoc.types.*

export expr_capsule_def

fn expr_capsule_def() -> ConstructCapsule:
    """Define the expr construct capsule.

    Expressions are core (same tier as variable). They underlie all
    other constructs — function calls, field access, literals, etc.
    """
    var cap = ConstructCapsule.new("expr", ConstructKind.Expr, ConstructTier.Core)

    cap.exclusive_files = [
        "10.frontend/core/parser_expr.spl"
    ]

    # Shared files
    val sb_ast = SharedBinding.new("10.frontend/core/ast.spl", "func", 10)
    val sb_hir = SharedBinding.new("20.hir/hir_definitions.spl", "func", 20)
    val sb_mir_lower = SharedBinding.new("50.mir/mir_lowering_expr.spl", "expr", 50)
    val sb_mir = SharedBinding.new("50.mir/mir_instructions.spl", "expr", 50)
    val sb_type_infer = SharedBinding.new("30.types/type_infer/inference_control.spl", "expr", 30)
    val sb_interpreter = SharedBinding.new("70.backend/backend/interpreter.spl", "func", 70)
    val sb_c_ir = SharedBinding.new("70.backend/backend/c_ir_builder.spl", "expr", 70)

    cap.shared_bindings = [sb_ast, sb_hir, sb_mir_lower, sb_mir, sb_type_infer, sb_interpreter, sb_c_ir]

    # Core tier — no construct dependencies
    cap.depends_on = []

    cap
