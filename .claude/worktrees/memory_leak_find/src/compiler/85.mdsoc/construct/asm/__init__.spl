# Construct Capsule: asm
#
# Groups all compiler files that handle inline assembly and native code.
# Tier: advanced (depends on expr, variable)
# Dimension: construct (vertical second axis)
# Participation: shared_bind

use compiler.mdsoc.types.*

export asm_capsule_def

fn asm_capsule_def() -> ConstructCapsule:
    """Define the asm construct capsule.

    Assembly handling is concentrated in the backend layer:
    - Native backend: ELF writer, encoding passes (exclusive)
    - Backend helpers shared with other constructs
    """
    var cap = ConstructCapsule.new("asm", ConstructKind.Asm, ConstructTier.Advanced)

    # Exclusive files — assembly and native code generation
    cap.exclusive_files = [
        "70.backend/backend/native/elf_writer.spl",
        "70.backend/backend/native/elf_writer_serialize.spl"
    ]

    # Shared files — backend infrastructure used by all constructs
    val sb_c_backend = SharedBinding.new("70.backend/backend/c_backend.spl", "func", 70)
    val sb_c_ir = SharedBinding.new("70.backend/backend/c_ir_builder.spl", "expr", 70)
    val sb_mir = SharedBinding.new("50.mir/mir_instructions.spl", "expr", 50)
    val sb_interpreter = SharedBinding.new("70.backend/backend/interpreter.spl", "expr", 70)
    val sb_bitfield = SharedBinding.new("70.backend/bitfield.spl", "asm", 70)

    cap.shared_bindings = [sb_c_backend, sb_c_ir, sb_mir, sb_interpreter, sb_bitfield]

    # Depends on expr (asm operands are expressions), variable (registers/memory)
    cap.depends_on = ["expr", "variable"]

    cap
