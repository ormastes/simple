# Expression Type Inference
#
# Core expression inference using Algorithm W and bidirectional type checking:
# - Bidirectional type checking (synthesize vs check modes)
# - Expression inference (literals, variables, functions, operators)
# - Collection inference (arrays, tuples, dicts, sets)
# - Function calls and method calls with bidirectional lambda checking
# - Field access and indexing
# - If/match/range/closure inference
# - Binary/unary operator inference
#
# Part of the type_infer/inference split. See inference.spl for module overview.

use compiler.hir.hir.*
use compiler.core.lexer.*
use compiler.types.dim_constraints.*
use compiler.traits.traits.*
use type_infer_types.*

impl HmInferContext:
    # =========================================================================
    # Bidirectional Type Checking
    # =========================================================================
    #
    # Bidirectional type checking combines two modes:
    # - Synthesize: Infer type from expression structure (bottom-up)
    # - Check: Validate expression against expected type (top-down)
    #
    # The key advantage is propagating type information into lambdas:
    #   val f: fn(i64) -> i64 = \x: x + 1   # x inferred as i64
    #
    # Reference: "Complete and Easy Bidirectional Typechecking for Higher-Rank Polymorphism"
    #            by Joshua Dunfield and Neelakantan R. Krishnaswami

    me synthesize_expr(expr: HirExpr) -> Result<HirType, TypeInferError>:
        """Synthesize (infer) the type of an expression.

        Bottom-up type inference: determines type from expression structure.
        Used when no expected type is available.

        Examples:
            synthesize(42)         => i64
            synthesize(true)       => bool
            synthesize(\x: x + 1)  => fn(Infer) -> Infer  (params not known)
        """
        self.infer_expr(expr)

    me check_expr(expr: HirExpr, expected: HirType) -> Result<(), TypeInferError>:
        """Check that an expression has the expected type.

        Top-down type checking: propagates expected type into expression.
        This enables better inference for lambdas and other constructs.

        Examples:
            check(\x: x + 1, fn(i64) -> i64) => Ok (x inferred as i64)
            check(42, text)                  => Err (type mismatch)
        """
        val span = expr.span

        # Special case: Lambda with expected function type
        # Propagate parameter types from expected into lambda
        match expr.kind:
            case Closure(params, body, captures):
                match expected.kind:
                    case Function(param_types, return_type, effects):
                        # Check arity matches
                        if params.len() != param_types.len():
                            return Err(TypeInferError.Mismatch(
                                expected: expected,
                                found: HirType(kind: HirTypeKind.Function([], HirType(kind: HirTypeKind.Unit, span: span), []), span: span),
                                span: span
                            ))

                        # Enter new level for lambda scope
                        self.enter_level()

                        # Bind parameters with expected types
                        var i = 0
                        while i < params.len():
                            val param = params[i]
                            val expected_param_ty = param_types[i]

                            # Use expected type, or fresh var if expected is Infer
                            val param_ty = match expected_param_ty.kind:
                                case Infer(_, _): self.fresh_var(param.span)
                                case _: expected_param_ty

                            self.bind_mono(param.name, param_ty)
                            i = i + 1

                        # Check body against expected return type
                        match self.check_expr(body, return_type):
                            case Ok(_):
                                self.exit_level()
                                Ok(())
                            case Err(e):
                                self.exit_level()
                                Err(e)

                    case _:
                        # Expected is not a function type, fall back to synthesize
                        match self.synthesize_expr(expr):
                            case Ok(inferred):
                                self.unify(inferred, expected).map(\x: ())
                            case Err(e): Err(e)

            # For all other expressions, synthesize and unify
            case _:
                match self.synthesize_expr(expr):
                    case Ok(inferred):
                        self.unify(inferred, expected).map(\x: ())
                    case Err(e): Err(e)

    me infer_expr_bidir(expr: HirExpr, mode: InferMode) -> Result<HirType, TypeInferError>:
        """Infer expression type using bidirectional type checking.

        Dispatches to check_expr or synthesize_expr based on mode.
        Returns the resulting type in both cases.

        Args:
            expr: Expression to type check
            mode: Synthesize or Check(expected_type)

        Returns:
            The type of the expression
        """
        match mode:
            case InferMode.Synthesize:
                self.synthesize_expr(expr)

            case InferMode.Check(expected):
                match self.check_expr(expr, expected):
                    case Ok(_):
                        # Return the expected type after successful check
                        Ok(expected)
                    case Err(e): Err(e)

    me check_subsumes(inferred: HirType, expected: HirType) -> Result<(), TypeInferError>:
        """Check that inferred type subsumes (is at least as general as) expected type.

        Used in bidirectional type checking for subtyping relationships.
        For now, this is equivalent to unification. Can be extended for
        subtyping with variance.
        """
        self.unify(inferred, expected).map(\x: ())

    # =========================================================================
    # Type Inference (Algorithm W)
    # =========================================================================

    me infer_expr(expr: HirExpr) -> Result<HirType, TypeInferError>:
        """Infer the type of an expression using Algorithm W."""
        val span = expr.span

        match expr.kind:
            # Literals
            case IntLit(_, suffix):
                val bits = if suffix.?:
                    match suffix.unwrap():
                        case "i8": 8
                        case "i16": 16
                        case "i32": 32
                        case "u8": 8
                        case "u16": 16
                        case "u32": 32
                        case "u64": 64
                        case _: 64
                else: 64
                var signed = true
                if suffix.?:
                    if suffix.unwrap().starts_with("u"):
                        signed = false
                Ok(HirType(kind: HirTypeKind.Int(bits, signed), span: span))

            case FloatLit(_, suffix):
                var bits = 64
                if suffix.?:
                    if suffix.unwrap() == "f32":
                        bits = 32
                Ok(HirType(kind: HirTypeKind.Float(bits), span: span))

            case StringLit(_, _):
                Ok(HirType(kind: HirTypeKind.Str, span: span))

            case BoolLit(_):
                Ok(HirType(kind: HirTypeKind.Bool, span: span))

            case CharLit(_):
                Ok(HirType(kind: HirTypeKind.Char, span: span))

            case Unit:
                Ok(HirType(kind: HirTypeKind.Unit, span: span))

            # Variables - lookup and instantiate
            case Var(symbol):
                val name = symbol.id.to_text()  # Get symbol name from ID
                self.lookup(name, span)

            # Array literals
            case ArrayLit(elements, _):
                if elements.is_empty():
                    val elem_ty = self.fresh_var(span)
                    Ok(HirType(kind: HirTypeKind.Array(elem_ty, nil), span: span))
                else:
                    match self.infer_expr(elements[0]):
                        case Ok(elem_ty):
                            var i = 1
                            while i < elements.len():
                                match self.infer_expr(elements[i]):
                                    case Ok(item_ty):
                                        match self.unify(elem_ty, item_ty):
                                            case Err(e): return Err(e)
                                            case _: pass
                                    case Err(e): return Err(e)
                                i = i + 1
                            Ok(HirType(kind: HirTypeKind.Array(self.resolve(elem_ty), nil), span: span))
                        case Err(e): Err(e)

            # Tuple literals
            case TupleLit(elements):
                var types: [HirType] = []
                for e in elements:
                    match self.infer_expr(e):
                        case Ok(ty): types = types.push(ty)
                        case Err(e): return Err(e)
                Ok(HirType(kind: HirTypeKind.Tuple(types), span: span))

            # Dict literals
            case DictLit(entries, _, _):
                if entries.is_empty():
                    val key_ty = self.fresh_var(span)
                    val val_ty = self.fresh_var(span)
                    Ok(HirType(kind: HirTypeKind.Dict(key_ty, val_ty), span: span))
                else:
                    val (k, v) = entries[0]
                    match self.infer_expr(k):
                        case Ok(key_ty):
                            match self.infer_expr(v):
                                case Ok(val_ty):
                                    var i = 1
                                    while i < entries.len():
                                        val (ki, vi) = entries[i]
                                        match self.infer_expr(ki):
                                            case Ok(kt):
                                                match self.unify(key_ty, kt):
                                                    case Err(e): return Err(e)
                                                    case _: pass
                                            case Err(e): return Err(e)
                                        match self.infer_expr(vi):
                                            case Ok(vt):
                                                match self.unify(val_ty, vt):
                                                    case Err(e): return Err(e)
                                                    case _: pass
                                            case Err(e): return Err(e)
                                        i = i + 1
                                    Ok(HirType(
                                        kind: HirTypeKind.Dict(self.resolve(key_ty), self.resolve(val_ty)),
                                        span: span
                                    ))
                                case Err(e): Err(e)
                        case Err(e): Err(e)

            # Set literals
            case SetLit(elements, _):
                if elements.is_empty():
                    # Empty set: create fresh type variable for element type
                    val elem_ty = self.fresh_var(span)
                    Ok(HirType(kind: HirTypeKind.Named("Set", [elem_ty]), span: span))
                else:
                    # Non-empty: infer from first element, unify rest
                    match self.infer_expr(elements[0]):
                        case Ok(elem_ty):
                            var i = 1
                            while i < elements.len():
                                match self.infer_expr(elements[i]):
                                    case Ok(item_ty):
                                        match self.unify(elem_ty, item_ty):
                                            case Err(e): return Err(e)
                                            case _: pass
                                    case Err(e): return Err(e)
                                i = i + 1
                            Ok(HirType(
                                kind: HirTypeKind.Named("Set", [self.resolve(elem_ty)]),
                                span: span
                            ))
                        case Err(e): Err(e)

            # Binary operations
            case Binary(op, left, right):
                match self.infer_expr(left):
                    case Ok(left_ty):
                        match self.infer_expr(right):
                            case Ok(right_ty):
                                self.infer_binary_op(op, left_ty, right_ty, span)
                            case Err(e): Err(e)
                    case Err(e): Err(e)

            # Unary operations
            case Unary(op, operand):
                match self.infer_expr(operand):
                    case Ok(operand_ty):
                        self.infer_unary_op(op, operand_ty, span)
                    case Err(e): Err(e)

            # Function calls (with bidirectional type checking for lambda arguments)
            case Call(callee, args, type_args):
                match self.infer_expr(callee):
                    case Ok(callee_ty):
                        # Resolve callee type to get expected parameter types
                        val resolved_callee = self.resolve(callee_ty)

                        # Try to extract parameter types for bidirectional checking
                        val expected_params = match resolved_callee.kind:
                            case Function(params, _, _): Some(params)
                            case _: nil

                        # Infer/check argument types with bidirectional mode
                        var arg_types: [HirType] = []
                        var i = 0
                        for arg in args:
                            # Use bidirectional checking if we know the expected param type
                            val arg_result = if expected_params.? and i < expected_params.unwrap().len():
                                val expected_param = expected_params.unwrap()[i]
                                # Use check mode for lambdas to propagate param types
                                match arg.value.kind:
                                    case Closure(_, _, _):
                                        match self.check_expr(arg.value, expected_param):
                                            case Ok(_): Ok(expected_param)
                                            case Err(e): Err(e)
                                    case _:
                                        # For non-lambdas, synthesize then unify
                                        match self.infer_expr(arg.value):
                                            case Ok(ty):
                                                match self.unify(ty, expected_param):
                                                    case Ok(_): Ok(self.resolve(ty))
                                                    case Err(e): Err(e)
                                            case Err(e): Err(e)
                            else:
                                # No expected type, just synthesize
                                self.infer_expr(arg.value)

                            match arg_result:
                                case Ok(ty): arg_types = arg_types.push(ty)
                                case Err(e): return Err(e)

                            i = i + 1

                        val ret_ty = self.fresh_var(span)
                        val expected_fn_ty = HirType(
                            kind: HirTypeKind.Function(arg_types, ret_ty, []),
                            span: span
                        )

                        match self.unify(callee_ty, expected_fn_ty):
                            case Err(e): Err(e)
                            case _:
                                # Generate trait obligations if callee is a function with bounds
                                # Extract function symbol from callee expression
                                match callee.kind:
                                    case Var(func_symbol):
                                        # Lower type_args from AST types to HIR types
                                        var hir_type_args: [HirType] = []
                                        # Lower type_args from call expression
                                        if call_type_args.?:
                                            for ta in call_type_args.unwrap():
                                                hir_type_args.push(ta)
                                        self.generate_obligations_for_function_call(func_symbol, hir_type_args, span)
                                    case _: pass  # Not a direct function call

                                Ok(self.resolve(ret_ty))
                    case Err(e): Err(e)

            # Method calls
            case MethodCall(receiver, method, args, _):
                match self.infer_expr(receiver):
                    case Ok(receiver_ty):
                        # Infer argument types
                        for arg in args:
                            match self.infer_expr(arg.value):
                                case Err(e): return Err(e)
                                case _: pass

                        # Generate trait obligation for method call
                        # This will be enhanced in Phase C (Method Resolution)
                        self.generate_obligation_for_method_call(receiver_ty, method, span)

                        # Method resolution requires more type information
                        # For now, return fresh var
                        Ok(self.fresh_var(span))
                    case Err(e): Err(e)

            # Field access
            case Field(base, _, _):
                match self.infer_expr(base):
                    case Ok(_):
                        # Field resolution requires struct/class type info
                        Ok(self.fresh_var(span))
                    case Err(e): Err(e)

            # Index
            case Index(base, index):
                match self.infer_expr(base):
                    case Ok(base_ty):
                        match self.infer_expr(index):
                            case Ok(idx_ty):
                                val resolved_base = self.resolve(base_ty)

                                # Check if this is a slice operation (index is a Range)
                                val is_slice = match index.kind:
                                    case Range(_, _, _, _): true
                                    case _: false

                                # BUG FIX: If base is still an inference variable and we're slicing,
                                # constrain it to be Str to prevent incorrect enum type unification
                                match resolved_base.kind:
                                    case Infer(_, _) if is_slice:
                                        # For slicing on unresolved type, assume Str
                                        val str_ty = HirType(kind: HirTypeKind.Str, span: span)
                                        match self.unify(resolved_base, str_ty):
                                            case Ok(_): return Ok(str_ty)
                                            case Err(e): return Err(e)
                                    case _: pass

                                match resolved_base.kind:
                                    case Array(elem, _):
                                        if is_slice:
                                            Ok(HirType(kind: HirTypeKind.Slice(elem), span: span))
                                        else:
                                            Ok(elem)
                                    case Slice(elem):
                                        if is_slice:
                                            Ok(HirType(kind: HirTypeKind.Slice(elem), span: span))
                                        else:
                                            Ok(elem)
                                    case Dict(_, value):
                                        Ok(value)  # Dict doesn't support slicing
                                    case Str:
                                        if is_slice:
                                            Ok(HirType(kind: HirTypeKind.Str, span: span))
                                        else:
                                            Ok(HirType(kind: HirTypeKind.Char, span: span))
                                    case Named(sym_id, _):
                                        # BUG FIX: Handle Named types that might be text/string
                                        # If it's a Named type, try to resolve it further or default to Str for slicing
                                        if is_slice:
                                            Ok(HirType(kind: HirTypeKind.Str, span: span))
                                        else:
                                            # For single index, create fresh var (could be Dict-like)
                                            Ok(self.fresh_var(span))
                                    case _:
                                        Ok(self.fresh_var(span))
                            case Err(e): Err(e)
                    case Err(e): Err(e)

            # If expression
            case If(cond, then_, else_):
                match self.infer_expr(cond):
                    case Ok(cond_ty):
                        val bool_ty = HirType(kind: HirTypeKind.Bool, span: span)
                        match self.unify(cond_ty, bool_ty):
                            case Err(e): return Err(e)
                            case _: pass
                        match self.infer_block(then_):
                            case Ok(then_ty):
                                if else_.?:
                                    match self.infer_block(else_.unwrap()):
                                        case Ok(else_ty):
                                            match self.unify(then_ty, else_ty):
                                                case Err(e): Err(e)
                                                case _: Ok(self.resolve(then_ty))
                                        case Err(e): Err(e)
                                else:
                                    Ok(self.resolve(then_ty))
                            case Err(e): Err(e)
                    case Err(e): Err(e)

            # Lambda (closure)
            case Closure(params, body, _):
                self.enter_level()

                var param_types: [HirType] = []
                for p in params:
                    val param_ty = if p.type_.kind != HirTypeKind.Infer(0, 0):
                        p.type_
                    else:
                        self.fresh_var(p.span)
                    param_types = param_types.push(param_ty)
                    self.bind_mono(p.name, param_ty)

                match self.infer_expr(body):
                    case Ok(body_ty):
                        self.exit_level()
                        var resolved_params: [HirType] = []
                        for pt in param_types:
                            resolved_params = resolved_params.push(self.resolve(pt))
                        Ok(HirType(
                            kind: HirTypeKind.Function(resolved_params, self.resolve(body_ty), []),
                            span: span
                        ))
                    case Err(e):
                        self.exit_level()
                        Err(e)

            # Match expression
            case MatchCase(scrutinee, arms):
                match self.infer_expr(scrutinee):
                    case Ok(scrut_ty):
                        val result_ty = self.fresh_var(span)
                        for arm in arms:
                            match self.infer_pattern(arm.pattern, scrut_ty):
                                case Err(e): return Err(e)
                                case _: pass
                            if arm.guard.?:
                                match self.infer_expr(arm.guard.unwrap()):
                                    case Ok(guard_ty):
                                        val bool_ty = HirType(kind: HirTypeKind.Bool, span: span)
                                        match self.unify(guard_ty, bool_ty):
                                            case Err(e): return Err(e)
                                            case _: pass
                                    case Err(e): return Err(e)
                            match self.infer_expr(arm.body):
                                case Ok(arm_ty):
                                    match self.unify(result_ty, arm_ty):
                                        case Err(e): return Err(e)
                                        case _: pass
                                case Err(e): return Err(e)
                        Ok(self.resolve(result_ty))
                    case Err(e): Err(e)

            # Range expressions
            case Range(start, end, _, _):
                if start.?:
                    match self.infer_expr(start.unwrap()):
                        case Err(e): return Err(e)
                        case _: pass
                if end.?:
                    match self.infer_expr(end.unwrap()):
                        case Err(e): return Err(e)
                        case _: pass
                val int_ty = HirType(kind: HirTypeKind.Int(64, true), span: span)
                Ok(HirType(kind: HirTypeKind.Slice(int_ty), span: span))

            case _:
                Err(TypeInferError(message: "unsupported expression kind: {expr.kind}", span: span))

    me infer_binary_op(op: HirBinOp, left: HirType, right: HirType, span: Span) -> Result<HirType, TypeInferError>:
        """Infer type of binary operation."""
        match op:
            # Arithmetic: operands same type, return same type
            case Add | Sub | Mul | Div | Mod | Pow:
                match self.unify(left, right):
                    case Err(e): Err(e)
                    case _: Ok(self.resolve(left))

            # Comparison: operands same type, return bool
            case Eq | NotEq | Lt | LtEq | Gt | GtEq:
                match self.unify(left, right):
                    case Err(e): Err(e)
                    case _: Ok(HirType(kind: HirTypeKind.Bool, span: span))

            # Logical: operands bool, return bool
            case And | Or:
                val bool_ty = HirType(kind: HirTypeKind.Bool, span: span)
                match self.unify(left, bool_ty):
                    case Err(e): return Err(e)
                    case _: pass
                match self.unify(right, bool_ty):
                    case Err(e): Err(e)
                    case _: Ok(bool_ty)

            # Bitwise: operands int, return int
            case BitAnd | BitOr | BitXor | Shl | Shr:
                val int_ty = HirType(kind: HirTypeKind.Int(64, true), span: span)
                match self.unify(left, int_ty):
                    case Err(e): return Err(e)
                    case _: pass
                match self.unify(right, int_ty):
                    case Err(e): Err(e)
                    case _: Ok(int_ty)

            # Pipeline: x |> f becomes f(x)
            # Left operand is value, right operand is function
            case PipeForward:
                self.infer_pipe_forward(left, right, span)

            # Composition: f >> g means \x -> g(f(x))
            # Both operands are functions
            case Compose:
                self.infer_compose(left, right, span)

            # Backward composition: f << g means \x -> f(g(x))
            case ComposeBack:
                self.infer_compose(right, left, span)

            # Parallel: a // b runs both and combines results
            case Parallel:
                self.infer_parallel(left, right, span)

            # Layer connection: l1 ~> l2 composes layers with dimension checking
            case LayerConnect:
                self.infer_layer_connect(left, right, span)

            # Matrix multiplication
            case MatMul:
                self.infer_matmul(left, right, span)

            # Broadcast operations
            case BroadcastAdd | BroadcastSub | BroadcastMul | BroadcastDiv | BroadcastPow:
                self.infer_broadcast_op(left, right, span)

            case _:
                Err(TypeInferError(message: "unsupported binary operator: {op}", span: span))

    me infer_unary_op(op: HirUnaryOp, operand: HirType, span: Span) -> Result<HirType, TypeInferError>:
        """Infer type of unary operation."""
        match op:
            case Neg:
                Ok(operand)
            case Not:
                Ok(HirType(kind: HirTypeKind.Bool, span: span))
            case BitNot:
                Ok(operand)
            case Ref:
                Ok(HirType(kind: HirTypeKind.Ref(operand, false), span: span))
            case RefMut:
                Ok(HirType(kind: HirTypeKind.Ref(operand, true), span: span))
            case Deref:
                val resolved = self.resolve(operand)
                match resolved.kind:
                    case Ref(inner, _) | Ptr(inner, _):
                        Ok(inner)
                    case _:
                        Ok(self.fresh_var(span))
            case _:
                Ok(operand)
