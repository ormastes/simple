# Level-Based Generalization and Instantiation
#
# Implements the let-polymorphism mechanism of Algorithm W:
# - Level management (enter_level, exit_level)
# - Fresh type variable generation
# - Free variable collection
# - Generalization (types → type schemes)
# - Instantiation (type schemes → types with fresh vars)
#
# The level system ensures we only generalize variables that are
# local to the current binding, not those from outer scopes.

use compiler.hir.hir.*
use compiler.core.lexer.*
use type_infer_types.*

impl HmInferContext:
    # =========================================================================
    # Level Management
    # =========================================================================

    me enter_level():
        """Enter a new level (for let-bindings, lambdas)."""
        self.level = self.level + 1

    me exit_level():
        """Exit the current level."""
        self.level = self.level - 1

    fn current_level() -> i64:
        """Get the current generalization level."""
        self.level

    # =========================================================================
    # Fresh Type Variables
    # =========================================================================

    me fresh_var(span: Span) -> HirType:
        """Create a fresh type variable at the current level."""
        self.fresh_var_at_level(self.level, span)

    me fresh_var_at_level(level: i64, span: Span) -> HirType:
        """Create a fresh type variable at a specific level."""
        val id = self.next_var
        self.next_var = self.next_var + 1
        HirType(
            kind: HirTypeKind.Infer(id, level),
            span: span
        )

    # =========================================================================
    # Free Variables
    # =========================================================================

    fn free_vars_with_levels(ty: HirType) -> [(i64, i64)]:
        """Collect free type variables in a type with their levels."""
        val resolved = self.resolve(ty)
        var vars: [(i64, i64)] = []
        self.collect_free_vars(resolved, vars)
        vars

    me collect_free_vars(ty: HirType, vars: [(i64, i64)]):
        """Collect free variables from a type."""
        match ty.kind:
            case Infer(id, level):
                vars = vars.push((id, level))
            case Function(params, ret, _):
                for p in params:
                    self.collect_free_vars(p, vars)
                self.collect_free_vars(ret, vars)
            case Tuple(elements):
                for e in elements:
                    self.collect_free_vars(e, vars)
            case Array(element, _) | Slice(element):
                self.collect_free_vars(element, vars)
            case Dict(key, value):
                self.collect_free_vars(key, vars)
                self.collect_free_vars(value, vars)
            case Optional(inner) | Ref(inner, _) | Ptr(inner, _):
                self.collect_free_vars(inner, vars)
            case Result(ok, err):
                self.collect_free_vars(ok, vars)
                self.collect_free_vars(err, vars)
            case Named(_, args):
                for a in args:
                    self.collect_free_vars(a, vars)
            case _:
                pass

    fn env_free_var_ids() -> [i64]:
        """Collect free type variable IDs in the environment."""
        var vars: [i64] = []
        for name, scheme in self.env:
            val ty_vars = self.free_vars_with_levels(scheme.ty)
            for (id, _) in ty_vars:
                if not scheme.vars.contains(id):
                    vars = vars.push(id)
        vars

    # =========================================================================
    # Generalization and Instantiation
    # =========================================================================

    fn generalize(ty: HirType) -> TypeScheme:
        """Generalize a type to a type scheme.
        Only variables at level > current env level are generalized."""
        val resolved = self.resolve(ty)
        val free_vars = self.free_vars_with_levels(resolved)
        val env_vars = self.env_free_var_ids()

        # Variables to quantify: free in ty, not in env, at level > current
        var to_generalize: [i64] = []
        for (id, var_level) in free_vars:
            if not env_vars.contains(id) and var_level > self.level:
                if not to_generalize.contains(id):
                    to_generalize = to_generalize.push(id)

        TypeScheme(vars: to_generalize, ty: resolved)

    fn generalize_all(ty: HirType) -> TypeScheme:
        """Generalize all variables (ignore levels) - for top-level definitions."""
        val resolved = self.resolve(ty)
        val free_vars = self.free_vars_with_levels(resolved)
        val env_vars = self.env_free_var_ids()

        var to_generalize: [i64] = []
        for (id, _) in free_vars:
            if not env_vars.contains(id):
                if not to_generalize.contains(id):
                    to_generalize = to_generalize.push(id)

        TypeScheme(vars: to_generalize, ty: resolved)

    me instantiate(scheme: TypeScheme) -> HirType:
        """Instantiate a type scheme with fresh type variables."""
        if scheme.vars.is_empty():
            return scheme.ty

        # Create mapping from bound vars to fresh vars
        var var_map: Dict<i64, HirType> = {}
        for bound_var in scheme.vars:
            var_map[bound_var] = self.fresh_var(scheme.ty.span)

        # Apply the mapping
        self.instantiate_type(scheme.ty, var_map)

    fn instantiate_type(ty: HirType, var_map: Dict<i64, HirType>) -> HirType:
        """Apply instantiation mapping to a type."""
        match ty.kind:
            case Infer(id, _):
                if var_map[id].?:
                    var_map[id]
                else:
                    ty
            case Function(params, ret, effects):
                var new_params: [HirType] = []
                for p in params:
                    new_params = new_params.push(self.instantiate_type(p, var_map))
                HirType(
                    kind: HirTypeKind.Function(new_params, self.instantiate_type(ret, var_map), effects),
                    span: ty.span
                )
            case Tuple(elements):
                var new_elements: [HirType] = []
                for e in elements:
                    new_elements = new_elements.push(self.instantiate_type(e, var_map))
                HirType(kind: HirTypeKind.Tuple(new_elements), span: ty.span)
            case Array(element, size):
                HirType(kind: HirTypeKind.Array(self.instantiate_type(element, var_map), size), span: ty.span)
            case Slice(element):
                HirType(kind: HirTypeKind.Slice(self.instantiate_type(element, var_map)), span: ty.span)
            case Dict(key, value):
                HirType(
                    kind: HirTypeKind.Dict(
                        self.instantiate_type(key, var_map),
                        self.instantiate_type(value, var_map)
                    ),
                    span: ty.span
                )
            case Optional(inner):
                HirType(kind: HirTypeKind.Optional(self.instantiate_type(inner, var_map)), span: ty.span)
            case Result(ok, err):
                HirType(
                    kind: HirTypeKind.Result(
                        self.instantiate_type(ok, var_map),
                        self.instantiate_type(err, var_map)
                    ),
                    span: ty.span
                )
            case Ref(inner, mutable):
                HirType(kind: HirTypeKind.Ref(self.instantiate_type(inner, var_map), mutable), span: ty.span)
            case Ptr(inner, mutable):
                HirType(kind: HirTypeKind.Ptr(self.instantiate_type(inner, var_map), mutable), span: ty.span)
            case Named(symbol, args):
                var new_args: [HirType] = []
                for a in args:
                    new_args = new_args.push(self.instantiate_type(a, var_map))
                HirType(kind: HirTypeKind.Named(symbol, new_args), span: ty.span)
            case _:
                ty
