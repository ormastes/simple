# Auto-Vectorization Pass - Phase 2: Vectorizability Validation
#
# Comprehensive checks for whether a loop can be safely vectorized.
# Validates control flow, function calls, array access patterns,
# trip count, and instruction compatibility.

use compiler.mir.mir_data.{MirBlock, MirInst, MirInstKind, MirTerminator, MirOperand, MirBinOp, LocalId}
use compiler.mir_opt.auto_vectorize_types.{LoopInfo, ArrayAccess}
use compiler.mir_opt.auto_vectorize_analysis.{DependencyAnalysisResult}

# ============================================================================
# Vectorizability Result
# ============================================================================

struct VectorizabilityResult:
    """Result of vectorizability check."""
    can_vectorize: bool
    reason: text           # Reason if can't vectorize
    trip_count: i64        # Estimated trip count
    complexity_score: i64  # Complexity score (lower is better)

# ============================================================================
# Main Validation
# ============================================================================

fn check_vectorizability(loop: LoopInfo, body_blocks: [MirBlock], dep_result: DependencyAnalysisResult) -> VectorizabilityResult:
    """
    Comprehensive vectorizability validation.
    Checks all conditions required for safe vectorization.
    """
    # Check 1: No loop-carried dependencies
    if not dep_result.vectorizable:
        return VectorizabilityResult(
            can_vectorize: false,
            reason: "Loop has loop-carried dependencies",
            trip_count: 0,
            complexity_score: 0
        )

    # Check 2: No function calls in loop body
    val has_calls = check_for_function_calls(body_blocks)
    if has_calls:
        return VectorizabilityResult(
            can_vectorize: false,
            reason: "Loop contains function calls",
            trip_count: 0,
            complexity_score: 0
        )

    # Check 3: Simple control flow only
    val complex_cf = check_control_flow_complexity(body_blocks)
    if complex_cf:
        return VectorizabilityResult(
            can_vectorize: false,
            reason: "Loop has complex control flow",
            trip_count: 0,
            complexity_score: 0
        )

    # Check 4: Array accesses must be linear
    val non_linear = check_array_access_patterns(dep_result.array_accesses, loop.induction_var)
    if non_linear:
        return VectorizabilityResult(
            can_vectorize: false,
            reason: "Loop has non-linear array accesses",
            trip_count: 0,
            complexity_score: 0
        )

    # Check 5: Trip count must be sufficient
    val trip_count = estimate_trip_count(loop)
    if trip_count < 8:  # Need at least 2 vector iterations
        return VectorizabilityResult(
            can_vectorize: false,
            reason: "Trip count too small for vectorization",
            trip_count: trip_count,
            complexity_score: 0
        )

    # Check 6: Calculate complexity score
    val complexity = calculate_complexity(body_blocks)

    # All checks passed
    VectorizabilityResult(
        can_vectorize: true,
        reason: "Loop is vectorizable",
        trip_count: trip_count,
        complexity_score: complexity
    )

# ============================================================================
# Individual Checks
# ============================================================================

fn check_for_function_calls(body_blocks: [MirBlock]) -> bool:
    """
    Check if loop body contains function calls.
    Function calls prevent vectorization (unless they're vectorizable intrinsics).
    """
    for block in body_blocks:
        for inst in block.instructions:
            match inst.kind:
                case Call(_, _, _):
                    return true
                case CallIndirect(_, _, _, _):
                    return true
                case _:
                    pass_do_nothing
    false

fn check_control_flow_complexity(body_blocks: [MirBlock]) -> bool:
    """
    Check if control flow is too complex for vectorization.
    Simple if-then is OK, complex branches are not.
    """
    # If more than 2 blocks, it's getting complex
    if body_blocks.len() > 2:
        return true

    # Check for complex terminators
    for block in body_blocks:
        match block.terminator:
            case Switch(_, _, _):
                # Switch statements are too complex
                return true
            case Unreachable:
                return true
            case _:
                pass_do_nothing

    false

fn check_array_access_patterns(accesses: [ArrayAccess], induction: LocalId) -> bool:
    """
    Check if all array accesses are linear (a[i] pattern).
    Non-linear accesses like a[f(i)] prevent vectorization.
    Returns true if non-linear patterns found.
    """
    for access in accesses:
        # Check if index is the induction variable
        if access.index_expr.id != induction.id:
            # Index is not simple induction variable
            # Could be i+1, i-1, etc. (more complex analysis needed)
            # For now, conservatively reject
            return true
    false

fn estimate_trip_count(loop: LoopInfo) -> i64:
    """
    Estimate the number of loop iterations.
    For simple loops: (end - start) / step
    """
    if loop.step == 0:
        return 0

    val count = (loop.end_value - loop.start_value) / loop.step
    if count < 0:
        return 0

    count

fn calculate_complexity(body_blocks: [MirBlock]) -> i64:
    """
    Calculate complexity score for loop body.
    Lower score = simpler loop = better vectorization candidate.
    """
    var score = 0

    for block in body_blocks:
        # Each instruction adds to complexity
        score = score + block.instructions.len()

        # Control flow adds complexity
        match block.terminator:
            case If(_, _, _):
                score = score + 10  # Conditional adds significant complexity
            case Switch(_, cases, _):
                score = score + (20 + cases.len() * 5)
            case _:
                pass_do_nothing

    score

# ============================================================================
# Instruction-Level Checks
# ============================================================================

fn can_vectorize_instruction(inst: MirInst) -> bool:
    """
    Check if a single instruction can be vectorized.
    """
    match inst.kind:
        case BinOp(_, op, _, _):
            # Check if operation has SIMD equivalent
            match op:
                case Add | Sub | Mul | Div:
                    true
                case _:
                    false
        case Load(_, _):
            true
        case Store(_, _):
            true
        case GetElementPtr(_, _, _):
            true
        case _:
            false

fn get_vectorizable_type(body_blocks: [MirBlock]) -> text?:
    """
    Determine the element type for vectorization (f32, f64, i32).
    Returns nil if mixed types or unsupported types found.
    """
    var found_type: text? = nil

    for block in body_blocks:
        for inst in block.instructions:
            val inst_type = get_instruction_type(inst)
            if inst_type.?:
                val t = inst_type.unwrap()
                if not found_type.?:
                    found_type = Some(t)
                elif found_type.unwrap() != t:
                    # Mixed types - can't vectorize
                    return nil

    found_type

fn get_instruction_type(inst: MirInst) -> text?:
    """
    Get the primary type involved in an instruction.
    Returns "f32", "f64", "i32", or nil.
    """
    match inst.kind:
        case BinOp(_, _, _, _):
            # Would need type info from operands
            # Simplified: assume f32
            Some("f32")
        case _:
            nil

# ============================================================================
# Exports
# ============================================================================

export VectorizabilityResult
export check_vectorizability
export check_for_function_calls, check_control_flow_complexity
export check_array_access_patterns, estimate_trip_count, calculate_complexity
export can_vectorize_instruction, get_vectorizable_type, get_instruction_type
