# MIR Lowering - Expression Lowering
#
# Expression lowering from HIR to MIR:
# - Literal lowering (int, float, bool, string, nil, unit)
# - Variable references
# - Binary/unary operators (including special pipeline/compose/parallel)
# - Function calls (direct and indirect)
# - Method calls (instance, trait, static, free function / UFCS)
# - Array, tuple, set, and constant expression lowering
# - Field access

use mir_data.*
use hir.*
use lexer.Span
use compiler.blocks.value.BlockValue
use compiler.mir.mir_lowering_types.{MirLowering, MirError}

# ============================================================================
# Expression Lowering
# ============================================================================

impl MirLowering:
    me lower_expr(expr: HirExpr) -> LocalId:
        """Lower HIR expression to MIR, return result local."""
        match expr.kind:
            case IntLit(value, _):
                var b = self.builder
                val result = b.emit_const_int(value)
                self.builder = b
                result

            case FloatLit(value, _):
                var b = self.builder
                val result = b.emit_const_float(value)
                self.builder = b
                result

            case BoolLit(value):
                var b = self.builder
                val result = b.emit_const_bool(value)
                self.builder = b
                result

            case StringLit(value, _):
                # Store string as constant; runtime resolves pointer
                var b = self.builder
                val dest = b.new_temp(MirType(kind: MirTypeKind.Opaque("str")))
                b.emit_const(dest, MirConstValue.Str(value), MirType(kind: MirTypeKind.Opaque("str")))
                self.builder = b
                dest

            case NilLit | UnitLit:
                var b = self.builder
                val result = b.new_temp(MirType__unit())
                self.builder = b
                result

            case Var(symbol):
                # Look up variable in local_map using contains_key first
                if self.local_map.contains_key(symbol):
                    self.local_map[symbol]
                else:
                    self.error("undefined variable", Some(expr.span))
                    var b_err = self.builder
                    val err_tmp = b_err.new_temp(MirType__i64())
                    self.builder = b_err
                    err_tmp

            case Binary(op, left, right):
                # Check if this is a special pipeline operator first
                val special_result = self.lower_binop_special(op, left, right)
                if special_result.?:
                    special_result.unwrap()
                else:
                    # Normal binary operation
                    val left_local = self.lower_expr(left)
                    val right_local = self.lower_expr(right)
                    val mir_op = self.lower_binop(op)
                    val result_type = self.infer_binop_type(op)
                    var b = self.builder
                    val binop_result = b.emit_binop(mir_op, mir_operand_copy(left_local), mir_operand_copy(right_local), result_type)
                    self.builder = b
                    binop_result

            case Unary(op, operand):
                val operand_local = self.lower_expr(operand)
                val mir_op = self.lower_unaryop(op)
                var b = self.builder
                val unary_result = b.emit_unary(mir_op, mir_operand_copy(operand_local), MirType__i64())
                self.builder = b
                unary_result

            case If(cond, then_, else_):
                self.lower_if(cond, then_, else_)

            case Call(callee, args, _):
                self.lower_call(callee, args)

            case MethodCall(receiver, method, args, resolution):
                self.lower_method_call(receiver, method, args, resolution)

            case ArrayLit(elements, _):
                self.lower_array_lit(elements)

            case Index(base, index):
                # Array indexing: arr[i] -> GEP + Load
                val base_local = self.lower_expr(base)
                val index_local = self.lower_expr(index)
                var b = self.builder
                val ptr = b.emit_gep(
                    mir_operand_copy(base_local),
                    [mir_operand_copy(index_local)],
                    MirType__ptr(MirType__i64(), false)
                )
                val loaded = b.emit_load(mir_operand_copy(ptr), MirType__i64())
                self.builder = b
                loaded

            case SetLit(elements, _):
                self.lower_set_lit(elements)

            case TupleLit(elements):
                self.lower_tuple_lit(elements)

            case Block(block):
                val result = self.lower_block(block)
                if result.?:
                    result.unwrap()
                else:
                    var b = self.builder
                    val temp = b.new_temp(MirType__unit())
                    self.builder = b
                    temp

            case Loop(body, _):
                self.lower_loop(body)

            case While(cond, body, _):
                self.lower_while(cond, body)

            case For(var_, iter, body, _):
                self.lower_for(var_, iter, body)

            case Return(value):
                var br = self.builder
                if value.?:
                    val result = self.lower_expr(value.unwrap())
                    br = self.builder
                    br.terminate_return(Some(mir_operand_copy(result)))
                else:
                    br.terminate_return(nil)
                self.builder = br
                var br2 = self.builder
                val ret_temp = br2.new_temp(MirType__unit())
                self.builder = br2
                ret_temp

            case Break(break_label, break_value):
                if self.loop_stack.len() > 0:
                    val (loop_continue_block, break_block) = self.loop_stack[self.loop_stack.len() - 1]
                    var b = self.builder
                    b.terminate_goto(break_block)
                    self.builder = b
                var b = self.builder
                val break_temp = b.new_temp(MirType__unit())
                self.builder = b
                break_temp

            case Continue(cont_label):
                if self.loop_stack.len() > 0:
                    val (continue_block, loop_break_block) = self.loop_stack[self.loop_stack.len() - 1]
                    var b = self.builder
                    b.terminate_goto(continue_block)
                    self.builder = b
                var b = self.builder
                val cont_temp = b.new_temp(MirType__unit())
                self.builder = b
                cont_temp

            # Custom blocks (user-defined: sh{}, sql{}, re{}, etc.)
            case CustomBlock(kind, value):
                self.lower_custom_block(kind, value, expr.span)

            # Math/DL blocks with special semantics
            case LossBlock(body):
                self.lower_loss_block(body)

            case NogradBlock(body):
                self.lower_nograd_block(body)

            case Range(start, end, inclusive, step):
                self.lower_range(start, end, inclusive, step)

            # Async/Await expressions
            case Await(future_expr):
                self.lower_await(future_expr)

            case Yield(value):
                self.lower_yield(value)

            # Unsafe block - lower the body, no special handling
            case UnsafeBlock(body):
                self.lower_block(body) ?? self.builder.new_temp(MirType__unit())

            # Inline assembly
            case InlineAsm(asm):
                self.lower_inline_asm(asm)

            # Target-qualified inline assembly
            case InlineAsmMatch(arms):
                self.lower_inline_asm_match(arms)

            # Field access: obj.field_name
            case Field(base, field_name, resolved):
                val base_local = self.lower_expr(base)
                val field_idx = self.resolve_field_index(base, field_name, resolved)
                var b = self.builder
                val result = b.emit_get_field(mir_operand_copy(base_local), field_idx, MirType__i64())
                self.builder = b
                result

            case _:
                self.error("unsupported MIR expression: {expr.kind}", nil)
                nil

    me lower_binop_special(op: HirBinOp, left: HirExpr, right: HirExpr) -> LocalId?:
        """Check if this is a special binary op needing non-BinOp lowering."""
        match op:
            case PipeForward:
                # x |> f  ->  PipeForward(x, f)
                val value_local = self.lower_expr(left)
                val func_local = self.lower_expr(right)
                val dest = self.builder.new_temp(MirType__i64())
                self.builder.emit(MirInst(kind: MirInstKind.PipeForward(dest, mir_operand_copy(value_local), mir_operand_copy(func_local)), span: nil))
                Some(dest)

            case Compose:
                # f >> g  ->  Compose(f, g, true)
                val f_local = self.lower_expr(left)
                val g_local = self.lower_expr(right)
                val dest = self.builder.new_temp(MirType__i64())
                self.builder.emit(MirInst(kind: MirInstKind.Compose(dest, mir_operand_copy(f_local), mir_operand_copy(g_local), true), span: nil))
                Some(dest)

            case ComposeBack:
                # f << g  ->  Compose(f, g, false)
                val f_local = self.lower_expr(left)
                val g_local = self.lower_expr(right)
                val dest = self.builder.new_temp(MirType__i64())
                self.builder.emit(MirInst(kind: MirInstKind.Compose(dest, mir_operand_copy(f_local), mir_operand_copy(g_local), false), span: nil))
                Some(dest)

            case Parallel:
                # f // g  ->  Parallel([f, g])
                val f_local = self.lower_expr(left)
                val g_local = self.lower_expr(right)
                val dest = self.builder.new_temp(MirType__i64())
                self.builder.emit(MirInst(kind: MirInstKind.Parallel(dest, [mir_operand_copy(f_local), mir_operand_copy(g_local)]), span: nil))
                Some(dest)

            case LayerConnect:
                # layer1 ~> layer2  ->  LayerConnect(layer1, layer2)
                val l1_local = self.lower_expr(left)
                val l2_local = self.lower_expr(right)
                val dest = self.builder.new_temp(MirType__i64())
                self.builder.emit(MirInst(kind: MirInstKind.LayerConnect(dest, mir_operand_copy(l1_local), mir_operand_copy(l2_local)), span: nil))
                Some(dest)

            case _:
                nil  # Not a special op, use normal BinOp

    me lower_binop(op: HirBinOp) -> MirBinOp:
        """Convert HIR binary op to MIR binary op."""
        match op:
            case Add: MirBinOp.Add
            case Sub: MirBinOp.Sub
            case Mul: MirBinOp.Mul
            case Div: MirBinOp.Div
            case Mod: MirBinOp.Rem
            case Pow: MirBinOp.Pow
            case MatMul: MirBinOp.MatMul
            case BitAnd: MirBinOp.BitAnd
            case BitOr: MirBinOp.BitOr
            case BitXor: MirBinOp.BitXor
            case Shl: MirBinOp.Shl
            case Shr: MirBinOp.Shr
            case Eq: MirBinOp.Eq
            case NotEq: MirBinOp.Ne
            case Lt: MirBinOp.Lt
            case LtEq: MirBinOp.Le
            case Gt: MirBinOp.Gt
            case GtEq: MirBinOp.Ge
            case BroadcastAdd: MirBinOp.BroadcastAdd
            case BroadcastSub: MirBinOp.BroadcastSub
            case BroadcastMul: MirBinOp.BroadcastMul
            case BroadcastDiv: MirBinOp.BroadcastDiv
            case BroadcastPow: MirBinOp.BroadcastPow
            case _: MirBinOp.Add

    me lower_unaryop(op: HirUnaryOp) -> MirUnaryOp:
        """Convert HIR unary op to MIR unary op."""
        match op:
            case Neg: MirUnaryOp.Neg
            case Not: MirUnaryOp.Not
            case BitNot: MirUnaryOp.BitNot
            case Transpose: MirUnaryOp.Transpose
            case _: MirUnaryOp.Neg

    me infer_binop_type(op: HirBinOp) -> MirType:
        """Infer result type of binary operation."""
        match op:
            case Eq | NotEq | Lt | LtEq | Gt | GtEq:
                MirType__bool()
            case _:
                MirType__i64()  # Default to i64

    me lower_call(callee: HirExpr, args: [HirCallArg]) -> LocalId:
        """Lower function call.

        Handles both direct calls (Var) and indirect calls (closures, function pointers).
        """
        var arg_operands: [MirOperand] = []
        for arg in args:
            val arg_local = self.lower_expr(arg.value)
            arg_operands = arg_operands.push(mir_operand_copy(arg_local))

        # Check if this is a direct call (Var) or indirect call
        match callee.kind:
            case Var(symbol):
                # Direct call - use Call instruction
                val func_operand = self.symbol_to_operand(symbol)
                var b = self.builder
                val result = b.emit_call(func_operand, arg_operands, MirType__i64())
                if result.?:
                    self.builder = b
                    result.unwrap()
                else:
                    val temp = b.new_temp(MirType__unit())
                    self.builder = b
                    temp

            case _:
                # Indirect call - lower callee expression and use CallIndirect
                val callee_local = self.lower_expr(callee)
                # Infer parameter types from arguments
                var param_types: [MirType] = []
                for arg_op in arg_operands:
                    param_types.push(MirType__i64())
                # Infer return type from callee's type annotation if available
                val ret_type = if callee.type_.?:
                    self.lower_type(callee.type_.unwrap())
                else:
                    MirType__i64()
                val sig = MirSignature(
                    params: param_types,
                    return_type: ret_type,
                    is_variadic: false
                )
                var b = self.builder
                val result = b.emit_call_indirect(mir_operand_copy(callee_local), arg_operands, sig, MirType__i64())
                if result.?:
                    self.builder = b
                    result.unwrap()
                else:
                    val temp = b.new_temp(MirType__unit())
                    self.builder = b
                    temp

    me lower_method_call(receiver: HirExpr, method: text, args: [HirCallArg], resolution: MethodResolution) -> LocalId:
        """Lower method call based on resolution.

        UFCS: For FreeFunction resolution, receiver becomes first argument.
        """
        match resolution:
            case InstanceMethod(type_id, method_id):
                # Direct method call on type
                val arg_operands = self.lower_receiver_and_args(receiver, args)
                val method_operand = self.symbol_to_operand(method_id)
                var b = self.builder
                val result = b.emit_call(method_operand, arg_operands, MirType__i64())
                if result.?:
                    self.builder = b
                    result.unwrap()
                else:
                    val temp = b.new_temp(MirType__unit())
                    self.builder = b
                    temp

            case TraitMethod(trait_id, method_id):
                val arg_operands = self.lower_receiver_and_args(receiver, args)
                val method_operand = self.symbol_to_operand(method_id)
                var b = self.builder
                val result = b.emit_call(method_operand, arg_operands, MirType__i64())
                if result.?:
                    self.builder = b
                    result.unwrap()
                else:
                    val temp = b.new_temp(MirType__unit())
                    self.builder = b
                    temp

            case FreeFunction(func_id):
                val arg_operands = self.lower_receiver_and_args(receiver, args)
                val func_operand = self.symbol_to_operand(func_id)
                var b = self.builder
                val result = b.emit_call(func_operand, arg_operands, MirType__i64())
                if result.?:
                    self.builder = b
                    result.unwrap()
                else:
                    val temp = b.new_temp(MirType__unit())
                    self.builder = b
                    temp

            case StaticMethod(type_id, method_id):
                var arg_operands: [MirOperand] = []
                for arg in args:
                    val arg_local = self.lower_expr(arg.value)
                    arg_operands = arg_operands.push(mir_operand_copy(arg_local))

                val method_operand = self.symbol_to_operand(method_id)
                var b = self.builder
                val result = b.emit_call(method_operand, arg_operands, MirType__i64())
                if result.?:
                    self.builder = b
                    result.unwrap()
                else:
                    val temp = b.new_temp(MirType__unit())
                    self.builder = b
                    temp

            case Unresolved:
                self.error("unresolved method call: {method}", nil)
                var b = self.builder
                val temp = b.new_temp(MirType__unit())
                self.builder = b
                temp

    me symbol_to_operand(symbol: SymbolId) -> MirOperand:
        """Convert a symbol to a function pointer operand."""
        # Look up function name from symbol table for direct calls
        val sym = self.symbols.get(symbol)
        val name = if sym.?: sym.name else: "unknown_{symbol.id}"
        MirOperand(kind: MirOperandKind.Const(
            MirConstValue.Str(name),
            MirType(kind: MirTypeKind.FuncPtr(MirSignature(params: [], return_type: MirType__i64(), is_variadic: false)))
        ))

    me lower_array_lit(elements: [HirExpr]) -> LocalId:
        """Lower array literal."""
        var operands: [MirOperand] = []
        for elem in elements:
            val local = self.lower_expr(elem)
            operands = operands.push(mir_operand_copy(local))

        val elem_type = if elements.len() > 0 and elements[0].type_.?:
            self.lower_type(elements[0].type_.unwrap())
        else:
            MirType__i64()
        val array_type = MirType(kind: MirTypeKind.Array(elem_type, elements.len()))

        self.builder.emit_aggregate(
            AggregateKind.Array(elem_type),
            operands,
            array_type
        )

    me lower_tuple_lit(elements: [HirExpr]) -> LocalId:
        """Lower tuple literal."""
        var operands: [MirOperand] = []
        var types: [MirType] = []
        for elem in elements:
            val local = self.lower_expr(elem)
            operands = operands.push(mir_operand_copy(local))
            val elem_ty = if elem.type_.?:
                self.lower_type(elem.type_.unwrap())
            else:
                MirType__i64()
            types = types.push(elem_ty)

        val tuple_type = MirType(kind: MirTypeKind.Tuple(types))
        self.builder.emit_aggregate(AggregateKind.Tuple, operands, tuple_type)

    me lower_set_lit(elements: [HirExpr]) -> LocalId:
        """Lower set literal to Set__from() call.

        Transforms: s{1, 2, 3}
        Into: Set__from([1, 2, 3])

        This is simpler than Set__new() + insert() and works with current runtime.
        Future optimization: emit direct Set__new() + insert() calls.
        """
        # Infer element type from first element, or default to i64
        val elem_type = if elements.len() > 0 and elements[0].type_.?:
            self.lower_type(elements[0].type_.unwrap())
        else:
            MirType__i64()

        # Lower elements to array literal
        var elem_operands: [MirOperand] = []
        for elem in elements:
            val elem_local = self.lower_expr(elem)
            elem_operands = elem_operands.push(mir_operand_copy(elem_local))

        # Create array from elements
        val array_type = MirType(kind: MirTypeKind.Array(elem_type, elements.len()))
        val array_local = self.builder.emit_aggregate(
            AggregateKind.Array(elem_type),
            elem_operands,
            array_type
        )

        # Call Set.from(array) - using runtime function placeholder
        # In a real implementation, this would resolve Set.from symbol from symbol table
        # For now, create a function operand that will be resolved by codegen
        val set_from_operand = MirOperand(kind: MirOperandKind.Const(
            MirConstValue.Int(0),  # Placeholder - codegen will resolve "Set.from"
            MirType(kind: MirTypeKind.FuncPtr(MirSignature(
                params: [array_type],
                return_type: MirType(kind: MirTypeKind.Named("Set", [elem_type])),
                is_variadic: false
            )))
        ))

        val set_type = MirType(kind: MirTypeKind.Named("Set", [elem_type]))
        val result = self.builder.emit_call(
            set_from_operand,
            [mir_operand_copy(array_local)],
            set_type
        )

        result ?? self.builder.new_temp(set_type)

    me lower_const_expr(expr: HirExpr) -> MirConstValue?:
        """Lower constant expression."""
        match expr.kind:
            case IntLit(value, _):
                Some(MirConstValue.Int(value))
            case FloatLit(value, _):
                Some(MirConstValue.Float(value))
            case BoolLit(value):
                Some(MirConstValue.Bool(value))
            case StringLit(value, _):
                Some(MirConstValue.Str(value))
            case _:
                nil

# ============================================================================
# Exports
# ============================================================================

# Methods are attached to MirLowering via impl block above.
# No separate exports needed -- they are accessed through MirLowering instances.
