# MIR Types - Type system and leaf data structures
#
# Split from mir_data.spl. Contains:
# - MIR type system (MirType, MirTypeKind, impl MirType)
# - Leaf structs/enums with no instruction dependencies
#   (LocalId, LocalKind, MirLocal, MirSignature, MirStatic,
#    MirConstant, MirConstValue, MirTypeDef, etc.)
# - LayoutPhase enum

use hir.SymbolId

# ============================================================================
# Layout Phase
# ============================================================================

"""Layout phase for code locality optimization."""
enum LayoutPhase:
    Startup      # Critical startup code, loaded first
    FirstFrame   # First frame initialization
    Steady       # Regular execution hot paths
    Cold         # Rarely executed (error handling, cleanup)

# ============================================================================
# Local Variable Types
# ============================================================================

struct LocalId:
    """Local variable identifier."""
    id: i64

"""Kind of local variable."""
enum LocalKind:
    Arg(index: i64)     # Function argument
    Var                  # Regular variable
    Temp                 # Temporary (SSA)
    Return               # Return slot

struct MirLocal:
    """Local variable slot."""
    id: LocalId
    name: text?
    type_: MirType
    kind: LocalKind

# ============================================================================
# Function Signature
# ============================================================================

struct MirSignature:
    """Function signature."""
    params: [MirType]
    return_type: MirType
    is_variadic: bool

# ============================================================================
# Constants
# ============================================================================

"""Constant value."""
enum MirConstValue:
    Int(value: i64)
    Float(value: f64)
    Bool(value: bool)
    Str(value: text)
    Array(elements: [MirConstValue])
    Tuple(elements: [MirConstValue])
    Struct(fields: Dict<text, MirConstValue>)
    Zero                 # Zero-initialized

struct MirConstant:
    """Compile-time constant."""
    symbol: SymbolId
    name: text
    type_: MirType
    value: MirConstValue

# ============================================================================
# Statics
# ============================================================================

struct MirStatic:
    """Static/global variable."""
    symbol: SymbolId
    name: text
    type_: MirType
    init: MirConstant?
    is_mutable: bool

# ============================================================================
# Type Definitions
# ============================================================================

struct MirTypeDef:
    """Type definition."""
    symbol: SymbolId
    name: text
    kind: MirTypeDefKind

"""Type definition kind."""
enum MirTypeDefKind:
    Struct(fields: [MirFieldDef])
    Enum(variants: [MirVariantDef])
    Union(variants: [MirType])

struct MirFieldDef:
    """Struct field definition."""
    name: text
    type_: MirType
    offset: i64

struct MirVariantDef:
    """Enum variant definition."""
    name: text
    discriminant: i64
    payload: MirType?

# ============================================================================
# MIR Types
# ============================================================================

struct MirType:
    """MIR type."""
    kind: MirTypeKind

"""MIR type kind."""
enum MirTypeKind:
    # Primitives
    I8, I16, I32, I64
    U8, U16, U32, U64
    F32, F64
    Bool
    Char
    Unit

    # SIMD vector types
    Vec4f     # 4x f32 (128-bit SSE/NEON)
    Vec8f     # 8x f32 (256-bit AVX2)
    Vec4d     # 4x f64 (256-bit AVX2)
    Vec4i     # 4x i32 (128-bit SSE/NEON)
    Vec8i     # 8x i32 (256-bit AVX2)

    # Pointers and references
    Ptr(pointee: MirType, mutable: bool)
    Ref(referent: MirType, mutable: bool)
    FuncPtr(signature: MirSignature)

    # Aggregates
    Array(element: MirType, size: i64)
    Slice(element: MirType)
    Tuple(elements: [MirType])
    Struct(symbol: SymbolId)
    Enum(symbol: SymbolId)

    # Special
    Never              # !
    Opaque(name: text) # Foreign type

    # Async types
    Promise(inner: MirType)    # Promise<T> - async computation result
    Generator(yield_: MirType, return_: MirType)  # Generator yielding and returning types
    ActorType(message: MirType)    # Actor handling message type

impl MirType:
    static fn i64() -> MirType:
        MirType(kind: MirTypeKind.I64)

    static fn f64() -> MirType:
        MirType(kind: MirTypeKind.F64)

    static fn bool() -> MirType:
        MirType(kind: MirTypeKind.Bool)

    static fn unit() -> MirType:
        MirType(kind: MirTypeKind.Unit)

    static fn ptr(pointee: MirType, mutable: bool) -> MirType:
        MirType(kind: MirTypeKind.Ptr(pointee, mutable))

    static fn promise(inner: MirType) -> MirType:
        """Create Promise<T> type for async computations."""
        MirType(kind: MirTypeKind.Promise(inner))

    static fn generator(yield_ty: MirType, return_ty: MirType) -> MirType:
        """Create Generator<Y, R> type for generators."""
        MirType(kind: MirTypeKind.Generator(yield_ty, return_ty))

    static fn actor_type(message_ty: MirType) -> MirType:
        """Create ActorType<M> type for actors."""
        MirType(kind: MirTypeKind.ActorType(message_ty))

    fn primitive_size() -> i64?:
        """Get size for primitive types, nil for composite types."""
        match self.kind:
            case I8 | U8 | Bool: Some(1)
            case I16 | U16 | Char: Some(2)
            case I32 | U32 | F32: Some(4)
            case I64 | U64 | F64 | Ptr(_, _) | Ref(_, _) | FuncPtr(_): Some(8)
            case _: nil

    fn size_bytes() -> i64:
        """Get size in bytes."""
        val prim = self.primitive_size()
        if prim.?:
            return prim.unwrap()

        match self.kind:
            case Unit | Never: 0
            case Array(elem, size): elem.size_bytes() * size
            case Tuple(elements):
                var total = 0
                for e in elements:
                    total = total + e.size_bytes()
                total
            case _: 8  # Default pointer size

    fn alignment() -> i64:
        """Get alignment in bytes."""
        val prim = self.primitive_size()
        if prim.?:
            return prim.unwrap()

        match self.kind:
            case Unit | Never: 1
            case Array(elem, _): elem.alignment()
            case Tuple(elements):
                var max_align = 1
                for e in elements:
                    val align = e.alignment()
                    if align > max_align:
                        max_align = align
                max_align
            case _: 8

# ============================================================================
# Exports
# ============================================================================

export LayoutPhase
export LocalId, LocalKind, MirLocal
export MirSignature
export MirConstValue, MirConstant
export MirStatic
export MirTypeDef, MirTypeDefKind, MirFieldDef, MirVariantDef
export MirType, MirTypeKind
