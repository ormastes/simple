# MIR Instructions - Blocks, instructions, terminators, operands
#
# Split from mir_data.spl. Contains:
# - BlockId, MirBlock
# - MirInst, MirInstKind (all instruction variants)
# - GPU, VHDL, borrow checking support types
# - MirBinOp, MirUnaryOp, AggregateKind
# - MirOperand, MirOperandKind + operand helper functions
# - MirTerminator, SwitchCase, MirAsmOperand
# - MirPlace, MirProjection, MirBorrowKind, MirBody
# - MirModule, MirFunction (depend on MirBlock)
# - copy_mir_function_with_blocks helper

use hir.SymbolId
use lexer.Span
use compiler.mir.mir_types.*

# ============================================================================
# MIR Basic Blocks
# ============================================================================

struct BlockId:
    """Basic block identifier."""
    id: i64

impl BlockId:
    static fn new(id: i64) -> BlockId:
        BlockId(id: id)

    static fn entry() -> BlockId:
        BlockId.new(0)

struct MirBlock:
    """Basic block."""
    id: BlockId
    label: text?
    instructions: [MirInst]
    terminator: MirTerminator

# ============================================================================
# MIR Instructions
# ============================================================================

struct MirInst:
    """MIR instruction."""
    kind: MirInstKind
    span: Span?

"""MIR instruction kind."""
enum MirInstKind:
    # Constants
    Const(dest: LocalId, value: MirConstValue, type_: MirType)

    # Moves and copies
    Copy(dest: LocalId, src: LocalId)
    Move(dest: LocalId, src: LocalId)

    # Arithmetic
    BinOp(dest: LocalId, op: MirBinOp, left: MirOperand, right: MirOperand)
    UnaryOp(dest: LocalId, op: MirUnaryOp, operand: MirOperand)
    CheckedBinOp(dest: LocalId, op: MirBinOp, left: MirOperand, right: MirOperand)

    # Memory
    Alloc(dest: LocalId, type_: MirType)
    Load(dest: LocalId, ptr: MirOperand)
    Store(ptr: MirOperand, value: MirOperand)
    GetElementPtr(dest: LocalId, base: MirOperand, indices: [MirOperand])

    # Aggregates
    Aggregate(dest: LocalId, kind: AggregateKind, operands: [MirOperand])
    GetField(dest: LocalId, base: MirOperand, field: i64)
    SetField(base: MirOperand, field: i64, value: MirOperand)

    # Casts
    Cast(dest: LocalId, operand: MirOperand, target: MirType)
    Bitcast(dest: LocalId, operand: MirOperand, target: MirType)

    # Function calls
    Call(dest: LocalId?, func: MirOperand, args: [MirOperand])
    CallIndirect(dest: LocalId?, ptr: MirOperand, args: [MirOperand], sig: MirSignature)

    # Intrinsics
    Intrinsic(dest: LocalId?, name: text, args: [MirOperand])

    # SIMD Operations (128-bit and 256-bit vector instructions)
    # f32x4 (128-bit SSE/NEON)
    SimdAddF32x4(dest: LocalId, a: MirOperand, b: MirOperand)
    SimdSubF32x4(dest: LocalId, a: MirOperand, b: MirOperand)
    SimdMulF32x4(dest: LocalId, a: MirOperand, b: MirOperand)
    SimdDivF32x4(dest: LocalId, a: MirOperand, b: MirOperand)
    SimdFmaF32x4(dest: LocalId, a: MirOperand, b: MirOperand, c: MirOperand)
    # f32x8 (256-bit AVX2)
    SimdAddF32x8(dest: LocalId, a: MirOperand, b: MirOperand)
    SimdSubF32x8(dest: LocalId, a: MirOperand, b: MirOperand)
    SimdMulF32x8(dest: LocalId, a: MirOperand, b: MirOperand)
    SimdDivF32x8(dest: LocalId, a: MirOperand, b: MirOperand)
    SimdFmaF32x8(dest: LocalId, a: MirOperand, b: MirOperand, c: MirOperand)
    # f64x4 (256-bit AVX2)
    SimdAddF64x4(dest: LocalId, a: MirOperand, b: MirOperand)
    SimdSubF64x4(dest: LocalId, a: MirOperand, b: MirOperand)
    SimdMulF64x4(dest: LocalId, a: MirOperand, b: MirOperand)
    SimdDivF64x4(dest: LocalId, a: MirOperand, b: MirOperand)
    SimdFmaF64x4(dest: LocalId, a: MirOperand, b: MirOperand, c: MirOperand)
    # i32x4 (128-bit SSE/NEON)
    SimdAddI32x4(dest: LocalId, a: MirOperand, b: MirOperand)
    SimdSubI32x4(dest: LocalId, a: MirOperand, b: MirOperand)
    SimdMulI32x4(dest: LocalId, a: MirOperand, b: MirOperand)
    # i32x8 (256-bit AVX2)
    SimdAddI32x8(dest: LocalId, a: MirOperand, b: MirOperand)
    SimdSubI32x8(dest: LocalId, a: MirOperand, b: MirOperand)
    SimdMulI32x8(dest: LocalId, a: MirOperand, b: MirOperand)
    # Horizontal operations
    SimdHaddF32x4(dest: LocalId, a: MirOperand)
    SimdHmaxF32x4(dest: LocalId, a: MirOperand)
    SimdHminF32x4(dest: LocalId, a: MirOperand)

    # Inline assembly (must be in unsafe block)
    InlineAsm(
        asm_template: text,              # Assembly template with {operand} placeholders
        is_volatile: bool,               # Prevent optimization
        inputs: [MirAsmOperand],         # Input operands
        outputs: [MirAsmOperand],        # Output operands
        clobbers: [text]                 # Clobbered registers
    )

    # Pipeline operators (require runtime function dispatch)
    PipeForward(dest: LocalId, value: MirOperand, func: MirOperand)
    Compose(dest: LocalId, f: MirOperand, g: MirOperand, forward: bool)
    Parallel(dest: LocalId, funcs: [MirOperand])
    LayerConnect(dest: LocalId, layer1: MirOperand, layer2: MirOperand)

    # Debug
    DebugValue(local: LocalId, name: text)
    Nop

    # Async/Await Operations
    # Creates a Promise<T> from an async expression body
    CreatePromise(dest: LocalId, body: LocalId, result_type: MirType)
    # Awaits a Promise, suspending until resolved
    Await(dest: LocalId, promise: MirOperand)
    # Yields a value from a generator, suspending execution
    Yield(value: MirOperand?)
    # Spawns an async task/actor
    Spawn(dest: LocalId, handler: MirOperand, args: [MirOperand])
    # Sends a message to an actor
    Send(target: MirOperand, message: MirOperand)
    # Receives a message from mailbox (blocking with optional timeout)
    Receive(dest: LocalId, timeout: MirOperand?)

    # Borrow checking instructions
    Ref(dest: LocalId, borrow_kind: MirBorrowKind, place: MirPlace)

    # GPU Instructions
    # Kernel definition - wraps a function body as a GPU kernel
    # WORKAROUND: Parser bug with multiple params of same custom type
    # GpuKernelDef(name: text, params: [MirLocal], body_block: BlockId)
    # GpuLaunch(kernel: MirOperand, grid_dim: MirOperand, block_dim: MirOperand, args: [MirOperand])
    GpuKernelDef(name: text)
    GpuLaunch(args: [text])
    # Thread ID accessors (dim: 0=x, 1=y, 2=z)
    GpuGlobalId(dest: LocalId, dim: i64)    # Global thread ID
    GpuLocalId(dest: LocalId, dim: i64)     # Local thread ID within block
    GpuBlockId(dest: LocalId, dim: i64)     # Block/workgroup ID
    GpuBlockDim(dest: LocalId, dim: i64)    # Block dimensions
    GpuGridDim(dest: LocalId, dim: i64)     # Grid dimensions
    # Synchronization
    GpuBarrier(scope: GpuBarrierScope)      # Thread synchronization barrier
    GpuMemFence(scope: GpuMemoryScope)      # Memory fence
    # Shared memory
    GpuSharedAlloc(dest: LocalId, type_: MirType, size: i64)  # Allocate shared memory
    # Atomic operations
    GpuAtomicOp(dest: LocalId, op: GpuAtomicOpKind, ptr: MirOperand, value: MirOperand)

    # VHDL Instructions
    # Process definition with sensitivity/clocking semantics
    VhdlProcess(kind: VhdlProcessKind, body_block: BlockId)
    # Signal assignment (with optional delay in nanoseconds)
    VhdlSignalAssign(target: MirOperand, value: MirOperand, delay_ns: i64?)
    # Variable assignment (inside process, immediate)
    VhdlVarAssign(target: MirOperand, value: MirOperand)
    # Port map instantiation
    VhdlPortMap(entity: text, instance: text, connections: [(text, MirOperand)])
    # Resize signal width (zero/sign extend or truncate)
    VhdlResize(dest: LocalId, operand: MirOperand, new_width: i64, signed: bool)
    # Slice a signal (hi downto lo)
    VhdlSlice(dest: LocalId, signal: MirOperand, hi: i64, lo: i64)
    # Concatenate signals
    VhdlConcat(dest: LocalId, parts: [MirOperand])

# ============================================================================
# GPU Support Types
# ============================================================================

"""Barrier scope for GPU synchronization."""
enum GpuBarrierScope:
    Workgroup   # Synchronize threads within workgroup/block
    Device      # Synchronize all threads on device (expensive)
    Subgroup    # Synchronize threads within subgroup/warp

"""Memory scope for GPU memory fences."""
enum GpuMemoryScope:
    Workgroup   # Workgroup-level memory visibility
    Device      # Device-level memory visibility
    QueueFamily # Vulkan queue family scope
    All         # All memory (host + device)

"""Atomic operation kinds for GPU."""
enum GpuAtomicOpKind:
    Add         # Atomic add
    Sub         # Atomic subtract
    And         # Atomic bitwise and
    Or          # Atomic bitwise or
    Xor         # Atomic bitwise xor
    Min         # Atomic min
    Max         # Atomic max
    Exchange    # Atomic exchange
    CompareExchange  # Compare and exchange

# ============================================================================
# VHDL Support Types
# ============================================================================

"""VHDL process kind."""
enum VhdlProcessKind:
    Combinational(sensitivity: [text])  # Combinational process with sensitivity list
    Clocked(domain: VhdlClockDomain)    # Clocked (sequential) process
    AsyncReset(domain: VhdlClockDomain) # Asynchronous reset process

"""VHDL clock domain definition."""
struct VhdlClockDomain:
    name: text
    clock_signal: text
    reset_signal: text?
    edge: VhdlClockEdge

"""VHDL clock edge."""
enum VhdlClockEdge:
    Rising
    Falling

"""VHDL signal kind."""
enum VhdlSignalKind:
    Wire        # Combinational signal
    Register    # Registered signal (flip-flop)
    Latch       # Latch-inferred signal (usually an error)
    Constant    # Constant signal
    Port(dir: VhdlPortDirection)  # Port signal

"""VHDL port direction."""
enum VhdlPortDirection:
    In
    Out
    InOut
    Buffer

"""VHDL signal resolution."""
enum VhdlSignalResolution:
    Unresolved  # bit/bit_vector (single driver)
    Resolved    # std_logic/std_logic_vector (multi-driver)

"""VHDL numeric kind for type-safe width tracking."""
enum VhdlNumericKind:
    Signed(width: i64)
    Unsigned(width: i64)
    Integer(lo: i64, hi: i64)
    Natural
    Positive

# ============================================================================
# Borrow Checking Support Types
# ============================================================================

"""Borrow kind for borrow checking."""
enum MirBorrowKind:
    Shared      # &T - immutable borrow
    Mutable     # &mut T - exclusive mutable borrow

"""Place projection for borrow checking."""
enum MirProjection:
    Deref               # *place
    Field(idx: i64)     # place.field_idx
    Index(local: LocalId) # place[idx_local]
    Downcast(variant: i64) # place as Variant

"""Memory place for borrow checking."""
struct MirPlace:
    local: LocalId
    projection: [MirProjection]

impl MirPlace:
    static fn local_place(id: LocalId) -> MirPlace:
        """Create a place referring to a local variable."""
        MirPlace(local: id, projection: [])

    fn deref() -> MirPlace:
        """Add a dereference projection."""
        MirPlace(local: self.local, projection: self.projection.push(MirProjection.Deref))

    fn field(idx: i64) -> MirPlace:
        """Add a field projection."""
        MirPlace(local: self.local, projection: self.projection.push(MirProjection.Field(idx)))

    fn index(local: LocalId) -> MirPlace:
        """Add an index projection."""
        MirPlace(local: self.local, projection: self.projection.push(MirProjection.Index(local)))

    fn downcast(variant: i64) -> MirPlace:
        """Add a downcast projection."""
        MirPlace(local: self.local, projection: self.projection.push(MirProjection.Downcast(variant)))

    fn to_text() -> text:
        """Convert place to text representation."""
        var result = "_l{self.local.id}"
        for proj in self.projection:
            match proj:
                case Deref: result = "(*{result})"
                case Field(idx): result = "{result}.{idx}"
                case Index(local): result = "{result}[_l{local.id}]"
                case Downcast(variant): result = "{result} as v{variant}"
        result

# ============================================================================
# Operations and Operands
# ============================================================================

"""Binary operation."""
enum MirBinOp:
    # Arithmetic
    Add, Sub, Mul, Div, Rem
    Pow                         # **
    # Matrix operations
    MatMul                      # @
    # Bitwise
    BitAnd, BitOr, BitXor, Shl, Shr
    # Comparison
    Eq, Ne, Lt, Le, Gt, Ge
    # Broadcast operations (dotted operators)
    BroadcastAdd                # .+
    BroadcastSub                # .-
    BroadcastMul                # .*
    BroadcastDiv                # ./
    BroadcastPow                # .^
    # Offset
    Offset  # Pointer arithmetic

"""Unary operation."""
enum MirUnaryOp:
    Neg
    Not
    BitNot
    Transpose   # ' (postfix, m{} only)

"""Aggregate construction kind."""
enum AggregateKind:
    Array(type_: MirType)
    Tuple
    Struct(symbol: SymbolId)
    Enum(symbol: SymbolId, variant: i64)

struct MirOperand:
    """Instruction operand."""
    kind: MirOperandKind

"""Operand kind."""
enum MirOperandKind:
    Copy(local: LocalId)
    Move(local: LocalId)
    Const(value: MirConstValue, type_: MirType)

# Free functions for MirOperand construction (workaround for bootstrap)
fn mir_operand_copy(local: LocalId) -> MirOperand:
    MirOperand(kind: MirOperandKind.Copy(local))

fn mir_operand_move(local: LocalId) -> MirOperand:
    MirOperand(kind: MirOperandKind.Move(local))

fn mir_operand_const_int(value: i64) -> MirOperand:
    MirOperand(kind: MirOperandKind.Const(MirConstValue.Int(value), MirType.i64()))

fn mir_operand_const_float(value: f64) -> MirOperand:
    MirOperand(kind: MirOperandKind.Const(MirConstValue.Float(value), MirType.f64()))

fn mir_operand_const_bool(value: bool) -> MirOperand:
    MirOperand(kind: MirOperandKind.Const(MirConstValue.Bool(value), MirType.bool()))

impl MirOperand:
    static fn copy(local: LocalId) -> MirOperand:
        mir_operand_copy(local)

    static fn move(local: LocalId) -> MirOperand:
        mir_operand_move(local)

    static fn const_int(value: i64) -> MirOperand:
        mir_operand_const_int(value)

    static fn const_float(value: f64) -> MirOperand:
        mir_operand_const_float(value)

    static fn const_bool(value: bool) -> MirOperand:
        mir_operand_const_bool(value)

# ============================================================================
# MIR Terminators
# ============================================================================

"""Switch case mapping a constant value to a target block."""
struct SwitchCase:
    value: i64
    target: BlockId

"""Inline assembly operand."""
struct MirAsmOperand:
    """Assembly operand (input/output) with constraint information."""
    name: text                  # Operand name (e.g., "op", "result")
    kind: AsmConstraintKind     # in, out, inout, lateout
    location: AsmLocation       # reg, mem, imm, specific register
    operand: MirOperand         # MIR operand for the value

"""Block terminator."""
enum MirTerminator:
    # Unconditional
    Goto(target: BlockId)
    Return(value: MirOperand?)

    # Conditional
    If(cond: MirOperand, then_: BlockId, else_: BlockId)
    Switch(value: MirOperand, targets: [SwitchCase], default: BlockId)

    # Exceptional
    Unreachable
    Abort(message: text)

    # Call terminators (for unwinding)
    CallTerminator(
        dest: LocalId?,
        func: MirOperand,
        args: [MirOperand],
        normal: BlockId,
        unwind: BlockId?
    )

# ============================================================================
# MIR Module and Function (depend on MirBlock)
# ============================================================================

struct MirModule:
    """Complete MIR module."""
    name: text
    functions: Dict<SymbolId, MirFunction>
    statics: Dict<SymbolId, MirStatic>
    constants: Dict<SymbolId, MirConstant>
    types: Dict<SymbolId, MirTypeDef>

struct MirFunction:
    """Function in MIR."""
    symbol: SymbolId
    name: text
    signature: MirSignature
    locals: [MirLocal]
    blocks: [MirBlock]
    entry_block: BlockId
    span: Span

    # Generic template metadata for .smf template storage
    generic_params: [text]
    is_generic_template: bool
    specialization_of: text?
    type_bindings: Dict<text, HirType>

    # Layout optimization metadata for native binary compilation
    layout_phase: LayoutPhase?

"""Function body wrapper for borrow checking."""
struct MirBody:
    name: text
    blocks: [MirBlock]
    locals: [MirLocal]
    arg_count: i64
    return_ty: MirType

impl MirBody:
    static fn from_function(func: MirFunction) -> MirBody:
        """Create MirBody from MirFunction for borrow checking."""
        MirBody(
            name: func.name,
            blocks: func.blocks,
            locals: func.locals,
            arg_count: func.signature.params.len(),
            return_ty: func.signature.return_type
        )

# Helper: Copy MirFunction with new blocks (workaround for no struct spread syntax)
fn copy_mir_function_with_blocks(func: MirFunction, new_blocks: [MirBlock]) -> MirFunction:
    """Create a copy of MirFunction with modified blocks field.

    Common pattern in optimization passes that transform blocks but preserve
    all other function metadata.
    """
    MirFunction(
        symbol: func.symbol,
        name: func.name,
        signature: func.signature,
        locals: func.locals,
        blocks: new_blocks,
        entry_block: func.entry_block,
        span: func.span,
        generic_params: func.generic_params,
        is_generic_template: func.is_generic_template,
        specialization_of: func.specialization_of,
        type_bindings: func.type_bindings
    )

# ============================================================================
# Exports
# ============================================================================

export BlockId, MirBlock
export MirInst, MirInstKind
export MirBinOp, MirUnaryOp, AggregateKind
export MirOperand, MirOperandKind
export mir_operand_copy, mir_operand_move, mir_operand_const_int, mir_operand_const_float, mir_operand_const_bool
export SwitchCase, MirAsmOperand
export MirTerminator
export MirModule, MirFunction
export MirBody
export copy_mir_function_with_blocks

# Borrow checking support types
export MirBorrowKind, MirPlace, MirProjection

# GPU support types
export GpuBarrierScope, GpuMemoryScope, GpuAtomicOpKind

# VHDL support types
export VhdlProcessKind, VhdlClockDomain, VhdlClockEdge
export VhdlSignalKind, VhdlPortDirection, VhdlSignalResolution, VhdlNumericKind
