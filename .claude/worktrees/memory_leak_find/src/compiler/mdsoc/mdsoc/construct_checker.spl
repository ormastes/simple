# MDSOC Construct Tier Checker
#
# Validates that construct capsule dependencies respect tier ordering.
# The construct dimension has 5 tiers (core → flow → decl → advanced → meta)
# with direction lower_to_upper: higher tiers depend on lower, not vice versa.
#
# Enforcement is warnings-only (warn_only = true) to allow iterating on
# boundaries before locking down.

use compiler.mdsoc.types.*
use compiler.mdsoc.layer_checker.{LayerViolation}


# Auto-generated desugared static method wrappers
fn ConstructLayerChecker__new(tier_def: LayerDef) -> ConstructLayerChecker:
    ConstructLayerChecker(
        tier_def: tier_def,
        construct_names: [],
        construct_tier_names: [],
        violations: [],
        warn_only: true
    )


export ConstructLayerChecker

# ============================================================================
# Construct Layer Checker
# ============================================================================

struct ConstructLayerChecker:
    """Validates tier-based dependencies between construct capsules.

    Uses LayerDef to check tier ordering. Violations are logged as
    warnings rather than hard errors (warn_only = true).
    """
    tier_def: LayerDef
    construct_names: [text]
    construct_tier_names: [text]
    violations: [LayerViolation]
    warn_only: bool

impl ConstructLayerChecker:
    static fn new(tier_def: LayerDef) -> ConstructLayerChecker:
        ConstructLayerChecker(
            tier_def: tier_def,
            construct_names: [],
            construct_tier_names: [],
            violations: [],
            warn_only: true
        )

    static fn with_default_tiers() -> ConstructLayerChecker:
        """Create checker with the standard 5-tier construct ordering.

        Tiers (lower_to_upper direction):
          core(0) -> flow(1) -> decl(2) -> advanced(3) -> meta(4)
        A construct in a higher tier can depend on lower tiers.
        """
        val order = ["core", "flow", "decl", "advanced", "meta"]
        val tier_def = LayerDef__new(order, LayerDirection.LowerToUpper)
        ConstructLayerChecker__new(tier_def)

    # -- Construct registration ----------------------------------------------

    me assign_construct_tier(construct_name: text, tier_name: text):
        """Register which tier a construct belongs to."""
        var i: i64 = 0
        for name in self.construct_names:
            if name == construct_name:
                self.construct_tier_names[i] = tier_name
                return
            i = i + 1
        self.construct_names.push(construct_name)
        self.construct_tier_names.push(tier_name)

    fn get_construct_tier(construct_name: text) -> text?:
        """Look up the tier for a construct. Returns nil if unregistered."""
        var i: i64 = 0
        for name in self.construct_names:
            if name == construct_name:
                return Some(self.construct_tier_names[i])
            i = i + 1
        nil

    # -- Dependency checking -------------------------------------------------

    fn check_construct_dep(from_construct: text, to_construct: text) -> LayerViolation?:
        """Check if from_construct can depend on to_construct.

        Returns a violation if the tier ordering is violated.
        Same-tier dependencies are allowed (allow_tier policy).
        Returns nil if allowed.
        """
        val from_tier_opt = self.get_construct_tier(from_construct)
        val to_tier_opt = self.get_construct_tier(to_construct)

        # Unregistered constructs: no constraint
        if from_tier_opt.? == false:
            return nil
        if to_tier_opt.? == false:
            return nil

        val from_tier = from_tier_opt ?? ""
        val to_tier = to_tier_opt ?? ""

        # Same-tier cycles are allowed (allow_tier policy)
        if from_tier == to_tier:
            return nil

        val allowed = self.tier_def.can_depend(from_tier, to_tier)
        if allowed:
            return nil

        val msg = self.tier_def.describe_violation(from_tier, to_tier)
        LayerViolation__new(
            from_construct, to_construct,
            from_tier, to_tier,
            msg, ""
        )

    me check_capsule_deps(capsule: ConstructCapsule):
        """Check all declared dependencies of a construct capsule.

        Records violations for any tier-order violations found.
        The capsule must be registered via assign_construct_tier first.
        """
        for dep_name in capsule.depends_on:
            val violation = self.check_construct_dep(capsule.name, dep_name)
            if violation.?:
                val v = violation ?? LayerViolation__new("", "", "", "", "", "")
                if self.warn_only:
                    # In warn_only mode, record but don't fail
                    self.violations.push(v)
                else:
                    self.violations.push(v)

    fn check_shared_consistency(binding: SharedBinding) -> [LayerViolation]:
        """Check that a shared binding's construct tags are tier-consistent.

        A shared file tagged to constructs of different tiers is allowed
        (that's the point of shared_bind), but the primary construct's tier
        must be checked for consistency with the layer_number.
        Returns list of violations (empty if consistent).
        """
        var result: [LayerViolation] = []
        val primary_tier_opt = self.get_construct_tier(binding.primary_construct)
        if primary_tier_opt.? == false:
            return result

        # Check each tag against primary for tier ordering
        for tag in binding.construct_tags:
            if tag != binding.primary_construct:
                val violation = self.check_construct_dep(tag, binding.primary_construct)
                if violation.?:
                    val v = violation ?? LayerViolation__new("", "", "", "", "", "")
                    result.push(v)
        result

    # -- Results access ------------------------------------------------------

    fn get_violations() -> [LayerViolation]:
        """Return all recorded violations."""
        self.violations

    fn has_violations() -> bool:
        self.violations.len() > 0

    fn violation_count() -> i64:
        self.violations.len()

    fn is_warn_only() -> bool:
        self.warn_only

    # -- Bulk registration from capsule list ---------------------------------

    me register_capsules(capsules: [ConstructCapsule]):
        """Register tier assignments for a list of construct capsules."""
        for cap in capsules:
            val tier_name = cap.tier.to_text()
            self.assign_construct_tier(cap.name, tier_name)

    me check_all_capsules(capsules: [ConstructCapsule]):
        """Register and check all capsules in one pass."""
        self.register_capsules(capsules)
        for cap in capsules:
            self.check_capsule_deps(cap)
