# Monomorphization Engine
#
# Creates specialized versions of generic functions, structs, and classes
# by substituting concrete type arguments. Iteratively processes pending
# specializations until all are resolved.
#
# Port of rust/compiler/src/monomorphize/engine.rs (300+ lines)

use hir_types.*
use hir_definitions.*
use monomorphize.type_subst.*

export ConcreteType, SpecializationKey, MonomorphizationTable, Monomorphizer
export specialize_function_with_types

# ============================================================================
# Concrete Types
# ============================================================================

enum ConcreteType:
    Int
    Float
    Bool
    String
    Nil
    Named(text)
    Array(ConcreteType)
    Tuple([ConcreteType])
    Dict(ConcreteType, ConcreteType)
    Function([ConcreteType], ConcreteType)
    Optional(ConcreteType)
    Specialized(text, [ConcreteType])

fn concrete_type_to_text(ty: ConcreteType) -> text:
    match ty:
        case Int: "Int"
        case Float: "Float"
        case Bool: "Bool"
        case String: "String"
        case Nil: "Nil"
        case Named(n): n
        case Array(elem): "Array_{concrete_type_to_text(elem)}"
        case Tuple(elems): "Tuple_{elems.map(\e: concrete_type_to_text(e)).join(\"_\")}"
        case Dict(k, v): "Dict_{concrete_type_to_text(k)}_{concrete_type_to_text(v)}"
        case Function(params, ret):
            "Fn_{params.map(\p: concrete_type_to_text(p)).join(\"_\")}_{concrete_type_to_text(ret)}"
        case Optional(inner): "Opt_{concrete_type_to_text(inner)}"
        case Specialized(name, args): "{name}_{args.map(\a: concrete_type_to_text(a)).join(\"_\")}"

# ============================================================================
# Specialization Key
# ============================================================================

struct SpecializationKey:
    name: text
    type_args: [ConcreteType]


# ============================================================================
# SpecializationKey Methods (was: impl SpecializationKey:)
# ============================================================================

# ============================================================================
# Monomorphization Table
# ============================================================================

class MonomorphizationTable:
    """Tracks pending and completed specializations."""
    pending_functions: [(SpecializationKey, Any)]
    pending_structs: [(SpecializationKey, Any)]
    pending_classes: [(SpecializationKey, Any)]
    specialized_functions: {text: Any}
    specialized_structs: {text: Any}
    specialized_classes: {text: Any}
    processed: [text]


# ============================================================================
# MonomorphizationTable Methods (was: impl MonomorphizationTable:)
# ============================================================================

fn monomorphizationtable_create() -> MonomorphizationTable:
        MonomorphizationTable(
            pending_functions: [], pending_structs: [], pending_classes: [],
            specialized_functions: {}, specialized_structs: {}, specialized_classes: {},
            processed: [])


fn monomorphizationtable_request_function(self: MonomorphizationTable, name: text, type_args: [ConcreteType], func: Any) -> text:
        val key = SpecializationKey(name: name, type_args: type_args)
        val mangled = key_mangled_name(key)
        if not self.processed_contains(processed, mangled):
            self.pending_functions = self.pending_functions_push(pending_functions, (key, func))
        mangled


# ============================================================================
# Monomorphizer
# ============================================================================

class Monomorphizer:
    """Monomorphization engine that creates specialized versions of generics."""
    generic_functions: {text: Any}
    generic_structs: {text: Any}
    generic_classes: {text: Any}
    table: MonomorphizationTable


# ============================================================================
# Monomorphizer Methods (was: impl Monomorphizer:)
# ============================================================================

fn monomorphizer_create() -> Monomorphizer:
        Monomorphizer(generic_functions: {}, generic_structs: {},
                      generic_classes: {}, table: monomorphizationtable_create())


fn monomorphizer_specialize_function_internal(self: Monomorphizer, key: SpecializationKey, func: Any) -> Any:
        """Specialize a single function with concrete type arguments.

        This creates a new function with:
        - Type parameters substituted with concrete types
        - Mangled name for uniqueness
        - All type references in body updated
        """
        # The func is stored as Any but should be HirFunction
        # For now, return as-is since we need proper type casting
        # The actual specialization will be done when we have proper HirFunction
        func


# ============================================================================
# Function Specialization with HirFunction
# ============================================================================

fn specialize_function_with_types(func: HirFunction, type_args: [HirType]) -> HirFunction:
    """Create a specialized version of a generic function.

    Args:
        func: The generic function to specialize
        type_args: Concrete type arguments to substitute

    Returns:
        A new HirFunction with type parameters replaced by concrete types
    """
    # Create substitution map from type parameters to concrete types
    val subst = typesubstitution_from_params(func.type_params, type_args)

    # Generate mangled name
    val mangled = generate_mangled_name(func.name, type_args)

    # Apply substitution to create specialized function
    substitute_function(func, subst, mangled)

fn generate_mangled_name(base_name: text, type_args: [HirType]) -> text:
    """Generate a unique mangled name for a specialization."""
    if not has_type_args:
        base_name
    else:
        val args_str = type_args.map(\t: mangle_type(t)).join("_")
        "{base_name}${args_str}"

fn mangle_type(ty: HirType) -> text:
    """Generate a mangling string for a type."""
    match ty.kind:
        case Int(bits, signed):
            if signed: "i{bits}" else: "u{bits}"
        case Float(bits): "f{bits}"
        case Bool: "bool"
        case Char: "char"
        case Str: "str"
        case Unit: "unit"
        case Never: "never"
        case Tuple(elems):
            val inner = elems.map(\e: mangle_type(e)).join("_")
            "tup_{inner}"
        case Array(elem, _):
            "arr_{mangle_type(elem)}"
        case Dict(k, v):
            "dict_{mangle_type(k)}_{mangle_type(v)}"
        case Optional(inner):
            "opt_{mangle_type(inner)}"
        case Named(symbol, args):
            if has_args:
                val inner = args.map(\a: mangle_type(a)).join("_")
                "T{symbol.id}_{inner}"
            else:
                "T{symbol.id}"
        case TypeParam(name, _):
            # Type params should be substituted before mangling
            "param_{name}"
        case _: "unknown"
