# AOP Debug Logger - Structured call trace logging
#
# Provides automatic function enter/exit logging with depth tracking,
# group pairing, and rich metadata (package path, class, function name, line).
#
# Activation:
#   - Env var: SIMPLE_AOP_DEBUG=1 or SIMPLE_AOP_DEBUG="parse_*" (filter pattern)
#   - Runtime: debug_log_enable() / debug_log_disable()
#
# Entries stored in a ring buffer (max 10K, trims oldest 1K on overflow).

extern fn rt_env_get(key: text) -> text
extern fn rt_time_now_unix_micros() -> i64

export DebugLogEntry
export debug_log_enter, debug_log_exit
export debug_log_enable, debug_log_disable, debug_log_clear
export debug_log_get_entries, debug_log_get_entries_since
export debug_log_get_status, debug_log_is_enabled
export debug_log_set_max_entries

# ============================================================================
# Debug Log Entry
# ============================================================================

struct DebugLogEntry:
    entry_id: i64
    group_id: i64
    parent_group_id: i64
    depth: i64
    entry_type: text          # "enter" | "exit"
    package_path: text
    class_name: text
    function_name: text
    line_number: i64
    timestamp_ms: i64
    duration_ms: i64
    params_text: text         # param names+values, e.g. 'path="/src/main.spl", mode=3'
    message: text             # custom info

# ============================================================================
# Module-level State (workaround for closure capture limitation)
# ============================================================================

var g_log_entries: [DebugLogEntry] = []
var g_log_depth = 0
var g_log_next_entry_id = 1
var g_log_next_group_id = 1
var g_log_enabled = false
var g_log_filter_pattern = "*"
var g_log_max_entries = 10000
var g_log_trim_count = 1000
var g_log_group_stack: [i64] = []   # stack of active group_ids

# ============================================================================
# Auto-init from SIMPLE_AOP_DEBUG env var
# ============================================================================

fn _auto_init():
    val env_val = rt_env_get("SIMPLE_AOP_DEBUG")
    if env_val != "" and env_val != nil:
        g_log_enabled = true
        if env_val != "1" and env_val != "true":
            g_log_filter_pattern = env_val
        else:
            g_log_filter_pattern = "*"

_auto_init()

# ============================================================================
# Core Functions
# ============================================================================

fn debug_log_enter(fn_name: text, module_path: text, class_name: text, line_num: i64, params_text: text) -> i64:
    if not g_log_enabled:
        return -1
    if not _matches_filter(fn_name, module_path):
        return -1

    val group_id = g_log_next_group_id
    g_log_next_group_id = g_log_next_group_id + 1

    var parent_gid = 0
    if g_log_group_stack.len() > 0:
        parent_gid = g_log_group_stack[g_log_group_stack.len() - 1]

    val now_ms = rt_time_now_unix_micros() / 1000

    val entry = DebugLogEntry(
        entry_id: g_log_next_entry_id,
        group_id: group_id,
        parent_group_id: parent_gid,
        depth: g_log_depth,
        entry_type: "enter",
        package_path: module_path,
        class_name: class_name,
        function_name: fn_name,
        line_number: line_num,
        timestamp_ms: now_ms,
        duration_ms: 0,
        params_text: params_text,
        message: ""
    )

    g_log_next_entry_id = g_log_next_entry_id + 1
    g_log_entries = g_log_entries + [entry]
    g_log_group_stack = g_log_group_stack + [group_id]
    g_log_depth = g_log_depth + 1

    _maybe_trim()

    group_id

fn debug_log_exit(fn_name: text, module_path: text, group_id: i64, start_time_ms: i64):
    if not g_log_enabled:
        return
    if group_id < 0:
        return

    val now_ms = rt_time_now_unix_micros() / 1000
    var dur = now_ms - start_time_ms
    if dur < 0:
        dur = 0

    # Pop from group stack
    if g_log_depth > 0:
        g_log_depth = g_log_depth - 1

    var parent_gid = 0
    if g_log_group_stack.len() > 1:
        parent_gid = g_log_group_stack[g_log_group_stack.len() - 2]

    # Remove last element from group stack
    if g_log_group_stack.len() > 0:
        var new_stack: [i64] = []
        for i in range(0, g_log_group_stack.len() - 1):
            new_stack = new_stack + [g_log_group_stack[i]]
        g_log_group_stack = new_stack

    val entry = DebugLogEntry(
        entry_id: g_log_next_entry_id,
        group_id: group_id,
        parent_group_id: parent_gid,
        depth: g_log_depth,
        entry_type: "exit",
        package_path: module_path,
        class_name: "",
        function_name: fn_name,
        line_number: 0,
        timestamp_ms: now_ms,
        duration_ms: dur,
        params_text: "",
        message: ""
    )

    g_log_next_entry_id = g_log_next_entry_id + 1
    g_log_entries = g_log_entries + [entry]

    _maybe_trim()

# ============================================================================
# Enable / Disable / Clear
# ============================================================================

fn debug_log_enable(pattern: text):
    g_log_enabled = true
    if pattern != "":
        g_log_filter_pattern = pattern
    else:
        g_log_filter_pattern = "*"

fn debug_log_disable():
    g_log_enabled = false

fn debug_log_clear():
    g_log_entries = []
    g_log_depth = 0
    g_log_next_entry_id = 1
    g_log_next_group_id = 1
    g_log_group_stack = []

fn debug_log_set_max_entries(max_count: i64):
    if max_count > 0:
        g_log_max_entries = max_count

# ============================================================================
# Query Functions
# ============================================================================

fn debug_log_get_entries() -> [DebugLogEntry]:
    g_log_entries

fn debug_log_get_entries_since(since_id: i64) -> [DebugLogEntry]:
    var result: [DebugLogEntry] = []
    for entry in g_log_entries:
        if entry.entry_id > since_id:
            result = result + [entry]
    result

fn debug_log_get_status() -> (bool, text, i64, i64):
    # Returns: (enabled, filter_pattern, entry_count, current_depth)
    (g_log_enabled, g_log_filter_pattern, g_log_entries.len(), g_log_depth)

fn debug_log_is_enabled() -> bool:
    g_log_enabled

# ============================================================================
# Internal Helpers
# ============================================================================

fn _matches_filter(fn_name: text, module_path: text) -> bool:
    if g_log_filter_pattern == "*":
        return true
    # Simple glob match: prefix*, *suffix, exact
    val pattern = g_log_filter_pattern
    if pattern.ends_with("*"):
        val prefix = pattern[0:pattern.len() - 1]
        val match_fn = fn_name.starts_with(prefix)
        val match_mod = module_path.starts_with(prefix)
        return match_fn or match_mod
    if pattern.starts_with("*"):
        val suffix = pattern[1:]
        val match_fn = fn_name.ends_with(suffix)
        val match_mod = module_path.ends_with(suffix)
        return match_fn or match_mod
    # Exact match on function name or module path
    fn_name == pattern or module_path == pattern

fn _maybe_trim():
    if g_log_entries.len() > g_log_max_entries:
        # Trim oldest entries
        var trimmed: [DebugLogEntry] = []
        val skip_count = g_log_trim_count
        for i in range(skip_count, g_log_entries.len()):
            trimmed = trimmed + [g_log_entries[i]]
        g_log_entries = trimmed
