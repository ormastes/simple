# Compilability Analysis
#
# Determines which parts of a program can compile to native code
# versus which require interpreter fallback. Walks AST and identifies
# features the codegen cannot yet handle.
#
# Port of rust/compiler/src/compilability.rs (791 lines)

export FallbackReason, CompilabilityStatus, CompilabilityAnalyzer

# ============================================================================
# Fallback Reasons
# ============================================================================

enum FallbackReason:
    """Why a construct requires interpreter fallback."""
    DynamicTypes
    CollectionOps
    CollectionLiteral
    StringOps
    GcInNogcContext
    BlockingInAsync
    ActorOps
    UserMacros
    PatternMatch
    Closure
    ObjectConstruction
    MethodCall
    FieldAccess
    Generator
    AsyncAwait
    Decorators
    TryOperator
    WithStatement
    ContextBlock
    UnknownExtern(text)
    NotYetImplemented(text)

impl FallbackReason:
    fn description() -> text:
        match self:
            case DynamicTypes: "dynamic type operations"
            case CollectionOps: "collection operations"
            case CollectionLiteral: "collection literal"
            case StringOps: "string operations"
            case GcInNogcContext: "GC allocation in nogc context"
            case BlockingInAsync: "blocking in async context"
            case ActorOps: "actor/concurrency primitives"
            case UserMacros: "user-defined macros"
            case PatternMatch: "pattern matching"
            case Closure: "lambda/closure"
            case ObjectConstruction: "object construction"
            case MethodCall: "method call"
            case FieldAccess: "field access"
            case Generator: "generator/yield"
            case AsyncAwait: "async/await"
            case Decorators: "decorators"
            case TryOperator: "try operator"
            case WithStatement: "with statement"
            case ContextBlock: "context block"
            case UnknownExtern(name): "unknown extern: {name}"
            case NotYetImplemented(feat): "not yet implemented: {feat}"

# ============================================================================
# Compilability Status
# ============================================================================

enum CompilabilityStatus:
    Compilable
    RequiresInterpreter([FallbackReason])

impl CompilabilityStatus:
    fn is_compilable() -> bool:
        match self: case Compilable: true; case _: false

    fn reasons() -> [FallbackReason]:
        match self:
            case Compilable: []
            case RequiresInterpreter(reasons): reasons

    fn merge(other: CompilabilityStatus) -> CompilabilityStatus:
        match (self, other):
            case (Compilable, Compilable): CompilabilityStatus.Compilable
            case (Compilable, RequiresInterpreter(r)): CompilabilityStatus.RequiresInterpreter(r)
            case (RequiresInterpreter(r), Compilable): CompilabilityStatus.RequiresInterpreter(r)
            case (RequiresInterpreter(a), RequiresInterpreter(b)):
                CompilabilityStatus.RequiresInterpreter(a.merge(b))

# ============================================================================
# Compilability Analyzer
# ============================================================================

class CompilabilityAnalyzer:
    """Analyzes functions for native code compilability."""
    results: {text: CompilabilityStatus}
    known_safe_externs: [text]

impl CompilabilityAnalyzer:
    static fn create() -> CompilabilityAnalyzer:
        CompilabilityAnalyzer(results: {},
            known_safe_externs: [
                "rt_print", "rt_println", "rt_eprintln",
                "rt_hash_sha256", "rt_file_exists", "rt_file_read_text",
                "rt_file_write_text", "rt_file_size", "rt_file_modified",
                "rt_time_now", "rt_env_var", "rt_exit"
            ])

    me analyze_function(name: text, features: [text]) -> CompilabilityStatus:
        """Analyze a function by its feature usage list."""
        var reasons: [FallbackReason] = []

        for feat in features:
            match feat:
                case "decorator": reasons = reasons.push(FallbackReason.Decorators)
                case "closure" | "lambda": reasons = reasons.push(FallbackReason.Closure)
                case "pattern_match": reasons = reasons.push(FallbackReason.PatternMatch)
                case "generator" | "yield": reasons = reasons.push(FallbackReason.Generator)
                case "async" | "await": reasons = reasons.push(FallbackReason.AsyncAwait)
                case "try_operator": reasons = reasons.push(FallbackReason.TryOperator)
                case "with_statement": reasons = reasons.push(FallbackReason.WithStatement)
                case "method_call": reasons = reasons.push(FallbackReason.MethodCall)
                case "field_access": reasons = reasons.push(FallbackReason.FieldAccess)
                case "object_construction": reasons = reasons.push(FallbackReason.ObjectConstruction)
                case "collection_literal": reasons = reasons.push(FallbackReason.CollectionLiteral)
                case "actor": reasons = reasons.push(FallbackReason.ActorOps)
                case "macro": reasons = reasons.push(FallbackReason.UserMacros)
                case _:
                    if feat.starts_with("extern:"):
                        val extern_name = feat[7:]
                        if not self.known_safe_externs.contains(extern_name):
                            reasons = reasons.push(FallbackReason.UnknownExtern(extern_name))

        val status = if reasons.?:
            CompilabilityStatus.RequiresInterpreter(reasons)
        else:
            CompilabilityStatus.Compilable

        self.results[name] = status
        status

    fn get_status(name: text) -> CompilabilityStatus?:
        if self.results.contains_key(name):
            Some(self.results[name])
        else:
            nil

    fn compilable_functions() -> [text]:
        var result: [text] = []
        for (name, status) in self.results:
            if status.is_compilable():
                result = result.push(name)
        result

    fn interpreter_functions() -> [text]:
        var result: [text] = []
        for (name, status) in self.results:
            if not status.is_compilable():
                result = result.push(name)
        result

    fn summary() -> (i64, i64):
        """Returns (compilable_count, interpreter_count)."""
        var c = 0
        var i = 0
        for (_, status) in self.results:
            if status.is_compilable(): c = c + 1
            else: i = i + 1
        (c, i)
