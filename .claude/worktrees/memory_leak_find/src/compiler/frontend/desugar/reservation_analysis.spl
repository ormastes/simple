# Resource Reservation Sum Analysis — Pass C
#
# Statically proves that task reservations never exceed resource capacity.
# Required for baremetal strict mode where pool.take() is infallible.
#
# Pipeline position:
#   Pass A (frame sizing) -> Pass B (spawn bounds) -> Pass C (reservation sums) -> Pass D (waiter budget)
#
# From v0.3 spec Section 5.2 / 10.5:
#   For each limited leaf R with capacity C:
#     demand = sum(T.reserve[R] * spawn_count[T]) for all tasks T
#     if demand > C: error "reservation overflow"
#
# Design decisions:
# - Reserve data provided externally (no reserve={...} parsing in this pass)
# - Uses boot_spawn_counts from Pass B as effective instance counts
# - Parallel arrays throughout (avoids Dict generics)
# - Per-task breakdown in ReservationDemand for detailed error messages

use compiler.frontend.desugar.spawn_analysis.{
    SpawnAnalysis,
    TaskInfo,
    get_boot_spawn_count
}

# ================================================================
# Constants
# ================================================================

val LEVEL_ERROR = "error"
val LEVEL_WARNING = "warning"
val LEVEL_INFO = "info"

# ================================================================
# Data Structures
# ================================================================

struct ResourceLeaf:
    """A limited resource leaf with a fixed capacity.

    Fields:
        path: Dotted path identifying the resource (e.g. "NetRes.pkt_pool")
        unit_name: Name of the unit type (e.g. "PktBuf")
        cap: Maximum number of units available
    """
    path: text
    unit_name: text
    cap: i64

struct TaskReservation:
    """Reservation requirements for a single task type.

    Fields:
        task_name: Name of the task type
        reserve_paths: Parallel array — resource paths this task reserves
        reserve_counts: Parallel array — number of units reserved per path
        instances: Effective instance count (from Pass B boot_spawn_counts)
    """
    task_name: text
    reserve_paths: [text]
    reserve_counts: [i64]
    instances: i64

struct ReservationDemand:
    """Computed demand for a single resource leaf.

    Fields:
        resource_path: Path of the resource being checked
        total_demand: Sum of (reserve * instances) across all tasks
        cap: Capacity of the resource
        overflow: True if total_demand > cap
        contributor_names: Parallel array — tasks that contribute demand
        contributor_amounts: Parallel array — demand per task
    """
    resource_path: text
    total_demand: i64
    cap: i64
    overflow: bool
    contributor_names: [text]
    contributor_amounts: [i64]

struct ReservationDiagnostic:
    """A single diagnostic from reservation verification.

    Fields:
        level: "error", "warning", or "info"
        message: Human-readable message
        resource_path: Which resource triggered this
        actual_demand: The demand that was computed
        capacity: The capacity that was exceeded
    """
    level: text
    message: text
    resource_path: text
    actual_demand: i64
    capacity: i64

struct ReservationVerifyResult:
    """Complete verification result for reservation analysis.

    Fields:
        diagnostics: All errors and warnings
        has_errors: True if any errors were found
        demands: Computed demands for all resources
        total_checks: Number of resources checked
        passed_checks: Number of resources that passed
    """
    diagnostics: [ReservationDiagnostic]
    has_errors: bool
    demands: [ReservationDemand]
    total_checks: i64
    passed_checks: i64

# ================================================================
# Core Functions
# ================================================================

fn get_task_reserve(task: TaskReservation, path: text) -> i64:
    """Look up how many units a task reserves for a given leaf path.

    Returns 0 if the task has no reservation for the given path.

    Args:
        task: The task reservation to search
        path: The resource path to look up

    Returns:
        Number of units reserved, or 0 if not found
    """
    for i in 0..task.reserve_paths.len():
        if task.reserve_paths[i] == path:
            return task.reserve_counts[i]
    0

fn compute_demand(leaf: ResourceLeaf, tasks: [TaskReservation]) -> ReservationDemand:
    """Compute total demand for a single resource leaf across all tasks.

    For each task T:
        contribution = T.reserve[leaf.path] * T.instances
    Total demand = sum of all contributions.

    Args:
        leaf: The resource leaf to check
        tasks: All task reservations

    Returns:
        ReservationDemand with per-task breakdown
    """
    var total = 0
    var names = []
    var amounts = []

    for task in tasks:
        val reserve = get_task_reserve(task, leaf.path)
        if reserve > 0:
            val contribution = reserve * task.instances
            total = total + contribution
            names = names + [task.task_name]
            amounts = amounts + [contribution]

    ReservationDemand(
        resource_path: leaf.path,
        total_demand: total,
        cap: leaf.cap,
        overflow: total > leaf.cap,
        contributor_names: names,
        contributor_amounts: amounts
    )

fn verify_reservations(
    leaves: [ResourceLeaf],
    tasks: [TaskReservation]
) -> ReservationVerifyResult:
    """Verify all resource reservations against their capacities.

    Main entry point for Pass C. For each resource leaf, computes
    total demand and checks against capacity.

    Args:
        leaves: All limited resource leaves with their capacities
        tasks: All task reservations with their instance counts

    Returns:
        ReservationVerifyResult with diagnostics for any overflows
    """
    var diagnostics = []
    var has_errors = false
    var demands = []
    var passed = 0

    for leaf in leaves:
        val demand = compute_demand(leaf, tasks)
        demands = demands + [demand]

        if demand.overflow:
            # Build contributor details
            var details = []
            for i in 0..demand.contributor_names.len():
                details = details + ["{demand.contributor_names[i]}={demand.contributor_amounts[i]}"]
            val breakdown = details.join(", ")

            val diag = ReservationDiagnostic(
                level: LEVEL_ERROR,
                message: "reservation overflow on '{leaf.path}': demand={demand.total_demand} > cap={leaf.cap} (contributors: {breakdown})",
                resource_path: leaf.path,
                actual_demand: demand.total_demand,
                capacity: leaf.cap
            )
            diagnostics = diagnostics + [diag]
            has_errors = true
        else:
            passed = passed + 1

    ReservationVerifyResult(
        diagnostics: diagnostics,
        has_errors: has_errors,
        demands: demands,
        total_checks: leaves.len(),
        passed_checks: passed
    )

# ================================================================
# Construction Helpers
# ================================================================

fn build_task_reservations_from_analysis(
    spawn_analysis: SpawnAnalysis,
    reserve_paths: [[text]],
    reserve_counts: [[i64]]
) -> [TaskReservation]:
    """Build TaskReservation list from SpawnAnalysis and external reserve data.

    Combines Pass B's task_infos and boot_spawn_counts with externally-provided
    reservation data. The reserve_paths and reserve_counts are parallel arrays
    of parallel arrays — reserve_paths[i] / reserve_counts[i] correspond to
    spawn_analysis.task_infos[i].

    Args:
        spawn_analysis: Result from Pass B
        reserve_paths: Per-task resource paths (parallel with task_infos)
        reserve_counts: Per-task reserve counts (parallel with task_infos)

    Returns:
        List of TaskReservation with boot_spawn_counts as instances
    """
    var result = []

    for i in 0..spawn_analysis.task_infos.len():
        val info = spawn_analysis.task_infos[i]
        val instances = get_boot_spawn_count(
            info.name,
            spawn_analysis.boot_spawn_names,
            spawn_analysis.boot_spawn_counts
        )

        # Get per-task reserve data (use empty if index out of bounds)
        var paths = []
        var counts = []
        if i < reserve_paths.len():
            paths = reserve_paths[i]
        if i < reserve_counts.len():
            counts = reserve_counts[i]

        val reservation = TaskReservation(
            task_name: info.name,
            reserve_paths: paths,
            reserve_counts: counts,
            instances: instances
        )
        result = result + [reservation]

    result

# ================================================================
# Formatting / Reporting
# ================================================================

fn format_demand(demand: ReservationDemand) -> text:
    """Format a single demand line with contributor breakdown.

    Args:
        demand: The demand to format

    Returns:
        Human-readable line describing demand vs capacity
    """
    var status = "OK"
    if demand.overflow:
        status = "OVERFLOW"

    var parts = []
    for i in 0..demand.contributor_names.len():
        parts = parts + ["{demand.contributor_names[i]}={demand.contributor_amounts[i]}"]
    val breakdown = parts.join(", ")

    if parts.len() > 0:
        return "  {demand.resource_path}: {demand.total_demand}/{demand.cap} [{status}] ({breakdown})"
    "  {demand.resource_path}: {demand.total_demand}/{demand.cap} [{status}]"

fn format_reservation_result(result: ReservationVerifyResult) -> text:
    """Format complete reservation verification result.

    Args:
        result: The verification result to format

    Returns:
        Human-readable multi-line report
    """
    var lines = []

    var status_str = "pass"
    if result.has_errors:
        status_str = "FAIL"
    lines = lines + ["Reservation Verification: {status_str} ({result.passed_checks}/{result.total_checks} resources OK)"]

    if result.demands.len() == 0:
        lines = lines + ["  No resources to check."]
        return lines.join("\n")

    lines = lines + ["  Resource demands:"]
    for demand in result.demands:
        lines = lines + [format_demand(demand)]

    if result.diagnostics.len() > 0:
        lines = lines + ["  Diagnostics:"]
        for diag in result.diagnostics:
            lines = lines + ["    [{diag.level}] {diag.message}"]

    lines.join("\n")

# ================================================================
# Exports
# ================================================================

export ResourceLeaf
export TaskReservation
export ReservationDemand
export ReservationDiagnostic
export ReservationVerifyResult
export LEVEL_ERROR, LEVEL_WARNING, LEVEL_INFO

export get_task_reserve
export compute_demand
export verify_reservations
export build_task_reservations_from_analysis
export format_demand
export format_reservation_result
