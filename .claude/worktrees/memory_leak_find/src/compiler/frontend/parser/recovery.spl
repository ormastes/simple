# Parser Error Recovery
#
# Detection of common mistakes from other languages, "did you mean?"
# suggestions, synchronization-based error recovery, and multi-error
# collection for better diagnostics.
#
# Port of rust/parser/src/error_recovery.rs (603 lines)

export CommonMistake, ErrorHintLevel, ErrorHint
export detect_common_mistake, RecoveryStrategy, ErrorCollector

# ============================================================================
# Common Mistakes from Other Languages
# ============================================================================

enum CommonMistake:
    # Python
    PythonDef           # def instead of fn
    PythonSelf          # self. instead of implicit self
    PythonNone          # nil instead of nil
    PythonTrue          # True instead of true
    PythonFalse         # False instead of false
    # Rust
    RustLetMut          # let mut instead of var
    RustFnMut           # fn(&mut self) instead of me fn()
    RustLifetime        # 'a not supported
    RustMacro           # macro! syntax
    RustTurbofish       # ::<T> instead of <T>
    # Java/C++
    JavaPublicClass     # public class instead of pub class
    JavaVoid            # void instead of no return type
    JavaNew             # new Type() instead of Type {}
    JavaThis            # this instead of self
    CppTemplate         # template<T> instead of <T>
    CppNamespace        # namespace instead of mod
    # TypeScript/JavaScript
    TsFunction          # function instead of fn
    TsConst             # const instead of val
    TsLet               # let instead of val
    TsInterface         # interface instead of trait
    TsArrowFunction     # => in function definition
    # C-style
    CSemicolon          # unnecessary semicolons
    CTypeFirst          # int x instead of val x: i32
    # Generic
    MissingColon        # missing : before block
    WrongBrackets       # [] instead of <> for generics
    ExplicitSelf        # (self) parameter when implicit
    MissingCommaInArgs  # func(x: 10 y: 20)
    MissingColonBeforeBlock
    MissingIndentAfterColon
    WrongIndentLevel

fn mistake_message(m: CommonMistake) -> text:
    match m:
        case PythonDef:
            "Use 'fn' to define functions in Simple, not 'def'.\n  Python:  def add(a, b):\n  Simple:  fn add(a, b):"
        case PythonSelf:
            "In Simple, 'self' is implicit in methods. Don't write 'self.'.\n  Python:  self.x = value\n  Simple:  x = value"
        case PythonNone:
            "Use 'nil' instead of 'None' in Simple.\n  Python:  return None\n  Simple:  return nil"
        case PythonTrue:
            "Use lowercase 'true' and 'false' in Simple."
        case PythonFalse:
            "Use lowercase 'true' and 'false' in Simple."
        case RustLetMut:
            "Use 'var' for mutable, 'val' for immutable.\n  Rust:    let mut x = 5;\n  Simple:  var x = 5"
        case RustFnMut:
            "Use 'me' keyword for mutable methods.\n  Rust:    fn update(&mut self) {}\n  Simple:  me update():"
        case RustLifetime:
            "Simple doesn't use lifetime annotations. Reference capabilities handle memory safety."
        case RustTurbofish:
            "Use <T> directly, not ::<T>."
        case RustMacro:
            "Simple uses '@' for macros, not '!'."
        case JavaPublicClass:
            "Use 'pub class' or 'pub struct' in Simple."
        case JavaVoid:
            "Omit return type for void functions.\n  Java:    void print(String s) {}\n  Simple:  fn print(s: text):"
        case JavaNew:
            "Use struct literal: Type(field: value) or Type { field: value }"
        case JavaThis:
            "Use 'self' (which is implicit in methods)."
        case CppTemplate:
            "Generic parameters come after the name: struct Vec<T>:"
        case CppNamespace:
            "Use 'mod' for modules instead of 'namespace'."
        case TsFunction:
            "Use 'fn' to define functions."
        case TsConst:
            "Use 'val' for immutable variables."
        case TsLet:
            "Use 'val' (immutable) or 'var' (mutable)."
        case TsInterface:
            "Use 'trait' instead of 'interface'."
        case TsArrowFunction:
            "Use ':' for function bodies, '=>' is not used.\n  Simple:  val add = \\a, b: a + b"
        case CSemicolon:
            "Semicolons are optional in Simple."
        case CTypeFirst:
            "Type comes after the name: val x: i32 = 5"
        case MissingColon:
            "Function and block definitions require ':' before the body."
        case WrongBrackets:
            "Use <> for generic types, not []."
        case ExplicitSelf:
            "'self' parameter is implicit in methods."
        case MissingCommaInArgs:
            "Missing comma between function arguments."
        case MissingColonBeforeBlock:
            "Missing colon before function body."
        case MissingIndentAfterColon:
            "Missing indentation after colon."
        case WrongIndentLevel:
            "Inconsistent indentation level."

fn mistake_suggestion(m: CommonMistake) -> text:
    match m:
        case PythonDef: "Replace 'def' with 'fn'"
        case PythonNone: "Replace 'None' with 'nil'"
        case PythonTrue: "Replace 'True' with 'true'"
        case PythonFalse: "Replace 'False' with 'false'"
        case RustLetMut: "Use 'var' instead of 'let mut'"
        case RustMacro: "Use '@' for macros instead of '!'"
        case RustFnMut: "Use 'me' keyword instead of '&mut self'"
        case JavaPublicClass: "Use 'pub class' or 'pub struct'"
        case JavaVoid: "Omit the return type"
        case JavaNew: "Use struct literal: Type(field: value)"
        case JavaThis: "Use 'self' (implicit in methods)"
        case TsFunction: "Replace 'function' with 'fn'"
        case TsConst: "Replace 'const' with 'val'"
        case TsLet: "Use 'val' or 'var'"
        case TsInterface: "Replace 'interface' with 'trait'"
        case MissingColon: "Add ':' before the body"
        case WrongBrackets: "Use <> instead of []"
        case MissingCommaInArgs: "Insert missing comma"
        case _: "See error message for details"

# ============================================================================
# Mistake Detection
# ============================================================================

# Known C-type names for CTypeFirst detection
val C_TYPE_NAMES = ["int", "uint", "float", "double", "char", "long",
                     "short", "byte", "boolean", "void", "string", "String"]

fn detect_common_mistake(current_lexeme: text, current_kind: text,
                         prev_kind: text, next_lexeme: text?) -> has_CommonMistake:
    """Detect common mistakes from other languages based on token sequence."""

    # Python: def
    if current_lexeme == "def":
        if current_kind == "Identifier":
        return CommonMistake.PythonDef

    # Python: nil (but not in case patterns, enum bodies, or after return/=)
    if current_lexeme == "None":
        if current_kind == "Identifier":
        if prev_kind != "Case" and prev_kind != "Newline" and prev_kind != "Indent"
           and prev_kind != "Return" and prev_kind != "Assign":
            return CommonMistake.PythonNone

    # Python: True/False
    if current_lexeme == "True":
        if current_kind == "Identifier":
        return CommonMistake.PythonTrue
    if current_lexeme == "False":
        if current_kind == "Identifier":
        return CommonMistake.PythonFalse

    # Rust: let mut
    if prev_kind == "Let":
        if current_lexeme == "mut" and current_kind == "Identifier":
        return CommonMistake.RustLetMut

    # Java: public class
    if current_lexeme == "public":
        if current_kind == "Identifier":
        if next_lexeme.?:
            if next_lexeme_value == "class":
            return CommonMistake.JavaPublicClass

    # Java: void (not after ->)
    if current_lexeme == "void":
        if current_kind == "Identifier" and prev_kind != "Arrow":
        return CommonMistake.JavaVoid

    # Java: this
    if current_lexeme == "this":
        if current_kind == "Identifier":
        return CommonMistake.JavaThis

    # TS: function
    if current_lexeme == "function":
        if current_kind == "Identifier":
        return CommonMistake.TsFunction

    # TS: const
    if current_lexeme == "const":
        if current_kind == "Identifier":
        return CommonMistake.TsConst

    # TS: interface
    if current_lexeme == "interface":
        if current_kind == "Identifier":
        return CommonMistake.TsInterface

    # C++: namespace
    if current_lexeme == "namespace":
        if current_kind == "Identifier":
        return CommonMistake.CppNamespace

    # C++: template
    if current_lexeme == "template":
        if current_kind == "Identifier":
        return CommonMistake.CppTemplate

    # Rust: turbofish ::<
    if current_kind == "Lt":
        if prev_kind == "DoubleColon":
        return CommonMistake.RustTurbofish

    # C-style type-first: int x
    if C_TYPE_NAMES__contains(current_lexeme):
        if current_kind == "Identifier":
        if next_lexeme.?:
            if next_lexeme_value_chars(next_lexeme_value)[0].is_lowercase():
            return CommonMistake.CTypeFirst

    nil

# ============================================================================
# Error Hints (Diagnostics)
# ============================================================================

enum ErrorHintLevel:
    Error
    Warning
    Info
    Hint

struct ErrorHint:
    level: ErrorHintLevel
    message: text
    line: i64
    column: i64
    # # DESUGARED: suggestion: text
    has_suggestion: bool
    suggestion: text
    # # DESUGARED: help: text
    has_help: bool
    help: text


# ============================================================================
# ErrorHint Methods (was: impl ErrorHint:)
# ============================================================================

fn errorhint_error(message: text, line: i64, column: i64) -> ErrorHint:
        ErrorHint(level: ErrorHintLevel.Error, message: message,
                  line: line, column: column, suggestion: nil, help: nil)


fn errorhint_warning(message: text, line: i64, column: i64) -> ErrorHint:
        ErrorHint(level: ErrorHintLevel.Warning, message: message,
                  line: line, column: column, suggestion: nil, help: nil)


# ============================================================================
# Recovery Strategy
# ============================================================================

enum RecoveryStrategy:
    """How to recover from a parse error."""
    SkipToNewline           # Skip tokens until newline (next statement)
    SkipToToken(kind: text) # Skip until specific token kind
    SkipToClosingBrace      # Skip to matching }
    InsertToken(kind: text) # Pretend token exists, continue
    PopContext              # Pop current parsing context and retry

# ============================================================================
# Error Collector (Multi-Error Support)
# ============================================================================

class ErrorCollector:
    """Collects multiple parse errors instead of stopping at the first one.

    After the first error, the parser enters recovery mode:
    it skips tokens until a synchronization point, then continues parsing.
    """
    errors: [ErrorHint]
    max_errors: i64
    in_recovery: bool


# ============================================================================
# ErrorCollector Methods (was: impl ErrorCollector:)
# ============================================================================

fn errorcollector_default() -> ErrorCollector:
        ErrorCollector(errors: [], max_errors: 50, in_recovery: false)


fn errorcollector_with_limit(max_errors: i64) -> ErrorCollector:
        ErrorCollector(errors: [], max_errors: max_errors, in_recovery: false)

