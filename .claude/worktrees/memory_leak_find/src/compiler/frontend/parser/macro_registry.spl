# Macro Registry for Parser Integration
#
# Compile-time macro registration and symbol tracking.
# Enables the parser to register introduced symbols when
# encountering macro invocations (LL(1) integration).
#
# Port of rust/parser/src/macro_registry.rs (559 lines)


# Auto-generated desugared static method wrappers
fn ConstEvalContext__empty() -> ConstEvalContext:
    ConstEvalContext(bindings: {})


export IntroducedSymbol, InjectionPoint, InjectionAnchor, InjectionCodeKind
export ConstValue, ConstEvalContext, MacroRegistry

# ============================================================================
# Introduced Symbols
# ============================================================================

enum IntroducedSymbol:
    """A symbol introduced by a macro (function, field, type, or variable)."""
    Function(name: text, params: [(text, text)], return_type: text?, source_macro: text)
    Field(name: text, type_name: text, source_macro: text)
    TypeAlias(name: text, source_macro: text)
    Variable(name: text, type_name: text, is_const: bool, source_macro: text)

fn symbol_name(sym: IntroducedSymbol) -> text:
    match sym:
        case Function(name, _, _, _): name
        case Field(name, _, _): name
        case TypeAlias(name, _): name
        case Variable(name, _, _, _): name

fn symbol_source_macro(sym: IntroducedSymbol) -> text:
    match sym:
        case Function(_, _, _, source): source
        case Field(_, _, source): source
        case TypeAlias(_, source): source
        case Variable(_, _, _, source): source

# ============================================================================
# Injection Points
# ============================================================================

enum InjectionAnchor:
    Head
    Tail
    Here

enum InjectionCodeKind:
    Stmt
    Block

struct InjectionPoint:
    source_macro: text
    label: text
    anchor: InjectionAnchor
    code_kind: InjectionCodeKind

# ============================================================================
# Const Evaluation
# ============================================================================

enum ConstValue:
    Int(i64)
    Str(text)
    Bool(bool)

impl ConstValue:
    fn as_i64() -> i64?:
        match self:
            case Int(n): Some(n)
            case _: nil

    fn as_str() -> text?:
        match self:
            case Str(s): Some(s)
            case _: nil

    fn as_bool() -> bool?:
        match self:
            case Bool(b): Some(b)
            case _: nil

    fn to_text() -> text:
        match self:
            case Int(n): "{n}"
            case Str(s): s
            case Bool(b): if b: "true" else: "false"

class ConstEvalContext:
    """Const bindings from macro arguments and loop indices."""
    bindings: {text: ConstValue}

impl ConstEvalContext:
    static fn empty() -> ConstEvalContext:
        ConstEvalContext(bindings: {})

    me bind(name: text, value: ConstValue):
        self.bindings[name] = value

    fn get(name: text) -> ConstValue?:
        if self.bindings.contains_key(name):
            Some(self.bindings[name])
        else:
            nil

    me unbind(name: text):
        self.bindings.remove(name)

# ============================================================================
# Macro Registry
# ============================================================================

struct MacroDef:
    """A macro definition (simplified representation)."""
    name: text
    params: [text]
    contract_intros: [MacroIntroDecl]
    contract_injects: [MacroInjectDecl]

struct MacroIntroDecl:
    """An intro declaration from a macro contract."""
    kind: text          # "fn", "field", "type", "var", "const"
    name_pattern: text  # may contain interpolation like "{name}_handler"
    type_pattern: text?

struct MacroInjectDecl:
    """An inject declaration from a macro contract."""
    label: text
    anchor: InjectionAnchor
    code_kind: InjectionCodeKind

class MacroRegistry:
    """Registry for macro definitions and introduced symbols.

    Used by the parser for LL(1) macro integration:
    - When a macro is defined, it's registered here
    - When invoked, its contract is processed to register symbols
    - Introduced symbols are available for name resolution and IDE completion
    """
    macros: {text: MacroDef}
    introduced_symbols: {text: [IntroducedSymbol]}  # scope -> symbols
    pending_injections: [InjectionPoint]
    ll1_mode: bool

impl MacroRegistry:
    static fn default() -> MacroRegistry:
        MacroRegistry(macros: {}, introduced_symbols: {},
                      pending_injections: [], ll1_mode: false)

    static fn with_ll1_mode() -> MacroRegistry:
        MacroRegistry(macros: {}, introduced_symbols: {},
                      pending_injections: [], ll1_mode: true)

    fn is_ll1_mode() -> bool:
        self.ll1_mode

    me set_ll1_mode(enabled: bool):
        self.ll1_mode = enabled

    me register_macro(macro_def: MacroDef):
        self.macros[macro_def.name] = macro_def

    fn get_macro(name: text) -> MacroDef?:
        if self.macros.contains_key(name):
            Some(self.macros[name])
        else:
            nil

    fn has_macro(name: text) -> bool:
        self.macros.contains_key(name)

    fn macro_names() -> [text]:
        self.macros.keys()

    me process_macro_invocation(macro_name: text, const_args: {text: ConstValue},
                                scope: text) -> Result<[IntroducedSymbol], text>:
        """Process a macro invocation's contract to register introduced symbols."""
        if not self.macros.contains_key(macro_name):
            return Err("Macro '{macro_name}' not defined")

        val macro_def = self.macros[macro_name]
        var ctx = ConstEvalContext__empty()

        # Add const args to context
        for (name, value) in const_args:
            ctx.bind(name, value)

        var introduced: [IntroducedSymbol] = []

        # Process intro declarations
        for intro in macro_def.contract_intros:
            val name = expand_name_pattern(intro.name_pattern, ctx)

            val sym = match intro.kind:
                case "fn":
                    IntroducedSymbol.Function(name: name, params: [],
                        return_type: intro.type_pattern, source_macro: macro_name)
                case "field":
                    IntroducedSymbol.Field(name: name,
                        type_name: intro.type_pattern ?? "unknown",
                        source_macro: macro_name)
                case "type":
                    IntroducedSymbol.TypeAlias(name: name, source_macro: macro_name)
                case "var":
                    IntroducedSymbol.Variable(name: name,
                        type_name: intro.type_pattern ?? "unknown",
                        is_const: false, source_macro: macro_name)
                case "const":
                    IntroducedSymbol.Variable(name: name,
                        type_name: intro.type_pattern ?? "unknown",
                        is_const: true, source_macro: macro_name)
                case _:
                    IntroducedSymbol.Variable(name: name,
                        type_name: "unknown", is_const: false,
                        source_macro: macro_name)

            introduced = introduced.push(sym)

        # Process inject declarations
        for inject in macro_def.contract_injects:
            self.pending_injections = self.pending_injections.push(
                InjectionPoint(source_macro: macro_name, label: inject.label,
                               anchor: inject.anchor, code_kind: inject.code_kind))

        # Store introduced symbols in scope
        if not self.introduced_symbols.contains_key(scope):
            self.introduced_symbols[scope] = []
        self.introduced_symbols[scope] = self.introduced_symbols[scope].merge(introduced)

        Ok(introduced)

    fn get_symbols_in_scope(scope: text) -> [IntroducedSymbol]:
        if self.introduced_symbols.contains_key(scope):
            self.introduced_symbols[scope]
        else:
            []

    fn lookup_symbol(name: text, scope: text) -> IntroducedSymbol?:
        val symbols = self.get_symbols_in_scope(scope)
        for sym in symbols:
            if symbol_name(sym) == name:
                return Some(sym)
        nil

    me take_pending_injections() -> [InjectionPoint]:
        val result = self.pending_injections
        self.pending_injections = []
        result

    me clear_scope(scope: text):
        self.introduced_symbols.remove(scope)

fn expand_name_pattern(pattern: text, ctx: ConstEvalContext) -> text:
    """Expand interpolation in name patterns like '{name}_handler'."""
    var result = pattern
    var start = result.find("{")
    while start.?:
        val idx = start.unwrap()
        val end = result[idx:].find("}")
        if end.?:
            val key = result[idx + 1:idx + end.unwrap()]
            val value = ctx.get(key)
            if value.?:
                result = result[:idx] + value.unwrap().to_text() + result[idx + end.unwrap() + 1:]
            else:
                break
            start = result.find("{")
        else:
            break
    result
