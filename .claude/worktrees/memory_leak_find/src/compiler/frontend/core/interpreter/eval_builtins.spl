# Core Interpreter — Builtin Function Evaluation
#
# Split from eval.spl. Contains:
# - eval_builtin_call: Dispatches built-in function calls (print, int, type_of, len, etc.)
# - __traits introspection built-in: fields, has_member, enum_members, is_struct, etc.
# - __mixin: compile-time code generation
# - @static_assert: compile-time assertions
#
# All evaluation returns a value_id (i64). Errors indicated by -1 (VAL_NONE).
# Returns -2 if the name is not a recognized builtin.

# ===== Builtin Functions =====
# Returns >= -1 if handled (value_id or -1 for error), returns -2 if not a builtin

fn eval_builtin_call(name: text, arg_eids: [i64]) -> i64:
    if name == "print":
        if arg_eids.len() > 0:
            val arg_val = eval_expr(arg_eids[0])
            if eval_had_error: return -1
            print val_to_text(arg_val)
        else:
            print ""
        return val_make_nil()

    if name == "println":
        if arg_eids.len() > 0:
            val arg_val = eval_expr(arg_eids[0])
            if eval_had_error: return -1
            print val_to_text(arg_val)
        else:
            print ""
        return val_make_nil()

    # __mixin(code_text) — compile-time code generation
    # Parses code_text as Simple source and registers new declarations into the
    # current module's function/struct tables so they can be called immediately.
    if name == "__mixin":
        if arg_eids.len() >= 1:
            val mx_code_val = eval_expr(arg_eids[0])
            if eval_had_error: return -1
            val mx_code = val_to_text(mx_code_val)
            val mx_old_count = module_get_decls().len()
            parse_module_file(mx_code, "mixin_generated.spl")
            val mx_all_decls = module_get_decls()
            val mx_new_count = mx_all_decls.len()
            var mx_i = mx_old_count
            while mx_i < mx_new_count:
                val mx_did = mx_all_decls[mx_i]
                val mx_tag = decl_get(mx_did).tag
                if mx_tag == DECL_FN:
                    val mx_fn_name = decl_get(mx_did).name
                    func_table_register(mx_fn_name, mx_did)
                    func_register_return_type(mx_fn_name, decl_get(mx_did).ret_type)
                if mx_tag == DECL_STRUCT:
                    val mx_struct_name = decl_get(mx_did).name
                    struct_table_register(mx_struct_name, mx_did)
                mx_i = mx_i + 1
            mx_i = mx_old_count
            while mx_i < mx_new_count:
                if eval_had_error: break
                val mx_did2 = mx_all_decls[mx_i]
                val mx_tag2 = decl_get(mx_did2).tag
                if mx_tag2 == DECL_VAL or mx_tag2 == DECL_VAR or mx_tag2 == DECL_ENUM or mx_tag2 == EVAL_DECL_LAZY_VAL:
                    eval_decl(mx_did2)
                mx_i = mx_i + 1
            return val_make_nil()
        return val_make_nil()

    # pragma_msg(expr) — prints expr value at eval time (compile-time diagnostic)
    if name == "pragma_msg":
        if arg_eids.len() > 0:
            val pm_val = eval_expr(arg_eids[0])
            if eval_had_error: return -1
            print val_to_text(pm_val)
        return val_make_nil()

    if name == "int":
        if arg_eids.len() > 0:
            val arg_val = eval_expr(arg_eids[0])
            if eval_had_error: return -1
            val kind = val_get_kind(arg_val)
            if kind == VAL_INT: return arg_val
            if kind == VAL_FLOAT:
                # Truncate float to int
                return val_make_int(int(val_get_float(arg_val)))
            if kind == VAL_TEXT:
                return val_make_int(int(val_get_text(arg_val)))
            if kind == VAL_BOOL:
                if val_get_bool(arg_val): return val_make_int(1)
                return val_make_int(0)
        return val_make_int(0)

    if name == "type_of":
        if arg_eids.len() > 0:
            val arg_val = eval_expr(arg_eids[0])
            if eval_had_error: return -1
            return val_make_text(val_kind_name(val_get_kind(arg_val)))
        return val_make_text("nil")

    if name == "len":
        if arg_eids.len() > 0:
            val arg_val = eval_expr(arg_eids[0])
            if eval_had_error: return -1
            val kind = val_get_kind(arg_val)
            if kind == VAL_ARRAY: return val_make_int(val_get_array(arg_val).len())
            if kind == VAL_TEXT: return val_make_int(val_get_text(arg_val).len())
        return val_make_int(0)

    if name == "to_text":
        if arg_eids.len() > 0:
            val arg_val = eval_expr(arg_eids[0])
            if eval_had_error: return -1
            return val_make_text(val_to_text(arg_val))
        return val_make_text("")

    # Annotation intrinsic: @static_assert(condition, message)
    # Evaluates condition at module load time; panics if false
    if name == "@static_assert":
        if arg_eids.len() >= 2:
            val sa_cond = eval_expr(arg_eids[0])
            if eval_had_error: return -1
            if val_is_truthy(sa_cond) == false:
                val sa_msg_val = eval_expr(arg_eids[1])
                if eval_had_error: return -1
                val sa_msg = val_to_text(sa_msg_val)
                eval_set_error("static_assert failed: " + sa_msg)
                return -1
        elif arg_eids.len() == 1:
            val sa_cond2 = eval_expr(arg_eids[0])
            if eval_had_error: return -1
            if val_is_truthy(sa_cond2) == false:
                eval_set_error("static_assert failed")
                return -1
        return val_make_nil()

    # @traits(query, T, ...) — compile-time introspection built-in
    if name == "__traits":
        if arg_eids.len() < 1:
            return val_make_array([])
        val tr_query_val = eval_expr(arg_eids[0])
        if eval_had_error: return -1
        val tr_query = val_to_text(tr_query_val)

        # @traits("fields", "TypeName") — returns [text] of field names
        if tr_query == "fields":
            if arg_eids.len() >= 2:
                val tr_type_val = eval_expr(arg_eids[1])
                if eval_had_error: return -1
                val tr_type_name = val_to_text(tr_type_val)
                val tr_struct_decl = struct_table_lookup(tr_type_name)
                if tr_struct_decl >= 0:
                    val tr_field_names = decl_get_fields(tr_struct_decl)
                    var tr_result: [i64] = []
                    for tr_fname in tr_field_names:
                        tr_result.push(val_make_text(tr_fname))
                    return val_make_array(tr_result)
            return val_make_array([])

        # @traits("has_member", "TypeName", "fieldName") — bool
        if tr_query == "has_member":
            if arg_eids.len() >= 3:
                val tr_type_val2 = eval_expr(arg_eids[1])
                if eval_had_error: return -1
                val tr_member_val = eval_expr(arg_eids[2])
                if eval_had_error: return -1
                val tr_type_name2 = val_to_text(tr_type_val2)
                val tr_member_name = val_to_text(tr_member_val)
                val tr_struct_decl2 = struct_table_lookup(tr_type_name2)
                if tr_struct_decl2 >= 0:
                    val tr_fields2 = decl_get_fields(tr_struct_decl2)
                    for tr_f2 in tr_fields2:
                        if tr_f2 == tr_member_name:
                            return val_make_bool(true)
                return val_make_bool(false)
            return val_make_bool(false)

        # @traits("enum_members", "EnumName") — returns [text] of variant names
        if tr_query == "enum_members":
            if arg_eids.len() >= 2:
                val tr_enum_type_val = eval_expr(arg_eids[1])
                if eval_had_error: return -1
                val tr_enum_name = val_to_text(tr_enum_type_val)
                val tr_variants_csv = enum_table_lookup(tr_enum_name)
                if tr_variants_csv != "":
                    var tr_enum_result: [i64] = []
                    var tr_vi = 0
                    var tr_vstart = 0
                    while tr_vi <= tr_variants_csv.len():
                        val tr_at_end = tr_vi == tr_variants_csv.len()
                        var tr_is_comma = false
                        if tr_at_end == false:
                            val tr_ch = tr_variants_csv[tr_vi:tr_vi+1]
                            tr_is_comma = tr_ch == ","
                        val tr_split = tr_at_end or tr_is_comma
                        if tr_split:
                            if tr_vi > tr_vstart:
                                val tr_variant = tr_variants_csv[tr_vstart:tr_vi]
                                tr_enum_result.push(val_make_text(tr_variant))
                            tr_vstart = tr_vi + 1
                        tr_vi = tr_vi + 1
                    return val_make_array(tr_enum_result)
            return val_make_array([])

        # @traits("is_struct", "TypeName") — bool
        if tr_query == "is_struct":
            if arg_eids.len() >= 2:
                val tr_is_type_val = eval_expr(arg_eids[1])
                if eval_had_error: return -1
                val tr_is_type_name = val_to_text(tr_is_type_val)
                val tr_is_struct_decl = struct_table_lookup(tr_is_type_name)
                return val_make_bool(tr_is_struct_decl >= 0)
            return val_make_bool(false)

        # @traits("is_enum", "TypeName") — bool
        if tr_query == "is_enum":
            if arg_eids.len() >= 2:
                val tr_ie_type_val = eval_expr(arg_eids[1])
                if eval_had_error: return -1
                val tr_ie_type_name = val_to_text(tr_ie_type_val)
                val tr_ie_variants = enum_table_lookup(tr_ie_type_name)
                return val_make_bool(tr_ie_variants != "")
            return val_make_bool(false)

        # @traits("is_phantom", "TypeName") — bool: true if struct is registered as phantom
        if tr_query == "is_phantom":
            if arg_eids.len() >= 2:
                val tr_ip_type_val = eval_expr(arg_eids[1])
                if eval_had_error: return -1
                val tr_ip_type_name = val_to_text(tr_ip_type_val)
                return val_make_bool(phantom_struct_is_registered(tr_ip_type_name))
            return val_make_bool(false)

        # @traits("get_member", obj, "fieldName") — value of field by name
        if tr_query == "get_member":
            if arg_eids.len() >= 3:
                val tr_gm_obj = eval_expr(arg_eids[1])
                if eval_had_error: return -1
                val tr_gm_field_val = eval_expr(arg_eids[2])
                if eval_had_error: return -1
                val tr_gm_field = val_to_text(tr_gm_field_val)
                val tr_gm_fields = val_get_struct_fields(tr_gm_obj)
                val tr_gm_values = val_get_struct_values(tr_gm_obj)
                var tr_gm_i = 0
                for tr_gm_f in tr_gm_fields:
                    if tr_gm_f == tr_gm_field:
                        if tr_gm_i < tr_gm_values.len():
                            return tr_gm_values[tr_gm_i]
                    tr_gm_i = tr_gm_i + 1
            return val_make_nil()

        # @traits("type_name", "TypeName") — returns type name as text
        if tr_query == "type_name":
            if arg_eids.len() >= 2:
                val tr_tn_val = eval_expr(arg_eids[1])
                if eval_had_error: return -1
                return val_make_text(val_to_text(tr_tn_val))
            return val_make_text("unknown")

        # @traits("file"), @traits("line"), @traits("function") — source location
        if tr_query == "file":
            return val_make_text(module_get_path())
        if tr_query == "line":
            return val_make_int(1)
        if tr_query == "function":
            if eval_current_decl_id >= 0:
                val tr_fn_node = decl_get(eval_current_decl_id)
                return val_make_text(tr_fn_node.name)
            return val_make_text("<module>")

        # @static_assert(cond, msg) — compile-time assertion
        # Desugared by parser to __traits("static_assert", cond, msg)
        if tr_query == "static_assert":
            if arg_eids.len() >= 3:
                val sa_tr_cond = eval_expr(arg_eids[1])
                if eval_had_error: return -1
                if val_is_truthy(sa_tr_cond) == false:
                    val sa_tr_msg_val = eval_expr(arg_eids[2])
                    if eval_had_error: return -1
                    val sa_tr_msg = val_to_text(sa_tr_msg_val)
                    eval_set_error("static_assert failed: " + sa_tr_msg)
                    return -1
            elif arg_eids.len() == 2:
                val sa_tr_cond2 = eval_expr(arg_eids[1])
                if eval_had_error: return -1
                if val_is_truthy(sa_tr_cond2) == false:
                    eval_set_error("static_assert failed")
                    return -1
            return val_make_nil()

        # @traits("methods", "TypeName") — return method names for a struct type
        # Methods are registered in func_table as "TypeName__methodName"
        if tr_query == "methods":
            if arg_eids.len() >= 2:
                val tr_mth_type_val = eval_expr(arg_eids[1])
                if eval_had_error: return -1
                val tr_mth_type_name = val_to_text(tr_mth_type_val)
                val tr_mth_prefix = tr_mth_type_name + "__"
                val tr_mth_prefix_len = tr_mth_prefix.len()
                var tr_mth_result: [i64] = []
                for tr_mth_key in ft_keys:
                    if tr_mth_key.len() > tr_mth_prefix_len:
                        val tr_mth_kpfx = tr_mth_key[0:tr_mth_prefix_len]
                        if tr_mth_kpfx == tr_mth_prefix:
                            val tr_mth_mname = tr_mth_key[tr_mth_prefix_len:tr_mth_key.len()]
                            tr_mth_result.push(val_make_text(tr_mth_mname))
                return val_make_array(tr_mth_result)
            return val_make_array([])

        # @traits("all_members", "TypeName") — fields + methods combined
        if tr_query == "all_members":
            if arg_eids.len() >= 2:
                val tr_am_type_val = eval_expr(arg_eids[1])
                if eval_had_error: return -1
                val tr_am_type_name = val_to_text(tr_am_type_val)
                var tr_am_result: [i64] = []
                # Add fields
                val tr_am_struct_decl = struct_table_lookup(tr_am_type_name)
                if tr_am_struct_decl >= 0:
                    val tr_am_field_names = decl_get_fields(tr_am_struct_decl)
                    for tr_am_fname in tr_am_field_names:
                        tr_am_result.push(val_make_text(tr_am_fname))
                # Add methods
                val tr_am_prefix = tr_am_type_name + "__"
                val tr_am_prefix_len = tr_am_prefix.len()
                for tr_am_key in ft_keys:
                    if tr_am_key.len() > tr_am_prefix_len:
                        val tr_am_kpfx = tr_am_key[0:tr_am_prefix_len]
                        if tr_am_kpfx == tr_am_prefix:
                            val tr_am_mname = tr_am_key[tr_am_prefix_len:tr_am_key.len()]
                            tr_am_result.push(val_make_text(tr_am_mname))
                return val_make_array(tr_am_result)
            return val_make_array([])

        # @traits("enum_count", "EnumName") — count of enum variants
        if tr_query == "enum_count":
            if arg_eids.len() >= 2:
                val tr_ec_type_val = eval_expr(arg_eids[1])
                if eval_had_error: return -1
                val tr_ec_type_name = val_to_text(tr_ec_type_val)
                val tr_ec_variants_csv = enum_table_lookup(tr_ec_type_name)
                if tr_ec_variants_csv == "":
                    return val_make_int(0)
                var tr_ec_count = 1
                var tr_ec_i = 0
                while tr_ec_i < tr_ec_variants_csv.len():
                    val tr_ec_ch = tr_ec_variants_csv[tr_ec_i:tr_ec_i+1]
                    if tr_ec_ch == ",":
                        tr_ec_count = tr_ec_count + 1
                    tr_ec_i = tr_ec_i + 1
                return val_make_int(tr_ec_count)
            return val_make_int(0)

        # @traits("is_class", "TypeName") — true if type has struct decl AND registered methods
        if tr_query == "is_class":
            if arg_eids.len() >= 2:
                val tr_ic_type_val = eval_expr(arg_eids[1])
                if eval_had_error: return -1
                val tr_ic_type_name = val_to_text(tr_ic_type_val)
                val tr_ic_struct_decl = struct_table_lookup(tr_ic_type_name)
                if tr_ic_struct_decl < 0:
                    return val_make_bool(false)
                val tr_ic_prefix = tr_ic_type_name + "__"
                val tr_ic_prefix_len = tr_ic_prefix.len()
                for tr_ic_key in ft_keys:
                    if tr_ic_key.len() > tr_ic_prefix_len:
                        val tr_ic_kpfx = tr_ic_key[0:tr_ic_prefix_len]
                        if tr_ic_kpfx == tr_ic_prefix:
                            return val_make_bool(true)
                return val_make_bool(false)
            return val_make_bool(false)

        # @traits("is_fn", "funcName") — true if function name exists in func_table
        if tr_query == "is_fn":
            if arg_eids.len() >= 2:
                val tr_if_val = eval_expr(arg_eids[1])
                if eval_had_error: return -1
                val tr_if_name = val_to_text(tr_if_val)
                val tr_if_decl = func_table_lookup(tr_if_name)
                return val_make_bool(tr_if_decl >= 0)
            return val_make_bool(false)

        # @traits("is_integral", "typeName") — true if integral numeric type
        if tr_query == "is_integral":
            if arg_eids.len() >= 2:
                val tr_ii_val = eval_expr(arg_eids[1])
                if eval_had_error: return -1
                val tr_ii_name = val_to_text(tr_ii_val)
                if tr_ii_name == "i64": return val_make_bool(true)
                if tr_ii_name == "i32": return val_make_bool(true)
                if tr_ii_name == "i16": return val_make_bool(true)
                if tr_ii_name == "i8": return val_make_bool(true)
                if tr_ii_name == "u64": return val_make_bool(true)
                if tr_ii_name == "u32": return val_make_bool(true)
                if tr_ii_name == "u16": return val_make_bool(true)
                if tr_ii_name == "u8": return val_make_bool(true)
                if tr_ii_name == "isize": return val_make_bool(true)
                if tr_ii_name == "usize": return val_make_bool(true)
                return val_make_bool(false)
            return val_make_bool(false)

        # @traits("is_float", "typeName") — true if floating-point type
        if tr_query == "is_float":
            if arg_eids.len() >= 2:
                val tr_ifl_val = eval_expr(arg_eids[1])
                if eval_had_error: return -1
                val tr_ifl_name = val_to_text(tr_ifl_val)
                if tr_ifl_name == "f64": return val_make_bool(true)
                if tr_ifl_name == "f32": return val_make_bool(true)
                return val_make_bool(false)
            return val_make_bool(false)

        # @traits("is_numeric", "typeName") — true if integral or float
        if tr_query == "is_numeric":
            if arg_eids.len() >= 2:
                val tr_in_val = eval_expr(arg_eids[1])
                if eval_had_error: return -1
                val tr_in_name = val_to_text(tr_in_val)
                if tr_in_name == "i64": return val_make_bool(true)
                if tr_in_name == "i32": return val_make_bool(true)
                if tr_in_name == "i16": return val_make_bool(true)
                if tr_in_name == "i8": return val_make_bool(true)
                if tr_in_name == "u64": return val_make_bool(true)
                if tr_in_name == "u32": return val_make_bool(true)
                if tr_in_name == "u16": return val_make_bool(true)
                if tr_in_name == "u8": return val_make_bool(true)
                if tr_in_name == "isize": return val_make_bool(true)
                if tr_in_name == "usize": return val_make_bool(true)
                if tr_in_name == "f64": return val_make_bool(true)
                if tr_in_name == "f32": return val_make_bool(true)
                return val_make_bool(false)
            return val_make_bool(false)

        # @traits("is_array", "typeName") — true if type name starts with "["
        if tr_query == "is_array":
            if arg_eids.len() >= 2:
                val tr_ia_val = eval_expr(arg_eids[1])
                if eval_had_error: return -1
                val tr_ia_name = val_to_text(tr_ia_val)
                if tr_ia_name.len() >= 2:
                    val tr_ia_first = tr_ia_name[0:1]
                    return val_make_bool(tr_ia_first == "[")
                return val_make_bool(false)
            return val_make_bool(false)

        # @traits("is_dict", "typeName") — true if type name starts with "{"
        if tr_query == "is_dict":
            if arg_eids.len() >= 2:
                val tr_id_val = eval_expr(arg_eids[1])
                if eval_had_error: return -1
                val tr_id_name = val_to_text(tr_id_val)
                if tr_id_name.len() >= 2:
                    val tr_id_first = tr_id_name[0:1]
                    return val_make_bool(tr_id_first == "{")
                return val_make_bool(false)
            return val_make_bool(false)

        # @traits("member_type", "TypeName", "fieldName") — field type as text from struct decl
        if tr_query == "member_type":
            if arg_eids.len() >= 3:
                val tr_mt_type_val = eval_expr(arg_eids[1])
                if eval_had_error: return -1
                val tr_mt_field_val = eval_expr(arg_eids[2])
                if eval_had_error: return -1
                val tr_mt_type_name = val_to_text(tr_mt_type_val)
                val tr_mt_field_name = val_to_text(tr_mt_field_val)
                val tr_mt_struct_decl = struct_table_lookup(tr_mt_type_name)
                if tr_mt_struct_decl >= 0:
                    val tr_mt_field_names = decl_get_fields(tr_mt_struct_decl)
                    val tr_mt_field_types = decl_get_field_types(tr_mt_struct_decl)
                    var tr_mt_i = 0
                    for tr_mt_fname in tr_mt_field_names:
                        if tr_mt_fname == tr_mt_field_name:
                            if tr_mt_i < tr_mt_field_types.len():
                                return val_make_text(tr_mt_field_types[tr_mt_i])
                            return val_make_text("unknown")
                        tr_mt_i = tr_mt_i + 1
                return val_make_text("")
            return val_make_text("")

        # @traits("set_member", obj, "fieldName", value) — set struct field by name
        if tr_query == "set_member":
            if arg_eids.len() >= 4:
                val tr_sm_obj = eval_expr(arg_eids[1])
                if eval_had_error: return -1
                val tr_sm_field_val = eval_expr(arg_eids[2])
                if eval_had_error: return -1
                val tr_sm_new_val = eval_expr(arg_eids[3])
                if eval_had_error: return -1
                val tr_sm_field = val_to_text(tr_sm_field_val)
                val_struct_set_field(tr_sm_obj, tr_sm_field, tr_sm_new_val)
                return val_make_nil()
            return val_make_nil()

        # @traits("compiles", expr) — returns bool true if expr evaluates without error
        if tr_query == "compiles":
            if arg_eids.len() >= 2:
                val old_had_error = eval_had_error
                val old_error_msg = eval_error_msg
                eval_had_error = false
                eval_error_msg = ""
                val comp_eid = arg_eids[1]
                eval_expr(comp_eid)
                val compiled_ok = not eval_had_error
                eval_had_error = old_had_error
                eval_error_msg = old_error_msg
                return val_make_bool(compiled_ok)
            return val_make_bool(false)

        # @traits("get_annotations", "sym_name") — returns [text] of known annotations
        if tr_query == "get_annotations":
            if arg_eids.len() >= 2:
                val ann_sym = val_to_text(eval_expr(arg_eids[1]))
                if eval_had_error: return -1
                var ann_list: [i64] = []
                if must_use_is_registered(ann_sym):
                    ann_list.push(val_make_text("must_use"))
                return val_make_array(ann_list)
            return val_make_array([])

        # @traits("has_annotation", "sym_name", "ann_name") — returns bool
        if tr_query == "has_annotation":
            if arg_eids.len() >= 3:
                val ha_sym = val_to_text(eval_expr(arg_eids[1]))
                if eval_had_error: return -1
                val ha_ann = val_to_text(eval_expr(arg_eids[2]))
                if eval_had_error: return -1
                if ha_ann == "must_use":
                    return val_make_bool(must_use_is_registered(ha_sym))
                return val_make_bool(false)
            return val_make_bool(false)

        # @traits("module_name") — returns current module path as text
        if tr_query == "module_name":
            return val_make_text(module_get_path())

        # @traits("identifier", sym_expr) — returns the text name of a symbol
        if tr_query == "identifier":
            if arg_eids.len() >= 2:
                val id_eid = arg_eids[1]
                if expr_get(id_eid).tag == 6:
                    return val_make_text(expr_get(id_eid).s_val)
                val id_val = eval_expr(id_eid)
                if eval_had_error: return -1
                return val_make_text(val_to_text(id_val))
            return val_make_text("")

        # @traits("module_file", "dotted.module.name") → File struct
        if tr_query == "module_file":
            if arg_eids.len() >= 2:
                val mf_mod_val = eval_expr(arg_eids[1])
                if eval_had_error: return -1
                val mf_mod_name = val_to_text(mf_mod_val)
                val mf_file_path = module_get_file_path(mf_mod_name)
                val mf_exists = mf_file_path != ""
                var mf_fields: [text] = ["path", "module_name", "exists"]
                var mf_vals: [i64] = []
                mf_vals.push(val_make_text(mf_file_path))
                mf_vals.push(val_make_text(mf_mod_name))
                mf_vals.push(val_make_bool(mf_exists))
                return val_make_struct("File", mf_fields, mf_vals)
            return val_make_nil()

        # @traits("class_info", "TypeName") → Class struct
        if tr_query == "class_info":
            if arg_eids.len() >= 2:
                val ci_type_val = eval_expr(arg_eids[1])
                if eval_had_error: return -1
                val ci_type_name = val_to_text(ci_type_val)
                val ci_struct_decl = struct_table_lookup(ci_type_name)
                if ci_struct_decl < 0:
                    return val_make_nil()
                val ci_field_names = decl_get_fields(ci_struct_decl)
                var ci_fields_arr: [i64] = []
                for ci_fn in ci_field_names:
                    ci_fields_arr.push(val_make_text(ci_fn))
                val ci_prefix = ci_type_name + "__"
                val ci_prefix_len = ci_prefix.len()
                var ci_methods_arr: [i64] = []
                for ci_key in ft_keys:
                    if ci_key.len() > ci_prefix_len:
                        val ci_kpfx = ci_key[0:ci_prefix_len]
                        if ci_kpfx == ci_prefix:
                            val ci_mname = ci_key[ci_prefix_len:ci_key.len()]
                            ci_methods_arr.push(val_make_text(ci_mname))
                val ci_mod = struct_table_get_module(ci_type_name)
                val ci_file = module_get_file_path(ci_mod)
                var ci_s_fields: [text] = ["name", "module_name", "file_path", "fields", "methods", "field_count", "method_count"]
                var ci_s_vals: [i64] = []
                ci_s_vals.push(val_make_text(ci_type_name))
                ci_s_vals.push(val_make_text(ci_mod))
                ci_s_vals.push(val_make_text(ci_file))
                ci_s_vals.push(val_make_array(ci_fields_arr))
                ci_s_vals.push(val_make_array(ci_methods_arr))
                ci_s_vals.push(val_make_int(ci_field_names.len()))
                ci_s_vals.push(val_make_int(ci_methods_arr.len()))
                return val_make_struct("Class", ci_s_fields, ci_s_vals)
            return val_make_nil()

        # @traits("module_wildcard", "dotted.prefix") → [File]
        if tr_query == "module_wildcard":
            if arg_eids.len() >= 2:
                val mw_prefix_val = eval_expr(arg_eids[1])
                if eval_had_error: return -1
                val mw_prefix = val_to_text(mw_prefix_val) + "."
                var mw_result: [i64] = []
                var mw_i: i64 = 0
                for mw_path in loaded_module_paths:
                    if mw_path.starts_with(mw_prefix):
                        val mw_fp = loaded_module_file_paths[mw_i]
                        var mw_f_fields: [text] = ["path", "module_name", "exists"]
                        var mw_f_vals: [i64] = []
                        mw_f_vals.push(val_make_text(mw_fp))
                        mw_f_vals.push(val_make_text(mw_path))
                        mw_f_vals.push(val_make_bool(true))
                        mw_result.push(val_make_struct("File", mw_f_fields, mw_f_vals))
                    mw_i = mw_i + 1
                return val_make_array(mw_result)
            return val_make_array([])

        # Unknown query — return nil
        return val_make_nil()

    # Not a builtin
    -2

export eval_builtin_call
