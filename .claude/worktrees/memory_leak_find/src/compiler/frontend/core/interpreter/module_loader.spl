# Core Interpreter — Runtime Module Loader
#
# Enables runtime resolution of `use` statements without requiring symlinks.
# Mirrors compile-time module loading but operates within interpreter context.
#
# Key responsibilities:
# 1. Resolve module paths (std.string → src/lib/text.spl)
# 2. Load and parse module source files
# 3. Extract exported functions from module AST
# 4. Register functions in interpreter's function table
#
# Module Path Resolution (in order):
# 1. Local directory (relative to current file)
# 2. SIMPLE_LIB environment variable path
# 3. Fallback to src/lib/ (standard library)

use compiler.core.frontend.{core_frontend_parse_isolated}

extern fn rt_file_read_text(path: text) -> text
extern fn rt_env_get(key: text) -> text
extern fn rt_file_exists(path: text) -> i64
extern fn rt_path_join(base: text, rel: text) -> text
extern fn rt_path_dirname(path: text) -> text

# AST Declaration Tags (from ast.spl)
val DECL_FN = 1
val DECL_EXTERN_FN = 2
val DECL_STRUCT = 3
val DECL_VAL = 4
val DECL_VAR = 5
val DECL_USE = 6
val DECL_EXPORT = 7
val DECL_ENUM = 8

# Helper struct for building CoreDecl (defined in ast_types.spl)
# Since we can't use generics at runtime, we construct these manually
struct ModuleDeclInfo:
    tag: i64
    name: text
    imports: [text]
    ret_type: i64

fn make_decl_info(tag: i64, name: text, imports: [text], ret_type: i64) -> ModuleDeclInfo:
    ModuleDeclInfo(tag: tag, name: name, imports: imports, ret_type: ret_type)

fn get_decl_info(did: i64) -> ModuleDeclInfo:
    # Build ModuleDeclInfo from AST arena using accessor functions
    val tag = decl_get_tag(did)
    val name = decl_get_name(did)
    val imports = decl_get_imports(did)
    val ret_type = decl_get_ret_type(did)
    make_decl_info(tag, name, imports, ret_type)

# ===== Loaded Module Tracking =====

# Parallel arrays to track loaded modules (no generics at runtime)
var loaded_module_paths: [text] = []
var loaded_module_file_paths: [text] = []
var loaded_module_exports: [[text]] = []
# Dict for O(1) module loaded check
var loaded_module_set = {}

# ===== Deferred (Lazy) Module Tracking =====

var deferred_module_names: [text] = []
var deferred_module_files: [text] = []
var deferred_module_imports: [[text]] = []
var deferred_module_set = {}

fn register_deferred_module(name: text, current_file: text, imported_names: [text]):
    if deferred_module_set.contains_key(name):
        return
    deferred_module_names.push(name)
    deferred_module_files.push(current_file)
    deferred_module_imports.push(imported_names)
    deferred_module_set[name] = true

fn is_deferred_module(name: text) -> i64:
    if deferred_module_set.contains_key(name):
        return 1
    0

fn force_deferred_module(name: text) -> i64:
    # Find the deferred module entry and load it
    var i: i64 = 0
    for mod_name in deferred_module_names:
        if mod_name == name:
            val current_file = deferred_module_files[i]
            val imported_names = deferred_module_imports[i]
            var load_result: i64 = 0
            if imported_names.len() == 0:
                load_result = load_module(name, current_file)
            else:
                load_result = load_module_selective(name, imported_names, current_file)
            # Remove from deferred set (mark as loaded)
            deferred_module_set[name] = false
            return load_result
        i = i + 1
    0

fn try_force_any_deferred_for(symbol_name: text) -> i64:
    # Try each deferred module until symbol is found
    var i: i64 = 0
    for mod_name in deferred_module_names:
        val still_deferred = deferred_module_set[mod_name]
        if still_deferred == true:
            val ok = force_deferred_module(mod_name)
            if ok == 1:
                # Check if this module provided the symbol
                val decl_id = func_table_lookup(symbol_name)
                if decl_id >= 0:
                    return 1
        i = i + 1
    0

fn module_loader_init():
    loaded_module_paths = []
    loaded_module_file_paths = []
    loaded_module_exports = []
    loaded_module_set = {}
    deferred_module_names = []
    deferred_module_files = []
    deferred_module_imports = []
    deferred_module_set = {}
    irt_init()

fn module_is_loaded(module_path: text) -> i64:
    if loaded_module_set.contains_key(module_path):
        return 1
    0

fn module_mark_loaded(module_path: text, file_path: text, exports: [text]):
    loaded_module_paths.push(module_path)
    loaded_module_file_paths.push(file_path)
    loaded_module_exports.push(exports)
    loaded_module_set[module_path] = true

fn module_get_file_path(module_name: text) -> text:
    var i: i64 = 0
    for path in loaded_module_paths:
        if path == module_name:
            return loaded_module_file_paths[i]
        i = i + 1
    ""

# ===== Module Path Resolution =====

extern fn rt_dir_list(path: text) -> [text]
extern fn rt_dir_exists(path: text) -> i64

fn resolve_module_path(module_name: text, current_file: text) -> text:
    # Convert dotted name to file path
    # std.string → std/text.spl
    # app.io.mod → app/io/mod.spl
    # compiler.frontend.X → compiler/10.frontend/X.spl (numbered dir support)

    var path_parts: [text] = []
    var current = ""
    var i: i64 = 0
    for char in module_name:
        if char == ".":
            if current != "":
                path_parts.push(current)
                current = ""
        else:
            current = current + char
        i = i + 1

    # Add final part
    if current != "":
        path_parts.push(current)

    # Join parts with /
    var relative_path = ""
    var pi: i64 = 0
    for part in path_parts:
        if pi > 0:
            relative_path = relative_path + "/"
        relative_path = relative_path + part
        pi = pi + 1

    relative_path = relative_path + ".spl"

    # Rewrite std/ → lib/ (std is a package alias, real code is in lib/)
    if relative_path.starts_with("std/"):
        relative_path = "lib" + relative_path.substring(3)

    # Try resolution strategies:

    # 1. Local directory (relative to current file)
    val current_dir = rt_path_dirname(current_file)
    val local_path = rt_path_join(current_dir, relative_path)
    if rt_file_exists(local_path) == 1:
        return local_path

    # 2. SIMPLE_LIB environment variable
    val simple_lib = rt_env_get("SIMPLE_LIB")
    val has_simple_lib = simple_lib != ""
    val lib_not_nil = simple_lib != nil
    val should_check_lib = has_simple_lib and lib_not_nil
    if should_check_lib:
        val lib_path = rt_path_join(simple_lib, relative_path)
        if rt_file_exists(lib_path) == 1:
            return lib_path

    # 3. Fallback to src/ directory
    val src_path = rt_path_join("src", relative_path)
    if rt_file_exists(src_path) == 1:
        return src_path

    # 4. Try lib subdirectory search (lib/*/X for use std.X / use lib.X)
    #    Default app mode is nogc_async_mut. Search order:
    #    nogc_async_mut (default) > nogc_sync_mut (sync fallback) > common > gc_async_mut > nogc_async_mut_noalloc
    if relative_path.starts_with("lib/"):
        val lib_subpath = relative_path.substring(4)
        val lib_dir = rt_path_join("src", "lib")
        val nam = rt_path_join(lib_dir, rt_path_join("nogc_async_mut", lib_subpath))
        if rt_file_exists(nam) == 1:
            return nam
        val nsm = rt_path_join(lib_dir, rt_path_join("nogc_sync_mut", lib_subpath))
        if rt_file_exists(nsm) == 1:
            return nsm
        val cm = rt_path_join(lib_dir, rt_path_join("common", lib_subpath))
        if rt_file_exists(cm) == 1:
            return cm
        val gam = rt_path_join(lib_dir, rt_path_join("gc_async_mut", lib_subpath))
        if rt_file_exists(gam) == 1:
            return gam
        val nanm = rt_path_join(lib_dir, rt_path_join("nogc_async_mut_noalloc", lib_subpath))
        if rt_file_exists(nanm) == 1:
            return nanm

    # 5. Try numbered directory resolution (NN.name pattern)
    val numbered_path = resolve_with_numbered_dirs("src", path_parts)
    if numbered_path != "":
        if rt_file_exists(numbered_path) == 1:
            return numbered_path

    # Return attempted path even if not found (will error later)
    relative_path

fn resolve_with_numbered_dirs(base: text, parts: [text]) -> text:
    """Walk path parts, resolving each segment with NN. prefix fallback."""
    var current_dir = base
    var pi: i64 = 0
    val last_idx = parts.len() - 1

    for part in parts:
        if pi < last_idx:
            # Intermediate segment — must be a directory
            val direct = rt_path_join(current_dir, part)
            if rt_dir_exists(direct) == 1:
                current_dir = direct
            else:
                # Try numbered directory
                val numbered = find_numbered_dir_interp(current_dir, part)
                if numbered != "":
                    current_dir = numbered
                else:
                    return ""
        else:
            # Last segment — try as .spl file
            val file_path = rt_path_join(current_dir, part + ".spl")
            return file_path
        pi = pi + 1
    ""

fn find_numbered_dir_interp(parent: text, segment: text) -> text:
    """Find NN.segment directory in parent. Returns path or empty string."""
    if rt_dir_exists(parent) != 1:
        return ""

    val entries = rt_dir_list(parent)
    for entry in entries:
        # Look for dot in entry name
        var dot_pos: i64 = -1
        var ci: i64 = 0
        for ch in entry:
            if ch == "." and dot_pos == -1:
                dot_pos = ci
            ci = ci + 1

        if dot_pos >= 1 and dot_pos <= 3:
            # Check if prefix is all digits
            val prefix = entry.substring(0, dot_pos)
            var all_digits = true
            for ch in prefix:
                if ch < "0" or ch > "9":
                    all_digits = false

            if all_digits:
                val name = entry.substring(dot_pos + 1)
                if name == segment:
                    val full_path = rt_path_join(parent, entry)
                    if rt_dir_exists(full_path) == 1:
                        return full_path
    ""

# ===== Module Loading =====

fn load_module_source(file_path: text) -> text:
    # Read module source file
    val source = rt_file_read_text(file_path)
    if source == nil:
        return ""
    source

fn parse_module_ast(source: text, path: text) -> i64:
    # Parse module into AST
    # Returns 1 on success, 0 on failure
    # Uses isolated core frontend path to avoid clobbering caller parse state.
    if core_frontend_parse_isolated(source, path):
        return 1
    0

fn extract_module_exports() -> [text]:
    # Extract exported function names from parsed module
    # Scans all declarations for DECL_EXPORT statements

    var exports: [text] = []
    var export_all = 0

    val decls = module_get_decls()

    # First pass: check for export statements
    for did in decls:
        val tag = decl_get_tag(did)

        if tag == DECL_EXPORT:
            # Get exported names from decl_imports field
            val names = decl_get_imports(did)
            for name in names:
                exports.push(name)

    # If no explicit exports found, export all functions
    if exports.len() == 0:
        export_all = 1

    if export_all == 1:
        for did in decls:
            val tag = decl_get_tag(did)

            if tag == DECL_FN:
                val name = decl_get_name(did)
                exports.push(name)

    exports

fn register_module_functions():
    # Register all module functions in interpreter's function table
    # This makes them available for calls

    val decls = module_get_decls()
    val mod_path = module_get_path()

    for did in decls:
        val tag = decl_get_tag(did)

        if tag == DECL_FN:
            val name = decl_get_name(did)
            val ret_type = decl_get_ret_type(did)
            func_table_register(name, did)
            func_register_return_type(name, ret_type)
            irt_track_func(mod_path, name)

        if tag == DECL_EXTERN_FN:
            val name = decl_get_name(did)
            val ret_type = decl_get_ret_type(did)
            func_register_return_type(name, ret_type)
            irt_track_func(mod_path, name)

        if tag == DECL_STRUCT:
            val name = decl_get_name(did)
            irt_track_struct(mod_path, name)

        if tag == DECL_ENUM:
            val name = decl_get_name(did)
            irt_track_enum(mod_path, name)

# ===== Public API =====

fn load_module(module_name: text, current_file: text) -> i64:
    # Load a module by name and register its exports
    # Returns 1 on success, 0 on failure

    # Check if already loaded
    if module_is_loaded(module_name) == 1:
        return 1

    # Resolve module path
    val resolved_path = resolve_module_path(module_name, current_file)

    # Load source
    val source = load_module_source(resolved_path)
    if source == "":
        return 0

    # Parse module
    val parse_ok = parse_module_ast(source, resolved_path)
    if parse_ok == 0:
        return 0

    # Begin tracking this module for selective unload
    irt_begin_module(module_name)

    # Extract exports
    val exports = extract_module_exports()

    # Register functions (also hooks into irt_track_*)
    register_module_functions()

    # Mark as loaded
    module_mark_loaded(module_name, resolved_path, exports)

    1

fn load_module_selective(module_name: text, imported_names: [text], current_file: text) -> i64:
    # Load module and verify requested names are exported
    # Returns 1 on success, 0 on failure

    # Load the module (full load)
    val load_ok = load_module(module_name, current_file)
    if load_ok == 0:
        return 0

    # Find module exports
    var module_exports: [text] = []
    var i: i64 = 0
    for path in loaded_module_paths:
        if path == module_name:
            module_exports = loaded_module_exports[i]
        i = i + 1

    # Verify all requested names are available
    # (For now, we trust the exports - full validation would require checking function table)

    1

fn interp_unload_module(module_name: text) -> i64:
    """Selectively unload a module: remove its names from tables.

    Removes all functions, structs, enums, and globals that were
    registered when this module was loaded. Also removes the module
    from the loaded-module tracking set.

    Returns the number of names removed, or 0 if module was not loaded.
    """
    if module_is_loaded(module_name) == 0:
        return 0

    # Remove all tracked names from tables
    val removed = irt_unload_module(module_name)

    # Remove from loaded-module set so it can be reloaded
    loaded_module_set[module_name] = false

    removed

export module_loader_init
export load_module, load_module_selective, interp_unload_module
export resolve_module_path, module_get_file_path
export loaded_module_paths, loaded_module_file_paths
export register_deferred_module, is_deferred_module
export force_deferred_module, try_force_any_deferred_for
