# Effects Cache
#
# Caches effect analysis results for functions and operations.
# Avoids re-analyzing unchanged functions during incremental compilation.
#
# Port of rust/compiler/src/effects_cache.rs (120+ lines)


# Auto-generated desugared static method wrappers
fn EffectCacheStats__empty() -> EffectCacheStats:
    EffectCacheStats(hits: 0, misses: 0, entries: 0)


export EffectCacheConfig, EffectCacheStats, FunctionEffectInfo, EffectCache

# ============================================================================
# Types
# ============================================================================

struct EffectCacheConfig:
    max_entries: i64
    validate_on_lookup: bool

impl EffectCacheConfig:
    static fn default_config() -> EffectCacheConfig:
        EffectCacheConfig(max_entries: 5000, validate_on_lookup: true)

struct EffectCacheStats:
    hits: i64
    misses: i64
    entries: i64

impl EffectCacheStats:
    static fn empty() -> EffectCacheStats:
        EffectCacheStats(hits: 0, misses: 0, entries: 0)

    fn hit_ratio() -> f64:
        val total = self.hits + self.misses
        if total == 0: 0.0
        else: self.hits.to_f64() / total.to_f64()

struct FunctionEffectInfo:
    """Effect analysis results for a single function."""
    name: text
    declared_effects: [text]
    derived_effects: [text]
    called_operations: [text]
    called_functions: [text]
    violations: [text]

impl FunctionEffectInfo:
    static fn empty(name: text) -> FunctionEffectInfo:
        FunctionEffectInfo(name: name, declared_effects: [], derived_effects: [],
                           called_operations: [], called_functions: [], violations: [])

    fn has_violations() -> bool:
        self.violations.?

    fn all_effects() -> [text]:
        """Combined declared and derived effects."""
        self.declared_effects.merge(self.derived_effects)

# ============================================================================
# Effect Cache
# ============================================================================

class EffectCache:
    """Caches function effect analysis results."""
    config: EffectCacheConfig
    function_cache: {text: FunctionEffectInfo}
    operation_effects: {text: [text]}    # operation -> required effects
    stats: EffectCacheStats

impl EffectCache:
    static fn create(config: EffectCacheConfig) -> EffectCache:
        EffectCache(config: config, function_cache: {},
                    operation_effects: {}, stats: EffectCacheStats__empty())

    fn lookup_function(name: text) -> FunctionEffectInfo?:
        if self.function_cache.contains_key(name):
            self.stats = EffectCacheStats(hits: self.stats.hits + 1,
                misses: self.stats.misses, entries: self.stats.entries)
            Some(self.function_cache[name])
        else:
            self.stats = EffectCacheStats(hits: self.stats.hits,
                misses: self.stats.misses + 1, entries: self.stats.entries)
            nil

    me store_function(info: FunctionEffectInfo):
        self.function_cache[info.name] = info
        self.stats = EffectCacheStats(hits: self.stats.hits,
            misses: self.stats.misses,
            entries: self.function_cache.len())

    me register_operation(operation: text, required_effects: [text]):
        self.operation_effects[operation] = required_effects

    fn get_operation_effects(operation: text) -> [text]:
        if self.operation_effects.contains_key(operation):
            self.operation_effects[operation]
        else:
            []

    me clear():
        self.function_cache = {}
        self.stats = EffectCacheStats__empty()

    fn get_stats() -> EffectCacheStats:
        self.stats
