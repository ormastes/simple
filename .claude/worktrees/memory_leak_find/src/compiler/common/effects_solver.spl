"""
Effect System - Phase 3C: Fixed-Point Solver

Iteratively infers effects until convergence. When a function calls an async
function, it becomes async too. This propagates through the call graph.

Status: Phase 3C Complete
"""

type Symbol = text

# ============================================================================
# Effect Type
# ============================================================================

enum Effect:
    Sync
    Async

    fn is_sync() -> bool:
        match self:
            case Effect.Sync: true
            case Effect.Async: false

    fn is_async() -> bool:
        not self.is_sync()

    fn combine(other: Effect) -> Effect:
        if self.is_async() or other.is_async():
            Effect.Async
        else:
            Effect.Sync

impl Effect:
    static fn combine_all(effects: [Effect]) -> Effect:
        var result = Effect.Sync
        for eff in effects:
            if eff.is_async():
                result = Effect.Async
        result

# ============================================================================
# HIR Expression (Placeholder)
# ============================================================================

enum HirExpr:
    IntLit(value: i64)
    StrLit(value: text)
    Call(func: Symbol, args: [HirExpr])
    Suspend(expr: HirExpr)
    Block(exprs: [HirExpr])

# ============================================================================
# HIR Function
# ============================================================================

class HirFunction:
    """Simplified HIR function for testing"""
    name: text
    body: HirExpr

impl HirFunction:
    static fn new(name: text, body: HirExpr) -> HirFunction:
        HirFunction(name: name, body: body)

# ============================================================================
# Effect Environment
# ============================================================================

class EffectEnv:
    data: text

impl EffectEnv:
    static fn new() -> EffectEnv:
        val env_data = {
            "effects": {},
            "builtins": {
                "http.get": Effect.Async,
                "print": Effect.Sync
            },
            "dirty_set": {}
        }
        EffectEnv(data: env_data)

    fn get_effect(sym: Symbol) -> Effect:
        val effects = self.data["effects"]
        val builtins = self.data["builtins"]

        if sym in effects:
            return effects[sym]

        if sym in builtins:
            return builtins[sym]

        Effect.Sync

    me set_effect(sym: Symbol, eff: Effect):
        val effects = self.data["effects"]
        val dirty_set = self.data["dirty_set"]
        val old_eff = self.get_effect(sym)

        if old_eff != eff:
            effects[sym] = eff
            dirty_set[sym] = true

    fn is_dirty() -> bool:
        val dirty_set = self.data["dirty_set"]
        dirty_set.len() > 0

    me clear_dirty():
        self.data["dirty_set"] = {}

# ============================================================================
# Effect Scanner
# ============================================================================

class EffectScanner:
    env: text

impl EffectScanner:
    static fn new(env) -> EffectScanner:
        EffectScanner(env: env)

    fn scan_expr(expr: HirExpr) -> Effect:
        match expr:
            case Suspend(_): Effect.Async

            case Call(func, args):
                val callee_effect = self.env.get_effect(func)
                if callee_effect.is_async():
                    return Effect.Async

                val arg_effects = []
                for arg in args:
                    arg_effects.push(self.scan_expr(arg))
                Effect__combine_all(arg_effects)

            case Block(exprs):
                val effects = []
                for e in exprs:
                    effects.push(self.scan_expr(e))
                Effect__combine_all(effects)

            case IntLit(_): Effect.Sync
            case StrLit(_): Effect.Sync

    fn scan_function(func: HirFunction) -> Effect:
        self.scan_expr(func.body)

# ============================================================================
# Fixed-Point Solver
# ============================================================================

class EffectSolver:
    """
    Iteratively infers effects until convergence

    Algorithm:
    1. Initialize all functions as Sync
    2. Repeat until no changes:
       - Scan each function body
       - Update effect in environment
       - Mark as dirty if changed
    3. Return converged environment
    """
    env: text
    scanner: text
    max_iterations: i64

impl EffectSolver:
    static fn new(env) -> EffectSolver:
        val scanner = EffectScanner__new(env)
        EffectSolver(
            env: env,
            scanner: scanner,
            max_iterations: 100
        )

    fn solve(functions: [HirFunction]) -> i64:
        """
        Run fixed-point solver

        Returns: number of iterations taken
        """
        # Initialize all functions as Sync
        for func in functions:
            self.env.set_effect(func.name, Effect.Sync)

        self.env.clear_dirty()

        # Fixed-point iteration
        var iterations = 0

        while iterations < self.max_iterations:
            iterations = iterations + 1

            # Scan each function
            for func in functions:
                val inferred_effect = self.scanner.scan_function(func)
                self.env.set_effect(func.name, inferred_effect)

            # Check if converged
            if not self.env.is_dirty():
                return iterations

            self.env.clear_dirty()

        # Max iterations reached (shouldn't happen in practice)
        iterations

    fn get_stats() -> text:
        """Get solver statistics."""
        val effects = self.env.data["effects"]
        val total = effects.len()
        var async_count = 0
        for name in effects.keys():
            val eff = effects[name]
            if eff.is_async():
                async_count = async_count + 1
        "Solver: {total} functions analyzed, {async_count} async, {total - async_count} sync ({self.max_iterations} max iterations)"

# ============================================================================
# Helper Functions
# ============================================================================

fn make_int(n: i64) -> HirExpr:
    HirExpr.IntLit(value: n)

fn make_str(s: text) -> HirExpr:
    HirExpr.StrLit(value: s)

fn make_call(func: Symbol, args: [HirExpr]) -> HirExpr:
    HirExpr.Call(func: func, args: args)

fn make_suspend(expr: HirExpr) -> HirExpr:
    HirExpr.Suspend(expr: expr)

fn make_block(exprs: [HirExpr]) -> HirExpr:
    HirExpr.Block(exprs: exprs)

fn make_func(name: text, body: HirExpr) -> HirFunction:
    HirFunction__new(name, body)

# ============================================================================
# Tests
# ============================================================================

fn test_single_function():
    """Test solver on single function"""
    val env = EffectEnv__new()
    val solver = EffectSolver__new(env)

    # Sync function
    val sync_func = make_func("sync_fn", make_int(42))
    val functions = [sync_func]

    val iterations = solver.solve(functions)

    assert env.get_effect("sync_fn") == Effect.Sync, "Sync function"
    assert iterations == 1, "Converged in 1 iteration"

    print "âœ… Single sync function"

fn test_async_function():
    """Test solver on async function (suspension operator)"""
    val env = EffectEnv__new()
    val solver = EffectSolver__new(env)

    # Async function with suspension
    val async_body = make_suspend(make_int(42))
    val async_func = make_func("async_fn", async_body)

    val iterations = solver.solve([async_func])

    assert env.get_effect("async_fn") == Effect.Async, "Async function"
    assert iterations == 1, "Converged in 1 iteration"

    print "âœ… Single async function"

fn test_call_chain():
    """Test effect propagation through call chain"""
    val env = EffectEnv__new()
    val solver = EffectSolver__new(env)

    # leaf: calls http.get (async builtin)
    val leaf_body = make_call("http.get", [make_str("url")])
    val leaf_func = make_func("leaf", leaf_body)

    # middle: calls leaf
    val middle_body = make_call("leaf", [])
    val middle_func = make_func("middle", middle_body)

    # top: calls middle
    val top_body = make_call("middle", [])
    val top_func = make_func("top", top_body)

    val functions = [leaf_func, middle_func, top_func]
    val iterations = solver.solve(functions)

    # All should be async (propagated through call chain)
    assert env.get_effect("leaf") == Effect.Async, "leaf is async"
    assert env.get_effect("middle") == Effect.Async, "middle is async"
    assert env.get_effect("top") == Effect.Async, "top is async"

    # Should converge in 3 iterations:
    # Iter 1: leaf becomes async
    # Iter 2: middle becomes async (sees leaf is async)
    # Iter 3: top becomes async (sees middle is async)
    # Iter 4: no changes â†’ converged
    assert iterations <= 4, "Converged in â‰¤4 iterations"

    print "âœ… Effect propagates through call chain"

fn test_mixed_functions():
    """Test mix of sync and async functions"""
    val env = EffectEnv__new()
    val solver = EffectSolver__new(env)

    # Sync function
    val sync_func = make_func("sync_fn", make_int(42))

    # Async function
    val async_body = make_call("http.get", [make_str("url")])
    val async_func = make_func("async_fn", async_body)

    # Sync caller (calls sync function)
    val sync_caller_body = make_call("sync_fn", [])
    val sync_caller = make_func("sync_caller", sync_caller_body)

    val functions = [sync_func, async_func, sync_caller]
    val iterations = solver.solve(functions)

    assert env.get_effect("sync_fn") == Effect.Sync, "sync_fn stays sync"
    assert env.get_effect("async_fn") == Effect.Async, "async_fn is async"
    assert env.get_effect("sync_caller") == Effect.Sync, "sync_caller stays sync"

    print "âœ… Mixed sync/async functions"

fn test_convergence():
    """Test that solver converges (no infinite loops)"""
    val env = EffectEnv__new()
    val solver = EffectSolver__new(env)

    # Create 10 functions calling each other
    var functions = []
    var i = 0
    while i < 10:
        val name = "func_{i}"
        val body = if i == 0:
            make_call("http.get", [make_str("url")])
        else:
            val prev = "func_{i - 1}"
            make_call(prev, [])

        functions.push(make_func(name, body))
        i = i + 1

    val iterations = solver.solve(functions)

    # All should be async (effect propagates from func_0)
    i = 0
    while i < 10:
        val name = "func_{i}"
        assert env.get_effect(name) == Effect.Async, "{name} is async"
        i = i + 1

    # Should converge in â‰¤11 iterations (10 propagations + 1 stable check)
    assert iterations <= 11, "Converged in â‰¤11 iterations"

    print "âœ… Solver converges on large call chain"

fn main():
    print ""
    print "Fixed-Point Solver Tests"
    print "========================"

    test_single_function()
    test_async_function()
    test_call_chain()
    test_mixed_functions()
    test_convergence()

    print ""
    print "ðŸŽ‰ Phase 3C Complete!"
    print ""
    print "Fixed-Point Solver implemented:"
    print "  âœ… Iterative effect inference"
    print "  âœ… Effect propagation through call chains"
    print "  âœ… Convergence detection"
    print "  âœ… Handles mixed sync/async functions"
    print "  âœ… Max iteration safety (100)"
    print ""
    print "Effect System Progress:"
    print "  Phase 3A: Effect enum (5h) âœ…"
    print "  Phase 3B: EffectEnv + Scanner (6h) âœ…"
    print "  Phase 3C: Fixed-Point Solver (5h) âœ…"
    print "  Phase 3D: Promise Wrapping (4h) - Next"
    print ""
    print "Total: 16/20 hours complete (80%)"


# Auto-generated desugared static method wrappers
fn EffectSolver__new(env) -> EffectSolver:
    val scanner = EffectScanner__new(env)
    EffectSolver(
        env: env,
        scanner: scanner,
        max_iterations: 100
    )

