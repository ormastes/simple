# Visibility and Export Model
#
# Implements the visibility and export rules verified in:
# verification/visibility_export/src/VisibilityExport.lean
#
# Proven Properties (Lean theorems):
# 1. private_stays_private: A private symbol cannot become public
# 2. private_module_restricts: A symbol in a private module cannot become public
# 3. must_be_exported: A symbol must be explicitly exported to be visible externally
# 4. meet_comm, meet_assoc: Visibility meet is commutative and associative
# 5. any_private_means_private: If any ancestor is private, result is private
# 6. all_public_means_public: All public ancestors means public result
#
# Key Properties:
# 1. Visibility is the **intersection** of declaration visibility and ancestor visibility
# 2. A directory's public API consists only of:
#    - Child modules declared as `pub mod` in its `__init__.spl`
#    - Symbols listed in `export use` inside that same `__init__.spl`
# 3. Nothing inside a child `.spl` file can make itself "more public" than its directory allows

# Visibility of a declaration or module
#
# Extends Lean: `inductive Visibility | pub | priv` with Internal and Package levels.
#
# Ordering: Public > Internal > Package > Private
# - Public:   Visible everywhere
# - Internal: Visible to same package + declared friends
# - Package:  Visible to same package only
# - Private:  Visible to same file only
enum Visibility:
    Public
    Internal
    Package
    Private

impl Visibility:
    # Check if this visibility is public
    fn is_public() -> bool:
        match self:
            case Visibility.Public:
                true
            case _:
                false

    # Check if this visibility is private
    fn is_private() -> bool:
        match self:
            case Visibility.Private:
                true
            case _:
                false

    # Check if this visibility is internal (friend-accessible)
    fn is_internal() -> bool:
        match self:
            case Visibility.Internal:
                true
            case _:
                false

    # Check if this visibility is package-only
    fn is_package() -> bool:
        match self:
            case Visibility.Package:
                true
            case _:
                false

    # Numeric rank for comparison (higher = more visible)
    fn rank() -> i64:
        match self:
            case Visibility.Public:
                3
            case Visibility.Internal:
                2
            case Visibility.Package:
                1
            case Visibility.Private:
                0

    # Convert to string for debugging
    fn to_string() -> text:
        match self:
            case Visibility.Public:
                "Public"
            case Visibility.Internal:
                "Internal"
            case Visibility.Package:
                "Package"
            case Visibility.Private:
                "Private"

    # Short marker for display (P/F/I/-)
    fn marker() -> text:
        match self:
            case Visibility.Public:
                "P"
            case Visibility.Internal:
                "F"
            case Visibility.Package:
                "I"
            case Visibility.Private:
                "-"

# A symbol identifier
#
# Corresponds to Lean: `structure SymbolId where name : String`
struct SymbolId:
    name: text

impl SymbolId:
    # Create a new symbol identifier
    static fn new(name: text) -> SymbolId:
        SymbolId(name: name)

    # Get the symbol name
    fn name() -> text:
        self.name

    # Check if two symbol IDs are equal
    fn equals(other: SymbolId) -> bool:
        self.name == other.name

# A symbol with visibility
#
# Corresponds to Lean: `structure Symbol where id : SymbolId; visibility : Visibility`
struct Symbol:
    id: SymbolId
    visibility: Visibility

impl Symbol:
    # Create a new symbol
    static fn new(name: text, visibility: Visibility) -> Symbol:
        Symbol(id: SymbolId__new(name), visibility: visibility)

    # Create a public symbol
    static fn pub_symbol(name: text) -> Symbol:
        Symbol__new(name, Visibility.Public)

    # Create a private symbol
    static fn priv_symbol(name: text) -> Symbol:
        Symbol__new(name, Visibility.Private)

    # Get the symbol ID
    fn get_id() -> SymbolId:
        self.id

    # Get the visibility
    fn get_visibility() -> Visibility:
        self.visibility

# A module declaration in __init__.spl
#
# Corresponds to Lean: `structure ModDecl where name : String; isPub : Bool`
struct ModDecl:
    name: text
    is_pub: bool

impl ModDecl:
    # Create a new module declaration
    static fn new(name: text, is_pub: bool) -> ModDecl:
        ModDecl(name: name, is_pub: is_pub)

    # Create a public module declaration
    static fn pub_decl(name: text) -> ModDecl:
        ModDecl__new(name, true)

    # Create a private module declaration
    static fn priv_decl(name: text) -> ModDecl:
        ModDecl__new(name, false)

    # Get the module name
    fn name() -> text:
        self.name

    # Check if the module is public
    fn is_pub() -> bool:
        self.is_pub

# A directory manifest (__init__.spl)
#
# Extends Lean: `structure DirManifest` with friend declarations and internal exports.
struct DirManifest:
    name: text
    children: [ModDecl]
    exports: [SymbolId]
    friends: [text]              # Friend package names (from `friend <pkg>` declarations)
    internal_exports: [SymbolId] # Symbols visible to friends (from `internal_export`)

impl DirManifest:
    # Create a new directory manifest
    static fn new(name: text) -> DirManifest:
        DirManifest(name: name, children: [], exports: [], friends: [], internal_exports: [])

    # Check if a child module is declared public in the manifest
    #
    # Corresponds to Lean: `def DirManifest.isChildPublic`
    fn is_child_public(child_name: text) -> bool:
        for decl in self.children:
            if decl.name() == child_name and decl.is_pub():
                return true
        false

    # Check if a symbol is explicitly exported
    #
    # Corresponds to Lean: `def DirManifest.isExported`
    fn is_exported(sym: SymbolId) -> bool:
        for exported in self.exports:
            if exported.equals(sym):
                return true
        false

    # Add a child module declaration
    me add_child(decl: ModDecl):
        self.children.push(decl)

    # Add an export
    me add_export(sym: SymbolId):
        self.exports.push(sym)

    # Add a friend package
    me add_friend(package_name: text):
        self.friends.push(package_name)

    # Add an internal export (friend-visible symbol)
    me add_internal_export(sym: SymbolId):
        self.internal_exports.push(sym)

    # Check if a package is declared as a friend
    fn is_friend(package_name: text) -> bool:
        for f in self.friends:
            if f == package_name:
                return true
        false

    # Check if a symbol is internally exported (friend-visible)
    fn is_internal_export(sym: SymbolId) -> bool:
        for ie in self.internal_exports:
            if ie.equals(sym):
                return true
        false

# Module contents: symbols defined in a module file
#
# Corresponds to Lean: `structure ModuleContents where symbols : List Symbol`
struct ModuleContents:
    symbols: [Symbol]

impl ModuleContents:
    # Create a new empty module contents
    static fn new() -> ModuleContents:
        ModuleContents(symbols: [])

    # Add a symbol to the module
    me add_symbol(symbol: Symbol):
        self.symbols.push(symbol)

    # Get visibility of a symbol from module contents
    #
    # Corresponds to Lean: `def ModuleContents.symbolVisibility`
    fn symbol_visibility(sym: SymbolId) -> Visibility?:
        for symbol in self.symbols:
            if symbol.get_id().equals(sym):
                return Some(symbol.get_visibility())
        nil

# Effective visibility combines declaration visibility with directory control
#
# A symbol is externally visible only if:
# 1. It is declared `pub` in its module
# 2. Its module is declared `pub mod` in the directory's __init__.spl
# 3. It's in the export list
#
# Corresponds to Lean: `def effectiveVisibility`
fn effective_visibility(
    manifest: DirManifest,
    module_name: text,
    mc: ModuleContents,
    sym: SymbolId
) -> Visibility:
    match mc.symbol_visibility(sym):
        case nil:
            # Symbol not found
            Visibility.Private
        case Some(Visibility.Private):
            # Declaration is private
            Visibility.Private
        case Some(Visibility.Public):
            # Symbol is declared public; check if directory allows export
            if manifest.is_child_public(module_name):
                if manifest.is_exported(sym):
                    Visibility.Public
                else:
                    Visibility.Private  # Not in export list
            else:
                Visibility.Private  # Module not public

# Visibility meet operation (intersection)
#
# Extends Lean: `def visibilityMeet` to handle 4-level visibility.
#
# Returns the more restrictive (lower rank) of two visibility levels.
# Ordering: Public(3) > Internal(2) > Package(1) > Private(0)
fn visibility_meet(v1: Visibility, v2: Visibility) -> Visibility:
    if v1.rank() <= v2.rank():
        v1
    else:
        v2

# Ancestor visibility through a path
#
# Corresponds to Lean: `def ancestorVisibility (path : List Visibility) : Visibility`
#
# This computes the effective visibility by folding visibility_meet over the path
fn ancestor_visibility(path: [Visibility]) -> Visibility:
    var result = Visibility.Public
    for v in path:
        result = visibility_meet(result, v)
    result

# Access policy for a directory
#
# Determines how external code can access contents of a directory:
# - Open: No __init__.spl present; all public files are freely accessible
# - Boundary: __init__.spl present; only exported symbols are accessible
# - Bypass: __init__.spl with #[bypass]; directory is transparent (pass-through)
enum AccessPolicy:
    Open
    Boundary
    Bypass

impl AccessPolicy:
    fn to_string() -> text:
        match self:
            case AccessPolicy.Open:
                "Open"
            case AccessPolicy.Boundary:
                "Boundary"
            case AccessPolicy.Bypass:
                "Bypass"

    fn is_open() -> bool:
        match self:
            case AccessPolicy.Open:
                true
            case AccessPolicy.Boundary:
                false
            case AccessPolicy.Bypass:
                false

    fn is_boundary() -> bool:
        match self:
            case AccessPolicy.Open:
                false
            case AccessPolicy.Boundary:
                true
            case AccessPolicy.Bypass:
                false

    fn is_bypass() -> bool:
        match self:
            case AccessPolicy.Open:
                false
            case AccessPolicy.Boundary:
                false
            case AccessPolicy.Bypass:
                true

# Determine the access policy for a directory
#
# Rules:
# - No __init__.spl → Open (freely accessible)
# - __init__.spl with #[bypass] → Bypass (transparent)
# - __init__.spl without #[bypass] → Boundary (exports only)
fn effective_access_policy(has_init: bool, is_bypass: bool) -> AccessPolicy:
    if not has_init:
        AccessPolicy.Open
    elif is_bypass:
        AccessPolicy.Bypass
    else:
        AccessPolicy.Boundary

# Check if access to a symbol through a path is allowed
#
# When traversing from root to a target symbol, each directory along the path
# is checked. If a directory has Boundary policy, the symbol must be exported
# by that directory's __init__.spl. Open and Bypass directories allow pass-through.
#
# Returns true if access is allowed.
fn check_access(
    manifest: DirManifest,
    policy: AccessPolicy,
    sym: SymbolId
) -> bool:
    match policy:
        case AccessPolicy.Open:
            true
        case AccessPolicy.Bypass:
            true
        case AccessPolicy.Boundary:
            manifest.is_exported(sym)

# Check if access to a symbol is allowed considering friend relationships.
#
# caller_package: the package of the code attempting access
# target_manifest: the DirManifest of the package containing the symbol
# sym: the symbol being accessed
# sym_visibility: the declared visibility of the symbol
#
# Returns true if access is allowed.
fn check_friend_access(
    caller_package: text,
    target_manifest: DirManifest,
    sym: SymbolId,
    sym_visibility: Visibility
) -> bool:
    match sym_visibility:
        case Visibility.Public:
            # Public symbols are always accessible
            true
        case Visibility.Internal:
            # Internal symbols are accessible by same package or friends
            if caller_package == target_manifest.name:
                return true
            # Check if caller is a declared friend
            if target_manifest.is_friend(caller_package):
                # Also check that the symbol is internally exported
                return target_manifest.is_internal_export(sym) or target_manifest.is_exported(sym)
            false
        case Visibility.Package:
            # Package symbols are only accessible within the same package
            caller_package == target_manifest.name
        case Visibility.Private:
            # Private symbols are never accessible from outside
            false

# Extract the layer number from a numbered directory name.
# Returns -1 if the directory name does not match NN.name pattern.
fn extract_layer_number(dir_name: text) -> i64:
    var dot_pos: i64 = -1
    var i: i64 = 0
    for ch in dir_name:
        if ch == "." and dot_pos == -1:
            dot_pos = i
        i = i + 1

    if dot_pos < 1 or dot_pos > 3:
        return -1

    val prefix = dir_name.substring(0, dot_pos)
    var all_digits = true
    for ch in prefix:
        if ch < "0" or ch > "9":
            all_digits = false

    if not all_digits:
        return -1

    # Parse numeric prefix
    var num: i64 = 0
    for ch in prefix:
        num = num * 10 + (ch.to_i64() - "0".to_i64())
    num

# Public exports

# Auto-generated desugared static method wrappers
fn DirManifest__new(name: text) -> DirManifest:
        DirManifest(name: name, children: [], exports: [], friends: [], internal_exports: [])

    # Check if a child module is declared public in the manifest
    #
    # Corresponds to Lean: `def DirManifest.isChildPublic`

fn ModDecl__new(name: text, is_pub: bool) -> ModDecl:
        ModDecl(name: name, is_pub: is_pub)

    # Create a public module declaration

fn Symbol__new(name: text, visibility: Visibility) -> Symbol:
        Symbol(id: SymbolId__new(name), visibility: visibility)

    # Create a public symbol

fn SymbolId__new(name: text) -> SymbolId:
        SymbolId(name: name)

    # Get the symbol name

export Visibility
export SymbolId
export Symbol
export ModDecl
export DirManifest
export ModuleContents
export effective_visibility
export visibility_meet
export ancestor_visibility
export AccessPolicy
export effective_access_policy
export check_access
export check_friend_access
export extract_layer_number
