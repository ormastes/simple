# Debug Coordinator
# Routes debug commands to the appropriate backend based on target type.

use compiler.core.*
use app.mcp.session.{SessionManager, TargetType, SessionState}

# DebugBackend trait - all backends implement this interface
trait DebugBackend:
    fn name() -> String
    fn attach(program_path: String, args: [String]) -> Result<Nil, String>
    fn detach() -> Result<Nil, String>
    fn run() -> Result<Nil, String>
    fn pause() -> Result<Nil, String>
    fn resume() -> Result<Nil, String>
    fn step_over() -> Result<Nil, String>
    fn step_in() -> Result<Nil, String>
    fn step_out() -> Result<Nil, String>
    fn add_breakpoint(file: String, line: Int) -> Result<Int, String>
    fn remove_breakpoint(file: String, line: Int) -> Result<Nil, String>
    fn stack_trace() -> Result<[FrameInfo], String>
    fn locals() -> Result<[VarInfo], String>
    fn evaluate(expr: String) -> Result<String, String>
    fn current_location() -> Result<LocationInfo, String>

# Frame info returned by stack trace
class FrameInfo:
    index: Int
    function_name: String
    file: String
    line: Int
    column: Int

    static fn of(index: Int, function_name: String, file: String, line: Int) -> FrameInfo:
        FrameInfo(
            index: index,
            function_name: function_name,
            file: file,
            line: line,
            column: 0
        )

# Variable info returned by locals inspection
class VarInfo:
    name: String
    value: String
    type_name: String

    static fn of(name: String, value: String, type_name: String) -> VarInfo:
        VarInfo(name: name, value: value, type_name: type_name)

# Current location info
class LocationInfo:
    file: String
    line: Int
    column: Int
    function_name: String

    static fn at(file: String, line: Int, function_name: String) -> LocationInfo:
        LocationInfo(file: file, line: line, column: 0, function_name: function_name)

# Debug Coordinator - routes commands to the correct backend
class DebugCoordinator:
    session_manager: SessionManager
    interpreter_backend: Option<DebugBackend>
    smf_backend: Option<DebugBackend>
    native_backend: Option<DebugBackend>
    remote_backend: Option<DebugBackend>

    static fn with_session_manager(sm: SessionManager) -> DebugCoordinator:
        DebugCoordinator(
            session_manager: sm,
            interpreter_backend: nil,
            smf_backend: nil,
            native_backend: nil,
            remote_backend: nil
        )

impl DebugCoordinator:
    # Register a backend
    me register_interpreter(backend: DebugBackend):
        self.interpreter_backend = Some(backend)

    me register_smf(backend: DebugBackend):
        self.smf_backend = Some(backend)

    me register_native(backend: DebugBackend):
        self.native_backend = Some(backend)

    me register_remote(backend: DebugBackend):
        self.remote_backend = Some(backend)

    # Get the backend for a session
    fn get_backend(session_id: String) -> Result<DebugBackend, String>:
        match self.session_manager.get_session(session_id):
            case Some(session):
                match session.target_type:
                    case TargetType.Interpreter:
                        match self.interpreter_backend:
                            case Some(b): Ok(b)
                            case nil: Err("Interpreter backend not registered")
                    case TargetType.Smf:
                        match self.smf_backend:
                            case Some(b): Ok(b)
                            case nil: Err("SMF backend not registered")
                    case TargetType.Native:
                        match self.native_backend:
                            case Some(b): Ok(b)
                            case nil: Err("Native backend not registered")
                    case TargetType.Remote:
                        match self.remote_backend:
                            case Some(b): Ok(b)
                            case nil: Err("Remote backend not registered")
            case nil:
                Err("Session not found: {session_id}")

    # --- Delegated debug commands ---

    me run_session(session_id: String) -> Result<Nil, String>:
        val backend = self.get_backend(session_id)?
        val session = self.session_manager.get_session(session_id).unwrap()
        backend.attach(session.program_path, session.args)?
        backend.run()?
        self.session_manager.set_state(session_id, SessionState.Running)
        Ok(nil)

    me pause_session(session_id: String) -> Result<Nil, String>:
        val backend = self.get_backend(session_id)?
        backend.pause()?
        self.session_manager.set_state(session_id, SessionState.Paused)
        Ok(nil)

    me resume_session(session_id: String) -> Result<Nil, String>:
        val backend = self.get_backend(session_id)?
        backend.resume()?
        self.session_manager.set_state(session_id, SessionState.Running)
        Ok(nil)

    fn step_over_session(session_id: String) -> Result<Nil, String>:
        val backend = self.get_backend(session_id)?
        backend.step_over()

    fn step_in_session(session_id: String) -> Result<Nil, String>:
        val backend = self.get_backend(session_id)?
        backend.step_in()

    fn step_out_session(session_id: String) -> Result<Nil, String>:
        val backend = self.get_backend(session_id)?
        backend.step_out()

    me add_breakpoint_session(session_id: String, file: String, line: Int) -> Result<Int, String>:
        val backend = self.get_backend(session_id)?
        val bp_id = backend.add_breakpoint(file, line)?
        self.session_manager.add_breakpoint(session_id, file, line)
        Ok(bp_id)

    fn remove_breakpoint_session(session_id: String, file: String, line: Int) -> Result<Nil, String>:
        val backend = self.get_backend(session_id)?
        backend.remove_breakpoint(file, line)

    fn stack_trace_session(session_id: String) -> Result<[FrameInfo], String>:
        val backend = self.get_backend(session_id)?
        backend.stack_trace()

    fn locals_session(session_id: String) -> Result<[VarInfo], String>:
        val backend = self.get_backend(session_id)?
        backend.locals()

    fn evaluate_session(session_id: String, expr: String) -> Result<String, String>:
        val backend = self.get_backend(session_id)?
        backend.evaluate(expr)

    fn location_session(session_id: String) -> Result<LocationInfo, String>:
        val backend = self.get_backend(session_id)?
        backend.current_location()

    me terminate_session(session_id: String) -> Result<Nil, String>:
        val backend = self.get_backend(session_id)?
        backend.detach()?
        self.session_manager.set_state(session_id, SessionState.Terminated)
        Ok(nil)
