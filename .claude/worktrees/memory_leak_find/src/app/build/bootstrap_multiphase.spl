# TESTING: Move critical enums to top of file
enum BuildProfile:
    Debug
    Release
    Bootstrap

enum PipelineStage:
    Check
    Bootstrap
    Build
    Seed
    Core1
    Core2
    Full1
    Full2

# Multi-Phase Bootstrap Pipeline (Seed Compiler Path)
#
# Phase implementations (1-4 + interpreter fallback) are in bootstrap_phases.spl
#
# Builds the Simple compiler from source using the seed C++ transpiler,
# producing working native binaries through a 4-phase chain:
#
#   Phase 0: Prerequisites check (seed_cpp, clang++, runtime libs)
#   Phase 1 (Core1): seed_cpp transpiles compiler → C++ → clang++ → native
#   Phase 2 (Core2): Core1 recompiles compiler (reproducibility check)
#   Phase 3 (Full1): Core2 compiles the full compiler
#   Phase 4 (Full2): Full1 recompiles itself (reproducibility check)
#
# The seed compiler (seed_cpp) is a minimal C++ program that reads Core Simple
# source and emits C++ code, which is then compiled with clang++ and linked
# against the Simple runtime library and startup CRT.
#
# Key insight: seed_cpp handles forward declarations via two-pass compilation
# (collects all struct/fn signatures first, then emits bodies), so file
# ordering only needs to avoid putting main.spl before its dependencies.

use app.io.mod (file_exists, file_size_raw, file_copy, file_delete, dir_create,
                  dir_walk, file_hash_sha256, shell, shell_bool, shell_output_trimmed,
                  time_now_unix_micros, file_read_text)

# Bootstrap phase
enum BootstrapPhase:
    Phase0    # Prerequisites check
    Phase1    # Core1: seed_cpp → C++ → clang → native
    Phase2    # Core2: Core1 recompiles compiler
    Phase3    # Full1: Core2 compiles full compiler
    Phase4    # Full2: Full1 recompiles itself (reproducibility)

# Compilation backend
enum CompilationBackend:
    SeedCpp     # seed_cpp → C++ → clang++ (bootstrap)
    Native      # Self-hosted compiler → C → clang (later phases)
    Interpreter # Fallback: interpreter verification

# Multi-phase bootstrap configuration
struct MultiphaseConfig:
    profile: BuildProfile
    verify_reproducibility: bool    # Core1==Core2 and Full1==Full2 check
    keep_artifacts: bool            # Keep intermediate binaries
    workspace_root: text
    output_dir: text
    seed_cpp_path: text             # Path to seed_cpp binary
    clang_path: text                # Path to clang++
    runtime_lib: text               # Path to libspl_runtime.a
    crt_lib: text                   # Path to libspl_crt_linux_x86_64.a
    compiler_dir: text         # Path to src/compiler/
    seed_include_dir: text          # Path to src/runtime/ (for runtime.h)

# Phase result
struct PhaseResult:
    phase: BootstrapPhase
    success: bool
    binary_path: text
    binary_size: i64
    compile_duration_ms: i64
    hash: text
    backend: CompilationBackend

impl PhaseResult:
    fn summary() -> text:
        val status = if self.success: "OK" else: "FAIL"
        val backend_name = backend_to_string(self.backend)
        "{status} Phase {phase_name(self.phase)}: {self.binary_size} bytes, {self.compile_duration_ms}ms ({backend_name})"

# Multi-phase bootstrap result
struct MultiphaseResult:
    phase0: PhaseResult
    phase1: PhaseResult
    phase2: PhaseResult
    phase3: PhaseResult
    phase4: PhaseResult
    verified: bool
    overall_success: bool

impl MultiphaseResult:
    fn summary() -> text:
        var lines = [
            self.phase0.summary(),
            self.phase1.summary(),
            self.phase2.summary(),
            self.phase3.summary()
        ]

        if self.phase4.success:
            lines = lines + [self.phase4.summary()]

        if self.verified:
            lines = lines + ["OK Verification: reproducible builds confirmed"]
        else:
            lines = lines + ["FAIL Verification: builds not reproducible"]

        lines.join("\n")

# ============================================================================
# File Discovery and Ordering
# ============================================================================

# Discover all .spl files in a directory recursively
fn discover_spl_files(dir: text) -> [text]:
    val all_files = dir_walk(dir)
    var spl_files: [text] = []
    for f in all_files:
        if f.ends_with(".spl"):
            spl_files.push(f)
    spl_files

# Extract module names from use statements in a source file
fn extract_deps_from_file(file_path: text) -> [text]:
    val source = file_read_text(file_path)
    if source == nil:
        return []
    var deps: [text] = []
    val lines = source.split("\n")
    for line in lines:
        val trimmed = line.trim()
        if trimmed.starts_with("use "):
            val rest = trimmed.substring(4).trim()
            # Extract the module path (before any parentheses or braces)
            var mod_path = rest
            val paren_idx = rest.index_of("(") ?? -1
            if paren_idx >= 0:
                mod_path = rest.substring(0, paren_idx).trim()
            val brace_idx = rest.index_of("{") ?? -1
            if brace_idx >= 0:
                val candidate = rest.substring(0, brace_idx).trim()
                if candidate.len() < mod_path.len():
                    mod_path = candidate
            if mod_path.ends_with("."):
                mod_path = mod_path.substring(0, mod_path.len() - 1)
            if mod_path.ends_with("*"):
                continue
            if mod_path.len() > 0:
                deps.push(mod_path)
    deps

# Convert a module path like "compiler.lexer_desugared" to a file path
fn module_to_file(mod_path: text, base_dir: text) -> text:
    # Try direct mapping: dots → slashes
    val rel = mod_path.replace(".", "/")
    val candidate = "{base_dir}/{rel}.spl"
    if file_exists(candidate):
        return candidate
    # Try as directory with __init__.spl
    val init_candidate = "{base_dir}/{rel}/__init__.spl"
    if file_exists(init_candidate):
        return init_candidate
    ""

# Build dependency-ordered file list for seed_cpp compilation
# Strategy: BFS from files with no internal deps, main.spl always last
fn build_ordered_file_list(base_dir: text) -> [text]:
    val all_files = discover_spl_files(base_dir)
    var main_file = ""
    var init_file = ""
    var other_files: [text] = []

    for f in all_files:
        if f.ends_with("/main.spl"):
            main_file = f
        elif f.ends_with("/__init__.spl"):
            init_file = f
        else:
            other_files.push(f)

    # Simple ordering: __init__.spl first (if exists), then other files sorted,
    # then main.spl last. seed_cpp does two-pass (signatures then bodies),
    # so circular deps within compilation are handled by C++ compilation model.
    var ordered: [text] = []

    if init_file != "":
        ordered.push(init_file)

    # Sort other files for deterministic builds
    var sorted = other_files.sort()
    for f in sorted:
        ordered.push(f)

    if main_file != "":
        ordered.push(main_file)

    ordered

# ============================================================================
# Multi-phase bootstrap orchestrator
# ============================================================================

class MultiphaseBootstrap:
    # Run complete multi-phase bootstrap
    static fn run(config: MultiphaseConfig) -> MultiphaseResult:
        print "================================================================"
        print "    Multi-Phase Bootstrap Pipeline (Seed Compiler Path)"
        print "================================================================"
        print ""
        print "Strategy: seed_cpp -> C++ -> clang++ -> native binary"
        print "Chain:    Core1 -> Core2 -> Full1 -> Full2 (reproducibility)"
        print ""

        dir_create(config.output_dir, true)

        # Phase 0: Prerequisites
        print "Phase 0: Prerequisites Check"
        print "----------------------------------------------------------------"
        val phase0_result = run_phase0(config)
        print phase0_result.summary()
        print ""

        if not phase0_result.success:
            return early_exit(phase0_result)

        # Phase 1: Core1 — seed_cpp transpiles compiler
        print "Phase 1: Core1 (seed_cpp -> C++ -> clang++ -> native)"
        print "----------------------------------------------------------------"
        val phase1_result = run_phase1_seed(config)
        print phase1_result.summary()
        print ""

        if not phase1_result.success:
            print "  Phase 1 failed. Attempting interpreter fallback..."
            val fallback = run_interpreter_fallback(config)
            return early_exit_after_phase1(phase0_result, fallback)

        # Phase 2: Core2 — Core1 recompiles compiler
        print "Phase 2: Core2 (Core1 compiles compiler)"
        print "----------------------------------------------------------------"
        val phase2_result = run_phase2_core(config, phase1_result)
        print phase2_result.summary()
        print ""

        if not phase2_result.success:
            return early_exit_after_phase2(phase0_result, phase1_result, phase2_result)

        # Verify Core1 == Core2 (reproducibility)
        var core_verified = true
        if config.verify_reproducibility:
            print "Verification: Comparing Core1 and Core2"
            print "----------------------------------------------------------------"
            core_verified = verify_phases(phase1_result, phase2_result)
            if core_verified:
                print "  OK Core reproducibility verified"
            else:
                print "  WARN Core hashes differ (expected for different compilation paths)"
            print ""

        # Phase 3: Full1 — Core2 compiles the full compiler
        print "Phase 3: Full1 (Core2 compiles full compiler)"
        print "----------------------------------------------------------------"
        val phase3_result = run_phase3_full(config, phase2_result)
        print phase3_result.summary()
        print ""

        if not phase3_result.success:
            return early_exit_after_phase3(phase0_result, phase1_result, phase2_result, phase3_result)

        # Phase 4: Full2 — Full1 recompiles itself
        var phase4_result = empty_phase_result(BootstrapPhase.Phase4, CompilationBackend.Native)
        var full_verified = true
        print "Phase 4: Full2 (Full1 recompiles itself)"
        print "----------------------------------------------------------------"
        phase4_result = run_phase4_full(config, phase3_result)
        print phase4_result.summary()
        print ""

        if phase4_result.success and config.verify_reproducibility:
            print "Verification: Comparing Full1 and Full2"
            print "----------------------------------------------------------------"
            full_verified = verify_phases(phase3_result, phase4_result)
            if full_verified:
                print "  OK Full compiler reproducibility verified"
            else:
                print "  FAIL Full compiler hashes differ"
            print ""

        # Final summary
        print "================================================================"
        print "                    Bootstrap Complete"
        print "================================================================"
        print ""

        val final_binary = if phase4_result.success: phase4_result else: phase3_result
        print "Final binary:"
        print "  Path:    {final_binary.binary_path}"
        print "  Size:    {final_binary.binary_size} bytes"
        print "  Hash:    {final_binary.hash}"
        print "  Backend: {backend_to_string(final_binary.backend)}"
        print ""

        val p01 = phase0_result.success and phase1_result.success
        val p012 = p01 and phase2_result.success
        val p0123 = p012 and phase3_result.success
        val verified = if config.verify_reproducibility: full_verified else: true
        val overall_success = p0123 and verified

        MultiphaseResult(
            phase0: phase0_result,
            phase1: phase1_result,
            phase2: phase2_result,
            phase3: phase3_result,
            phase4: phase4_result,
            verified: verified,
            overall_success: overall_success
        )

# ============================================================================
# Phase Implementations
# ============================================================================

# Phase 0: Verify all prerequisites exist
fn run_phase0(config: MultiphaseConfig) -> PhaseResult:
    val start_time = current_time_ms()
    var all_ok = true

    # Check bin/release/simple (runtime interpreter)
    if file_exists("bin/release/simple"):
        val size = file_size_raw("bin/release/simple")
        print "  OK bin/release/simple ({size} bytes)"
    else:
        print "  FAIL bin/release/simple not found"
        all_ok = false

    # Check seed_cpp
    if file_exists(config.seed_cpp_path):
        val size = file_size_raw(config.seed_cpp_path)
        print "  OK {config.seed_cpp_path} ({size} bytes)"
    else:
        print "  FAIL {config.seed_cpp_path} not found"
        print "    Build it: cd build/seed && cmake ../../src/runtime && cmake --build . --parallel"
        all_ok = false

    # Check clang++
    val clang_check = shell("which {config.clang_path} 2>/dev/null")
    if clang_check.exit_code == 0:
        val version_result = shell("{config.clang_path} --version 2>/dev/null | head -1")
        val version_line = version_result.stdout.trim()
        print "  OK {config.clang_path} found ({version_line})"
    else:
        print "  FAIL {config.clang_path} not found"
        all_ok = false

    # Check runtime library
    if file_exists(config.runtime_lib):
        val size = file_size_raw(config.runtime_lib)
        print "  OK {config.runtime_lib} ({size} bytes)"
    else:
        print "  FAIL {config.runtime_lib} not found"
        all_ok = false

    # Check CRT startup library
    if file_exists(config.crt_lib):
        val size = file_size_raw(config.crt_lib)
        print "  OK {config.crt_lib} ({size} bytes)"
    else:
        print "  FAIL {config.crt_lib} not found"
        all_ok = false

    # Check compiler directory
    val core_files = discover_spl_files(config.compiler_dir)
    if core_files.len() > 0:
        print "  OK {config.compiler_dir} ({core_files.len()} .spl files)"
    else:
        print "  FAIL {config.compiler_dir} has no .spl files"
        all_ok = false

    # Check seed include dir (for runtime.h)
    if file_exists("{config.seed_include_dir}/runtime.h"):
        print "  OK {config.seed_include_dir}/runtime.h found"
    else:
        print "  WARN {config.seed_include_dir}/runtime.h not found (may not be needed)"

    if not all_ok:
        return PhaseResult(
            phase: BootstrapPhase.Phase0,
            success: false,
            binary_path: "",
            binary_size: 0,
            compile_duration_ms: current_time_ms() - start_time,
            hash: "",
            backend: CompilationBackend.SeedCpp
        )

    PhaseResult(
        phase: BootstrapPhase.Phase0,
        success: true,
        binary_path: "bin/release/simple",
        binary_size: file_size_raw("bin/release/simple"),
        compile_duration_ms: current_time_ms() - start_time,
        hash: file_hash_sha256("bin/release/simple"),
        backend: CompilationBackend.Interpreter
    )


# ============================================================================
# Helpers
# ============================================================================

# Verify that two phase results produce identical binaries
fn verify_phases(phase_a: PhaseResult, phase_b: PhaseResult) -> bool:
    if phase_a.hash != phase_b.hash:
        print "  Hash mismatch:"
        print "    {phase_name(phase_a.phase)}: {phase_a.hash}"
        print "    {phase_name(phase_b.phase)}: {phase_b.hash}"
        return false

    if phase_a.binary_size != phase_b.binary_size:
        print "  Size mismatch:"
        print "    {phase_name(phase_a.phase)}: {phase_a.binary_size} bytes"
        print "    {phase_name(phase_b.phase)}: {phase_b.binary_size} bytes"
        return false

    print "  Hashes match: {phase_a.hash}"
    print "  Sizes match:  {phase_a.binary_size} bytes"
    true

# Empty phase result
fn empty_phase_result(phase: BootstrapPhase, backend: CompilationBackend) -> PhaseResult:
    PhaseResult(
        phase: phase,
        success: false,
        binary_path: "",
        binary_size: 0,
        compile_duration_ms: 0,
        hash: "",
        backend: backend
    )

# Failed phase result
fn fail_phase(phase: BootstrapPhase, backend: CompilationBackend, start_time: i64) -> PhaseResult:
    PhaseResult(
        phase: phase,
        success: false,
        binary_path: "",
        binary_size: 0,
        compile_duration_ms: current_time_ms() - start_time,
        hash: "",
        backend: backend
    )

# Current time in milliseconds
fn current_time_ms() -> i64:
    time_now_unix_micros() / 1000

# Phase name
fn phase_name(phase: BootstrapPhase) -> text:
    match phase:
        case BootstrapPhase.Phase0: "Phase0"
        case BootstrapPhase.Phase1: "Phase1-Core1"
        case BootstrapPhase.Phase2: "Phase2-Core2"
        case BootstrapPhase.Phase3: "Phase3-Full1"
        case BootstrapPhase.Phase4: "Phase4-Full2"

# Backend name
fn backend_to_string(backend: CompilationBackend) -> text:
    match backend:
        case CompilationBackend.SeedCpp: "seed_cpp->C++->clang++"
        case CompilationBackend.Native: "self-hosted->native"
        case CompilationBackend.Interpreter: "interpreter"

# ============================================================================
# Early exit helpers
# ============================================================================

fn early_exit(phase0: PhaseResult) -> MultiphaseResult:
    MultiphaseResult(
        phase0: phase0,
        phase1: empty_phase_result(BootstrapPhase.Phase1, CompilationBackend.SeedCpp),
        phase2: empty_phase_result(BootstrapPhase.Phase2, CompilationBackend.Native),
        phase3: empty_phase_result(BootstrapPhase.Phase3, CompilationBackend.Native),
        phase4: empty_phase_result(BootstrapPhase.Phase4, CompilationBackend.Native),
        verified: false,
        overall_success: false
    )

fn early_exit_after_phase1(phase0: PhaseResult, phase1: PhaseResult) -> MultiphaseResult:
    MultiphaseResult(
        phase0: phase0,
        phase1: phase1,
        phase2: empty_phase_result(BootstrapPhase.Phase2, CompilationBackend.Native),
        phase3: empty_phase_result(BootstrapPhase.Phase3, CompilationBackend.Native),
        phase4: empty_phase_result(BootstrapPhase.Phase4, CompilationBackend.Native),
        verified: false,
        overall_success: false
    )

fn early_exit_after_phase2(phase0: PhaseResult, phase1: PhaseResult, phase2: PhaseResult) -> MultiphaseResult:
    MultiphaseResult(
        phase0: phase0,
        phase1: phase1,
        phase2: phase2,
        phase3: empty_phase_result(BootstrapPhase.Phase3, CompilationBackend.Native),
        phase4: empty_phase_result(BootstrapPhase.Phase4, CompilationBackend.Native),
        verified: false,
        overall_success: false
    )

fn early_exit_after_phase3(phase0: PhaseResult, phase1: PhaseResult, phase2: PhaseResult, phase3: PhaseResult) -> MultiphaseResult:
    MultiphaseResult(
        phase0: phase0,
        phase1: phase1,
        phase2: phase2,
        phase3: phase3,
        phase4: empty_phase_result(BootstrapPhase.Phase4, CompilationBackend.Native),
        verified: false,
        overall_success: false
    )

# ============================================================================
# Default configuration
# ============================================================================

fn default_multiphase_config() -> MultiphaseConfig:
    MultiphaseConfig(
        profile: BuildProfile.Bootstrap,
        verify_reproducibility: true,
        keep_artifacts: true,
        workspace_root: ".",
        output_dir: "build/bootstrap",
        seed_cpp_path: "build/seed/seed_cpp",
        clang_path: "clang++",
        runtime_lib: "build/seed/libspl_runtime.a",
        crt_lib: "build/seed/startup/libspl_crt_linux_x86_64.a",
        compiler_dir: "src/compiler",
        seed_include_dir: "src/runtime"
    )

# Quick entry point
fn quick_multiphase_bootstrap() -> MultiphaseResult:
    MultiphaseBootstrap.run(default_multiphase_config())

# Re-export phase implementations from bootstrap_phases.spl
use app.build.bootstrap_phases.*

# Re-export 8-stage pipeline (extracted to bootstrap_pipeline.spl)
use app.build.bootstrap_pipeline.*
