#!/usr/bin/env simple
# Feature Documentation Verification Script
# Verifies generated docs match or exceed baseline quality
# Migrated from scripts/verify/verify_features.sh

use app.io
use app.utils.colors (success, error, warning, info)

export main, verify_features

struct VerificationStats:
    total_checks: i64
    passed_checks: i64
    failed_checks: i64
    warnings: i64

fn main():
    verify_features()

fn verify_features():
    """Verify feature documentation quality"""
    val old_dir = "doc/old_features"
    val new_dir = "doc/features"

    print "=========================================="
    print "Feature Documentation Verification"
    print "=========================================="
    print ""

    var stats = VerificationStats(
        total_checks: 0,
        passed_checks: 0,
        failed_checks: 0,
        warnings: 0
    )

    # Check 1: File count comparison
    check_file_count(old_dir, new_dir, stats)

    # Check 2: Category coverage
    check_category_coverage(old_dir, new_dir, stats)

    # Check 3: Metadata field presence
    check_metadata_fields(new_dir, stats)

    # Check 4: Required sections
    check_required_sections(new_dir, stats)

    # Check 5: Auto-generation warning
    check_autogen_warning(new_dir, stats)

    # Check 6: Cross-reference integrity
    check_spec_references(new_dir, stats)

    # Summary
    print_summary(stats)

fn check_file_count(old_dir: text, new_dir: text, stats: VerificationStats):
    """Check file count comparison"""
    print "Check 1: File Count"
    print "-------------------"

    val old_count = count_md_files(old_dir)
    val new_count = count_md_files(new_dir)

    print info("Baseline files: {old_count}")
    print info("Generated files: {new_count}")

    if new_count >= old_count:
        pass_check("File count: {new_count} >= {old_count} (baseline)", stats)
    else:
        fail_check("File count: {new_count} < {old_count} (missing files)", stats)

    print ""

fn check_category_coverage(old_dir: text, new_dir: text, stats: VerificationStats):
    """Check category coverage"""
    print "Check 2: Category Coverage"
    print "--------------------------"

    if not is_dir(old_dir):
        warn_check("Baseline directory not found", stats)
        print ""
        return

    val categories = dir_list(old_dir)

    for category in categories:
        val category_path = "{old_dir}/{category}"

        if not is_dir(category_path):
            continue

        # Skip special directories
        if category == "done":
            continue

        val old_files = count_category_files(category_path)
        val new_category_path = "{new_dir}/{category}"

        if is_dir(new_category_path):
            val new_files = count_category_files(new_category_path)

            if new_files >= old_files:
                pass_check("Category '{category}': {new_files}/{old_files} files", stats)
            else:
                fail_check("Category '{category}': {new_files}/{old_files} files (incomplete)", stats)
        else:
            fail_check("Category '{category}': missing directory", stats)

    print ""

fn check_metadata_fields(new_dir: text, stats: VerificationStats):
    """Check metadata field presence"""
    print "Check 3: Metadata Field Presence"
    print "--------------------------------"

    val sample_files = get_sample_files(new_dir, 5)

    if sample_files.len() == 0:
        warn_check("No files to check metadata", stats)
        print ""
        return

    val required_fields = ["Feature ID", "Feature Name", "Category", "Difficulty", "Status", "Implementation"]

    for file in sample_files:
        val basename = extract_basename(file)
        val content = file_read(file)
        var missing_fields = []

        for field in required_fields:
            val pattern = "| **{field}** |"
            if not content.contains(pattern):
                missing_fields = missing_fields + [field]

        if missing_fields.len() == 0:
            pass_check("{basename}: All required metadata fields present", stats)
        else:
            val fields_str = missing_fields.join(", ")
            fail_check("{basename}: Missing fields: {fields_str}", stats)

    print ""

fn check_required_sections(new_dir: text, stats: VerificationStats):
    """Check required sections"""
    print "Check 4: Required Sections"
    print "-------------------------"

    val sample_files = get_sample_files(new_dir, 5)

    if sample_files.len() == 0:
        warn_check("No files to check sections", stats)
        print ""
        return

    val required_sections = ["## Overview", "## Description", "## Implementation", "## Testing"]

    for file in sample_files:
        val basename = extract_basename(file)
        val content = file_read(file)
        var missing_sections = []

        for section in required_sections:
            if not content.contains(section):
                val section_name = section.replace("## ", "")
                missing_sections = missing_sections + [section_name]

        if missing_sections.len() == 0:
            pass_check("{basename}: All required sections present", stats)
        else:
            val sections_str = missing_sections.join(", ")
            fail_check("{basename}: Missing sections: {sections_str}", stats)

    print ""

fn check_autogen_warning(new_dir: text, stats: VerificationStats):
    """Check auto-generation warning"""
    print "Check 5: Auto-generation Warning"
    print "--------------------------------"

    val sample_files = get_sample_files(new_dir, 5)

    if sample_files.len() == 0:
        warn_check("No files to check auto-gen warning", stats)
        print ""
        return

    for file in sample_files:
        val basename = extract_basename(file)
        val content = file_read(file)

        if content.contains("This file is auto-generated from BDD system tests"):
            pass_check("{basename}: Contains auto-generation warning", stats)
        else:
            warn_check("{basename}: Missing auto-generation warning", stats)

    print ""

fn check_spec_references(new_dir: text, stats: VerificationStats):
    """Check cross-reference integrity"""
    print "Check 6: Cross-reference Integrity"
    print "----------------------------------"

    val sample_files = get_sample_files(new_dir, 5)

    if sample_files.len() == 0:
        warn_check("No files to check cross-references", stats)
        print ""
        return

    for file in sample_files:
        val basename = extract_basename(file)
        val content = file_read(file)

        # Check if spec references are present
        if content.contains("](../../spec/"):
            # Extract spec path (simplified pattern matching)
            val lines = content.split("\n")
            var found_valid_ref = false

            for line in lines:
                if line.contains("](../../spec/"):
                    val start = line.find("](../../spec/")
                    if start >= 0:
                        val after = line.substring(start + 13, line.len())
                        val end = after.find(")")
                        if end > 0:
                            val spec_path = after.substring(0, end)
                            val full_path = "doc/spec/{spec_path}"

                            if file_exists(full_path):
                                pass_check("{basename}: Spec reference valid ({spec_path})", stats)
                                found_valid_ref = true
                                break
                            else:
                                warn_check("{basename}: Spec reference may be invalid ({spec_path})", stats)
                                found_valid_ref = true
                                break

            if not found_valid_ref:
                warn_check("{basename}: No spec reference found", stats)
        else:
            warn_check("{basename}: No spec reference found", stats)

    print ""

fn print_summary(stats: VerificationStats):
    """Print verification summary"""
    print "=========================================="
    print "Verification Summary"
    print "=========================================="
    print ""
    print "Total Checks:  {stats.total_checks}"
    print success("Passed:        {stats.passed_checks}")
    print error("Failed:        {stats.failed_checks}")
    print warning("Warnings:      {stats.warnings}")
    print ""

    # Calculate pass percentage
    if stats.total_checks > 0:
        val pass_pct = (stats.passed_checks * 100) / stats.total_checks
        print "Pass Rate:     {pass_pct}%"
    else:
        print "Pass Rate:     N/A (no checks run)"

    print ""

    # Overall result
    if stats.failed_checks == 0:
        print success("✓ VERIFICATION PASSED")
        if stats.warnings > 0:
            print warning("⚠ {stats.warnings} warnings (review recommended)")
        exit(0)
    else:
        print error("✗ VERIFICATION FAILED")
        print "  Fix {stats.failed_checks} failed check(s) before proceeding"
        exit(1)

fn pass_check(message: text, stats: VerificationStats):
    """Record passed check"""
    print success("✓ {message}")
    stats.passed_checks = stats.passed_checks + 1
    stats.total_checks = stats.total_checks + 1

fn fail_check(message: text, stats: VerificationStats):
    """Record failed check"""
    print error("✗ {message}")
    stats.failed_checks = stats.failed_checks + 1
    stats.total_checks = stats.total_checks + 1

fn warn_check(message: text, stats: VerificationStats):
    """Record warning"""
    print warning("⚠ {message}")
    stats.warnings = stats.warnings + 1

fn count_md_files(directory: text) -> i64:
    """Count markdown files in directory"""
    if not is_dir(directory):
        return 0

    val (stdout, _, code) = process_run("find",
        [directory, "-type", "f", "-name", "*.md"])

    if code != 0:
        return 0

    val lines = stdout.split("\n")
    var count = 0
    for line in lines:
        if line.trim().len() > 0:
            count = count + 1
    count

fn count_category_files(category_path: text) -> i64:
    """Count markdown files in a category directory"""
    if not is_dir(category_path):
        return 0

    val (stdout, _, code) = process_run("find",
        [category_path, "-maxdepth", "1", "-type", "f", "-name", "*.md"])

    if code != 0:
        return 0

    val lines = stdout.split("\n")
    var count = 0
    for line in lines:
        if line.trim().len() > 0:
            count = count + 1
    count

fn get_sample_files(directory: text, limit: i64) -> [text]:
    """Get sample files from directory"""
    if not is_dir(directory):
        return []

    val (stdout, _, code) = process_run("find",
        [directory, "-type", "f", "-name", "*.md", "!", "-path", "*/done/*"])

    if code != 0:
        return []

    val lines = stdout.split("\n")
    var files = []
    var count = 0

    for line in lines:
        if count >= limit:
            break

        val path = line.trim()
        if path.len() > 0:
            files = files + [path]
            count = count + 1

    files

fn extract_basename(path: text) -> text:
    """Extract filename from path"""
    val parts = path.split("/")
    if parts.len() > 0:
        return parts[parts.len() - 1]
    path
