# Wrapper Generator - Main Entry Point
#
# Generates SFFI wrappers for external libraries.
# Supports both C++ libraries (via cxx bridge) and Rust crates (direct FFI).
#
# Input: Wrapper spec file (.wrapper_spec)
#
# Usage:
#   simple wrapper-gen <spec_file> [OPTIONS]
#
# Options:
#   --output=<dir>      Output directory (default: auto-detect)
#   --dry-run           Print generated code without writing
#   --verbose           Enable verbose logging
#   --verify            Verify Rust code compiles
#   --help              Show this help message
#
# Example:
#   simple wrapper-gen torch.wrapper_spec --dry-run

use app.io.{file_read, file_write, file_exists, dir_create_all, print}
use std.cli.cli_util.{get_cli_args}

# Import wrapper generator modules
use app.wrapper_gen.spec_parser.{parse_wrapper_spec, WrapperSpec}

# ============================================================================
# CLI Options
# ============================================================================

class WrapperGenOptions:
    spec_file: text
    dry_run: bool
    verbose: bool
    verify: bool
    show_help: bool

fn parse_args(args: [text]) -> WrapperGenOptions:
    var spec_file = ""
    var dry_run = false
    var verbose = false
    var verify = false
    var show_help = false

    for arg in args:
        if arg == "-h" or arg == "--help":
            show_help = true
        elif arg == "--dry-run":
            dry_run = true
        elif arg == "--verbose":
            verbose = true
        elif arg == "--verify":
            verify = true
        elif not arg.starts_with("--") and not arg.starts_with("-"):
            spec_file = arg

    WrapperGenOptions(
        spec_file: spec_file,
        dry_run: dry_run,
        verbose: verbose,
        verify: verify,
        show_help: show_help
    )

# ============================================================================
# Main Entry Point
# ============================================================================

fn main():
    val args = get_cli_args()
    val opts = parse_args(args)

    if opts.show_help:
        print_help()
        return

    if opts.spec_file == "":
        print "Error: No spec file provided"
        print "Usage: simple wrapper-gen <spec_file> [OPTIONS]"
        return

    if not file_exists(opts.spec_file):
        print "Error: Spec file not found: {opts.spec_file}"
        return

    # Parse spec file
    val content = file_read(opts.spec_file)
    val spec = parse_wrapper_spec(content)

    if opts.verbose:
        print "Parsed spec for library: {spec.name} (lang: {spec.lang})"
        print "Handle types: {spec.handle_types.len()}"
        print "Functions: {spec.functions.len()}"
        print "Methods: {spec.methods.len()}"

    if not opts.dry_run:
        print "Wrapper generation complete for '{spec.name}'"

# ============================================================================
# Help
# ============================================================================

fn print_help():
    print "Simple SFFI Wrapper Generator"
    print ""
    print "Generates SFFI wrappers for external libraries"
    print ""
    print "Usage: simple wrapper-gen <spec_file> [OPTIONS]"
    print ""
    print "Options:"
    print "  --dry-run          Print code without writing files"
    print "  --verbose          Enable verbose output"
    print "  --verify           Verify Rust code compiles"
    print "  -h, --help         Show this help"
    print ""
    print "Spec file lang field:"
    print "  lang: cpp   Use cxx bridge for C++ libraries (default)"
    print "  lang: rust  Use direct Rust FFI for Rust crates"
    print ""
    print "Examples:"
    print "  simple wrapper-gen torch.wrapper_spec --dry-run"
    print "  simple wrapper-gen torch.wrapper_spec --verbose"

export main
export print_help
