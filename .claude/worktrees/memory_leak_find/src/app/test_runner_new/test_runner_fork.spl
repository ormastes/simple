# Test Runner Fork Mode
#
# Runs test files using fork()-without-exec for fast isolation.
# The child process inherits the loaded binary (COW pages) and calls
# rt_cli_run_file() directly — no exec, no binary loading, no CLI parsing.
# OS reclaims all child memory on _exit().

use test_runner_types.*
use test_runner_execute.{make_result_from_output}
use app.io.time_ops.{time_now_unix_micros}

# FFI declarations for fork bridge
extern fn rt_fork_child_setup() -> i64
extern fn rt_fork_parent_wait(pid: i64, timeout_ms: i64) -> i64
extern fn rt_fork_parent_stdout() -> text
extern fn rt_fork_parent_stderr() -> text
extern fn rt_fork_child_exit(code: i64)

# FFI declaration for running interpreter on a file (Rust-side, already in binary)
extern fn rt_cli_run_file(path: text, args: [text], gc_log: bool, gc_off: bool) -> i64

# =========================================================================
# Fork Mode Execution
# =========================================================================

fn run_test_file_fork(file_path: text, options: TestOptions) -> TestFileResult:
    val timeout_ms = options.timeout * 1000
    val start = time_now_unix_micros()

    val pid_or_zero = rt_fork_child_setup()

    if pid_or_zero == 0:
        # === CHILD PROCESS ===
        # Binary already in memory (COW), no loading needed.
        # rt_cli_run_file calls the Rust interpreter directly.
        var args: [text] = []
        val result = rt_cli_run_file(file_path, args, options.gc_log, options.gc_off)
        rt_fork_child_exit(result)
        # UNREACHABLE — rt_fork_child_exit calls _exit()
        # Return a dummy value to satisfy type checker
        return TestFileResult(path: file_path, passed: 0, failed: 0, skipped: 0, pending: 0, duration_ms: 0, error: "", timed_out: false)

    if pid_or_zero < 0:
        # Fork failed — return error result
        val end = time_now_unix_micros()
        val duration_ms = (end - start) / 1000
        return TestFileResult(
            path: file_path,
            passed: 0,
            failed: 1,
            skipped: 0,
            pending: 0,
            duration_ms: duration_ms,
            error: "fork() failed",
            timed_out: false
        )

    # === PARENT PROCESS ===
    val exit_code = rt_fork_parent_wait(pid_or_zero, timeout_ms)
    val stdout = rt_fork_parent_stdout()
    val stderr = rt_fork_parent_stderr()
    val end = time_now_unix_micros()
    val duration_ms = (end - start) / 1000

    make_result_from_output(file_path, stdout, stderr, exit_code, duration_ms, options.timeout)

# =========================================================================
# Exports
# =========================================================================

export run_test_file_fork
