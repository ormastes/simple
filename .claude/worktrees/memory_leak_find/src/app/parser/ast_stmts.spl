# AST Node Types â€” Statement, Module System, and AOP Nodes
#
# Extracted from ast.spl. Contains:
# - Statement structs (LetStmt, IfStmt, MatchStmt, ForStmt, etc.)
# - Module system nodes (ModDecl, UseStmt, MultiUse, etc.)
# - AOP nodes (AopAdvice, DiBinding, ArchitectureRule, MockDecl)

from token import {Span}
from ast import {Expr, Pattern, Type, Block, ContractClause, Capability, Visibility, Mutability, StorageClass, FunctionDef, Attribute, ModulePath, ImportTarget}

# === Statement Nodes ===

struct LetStmt:
    span: Span
    pattern: Pattern
    ty: Type?
    value: Expr?
    mutability: Mutability
    storage_class: StorageClass
    is_ghost: bool
    is_suspend: bool

struct ConstStmt:
    span: Span
    name: text
    ty: Type?
    value: Expr
    visibility: Visibility

struct StaticStmt:
    span: Span
    name: text
    ty: Type?
    value: Expr
    mutability: Mutability
    visibility: Visibility

struct AssignmentStmt:
    span: Span
    target: Expr
    op: AssignOp
    value: Expr

struct ReturnStmt:
    span: Span
    value: Expr?

struct IfStmt:
    span: Span
    let_pattern: Pattern?
    condition: Expr
    then_block: Block
    elif_branches: [(Expr, Block)]
    else_block: Block?
    is_suspend: bool

struct MatchStmt:
    span: Span
    subject: Expr
    arms: [MatchArm]
    is_suspend: bool

struct ForStmt:
    span: Span
    pattern: Pattern
    iterable: Expr
    body: Block
    is_suspend: bool
    auto_enumerate: bool
    invariants: [ContractClause]

struct WhileStmt:
    span: Span
    let_pattern: Pattern?
    condition: Expr
    body: Block
    is_suspend: bool
    invariants: [ContractClause]

struct LoopStmt:
    span: Span
    body: Block

struct BreakStmt:
    span: Span
    value: Expr?

struct ContinueStmt:
    span: Span

struct PassStmt:
    span: Span

struct SkipStmt:
    span: Span
    body: SkipBody

enum SkipBody:
    Standalone
    BlockBody(Block)

struct DeferStmt:
    span: Span
    body: DeferBody

enum DeferBody:
    ExprBody(Expr)
    BlockBody(Block)

struct GuardStmt:
    span: Span
    condition: Expr?
    result: Expr

struct AssertStmt:
    span: Span
    condition: Expr
    message: text?

struct AssumeStmt:
    span: Span
    condition: Expr
    message: text?

struct AdmitStmt:
    span: Span
    condition: Expr
    message: text?

struct ProofHintStmt:
    span: Span
    hint: text

struct CalcStmt:
    span: Span
    steps: [CalcStep]

struct CalcStep:
    span: Span
    expr: Expr
    justification: text?

struct ContextStmt:
    span: Span
    context: Expr
    body: Block

struct WithStmt:
    span: Span
    resource: Expr
    name: text?
    body: Block

struct LeanBlock:
    span: Span
    import_path: text?
    code: text

# === Module System Nodes ===

struct ModDecl:
    span: Span
    name: text
    visibility: Visibility
    attributes: [Attribute]
    body: [Node]?

struct UseStmt:
    span: Span
    path: ModulePath
    target: ImportTarget
    is_type_only: bool
    is_lazy: bool

struct MultiUse:
    span: Span
    imports: [(ModulePath, ImportTarget)]
    is_type_only: bool
    is_lazy: bool

struct CommonUseStmt:
    span: Span
    path: ModulePath
    target: ImportTarget

struct ExportUseStmt:
    span: Span
    path: ModulePath
    target: ImportTarget

struct AutoImportStmt:
    span: Span
    path: ModulePath
    macro_name: text

enum StructuredExportEntry:
    Single(text)
    Aliased(name: text, alias: text)
    FromModule(path: ModulePath, items: [ImportTarget])
    GlobExport(ModulePath)

struct StructuredExportBlock:
    span: Span
    entries: [StructuredExportEntry]

struct RequiresCapabilitiesStmt:
    span: Span
    capabilities: [Capability]

struct UnfoldStmt:
    """Package unfold declaration marking a package as namespace-only.

    When a package has an unfold declaration, direct imports of that package
    become errors - users must import the unfolded subpackages instead.

    Syntax: `unfold {subpkg1, subpkg2, ...}`
    """
    span: Span
    subpackages: [text]

# === AOP Nodes ===

struct AopAdvice:
    span: Span
    pointcut: text
    handler: Expr

struct DiBinding:
    span: Span
    pointcut: text
    impl_expr: Expr

struct ArchitectureRule:
    span: Span
    kind: text
    pointcut: text

struct MockDecl:
    span: Span
    name: text
    trait_name: text
    methods: [FunctionDef]

export LetStmt, ConstStmt, StaticStmt, AssignmentStmt, ReturnStmt
export IfStmt, MatchStmt, ForStmt, WhileStmt, LoopStmt
export BreakStmt, ContinueStmt, PassStmt, SkipStmt, DeferStmt, GuardStmt
export AssertStmt, AssumeStmt, AdmitStmt, ProofHintStmt, CalcStmt, UnfoldStmt
export ContextStmt, WithStmt, LeanBlock
export ModDecl, UseStmt, MultiUse, CommonUseStmt, ExportUseStmt
export AutoImportStmt, StructuredExportBlock, RequiresCapabilitiesStmt
export SkipBody, DeferBody, CalcStep
export StructuredExportEntry
export AopAdvice, DiBinding, ArchitectureRule, MockDecl
