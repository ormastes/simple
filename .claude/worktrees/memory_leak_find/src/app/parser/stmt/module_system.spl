# Statement Parser - Module System Module
#
# Parsing for module system statements: use, import (deprecated), from-import (deprecated),
# mod declarations, common use, export, auto import, requires capabilities, structured export.
# Extracted from statements.spl (Module System section)

from token import {Span, Token, TokenKind}
from ast import {Node, Block,
                 ModulePath, ImportTarget, UseStmt, MultiUse,
                 ModDecl, CommonUseStmt, ExportUseStmt, AutoImportStmt}
from error import {ParseError}

export ModuleSystemParser

impl Parser:
    # Parse module path: dot-separated identifiers, with ./ or ../ for relative
    fn parse_module_path(self) -> ModulePath:
        val parts = []
        val is_relative = false
        val up_count = 0

        # Check for relative paths
        if self.check(TokenKind.Dot):
            is_relative = true
            self.advance()
            if self.check(TokenKind.Dot):
                # ../
                while self.check(TokenKind.Dot):
                    up_count = up_count + 1
                    self.advance()

        # Parse dot-separated path
        parts.append(self.expect_identifier())
        while self.check(TokenKind.Dot):
            self.advance()
            parts.append(self.expect_identifier())

        ModulePath(
            parts: parts,
            is_relative: is_relative,
            up_count: up_count,
        )

    # Parse import target: single, aliased, group, or glob
    fn parse_import_target(self) -> ImportTarget:
        if self.check(TokenKind.Star):
            # Glob import: *
            self.advance()
            ImportTarget.Glob

        elif self.check(TokenKind.LBrace):
            # Group import: {item1, item2 as alias, ...}
            self.advance()
            val items = []
            while not self.check(TokenKind.RBrace):
                val name = self.expect_identifier()
                val alias = nil
                if self.check(TokenKind.As):
                    self.advance()
                    alias = Some(self.expect_identifier())
                items.append((name, alias))
                if not self.check(TokenKind.RBrace):
                    self.expect(TokenKind.Comma)
            self.expect(TokenKind.RBrace)
            ImportTarget.Group(items)

        else:
            # Single: name or name as alias
            val name = self.expect_identifier()
            val alias = nil
            if self.check(TokenKind.As):
                self.advance()
                alias = Some(self.expect_identifier())
            ImportTarget.Single(name, alias)

    # Parse use statement: use module.{items} or use module.*
    fn parse_use_statement(self) -> Result<Node, ParseError>:
        val start_span = self.current.span
        self.expect(TokenKind.Use)

        # Check for lazy modifier: use lazy module.Item
        val is_lazy = if self.current.kind.is_identifier_named("lazy"):
            self.advance()
            true
        else:
            false

        val path = self.parse_module_path()

        # Check for .{items} or .* after path
        val target = nil
        if self.check(TokenKind.Dot):
            self.advance()
            target = Some(self.parse_import_target())

        val end_span = self.previous.span
        val span = Span(start_span.start, end_span.end, start_span.line, start_span.column)

        Ok(Node.Use(UseStmt(
            span: span,
            path: path,
            target: target,
            is_lazy: is_lazy,
        )))

    # Parse import statement (deprecated, alias for use): import module
    fn parse_import_statement(self) -> Result<Node, ParseError>:
        val start_span = self.current.span
        self.expect(TokenKind.Import)

        # Print deprecation warning to help users
        print "[DEPRECATED] 'import' keyword is deprecated. Use 'use' instead."
        print "  Example: use module.path (item1, item2)"
        print "  See CLAUDE.md for correct import syntax."

        val path = self.parse_module_path()

        val target = nil
        if self.check(TokenKind.Dot):
            self.advance()
            target = Some(self.parse_import_target())

        val end_span = self.previous.span
        val span = Span(start_span.start, end_span.end, start_span.line, start_span.column)

        Ok(Node.Use(UseStmt(
            span: span,
            path: path,
            target: target,
            is_lazy: false,
        )))

    # Parse from-import statement (deprecated Python-style): from module import {items}
    fn parse_from_import(self) -> Result<Node, ParseError>:
        val start_span = self.current.span
        self.expect(TokenKind.From)

        # Print deprecation warning to help users
        print "[DEPRECATED] 'from...import' syntax is deprecated. Use 'use' instead."
        print "  Example: use module.path (item1, item2)"
        print "  Python style: from module import {item1, item2}"
        print "  Simple style: use module (item1, item2)"
        print "  See CLAUDE.md for correct import syntax."

        val path = self.parse_module_path()
        self.expect(TokenKind.Import)
        val target = self.parse_import_target()

        val end_span = self.previous.span
        val span = Span(start_span.start, end_span.end, start_span.line, start_span.column)

        Ok(Node.Use(UseStmt(
            span: span,
            path: path,
            target: Some(target),
            is_lazy: false,
        )))

    # Parse mod declaration: mod name or mod name: block (inline)
    fn parse_mod_declaration(self) -> Result<Node, ParseError>:
        val start_span = self.current.span
        self.expect(TokenKind.Mod)

        val name = self.expect_identifier()

        # Check for inline module
        val body = nil
        if self.check(TokenKind.Colon):
            self.advance()
            body = Some(self.parse_block())

        val end_span = self.previous.span
        val span = Span(start_span.start, end_span.end, start_span.line, start_span.column)

        Ok(Node.Mod(ModDecl(
            span: span,
            name: name,
            body: body,
        )))

    # Parse common use: common use module.{items}
    fn parse_common_use(self) -> Result<Node, ParseError>:
        val start_span = self.current.span
        self.expect(TokenKind.Common)
        self.expect(TokenKind.Use)

        val path = self.parse_module_path()

        val target = nil
        if self.check(TokenKind.Dot):
            self.advance()
            target = Some(self.parse_import_target())

        val end_span = self.previous.span
        val span = Span(start_span.start, end_span.end, start_span.line, start_span.column)

        Ok(Node.CommonUse(CommonUseStmt(
            span: span,
            path: path,
            target: target,
        )))

    # Parse export statement: export name1, name2 or export use module
    fn parse_export_statement(self) -> Result<Node, ParseError>:
        val start_span = self.current.span
        self.expect(TokenKind.Export)

        # export use module.{items}
        if self.check(TokenKind.Use):
            self.advance()
            val path = self.parse_module_path()
            val target = nil
            if self.check(TokenKind.Dot):
                self.advance()
                target = Some(self.parse_import_target())

            val end_span = self.previous.span
            val span = Span(start_span.start, end_span.end, start_span.line, start_span.column)

            return Ok(Node.ExportUse(ExportUseStmt(
                span: span,
                path: path,
                target: target,
            )))

        # export name1, name2
        val names = []
        names.append(self.expect_identifier())
        while self.check(TokenKind.Comma):
            self.advance()
            names.append(self.expect_identifier())

        val end_span = self.previous.span
        val span = Span(start_span.start, end_span.end, start_span.line, start_span.column)

        Ok(Node.Export(names, span))

    # Parse auto import statement: auto import pattern
    fn parse_auto_import(self) -> Result<Node, ParseError>:
        val start_span = self.current.span
        self.expect(TokenKind.Auto)
        self.expect(TokenKind.Import)

        val pattern = self.parse_module_path()

        val end_span = self.previous.span
        val span = Span(start_span.start, end_span.end, start_span.line, start_span.column)

        Ok(Node.AutoImport(AutoImportStmt(
            span: span,
            pattern: pattern,
        )))

    # Parse requires capabilities: requires capability1, capability2
    fn parse_requires_capabilities(self) -> Result<Node, ParseError>:
        val start_span = self.current.span
        self.expect(TokenKind.Requires)

        val capabilities = []
        capabilities.append(self.expect_identifier())
        while self.check(TokenKind.Comma):
            self.advance()
            capabilities.append(self.expect_identifier())

        val end_span = self.previous.span
        val span = Span(start_span.start, end_span.end, start_span.line, start_span.column)

        Ok(Node.RequiresCapabilities(capabilities, span))

    # Parse structured export: structured_export: block
    fn parse_structured_export(self) -> Result<Node, ParseError>:
        val start_span = self.current.span
        self.expect_ident_value("structured_export")
        self.expect(TokenKind.Colon)
        val body = self.parse_block()

        val end_span = self.previous.span
        val span = Span(start_span.start, end_span.end, start_span.line, start_span.column)

        Ok(Node.StructuredExport(body, span))
