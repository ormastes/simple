# Statement Parser - Jump Statements Module
#
# Parsing for jump statements: return, break, continue, pass, skip.
# Extracted from statements.spl (Jump Statements section)

from token import {Span, Token, TokenKind}
from ast import {Node, Block,
                 ReturnStmt, BreakStmt, ContinueStmt, PassStmt, SkipStmt}
from error import {ParseError}

export JumpParser

impl Parser:
    # Parse return statement: return or return expr
    fn parse_return_statement(self) -> Result<Node, ParseError>:
        val start_span = self.current.span
        self.expect(TokenKind.Return)

        val value = nil
        if not self.check(TokenKind.Newline) and not self.check(TokenKind.Dedent) and not self.is_at_end():
            value = Some(self.parse_expression())

        val end_span = self.previous.span
        val span = Span(start_span.start, end_span.end, start_span.line, start_span.column)

        Ok(Node.Return(ReturnStmt(
            span: span,
            value: value,
        )))

    # Parse break statement: break or break expr
    fn parse_break_statement(self) -> Result<Node, ParseError>:
        val start_span = self.current.span
        self.expect(TokenKind.Break)

        val value = nil
        if not self.check(TokenKind.Newline) and not self.check(TokenKind.Dedent) and not self.is_at_end():
            value = Some(self.parse_expression())

        val end_span = self.previous.span
        val span = Span(start_span.start, end_span.end, start_span.line, start_span.column)

        Ok(Node.Break(BreakStmt(
            span: span,
            value: value,
        )))

    # Parse continue statement
    fn parse_continue_statement(self) -> Result<Node, ParseError>:
        val start_span = self.current.span
        self.expect(TokenKind.Continue)

        val end_span = self.previous.span
        val span = Span(start_span.start, end_span.end, start_span.line, start_span.column)

        Ok(Node.Continue(ContinueStmt(span: span)))

    # Parse pass statement (no-op)
    fn parse_pass_statement(self) -> Result<Node, ParseError>:
        val start_span = self.current.span
        self.expect(TokenKind.Pass)

        val end_span = self.previous.span
        val span = Span(start_span.start, end_span.end, start_span.line, start_span.column)

        Ok(Node.Pass(PassStmt(span: span)))

    # Parse skip statement: skip or skip: block
    fn parse_skip_statement(self) -> Result<Node, ParseError>:
        val start_span = self.current.span
        self.expect(TokenKind.Skip)

        val body = nil
        if self.check(TokenKind.Colon):
            self.advance()
            body = Some(self.parse_block())

        val end_span = self.previous.span
        val span = Span(start_span.start, end_span.end, start_span.line, start_span.column)

        Ok(Node.Skip(SkipStmt(
            span: span,
            body: body,
        )))
