# Statement Parser - AOP and DI Module
#
# Parsing for aspect-oriented programming (AOP) and dependency injection (DI):
# advice, bindings, architecture rules, mock declarations, and pointcut expressions.
# Extracted from statements.spl (AOP and DI section)

from token import {Span, Token, TokenKind}
from ast import {Node, Block, Expr,
                 AopAdvice, DiBinding, ArchRule, MockDecl}
from error import {ParseError}

export AopParser

impl Parser:
    # Parse AOP advice: on pc{predicate} use Interceptor
    fn parse_aop_advice(self) -> Result<Node, ParseError>:
        val start_span = self.current.span
        self.expect(TokenKind.On)

        # Parse pointcut: pc{...}
        val pointcut = self.parse_pointcut_expr()

        self.expect(TokenKind.Use)
        val interceptor = self.parse_expression()

        val end_span = self.previous.span
        val span = Span(start_span.start, end_span.end, start_span.line, start_span.column)

        Ok(Node.AopAdvice(AopAdvice(
            span: span,
            pointcut: pointcut,
            interceptor: interceptor,
        )))

    # Parse DI binding: bind on pc{predicate} -> Impl
    fn parse_di_binding(self) -> Result<Node, ParseError>:
        val start_span = self.current.span
        self.expect_ident_value("bind")
        self.expect(TokenKind.On)

        val pointcut = self.parse_pointcut_expr()

        self.expect(TokenKind.Arrow)
        val implementation = self.parse_expression()

        val end_span = self.previous.span
        val span = Span(start_span.start, end_span.end, start_span.line, start_span.column)

        Ok(Node.DiBinding(DiBinding(
            span: span,
            pointcut: pointcut,
            implementation: implementation,
        )))

    # Parse architecture rule: forbid pc{predicate} or allow pc{predicate}
    fn parse_arch_rule(self) -> Result<Node, ParseError>:
        val start_span = self.current.span

        val is_allow = if self.check_ident("forbid"):
            self.advance()
            false
        elif self.check_ident("allow"):
            self.advance()
            true
        else:
            return Err(ParseError.unexpected_token(
                "forbid or allow", "{self.current.kind}", self.current.span))

        val pointcut = self.parse_pointcut_expr()

        val end_span = self.previous.span
        val span = Span(start_span.start, end_span.end, start_span.line, start_span.column)

        Ok(Node.ArchRule(ArchRule(
            span: span,
            is_allow: is_allow,
            pointcut: pointcut,
        )))

    # Parse mock declaration: mock Name implements Trait: block
    fn parse_mock_declaration(self) -> Result<Node, ParseError>:
        val start_span = self.current.span
        self.expect(TokenKind.Mock)

        val name = self.expect_identifier()
        self.expect_ident_value("implements")
        val trait_name = self.expect_identifier()
        self.expect(TokenKind.Colon)
        val body = self.parse_block()

        val end_span = self.previous.span
        val span = Span(start_span.start, end_span.end, start_span.line, start_span.column)

        Ok(Node.MockDecl(MockDecl(
            span: span,
            name: name,
            trait_name: trait_name,
            body: body,
        )))

    # Parse pointcut expression: pc{predicate}
    fn parse_pointcut_expr(self) -> Expr:
        # pc{...} is lexed as a CustomBlock token with kind "pc"
        if self.check_custom_block("pc"):
            val payload = self.get_custom_block_payload()
            self.advance()
            Expr.PointcutExpr(payload)
        else:
            self.error("expected pc{...} pointcut expression")
