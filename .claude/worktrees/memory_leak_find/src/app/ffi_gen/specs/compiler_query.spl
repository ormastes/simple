# SFFI Specification for Compiler Query API
#
# This specification defines the FFI functions needed for the Compiler Query API,
# which powers the LSP (Language Server Protocol) integration.
#
# These functions bridge Simple's compiler internals (written in Rust) with
# the query API (written in Simple).
#
# Generate Rust FFI code with:
#   simple sffi-gen --gen-intern compiler_query.spl

# --- Type Definitions ---

# Position in source code (0-based)
struct Position:
    line: i64
    column: i64

# Location in source code
struct Location:
    file: text
    start: Position
    end: Position

# Range in source code
struct Range:
    start: Position
    end: Position

# Symbol kind enumeration
enum SymbolKind:
    Variable
    Function
    Method
    Class
    Struct
    Enum
    Trait
    Module
    Parameter
    Field
    EnumVariant

# Symbol information
struct Symbol:
    name: text
    kind: SymbolKind
    location: Location
    type_info: Option<text>
    doc_comment: Option<text>
    is_public: bool
    is_mutable: bool

# Parse error
struct ParseError:
    line: i64
    column: i64
    message: text

# Type error
struct TypeError:
    line: i64
    column: i64
    length: i64
    message: text
    code: text

# Abstract syntax tree (opaque handle)
struct AST:
    handle: i64

# Symbol table (opaque handle)
struct SymbolTable:
    handle: i64

# Scope information
struct Scope:
    visible_symbols: [Symbol]

# --- FFI Function Specifications ---

# Parse source code into AST
#
# Takes source code and file path, returns AST or parse error.
# The AST is cached internally by file path for performance.
#
# Example:
#   val result = rt_parse_source("fn main(): print(\"hello\")", "test.spl")
#   if result.ok.?:
#       val ast = result.unwrap()
extern fn rt_parse_source(source: text, file_path: text) -> Result<AST, ParseError>

# Get file modification time (Unix timestamp)
#
# Used for cache invalidation. Returns 0 if file doesn't exist.
#
# Example:
#   val mtime = rt_get_file_mtime("/path/to/file.spl")
extern fn rt_get_file_mtime(path: text) -> i64

# Build symbol table from AST
#
# Performs name resolution and builds a symbol table containing
# all symbols defined in the AST (functions, classes, variables, etc.)
#
# Example:
#   val symbol_table = rt_build_symbol_table(ast)
extern fn rt_build_symbol_table(ast: AST) -> SymbolTable

# Find symbol at a specific position
#
# Returns the symbol at the given line and column, or nil if no
# symbol is present at that location.
#
# Example:
#   val pos = Position(line: 10, column: 15)
#   val symbol = rt_find_symbol_at_position(table, pos)
extern fn rt_find_symbol_at_position(table: SymbolTable, pos: Position) -> Option<Symbol>

# Find all references to a symbol by name
#
# Returns a list of locations where the symbol is referenced.
# This is used for "find references" functionality.
#
# Example:
#   val refs = rt_find_symbol_references(table, "my_function")
extern fn rt_find_symbol_references(table: SymbolTable, name: text) -> [Location]

# Get scope at a specific position
#
# Returns the scope (visible symbols) at the given position.
# This is used for code completion and hover information.
#
# Example:
#   val pos = Position(line: 10, column: 15)
#   val scope = rt_get_scope_at_position(table, pos)
extern fn rt_get_scope_at_position(table: SymbolTable, pos: Position) -> Scope

# Extract all symbols from symbol table
#
# Returns a flat list of all symbols in the table.
# This is used for document symbols and workspace symbols.
#
# Example:
#   val all_symbols = rt_extract_all_symbols(table)
extern fn rt_extract_all_symbols(table: SymbolTable) -> [Symbol]

# Type check an AST and return type errors
#
# Performs type checking on the AST and returns a list of type errors.
# This is used for diagnostics in the LSP.
#
# Example:
#   val errors = rt_type_check_ast(ast)
extern fn rt_type_check_ast(ast: AST) -> [TypeError]

# Get context-appropriate keywords for completion
#
# Returns a list of keywords that are valid at the given position
# and scope. For example, "val", "var", "fn", "class", etc.
#
# Example:
#   val keywords = rt_get_context_keywords(pos, scope)
extern fn rt_get_context_keywords(pos: Position, scope: Scope) -> [text]

# Free AST handle (memory management)
#
# Releases the AST from the cache. Call this when done with an AST
# to free memory.
#
# Example:
#   rt_free_ast(ast)
extern fn rt_free_ast(ast: AST)

# Free symbol table handle (memory management)
#
# Releases the symbol table from memory. Call this when done with
# a symbol table to free memory.
#
# Example:
#   rt_free_symbol_table(table)
extern fn rt_free_symbol_table(table: SymbolTable)

# --- Notes for Implementation ---
#
# Rust Implementation Location: rust/compiler/src/query_ffi.rs
#
# The Rust implementation should:
# 1. Cache ASTs by file path for performance
# 2. Integrate with existing parser (rust/parser/)
# 3. Use existing symbol resolution (rust/compiler/src/dependency/)
# 4. Use existing type checker (rust/compiler/src/type_check/)
# 5. Handle errors gracefully and return meaningful error messages
#
# Performance targets:
# - rt_parse_source: < 100ms for typical files
# - rt_find_symbol_at_position: < 10ms
# - rt_type_check_ast: < 200ms for typical files
# - rt_get_scope_at_position: < 20ms
#
# Thread safety:
# - All functions should be thread-safe for concurrent LSP requests
# - Use Arc<Mutex<>> for shared state if needed
# - Consider using RwLock for read-heavy operations
