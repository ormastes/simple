# FFI Wrapper Generator - Impl Block Code Generation
#
# Generates Rust impl blocks from ImplSpec.
#
# Usage:
#   import app.ffi_gen.impl_gen (generate_impl)

use app.ffi_gen.types*

# ============================================================================
# Impl Block Generation
# ============================================================================

# Generate a complete impl block
fn generate_impl(spec: ImplSpec) -> text:
    var out = ""

    # impl header
    val generics_str = format_impl_generics(spec.generics)
    val where_str = format_impl_where(spec.where_clauses)

    if spec.trait_name != "":
        # Trait implementation
        out = out + "impl{generics_str} {spec.trait_name} for {spec.type_name}{where_str} {{\n"
    else:
        # Inherent implementation
        out = out + "impl{generics_str} {spec.type_name}{where_str} {{\n"

    # Methods
    for method in spec.methods:
        out = out + generate_method(method)
        out = out + "\n"

    out = out + "}}\n"
    out

# Generate a single method
fn generate_method(method: MethodSpec) -> text:
    var out = ""

    # Doc comment
    if method.doc != "":
        for line in method.doc.split("\n"):
            out = out + "    /// {line}\n"

    # Build signature
    val vis = if method.visibility != "": "{method.visibility} " else: ""
    val unsafe_kw = if method.unsafe_fn: "unsafe " else: ""
    val generics_str = format_impl_generics(method.generics)
    val where_str = format_method_where(method.where_clauses)

    # Parameters
    var params_list: [text] = []
    if method.self_param != "":
        params_list.push(method.self_param)
    for p in method.params:
        params_list.push("{p.name}: {p.rust_type}")
    val params_str = params_list.join(", ")

    # Return type
    val return_str = if method.return_type != "" and method.return_type != "()":
        " -> {method.return_type}"
    else:
        ""

    out = out + "    {vis}{unsafe_kw}fn {method.name}{generics_str}({params_str}){return_str}{where_str} {{\n"

    # Body - indent each line
    for line in method.body.split("\n"):
        if line.trim() != "":
            out = out + "        {line}\n"
        else:
            out = out + "\n"

    out = out + "    }}\n"
    out

# ============================================================================
# Helper Functions
# ============================================================================

fn format_impl_generics(generics: [text]) -> text:
    if generics.len() == 0:
        ""
    else:
        "<{generics.join(\", \")}>"

fn format_impl_where(where_clauses: [text]) -> text:
    if where_clauses.len() == 0:
        ""
    else:
        "\nwhere\n    {where_clauses.join(\",\\n    \")}"

fn format_method_where(where_clauses: [text]) -> text:
    if where_clauses.len() == 0:
        ""
    else:
        "\n    where\n        {where_clauses.join(\",\\n        \")}"

# Create an impl block with methods taking &self
fn generate_inherent_impl(type_name: text, methods: [{text: {text: text}}]) -> text:
    var method_specs: [MethodSpec] = []

    for entry in methods:
        for mname in entry.keys():
            val info = entry[mname]
            val self_param = info["self"] ?? "&self"
            val return_type = info["return"] ?? "()"
            val body = info["body"] ?? ""
            method_specs.push(MethodSpec.method(mname, self_param, [], return_type, body))

    val spec = ImplSpec.inherent(type_name, method_specs)
    generate_impl(spec)
