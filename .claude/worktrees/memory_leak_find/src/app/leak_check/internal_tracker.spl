# Leak Check - Internal Allocation Tracker
#
# Module-level allocation ledger that records alloc/free events.
# Used by the internal leak detection mode.

use types

# Module-level allocation ledger
var alloc_ledger: [AllocationRecord] = []

# Reset the allocation ledger
fn tracker_reset():
    alloc_ledger = []

# Record a new allocation
fn tracker_record_alloc(address: i64, size: i64, type_id: text, source_file: text, source_line: i64, source_function: text):
    val record = AllocationRecord(
        address: address,
        size: size,
        type_id: type_id,
        source_file: source_file,
        source_line: source_line,
        source_function: source_function,
        timestamp_us: 0,
        freed: false
    )
    alloc_ledger.push(record)

# Record a free event by marking the matching allocation as freed
fn tracker_record_free(address: i64):
    # Scan backwards to find the most recent matching allocation
    var i = alloc_ledger.len() - 1
    while i >= 0:
        if alloc_ledger[i].address == address and not alloc_ledger[i].freed:
            alloc_ledger[i].freed = true
            return
        i = i - 1

# Get all non-freed allocations (leaked records)
fn tracker_get_leaks() -> [AllocationRecord]:
    var leaks: [AllocationRecord] = []
    for record in alloc_ledger:
        if not record.freed:
            leaks.push(record)
    leaks

# Get total number of tracked allocations
fn tracker_get_alloc_count() -> i64:
    alloc_ledger.len()

# Get total number of freed allocations
fn tracker_get_free_count() -> i64:
    var count = 0
    for record in alloc_ledger:
        if record.freed:
            count = count + 1
    count

# Build histogram by allocation size class
fn tracker_build_histogram_by_size() -> [AllocBucket]:
    var buckets: [AllocBucket] = []
    # 6 size classes
    var b0_count = 0
    var b0_bytes: i64 = 0
    var b1_count = 0
    var b1_bytes: i64 = 0
    var b2_count = 0
    var b2_bytes: i64 = 0
    var b3_count = 0
    var b3_bytes: i64 = 0
    var b4_count = 0
    var b4_bytes: i64 = 0
    var b5_count = 0
    var b5_bytes: i64 = 0

    for record in alloc_ledger:
        if record.freed:
            continue
        if record.size <= 64:
            b0_count = b0_count + 1
            b0_bytes = b0_bytes + record.size
        elif record.size <= 256:
            b1_count = b1_count + 1
            b1_bytes = b1_bytes + record.size
        elif record.size <= 1024:
            b2_count = b2_count + 1
            b2_bytes = b2_bytes + record.size
        elif record.size <= 4096:
            b3_count = b3_count + 1
            b3_bytes = b3_bytes + record.size
        elif record.size <= 65536:
            b4_count = b4_count + 1
            b4_bytes = b4_bytes + record.size
        else:
            b5_count = b5_count + 1
            b5_bytes = b5_bytes + record.size

    if b0_count > 0:
        buckets.push(AllocBucket(label: "0-64B", count: b0_count, total_bytes: b0_bytes))
    if b1_count > 0:
        buckets.push(AllocBucket(label: "64-256B", count: b1_count, total_bytes: b1_bytes))
    if b2_count > 0:
        buckets.push(AllocBucket(label: "256B-1KB", count: b2_count, total_bytes: b2_bytes))
    if b3_count > 0:
        buckets.push(AllocBucket(label: "1-4KB", count: b3_count, total_bytes: b3_bytes))
    if b4_count > 0:
        buckets.push(AllocBucket(label: "4-64KB", count: b4_count, total_bytes: b4_bytes))
    if b5_count > 0:
        buckets.push(AllocBucket(label: "64KB+", count: b5_count, total_bytes: b5_bytes))

    buckets

# Build histogram by source location
fn tracker_build_histogram_by_location() -> [AllocBucket]:
    var buckets: [AllocBucket] = []
    var seen_labels: [text] = []

    for record in alloc_ledger:
        if record.freed:
            continue
        val label = "{record.source_file}:{record.source_line}"
        var found = false
        var bi = 0
        while bi < buckets.len():
            if seen_labels[bi] == label:
                buckets[bi].count = buckets[bi].count + 1
                buckets[bi].total_bytes = buckets[bi].total_bytes + record.size
                found = true
                break
            bi = bi + 1
        if not found:
            seen_labels.push(label)
            buckets.push(AllocBucket(label: label, count: 1, total_bytes: record.size))

    buckets

export tracker_reset, tracker_record_alloc, tracker_record_free
export tracker_get_leaks, tracker_get_alloc_count, tracker_get_free_count
export tracker_build_histogram_by_size, tracker_build_histogram_by_location
