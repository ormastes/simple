# Memory Leak Finder - Main Entry Point
#
# Monitors memory usage while running tests sequentially to detect
# sustained memory growth patterns that may indicate memory leaks.
#
# Usage:
#     simple-leak-finder [options] [test-pattern]
#
# See --help for full options.

use types
use memory
use config
use discovery
use runner
use reporter

use app.io.mod (current_time_unix)

# Get current timestamp in ISO 8601 format
fn now_iso8601() -> text:
    val unix_ts = current_time_unix()
    # Simplified - just return Unix timestamp as string for now
    # Full DateTime would need the time module
    "{unix_ts}"

# Main entry point
fn main() -> i32:
    # Parse command line arguments
    val config_result = config.parse_args()
    val cfg = match config_result:
        case Ok(c): c
        case Err(e):
            if e == "HELP":
                config.print_usage()
                return 0
            else:
                print("Error: {e}")
                print("")
                config.print_usage()
                return 1

    # Check if memory reading is available (Linux only)
    if not memory.is_memory_available():
        print("Error: Memory monitoring requires /proc/meminfo (Linux only)")
        return 1

    # Print configuration if verbose
    if cfg.verbose:
        print(config.format_config(cfg))
        print("")

    # Discover tests
    print("Discovering tests...")
    val tests = discovery.discover_tests(cfg.test_type, cfg.test_pattern)

    if tests.len() == 0:
        print("No tests found.")
        return 0

    print("Found {tests.len()} tests")
    print("")

    # Initialize report
    var report = types.empty_report(types.test_type_to_string(cfg.test_type))
    report.timestamp = now_iso8601()
    report.total_tests = tests.len() as i32

    # Get baseline memory
    val baseline = memory.get_available_memory()
    if baseline < 0:
        print("Error: Failed to read baseline memory")
        return 1
    report.baseline_memory_kb = baseline

    if cfg.verbose:
        print("Baseline memory: {memory.format_memory_kb(baseline)}")
        print("")

    # Run tests and track memory
    var consecutive_growth = 0
    var growth_sum: i64 = 0
    var first_growth_index = 0
    var last_test_before_leak: text = ""

    print("Running tests...")

    for i in 0..tests.len():
        val test = tests[i]

        # Get memory before test
        val mem_before = memory.get_available_memory()
        if mem_before < 0:
            print("Warning: Failed to read memory before test: {test.name}")
            continue

        # Run test
        var result = runner.run_test(test, cfg.timeout_seconds)
        result.memory_before_kb = mem_before

        # Get memory after test
        val mem_after = memory.get_available_memory()
        if mem_after < 0:
            print("Warning: Failed to read memory after test: {test.name}")
            continue

        result.memory_after_kb = mem_after
        result.diff_kb = mem_before - mem_after  # positive = freed, negative = consumed

        # Print progress if verbose
        if cfg.verbose:
            print(runner.format_test_result(result, true))

        # Track memory growth
        if result.diff_kb < -(cfg.threshold_kb):  # Memory consumed > threshold
            if consecutive_growth == 0:
                first_growth_index = i as i32
                last_test_before_leak = test.path
            consecutive_growth = consecutive_growth + 1
            growth_sum = growth_sum + (-result.diff_kb)
        else:
            consecutive_growth = 0
            growth_sum = 0
            first_growth_index = 0

        # Check for leak pattern
        if consecutive_growth >= cfg.consecutive_count:
            val leak = types.LeakEntry(
                test_file: last_test_before_leak,
                consecutive_count: consecutive_growth,
                growth_kb: growth_sum,
                first_test_index: first_growth_index
            )
            report.leaks.push(leak)

            print("")
            print("LEAK DETECTED: {leak.format()}")

            if cfg.stop_on_leak:
                print("Stopping due to --stop-on-leak")
                break

            # Reset after recording leak
            consecutive_growth = 0
            growth_sum = 0

        # Store result
        report.test_runs.push(result)

    # Get final memory
    val final_mem = memory.get_available_memory()
    if final_mem >= 0:
        report.final_memory_kb = final_mem

    # Print or write report
    print("")
    print(reporter.generate_summary(report))

    match cfg.output_file:
        case Some(path):
            match reporter.write_report(report, path):
                case Ok(_):
                    print("Report written to: {path}")
                case Err(e):
                    print("Error: {e}")
                    return 1
        case nil:
            # Already printed summary above
            if cfg.verbose:
                print("")
                print("=== Full SDN Report ===")
                reporter.print_report(report)

    # Exit code based on leaks found
    if report.has_leaks():
        return 1
    else:
        return 0

# Export main
export main
