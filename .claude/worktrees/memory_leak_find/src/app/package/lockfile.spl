# Lockfile Parser and Generator
# Handles simple.lock file operations

use app.io.{file_read, time_now_unix_micros, timestamp_year, timestamp_month, timestamp_day, timestamp_hour, timestamp_minute, timestamp_second}
use std.package_ffi.{path_exists}
use package.types
use package.semver
use std.db_atomic.{atomic_write, DbConfig}

# ============================================================================
# Lockfile Parsing
# ============================================================================

fn parse_lockfile_file(path: text) -> Result<Lockfile, text>:
    """Parse a lockfile from disk"""
    if not path_exists(path):
        return Err("Lockfile not found: {path}")

    val content = file_read(path)
    if content.is_err():
        return Err("Failed to read lockfile: {path}")

    parse_lockfile_string(content.unwrap())

fn parse_lockfile_string(content: text) -> Result<Lockfile, text>:
    """Parse a lockfile from SDN string"""
    # Parse SDN content - need placeholder for now
    # TODO: Implement proper SDN parsing when SDN module is ready
    return Err("SDN parsing not yet implemented for lockfiles")

    # Parse lockfile version (required)
    # val version = sdn.get_int("lockfile_version")?
    # if version != 1:
    #     return Err("Unsupported lockfile version: {version}")

    # Parse generation timestamp (required)
    # val generated = sdn.get_string("generated")?

    # Parse packages table
    # val packages = parse_packages_table(sdn)?

    # Ok(Lockfile(
    #     version: version,
    #     generated: generated,
    #     packages: packages
    # ))

fn parse_packages_table(sdn: SdnValue) -> Result<[LockedPackage], text>:
    """Parse the packages table from lockfile"""
    # TODO: Implement when SDN table parsing is ready
    return Err("Package table parsing not yet implemented")

    # val table = sdn.get_table("packages")?
    #
    # var packages = []
    #
    # # Each row in the table is a package
    # for row in table.rows:
    #     val pkg = parse_locked_package(row)?
    #     packages.push(pkg)
    #
    # Ok(packages)

fn parse_locked_package(row: SdnTableRow) -> Result<LockedPackage, text>:
    """Parse a single locked package from table row

    Columns: name, version, source, checksum, deps (optional)
    """
    val name = row.get_string("name")?
    val version_str = row.get_string("version")?
    val version = parse_version(version_str)?
    val source = row.get_string("source")?
    val checksum = row.get_string("checksum")?

    # Dependencies are optional
    val dependencies = row.get_string_array_opt("deps").unwrap_or([])

    Ok(LockedPackage(
        name: name,
        version: version,
        source: source,
        checksum: checksum,
        dependencies: dependencies
    ))

# ============================================================================
# Lockfile Generation
# ============================================================================

fn generate_lockfile(resolved: [ResolvedDependency]) -> Lockfile:
    """Generate a lockfile from resolved dependencies"""
    var packages = []

    for dep in resolved:
        val pkg = locked_package_from_resolved(dep)
        packages.push(pkg)

    Lockfile(
        version: 1,
        generated: current_iso8601_timestamp(),
        packages: packages
    )

fn locked_package_from_resolved(dep: ResolvedDependency) -> LockedPackage:
    """Convert resolved dependency to locked package"""
    val source_str = dependency_source_to_string(dep.source)
    val checksum = dep.checksum.unwrap_or("sha256:unknown")

    LockedPackage(
        name: dep.name,
        version: dep.version,
        source: source_str,
        checksum: checksum,
        dependencies: []  # Will be populated by resolver
    )

fn dependency_source_to_string(source: DependencySource) -> text:
    """Convert dependency source to lockfile format"""
    match source:
        DependencySource.Registry:
            "registry"

        DependencySource.Git(url, ref):
            val ref_str = match ref:
                GitRef.Tag(name): "tags/{name}"
                GitRef.Branch(name): "branch/{name}"
                GitRef.Commit(hash): hash

            "git+{url}#{ref_str}"

        DependencySource.Path(path):
            "path+{path}"

# ============================================================================
# Lockfile Serialization
# ============================================================================

fn lockfile_to_string(lockfile: Lockfile) -> text:
    """Serialize lockfile to SDN format"""
    var parts = [
        "# Generated by Simple Package Manager",
        "# Do not edit manually",
        "",
        "lockfile_version: {lockfile.version}",
        "generated: {lockfile.generated}",
        "",
        "packages |name, version, source, checksum, deps|"
    ]

    for pkg in lockfile.packages:
        val deps_str = format_dependencies_array(pkg.dependencies)
        parts.push("  {pkg.name}, {pkg.version.to_string()}, {pkg.source}, {pkg.checksum}, {deps_str}")

    parts.join("\n") + "\n"

fn format_dependencies_array(deps: [text]) -> text:
    """Format dependencies array for table"""
    if deps.is_empty():
        return "[]"

    "[" + deps.join(", ") + "]"

fn write_lockfile(lockfile: Lockfile, path: text) -> Result<(), text>:
    """Write lockfile to disk atomically (CRITICAL - dependency management!)"""
    val content = lockfile_to_string(lockfile)

    # Atomic write with backup to prevent lockfile corruption
    val write_result = atomic_write(path, content, DbConfig__defaults())
    if write_result.ok.?:
        Ok(())
    else:
        Err("Failed to write lockfile to {path}: {write_result.unwrap_err()}")

# ============================================================================
# Lockfile Validation
# ============================================================================

fn validate_lockfile(lockfile: Lockfile) -> bool:
    """Validate lockfile integrity

    Checks:
        - All packages have valid checksums
        - All dependency references exist
        - No circular dependencies
    """
    # Check all packages have checksums
    for pkg in lockfile.packages:
        if not validate_checksum(pkg.checksum):
            return false

    # Check all dependency references exist
    for pkg in lockfile.packages:
        for dep_ref in pkg.dependencies:
            val dep_name = extract_package_name_from_ref(dep_ref)
            if not lockfile.has_package(dep_name):
                return false

    true

fn validate_checksum(checksum: text) -> bool:
    """Validate checksum format (must be sha256:hex)"""
    if not checksum.starts_with("sha256:"):
        return false

    # Check length (sha256: + 64 hex chars = 71)
    if checksum.length < 71:
        return false

    true

fn extract_package_name_from_ref(ref: text) -> text:
    """Extract package name from reference like 'http@1.1.0'"""
    val parts = ref.split("@")
    if parts.length > 0:
        parts[0]
    else:
        ref

# ============================================================================
# Lockfile Utilities
# ============================================================================

fn lockfile_path() -> text:
    """Get standard lockfile path for current directory"""
    "./simple.lock"

fn has_lockfile() -> bool:
    """Check if lockfile exists in current directory"""
    path_exists(lockfile_path())

fn current_iso8601_timestamp() -> text:
    """Get current timestamp in ISO 8601 format"""
    val now_micros = time_now_unix_micros()
    format_iso8601_from_micros(now_micros)

fn format_iso8601_from_micros(micros: i64) -> text:
    """Format Unix microseconds as ISO 8601"""
    # Simplified for now - will need proper datetime formatting
    # Format: 2026-02-01T12:34:56Z

    val seconds = micros / 1000000

    # Extract components (simplified) - using functions from app.io.time_ops
    val year = timestamp_year(micros) as i64
    val month = timestamp_month(micros) as i64
    val day = timestamp_day(micros) as i64
    val hour = timestamp_hour(micros) as i64
    val minute = timestamp_minute(micros) as i64
    val second = timestamp_second(micros) as i64

    # Format with zero padding
    "{year:04}-{month:02}-{day:02}T{hour:02}:{minute:02}:{second:02}Z"

# ============================================================================
# SDN Helper Types (Placeholder)
# ============================================================================

struct SdnTableRow:
    """Table row from SDN"""
    fields: Dict<text, text>

    static fn empty() -> SdnTableRow:
        SdnTableRow(fields: {})

    fn get_string(key: text) -> Result<text, text>:
        if self.fields.contains_key(key):
            Ok(self.fields[key])
        else:
            Err("Missing field: {key}")

    fn get_string_array_opt(key: text) -> [text]?:
        if not self.fields.contains_key(key):
            return nil
        val raw = self.fields[key].trim()
        if raw == "[]":
            return Some([])
        if not raw.starts_with("["):
            return nil
        # Strip brackets
        val inner = raw.substring(1, raw.length - 1)
        val parts = inner.split(",")
        val result = parts.map(\s: s.trim())
        Some(result)

struct SdnTable:
    """Table from SDN"""
    columns: [text]
    rows: [SdnTableRow]

    static fn empty() -> SdnTable:
        SdnTable(columns: [], rows: [])

# Extension to SdnValue for table support
# TODO: Implement properly when SDN module is stabilized
# impl SdnValue:
#     fn get_string(key: text) -> Result<text, text>:
#         val child = self.get(key)
#         if child.?:
#             val s = child.unwrap().as_str()
#             if s.?:
#                 Ok(s.unwrap())
#             else:
#                 Err("Field '{key}' is not a string")
#         else:
#             Err("Missing field: {key}")
#
#     fn get_int(key: text) -> Result<i64, text>:
#         val child = self.get(key)
#         if child.?:
#             val n = child.unwrap().as_i64()
#             if n.?:
#                 Ok(n.unwrap())
#             else:
#                 Err("Field '{key}' is not an integer")
#         else:
#             Err("Missing field: {key}")
#
#     fn get_table(key: text) -> Result<SdnTable, text>:
#         val child = self.get(key)
#         if not child.?:
#             return Err("Missing table: {key}")
#         val table_val = child.unwrap()
#         if not table_val.is_table():
#             return Err("Field '{key}' is not a table")
#         # Extract table fields and rows from SdnValue.Table
#         match table_val:
#             case SdnValue.Table(fields_opt, types_opt, raw_rows):
#                 val columns = fields_opt ?? []
#                 var rows: [SdnTableRow] = []
#                 for raw_row in raw_rows:
#                     var row_fields: Dict<text, text> = {}
#                     var ci = 0
#                     while ci < columns.len() and ci < raw_row.len():
#                         val cell_str = raw_row[ci].as_str() ?? raw_row[ci].to_text()
#                         row_fields[columns[ci]] = cell_str
#                         ci = ci + 1
#                     rows.push(SdnTableRow(fields: row_fields))
#                 Ok(SdnTable(columns: columns, rows: rows))
#             case _:
#                 Err("Field '{key}' is not a table")
# ============================================================================
# Lockfile Comparison (for updates)
# ============================================================================

fn compare_lockfiles(old: Lockfile, new: Lockfile) -> LockfileChanges:
    """Compare two lockfiles to find changes"""
    var added = []
    var removed = []
    var updated = []

    # Find added packages
    for pkg in new.packages:
        if not old.has_package(pkg.name):
            added.push(pkg.name)

    # Find removed packages
    for pkg in old.packages:
        if not new.has_package(pkg.name):
            removed.push(pkg.name)

    # Find updated packages
    for new_pkg in new.packages:
        match old.find_package(new_pkg.name):
            Some(old_pkg):
                if not version_equal(new_pkg.version, old_pkg.version):
                    updated.push((new_pkg.name, old_pkg.version, new_pkg.version))
            nil:
                pass  # Already in added list

    LockfileChanges(
        added: added,
        removed: removed,
        updated: updated
    )

struct LockfileChanges:
    """Changes between two lockfiles"""
    added: [text]
    removed: [text]
    updated: [(text, Version, Version)]  # (name, old_version, new_version)

    fn has_changes() -> bool:
        not (self.added.is_empty() and
             self.removed.is_empty() and
             self.updated.is_empty())

    fn summary() -> text:
        var parts = []

        if not self.added.is_empty():
            parts.push("Added {self.added.length} packages")

        if not self.removed.is_empty():
            parts.push("Removed {self.removed.length} packages")

        if not self.updated.is_empty():
            parts.push("Updated {self.updated.length} packages")

        parts.join("\n") + (if parts.is_empty() then "" else "\n")

export parse_lockfile_file, parse_lockfile_string, generate_lockfile
export lockfile_to_string, write_lockfile
export validate_lockfile, validate_checksum
export compare_lockfiles, LockfileChanges
export lockfile_path, has_lockfile
export SdnTableRow, SdnTable
