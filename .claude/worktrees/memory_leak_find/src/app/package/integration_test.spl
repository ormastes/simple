# Package Manager - Integration Test
# Quick test to verify basic functionality

use package.types
use package.semver

print "Package Manager Integration Test"
print "================================="
print ""

# Test 1: Version parsing
print "Test 1: Version Parsing"
val v1 = parse_version("1.2.3")
match v1:
    Ok(version):
        print "  ✓ Parsed version: {version.to_string()}"
        if version.major == 1 and version.minor == 2 and version.patch == 3:
            print "  ✓ Version components correct"
        else:
            print "  ✗ Version components wrong"
    Err(e):
        print "  ✗ Failed to parse: {e}"

print ""

# Test 2: Version with prerelease
print "Test 2: Version with Prerelease"
val v2 = parse_version("2.0.0-alpha.1")
match v2:
    Ok(version):
        print "  ✓ Parsed: {version.to_string()}"
        match version.prerelease:
            Some(pre):
                if pre == "alpha.1":
                    print "  ✓ Prerelease correct: {pre}"
                else:
                    print "  ✗ Wrong prerelease: {pre}"
            nil:
                print "  ✗ Missing prerelease"
    Err(e):
        print "  ✗ Failed: {e}"

print ""

# Test 3: Version comparison
print "Test 3: Version Comparison"
val va = parse_version("2.0.0").unwrap()
val vb = parse_version("1.9.9").unwrap()

if version_greater(va, vb):
    print "  ✓ 2.0.0 > 1.9.9"
else:
    print "  ✗ Comparison failed"

if version_equal(va, va):
    print "  ✓ Version equality works"
else:
    print "  ✗ Equality failed"

print ""

# Test 4: Constraint parsing
print "Test 4: Constraint Parsing"
val c1 = parse_constraint("^1.2.3")
match c1:
    Ok(constraint):
        print "  ✓ Parsed caret constraint: ^1.2.3"
    Err(e):
        print "  ✗ Failed to parse: {e}"

val c2 = parse_constraint("~1.2.3")
match c2:
    Ok(constraint):
        print "  ✓ Parsed tilde constraint: ~1.2.3"
    Err(e):
        print "  ✗ Failed to parse: {e}"

val c3 = parse_constraint("*")
match c3:
    Ok(constraint):
        print "  ✓ Parsed wildcard: *"
    Err(e):
        print "  ✗ Failed to parse: {e}"

print ""

# Test 5: Constraint satisfaction - Caret
print "Test 5: Caret Constraint Satisfaction"
val caret_constraint = parse_constraint("^1.2.3").unwrap()

val v1_2_3 = parse_version("1.2.3").unwrap()
val v1_2_4 = parse_version("1.2.4").unwrap()
val v1_9_9 = parse_version("1.9.9").unwrap()
val v2_0_0 = parse_version("2.0.0").unwrap()

if satisfies(v1_2_3, caret_constraint):
    print "  ✓ ^1.2.3 matches 1.2.3"
else:
    print "  ✗ Should match 1.2.3"

if satisfies(v1_2_4, caret_constraint):
    print "  ✓ ^1.2.3 matches 1.2.4"
else:
    print "  ✗ Should match 1.2.4"

if satisfies(v1_9_9, caret_constraint):
    print "  ✓ ^1.2.3 matches 1.9.9"
else:
    print "  ✗ Should match 1.9.9"

if not satisfies(v2_0_0, caret_constraint):
    print "  ✓ ^1.2.3 does NOT match 2.0.0 (correct)"
else:
    print "  ✗ Should NOT match 2.0.0"

print ""

# Test 6: Constraint satisfaction - 0.x special handling
print "Test 6: Caret 0.x Special Handling"
val caret_0x = parse_constraint("^0.2.3").unwrap()

val v0_2_3 = parse_version("0.2.3").unwrap()
val v0_2_4 = parse_version("0.2.4").unwrap()
val v0_3_0 = parse_version("0.3.0").unwrap()

if satisfies(v0_2_3, caret_0x):
    print "  ✓ ^0.2.3 matches 0.2.3"
else:
    print "  ✗ Should match 0.2.3"

if satisfies(v0_2_4, caret_0x):
    print "  ✓ ^0.2.3 matches 0.2.4"
else:
    print "  ✗ Should match 0.2.4"

if not satisfies(v0_3_0, caret_0x):
    print "  ✓ ^0.2.3 does NOT match 0.3.0 (correct - 0.x is unstable)"
else:
    print "  ✗ Should NOT match 0.3.0"

print ""

# Test 7: Tilde constraint
print "Test 7: Tilde Constraint"
val tilde_constraint = parse_constraint("~1.2.3").unwrap()

val v1_2_9 = parse_version("1.2.9").unwrap()
val v1_3_0 = parse_version("1.3.0").unwrap()

if satisfies(v1_2_9, tilde_constraint):
    print "  ✓ ~1.2.3 matches 1.2.9"
else:
    print "  ✗ Should match 1.2.9"

if not satisfies(v1_3_0, tilde_constraint):
    print "  ✓ ~1.2.3 does NOT match 1.3.0 (correct)"
else:
    print "  ✗ Should NOT match 1.3.0"

print ""

# Test 8: Dependency types
print "Test 8: Dependency Types"

val dep1 = Dependency.registry("http", parse_constraint("^1.0").unwrap())
print "  ✓ Created registry dependency: {dep1.name}"

val dep2 = Dependency.path("utils", "../utils")
print "  ✓ Created path dependency: {dep2.name}"

val dep3 = Dependency.git("mylib", "https://github.com/alice/mylib", GitRef.Tag(name: "v1.0.0"))
print "  ✓ Created git dependency: {dep3.name}"

print ""

# Summary
print "================================="
print "Integration test complete!"
print "All basic functionality working."
