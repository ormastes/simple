#!/usr/bin/env simple
# Git-to-JJ wrapper - Redirects git commands to jj equivalents
# This helps LLMs and users transitioning from git to jj
#
# Usage: git_wrapper <git-command> [args...]
# Migrated from: scripts/jj-wrappers/git.sh

use app.io

export main, translate_git_command

fn main():
    val args = get_args()

    if args.len() == 0:
        show_usage()
        exit(0)

    val git_cmd = args[0]
    val cmd_args = if args.len() > 1: args[1:] else: []

    print "NOTE: This project uses jj (Jujutsu) instead of git."
    print "      Please use 'jj' commands directly next time."
    print "      Translating 'git {git_cmd}' -> jj equivalent..."
    print ""

    val exit_code = translate_git_command(git_cmd, cmd_args)
    exit(exit_code)

fn translate_git_command(cmd: text, args: [text]) -> i64:
    """Translate git command to jj equivalent and execute it"""
    match cmd:
        "status":
            run_jj(["status"] + args)

        "diff":
            run_jj(["diff"] + args)

        "log":
            run_jj(["log"] + args)

        "add":
            print "Note: jj auto-tracks files, no need to add"
            run_jj(["status"])

        "commit":
            handle_commit(args)

        "push":
            run_jj(["git", "push"] + args)

        "pull", "fetch":
            run_jj(["git", "fetch"] + args)

        "checkout":
            run_jj(["edit"] + args)

        "branch":
            run_jj(["bookmark"] + args)

        "stash":
            print "Note: jj doesn't need stash - changes are always preserved"
            run_jj(["status"])

        "init":
            run_jj(["git", "init"] + args)

        "clone":
            run_jj(["git", "clone"] + args)

        "show":
            run_jj(["show"] + args)

        "reset":
            print "Note: use 'jj restore' or 'jj abandon' instead of git reset"
            run_jj(["status"])

        _:
            print "Unknown git command: {cmd}"
            print "Use jj directly. Common commands:"
            print "  jj status, jj diff, jj log, jj commit, jj describe"
            print "  jj git push, jj git fetch, jj edit, jj new"
            1

fn handle_commit(args: [text]) -> i64:
    """Handle git commit command with -m flag parsing"""
    if args.len() == 0:
        return run_jj(["commit"])

    # Check for -m flag
    if args[0] == "-m":
        if args.len() > 1:
            # Combine message args
            val message_parts = args[1:]
            val message = message_parts.join(" ")
            return run_jj(["commit", "-m", message])
        else:
            print "Error: -m requires a message"
            return 1

    # Pass through other args
    run_jj(["commit"] + args)

fn run_jj(args: [text]) -> i64:
    """Run jj command and return exit code"""
    val (stdout, stderr, code) = process_run("jj", args)

    if stdout.len() > 0:
        print stdout

    if stderr.len() > 0:
        print stderr

    code

fn show_usage():
    """Show usage information"""
    print "Git-to-JJ Wrapper"
    print ""
    print "Usage: git_wrapper <git-command> [args...]"
    print ""
    print "This wrapper translates git commands to jj (Jujutsu) equivalents."
    print "Consider using jj directly instead:"
    print ""
    print "Common translations:"
    print "  git status        -> jj status"
    print "  git diff          -> jj diff"
    print "  git log           -> jj log"
    print "  git add           -> (auto-tracked, use jj status)"
    print "  git commit -m ... -> jj commit -m ..."
    print "  git push          -> jj git push"
    print "  git pull/fetch    -> jj git fetch"
    print "  git checkout      -> jj edit"
    print "  git branch        -> jj bookmark"
    print "  git stash         -> (not needed, changes preserved)"
    print "  git reset         -> jj restore / jj abandon"
