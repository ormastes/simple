#!/usr/bin/env simple
# Simplified File I/O Protection MCP Server
# Minimal version that works in interpreted mode

# Direct extern declarations (no imports)
extern fn rt_file_write_text(path: text, content: text) -> bool
extern fn rt_file_read_text(path: text) -> text
extern fn rt_file_exists(path: text) -> bool
extern fn rt_file_delete(path: text) -> bool

# Simple protection check
fn check_protection(path: text, operation: text) -> text:
    # Check for protected patterns
    if path == "CLAUDE.md" or path == "README.md" or path == "MEMORY.md":
        if operation == "write" or operation == "delete":
            return "DENIED: File is protected (read-only)"
        return "ALLOWED"

    # Check for test files (redirect to temp)
    if path.starts_with("test") and path.ends_with(".txt"):
        return "REDIRECT: /tmp/fileio_temp/{path}"

    if path.starts_with("mcp_test"):
        return "REDIRECT: /tmp/fileio_temp/{path}"

    # Check for shell scripts (redirect)
    if path.ends_with(".sh"):
        return "REDIRECT: /tmp/fileio_temp/{path}"

    # Check for git directory (deny all)
    if path.starts_with(".git/") or path.starts_with(".jj/"):
        return "DENIED: Version control directory"

    # Check for lock files (deny)
    if path.ends_with(".lock"):
        return "DENIED: Lock files are system managed"

    # Check for SDN files (atomic required)
    if path.ends_with(".sdn"):
        return "ATOMIC: Database files require atomic writes"

    # Allow build and temp directories
    if path.starts_with("build/") or path.starts_with("tmp/") or path.starts_with("/tmp/"):
        return "ALLOWED"

    # Default: DENY root-level files (no directory separator)
    if not path.contains("/"):
        return "DENIED: Root-level files not allowed (use /tmp/ or build/)"

    # Allow subdirectories by default
    return "ALLOWED"

# Handle safe_write tool
fn handle_safe_write(path: text, content: text) -> text:
    val protection = check_protection(path, "write")

    if protection.starts_with("DENIED"):
        return "ERROR: {protection}"

    if protection.starts_with("REDIRECT"):
        val redirect_path = "/tmp/fileio_temp/{path}"
        val success = rt_file_write_text(redirect_path, content)
        if success:
            return "OK: File written to {redirect_path}"
        else:
            return "ERROR: Failed to write to temp"

    if protection.starts_with("ATOMIC"):
        return "ERROR: Atomic write required (use safe_atomic_write)"

    # ALLOWED
    val success = rt_file_write_text(path, content)
    if success:
        return "OK: File written to {path}"
    else:
        return "ERROR: Write failed"

# Handle safe_read tool
fn handle_safe_read(path: text) -> text:
    val protection = check_protection(path, "read")

    if protection.starts_with("DENIED"):
        return "ERROR: {protection}"

    if rt_file_exists(path):
        val content = rt_file_read_text(path)
        return "OK: {content}"
    else:
        return "ERROR: File not found"

# Handle check_protection tool
fn handle_check_protection(path: text) -> text:
    val result = check_protection(path, "write")
    return "PROTECTION: {result}"

# Main entry point
fn main():
    print "=== Simplified File I/O Protection MCP ===="
    print "Server started (interactive mode)"
    print ""
    print "Available commands:"
    print "  write <path> <content> - Write file with protection"
    print "  read <path> - Read file with protection"
    print "  check <path> - Check protection status"
    print "  quit - Exit"
    print ""

    loop:
        print "> "
        val line = input("")

        if line.len() == 0 or line == "quit":
            break

        if line.starts_with("write "):
            val parts = line[6:].split(" ")
            if parts.len() >= 2:
                val path = parts[0]
                val content = parts[1]
                val result = handle_safe_write(path, content)
                print result
            else:
                print "ERROR: Usage: write <path> <content>"

        elif line.starts_with("read "):
            val path = line[5:]
            val result = handle_safe_read(path)
            print result

        elif line.starts_with("check "):
            val path = line[6:]
            val result = handle_check_protection(path)
            print result

        else:
            print "ERROR: Unknown command: {line}"

        print ""
