# MCP Debug Session Types
#
# Session state types, breakpoint tracking, and session management
# for the MCP debug tools subsystem.

use app.mcp.helpers.{parse_int}

# --- Session State Types ---

enum SessionState:
    Created
    Running
    Paused
    Stopped
    Terminated

enum TargetType:
    Interpreter
    Smf
    Native
    Remote

# Breakpoint within a session
class SessionBreakpoint:
    id: Int
    file: String
    line: Int
    condition: String

# Debug session
class DebugSession:
    id: String
    program: String
    target_type: String
    state: String
    breakpoints: [SessionBreakpoint]
    next_bp_id: Int

# Session manager - holds all debug sessions
class SessionManager:
    sessions: [DebugSession]
    next_session_id: Int

    static fn empty() -> SessionManager:
        SessionManager(sessions: [], next_session_id: 1)

    me create_session(program: String, target_type: String) -> DebugSession:
        val sid = "session_" + self.next_session_id.to_string()
        self.next_session_id = self.next_session_id + 1
        val session = DebugSession(
            id: sid,
            program: program,
            target_type: target_type,
            state: "created",
            breakpoints: [],
            next_bp_id: 1
        )
        self.sessions = self.sessions + [session]
        session

    fn find_session(session_id: String) -> Int:
        # Returns index or -1 if not found
        var idx = 0
        for s in self.sessions:
            if s.id == session_id:
                return idx
            idx = idx + 1
        return -1

    me remove_session(session_id: String) -> Bool:
        var new_sessions = []
        var found = false
        for s in self.sessions:
            if s.id == session_id:
                found = true
            else:
                new_sessions = new_sessions + [s]
        self.sessions = new_sessions
        found

    fn list_sessions() -> [DebugSession]:
        self.sessions

    me add_breakpoint(session_id: String, file: String, line: Int, condition: String) -> String:
        val idx = self.find_session(session_id)
        if idx < 0:
            return ""
        var session = self.sessions[idx]
        val bp_id = session.next_bp_id
        session.next_bp_id = session.next_bp_id + 1
        val bp = SessionBreakpoint(id: bp_id, file: file, line: line, condition: condition)
        session.breakpoints = session.breakpoints + [bp]
        self.sessions[idx] = session
        bp_id.to_string()

    me remove_breakpoint(session_id: String, bp_id_str: String) -> Bool:
        val idx = self.find_session(session_id)
        if idx < 0:
            return false
        var session = self.sessions[idx]
        val bp_id_result = parse_int(bp_id_str)
        var bp_id = -1
        match bp_id_result:
            Ok(v): bp_id = v
            Err(_): return false
        var new_bps = []
        var found = false
        for bp in session.breakpoints:
            if bp.id == bp_id:
                found = true
            else:
                new_bps = new_bps + [bp]
        session.breakpoints = new_bps
        self.sessions[idx] = session
        found

    me set_state(session_id: String, new_state: String) -> Bool:
        val idx = self.find_session(session_id)
        if idx < 0:
            return false
        var session = self.sessions[idx]
        session.state = new_state
        self.sessions[idx] = session
        true

# --- Exports ---

export SessionState, TargetType, SessionBreakpoint, DebugSession, SessionManager
