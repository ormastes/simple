# Volatile Memory Operations - SFFI Wrappers
#
# Provides volatile read/write primitives for memory-mapped I/O (MMIO).
# Essential for embedded systems where compiler optimizations must not
# reorder or eliminate hardware register accesses.
#
# SFFI pattern:
#   - extern fn rt_volatile_* : raw runtime bindings
#   - fn volatile_* : Simple API wrappers
#
# Usage:
#   val gpio_in = volatile_read_u32(0x40020010)
#   volatile_write_u32(0x40020014, 0x0001)
#   memory_barrier()
#
# Memory Barriers:
#   memory_barrier()  - full fence (prevents reordering across barrier)
#   load_barrier()    - acquire fence (loads before barrier are visible)
#   store_barrier()   - release fence (stores before barrier are committed)

# ============================================================================
# Extern Declarations - Volatile Reads
# ============================================================================

extern fn rt_volatile_read_u8(addr: i64) -> i64
extern fn rt_volatile_read_u16(addr: i64) -> i64
extern fn rt_volatile_read_u32(addr: i64) -> i64
extern fn rt_volatile_read_u64(addr: i64) -> i64

# Interpreter fallback stubs (ignored in compiled mode where externs are provided)
fn rt_volatile_read_u8__fallback(addr: i64) -> i64: 0
fn rt_volatile_read_u16__fallback(addr: i64) -> i64: 0
fn rt_volatile_read_u32__fallback(addr: i64) -> i64: 0
fn rt_volatile_read_u64__fallback(addr: i64) -> i64: 0

# ============================================================================
# Extern Declarations - Volatile Writes
# ============================================================================

extern fn rt_volatile_write_u8(addr: i64, value: i64)
extern fn rt_volatile_write_u16(addr: i64, value: i64)
extern fn rt_volatile_write_u32(addr: i64, value: i64)
extern fn rt_volatile_write_u64(addr: i64, value: i64)

fn rt_volatile_write_u8__fallback(addr: i64, value: i64): ()
fn rt_volatile_write_u16__fallback(addr: i64, value: i64): ()
fn rt_volatile_write_u32__fallback(addr: i64, value: i64): ()
fn rt_volatile_write_u64__fallback(addr: i64, value: i64): ()

# ============================================================================
# Extern Declarations - Memory Barriers
# ============================================================================

extern fn rt_memory_barrier()
extern fn rt_load_barrier()
extern fn rt_store_barrier()

fn rt_memory_barrier__fallback(): ()
fn rt_load_barrier__fallback(): ()
fn rt_store_barrier__fallback(): ()

# ============================================================================
# Simple API - Volatile Reads
# ============================================================================

fn volatile_read_u8(addr: i64) -> i64:
    # Read a single byte from a volatile memory address.
    if has_runtime_volatiles():
        rt_volatile_read_u8(addr)
    else:
        rt_volatile_read_u8__fallback(addr)

fn volatile_read_u16(addr: i64) -> i64:
    # Read a 16-bit value from a volatile memory address.
    if has_runtime_volatiles():
        rt_volatile_read_u16(addr)
    else:
        rt_volatile_read_u16__fallback(addr)

fn volatile_read_u32(addr: i64) -> i64:
    # Read a 32-bit value from a volatile memory address.
    if has_runtime_volatiles():
        rt_volatile_read_u32(addr)
    else:
        rt_volatile_read_u32__fallback(addr)

fn volatile_read_u64(addr: i64) -> i64:
    # Read a 64-bit value from a volatile memory address.
    if has_runtime_volatiles():
        rt_volatile_read_u64(addr)
    else:
        rt_volatile_read_u64__fallback(addr)

# ============================================================================
# Simple API - Volatile Writes
# ============================================================================

fn volatile_write_u8(addr: i64, value: i64):
    # Write a single byte to a volatile memory address.
    if has_runtime_volatiles():
        rt_volatile_write_u8(addr, value)
    else:
        rt_volatile_write_u8__fallback(addr, value)

fn volatile_write_u16(addr: i64, value: i64):
    # Write a 16-bit value to a volatile memory address.
    if has_runtime_volatiles():
        rt_volatile_write_u16(addr, value)
    else:
        rt_volatile_write_u16__fallback(addr, value)

fn volatile_write_u32(addr: i64, value: i64):
    # Write a 32-bit value to a volatile memory address.
    if has_runtime_volatiles():
        rt_volatile_write_u32(addr, value)
    else:
        rt_volatile_write_u32__fallback(addr, value)

fn volatile_write_u64(addr: i64, value: i64):
    # Write a 64-bit value to a volatile memory address.
    if has_runtime_volatiles():
        rt_volatile_write_u64(addr, value)
    else:
        rt_volatile_write_u64__fallback(addr, value)

# ============================================================================
# Simple API - Memory Barriers
# ============================================================================

fn memory_barrier():
    # Full memory barrier. Prevents reordering of loads and stores.
    if has_runtime_volatiles():
        rt_memory_barrier()
    else:
        rt_memory_barrier__fallback()

fn load_barrier():
    # Acquire barrier. All loads after this point see stores from before.
    if has_runtime_volatiles():
        rt_load_barrier()
    else:
        rt_load_barrier__fallback()

fn store_barrier():
    # Release barrier. All stores before this point are visible after.
    if has_runtime_volatiles():
        rt_store_barrier()
    else:
        rt_store_barrier__fallback()

fn has_runtime_volatiles() -> bool:
    # Interpreter canâ€™t resolve externs; compiled mode will link them.
    # Detect via env hint (set by test runner) or default to false in interpreter.
    # When compiled, runtime will rewrite this function to return true.
    false

# ============================================================================
# Utility
# ============================================================================

fn volatile_read_modify_write_u32(addr: i64, mask: i64, value: i64):
    # Atomic read-modify-write on a 32-bit volatile register.
    # Clears the bits in mask, then sets the bits in value.
    val current = volatile_read_u32(addr)
    val mask_inv = mask_invert_u32(mask)
    val cleared = bitand_u32(current, mask_inv)
    val updated = bitor_u32(cleared, bitand_u32(value, mask))
    volatile_write_u32(addr, updated)

fn bitand_u32(a: i64, b: i64) -> i64:
    # Bitwise AND for 32-bit values using arithmetic.
    var result: i64 = 0
    var bit: i64 = 1
    var i: i64 = 0
    while i < 32:
        if (a / bit) % 2 == 1 and (b / bit) % 2 == 1:
            result = result + bit
        bit = bit * 2
        i = i + 1
    result

fn bitor_u32(a: i64, b: i64) -> i64:
    # Bitwise OR for 32-bit values using arithmetic.
    var result: i64 = 0
    var bit: i64 = 1
    var i: i64 = 0
    while i < 32:
        val a_bit = (a / bit) % 2
        val b_bit = (b / bit) % 2
        if a_bit == 1 or b_bit == 1:
            result = result + bit
        bit = bit * 2
        i = i + 1
    result

fn mask_invert_u32(mask: i64) -> i64:
    # Invert a 32-bit mask (ones complement within 32 bits).
    val max_u32: i64 = 4294967295
    max_u32 - mask

# ============================================================================
# Exports
# ============================================================================

export volatile_read_u8, volatile_read_u16, volatile_read_u32, volatile_read_u64
export volatile_write_u8, volatile_write_u16, volatile_write_u32, volatile_write_u64
export memory_barrier, load_barrier, store_barrier
export volatile_read_modify_write_u32
export bitand_u32, bitor_u32, mask_invert_u32
