# tools_jj_misc.spl - Miscellaneous tools (13 tools)
#
# Tools: tag_list, op_log, op_undo, op_restore, workspace_add, workspace_list,
#        workspace_forget, sparse_list, sparse_set, conflict_list, resolve,
#        config_get, config_set

use app.mcp_jj.helpers.{LB, RB, Q, jp, js, jo1, jo2, jo3, escape_json, make_tool_result, make_error_response, make_tool_schema_multi, make_tool_schema, make_no_param_tool, make_prop, make_prop_bool, make_prop_int, extract_nested_string, extract_arguments_dict, handle_jj_result, handle_jj_result_stdout}
use app.mcp_jj.jj_runner.{JjResult, jj_run, jj_run_with_args, shell_quote}

# =============================================================================
# TAGS (1 tool)
# =============================================================================

# --- 36. jj_tag_list ---

fn schema_jj_tag_list() -> String:
    make_no_param_tool("jj_tag_list", "List all tags in the repository", true, false, true)

fn handle_jj_tag_list(id: String, body: String, repo_path: String) -> String:
    handle_jj_result_stdout(id, jj_run("tag list", repo_path))

# =============================================================================
# OPERATION HISTORY (3 tools)
# =============================================================================

# --- 37. jj_op_log ---

fn schema_jj_op_log() -> String:
    make_tool_schema("jj_op_log", "Show the history of jj operations", "limit", "Max number of operations to show", false, true, false, true)

fn handle_jj_op_log(id: String, body: String, repo_path: String) -> String:
    val limit = extract_nested_string(body, "arguments", "limit")
    var cmd = "op log"
    if limit != "":
        cmd = cmd + " -n " + limit
    handle_jj_result_stdout(id, jj_run(cmd, repo_path))

# --- 38. jj_op_undo ---

fn schema_jj_op_undo() -> String:
    make_no_param_tool("jj_op_undo", "Undo the most recent jj operation", false, true, false)

fn handle_jj_op_undo(id: String, body: String, repo_path: String) -> String:
    handle_jj_result(id, jj_run("op undo", repo_path))

# --- 39. jj_op_restore ---

fn schema_jj_op_restore() -> String:
    make_tool_schema("jj_op_restore", "Restore the repository to the state at a specific operation", "operation", "Operation ID to restore to", true, false, true, false)

fn handle_jj_op_restore(id: String, body: String, repo_path: String) -> String:
    val operation = extract_nested_string(body, "arguments", "operation")
    if operation == "":
        return make_error_response(id, -32602, "Missing required parameter: operation")
    var cmd = "op restore " + operation
    handle_jj_result(id, jj_run(cmd, repo_path))

# =============================================================================
# WORKSPACE (3 tools)
# =============================================================================

# --- 40. jj_workspace_add ---

fn schema_jj_workspace_add() -> String:
    var props = LB()
    props = props + make_prop("path", "Path for the new workspace")
    props = props + "," + make_prop("name", "Name for the workspace")
    props = props + RB()
    make_tool_schema_multi("jj_workspace_add", "Add a new workspace at a specified path", props, "[" + js("path") + "]", false, false, false)

fn handle_jj_workspace_add(id: String, body: String, repo_path: String) -> String:
    val path = extract_nested_string(body, "arguments", "path")
    val name = extract_nested_string(body, "arguments", "name")
    if path == "":
        return make_error_response(id, -32602, "Missing required parameter: path")
    var cmd = "workspace add"
    if name != "":
        cmd = cmd + " --name " + name
    cmd = cmd + " " + path
    handle_jj_result(id, jj_run(cmd, repo_path))

# --- 41. jj_workspace_list ---

fn schema_jj_workspace_list() -> String:
    make_no_param_tool("jj_workspace_list", "List all workspaces in the repository", true, false, true)

fn handle_jj_workspace_list(id: String, body: String, repo_path: String) -> String:
    handle_jj_result_stdout(id, jj_run("workspace list", repo_path))

# --- 42. jj_workspace_forget ---

fn schema_jj_workspace_forget() -> String:
    make_tool_schema("jj_workspace_forget", "Forget a workspace and stop tracking it", "name", "Name of the workspace to forget", true, false, true, false)

fn handle_jj_workspace_forget(id: String, body: String, repo_path: String) -> String:
    val name = extract_nested_string(body, "arguments", "name")
    if name == "":
        return make_error_response(id, -32602, "Missing required parameter: name")
    var cmd = "workspace forget " + name
    handle_jj_result(id, jj_run(cmd, repo_path))

# =============================================================================
# SPARSE (2 tools)
# =============================================================================

# --- 43. jj_sparse_list ---

fn schema_jj_sparse_list() -> String:
    make_no_param_tool("jj_sparse_list", "List the current sparse patterns for the working copy", true, false, true)

fn handle_jj_sparse_list(id: String, body: String, repo_path: String) -> String:
    handle_jj_result_stdout(id, jj_run("sparse list", repo_path))

# --- 44. jj_sparse_set ---

fn schema_jj_sparse_set() -> String:
    var props = LB()
    props = props + make_prop("add", "Paths to add to the sparse set")
    props = props + "," + make_prop("remove", "Paths to remove from the sparse set")
    props = props + "," + make_prop_bool("clear", "Clear all sparse patterns first")
    props = props + RB()
    make_tool_schema_multi("jj_sparse_set", "Set which paths are included in the sparse working copy", props, "[]", false, false, false)

fn handle_jj_sparse_set(id: String, body: String, repo_path: String) -> String:
    val add = extract_nested_string(body, "arguments", "add")
    val remove = extract_nested_string(body, "arguments", "remove")
    val clear = extract_nested_string(body, "arguments", "clear")
    var cmd = "sparse set"
    if clear == "true":
        cmd = cmd + " --clear"
    if add != "":
        cmd = cmd + " --add " + add
    if remove != "":
        cmd = cmd + " --remove " + remove
    handle_jj_result(id, jj_run(cmd, repo_path))

# =============================================================================
# CONFLICTS (2 tools)
# =============================================================================

# --- 45. jj_conflict_list ---

fn schema_jj_conflict_list() -> String:
    make_no_param_tool("jj_conflict_list", "List files with unresolved conflicts in the working copy", true, false, true)

fn handle_jj_conflict_list(id: String, body: String, repo_path: String) -> String:
    handle_jj_result_stdout(id, jj_run("resolve --list", repo_path))

# --- 46. jj_resolve ---

fn schema_jj_resolve() -> String:
    make_tool_schema("jj_resolve", "Start conflict resolution for a file", "path", "File path to resolve", false, false, false, false)

fn handle_jj_resolve(id: String, body: String, repo_path: String) -> String:
    val path = extract_nested_string(body, "arguments", "path")
    var cmd = "resolve"
    if path != "":
        cmd = cmd + " " + path
    handle_jj_result(id, jj_run(cmd, repo_path))

# =============================================================================
# CONFIG (2 tools)
# =============================================================================

# --- 47. jj_config_get ---

fn schema_jj_config_get() -> String:
    make_tool_schema("jj_config_get", "Get a jj configuration value", "name", "Configuration key name", true, true, false, true)

fn handle_jj_config_get(id: String, body: String, repo_path: String) -> String:
    val name = extract_nested_string(body, "arguments", "name")
    if name == "":
        return make_error_response(id, -32602, "Missing required parameter: name")
    var cmd = "config get " + name
    handle_jj_result_stdout(id, jj_run(cmd, repo_path))

# --- 48. jj_config_set ---

fn schema_jj_config_set() -> String:
    var props = LB()
    props = props + make_prop("name", "Configuration key name")
    props = props + "," + make_prop("value", "Value to set")
    props = props + RB()
    make_tool_schema_multi("jj_config_set", "Set a jj configuration value", props, "[" + js("name") + "," + js("value") + "]", false, false, true)

fn handle_jj_config_set(id: String, body: String, repo_path: String) -> String:
    val name = extract_nested_string(body, "arguments", "name")
    val value = extract_nested_string(body, "arguments", "value")
    if name == "":
        return make_error_response(id, -32602, "Missing required parameter: name")
    if value == "":
        return make_error_response(id, -32602, "Missing required parameter: value")
    var cmd = "config set --user " + name + " " + value
    handle_jj_result(id, jj_run(cmd, repo_path))

export schema_jj_tag_list
export schema_jj_op_log, schema_jj_op_undo, schema_jj_op_restore
export schema_jj_workspace_add, schema_jj_workspace_list, schema_jj_workspace_forget
export schema_jj_sparse_list, schema_jj_sparse_set
export schema_jj_conflict_list, schema_jj_resolve
export schema_jj_config_get, schema_jj_config_set
export handle_jj_tag_list
export handle_jj_op_log, handle_jj_op_undo, handle_jj_op_restore
export handle_jj_workspace_add, handle_jj_workspace_list, handle_jj_workspace_forget
export handle_jj_sparse_list, handle_jj_sparse_set
export handle_jj_conflict_list, handle_jj_resolve
export handle_jj_config_get, handle_jj_config_set
