# Type Check Command
#
# CLI command for type checking Simple source files.
# Usage: simple check [options] <file>

use app.io*
use compiler.type_system.checker (TypeChecker, TypeError)
use app.parser.parser (parse_file)

# ============================================================================
# Check Command
# ============================================================================

fn run_check(args: [text]) -> i64:
    """Run type checking on a file.

    Returns:
    - 0 on success (no type errors)
    - 1 on type errors
    - 2 on parse errors
    - 3 on file not found
    """

    # Parse arguments
    val (options, files) = parse_check_args(args)

    if files.is_empty():
        eprint("Error: No input files specified")
        eprint("Usage: simple check [options] <file>")
        return 3

    # Check each file
    var total_errors = 0
    for file_path in files:
        val errors = check_file(file_path, options)
        total_errors = total_errors + errors

    if total_errors > 0:
        eprint("\n{total_errors} type error(s) found")
        return 1
    else:
        if options.verbose:
            println("✓ Type checking passed")
        return 0

# ============================================================================
# Check Single File
# ============================================================================

fn check_file(file_path: text, options: CheckOptions) -> i64:
    """Type check a single file. Returns error count."""

    # Check file exists
    if not file_exists(file_path):
        eprint("Error: File not found: {file_path}")
        return 1

    if options.verbose:
        println("Type checking {file_path}...")

    # Parse file
    val parse_result = parse_file(file_path)
    if not parse_result.is_ok():
        eprint("Parse error in {file_path}:")
        eprint("  {parse_result.err.unwrap()}")
        return 1

    val module = parse_result.unwrap()

    # Type check
    val checker = TypeChecker.create()
    val check_result = checker.check_module(module)

    match check_result:
        case Ok(_):
            if options.verbose:
                println("✓ {file_path} - no type errors")

            # Show inferred types if requested
            if options.show_types:
                show_inferred_types(checker, module)

            return 0

        case Err(error):
            # Print type error
            print_type_error(file_path, error, options)
            return 1

# ============================================================================
# Error Reporting
# ============================================================================

fn print_type_error(file_path: text, error: TypeError, options: CheckOptions):
    """Pretty-print a type error."""

    eprint("Type error in {file_path}:")

    match error:
        case Undefined(name):
            eprint("  Undefined identifier: {name}")
            if options.suggest_fixes:
                suggest_undefined_fix(name)

        case TypeMismatch(expected, found):
            eprint("  Type mismatch:")
            eprint("    Expected: {expected}")
            eprint("    Found:    {found}")

        case ConstKeyNotFound(key, expected_keys):
            eprint("  Unknown key '{key}'")
            eprint("  Expected one of: {expected_keys.join(", ")}")

        case ConstKeyMissing(key, provided_keys):
            eprint("  Missing required key '{key}'")
            eprint("  Provided: {provided_keys.join(", ")}")

        case CoherenceError(msg):
            eprint("  Trait coherence error: {msg}")

        case Other(msg):
            eprint("  {msg}")

fn suggest_undefined_fix(name: text):
    """Suggest fixes for undefined identifiers."""
    # Did-you-mean suggestions (Phase 1B.3 - TODO #0 ✅)
    # Infrastructure in error_formatter.spl (levenshtein_distance, find_similar_names)
    # Would integrate here when symbol table access is available
    eprint("  Hint: Check if '{name}' is imported or defined")

# ============================================================================
# Type Display
# ============================================================================

fn show_inferred_types(checker: TypeChecker, module: ast.Module):
    """Show inferred types for top-level definitions."""

    println("\nInferred types:")

    for (name, ty) in checker.env:
        # Filter out built-ins
        if not is_builtin(name):
            println("  {name}: {type_to_string(ty)}")

fn is_builtin(name: text) -> bool:
    """Check if name is a built-in."""
    val builtins = [
        "print", "println", "eprint", "eprint",
        "len", "type", "str", "int",
        "spawn", "await", "async",
        "Some", "None", "Ok", "Err"
    ]
    builtins.contains(name)

fn type_to_string(ty: Type) -> text:
    """Convert type to human-readable string."""
    match ty:
        case Int(bits, signed):
            if signed: "i{bits}" else: "u{bits}"
        case Float(bits): "f{bits}"
        case Bool: "bool"
        case Str: "text"
        case Nil: "nil"
        case Unit: "()"
        case Var(id): "?{id.id}"
        case Function(params, ret):
            val param_strs = params.map(\p: type_to_string(p))
            "fn({param_strs.join(", ")}) -> {type_to_string(ret)}"
        case Array(elem, _): "[{type_to_string(elem)}]"
        case Tuple(elements):
            val elem_strs = elements.map(\e: type_to_string(e))
            "({elem_strs.join(", ")})"
        case Optional(inner): "{type_to_string(inner)}?"
        case Result(ok, err): "Result<{type_to_string(ok)}, {type_to_string(err)}>"
        case Struct(name, _, _): name
        case Enum(name, _, _): name
        case Class(name, _): name
        case Named(name): name
        case Union(types):
            val type_strs = types.map(\t: type_to_string(t))
            type_strs.join(" | ")
        case Dict(key, value): "Dict<{type_to_string(key)}, {type_to_string(value)}>"
        case Generic(base, args):
            val arg_strs = args.map(\a: type_to_string(a))
            "{base}<{arg_strs.join(", ")}>"
        case Borrow(inner): "&{type_to_string(inner)}"
        case BorrowMut(inner): "&mut {type_to_string(inner)}"
        case _: "unknown"

# ============================================================================
# Options Parsing
# ============================================================================

struct CheckOptions:
    verbose: bool
    show_types: bool
    suggest_fixes: bool
    trace: bool

fn parse_check_args(args: [text]) -> (CheckOptions, [text]):
    """Parse check command arguments.

    Returns (options, files)
    """

    var options = CheckOptions(
        verbose: false,
        show_types: false,
        suggest_fixes: true,
        trace: false
    )

    var files: [text] = []

    for arg in args:
        match arg:
            case "--verbose" | "-v":
                options.verbose = true
            case "--show-types" | "-t":
                options.show_types = true
            case "--no-suggestions":
                options.suggest_fixes = false
            case "--trace":
                options.trace = true
            case "--help" | "-h":
                print_check_help()
                # Exit handled by caller
            case _:
                # File argument
                if not arg.starts_with("-"):
                    files = files.push(arg)
                else:
                    eprint("Warning: Unknown option: {arg}")

    (options, files)

fn print_check_help():
    """Print help message for check command."""
    println("simple check - Type check Simple source files")
    println("")
    println("USAGE:")
    println("    simple check [OPTIONS] <file>...")
    println("")
    println("OPTIONS:")
    println("    -v, --verbose         Verbose output")
    println("    -t, --show-types      Show inferred types")
    println("    --no-suggestions      Don't suggest fixes")
    println("    --trace               Show type checking trace")
    println("    -h, --help            Print help")
    println("")
    println("EXAMPLES:")
    println("    simple check src/main.spl")
    println("    simple check --verbose src/*.spl")
    println("    simple check --show-types src/lib.spl")

# ============================================================================
# Exports
# ============================================================================

export run_check, check_file
export CheckOptions, parse_check_args
