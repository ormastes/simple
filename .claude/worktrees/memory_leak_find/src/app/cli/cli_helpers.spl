# CLI Helpers - Help Text, Init Command, SDN Parsing
#
# Extracted from main.spl. Contains:
# - print_cli_help: Full CLI help text
# - handle_init: Project initialization
# - read_sdn_run_config: SDN manifest parsing
# - sdn_line_indent, strip_sdn_quotes: SDN helpers
# - check_self_contained: Self-contained binary detection

use app.io.mod (file_exists, file_read, file_write, dir_create, cwd, env_get, shell, file_size_raw)
use app.cli.main.{get_version, print_error, path, atomic_write, DbConfig__defaults}

fn print_cli_help():
    val v = get_version()
    print "Simple Language v{v}"
    print ""
    print "Usage:"
    print "  simple                      Start interactive TUI REPL (default)"
    print "  simple --notui              Start Normal REPL (rustyline-based)"
    print "  simple <file.spl>           Run source file"
    print "  simple <file.smf>           Run compiled binary"
    print "  simple -c \"code\"            Run code string"
    print "  simple compile <src> [-o <out>] [options]  Compile source file"
    print "  simple compile <src> --format=self-contained -o <out>  Self-contained binary"
    print "  simple watch <file.spl>     Watch and auto-recompile"
    print "  simple targets              List available target architectures"
    print "  simple linkers              List available native linkers"
    print ""
    print "Testing:"
    print "  simple test [path]          Run tests (default: test/)"
    print "  simple test --unit          Run unit tests only"
    print "  simple test --integration   Run integration tests only"
    print "  simple test --system        Run system tests only"
    print "  simple test --tag <name>    Filter by tag"
    print "  simple test --fail-fast     Stop on first failure"
    print "  simple test --format <fmt>  Output format: text, json, doc"
    print "  simple test --list-skip-features  List features from .skip files"
    print "  simple test --planned-only  Filter to planned features only"
    print ""
    print "Code Quality:"
    print "  simple lex <file.spl>       Tokenize file (Simple lexer)"
    print "  simple lint [path]          Run linter on file or directory"
    print "  simple lint --fix           Apply auto-fixes"
    print "  simple duplicate-check [path]  Detect code duplication"
    print "  simple fmt [path]           Format file or directory"
    print "  simple fmt --check          Check formatting without changes"
    print "  simple check [path]         Type check without running (NEW: Full type inference)"
    print "  simple check --show-types   Show inferred types"
    print "  simple check --verbose      Verbose type checking output"
    print "  simple check-capsule <path> Validate MDSOC capsule documentation"
    print "  simple check-capsule <path> --json  JSON output"
    print "  simple check-arch [root]    Validate architecture dependency rules"
    print "  simple check-dbs [db...]    Check database integrity"
    print "  simple fix-dbs [db...]      Fix database issues (--dry-run to preview)"
    print "  simple doc-coverage [path]  Check documentation coverage"
    print "  simple doc-coverage --format=json|md|terminal  Output format"
    print "  simple doc-coverage --missing           Show only missing docs"
    print ""
    print "LLM-Friendly Tools:"
    print "  simple mcp <file.spl>       Generate minimal code preview"
    print "  simple diff <old> <new>     Semantic diff"
    print "  simple brief <path>         Brief view for LLM context"
    print "  simple query --generated    Find LLM-generated code"
    print ""
    print "Project Statistics:"
    print "  simple stats                Show project metrics (files, lines, tests, features)"
    print "  simple stats --brief        Show condensed statistics (no docs section)"
    print "  simple stats --verbose      Show detailed statistics (with directory info)"
    print "  simple stats --quick        Skip line counting (faster)"
    print "  simple stats --json         Output as JSON (for CI/CD integration)"
    print "  simple stats --doc-coverage-only        Show only documentation coverage"
    print "  simple stats --format=json|csv          Export format for stats"
    print ""
    print "Verification:"
    print "  simple verify <file.spl>    Run formal verification"
    print "  simple gen-lean generate    Generate Lean verification files"
    print ""
    print "FFI Generation:"
    print "  simple ffi-gen <file.spl>   Generate FFI wrappers from @Lib annotations"
    print "  simple wrapper-gen <spec>   Generate SFFI wrappers for external libraries"
    print ""
    print "Build System:"
    print "  simple build [options]      Build the project"
    print "  simple build test           Run tests"
    print "  simple build clean          Clean build artifacts"
    print "  simple build --warn-docs                Enable doc warnings"
    print "  simple build --warn-docs-level=warn|error   Warning level"
    print "  simple build --target=wasm32-wasi       Compile to WebAssembly"
    print "  simple build --wasm-backend=auto|llvm|wat  WASM backend (default: auto)"
    print ""
    print "Package Management:"
    print "  simple init [name]          Create a new project"
    print "  simple add <pkg> [options]  Add a dependency"
    print "  simple remove <pkg>         Remove a dependency"
    print "  simple install              Install all dependencies"
    print "  simple update [pkg]         Update dependencies"
    print "  simple list                 List installed dependencies"
    print "  simple tree                 Show dependency tree"
    print ""
    print "Options:"
    print "  -h, --help     Show this help"
    print "  -v, --version  Show version"
    print "  -c <code>      Run code string"
    print "  --notui        Use Normal REPL instead of TUI"
    print "  --gc-log       Enable verbose GC logging"
    print "  --gc-off       Disable garbage collection"
    print ""
    print "Execution Mode:"
    print "  --run-config=shared|interpreter|compiler|legacy  Set execution behavior (default: shared)"
    print "  --backend=auto|cranelift|llvm  Select JIT backend (default: auto)"
    print "  --interpret                    Force interpreter mode (no JIT)"
    print "  --interpret-optimized          Alias for shared/optimized interpreter mode"
    print "  --interpreter-mode=optimized|classic  Select interpreter mode (classic is legacy)"
    print "  SIMPLE_EXECUTION_MODE env var  jit|interpret|interpret-optimized|cranelift|llvm"
    print ""
    print "Fault Detection:"
    print "  --no-jit                       Disable JIT compilation (pure tree-walk)"
    print "  --jit-threshold=N              JIT compile after N calls (default: 10)"
    print "  --backend=NAME                 JIT backend: auto, cranelift, llvm"
    print "  --stack-overflow-detection     Enable recursion depth check"
    print "  --no-stack-overflow-detection  Disable recursion depth check"
    print "  --max-recursion-depth=N        Set max call depth (default: 1000)"
    print "  --timeout=N                    Set wall-clock timeout in seconds"
    print "  --execution-limit=N            Set instruction count limit"
    print ""
    print "Examples:"
    print "  simple                      # Start REPL"
    print "  simple hello.spl            # Run source"
    print "  simple -c \"print 42\"        # Run expression"
    print "  simple compile app.spl      # Compile to native"
    print "  simple test                 # Run all tests"

# =========================================================================
# Init command
# =========================================================================

fn handle_init(args: [str]) -> i64:
    val current_dir = cwd()

    # Check if already initialized
    if file_exists("{current_dir}/simple.sdn"):
        print_error("Project already initialized (simple.sdn exists)")
        return 1
    if file_exists("{current_dir}/simple.toml"):
        print_error("Project already initialized (simple.toml exists)")
        return 1

    # Determine project name from args
    # args[0] is "init" command itself, args[1+] are actual arguments
    var name = ""
    var i = 1
    while i < args.len():
        val arg = args[i]
        if not arg.starts_with("-"):
            name = arg
        i = i + 1
    if name == "":
        name = path.basename(current_dir)
    if name == "":
        name = "my-project"

    # Write simple.sdn manifest atomically
    val manifest = "# Simple Package Manifest\n# SDN (Simple Data Notation) format\n\npackage:\n  name: {name}\n  version: 0.1.0\n  license: MIT\n  main: src/main.spl\n\nexecution:\n  run-config: shared\n"
    val write_result = atomic_write("{current_dir}/simple.sdn", manifest, DbConfig__defaults())
    if not write_result.is_ok():
        print_error("Failed to write simple.sdn: {write_result.unwrap_err()}")
        return 1

    # Create src directory
    if not dir_create("{current_dir}/src", true):
        print_error("Failed to create src/ directory")
        return 1

    # Write src/main.spl if it doesn't exist
    val main_path = "{current_dir}/src/main.spl"
    if not file_exists(main_path):
        val main_content = "# Simple Language Project\n# Run with: simple run\n\nfn main() -> i32:\n    print(\"Hello, Simple!\")\n    return 0\n"
        if not file_write(main_path, main_content):
            print_error("Failed to write src/main.spl")
            return 1

    print "Initialized Simple project '{name}'"
    return 0

fn read_sdn_run_config() -> text:
    val current_dir = cwd()
    val sdn_path = "{current_dir}/simple.sdn"
    if not file_exists(sdn_path):
        return ""
    val content = file_read(sdn_path)
    if content == "":
        return ""
    # Simple line-based parsing for execution.run-config
    var in_execution = false
    val lines = content.split("\n")
    for line in lines:
        val trimmed = line.trim()
        if trimmed == "" or trimmed.starts_with("#"):
            continue
        val indent = sdn_line_indent(line)
        if indent == 0 and trimmed.ends_with(":"):
            in_execution = trimmed == "execution:"
            continue
        if in_execution and indent >= 2:
            if trimmed.starts_with("run-config:"):
                val value = trimmed[11:].trim()
                return strip_sdn_quotes(value)
    ""

fn sdn_line_indent(line: text) -> i64:
    var count = 0
    var i = 0
    while i < line.len():
        val ch = line[i:i + 1]
        if ch == " ":
            count = count + 1
        elif ch == "\t":
            count = count + 4
        else:
            break
        i = i + 1
    count

fn strip_sdn_quotes(s: text) -> text:
    if s.len() >= 2:
        if (s.starts_with("\"") and s.ends_with("\"")) or (s.starts_with("'") and s.ends_with("'")):
            return s[1 : s.len() - 1]
    s

fn check_self_contained() -> bool:
    # Check if this binary is a self-contained executable (runtime + SMF)
    val exe_path_result = shell("readlink -f /proc/self/exe 2>/dev/null")
    if exe_path_result.exit_code != 0:
        return false

    val exe_path = exe_path_result.stdout.replace("\n", "")
    if exe_path == "":
        return false

    # Quick size check: must be > 32 bytes
    val size = file_size_raw(exe_path)
    if size < 33:
        return false

    # Read last 4 bytes to check magic "SMFE" (83 77 70 69)
    val trailer_offset = size - 32
    val strip_ws = " " + "\n"
    val magic_result = shell("dd if='{exe_path}' bs=1 skip={trailer_offset} count=4 2>/dev/null | od -A n -t x1 | tr -d '{strip_ws}'")
    if magic_result.exit_code != 0:
        return false

    val magic_hex = magic_result.stdout.replace("\n", "")
    if magic_hex != "534d4645":
        return false

    # This is a self-contained binary - extract SMF offset and size from trailer
    val trailer_result = shell("dd if='{exe_path}' bs=1 skip={trailer_offset} count=32 2>/dev/null | od -A n -t x1 | tr -d '{strip_ws}'")
    if trailer_result.exit_code != 0:
        return false

    eprint("[WARNING] SMF loader not yet available in Simple; cannot load embedded SMF directly")
    print "[self-contained] Detected embedded SMF in {exe_path}"
    print "[self-contained] Self-contained execution not yet fully implemented"
    print "[self-contained] Use: simple run <file.smf> to run SMF modules"
    true

export print_cli_help, handle_init
export read_sdn_run_config, sdn_line_indent, strip_sdn_quotes
export check_self_contained
