# Database statistics aggregation

use app.io (file_exists, file_read)
use app.stats.types (TestStats, FeatureStats, BugStats, CoverageStats)

# Default empty test stats
fn default_test_stats() -> TestStats:
    TestStats(
        total: 0, passed: 0, failed: 0, skipped: 0,
        sspec_count: 0, sdoc_count: 0,
        system_count: 0, integration_count: 0, unit_count: 0
    )

# Collect test statistics from test_db.sdn
# Simple approach: just count lines in the file
fn collect_test_stats() -> TestStats:
    if not file_exists("doc/test/test_db.sdn"):
        return default_test_stats()

    val content = file_read("doc/test/test_db.sdn")
    val lines = content.split("\n")

    var passed = 0
    var failed = 0
    var skipped = 0

    for line in lines:
        val trimmed = line.trim()
        # Count status occurrences in lines
        if trimmed.contains(", passed,") or trimmed.contains(", 4,"):
            passed = passed + 1
        elif trimmed.contains(", failed,") or trimmed.contains(", 5,"):
            failed = failed + 1
        elif trimmed.contains(", skipped,") or trimmed.contains(", 6,"):
            skipped = skipped + 1

    val total = passed + failed + skipped
    TestStats(
        total: total,
        passed: passed,
        failed: failed,
        skipped: skipped,
        sspec_count: 0,
        sdoc_count: 0,
        system_count: 0,
        integration_count: 0,
        unit_count: 0
    )

# Collect feature statistics from feature_db.sdn
fn collect_feature_stats() -> FeatureStats:
    if not file_exists("doc/feature/feature_db.sdn"):
        return FeatureStats(total: 0, complete: 0, in_progress: 0, planned: 0)

    val content = file_read("doc/feature/feature_db.sdn")
    val lines = content.split("\n")

    var total = 0
    var complete = 0
    var in_progress = 0
    var planned = 0

    for line in lines:
        val trimmed = line.trim()
        if trimmed.starts_with("features "):
            continue
        if trimmed.len() == 0 or trimmed.starts_with("#"):
            continue

        # Count non-header lines as features
        if trimmed.contains(", complete,"):
            complete = complete + 1
            total = total + 1
        elif trimmed.contains(", in_progress,"):
            in_progress = in_progress + 1
            total = total + 1
        elif trimmed.contains(", planned,"):
            planned = planned + 1
            total = total + 1
        elif trimmed.len() > 10:
            # Other status
            total = total + 1

    FeatureStats(
        total: total,
        complete: complete,
        in_progress: in_progress,
        planned: planned
    )

# Collect bug statistics from bug_db.sdn
fn collect_bug_stats() -> BugStats:
    if not file_exists("doc/bug/bug_db.sdn"):
        return BugStats(total: 0, open: 0, critical: 0, fixed: 0)

    val content = file_read("doc/bug/bug_db.sdn")
    val lines = content.split("\n")

    var total = 0
    var open = 0
    var critical = 0
    var fixed = 0

    for line in lines:
        val trimmed = line.trim()
        if trimmed.starts_with("bugs "):
            continue
        if trimmed.len() == 0 or trimmed.starts_with("#"):
            continue

        # Count non-header lines as bugs
        if trimmed.contains(", open,"):
            open = open + 1
            total = total + 1
        elif trimmed.contains(", fixed,"):
            fixed = fixed + 1
            total = total + 1
        elif trimmed.len() > 10:
            total = total + 1

        # Check for critical severity
        if trimmed.contains(", critical,"):
            critical = critical + 1

    BugStats(
        total: total,
        open: open,
        critical: critical,
        fixed: fixed
    )

# Collect coverage statistics from .coverage/coverage.sdn
fn collect_coverage_stats() -> CoverageStats:
    if not file_exists("build/coverage/coverage.sdn"):
        return CoverageStats(percent: 0.0, lines_covered: 0, lines_total: 0)

    # Coverage file doesn't exist yet, return placeholder
    CoverageStats(percent: 0.0, lines_covered: 0, lines_total: 0)

export collect_test_stats, collect_feature_stats, collect_bug_stats, collect_coverage_stats
