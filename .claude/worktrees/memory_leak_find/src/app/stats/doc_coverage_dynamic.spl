# Shell-based doc-coverage CLI handler
# Supports --format=terminal|json|md, --missing, and optional path argument

use app.io.mod (process_run)

# Run a shell command and return trimmed stdout (or "0" on failure)
fn dc_run_cmd(cmd: text) -> text:
    val result = process_run("sh", ["-c", cmd])
    val stdout = result.0
    val exit_code = result.2
    if exit_code == 0:
        stdout.trim()
    else:
        "0"

# Check if a flag is present in args
fn dc_has_flag(args: [text], flag: text) -> bool:
    var i = 0
    while i < args.len():
        if args[i] == flag:
            return true
        i = i + 1
    false

# Get value of --format=X flag (returns default if not present)
fn dc_get_format(args: [text]) -> text:
    var i = 0
    while i < args.len():
        val arg = args[i]
        if arg.starts_with("--format="):
            return arg[9:]
        i = i + 1
    "terminal"

# Get optional path argument (first non-flag arg, or default)
fn dc_get_path(args: [text]) -> text:
    var i = 0
    while i < args.len():
        val arg = args[i]
        if not arg.starts_with("--"):
            return arg
        i = i + 1
    "src/lib src/core src/lib src/app"

# Count total public functions in path
fn count_public_fns(path: text) -> i64:
    val cmd = "grep -rn '^fn ' {path} --include='*.spl' 2>/dev/null | wc -l"
    dc_run_cmd(cmd).to_int()

# Count documented functions (# comment on preceding line) in path
fn count_documented_fns(path: text) -> i64:
    val cmd = "grep -rn -B1 '^fn ' {path} --include='*.spl' 2>/dev/null | grep -cE -- '-[0-9]+-#' 2>/dev/null || echo 0"
    dc_run_cmd(cmd).to_int()

# Count functions with docstrings (\"\"\" before fn)
fn count_docstring_fns(path: text) -> i64:
    val cmd = "grep -rn -B2 '^fn ' {path} --include='*.spl' 2>/dev/null | grep -c '\"\"\"' || echo 0"
    dc_run_cmd(cmd).to_int()

# Print terminal-format coverage report
fn print_terminal_report(path: text):
    val total = count_public_fns(path)
    val documented = count_documented_fns(path)
    val with_docstring = count_docstring_fns(path)

    print "========================================="
    print "Documentation Coverage Report"
    print "========================================="
    print ""
    print "Scope: {path}"
    print ""

    if total > 0:
        val doc_pct = (documented * 100) / total
        val ds_pct = (with_docstring * 100) / total
        print "Public Functions:  {total}"
        print "Documented:        {documented} ({doc_pct}%)"
        print "With Docstring:    {with_docstring} ({ds_pct}%)"
    else:
        print "Public Functions:  0"
        print "Documented:        0 (0%)"
        print "With Docstring:    0 (0%)"

    # Per-scope breakdown
    print ""
    print "Per-Scope Breakdown:"

    val std_total = count_public_fns("src/lib")
    val std_doc = count_documented_fns("src/lib")
    if std_total > 0:
        val std_pct = (std_doc * 100) / std_total
        print "  std/:  {std_doc}/{std_total} ({std_pct}%)"

    val core_total = count_public_fns("src/core")
    val core_doc = count_documented_fns("src/core")
    if core_total > 0:
        val core_pct = (core_doc * 100) / core_total
        print "  core/: {core_doc}/{core_total} ({core_pct}%)"

    val lib_total = count_public_fns("src/lib")
    val lib_doc = count_documented_fns("src/lib")
    if lib_total > 0:
        val lib_pct = (lib_doc * 100) / lib_total
        print "  lib/:  {lib_doc}/{lib_total} ({lib_pct}%)"

    val app_total = count_public_fns("src/app")
    val app_doc = count_documented_fns("src/app")
    if app_total > 0:
        val app_pct = (app_doc * 100) / app_total
        print "  app/:  {app_doc}/{app_total} ({app_pct}%)"

    print ""
    print "========================================="

# Print JSON-format coverage report
fn print_json_report(path: text):
    val total = count_public_fns(path)
    val documented = count_documented_fns(path)
    val with_docstring = count_docstring_fns(path)

    var doc_pct = 0
    var ds_pct = 0
    if total > 0:
        doc_pct = (documented * 100) / total
        ds_pct = (with_docstring * 100) / total

    val std_total = count_public_fns("src/lib")
    val std_doc = count_documented_fns("src/lib")
    var std_pct = 0
    if std_total > 0:
        std_pct = (std_doc * 100) / std_total

    val core_total = count_public_fns("src/core")
    val core_doc = count_documented_fns("src/core")
    var core_pct = 0
    if core_total > 0:
        core_pct = (core_doc * 100) / core_total

    val lib_total = count_public_fns("src/lib")
    val lib_doc = count_documented_fns("src/lib")
    var lib_pct = 0
    if lib_total > 0:
        lib_pct = (lib_doc * 100) / lib_total

    val app_total = count_public_fns("src/app")
    val app_doc = count_documented_fns("src/app")
    var app_pct = 0
    if app_total > 0:
        app_pct = (app_doc * 100) / app_total

    print "{"
    print "  \"scope\": \"{path}\","
    print "  \"total_public\": {total},"
    print "  \"documented\": {documented},"
    print "  \"with_docstring\": {with_docstring},"
    print "  \"doc_percent\": {doc_pct},"
    print "  \"docstring_percent\": {ds_pct},"
    print "  \"per_scope\": {"
    print "    \"std\": {{ \"total\": {std_total}, \"documented\": {std_doc}, \"percent\": {std_pct} }},"
    print "    \"core\": {{ \"total\": {core_total}, \"documented\": {core_doc}, \"percent\": {core_pct} }},"
    print "    \"lib\": {{ \"total\": {lib_total}, \"documented\": {lib_doc}, \"percent\": {lib_pct} }},"
    print "    \"app\": {{ \"total\": {app_total}, \"documented\": {app_doc}, \"percent\": {app_pct} }}"
    print "  }"
    print "}"

# Print Markdown-format coverage report
fn print_md_report(path: text):
    val total = count_public_fns(path)
    val documented = count_documented_fns(path)
    val with_docstring = count_docstring_fns(path)

    var doc_pct = 0
    var ds_pct = 0
    if total > 0:
        doc_pct = (documented * 100) / total
        ds_pct = (with_docstring * 100) / total

    print "# Documentation Coverage Report"
    print ""
    print "**Scope:** `{path}`"
    print ""
    print "## Summary"
    print ""
    print "| Metric | Count | Percent |"
    print "|--------|-------|---------|"
    print "| Public Functions | {total} | 100% |"
    print "| Documented | {documented} | {doc_pct}% |"
    print "| With Docstring | {with_docstring} | {ds_pct}% |"
    print ""
    print "## Per-Scope Breakdown"
    print ""
    print "| Scope | Total | Documented | % |"
    print "|-------|-------|------------|---|"

    val std_total = count_public_fns("src/lib")
    val std_doc = count_documented_fns("src/lib")
    var std_pct = 0
    if std_total > 0:
        std_pct = (std_doc * 100) / std_total
    print "| std/ | {std_total} | {std_doc} | {std_pct}% |"

    val core_total = count_public_fns("src/core")
    val core_doc = count_documented_fns("src/core")
    var core_pct = 0
    if core_total > 0:
        core_pct = (core_doc * 100) / core_total
    print "| core/ | {core_total} | {core_doc} | {core_pct}% |"

    val lib_total = count_public_fns("src/lib")
    val lib_doc = count_documented_fns("src/lib")
    var lib_pct = 0
    if lib_total > 0:
        lib_pct = (lib_doc * 100) / lib_total
    print "| lib/ | {lib_total} | {lib_doc} | {lib_pct}% |"

    val app_total = count_public_fns("src/app")
    val app_doc = count_documented_fns("src/app")
    var app_pct = 0
    if app_total > 0:
        app_pct = (app_doc * 100) / app_total
    print "| app/ | {app_total} | {app_doc} | {app_pct}% |"

# Show undocumented functions using awk
fn print_missing(path: text):
    print "Undocumented public functions in {path}:"
    print ""
    val cmd = "grep -rn '^fn ' {path} --include='*.spl' -B1 2>/dev/null | awk '/^--$/{next} prev !~ /#/ && /^fn /{print FILENAME\": \"$0} {prev=$0}' || grep -rn '^fn ' {path} --include='*.spl' 2>/dev/null | head -20"
    val output = dc_run_cmd(cmd)
    if output == "0" or output == "":
        print "(none found or all documented)"
    else:
        print output

# Main entry point for doc-coverage command
fn run_doc_coverage(args: [text]) -> i64:
    val format = dc_get_format(args)
    val show_missing = dc_has_flag(args, "--missing")
    val path = dc_get_path(args)

    if show_missing:
        print_missing(path)
        return 0

    if format == "json":
        print_json_report(path)
    elif format == "md":
        print_md_report(path)
    else:
        print_terminal_report(path)

    0

export run_doc_coverage
