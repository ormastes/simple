# Standard Library â€” GenServer OTP Behaviour
#
# @tag:api
# @tag:stdlib
#
# GenServer behaviour for request-reply server processes.
# Inspired by Erlang/OTP gen_server.
#
# Implement handle_call and handle_cast for your server logic.
# handle_info and terminate have default no-op implementations.
#
# Use @behaviour(GenServer) annotation on implementing class/struct.
#
# Usage:
#   @behaviour(GenServer)
#   class CounterServer:
#       fn init(args: text) -> text: "0"
#       fn handle_call(request: text, state: text) -> text:
#           if request == "get": state
#           else: state
#       fn handle_cast(msg: text, state: text) -> text: state

# GenServer behaviour trait.
# Required: init, handle_call, handle_cast
# Optional (have defaults): handle_info, terminate
trait GenServer:
    # Called when the server starts. Returns the initial state.
    fn init(args: text) -> text

    # Handle a synchronous call (request-reply pattern).
    # Returns the new state (reply is embedded in state convention, or use text).
    fn handle_call(request: text, state: text) -> text

    # Handle an asynchronous cast (fire-and-forget message).
    # Returns the new state.
    fn handle_cast(msg: text, state: text) -> text

    # Handle an unexpected message. Default: ignore and keep state.
    fn handle_info(msg: text, state: text) -> text:
        state

    # Called on termination. Default: no cleanup needed.
    fn terminate(reason: text, state: text):
        pass_do_nothing

# GenServerRunner â€” wraps a GenServer impl and runs its message loop.
struct GenServerRunner:
    state: text
    name: text
    running: bool

# Create a runner for a GenServer with the given initial state.
fn gen_server_runner(name: text, initial_state: text) -> GenServerRunner:
    GenServerRunner(state: initial_state, name: name, running: false)

# Start the runner (marks it as running).
fn gen_server_start(runner: GenServerRunner):
    runner.running = true

# Stop the runner.
fn gen_server_stop(runner: GenServerRunner):
    runner.running = false

# Check if the runner is active.
fn gen_server_is_running(runner: GenServerRunner) -> bool:
    runner.running

# Simulate a synchronous call to the server.
# In interpreter mode this calls handle_call directly.
fn gen_server_call(runner: GenServerRunner, request: text, handler: fn(text, text) -> text) -> text:
    val new_state = handler(request, runner.state)
    runner.state = new_state
    new_state

# Simulate an async cast to the server.
fn gen_server_cast(runner: GenServerRunner, msg: text, handler: fn(text, text) -> text):
    val new_state = handler(msg, runner.state)
    runner.state = new_state

export GenServer, GenServerRunner
export gen_server_runner, gen_server_start, gen_server_stop
export gen_server_is_running, gen_server_call, gen_server_cast
