# Standard Library â€” Supervision Trees
#
# @tag:api
# @tag:stdlib
#
# Lightweight supervision tree library for managing child processes/tasks.
# Inspired by Erlang/OTP supervision patterns.
#
# Usage:
#   val config = SupervisorConfig(strategy: "one_for_one", max_restarts: 5, max_seconds: 60)
#   val sup = Supervisor(config: config, children: [])
#   sup.add_child(ChildSpec(id: "worker1", restart: "permanent", shutdown: "brutal_kill"))

# Restart strategies
val RESTART_PERMANENT = "permanent"   # always restart
val RESTART_TEMPORARY = "temporary"   # never restart
val RESTART_TRANSIENT = "transient"   # restart only on abnormal exit

# Supervisor strategies
val STRATEGY_ONE_FOR_ONE = "one_for_one"       # restart only failed child
val STRATEGY_ONE_FOR_ALL = "one_for_all"       # restart all if one fails
val STRATEGY_REST_FOR_ONE = "rest_for_one"     # restart failed + started after it
val STRATEGY_SIMPLE_ONE_FOR_ONE = "simple_one_for_one"  # dynamic children of same type

# Shutdown strategies
val SHUTDOWN_BRUTAL_KILL = "brutal_kill"  # immediate kill
val SHUTDOWN_INFINITY = "infinity"        # wait forever
val SHUTDOWN_TIMEOUT = "timeout"          # wait fixed timeout

struct SupervisorConfig:
    strategy: text
    max_restarts: i64
    max_seconds: i64

struct ChildSpec:
    id: text
    restart: text
    shutdown: text
    shutdown_ms: i64

fn supervisor_config_default() -> SupervisorConfig:
    SupervisorConfig(
        strategy: STRATEGY_ONE_FOR_ONE,
        max_restarts: 3,
        max_seconds: 5
    )

fn child_spec(id: text) -> ChildSpec:
    ChildSpec(
        id: id,
        restart: RESTART_PERMANENT,
        shutdown: SHUTDOWN_BRUTAL_KILL,
        shutdown_ms: 0
    )

fn child_spec_with_restart(id: text, restart: text) -> ChildSpec:
    ChildSpec(
        id: id,
        restart: restart,
        shutdown: SHUTDOWN_BRUTAL_KILL,
        shutdown_ms: 0
    )

class Supervisor:
    config: SupervisorConfig
    children: [ChildSpec]
    restart_counts: [i64]
    running: bool

    me add_child(spec: ChildSpec):
        self.children.push(spec)
        self.restart_counts.push(0)

    me remove_child(child_id: text):
        var new_children: [ChildSpec] = []
        var new_counts: [i64] = []
        var i = 0
        for cs in self.children:
            if cs.id != child_id:
                new_children.push(cs)
                new_counts.push(self.restart_counts[i])
            i = i + 1
        self.children = new_children
        self.restart_counts = new_counts

    fn get_child(child_id: text) -> ChildSpec:
        for cs in self.children:
            if cs.id == child_id:
                return cs
        ChildSpec(id: "", restart: "", shutdown: "", shutdown_ms: 0)

    fn child_count() -> i64:
        self.children.len()

    me start():
        self.running = true

    me stop():
        self.running = false

    fn is_running() -> bool:
        self.running

    me record_restart(child_id: text):
        var i = 0
        for cs in self.children:
            if cs.id == child_id:
                self.restart_counts[i] = self.restart_counts[i] + 1
                return
            i = i + 1

    fn restart_count(child_id: text) -> i64:
        var i = 0
        for cs in self.children:
            if cs.id == child_id:
                return self.restart_counts[i]
            i = i + 1
        0

    fn should_restart(child_id: text) -> bool:
        var i = 0
        for cs in self.children:
            if cs.id == child_id:
                if cs.restart == RESTART_TEMPORARY:
                    return false
                return true
            i = i + 1
        false

    fn within_limits() -> bool:
        var total_restarts: i64 = 0
        for cnt in self.restart_counts:
            total_restarts = total_restarts + cnt
        total_restarts <= self.config.max_restarts

    static fn new(strategy: text) -> Supervisor:
        Supervisor(
            config: SupervisorConfig(
                strategy: strategy,
                max_restarts: 3,
                max_seconds: 5
            ),
            children: [],
            restart_counts: [],
            running: false
        )

fn supervisor_new(strategy: text) -> Supervisor:
    Supervisor(
        config: SupervisorConfig(
            strategy: strategy,
            max_restarts: 3,
            max_seconds: 5
        ),
        children: [],
        restart_counts: [],
        running: false
    )

export SupervisorConfig, ChildSpec, Supervisor
export RESTART_PERMANENT, RESTART_TEMPORARY, RESTART_TRANSIENT
export STRATEGY_ONE_FOR_ONE, STRATEGY_ONE_FOR_ALL, STRATEGY_REST_FOR_ONE
export STRATEGY_SIMPLE_ONE_FOR_ONE
export SHUTDOWN_BRUTAL_KILL, SHUTDOWN_INFINITY, SHUTDOWN_TIMEOUT
export supervisor_config_default, child_spec, child_spec_with_restart, supervisor_new
