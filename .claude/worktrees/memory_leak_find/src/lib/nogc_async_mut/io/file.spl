"""
# Async File I/O

Async file handle using thread pool offload (files don't support epoll).
Owns a raw fd directly and dispatches FFI operations to a thread pool.

## Components

| Type | Traits | Description |
|------|--------|-------------|
| AsyncFileHandle | AsyncRead, AsyncWrite, AsyncSeek, AsyncClose | Thread-pool async file |
| AsyncFile | (static) | One-shot async convenience methods |
| ThreadPool | — | Worker thread pool for blocking offload |

## Handle-Based Usage

```simple
# val fh = await AsyncFileHandle.open("data.txt", FileMode.ReadOnly)?
# val content = await fh.read_text()?
# await fh.close()?
```

## Static Convenience

```simple
# val text = await AsyncFile.read("config.sdn")?
# await AsyncFile.write("output.txt", text)?
```

## Async Mirrors Sync

```simple
# Sync:
#   val fh = FileHandle.open("data.txt", FileMode.ReadOnly)?
#   val text = fh.read_text()?
#   fh.close()?
#
# Async — same names, just add await:
#   val fh = await AsyncFileHandle.open("data.txt", FileMode.ReadOnly)?
#   val text = await fh.read_text()?
#   await fh.close()?
```

## Thread Pool

```simple
# val pool = ThreadPool.new(4)
# val result = await pool.spawn(\\: expensive_computation())
```
"""

use std.common.io.async_traits.{AsyncRead, AsyncWrite, AsyncSeek, AsyncClose}
use std.common.io.types.{IoError, IoErrorKind, SeekFrom, FileMode, FileMetadata}
use std.async.future.{Future}

# ============================================================================
# FFI Functions
# ============================================================================

# Thread pool
extern fn rt_thread_pool_create(size: i64)
extern fn rt_thread_pool_spawn<T>(task: fn() -> T) -> Future<T>

# File handle operations
extern fn rt_io_file_open(path: text, mode: i64) -> i64
extern fn rt_io_file_read(fd: i64, size: i64) -> [u8]
extern fn rt_io_file_read_all(fd: i64) -> [u8]
extern fn rt_io_file_read_line(fd: i64) -> text?
extern fn rt_io_file_write(fd: i64, data: [u8]) -> i64
extern fn rt_io_file_write_all(fd: i64, data: [u8]) -> bool
extern fn rt_io_file_seek(fd: i64, offset: i64, whence: i64) -> i64
extern fn rt_io_file_flush(fd: i64) -> bool
extern fn rt_io_file_close(fd: i64) -> bool
extern fn rt_io_file_metadata(fd: i64) -> FileMetadata?
extern fn rt_io_file_exists(path: text) -> bool
extern fn rt_io_file_delete(path: text) -> bool

# Text/bytes conversion
extern fn rt_bytes_to_text(data: [u8]) -> text
extern fn rt_text_to_bytes(s: text) -> [u8]

# ============================================================================
# ThreadPool - Minimal Thread Pool for File I/O
# ============================================================================

class ThreadPool:
    """Thread pool for offloading blocking file I/O.

    Example:
        val pool = ThreadPool.new(4)
        val result = await pool.spawn(\: heavy_computation())
    """
    size: i64

    static fn new(size: i64) -> ThreadPool:
        """Create thread pool.

        Args:
            size: Number of worker threads

        Returns:
            ThreadPool
        """
        rt_thread_pool_create(size)
        ThreadPool(size: size)

    static fn default() -> ThreadPool:
        """Create default thread pool (4 threads)."""
        ThreadPool.new(4)

    fn spawn<T>(task: fn() -> T) -> Future<T>:
        """Submit task to thread pool.

        Args:
            task: Closure to run on pool thread

        Returns:
            Future that resolves when task completes
        """
        rt_thread_pool_spawn(task)

# Default global pool
var global_pool: ThreadPool? = nil

fn get_pool() -> ThreadPool:
    """Get or create the global thread pool."""
    if not global_pool.?:
        global_pool = Some(ThreadPool.default())
    global_pool.unwrap()

# ============================================================================
# Internal helpers
# ============================================================================

fn file_mode_to_int(mode: FileMode) -> i64:
    """Convert FileMode to integer for FFI."""
    match mode:
        case FileMode.ReadOnly: 0
        case FileMode.WriteOnly: 1
        case FileMode.ReadWrite: 2
        case FileMode.Append: 3

# ============================================================================
# AsyncFileHandle - Async File Handle
# ============================================================================

class AsyncFileHandle with AsyncRead, AsyncWrite, AsyncSeek, AsyncClose:
    """Async file handle with thread pool offload.

    All operations are dispatched to a thread pool since
    regular files don't support epoll/non-blocking I/O.
    Owns the raw fd directly — no sync wrapper dependency.

    Example:
        val fh = await AsyncFileHandle.open("data.txt", FileMode.ReadOnly)?
        val text = await fh.read_text()?
        await fh.close()?
    """
    fd: i64
    mode: FileMode
    open: bool
    pool: ThreadPool

    # --- Factory ---

    static fn open(path: text, mode: FileMode) -> Future<Result<AsyncFileHandle, IoError>>:
        """Open file asynchronously.

        Args:
            path: File path
            mode: Open mode

        Returns:
            Future with Result containing AsyncFileHandle
        """
        val pool = get_pool()
        pool.spawn(\:
            val mode_int = file_mode_to_int(mode)
            val fd = rt_io_file_open(path, mode_int)
            if fd < 0:
                return Err(IoError.new(IoErrorKind.NotFound, "failed to open: {path}"))
            Ok(AsyncFileHandle(fd: fd, mode: mode, open: true, pool: pool))
        )

    static fn read_file(path: text) -> Future<Result<AsyncFileHandle, IoError>>:
        """Open file for reading asynchronously."""
        AsyncFileHandle.open(path, FileMode.ReadOnly)

    static fn create(path: text) -> Future<Result<AsyncFileHandle, IoError>>:
        """Create file for writing asynchronously."""
        AsyncFileHandle.open(path, FileMode.WriteOnly)

    # --- AsyncRead (thread pool offload) ---

    fn read(size: i64) -> Future<Result<[u8], IoError>>:
        """Read up to size bytes asynchronously."""
        val fd = self.fd
        self.pool.spawn(\:
            val data = rt_io_file_read(fd, size)
            if data.len() < 0:
                return Err(IoError.new(IoErrorKind.Other, "read failed"))
            Ok(data)
        )

    fn read_exact(size: i64) -> Future<Result<[u8], IoError>>:
        """Read exactly size bytes asynchronously."""
        val fd = self.fd
        self.pool.spawn(\:
            val data = rt_io_file_read(fd, size)
            if data.len() != size:
                return Err(IoError.new(IoErrorKind.UnexpectedEof, "read_exact: got {data.len()} of {size} bytes"))
            Ok(data)
        )

    fn read_all() -> Future<Result<[u8], IoError>>:
        """Read all remaining bytes asynchronously."""
        val fd = self.fd
        self.pool.spawn(\:
            val data = rt_io_file_read_all(fd)
            Ok(data)
        )

    fn read_text() -> Future<Result<text, IoError>>:
        """Read all content as text asynchronously."""
        val fd = self.fd
        self.pool.spawn(\:
            val data = rt_io_file_read_all(fd)
            val s = rt_bytes_to_text(data)
            Ok(s)
        )

    fn read_line() -> Future<Result<text, IoError>>:
        """Read a single line asynchronously."""
        val fd = self.fd
        self.pool.spawn(\:
            val line = rt_io_file_read_line(fd)
            if line == nil:
                return Err(IoError.new(IoErrorKind.UnexpectedEof, "end of file"))
            Ok(line)
        )

    # --- AsyncWrite (thread pool offload) ---

    fn write(data: [u8]) -> Future<Result<i64, IoError>>:
        """Write bytes asynchronously."""
        val fd = self.fd
        self.pool.spawn(\:
            val written = rt_io_file_write(fd, data)
            if written < 0:
                return Err(IoError.new(IoErrorKind.Other, "write failed"))
            Ok(written)
        )

    fn write_all(data: [u8]) -> Future<Result<(), IoError>>:
        """Write all bytes asynchronously."""
        val fd = self.fd
        self.pool.spawn(\:
            val ok = rt_io_file_write_all(fd, data)
            if not ok:
                return Err(IoError.new(IoErrorKind.Other, "write_all failed"))
            Ok(())
        )

    fn write_text(s: text) -> Future<Result<(), IoError>>:
        """Write text asynchronously."""
        val fd = self.fd
        self.pool.spawn(\:
            val bytes = rt_text_to_bytes(s)
            val ok = rt_io_file_write_all(fd, bytes)
            if not ok:
                return Err(IoError.new(IoErrorKind.Other, "write_text failed"))
            Ok(())
        )

    fn flush() -> Future<Result<(), IoError>>:
        """Flush to disk asynchronously."""
        val fd = self.fd
        self.pool.spawn(\:
            val ok = rt_io_file_flush(fd)
            if not ok:
                return Err(IoError.new(IoErrorKind.Other, "flush failed"))
            Ok(())
        )

    # --- AsyncSeek (thread pool offload) ---

    fn seek(pos: SeekFrom) -> Future<Result<i64, IoError>>:
        """Seek to position asynchronously."""
        val fd = self.fd
        self.pool.spawn(\:
            val (offset, whence) = match pos:
                case SeekFrom.Start(o): (o, 0)
                case SeekFrom.Current(o): (o, 1)
                case SeekFrom.End(o): (o, 2)
            val new_pos = rt_io_file_seek(fd, offset, whence)
            if new_pos < 0:
                return Err(IoError.new(IoErrorKind.Other, "seek failed"))
            Ok(new_pos)
        )

    fn position() -> Future<Result<i64, IoError>>:
        """Get current position asynchronously."""
        self.seek(SeekFrom.Current(0))

    fn rewind() -> Future<Result<(), IoError>>:
        """Seek to beginning asynchronously."""
        val fd = self.fd
        self.pool.spawn(\:
            val new_pos = rt_io_file_seek(fd, 0, 0)
            if new_pos < 0:
                return Err(IoError.new(IoErrorKind.Other, "rewind failed"))
            Ok(())
        )

    # --- AsyncClose (thread pool offload) ---

    me close() -> Future<Result<(), IoError>>:
        """Close file handle asynchronously."""
        val fd = self.fd
        self.open = false
        self.pool.spawn(\:
            val ok = rt_io_file_close(fd)
            if not ok:
                return Err(IoError.new(IoErrorKind.Other, "close failed"))
            Ok(())
        )

    fn is_open() -> bool:
        """Check if file handle is open (sync)."""
        self.open

    # --- File-specific ---

    fn metadata() -> Future<Result<FileMetadata, IoError>>:
        """Get file metadata asynchronously."""
        val fd = self.fd
        self.pool.spawn(\:
            val meta = rt_io_file_metadata(fd)
            if meta == nil:
                return Err(IoError.new(IoErrorKind.Other, "metadata failed"))
            Ok(meta)
        )

    fn size() -> Future<Result<i64, IoError>>:
        """Get file size asynchronously."""
        val fd = self.fd
        self.pool.spawn(\:
            val meta = rt_io_file_metadata(fd)
            if meta == nil:
                return Err(IoError.new(IoErrorKind.Other, "metadata failed"))
            Ok(meta.size)
        )

# ============================================================================
# AsyncFile - Static Convenience
# ============================================================================

class AsyncFile:
    """One-shot async file operations.

    Example:
        val text = await AsyncFile.read("config.sdn")?
        await AsyncFile.write("output.txt", text)?
    """

    static fn read(path: text) -> Future<Result<text, IoError>>:
        """Read entire file as text asynchronously."""
        val pool = get_pool()
        pool.spawn(\:
            val mode_int = file_mode_to_int(FileMode.ReadOnly)
            val fd = rt_io_file_open(path, mode_int)
            if fd < 0:
                return Err(IoError.new(IoErrorKind.NotFound, "failed to open: {path}"))
            val data = rt_io_file_read_all(fd)
            val content = rt_bytes_to_text(data)
            rt_io_file_close(fd)
            Ok(content)
        )

    static fn read_bytes(path: text) -> Future<Result<[u8], IoError>>:
        """Read entire file as bytes asynchronously."""
        val pool = get_pool()
        pool.spawn(\:
            val mode_int = file_mode_to_int(FileMode.ReadOnly)
            val fd = rt_io_file_open(path, mode_int)
            if fd < 0:
                return Err(IoError.new(IoErrorKind.NotFound, "failed to open: {path}"))
            val data = rt_io_file_read_all(fd)
            rt_io_file_close(fd)
            Ok(data)
        )

    static fn write(path: text, content: text) -> Future<Result<(), IoError>>:
        """Write text to file asynchronously."""
        val pool = get_pool()
        pool.spawn(\:
            val mode_int = file_mode_to_int(FileMode.WriteOnly)
            val fd = rt_io_file_open(path, mode_int)
            if fd < 0:
                return Err(IoError.new(IoErrorKind.NotFound, "failed to create: {path}"))
            val bytes = rt_text_to_bytes(content)
            val ok = rt_io_file_write_all(fd, bytes)
            rt_io_file_close(fd)
            if not ok:
                return Err(IoError.new(IoErrorKind.Other, "write failed"))
            Ok(())
        )

    static fn write_bytes(path: text, data: [u8]) -> Future<Result<(), IoError>>:
        """Write bytes to file asynchronously."""
        val pool = get_pool()
        pool.spawn(\:
            val mode_int = file_mode_to_int(FileMode.WriteOnly)
            val fd = rt_io_file_open(path, mode_int)
            if fd < 0:
                return Err(IoError.new(IoErrorKind.NotFound, "failed to create: {path}"))
            val ok = rt_io_file_write_all(fd, data)
            rt_io_file_close(fd)
            if not ok:
                return Err(IoError.new(IoErrorKind.Other, "write_bytes failed"))
            Ok(())
        )

    static fn exists(path: text) -> Future<bool>:
        """Check if file exists asynchronously."""
        val pool = get_pool()
        pool.spawn(\: rt_io_file_exists(path))

    static fn delete(path: text) -> Future<Result<(), IoError>>:
        """Delete file asynchronously."""
        val pool = get_pool()
        pool.spawn(\:
            val ok = rt_io_file_delete(path)
            if not ok:
                return Err(IoError.new(IoErrorKind.NotFound, "delete failed: {path}"))
            Ok(())
        )

# ============================================================================
# Exports
# ============================================================================

export ThreadPool
export AsyncFileHandle
export AsyncFile
