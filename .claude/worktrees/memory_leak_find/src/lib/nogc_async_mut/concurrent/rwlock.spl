# RwLock Module - Read-Write Lock
# @tag:stdlib
# @tag:api
#
# Provides read-write locks for concurrent read access with exclusive writes.
# RwLock allows multiple simultaneous readers OR one exclusive writer.
#
# Locking Model:
#   - Multiple readers can hold read lock simultaneously
#   - Only one writer can hold write lock at a time
#   - Writers block until all readers release
#   - Readers block while writer holds lock
#   - read() and write() block until lock acquired
#   - try_read() and try_write() return nil if lock unavailable
#
# Thread Safety:
#   - All lock operations are atomic
#   - No reader starvation - writer preference in contention
#   - No deadlock detection - avoid circular dependencies
#   - No automatic unlock - must explicitly release
#
# Performance Characteristics:
#   - Read lock: ~40ns if no writers (shared access)
#   - Write lock: ~50ns if no readers/writers (exclusive access)
#   - Ideal for read-heavy workloads (90%+ reads)
#   - Use Mutex if writes are common (>10%)
#
# SDoctest Examples:
#
# Example 1: Basic Read/Write
# ```simple
# use std.concurrent.rwlock.{rwlock_new}
#
# val rw = rwlock_new(0)
# val value = rw.read()
# print value  # Prints: 0
# rw.set(42)
# val updated = rw.read()
# print updated  # Prints: 42
# ```
#
# Example 2: Concurrent Readers
# ```simple
# use std.concurrent.rwlock.{rwlock_new}
# use std.concurrent.thread.{thread_spawn}
#
# val data = rwlock_new(100)
# val reader = \:
#     val v = data.read()
#     v
# val h1 = thread_spawn(reader)
# val h2 = thread_spawn(reader)
# val r1 = h1.join()
# val r2 = h2.join()
# print r1  # Prints: 100
# print r2  # Prints: 100
# ```
#
# Example 3: Try Lock (Non-Blocking)
# ```simple
# use std.concurrent.rwlock.{rwlock_new}
#
# val rw = rwlock_new(10)
# val read_val = rw.try_read()
# print read_val  # Prints: 10
# val write_val = rw.try_write()
# print (write_val == nil)  # Prints: true (read lock held)
# ```
#
# Common Patterns:
#   - Configuration Cache: Many readers, rare updates
#   - Shared State Query: Threads read frequently, update occasionally
#   - Metrics Collection: Writers increment, readers snapshot
#
# Limitations:
#   - No RAII guards - must manually release locks
#   - No upgrade from read to write lock
#   - No timeout on blocking operations
#   - Writer starvation possible if readers constantly acquire lock

# --- SFFI declarations ---
extern fn rt_rwlock_new(initial: Any) -> Any
extern fn rt_rwlock_read(rwlock: Any) -> Any
extern fn rt_rwlock_write(rwlock: Any) -> Any
extern fn rt_rwlock_try_read(rwlock: Any) -> Any
extern fn rt_rwlock_try_write(rwlock: Any) -> Any
extern fn rt_rwlock_set(rwlock: Any, new_value: Any) -> Any

# --- RwLock ---
# @tag:api
#
# Handle to a read-write lock protecting a value.
# Allows multiple concurrent readers OR one exclusive writer.

class RwLock:
    _handle: Any  # Rust RwLock handle (opaque)

    # Acquires read lock and returns protected value (blocking).
    # Multiple threads can hold read lock simultaneously.
    # Blocks if writer holds lock.
    # @tag:api
    fn read() -> Any:
        rt_rwlock_read(self._handle)

    # Acquires write lock and returns protected value (blocking).
    # Only one thread can hold write lock.
    # Blocks if any readers or writer hold lock.
    # @tag:api
    fn write() -> Any:
        rt_rwlock_write(self._handle)

    # Non-blocking read lock attempt - returns nil if write lock held.
    # Returns protected value if read lock acquired.
    # @tag:api
    fn try_read() -> Any:
        rt_rwlock_try_read(self._handle)

    # Non-blocking write lock attempt - returns nil if any lock held.
    # Returns protected value if write lock acquired exclusively.
    # @tag:api
    fn try_write() -> Any:
        rt_rwlock_try_write(self._handle)

    # Updates protected value (acquires write lock internally).
    # Convenience method for write-and-release in one operation.
    # Blocks until write lock available.
    # @tag:api
    fn set(new_value: Any) -> Any:
        rt_rwlock_set(self._handle, new_value)

# --- API ---

# Creates a new read-write lock protecting the given initial value.
# Lock starts unlocked - first read() or write() succeeds immediately.
# @tag:api
fn rwlock_new(initial: Any) -> RwLock:
    val handle = rt_rwlock_new(initial)
    RwLock(_handle: handle)
