# Task - Schedulable Async Work
#
# Tasks wrap futures and provide scheduling metadata.

use std.async.future.{Future}
use std.async.ffi.{task_alloc_id}

enum TaskState:
    """Task execution state."""
    Pending      # Not yet started
    Running      # Currently executing
    Suspended    # Waiting for event
    Completed    # Finished
    Cancelled    # Cancelled

class Task:
    """Schedulable unit of async work.

    A task wraps a future and provides scheduling metadata.

    Example:
        val task = Task.new(\: async_work())
        executor.spawn(task)
    """
    id: usize           # Task ID
    future: [u8]        # Future to execute
    priority: i32       # Task priority (higher = more urgent)
    state: TaskState    # Current state

impl Task:
    static fn new<T>(f: fn() -> Future<T>) -> Task:
        """Create new task from async function.

        Args:
            f: Async function

        Returns:
            Task
        """
        val id = task_alloc_id()
        val future = f()

        Task(
            id: id,
            future: future.state,
            priority: 0,
            state: TaskState.Pending
        )

    static fn with_priority<T>(f: fn() -> Future<T>, priority: i32) -> Task:
        """Create task with priority.

        Args:
            f: Async function
            priority: Task priority

        Returns:
            Task
        """
        var task = Task.new(f)
        task.priority = priority
        task

    fn is_completed() -> bool:
        """Check if task is completed."""
        match self.state:
            case TaskState.Completed: true
            case _: false

    fn is_running() -> bool:
        """Check if task is running."""
        match self.state:
            case TaskState.Running: true
            case _: false

export Task, TaskState
