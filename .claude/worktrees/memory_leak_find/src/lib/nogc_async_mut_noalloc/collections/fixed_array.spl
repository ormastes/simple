# Fixed-Size Array - Capacity-Bounded Array
#
# A dynamic array wrapper that enforces a maximum capacity.
# Push operations fail (return false) when capacity is reached.
# In compiled baremetal targets, this lowers to stack-allocated storage.
#
# Usage:
#   val arr = FixedArray.new(32)
#   arr.push(42)
#   val v = arr.get(0)

export FixedArray
export fixed_array_8, fixed_array_16, fixed_array_32, fixed_array_64
export fixed_array_128, fixed_array_256

# ============================================================================
# FixedArray - Capacity-Bounded Array
# ============================================================================

class FixedArray:
    """Fixed-capacity array backed by bounded storage.

    All operations are O(1) except remove() which is O(n).
    No heap growth â€” push returns false when full.
    """
    items: [i64]
    len: i32
    capacity: i32

    static fn new(capacity: i32) -> FixedArray:
        """Create a new fixed array with the given capacity."""
        FixedArray(items: [], len: 0, capacity: capacity)

    me push(value: i64) -> bool:
        """Append value. Returns false if array is full."""
        if self.len >= self.capacity:
            return false
        self.items.push(value)
        self.len = self.len + 1
        true

    fn get(index: i32) -> i64:
        """Get value at index. Caller must ensure index < len."""
        self.items[index]

    me set(index: i32, value: i64):
        """Set value at index. Caller must ensure index < len."""
        self.items[index] = value

    me remove(index: i32) -> i64:
        """Remove value at index, shifting elements left. Returns removed value."""
        val value = self.items[index]
        var i = index
        while i < self.len - 1:
            self.items[i] = self.items[i + 1]
            i = i + 1
        self.len = self.len - 1
        value

    fn is_full() -> bool:
        """Check if array is at capacity."""
        self.len >= self.capacity

    fn is_empty() -> bool:
        """Check if array has no elements."""
        self.len == 0

    me clear():
        """Remove all elements (capacity unchanged)."""
        self.items = []
        self.len = 0

    fn size() -> i32:
        """Return current number of elements."""
        self.len

    fn last() -> i64:
        """Return last element. Caller must ensure non-empty."""
        self.items[self.len - 1]

    me pop() -> i64:
        """Remove and return last element. Caller must ensure non-empty."""
        self.len = self.len - 1
        val value = self.items[self.len]
        value

    fn contains(value: i64) -> bool:
        """Check if value exists in array."""
        var i = 0
        while i < self.len:
            if self.items[i] == value:
                return true
            i = i + 1
        false

    fn index_of(value: i64) -> i32:
        """Find index of value. Returns -1 if not found."""
        var i = 0
        while i < self.len:
            if self.items[i] == value:
                return i
            i = i + 1
        -1

# ============================================================================
# Factory Functions (Common Sizes)
# ============================================================================

fn fixed_array_8() -> FixedArray:
    """Create a FixedArray with capacity 8."""
    FixedArray.new(8)

fn fixed_array_16() -> FixedArray:
    """Create a FixedArray with capacity 16."""
    FixedArray.new(16)

fn fixed_array_32() -> FixedArray:
    """Create a FixedArray with capacity 32."""
    FixedArray.new(32)

fn fixed_array_64() -> FixedArray:
    """Create a FixedArray with capacity 64."""
    FixedArray.new(64)

fn fixed_array_128() -> FixedArray:
    """Create a FixedArray with capacity 128."""
    FixedArray.new(128)

fn fixed_array_256() -> FixedArray:
    """Create a FixedArray with capacity 256."""
    FixedArray.new(256)
