# Fixed Set - Hash Set with Fixed Capacity
#
# Backed by FixedMap (key-only, value=1 sentinel).
# Fixed capacity, no heap growth. Operations are O(1) average.
#
# Usage:
#   val s = FixedSet.new(32)
#   s.add(42)
#   s.contains(42)  # true
#   s.remove(42)

export FixedSet

# ============================================================================
# FixedSet - Open-Addressing Hash Set
# ============================================================================

class FixedSet:
    """Fixed-capacity hash set backed by FixedMap.

    Keys are i64. Uses FixedMap with sentinel value 1
    for all entries. Load factor should stay below 75%
    for good performance.
    """
    map: FixedMap
    max_capacity: i32

    static fn new(capacity: i32) -> FixedSet:
        """Create a new hash set with the given capacity."""
        FixedSet(map: FixedMap.new(capacity), max_capacity: capacity)

    me add(value: i64) -> bool:
        """Add value to the set. Returns false if set is full."""
        if self.map.contains(value):
            return true    # Already present, not an error
        self.map.put(value, 1)

    me remove(value: i64) -> bool:
        """Remove value from the set. Returns false if not found."""
        self.map.remove(value)

    fn contains(value: i64) -> bool:
        """Check if value exists in the set."""
        self.map.contains(value)

    fn size() -> i32:
        """Return number of elements in the set."""
        self.map.size()

    fn is_empty() -> bool:
        """Check if set has no elements."""
        self.map.is_empty()

    fn is_full() -> bool:
        """Check if set is at capacity."""
        self.map.is_full()

    fn capacity() -> i32:
        """Return the maximum capacity of the set."""
        self.max_capacity
