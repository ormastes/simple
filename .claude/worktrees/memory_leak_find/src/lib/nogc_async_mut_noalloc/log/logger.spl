# Logger - Core Logging API for Bare-Metal Systems
#
# Provides log level filtering and dispatch to configured targets.
# All log functions check the global level before formatting/dispatching.
#
# Usage:
#   log_init(LOG_INFO, TARGET_DEVICE | TARGET_SEMIHOST)
#   log_info("System booted")
#   log_warn("Low memory")
#   log_error("Fault detected")

export LOG_TRACE, LOG_DEBUG, LOG_INFO, LOG_WARN, LOG_ERROR, LOG_FATAL, LOG_OFF
export log_init, log_set_level, log_set_targets
export log_trace, log_debug, log_info, log_warn, log_error, log_fatal
export log_trace_h, log_debug_h, log_info_h, log_warn_h, log_error_h, log_fatal_h
export log_info_h1, log_warn_h1, log_error_h1
export log_info_h2, log_warn_h2, log_error_h2
export log_level_name

# ============================================================================
# Log Levels (i32 constants, ordered by severity)
# ============================================================================

val LOG_TRACE: i32 = 0
val LOG_DEBUG: i32 = 1
val LOG_INFO: i32  = 2
val LOG_WARN: i32  = 3
val LOG_ERROR: i32 = 4
val LOG_FATAL: i32 = 5
val LOG_OFF: i32   = 6

# ============================================================================
# Global Logger State
# ============================================================================

var g_log_level: i32 = LOG_INFO      # Minimum level to output
var g_log_targets: i32 = 0           # Bitmask of active targets

# ============================================================================
# Initialization
# ============================================================================

fn log_init(level: i32, targets: i32):
    """Initialize the logger with minimum level and target bitmask.

    Level: one of LOG_TRACE..LOG_OFF
    Targets: bitwise OR of TARGET_DEVICE, TARGET_SEMIHOST, TARGET_HOST_FILE
    """
    g_log_level = level
    g_log_targets = targets

fn log_set_level(level: i32):
    """Change minimum log level at runtime."""
    g_log_level = level

fn log_set_targets(targets: i32):
    """Change active log targets at runtime."""
    g_log_targets = targets

# ============================================================================
# Level Name Helper
# ============================================================================

fn log_level_name(level: i32) -> text:
    """Return human-readable name for a log level."""
    if level == LOG_TRACE: return "TRACE"
    if level == LOG_DEBUG: return "DEBUG"
    if level == LOG_INFO:  return "INFO"
    if level == LOG_WARN:  return "WARN"
    if level == LOG_ERROR: return "ERROR"
    if level == LOG_FATAL: return "FATAL"
    "UNKNOWN"

# ============================================================================
# Text-Based Log Functions
# ============================================================================

fn log_at(level: i32, msg: text):
    """Log a message at the given level. Checks level filter first."""
    if level < g_log_level:
        return
    val prefix = log_level_name(level)
    val formatted = "[{prefix}] {msg}"
    log_dispatch(level, formatted)

fn log_trace(msg: text):
    """Log at TRACE level."""
    log_at(LOG_TRACE, msg)

fn log_debug(msg: text):
    """Log at DEBUG level."""
    log_at(LOG_DEBUG, msg)

fn log_info(msg: text):
    """Log at INFO level."""
    log_at(LOG_INFO, msg)

fn log_warn(msg: text):
    """Log at WARN level."""
    log_at(LOG_WARN, msg)

fn log_error(msg: text):
    """Log at ERROR level."""
    log_at(LOG_ERROR, msg)

fn log_fatal(msg: text):
    """Log at FATAL level."""
    log_at(LOG_FATAL, msg)

# ============================================================================
# Handle-Based Log Functions (Compressed — String Interning)
# ============================================================================

fn log_at_h(level: i32, handle: i32):
    """Log interned string at the given level."""
    if level < g_log_level:
        return
    log_dispatch_h(level, handle)

fn log_trace_h(handle: i32):
    """Log interned string at TRACE level."""
    log_at_h(LOG_TRACE, handle)

fn log_debug_h(handle: i32):
    """Log interned string at DEBUG level."""
    log_at_h(LOG_DEBUG, handle)

fn log_info_h(handle: i32):
    """Log interned string at INFO level."""
    log_at_h(LOG_INFO, handle)

fn log_warn_h(handle: i32):
    """Log interned string at WARN level."""
    log_at_h(LOG_WARN, handle)

fn log_error_h(handle: i32):
    """Log interned string at ERROR level."""
    log_at_h(LOG_ERROR, handle)

fn log_fatal_h(handle: i32):
    """Log interned string at FATAL level."""
    log_at_h(LOG_FATAL, handle)

# ============================================================================
# Parameterized Handle Log Functions (1-2 params)
# ============================================================================

fn log_info_h1(handle: i32, p0: i32):
    """Log interned string at INFO level with 1 parameter."""
    if LOG_INFO < g_log_level:
        return
    log_dispatch_h1(LOG_INFO, handle, p0)

fn log_warn_h1(handle: i32, p0: i32):
    """Log interned string at WARN level with 1 parameter."""
    if LOG_WARN < g_log_level:
        return
    log_dispatch_h1(LOG_WARN, handle, p0)

fn log_error_h1(handle: i32, p0: i32):
    """Log interned string at ERROR level with 1 parameter."""
    if LOG_ERROR < g_log_level:
        return
    log_dispatch_h1(LOG_ERROR, handle, p0)

fn log_info_h2(handle: i32, p0: i32, p1: i32):
    """Log interned string at INFO level with 2 parameters."""
    if LOG_INFO < g_log_level:
        return
    log_dispatch_h2(LOG_INFO, handle, p0, p1)

fn log_warn_h2(handle: i32, p0: i32, p1: i32):
    """Log interned string at WARN level with 2 parameters."""
    if LOG_WARN < g_log_level:
        return
    log_dispatch_h2(LOG_WARN, handle, p0, p1)

fn log_error_h2(handle: i32, p0: i32, p1: i32):
    """Log interned string at ERROR level with 2 parameters."""
    if LOG_ERROR < g_log_level:
        return
    log_dispatch_h2(LOG_ERROR, handle, p0, p1)

# ============================================================================
# Dispatch (delegates to targets.spl)
# ============================================================================

fn log_dispatch(level: i32, msg: text):
    """Dispatch formatted message to all active targets."""
    # Inline dispatch — targets.spl provides the target_*_write functions
    # Import pattern: both files are in the same module, auto-resolved
    if (g_log_targets & 1) != 0:
        target_device_write(msg)
    if (g_log_targets & 2) != 0:
        target_semihost_write(msg)
    if (g_log_targets & 4) != 0:
        target_file_write(msg)

fn log_dispatch_h(level: i32, handle: i32):
    """Dispatch interned handle to all active targets."""
    if (g_log_targets & 2) != 0:
        target_semihost_write_h(handle)

fn log_dispatch_h1(level: i32, handle: i32, p0: i32):
    """Dispatch interned handle with 1 param to semihost target."""
    if (g_log_targets & 2) != 0:
        target_semihost_write_h1(handle, p0)

fn log_dispatch_h2(level: i32, handle: i32, p0: i32, p1: i32):
    """Dispatch interned handle with 2 params to semihost target."""
    if (g_log_targets & 2) != 0:
        target_semihost_write_h2(handle, p0, p1)
