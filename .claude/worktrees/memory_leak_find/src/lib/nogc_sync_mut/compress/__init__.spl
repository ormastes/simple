"""Compression Module - Compression and decompression utilities

@tag:stdlib
@tag:api

This module provides compression and decompression utilities for common
formats including gzip, zlib, bzip2, lz4, and zstd. It supports both
in-memory and streaming operations.

Core Features
-------------

- **Multiple formats**: gzip, zlib, bzip2, lz4, zstd
- **Compression levels**: Fast to maximum compression
- **Streaming**: Process large files efficiently
- **In-memory**: Compress/decompress byte arrays
- **Error handling**: Robust error detection

Public API
----------

General compression:
```simple
use std.compress.{compress, decompress, CompressionFormat, CompressionLevel}
```

Format-specific functions:
```simple
use std.compress.{gzip_compress, gzip_decompress}
use std.compress.{zlib_compress, zlib_decompress}
use std.compress.{bzip2_compress, bzip2_decompress}
use std.compress.{lz4_compress, lz4_decompress}
use std.compress.{zstd_compress, zstd_decompress}
```

Examples
--------

Basic compression and decompression:
```simple
use std.compress.{compress, decompress, CompressionFormat}

# Original data
val data = b"Hello, World! This is some text to compress."

# Compress with gzip
val compressed = compress(data, CompressionFormat.Gzip)
print "Original: {data.len()} bytes"
print "Compressed: {compressed.len()} bytes"

# Decompress
val decompressed = decompress(compressed, CompressionFormat.Gzip)
print "Decompressed: {decompressed}"  # Hello, World! ...
```

Compression levels:
```simple
use std.compress.{gzip_compress, CompressionLevel}

val data = b"Example data to compress with different levels"

# Fast compression (less CPU, larger output)
val fast = gzip_compress(data, CompressionLevel.Fast)

# Balanced compression (default)
val balanced = gzip_compress(data, CompressionLevel.Default)

# Maximum compression (more CPU, smaller output)
val max = gzip_compress(data, CompressionLevel.Maximum)

print "Fast: {fast.len()} bytes"
print "Balanced: {balanced.len()} bytes"
print "Maximum: {max.len()} bytes"
```

File compression:
```simple
use std.compress.{gzip_compress_file, gzip_decompress_file}
use std.io_runtime.{file_read_bytes, file_write_bytes}

# Compress file
val input_path = "/tmp/large_file.txt"
val output_path = "/tmp/large_file.txt.gz"

val data = file_read_bytes(input_path)
val compressed = gzip_compress(data, CompressionLevel.Default)
file_write_bytes(output_path, compressed)

print "Compressed {input_path} -> {output_path}"

# Decompress file
val compressed_data = file_read_bytes(output_path)
val decompressed = gzip_decompress(compressed_data)
file_write_bytes("/tmp/restored.txt", decompressed)
```

Streaming compression:
```simple
use std.compress.{GzipCompressor, GzipDecompressor}

# Create compressor
val compressor = GzipCompressor.new(CompressionLevel.Default)

# Compress in chunks
val chunk1 = b"First chunk of data"
val chunk2 = b"Second chunk of data"
val chunk3 = b"Final chunk"

compressor.write(chunk1)
compressor.write(chunk2)
compressor.write(chunk3)

# Finalize and get compressed data
val compressed = compressor.finish()
print "Total compressed: {compressed.len()} bytes"
```

Format selection:
```simple
use std.compress.{compress, CompressionFormat}

val data = b"Data to compress"

# Try different formats
val gzip_result = compress(data, CompressionFormat.Gzip)
val zlib_result = compress(data, CompressionFormat.Zlib)
val bzip2_result = compress(data, CompressionFormat.Bzip2)
val lz4_result = compress(data, CompressionFormat.Lz4)
val zstd_result = compress(data, CompressionFormat.Zstd)

print "Gzip: {gzip_result.len()} bytes"
print "Zlib: {zlib_result.len()} bytes"
print "Bzip2: {bzip2_result.len()} bytes"
print "LZ4: {lz4_result.len()} bytes (fast)"
print "Zstd: {zstd_result.len()} bytes (modern)"
```

Compression Formats
-------------------

| Format | Speed | Ratio | Use Case |
|--------|-------|-------|----------|
| LZ4 | Very Fast | Low | Real-time, logging |
| Zstd | Fast | Good | General purpose |
| Gzip | Medium | Good | Web, archives |
| Zlib | Medium | Good | PNG, HTTP |
| Bzip2 | Slow | Best | Archival |

Compression Levels
------------------

```simple
CompressionLevel.Fast       # Level 1 - fast, lower compression
CompressionLevel.Default    # Level 6 - balanced
CompressionLevel.Maximum    # Level 9 - slow, best compression
CompressionLevel.Custom(5)  # Custom level (1-9)
```

Error Handling
--------------

All operations return Result types:

```simple
match gzip_compress(data, CompressionLevel.Default):
    case Ok(compressed):
        print "Compressed successfully: {compressed.len()} bytes"
    case Err(error):
        print "Compression failed: {error.message}"
```

Decompression errors:
```simple
match gzip_decompress(corrupted_data):
    case Ok(data):
        print "Decompressed: {data.len()} bytes"
    case Err(error):
        print "Decompression failed: {error.message}"
        print "  Possible corruption or wrong format"
```

Performance Tips
----------------

1. **Choose right format**: LZ4 for speed, Bzip2 for size
2. **Adjust compression level**: Balance speed vs size
3. **Use streaming**: For files larger than available RAM
4. **Batch small files**: Compress multiple files together
5. **Prefer Zstd**: Modern format with good speed/ratio

Memory Usage
------------

In-memory compression requires:
- Input data size
- Temporary buffers (1-2x input size)
- Output buffer (variable, usually smaller)

Streaming compression uses fixed buffers:
- Smaller memory footprint
- Suitable for large files

Submodules
----------

- **gzip**: Gzip compression (RFC 1952)
- **zlib**: Zlib compression (RFC 1950)
- **bzip2**: Bzip2 compression
- **lz4**: LZ4 compression (very fast)
- **zstd**: Zstandard compression (modern)

Related Modules
---------------

- **std.io_runtime**: File I/O operations
- **std.fs**: Filesystem utilities
- **app.io**: Low-level I/O

See Also
--------

- **doc/guide/compression.md**: Compression guide
- **test/unit/std/compress/**: Compression test examples
"""

# All submodules are automatically available.
