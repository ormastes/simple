# Utility functions for byte operations

# Convert string to byte array
use string.{char_from_code}

fn string_to_bytes(s: text) -> List:
    val result = []
    var i = 0
    while i < s.len():
        val ch = s.char_at(i)
        val code = s.char_code_at(i)
        result.append(code)
        i = i + 1
    result

# Convert byte array to string
fn bytes_to_string(bytes: List) -> text:
    var result = ""
    var i = 0
    while i < bytes.len():
        val code = bytes.get(i)
        if code >= 0 and code <= 127:
            val ch = code_to_char(code)
            result = result + ch
        i = i + 1
    result

# Convert character code to character
fn code_to_char(code: i64) -> text:
    """Wrapper for string.char_from_code."""
    char_from_code(code)
fn i64_to_bytes_be(value: i64) -> List:
    val result = []
    result.append((value >> 56) & 0xFF)
    result.append((value >> 48) & 0xFF)
    result.append((value >> 40) & 0xFF)
    result.append((value >> 32) & 0xFF)
    result.append((value >> 24) & 0xFF)
    result.append((value >> 16) & 0xFF)
    result.append((value >> 8) & 0xFF)
    result.append(value & 0xFF)
    result

# Encode integer as little-endian bytes
fn i64_to_bytes_le(value: i64) -> List:
    val result = []
    result.append(value & 0xFF)
    result.append((value >> 8) & 0xFF)
    result.append((value >> 16) & 0xFF)
    result.append((value >> 24) & 0xFF)
    result.append((value >> 32) & 0xFF)
    result.append((value >> 40) & 0xFF)
    result.append((value >> 48) & 0xFF)
    result.append((value >> 56) & 0xFF)
    result

# Decode big-endian bytes to integer
fn bytes_to_i64_be(bytes: List) -> i64:
    if bytes.len() < 8:
        return 0
    val b0 = bytes.get(0)
    val b1 = bytes.get(1)
    val b2 = bytes.get(2)
    val b3 = bytes.get(3)
    val b4 = bytes.get(4)
    val b5 = bytes.get(5)
    val b6 = bytes.get(6)
    val b7 = bytes.get(7)
    var result = 0
    result = (b0 << 56) | (b1 << 48) | (b2 << 40) | (b3 << 32)
    result = result | (b4 << 24) | (b5 << 16) | (b6 << 8) | b7
    result

# Decode little-endian bytes to integer
fn bytes_to_i64_le(bytes: List) -> i64:
    if bytes.len() < 8:
        return 0
    val b0 = bytes.get(0)
    val b1 = bytes.get(1)
    val b2 = bytes.get(2)
    val b3 = bytes.get(3)
    val b4 = bytes.get(4)
    val b5 = bytes.get(5)
    val b6 = bytes.get(6)
    val b7 = bytes.get(7)
    var result = 0
    result = (b7 << 56) | (b6 << 48) | (b5 << 40) | (b4 << 32)
    result = result | (b3 << 24) | (b2 << 16) | (b1 << 8) | b0
    result

# Encode 32-bit integer as big-endian bytes
fn i32_to_bytes_be(value: i64) -> List:
    val result = []
    result.append((value >> 24) & 0xFF)
    result.append((value >> 16) & 0xFF)
    result.append((value >> 8) & 0xFF)
    result.append(value & 0xFF)
    result

# Encode 32-bit integer as little-endian bytes
fn i32_to_bytes_le(value: i64) -> List:
    val result = []
    result.append(value & 0xFF)
    result.append((value >> 8) & 0xFF)
    result.append((value >> 16) & 0xFF)
    result.append((value >> 24) & 0xFF)
    result

# Decode big-endian bytes to 32-bit integer
fn bytes_to_i32_be(bytes: List) -> i64:
    if bytes.len() < 4:
        return 0
    val b0 = bytes.get(0)
    val b1 = bytes.get(1)
    val b2 = bytes.get(2)
    val b3 = bytes.get(3)
    (b0 << 24) | (b1 << 16) | (b2 << 8) | b3

# Decode little-endian bytes to 32-bit integer
fn bytes_to_i32_le(bytes: List) -> i64:
    if bytes.len() < 4:
        return 0
    val b0 = bytes.get(0)
    val b1 = bytes.get(1)
    val b2 = bytes.get(2)
    val b3 = bytes.get(3)
    (b3 << 24) | (b2 << 16) | (b1 << 8) | b0

# Compare two byte arrays
fn compare_bytes(a: List, b: List) -> i64:
    val len_a = a.len()
    val len_b = b.len()
    val min_len = if len_a < len_b: len_a else: len_b
    var i = 0
    while i < min_len:
        val byte_a = a.get(i)
        val byte_b = b.get(i)
        if byte_a < byte_b:
            return -1
        if byte_a > byte_b:
            return 1
        i = i + 1
    if len_a < len_b:
        return -1
    if len_a > len_b:
        return 1
    0

# Check if two byte arrays are equal
fn bytes_equal(a: List, b: List) -> bool:
    compare_bytes(a, b) == 0

# Concatenate two byte arrays
fn concat_bytes(a: List, b: List) -> List:
    val result = []
    var i = 0
    while i < a.len():
        result.append(a.get(i))
        i = i + 1
    i = 0
    while i < b.len():
        result.append(b.get(i))
        i = i + 1
    result

# Create a copy of a byte array
fn copy_bytes(bytes: List) -> List:
    val result = []
    var i = 0
    while i < bytes.len():
        result.append(bytes.get(i))
        i = i + 1
    result

# Reverse a byte array
fn reverse_bytes(bytes: List) -> List:
    val result = []
    var i = 0
    val len_val = bytes.len()
    while i < len_val:
        result.append(bytes.get(len_val - 1 - i))
        i = i + 1
    result

# Get a slice of a byte array
fn slice_bytes(bytes: List, start: i64, end: i64) -> List:
    val result = []
    var i = start
    while i < end and i < bytes.len():
        result.append(bytes.get(i))
        i = i + 1
    result

# Find a byte in a byte array (returns index or -1)
fn find_byte(bytes: List, target: i64) -> i64:
    var i = 0
    while i < bytes.len():
        if bytes.get(i) == target:
            return i
        i = i + 1
    -1

# Count occurrences of a byte in a byte array
fn count_byte(bytes: List, target: i64) -> i64:
    var count = 0
    var i = 0
    while i < bytes.len():
        if bytes.get(i) == target:
            count = count + 1
        i = i + 1
    count

# XOR two byte arrays (result length is minimum of both)
fn xor_bytes(a: List, b: List) -> List:
    val result = []
    val len_a = a.len()
    val len_b = b.len()
    val min_len = if len_a < len_b: len_a else: len_b
    var i = 0
    while i < min_len:
        result.append(a.get(i) ^ b.get(i))
        i = i + 1
    result

# Convert byte array to hexadecimal string
fn bytes_to_hex(bytes: List) -> text:
    val hex_chars = "0123456789abcdef"
    var result = ""
    var i = 0
    while i < bytes.len():
        val byte_val = bytes.get(i)
        val high = (byte_val >> 4) & 0x0F
        val low = byte_val & 0x0F
        result = result + hex_chars.char_at(high)
        result = result + hex_chars.char_at(low)
        i = i + 1
    result

# Convert hexadecimal string to byte array
fn hex_to_bytes(hex: text) -> List:
    val result = []
    var i = 0
    while i < hex.len() - 1:
        val high_char = hex.char_at(i)
        val low_char = hex.char_at(i + 1)
        val high = hex_char_to_value(high_char)
        val low = hex_char_to_value(low_char)
        if high >= 0 and low >= 0:
            result.append((high << 4) | low)
        i = i + 2
    result

# Convert hex character to value
fn hex_char_to_value(ch: text) -> i64:
    if ch == "0": return 0
    if ch == "1": return 1
    if ch == "2": return 2
    if ch == "3": return 3
    if ch == "4": return 4
    if ch == "5": return 5
    if ch == "6": return 6
    if ch == "7": return 7
    if ch == "8": return 8
    if ch == "9": return 9
    if ch == "a" or ch == "A": return 10
    if ch == "b" or ch == "B": return 11
    if ch == "c" or ch == "C": return 12
    if ch == "d" or ch == "D": return 13
    if ch == "e" or ch == "E": return 14
    if ch == "f" or ch == "F": return 15
    -1

# Checksum calculation (simple sum modulo 256)
fn checksum(bytes: List) -> i64:
    var sum = 0
    var i = 0
    while i < bytes.len():
        sum = sum + bytes.get(i)
        i = i + 1
    sum & 0xFF

# CRC-8 calculation
fn crc8(bytes: List) -> i64:
    var crc = 0
    var i = 0
    while i < bytes.len():
        crc = crc ^ bytes.get(i)
        var j = 0
        while j < 8:
            var test = (crc & 0x80) != 0
            if test:
                crc = (crc << 1) ^ 0x07
            if not test:
                crc = crc << 1
            j = j + 1
        i = i + 1
    crc & 0xFF
