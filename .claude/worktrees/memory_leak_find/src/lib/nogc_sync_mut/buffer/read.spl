# Buffer Read Operations

# Read a single byte
fn buffer_read_byte(buf: Buffer) -> i64:
    if buf.read_pos >= buf.write_pos:
        return -1
    val byte_val = buf.data.get(buf.read_pos)
    var new_pos = buf.read_pos
    new_pos = new_pos + 1
    buf.read_pos = new_pos
    byte_val

# Read multiple bytes into a list
fn buffer_read_bytes(buf: Buffer, count: i64) -> List:
    val result = []
    var remaining = count
    while remaining > 0 and buf.read_pos < buf.write_pos:
        result.append(buf.data.get(buf.read_pos))
        var new_pos = buf.read_pos
        new_pos = new_pos + 1
        buf.read_pos = new_pos
        remaining = remaining - 1
    result

# Read bytes until buffer is empty
fn buffer_read_all(buf: Buffer) -> List:
    buffer_read_bytes(buf, buf.available())

# Peek at a byte without advancing position
fn buffer_peek_byte(buf: Buffer) -> i64:
    if buf.read_pos >= buf.write_pos:
        return -1
    buf.data.get(buf.read_pos)

# Peek at multiple bytes without advancing position
fn buffer_peek_bytes(buf: Buffer, count: i64) -> List:
    val result = []
    var i = 0
    var pos = buf.read_pos
    while i < count and pos < buf.write_pos:
        result.append(buf.data.get(pos))
        pos = pos + 1
        i = i + 1
    result

# Read a 64-bit integer in big-endian format
fn buffer_read_i64_be(buf: Buffer) -> i64:
    val b0 = buffer_read_byte(buf)
    val b1 = buffer_read_byte(buf)
    val b2 = buffer_read_byte(buf)
    val b3 = buffer_read_byte(buf)
    val b4 = buffer_read_byte(buf)
    val b5 = buffer_read_byte(buf)
    val b6 = buffer_read_byte(buf)
    val b7 = buffer_read_byte(buf)
    var result = 0
    result = (b0 << 56) | (b1 << 48) | (b2 << 40) | (b3 << 32)
    result = result | (b4 << 24) | (b5 << 16) | (b6 << 8) | b7
    result

# Read a 64-bit integer in little-endian format
fn buffer_read_i64_le(buf: Buffer) -> i64:
    val b0 = buffer_read_byte(buf)
    val b1 = buffer_read_byte(buf)
    val b2 = buffer_read_byte(buf)
    val b3 = buffer_read_byte(buf)
    val b4 = buffer_read_byte(buf)
    val b5 = buffer_read_byte(buf)
    val b6 = buffer_read_byte(buf)
    val b7 = buffer_read_byte(buf)
    var result = 0
    result = (b7 << 56) | (b6 << 48) | (b5 << 40) | (b4 << 32)
    result = result | (b3 << 24) | (b2 << 16) | (b1 << 8) | b0
    result

# Read a 32-bit integer in big-endian format
fn buffer_read_i32_be(buf: Buffer) -> i64:
    val b0 = buffer_read_byte(buf)
    val b1 = buffer_read_byte(buf)
    val b2 = buffer_read_byte(buf)
    val b3 = buffer_read_byte(buf)
    (b0 << 24) | (b1 << 16) | (b2 << 8) | b3

# Read a 32-bit integer in little-endian format
fn buffer_read_i32_le(buf: Buffer) -> i64:
    val b0 = buffer_read_byte(buf)
    val b1 = buffer_read_byte(buf)
    val b2 = buffer_read_byte(buf)
    val b3 = buffer_read_byte(buf)
    (b3 << 24) | (b2 << 16) | (b1 << 8) | b0

# Read a 16-bit integer in big-endian format
fn buffer_read_i16_be(buf: Buffer) -> i64:
    val b0 = buffer_read_byte(buf)
    val b1 = buffer_read_byte(buf)
    (b0 << 8) | b1

# Read a 16-bit integer in little-endian format
fn buffer_read_i16_le(buf: Buffer) -> i64:
    val b0 = buffer_read_byte(buf)
    val b1 = buffer_read_byte(buf)
    (b1 << 8) | b0

# Read a string with length prefix
fn buffer_read_string(buf: Buffer) -> text:
    val len_val = buffer_read_i32_be(buf)
    if len_val < 0 or len_val > buf.available():
        return ""
    val bytes = buffer_read_bytes(buf, len_val)
    bytes_to_string(bytes)

# Read a fixed-length string
fn buffer_read_raw_string(buf: Buffer, length: i64) -> text:
    val bytes = buffer_read_bytes(buf, length)
    bytes_to_string(bytes)

# Read until newline or end
fn buffer_read_line(buf: Buffer) -> text:
    val bytes = []
    var byte_val = buffer_read_byte(buf)
    while byte_val != -1 and byte_val != 10:
        bytes.append(byte_val)
        byte_val = buffer_read_byte(buf)
    bytes_to_string(bytes)

# Forward declaration
fn bytes_to_string(bytes: List) -> text
