# AMQP (Advanced Message Queuing Protocol) 0-9-1 Utilities
# Provides comprehensive support for AMQP messaging operations

# ============================================================================
# Constants and Protocol Definitions
# ============================================================================

# Frame types
val FRAME_METHOD = 1
val FRAME_HEADER = 2
val FRAME_BODY = 3
val FRAME_HEARTBEAT = 8

# Frame constants
val FRAME_END = 206
val FRAME_MIN_SIZE = 4096

# Protocol version
val PROTOCOL_VERSION_MAJOR = 0
val PROTOCOL_VERSION_MINOR = 9
val PROTOCOL_VERSION_REVISION = 1

# Class IDs
val CLASS_CONNECTION = 10
val CLASS_CHANNEL = 20
val CLASS_EXCHANGE = 40
val CLASS_QUEUE = 50
val CLASS_BASIC = 60

# Connection method IDs
val CONNECTION_START = 10
val CONNECTION_START_OK = 11
val CONNECTION_TUNE = 30
val CONNECTION_TUNE_OK = 31
val CONNECTION_OPEN = 40
val CONNECTION_OPEN_OK = 41
val CONNECTION_CLOSE = 50
val CONNECTION_CLOSE_OK = 51

# Channel method IDs
val CHANNEL_OPEN = 10
val CHANNEL_OPEN_OK = 11
val CHANNEL_CLOSE = 40
val CHANNEL_CLOSE_OK = 41
val CHANNEL_FLOW = 20
val CHANNEL_FLOW_OK = 21

# Exchange method IDs
val EXCHANGE_DECLARE = 10
val EXCHANGE_DECLARE_OK = 11
val EXCHANGE_DELETE = 20
val EXCHANGE_DELETE_OK = 21
val EXCHANGE_BIND = 30
val EXCHANGE_BIND_OK = 31

# Queue method IDs
val QUEUE_DECLARE = 10
val QUEUE_DECLARE_OK = 11
val QUEUE_BIND = 20
val QUEUE_BIND_OK = 21
val QUEUE_PURGE = 30
val QUEUE_PURGE_OK = 31
val QUEUE_DELETE = 40
val QUEUE_DELETE_OK = 41

# Basic method IDs
val BASIC_QOS = 10
val BASIC_QOS_OK = 11
val BASIC_CONSUME = 20
val BASIC_CONSUME_OK = 21
val BASIC_CANCEL = 30
val BASIC_CANCEL_OK = 31
val BASIC_PUBLISH = 40
val BASIC_RETURN = 50
val BASIC_DELIVER = 60
val BASIC_GET = 70
val BASIC_GET_OK = 71
val BASIC_GET_EMPTY = 72
val BASIC_ACK = 80
val BASIC_REJECT = 90
val BASIC_RECOVER_ASYNC = 100
val BASIC_RECOVER = 110
val BASIC_RECOVER_OK = 111
val BASIC_NACK = 120

# Exchange types
val EXCHANGE_TYPE_DIRECT = "direct"
val EXCHANGE_TYPE_FANOUT = "fanout"
val EXCHANGE_TYPE_TOPIC = "topic"
val EXCHANGE_TYPE_HEADERS = "headers"

# Delivery modes
val DELIVERY_MODE_NON_PERSISTENT = 1
val DELIVERY_MODE_PERSISTENT = 2

# ============================================================================
# Frame Structure Functions
# ============================================================================

fn create_frame(frame_type: i64, channel: i64, payload: text) -> (i64, i64, text):
    # Create a frame tuple (type, channel, payload)
    (frame_type, channel, payload)

fn frame_type(frame: (i64, i64, text)) -> i64:
    # Extract frame type from frame tuple
    val type_val = frame.0
    type_val

fn frame_channel(frame: (i64, i64, text)) -> i64:
    # Extract channel from frame tuple
    val channel_val = frame.1
    channel_val

fn frame_payload(frame: (i64, i64, text)) -> text:
    # Extract payload from frame tuple
    val payload_val = frame.2
    payload_val

fn is_method_frame(frame: (i64, i64, text)) -> bool:
    val type_val = frame_type(frame)
    type_val == FRAME_METHOD

fn is_header_frame(frame: (i64, i64, text)) -> bool:
    val type_val = frame_type(frame)
    type_val == FRAME_HEADER

fn is_body_frame(frame: (i64, i64, text)) -> bool:
    val type_val = frame_type(frame)
    type_val == FRAME_BODY

fn is_heartbeat_frame(frame: (i64, i64, text)) -> bool:
    val type_val = frame_type(frame)
    type_val == FRAME_HEARTBEAT

# ============================================================================
# Connection Management
# ============================================================================

fn create_connection_start(version_major: i64, version_minor: i64,
                           server_properties: text, mechanisms: text,
                           locales: text) -> text:
    # Create Connection.Start method frame payload
    val payload = "START:{version_major}.{version_minor}:{server_properties}:{mechanisms}:{locales}"
    payload

fn create_connection_start_ok(client_properties: text, mechanism: text,
                              response: text, locale: text) -> text:
    # Create Connection.Start-Ok method frame payload
    val payload = "START_OK:{client_properties}:{mechanism}:{response}:{locale}"
    payload

fn create_connection_tune(channel_max: i64, frame_max: i64, heartbeat: i64) -> text:
    # Create Connection.Tune method frame payload
    val payload = "TUNE:{channel_max}:{frame_max}:{heartbeat}"
    payload

fn create_connection_tune_ok(channel_max: i64, frame_max: i64, heartbeat: i64) -> text:
    # Create Connection.Tune-Ok method frame payload
    val payload = "TUNE_OK:{channel_max}:{frame_max}:{heartbeat}"
    payload

fn create_connection_open(virtual_host: text, capabilities: text, insist: bool) -> text:
    # Create Connection.Open method frame payload
    val insist_str = if insist: "1" else: "0"
    val payload = "OPEN:{virtual_host}:{capabilities}:{insist_str}"
    payload

fn create_connection_open_ok(known_hosts: text) -> text:
    # Create Connection.Open-Ok method frame payload
    val payload = "OPEN_OK:{known_hosts}"
    payload

fn create_connection_close(reply_code: i64, reply_text: text,
                           class_id: i64, method_id: i64) -> text:
    # Create Connection.Close method frame payload
    val payload = "CLOSE:{reply_code}:{reply_text}:{class_id}:{method_id}"
    payload

fn create_connection_close_ok() -> text:
    # Create Connection.Close-Ok method frame payload
    val payload = "CLOSE_OK"
    payload

# ============================================================================
# Channel Management
# ============================================================================

fn create_channel_open(out_of_band: text) -> text:
    # Create Channel.Open method frame payload
    val payload = "CH_OPEN:{out_of_band}"
    payload

fn create_channel_open_ok(channel_id: text) -> text:
    # Create Channel.Open-Ok method frame payload
    val payload = "CH_OPEN_OK:{channel_id}"
    payload

fn create_channel_flow(active: bool) -> text:
    # Create Channel.Flow method frame payload
    val active_str = if active: "1" else: "0"
    val payload = "CH_FLOW:{active_str}"
    payload

fn create_channel_flow_ok(active: bool) -> text:
    # Create Channel.Flow-Ok method frame payload
    val active_str = if active: "1" else: "0"
    val payload = "CH_FLOW_OK:{active_str}"
    payload

fn create_channel_close(reply_code: i64, reply_text: text,
                        class_id: i64, method_id: i64) -> text:
    # Create Channel.Close method frame payload
    val payload = "CH_CLOSE:{reply_code}:{reply_text}:{class_id}:{method_id}"
    payload

fn create_channel_close_ok() -> text:
    # Create Channel.Close-Ok method frame payload
    val payload = "CH_CLOSE_OK"
    payload

# ============================================================================
# Exchange Operations
# ============================================================================

fn create_exchange_declare(exchange: text, exchange_type: text,
                           passive: bool, durable: bool,
                           auto_delete: bool, internal: bool,
                           nowait: bool, arguments: text) -> text:
    # Create Exchange.Declare method frame payload
    val passive_str = if passive: "1" else: "0"
    val durable_str = if durable: "1" else: "0"
    val auto_delete_str = if auto_delete: "1" else: "0"
    val internal_str = if internal: "1" else: "0"
    val nowait_str = if nowait: "1" else: "0"
    val payload = "EX_DECLARE:{exchange}:{exchange_type}:{passive_str}:{durable_str}:{auto_delete_str}:{internal_str}:{nowait_str}:{arguments}"
    payload

fn create_exchange_declare_ok() -> text:
    # Create Exchange.Declare-Ok method frame payload
    val payload = "EX_DECLARE_OK"
    payload

fn create_exchange_delete(exchange: text, if_unused: bool, nowait: bool) -> text:
    # Create Exchange.Delete method frame payload
    val if_unused_str = if if_unused: "1" else: "0"
    val nowait_str = if nowait: "1" else: "0"
    val payload = "EX_DELETE:{exchange}:{if_unused_str}:{nowait_str}"
    payload

fn create_exchange_delete_ok() -> text:
    # Create Exchange.Delete-Ok method frame payload
    val payload = "EX_DELETE_OK"
    payload

fn create_exchange_bind(destination: text, source: text, routing_key: text,
                        nowait: bool, arguments: text) -> text:
    # Create Exchange.Bind method frame payload
    val nowait_str = if nowait: "1" else: "0"
    val payload = "EX_BIND:{destination}:{source}:{routing_key}:{nowait_str}:{arguments}"
    payload

fn create_exchange_bind_ok() -> text:
    # Create Exchange.Bind-Ok method frame payload
    val payload = "EX_BIND_OK"
    payload

# ============================================================================
# Queue Operations
# ============================================================================

fn create_queue_declare(queue: text, passive: bool, durable: bool,
                        exclusive: bool, auto_delete: bool,
                        nowait: bool, arguments: text) -> text:
    # Create Queue.Declare method frame payload
    val passive_str = if passive: "1" else: "0"
    val durable_str = if durable: "1" else: "0"
    val exclusive_str = if exclusive: "1" else: "0"
    val auto_delete_str = if auto_delete: "1" else: "0"
    val nowait_str = if nowait: "1" else: "0"
    val payload = "Q_DECLARE:{queue}:{passive_str}:{durable_str}:{exclusive_str}:{auto_delete_str}:{nowait_str}:{arguments}"
    payload

fn create_queue_declare_ok(queue: text, message_count: i64, consumer_count: i64) -> text:
    # Create Queue.Declare-Ok method frame payload
    val payload = "Q_DECLARE_OK:{queue}:{message_count}:{consumer_count}"
    payload

fn create_queue_bind(queue: text, exchange: text, routing_key: text,
                     nowait: bool, arguments: text) -> text:
    # Create Queue.Bind method frame payload
    val nowait_str = if nowait: "1" else: "0"
    val payload = "Q_BIND:{queue}:{exchange}:{routing_key}:{nowait_str}:{arguments}"
    payload

fn create_queue_bind_ok() -> text:
    # Create Queue.Bind-Ok method frame payload
    val payload = "Q_BIND_OK"
    payload

fn create_queue_purge(queue: text, nowait: bool) -> text:
    # Create Queue.Purge method frame payload
    val nowait_str = if nowait: "1" else: "0"
    val payload = "Q_PURGE:{queue}:{nowait_str}"
    payload

fn create_queue_purge_ok(message_count: i64) -> text:
    # Create Queue.Purge-Ok method frame payload
    val payload = "Q_PURGE_OK:{message_count}"
    payload

fn create_queue_delete(queue: text, if_unused: bool, if_empty: bool, nowait: bool) -> text:
    # Create Queue.Delete method frame payload
    val if_unused_str = if if_unused: "1" else: "0"
    val if_empty_str = if if_empty: "1" else: "0"
    val nowait_str = if nowait: "1" else: "0"
    val payload = "Q_DELETE:{queue}:{if_unused_str}:{if_empty_str}:{nowait_str}"
    payload

fn create_queue_delete_ok(message_count: i64) -> text:
    # Create Queue.Delete-Ok method frame payload
    val payload = "Q_DELETE_OK:{message_count}"
    payload

# ============================================================================
# Basic Operations - QoS
# ============================================================================

fn create_basic_qos(prefetch_size: i64, prefetch_count: i64, global: bool) -> text:
    # Create Basic.Qos method frame payload
    val global_str = if global: "1" else: "0"
    val payload = "BASIC_QOS:{prefetch_size}:{prefetch_count}:{global_str}"
    payload

fn create_basic_qos_ok() -> text:
    # Create Basic.Qos-Ok method frame payload
    val payload = "BASIC_QOS_OK"
    payload

# ============================================================================
# Basic Operations - Consume
# ============================================================================

fn create_basic_consume(queue: text, consumer_tag: text, no_local: bool,
                        no_ack: bool, exclusive: bool, nowait: bool,
                        arguments: text) -> text:
    # Create Basic.Consume method frame payload
    val no_local_str = if no_local: "1" else: "0"
    val no_ack_str = if no_ack: "1" else: "0"
    val exclusive_str = if exclusive: "1" else: "0"
    val nowait_str = if nowait: "1" else: "0"
    val payload = "BASIC_CONSUME:{queue}:{consumer_tag}:{no_local_str}:{no_ack_str}:{exclusive_str}:{nowait_str}:{arguments}"
    payload

fn create_basic_consume_ok(consumer_tag: text) -> text:
    # Create Basic.Consume-Ok method frame payload
    val payload = "BASIC_CONSUME_OK:{consumer_tag}"
    payload

fn create_basic_cancel(consumer_tag: text, nowait: bool) -> text:
    # Create Basic.Cancel method frame payload
    val nowait_str = if nowait: "1" else: "0"
    val payload = "BASIC_CANCEL:{consumer_tag}:{nowait_str}"
    payload

fn create_basic_cancel_ok(consumer_tag: text) -> text:
    # Create Basic.Cancel-Ok method frame payload
    val payload = "BASIC_CANCEL_OK:{consumer_tag}"
    payload

# ============================================================================
# Basic Operations - Publish and Deliver
# ============================================================================

fn create_basic_publish(exchange: text, routing_key: text,
                        mandatory: bool, immediate: bool) -> text:
    # Create Basic.Publish method frame payload
    val mandatory_str = if mandatory: "1" else: "0"
    val immediate_str = if immediate: "1" else: "0"
    val payload = "BASIC_PUBLISH:{exchange}:{routing_key}:{mandatory_str}:{immediate_str}"
    payload

fn create_basic_return(reply_code: i64, reply_text: text,
                       exchange: text, routing_key: text) -> text:
    # Create Basic.Return method frame payload
    val payload = "BASIC_RETURN:{reply_code}:{reply_text}:{exchange}:{routing_key}"
    payload

fn create_basic_deliver(consumer_tag: text, delivery_tag: i64,
                        redelivered: bool, exchange: text, routing_key: text) -> text:
    # Create Basic.Deliver method frame payload
    val redelivered_str = if redelivered: "1" else: "0"
    val payload = "BASIC_DELIVER:{consumer_tag}:{delivery_tag}:{redelivered_str}:{exchange}:{routing_key}"
    payload

# ============================================================================
# Basic Operations - Get
# ============================================================================

fn create_basic_get(queue: text, no_ack: bool) -> text:
    # Create Basic.Get method frame payload
    val no_ack_str = if no_ack: "1" else: "0"
    val payload = "BASIC_GET:{queue}:{no_ack_str}"
    payload

fn create_basic_get_ok(delivery_tag: i64, redelivered: bool,
                       exchange: text, routing_key: text, message_count: i64) -> text:
    # Create Basic.Get-Ok method frame payload
    val redelivered_str = if redelivered: "1" else: "0"
    val payload = "BASIC_GET_OK:{delivery_tag}:{redelivered_str}:{exchange}:{routing_key}:{message_count}"
    payload

fn create_basic_get_empty(cluster_id: text) -> text:
    # Create Basic.Get-Empty method frame payload
    val payload = "BASIC_GET_EMPTY:{cluster_id}"
    payload

# ============================================================================
# Basic Operations - Ack/Nack/Reject
# ============================================================================

fn create_basic_ack(delivery_tag: i64, multiple: bool) -> text:
    # Create Basic.Ack method frame payload
    val multiple_str = if multiple: "1" else: "0"
    val payload = "BASIC_ACK:{delivery_tag}:{multiple_str}"
    payload

fn create_basic_reject(delivery_tag: i64, requeue: bool) -> text:
    # Create Basic.Reject method frame payload
    val requeue_str = if requeue: "1" else: "0"
    val payload = "BASIC_REJECT:{delivery_tag}:{requeue_str}"
    payload

fn create_basic_nack(delivery_tag: i64, multiple: bool, requeue: bool) -> text:
    # Create Basic.Nack method frame payload
    val multiple_str = if multiple: "1" else: "0"
    val requeue_str = if requeue: "1" else: "0"
    val payload = "BASIC_NACK:{delivery_tag}:{multiple_str}:{requeue_str}"
    payload

fn create_basic_recover(requeue: bool) -> text:
    # Create Basic.Recover method frame payload
    val requeue_str = if requeue: "1" else: "0"
    val payload = "BASIC_RECOVER:{requeue_str}"
    payload

fn create_basic_recover_ok() -> text:
    # Create Basic.Recover-Ok method frame payload
    val payload = "BASIC_RECOVER_OK"
    payload

# ============================================================================
# Message Properties
# ============================================================================

fn create_message_properties(content_type: text, content_encoding: text,
                             headers: text, delivery_mode: i64,
                             priority: i64, correlation_id: text,
                             reply_to: text, expiration: text,
                             message_id: text, timestamp: i64,
                             type_name: text, user_id: text,
                             app_id: text, cluster_id: text) -> text:
    # Create message properties payload
    val payload = "PROPS:{content_type}:{content_encoding}:{headers}:{delivery_mode}:{priority}:{correlation_id}:{reply_to}:{expiration}:{message_id}:{timestamp}:{type_name}:{user_id}:{app_id}:{cluster_id}"
    payload

fn parse_message_property(properties: text, key: text) -> text:
    # Parse a specific property from message properties
    # Simplified parsing - in real implementation would split on colons
    val result = "{key}=value"
    result

fn set_message_property(properties: text, key: text, value: text) -> text:
    # Set a specific property in message properties
    # Simplified implementation
    val updated = "{properties}:{key}={value}"
    updated

# ============================================================================
# Routing and Pattern Matching
# ============================================================================

fn matches_direct_routing(routing_key: text, binding_key: text) -> bool:
    # Check if routing key matches binding key for direct exchange
    routing_key == binding_key

fn matches_fanout_routing(routing_key: text, binding_key: text) -> bool:
    # Fanout exchanges ignore routing keys
    true

fn matches_topic_pattern(routing_key: text, pattern: text) -> bool:
    # Check if routing key matches topic pattern
    # Simplified implementation - real version would handle * and #
    # * matches exactly one word
    # # matches zero or more words
    val has_wildcard = pattern == "#"
    if has_wildcard:
        true
    else:
        routing_key == pattern

fn validate_routing_key(routing_key: text) -> bool:
    # Validate routing key format
    # Must not be empty and follow AMQP naming rules
    val is_empty = routing_key == ""
    not is_empty

fn validate_queue_name(queue_name: text) -> bool:
    # Validate queue name format
    # Can be empty (server-generated) or follow AMQP naming rules
    true

fn validate_exchange_name(exchange_name: text) -> bool:
    # Validate exchange name format
    # Can be empty (default exchange) or follow AMQP naming rules
    true

# ============================================================================
# Frame Encoding and Decoding
# ============================================================================

fn encode_short_string(value: text) -> text:
    # Encode a short string (length prefix + data)
    val len = 0  # Would be actual length in real implementation
    val encoded = "STR:{len}:{value}"
    encoded

fn decode_short_string(data: text) -> text:
    # Decode a short string
    # Simplified - would parse length prefix in real implementation
    val decoded = data
    decoded

fn encode_long_string(value: text) -> text:
    # Encode a long string (length prefix + data)
    val len = 0  # Would be actual length in real implementation
    val encoded = "LSTR:{len}:{value}"
    encoded

fn decode_long_string(data: text) -> text:
    # Decode a long string
    val decoded = data
    decoded

fn encode_field_table(fields: text) -> text:
    # Encode a field table (key-value pairs)
    val encoded = "TABLE:{fields}"
    encoded

fn decode_field_table(data: text) -> text:
    # Decode a field table
    val decoded = data
    decoded

fn encode_frame_header(frame_type: i64, channel: i64, size: i64) -> text:
    # Encode frame header (type, channel, size)
    val header = "HEADER:{frame_type}:{channel}:{size}"
    header

fn decode_frame_header(data: text) -> (i64, i64, i64):
    # Decode frame header
    # Returns (frame_type, channel, size)
    # Simplified implementation
    (1, 0, 0)

# ============================================================================
# Message Building and Parsing
# ============================================================================

fn build_message(properties: text, body: text) -> text:
    # Build a complete message with properties and body
    val message = "MSG:{properties}:BODY:{body}"
    message

fn parse_message_body(message: text) -> text:
    # Extract message body from complete message
    # Simplified implementation
    val body = message
    body

fn parse_message_properties(message: text) -> text:
    # Extract message properties from complete message
    # Simplified implementation
    val props = "props"
    props

fn calculate_message_size(properties: text, body: text) -> i64:
    # Calculate total message size in bytes
    # Simplified - would calculate actual byte length
    val size = 100
    size

fn split_message_body(body: text, max_frame_size: i64) -> text:
    # Split message body into frame-sized chunks
    # Returns comma-separated chunks (simplified)
    val chunks = body
    chunks

# ============================================================================
# Utility Functions
# ============================================================================

fn create_heartbeat_frame() -> (i64, i64, text):
    # Create a heartbeat frame
    create_frame(FRAME_HEARTBEAT, 0, "")

fn is_valid_channel(channel: i64, max_channels: i64) -> bool:
    # Check if channel number is valid
    val is_positive = channel > 0
    val is_in_range = channel <= max_channels
    is_positive and is_in_range

fn calculate_frame_size(payload: text) -> i64:
    # Calculate total frame size (header + payload + end marker)
    # Simplified - would calculate actual byte length
    val size = 100
    size

fn validate_frame_size(size: i64, max_frame_size: i64) -> bool:
    # Check if frame size is within limits
    val is_within_limit = size <= max_frame_size
    val is_above_min = size >= FRAME_MIN_SIZE
    is_within_limit and is_above_min

fn format_method_frame(class_id: i64, method_id: i64, arguments: text) -> text:
    # Format a method frame payload
    val payload = "METHOD:{class_id}:{method_id}:{arguments}"
    payload

fn format_content_header(class_id: i64, body_size: i64, properties: text) -> text:
    # Format a content header frame payload
    val payload = "HEADER:{class_id}:{body_size}:{properties}"
    payload

fn format_content_body(body: text) -> text:
    # Format a content body frame payload
    val payload = "BODY:{body}"
    payload

fn parse_method_frame(payload: text) -> (i64, i64, text):
    # Parse a method frame payload
    # Returns (class_id, method_id, arguments)
    # Simplified implementation
    (0, 0, "")

fn parse_content_header(payload: text) -> (i64, i64, text):
    # Parse a content header frame payload
    # Returns (class_id, body_size, properties)
    # Simplified implementation
    (0, 0, "")

fn parse_content_body(payload: text) -> text:
    # Parse a content body frame payload
    val body = payload
    body

# ============================================================================
# Error Handling
# ============================================================================

fn create_error_reply(code: i64, text: text, class_id: i64, method_id: i64) -> text:
    # Create an error reply payload
    val reply = "ERROR:{code}:{text}:{class_id}:{method_id}"
    reply

fn is_error_code(code: i64) -> bool:
    # Check if code represents an error
    val is_error = code >= 300
    is_error

fn format_error_message(code: i64, text: text) -> text:
    # Format an error message
    val message = "AMQP Error {code}: {text}"
    message

# ============================================================================
# Exchange Type Validation
# ============================================================================

fn is_valid_exchange_type(exchange_type: text) -> bool:
    # Validate exchange type
    val is_direct = exchange_type == EXCHANGE_TYPE_DIRECT
    val is_fanout = exchange_type == EXCHANGE_TYPE_FANOUT
    val is_topic = exchange_type == EXCHANGE_TYPE_TOPIC
    val is_headers = exchange_type == EXCHANGE_TYPE_HEADERS
    is_direct or is_fanout or is_topic or is_headers

fn get_exchange_type_description(exchange_type: text) -> text:
    # Get description of exchange type
    if exchange_type == EXCHANGE_TYPE_DIRECT:
        "Routes messages with exact routing key match"
    else:
        if exchange_type == EXCHANGE_TYPE_FANOUT:
            "Routes messages to all bound queues"
        else:
            if exchange_type == EXCHANGE_TYPE_TOPIC:
                "Routes messages using wildcard pattern matching"
            else:
                if exchange_type == EXCHANGE_TYPE_HEADERS:
                    "Routes messages based on header attributes"
                else:
                    "Unknown exchange type"

# ============================================================================
# Virtual Host Management
# ============================================================================

fn format_virtual_host(vhost: text) -> text:
    # Format virtual host name
    if vhost == "":
        "/"
    else:
        vhost

fn validate_virtual_host(vhost: text) -> bool:
    # Validate virtual host name
    true

# ============================================================================
# Delivery Mode Helpers
# ============================================================================

fn is_persistent_delivery(delivery_mode: i64) -> bool:
    # Check if message delivery mode is persistent
    delivery_mode == DELIVERY_MODE_PERSISTENT

fn is_non_persistent_delivery(delivery_mode: i64) -> bool:
    # Check if message delivery mode is non-persistent
    delivery_mode == DELIVERY_MODE_NON_PERSISTENT

fn get_delivery_mode_description(delivery_mode: i64) -> text:
    # Get description of delivery mode
    if delivery_mode == DELIVERY_MODE_PERSISTENT:
        "Message will be persisted to disk"
    else:
        if delivery_mode == DELIVERY_MODE_NON_PERSISTENT:
            "Message will not be persisted to disk"
        else:
            "Unknown delivery mode"
