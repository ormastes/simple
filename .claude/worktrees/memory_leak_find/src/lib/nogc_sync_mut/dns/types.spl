# DNS Protocol Type Definitions and Constants

# DNS Record Type Codes
val DNS_TYPE_A = 1
val DNS_TYPE_NS = 2
val DNS_TYPE_CNAME = 5
val DNS_TYPE_SOA = 6
val DNS_TYPE_PTR = 12
val DNS_TYPE_MX = 15
val DNS_TYPE_TXT = 16
val DNS_TYPE_AAAA = 28
val DNS_TYPE_SRV = 33

# DNS Class Codes
val DNS_CLASS_IN = 1      # Internet
val DNS_CLASS_CH = 3      # Chaos
val DNS_CLASS_HS = 4      # Hesiod

# DNS Response Codes
val DNS_RCODE_NOERROR = 0   # No error
val DNS_RCODE_FORMERR = 1   # Format error
val DNS_RCODE_SERVFAIL = 2  # Server failure
val DNS_RCODE_NXDOMAIN = 3  # Non-existent domain
val DNS_RCODE_NOTIMP = 4    # Not implemented
val DNS_RCODE_REFUSED = 5   # Query refused

# DNS Header Flags
val DNS_FLAG_QR_QUERY = 0
val DNS_FLAG_QR_RESPONSE = 1
val DNS_FLAG_OPCODE_QUERY = 0
val DNS_FLAG_OPCODE_IQUERY = 1
val DNS_FLAG_OPCODE_STATUS = 2

# DNS Message Structure
# Message: (header, questions, answers, authority, additional)
# Header: (id, flags, qd_count, an_count, ns_count, ar_count)
# Flags: (qr, opcode, aa, tc, rd, ra, rcode)
# Question: (name, qtype, qclass)
# ResourceRecord: (name, rtype, rclass, ttl, data)

fn dns_create_header(id: i64, qr: i64, opcode: i64, aa: i64, tc: i64, rd: i64, ra: i64, rcode: i64, qd_count: i64, an_count: i64, ns_count: i64, ar_count: i64):
    # Create DNS header tuple
    # Returns: (id, flags, qd_count, an_count, ns_count, ar_count)
    val flags = dns_encode_flags(qr, opcode, aa, tc, rd, ra, rcode)
    (id, flags, qd_count, an_count, ns_count, ar_count)

fn dns_create_question(name: text, qtype: i64, qclass: i64):
    # Create DNS question tuple
    # Returns: (name, qtype, qclass)
    (name, qtype, qclass)

fn dns_create_rr(name: text, rtype: i64, rclass: i64, ttl: i64, data: text):
    # Create DNS resource record tuple
    # Returns: (name, rtype, rclass, ttl, data)
    (name, rtype, rclass, ttl, data)

fn dns_create_message(header, questions, answers, authority, additional):
    # Create DNS message tuple
    # Returns: (header, questions, answers, authority, additional)
    (header, questions, answers, authority, additional)

fn dns_encode_flags(qr: i64, opcode: i64, aa: i64, tc: i64, rd: i64, ra: i64, rcode: i64) -> i64:
    # Encode DNS header flags into 16-bit value
    # QR(1) | Opcode(4) | AA(1) | TC(1) | RD(1) | RA(1) | Z(3) | RCODE(4)
    var result = 0
    result = result + (qr * 32768)      # Bit 15
    result = result + (opcode * 2048)   # Bits 11-14
    result = result + (aa * 1024)       # Bit 10
    result = result + (tc * 512)        # Bit 9
    result = result + (rd * 256)        # Bit 8
    result = result + (ra * 128)        # Bit 7
    result = result + rcode             # Bits 0-3
    result

fn dns_decode_flags(flags: i64):
    # Decode DNS header flags from 16-bit value
    # Returns: (qr, opcode, aa, tc, rd, ra, rcode)
    val qr = (flags / 32768) % 2
    val opcode = (flags / 2048) % 16
    val aa = (flags / 1024) % 2
    val tc = (flags / 512) % 2
    val rd = (flags / 256) % 2
    val ra = (flags / 128) % 2
    val rcode = flags % 16
    (qr, opcode, aa, tc, rd, ra, rcode)
