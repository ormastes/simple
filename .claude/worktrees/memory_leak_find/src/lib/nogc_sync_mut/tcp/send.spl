# TCP Send Operations
#
# Functions for sending data over TCP connections

import "types" as Types

# Send data (add to send buffer)
fn tcp_send(conn: (text, i64, i64, text, text, list, i64), data: text) -> (text, i64, i64, text, text, list, i64):
    val state = Types.tcp_connection_get_state(conn)
    val can_send = Types.tcp_state_can_send(state)
    if can_send:
        val current_buf = Types.tcp_connection_get_send_buffer(conn)
        val new_buf = current_buf + data
        Types.tcp_connection_set_send_buffer(conn, new_buf)
    else:
        conn

# Flush send buffer
fn tcp_flush_send_buffer(conn: (text, i64, i64, text, text, list, i64)) -> (text, i64, i64, text, text, list, i64):
    val empty = ""
    Types.tcp_connection_set_send_buffer(conn, empty)

# Get send buffer size
fn tcp_get_send_buffer_size(conn: (text, i64, i64, text, text, list, i64)) -> i64:
    val buffer = Types.tcp_connection_get_send_buffer(conn)
    buffer.len()

# Check if send buffer is empty
fn tcp_send_buffer_is_empty(conn: (text, i64, i64, text, text, list, i64)) -> bool:
    val size = tcp_get_send_buffer_size(conn)
    size == 0

# Check if connection is writable
fn tcp_connection_is_writable(conn: (text, i64, i64, text, text, list, i64)) -> bool:
    val state = Types.tcp_connection_get_state(conn)
    val can_send = Types.tcp_state_can_send(state)
    if can_send:
        val buf_size = tcp_get_send_buffer_size(conn)
        buf_size < Types.TCP_MAX_BUFFER_SIZE
    else:
        false

export tcp_send
export tcp_flush_send_buffer
export tcp_get_send_buffer_size
export tcp_send_buffer_is_empty
export tcp_connection_is_writable
