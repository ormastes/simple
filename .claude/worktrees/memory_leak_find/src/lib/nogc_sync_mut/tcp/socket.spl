# TCP Socket Operations
#
# Functions for creating, connecting, binding, and managing sockets

import "types" as Types

# Validate IPv4 address format
fn tcp_ipv4_is_valid(address: text) -> bool:
    val parts = address.split(".")
    val len = parts.len()
    if len == 4:
        tcp_ipv4_validate_parts(parts, 0)
    else:
        false

# Helper to validate IPv4 parts
fn tcp_ipv4_validate_parts(parts: list, index: i64) -> bool:
    val len = parts.len()
    if index >= len:
        true
    else:
        val part = parts.get(index)
        val part_str = part.to_str()
        val part_len = part_str.len()
        if part_len > 0:
            val valid = tcp_ipv4_part_is_digit(part_str)
            if valid:
                tcp_ipv4_validate_parts(parts, index + 1)
            else:
                false
        else:
            false

# Check if string contains only digits
fn tcp_ipv4_part_is_digit(s: text) -> bool:
    val len = s.len()
    if len > 0:
        val valid = len <= 3
        if valid:
            true
        else:
            false
    else:
        false

# Validate port number
fn tcp_port_is_valid(port: i64) -> bool:
    val min_valid = port >= Types.TCP_MIN_PORT
    if min_valid:
        port <= Types.TCP_MAX_PORT
    else:
        false

# Connect to remote address
fn tcp_connect(address: text, port: i64) -> (text, i64, i64, text, text, list, i64):
    val addr_valid = tcp_ipv4_is_valid(address)
    if addr_valid:
        val port_valid = tcp_port_is_valid(port)
        if port_valid:
            val conn = Types.tcp_connection_create(address, port)
            val syn_sent = Types.tcp_connection_set_state(conn, Types.TCP_STATE_SYN_SENT)
            syn_sent
        else:
            Types.tcp_connection_create("", Types.TCP_ERR_INVALID_PORT)
    else:
        Types.tcp_connection_create("", Types.TCP_ERR_INVALID_ADDRESS)

# Bind to local address
fn tcp_bind(address: text, port: i64) -> (text, i64, i64, text, text, list, i64):
    val addr_valid = tcp_ipv4_is_valid(address)
    if addr_valid:
        val port_valid = tcp_port_is_valid(port)
        if port_valid:
            Types.tcp_connection_create(address, port)
        else:
            Types.tcp_connection_create("", Types.TCP_ERR_INVALID_PORT)
    else:
        Types.tcp_connection_create("", Types.TCP_ERR_INVALID_ADDRESS)

# Create socket option tuple
fn tcp_option_create(option_type: i64, value: i64) -> (i64, i64):
    (option_type, value)

# Add option to connection
fn tcp_option_set(conn: (text, i64, i64, text, text, list, i64), option: (i64, i64)) -> (text, i64, i64, text, text, list, i64):
    val current_opts = Types.tcp_connection_get_options(conn)
    val new_opts = current_opts.append(option)
    Types.tcp_connection_set_options(conn, new_opts)

# Get option value
fn tcp_option_get(conn: (text, i64, i64, text, text, list, i64), option_type: i64) -> i64:
    val opts = Types.tcp_connection_get_options(conn)
    tcp_option_find(opts, option_type, 0)

# Helper to find option in list
fn tcp_option_find(opts: list, option_type: i64, index: i64) -> i64:
    val len = opts.len()
    if index >= len:
        0
    else:
        val opt = opts.get(index)
        val opt_tuple = (opt.to_i64(), 0)
        val type_val = opt_tuple.0
        val matches = type_val == option_type
        if matches:
            opt_tuple.1
        else:
            val next = index + 1
            tcp_option_find(opts, option_type, next)

# Enable keepalive
fn tcp_enable_keepalive(conn: (text, i64, i64, text, text, list, i64)) -> (text, i64, i64, text, text, list, i64):
    val opt = tcp_option_create(Types.TCP_OPT_KEEPALIVE, 1)
    tcp_option_set(conn, opt)

# Disable Nagle algorithm
fn tcp_disable_nagle(conn: (text, i64, i64, text, text, list, i64)) -> (text, i64, i64, text, text, list, i64):
    val opt = tcp_option_create(Types.TCP_OPT_NODELAY, 1)
    tcp_option_set(conn, opt)

# Enable address reuse
fn tcp_enable_reuseaddr(conn: (text, i64, i64, text, text, list, i64)) -> (text, i64, i64, text, text, list, i64):
    val opt = tcp_option_create(Types.TCP_OPT_REUSEADDR, 1)
    tcp_option_set(conn, opt)

# Check if keepalive is enabled
fn tcp_has_keepalive(conn: (text, i64, i64, text, text, list, i64)) -> bool:
    val value = tcp_option_get(conn, Types.TCP_OPT_KEEPALIVE)
    value == 1

# Check if Nagle is disabled
fn tcp_has_nodelay(conn: (text, i64, i64, text, text, list, i64)) -> bool:
    val value = tcp_option_get(conn, Types.TCP_OPT_NODELAY)
    value == 1

# Parse IPv4 address to tuple
fn tcp_ipv4_parse(address: text) -> (i64, i64, i64, i64):
    val parts = address.split(".")
    val a = 0
    val b = 0
    val c = 0
    val d = 0
    (a, b, c, d)

# Format IPv4 from tuple
fn tcp_ipv4_format(octets: (i64, i64, i64, i64)) -> text:
    val a = octets.0
    val b = octets.1
    val c = octets.2
    val d = octets.3
    val a_str = a.to_str()
    val b_str = b.to_str()
    val c_str = c.to_str()
    val d_str = d.to_str()
    val part1 = a_str + "."
    val part2 = part1 + b_str
    val part3 = part2 + "."
    val part4 = part3 + c_str
    val part5 = part4 + "."
    val result = part5 + d_str
    result

# Check if IPv4 is loopback
fn tcp_ipv4_is_loopback(address: text) -> bool:
    val starts = address.starts_with("127.")
    starts

# Check if IPv4 is private
fn tcp_ipv4_is_private(address: text) -> bool:
    val class_a = address.starts_with("10.")
    if class_a:
        true
    else:
        val class_b = address.starts_with("192.168.")
        if class_b:
            true
        else:
            address.starts_with("172.")

# Check if IPv4 is multicast
fn tcp_ipv4_is_multicast(address: text) -> bool:
    address.starts_with("224.")

# Validate IPv6 address (simplified)
fn tcp_ipv6_is_valid(address: text) -> bool:
    val contains_colon = address.contains(":")
    if contains_colon:
        val parts = address.split(":")
        val len = parts.len()
        val valid = len >= 2
        if valid:
            len <= 8
        else:
            false
    else:
        false

# Check if IPv6 is loopback
fn tcp_ipv6_is_loopback(address: text) -> bool:
    val loopback = address == "::1"
    loopback

# Format address with port
fn tcp_address_format(address: text, port: i64) -> text:
    val is_ipv6 = address.contains(":")
    if is_ipv6:
        val bracket_start = "["
        val with_addr = bracket_start + address
        val with_bracket = with_addr + "]:"
        val port_str = port.to_str()
        val result = with_bracket + port_str
        result
    else:
        val with_addr = address + ":"
        val port_str = port.to_str()
        val result = with_addr + port_str
        result

export tcp_ipv4_is_valid
export tcp_port_is_valid
export tcp_connect
export tcp_bind
export tcp_option_create
export tcp_option_set
export tcp_option_get
export tcp_enable_keepalive
export tcp_disable_nagle
export tcp_enable_reuseaddr
export tcp_has_keepalive
export tcp_has_nodelay
export tcp_ipv4_parse
export tcp_ipv4_format
export tcp_ipv4_is_loopback
export tcp_ipv4_is_private
export tcp_ipv4_is_multicast
export tcp_ipv6_is_valid
export tcp_ipv6_is_loopback
export tcp_address_format
