# WebSocket Connection Module
# Handles close frames, status codes, and connection management

from std.websocket.types import OPCODE_CLOSE
from std.websocket.types import CLOSE_NORMAL
from std.websocket.types import CLOSE_GOING_AWAY
from std.websocket.types import CLOSE_PROTOCOL_ERROR
from std.websocket.types import CLOSE_UNSUPPORTED_DATA
from std.websocket.types import CLOSE_NO_STATUS
from std.websocket.types import CLOSE_ABNORMAL
from std.websocket.types import CLOSE_INVALID_PAYLOAD
from std.websocket.types import CLOSE_POLICY_VIOLATION
from std.websocket.types import CLOSE_MESSAGE_TOO_BIG
from std.websocket.types import CLOSE_MANDATORY_EXTENSION
from std.websocket.types import CLOSE_INTERNAL_ERROR
from std.websocket.frame import create_frame
from std.websocket.frame import generate_masking_key
from std.websocket.handshake import text_to_bytes
from std.websocket.handshake import bytes_to_text

# ==============================================================================
# Close Frame Creation
# ==============================================================================

fn create_close_frame(status_code: i64, reason: text, is_masked: i64) -> List<i64>:
    val payload = []
    val b1 = (status_code >> 8) & 0xFF
    val b2 = status_code & 0xFF
    payload.push(b1)
    payload.push(b2)

    val reason_bytes = text_to_bytes(reason)
    val len = reason_bytes.length()
    var i = 0
    while i < len:
        payload.push(reason_bytes.at(i))
        i = i + 1

    val mask_key = if is_masked == 1: generate_masking_key() else: []
    create_frame(1, OPCODE_CLOSE, is_masked, payload, mask_key)

fn create_empty_close_frame(is_masked: i64) -> List<i64>:
    val payload = []
    val mask_key = if is_masked == 1: generate_masking_key() else: []
    create_frame(1, OPCODE_CLOSE, is_masked, payload, mask_key)

fn create_close_with_status(status_code: i64, is_masked: i64) -> List<i64>:
    create_close_frame(status_code, "", is_masked)

# ==============================================================================
# Close Frame Parsing
# ==============================================================================

fn extract_close_status(payload: List<i64>) -> i64:
    if payload.length() < 2:
        return CLOSE_NO_STATUS

    val b1 = payload.at(0)
    val b2 = payload.at(1)
    (b1 << 8) | b2

fn extract_close_reason(payload: List<i64>) -> text:
    if payload.length() <= 2:
        return ""

    val reason_bytes = []
    val len = payload.length()
    var i = 2

    while i < len:
        reason_bytes.push(payload.at(i))
        i = i + 1

    bytes_to_text(reason_bytes)

# ==============================================================================
# Close Status Code Functions
# ==============================================================================

fn close_status_name(code: i64) -> text:
    if code == CLOSE_NORMAL:
        "Normal Closure"
    else:
        if code == CLOSE_GOING_AWAY:
            "Going Away"
        else:
            if code == CLOSE_PROTOCOL_ERROR:
                "Protocol Error"
            else:
                if code == CLOSE_UNSUPPORTED_DATA:
                    "Unsupported Data"
                else:
                    if code == CLOSE_NO_STATUS:
                        "No Status"
                    else:
                        if code == CLOSE_ABNORMAL:
                            "Abnormal Closure"
                        else:
                            if code == CLOSE_INVALID_PAYLOAD:
                                "Invalid Payload"
                            else:
                                if code == CLOSE_POLICY_VIOLATION:
                                    "Policy Violation"
                                else:
                                    if code == CLOSE_MESSAGE_TOO_BIG:
                                        "Message Too Big"
                                    else:
                                        if code == CLOSE_MANDATORY_EXTENSION:
                                            "Mandatory Extension"
                                        else:
                                            if code == CLOSE_INTERNAL_ERROR:
                                                "Internal Error"
                                            else:
                                                "Unknown"

fn is_valid_close_status(code: i64) -> i64:
    if code >= 1000:
        if code <= 1011:
            1
        else:
            0
    else:
        0
