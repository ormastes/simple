# OAuth 2.0 Authorization Module
# Authorization flow and request building

import string
import array
import oauth.types
import oauth.utilities

# State Generation and Validation (CSRF Protection)
# ============================================================================

# Generate random state parameter for CSRF protection
# Returns a random 32-character string
fn generate_state() -> text:
    val chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
    var state = ""
    var i = 0
    while i < 32:
        val idx = random_int(0, string.length(chars) - 1)
        val char = string.char_at(chars, idx)
        state = string.concat(state, char)
        i = i + 1
    state

# Verify state parameter matches expected value
fn verify_state(state: text, expected: text) -> bool:
    string.equals(state, expected)

# Generate state with timestamp prefix (for expiry checking)
fn generate_state_with_timestamp() -> text:
    val timestamp = get_current_timestamp()
    val random_part = generate_state()
    val timestamp_str = i64_to_text(timestamp)
    string.concat(string.concat(timestamp_str, "_"), random_part)

# Verify state and check if not expired (within 10 minutes)
fn verify_state_with_expiry(state: text, expected: text, max_age_seconds: i64) -> bool:
    if not verify_state(state, expected):
        false
    else:
        # Extract timestamp from state
        val parts = text.split(state, "_")
        if array.length(parts) < 2:
            false
        else:
            val timestamp_str = array.get(parts, 0)
            val timestamp = text_to_i64(timestamp_str)
            val now = get_current_timestamp()
            val age = now - timestamp
            age <= max_age_seconds


# ============================================================================
# PKCE (Proof Key for Code Exchange) - RFC 7636
# ============================================================================

# Generate code verifier (43-128 characters, URL-safe)
fn generate_code_verifier() -> text:
    val chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~"
    var verifier = ""
    var i = 0
    val length = 128  # Maximum length for better security
    while i < length:
        val idx = random_int(0, string.length(chars) - 1)
        val char = string.char_at(chars, idx)
        verifier = string.concat(verifier, char)
        i = i + 1
    verifier

# Generate code challenge from verifier using S256 method
# Challenge = BASE64URL(SHA256(verifier))
fn generate_code_challenge(verifier: text) -> text:
    # Simple implementation: use hash of verifier
    # In production, use proper SHA-256 and BASE64URL encoding
    val hashed = hash_sha256(verifier)
    base64url_encode(hashed)

# Verify code challenge matches verifier
fn verify_code_challenge(verifier: text, challenge: text) -> bool:
    val computed = generate_code_challenge(verifier)
    string.equals(computed, challenge)

# Get PKCE method (always S256 for security)
fn get_pkce_method() -> text:
    "S256"

# ============================================================================

# Authorization Request Building
# ============================================================================

# Build authorization URL for OAuth 2.0 flow
fn build_auth_url(config, scopes, state: text) -> text:
    val base_url = get_config_auth_url(config)
    val client_id = get_config_client_id(config)
    val redirect_uri = get_config_redirect_uri(config)
    val scope_string = build_scope_string(scopes)

    var url = base_url
    url = string.concat(url, "?response_type=code")

    val client_param = string.concat("&client_id=", url_encode(client_id))
    url = string.concat(url, client_param)

    val redirect_param = string.concat("&redirect_uri=", url_encode(redirect_uri))
    url = string.concat(url, redirect_param)

    val scope_param = string.concat("&scope=", url_encode(scope_string))
    url = string.concat(url, scope_param)

    val state_param = string.concat("&state=", url_encode(state))
    url = string.concat(url, state_param)

    url

# Build authorization URL with PKCE
fn build_auth_url_with_pkce(config, scopes, state: text, code_challenge: text) -> text:
    val base_url = build_auth_url(config, scopes, state)

    val challenge_param = string.concat("&code_challenge=", url_encode(code_challenge))
    var url = string.concat(base_url, challenge_param)

    val method_param = string.concat("&code_challenge_method=", get_pkce_method())
    url = string.concat(url, method_param)

    url

# Build authorization URL with additional parameters
fn build_auth_url_with_params(config, scopes, state: text, extra_params):
    var url = build_auth_url(config, scopes, state)

    var i = 0
    while i < array.length(extra_params):
        val param = array.get(extra_params, i)
        val key = param.0
        val value = param.1

        val param_str = string.concat(string.concat("&", key), string.concat("=", url_encode(value)))
        url = string.concat(url, param_str)
        i = i + 1

    url

# ============================================================================
# Authorization Response Parsing
# ============================================================================

# Parse authorization callback URL
# Returns: (code, state, error, error_description)
fn parse_auth_response(callback_url: text):
    val params = parse_query_params(callback_url)

    val code = get_param_value(params, "code")
    val state = get_param_value(params, "state")
    val error = get_param_value(params, "error")
    val error_desc = get_param_value(params, "error_description")

    (code, state, error, error_desc)

# Get authorization code from response
fn get_auth_code(response):
    response.0

# Get state from response
fn get_response_state(response):
    response.1

# Get error from response
fn get_response_error(response):
    response.2

# Get error description from response
fn get_response_error_description(response):
    response.3

# Check if authorization response has error
fn has_auth_error(response) -> bool:
    val error = get_response_error(response)
    string.length(error) > 0

# ============================================================================
# Token Exchange (Authorization Code Flow)
# ============================================================================


# ============================================================================
# EXPORTS
# ============================================================================

export generate_state, verify_state, generate_state_with_timestamp, verify_state_with_expiry
export generate_code_verifier, generate_code_challenge, verify_code_challenge, get_pkce_method
export build_auth_url, build_auth_url_with_pkce, build_auth_url_with_params
export parse_auth_response, get_auth_code, get_response_state, get_response_error
export get_response_error_description, has_auth_error
