# STOMP Subscribe Module

# ============================================================================
# Subscription Management
# ============================================================================

# Generate unique subscription ID
fn generate_subscription_id(prefix: text, counter: i64) -> text:
    var result = prefix
    result = result + "-"
    result = result + counter.to_text()
    return result

# Get subscription ID from frame
fn get_subscription_id(frame: tuple):
    val headers = get_frame_headers(frame)
    return get_header_value(headers, stomp_header_subscription())

# Get destination from frame
fn get_destination(frame: tuple):
    val headers = get_frame_headers(frame)
    return get_header_value(headers, stomp_header_destination())

# Get message ID from frame
fn get_message_id(frame: tuple):
    val headers = get_frame_headers(frame)
    return get_header_value(headers, stomp_header_message_id())

# Get acknowledgment mode from frame
fn get_ack_mode(frame: tuple):
    val headers = get_frame_headers(frame)
    return get_header_value(headers, stomp_header_ack())

# Check if destination is a queue
fn is_queue_destination(destination: text) -> bool:
    return destination.starts_with("/queue/")

# Check if destination is a topic
fn is_topic_destination(destination: text) -> bool:
    return destination.starts_with("/topic/")

# Check if destination is temporary
fn is_temp_destination(destination: text) -> bool:
    return destination.starts_with("/temp-queue/") or destination.starts_with("/temp-topic/")

# Extract destination name (without prefix)
fn extract_destination_name(destination: text) -> text:
    if is_queue_destination(destination):
        return destination.substring(7, destination.len())

    if is_topic_destination(destination):
        return destination.substring(7, destination.len())

    if destination.starts_with("/temp-queue/"):
        return destination.substring(12, destination.len())

    if destination.starts_with("/temp-topic/"):
        return destination.substring(12, destination.len())

    return destination

# ============================================================================
# Content Type Handling
# ============================================================================

# Get content type from frame
fn get_content_type(frame: tuple):
    val headers = get_frame_headers(frame)
    return get_header_value(headers, stomp_header_content_type())

# Get content length from frame
fn get_content_length(frame: tuple):
    val headers = get_frame_headers(frame)
    val value = get_header_value(headers, stomp_header_content_length())

    if value == nil:
        return nil

    return value.to_int()

# Check if body is text
fn is_text_body(frame: tuple) -> bool:
    val content_type = get_content_type(frame)

    if content_type == nil:
        return true

    if content_type.starts_with("text/"):
        return true

    if content_type == "application/json":
        return true

    if content_type == "application/xml":
        return true

    return false

# Check if body is binary
fn is_binary_body(frame: tuple) -> bool:
    return not is_text_body(frame)


# Export all public functions
