# HTTP Client Type Definitions and Constants

val HTTP_VERSION = "HTTP/1.1"
val METHOD_GET = "GET"
val METHOD_POST = "POST"
val METHOD_PUT = "PUT"
val METHOD_DELETE = "DELETE"
val METHOD_PATCH = "PATCH"
val METHOD_HEAD = "HEAD"
val METHOD_OPTIONS = "OPTIONS"
val CONTENT_TYPE_JSON = "application/json"
val CONTENT_TYPE_FORM = "application/x-www-form-urlencoded"
val CONTENT_TYPE_MULTIPART = "multipart/form-data"
val CONTENT_TYPE_TEXT = "text/plain"
val CONTENT_TYPE_HTML = "text/html"
val CONTENT_TYPE_XML = "application/xml"
val CONTENT_TYPE_OCTET_STREAM = "application/octet-stream"
val STATUS_OK = 200
val STATUS_CREATED = 201
val STATUS_ACCEPTED = 202
val STATUS_NO_CONTENT = 204
val STATUS_MOVED_PERMANENTLY = 301
val STATUS_FOUND = 302
val STATUS_SEE_OTHER = 303
val STATUS_NOT_MODIFIED = 304
val STATUS_TEMPORARY_REDIRECT = 307
val STATUS_PERMANENT_REDIRECT = 308
val STATUS_BAD_REQUEST = 400
val STATUS_UNAUTHORIZED = 401
val STATUS_FORBIDDEN = 403
val STATUS_NOT_FOUND = 404
val STATUS_METHOD_NOT_ALLOWED = 405
val STATUS_CONFLICT = 409
val STATUS_INTERNAL_SERVER_ERROR = 500
val STATUS_NOT_IMPLEMENTED = 501
val STATUS_BAD_GATEWAY = 502
val STATUS_SERVICE_UNAVAILABLE = 503
val USER_AGENT_DEFAULT = "SimpleHTTP/1.0"
val ACCEPT_DEFAULT = "*/*"

fn url_encode(text: text) -> text:
    var result = ""
    var i = 0
    var len = text.length()
    while i < len:
        var ch = text.char_at(i)
        var code = text.char_code_at(i)
        var is_alpha = (code >= 65 and code <= 90) or (code >= 97 and code <= 122)
        var is_digit = code >= 48 and code <= 57
        var is_unreserved = is_alpha or is_digit or ch == "-" or ch == "_" or ch == "." or ch == "~"
        if is_unreserved:
            result = result + ch
        else:
            var hex = code.to_string(16).to_upper()
            if hex.length() == 1:
                hex = "0" + hex
            result = result + "%" + hex
        i = i + 1
    result

fn url_decode(text: text) -> text:
    var result = ""
    var i = 0
    var len = text.length()
    while i < len:
        var ch = text.char_at(i)
        if ch == "%":
            if i + 2 < len:
                var hex = text.substring(i + 1, i + 3)
                var code = hex.parse_int(16)
                result = result + code.to_char()
                i = i + 3
            else:
                result = result + ch
                i = i + 1
        else:
            if ch == "+":
                result = result + " "
            else:
                result = result + ch
            i = i + 1
    result

fn url_encode_component(component: text) -> text:
    url_encode(component)

fn url_decode_component(component: text) -> text:
    url_decode(component)

fn parse_url(url: text) -> (text, text, i64, text, text, text):
    var scheme = ""
    var host = ""
    var port = 80
    var path = "/"
    var query = ""
    var fragment = ""
    var remaining = url
    var scheme_end = remaining.index_of("://")
    if scheme_end >= 0:
        scheme = remaining.substring(0, scheme_end)
        remaining = remaining.substring(scheme_end + 3, remaining.length())
        if scheme == "https":
            port = 443
    else:
        scheme = "http"
    var fragment_start = remaining.index_of("#")
    if fragment_start >= 0:
        fragment = remaining.substring(fragment_start + 1, remaining.length())
        remaining = remaining.substring(0, fragment_start)
    var query_start = remaining.index_of("?")
    if query_start >= 0:
        query = remaining.substring(query_start + 1, remaining.length())
        remaining = remaining.substring(0, query_start)
    var path_start = remaining.index_of("/")
    if path_start >= 0:
        path = remaining.substring(path_start, remaining.length())
        remaining = remaining.substring(0, path_start)
    var port_start = remaining.index_of(":")
    if port_start >= 0:
        host = remaining.substring(0, port_start)
        var port_str = remaining.substring(port_start + 1, remaining.length())
        port = port_str.parse_int()
    else:
        host = remaining
    (scheme, host, port, path, query, fragment)

fn build_url(scheme: text, host: text, port: i64, path: text, query: text, fragment: text) -> text:
    var url = scheme + "://" + host
    var default_port = 80
    if scheme == "https":
        default_port = 443
    if port != default_port:
        url = url + ":" + port.to_string()
    url = url + path
    if query.length() > 0:
        url = url + "?" + query
    if fragment.length() > 0:
        url = url + "#" + fragment
    url

fn url_join(base: text, relative: text) -> text:
    if relative.starts_with("http://") or relative.starts_with("https://"):
        relative
    else:
        var parsed = parse_url(base)
        var scheme = parsed.0
        var host = parsed.1
        var port = parsed.2
        var base_path = parsed.3
        var new_path = relative
        if relative.starts_with("/"):
            new_path = relative
        else:
            var last_slash = base_path.last_index_of("/")
            if last_slash >= 0:
                var dir = base_path.substring(0, last_slash + 1)
                new_path = dir + relative
            else:
                new_path = "/" + relative
        build_url(scheme, host, port, new_path, "", "")

fn parse_query_string(query: text) -> list:
    var params = []
    if query.length() == 0:
        return params
    var pairs = query.split("&")
    var i = 0
    while i < pairs.length():
        var pair = pairs[i]
        var eq_pos = pair.index_of("=")
        if eq_pos >= 0:
            var key = pair.substring(0, eq_pos)
            var value = pair.substring(eq_pos + 1, pair.length())
            key = url_decode(key)
            value = url_decode(value)
            params.append((key, value))
        else:
            var key = url_decode(pair)
            params.append((key, ""))
        i = i + 1
    params

fn build_query_string(params: list) -> text:
    var result = ""
    var i = 0
    while i < params.length():
        var param = params[i]
        var key = param.0
        var value = param.1
        if i > 0:
            result = result + "&"
        result = result + url_encode(key)
        if value.length() > 0:
            result = result + "=" + url_encode(value)
        i = i + 1
    result

fn add_query_param(url: text, key: text, value: text) -> text:
    var parsed = parse_url(url)
    var scheme = parsed.0
    var host = parsed.1
    var port = parsed.2
    var path = parsed.3
    var query = parsed.4
    var fragment = parsed.5
    var params = parse_query_string(query)
    params.append((key, value))
    var new_query = build_query_string(params)
    build_url(scheme, host, port, path, new_query, fragment)

fn remove_query_param(url: text, key: text) -> text:
    var parsed = parse_url(url)
    var scheme = parsed.0
    var host = parsed.1
    var port = parsed.2
    var path = parsed.3
    var query = parsed.4
    var fragment = parsed.5
    var params = parse_query_string(query)
    var filtered = []
    var i = 0
    while i < params.length():
        var param = params[i]
        if param.0 != key:
            filtered.append(param)
        i = i + 1
    var new_query = build_query_string(filtered)
    build_url(scheme, host, port, path, new_query, fragment)
