# Memory Allocator Interface
#
# Pluggable memory allocation interface with multiple implementations.
# Provides foundation for custom memory management strategies.
#
# Allocators:
# - SystemAllocator: Wrapper around system malloc/free
# - ArenaAllocator: Bump allocator (fast, reset all at once)
# - PoolAllocator: Fixed-size object pool (very fast, no fragmentation)
# - SlabAllocator: Multiple size classes (general purpose)
#
# Usage:
#   val allocator = ArenaAllocator.new(capacity: 1024 * 1024)
#   val ptr = allocator.allocate(size: 128, align: 8)
#   // Use memory...
#   allocator.deallocate(ptr, size: 128, align: 8)
#
# Architecture:
# - Allocator trait: Common interface
# - Multiple implementations with different trade-offs
# - Thread-local allocators for performance
# - Integration with GC (Week 7-10)

use std.atomic.*

# ============================================================================
# Allocator Trait
# ============================================================================

trait Allocator:
    """Memory allocator interface.

    All allocators must implement these methods.
    Implementations can use different strategies (bump, pool, slab, etc.)
    """

    fn allocate(size: usize, align: usize) -> [u8]?:
        """Allocate memory with specified size and alignment.

        Args:
            size: Number of bytes to allocate
            align: Alignment requirement (must be power of 2)

        Returns:
            Some(ptr) - Pointer to allocated memory (aligned)
            nil - Allocation failed (out of memory)

        Safety:
            - Returned pointer is valid until deallocate() called
            - Returned pointer is aligned to 'align' bytes
            - Memory is uninitialized
        """

    fn deallocate(ptr: [u8], size: usize, align: usize):
        """Deallocate previously allocated memory.

        Args:
            ptr: Pointer returned by allocate()
            size: Same size passed to allocate()
            align: Same alignment passed to allocate()

        Safety:
            - ptr must have been returned by allocate()
            - size and align must match original allocation
            - Double-free is undefined behavior
        """

    fn reallocate(ptr: [u8], old_size: usize, new_size: usize, align: usize) -> [u8]?:
        """Reallocate memory to new size.

        Args:
            ptr: Pointer returned by allocate()
            old_size: Original size
            new_size: New size
            align: Alignment

        Returns:
            Some(new_ptr) - Pointer to reallocated memory
            nil - Reallocation failed

        Default implementation: allocate new, copy, deallocate old
        """

    fn total_allocated() -> usize:
        """Get total bytes currently allocated.

        Returns:
            Total allocated bytes

        Note: Not all allocators track this (may return 0)
        """

# ============================================================================
# SystemAllocator - System malloc/free Wrapper
# ============================================================================

class SystemAllocator:
    """System allocator using malloc/free.

    Wraps system allocator (libc malloc/free).
    Simple, no overhead, but no custom features.

    Characteristics:
    - Thread-safe (system allocator handles synchronization)
    - No memory tracking
    - Full OS memory available
    - Standard allocation performance

    Example:
        val allocator = SystemAllocator.new()
        val ptr = allocator.allocate(1024, 8)
        // Use memory...
        allocator.deallocate(ptr, 1024, 8)
    """
    _marker: i32  # Zero-sized type (no fields needed)

    static fn new() -> SystemAllocator:
        """Create system allocator instance."""
        SystemAllocator(_marker: 0)

impl Allocator for SystemAllocator:
    fn allocate(size: usize, align: usize) -> [u8]?:
        """Allocate via system malloc."""
        val ptr = sys_malloc(size, align)
        if ptr_is_null(ptr):
            nil
        else:
            Some(ptr)

    fn deallocate(ptr: [u8], size: usize, align: usize):
        """Deallocate via system free."""
        sys_free(ptr, size, align)

    fn reallocate(ptr: [u8], old_size: usize, new_size: usize, align: usize) -> [u8]?:
        """Reallocate via system realloc."""
        val new_ptr = sys_realloc(ptr, old_size, new_size, align)
        if ptr_is_null(new_ptr):
            nil
        else:
            Some(new_ptr)

    fn total_allocated() -> usize:
        """System allocator doesn't track allocations."""
        0

# ============================================================================
# ArenaAllocator - Bump Allocator
# ============================================================================

class ArenaAllocator:
    """Bump allocator (arena allocator).

    Allocates by bumping a pointer. Very fast O(1) allocation.
    No individual deallocation - reset entire arena at once.

    Characteristics:
    - Very fast allocation (just bump pointer)
    - No deallocation overhead
    - No fragmentation
    - Bulk deallocation (reset)
    - Fixed capacity

    Use cases:
    - Temporary allocations (request handling)
    - Phase-based allocation (compile pass)
    - Batch processing

    Example:
        val arena = ArenaAllocator.new(capacity: 1024 * 1024)  // 1 MB

        // Fast allocations
        val obj1 = arena.allocate(128, 8)
        val obj2 = arena.allocate(256, 16)

        // Use objects...

        // Bulk deallocate everything
        arena.reset()
    """
    buffer: [u8]       # Pre-allocated memory block
    capacity: usize    # Total capacity
    offset: usize      # Current allocation offset
    allocated: usize   # Total bytes allocated

    static fn new(capacity: usize) -> ArenaAllocator:
        """Create arena allocator with fixed capacity.

        Args:
            capacity: Size of arena in bytes

        Returns:
            Arena allocator

        Note: Allocates arena buffer from system allocator
        """
        val buffer = sys_malloc(capacity, 8)
        ArenaAllocator(
            buffer: buffer,
            capacity: capacity,
            offset: 0,
            allocated: 0
        )

    me reset():
        """Reset arena to initial state.

        Deallocates all objects at once by resetting offset.
        Very fast O(1) operation.
        """
        self.offset = 0
        self.allocated = 0

    fn remaining() -> usize:
        """Get remaining capacity.

        Returns:
            Bytes available for allocation
        """
        self.capacity - self.offset

    fn is_full() -> bool:
        """Check if arena is full.

        Returns:
            true if no space left
        """
        self.offset >= self.capacity

impl Allocator for ArenaAllocator:
    me allocate(size: usize, align: usize) -> [u8]?:
        """Allocate by bumping offset.

        Args:
            size: Bytes to allocate
            align: Alignment (power of 2)

        Returns:
            Some(ptr) - Aligned pointer
            nil - Arena full
        """
        # Align current offset
        val aligned_offset = align_up(self.offset, align)

        # Check if allocation fits
        val end_offset = aligned_offset + size
        if end_offset > self.capacity:
            return nil  # Arena full

        # Allocate by bumping offset
        val ptr = buffer_offset(self.buffer, aligned_offset)
        self.offset = end_offset
        self.allocated = self.allocated + size

        Some(ptr)

    fn deallocate(ptr: [u8], size: usize, align: usize):
        """No-op for arena allocator.

        Arena doesn't support individual deallocation.
        Use reset() to deallocate everything.
        """
        # No-op - use reset() instead

    fn reallocate(ptr: [u8], old_size: usize, new_size: usize, align: usize) -> [u8]?:
        """Reallocate by allocating new and copying.

        Note: Old memory is leaked until reset()
        """
        val new_ptr = self.allocate(new_size, align)?
        memory_copy(new_ptr, ptr, old_size)
        Some(new_ptr)

    fn total_allocated() -> usize:
        """Get total allocated bytes."""
        self.allocated

# ============================================================================
# PoolAllocator - Fixed-Size Object Pool
# ============================================================================

class PoolAllocator:
    """Fixed-size object pool.

    Pre-allocates fixed-size objects. Very fast allocation/deallocation.
    Perfect for objects of same size (AST nodes, tokens, etc.)

    Characteristics:
    - O(1) allocation and deallocation
    - No fragmentation
    - Fixed object size
    - Memory reuse
    - Free list management

    Use cases:
    - AST nodes (all same size)
    - Token objects
    - Event objects
    - Small uniform allocations

    Example:
        # Pool of 1000 objects, 64 bytes each
        val pool = PoolAllocator.new(object_size: 64, capacity: 1000)

        val obj1 = pool.allocate(64, 8)  // Fast - from free list
        val obj2 = pool.allocate(64, 8)  // Fast

        pool.deallocate(obj1, 64, 8)     // Return to free list
        val obj3 = pool.allocate(64, 8)  // Reuses obj1's slot
    """
    buffer: [u8]       # Pre-allocated memory block
    object_size: usize # Size of each object (fixed)
    capacity: usize    # Max number of objects
    free_list: [u8]?   # Head of free list (linked via first ptr in object)
    allocated_count: usize  # Number of objects currently allocated

    static fn new(object_size: usize, capacity: usize) -> PoolAllocator:
        """Create object pool.

        Args:
            object_size: Size of each object (must be >= pointer size)
            capacity: Maximum number of objects

        Returns:
            Pool allocator
        """
        val total_size = object_size * capacity
        val buffer = sys_malloc(total_size, 8)

        # Initialize free list (link all objects)
        var free_list: [u8]? = nil
        for i in 0..capacity:
            val obj_ptr = buffer_offset(buffer, i * object_size)
            # Link to previous head
            ptr_write(obj_ptr, free_list)
            free_list = Some(obj_ptr)

        PoolAllocator(
            buffer: buffer,
            object_size: object_size,
            capacity: capacity,
            free_list: free_list,
            allocated_count: 0
        )

    fn available() -> usize:
        """Get number of available objects.

        Returns:
            Objects available for allocation
        """
        self.capacity - self.allocated_count

    fn is_full() -> bool:
        """Check if pool is full."""
        self.allocated_count >= self.capacity

impl Allocator for PoolAllocator:
    me allocate(size: usize, align: usize) -> [u8]?:
        """Allocate from free list.

        Args:
            size: Must equal object_size
            align: Ignored (objects are pre-aligned)

        Returns:
            Some(ptr) - Object from pool
            nil - Pool full

        Safety: size must equal object_size
        """
        # Verify size matches
        if size != self.object_size:
            return nil  # Wrong size

        # Pop from free list
        match self.free_list:
            case nil:
                nil  # Pool exhausted
            case Some(ptr):
                # Read next pointer from object
                val next = ptr_read(ptr)
                self.free_list = next
                self.allocated_count = self.allocated_count + 1
                Some(ptr)

    me deallocate(ptr: [u8], size: usize, align: usize):
        """Return object to free list.

        Args:
            ptr: Object to return
            size: Must equal object_size
            align: Ignored
        """
        # Verify size
        if size != self.object_size:
            return  # Invalid size, skip

        # Push to free list
        ptr_write(ptr, self.free_list)
        self.free_list = Some(ptr)
        self.allocated_count = self.allocated_count - 1

    fn reallocate(ptr: [u8], old_size: usize, new_size: usize, align: usize) -> [u8]?:
        """Pool doesn't support reallocation."""
        nil  # Not supported

    fn total_allocated() -> usize:
        """Get total allocated bytes."""
        self.allocated_count * self.object_size

# ============================================================================
# SlabAllocator - Multiple Size Classes
# ============================================================================

class SlabAllocator:
    """Slab allocator with multiple size classes.

    Pre-allocates pools for common sizes. Routes allocations to appropriate pool.
    Good general-purpose allocator with low fragmentation.

    Size classes: 16, 32, 64, 128, 256, 512, 1024, 2048 bytes
    Larger allocations fall back to system allocator.

    Characteristics:
    - Fast allocation for common sizes
    - Low fragmentation
    - Memory reuse
    - Automatic size class selection

    Use cases:
    - General-purpose allocation
    - Mixed-size objects
    - Replacement for system allocator

    Example:
        val slab = SlabAllocator.new()

        val small = slab.allocate(32, 8)   // From 32-byte pool
        val medium = slab.allocate(128, 8) // From 128-byte pool
        val large = slab.allocate(5000, 8) // From system allocator
    """
    pools: [PoolAllocator]  # Pools for each size class
    size_classes: [usize]   # Size class boundaries
    system: SystemAllocator # Fallback for large allocations

    static fn new() -> SlabAllocator:
        """Create slab allocator with default size classes."""
        val size_classes = [16, 32, 64, 128, 256, 512, 1024, 2048]
        var pools: [PoolAllocator] = []

        # Create pool for each size class
        for size in size_classes:
            val pool = PoolAllocator.new(
                object_size: size,
                capacity: 128  # 128 objects per pool
            )
            pools = pools.push(pool)

        SlabAllocator(
            pools: pools,
            size_classes: size_classes,
            system: SystemAllocator.new()
        )

    fn find_size_class(size: usize) -> i32:
        """Find appropriate size class for allocation.

        Args:
            size: Requested size

        Returns:
            Index of size class, or -1 if too large
        """
        for i in 0..self.size_classes.len():
            if size <= self.size_classes[i]:
                return i as i32
        -1  # Too large for pools

impl Allocator for SlabAllocator:
    me allocate(size: usize, align: usize) -> [u8]?:
        """Allocate from appropriate size class.

        Args:
            size: Bytes to allocate
            align: Alignment

        Returns:
            Some(ptr) - Allocated memory
            nil - Allocation failed
        """
        val class_idx = self.find_size_class(size)

        if class_idx >= 0:
            # Allocate from pool
            val pool = self.pools[class_idx]
            pool.allocate(self.size_classes[class_idx], align)
        else:
            # Too large - use system allocator
            self.system.allocate(size, align)

    me deallocate(ptr: [u8], size: usize, align: usize):
        """Deallocate to appropriate size class."""
        val class_idx = self.find_size_class(size)

        if class_idx >= 0:
            # Return to pool
            val pool = self.pools[class_idx]
            pool.deallocate(ptr, self.size_classes[class_idx], align)
        else:
            # Large allocation - free via system
            self.system.deallocate(ptr, size, align)

    me reallocate(ptr: [u8], old_size: usize, new_size: usize, align: usize) -> [u8]?:
        """Reallocate (may change size class)."""
        val old_class = self.find_size_class(old_size)
        val new_class = self.find_size_class(new_size)

        if old_class == new_class and old_class >= 0:
            # Same size class - no reallocation needed
            Some(ptr)
        else:
            # Different size class or large - allocate, copy, free
            val new_ptr = self.allocate(new_size, align)?
            memory_copy(new_ptr, ptr, old_size)
            self.deallocate(ptr, old_size, align)
            Some(new_ptr)

    fn total_allocated() -> usize:
        """Get total allocated across all pools."""
        var total: usize = 0
        for pool in self.pools:
            total = total + pool.total_allocated()
        total

# ============================================================================
# Mock Implementations (For Interpreter Testing)
# ============================================================================
# These mock implementations allow allocator tests to run in the interpreter.
# When compiled, the real extern functions below will be used instead.

# Mock allocator using Simple arrays
fn sys_malloc(size: usize, align: usize) -> [u8]:
    """Mock malloc: allocate array of given size."""
    if size == 0:
        []
    else:
        [0u8; size]

fn sys_free(ptr: [u8], size: usize, align: usize):
    """Mock free: no-op (garbage collector handles it)."""
    ()

fn sys_realloc(ptr: [u8], old_size: usize, new_size: usize, align: usize) -> [u8]:
    """Mock realloc: allocate new array and copy data."""
    if new_size == 0:
        []
    else:
        val new_ptr = [0u8; new_size]
        # Copy old data to new array (up to min of old/new size)
        val copy_size = if old_size < new_size: old_size else: new_size
        for i in 0..copy_size:
            new_ptr[i] = ptr[i]
        new_ptr

# Pointer utilities
fn ptr_is_null(ptr: [u8]) -> bool:
    """Mock ptr_is_null: check if array is empty."""
    ptr.len() == 0

fn ptr_write(ptr: [u8], value: [u8]?):
    """Mock ptr_write: no-op (not needed for basic tests)."""
    ()

fn ptr_read(ptr: [u8]) -> [u8]?:
    """Mock ptr_read: return the array itself."""
    if ptr.len() > 0:
        Some(ptr)
    else:
        nil

fn buffer_offset(buffer: [u8], offset: usize) -> [u8]:
    """Mock buffer_offset: return slice of buffer from offset."""
    if offset >= buffer.len():
        []
    else:
        buffer[offset:]

fn memory_copy(dest: [u8], src: [u8], size: usize):
    """Mock memory_copy: copy bytes from src to dest."""
    val copy_size = if size > src.len(): src.len() else: size
    for i in 0..copy_size:
        if i < dest.len():
            dest[i] = src[i]

# Alignment utilities
fn align_up(value: usize, align: usize) -> usize:
    """Mock align_up: round value up to alignment boundary."""
    if align == 0 or align == 1:
        value
    else:
        val remainder = value % align
        if remainder == 0:
            value
        else:
            value + (align - remainder)

fn is_aligned(value: usize, align: usize) -> bool:
    """Mock is_aligned: check if value is aligned."""
    if align == 0 or align == 1:
        true
    else:
        value % align == 0

# ============================================================================
# FFI Functions (Low-Level Memory Operations)
# ============================================================================
# NOTE: The above mock implementations are used in interpreter mode.
# When compiled, these extern declarations would take precedence.
# For now, we comment them out to use the mocks.

# System allocator
# extern fn sys_malloc(size: usize, align: usize) -> [u8]
# extern fn sys_free(ptr: [u8], size: usize, align: usize)
# extern fn sys_realloc(ptr: [u8], old_size: usize, new_size: usize, align: usize) -> [u8]

# Pointer utilities
# extern fn ptr_is_null(ptr: [u8]) -> bool
# extern fn ptr_write(ptr: [u8], value: [u8]?)
# extern fn ptr_read(ptr: [u8]) -> [u8]?
# extern fn buffer_offset(buffer: [u8], offset: usize) -> [u8]
# extern fn memory_copy(dest: [u8], src: [u8], size: usize)

# Alignment
# extern fn align_up(value: usize, align: usize) -> usize
# extern fn is_aligned(value: usize, align: usize) -> bool

# ============================================================================
# Utility Functions
# ============================================================================

fn next_power_of_2(n: usize) -> usize:
    """Round up to next power of 2.

    Args:
        n: Input value

    Returns:
        Next power of 2 >= n

    Example:
        next_power_of_2(10) == 16
        next_power_of_2(16) == 16
    """
    if n <= 1:
        return 1

    var power: usize = 1
    while power < n:
        power = power * 2
    power

fn is_power_of_2(n: usize) -> bool:
    """Check if value is power of 2.

    Args:
        n: Value to check

    Returns:
        true if n is power of 2
    """
    n > 0 and (n and (n - 1)) == 0

# ============================================================================
# Exports
# ============================================================================

export Allocator
export SystemAllocator
export ArenaAllocator
export PoolAllocator
export SlabAllocator
export next_power_of_2
export is_power_of_2
