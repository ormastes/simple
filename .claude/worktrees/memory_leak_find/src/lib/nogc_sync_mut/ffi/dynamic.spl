# Dynamic Library Loader (SFFI)
#
# Provides convention-based dynamic loading of .so/.dll for SFFI.
# Convention: rt_{prefix}_{fn} -> $SIMPLE_SFFI_PATH/libspl_{prefix}.so
#
# Works in C-compiled mode where spl_dlopen/spl_dlsym are available.
# In interpreter mode, spl_dlopen is not whitelisted — use compiled binary.
#
# Usage:
#   val lib = DynLib.load("build/libspl_torch.so")
#   if lib.?:
#       val h = lib.unwrap()
#       val result = h.call1("rt_torch_available", 0)
#
#   # Or via DynLoader singleton:
#   DynLoader.instance().ensure_loaded("build/libspl_torch.so")
#   val result = DynLoader.instance().call0("build/libspl_torch.so", "rt_torch_available")
#
#   # Or via convention:
#   val result = sffi_call("rt_torch_available", [])

# ============================================================================
# Raw FFI Declarations
# ============================================================================

extern fn spl_dlopen(path: text) -> i64
extern fn spl_dlsym(handle: i64, name: text) -> i64
extern fn spl_dlclose(handle: i64) -> i64
extern fn spl_wffi_call_i64(fptr: i64, args: [i64], nargs: i64) -> i64

extern fn rt_env_get(key: text) -> text

# ============================================================================
# DynLib — single loaded shared library handle
# ============================================================================

class DynLib:
    handle: i64
    path: text

impl DynLib:
    # Load a shared library from the given path.
    # Returns nil if dlopen fails (handle == 0).
    static fn load(path: text) -> DynLib?:
        val h = spl_dlopen(path)
        if h == 0:
            nil
        else:
            DynLib(handle: h, path: path)

    # Look up a symbol by name. Returns 0 if not found.
    fn sym(name: text) -> i64:
        spl_dlsym(self.handle, name)

    # Call a function with 0 arguments.
    fn call0(name: text) -> i64:
        val fptr = spl_dlsym(self.handle, name)
        var args: [i64] = []
        spl_wffi_call_i64(fptr, args, 0)

    # Call a function with 1 argument.
    fn call1(name: text, a0: i64) -> i64:
        val fptr = spl_dlsym(self.handle, name)
        var args: [i64] = []
        args.push(a0)
        spl_wffi_call_i64(fptr, args, 1)

    # Call a function with 2 arguments.
    fn call2(name: text, a0: i64, a1: i64) -> i64:
        val fptr = spl_dlsym(self.handle, name)
        var args: [i64] = []
        args.push(a0)
        args.push(a1)
        spl_wffi_call_i64(fptr, args, 2)

    # Call a function with 3 arguments.
    fn call3(name: text, a0: i64, a1: i64, a2: i64) -> i64:
        val fptr = spl_dlsym(self.handle, name)
        var args: [i64] = []
        args.push(a0)
        args.push(a1)
        args.push(a2)
        spl_wffi_call_i64(fptr, args, 3)

    # Call a function with 4 arguments.
    fn call4(name: text, a0: i64, a1: i64, a2: i64, a3: i64) -> i64:
        val fptr = spl_dlsym(self.handle, name)
        var args: [i64] = []
        args.push(a0)
        args.push(a1)
        args.push(a2)
        args.push(a3)
        spl_wffi_call_i64(fptr, args, 4)

    # Call a function with a pre-built args array (general case).
    fn call_n(name: text, args: [i64]) -> i64:
        val fptr = spl_dlsym(self.handle, name)
        val nargs = args.len()
        spl_wffi_call_i64(fptr, args, nargs)

    # Close the library and zero the handle.
    me close():
        spl_dlclose(self.handle)
        self.handle = 0

# ============================================================================
# Module-level singleton state for DynLoader
# ============================================================================

var _dyn_loader_libs: {text: DynLib} = {}

# ============================================================================
# DynLoader — convention-based singleton loader
# ============================================================================

class DynLoader:
    libs: {text: DynLib}

impl DynLoader:
    # Return a DynLoader wrapping the module-level shared state.
    static fn instance() -> DynLoader:
        DynLoader(libs: _dyn_loader_libs)

    # Ensure the library at path is loaded. Returns true if available.
    me ensure_loaded(path: text) -> bool:
        if self.libs.contains(path):
            true
        else:
            val result = DynLib.load(path)
            if result.?:
                val lib = result.unwrap()
                self.libs[path] = lib
                _dyn_loader_libs[path] = lib
                true
            else:
                false

    # Return the loaded DynLib for path, or nil.
    fn get_lib(path: text) -> DynLib?:
        if self.libs.contains(path):
            self.libs[path]
        else:
            nil

    # Call with 0 arguments, loading the library if needed.
    me call0(path: text, func: text) -> i64:
        self.ensure_loaded(path)
        val maybe = self.get_lib(path)
        if maybe.?:
            val lib = maybe.unwrap()
            lib.call0(func)
        else:
            0

    # Call with 1 argument.
    me call1(path: text, func: text, a0: i64) -> i64:
        self.ensure_loaded(path)
        val maybe = self.get_lib(path)
        if maybe.?:
            val lib = maybe.unwrap()
            lib.call1(func, a0)
        else:
            0

    # Call with 2 arguments.
    me call2(path: text, func: text, a0: i64, a1: i64) -> i64:
        self.ensure_loaded(path)
        val maybe = self.get_lib(path)
        if maybe.?:
            val lib = maybe.unwrap()
            lib.call2(func, a0, a1)
        else:
            0

    # Call with 3 arguments.
    me call3(path: text, func: text, a0: i64, a1: i64, a2: i64) -> i64:
        self.ensure_loaded(path)
        val maybe = self.get_lib(path)
        if maybe.?:
            val lib = maybe.unwrap()
            lib.call3(func, a0, a1, a2)
        else:
            0

    # General dispatch with pre-built args array.
    me call(path: text, func: text, args: [i64]) -> i64:
        self.ensure_loaded(path)
        val maybe = self.get_lib(path)
        if maybe.?:
            val lib = maybe.unwrap()
            lib.call_n(func, args)
        else:
            0

# ============================================================================
# Convention helpers
# ============================================================================

# Build the library path for a given SFFI prefix.
# Reads SIMPLE_SFFI_PATH env var; defaults to "build" if empty.
# On Windows (OS == "Windows_NT") uses .dll extension, otherwise .so.
fn sffi_lib_path(prefix: text) -> text:
    var base = rt_env_get("SIMPLE_SFFI_PATH")
    if base == "":
        base = "build"
    val os = rt_env_get("OS")
    if os == "Windows_NT":
        "{base}/libspl_{prefix}.dll"
    else:
        "{base}/libspl_{prefix}.so"

# Call an SFFI function by its full rt_{prefix}_{rest} name.
# Parses the prefix from the function name, resolves the library path
# via sffi_lib_path, and dispatches through the DynLoader singleton.
#
# Example:
#   sffi_call("rt_torch_available", [])
fn sffi_call(func_name: text, args: [i64]) -> i64:
    val parts = func_name.split("_")
    val prefix = parts[1]
    val lib_path = sffi_lib_path(prefix)
    var loader = DynLoader.instance()
    loader.call(lib_path, func_name, args)

export DynLib, DynLoader, sffi_lib_path, sffi_call
