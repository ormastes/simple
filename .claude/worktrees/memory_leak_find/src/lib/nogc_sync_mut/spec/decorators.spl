# Skip/Ignore Decorators
# High-level decorator functions for test skipping
# NOTE: No global var state due to runtime module var limitation

use std.spec.condition.{SkipCondition, create_skip_condition}

# NOTE: These extern declarations reference runtime built-in test functions
# The actual test execution (it, describe) is handled by the runtime
extern fn rt_test_it(name: text, block: fn())
extern fn rt_test_skip(name: text, reason: text)

# ================================================================
# CORE DECORATORS
# ================================================================

fn skip(
    platforms: [text],
    runtimes: [text],
    profiles: [text],
    architectures: [text],
    features: [text],
    version: text,
    hardware: [text],
    dependencies: [text],
    env_vars: {text: text},
    fs_features: [text],
    network: bool,
    tags: [text],
    reason: text
) -> fn(text, fn()):
    """
    Create a skip decorator that skips tests based on matching conditions.

    Semantic: "Will implement in future" - This is a TODO item.
    Use when the feature SHOULD work in this environment but isn't implemented yet.

    Skipped tests are COUNTED in test totals and reported as "SKIP" to track technical debt.

    Args:
        platforms: Skip on these platforms ["windows", "linux", "macos", "unix"]
        runtimes: Skip on these runtime modes ["interpreter", "compiled", "jit"]
        profiles: Skip on these build profiles ["debug", "release", "bootstrap"]
        architectures: Skip on these architectures ["x86_64", "aarch64", "arm64"]
        features: Skip if these features are missing ["generics", "async", "macros"]
        version: Skip if version constraint not met ">= 0.5.0"
        hardware: Skip if hardware missing ["gpu", "simd", "avx2", "neon"]
        dependencies: Skip if dependencies present ["torch", "numpy"]
        env_vars: Skip if env vars don't match {"CI": "true"}
        fs_features: Skip if FS features missing ["symlinks", "permissions"]
        network: Skip if network required but unavailable
        tags: Metadata tags ["slow", "integration"]
        reason: Explanation of why skipped

    Returns:
        Decorator function that takes (name, block) and either runs or skips the test.

    Usage:
        val skip_win = skip(platforms: ["windows"], reason: "Not yet ported")
        skip_win("file permissions test", fn():
            chmod("/tmp/file", 0o644)
        )
    """

    # Create condition
    val condition = create_skip_condition(
        platforms, runtimes, profiles, architectures,
        features, version, hardware, dependencies,
        env_vars, fs_features, network, tags,
        reason, false  # ignore=false for skip
    )

    # Return decorator function
    fn decorator(name: text, block: fn()):
        if condition.matches():
            # Skip: count and print
            val reason_msg = if reason != "":
                reason
            else:
                "Condition matched"

            print "    it {name} ... skipped ({reason_msg})"
            # NOTE: Cannot track count due to runtime limitation
        else:
            # Run test normally
            rt_test_it(name, block)

    decorator

fn ignore(
    platforms: [text],
    runtimes: [text],
    profiles: [text],
    architectures: [text],
    features: [text],
    version: text,
    hardware: [text],
    dependencies: [text],
    env_vars: {text: text},
    fs_features: [text],
    network: bool,
    tags: [text],
    reason: text
) -> fn(text, fn()):
    """
    Create an ignore decorator that completely ignores tests based on matching conditions.

    Semantic: "Fundamentally not supported" - This will NEVER be fixed.
    Use when the environment fundamentally lacks the capability.

    Ignored tests are NOT counted in test totals at all. Completely silent.

    Args:
        Same as skip() - see skip() documentation

    Returns:
        Decorator function that either runs test or completely ignores it (silent).

    Usage:
        val ignore_win = ignore(platforms: ["windows"], reason: "Unix fork() API")
        ignore_win("fork test", fn():
            pid = fork()
        )
    """

    # Initialize environment detection
    # Create condition
    val condition = create_skip_condition(
        platforms, runtimes, profiles, architectures,
        features, version, hardware, dependencies,
        env_vars, fs_features, network, tags,
        reason, true  # ignore=true
    )

    # Return decorator function
    fn decorator(name: text, block: fn()):
        if condition.matches():
            # Ignore: completely silent, no output, no counting
            # NOTE: Cannot track count due to runtime limitation
            ()
        else:
            # Run test normally
            rt_test_it(name, block)

    decorator

fn only_on(
    platforms: [text],
    runtimes: [text],
    profiles: [text],
    architectures: [text],
    features: [text],
    version: text,
    hardware: [text],
    dependencies: [text],
    env_vars: {text: text},
    fs_features: [text],
    network: bool,
    tags: [text]
) -> fn(text, fn()):
    """
    Create a decorator that runs tests ONLY on specified conditions.
    Uses inverse logic of skip() - skips if conditions DON'T match.

    Args:
        Same as skip() but without reason (auto-generated)

    Returns:
        Decorator function that runs test only on matching conditions.

    Usage:
        val only_linux = only_on(platforms: ["linux"])
        only_linux("Linux-specific test", fn():
            test_body()
        )
    """

    # Initialize environment detection
    # Create condition (inverse logic handled below)
    val condition = create_skip_condition(
        platforms, runtimes, profiles, architectures,
        features, version, hardware, dependencies,
        env_vars, fs_features, network, tags,
        "", false
    )

    # Return decorator function
    fn decorator(name: text, block: fn()):
        # Inverse logic: skip if NOT matching
        if not condition.matches():
            # Run test
            rt_test_it(name, block)
        else:
            # Skip with auto-generated reason
            print "    it {name} ... skipped (Not on specified platform/runtime)"
            # NOTE: Cannot track count due to runtime limitation

    decorator

fn skip_if(condition: fn() -> bool, reason: text) -> fn(text, fn()):
    """
    Create a conditional skip decorator that evaluates a custom condition.

    Args:
        condition: Function that returns true if test should be skipped
        reason: Explanation of why skipped

    Returns:
        Decorator function that evaluates condition before running test.

    Usage:
        val skip_no_ci = skip_if(fn(): get_env("CI") == "", "Requires CI")
        skip_no_ci("CI-only test", fn():
            test_body()
        )
    """

    fn decorator(name: text, block: fn()):
        if condition():
            val reason_msg = if reason != "":
                reason
            else:
                "Condition not met"

            print "    it {name} ... skipped ({reason_msg})"
            # NOTE: Cannot track count due to runtime limitation
        else:
            rt_test_it(name, block)

    decorator

# ================================================================
# SIMPLIFIED DECORATORS (Common Cases)
# ================================================================

fn skip_on_windows(reason: text) -> fn(text, fn()):
    """Simplified: Skip on Windows."""
    skip(
        platforms: ["windows"],
        runtimes: [],
        profiles: [],
        architectures: [],
        features: [],
        version: "",
        hardware: [],
        dependencies: [],
        env_vars: {},
        fs_features: [],
        network: false,
        tags: [],
        reason: reason
    )

fn skip_on_linux(reason: text) -> fn(text, fn()):
    """Simplified: Skip on Linux."""
    skip(
        platforms: ["linux"],
        runtimes: [],
        profiles: [],
        architectures: [],
        features: [],
        version: "",
        hardware: [],
        dependencies: [],
        env_vars: {},
        fs_features: [],
        network: false,
        tags: [],
        reason: reason
    )

fn skip_on_interpreter(reason: text) -> fn(text, fn()):
    """Simplified: Skip in interpreter mode."""
    skip(
        platforms: [],
        runtimes: ["interpreter"],
        profiles: [],
        architectures: [],
        features: [],
        version: "",
        hardware: [],
        dependencies: [],
        env_vars: {},
        fs_features: [],
        network: false,
        tags: [],
        reason: reason
    )

fn ignore_on_windows(reason: text) -> fn(text, fn()):
    """Simplified: Ignore on Windows (fundamentally not supported)."""
    ignore(
        platforms: ["windows"],
        runtimes: [],
        profiles: [],
        architectures: [],
        features: [],
        version: "",
        hardware: [],
        dependencies: [],
        env_vars: {},
        fs_features: [],
        network: false,
        tags: [],
        reason: reason
    )

# Export
export skip, ignore, only_on, skip_if
export skip_on_windows, skip_on_linux, skip_on_interpreter, ignore_on_windows
