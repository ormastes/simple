# Query Builder for SDN Databases
#
# Provides fluent query interface with filtering, sorting, and limiting.

use std.database.core.{SdnTable, SdnRow}

# ============================================================================
# Compare Operators
# ============================================================================

enum CompareOp:
    Eq           # Equal
    Ne           # Not equal
    Gt           # Greater than
    Ge           # Greater or equal
    Lt           # Less than
    Le           # Less or equal
    Contains     # String contains
    StartsWith   # String starts with
    EndsWith     # String ends with

# ============================================================================
# Filter
# ============================================================================

struct Filter:
    field: text
    op: CompareOp
    value: text

    # Check if row matches filter
    fn matches(row: SdnRow) -> bool:
        val field_value = row.get(self.field)
        if not field_value.?:
            return false

        val fv = field_value.unwrap()
        match self.op:
            CompareOp.Eq: fv == self.value
            CompareOp.Ne: fv != self.value
            CompareOp.Gt: fv > self.value
            CompareOp.Ge: fv >= self.value
            CompareOp.Lt: fv < self.value
            CompareOp.Le: fv <= self.value
            CompareOp.Contains: fv.contains(self.value)
            CompareOp.StartsWith: fv.starts_with(self.value)
            CompareOp.EndsWith: fv.ends_with(self.value)

# ============================================================================
# QueryBuilder
# ============================================================================

class QueryBuilder:
    table: SdnTable
    filters: [Filter]
    sort_field: text?
    sort_desc: bool
    limit_count: i64?

    # Create query builder for table
    static fn for_table(table: SdnTable) -> QueryBuilder:
        QueryBuilder(
            table: table,
            filters: [],
            sort_field: nil,
            sort_desc: false,
            limit_count: nil
        )

    # Add filter condition
    me filter_by(field: text, op: CompareOp, value: text) -> QueryBuilder:
        self.filters.push(Filter(field: field, op: op, value: value))
        self

    # Filter by multiple values (field IN (values))
    me filter_in(field: text, values: [text]) -> QueryBuilder:
        # Add OR filters for each value
        # Note: This is simplified - proper implementation would group OR conditions
        for value in values:
            self.filters.push(Filter(field: field, op: CompareOp.Eq, value: value))
        self

    # Exclude soft-deleted rows (valid=true)
    me only_valid() -> QueryBuilder:
        self.filter_by("valid", CompareOp.Eq, "true")

    # Sort results
    me order_by(field: text, desc: bool) -> QueryBuilder:
        self.sort_field = Some(field)
        self.sort_desc = desc
        self

    # Limit results
    me take(n: i64) -> QueryBuilder:
        self.limit_count = Some(n)
        self

    # Execute query
    fn execute() -> [SdnRow]:
        var results = self.table.rows

        # Apply filters
        for filter in self.filters:
            results = results.filter(\row: filter.matches(row))

        # Apply sorting (merge sort - O(n log n) stable sort)
        if self.sort_field.?:
            val field = self.sort_field?
            results = merge_sort_rows(results, field, self.sort_desc)

        # Apply limit
        if self.limit_count.?:
            val limit = self.limit_count?
            results = results.take(limit)

        results

    # Count results
    fn count() -> i64:
        self.execute().len()

    # Check if any match
    fn exists() -> bool:
        self.count() > 0

# ============================================================================
# Extension for SdnDatabase
# ============================================================================

# Add query() method to SdnDatabase
# Note: In actual implementation, this would be in mod.spl as method on SdnDatabase
# For now, we provide standalone function

use std.database.core.{SdnDatabase}

# Merge sort for arrays of SdnRow - O(n log n) stable sort
fn merge_sort_rows(rows: [SdnRow], field: text, desc: bool) -> [SdnRow]:
    if rows.len() <= 1:
        return rows
    val mid = rows.len() / 2
    var left: [SdnRow] = []
    var right: [SdnRow] = []
    for i in 0..mid:
        left = left.push(rows[i])
    for i in mid..rows.len():
        right = right.push(rows[i])
    merge_rows(left=merge_sort_rows(left, field, desc), right=merge_sort_rows(right, field, desc), field=field, desc=desc)

fn merge_rows(left: [SdnRow], right: [SdnRow], field: text, desc: bool) -> [SdnRow]:
    var result: [SdnRow] = []
    var i = 0
    var j = 0
    while i < left.len() and j < right.len():
        val a = left[i].get(field) ?? ""
        val b = right[j].get(field) ?? ""
        val take_left = if desc: a >= b else: a <= b
        if take_left:
            result = result.push(left[i])
            i = i + 1
        else:
            result = result.push(right[j])
            j = j + 1
    while i < left.len():
        result = result.push(left[i])
        i = i + 1
    while j < right.len():
        result = result.push(right[j])
        j = j + 1
    result

fn query_table(db: SdnDatabase, table_name: text) -> QueryBuilder?:
    val table = db.get_table(table_name)?
    Some(QueryBuilder__for_table(table))
