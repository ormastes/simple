# Todo Database - Read/validate wrapper for todo_db.sdn
#
# The todo_scan app currently writes directly via file_write(),
# bypassing the shared database library. This module provides
# read-only access and validation for check-dbs/fix-dbs commands.
#
# NOTE: Write path migration is out of scope. This module only
# reads and validates existing todo_db.sdn files.
#
# Usage:
#   use std.database.todo.{TodoDatabase, load_todo_database}
#   val db = load_todo_database("doc/todo/todo_db.sdn")

use std.database.core.{SdnDatabase, SdnTable, SdnRow}
use std.database.checker.{DbIssue, check_duplicate_ids, check_valid_column,
    check_required_fields, check_empty_required, check_file_refs, check_enum_values}

# Direct extern declarations for bootstrap runtime compatibility
extern fn rt_file_exists(path: text) -> bool
fn file_exists(path: text) -> bool:
    rt_file_exists(path)

# ============================================================================
# Structs
# ============================================================================

struct TodoEntry:
    id: text
    keyword: text       # TODO, FIXME, HACK, etc.
    file: text
    line: i64
    message: text
    status: text        # "open", "closed", "blocked"
    valid: bool

# ============================================================================
# Helper Functions
# ============================================================================

fn load_todo_database(path: text) -> TodoDatabase?:
    val db = SdnDatabase.load(path)?
    Some(TodoDatabase(db: db))

# ============================================================================
# TodoDatabase
# ============================================================================

class TodoDatabase:
    db: SdnDatabase

    # Get all valid todo entries
    fn all_todos() -> [TodoEntry]:
        val table_opt = self.db.get_table("todos")
        if not table_opt.?:
            return []

        val table = table_opt.unwrap()
        var result: [TodoEntry] = []

        for row in table.valid_rows():
            val id = row.get("id") ?? ""
            val keyword = row.get("keyword") ?? ""
            val file = row.get("file") ?? ""
            val line = row.get_i64("line") ?? 0
            val message = row.get("message") ?? ""
            val status = row.get("status") ?? "open"
            val valid_opt = row.get("valid")
            val valid = if valid_opt.?: valid_opt.unwrap() == "true" else: true

            result.push(TodoEntry(
                id: id,
                keyword: keyword,
                file: file,
                line: line,
                message: message,
                status: status,
                valid: valid
            ))

        result

    # Validate the todo database
    fn validate() -> [DbIssue]:
        var issues: [DbIssue] = []
        val db_name = "todo"

        val table_opt = self.db.get_table("todos")
        if not table_opt.?:
            issues.push(DbIssue(
                db_name: db_name,
                severity: "error",
                issue_type: "missing_table",
                message: "Expected 'todos' table not found in todo database",
                auto_fixable: false
            ))
            return issues

        val table = table_opt.unwrap()

        # Check required columns
        val required = ["id", "keyword", "file", "line", "status", "valid"]
        val col_issues = check_required_fields(table, required, db_name)
        for issue in col_issues:
            issues.push(issue)

        # Check for duplicate IDs
        val dup_issues = check_duplicate_ids(table, "id", db_name)
        for issue in dup_issues:
            issues.push(issue)

        # Check valid column values
        val valid_issues = check_valid_column(table, db_name)
        for issue in valid_issues:
            issues.push(issue)

        # Check required fields are not empty
        val empty_kw = check_empty_required(table, "keyword", db_name)
        for issue in empty_kw:
            issues.push(issue)

        val empty_file = check_empty_required(table, "file", db_name)
        for issue in empty_file:
            issues.push(issue)

        # Check status values
        val valid_statuses = ["open", "closed", "blocked"]
        val status_issues = check_enum_values(table, "status", valid_statuses, db_name)
        for issue in status_issues:
            issues.push(issue)

        # Check referenced files exist
        val file_issues = check_file_refs(table, "file", db_name)
        for issue in file_issues:
            issues.push(issue)

        # Warn about direct file_write bypass
        issues.push(DbIssue(
            db_name: db_name,
            severity: "info",
            issue_type: "bypass_warning",
            message: "TodoDB uses direct file_write() â€” not managed by shared database library",
            auto_fixable: false
        ))

        issues

# ============================================================================
# Exports
# ============================================================================

export TodoDatabase, TodoEntry
export load_todo_database
