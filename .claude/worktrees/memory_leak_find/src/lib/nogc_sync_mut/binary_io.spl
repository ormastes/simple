# Binary I/O
#
# Binary reading and writing with endianness support.
# Provides efficient serialization/deserialization of primitive types.
#
# Components:
# - ByteOrder: Endianness (LittleEndian, BigEndian, Native)
# - BinaryReader: Read binary data from byte streams
# - BinaryWriter: Write binary data to byte streams
# - Serializable/Deserializable: Traits for custom types
# - BufferedReader/BufferedWriter: Buffered I/O for efficiency
#
# Usage:
#   val reader = BinaryReader.new(data)
#   val value = reader.read_u32(ByteOrder.LittleEndian)
#
# Architecture:
# - Zero-copy when possible
# - Endianness conversion on demand
# - Buffering for small reads/writes

# ============================================================================
# ByteOrder - Endianness
# ============================================================================

enum ByteOrder:
    """Byte order for multi-byte values.

    - LittleEndian: Least significant byte first (x86, ARM)
    - BigEndian: Most significant byte first (network order)
    - Native: Platform default
    """
    LittleEndian
    BigEndian
    Native

impl ByteOrder:
    static fn native() -> ByteOrder:
        """Get native byte order for this platform.

        Returns:
            Native byte order (LittleEndian on most platforms)
        """
        # Most platforms are little-endian
        # FFI function returns true if little-endian
        if is_little_endian():
            ByteOrder.LittleEndian
        else:
            ByteOrder.BigEndian

    fn is_little_endian() -> bool:
        """Check if this byte order is little-endian."""
        match self:
            case ByteOrder.LittleEndian: true
            case ByteOrder.BigEndian: false
            case ByteOrder.Native: is_little_endian()

    fn is_big_endian() -> bool:
        """Check if this byte order is big-endian."""
        not self.is_little_endian()

# ============================================================================
# BinaryReader - Read Binary Data
# ============================================================================

class BinaryReader:
    """Read binary data from byte buffer.

    Supports reading primitive types with endianness control.

    Example:
        val data = [0x01, 0x02, 0x03, 0x04]
        val reader = BinaryReader.new(data)

        val value = reader.read_u32(ByteOrder.LittleEndian)
        # 0x04030201 = 67305985
    """
    buffer: [u8]       # Byte buffer
    position: usize    # Current read position

    static fn new(buffer: [u8]) -> BinaryReader:
        """Create reader from byte buffer.

        Args:
            buffer: Byte buffer to read from

        Returns:
            Binary reader
        """
        BinaryReader(buffer: buffer, position: 0)

    fn remaining() -> usize:
        """Get number of bytes remaining.

        Returns:
            Bytes remaining to read
        """
        if self.position >= self.buffer.len():
            0
        else:
            self.buffer.len() - self.position

    fn has_remaining() -> bool:
        """Check if there are bytes remaining.

        Returns:
            true if bytes available, false otherwise
        """
        self.remaining() > 0

    fn peek_u8() -> u8?:
        """Peek at next byte without advancing position.

        Returns:
            Some(byte) if available, nil if at end
        """
        if self.position < self.buffer.len():
            Some(self.buffer[self.position])
        else:
            nil

    fn read_u8() -> u8?:
        """Read unsigned 8-bit integer.

        Returns:
            Some(value) if successful, nil if at end
        """
        if self.position >= self.buffer.len():
            return nil

        val value = self.buffer[self.position]
        self.position = self.position + 1
        Some(value)

    fn read_i8() -> i8?:
        """Read signed 8-bit integer.

        Returns:
            Some(value) if successful, nil if at end
        """
        self.read_u8().map(\b: b as i8)

    fn read_u16(order: ByteOrder) -> u16?:
        """Read unsigned 16-bit integer.

        Args:
            order: Byte order

        Returns:
            Some(value) if successful, nil if insufficient bytes
        """
        if self.remaining() < 2:
            return nil

        val b0 = self.buffer[self.position]
        val b1 = self.buffer[self.position + 1]
        self.position = self.position + 2

        if order.is_little_endian():
            Some(bytes_to_u16_le(b0, b1))
        else:
            Some(bytes_to_u16_be(b0, b1))

    fn read_i16(order: ByteOrder) -> i16?:
        """Read signed 16-bit integer.

        Args:
            order: Byte order

        Returns:
            Some(value) if successful, nil if insufficient bytes
        """
        self.read_u16(order).map(\u: u as i16)

    fn read_u32(order: ByteOrder) -> u32?:
        """Read unsigned 32-bit integer.

        Args:
            order: Byte order

        Returns:
            Some(value) if successful, nil if insufficient bytes
        """
        if self.remaining() < 4:
            return nil

        val bytes = [
            self.buffer[self.position],
            self.buffer[self.position + 1],
            self.buffer[self.position + 2],
            self.buffer[self.position + 3]
        ]
        self.position = self.position + 4

        if order.is_little_endian():
            Some(bytes_to_u32_le(bytes))
        else:
            Some(bytes_to_u32_be(bytes))

    fn read_i32(order: ByteOrder) -> i32?:
        """Read signed 32-bit integer.

        Args:
            order: Byte order

        Returns:
            Some(value) if successful, nil if insufficient bytes
        """
        self.read_u32(order).map(\u: u as i32)

    fn read_u64(order: ByteOrder) -> u64?:
        """Read unsigned 64-bit integer.

        Args:
            order: Byte order

        Returns:
            Some(value) if successful, nil if insufficient bytes
        """
        if self.remaining() < 8:
            return nil

        val bytes = [
            self.buffer[self.position],
            self.buffer[self.position + 1],
            self.buffer[self.position + 2],
            self.buffer[self.position + 3],
            self.buffer[self.position + 4],
            self.buffer[self.position + 5],
            self.buffer[self.position + 6],
            self.buffer[self.position + 7]
        ]
        self.position = self.position + 8

        if order.is_little_endian():
            Some(bytes_to_u64_le(bytes))
        else:
            Some(bytes_to_u64_be(bytes))

    fn read_i64(order: ByteOrder) -> i64?:
        """Read signed 64-bit integer.

        Args:
            order: Byte order

        Returns:
            Some(value) if successful, nil if insufficient bytes
        """
        self.read_u64(order).map(\u: u as i64)

    fn read_f32(order: ByteOrder) -> f32?:
        """Read 32-bit floating point.

        Args:
            order: Byte order

        Returns:
            Some(value) if successful, nil if insufficient bytes
        """
        self.read_u32(order).map(\bits: f32_from_bits(bits))

    fn read_f64(order: ByteOrder) -> f64?:
        """Read 64-bit floating point.

        Args:
            order: Byte order

        Returns:
            Some(value) if successful, nil if insufficient bytes
        """
        self.read_u64(order).map(\bits: f64_from_bits(bits))

    fn read_bytes(count: usize) -> [u8]?:
        """Read exact number of bytes.

        Args:
            count: Number of bytes to read

        Returns:
            Some(bytes) if successful, nil if insufficient bytes
        """
        if self.remaining() < count:
            return nil

        val bytes = self.buffer[self.position : self.position + count]
        self.position = self.position + count
        Some(bytes)

    fn read_string(length: usize) -> text?:
        """Read UTF-8 string of specified length.

        Args:
            length: Number of bytes to read

        Returns:
            Some(string) if successful, nil if insufficient bytes
        """
        self.read_bytes(length).map(\bytes: bytes_to_string(bytes))

    me skip(count: usize) -> bool:
        """Skip specified number of bytes.

        Args:
            count: Number of bytes to skip

        Returns:
            true if successful, false if insufficient bytes
        """
        if self.remaining() < count:
            return false

        self.position = self.position + count
        true

    me seek(position: usize) -> bool:
        """Seek to absolute position.

        Args:
            position: Position to seek to

        Returns:
            true if successful, false if out of bounds
        """
        if position > self.buffer.len():
            return false

        self.position = position
        true

# ============================================================================
# BinaryWriter - Write Binary Data
# ============================================================================

class BinaryWriter:
    """Write binary data to byte buffer.

    Supports writing primitive types with endianness control.

    Example:
        val writer = BinaryWriter.new()

        writer.write_u32(0x04030201, ByteOrder.LittleEndian)
        val bytes = writer.to_bytes()
        # [0x01, 0x02, 0x03, 0x04]
    """
    buffer: [u8]       # Byte buffer

    static fn new() -> BinaryWriter:
        """Create new writer with empty buffer."""
        BinaryWriter(buffer: [])

    static fn with_capacity(capacity: usize) -> BinaryWriter:
        """Create writer with pre-allocated capacity.

        Args:
            capacity: Initial capacity in bytes

        Returns:
            Binary writer
        """
        BinaryWriter(buffer: allocate_buffer(capacity))

    fn len() -> usize:
        """Get number of bytes written.

        Returns:
            Byte count
        """
        self.buffer.len()

    fn is_empty() -> bool:
        """Check if buffer is empty."""
        self.buffer.len() == 0

    me write_u8(value: u8):
        """Write unsigned 8-bit integer.

        Args:
            value: Value to write
        """
        self.buffer = self.buffer.push(value)

    me write_i8(value: i8):
        """Write signed 8-bit integer.

        Args:
            value: Value to write
        """
        self.write_u8(value as u8)

    me write_u16(value: u16, order: ByteOrder):
        """Write unsigned 16-bit integer.

        Args:
            value: Value to write
            order: Byte order
        """
        if order.is_little_endian():
            val bytes = u16_to_bytes_le(value)
            self.buffer = self.buffer.push(bytes[0])
            self.buffer = self.buffer.push(bytes[1])
        else:
            val bytes = u16_to_bytes_be(value)
            self.buffer = self.buffer.push(bytes[0])
            self.buffer = self.buffer.push(bytes[1])

    me write_i16(value: i16, order: ByteOrder):
        """Write signed 16-bit integer.

        Args:
            value: Value to write
            order: Byte order
        """
        self.write_u16(value as u16, order)

    me write_u32(value: u32, order: ByteOrder):
        """Write unsigned 32-bit integer.

        Args:
            value: Value to write
            order: Byte order
        """
        val bytes = if order.is_little_endian():
            u32_to_bytes_le(value)
        else:
            u32_to_bytes_be(value)

        for byte in bytes:
            self.buffer = self.buffer.push(byte)

    me write_i32(value: i32, order: ByteOrder):
        """Write signed 32-bit integer.

        Args:
            value: Value to write
            order: Byte order
        """
        self.write_u32(value as u32, order)

    me write_u64(value: u64, order: ByteOrder):
        """Write unsigned 64-bit integer.

        Args:
            value: Value to write
            order: Byte order
        """
        val bytes = if order.is_little_endian():
            u64_to_bytes_le(value)
        else:
            u64_to_bytes_be(value)

        for byte in bytes:
            self.buffer = self.buffer.push(byte)

    me write_i64(value: i64, order: ByteOrder):
        """Write signed 64-bit integer.

        Args:
            value: Value to write
            order: Byte order
        """
        self.write_u64(value as u64, order)

    me write_f32(value: f32, order: ByteOrder):
        """Write 32-bit floating point.

        Args:
            value: Value to write
            order: Byte order
        """
        val bits = f32_to_bits(value)
        self.write_u32(bits, order)

    me write_f64(value: f64, order: ByteOrder):
        """Write 64-bit floating point.

        Args:
            value: Value to write
            order: Byte order
        """
        val bits = f64_to_bits(value)
        self.write_u64(bits, order)

    me write_bytes(bytes: [u8]):
        """Write byte array.

        Args:
            bytes: Bytes to write
        """
        for byte in bytes:
            self.buffer = self.buffer.push(byte)

    me write_string(text: text):
        """Write UTF-8 string.

        Args:
            text: String to write
        """
        val bytes = string_to_bytes(text)
        self.write_bytes(bytes)

    fn to_bytes() -> [u8]:
        """Get written bytes.

        Returns:
            Byte array
        """
        self.buffer

    me clear():
        """Clear buffer."""
        self.buffer = []

# ============================================================================
# Serializable/Deserializable Traits
# ============================================================================

trait Serializable:
    """Trait for types that can be serialized to binary.

    Example:
        impl Serializable for Point:
            fn serialize(writer: BinaryWriter):
                writer.write_i32(self.x, ByteOrder.Native)
                writer.write_i32(self.y, ByteOrder.Native)
    """
    fn serialize(writer: BinaryWriter)

trait Deserializable:
    """Trait for types that can be deserialized from binary.

    Example:
        impl Deserializable for Point:
            static fn deserialize(reader: BinaryReader) -> Point?:
                val x = reader.read_i32(ByteOrder.Native)?
                val y = reader.read_i32(ByteOrder.Native)?
                Some(Point(x: x, y: y))
    """
    static fn deserialize(reader: BinaryReader) -> Self?

# ============================================================================
# BufferedReader - Buffered Binary Reading
# ============================================================================

class BufferedReader:
    """Buffered binary reader for efficient small reads.

    Example:
        val reader = BufferedReader.new(data, buffer_size: 4096)
        val value = reader.read_u32(ByteOrder.LittleEndian)
    """
    inner: BinaryReader
    buffer_size: usize

    static fn new(data: [u8], buffer_size: usize) -> BufferedReader:
        """Create buffered reader.

        Args:
            data: Data to read from
            buffer_size: Buffer size in bytes

        Returns:
            Buffered reader
        """
        BufferedReader(
            inner: BinaryReader.new(data),
            buffer_size: buffer_size
        )

    fn read_u8() -> u8?:
        """Read unsigned 8-bit integer."""
        self.inner.read_u8()

    fn read_u32(order: ByteOrder) -> u32?:
        """Read unsigned 32-bit integer."""
        self.inner.read_u32(order)

    fn read_u64(order: ByteOrder) -> u64?:
        """Read unsigned 64-bit integer."""
        self.inner.read_u64(order)

    fn remaining() -> usize:
        """Get bytes remaining."""
        self.inner.remaining()

# ============================================================================
# BufferedWriter - Buffered Binary Writing
# ============================================================================

class BufferedWriter:
    """Buffered binary writer for efficient small writes.

    Buffers writes and flushes when buffer is full.

    Example:
        val writer = BufferedWriter.new(buffer_size: 4096)
        writer.write_u32(42, ByteOrder.LittleEndian)
        writer.flush()
    """
    inner: BinaryWriter
    buffer_size: usize
    unflushed: usize

    static fn new(buffer_size: usize) -> BufferedWriter:
        """Create buffered writer.

        Args:
            buffer_size: Buffer size in bytes

        Returns:
            Buffered writer
        """
        BufferedWriter(
            inner: BinaryWriter.with_capacity(buffer_size),
            buffer_size: buffer_size,
            unflushed: 0
        )

    me write_u8(value: u8):
        """Write unsigned 8-bit integer."""
        self.inner.write_u8(value)
        self.unflushed = self.unflushed + 1
        self.check_flush()

    me write_u32(value: u32, order: ByteOrder):
        """Write unsigned 32-bit integer."""
        self.inner.write_u32(value, order)
        self.unflushed = self.unflushed + 4
        self.check_flush()

    me check_flush():
        """Flush if buffer is full."""
        if self.unflushed >= self.buffer_size:
            self.flush()

    me flush():
        """Flush buffer (no-op for in-memory buffer)."""
        self.unflushed = 0

    fn to_bytes() -> [u8]:
        """Get written bytes."""
        self.inner.to_bytes()

# ============================================================================
# FFI Functions
# ============================================================================

# Platform detection
extern fn is_little_endian() -> bool

# Byte conversion (little-endian)
extern fn bytes_to_u16_le(b0: u8, b1: u8) -> u16
extern fn bytes_to_u32_le(bytes: [u8]) -> u32
extern fn bytes_to_u64_le(bytes: [u8]) -> u64
extern fn u16_to_bytes_le(value: u16) -> [u8]
extern fn u32_to_bytes_le(value: u32) -> [u8]
extern fn u64_to_bytes_le(value: u64) -> [u8]

# Byte conversion (big-endian)
extern fn bytes_to_u16_be(b0: u8, b1: u8) -> u16
extern fn bytes_to_u32_be(bytes: [u8]) -> u32
extern fn bytes_to_u64_be(bytes: [u8]) -> u64
extern fn u16_to_bytes_be(value: u16) -> [u8]
extern fn u32_to_bytes_be(value: u32) -> [u8]
extern fn u64_to_bytes_be(value: u64) -> [u8]

# Float conversion
extern fn f32_from_bits(bits: u32) -> f32
extern fn f64_from_bits(bits: u64) -> f64
extern fn f32_to_bits(value: f32) -> u32
extern fn f64_to_bits(value: f64) -> u64

# String conversion
extern fn bytes_to_string(bytes: [u8]) -> text
extern fn string_to_bytes(text: text) -> [u8]

# Buffer allocation
extern fn allocate_buffer(capacity: usize) -> [u8]

# ============================================================================
# Exports
# ============================================================================

export ByteOrder
export BinaryReader
export BinaryWriter
export Serializable
export Deserializable
export BufferedReader
export BufferedWriter
