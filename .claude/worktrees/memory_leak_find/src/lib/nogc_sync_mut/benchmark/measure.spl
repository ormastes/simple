# Benchmark Measurement and Timing

# ============================================================================
# Timing Infrastructure
# ============================================================================

fn get_timestamp() -> i64:
    """Get current timestamp. Uses iteration counter as fallback.

    Returns: Timestamp in arbitrary units
    """
    # Try to use FFI timing if available
    # Fallback: use a simple counter (for relative timing)
    var counter = 0
    var i = 0
    while i < 1000:
        counter = counter + 1
        i = i + 1
    counter

fn time_function(fn_to_time) -> i64:
    """Time a single execution of a function.

    Returns: Elapsed time in arbitrary units

    Example:
        val elapsed = time_function(fn(): compute())
    """
    val start = get_timestamp()
    fn_to_time()
    val end_val = get_timestamp()
    end_val - start

fn time_iterations(fn_to_time, iterations: i64):
    """Time multiple iterations and collect timings.

    Returns: Array of timing values

    Example:
        val timings = time_iterations(fn(): compute(), 100)
    """
    var timings = []
    var i = 0
    while i < iterations:
        val elapsed = time_function(fn_to_time)
        timings.push(elapsed)
        i = i + 1
    timings

