# Debugging Support for Simple
#
# Debug printing, tracing, and breakpoints.


# ============================================================================
# Enums
# ============================================================================

enum DebugLevel:
    Off
    Error
    Warn
    Info
    Debug
    Trace

enum StepMode:
    Continue
    StepOver
    StepInto
    StepOut

# ============================================================================
# Classes
# ============================================================================

class Breakpoint:
    file: text
    line: i64
    condition: text  # Empty string means no condition
    hit_count: i64
    enabled: bool

class StackFrame:
    fn_name: text
    file: text
    line: i64
    locals: [text]  # Array of "name=value" strings

class Debugger:
    breakpoints: [Breakpoint]
    watch_expressions: [text]
    call_stack: [StackFrame]
    is_stepping: bool
    step_mode: StepMode
    debug_level: DebugLevel
    trace_enabled: bool

    # Breakpoint management
    me add_breakpoint(file: text, line: i64, condition: text):
        val bp = Breakpoint(
            file: file,
            line: line,
            condition: condition,
            hit_count: 0,
            enabled: true
        )
        self.breakpoints.push(bp)

    me remove_breakpoint(file: text, line: i64):
        var new_breakpoints = []
        for bp in self.breakpoints:
            if bp.file != file or bp.line != line:
                new_breakpoints.push(bp)
        self.breakpoints = new_breakpoints

    me toggle_breakpoint(file: text, line: i64):
        for bp in self.breakpoints:
            if bp.file == file and bp.line == line:
                bp.enabled = not bp.enabled

    fn has_breakpoint(file: text, line: i64) -> bool:
        for bp in self.breakpoints:
            if bp.file == file and bp.line == line and bp.enabled:
                return true
        false

    fn list_breakpoints() -> [text]:
        var result = []
        for bp in self.breakpoints:
            val status = if bp.enabled: "enabled" else: "disabled"
            result.push("{bp.file}:{bp.line} ({status}, hit {bp.hit_count} times)")
        result

    # Watch expressions
    me add_watch(expr: text):
        self.watch_expressions.push(expr)

    me remove_watch(idx: i64):
        if idx >= 0 and idx < self.watch_expressions.len():
            var new_watches = []
            for i in 0..self.watch_expressions.len():
                if i != idx:
                    new_watches.push(self.watch_expressions[i])
            self.watch_expressions = new_watches

    fn list_watches() -> [text]:
        self.watch_expressions

    # Call stack management
    me push_frame(frame: StackFrame):
        self.call_stack.push(frame)

    me pop_frame():
        if self.call_stack.len() > 0:
            self.call_stack.pop()

    fn current_frame() -> StackFrame:
        if self.call_stack.len() == 0:
            return StackFrame(fn_name: "", file: "", line: 0, locals: [])
        self.call_stack[self.call_stack.len() - 1]

    fn get_stack_trace() -> [text]:
        var trace = []
        val depth = self.call_stack.len()
        for i in 0..depth:
            val idx = depth - 1 - i
            val frame = self.call_stack[idx]
            trace.push("  #{i}: {frame.fn_name} at {frame.file}:{frame.line}")
        trace

    # Stepping control
    me step_over():
        self.is_stepping = true
        self.step_mode = StepMode.StepOver

    me step_into():
        self.is_stepping = true
        self.step_mode = StepMode.StepInto

    me step_out():
        self.is_stepping = true
        self.step_mode = StepMode.StepOut

    me continue_execution():
        self.is_stepping = false
        self.step_mode = StepMode.Continue

    # Debug level management
    me set_debug_level(level: DebugLevel):
        self.debug_level = level

    fn get_debug_level() -> DebugLevel:
        self.debug_level

    me set_trace(enabled: bool):
        self.trace_enabled = enabled

    fn is_trace_enabled() -> bool:
        self.trace_enabled

    fn debug_print(msg_level: DebugLevel, msg: text):
        debug_print(self.debug_level, msg_level, msg)

    # Should break check
    me should_break(file: text, line: i64) -> bool:
        # Check breakpoints
        for bp in self.breakpoints:
            if bp.file == file and bp.line == line and bp.enabled:
                bp.hit_count = bp.hit_count + 1
                return true

        # Check stepping
        if self.is_stepping:
            if self.step_mode == StepMode.StepInto:
                return true
            if self.step_mode == StepMode.StepOver:
                return true  # Simplified: break at every line
            if self.step_mode == StepMode.StepOut:
                return false  # Simplified: don't break until we exit

        false

# ============================================================================
# Debug Level Functions (stateless)
# ============================================================================

fn level_to_int(level: DebugLevel) -> i64:
    if level == DebugLevel.Off:
        return 0
    if level == DebugLevel.Error:
        return 1
    if level == DebugLevel.Warn:
        return 2
    if level == DebugLevel.Info:
        return 3
    if level == DebugLevel.Debug:
        return 4
    if level == DebugLevel.Trace:
        return 5
    0  # Default

fn should_print(current_level: DebugLevel, msg_level: DebugLevel) -> bool:
    val current_int = level_to_int(current_level)
    val msg_int = level_to_int(msg_level)
    msg_int <= current_int

# ============================================================================
# Debug Print
# ============================================================================

fn debug_print(current_level: DebugLevel, msg_level: DebugLevel, msg: text):
    if not should_print(current_level, msg_level):
        return

    var prefix = ""
    if msg_level == DebugLevel.Error:
        prefix = "[ERROR]"
    if msg_level == DebugLevel.Warn:
        prefix = "[WARN]"
    if msg_level == DebugLevel.Info:
        prefix = "[INFO]"
    if msg_level == DebugLevel.Debug:
        prefix = "[DEBUG]"
    if msg_level == DebugLevel.Trace:
        prefix = "[TRACE]"

    print "{prefix} {msg}"

# ============================================================================
# Debugger Factory
# ============================================================================

fn debugger_new() -> Debugger:
    Debugger(
        breakpoints: [],
        watch_expressions: [],
        call_stack: [],
        is_stepping: false,
        step_mode: StepMode.Continue,
        debug_level: DebugLevel.Off,
        trace_enabled: false
    )

# ============================================================================
# Command Handler
# ============================================================================

fn handle_debug_command(debugger: Debugger, cmd: text) -> text:
    """
    Handle debug commands. Returns result message or error message.
    """
    val parts = cmd.split(" ")
    if parts.len() == 0:
        return ""

    val command = parts[0]

    # break <file>:<line>
    if command == "break" or command == "b":
        if parts.len() < 2:
            return "ERROR: Usage: break <file>:<line>"
        val location = parts[1]
        val loc_parts = location.split(":")
        if loc_parts.len() != 2:
            return "ERROR: Invalid breakpoint format"
        val file = loc_parts[0]
        val line = int(loc_parts[1])
        debugger.add_breakpoint(file, line, "")
        return "Breakpoint set at {file}:{line}"

    # delete <file>:<line>
    if command == "delete" or command == "d":
        if parts.len() < 2:
            return "ERROR: Usage: delete <file>:<line>"
        val location = parts[1]
        val loc_parts = location.split(":")
        if loc_parts.len() != 2:
            return "ERROR: Invalid breakpoint format"
        val file = loc_parts[0]
        val line = int(loc_parts[1])
        debugger.remove_breakpoint(file, line)
        return "Breakpoint removed"

    # continue
    if command == "continue" or command == "c":
        debugger.continue_execution()
        return "Continuing..."

    # step
    if command == "step" or command == "s":
        debugger.step_into()
        return "Stepping into..."

    # next
    if command == "next" or command == "n":
        debugger.step_over()
        return "Stepping over..."

    # finish
    if command == "finish" or command == "f":
        debugger.step_out()
        return "Stepping out..."

    # backtrace
    if command == "backtrace" or command == "bt":
        val trace = debugger.get_stack_trace()
        var result = "Call stack:\n"
        for line in trace:
            result = result + line + "\n"
        return result

    # print <expr>
    if command == "print" or command == "p":
        if parts.len() < 2:
            return "ERROR: Usage: print <expr>"
        var expr = ""
        for i in 1..parts.len():
            if i > 1:
                expr = expr + " "
            expr = expr + parts[i]
        return "EXPR: {expr}"  # Simplified: just echo the expression

    # watch <expr>
    if command == "watch" or command == "w":
        if parts.len() < 2:
            return "ERROR: Usage: watch <expr>"
        var expr = ""
        for i in 1..parts.len():
            if i > 1:
                expr = expr + " "
            expr = expr + parts[i]
        debugger.add_watch(expr)
        return "Watch added"

    # help
    if command == "help" or command == "h":
        var help_text = "Debug commands:\n"
        help_text = help_text + "  break <file>:<line>  - Set breakpoint\n"
        help_text = help_text + "  delete <file>:<line> - Remove breakpoint\n"
        help_text = help_text + "  continue             - Continue execution\n"
        help_text = help_text + "  step                 - Step into\n"
        help_text = help_text + "  next                 - Step over\n"
        help_text = help_text + "  finish               - Step out\n"
        help_text = help_text + "  backtrace            - Show call stack\n"
        help_text = help_text + "  print <expr>         - Evaluate expression\n"
        help_text = help_text + "  watch <expr>         - Add watch expression\n"
        help_text = help_text + "  help                 - Show this help"
        return help_text

    # Unknown command
    "ERROR: Unknown command: {command}. Type 'help' for commands."

# ============================================================================
# Exports
# ============================================================================

export DebugLevel, StepMode, Breakpoint, StackFrame, Debugger
export level_to_int, should_print
export debug_print
export debugger_new
export handle_debug_command
