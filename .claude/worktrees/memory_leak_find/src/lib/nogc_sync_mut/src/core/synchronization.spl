# Synchronization Primitives - Pure Simple Implementation
#
# Provides basic synchronization primitives (single-threaded simulation)
# In a true multi-threaded environment, these would use OS-level synchronization

export Atomic, Mutex, RwLock, Semaphore

class Atomic:
    """Atomic integer operations (single-threaded simulation)."""
    value: i64

    me load() -> i64:
        """Load current value."""
        self.value

    me store(new_value: i64):
        """Store new value."""
        self.value = new_value

    me swap(new_value: i64) -> i64:
        """Swap value and return old value."""
        val old = self.value
        self.value = new_value
        old

    me fetch_add(delta: i64) -> i64:
        """Add delta and return old value."""
        val old = self.value
        self.value = self.value + delta
        old

    me fetch_sub(delta: i64) -> i64:
        """Subtract delta and return old value."""
        val old = self.value
        self.value = self.value - delta
        old

    me compare_exchange(expected: i64, desired: i64) -> bool:
        """Compare and exchange if value matches expected."""
        if self.value == expected:
            self.value = desired
            return true
        else:
            return false

impl Atomic:
    static fn create(initial: i64) -> Atomic:
        """Create new atomic with initial value."""
        Atomic(value: initial)

class Mutex:
    """Mutual exclusion lock (single-threaded simulation)."""
    locked: bool
    data: Any

    me lock():
        """Acquire the mutex lock."""
        self.locked = true

    me unlock():
        """Release the mutex lock."""
        self.locked = false

    me try_lock() -> bool:
        """Try to acquire lock, return true if successful."""
        if not self.locked:
            self.locked = true
            return true
        else:
            return false

    me with_lock(data: Any) -> Any:
        """Execute with lock held."""
        self.lock()
        self.data = data
        self.unlock()
        data

    fn into_inner() -> Any:
        """Get the inner value."""
        self.data

    fn is_locked() -> bool:
        """Check if mutex is locked."""
        self.locked

impl Mutex:
    static fn create(data: Any) -> Mutex:
        """Create new mutex with data."""
        Mutex(locked: false, data: data)

class RwLock:
    """Read-write lock (single-threaded simulation)."""
    readers: i64
    writer: bool
    data: Any

    me read() -> Any:
        """Acquire read lock and return data."""
        self.readers = self.readers + 1
        self.data

    me write(new_data: Any):
        """Acquire write lock and update data."""
        self.writer = true
        self.data = new_data
        self.writer = false

    me read_unlock():
        """Release read lock."""
        if self.readers > 0:
            self.readers = self.readers - 1

    fn into_inner() -> Any:
        """Get the inner value."""
        self.data

    fn is_locked() -> bool:
        """Check if lock is held."""
        self.readers > 0 or self.writer

impl RwLock:
    static fn create(data: Any) -> RwLock:
        """Create new read-write lock with data."""
        RwLock(readers: 0, writer: false, data: data)

class Semaphore:
    """Counting semaphore (single-threaded simulation)."""
    permits: i64
    max_permits: i64

    me acquire(n: i64 = 1):
        """Acquire n permits."""
        if self.permits >= n:
            self.permits = self.permits - n

    me release(n: i64 = 1):
        """Release n permits."""
        self.permits = self.permits + n
        if self.permits > self.max_permits:
            self.permits = self.max_permits

    me try_acquire(n: i64 = 1) -> bool:
        """Try to acquire n permits, return true if successful."""
        if self.permits >= n:
            self.permits = self.permits - n
            return true
        else:
            return false

    fn available_permits() -> i64:
        """Get number of available permits."""
        self.permits

impl Semaphore:
    static fn create(permits: i64) -> Semaphore:
        """Create new semaphore with initial permits."""
        Semaphore(permits: permits, max_permits: permits)
