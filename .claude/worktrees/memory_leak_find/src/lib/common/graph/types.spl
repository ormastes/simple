# Graph Data Structures and Type Definitions
#
# Purpose: Core graph type definitions and basic construction operations
#
# Contains:
# - Graph representation (tuple-based with adjacency list)
# - Graph constructors and type checking
# - Basic vertex/edge operations
# - Graph conversions (matrix/adjacency list)

# ============================================================================
# Core Data Structures
# ============================================================================
# Graph: (directed: bool, weighted: bool, num_vertices: i64, edges: list, adj_list: map)
# Edge: (from: i64, to: i64, weight: f64)
# AdjList: map<i64, list<(to: i64, weight: f64)>>

# Create an empty graph
fn graph_new(directed: bool, weighted: bool) -> tuple:
    (directed, weighted, 0, [], {})

# Create a graph with n vertices
fn graph_with_vertices(directed: bool, weighted: bool, n: i64) -> tuple:
    var adj_list = {}
    var i = 0
    while i < n:
        adj_list = adj_list.set(i, [])
        i = i + 1
    (directed, weighted, n, [], adj_list)

# Get number of vertices
fn graph_num_vertices(graph: tuple) -> i64:
    graph.2

# Get number of edges
fn graph_num_edges(graph: tuple) -> i64:
    graph.3.len()

# Check if graph is directed
fn graph_is_directed(graph: tuple) -> bool:
    graph.0

# Check if graph is weighted
fn graph_is_weighted(graph: tuple) -> bool:
    graph.1

# Get all edges
fn graph_edges(graph: tuple) -> list:
    graph.3

# Get adjacency list
fn graph_adj_list(graph: tuple) -> map:
    graph.4

# ============================================================================
# Graph Construction Operations
# ============================================================================

# Add a vertex to the graph
fn graph_add_vertex(graph: tuple) -> tuple:
    var directed = graph.0
    var weighted = graph.1
    var num_vertices = graph.2
    var edges = graph.3
    var adj_list = graph.4

    adj_list = adj_list.set(num_vertices, [])
    (directed, weighted, num_vertices + 1, edges, adj_list)

# Add an edge to the graph
fn graph_add_edge(graph: tuple, from: i64, to: i64, weight: f64) -> tuple:
    var directed = graph.0
    var weighted = graph.1
    var num_vertices = graph.2
    var edges = graph.3
    var adj_list = graph.4

    # Ensure vertices exist
    var max_vertex = from
    if to > max_vertex:
        max_vertex = to

    while num_vertices <= max_vertex:
        adj_list = adj_list.set(num_vertices, [])
        num_vertices = num_vertices + 1

    # Add edge to edge list
    var edge = (from, to, weight)
    edges = edges.append(edge)

    # Update adjacency list
    var from_neighbors = adj_list.get(from)
    from_neighbors = from_neighbors.append((to, weight))
    adj_list = adj_list.set(from, from_neighbors)

    # If undirected, add reverse edge
    if !directed:
        var to_neighbors = adj_list.get(to)
        to_neighbors = to_neighbors.append((from, weight))
        adj_list = adj_list.set(to, to_neighbors)

    (directed, weighted, num_vertices, edges, adj_list)

# Add an unweighted edge (weight = 1.0)
fn graph_add_edge_unweighted(graph: tuple, from: i64, to: i64) -> tuple:
    graph_add_edge(graph, from, to, 1.0)

# Remove a vertex from the graph
fn graph_remove_vertex(graph: tuple, vertex: i64) -> tuple:
    var directed = graph.0
    var weighted = graph.1
    var num_vertices = graph.2
    var edges = graph.3
    var adj_list = graph.4

    # Remove all edges involving this vertex
    var new_edges = []
    var i = 0
    while i < edges.len():
        var edge = edges.get(i)
        var from = edge.0
        var to = edge.1
        if from != vertex && to != vertex:
            new_edges = new_edges.append(edge)
        i = i + 1

    # Rebuild adjacency list
    var new_adj_list = {}
    var v = 0
    while v < num_vertices:
        if v != vertex:
            var neighbors = adj_list.get(v)
            var filtered_neighbors = []
            var j = 0
            while j < neighbors.len():
                var neighbor = neighbors.get(j)
                if neighbor.0 != vertex:
                    filtered_neighbors = filtered_neighbors.append(neighbor)
                j = j + 1
            new_adj_list = new_adj_list.set(v, filtered_neighbors)
        v = v + 1

    (directed, weighted, num_vertices, new_edges, new_adj_list)

# Remove an edge from the graph
fn graph_remove_edge(graph: tuple, from: i64, to: i64) -> tuple:
    var directed = graph.0
    var weighted = graph.1
    var num_vertices = graph.2
    var edges = graph.3
    var adj_list = graph.4

    # Remove from edge list
    var new_edges = []
    var i = 0
    while i < edges.len():
        var edge = edges.get(i)
        var edge_from = edge.0
        var edge_to = edge.1
        var keep = true
        if edge_from == from && edge_to == to:
            keep = false
        if !directed && edge_from == to && edge_to == from:
            keep = false
        if keep:
            new_edges = new_edges.append(edge)
        i = i + 1

    # Remove from adjacency list
    var from_neighbors = adj_list.get(from)
    var new_from_neighbors = []
    var j = 0
    while j < from_neighbors.len():
        var neighbor = from_neighbors.get(j)
        if neighbor.0 != to:
            new_from_neighbors = new_from_neighbors.append(neighbor)
        j = j + 1
    adj_list = adj_list.set(from, new_from_neighbors)

    if !directed:
        var to_neighbors = adj_list.get(to)
        var new_to_neighbors = []
        var k = 0
        while k < to_neighbors.len():
            var neighbor = to_neighbors.get(k)
            if neighbor.0 != from:
                new_to_neighbors = new_to_neighbors.append(neighbor)
            k = k + 1
        adj_list = adj_list.set(to, new_to_neighbors)

    (directed, weighted, num_vertices, new_edges, adj_list)

# Get neighbors of a vertex
fn graph_neighbors(graph: tuple, vertex: i64) -> list:
    var adj_list = graph.4
    var neighbors = adj_list.get(vertex)
    if neighbors == nil:
        []
    else:
        neighbors

# ============================================================================
# Graph Conversions
# ============================================================================

# Convert adjacency list to adjacency matrix
fn graph_to_matrix(graph: tuple) -> list:
    var num_vertices = graph.2
    var adj_list = graph.4
    var matrix = []

    var i = 0
    while i < num_vertices:
        var row = []
        var j = 0
        while j < num_vertices:
            row = row.append(0.0)
            j = j + 1
        matrix = matrix.append(row)
        i = i + 1

    # Fill matrix with edge weights
    var k = 0
    while k < num_vertices:
        var neighbors = adj_list.get(k)
        if neighbors != nil:
            var m = 0
            while m < neighbors.len():
                var neighbor = neighbors.get(m)
                var to = neighbor.0
                var weight = neighbor.1
                var row = matrix.get(k)
                row = row.set(to, weight)
                matrix = matrix.set(k, row)
                m = m + 1
        k = k + 1

    matrix

# Create graph from adjacency matrix
fn graph_from_matrix(matrix: list, directed: bool, weighted: bool) -> tuple:
    var n = matrix.len()
    var graph = graph_with_vertices(directed, weighted, n)

    var i = 0
    while i < n:
        var row = matrix.get(i)
        var j = 0
        while j < row.len():
            var weight = row.get(j)
            if weight != 0.0:
                graph = graph_add_edge(graph, i, j, weight)
            j = j + 1
        i = i + 1

    graph

# Export graph to edge list format (list of (from, to, weight) tuples)
fn graph_to_edge_list(graph: tuple) -> list:
    graph.3

# Create graph from edge list
fn graph_from_edge_list(edges: list, directed: bool, weighted: bool) -> tuple:
    var graph = graph_new(directed, weighted)

    var i = 0
    while i < edges.len():
        var edge = edges.get(i)
        graph = graph_add_edge(graph, edge.0, edge.1, edge.2)
        i = i + 1

    graph

export *
