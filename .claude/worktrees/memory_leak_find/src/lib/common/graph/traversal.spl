# Graph Traversal Algorithms
#
# Purpose: Breadth-first search (BFS) and depth-first search (DFS) implementations
#
# Contains:
# - DFS traversal (basic and with ordering)
# - BFS traversal (basic and with distances)
# - Shortest path (BFS for unweighted graphs)
# - Topological sort

# Import types module for graph_neighbors
mod graph.types

# ============================================================================
# Graph Traversal: DFS (Depth-First Search)
# ============================================================================

# DFS traversal starting from a vertex (returns visited list)
fn graph_dfs(graph: tuple, start: i64) -> list:
    var visited = []
    var stack = [start]
    var visited_set = {}

    while stack.len() > 0:
        var vertex = stack.get(stack.len() - 1)
        stack = stack.slice(0, stack.len() - 1)

        var is_visited = visited_set.get(vertex)
        if is_visited == nil:
            visited = visited.append(vertex)
            visited_set = visited_set.set(vertex, true)

            var neighbors = graph_neighbors(graph, vertex)
            var i = neighbors.len() - 1
            while i >= 0:
                var neighbor = neighbors.get(i)
                stack = stack.append(neighbor.0)
                i = i - 1

    visited

# DFS with pre-order and post-order callbacks (returns (pre_order, post_order))
fn graph_dfs_with_order(graph: tuple, start: i64) -> tuple:
    var pre_order = []
    var post_order = []
    var visited_set = {}
    var stack = [(start, false)]

    while stack.len() > 0:
        var item = stack.get(stack.len() - 1)
        stack = stack.slice(0, stack.len() - 1)
        var vertex = item.0
        var post = item.1

        if post:
            post_order = post_order.append(vertex)
        else:
            var is_visited = visited_set.get(vertex)
            if is_visited == nil:
                visited_set = visited_set.set(vertex, true)
                pre_order = pre_order.append(vertex)
                stack = stack.append((vertex, true))

                var neighbors = graph_neighbors(graph, vertex)
                var i = neighbors.len() - 1
                while i >= 0:
                    var neighbor = neighbors.get(i)
                    stack = stack.append((neighbor.0, false))
                    i = i - 1

    (pre_order, post_order)

# DFS for all vertices (handles disconnected graphs)
fn graph_dfs_all(graph: tuple) -> list:
    var visited_set = {}
    var all_visited = []
    var num_vertices = graph.2

    var i = 0
    while i < num_vertices:
        var is_visited = visited_set.get(i)
        if is_visited == nil:
            var component = graph_dfs(graph, i)
            var j = 0
            while j < component.len():
                var vertex = component.get(j)
                visited_set = visited_set.set(vertex, true)
                all_visited = all_visited.append(vertex)
                j = j + 1
        i = i + 1

    all_visited

# ============================================================================
# Graph Traversal: BFS (Breadth-First Search)
# ============================================================================

# BFS traversal starting from a vertex (returns visited list)
fn graph_bfs(graph: tuple, start: i64) -> list:
    var visited = []
    var queue = [start]
    var visited_set = {}
    visited_set = visited_set.set(start, true)

    while queue.len() > 0:
        var vertex = queue.get(0)
        queue = queue.slice(1, queue.len())
        visited = visited.append(vertex)

        var neighbors = graph_neighbors(graph, vertex)
        var i = 0
        while i < neighbors.len():
            var neighbor = neighbors.get(i)
            var neighbor_id = neighbor.0
            var is_visited = visited_set.get(neighbor_id)
            if is_visited == nil:
                visited_set = visited_set.set(neighbor_id, true)
                queue = queue.append(neighbor_id)
            i = i + 1

    visited

# BFS with distance tracking (returns map<vertex, distance>)
fn graph_bfs_distances(graph: tuple, start: i64) -> map:
    var distances = {}
    var queue = [start]
    distances = distances.set(start, 0)

    while queue.len() > 0:
        var vertex = queue.get(0)
        queue = queue.slice(1, queue.len())
        var current_dist = distances.get(vertex)

        var neighbors = graph_neighbors(graph, vertex)
        var i = 0
        while i < neighbors.len():
            var neighbor = neighbors.get(i)
            var neighbor_id = neighbor.0
            var has_dist = distances.get(neighbor_id)
            if has_dist == nil:
                distances = distances.set(neighbor_id, current_dist + 1)
                queue = queue.append(neighbor_id)
            i = i + 1

    distances

# BFS for shortest path (unweighted graphs)
fn graph_bfs_shortest_path(graph: tuple, start: i64, end: i64) -> list:
    var parent = {}
    var queue = [start]
    var visited = {}
    visited = visited.set(start, true)
    parent = parent.set(start, -1)

    var found = false
    while queue.len() > 0 && !found:
        var vertex = queue.get(0)
        queue = queue.slice(1, queue.len())

        if vertex == end:
            found = true
        else:
            var neighbors = graph_neighbors(graph, vertex)
            var i = 0
            while i < neighbors.len():
                var neighbor = neighbors.get(i)
                var neighbor_id = neighbor.0
                var is_visited = visited.get(neighbor_id)
                if is_visited == nil:
                    visited = visited.set(neighbor_id, true)
                    parent = parent.set(neighbor_id, vertex)
                    queue = queue.append(neighbor_id)
                i = i + 1

    if !found:
        return []

    # Reconstruct path
    var path = []
    var current = end
    while current != -1:
        path = [current].concat(path)
        current = parent.get(current)

    path

# ============================================================================
# Topological Sort
# ============================================================================

# Topological sort (for DAGs - Directed Acyclic Graphs)
# Returns list of vertices in topological order, or empty list if cycle exists
fn graph_topological_sort(graph: tuple) -> list:
    if graph_has_cycle_directed(graph):
        return []

    var visited = {}
    var stack = []
    var num_vertices = graph.2

    fn dfs_topo(vertex: i64) -> bool:
        visited = visited.set(vertex, true)

        var neighbors = graph_neighbors(graph, vertex)
        var i = 0
        while i < neighbors.len():
            var neighbor = neighbors.get(i)
            var neighbor_id = neighbor.0
            var is_visited = visited.get(neighbor_id)
            if is_visited == nil:
                dfs_topo(neighbor_id)
            i = i + 1

        stack = [vertex].concat(stack)
        true

    var j = 0
    while j < num_vertices:
        var is_visited = visited.get(j)
        if is_visited == nil:
            dfs_topo(j)
        j = j + 1

    stack

# Kahn's algorithm for topological sort (using in-degrees)
fn graph_topological_sort_kahn(graph: tuple) -> list:
    var num_vertices = graph.2
    var in_degree = {}

    # Calculate in-degrees
    var i = 0
    while i < num_vertices:
        in_degree = in_degree.set(i, 0)
        i = i + 1

    var j = 0
    while j < num_vertices:
        var neighbors = graph_neighbors(graph, j)
        var k = 0
        while k < neighbors.len():
            var neighbor = neighbors.get(k)
            var neighbor_id = neighbor.0
            var deg = in_degree.get(neighbor_id)
            in_degree = in_degree.set(neighbor_id, deg + 1)
            k = k + 1
        j = j + 1

    # Queue vertices with in-degree 0
    var queue = []
    var m = 0
    while m < num_vertices:
        if in_degree.get(m) == 0:
            queue = queue.append(m)
        m = m + 1

    var result = []
    while queue.len() > 0:
        var vertex = queue.get(0)
        queue = queue.slice(1, queue.len())
        result = result.append(vertex)

        var neighbors = graph_neighbors(graph, vertex)
        var n = 0
        while n < neighbors.len():
            var neighbor = neighbors.get(n)
            var neighbor_id = neighbor.0
            var deg = in_degree.get(neighbor_id)
            deg = deg - 1
            in_degree = in_degree.set(neighbor_id, deg)
            if deg == 0:
                queue = queue.append(neighbor_id)
            n = n + 1

    if result.len() != num_vertices:
        []
    else:
        result

# ============================================================================
# Helper Functions (Internal)
# ============================================================================

# Detect cycle in directed graph using DFS with colors
fn graph_has_cycle_directed(graph: tuple) -> bool:
    var white = 0
    var gray = 1
    var black = 2
    var color = {}
    var num_vertices = graph.2

    var i = 0
    while i < num_vertices:
        color = color.set(i, white)
        i = i + 1

    fn dfs_cycle_directed(vertex: i64) -> bool:
        color = color.set(vertex, gray)

        var neighbors = graph_neighbors(graph, vertex)
        var j = 0
        while j < neighbors.len():
            var neighbor = neighbors.get(j)
            var neighbor_id = neighbor.0
            var neighbor_color = color.get(neighbor_id)

            if neighbor_color == gray:
                return true

            if neighbor_color == white:
                if dfs_cycle_directed(neighbor_id):
                    return true

            j = j + 1

        color = color.set(vertex, black)
        false

    var k = 0
    while k < num_vertices:
        var vertex_color = color.get(k)
        if vertex_color == white:
            if dfs_cycle_directed(k):
                return true
        k = k + 1

    false

export *
