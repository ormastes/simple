# XML XPath Module
# Provides XPath-like query and search functionality for XML elements

# =============================================================================
# Querying - Find Operations
# =============================================================================

fn xml_find_by_tag(element: tuple, tag_name: text) -> list:
    # Find all descendant elements with matching tag name
    var results = []
    val elem_tag = xml_get_tag(element)

    if elem_tag == tag_name:
        results = results.append(element)

    val children = xml_get_children(element)
    var i = 0
    val len = children.len()

    while i < len:
        val child = children[i]
        val child_results = xml_find_by_tag(child, tag_name)
        var j = 0
        val child_len = child_results.len()

        while j < child_len:
            results = results.append(child_results[j])
            j = j + 1

        i = i + 1

    results

fn xml_find_first_by_tag(element: tuple, tag_name: text) -> tuple:
    # Find first descendant element with matching tag name
    val results = xml_find_by_tag(element, tag_name)
    var first_elem = xml_element_simple("")

    if results.len() > 0:
        first_elem = results[0]

    first_elem

fn xml_find_by_attr(element: tuple, attr_name: text, attr_value: text) -> list:
    # Find all descendant elements with matching attribute
    var results = []
    val elem_attr = xml_get_attr(element, attr_name)

    if elem_attr == attr_value:
        results = results.append(element)

    val children = xml_get_children(element)
    var i = 0
    val len = children.len()

    while i < len:
        val child = children[i]
        val child_results = xml_find_by_attr(child, attr_name, attr_value)
        var j = 0
        val child_len = child_results.len()

        while j < child_len:
            results = results.append(child_results[j])
            j = j + 1

        i = i + 1

    results

fn xml_find_first_by_attr(element: tuple, attr_name: text, attr_value: text) -> tuple:
    # Find first descendant element with matching attribute
    val results = xml_find_by_attr(element, attr_name, attr_value)
    var first_elem = xml_element_simple("")

    if results.len() > 0:
        first_elem = results[0]

    first_elem

fn xml_get_descendants(element: tuple) -> list:
    # Get all descendant elements
    var results = []
    val children = xml_get_children(element)
    var i = 0
    val len = children.len()

    while i < len:
        val child = children[i]
        results = results.append(child)

        val child_descendants = xml_get_descendants(child)
        var j = 0
        val desc_len = child_descendants.len()

        while j < desc_len:
            results = results.append(child_descendants[j])
            j = j + 1

        i = i + 1

    results

fn xml_filter_by_tag(elements: list, tag_name: text) -> list:
    # Filter list of elements by tag name
    var results = []
    var i = 0
    val len = elements.len()

    while i < len:
        val elem = elements[i]
        val elem_tag = xml_get_tag(elem)

        if elem_tag == tag_name:
            results = results.append(elem)

        i = i + 1

    results

# =============================================================================
# XPath-like Simple Query
# =============================================================================

fn xml_query(element: tuple, path: text) -> list:
    # Simple XPath-like query
    # Supports: "//tag", "tag", "tag[@attr='value']", "tag/child"

    var results = []

    # Check for descendant search
    if path.starts_with("//"):
        val tag_part = path.slice(2, path.len())
        val bracket_pos = tag_part.index("[")

        var tag_name = tag_part
        var attr_filter = ""

        if bracket_pos >= 0:
            tag_name = tag_part.slice(0, bracket_pos)
            val bracket_end = tag_part.index("]")
            var filter_len = 0
            if bracket_end >= 0:
                filter_len = bracket_end
            else:
                filter_len = tag_part.len()
            attr_filter = tag_part.slice(bracket_pos + 1, filter_len)

        results = xml_find_by_tag(element, tag_name)

        # Apply attribute filter
        if attr_filter.len() > 0:
            val attr_parts = xml_parse_attr_filter(attr_filter)
            val attr_name = attr_parts.0
            val attr_value = attr_parts.1
            results = xml_filter_by_attr_value(results, attr_name, attr_value)
    elif path.contains("/"):
        # Path navigation
        val parts = path.split("/")
        var current = [element]
        var i = 0
        val len = parts.len()

        while i < len:
            val part = parts[i]
            var next_elements = []
            var j = 0
            val curr_len = current.len()

            while j < curr_len:
                val elem = current[j]
                val children = xml_get_children(elem)
                val filtered = xml_filter_by_tag(children, part)
                var k = 0
                val filt_len = filtered.len()

                while k < filt_len:
                    next_elements = next_elements.append(filtered[k])
                    k = k + 1

                j = j + 1

            current = next_elements
            i = i + 1

        results = current
    else:
        # Direct child search
        val children = xml_get_children(element)
        results = xml_filter_by_tag(children, path)

    results

fn xml_parse_attr_filter(filter_str: text) -> tuple:
    # Parse attribute filter like "@id='123'"
    # Returns: (attr_name, attr_value)

    var attr_name = ""
    var attr_value = ""

    if filter_str.starts_with("@"):
        val without_at = filter_str.slice(1, filter_str.len())
        val eq_pos = without_at.index("=")

        if eq_pos >= 0:
            attr_name = without_at.slice(0, eq_pos)
            val value_part = without_at.slice(eq_pos + 1, without_at.len())

            # Remove quotes
            var clean_value = value_part
            if value_part.starts_with("'") or value_part.starts_with("\""):
                clean_value = value_part.slice(1, value_part.len())
            if clean_value.ends_with("'") or clean_value.ends_with("\""):
                val new_len = clean_value.len() - 1
                clean_value = clean_value.slice(0, new_len)

            attr_value = clean_value

    (attr_name, attr_value)

fn xml_filter_by_attr_value(elements: list, attr_name: text, attr_value: text) -> list:
    # Filter elements by attribute value
    var results = []
    var i = 0
    val len = elements.len()

    while i < len:
        val elem = elements[i]
        val elem_attr = xml_get_attr(elem, attr_name)

        if elem_attr == attr_value:
            results = results.append(elem)

        i = i + 1

    results

fn xml_query_first(element: tuple, path: text) -> tuple:
    # Get first element matching query
    val results = xml_query(element, path)
    var first_elem = xml_element_simple("")

    if results.len() > 0:
        first_elem = results[0]

    first_elem

# =============================================================================
# Helper Functions
# =============================================================================

fn xml_get_tag(element: tuple) -> text:
    element.0

fn xml_get_children(element: tuple) -> list:
    element.2

fn xml_get_attr(element: tuple, attr_name: text) -> text:
    val attrs = xml_get_attributes(element)
    var result = ""
    var i = 0
    val len = attrs.len()
    var found = false

    while i < len and not found:
        val attr = attrs[i]
        val name = attr.0
        val value = attr.1
        if name == attr_name:
            result = value
            found = true
        i = i + 1

    result

fn xml_get_attributes(element: tuple) -> list:
    element.1

fn xml_element_simple(tag: text) -> tuple:
    val empty_attrs = []
    val empty_children = []
    xml_element(tag, empty_attrs, empty_children, "")

fn xml_element(tag: text, attributes: list, children: list, text_content: text) -> tuple:
    (tag, attributes, children, text_content)
