# XML Types Module
# Provides data structures and type creation functions for XML processing

# =============================================================================
# Data Structure Documentation
# =============================================================================

# XmlElement: (tag: text, attributes: List<(text, text)>, children: List<XmlElement>, text: text)
# Using tuple format to avoid runtime generics issues

# XmlToken: (type: text, value: text, line: i64, col: i64)
# Token types: "open_tag", "close_tag", "text", "cdata", "comment", "pi", "doctype"

# Namespace: (prefix: text, uri: text)

# =============================================================================
# Core Element Creation
# =============================================================================

fn xml_element(tag: text, attributes: list, children: list, text_content: text) -> tuple:
    # Create a new XML element
    (tag, attributes, children, text_content)

fn xml_element_simple(tag: text) -> tuple:
    # Create a simple element with no attributes, children, or text
    val empty_attrs = []
    val empty_children = []
    xml_element(tag, empty_attrs, empty_children, "")

fn xml_element_with_text(tag: text, text_content: text) -> tuple:
    # Create an element with text content
    val empty_attrs = []
    val empty_children = []
    xml_element(tag, empty_attrs, empty_children, text_content)

fn xml_element_with_attrs(tag: text, attributes: list) -> tuple:
    # Create an element with attributes
    val empty_children = []
    xml_element(tag, attributes, empty_children, "")

fn xml_element_with_children(tag: text, children: list) -> tuple:
    # Create an element with children
    val empty_attrs = []
    xml_element(tag, empty_attrs, children, "")

# =============================================================================
# Element Accessors
# =============================================================================

fn xml_get_tag(element: tuple) -> text:
    # Get the tag name from an element
    element.0

fn xml_get_attributes(element: tuple) -> list:
    # Get all attributes from an element
    element.1

fn xml_get_children(element: tuple) -> list:
    # Get all children from an element
    element.2

fn xml_get_text(element: tuple) -> text:
    # Get the text content from an element
    element.3

fn xml_set_tag(element: tuple, new_tag: text) -> tuple:
    # Set a new tag name
    val attrs = xml_get_attributes(element)
    val children = xml_get_children(element)
    val text_val = xml_get_text(element)
    xml_element(new_tag, attrs, children, text_val)

fn xml_set_attributes(element: tuple, new_attrs: list) -> tuple:
    # Set new attributes
    val tag = xml_get_tag(element)
    val children = xml_get_children(element)
    val text_val = xml_get_text(element)
    xml_element(tag, new_attrs, children, text_val)

fn xml_set_children(element: tuple, new_children: list) -> tuple:
    # Set new children
    val tag = xml_get_tag(element)
    val attrs = xml_get_attributes(element)
    val text_val = xml_get_text(element)
    xml_element(tag, attrs, new_children, text_val)

fn xml_set_text(element: tuple, new_text: text) -> tuple:
    # Set new text content
    val tag = xml_get_tag(element)
    val attrs = xml_get_attributes(element)
    val children = xml_get_children(element)
    xml_element(tag, attrs, children, new_text)

# =============================================================================
# Namespace Support
# =============================================================================

fn xml_create_namespace(prefix: text, uri: text) -> tuple:
    # Create a namespace tuple
    (prefix, uri)

fn xml_get_namespace_prefix(ns: tuple) -> text:
    # Get namespace prefix
    ns.0

fn xml_get_namespace_uri(ns: tuple) -> text:
    # Get namespace URI
    ns.1

fn xml_get_qualified_name(prefix: text, local_name: text) -> text:
    # Get qualified name with namespace prefix
    var qname = local_name
    if prefix.len() > 0:
        qname = prefix + ":" + local_name
    qname

fn xml_split_qualified_name(qname: text) -> tuple:
    # Split qualified name into (prefix, local_name)
    val colon_pos = qname.index(":")
    var prefix = ""
    var local_name = qname

    if colon_pos >= 0:
        prefix = qname.slice(0, colon_pos)
        local_name = qname.slice(colon_pos + 1, qname.len())

    (prefix, local_name)
