# XML Serializer Module
# Provides XML serialization and formatting functionality

# =============================================================================
# Serialization
# =============================================================================

fn xml_to_string(element: tuple) -> text:
    # Convert element to XML string
    xml_to_string_indent(element, 0, false)

fn xml_to_string_pretty(element: tuple) -> text:
    # Convert element to pretty-printed XML string
    xml_to_string_indent(element, 0, true)

fn xml_to_string_indent(element: tuple, indent_level: i64, pretty: bool) -> text:
    # Convert element to XML string with indentation
    val tag = xml_get_tag(element)
    val attrs = xml_get_attributes(element)
    val children = xml_get_children(element)
    val text_val = xml_get_text(element)

    # Build indent string
    var indent = ""
    if pretty:
        var i = 0
        while i < indent_level:
            indent = indent + "  "
            i = i + 1

    # Build opening tag
    var result = indent + "<" + tag

    # Add attributes
    var i = 0
    val attr_len = attrs.len()
    while i < attr_len:
        val attr = attrs[i]
        val name = attr.0
        val value = attr.1
        val encoded_value = xml_encode_attr_value(value)
        result = result + " " + name + "=\"" + encoded_value + "\""
        i = i + 1

    # Check if self-closing
    val has_content = xml_has_text(element)
    val has_kids = xml_has_children(element)
    var is_self_closing = false
    if not has_content and not has_kids:
        is_self_closing = true

    if is_self_closing:
        result = result + " />"
        if pretty:
            result = result + "\n"
    else:
        result = result + ">"

        # Add text content
        if has_content:
            val encoded_text = xml_encode_entities(text_val)
            result = result + encoded_text

        # Add children
        if has_kids:
            if pretty and not has_content:
                result = result + "\n"

            var j = 0
            val child_len = children.len()
            while j < child_len:
                val child = children[j]
                val next_indent = indent_level + 1
                val child_str = xml_to_string_indent(child, next_indent, pretty)
                result = result + child_str
                j = j + 1

            if pretty and not has_content:
                result = result + indent

        # Add closing tag
        result = result + "</" + tag + ">"
        if pretty:
            result = result + "\n"

    result

fn xml_format(xml_str: text) -> text:
    # Format XML string with pretty printing
    val elem = xml_parse(xml_str)
    xml_to_string_pretty(elem)

fn xml_to_compact_string(element: tuple) -> text:
    # Convert to string without any whitespace
    val xml_str = xml_to_string(element)
    var compact = xml_str.replace("\n", "")
    compact = compact.replace("\r", "")
    compact = compact.replace("\t", "")

    # Remove spaces between tags
    while compact.contains("> <"):
        compact = compact.replace("> <", "><")

    compact

# =============================================================================
# Helper Functions
# =============================================================================

fn xml_get_tag(element: tuple) -> text:
    element.0

fn xml_get_attributes(element: tuple) -> list:
    element.1

fn xml_get_children(element: tuple) -> list:
    element.2

fn xml_get_text(element: tuple) -> text:
    element.3

fn xml_has_text(element: tuple) -> bool:
    val text_val = xml_get_text(element)
    text_val.len() > 0

fn xml_has_children(element: tuple) -> bool:
    val count = xml_get_child_count(element)
    count > 0

fn xml_get_child_count(element: tuple) -> i64:
    val children = xml_get_children(element)
    children.len()

fn xml_encode_attr_value(text_val: text) -> text:
    xml_encode_entities(text_val)

fn xml_encode_entities(text_val: text) -> text:
    # Encode XML entities
    var result = text_val
    result = result.replace("&", "&amp;")
    result = result.replace("<", "&lt;")
    result = result.replace(">", "&gt;")
    result = result.replace("\"", "&quot;")
    result = result.replace("'", "&apos;")
    result

fn xml_parse(xml_str: text) -> tuple:
    # Placeholder - should import from parser module
    val empty_attrs = []
    val empty_children = []
    ("", empty_attrs, empty_children, "")
