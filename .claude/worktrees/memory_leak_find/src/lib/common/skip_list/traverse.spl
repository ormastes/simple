# Skip List Traversal and Iteration Operations
#
# This module provides functions for iterating over skip lists and extracting data.

import types

# Create iterator (returns current node index)
fn sl_iter_begin(skiplist: tuple) -> i64:
    var nodes = types.sl_get_nodes(skiplist)
    var head_idx = types.sl_get_head_idx(skiplist)
    var head_node = nodes[head_idx]
    var first_idx = types.sl_node_get_forward(head_node, 0)
    first_idx

# Check if iterator is at end
fn sl_iter_is_end(iter_idx: i64) -> i64:
    if iter_idx == types.NIL_REF:
        1
    else:
        0

# Get key at iterator position
fn sl_iter_key(skiplist: tuple, iter_idx: i64) -> i64:
    if iter_idx == types.NIL_REF:
        return 0
    var nodes = types.sl_get_nodes(skiplist)
    var node = nodes[iter_idx]
    var key = types.sl_node_key(node)
    key

# Get value at iterator position
fn sl_iter_value(skiplist: tuple, iter_idx: i64) -> i64:
    if iter_idx == types.NIL_REF:
        return 0
    var nodes = types.sl_get_nodes(skiplist)
    var node = nodes[iter_idx]
    var value = types.sl_node_value(node)
    value

# Advance iterator to next position
fn sl_iter_next(skiplist: tuple, iter_idx: i64) -> i64:
    if iter_idx == types.NIL_REF:
        return types.NIL_REF
    var nodes = types.sl_get_nodes(skiplist)
    var node = nodes[iter_idx]
    var next_idx = types.sl_node_get_forward(node, 0)
    next_idx

# Get key-value pair at iterator position
fn sl_iter_pair(skiplist: tuple, iter_idx: i64) -> tuple:
    var key = sl_iter_key(skiplist, iter_idx)
    var value = sl_iter_value(skiplist, iter_idx)
    (key, value)

# Get all key-value pairs in sorted order
fn sl_to_pairs(skiplist: tuple) -> list:
    var nodes = types.sl_get_nodes(skiplist)
    var head_idx = types.sl_get_head_idx(skiplist)
    var head_node = nodes[head_idx]
    var current_idx = types.sl_node_get_forward(head_node, 0)

    var result = []
    while current_idx != types.NIL_REF:
        var current_node = nodes[current_idx]
        var key = types.sl_node_key(current_node)
        var value = types.sl_node_value(current_node)
        var pair = (key, value)
        result = result + [pair]
        current_idx = types.sl_node_get_forward(current_node, 0)

    result

# Get all keys in sorted order
fn sl_keys(skiplist: tuple) -> list:
    var pairs = sl_to_pairs(skiplist)
    var result = []
    var i = 0
    while i < pairs.len():
        var pair = pairs[i]
        var key = pair[0]
        result = result + [key]
        i = i + 1
    result

# Get all values in sorted order by key
fn sl_values(skiplist: tuple) -> list:
    var pairs = sl_to_pairs(skiplist)
    var result = []
    var i = 0
    while i < pairs.len():
        var pair = pairs[i]
        var value = pair[1]
        result = result + [value]
        i = i + 1
    result

# Get minimum key
fn sl_min_key(skiplist: tuple) -> i64:
    var nodes = types.sl_get_nodes(skiplist)
    var head_idx = types.sl_get_head_idx(skiplist)
    var head_node = nodes[head_idx]
    var first_idx = types.sl_node_get_forward(head_node, 0)

    if first_idx == types.NIL_REF:
        return types.MIN_KEY

    var first_node = nodes[first_idx]
    var key = types.sl_node_key(first_node)
    key

# Get maximum key
fn sl_max_key(skiplist: tuple) -> i64:
    var nodes = types.sl_get_nodes(skiplist)
    var head_idx = types.sl_get_head_idx(skiplist)
    var current_level = types.sl_get_level(skiplist)

    var current_idx = head_idx
    var lvl = current_level

    while lvl >= 0:
        var current_node = nodes[current_idx]
        var next_idx = types.sl_node_get_forward(current_node, lvl)

        while next_idx != types.NIL_REF:
            current_idx = next_idx
            current_node = nodes[current_idx]
            next_idx = types.sl_node_get_forward(current_node, lvl)

        lvl = lvl - 1

    if current_idx == head_idx:
        return types.MAX_KEY

    var last_node = nodes[current_idx]
    var key = types.sl_node_key(last_node)
    key

# Get first key-value pair
fn sl_first(skiplist: tuple) -> tuple:
    var nodes = types.sl_get_nodes(skiplist)
    var head_idx = types.sl_get_head_idx(skiplist)
    var head_node = nodes[head_idx]
    var first_idx = types.sl_node_get_forward(head_node, 0)

    if first_idx == types.NIL_REF:
        return (0, 0)

    var first_node = nodes[first_idx]
    var key = types.sl_node_key(first_node)
    var value = types.sl_node_value(first_node)
    (key, value)

# Get last key-value pair
fn sl_last(skiplist: tuple) -> tuple:
    var max_k = sl_max_key(skiplist)
    import search
    var value = search.sl_get(skiplist, max_k)
    (max_k, value)
