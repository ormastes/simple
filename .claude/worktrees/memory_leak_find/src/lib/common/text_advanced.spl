# Text â€” Advanced Operations
#
# Extracted from text.spl. Contains:
# - Advanced tokenization (split_whitespace, extract_words)
# - Line processing (trim_lines, number_lines, prefix_lines, suffix_lines)
# - Case conversion (to_title_case, to_snake_case, to_camel_case)
# - Word operations (word_count, word_wrap, reverse_words, longest_word)
# - Character analysis (char_frequency, most_common_char, most_common_words)
# - Indentation (detect_indent, normalize_indent, dedent_lines)
# - String similarity (levenshtein_distance, hamming_distance)
# - Advanced joining (join_with_separator, join_natural)
# - JSON escaping (escape_json)

use lib.common.text.{text_is_alphanumeric, text_is_alpha, is_uppercase_char, is_lowercase_char, char_at, split_whitespace}

# ============================================================================
# Advanced Tokenization (from text_utils)
# ============================================================================

fn split_whitespace(text: text):
    """Split text by whitespace, removing empty tokens.

    Example:
        split_whitespace("hello   world  \n foo")  # ["hello", "world", "foo"]
    """
    val parts = text.split(" ")
    var result = []

    for part in parts:
        val trimmed = part.trim()
        if trimmed.len() > 0:
            result.push(trimmed)

    result

fn extract_words(text: text):
    """Extract words (alphanumeric sequences) from text.

    Example:
        extract_words("Hello, world! 123")  # ["Hello", "world", "123"]
    """
    var words = []
    var current_word = ""
    var i = 0

    while i < text.len():
        val ch = text[i]
        if text_is_alphanumeric(ch):
            current_word = current_word + ch
        else:
            if current_word.len() > 0:
                words.push(current_word)
                current_word = ""
        i = i + 1

    if current_word.len() > 0:
        words.push(current_word)

    words

# ============================================================================
# Line Processing (from text_utils)
# ============================================================================

fn trim_lines(lines):
    """Trim whitespace from each line.

    Example:
        trim_lines(["  hello  ", "  world  "])  # ["hello", "world"]
    """
    var result = []
    for line in lines:
        result.push(line.trim())
    result

fn remove_empty_lines(lines):
    """Remove empty or whitespace-only lines.

    Example:
        remove_empty_lines(["hello", "", "world", "  "])
        # ["hello", "world"]
    """
    var result = []
    for line in lines:
        if line.trim().len() > 0:
            result.push(line)
    result

fn number_lines(lines, start: i64):
    """Add line numbers to lines.

    Example:
        number_lines(["hello", "world"], 1)
        # ["1: hello", "2: world"]
    """
    var result = []
    var i = 0

    while i < lines.len():
        val line_num = start + i
        result.push("{line_num}: {lines[i]}")
        i = i + 1

    result

fn prefix_lines(lines, prefix: text):
    """Add prefix to each line.

    Example:
        prefix_lines(["hello", "world"], "> ")
        # ["> hello", "> world"]
    """
    var result = []
    for line in lines:
        result.push(prefix + line)
    result

fn suffix_lines(lines, suffix: text):
    """Add suffix to each line.

    Example:
        suffix_lines(["hello", "world"], "!")
        # ["hello!", "world!"]
    """
    var result = []
    for line in lines:
        result.push(line + suffix)
    result

# ============================================================================
# Advanced Case Conversion (from text_utils)
# ============================================================================

fn to_title_case(text: text) -> text:
    """Convert text to title case (capitalize first letter of each word).

    Example:
        to_title_case("hello world")  # "Hello World"
    """
    var result = ""
    var capitalize_next = true
    var i = 0

    while i < text.len():
        val ch = text[i]

        if is_whitespace_char(ch):
            result = result + ch
            capitalize_next = true
        elif capitalize_next and text_is_alpha(ch):
            if is_lowercase_char(ch):
                val upper_code = ch[0] - 32
                result = result + upper_code
            else:
                result = result + ch
            capitalize_next = false
        else:
            if is_uppercase_char(ch):
                val lower_code = ch[0] + 32
                result = result + lower_code
            else:
                result = result + ch

        i = i + 1

    result

fn to_snake_case(text: text) -> text:
    """Convert text to snake_case.

    Example:
        to_snake_case("HelloWorld")  # "hello_world"
        to_snake_case("hello world")  # "hello_world"
    """
    var result = ""
    var i = 0

    while i < text.len():
        val ch = text[i]

        if is_whitespace_char(ch):
            result = result + "_"
        elif is_uppercase_char(ch):
            if i > 0 and not is_whitespace_char(text[i-1]):
                result = result + "_"
            val lower_code = ch[0] + 32
            result = result + lower_code
        else:
            result = result + ch

        i = i + 1

    result

fn to_camel_case(text: text) -> text:
    """Convert text to camelCase.

    Example:
        to_camel_case("hello world")  # "helloWorld"
        to_camel_case("hello_world")  # "helloWorld"
    """
    var result = ""
    var capitalize_next = false
    var i = 0

    while i < text.len():
        val ch = text[i]

        if ch == " " or ch == "_":
            capitalize_next = true
        elif capitalize_next and text_is_alpha(ch):
            if is_lowercase_char(ch):
                val upper_code = ch[0] - 32
                result = result + upper_code
            else:
                result = result + ch
            capitalize_next = false
        else:
            result = result + ch

        i = i + 1

    result

# ============================================================================
# Word Operations (from text_utils)
# ============================================================================

fn word_count(text: text) -> i64:
    """Count words in text.

    Example:
        word_count("Hello world, how are you?")  # 5
    """
    val words = extract_words(text)
    words.len()

fn word_wrap(text: text, width: i64):
    """Wrap text to specified width.

    Delegates to wrap_text() from std.format_utils.

    Returns array of lines.

    Example:
        word_wrap("The quick brown fox", 10)
        # ["The quick", "brown fox"]
    """
    wrap_text(text, width)

fn reverse_words(text: text) -> text:
    """Reverse order of words in text.

    Example:
        reverse_words("hello world")  # "world hello"
    """
    val words = split_whitespace(text)
    var reversed = []
    var i = words.len() - 1

    while i >= 0:
        reversed.push(words[i])
        i = i - 1

    reversed.join(" ")

fn longest_word(text: text):
    """Find longest word in text.

    Returns (word, length) tuple or nil.

    Example:
        longest_word("The quick brown fox")  # ("quick", 5)
    """
    val words = extract_words(text)
    if words.len() == 0:
        return nil

    var longest = words[0]
    var max_len = longest.len()

    for word in words:
        if word.len() > max_len:
            longest = word
            max_len = word.len()

    (longest, max_len)

# ============================================================================
# Text Analysis (from text_utils)
# ============================================================================

fn char_frequency(text: text):
    """Calculate character frequency.

    Returns array of (char, count) tuples.

    Example:
        char_frequency("hello")
        # [('h',1), ('e',1), ('l',2), ('o',1)]
    """
    var counts = []
    var i = 0

    while i < text.len():
        val ch = text[i]

        # Find or add character
        var found = false
        var j = 0
        while j < counts.len():
            val (char, count) = counts[j]
            if char == ch:
                counts[j] = (char, count + 1)
                found = true
                break
            j = j + 1

        if not found:
            counts.push((ch, 1))

        i = i + 1

    counts

fn most_common_char(text: text):
    """Find most common character.

    Returns (char, count) tuple or nil.

    Example:
        most_common_char("hello")  # ('l', 2)
    """
    val freqs = char_frequency(text)
    if freqs.len() == 0:
        return nil

    var max_char = nil
    var max_count = 0

    for (char, count) in freqs:
        if count > max_count:
            max_char = char
            max_count = count

    (max_char, max_count)

fn most_common_words(text: text, n: i64):
    """Find n most common words.

    Example:
        most_common_words("hello world hello", 1)
        # [("hello", 2)]
    """
    val words = extract_words(text)

    # Count word frequencies
    var counts = []
    for word in words:
        var found = false
        var i = 0
        while i < counts.len():
            val (w, count) = counts[i]
            if w == word:
                counts[i] = (w, count + 1)
                found = true
                break
            i = i + 1

        if not found:
            counts.push((word, 1))

    # Sort by frequency (simple selection sort)
    var sorted = counts
    var i = 0
    while i < sorted.len() - 1:
        var max_idx = i
        var j = i + 1
        while j < sorted.len():
            val (_, count1) = sorted[max_idx]
            val (_, count2) = sorted[j]
            if count2 > count1:
                max_idx = j
            j = j + 1

        if max_idx != i:
            val temp = sorted[i]
            sorted[i] = sorted[max_idx]
            sorted[max_idx] = temp

        i = i + 1

    # Take top n
    var result = []
    i = 0
    while i < n and i < sorted.len():
        result.push(sorted[i])
        i = i + 1

    result

# ============================================================================
# Indentation (from text_utils)
# ============================================================================

fn detect_indent(lines):
    """Detect indentation level of first indented line.

    Returns number of leading spaces.

    Example:
        detect_indent(["hello", "  world", "    foo"])  # 2
    """
    for line in lines:
        var spaces = 0
        var i = 0

        while i < line.len():
            if line[i] == ' ':
                spaces = spaces + 1
            else:
                break
            i = i + 1

        if spaces > 0:
            return spaces

    0

fn normalize_indent(lines, new_indent: i64):
    """Normalize indentation to specified number of spaces.

    Example:
        normalize_indent(["  hello", "    world"], 4)
        # ["    hello", "        world"]
    """
    val current_indent = detect_indent(lines)
    if current_indent == 0:
        return lines

    var result = []

    for line in lines:
        # Count leading spaces
        var spaces = 0
        var i = 0
        while i < line.len():
            if line[i] == ' ':
                spaces = spaces + 1
            else:
                break
            i = i + 1

        # Calculate new indentation
        val indent_level = spaces / current_indent
        val new_spaces = indent_level * new_indent

        # Build new line
        var new_line = ""
        var j = 0
        while j < new_spaces:
            new_line = new_line + " "
            j = j + 1

        # Add rest of line
        new_line = new_line + line[spaces..]
        result.push(new_line)

    result

fn dedent_lines(lines):
    """Remove common leading whitespace from all lines.

    Example:
        dedent_lines(["  hello", "    world"])
        # ["hello", "  world"]
    """
    val min_indent = detect_indent(lines)
    if min_indent == 0:
        return lines

    var result = []

    for line in lines:
        if line.len() >= min_indent:
            result.push(line[min_indent..])
        else:
            result.push(line)

    result

# ============================================================================
# String Similarity (from text_utils)
# ============================================================================

fn levenshtein_distance(s1: text, s2: text) -> i64:
    """Calculate Levenshtein (edit) distance between two strings.

    Number of single-character edits needed to transform s1 into s2.

    Example:
        levenshtein_distance("kitten", "sitting")  # 3
    """
    val len1 = s1.len()
    val len2 = s2.len()

    # Create distance matrix
    var dp = []
    var i = 0
    while i <= len1:
        var row = []
        var j = 0
        while j <= len2:
            row.push(0)
            j = j + 1
        dp.push(row)
        i = i + 1

    # Initialize first row and column
    i = 0
    while i <= len1:
        dp[i][0] = i
        i = i + 1

    var j = 0
    while j <= len2:
        dp[0][j] = j
        j = j + 1

    # Fill matrix
    i = 1
    while i <= len1:
        j = 1
        while j <= len2:
            val cost = if s1[i-1] == s2[j-1]: 0 else: 1

            val delete = dp[i-1][j] + 1
            val insert = dp[i][j-1] + 1
            val substitute = dp[i-1][j-1] + cost

            var min = delete
            if insert < min:
                min = insert
            if substitute < min:
                min = substitute

            dp[i][j] = min
            j = j + 1
        i = i + 1

    dp[len1][len2]

fn hamming_distance(s1: text, s2: text):
    """Calculate Hamming distance (must be same length).

    Number of positions where characters differ.

    Example:
        hamming_distance("karolin", "kathrin")  # 3
    """
    if s1.len() != s2.len():
        return nil

    var distance = 0
    var i = 0

    while i < s1.len():
        if s1[i] != s2[i]:
            distance = distance + 1
        i = i + 1

    distance

# ============================================================================
# Advanced Text Joining (from text_utils)
# ============================================================================

fn join_with_separator(items, separator: text, final_separator: text) -> text:
    """Join items with different final separator.

    Example:
        join_with_separator(["a", "b", "c"], ", ", " and ")
        # "a, b and c"
    """
    if items.len() == 0:
        return ""
    if items.len() == 1:
        return items[0]

    var result = items[0]
    var i = 1

    while i < items.len() - 1:
        result = result + separator + items[i]
        i = i + 1

    result = result + final_separator + items[items.len() - 1]
    result

fn join_natural(items) -> text:
    """Join items naturally with commas and 'and'.

    Example:
        join_natural(["Alice", "Bob", "Charlie"])
        # "Alice, Bob, and Charlie"
    """
    join_with_separator(items, ", ", ", and ")

# ============================================================================
# JSON Escaping
# ============================================================================

fn escape_json(s: text) -> text:
    """Escape special characters for JSON strings.

    Escapes: backslash, double quote, newline, carriage return, tab

    Example:
        escape_json("Hello\\n\\\"World\\\"") -> "Hello\\\\n\\\\\\\"World\\\\\\\""
    """
    var r = s.replace("\\", "\\\\")
    r = r.replace("\"", "\\\"")
    r = r.replace("\n", "\\n")
    r = r.replace("\r", "\\r")
    r = r.replace("\t", "\\t")
    r

export split_whitespace, extract_words
export trim_lines, remove_empty_lines, number_lines, prefix_lines, suffix_lines
export to_title_case, to_snake_case, to_camel_case
export word_count, word_wrap, reverse_words, longest_word
export char_frequency, most_common_char, most_common_words
export detect_indent, normalize_indent, dedent_lines
export levenshtein_distance, hamming_distance
export join_with_separator, join_natural
export escape_json
