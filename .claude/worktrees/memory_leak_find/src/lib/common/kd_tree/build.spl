# K-d Tree Construction and Structural Operations
# Tree building, height, size, rebalancing, and validation

import kd_tree.types

# ============================================================================
# Point List Operations
# ============================================================================

fn points_get_dimension(points: List<List<i64>>) -> i64:
    # Get dimension from first point
    if points.length() == 0:
        return 0
    val first = points.get(0)
    first.length()

fn points_partition(points: List<List<i64>>, dim: i64, pivot: i64) -> List:
    # Partition points by dimension and pivot value
    # Returns [left_points, right_points]
    var left = []
    var right = []
    var i = 0
    while i < points.length():
        val point = points.get(i)
        val coord = point.get(dim)
        if coord < pivot:
            left.push(point)
        else:
            right.push(point)
        i = i + 1
    [left, right]

fn points_find_median(points: List<List<i64>>, dim: i64) -> i64:
    # Find median value along dimension (approximation)
    if points.length() == 0:
        return 0

    var coords = []
    var i = 0
    while i < points.length():
        val point = points.get(i)
        val coord = point.get(dim)
        coords.push(coord)
        i = i + 1

    val sorted = list_sort(coords)
    val mid = sorted.length() / 2
    sorted.get(mid)

fn points_find_median_point(points: List<List<i64>>, dim: i64) -> List<i64>:
    # Find point with median value along dimension
    if points.length() == 0:
        return []

    val median_val = points_find_median(points, dim)
    var i = 0
    while i < points.length():
        val point = points.get(i)
        val coord = point.get(dim)
        if coord == median_val:
            return point
        i = i + 1

    points.get(0)

fn points_filter_not_equal(points: List<List<i64>>, target: List<i64>) -> List<List<i64>>:
    # Filter out point equal to target
    var result = []
    var i = 0
    while i < points.length():
        val point = points.get(i)
        val is_equal = point_equal(point, target)
        if is_equal == 0:
            result.push(point)
        i = i + 1
    result

# ============================================================================
# List Utilities
# ============================================================================

fn list_sort(lst: List<i64>) -> List<i64>:
    # Simple insertion sort for small lists
    if lst.length() <= 1:
        return lst

    var sorted = []
    var i = 0
    while i < lst.length():
        val val = lst.get(i)
        sorted.push(val)
        i = i + 1

    var j = 1
    while j < sorted.length():
        val key = sorted.get(j)
        var k = j - 1
        while k >= 0:
            val curr = sorted.get(k)
            if curr <= key:
                break
            sorted.set(k + 1, curr)
            k = k - 1
        sorted.set(k + 1, key)
        j = j + 1

    sorted

fn list_min(lst: List<i64>) -> i64:
    # Find minimum value in list
    if lst.length() == 0:
        return 0
    var min_val = lst.get(0)
    var i = 1
    while i < lst.length():
        val val = lst.get(i)
        if val < min_val:
            min_val = val
        i = i + 1
    min_val

fn list_max(lst: List<i64>) -> i64:
    # Find maximum value in list
    if lst.length() == 0:
        return 0
    var max_val = lst.get(0)
    var i = 1
    while i < lst.length():
        val val = lst.get(i)
        if val > max_val:
            max_val = val
        i = i + 1
    max_val

# ============================================================================
# K-d Tree Construction
# ============================================================================

fn kdtree_build_recursive(points: List<List<i64>>, depth: i64, k: i64):
    # Recursively build K-d tree
    if points.length() == 0:
        return nil

    if points.length() == 1:
        val point = points.get(0)
        val dim = depth % k
        val value = point.get(dim)
        return kdnode_create(dim, value, point)

    val dim = depth % k
    val median_point = points_find_median_point(points, dim)
    val median_val = median_point.get(dim)

    val remaining = points_filter_not_equal(points, median_point)
    val partitions = points_partition(remaining, dim, median_val)
    val left_points = partitions.get(0)
    val right_points = partitions.get(1)

    val node = kdnode_create(dim, median_val, median_point)
    val left = kdtree_build_recursive(left_points, depth + 1, k)
    val right = kdtree_build_recursive(right_points, depth + 1, k)

    kdnode_set_left(node, left)
    kdnode_set_right(node, right)
    node

fn kdtree_build(points: List<List<i64>>):
    # Build K-d tree from list of points
    if points.length() == 0:
        return nil
    val k = points_get_dimension(points)
    kdtree_build_recursive(points, 0, k)

fn kdtree_height(node) -> i64:
    # Calculate height of K-d tree
    if node == nil:
        return 0

    val left = kdnode_get_left(node)
    val right = kdnode_get_right(node)
    val left_height = kdtree_height(left)
    val right_height = kdtree_height(right)

    val max_height = if left_height > right_height: left_height else: right_height
    max_height + 1

fn kdtree_size(node) -> i64:
    # Count number of nodes in tree
    if node == nil:
        return 0

    val left = kdnode_get_left(node)
    val right = kdnode_get_right(node)
    val left_size = kdtree_size(left)
    val right_size = kdtree_size(right)

    left_size + right_size + 1

fn kdtree_to_list(node) -> List<List<i64>>:
    # Convert tree to list of points (in-order traversal)
    if node == nil:
        return []

    var result = []
    val left = kdnode_get_left(node)
    val right = kdnode_get_right(node)

    val left_list = kdtree_to_list(left)
    var i = 0
    while i < left_list.length():
        val point = left_list.get(i)
        result.push(point)
        i = i + 1

    val point = kdnode_get_point(node)
    result.push(point)

    val right_list = kdtree_to_list(right)
    var j = 0
    while j < right_list.length():
        val point = right_list.get(j)
        result.push(point)
        j = j + 1

    result

# ============================================================================
# Tree Rebalancing
# ============================================================================

fn kdtree_rebalance(node):
    # Rebalance K-d tree
    if node == nil:
        return nil

    val points = kdtree_to_list(node)
    kdtree_build(points)

fn kdtree_needs_rebalance(node, threshold: i64) -> i64:
    # Check if tree needs rebalancing based on height threshold
    val height = kdtree_height(node)
    val size = kdtree_size(node)

    if size == 0:
        return 0

    var ideal_height = 1
    var temp = size
    while temp > 1:
        temp = temp / 2
        ideal_height = ideal_height + 1

    val diff = height - ideal_height
    if diff > threshold:
        return 1
    0

# ============================================================================
# Tree Statistics
# ============================================================================

fn kdtree_depth(node, point: List<i64>) -> i64:
    # Find depth of point in tree
    if node == nil:
        return -1

    val node_point = kdnode_get_point(node)
    val is_equal = point_equal(node_point, point)
    if is_equal == 1:
        return 0

    val dim = kdnode_get_dim(node)
    val pivot = kdnode_get_value(node)
    val coord = point.get(dim)

    var child = nil
    if coord < pivot:
        child = kdnode_get_left(node)
    else:
        child = kdnode_get_right(node)

    val child_depth = kdtree_depth(child, point)
    if child_depth == -1:
        return -1
    child_depth + 1

fn kdtree_leaf_count(node) -> i64:
    # Count number of leaf nodes
    if node == nil:
        return 0

    val is_leaf = kdnode_is_leaf(node)
    if is_leaf == 1:
        return 1

    val left = kdnode_get_left(node)
    val right = kdnode_get_right(node)
    val left_count = kdtree_leaf_count(left)
    val right_count = kdtree_leaf_count(right)

    left_count + right_count

fn kdtree_balance_factor(node) -> i64:
    # Calculate balance factor (height difference between subtrees)
    if node == nil:
        return 0

    val left = kdnode_get_left(node)
    val right = kdnode_get_right(node)
    val left_height = kdtree_height(left)
    val right_height = kdtree_height(right)

    val diff = left_height - right_height
    if diff < 0: -diff else: diff

# ============================================================================
# Dimensional Analysis
# ============================================================================

fn kdtree_dimension_bounds(node, dim: i64) -> List:
    # Get min and max values along a dimension
    # Returns [min, max]
    if node == nil:
        return [999999999, -999999999]

    val point = kdnode_get_point(node)
    val value = point.get(dim)

    val left = kdnode_get_left(node)
    val right = kdnode_get_right(node)

    var min_val = value
    var max_val = value

    if left != nil:
        val left_bounds = kdtree_dimension_bounds(left, dim)
        val left_min = left_bounds.get(0)
        val left_max = left_bounds.get(1)
        if left_min < min_val:
            min_val = left_min
        if left_max > max_val:
            max_val = left_max

    if right != nil:
        val right_bounds = kdtree_dimension_bounds(right, dim)
        val right_min = right_bounds.get(0)
        val right_max = right_bounds.get(1)
        if right_min < min_val:
            min_val = right_min
        if right_max > max_val:
            max_val = right_max

    [min_val, max_val]

fn kdtree_bounding_box(node) -> List:
    # Get bounding box for entire tree
    if node == nil:
        return [[], []]

    val points = kdtree_to_list(node)
    bbox_create(points)

fn kdtree_dimension_variance(node, dim: i64) -> i64:
    # Calculate variance along dimension
    val points = kdtree_to_list(node)
    if points.length() == 0:
        return 0

    var sum = 0
    var i = 0
    while i < points.length():
        val point = points.get(i)
        val coord = point.get(dim)
        sum = sum + coord
        i = i + 1

    val mean = sum / points.length()

    var var_sum = 0
    var j = 0
    while j < points.length():
        val point = points.get(j)
        val coord = point.get(j)
        val diff = coord - mean
        var_sum = var_sum + (diff * diff)
        j = j + 1

    var_sum / points.length()

# ============================================================================
# Tree Comparison
# ============================================================================

fn kdtree_points_equal(node1, node2) -> i64:
    # Check if two trees contain same points
    val points1 = kdtree_to_list(node1)
    val points2 = kdtree_to_list(node2)

    if points1.length() != points2.length():
        return 0

    var i = 0
    while i < points1.length():
        val p1 = points1.get(i)
        var found = 0
        var j = 0
        while j < points2.length():
            val p2 = points2.get(j)
            val is_equal = point_equal(p1, p2)
            if is_equal == 1:
                found = 1
                break
            j = j + 1
        if found == 0:
            return 0
        i = i + 1

    1

fn kdtree_subset(node1, node2) -> i64:
    # Check if node1 points are subset of node2 points
    val points1 = kdtree_to_list(node1)
    val points2 = kdtree_to_list(node2)

    var i = 0
    while i < points1.length():
        val p1 = points1.get(i)
        var found = 0
        var j = 0
        while j < points2.length():
            val p2 = points2.get(j)
            val is_equal = point_equal(p1, p2)
            if is_equal == 1:
                found = 1
                break
            j = j + 1
        if found == 0:
            return 0
        i = i + 1

    1

# ============================================================================
# Bulk Operations
# ============================================================================

fn kdtree_merge(node1, node2):
    # Merge two K-d trees
    val points1 = kdtree_to_list(node1)
    val points2 = kdtree_to_list(node2)

    var all_points = []
    var i = 0
    while i < points1.length():
        val point = points1.get(i)
        all_points.push(point)
        i = i + 1

    var j = 0
    while j < points2.length():
        val point = points2.get(j)
        all_points.push(point)
        j = j + 1

    kdtree_build(all_points)
