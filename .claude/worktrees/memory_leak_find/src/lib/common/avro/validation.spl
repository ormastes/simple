# Avro Schema Validation and Compatibility
#
# Schema validation and compatibility checking for Avro schema evolution
# and reader/writer schema resolution.

# ============================================================================
# Schema Validation
# ============================================================================

fn avro_validate_schema(schema) -> bool:
    """Validate schema structure. Returns true if valid."""
    if schema == nil:
        return false

    val type_id = schema.type
    if type_id < 0:
        return false
    if type_id > avro_type_fixed():
        return false

    if avro_is_primitive(schema):
        return true

    if type_id == avro_type_record():
        return avro_validate_record_schema(schema)

    if type_id == avro_type_enum():
        return avro_validate_enum_schema(schema)

    if type_id == avro_type_array():
        return avro_validate_array_schema(schema)

    if type_id == avro_type_map():
        return avro_validate_map_schema(schema)

    if type_id == avro_type_union():
        return avro_validate_union_schema(schema)

    if type_id == avro_type_fixed():
        return avro_validate_fixed_schema(schema)

    false

fn avro_validate_record_schema(schema) -> bool:
    """Validate record schema."""
    if schema.name == nil:
        return false
    if schema.name == "":
        return false
    if schema.fields == nil:
        return false
    if schema.fields.len() == 0:
        return false

    # Validate each field
    val fields = schema.fields
    var i = 0
    while i < fields.len():
        val field = fields[i]
        if field.name == nil:
            return false
        if field.name == "":
            return false
        if field.type == nil:
            return false
        val field_valid = avro_validate_schema(field.type)
        if field_valid == false:
            return false
        i = i + 1

    true

fn avro_validate_enum_schema(schema) -> bool:
    """Validate enum schema."""
    if schema.name == nil:
        return false
    if schema.name == "":
        return false
    if schema.symbols == nil:
        return false
    if schema.symbols.len() == 0:
        return false
    true

fn avro_validate_array_schema(schema) -> bool:
    """Validate array schema."""
    if schema.items == nil:
        return false
    avro_validate_schema(schema.items)

fn avro_validate_map_schema(schema) -> bool:
    """Validate map schema."""
    if schema.values == nil:
        return false
    avro_validate_schema(schema.values)

fn avro_validate_union_schema(schema) -> bool:
    """Validate union schema."""
    if schema.types == nil:
        return false
    if schema.types.len() < 2:
        return false

    # Validate each type in union
    val types = schema.types
    var i = 0
    while i < types.len():
        val type_valid = avro_validate_schema(types[i])
        if type_valid == false:
            return false
        i = i + 1

    true

fn avro_validate_fixed_schema(schema) -> bool:
    """Validate fixed schema."""
    if schema.name == nil:
        return false
    if schema.name == "":
        return false
    if schema.size <= 0:
        return false
    true

# ============================================================================
# Schema Compatibility Checking
# ============================================================================

fn avro_schemas_compatible(writer_schema, reader_schema) -> bool:
    """Check if reader schema is compatible with writer schema.
    Implements Avro schema resolution rules."""
    val writer_type = writer_schema.type
    val reader_type = reader_schema.type

    # Same type is always compatible
    if writer_type == reader_type:
        if avro_is_primitive(writer_schema):
            return true

        if writer_type == avro_type_record():
            return avro_records_compatible(writer_schema, reader_schema)

        if writer_type == avro_type_enum():
            return avro_enums_compatible(writer_schema, reader_schema)

        if writer_type == avro_type_array():
            return avro_arrays_compatible(writer_schema, reader_schema)

        if writer_type == avro_type_map():
            return avro_maps_compatible(writer_schema, reader_schema)

        if writer_type == avro_type_union():
            return avro_unions_compatible(writer_schema, reader_schema)

        if writer_type == avro_type_fixed():
            return avro_fixed_compatible(writer_schema, reader_schema)

    # Numeric promotions
    if writer_type == avro_type_int():
        if reader_type == avro_type_long():
            return true
        if reader_type == avro_type_float():
            return true
        if reader_type == avro_type_double():
            return true

    if writer_type == avro_type_long():
        if reader_type == avro_type_float():
            return true
        if reader_type == avro_type_double():
            return true

    if writer_type == avro_type_float():
        if reader_type == avro_type_double():
            return true

    # String/bytes compatibility
    if writer_type == avro_type_string():
        if reader_type == avro_type_bytes():
            return true

    if writer_type == avro_type_bytes():
        if reader_type == avro_type_string():
            return true

    false

fn avro_records_compatible(writer_schema, reader_schema) -> bool:
    """Check record compatibility."""
    # Name must match (or alias match - not implemented here)
    if writer_schema.name != reader_schema.name:
        return false

    # All reader fields must be present in writer or have defaults
    val reader_fields = reader_schema.fields
    var i = 0
    while i < reader_fields.len():
        val reader_field = reader_fields[i]
        val writer_field = avro_find_field(writer_schema, reader_field.name)
        if writer_field == nil:
            # Field not in writer - must have default
            if reader_field.default == nil:
                return false
        else:
            # Field exists - check type compatibility
            val types_compatible = avro_schemas_compatible(writer_field.type, reader_field.type)
            if types_compatible == false:
                return false
        i = i + 1

    true

fn avro_enums_compatible(writer_schema, reader_schema) -> bool:
    """Check enum compatibility."""
    # Name must match
    if writer_schema.name != reader_schema.name:
        return false

    # All writer symbols must exist in reader
    val writer_symbols = writer_schema.symbols
    val reader_symbols = reader_schema.symbols

    var i = 0
    while i < writer_symbols.len():
        val writer_symbol = writer_symbols[i]
        var found = false
        var j = 0
        while j < reader_symbols.len():
            if reader_symbols[j] == writer_symbol:
                found = true
            j = j + 1
        if found == false:
            return false
        i = i + 1

    true

fn avro_arrays_compatible(writer_schema, reader_schema) -> bool:
    """Check array compatibility."""
    avro_schemas_compatible(writer_schema.items, reader_schema.items)

fn avro_maps_compatible(writer_schema, reader_schema) -> bool:
    """Check map compatibility."""
    avro_schemas_compatible(writer_schema.values, reader_schema.values)

fn avro_unions_compatible(writer_schema, reader_schema) -> bool:
    """Check union compatibility (simplified)."""
    # All writer types must be compatible with at least one reader type
    val writer_types = writer_schema.types
    val reader_types = reader_schema.types

    var i = 0
    while i < writer_types.len():
        val writer_type = writer_types[i]
        var compatible = false
        var j = 0
        while j < reader_types.len():
            val reader_type = reader_types[j]
            val check = avro_schemas_compatible(writer_type, reader_type)
            if check:
                compatible = true
            j = j + 1
        if compatible == false:
            return false
        i = i + 1

    true

fn avro_fixed_compatible(writer_schema, reader_schema) -> bool:
    """Check fixed compatibility."""
    if writer_schema.name != reader_schema.name:
        return false
    if writer_schema.size != reader_schema.size:
        return false
    true

# ============================================================================
# Schema Comparison
# ============================================================================

fn avro_schema_equals(schema1, schema2) -> bool:
    """Check if two schemas are equal."""
    val json1 = avro_schema_to_json(schema1)
    val json2 = avro_schema_to_json(schema2)
    json1 == json2
