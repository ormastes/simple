# ============================================================================
# Utility Functions
# ============================================================================

# Convert byte value to 2-digit hex string
fn to_hex_byte(value: i64) -> text:
    var hex_chars = "0123456789ABCDEF"
    var high = value / 16
    var low = value % 16
    var high_char = string_char_at(hex_chars, high)
    var low_char = string_char_at(hex_chars, low)
    high_char + low_char

# Convert 2 hex digits to byte value
fn from_hex_byte(hex1: text, hex2: text) -> i64:
    var h1 = hex_digit_value(hex1)
    var h2 = hex_digit_value(hex2)
    h1 * 16 + h2

# Get numeric value of hex digit
fn hex_digit_value(digit: text) -> i64:
    var code = string_char_code(digit)
    if code >= 48 and code <= 57:
        return code - 48  # 0-9
    if code >= 65 and code <= 70:
        return code - 65 + 10  # A-F
    if code >= 97 and code <= 102:
        return code - 97 + 10  # a-f
    0

# Check if string is numeric
fn is_numeric(str: text) -> bool:
    if str == "":
        return false

    var i = 0
    while i < string_length(str):
        var ch = string_char_at(str, i)
        var code = string_char_code(ch)
        if code < 48 or code > 57:
            return false
        i = i + 1

    true

# Extract domain from host (remove subdomain)
fn get_domain(host: text) -> text:
    if host == "":
        return ""

    var parts = string_split(host, ".")
    var len = array_length(parts)

    if len < 2:
        return host

    # Return last 2 parts (domain.tld)
    var domain = array_get(parts, len - 2)
    var tld = array_get(parts, len - 1)
    domain + "." + tld

# Check if host is an IP address (simple check)
fn is_ip_address(host: text) -> bool:
    if host == "":
        return false

    # IPv4 simple check
    var parts = string_split(host, ".")
    if array_length(parts) == 4:
        var all_numeric = true
        var i = 0
        while i < 4:
            var part = array_get(parts, i)
            if not is_numeric(part):
                all_numeric = false
            i = i + 1
        return all_numeric

    # IPv6 simple check (contains :)
    string_contains(host, ":")

# Remove default port from URI if present
fn remove_default_port(uri: text) -> text:
    var components = parse_uri(uri)
    if components.port != "" and is_default_port(components.scheme, components.port):
        components.port = ""
    build_uri(components)

# Add trailing slash to path if not present
fn ensure_trailing_slash(uri: text) -> text:
    var components = parse_uri(uri)
    if components.path != "" and not string_ends_with(components.path, "/"):
        components.path = components.path + "/"
    build_uri(components)

# Remove trailing slash from path if present
fn remove_trailing_slash(uri: text) -> text:
    var components = parse_uri(uri)
    if string_ends_with(components.path, "/") and string_length(components.path) > 1:
        components.path = string_substring(components.path, 0, string_length(components.path) - 1)
    build_uri(components)

# ============================================================================
# Helper Functions (String operations not in stdlib)
# ============================================================================

fn string_to_lower(s: text) -> text:
    var result = ""
    var i = 0
    while i < string_length(s):
        var ch = string_char_at(s, i)
        var code = string_char_code(ch)
        if code >= 65 and code <= 90:  # A-Z
            var lower_code = code + 32
            var lower_ch = string_from_char_code(lower_code)
            result = result + lower_ch
        else:
            result = result + ch
        i = i + 1
    result

fn string_starts_with(s: text, prefix: text) -> bool:
    var s_len = string_length(s)
    var p_len = string_length(prefix)
    if p_len > s_len:
        return false
    var i = 0
    while i < p_len:
        var s_ch = string_char_at(s, i)
        var p_ch = string_char_at(prefix, i)
        if s_ch != p_ch:
            return false
        i = i + 1
    true

fn string_ends_with(s: text, suffix: text) -> bool:
    var s_len = string_length(s)
    var suf_len = string_length(suffix)
    if suf_len > s_len:
        return false
    var start = s_len - suf_len
    var i = 0
    while i < suf_len:
        var s_ch = string_char_at(s, start + i)
        var suf_ch = string_char_at(suffix, i)
        if s_ch != suf_ch:
            return false
        i = i + 1
    true

fn string_index_of(s: text, needle: text) -> i64:
    var s_len = string_length(s)
    var n_len = string_length(needle)
    if n_len == 0 or n_len > s_len:
        return -1
    var i = 0
    while i <= s_len - n_len:
        var match = true
        var j = 0
        while j < n_len:
            var s_ch = string_char_at(s, i + j)
            var n_ch = string_char_at(needle, j)
            if s_ch != n_ch:
                match = false
            j = j + 1
        if match:
            return i
        i = i + 1
    -1

fn string_last_index_of(s: text, needle: text) -> i64:
    var s_len = string_length(s)
    var n_len = string_length(needle)
    if n_len == 0 or n_len > s_len:
        return -1
    var i = s_len - n_len
    while i >= 0:
        var match = true
        var j = 0
        while j < n_len:
            var s_ch = string_char_at(s, i + j)
            var n_ch = string_char_at(needle, j)
            if s_ch != n_ch:
                match = false
            j = j + 1
        if match:
            return i
        i = i - 1
    -1

fn string_replace_all(s: text, old: text, new: text) -> text:
    var result = ""
    var i = 0
    var s_len = string_length(s)
    var old_len = string_length(old)

    while i < s_len:
        var found = true
        var j = 0
        while j < old_len and i + j < s_len:
            var s_ch = string_char_at(s, i + j)
            var old_ch = string_char_at(old, j)
            if s_ch != old_ch:
                found = false
            j = j + 1

        if found and j == old_len:
            result = result + new
            i = i + old_len
        else:
            var ch = string_char_at(s, i)
            result = result + ch
            i = i + 1

    result

fn string_contains(s: text, needle: text) -> bool:
    string_index_of(s, needle) >= 0
