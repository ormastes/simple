# URI Building Functions
# ============================================================================

# Build a URI from components
fn build_uri(components: UriComponents) -> text:
    components.to_string()

# Build a URL with common parameters
fn build_url(scheme: text, host: text, path: text, query: text, fragment: text) -> text:
    var components = UriComponents(
        scheme: scheme,
        userinfo: "",
        host: host,
        port: "",
        path: path,
        query: query,
        fragment: fragment
    )
    build_uri(components)

# Build a query string from array of QueryParam
fn build_query_string(params: array) -> text:
    if array_length(params) == 0:
        return ""

    var result = ""
    var i = 0
    while i < array_length(params):
        var param = array_get(params, i)
        if i > 0:
            result = result + "&"
        result = result + uri_encode(param.key) + "=" + uri_encode(param.value)
        i = i + 1

    result

# ============================================================================
# Component Access Functions
# ============================================================================

# Get scheme from URI string
fn get_scheme(uri: text) -> text:
    var components = parse_uri(uri)
    components.scheme

# Get host from URI string
fn get_host(uri: text) -> text:
    var components = parse_uri(uri)
    components.host

# Get port from URI string
fn get_port(uri: text) -> text:
    var components = parse_uri(uri)
    components.port

# Get path from URI string
fn get_path(uri: text) -> text:
    var components = parse_uri(uri)
    components.path

# Get query from URI string
fn get_query(uri: text) -> text:
    var components = parse_uri(uri)
    components.query

# Get fragment from URI string
fn get_fragment(uri: text) -> text:
    var components = parse_uri(uri)
    components.fragment

# Get userinfo from URI string
fn get_userinfo(uri: text) -> text:
    var components = parse_uri(uri)
    components.userinfo

# Get full authority (userinfo@host:port)
fn get_authority(uri: text) -> text:
    var components = parse_uri(uri)
    var authority = ""

    if components.userinfo != "":
        authority = components.userinfo + "@"

    authority = authority + components.host

    if components.port != "":
        authority = authority + ":" + components.port

    authority

# ============================================================================
# Path Operations
# ============================================================================

# Join path segments with proper separators
fn join_path(segments: array) -> text:
    if array_length(segments) == 0:
        return ""

    var result = ""
    var i = 0
    while i < array_length(segments):
        var segment = array_get(segments, i)

        # Skip empty segments
        if segment != "":
            if i > 0 and not string_starts_with(segment, "/"):
                result = result + "/"
            result = result + segment

        i = i + 1

    result

# Normalize a path by resolving . and .. segments
fn normalize_path(path: text) -> text:
    if path == "" or path == "/":
        return path

    var is_absolute = string_starts_with(path, "/")
    var segments = string_split(path, "/")
    var normalized = []

    var i = 0
    while i < array_length(segments):
        var segment = array_get(segments, i)
# Query Operations
# ============================================================================
# Query Operations
# ============================================================================

# Add a query parameter to a URI
fn add_query_param(uri: text, key: text, value: text) -> text:
    var components = parse_uri(uri)
    var params = parse_query_string(components.query)
    var new_param = QueryParam(key: key, value: value)
    params = array_push(params, new_param)
    components.query = build_query_string(params)
    build_uri(components)

# Remove a query parameter from a URI
fn remove_query_param(uri: text, key: text) -> text:
    var components = parse_uri(uri)
    var params = parse_query_string(components.query)
    var filtered = []

    var i = 0
    while i < array_length(params):
        var param = array_get(params, i)
        if param.key != key:
            filtered = array_push(filtered, param)
        i = i + 1

    components.query = build_query_string(filtered)
    build_uri(components)

# Get a query parameter value from a URI
fn get_query_param(uri: text, key: text) -> text:
    var components = parse_uri(uri)
    var params = parse_query_string(components.query)

    var i = 0
    while i < array_length(params):
        var param = array_get(params, i)
        if param.key == key:
            return param.value
        i = i + 1

    ""

# Get all values for a query parameter (for keys that appear multiple times)
fn get_query_param_all(uri: text, key: text) -> array:
    var components = parse_uri(uri)
    var params = parse_query_string(components.query)
    var values = []

    var i = 0
    while i < array_length(params):
        var param = array_get(params, i)
        if param.key == key:
            values = array_push(values, param.value)
        i = i + 1

    values

# Update or add a query parameter
fn set_query_param(uri: text, key: text, value: text) -> text:
    var components = parse_uri(uri)
    var params = parse_query_string(components.query)
    var found = false
    var updated = []

    var i = 0
    while i < array_length(params):
        var param = array_get(params, i)
        if param.key == key:
            if not found:
                var new_param = QueryParam(key: key, value: value)
                updated = array_push(updated, new_param)
                found = true
            # Skip duplicate keys
        else:
            updated = array_push(updated, param)
        i = i + 1

    if not found:
        var new_param = QueryParam(key: key, value: value)
        updated = array_push(updated, new_param)

    components.query = build_query_string(updated)
    build_uri(components)

