# Digital Signature Verification Module
# RSA and DSA signature verification functions

# =============================================================================
# RSA PKCS#1 v1.5 Verification
# =============================================================================

fn rsa_verify_pkcs1(message: text, signature: tuple, public_key: tuple) -> bool:
    """Verify RSA PKCS#1 v1.5 signature."""
    # Get signature value
    val s = signature_r(signature)

    # Get key components
    val n = rsa_public_key_n(public_key)
    val e = rsa_public_key_e(public_key)

    # Decrypt signature: em = s^e mod n
    val em_int = mod_pow(s, e, n)

    # Convert to bytes
    val em_bytes = int_to_bytes(em_int, 32)

    # Decode to extract hash
    val decoded_hash = emsa_pkcs1_decode(em_bytes)

    if decoded_hash < 0:
        return false

    # Hash message
    val computed_hash = hash_for_signature(message, "RSA-PKCS1")

    # Compare hashes
    decoded_hash == computed_hash

# =============================================================================
# RSA-PSS Verification
# =============================================================================

fn pss_verify_encoding(hash_value: i64, encoded: list, em_bits: i64, salt_len: i64) -> bool:
    """Verify PSS encoding."""
    val em_len = (em_bits + 7) / 8
    val h_len = 8

    if encoded.len() < em_len:
        return false

    # Check last byte
    if encoded.get(encoded.len() - 1) != 0xbc:
        return false

    # Extract maskedDB and H
    val masked_db_len = em_len - h_len - 1
    var masked_db = []
    var i = 0
    while i < masked_db_len:
        masked_db.push(encoded.get(i))
        i = i + 1

    var h_bytes = []
    var j = masked_db_len
    while j < masked_db_len + h_len:
        h_bytes.push(encoded.get(j))
        j = j + 1

    val h = bytes_to_int(h_bytes)

    # dbMask = MGF(H, len(maskedDB))
    val db_mask = mgf1_simple(h, masked_db_len)

    # DB = maskedDB XOR dbMask
    val db = xor_bytes(masked_db, db_mask)

    # Extract salt (last salt_len bytes of DB)
    val ps_len = masked_db_len - salt_len - 1

    # Check PS is all zeros
    var p = 0
    while p < ps_len:
        if db.get(p) != 0x00:
            return false
        p = p + 1

    # Check 0x01 separator
    if db.get(ps_len) != 0x01:
        return false

    # Extract salt
    var salt = []
    var s = ps_len + 1
    while s < db.len():
        salt.push(db.get(s))
        s = s + 1

    # M' = 8*0x00 || hash || salt
    var m_prime = []
    var z = 0
    while z < 8:
        m_prime.push(0x00)
        z = z + 1

    val hash_bytes = int_to_bytes(hash_value, h_len)
    var hb = 0
    while hb < hash_bytes.len():
        m_prime.push(hash_bytes.get(hb))
        hb = hb + 1

    var sb = 0
    while sb < salt.len():
        m_prime.push(salt.get(sb))
        sb = sb + 1

    # H' = Hash(M')
    val h_prime = hash_bytes_simple(m_prime)

    # Compare H == H'
    h == h_prime

fn rsa_verify_pss(message: text, signature: tuple, public_key: tuple, salt_len: i64) -> bool:
    """Verify RSA-PSS signature."""
    # Get signature value
    val s = signature_r(signature)

    # Get key components
    val n = rsa_public_key_n(public_key)
    val e = rsa_public_key_e(public_key)

    # Decrypt signature: em = s^e mod n
    val em_int = mod_pow(s, e, n)

    # Convert to bytes
    val em_bits = 256
    val em_len = (em_bits + 7) / 8
    val em_bytes = int_to_bytes(em_int, em_len)

    # Hash message
    val hash_value = hash_for_signature(message, "RSA-PSS")

    # Verify PSS encoding
    pss_verify_encoding(hash_value, em_bytes, em_bits, salt_len)

# =============================================================================
# DSA Verification
# =============================================================================

fn dsa_verify(message: text, signature: tuple, public_key: tuple) -> bool:
    """Verify DSA signature."""
    val params = dsa_public_key_params(public_key)
    val p = dsa_params_p(params)
    val q = dsa_params_q(params)
    val g = dsa_params_g(params)
    val y = dsa_public_key_y(public_key)

    val r = signature_r(signature)
    val s = signature_s(signature)

    # Check bounds
    if r <= 0:
        return false
    if r >= q:
        return false
    if s <= 0:
        return false
    if s >= q:
        return false

    # Hash message
    val h = hash_for_signature(message, "DSA")
    val h_mod_q = h % q

    # w = s^(-1) mod q
    val w = mod_inverse(s, q)

    # u1 = h * w mod q
    val u1 = (h_mod_q * w) % q

    # u2 = r * w mod q
    val u2 = (r * w) % q

    # v = ((g^u1 * y^u2) mod p) mod q
    val g_u1 = mod_pow(g, u1, p)
    val y_u2 = mod_pow(y, u2, p)
    val v = ((g_u1 * y_u2) % p) % q

    # Accept if v == r
    v == r

# =============================================================================
# Auto Verification
# =============================================================================

fn verify_signature_auto(message: text, signature: tuple, public_key: tuple) -> bool:
    """Automatically verify signature based on algorithm."""
    val algo = signature_algorithm(signature)

    if algo == "RSA-PKCS1":
        return rsa_verify_pkcs1(message, signature, public_key)

    if algo == "RSA-PSS":
        val salt_len = signature_s(signature)
        return rsa_verify_pss(message, signature, public_key, salt_len)

    if algo == "DSA":
        return dsa_verify(message, signature, public_key)

    false

fn batch_verify_signatures(messages: list, signatures: list, public_keys: list) -> bool:
    """Batch verify multiple signatures."""
    if messages.len() != signatures.len():
        return false

    if messages.len() != public_keys.len():
        return false

    var i = 0
    while i < messages.len():
        val msg = messages.get(i)
        val sig = signatures.get(i)
        val key = public_keys.get(i)

        val valid = verify_signature_auto(msg, sig, key)
        if !valid:
            return false

        i = i + 1

    true

# =============================================================================
# Multi-Signature Verification
# =============================================================================

fn verify_aggregate(message: text, agg_sig: tuple, public_keys: list) -> bool:
    """Verify aggregated signature (simplified)."""
    if public_keys.len() == 0:
        return false

    # Simplified: verify against first key
    val first_key = public_keys.get(0)
    rsa_verify_pkcs1(message, agg_sig, first_key)
