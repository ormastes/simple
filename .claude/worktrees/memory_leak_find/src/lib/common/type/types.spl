# Core Type System
#
# Type representations, substitution, type schemes, and type errors.
# Port of rust/type/src/lib.rs (core types section)

export Type, TypeScheme, Substitution, TypeError, ConstKeyValidation
export FunctionType, MixinInfo, RequiredMethodSig
export validate_dict_keys_against_const_set

# Full type system
enum Type:
    Int
    Bool
    Str
    Float
    Nil
    Var(id: i64)
    Function(params: [Type], ret: Type)
    Array(element: Type)
    Union(members: [Type])
    TaggedUnion(name: text)
    Bitfield(name: text)
    Generic(name: text, args: [Type])
    TypeParam(name: text)
    Named(name: text)
    Tuple(elements: [Type])
    Dict(key: Type, value: Type)
    Optional(inner: Type)
    Borrow(inner: Type)
    BorrowMut(inner: Type)
    Constructor(target: Type, args: [Type]?)
    Simd(lanes: i64, element: Type)
    DynTrait(name: text)
    ConstKeySet(keys: [text])
    DependentKeys(source: text)

impl Type:
    # Apply substitution to this type
    fn apply_subst(subst: Substitution) -> Type:
        match self:
            case Type.Var(id):
                val resolved = subst.get(id)
                if resolved.?:
                    resolved.unwrap().apply_subst(subst)
                else:
                    self
            case Type.Function(params, ret):
                Type.Function(
                    params: params.map(\p: p.apply_subst(subst)),
                    ret: ret.apply_subst(subst))
            case Type.Array(elem):
                Type.Array(element: elem.apply_subst(subst))
            case Type.Union(members):
                Type.Union(members: members.map(\m: m.apply_subst(subst)))
            case Type.Generic(name, args):
                Type.Generic(name: name, args: args.map(\a: a.apply_subst(subst)))
            case Type.Tuple(elements):
                Type.Tuple(elements: elements.map(\e: e.apply_subst(subst)))
            case Type.Dict(key, value):
                Type.Dict(key: key.apply_subst(subst), value: value.apply_subst(subst))
            case Type.Optional(inner):
                Type.Optional(inner: inner.apply_subst(subst))
            case Type.Borrow(inner):
                Type.Borrow(inner: inner.apply_subst(subst))
            case Type.BorrowMut(inner):
                Type.BorrowMut(inner: inner.apply_subst(subst))
            case Type.Simd(lanes, elem):
                Type.Simd(lanes: lanes, element: elem.apply_subst(subst))
            case _: self

    # Substitute type parameters with concrete types
    fn substitute_type_params(subst: Dict<text, Type>) -> Type:
        match self:
            case Type.TypeParam(name):
                if subst.has(name): subst[name] else: self
            case Type.Function(params, ret):
                Type.Function(
                    params: params.map(\p: p.substitute_type_params(subst)),
                    ret: ret.substitute_type_params(subst))
            case Type.Array(elem):
                Type.Array(element: elem.substitute_type_params(subst))
            case Type.Union(members):
                Type.Union(members: members.map(\m: m.substitute_type_params(subst)))
            case Type.Generic(name, args):
                Type.Generic(name: name, args: args.map(\a: a.substitute_type_params(subst)))
            case Type.Tuple(elements):
                Type.Tuple(elements: elements.map(\e: e.substitute_type_params(subst)))
            case Type.Dict(key, value):
                Type.Dict(key: key.substitute_type_params(subst),
                          value: value.substitute_type_params(subst))
            case Type.Optional(inner):
                Type.Optional(inner: inner.substitute_type_params(subst))
            case Type.Borrow(inner):
                Type.Borrow(inner: inner.substitute_type_params(subst))
            case Type.BorrowMut(inner):
                Type.BorrowMut(inner: inner.substitute_type_params(subst))
            case Type.Constructor(target, args):
                Type.Constructor(
                    target: target.substitute_type_params(subst),
                    args: if args.?: Some(args.unwrap().map(\a: a.substitute_type_params(subst))) else: nil)
            case Type.Simd(lanes, elem):
                Type.Simd(lanes: lanes, element: elem.substitute_type_params(subst))
            case _: self

    # Check if this type contains the given type variable
    fn contains_var(var_id: i64) -> bool:
        match self:
            case Type.Var(id): id == var_id
            case Type.Function(params, ret):
                params.any(\p: p.contains_var(var_id)) or ret.contains_var(var_id)
            case Type.Array(elem): elem.contains_var(var_id)
            case Type.Union(members): members.any(\m: m.contains_var(var_id))
            case Type.Generic(_, args): args.any(\a: a.contains_var(var_id))
            case Type.Tuple(elements): elements.any(\e: e.contains_var(var_id))
            case Type.Dict(key, value): key.contains_var(var_id) or value.contains_var(var_id)
            case Type.Optional(inner): inner.contains_var(var_id)
            case Type.Borrow(inner): inner.contains_var(var_id)
            case Type.BorrowMut(inner): inner.contains_var(var_id)
            case Type.Simd(_, elem): elem.contains_var(var_id)
            case _: false

# Type scheme: forall vars. ty (polymorphic type)
struct TypeScheme:
    vars: [i64]
    ty: Type

impl TypeScheme:
    static fn mono(ty: Type) -> TypeScheme:
        TypeScheme(vars: [], ty: ty)

    static fn poly(vars: [i64], ty: Type) -> TypeScheme:
        TypeScheme(vars: vars, ty: ty)

# Substitution map for type variables
class Substitution:
    map: Dict<i64, Type>

impl Substitution:
    static fn empty() -> Substitution:
        Substitution(map: {})

    fn get(id: i64) -> Type?:
        if self.map.has(id):
            Some(self.map[id])
        else:
            nil

    me insert(id: i64, ty: Type):
        self.map[id] = ty

    # Compose: self âˆ˜ other
    me compose(other: Substitution):
        for id in other.map.keys():
            val new_ty = other.map[id].apply_subst(self)
            self.map[id] = new_ty

# Type error
enum TypeError:
    Mismatch(expected: Type, found: Type)
    Undefined(name: text)
    OccursCheck(var_id: i64, ty: Type)
    Other(message: text)
    ConstKeyNotFound(key: text, expected_keys: [text])
    ConstKeyMissing(key: text, provided_keys: [text])
    ConstKeyMustBeLiteral(found: text)

impl TypeError:
    fn message() -> text:
        match self:
            case TypeError.Mismatch(expected, found):
                "type mismatch: expected {expected}, found {found}"
            case TypeError.Undefined(name): "undefined: {name}"
            case TypeError.OccursCheck(var_id, ty):
                "infinite type: variable {var_id} occurs in {ty}"
            case TypeError.Other(msg): msg
            case TypeError.ConstKeyNotFound(key, expected):
                "unknown key '{key}', expected one of: {expected.join(\", \")}"
            case TypeError.ConstKeyMissing(key, provided):
                "missing required key '{key}'"
            case TypeError.ConstKeyMustBeLiteral(found):
                "dict key must be a string literal, found: {found}"

# Function type for method signatures
struct FunctionType:
    params: [Type]
    ret: Type

impl FunctionType:
    fn substitute_type_params(subst: Dict<text, Type>) -> FunctionType:
        FunctionType(
            params: self.params.map(\p: p.substitute_type_params(subst)),
            ret: self.ret.substitute_type_params(subst))

# Required method signature in a mixin
struct RequiredMethodSig:
    name: text
    params: [Type]
    ret: Type

impl RequiredMethodSig:
    fn substitute_type_params(subst: Dict<text, Type>) -> RequiredMethodSig:
        RequiredMethodSig(
            name: self.name,
            params: self.params.map(\p: p.substitute_type_params(subst)),
            ret: self.ret.substitute_type_params(subst))

# Mixin metadata for type checking
struct MixinInfo:
    name: text
    type_params: [text]
    fields: [(text, Type)]
    methods: [(text, FunctionType)]
    required_traits: [text]
    required_mixins: [text]
    required_methods: [RequiredMethodSig]

impl MixinInfo:
    fn instantiate(type_args: [Type]) -> Result<MixinInfo, text>:
        if type_args.len() != self.type_params.len():
            return Err("Mixin {self.name} expects {self.type_params.len()} type arguments, got {type_args.len()}")

        var subst = {}
        for i in 0..self.type_params.len():
            subst[self.type_params[i]] = type_args[i]

        val fields = self.fields.map(\f: (f.0, f.1.substitute_type_params(subst)))
        val methods = self.methods.map(\m: (m.0, m.1.substitute_type_params(subst)))
        val required_methods = self.required_methods.map(\s: s.substitute_type_params(subst))

        Ok(MixinInfo(
            name: self.name, type_params: [], fields: fields,
            methods: methods, required_traits: self.required_traits,
            required_mixins: self.required_mixins,
            required_methods: required_methods))

# Const key validation result
struct ConstKeyValidation:
    unknown_keys: [text]
    missing_keys: [text]
    non_literal_keys: bool

impl ConstKeyValidation:
    fn is_valid() -> bool:
        self.unknown_keys.len() == 0 and self.missing_keys.len() == 0 and not self.non_literal_keys

# Validate dict keys against expected const key set
fn validate_dict_keys_against_const_set(dict_keys: [text?], expected_keys: [text]) -> ConstKeyValidation:
    var unknown_keys = []
    var provided_keys = []
    var non_literal_keys = false

    for key in dict_keys:
        if key.?:
            val k = key.unwrap()
            provided_keys.push(k)
            if not expected_keys.contains(k):
                unknown_keys.push(k)
        else:
            non_literal_keys = true

    val missing_keys = expected_keys.filter(\k: not provided_keys.contains(k))

    ConstKeyValidation(
        unknown_keys: unknown_keys,
        missing_keys: missing_keys,
        non_literal_keys: non_literal_keys)
