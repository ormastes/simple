# Skip List â€” Statistics, Set Operations, and Utility Functions
#
# Extracted from skiplist_utils.spl. Contains:
# - Statistics: sl_size, sl_height, sl_is_empty, sl_max_level, sl_probability
# - Percentile/Median: sl_percentile, sl_median
# - Set operations: sl_union, sl_intersection, sl_difference, sl_symmetric_difference
# - Comparison: sl_equals, sl_is_subset, sl_is_disjoint
# - Management: sl_clear, sl_clone, sl_count_level_usage, sl_node_count, sl_average_level
# - Map utilities: slm_size, slm_is_empty, slm_clear

use lib.common.skiplist_utils.{sl_get_size, sl_get_current_level, sl_get_at, sl_get_nodes, sl_get_max_level, sl_get_probability}
use lib.common.skiplist_utils.{sl_to_list, sl_insert_many, sl_search, create_skiplist_with_params, get_node_level}
use lib.common.skiplist_utils.{slm_get_keys, slm_set_keys, slm_set_entries}
use lib.common.skiplist_utils.{sl_intersection}

fn sl_size(skiplist: tuple) -> i64:
    sl_get_size(skiplist)

fn sl_height(skiplist: tuple) -> i64:
    var current_level = sl_get_current_level(skiplist)
    current_level + 1

fn sl_is_empty(skiplist: tuple) -> i64:
    var size = sl_get_size(skiplist)
    if size == 0:
        1
    else:
        0

fn sl_max_level(skiplist: tuple) -> i64:
    sl_get_max_level(skiplist)

fn sl_probability(skiplist: tuple) -> f64:
    sl_get_probability(skiplist)

fn sl_percentile(skiplist: tuple, p: f64) -> i64:
    var size = sl_size(skiplist)
    if size == 0:
        return 0

    var pf = p
    var sizef = size
    var index_float = pf * sizef
    var index = index_float

    if index >= size:
        index = size - 1

    if index < 0:
        index = 0

    sl_get_at(skiplist, index)

fn sl_median(skiplist: tuple) -> i64:
    sl_percentile(skiplist, 0.5)

fn sl_union(skiplist1: tuple, skiplist2: tuple) -> list:
    var list1 = sl_to_list(skiplist1)
    var list2 = sl_to_list(skiplist2)

    var result = []
    var i1 = 0
    var i2 = 0

    while i1 < list1.len():
        if i2 >= list2.len():
            var v1 = list1[i1]
            result = result + [v1]
            i1 = i1 + 1
        else:
            var v1 = list1[i1]
            var v2 = list2[i2]
            if v1 < v2:
                result = result + [v1]
                i1 = i1 + 1
            else:
                if v1 == v2:
                    result = result + [v1]
                    i1 = i1 + 1
                    i2 = i2 + 1
                else:
                    result = result + [v2]
                    i2 = i2 + 1

    while i2 < list2.len():
        var v2 = list2[i2]
        result = result + [v2]
        i2 = i2 + 1

    result

fn sl_intersection(skiplist1: tuple, skiplist2: tuple) -> list:
    var list1 = sl_to_list(skiplist1)
    var list2 = sl_to_list(skiplist2)

    var result = []
    var i1 = 0
    var i2 = 0

    while i1 < list1.len():
        if i2 >= list2.len():
            break

        var v1 = list1[i1]
        var v2 = list2[i2]

        if v1 == v2:
            result = result + [v1]
            i1 = i1 + 1
            i2 = i2 + 1
        else:
            if v1 < v2:
                i1 = i1 + 1
            else:
                i2 = i2 + 1

    result

fn sl_difference(skiplist1: tuple, skiplist2: tuple) -> list:
    var list1 = sl_to_list(skiplist1)
    var list2 = sl_to_list(skiplist2)

    var result = []
    var i1 = 0
    var i2 = 0

    while i1 < list1.len():
        var v1 = list1[i1]

        if i2 >= list2.len():
            result = result + [v1]
            i1 = i1 + 1
        else:
            var v2 = list2[i2]

            if v1 == v2:
                i1 = i1 + 1
                i2 = i2 + 1
            else:
                if v1 < v2:
                    result = result + [v1]
                    i1 = i1 + 1
                else:
                    i2 = i2 + 1

    result

fn sl_symmetric_difference(skiplist1: tuple, skiplist2: tuple) -> list:
    var diff1 = sl_difference(skiplist1, skiplist2)
    var diff2 = sl_difference(skiplist2, skiplist1)

    var result = []
    var i1 = 0
    var i2 = 0

    while i1 < diff1.len():
        if i2 >= diff2.len():
            var v1 = diff1[i1]
            result = result + [v1]
            i1 = i1 + 1
        else:
            var v1 = diff1[i1]
            var v2 = diff2[i2]
            if v1 < v2:
                result = result + [v1]
                i1 = i1 + 1
            else:
                result = result + [v2]
                i2 = i2 + 1

    while i2 < diff2.len():
        var v2 = diff2[i2]
        result = result + [v2]
        i2 = i2 + 1

    result

fn sl_equals(skiplist1: tuple, skiplist2: tuple) -> i64:
    var list1 = sl_to_list(skiplist1)
    var list2 = sl_to_list(skiplist2)

    if list1.len() != list2.len():
        return 0

    var i = 0
    while i < list1.len():
        var v1 = list1[i]
        var v2 = list2[i]
        if v1 != v2:
            return 0
        i = i + 1

    1

fn sl_is_subset(skiplist1: tuple, skiplist2: tuple) -> i64:
    var list1 = sl_to_list(skiplist1)
    var list2 = sl_to_list(skiplist2)

    var i1 = 0
    var i2 = 0

    while i1 < list1.len():
        if i2 >= list2.len():
            return 0

        var v1 = list1[i1]
        var v2 = list2[i2]

        if v1 == v2:
            i1 = i1 + 1
            i2 = i2 + 1
        else:
            if v1 < v2:
                return 0
            else:
                i2 = i2 + 1

    1

fn sl_is_disjoint(skiplist1: tuple, skiplist2: tuple) -> i64:
    var intersection = sl_intersection(skiplist1, skiplist2)
    if intersection.len() == 0:
        1
    else:
        0

fn sl_clear(skiplist: tuple) -> tuple:
    var max_level = sl_get_max_level(skiplist)
    var probability = sl_get_probability(skiplist)
    create_skiplist_with_params(max_level, probability)

fn sl_clone(skiplist: tuple) -> tuple:
    var max_level = sl_get_max_level(skiplist)
    var probability = sl_get_probability(skiplist)
    var result = create_skiplist_with_params(max_level, probability)
    var values = sl_to_list(skiplist)
    sl_insert_many(result, values)

fn sl_count_level_usage(skiplist: tuple) -> list:
    var nodes = sl_get_nodes(skiplist)
    var max_level = sl_get_max_level(skiplist)

    var counts = []
    var i = 0
    while i <= max_level:
        counts = counts + [0]
        i = i + 1

    var node_idx = 0
    while node_idx < nodes.len():
        var node = nodes[node_idx]
        var level = get_node_level(node)

        var new_counts = []
        var j = 0
        while j <= max_level:
            if j <= level:
                var old_count = counts[j]
                new_counts = new_counts + [old_count + 1]
            else:
                var old_count = counts[j]
                new_counts = new_counts + [old_count]
            j = j + 1
        counts = new_counts

        node_idx = node_idx + 1

    counts

fn sl_node_count(skiplist: tuple) -> i64:
    var nodes = sl_get_nodes(skiplist)
    nodes.len()

fn sl_average_level(skiplist: tuple) -> f64:
    var nodes = sl_get_nodes(skiplist)
    var total_levels = 0
    var count = 0

    var i = 1
    while i < nodes.len():
        var node = nodes[i]
        var level = get_node_level(node)
        total_levels = total_levels + level
        count = count + 1
        i = i + 1

    if count == 0:
        return 0.0

    var total_float = total_levels
    var count_float = count
    total_float / count_float

fn slm_size(map: tuple) -> i64:
    var keys = slm_get_keys(map)
    sl_size(keys)

fn slm_is_empty(map: tuple) -> i64:
    var keys = slm_get_keys(map)
    sl_is_empty(keys)

fn slm_clear(map: tuple) -> tuple:
    var keys = slm_get_keys(map)
    var cleared_keys = sl_clear(keys)
    var result = slm_set_keys(map, cleared_keys)
    result = slm_set_entries(result, [])
    result
