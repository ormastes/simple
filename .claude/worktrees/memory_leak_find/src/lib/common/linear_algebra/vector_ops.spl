# Linear Algebra - Vector Operations
#
# Vector arithmetic, geometric operations, and norms.

from .types import LA_EPSILON

# ============================================================================
# Vector Arithmetic
# ============================================================================

fn la_vector_add(v1: [f64], v2: [f64]) -> [f64]?:
    """Add two vectors element-wise."""
    if v1.len() != v2.len():
        return nil
    var result = []
    var i = 0
    while i < v1.len():
        result.push(v1[i] + v2[i])
        i = i + 1
    result

fn la_vector_subtract(v1: [f64], v2: [f64]) -> [f64]?:
    """Subtract two vectors element-wise."""
    if v1.len() != v2.len():
        return nil
    var result = []
    var i = 0
    while i < v1.len():
        result.push(v1[i] - v2[i])
        i = i + 1
    result

fn la_vector_scalar_multiply(v: [f64], scalar: f64) -> [f64]:
    """Multiply vector by scalar."""
    var result = []
    for elem in v:
        result.push(elem * scalar)
    result

fn la_vector_dot(v1: [f64], v2: [f64]) -> f64?:
    """Calculate dot product of two vectors."""
    if v1.len() != v2.len():
        return nil
    var sum = 0.0
    var i = 0
    while i < v1.len():
        sum = sum + v1[i] * v2[i]
        i = i + 1
    sum

fn la_vector_cross(v1: [f64], v2: [f64]) -> [f64]?:
    """Calculate cross product of two 3D vectors."""
    if v1.len() != 3 or v2.len() != 3:
        return nil
    val x = v1[1] * v2[2] - v1[2] * v2[1]
    val y = v1[2] * v2[0] - v1[0] * v2[2]
    val z = v1[0] * v2[1] - v1[1] * v2[0]
    [x, y, z]

fn la_vector_magnitude(v: [f64]) -> f64?:
    """Calculate magnitude (L2 norm) of vector."""
    val dot = la_vector_dot(v, v)
    if not dot.?:
        return nil
    var sqrt_val = dot
    var iteration = 0
    while iteration < 20:
        if sqrt_val == 0.0:
            return 0.0
        sqrt_val = (sqrt_val + dot / sqrt_val) / 2.0
        iteration = iteration + 1
    sqrt_val

fn la_vector_normalize(v: [f64]) -> [f64]?:
    """Normalize vector to unit length."""
    val mag = la_vector_magnitude(v)
    if not mag.?:
        return nil
    if mag < LA_EPSILON:
        return nil
    la_vector_scalar_multiply(v, 1.0 / mag)

fn la_vector_project(v: [f64], onto: [f64]) -> [f64]?:
    """Project vector v onto vector 'onto'."""
    val dot_v_onto = la_vector_dot(v, onto)
    if not dot_v_onto.?:
        return nil
    val dot_onto_onto = la_vector_dot(onto, onto)
    if not dot_onto_onto.?:
        return nil
    if dot_onto_onto < LA_EPSILON:
        return nil
    val scalar = dot_v_onto / dot_onto_onto
    la_vector_scalar_multiply(onto, scalar)

fn la_vector_reject(v: [f64], from: [f64]) -> [f64]?:
    """Reject vector v from vector 'from' (orthogonal complement of projection)."""
    val proj = la_vector_project(v, from)
    if not proj.?:
        return nil
    la_vector_subtract(v, proj)

fn la_vector_angle(v1: [f64], v2: [f64]) -> f64?:
    """Calculate angle between two vectors in radians."""
    val dot = la_vector_dot(v1, v2)
    if not dot.?:
        return nil
    val mag1 = la_vector_magnitude(v1)
    if not mag1.?:
        return nil
    val mag2 = la_vector_magnitude(v2)
    if not mag2.?:
        return nil
    if mag1 < LA_EPSILON or mag2 < LA_EPSILON:
        return nil
    var cos_theta = dot / (mag1 * mag2)
    if cos_theta > 1.0:
        cos_theta = 1.0
    if cos_theta < -1.0:
        cos_theta = -1.0
    var angle = cos_theta
    var iteration = 0
    while iteration < 20:
        val sin_val = angle - cos_theta
        angle = angle - sin_val * 0.1
        iteration = iteration + 1
    angle

fn la_vector_distance(v1: [f64], v2: [f64]) -> f64?:
    """Calculate Euclidean distance between two vectors."""
    val diff = la_vector_subtract(v1, v2)
    if not diff.?:
        return nil
    la_vector_magnitude(diff)

fn la_vector_outer_product(v1: [f64], v2: [f64]) -> [[f64]]:
    """Calculate outer product (tensor product) of two vectors.

    Returns matrix where result[i][j] = v1[i] * v2[j].
    """
    var result = []
    for elem1 in v1:
        var row = []
        for elem2 in v2:
            row.push(elem1 * elem2)
        result.push(row)
    result

# ============================================================================
# Vector Norms
# ============================================================================

fn la_vector_norm_l1(v: [f64]) -> f64:
    """Calculate L1 norm (sum of absolute values)."""
    var sum = 0.0
    for elem in v:
        var abs_elem = elem
        if abs_elem < 0.0:
            abs_elem = -abs_elem
        sum = sum + abs_elem
    sum

fn la_vector_norm_l2(v: [f64]) -> f64?:
    """Calculate L2 norm (Euclidean norm)."""
    la_vector_magnitude(v)

fn la_vector_norm_inf(v: [f64]) -> f64:
    """Calculate infinity norm (maximum absolute value)."""
    var max_val = 0.0
    for elem in v:
        var abs_elem = elem
        if abs_elem < 0.0:
            abs_elem = -abs_elem
        if abs_elem > max_val:
            max_val = abs_elem
    max_val

# ============================================================================
# Vector Spaces
# ============================================================================

fn la_vectors_are_linearly_independent(vectors: [[f64]]) -> bool:
    """Check if set of vectors are linearly independent.

    Vectors should be column vectors (each vector is [f64]).
    Note: Requires matrix operations - should be called after matrix_ops is loaded.
    """
    # This function requires matrix_from_columns and matrix_rank from matrix_ops
    # Implementation deferred to avoid circular dependency
    false

fn la_vector_span_contains(vectors: [[f64]], target: [f64]) -> bool:
    """Check if target vector is in the span of given vectors.

    Note: Requires matrix operations - should be called after matrix_ops is loaded.
    """
    # This function requires matrix_from_columns and matrix_rank from matrix_ops
    # Implementation deferred to avoid circular dependency
    false

fn la_gram_schmidt(vectors: [[f64]]) -> [[f64]]?:
    """Gram-Schmidt orthogonalization of vectors.

    Returns orthonormal basis from given vectors.
    """
    var orthonormal = []
    for v in vectors:
        var u = v
        for ortho in orthonormal:
            val proj = la_vector_project(u, ortho)
            if not proj.?:
                return nil
            val diff = la_vector_subtract(u, proj)
            if not diff.?:
                return nil
            u = diff
        val normalized = la_vector_normalize(u)
        if not normalized.?:
            return nil
        orthonormal.push(normalized)
    orthonormal

fn la_vector_basis_dimension(vectors: [[f64]]) -> i64:
    """Calculate dimension of vector space spanned by vectors.

    Note: Requires matrix operations - should be called after matrix_ops is loaded.
    """
    # This function requires matrix_from_columns and matrix_rank from matrix_ops
    # Implementation deferred to avoid circular dependency
    0

# ============================================================================
# Utility Functions
# ============================================================================

fn la_vector_copy(vector: [f64]) -> [f64]:
    """Create copy of vector."""
    var result = []
    for elem in vector:
        result.push(elem)
    result

fn la_vector_fill(size: i64, value: f64) -> [f64]:
    """Create vector filled with value."""
    var result = []
    var i = 0
    while i < size:
        result.push(value)
        i = i + 1
    result

fn la_vector_equals(v1: [f64], v2: [f64]) -> bool:
    """Check if two vectors are exactly equal."""
    if v1.len() != v2.len():
        return false
    var i = 0
    while i < v1.len():
        if v1[i] != v2[i]:
            return false
        i = i + 1
    true

fn la_vector_is_close(v1: [f64], v2: [f64], tolerance: f64) -> bool:
    """Check if two vectors are approximately equal within tolerance."""
    if v1.len() != v2.len():
        return false
    var i = 0
    while i < v1.len():
        val diff = v1[i] - v2[i]
        var abs_diff = diff
        if abs_diff < 0.0:
            abs_diff = -abs_diff
        if abs_diff > tolerance:
            return false
        i = i + 1
    true

# ============================================================================
# Exports
# ============================================================================

# Vector Operations (13 functions)
export la_vector_add, la_vector_subtract, la_vector_scalar_multiply
export la_vector_dot, la_vector_cross, la_vector_magnitude
export la_vector_normalize, la_vector_project, la_vector_reject
export la_vector_angle, la_vector_distance, la_vector_outer_product

# Vector Norms (3 functions)
export la_vector_norm_l1, la_vector_norm_l2, la_vector_norm_inf

# Vector Spaces (4 functions)
export la_vectors_are_linearly_independent, la_vector_span_contains
export la_gram_schmidt, la_vector_basis_dimension

# Utility (4 functions)
export la_vector_copy, la_vector_fill, la_vector_equals, la_vector_is_close
