# Tree Modification Operations
#
# Functions for modifying trees: BST operations, transformations.

# ============================================================================
# Exports
# ============================================================================

export bst_insert, bst_delete, mirror
export heap_parent, heap_left, heap_right
export min_heapify_down, max_heapify_down, min_heapify_up, max_heapify_up
export build_min_heap, build_max_heap
export heap_insert_min, heap_insert_max, extract_min, extract_max
export heap_sort

# ============================================================================
# Binary Search Tree Operations
# ============================================================================

fn bst_insert(tree, value):
    """Insert value into BST.

    Example:
        bst_insert(tree, 7)
    """
    if not tree.?:
        return create_leaf(value)

    val (node_val, left, right) = tree

    if value < node_val:
        val new_left = bst_insert(left, value)
        create_node(node_val, new_left, right)
    else:
        if value > node_val:
            val new_right = bst_insert(right, value)
            create_node(node_val, left, new_right)
        else:
            tree

fn bst_delete(tree, value):
    """Delete value from BST.

    Example:
        bst_delete(tree, 7)
    """
    if not tree.?:
        return nil

    val (node_val, left, right) = tree

    if value < node_val:
        val new_left = bst_delete(left, value)
        create_node(node_val, new_left, right)
    else:
        if value > node_val:
            val new_right = bst_delete(right, value)
            create_node(node_val, left, new_right)
        else:
            # Node to delete found
            if not left.?:
                return right
            if not right.?:
                return left

            # Node has two children - replace with min from right subtree
            val min_val = bst_min(right)
            val new_right = bst_delete(right, min_val)
            create_node(min_val, left, new_right)

fn mirror(tree):
    """Create mirror image of tree (swap left and right).

    Example:
        mirror(tree)  # Tree with left and right swapped
    """
    if not tree.?:
        return nil

    val (value, left, right) = tree
    val new_left = mirror(right)
    val new_right = mirror(left)
    create_node(value, new_left, new_right)

# ============================================================================
# Heap Operations (Array-based)
# ============================================================================

fn heap_parent(index: i64) -> i64:
    """Get parent index in heap."""
    (index - 1) / 2

fn heap_left(index: i64) -> i64:
    """Get left child index in heap."""
    2 * index + 1

fn heap_right(index: i64) -> i64:
    """Get right child index in heap."""
    2 * index + 2

fn min_heapify_down(heap, index: i64):
    """Restore min-heap property downward from index.

    Modifies heap in place.
    """
    val size = heap.len()
    var smallest = index
    val left = heap_left(index)
    val right = heap_right(index)

    if left < size and heap[left] < heap[smallest]:
        smallest = left

    if right < size and heap[right] < heap[smallest]:
        smallest = right

    if smallest != index:
        # Swap
        val temp = heap[index]
        heap[index] = heap[smallest]
        heap[smallest] = temp
        min_heapify_down(heap, smallest)

fn max_heapify_down(heap, index: i64):
    """Restore max-heap property downward from index.

    Modifies heap in place.
    """
    val size = heap.len()
    var largest = index
    val left = heap_left(index)
    val right = heap_right(index)

    if left < size and heap[left] > heap[largest]:
        largest = left

    if right < size and heap[right] > heap[largest]:
        largest = right

    if largest != index:
        # Swap
        val temp = heap[index]
        heap[index] = heap[largest]
        heap[largest] = temp
        max_heapify_down(heap, largest)

fn min_heapify_up(heap, index: i64):
    """Restore min-heap property upward from index.

    Modifies heap in place.
    """
    if index == 0:
        return

    val parent = heap_parent(index)
    if heap[index] < heap[parent]:
        # Swap
        val temp = heap[index]
        heap[index] = heap[parent]
        heap[parent] = temp
        min_heapify_up(heap, parent)

fn max_heapify_up(heap, index: i64):
    """Restore max-heap property upward from index.

    Modifies heap in place.
    """
    if index == 0:
        return

    val parent = heap_parent(index)
    if heap[index] > heap[parent]:
        # Swap
        val temp = heap[index]
        heap[index] = heap[parent]
        heap[parent] = temp
        max_heapify_up(heap, parent)

fn build_min_heap(arr):
    """Build min-heap from array.

    Modifies array in place to satisfy heap property.

    Example:
        build_min_heap([5, 3, 8, 1, 9])  # [1, 3, 8, 5, 9]
    """
    val size = arr.len()
    var i = size / 2 - 1

    while i >= 0:
        min_heapify_down(arr, i)
        i = i - 1

    arr

fn build_max_heap(arr):
    """Build max-heap from array.

    Modifies array in place to satisfy heap property.

    Example:
        build_max_heap([5, 3, 8, 1, 9])  # [9, 5, 8, 1, 3]
    """
    val size = arr.len()
    var i = size / 2 - 1

    while i >= 0:
        max_heapify_down(arr, i)
        i = i - 1

    arr

fn heap_insert_min(heap, value):
    """Insert value into min-heap.

    Example:
        heap_insert_min(heap, 4)
    """
    heap.push(value)
    min_heapify_up(heap, heap.len() - 1)

fn heap_insert_max(heap, value):
    """Insert value into max-heap.

    Example:
        heap_insert_max(heap, 4)
    """
    heap.push(value)
    max_heapify_up(heap, heap.len() - 1)

fn extract_min(heap):
    """Extract minimum value from min-heap.

    Returns minimum value or nil if empty.

    Example:
        extract_min(heap)  # 1
    """
    if heap.len() == 0:
        return nil

    val min_val = heap[0]

    if heap.len() == 1:
        heap.pop()
        return min_val

    # Replace root with last element
    heap[0] = heap[heap.len() - 1]
    heap.pop()

    # Restore heap property
    min_heapify_down(heap, 0)

    min_val

fn extract_max(heap):
    """Extract maximum value from max-heap.

    Returns maximum value or nil if empty.

    Example:
        extract_max(heap)  # 9
    """
    if heap.len() == 0:
        return nil

    val max_val = heap[0]

    if heap.len() == 1:
        heap.pop()
        return max_val

    # Replace root with last element
    heap[0] = heap[heap.len() - 1]
    heap.pop()

    # Restore heap property
    max_heapify_down(heap, 0)

    max_val

fn heap_sort(arr):
    """Sort array using heap sort (ascending order).

    Modifies array in place.

    Example:
        heap_sort([5, 3, 8, 1, 9])  # [1, 3, 5, 8, 9]
    """
    build_max_heap(arr)

    var i = arr.len() - 1
    while i > 0:
        # Swap root with last element
        val temp = arr[0]
        arr[0] = arr[i]
        arr[i] = temp

        # Reduce heap size and heapify
        var temp_heap = []
        var j = 0
        while j < i:
            temp_heap.push(arr[j])
            j = j + 1

        max_heapify_down(temp_heap, 0)

        # Copy back
        j = 0
        while j < temp_heap.len():
            arr[j] = temp_heap[j]
            j = j + 1

        i = i - 1

    arr
