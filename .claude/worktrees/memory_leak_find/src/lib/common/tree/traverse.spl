# Tree Traversal Operations
#
# Functions for traversing trees in different orders.

# ============================================================================
# Exports
# ============================================================================

export inorder, preorder, postorder, level_order

# ============================================================================
# Tree Traversals
# ============================================================================

fn inorder_helper(node, result):
    """Helper for inorder traversal."""
    if not node.?:
        return

    val (value, left, right) = node
    inorder_helper(left, result)
    result.push(value)
    inorder_helper(right, result)

fn inorder(tree):
    """Inorder traversal (left, root, right).

    Returns array of values in inorder.

    Example:
        inorder(tree)  # [4, 2, 5, 1, 3]
    """
    var result = []
    inorder_helper(tree, result)
    result

fn preorder_helper(node, result):
    """Helper for preorder traversal."""
    if not node.?:
        return

    val (value, left, right) = node
    result.push(value)
    preorder_helper(left, result)
    preorder_helper(right, result)

fn preorder(tree):
    """Preorder traversal (root, left, right).

    Returns array of values in preorder.

    Example:
        preorder(tree)  # [1, 2, 4, 5, 3]
    """
    var result = []
    preorder_helper(tree, result)
    result

fn postorder_helper(node, result):
    """Helper for postorder traversal."""
    if not node.?:
        return

    val (value, left, right) = node
    postorder_helper(left, result)
    postorder_helper(right, result)
    result.push(value)

fn postorder(tree):
    """Postorder traversal (left, right, root).

    Returns array of values in postorder.

    Example:
        postorder(tree)  # [4, 5, 2, 3, 1]
    """
    var result = []
    postorder_helper(tree, result)
    result

fn level_order(tree):
    """Level-order traversal (breadth-first).

    Returns array of values in level order.

    Example:
        level_order(tree)  # [1, 2, 3, 4, 5]
    """
    if not tree.?:
        return []

    var result = []
    var queue = [tree]

    while queue.len() > 0:
        # Dequeue first element
        val node = queue[0]
        var new_queue = []
        var i = 1
        while i < queue.len():
            new_queue.push(queue[i])
            i = i + 1
        queue = new_queue

        val (value, left, right) = node
        result.push(value)

        if left.?:
            queue.push(left)
        if right.?:
            queue.push(right)

    result
