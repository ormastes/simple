# B-Tree Insertion Operations
#
# Purpose: Insert keys into B-tree while maintaining properties
#
# Contains:
# - Insert into non-full nodes
# - Root splitting and tree growth
# - Main insertion API

mod b_tree.types
mod b_tree.search
mod b_tree.split

# ============================================================================
# Insertion Helper Functions
# ============================================================================

# Insert a key into a node that is not full
# Assumes node is not full
# Returns new node with key inserted
fn insert_non_full(node, key):
    val keys = node_keys(node)
    val children = node_children(node)
    val is_leaf = node_is_leaf(node)
    val n = node_n(node)
    val t = node_t(node)

    if is_leaf:
        # Insert key in sorted position
        val idx = find_key_index(node, key)
        var new_keys = []
        for i in 0..idx:
            val k = keys.i
            new_keys = list_append(new_keys, k)
        new_keys = list_append(new_keys, key)
        for i in idx..n:
            val k = keys.i
            new_keys = list_append(new_keys, k)

        var new_node = node
        new_node = node_set_keys(new_node, new_keys)
        new_node = node_set_n(new_node, n + 1)
        new_node
    else:
        # Find child to insert into
        val idx = find_key_index(node, key)
        val child = children.idx

        # Check if child is full
        val child_full = is_full(child)
        if child_full:
            # Split child first
            val split_result = split_child(node, idx, child)
            val new_parent = split_result.0
            val new_child = split_result.1
            val new_sibling = split_result.2

            # Determine which child to insert into
            val parent_keys = node_keys(new_parent)
            val mid_key = parent_keys.idx
            val go_right = key > mid_key
            if go_right:
                val right_idx = idx + 1
                val parent_children = node_children(new_parent)
                val right_child = parent_children.right_idx
                val updated_right = insert_non_full(right_child, key)

                # Update parent's children
                var updated_children = []
                for i in 0..(right_idx):
                    val c = parent_children.i
                    updated_children = list_append(updated_children, c)
                updated_children = list_append(updated_children, updated_right)
                val parent_n = node_n(new_parent)
                for i in (right_idx + 1)..(parent_n + 1):
                    val c = parent_children.i
                    updated_children = list_append(updated_children, c)

                val result = node_set_children(new_parent, updated_children)
                result
            else:
                val updated_left = insert_non_full(new_child, key)

                # Update parent's children
                val parent_children = node_children(new_parent)
                var updated_children = []
                for i in 0..idx:
                    val c = parent_children.i
                    updated_children = list_append(updated_children, c)
                updated_children = list_append(updated_children, updated_left)
                val parent_n = node_n(new_parent)
                for i in (idx + 1)..(parent_n + 1):
                    val c = parent_children.i
                    updated_children = list_append(updated_children, c)

                val result = node_set_children(new_parent, updated_children)
                result
        else:
            # Insert into non-full child
            val updated_child = insert_non_full(child, key)

            # Update this node's children
            var updated_children = []
            for i in 0..idx:
                val c = children.i
                updated_children = list_append(updated_children, c)
            updated_children = list_append(updated_children, updated_child)
            for i in (idx + 1)..(n + 1):
                val c = children.i
                updated_children = list_append(updated_children, c)

            val result = node_set_children(node, updated_children)
            result

# ============================================================================
# Main Insertion Function
# ============================================================================

# Insert a key into the B-tree
# Parameters:
#   tree: The B-tree
#   key: Key to insert
# Returns: Updated tree
fn btree_insert(tree, key):
    val root = tree_root(tree)
    val t = tree_t(tree)
    val height = tree_height(tree)

    # Check if root is full
    val root_full = is_full(root)
    if root_full:
        # Create new root
        var new_root = create_node(t, false)

        # Old root becomes child of new root
        var new_root_children = []
        new_root_children = list_append(new_root_children, root)
        new_root = node_set_children(new_root, new_root_children)

        # Split old root
        val split_result = split_child(new_root, 0, root)
        val updated_root = split_result.0

        # Insert into new root
        val final_root = insert_non_full(updated_root, key)

        # Update tree with new root and increased height
        var new_tree = tree
        new_tree = tree_set_root(new_tree, final_root)
        new_tree = tree_set_height(new_tree, height + 1)
        new_tree
    else:
        # Insert into non-full root
        val updated_root = insert_non_full(root, key)
        val result = tree_set_root(tree, updated_root)
        result

export *
