# AES Cipher Core Module
#
# This module contains core AES cipher transformations and block operations

# Import dependencies
import aes/utilities
import aes/types
import aes/sbox
import aes/key_expansion

# =============================================================================
# AES SHIFTROWS TRANSFORMATION
# =============================================================================

# Shift rows in state
# Row 0: no shift
# Row 1: shift left by 1
# Row 2: shift left by 2
# Row 3: shift left by 3
fn shift_rows(state: list) -> list:
    var new_state = state

    # Row 1: shift left by 1
    val r1_c0 = state_get(state, 1, 0)
    val r1_c1 = state_get(state, 1, 1)
    val r1_c2 = state_get(state, 1, 2)
    val r1_c3 = state_get(state, 1, 3)
    new_state = state_set(new_state, 1, 0, r1_c1)
    new_state = state_set(new_state, 1, 1, r1_c2)
    new_state = state_set(new_state, 1, 2, r1_c3)
    new_state = state_set(new_state, 1, 3, r1_c0)

    # Row 2: shift left by 2
    val r2_c0 = state_get(state, 2, 0)
    val r2_c1 = state_get(state, 2, 1)
    val r2_c2 = state_get(state, 2, 2)
    val r2_c3 = state_get(state, 2, 3)
    new_state = state_set(new_state, 2, 0, r2_c2)
    new_state = state_set(new_state, 2, 1, r2_c3)
    new_state = state_set(new_state, 2, 2, r2_c0)
    new_state = state_set(new_state, 2, 3, r2_c1)

    # Row 3: shift left by 3
    val r3_c0 = state_get(state, 3, 0)
    val r3_c1 = state_get(state, 3, 1)
    val r3_c2 = state_get(state, 3, 2)
    val r3_c3 = state_get(state, 3, 3)
    new_state = state_set(new_state, 3, 0, r3_c3)
    new_state = state_set(new_state, 3, 1, r3_c0)
    new_state = state_set(new_state, 3, 2, r3_c1)
    new_state = state_set(new_state, 3, 3, r3_c2)

    new_state

# Inverse shift rows
fn inv_shift_rows(state: list) -> list:
    var new_state = state

    # Row 1: shift right by 1 (= shift left by 3)
    val r1_c0 = state_get(state, 1, 0)
    val r1_c1 = state_get(state, 1, 1)
    val r1_c2 = state_get(state, 1, 2)
    val r1_c3 = state_get(state, 1, 3)
    new_state = state_set(new_state, 1, 0, r1_c3)
    new_state = state_set(new_state, 1, 1, r1_c0)
    new_state = state_set(new_state, 1, 2, r1_c1)
    new_state = state_set(new_state, 1, 3, r1_c2)

    # Row 2: shift right by 2 (= shift left by 2)
    val r2_c0 = state_get(state, 2, 0)
    val r2_c1 = state_get(state, 2, 1)
    val r2_c2 = state_get(state, 2, 2)
    val r2_c3 = state_get(state, 2, 3)
    new_state = state_set(new_state, 2, 0, r2_c2)
    new_state = state_set(new_state, 2, 1, r2_c3)
    new_state = state_set(new_state, 2, 2, r2_c0)
    new_state = state_set(new_state, 2, 3, r2_c1)

    # Row 3: shift right by 3 (= shift left by 1)
    val r3_c0 = state_get(state, 3, 0)
    val r3_c1 = state_get(state, 3, 1)
    val r3_c2 = state_get(state, 3, 2)
    val r3_c3 = state_get(state, 3, 3)
    new_state = state_set(new_state, 3, 0, r3_c1)
    new_state = state_set(new_state, 3, 1, r3_c2)
    new_state = state_set(new_state, 3, 2, r3_c3)
    new_state = state_set(new_state, 3, 3, r3_c0)

    new_state

# =============================================================================
# AES MIXCOLUMNS TRANSFORMATION
# =============================================================================

# Mix a single column using matrix multiplication in GF(2^8)
# Multiply by fixed matrix:
# [2 3 1 1]
# [1 2 3 1]
# [1 1 2 3]
# [3 1 1 2]
fn mix_column(col: list) -> list:
    val s0 = col[0]
    val s1 = col[1]
    val s2 = col[2]
    val s3 = col[3]

    val t0_1 = gmul(2, s0)
    val t0_2 = gmul(3, s1)
    val t0_3 = s2
    val t0_4 = s3
    val t0_xor1 = xor_byte(t0_1, t0_2)
    val t0_xor2 = xor_byte(t0_xor1, t0_3)
    val t0 = xor_byte(t0_xor2, t0_4)

    val t1_1 = s0
    val t1_2 = gmul(2, s1)
    val t1_3 = gmul(3, s2)
    val t1_4 = s3
    val t1_xor1 = xor_byte(t1_1, t1_2)
    val t1_xor2 = xor_byte(t1_xor1, t1_3)
    val t1 = xor_byte(t1_xor2, t1_4)

    val t2_1 = s0
    val t2_2 = s1
    val t2_3 = gmul(2, s2)
    val t2_4 = gmul(3, s3)
    val t2_xor1 = xor_byte(t2_1, t2_2)
    val t2_xor2 = xor_byte(t2_xor1, t2_3)
    val t2 = xor_byte(t2_xor2, t2_4)

    val t3_1 = gmul(3, s0)
    val t3_2 = s1
    val t3_3 = s2
    val t3_4 = gmul(2, s3)
    val t3_xor1 = xor_byte(t3_1, t3_2)
    val t3_xor2 = xor_byte(t3_xor1, t3_3)
    val t3 = xor_byte(t3_xor2, t3_4)

    [t0, t1, t2, t3]

# Mix columns transformation
fn mix_columns(state: list) -> list:
    var new_state = state

    # Process each column
    var col = 0
    while col < 4:
        val s0 = state_get(state, 0, col)
        val s1 = state_get(state, 1, col)
        val s2 = state_get(state, 2, col)
        val s3 = state_get(state, 3, col)

        val column = [s0, s1, s2, s3]
        val mixed = mix_column(column)

        new_state = state_set(new_state, 0, col, mixed[0])
        new_state = state_set(new_state, 1, col, mixed[1])
        new_state = state_set(new_state, 2, col, mixed[2])
        new_state = state_set(new_state, 3, col, mixed[3])

        col = col + 1

    new_state

# Inverse mix column
# Multiply by inverse matrix:
# [14 11 13  9]
# [ 9 14 11 13]
# [13  9 14 11]
# [11 13  9 14]
fn inv_mix_column(col: list) -> list:
    val s0 = col[0]
    val s1 = col[1]
    val s2 = col[2]
    val s3 = col[3]

    val t0_1 = gmul(14, s0)
    val t0_2 = gmul(11, s1)
    val t0_3 = gmul(13, s2)
    val t0_4 = gmul(9, s3)
    val t0_xor1 = xor_byte(t0_1, t0_2)
    val t0_xor2 = xor_byte(t0_xor1, t0_3)
    val t0 = xor_byte(t0_xor2, t0_4)

    val t1_1 = gmul(9, s0)
    val t1_2 = gmul(14, s1)
    val t1_3 = gmul(11, s2)
    val t1_4 = gmul(13, s3)
    val t1_xor1 = xor_byte(t1_1, t1_2)
    val t1_xor2 = xor_byte(t1_xor1, t1_3)
    val t1 = xor_byte(t1_xor2, t1_4)

    val t2_1 = gmul(13, s0)
    val t2_2 = gmul(9, s1)
    val t2_3 = gmul(14, s2)
    val t2_4 = gmul(11, s3)
    val t2_xor1 = xor_byte(t2_1, t2_2)
    val t2_xor2 = xor_byte(t2_xor1, t2_3)
    val t2 = xor_byte(t2_xor2, t2_4)

    val t3_1 = gmul(11, s0)
    val t3_2 = gmul(13, s1)
    val t3_3 = gmul(9, s2)
    val t3_4 = gmul(14, s3)
    val t3_xor1 = xor_byte(t3_1, t3_2)
    val t3_xor2 = xor_byte(t3_xor1, t3_3)
    val t3 = xor_byte(t3_xor2, t3_4)

    [t0, t1, t2, t3]

# Inverse mix columns transformation
fn inv_mix_columns(state: list) -> list:
    var new_state = state

    # Process each column
    var col = 0
    while col < 4:
        val s0 = state_get(state, 0, col)
        val s1 = state_get(state, 1, col)
        val s2 = state_get(state, 2, col)
        val s3 = state_get(state, 3, col)

        val column = [s0, s1, s2, s3]
        val mixed = inv_mix_column(column)

        new_state = state_set(new_state, 0, col, mixed[0])
        new_state = state_set(new_state, 1, col, mixed[1])
        new_state = state_set(new_state, 2, col, mixed[2])
        new_state = state_set(new_state, 3, col, mixed[3])

        col = col + 1

    new_state

# =============================================================================
# AES ADDROUNDKEY TRANSFORMATION
# =============================================================================

# XOR state with round key
fn add_round_key(state: list, round_key: list) -> list:
    val new_state = []
    var i = 0
    while i < 16:
        val xor_val = xor_byte(state[i], round_key[i])
        new_state.append(xor_val)
        i = i + 1
    new_state

# =============================================================================
# AES CORE ENCRYPTION/DECRYPTION (Single Block)
# =============================================================================

# Encrypt single 16-byte block with expanded key
fn aes_encrypt_block_with_expanded(block: list, expanded_key: list, num_rounds: i64) -> list:
    var state = create_state(block)

    # Initial round key addition
    val round_key_0 = get_round_key(expanded_key, 0)
    state = add_round_key(state, round_key_0)

    # Main rounds
    var round = 1
    while round < num_rounds:
        state = sub_bytes(state)
        state = shift_rows(state)
        state = mix_columns(state)
        val round_key = get_round_key(expanded_key, round)
        state = add_round_key(state, round_key)
        round = round + 1

    # Final round (no MixColumns)
    state = sub_bytes(state)
    state = shift_rows(state)
    val final_key = get_round_key(expanded_key, num_rounds)
    state = add_round_key(state, final_key)

    state_to_block(state)

# Decrypt single 16-byte block with expanded key
fn aes_decrypt_block_with_expanded(block: list, expanded_key: list, num_rounds: i64) -> list:
    var state = create_state(block)

    # Initial round key addition (with last round key)
    val round_key_final = get_round_key(expanded_key, num_rounds)
    state = add_round_key(state, round_key_final)

    # Main rounds (in reverse)
    var round = num_rounds - 1
    while round > 0:
        state = inv_shift_rows(state)
        state = inv_sub_bytes(state)
        val round_key = get_round_key(expanded_key, round)
        state = add_round_key(state, round_key)
        state = inv_mix_columns(state)
        round = round - 1

    # Final round (no InvMixColumns)
    state = inv_shift_rows(state)
    state = inv_sub_bytes(state)
    val round_key_0 = get_round_key(expanded_key, 0)
    state = add_round_key(state, round_key_0)

    state_to_block(state)

# Encrypt single block (determine rounds from key size)
fn aes_encrypt_block(block: list, key: list) -> list:
    val key_size = key.length()
    val num_rounds = 0
    var rounds = 0

    if key_size == 16:
        rounds = 10
    else:
        if key_size == 24:
            rounds = 12
        else:
            rounds = 14

    val expanded = expand_key(key, key_size)
    aes_encrypt_block_with_expanded(block, expanded, rounds)

# Decrypt single block (determine rounds from key size)
fn aes_decrypt_block(block: list, key: list) -> list:
    val key_size = key.length()
    val num_rounds = 0
    var rounds = 0

    if key_size == 16:
        rounds = 10
    else:
        if key_size == 24:
            rounds = 12
        else:
            rounds = 14

    val expanded = expand_key(key, key_size)
    aes_decrypt_block_with_expanded(block, expanded, rounds)
