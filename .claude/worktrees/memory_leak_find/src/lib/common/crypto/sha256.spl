# SHA-256 Hash Implementation
#
# Secure Hash Algorithm 256-bit
# Pure Simple implementation following FIPS 180-4 specification
#
# Recommended for most cryptographic applications

mod crypto.types

# =============================================================================
# SHA-256 Constants and Initial Values
# =============================================================================

# SHA-256 constants (first 32 bits of fractional parts of cube roots of first 64 primes)
fn sha256_k_constants() -> list:
    [
        0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
        0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
        0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
        0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
        0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
        0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
        0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
        0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
        0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
    ]

# SHA-256 initial hash values (first 32 bits of fractional parts of square roots of first 8 primes)
fn sha256_initial_hash() -> list:
    [
        0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
        0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
    ]

# =============================================================================
# SHA-256 Functions
# =============================================================================

# SHA-256 choice function
fn sha256_ch(x: i64, y: i64, z: i64) -> i64:
    (x & y) ^ ((~x) & z)

# SHA-256 majority function
fn sha256_maj(x: i64, y: i64, z: i64) -> i64:
    (x & y) ^ (x & z) ^ (y & z)

# SHA-256 Sigma0 function
fn sha256_sigma0(x: i64) -> i64:
    val r2 = rotr32(x, 2)
    val r13 = rotr32(x, 13)
    val r22 = rotr32(x, 22)
    r2 ^ r13 ^ r22

# SHA-256 Sigma1 function
fn sha256_sigma1(x: i64) -> i64:
    val r6 = rotr32(x, 6)
    val r11 = rotr32(x, 11)
    val r25 = rotr32(x, 25)
    r6 ^ r11 ^ r25

# SHA-256 sigma0 function (lowercase)
fn sha256_little_sigma0(x: i64) -> i64:
    val r7 = rotr32(x, 7)
    val r18 = rotr32(x, 18)
    val s3 = shr32(x, 3)
    r7 ^ r18 ^ s3

# SHA-256 sigma1 function (lowercase)
fn sha256_little_sigma1(x: i64) -> i64:
    val r17 = rotr32(x, 17)
    val r19 = rotr32(x, 19)
    val s10 = shr32(x, 10)
    r17 ^ r19 ^ s10

# =============================================================================
# SHA-256 Core Operations
# =============================================================================

# Create SHA-256 context for incremental hashing
# Returns tuple: (h: list[8], data: list, datalen: i64, bitlen: i64)
fn create_sha256_context() -> tuple:
    val h = sha256_initial_hash()
    val data = []
    (h, data, 0, 0)

# Pad message for SHA-256 (512-bit blocks)
fn sha256_pad_message(bytes: list) -> list:
    var padded = []
    var i = 0

    # Copy original bytes
    while i < bytes.len():
        padded.push(bytes.get(i))
        i = i + 1

    val original_len = bytes.len()
    val original_bit_len = original_len * 8

    # Append 1 bit (0x80)
    padded.push(0x80)

    # Append 0 bits until length â‰¡ 448 (mod 512)
    val target_len = ((original_len + 8) / 64 + 1) * 64
    while padded.len() < target_len - 8:
        padded.push(0)

    # Append length as 64-bit big-endian
    # For simplicity, assume length fits in 32 bits
    padded.push(0)
    padded.push(0)
    padded.push(0)
    padded.push(0)
    padded.push((original_bit_len >> 24) & 0xFF)
    padded.push((original_bit_len >> 16) & 0xFF)
    padded.push((original_bit_len >> 8) & 0xFF)
    padded.push(original_bit_len & 0xFF)

    padded

# Process one 512-bit block for SHA-256
fn sha256_process_block(h: list, block: list) -> list:
    # Prepare message schedule (64 entries)
    var w = []
    var i = 0

    # First 16 words from block (big-endian)
    while i < 16:
        val idx = i * 4
        val b0 = block.get(idx)
        val b1 = block.get(idx + 1)
        val b2 = block.get(idx + 2)
        val b3 = block.get(idx + 3)
        val word = (b0 << 24) | (b1 << 16) | (b2 << 8) | b3
        w.push(word)
        i = i + 1

    # Extend to 64 words
    while i < 64:
        val w15 = w.get(i - 15)
        val w2 = w.get(i - 2)
        val w16 = w.get(i - 16)
        val w7 = w.get(i - 7)

        val s0 = sha256_little_sigma0(w15)
        val s1 = sha256_little_sigma1(w2)

        val word = add_mod32(add_mod32(add_mod32(s1, w7), s0), w16)
        w.push(word)
        i = i + 1

    # Initialize working variables
    var a = h.get(0)
    var b = h.get(1)
    var c = h.get(2)
    var d = h.get(3)
    var e = h.get(4)
    var f = h.get(5)
    var g = h.get(6)
    var h_var = h.get(7)

    val k = sha256_k_constants()

    # 64 rounds
    i = 0
    while i < 64:
        val S1 = sha256_sigma1(e)
        val ch = sha256_ch(e, f, g)
        val temp1_part1 = add_mod32(h_var, S1)
        val temp1_part2 = add_mod32(ch, k.get(i))
        val temp1_part3 = add_mod32(temp1_part2, w.get(i))
        val temp1 = add_mod32(temp1_part1, temp1_part3)

        val S0 = sha256_sigma0(a)
        val maj = sha256_maj(a, b, c)
        val temp2 = add_mod32(S0, maj)

        h_var = g
        g = f
        f = e
        e = add_mod32(d, temp1)
        d = c
        c = b
        b = a
        a = add_mod32(temp1, temp2)

        i = i + 1

    # Add compressed chunk to current hash value
    var new_h = []
    new_h.push(add_mod32(h.get(0), a))
    new_h.push(add_mod32(h.get(1), b))
    new_h.push(add_mod32(h.get(2), c))
    new_h.push(add_mod32(h.get(3), d))
    new_h.push(add_mod32(h.get(4), e))
    new_h.push(add_mod32(h.get(5), f))
    new_h.push(add_mod32(h.get(6), g))
    new_h.push(add_mod32(h.get(7), h_var))

    new_h

# Update SHA-256 context with new data
fn sha256_update(ctx: tuple, data: list) -> tuple:
    val h = ctx.get(0)
    val existing_data = ctx.get(1)
    val datalen = ctx.get(2)
    val bitlen = ctx.get(3)

    # Append new data
    var updated_data = []
    var i = 0
    while i < existing_data.len():
        updated_data.push(existing_data.get(i))
        i = i + 1

    i = 0
    while i < data.len():
        updated_data.push(data.get(i))
        i = i + 1

    val new_datalen = datalen + data.len()
    val new_bitlen = bitlen + (data.len() * 8)

    (h, updated_data, new_datalen, new_bitlen)

# Finalize SHA-256 hash
fn sha256_finalize(ctx: tuple) -> list:
    val h = ctx.get(0)
    val data = ctx.get(1)

    # Pad the data
    val padded = sha256_pad_message(data)

    # Process all blocks
    var current_h = h
    var i = 0
    while i < padded.len():
        var block = []
        var j = 0
        while j < 64:
            block.push(padded.get(i + j))
            j = j + 1

        current_h = sha256_process_block(current_h, block)
        i = i + 64

    # Convert hash values to bytes (big-endian)
    var result = []
    i = 0
    while i < 8:
        val h_val = current_h.get(i)
        result.push((h_val >> 24) & 0xFF)
        result.push((h_val >> 16) & 0xFF)
        result.push((h_val >> 8) & 0xFF)
        result.push(h_val & 0xFF)
        i = i + 1

    result

# Reset SHA-256 context
fn sha256_reset(ctx: tuple) -> tuple:
    create_sha256_context()

# =============================================================================
# Public API
# =============================================================================

# SHA-256 hash of byte list (returns byte list)
fn sha256_bytes(bytes: list) -> list:
    val ctx = create_sha256_context()
    val updated_ctx = sha256_update(ctx, bytes)
    sha256_finalize(updated_ctx)

# SHA-256 hash of text (returns byte list)
fn sha256(text: text) -> list:
    val bytes = text_to_bytes(text)
    sha256_bytes(bytes)

# SHA-256 hash of text (returns hex string)
fn sha256_hex(text: text) -> text:
    val hash = sha256(text)
    bytes_to_hex(hash)

# SHA-256 hash with uppercase hex output
fn sha256_hex_upper(text: text) -> text:
    val hash = sha256(text)
    hash_to_upper_hex(hash)

# Double hash (hash of hash - used in some applications)
fn double_sha256(text: text) -> list:
    val first_hash = sha256(text)
    sha256_bytes(first_hash)

# Double hash hex
fn double_sha256_hex(text: text) -> text:
    val hash = double_sha256(text)
    bytes_to_hex(hash)

# Hash streaming data (incremental)
fn hash_stream_sha256(chunks: list) -> text:
    var ctx = create_sha256_context()
    var i = 0

    while i < chunks.len():
        val chunk = chunks.get(i)
        val chunk_bytes = text_to_bytes(chunk)
        ctx = sha256_update(ctx, chunk_bytes)
        i = i + 1

    val hash = sha256_finalize(ctx)
    bytes_to_hex(hash)
