# Cryptographic Utilities
#
# High-level cryptographic utilities:
# - Password hashing and verification
# - Hash verification and comparison
# - Checksum creation and verification
# - Algorithm selection and metadata
# - Constant-time operations for security

mod crypto.types
mod crypto.sha256
mod crypto.sha512
mod crypto.pbkdf2

# =============================================================================
# Security Utilities
# =============================================================================

# Constant-time comparison to prevent timing attacks
fn constant_time_compare(a: list, b: list) -> bool:
    if a.len() != b.len():
        false
    else:
        var result = 0
        var i = 0
        while i < a.len():
            result = result | (a.get(i) ^ b.get(i))
            i = i + 1

        result == 0

# Secure hash comparison
fn secure_compare(hash1: list, hash2: list) -> bool:
    constant_time_compare(hash1, hash2)

# Verify hash matches expected value
fn verify_hash(data: text, expected_hex: text) -> bool:
    val actual_hash = sha256_hex(data)
    constant_time_compare(text_to_bytes(actual_hash), text_to_bytes(expected_hex))

# =============================================================================
# Password Hashing and Verification
# =============================================================================

# Hash password with salt (uses PBKDF2-SHA256 with 100,000 iterations)
fn hash_password(password: text, salt: text) -> text:
    val hash = pbkdf2_sha256(password, salt, 100000)
    bytes_to_hex(hash)

# Verify password hash
fn verify_password(password: text, salt: text, expected_hash_hex: text) -> bool:
    val actual_hash = hash_password(password, salt)
    constant_time_compare(text_to_bytes(actual_hash), text_to_bytes(expected_hash_hex))

# Generate simple salt (NOT cryptographically secure - use external RNG for production)
fn generate_salt(length: i64) -> text:
    # Simple deterministic salt generation - NOT SECURE
    # In production, use a cryptographically secure random number generator
    var salt = ""
    var i = 0
    while i < length:
        val char_code = ((i * 7919) % 94) + 33  # Printable ASCII range
        salt = salt + char_code.chr()
        i = i + 1

    salt

# =============================================================================
# Checksum and Quick Verification
# =============================================================================

# Create checksum (short hash for quick verification)
fn create_checksum(data: text) -> text:
    val hash = sha256(data)
    val truncated = truncate_hash(hash, 4)
    bytes_to_hex(truncated)

# Verify checksum
fn verify_checksum(data: text, expected_checksum: text) -> bool:
    val actual = create_checksum(data)
    compare_hex_hashes(actual, expected_checksum)

# Compare two hex strings (case-insensitive)
fn compare_hex_hashes(hex1: text, hex2: text) -> bool:
    if hex1.len() != hex2.len():
        false
    else:
        var i = 0
        var match = true

        while i < hex1.len():
            val c1 = hex1.get(i)
            val c2 = hex2.get(i)

            val c1_lower = if c1 >= "A" && c1 <= "F":
                c1.lower()
            else:
                c1

            val c2_lower = if c2 >= "A" && c2 <= "F":
                c2.lower()
            else:
                c2

            if c1_lower != c2_lower:
                match = false

            i = i + 1

        match

# =============================================================================
# Algorithm Selection and Metadata
# =============================================================================

# Hash with algorithm selection
fn hash_with_algorithm(text: text, algorithm: text) -> text:
    if algorithm == "sha256":
        sha256_hex(text)
    else:
        if algorithm == "sha512":
            sha512_hex(text)
        else:
            if algorithm == "sha1":
                sha1_hex(text)
            else:
                if algorithm == "md5":
                    md5_hex(text)
                else:
                    # Default to SHA-256
                    sha256_hex(text)

# Get hash algorithm output length in bytes
fn get_hash_length(algorithm: text) -> i64:
    if algorithm == "sha256":
        32
    else:
        if algorithm == "sha512":
            64
        else:
            if algorithm == "sha1":
                20
            else:
                if algorithm == "md5":
                    16
                else:
                    # Default SHA-256
                    32

# Get hash algorithm block size in bytes
fn get_block_size(algorithm: text) -> i64:
    if algorithm == "sha256":
        64
    else:
        if algorithm == "sha512":
            128
        else:
            if algorithm == "sha1":
                64
            else:
                if algorithm == "md5":
                    64
                else:
                    # Default SHA-256
                    64

# Check if algorithm is secure
fn is_secure_algorithm(algorithm: text) -> bool:
    algorithm == "sha256" || algorithm == "sha512"

# Get recommended algorithm
fn get_recommended_algorithm() -> text:
    "sha256"
