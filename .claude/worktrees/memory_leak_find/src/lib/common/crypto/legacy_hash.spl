# Legacy Hash Algorithms (DEPRECATED)
#
# WARNING: SHA-1 and MD5 are cryptographically broken and should NEVER
# be used for security-critical applications. Use SHA-256 or SHA-512 instead.
#
# Provided only for compatibility with legacy systems.

mod crypto.types

# =============================================================================
# SHA-1 Implementation (DEPRECATED)
# =============================================================================

# WARNING: SHA-1 is cryptographically broken. Use SHA-256 or SHA-512.

# SHA-1 initial hash values
fn sha1_initial_hash() -> list:
    [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]

# SHA-1 f function
fn sha1_f(t: i64, b: i64, c: i64, d: i64) -> i64:
    if t < 20:
        (b & c) | ((~b) & d)
    else:
        if t < 40:
            b ^ c ^ d
        else:
            if t < 60:
                (b & c) | (b & d) | (c & d)
            else:
                b ^ c ^ d

# SHA-1 K constant
fn sha1_k(t: i64) -> i64:
    if t < 20:
        0x5A827999
    else:
        if t < 40:
            0x6ED9EBA1
        else:
            if t < 60:
                0x8F1BBCDC
            else:
                0xCA62C1D6

# Pad message for SHA-1
fn sha1_pad_message(bytes: list) -> list:
    var padded = []
    var i = 0

    # Copy original bytes
    while i < bytes.len():
        padded.push(bytes.get(i))
        i = i + 1

    val original_len = bytes.len()
    val original_bit_len = original_len * 8

    # Append 1 bit
    padded.push(0x80)

    # Pad to 56 bytes (mod 64)
    val target_len = ((original_len + 8) / 64 + 1) * 64
    while padded.len() < target_len - 8:
        padded.push(0)

    # Append length
    padded.push(0)
    padded.push(0)
    padded.push(0)
    padded.push(0)
    padded.push((original_bit_len >> 24) & 0xFF)
    padded.push((original_bit_len >> 16) & 0xFF)
    padded.push((original_bit_len >> 8) & 0xFF)
    padded.push(original_bit_len & 0xFF)

    padded

# Process SHA-1 block
fn sha1_process_block(h: list, block: list) -> list:
    # Prepare message schedule
    var w = []
    var i = 0

    # First 16 words
    while i < 16:
        val idx = i * 4
        val b0 = block.get(idx)
        val b1 = block.get(idx + 1)
        val b2 = block.get(idx + 2)
        val b3 = block.get(idx + 3)
        val word = (b0 << 24) | (b1 << 16) | (b2 << 8) | b3
        w.push(word)
        i = i + 1

    # Extend to 80 words
    while i < 80:
        val w3 = w.get(i - 3)
        val w8 = w.get(i - 8)
        val w14 = w.get(i - 14)
        val w16 = w.get(i - 16)
        val word = rotl32(w3 ^ w8 ^ w14 ^ w16, 1)
        w.push(word)
        i = i + 1

    # Initialize working variables
    var a = h.get(0)
    var b = h.get(1)
    var c = h.get(2)
    var d = h.get(3)
    var e = h.get(4)

    # 80 rounds
    i = 0
    while i < 80:
        val f = sha1_f(i, b, c, d)
        val k = sha1_k(i)
        val rotated_a = rotl32(a, 5)
        val temp_sum1 = add_mod32(rotated_a, f)
        val temp_sum2 = add_mod32(temp_sum1, e)
        val temp_sum3 = add_mod32(temp_sum2, k)
        val temp = add_mod32(temp_sum3, w.get(i))

        e = d
        d = c
        c = rotl32(b, 30)
        b = a
        a = temp

        i = i + 1

    # Add to hash
    var new_h = []
    new_h.push(add_mod32(h.get(0), a))
    new_h.push(add_mod32(h.get(1), b))
    new_h.push(add_mod32(h.get(2), c))
    new_h.push(add_mod32(h.get(3), d))
    new_h.push(add_mod32(h.get(4), e))

    new_h

# SHA-1 hash of byte list
fn sha1_bytes(bytes: list) -> list:
    val padded = sha1_pad_message(bytes)
    var h = sha1_initial_hash()

    var i = 0
    while i < padded.len():
        var block = []
        var j = 0
        while j < 64:
            block.push(padded.get(i + j))
            j = j + 1

        h = sha1_process_block(h, block)
        i = i + 64

    # Convert to bytes
    var result = []
    i = 0
    while i < 5:
        val h_val = h.get(i)
        result.push((h_val >> 24) & 0xFF)
        result.push((h_val >> 16) & 0xFF)
        result.push((h_val >> 8) & 0xFF)
        result.push(h_val & 0xFF)
        i = i + 1

    result

# SHA-1 hash of text (DEPRECATED)
fn sha1(text: text) -> list:
    val bytes = text_to_bytes(text)
    sha1_bytes(bytes)

# SHA-1 hash hex (DEPRECATED)
fn sha1_hex(text: text) -> text:
    val hash = sha1(text)
    bytes_to_hex(hash)

# =============================================================================
# MD5 Implementation (INSECURE)
# =============================================================================

# WARNING: MD5 is cryptographically broken. Use SHA-256 or SHA-512.

# MD5 initial hash values
fn md5_initial_hash() -> list:
    [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476]

# MD5 F function
fn md5_f(x: i64, y: i64, z: i64) -> i64:
    (x & y) | ((~x) & z)

# MD5 G function
fn md5_g(x: i64, y: i64, z: i64) -> i64:
    (x & z) | (y & (~z))

# MD5 H function
fn md5_h(x: i64, y: i64, z: i64) -> i64:
    x ^ y ^ z

# MD5 I function
fn md5_i(x: i64, y: i64, z: i64) -> i64:
    y ^ (x | (~z))

# MD5 sine table
fn md5_t(i: i64) -> i64:
    # Precomputed values from floor(abs(sin(i + 1)) * 2^32)
    val table = [
        0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee, 0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,
        0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be, 0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821,
        0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa, 0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,
        0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed, 0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a,
        0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c, 0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,
        0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05, 0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,
        0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039, 0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,
        0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1, 0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391
    ]
    table.get(i)

# Pad message for MD5
fn md5_pad_message(bytes: list) -> list:
    var padded = []
    var i = 0

    while i < bytes.len():
        padded.push(bytes.get(i))
        i = i + 1

    val original_len = bytes.len()
    val original_bit_len = original_len * 8

    padded.push(0x80)

    val target_len = ((original_len + 8) / 64 + 1) * 64
    while padded.len() < target_len - 8:
        padded.push(0)

    # Length in little-endian
    padded.push(original_bit_len & 0xFF)
    padded.push((original_bit_len >> 8) & 0xFF)
    padded.push((original_bit_len >> 16) & 0xFF)
    padded.push((original_bit_len >> 24) & 0xFF)
    padded.push(0)
    padded.push(0)
    padded.push(0)
    padded.push(0)

    padded

# Process MD5 block
fn md5_process_block(h: list, block: list) -> list:
    # Parse block into 16 words (little-endian)
    var m = []
    var i = 0
    while i < 16:
        val idx = i * 4
        val b0 = block.get(idx)
        val b1 = block.get(idx + 1)
        val b2 = block.get(idx + 2)
        val b3 = block.get(idx + 3)
        val word = b0 | (b1 << 8) | (b2 << 16) | (b3 << 24)
        m.push(word)
        i = i + 1

    var a = h.get(0)
    var b = h.get(1)
    var c = h.get(2)
    var d = h.get(3)

    # Round 1
    val s1 = [7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22]
    i = 0
    while i < 16:
        val f = md5_f(b, c, d)
        val g = i
        val temp_sum1 = add_mod32(a, f)
        val temp_sum2 = add_mod32(temp_sum1, md5_t(i))
        val temp_sum3 = add_mod32(temp_sum2, m.get(g))
        val temp = add_mod32(b, rotl32(temp_sum3, s1.get(i)))

        a = d
        d = c
        c = b
        b = temp
        i = i + 1

    # Round 2
    val s2 = [5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20]
    i = 0
    while i < 16:
        val f = md5_g(b, c, d)
        val g = (5 * i + 1) % 16
        val temp_sum1 = add_mod32(a, f)
        val temp_sum2 = add_mod32(temp_sum1, md5_t(16 + i))
        val temp_sum3 = add_mod32(temp_sum2, m.get(g))
        val temp = add_mod32(b, rotl32(temp_sum3, s2.get(i)))

        a = d
        d = c
        c = b
        b = temp
        i = i + 1

    # Round 3
    val s3 = [4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23]
    i = 0
    while i < 16:
        val f = md5_h(b, c, d)
        val g = (3 * i + 5) % 16
        val temp_sum1 = add_mod32(a, f)
        val temp_sum2 = add_mod32(temp_sum1, md5_t(32 + i))
        val temp_sum3 = add_mod32(temp_sum2, m.get(g))
        val temp = add_mod32(b, rotl32(temp_sum3, s3.get(i)))

        a = d
        d = c
        c = b
        b = temp
        i = i + 1

    # Round 4
    val s4 = [6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21]
    i = 0
    while i < 16:
        val f = md5_i(b, c, d)
        val g = (7 * i) % 16
        val temp_sum1 = add_mod32(a, f)
        val temp_sum2 = add_mod32(temp_sum1, md5_t(48 + i))
        val temp_sum3 = add_mod32(temp_sum2, m.get(g))
        val temp = add_mod32(b, rotl32(temp_sum3, s4.get(i)))

        a = d
        d = c
        c = b
        b = temp
        i = i + 1

    # Add to hash
    var new_h = []
    new_h.push(add_mod32(h.get(0), a))
    new_h.push(add_mod32(h.get(1), b))
    new_h.push(add_mod32(h.get(2), c))
    new_h.push(add_mod32(h.get(3), d))

    new_h

# MD5 hash of byte list
fn md5_bytes(bytes: list) -> list:
    val padded = md5_pad_message(bytes)
    var h = md5_initial_hash()

    var i = 0
    while i < padded.len():
        var block = []
        var j = 0
        while j < 64:
            block.push(padded.get(i + j))
            j = j + 1

        h = md5_process_block(h, block)
        i = i + 64

    # Convert to bytes (little-endian)
    var result = []
    i = 0
    while i < 4:
        val h_val = h.get(i)
        result.push(h_val & 0xFF)
        result.push((h_val >> 8) & 0xFF)
        result.push((h_val >> 16) & 0xFF)
        result.push((h_val >> 24) & 0xFF)
        i = i + 1

    result

# MD5 hash of text (INSECURE)
fn md5(text: text) -> list:
    val bytes = text_to_bytes(text)
    md5_bytes(bytes)

# MD5 hash hex (INSECURE)
fn md5_hex(text: text) -> text:
    val hash = md5(text)
    bytes_to_hex(hash)
