# Linked List Search Functions

# Get the first element (head) of the list
# Args:
#   list: Linked list
# Returns: First element or nil if empty
fn ll_head(list):
    if list == nil:
        nil
    else:
        list[0]

# Get the tail (all elements except first)
# Args:
#   list: Linked list
# Returns: List without first element, or nil if empty
fn ll_tail(list):
    if list == nil:
        nil
    else:
        list[1]

# Get element at specific index
# Args:
#   list: Linked list
#   index: Zero-based index
# Returns: Element at index or nil if out of bounds
fn ll_get(list, index):
    var current = list
    var i = 0
    while current != nil:
        if i == index:
            return current[0]
        i = i + 1
        current = current[1]
    nil

# Check if list is empty
# Args:
#   list: Linked list
# Returns: true if empty, false otherwise
fn ll_is_empty(list):
    list == nil

# Get length of list
# Args:
#   list: Linked list
# Returns: Number of elements
fn ll_length(list):
    var count = 0
    var current = list
    while current != nil:
        count = count + 1
        current = current[1]
    count

# Check if list contains value
# Args:
#   list: Linked list
#   value: Value to search for
# Returns: true if value found, false otherwise
fn ll_contains(list, value):
    var current = list
    while current != nil:
        if current[0] == value:
            return true
        current = current[1]
    false

# Find first element matching predicate
# Args:
#   list: Linked list
#   pred: Predicate function (value -> bool)
# Returns: First matching value or nil
fn ll_find(list, pred):
    var current = list
    while current != nil:
        var val = current[0]
        if pred(val):
            return val
        current = current[1]
    nil

# Find index of first occurrence of value
# Args:
#   list: Linked list
#   value: Value to search for
# Returns: Index of value or -1 if not found
fn ll_index_of(list, value):
    var current = list
    var index = 0
    while current != nil:
        if current[0] == value:
            return index
        index = index + 1
        current = current[1]
    -1

# Check if all elements satisfy predicate
# Args:
#   list: Linked list
#   pred: Predicate function (value -> bool)
# Returns: true if all elements match, false otherwise
fn ll_all(list, pred):
    var current = list
    while current != nil:
        var val = current[0]
        if !pred(val):
            return false
        current = current[1]
    true

# Check if any element satisfies predicate
# Args:
#   list: Linked list
#   pred: Predicate function (value -> bool)
# Returns: true if any element matches, false otherwise
fn ll_any(list, pred):
    var current = list
    while current != nil:
        var val = current[0]
        if pred(val):
            return true
        current = current[1]
    false

# Get last element of list
# Args:
#   list: Linked list
# Returns: Last element or nil if empty
fn ll_last(list):
    if list == nil:
        nil
    else:
        var current = list
        var last = current[0]
        while current != nil:
            last = current[0]
            current = current[1]
        last

# Get all elements except last
# Args:
#   list: Linked list
# Returns: New list without last element
fn ll_init(list):
    if list == nil:
        nil
    else:
        var arr = ll_to_array(list)
        if arr.length() <= 1:
            nil
        else:
            var new_arr = []
            var i = 0
            while i < arr.length() - 1:
                new_arr = new_arr.push(arr[i])
                i = i + 1
            ll_from_array(new_arr)

# Detect cycle using Floyd's algorithm (tortoise and hare)
# Args:
#   list: Linked list (potentially with cycle)
# Returns: true if cycle exists, false otherwise
#
# Note: This implementation assumes proper node structure.
# In practice, cycles cannot be created with immutable tuples,
# but this demonstrates the algorithm conceptually.
fn ll_has_cycle(list):
    if list == nil:
        return false

    var slow = list
    var fast = list

    while fast != nil:
        var fast_next = fast[1]
        if fast_next == nil:
            return false

        slow = slow[1]
        fast = fast_next[1]

        if slow == fast:
            return true

    false

# Find cycle start node (Floyd's algorithm phase 2)
# Args:
#   list: Linked list with cycle
# Returns: Value at cycle start, or nil if no cycle
#
# Note: Conceptual implementation - cycles cannot exist with immutable tuples
fn ll_find_cycle_start(list):
    if list == nil:
        return nil

    var slow = list
    var fast = list
    var has_cycle = false

    while fast != nil:
        var fast_next = fast[1]
        if fast_next == nil:
            return nil

        slow = slow[1]
        fast = fast_next[1]

        if slow == fast:
            has_cycle = true
            break

    if !has_cycle:
        return nil

    slow = list
    while slow != fast:
        slow = slow[1]
        fast = fast[1]

    slow[0]
