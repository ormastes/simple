# Fenwick Tree Range Operations
#
# Purpose: Range sum queries and range update operations
#
# Contains:
# - Range sum queries
# - Range update trees (difference array technique)
# - Range update and query operations

# Import utilities from other modules
mod fenwick_tree.types
mod fenwick_tree.query
mod fenwick_tree.update

# ============================================================================
# Range Query Operations
# ============================================================================

# Query sum in range [l, r]
fn range_sum(fenwick_tree, l: i64, r: i64) -> i64:
    """Compute sum of elements in range [l, r] (inclusive, 1-indexed).

    Uses prefix sum difference:
      range_sum(l, r) = prefix_sum(r) - prefix_sum(l-1)

    Args:
      fenwick_tree: (tree, n) tuple
      l: Left boundary (1-indexed, inclusive)
      r: Right boundary (1-indexed, inclusive)

    Returns:
      Sum of elements from index l to r

    Time: O(log n)

    Example:
      range_sum(tree, 3, 7) returns sum of arr[3..7]
      = prefix_sum(7) - prefix_sum(2)
    """
    if l > r:
        return 0
    if l < 1:
        return range_sum(fenwick_tree, 1, r)

    val sum_r = prefix_sum(fenwick_tree, r)
    val sum_l = prefix_sum(fenwick_tree, l - 1)
    sum_r - sum_l

# Alias for range_sum
fn sum_range(fenwick_tree, left: i64, right: i64) -> i64:
    """Query range sum [left, right]. Alias for range_sum.

    Time: O(log n)
    """
    range_sum(fenwick_tree, left, right)

# ============================================================================
# Range Update with Difference Array
# ============================================================================

# Create a Fenwick tree that supports efficient range updates
fn create_range_update_tree(n: i64) -> ((list, i64), (list, i64), i64):
    """Create a Fenwick tree optimized for range updates.

    Uses two Fenwick trees to support efficient range updates:
    - tree1: Difference array
    - tree2: Auxiliary tree for queries

    This allows O(log n) range updates and O(log n) point queries.

    Args:
      n: Number of elements

    Returns:
      (tree1, tree2, n) tuple

    Time: O(n)
    Space: O(n)
    """
    val tree1 = create_fenwick_tree(n)
    val tree2 = create_fenwick_tree(n)
    (tree1, tree2, n)

# Build range update tree from array
fn create_range_update_from_array(arr: list) -> ((list, i64), (list, i64), i64):
    """Build a range update tree from an existing array.

    Args:
      arr: Input array (0-indexed)

    Returns:
      Range update tree structure

    Time: O(n)
    """
    val n = arr.len()
    var tree1 = create_fenwick_tree(n)
    var tree2 = create_fenwick_tree(n)

    var i = 0
    while i < n:
        val idx = i + 1
        tree1 = update(tree1, idx, arr[i])
        i = i + 1

    (tree1, tree2, n)

# Update range [l, r] by adding delta (using difference array)
fn range_update(range_tree, l: i64, r: i64, delta: i64) -> ((list, i64), (list, i64), i64):
    """Add delta to all elements in range [l, r].

    Uses difference array technique:
    - Update diff[l] += delta
    - Update diff[r+1] -= delta

    This makes prefix sums correctly reflect range updates.

    Args:
      range_tree: (tree1, tree2, n) tuple
      l: Left boundary (1-indexed, inclusive)
      r: Right boundary (1-indexed, inclusive)
      delta: Value to add to range

    Returns:
      Updated range update tree

    Time: O(log n)

    Example:
      range_update(tree, 2, 5, 10) adds 10 to arr[2..5]
    """
    val tree1 = range_tree.0
    val tree2 = range_tree.1
    val n = range_tree.2

    if l > r:
        return range_tree
    if l < 1:
        return range_update(range_tree, 1, r, delta)
    if r > n:
        return range_update(range_tree, l, n, delta)

    val new_tree1_1 = update(tree1, l, delta)
    var new_tree1 = new_tree1_1
    if r + 1 <= n:
        new_tree1 = update(new_tree1_1, r + 1, 0 - delta)

    (new_tree1, tree2, n)

# Add value to range [l, r]
fn add_range(range_tree, l: i64, r: i64, value: i64) -> ((list, i64), (list, i64), i64):
    """Add value to range [l, r]. Alias for range_update.

    Time: O(log n)
    """
    range_update(range_tree, l, r, value)

# Query point value in range update tree
fn range_update_point_query(range_tree, i: i64) -> i64:
    """Query value at index i in a range update tree.

    Computes prefix sum of difference array.

    Args:
      range_tree: (tree1, tree2, n) tuple
      i: 1-indexed position

    Returns:
      Value at index i after all range updates

    Time: O(log n)
    """
    val tree1 = range_tree.0
    prefix_sum(tree1, i)

# Query range sum in range update tree
fn range_update_range_sum(range_tree, l: i64, r: i64) -> i64:
    """Query range sum [l, r] in a range update tree.

    Time: O(n) - requires summing individual elements
    This is less efficient than standard range queries.
    """
    if l > r:
        return 0

    var sum = 0
    var i = l
    while i <= r:
        val val = range_update_point_query(range_tree, i)
        sum = sum + val
        i = i + 1
    sum
