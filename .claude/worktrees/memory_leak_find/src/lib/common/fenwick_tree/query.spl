# Fenwick Tree Query Operations
#
# Purpose: Prefix sum and point query operations
#
# Contains:
# - Prefix sum queries
# - Point value queries
# - Query aliases

# Import bit manipulation utilities from types module
mod fenwick_tree.types

# ============================================================================
# Prefix Sum Query Operations
# ============================================================================

# Query prefix sum from index 1 to i
fn prefix_sum(fenwick_tree, i: i64) -> i64:
    """Compute prefix sum from index 1 to i (inclusive).

    Sums tree[i] and all ancestors in query path.
    Traverses backwards by repeatedly subtracting LSB.

    Algorithm:
      sum = 0
      while i > 0:
        sum += tree[i]
        i = i - (i & -i)  # Move to next range
      return sum

    Args:
      fenwick_tree: (tree, n) tuple
      i: 1-indexed position (query range [1, i])

    Returns:
      Sum of elements from index 1 to i

    Time: O(log n)

    Example:
      prefix_sum(tree, 5) returns sum of arr[1..5]
      Accesses tree[5], tree[4], tree[0] and sums them
    """
    val tree = fenwick_tree.0
    val n = fenwick_tree.1

    if i < 0:
        return 0
    if i > n:
        return prefix_sum(fenwick_tree, n)

    var sum = 0
    var idx = i
    while idx > 0:
        val current = tree[idx]
        sum = sum + current
        idx = get_next(idx)

    sum

# Alias for prefix_sum
fn query(fenwick_tree, i: i64) -> i64:
    """Query prefix sum up to index i. Alias for prefix_sum.

    Time: O(log n)
    """
    prefix_sum(fenwick_tree, i)

# ============================================================================
# Point Query Operations
# ============================================================================

# Get value at single point i
fn point_query(fenwick_tree, i: i64) -> i64:
    """Get the value at a single index i.

    Computes the difference of prefix sums:
      point_query(i) = prefix_sum(i) - prefix_sum(i-1)

    Args:
      fenwick_tree: (tree, n) tuple
      i: 1-indexed position

    Returns:
      Value at index i

    Time: O(log n)
    """
    val sum_i = prefix_sum(fenwick_tree, i)
    val sum_prev = prefix_sum(fenwick_tree, i - 1)
    sum_i - sum_prev

# Alias for point_query
fn get_value_at(fenwick_tree, i: i64) -> i64:
    """Get value at index i. Alias for point_query.

    Time: O(log n)
    """
    point_query(fenwick_tree, i)

# ============================================================================
# Advanced Query Operations
# ============================================================================

# Find smallest index where prefix sum >= target
fn lower_bound(fenwick_tree, target: i64) -> i64:
    """Find smallest index i where prefix_sum(i) >= target.

    Uses binary search on prefix sums.
    Returns -1 if no such index exists.

    Args:
      fenwick_tree: (tree, n) tuple
      target: Target prefix sum

    Returns:
      Smallest index with prefix_sum >= target, or -1

    Time: O(log² n)

    Example:
      If prefix sums are [3, 5, 4, 10, 15, ...]
      lower_bound(tree, 7) returns 4 (first sum >= 7 is 10)
    """
    val n = fenwick_tree.1

    var left = 1
    var right = n
    var result = -1

    while left <= right:
        val mid = (left + right) / 2
        val psum = prefix_sum(fenwick_tree, mid)

        if psum >= target:
            result = mid
            right = mid - 1
        else:
            left = mid + 1

    result

# Find largest index where prefix sum <= target
fn upper_bound(fenwick_tree, target: i64) -> i64:
    """Find largest index i where prefix_sum(i) <= target.

    Uses binary search on prefix sums.
    Returns 0 if no such index exists.

    Args:
      fenwick_tree: (tree, n) tuple
      target: Target prefix sum

    Returns:
      Largest index with prefix_sum <= target, or 0

    Time: O(log² n)
    """
    val n = fenwick_tree.1

    var left = 1
    var right = n
    var result = 0

    while left <= right:
        val mid = (left + right) / 2
        val psum = prefix_sum(fenwick_tree, mid)

        if psum <= target:
            result = mid
            left = mid + 1
        else:
            right = mid - 1

    result

# Find k-th smallest element (requires frequency tree)
fn find_kth_smallest(fenwick_tree, k: i64) -> i64:
    """Find the k-th smallest element in a frequency Fenwick tree.

    Assumes Fenwick tree stores frequencies at each position.
    Uses binary search to find position with k-th element.

    Args:
      fenwick_tree: Frequency tree (tree, n) tuple
      k: 1-indexed position (1 = smallest)

    Returns:
      Index containing the k-th element, or -1

    Time: O(log² n)

    Example:
      Frequencies: [0, 2, 1, 0, 3, 1, ...]
      find_kth_smallest(tree, 3) finds position of 3rd element
    """
    val n = fenwick_tree.1

    if k < 1:
        return -1

    val total = prefix_sum(fenwick_tree, n)
    if k > total:
        return -1

    lower_bound(fenwick_tree, k)
