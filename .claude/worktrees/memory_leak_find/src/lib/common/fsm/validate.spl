# FSM Validation and Analysis Functions

fn validate_fsm(fsm: FSM) -> text:
    """Validate FSM structure. Returns empty string if valid, error message otherwise."""
    # Check if initial state exists
    if fsm.initial_state == "":
        return "No initial state set"

    var initial_exists = false
    for i in 0..fsm.states.len():
        if fsm.states[i].name == fsm.initial_state:
            initial_exists = true

    if not initial_exists:
        return "Initial state does not exist in state set"

    # Check if all transitions reference valid states
    for i in 0..fsm.transitions.len():
        var trans = fsm.transitions[i]
        var from_exists = false
        var to_exists = false

        for j in 0..fsm.states.len():
            if fsm.states[j].name == trans.from_state:
                from_exists = true
            if fsm.states[j].name == trans.to_state:
                to_exists = true

        if not from_exists:
            return "Transition from non-existent state: " + trans.from_state
        if not to_exists:
            return "Transition to non-existent state: " + trans.to_state

    ""

fn is_deterministic(fsm: FSM) -> bool:
    """Check if FSM is deterministic (DFA)."""
    # Check for epsilon transitions
    if has_epsilon_transitions(fsm):
        return false

    # Check for multiple transitions on same symbol from same state
    for i in 0..fsm.transitions.len():
        var trans1 = fsm.transitions[i]
        for j in (i + 1)..fsm.transitions.len():
            var trans2 = fsm.transitions[j]
            if trans1.from_state == trans2.from_state and trans1.symbol == trans2.symbol:
                return false

    true

fn reachable_states(fsm: FSM) -> [text]:
    """Get list of states reachable from initial state."""
    if fsm.initial_state == "":
        return []

    var reachable: [text] = [fsm.initial_state]
    var queue: [text] = [fsm.initial_state]
    var queue_start = 0

    # BFS traversal
    while queue_start < queue.len():
        var current = queue[queue_start]
        queue_start = queue_start + 1

        # Find all transitions from current state
        for i in 0..fsm.transitions.len():
            var trans = fsm.transitions[i]
            if trans.from_state == current:
                # Check if to_state is already reachable
                var already_reachable = false
                for j in 0..reachable.len():
                    if reachable[j] == trans.to_state:
                        already_reachable = true

                if not already_reachable:
                    reachable = reachable + [trans.to_state]
                    queue = queue + [trans.to_state]

    reachable

fn minimize_fsm(fsm: FSM) -> FSM:
    """Minimize DFA by merging equivalent states (basic implementation)."""
    if not is_deterministic(fsm):
        return fsm  # Can only minimize DFAs

    # Remove unreachable states first
    var reach = reachable_states(fsm)
    var new_states: [FSMState] = []
    for i in 0..fsm.states.len():
        var is_reachable = false
        for j in 0..reach.len():
            if fsm.states[i].name == reach[j]:
                is_reachable = true
        if is_reachable:
            new_states = new_states + [fsm.states[i]]

    # For basic minimization, we'll just remove unreachable states
    # Full Hopcroft minimization is complex for runtime constraints
    var new_transitions: [FSMTransition] = []
    for i in 0..fsm.transitions.len():
        var trans = fsm.transitions[i]
        var from_reachable = false
        var to_reachable = false
        for j in 0..reach.len():
            if trans.from_state == reach[j]:
                from_reachable = true
            if trans.to_state == reach[j]:
                to_reachable = true
        if from_reachable and to_reachable:
            new_transitions = new_transitions + [trans]

    FSM(
        states: new_states,
        transitions: new_transitions,
        initial_state: fsm.initial_state,
        current: fsm.current,
        alphabet: fsm.alphabet,
        deterministic: fsm.deterministic
    )

fn complement_fsm(fsm: FSM) -> FSM:
    """Create complement FSM (accepts strings that original rejects)."""
    if not is_deterministic(fsm):
        return fsm  # Can only complement complete DFAs

    # Flip accepting states
    var new_states: [FSMState] = []
    for i in 0..fsm.states.len():
        var old_state = fsm.states[i]
        var new_state = FSMState(
            name: old_state.name,
            accepting: not old_state.accepting,
            data: old_state.data
        )
        new_states = new_states + [new_state]

    FSM(
        states: new_states,
        transitions: fsm.transitions,
        initial_state: fsm.initial_state,
        current: fsm.current,
        alphabet: fsm.alphabet,
        deterministic: fsm.deterministic
    )

fn to_dfa(fsm: FSM) -> FSM:
    """Convert NFA to DFA using subset construction (simplified)."""
    if is_deterministic(fsm):
        return fsm

    # This is a simplified conversion that handles epsilon transitions
    # Full subset construction is complex for runtime constraints
    var dfa = create_fsm()

    # Compute epsilon closure of initial state
    var initial_closure = epsilon_closure(fsm, fsm.initial_state)
    var initial_name = join_state_names(initial_closure)

    # Check if any state in initial closure is accepting
    var initial_accepting = false
    for i in 0..initial_closure.len():
        for j in 0..fsm.states.len():
            if fsm.states[j].name == initial_closure[i] and fsm.states[j].accepting:
                initial_accepting = true

    dfa = add_state(dfa, initial_name, initial_accepting)
    dfa = set_initial_state(dfa, initial_name)

    dfa
