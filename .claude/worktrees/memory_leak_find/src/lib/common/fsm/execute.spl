# FSM Execution Functions

fn process_input(fsm: FSM, symbol: text) -> FSM:
    """Process a single input symbol and transition to next state."""
    if fsm.current == "":
        return fsm

    # Find applicable transitions
    var next_state = ""
    var highest_priority = -1000000

    for i in 0..fsm.transitions.len():
        var trans = fsm.transitions[i]
        if trans.from_state == fsm.current and trans.symbol == symbol:
            if trans.priority > highest_priority:
                highest_priority = trans.priority
                next_state = trans.to_state

    if next_state == "":
        # No valid transition - stay in error state (empty string)
        next_state = ""

    FSM(
        states: fsm.states,
        transitions: fsm.transitions,
        initial_state: fsm.initial_state,
        current: next_state,
        alphabet: fsm.alphabet,
        deterministic: fsm.deterministic
    )

fn process_sequence(fsm: FSM, symbols: [text]) -> FSM:
    """Process a sequence of input symbols."""
    var current_fsm = fsm
    for i in 0..symbols.len():
        current_fsm = process_input(current_fsm, symbols[i])
        if current_fsm.current == "":
            # Early exit on invalid transition
            return current_fsm
    current_fsm

fn current_state(fsm: FSM) -> text:
    """Get the current state name."""
    fsm.current

fn reset_fsm(fsm: FSM) -> FSM:
    """Reset FSM to initial state."""
    FSM(
        states: fsm.states,
        transitions: fsm.transitions,
        initial_state: fsm.initial_state,
        current: fsm.initial_state,
        alphabet: fsm.alphabet,
        deterministic: fsm.deterministic
    )

fn is_in_state(fsm: FSM, state_name: text) -> bool:
    """Check if FSM is currently in the given state."""
    fsm.current == state_name

fn is_accepting_state(fsm: FSM) -> bool:
    """Check if current state is accepting."""
    if fsm.current == "":
        return false

    for i in 0..fsm.states.len():
        var state = fsm.states[i]
        if state.name == fsm.current:
            return state.accepting
    false

fn accepts_string(fsm: FSM, input: text) -> bool:
    """Check if FSM accepts the given input string."""
    # Convert string to symbol array
    var symbols: [text] = []
    for i in 0..input.len():
        symbols = symbols + [input[i:i+1]]

    if is_deterministic(fsm):
        # Use DFA simulation
        var result_fsm = reset_fsm(fsm)
        result_fsm = process_sequence(result_fsm, symbols)
        return is_accepting_state(result_fsm)
    else:
        # Use NFA simulation
        return simulate_nfa(fsm, symbols)

fn simulate_nfa(fsm: FSM, symbols: [text]) -> bool:
    """Simulate NFA execution and check if any path leads to accepting state."""
    if fsm.initial_state == "":
        return false

    # Track all possible current states
    var current_states: [text] = epsilon_closure(fsm, fsm.initial_state)

    # Process each symbol
    for sym_idx in 0..symbols.len():
        var symbol = symbols[sym_idx]
        var next_states: [text] = []

        # For each current state, find all reachable states on symbol
        for i in 0..current_states.len():
            var state = current_states[i]
            for j in 0..fsm.transitions.len():
                var trans = fsm.transitions[j]
                if trans.from_state == state and trans.symbol == symbol:
                    # Add epsilon closure of destination
                    var closure = epsilon_closure(fsm, trans.to_state)
                    for k in 0..closure.len():
                        var already_added = false
                        for m in 0..next_states.len():
                            if next_states[m] == closure[k]:
                                already_added = true
                        if not already_added:
                            next_states = next_states + [closure[k]]

        current_states = next_states
        if current_states.len() == 0:
            return false  # No valid transitions

    # Check if any final state is accepting
    for i in 0..current_states.len():
        for j in 0..fsm.states.len():
            if fsm.states[j].name == current_states[i] and fsm.states[j].accepting:
                return true

    false

fn match_pattern(fsm: FSM, input: text) -> [text]:
    """Find all matching substrings in input. Returns list of matches."""
    var matches: [text] = []

    # Try matching from each position
    for start in 0..input.len():
        for end in (start + 1)..(input.len() + 1):
            var substring = input[start:end]
            if accepts_string(fsm, substring):
                matches = matches + [substring]

    matches
