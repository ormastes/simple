# X.509 Certificate Parsing
#
# This module handles parsing of X.509 certificate structure including
# Distinguished Names, validity periods, public keys, and extensions.

fn parse_rdn_component(rdn_bytes: text) -> text:
    # Parse Relative Distinguished Name component (OID, value)
    val tlv = asn1_read_tlv(rdn_bytes, 0)
    if tlv == nil:
        return nil

    val tag = tlv[0]
    val seq_value = tlv[1]

    # RDN is a SET containing a SEQUENCE
    val inner_tlv = asn1_read_tlv(seq_value, 0)
    if inner_tlv == nil:
        return nil

    val inner_value = inner_tlv[1]

    # SEQUENCE contains OID and value
    val oid_tlv = asn1_read_tlv(inner_value, 0)
    if oid_tlv == nil:
        return nil

    val oid = parse_der_oid(oid_tlv[1])

    val value_tlv = asn1_read_tlv(inner_value, oid_tlv[2])
    if value_tlv == nil:
        return nil

    val value = parse_der_string(value_tlv[1])

    (oid, value)

fn parse_distinguished_name(dn_bytes: text) -> text:
    # Parse Distinguished Name and return (cn, o, ou, c, st, l, components)
    var cn = nil
    var o = nil
    var ou = nil
    var c = nil
    var st = nil
    var l = nil
    var components = []

    var offset = 0
    while offset < dn_bytes.length():
        val tlv = asn1_read_tlv(dn_bytes, offset)
        if tlv == nil:
            break

        val component = parse_rdn_component(dn_bytes.substring(offset, tlv[2]))
        if component != nil:
            val oid = component[0]
            val value = component[1]
            components = components + [(oid, value)]

            if oid == OID_COMMON_NAME:
                cn = value
            else:
                if oid == OID_ORGANIZATION:
                    o = value
                else:
                    if oid == OID_ORG_UNIT:
                        ou = value
                    else:
                        if oid == OID_COUNTRY:
                            c = value
                        else:
                            if oid == OID_STATE:
                                st = value
                            else:
                                if oid == OID_LOCALITY:
                                    l = value

        offset = tlv[2]

    (cn, o, ou, c, st, l, components)

fn get_common_name(dn: text) -> text:
    # Extract Common Name from Distinguished Name tuple
    dn[0]

fn get_organization(dn: text) -> text:
    # Extract Organization from Distinguished Name tuple
    dn[1]

fn get_org_unit(dn: text) -> text:
    # Extract Organizational Unit from Distinguished Name tuple
    dn[2]

fn get_country(dn: text) -> text:
    # Extract Country from Distinguished Name tuple
    dn[3]

fn get_state(dn: text) -> text:
    # Extract State/Province from Distinguished Name tuple
    dn[4]

fn get_locality(dn: text) -> text:
    # Extract Locality from Distinguished Name tuple
    dn[5]

fn dn_to_string(dn: text) -> text:
    # Convert Distinguished Name tuple to string representation
    var parts = []

    if dn[0] != nil:
        parts = parts + ["CN={dn[0]}"]
    if dn[1] != nil:
        parts = parts + ["O={dn[1]}"]
    if dn[2] != nil:
        parts = parts + ["OU={dn[2]}"]
    if dn[5] != nil:
        parts = parts + ["L={dn[5]}"]
    if dn[4] != nil:
        parts = parts + ["ST={dn[4]}"]
    if dn[3] != nil:
        parts = parts + ["C={dn[3]}"]

    parts.join(", ")

fn parse_utc_time(time_bytes: text) -> text:
    # Parse UTCTime (YYMMDDHHMMSSZ)
    if time_bytes.length() < 13:
        return nil

    val time_str = parse_der_string(time_bytes)

    # Extract components
    val year_str = time_str.substring(0, 2)
    val month_str = time_str.substring(2, 4)
    val day_str = time_str.substring(4, 6)
    val hour_str = time_str.substring(6, 8)
    val minute_str = time_str.substring(8, 10)
    val second_str = time_str.substring(10, 12)

    var year = year_str.to_int()
    # Y2K handling: 00-49 is 2000-2049, 50-99 is 1950-1999
    year = if year < 50: year + 2000 else: year + 1900

    val month = month_str.to_int()
    val day = day_str.to_int()
    val hour = hour_str.to_int()
    val minute = minute_str.to_int()
    val second = second_str.to_int()

    (year, month, day, hour, minute, second)

fn parse_generalized_time(time_bytes: text) -> text:
    # Parse GeneralizedTime (YYYYMMDDHHMMSSZ)
    if time_bytes.length() < 15:
        return nil

    val time_str = parse_der_string(time_bytes)

    val year = time_str.substring(0, 4).to_int()
    val month = time_str.substring(4, 6).to_int()
    val day = time_str.substring(6, 8).to_int()
    val hour = time_str.substring(8, 10).to_int()
    val minute = time_str.substring(10, 12).to_int()
    val second = time_str.substring(12, 14).to_int()

    (year, month, day, hour, minute, second)

fn time_to_timestamp(time_tuple: text) -> i64:
    # Convert time tuple to Unix timestamp (simplified)
    val year = time_tuple[0]
    val month = time_tuple[1]
    val day = time_tuple[2]
    val hour = time_tuple[3]
    val minute = time_tuple[4]
    val second = time_tuple[5]

    # Simplified calculation (doesn't account for leap years properly)
    val days = (year - 1970) * 365 + month * 30 + day
    val seconds = days * 86400 + hour * 3600 + minute * 60 + second
    seconds

fn get_current_timestamp() -> i64:
    # Get current Unix timestamp (simplified - would need platform support)
    # For now, return a fixed value representing 2024
    1704067200  # Jan 1, 2024

fn parse_validity(validity_bytes: text) -> text:
    # Parse Validity SEQUENCE (notBefore, notAfter)
    val items = parse_der_sequence(validity_bytes)
    if items.length() < 2:
        return nil

    val not_before_tlv = items[0]
    val not_after_tlv = items[1]

    var not_before = nil
    var not_after = nil

    # notBefore can be UTCTime or GeneralizedTime
    if not_before_tlv[0] == TAG_UTCTIME:
        not_before = parse_utc_time(not_before_tlv[1])
    else:
        if not_before_tlv[0] == TAG_GENERALIZED_TIME:
            not_before = parse_generalized_time(not_before_tlv[1])

    # notAfter can be UTCTime or GeneralizedTime
    if not_after_tlv[0] == TAG_UTCTIME:
        not_after = parse_utc_time(not_after_tlv[1])
    else:
        if not_after_tlv[0] == TAG_GENERALIZED_TIME:
            not_after = parse_generalized_time(not_after_tlv[1])

    (not_before, not_after)

fn parse_public_key(spki_bytes: text) -> text:
    # Parse SubjectPublicKeyInfo
    val items = parse_der_sequence(spki_bytes)
    if items.length() < 2:
        return nil

    val algorithm_tlv = items[0]
    val public_key_tlv = items[1]

    # Parse algorithm identifier
    val alg_items = parse_der_sequence(algorithm_tlv[1])
    if alg_items.length() == 0:
        return nil

    val algorithm_oid = parse_der_oid(alg_items[0][1])

    # Parse public key bit string
    val key_bits = parse_der_bit_string(public_key_tlv[1])
    val key_bytes = key_bits[1]
    val bits = (key_bytes.length() - key_bits[0]) * 8

    (algorithm_oid, key_bytes, bits)

fn parse_extension(ext_bytes: text) -> text:
    # Parse single Extension (oid, critical, value)
    val items = parse_der_sequence(ext_bytes)
    if items.length() < 2:
        return nil

    val oid = parse_der_oid(items[0][1])

    var critical = false
    var value_idx = 1

    # Check if critical flag is present
    if items.length() >= 3:
        if items[1][0] == TAG_INTEGER:
            critical = parse_der_integer(items[1][1]) != 0
            value_idx = 2

    val value = items[value_idx][1]

    (oid, critical, value)

fn parse_extensions(ext_bytes: text) -> text:
    # Parse Extensions SEQUENCE
    var extensions = []

    # Extensions are wrapped in context-specific tag [3]
    val outer_tlv = asn1_read_tlv(ext_bytes, 0)
    if outer_tlv == nil:
        return []

    if outer_tlv[0] != TAG_CONTEXT_3:
        return []

    val inner_items = parse_der_sequence(outer_tlv[1])

    var i = 0
    while i < inner_items.length():
        val ext_tlv = inner_items[i]
        val ext = parse_extension(ext_tlv[1])
        if ext != nil:
            extensions = extensions + [ext]
        i = i + 1

    extensions

fn parse_basic_constraints(value_bytes: text) -> text:
    # Parse Basic Constraints extension (ca, path_len)
    val items = parse_der_sequence(value_bytes)

    var is_ca = false
    var path_len = nil

    if items.length() > 0:
        if items[0][0] == TAG_INTEGER:
            is_ca = parse_der_integer(items[0][1]) != 0

    if items.length() > 1:
        if items[1][0] == TAG_INTEGER:
            path_len = parse_der_integer(items[1][1])

    (is_ca, path_len)

fn parse_subject_alt_names(value_bytes: text) -> text:
    # Parse Subject Alternative Name extension
    var names = []

    val items = parse_der_sequence(value_bytes)
    var i = 0

    while i < items.length():
        val item = items[i]
        val tag = item[0]
        val value = item[1]

        # Context-specific tags for different name types
        # [2] = dNSName
        if tag == 130:
            names = names + [("dns", parse_der_string(value))]
        else:
            # [1] = rfc822Name (email)
            if tag == 129:
                names = names + [("email", parse_der_string(value))]
            else:
                # [6] = uniformResourceIdentifier
                if tag == 134:
                    names = names + [("uri", parse_der_string(value))]
                else:
                    # [7] = iPAddress
                    if tag == 135:
                        names = names + [("ip", value)]

        i = i + 1

    names

fn parse_key_usage(value_bytes: text) -> text:
    # Parse Key Usage extension (returns bit flags)
    if value_bytes.length() == 0:
        return 0

    val bits = parse_der_bit_string(value_bytes)
    if bits[1].length() == 0:
        return 0

    # Return first byte of bit string as flags
    bits[1].char_code_at(0)

fn parse_tbs_certificate(tbs_bytes: text) -> text:
    # Parse TBSCertificate (To Be Signed Certificate)
    val items = parse_der_sequence(tbs_bytes)
    if items.length() < 7:
        return nil

    var idx = 0

    # Version [0] EXPLICIT (optional)
    var version = 1
    if items[idx][0] == TAG_CONTEXT_0:
        val version_seq = parse_der_sequence(items[idx][1])
        if version_seq.length() > 0:
            version = parse_der_integer(version_seq[0][1]) + 1
        idx = idx + 1

    # Serial Number
    val serial = parse_der_integer(items[idx][1])
    idx = idx + 1

    # Signature Algorithm
    val sig_alg_items = parse_der_sequence(items[idx][1])
    val sig_alg = parse_der_oid(sig_alg_items[0][1])
    idx = idx + 1

    # Issuer
    val issuer = parse_distinguished_name(items[idx][1])
    idx = idx + 1

    # Validity
    val validity = parse_validity(items[idx][1])
    idx = idx + 1

    # Subject
    val subject = parse_distinguished_name(items[idx][1])
    idx = idx + 1

    # SubjectPublicKeyInfo
    val public_key = parse_public_key(items[idx][1])
    idx = idx + 1

    # Extensions [3] EXPLICIT (optional)
    var extensions = []
    if idx < items.length():
        if items[idx][0] == TAG_CONTEXT_3:
            extensions = parse_extensions(items[idx][1])

    (version, serial, sig_alg, issuer, validity, subject, public_key, extensions)

fn parse_certificate_der(der: text) -> text:
    # Parse DER-encoded certificate
    # Returns: (version, serial, issuer, subject, validity, public_key, extensions, sig_alg, signature, raw_der)

    val cert_tlv = asn1_read_tlv(der, 0)
    if cert_tlv == nil:
        return nil

    val cert_seq = parse_der_sequence(cert_tlv[1])
    if cert_seq.length() < 3:
        return nil

    # TBSCertificate
    val tbs_tlv = cert_seq[0]
    val tbs = parse_tbs_certificate(tbs_tlv[1])
    if tbs == nil:
        return nil

    # signatureAlgorithm
    val sig_alg_tlv = cert_seq[1]
    val sig_alg_items = parse_der_sequence(sig_alg_tlv[1])
    val sig_alg = parse_der_oid(sig_alg_items[0][1])

    # signatureValue
    val sig_tlv = cert_seq[2]
    val signature = parse_der_bit_string(sig_tlv[1])

    val version = tbs[0]
    val serial = tbs[1]
    val issuer = tbs[3]
    val subject = tbs[5]
    val validity = tbs[4]
    val public_key = tbs[6]
    val extensions = tbs[7]

    (version, serial, issuer, subject, validity, public_key, extensions, sig_alg, signature[1], der)

fn parse_certificate(pem: text) -> text:
    # Parse PEM-encoded certificate
    val der = pem_decode(pem)
    if der == nil:
        return nil

    parse_certificate_der(der)

fn parse_certificate_chain(pem_chain: text) -> text:
    # Parse multiple PEM certificates into chain
    val pem_certs = split_pem_chain(pem_chain)
    var certs = []

    var i = 0
    while i < pem_certs.length():
        val cert = parse_certificate(pem_certs[i])
        if cert != nil:
            certs = certs + [cert]
        i = i + 1

    certs

fn get_version(cert: text) -> i64:
    # Get certificate version (1, 2, or 3)
    cert[0]

fn get_serial_number(cert: text) -> i64:
    # Get certificate serial number
    cert[1]

fn get_issuer(cert: text) -> text:
    # Get issuer Distinguished Name
    cert[2]

fn get_subject(cert: text) -> text:
    # Get subject Distinguished Name
    cert[3]

fn get_validity(cert: text) -> text:
    # Get validity period
    cert[4]

fn get_public_key(cert: text) -> text:
    # Get public key from certificate tuple
    cert[5]

fn get_extensions(cert: text) -> text:
    # Get extensions from certificate tuple
    cert[6]

fn get_signature_algorithm(cert: text) -> text:
    # Get signature algorithm OID
    cert[7]

fn get_signature(cert: text) -> text:
    # Get signature value
    cert[8]

fn get_raw_der(cert: text) -> text:
    # Get raw DER bytes of certificate
    cert[9]

fn get_not_before(cert: text) -> text:
    # Get notBefore from certificate tuple
    val validity = cert[4]
    validity[0]

fn get_not_after(cert: text) -> text:
    # Get notAfter from certificate tuple
    val validity = cert[4]
    validity[1]

fn get_public_key_algorithm(cert: text) -> text:
    # Get public key algorithm OID
    val pub_key = get_public_key(cert)
    pub_key[0]

fn get_public_key_bits(cert: text) -> i64:
    # Get public key size in bits
    val pub_key = get_public_key(cert)
    pub_key[2]

fn is_rsa_key(cert: text) -> bool:
    # Check if certificate uses RSA public key
    val algorithm = get_public_key_algorithm(cert)
    algorithm == OID_RSA_ENCRYPTION

fn find_extension(cert: text, oid: text) -> text:
    # Find extension by OID
    val extensions = get_extensions(cert)
    if extensions == nil:
        return nil

    var i = 0
    while i < extensions.length():
        val ext = extensions[i]
        if ext[0] == oid:
            return ext
        i = i + 1

    nil

fn is_ca_certificate(cert: text) -> bool:
    # Check if certificate is a CA certificate
    val ext = find_extension(cert, OID_BASIC_CONSTRAINTS)
    if ext == nil:
        return false

    val bc = parse_basic_constraints(ext[2])
    if bc == nil:
        return false

    bc[0]

fn get_path_length_constraint(cert: text) -> i64:
    # Get path length constraint from Basic Constraints
    val ext = find_extension(cert, OID_BASIC_CONSTRAINTS)
    if ext == nil:
        return nil

    val bc = parse_basic_constraints(ext[2])
    if bc == nil:
        return nil

    bc[1]

fn get_subject_alt_names(cert: text) -> text:
    # Get Subject Alternative Names from certificate
    val ext = find_extension(cert, OID_SUBJECT_ALT_NAME)
    if ext == nil:
        return []

    parse_subject_alt_names(ext[2])

fn get_dns_names(cert: text) -> text:
    # Extract DNS names from Subject Alternative Names
    val san = get_subject_alt_names(cert)
    var dns_names = []

    var i = 0
    while i < san.length():
        val name = san[i]
        if name[0] == "dns":
            dns_names = dns_names + [name[1]]
        i = i + 1

    dns_names

fn get_key_usage(cert: text) -> i64:
    # Get Key Usage flags from certificate
    val ext = find_extension(cert, OID_KEY_USAGE)
    if ext == nil:
        return nil

    parse_key_usage(ext[2])

fn has_key_usage_flag(cert: text, flag: i64) -> bool:
    # Check if certificate has specific key usage flag
    val usage = get_key_usage(cert)
    if usage == nil:
        return false

    (usage & flag) != 0

fn is_self_signed(cert: text) -> bool:
    # Check if certificate is self-signed
    val issuer = get_issuer(cert)
    val subject = get_subject(cert)

    val issuer_cn = get_common_name(issuer)
    val subject_cn = get_common_name(subject)

    issuer_cn == subject_cn
