# Special Functions
#
# Purpose: Mathematical special functions and transcendental functions
#
# Contains:
# - Factorial (floating-point)
# - Binomial coefficients
# - Gamma function approximation (Stirling)
# - Elementary transcendental functions (log, exp, sqrt, power)
# - Trigonometric functions (sin, cos via Taylor series)
# - Error function (erf approximation)

fn nm_factorial_f64(n: i64) -> f64:
    """Calculate factorial as floating point.

    Allows larger values than integer factorial.

    Example:
        nm_factorial_f64(10)  # 3628800.0
    """
    if n <= 1:
        return 1.0

    var result = 1.0
    var i = 2
    while i <= n:
        result = result * i
        i = i + 1
    result

fn nm_binomial_coefficient(n: i64, k: i64) -> f64:
    """Calculate binomial coefficient C(n,k) as float.

    C(n,k) = n! / (k! * (n-k)!)

    Example:
        nm_binomial_coefficient(5, 2)  # 10.0
    """
    if k > n or k < 0:
        return 0.0
    if k == 0 or k == n:
        return 1.0

    var k_adjusted = k
    if k > n - k:
        k_adjusted = n - k

    var result = 1.0
    var i = 0
    while i < k_adjusted:
        result = result * (n - i) / (i + 1)
        i = i + 1
    result

fn nm_log_gamma_stirling(x: f64) -> f64:
    """Approximate log(gamma(x)) using Stirling's approximation.

    log(Γ(x)) ≈ (x - 0.5)*log(x) - x + 0.5*log(2π)
    Accurate for large x.

    Example:
        nm_log_gamma_stirling(10.0)
    """
    if x <= 0.0:
        return 0.0

    val log_2pi = 1.8378770664093453
    (x - 0.5) * nm_log_approx(x) - x + 0.5 * log_2pi

fn nm_log_approx(x: f64) -> f64:
    """Approximate natural logarithm using Taylor series.

    For x near 1, uses ln(1+y) ≈ y - y²/2 + y³/3 - ...

    Example:
        nm_log_approx(2.0)  # ≈ 0.693
    """
    if x <= 0.0:
        return -999999999.0
    if x == 1.0:
        return 0.0

    var y = x - 1.0
    var result = 0.0
    var term = y
    var i = 1

    while i <= 50:
        if i % 2 == 1:
            result = result + term / i
        else:
            result = result - term / i
        term = term * y
        i = i + 1

    result

fn nm_exp_approx(x: f64) -> f64:
    """Approximate exponential function using Taylor series.

    e^x = 1 + x + x²/2! + x³/3! + ...

    Example:
        nm_exp_approx(1.0)  # ≈ 2.718
    """
    val NM_EPSILON = 1e-14

    var result = 1.0
    var term = 1.0
    var i = 1

    while i <= 50:
        term = term * x / i
        result = result + term
        var abs_term = term
        if abs_term < 0.0:
            abs_term = -abs_term
        if abs_term < NM_EPSILON:
            return result
        i = i + 1

    result

fn nm_sqrt_newton(x: f64, tolerance: f64) -> f64:
    """Calculate square root using Newton's method.

    Solves f(y) = y² - x = 0.

    Example:
        nm_sqrt_newton(2.0, 1e-10)  # ≈ 1.414
    """
    if x < 0.0:
        return 0.0
    if x == 0.0:
        return 0.0

    # Local convergence check
    fn nm_is_converged_local(current: f64, previous: f64, tol: f64) -> bool:
        var diff = current - previous
        if diff < 0.0:
            diff = -diff
        diff < tol

    var y = x / 2.0
    var iterations = 0

    while iterations < 100:
        val y_new = (y + x / y) / 2.0
        if nm_is_converged_local(y_new, y, tolerance):
            return y_new
        y = y_new
        iterations = iterations + 1

    y

fn nm_power_approx(base: f64, exp: f64) -> f64:
    """Approximate power function base^exp.

    Uses exp(exp * log(base)).

    Example:
        nm_power_approx(2.0, 3.0)  # 8.0
    """
    if base <= 0.0:
        return 0.0
    if exp == 0.0:
        return 1.0

    val log_base = nm_log_approx(base)
    val exp_val = nm_exp_approx(exp * log_base)
    exp_val

fn nm_sin_taylor(x: f64, terms: i64) -> f64:
    """Approximate sine using Taylor series.

    sin(x) = x - x³/3! + x⁵/5! - x⁷/7! + ...

    Example:
        nm_sin_taylor(1.0, 10)  # ≈ 0.841
    """
    var result = 0.0
    var term = x
    var i = 0

    while i < terms:
        if i % 2 == 0:
            result = result + term
        else:
            result = result - term

        term = term * x * x / ((2 * i + 2) * (2 * i + 3))
        i = i + 1

    result

fn nm_cos_taylor(x: f64, terms: i64) -> f64:
    """Approximate cosine using Taylor series.

    cos(x) = 1 - x²/2! + x⁴/4! - x⁶/6! + ...

    Example:
        nm_cos_taylor(1.0, 10)  # ≈ 0.540
    """
    var result = 1.0
    var term = 1.0
    var i = 0

    while i < terms:
        term = term * x * x / ((2 * i + 1) * (2 * i + 2))
        if i % 2 == 0:
            result = result - term
        else:
            result = result + term
        i = i + 1

    result

fn nm_erf_approx(x: f64) -> f64:
    """Approximate error function using polynomial approximation.

    erf(x) ≈ 1 - (a₁t + a₂t² + a₃t³ + a₄t⁴ + a₅t⁵)e^(-x²)
    where t = 1/(1 + px).

    Example:
        nm_erf_approx(1.0)  # ≈ 0.842
    """
    val p = 0.3275911
    val a1 = 0.254829592
    val a2 = -0.284496736
    val a3 = 1.421413741
    val a4 = -1.453152027
    val a5 = 1.061405429

    var sign = 1.0
    var abs_x = x
    if x < 0.0:
        sign = -1.0
        abs_x = -x

    val t = 1.0 / (1.0 + p * abs_x)
    val t2 = t * t
    val t3 = t2 * t
    val t4 = t3 * t
    val t5 = t4 * t

    val exp_val = nm_exp_approx(-abs_x * abs_x)
    val poly = a1 * t + a2 * t2 + a3 * t3 + a4 * t4 + a5 * t5

    sign * (1.0 - poly * exp_val)

export *
