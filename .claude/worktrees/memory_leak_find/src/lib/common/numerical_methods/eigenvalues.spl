# Eigenvalue Methods
#
# Purpose: Finding eigenvalues and eigenvectors of matrices
#
# Contains:
# - Power iteration (finds dominant eigenvalue)
# - Inverse power iteration (finds smallest eigenvalue)
# - Vector and matrix norms (L1, L2, infinity, Frobenius)

fn nm_power_iteration(a: [[f64]], max_iter: i64, tolerance: f64) -> f64:
    """Find dominant eigenvalue using power iteration.

    Returns largest eigenvalue in absolute value.
    Converges if dominant eigenvalue is unique.

    Example:
        nm_power_iteration([[2.0, 1.0], [1.0, 2.0]], 100, 1e-10)
    """
    val n = a.len()
    if n == 0:
        return 0.0

    # Local convergence check
    fn nm_is_converged_local(current: f64, previous: f64, tol: f64) -> bool:
        var diff = current - previous
        if diff < 0.0:
            diff = -diff
        diff < tol

    var v = []
    var i = 0
    while i < n:
        v.push(1.0)
        i = i + 1

    var lambda = 0.0
    var iterations = 0

    while iterations < max_iter:
        var av = []
        i = 0
        while i < n:
            var sum = 0.0
            var j = 0
            while j < n:
                sum = sum + a[i][j] * v[j]
                j = j + 1
            av.push(sum)
            i = i + 1

        var max_val = av[0]
        var abs_max_val = max_val
        if abs_max_val < 0.0:
            abs_max_val = -abs_max_val

        i = 1
        while i < n:
            var abs_val = av[i]
            if abs_val < 0.0:
                abs_val = -abs_val
            if abs_val > abs_max_val:
                max_val = av[i]
                abs_max_val = abs_val
            i = i + 1

        val lambda_new = max_val

        i = 0
        while i < n:
            v[i] = av[i] / max_val
            i = i + 1

        if iterations > 0 and nm_is_converged_local(lambda_new, lambda, tolerance):
            return lambda_new

        lambda = lambda_new
        iterations = iterations + 1

    lambda

fn nm_inverse_power_iteration(a: [[f64]], max_iter: i64, tolerance: f64) -> f64:
    """Find smallest eigenvalue using inverse power iteration.

    Returns smallest eigenvalue in absolute value.
    Requires solving linear system at each step.

    Example:
        nm_inverse_power_iteration([[3.0, 1.0], [1.0, 3.0]], 100, 1e-10)
    """
    val n = a.len()
    if n == 0:
        return 0.0

    # Import Gauss elimination locally (simplified version)
    fn gauss_elim_local(a_mat: [[f64]], b_vec: [f64]) -> [f64]:
        val n_local = a_mat.len()
        if n_local == 0 or b_vec.len() != n_local:
            return []

        val eps = 1e-14

        var aug = []
        var i_local = 0
        while i_local < n_local:
            var row = []
            var j_local = 0
            while j_local < n_local:
                row.push(a_mat[i_local][j_local])
                j_local = j_local + 1
            row.push(b_vec[i_local])
            aug.push(row)
            i_local = i_local + 1

        i_local = 0
        while i_local < n_local:
            var max_row = i_local
            var j_local = i_local + 1
            while j_local < n_local:
                var abs_max = aug[max_row][i_local]
                if abs_max < 0.0:
                    abs_max = -abs_max
                var abs_curr = aug[j_local][i_local]
                if abs_curr < 0.0:
                    abs_curr = -abs_curr
                if abs_curr > abs_max:
                    max_row = j_local
                j_local = j_local + 1

            if max_row != i_local:
                val temp_row = aug[i_local]
                aug[i_local] = aug[max_row]
                aug[max_row] = temp_row

            val pivot = aug[i_local][i_local]
            var abs_pivot = pivot
            if abs_pivot < 0.0:
                abs_pivot = -abs_pivot
            if abs_pivot < eps:
                return []

            j_local = i_local + 1
            while j_local < n_local:
                val factor = aug[j_local][i_local] / pivot
                var k_local = i_local
                while k_local <= n_local:
                    aug[j_local][k_local] = aug[j_local][k_local] - factor * aug[i_local][k_local]
                    k_local = k_local + 1
                j_local = j_local + 1

            i_local = i_local + 1

        var x_local = []
        i_local = 0
        while i_local < n_local:
            x_local.push(0.0)
            i_local = i_local + 1

        i_local = n_local - 1
        while i_local >= 0:
            var sum_local = aug[i_local][n_local]
            var j_local = i_local + 1
            while j_local < n_local:
                sum_local = sum_local - aug[i_local][j_local] * x_local[j_local]
                j_local = j_local + 1
            x_local[i_local] = sum_local / aug[i_local][i_local]
            i_local = i_local - 1

        x_local

    # Local convergence check
    fn nm_is_converged_local(current: f64, previous: f64, tol: f64) -> bool:
        var diff = current - previous
        if diff < 0.0:
            diff = -diff
        diff < tol

    var v = []
    var i = 0
    while i < n:
        v.push(1.0)
        i = i + 1

    var lambda = 0.0
    var iterations = 0

    while iterations < max_iter:
        val v_new = gauss_elim_local(a, v)
        if v_new.len() == 0:
            return lambda

        var max_val = v_new[0]
        var abs_max_val = max_val
        if abs_max_val < 0.0:
            abs_max_val = -abs_max_val

        i = 1
        while i < n:
            var abs_val = v_new[i]
            if abs_val < 0.0:
                abs_val = -abs_val
            if abs_val > abs_max_val:
                max_val = v_new[i]
                abs_max_val = abs_val
            i = i + 1

        i = 0
        while i < n:
            v[i] = v_new[i] / max_val
            i = i + 1

        val lambda_new = 1.0 / max_val

        if iterations > 0 and nm_is_converged_local(lambda_new, lambda, tolerance):
            return lambda_new

        lambda = lambda_new
        iterations = iterations + 1

    lambda

# ============================================================================
# Vector and Matrix Norms
# ============================================================================

fn nm_vector_norm_1(v: [f64]) -> f64:
    """Calculate L1 norm (Manhattan norm) of vector.

    ||v||₁ = Σ|vᵢ|

    Example:
        nm_vector_norm_1([3.0, -4.0])  # 7.0
    """
    var sum = 0.0
    var i = 0
    while i < v.len():
        var abs_val = v[i]
        if abs_val < 0.0:
            abs_val = -abs_val
        sum = sum + abs_val
        i = i + 1
    sum

fn nm_vector_norm_2(v: [f64]) -> f64:
    """Calculate L2 norm (Euclidean norm) of vector.

    ||v||₂ = √(Σvᵢ²)

    Example:
        nm_vector_norm_2([3.0, 4.0])  # 5.0
    """
    val NM_SQRT_EPSILON = 1e-7

    # Local sqrt function
    fn nm_sqrt_newton_local(x: f64, tol: f64) -> f64:
        if x < 0.0:
            return 0.0
        if x == 0.0:
            return 0.0

        var y = x / 2.0
        var iter = 0

        while iter < 100:
            val y_new = (y + x / y) / 2.0
            var diff = y_new - y
            if diff < 0.0:
                diff = -diff
            if diff < tol:
                return y_new
            y = y_new
            iter = iter + 1

        y

    var sum = 0.0
    var i = 0
    while i < v.len():
        sum = sum + v[i] * v[i]
        i = i + 1
    nm_sqrt_newton_local(sum, NM_SQRT_EPSILON)

fn nm_vector_norm_inf(v: [f64]) -> f64:
    """Calculate infinity norm (maximum norm) of vector.

    ||v||∞ = max|vᵢ|

    Example:
        nm_vector_norm_inf([3.0, -7.0, 2.0])  # 7.0
    """
    if v.len() == 0:
        return 0.0

    var max_val = v[0]
    if max_val < 0.0:
        max_val = -max_val

    var i = 1
    while i < v.len():
        var abs_val = v[i]
        if abs_val < 0.0:
            abs_val = -abs_val
        if abs_val > max_val:
            max_val = abs_val
        i = i + 1

    max_val

fn nm_matrix_norm_frobenius(a: [[f64]]) -> f64:
    """Calculate Frobenius norm of matrix.

    ||A||_F = √(ΣΣaᵢⱼ²)

    Example:
        nm_matrix_norm_frobenius([[1.0, 2.0], [3.0, 4.0]])
    """
    val NM_SQRT_EPSILON = 1e-7

    # Local sqrt function
    fn nm_sqrt_newton_local(x: f64, tol: f64) -> f64:
        if x < 0.0:
            return 0.0
        if x == 0.0:
            return 0.0

        var y = x / 2.0
        var iter = 0

        while iter < 100:
            val y_new = (y + x / y) / 2.0
            var diff = y_new - y
            if diff < 0.0:
                diff = -diff
            if diff < tol:
                return y_new
            y = y_new
            iter = iter + 1

        y

    var sum = 0.0
    var i = 0
    while i < a.len():
        var j = 0
        while j < a[i].len():
            sum = sum + a[i][j] * a[i][j]
            j = j + 1
        i = i + 1
    nm_sqrt_newton_local(sum, NM_SQRT_EPSILON)

fn nm_matrix_norm_1(a: [[f64]]) -> f64:
    """Calculate 1-norm of matrix (max column sum).

    ||A||₁ = max_j Σᵢ|aᵢⱼ|

    Example:
        nm_matrix_norm_1([[1.0, 2.0], [3.0, 4.0]])  # 6.0
    """
    if a.len() == 0:
        return 0.0

    val n_cols = a[0].len()
    var max_sum = 0.0

    var j = 0
    while j < n_cols:
        var col_sum = 0.0
        var i = 0
        while i < a.len():
            var abs_val = a[i][j]
            if abs_val < 0.0:
                abs_val = -abs_val
            col_sum = col_sum + abs_val
            i = i + 1
        if col_sum > max_sum:
            max_sum = col_sum
        j = j + 1

    max_sum

fn nm_matrix_norm_inf(a: [[f64]]) -> f64:
    """Calculate infinity norm of matrix (max row sum).

    ||A||∞ = max_i Σⱼ|aᵢⱼ|

    Example:
        nm_matrix_norm_inf([[1.0, 2.0], [3.0, 4.0]])  # 7.0
    """
    var max_sum = 0.0
    var i = 0

    while i < a.len():
        var row_sum = 0.0
        var j = 0
        while j < a[i].len():
            var abs_val = a[i][j]
            if abs_val < 0.0:
                abs_val = -abs_val
            row_sum = row_sum + abs_val
            j = j + 1
        if row_sum > max_sum:
            max_sum = row_sum
        i = i + 1

    max_sum

export *
