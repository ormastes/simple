# Numerical Differentiation
#
# Purpose: Numerical approximation of derivatives and differential operators
#
# Contains:
# - Forward/backward/central differences
# - Second derivatives
# - Richardson extrapolation
# - Partial derivatives
# - Five-point stencil (high accuracy)
# - Gradient vectors
# - Hessian matrices
# - Laplacian operator

fn nm_forward_difference(f, x: f64, h: f64) -> f64:
    """Calculate derivative using forward difference.

    f'(x) ≈ (f(x+h) - f(x)) / h
    Error is O(h).

    Example:
        nm_forward_difference(lambda x: x*x, 2.0, 0.001)  # ≈ 4
    """
    (f(x + h) - f(x)) / h

fn nm_backward_difference(f, x: f64, h: f64) -> f64:
    """Calculate derivative using backward difference.

    f'(x) ≈ (f(x) - f(x-h)) / h
    Error is O(h).

    Example:
        nm_backward_difference(lambda x: x*x, 2.0, 0.001)
    """
    (f(x) - f(x - h)) / h

fn nm_central_difference(f, x: f64, h: f64) -> f64:
    """Calculate derivative using central difference.

    f'(x) ≈ (f(x+h) - f(x-h)) / (2h)
    Error is O(h^2), more accurate than forward/backward.

    Example:
        nm_central_difference(lambda x: x*x, 2.0, 0.001)
    """
    (f(x + h) - f(x - h)) / (2.0 * h)

fn nm_second_derivative(f, x: f64, h: f64) -> f64:
    """Calculate second derivative using central difference.

    f''(x) ≈ (f(x+h) - 2f(x) + f(x-h)) / h^2

    Example:
        nm_second_derivative(lambda x: x*x, 2.0, 0.001)  # ≈ 2
    """
    (f(x + h) - 2.0 * f(x) + f(x - h)) / (h * h)

fn nm_richardson_extrapolation(f, x: f64, h: f64) -> f64:
    """Calculate derivative using Richardson extrapolation.

    Combines two central difference estimates for higher accuracy.
    Error is O(h^4).

    Example:
        nm_richardson_extrapolation(lambda x: x*x, 2.0, 0.01)
    """
    val d1 = nm_central_difference(f, x, h)
    val d2 = nm_central_difference(f, x, h / 2.0)

    (4.0 * d2 - d1) / 3.0

fn nm_partial_derivative_x(f, x: f64, y: f64, h: f64) -> f64:
    """Calculate partial derivative with respect to x.

    ∂f/∂x ≈ (f(x+h, y) - f(x-h, y)) / (2h)

    Example:
        nm_partial_derivative_x(lambda x, y: x*x + y*y, 1.0, 2.0, 0.001)
    """
    (f(x + h, y) - f(x - h, y)) / (2.0 * h)

fn nm_partial_derivative_y(f, x: f64, y: f64, h: f64) -> f64:
    """Calculate partial derivative with respect to y.

    ∂f/∂y ≈ (f(x, y+h) - f(x, y-h)) / (2h)

    Example:
        nm_partial_derivative_y(lambda x, y: x*x + y*y, 1.0, 2.0, 0.001)
    """
    (f(x, y + h) - f(x, y - h)) / (2.0 * h)

fn nm_five_point_stencil(f, x: f64, h: f64) -> f64:
    """Calculate derivative using five-point stencil.

    f'(x) ≈ (-f(x+2h) + 8f(x+h) - 8f(x-h) + f(x-2h)) / (12h)
    Error is O(h^4), very accurate.

    Example:
        nm_five_point_stencil(lambda x: x*x*x, 2.0, 0.001)  # ≈ 12
    """
    val f_plus2 = f(x + 2.0 * h)
    val f_plus1 = f(x + h)
    val f_minus1 = f(x - h)
    val f_minus2 = f(x - 2.0 * h)

    (-f_plus2 + 8.0 * f_plus1 - 8.0 * f_minus1 + f_minus2) / (12.0 * h)

fn nm_gradient_2d(f, x: f64, y: f64, h: f64) -> [f64]:
    """Calculate gradient vector in 2D.

    Returns [∂f/∂x, ∂f/∂y].

    Example:
        nm_gradient_2d(lambda x, y: x*x + y*y, 1.0, 2.0, 0.001)  # [2.0, 4.0]
    """
    val df_dx = nm_partial_derivative_x(f, x, y, h)
    val df_dy = nm_partial_derivative_y(f, x, y, h)
    [df_dx, df_dy]

fn nm_hessian_2d(f, x: f64, y: f64, h: f64) -> [[f64]]:
    """Calculate Hessian matrix in 2D.

    Returns [[∂²f/∂x², ∂²f/∂x∂y], [∂²f/∂y∂x, ∂²f/∂y²]].

    Example:
        nm_hessian_2d(lambda x, y: x*x + y*y, 1.0, 2.0, 0.01)
    """
    val fxx = (f(x + h, y) - 2.0 * f(x, y) + f(x - h, y)) / (h * h)
    val fyy = (f(x, y + h) - 2.0 * f(x, y) + f(x, y - h)) / (h * h)
    val fxy = (f(x + h, y + h) - f(x + h, y - h) - f(x - h, y + h) + f(x - h, y - h)) / (4.0 * h * h)

    [[fxx, fxy], [fxy, fyy]]

fn nm_laplacian_2d(f, x: f64, y: f64, h: f64) -> f64:
    """Calculate Laplacian (∇²f = ∂²f/∂x² + ∂²f/∂y²).

    Example:
        nm_laplacian_2d(lambda x, y: x*x + y*y, 1.0, 2.0, 0.01)  # ≈ 4.0
    """
    val fxx = (f(x + h, y) - 2.0 * f(x, y) + f(x - h, y)) / (h * h)
    val fyy = (f(x, y + h) - 2.0 * f(x, y) + f(x, y - h)) / (h * h)
    fxx + fyy

export *
