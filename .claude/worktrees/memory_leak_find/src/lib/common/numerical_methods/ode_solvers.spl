# ODE Solvers
#
# Purpose: Numerical methods for solving ordinary differential equations
#
# Contains:
# - Euler's method (explicit, first-order)
# - Runge-Kutta methods (RK2 midpoint, RK2 Heun, RK4 classic)
# - Adams-Bashforth multi-step methods (2-step, 4-step)
# - Backward Euler (implicit, stable)
# - Trapezoidal method (implicit, second-order)

fn nm_euler_method(f, y0: f64, t0: f64, t_end: f64, h: f64) -> [f64]:
    """Solve ODE using Euler's method.

    Solves dy/dt = f(t, y) with initial condition y(t0) = y0.
    First-order method, error is O(h).

    Example:
        nm_euler_method(lambda t, y: y, 1.0, 0.0, 1.0, 0.1)  # Solves y' = y
    """
    var results = []
    var t = t0
    var y = y0

    while t <= t_end:
        results.push(y)
        val dy = f(t, y)
        y = y + h * dy
        t = t + h

    results

fn nm_rk2_midpoint(f, y0: f64, t0: f64, t_end: f64, h: f64) -> [f64]:
    """Solve ODE using Runge-Kutta 2nd order (midpoint) method.

    Second-order method, error is O(h^2).
    More accurate than Euler.

    Example:
        nm_rk2_midpoint(lambda t, y: y, 1.0, 0.0, 1.0, 0.1)
    """
    var results = []
    var t = t0
    var y = y0

    while t <= t_end:
        results.push(y)
        val k1 = f(t, y)
        val k2 = f(t + h / 2.0, y + h * k1 / 2.0)
        y = y + h * k2
        t = t + h

    results

fn nm_rk2_heun(f, y0: f64, t0: f64, t_end: f64, h: f64) -> [f64]:
    """Solve ODE using Runge-Kutta 2nd order (Heun's) method.

    Also known as improved Euler method.
    Second-order method, error is O(h^2).

    Example:
        nm_rk2_heun(lambda t, y: -y, 1.0, 0.0, 1.0, 0.1)
    """
    var results = []
    var t = t0
    var y = y0

    while t <= t_end:
        results.push(y)
        val k1 = f(t, y)
        val k2 = f(t + h, y + h * k1)
        y = y + h * (k1 + k2) / 2.0
        t = t + h

    results

fn nm_rk4_classic(f, y0: f64, t0: f64, t_end: f64, h: f64) -> [f64]:
    """Solve ODE using classic Runge-Kutta 4th order method.

    The workhorse ODE solver. Fourth-order method, error is O(h^4).
    Excellent balance of accuracy and efficiency.

    Example:
        nm_rk4_classic(lambda t, y: -y, 1.0, 0.0, 1.0, 0.1)
    """
    var results = []
    var t = t0
    var y = y0

    while t <= t_end:
        results.push(y)
        val k1 = f(t, y)
        val k2 = f(t + h / 2.0, y + h * k1 / 2.0)
        val k3 = f(t + h / 2.0, y + h * k2 / 2.0)
        val k4 = f(t + h, y + h * k3)
        y = y + h * (k1 + 2.0 * k2 + 2.0 * k3 + k4) / 6.0
        t = t + h

    results

fn nm_adams_bashforth_2(f, y0: f64, y1: f64, t0: f64, t_end: f64, h: f64) -> [f64]:
    """Solve ODE using Adams-Bashforth 2-step method.

    Multi-step method requiring two initial values.
    Second-order explicit method.

    Example:
        nm_adams_bashforth_2(lambda t, y: y, 1.0, 1.1, 0.0, 1.0, 0.1)
    """
    var results = []
    var t = t0 + h
    var y_prev = y0
    var y_curr = y1

    results.push(y0)
    results.push(y1)

    while t <= t_end:
        val f_prev = f(t - h, y_prev)
        val f_curr = f(t, y_curr)
        val y_next = y_curr + h * (3.0 * f_curr - f_prev) / 2.0
        results.push(y_next)
        y_prev = y_curr
        y_curr = y_next
        t = t + h

    results

fn nm_adams_bashforth_4(f, ys: [f64], t0: f64, t_end: f64, h: f64) -> [f64]:
    """Solve ODE using Adams-Bashforth 4-step method.

    Multi-step method requiring four initial values.
    Fourth-order explicit method, very efficient.

    Example:
        nm_adams_bashforth_4(lambda t, y: y, [1.0, 1.1, 1.21, 1.331], 0.0, 1.0, 0.1)
    """
    if ys.len() < 4:
        return ys

    var results = []
    var i = 0
    while i < 4:
        results.push(ys[i])
        i = i + 1

    var t = t0 + 3.0 * h

    while t <= t_end:
        val n = results.len()
        val f0 = f(t - 3.0 * h, results[n - 4])
        val f1 = f(t - 2.0 * h, results[n - 3])
        val f2 = f(t - h, results[n - 2])
        val f3 = f(t, results[n - 1])

        val y_next = results[n - 1] + h * (55.0 * f3 - 59.0 * f2 + 37.0 * f1 - 9.0 * f0) / 24.0
        results.push(y_next)
        t = t + h

    results

fn nm_backward_euler(f, y0: f64, t0: f64, t_end: f64, h: f64, newton_iter: i64) -> [f64]:
    """Solve ODE using backward Euler (implicit) method.

    More stable than forward Euler, especially for stiff equations.
    Requires solving nonlinear equation at each step.

    Example:
        nm_backward_euler(lambda t, y: -10*y, 1.0, 0.0, 1.0, 0.1, 5)
    """
    var results = []
    var t = t0
    var y = y0
    val NM_SQRT_EPSILON = 1e-7

    while t <= t_end:
        results.push(y)

        var y_next = y
        var iter = 0
        while iter < newton_iter:
            val g = y_next - y - h * f(t + h, y_next)
            val dg = 1.0 - h * (f(t + h, y_next + NM_SQRT_EPSILON) - f(t + h, y_next)) / NM_SQRT_EPSILON
            if dg == 0.0:
                break
            y_next = y_next - g / dg
            iter = iter + 1

        y = y_next
        t = t + h

    results

fn nm_trapezoidal_ode(f, y0: f64, t0: f64, t_end: f64, h: f64, newton_iter: i64) -> [f64]:
    """Solve ODE using trapezoidal (implicit) method.

    Second-order implicit method, very stable.
    y_{n+1} = y_n + h/2 * (f(t_n, y_n) + f(t_{n+1}, y_{n+1}))

    Example:
        nm_trapezoidal_ode(lambda t, y: -y, 1.0, 0.0, 1.0, 0.1, 5)
    """
    var results = []
    var t = t0
    var y = y0
    val NM_SQRT_EPSILON = 1e-7

    while t <= t_end:
        results.push(y)

        val f_curr = f(t, y)
        var y_next = y + h * f_curr

        var iter = 0
        while iter < newton_iter:
            val f_next = f(t + h, y_next)
            val g = y_next - y - h * (f_curr + f_next) / 2.0

            val f_next_pert = f(t + h, y_next + NM_SQRT_EPSILON)
            val dg = 1.0 - h * (f_next_pert - f_next) / (2.0 * NM_SQRT_EPSILON)

            if dg == 0.0:
                break
            y_next = y_next - g / dg
            iter = iter + 1

        y = y_next
        t = t + h

    results

export *
