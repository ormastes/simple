# Root Finding Methods
#
# Purpose: Finding zeros of functions using various numerical methods
#
# Contains:
# - Bisection method (guaranteed convergence, linear)
# - Newton-Raphson method (quadratic convergence)
# - Secant method (superlinear, no derivative needed)
# - Brent's method (combines bisection/secant/IQI)
# - Fixed-point iteration
# - Muller's method (quadratic interpolation)

fn nm_bisection(f, a: f64, b: f64, tolerance: f64, max_iter: i64) -> f64:
    """Find root using bisection method.

    Requires f(a) and f(b) to have opposite signs.
    Guaranteed to converge but slow (linear convergence).

    Example:
        nm_bisection(lambda x: x*x - 2, 0.0, 2.0, 1e-10, 100)  # sqrt(2)
    """
    var left = a
    var right = b
    var iterations = 0

    while iterations < max_iter:
        val mid = (left + right) / 2.0
        val f_mid = f(mid)

        var abs_f_mid = f_mid
        if abs_f_mid < 0.0:
            abs_f_mid = -abs_f_mid

        if abs_f_mid < tolerance:
            return mid

        val f_left = f(left)
        if (f_left < 0.0 and f_mid > 0.0) or (f_left > 0.0 and f_mid < 0.0):
            right = mid
        else:
            left = mid

        iterations = iterations + 1

    (left + right) / 2.0

fn nm_newton_raphson(f, df, x0: f64, tolerance: f64, max_iter: i64) -> f64:
    """Find root using Newton-Raphson method.

    Requires function f and its derivative df.
    Fast convergence (quadratic) near root but requires good initial guess.

    Example:
        nm_newton_raphson(lambda x: x*x - 2, lambda x: 2*x, 1.0, 1e-10, 100)
    """
    var x = x0
    var iterations = 0

    while iterations < max_iter:
        val fx = f(x)

        var abs_fx = fx
        if abs_fx < 0.0:
            abs_fx = -abs_fx

        if abs_fx < tolerance:
            return x

        val dfx = df(x)
        if dfx == 0.0:
            return x

        val x_new = x - fx / dfx

        # Import from error_analysis
        val NM_EPSILON = 1e-14
        fn nm_is_converged_local(current: f64, previous: f64, tol: f64) -> bool:
            var diff = current - previous
            if diff < 0.0:
                diff = -diff
            diff < tol

        if nm_is_converged_local(x_new, x, tolerance):
            return x_new

        x = x_new
        iterations = iterations + 1

    x

fn nm_secant(f, x0: f64, x1: f64, tolerance: f64, max_iter: i64) -> f64:
    """Find root using secant method.

    Similar to Newton-Raphson but uses finite difference instead of derivative.
    Superlinear convergence, doesn't require derivative.

    Example:
        nm_secant(lambda x: x*x - 2, 1.0, 2.0, 1e-10, 100)
    """
    var x_prev = x0
    var x_curr = x1
    var iterations = 0

    # Local convergence check
    fn nm_is_converged_local(current: f64, previous: f64, tol: f64) -> bool:
        var diff = current - previous
        if diff < 0.0:
            diff = -diff
        diff < tol

    while iterations < max_iter:
        val f_prev = f(x_prev)
        val f_curr = f(x_curr)

        var abs_f_curr = f_curr
        if abs_f_curr < 0.0:
            abs_f_curr = -abs_f_curr

        if abs_f_curr < tolerance:
            return x_curr

        val denominator = f_curr - f_prev
        if denominator == 0.0:
            return x_curr

        val x_new = x_curr - f_curr * (x_curr - x_prev) / denominator

        if nm_is_converged_local(x_new, x_curr, tolerance):
            return x_new

        x_prev = x_curr
        x_curr = x_new
        iterations = iterations + 1

    x_curr

fn nm_brent(f, a: f64, b: f64, tolerance: f64, max_iter: i64) -> f64:
    """Find root using Brent's method.

    Combines bisection, secant, and inverse quadratic interpolation.
    Guaranteed convergence of bisection with speed of secant.

    Example:
        nm_brent(lambda x: x*x - 2, 0.0, 2.0, 1e-10, 100)
    """
    var x_a = a
    var x_b = b
    var x_c = a
    var d = 0.0

    var f_a = f(x_a)
    var f_b = f(x_b)
    var f_c = f_a

    var iterations = 0
    val NM_EPSILON = 1e-14

    while iterations < max_iter:
        var abs_f_b = f_b
        if abs_f_b < 0.0:
            abs_f_b = -abs_f_b

        if abs_f_b < tolerance:
            return x_b

        if (f_a < 0.0 and f_b < 0.0) or (f_a > 0.0 and f_b > 0.0):
            x_c = x_a
            f_c = f_a
            d = x_b - x_a

        var abs_f_c = f_c
        if abs_f_c < 0.0:
            abs_f_c = -abs_f_c

        var abs_f_a = f_a
        if abs_f_a < 0.0:
            abs_f_a = -abs_f_a

        if abs_f_c < abs_f_b:
            x_a = x_b
            x_b = x_c
            x_c = x_a
            f_a = f_b
            f_b = f_c
            f_c = f_a

        val tol = 2.0 * NM_EPSILON * x_b + tolerance
        var abs_diff = x_b - x_c
        if abs_diff < 0.0:
            abs_diff = -abs_diff

        val m = (x_c - x_b) / 2.0

        var abs_m = m
        if abs_m < 0.0:
            abs_m = -abs_m

        if abs_m < tol or f_b == 0.0:
            return x_b

        x_a = x_b
        f_a = f_b

        x_b = x_b + m
        f_b = f(x_b)

        iterations = iterations + 1

    x_b

fn nm_fixed_point_iteration(g, x0: f64, tolerance: f64, max_iter: i64) -> f64:
    """Find fixed point using fixed-point iteration.

    Finds x such that g(x) = x.
    Converges if |g'(x)| < 1 near the fixed point.

    Example:
        nm_fixed_point_iteration(lambda x: (x + 2.0/x) / 2.0, 1.0, 1e-10, 100)
    """
    var x = x0
    var iterations = 0

    # Local convergence check
    fn nm_is_converged_local(current: f64, previous: f64, tol: f64) -> bool:
        var diff = current - previous
        if diff < 0.0:
            diff = -diff
        diff < tol

    while iterations < max_iter:
        val x_new = g(x)

        if nm_is_converged_local(x_new, x, tolerance):
            return x_new

        x = x_new
        iterations = iterations + 1

    x

fn nm_muller_method(f, x0: f64, x1: f64, x2: f64, tolerance: f64, max_iter: i64) -> f64:
    """Find root using Muller's method.

    Uses quadratic interpolation through three points.
    Can find complex roots (returns real part if converged).

    Example:
        nm_muller_method(lambda x: x*x - 2, 0.0, 1.0, 2.0, 1e-10, 100)
    """
    var x_0 = x0
    var x_1 = x1
    var x_2 = x2

    var iterations = 0
    val NM_EPSILON = 1e-14
    val NM_SQRT_EPSILON = 1e-7

    # Local sqrt function
    fn nm_sqrt_newton_local(x: f64, tol: f64) -> f64:
        if x < 0.0:
            return 0.0
        if x == 0.0:
            return 0.0

        var y = x / 2.0
        var iter = 0

        while iter < 100:
            val y_new = (y + x / y) / 2.0
            var diff = y_new - y
            if diff < 0.0:
                diff = -diff
            if diff < tol:
                return y_new
            y = y_new
            iter = iter + 1

        y

    # Local convergence check
    fn nm_is_converged_local(current: f64, previous: f64, tol: f64) -> bool:
        var diff = current - previous
        if diff < 0.0:
            diff = -diff
        diff < tol

    while iterations < max_iter:
        val f0 = f(x_0)
        val f1 = f(x_1)
        val f2 = f(x_2)

        var abs_f2 = f2
        if abs_f2 < 0.0:
            abs_f2 = -abs_f2

        if abs_f2 < tolerance:
            return x_2

        val h0 = x_1 - x_0
        val h1 = x_2 - x_1
        val delta0 = (f1 - f0) / h0
        val delta1 = (f2 - f1) / h1

        val a = (delta1 - delta0) / (h1 + h0)
        val b = a * h1 + delta1
        val c = f2

        val disc = b * b - 4.0 * a * c

        if disc < 0.0:
            return x_2

        val sqrt_disc = nm_sqrt_newton_local(disc, NM_SQRT_EPSILON)

        val denom1 = b + sqrt_disc
        val denom2 = b - sqrt_disc

        var abs_d1 = denom1
        if abs_d1 < 0.0:
            abs_d1 = -abs_d1
        var abs_d2 = denom2
        if abs_d2 < 0.0:
            abs_d2 = -abs_d2

        val denominator = if abs_d1 > abs_d2: denom1 else: denom2

        if denominator == 0.0:
            return x_2

        val x_3 = x_2 - 2.0 * c / denominator

        if nm_is_converged_local(x_3, x_2, tolerance):
            return x_3

        x_0 = x_1
        x_1 = x_2
        x_2 = x_3

        iterations = iterations + 1

    x_2

export *
