# Bitwise Operation Utilities
#
# Helper functions for bitwise operations and bit manipulation.
# Pure Simple implementation - no external dependencies.
#
# Assumes i64 values (64-bit signed integers).
# All operations preserve signed integer semantics.
#
# Functions:
# - Bit testing: test_bit, set_bit, clear_bit, toggle_bit
# - Bit counting: count_ones, count_zeros, leading_zeros, trailing_zeros
# - Bit manipulation: reverse_bits, rotate_left, rotate_right
# - Masks and patterns: create_mask, extract_bits, insert_bits
# - Bitwise predicates: is_power_of_two, is_bit_set
# - Bitwise utilities: lowest_set_bit, highest_set_bit

# ============================================================================
# Bit Testing
# ============================================================================

fn test_bit(n: i64, bit: i64) -> bool:
    """Test if bit at position is set.

    Position 0 is LSB (least significant bit).

    Example:
        test_bit(0b1010, 1)  # true (2nd bit is 1)
        test_bit(0b1010, 0)  # false (1st bit is 0)
    """
    if bit < 0 or bit >= 64:
        return false
    ((n >> bit) & 1) == 1

fn is_bit_set(n: i64, bit: i64) -> bool:
    """Check if bit at position is set (alias for test_bit).

    Example:
        is_bit_set(0b1010, 3)  # true
    """
    test_bit(n, bit)

# ============================================================================
# Bit Manipulation
# ============================================================================

fn set_bit(n: i64, bit: i64) -> i64:
    """Set bit at position to 1.

    Example:
        set_bit(0b1000, 0)  # 0b1001
        set_bit(0b1010, 2)  # 0b1110
    """
    if bit < 0 or bit >= 64:
        return n
    n | (1 << bit)

fn clear_bit(n: i64, bit: i64) -> i64:
    """Clear bit at position (set to 0).

    Example:
        clear_bit(0b1010, 1)  # 0b1000
        clear_bit(0b1111, 2)  # 0b1011
    """
    if bit < 0 or bit >= 64:
        return n
    n & ~(1 << bit)

fn toggle_bit(n: i64, bit: i64) -> i64:
    """Toggle bit at position (flip 0<->1).

    Example:
        toggle_bit(0b1010, 0)  # 0b1011
        toggle_bit(0b1010, 1)  # 0b1000
    """
    if bit < 0 or bit >= 64:
        return n
    n ^ (1 << bit)

# ============================================================================
# Bit Counting
# ============================================================================

fn count_ones(n: i64) -> i64:
    """Count number of 1 bits (population count).

    Uses Brian Kernighan's algorithm.

    Example:
        count_ones(0b1010)  # 2
        count_ones(0b1111)  # 4
    """
    var count = 0
    var value = n

    # Handle negative numbers by treating as unsigned
    if value < 0:
        # For negative numbers, we need to count in unsigned representation
        # Convert to positive by adding 2^64 (conceptually)
        value = value & 0x7FFFFFFFFFFFFFFF  # Clear sign bit
        count = count + 1  # Sign bit was 1

    while value != 0:
        value = value & (value - 1)
        count = count + 1

    count

fn count_zeros(n: i64) -> i64:
    """Count number of 0 bits.

    Example:
        count_zeros(0b1010)  # 62 (in 64-bit)
    """
    64 - count_ones(n)

fn leading_zeros(n: i64) -> i64:
    """Count leading zero bits from MSB.

    Example:
        leading_zeros(0b0001)  # 60 (for 64-bit)
        leading_zeros(0b1000)  # 60
    """
    if n == 0:
        return 64

    var count = 0
    var value = n

    # Handle negative numbers
    if value < 0:
        return 0

    # Find highest set bit
    var bit = 63
    while bit >= 0:
        if (value >> bit) & 1 == 1:
            return 63 - bit
        bit = bit - 1

    64

fn trailing_zeros(n: i64) -> i64:
    """Count trailing zero bits from LSB.

    Example:
        trailing_zeros(0b1000)  # 3
        trailing_zeros(0b1100)  # 2
    """
    if n == 0:
        return 64

    var count = 0
    var value = n

    while (value & 1) == 0:
        count = count + 1
        value = value >> 1

    count

# ============================================================================
# Bit Pattern Operations
# ============================================================================

fn reverse_bits(n: i64) -> i64:
    """Reverse bit order.

    Example:
        reverse_bits(0b1010)  # 0b0101000...
    """
    var result = 0
    var value = n
    var i = 0

    while i < 64:
        result = (result << 1) | (value & 1)
        value = value >> 1
        i = i + 1

    result

fn rotate_left(n: i64, shift: i64) -> i64:
    """Rotate bits left (circular shift).

    Example:
        rotate_left(0b11000, 2)  # 0b00011...
    """
    val s = shift % 64
    if s == 0:
        return n
    (n << s) | ((n >> (64 - s)) & ((1 << s) - 1))

fn rotate_right(n: i64, shift: i64) -> i64:
    """Rotate bits right (circular shift).

    Example:
        rotate_right(0b00011, 2)  # 0b11000...
    """
    val s = shift % 64
    if s == 0:
        return n
    ((n >> s) | (n << (64 - s))) & 0x7FFFFFFFFFFFFFFF

# ============================================================================
# Bit Masks
# ============================================================================

fn create_mask(width: i64, position: i64) -> i64:
    """Create bit mask of given width at position.

    Example:
        create_mask(3, 2)  # 0b11100 (3 bits starting at position 2)
    """
    if width <= 0 or width > 64 or position < 0 or position >= 64:
        return 0

    var mask = 0
    var i = 0
    while i < width and (position + i) < 64:
        mask = mask | (1 << (position + i))
        i = i + 1

    mask

fn extract_bits(n: i64, start: i64, width: i64) -> i64:
    """Extract bits from position for width.

    Example:
        extract_bits(0b11010110, 2, 3)  # 0b101
    """
    if width <= 0 or start < 0 or start >= 64:
        return 0

    val mask = create_mask(width, 0)
    (n >> start) & mask

fn insert_bits(target: i64, value: i64, start: i64, width: i64) -> i64:
    """Insert bits into target at position.

    Example:
        insert_bits(0b11110000, 0b101, 2, 3)  # 0b11110100
    """
    if width <= 0 or start < 0 or start >= 64:
        return target

    val mask = create_mask(width, start)
    val cleared = target & ~mask
    val shifted = (value << start) & mask
    cleared | shifted

# ============================================================================
# Bitwise Predicates
# ============================================================================

fn is_power_of_two_bits(n: i64) -> bool:
    """Check if number is power of 2 using bitwise operation.

    Example:
        is_power_of_two_bits(8)  # true
        is_power_of_two_bits(7)  # false
    """
    n > 0 and (n & (n - 1)) == 0

fn has_single_bit(n: i64) -> bool:
    """Check if number has exactly one bit set.

    Example:
        has_single_bit(8)  # true
        has_single_bit(9)  # false
    """
    count_ones(n) == 1

# ============================================================================
# Bit Position Finding
# ============================================================================

fn lowest_set_bit(n: i64) -> i64:
    """Find position of lowest set bit.

    Returns -1 if no bits are set.

    Example:
        lowest_set_bit(0b1010)  # 1
        lowest_set_bit(0b1000)  # 3
    """
    if n == 0:
        return -1

    var position = 0
    var value = n

    while (value & 1) == 0:
        value = value >> 1
        position = position + 1

    position

fn highest_set_bit(n: i64) -> i64:
    """Find position of highest set bit.

    Returns -1 if no bits are set.

    Example:
        highest_set_bit(0b1010)  # 3
        highest_set_bit(0b0001)  # 0
    """
    if n == 0:
        return -1

    if n < 0:
        return 63

    var position = 0
    var value = n

    while value > 0:
        value = value >> 1
        position = position + 1

    position - 1

# ============================================================================
# Bit Parity
# ============================================================================

fn parity(n: i64) -> i64:
    """Calculate parity (XOR of all bits).

    Returns 0 for even parity, 1 for odd parity.

    Example:
        parity(0b1010)  # 0 (even: 2 bits set)
        parity(0b1011)  # 1 (odd: 3 bits set)
    """
    count_ones(n) % 2

fn has_even_parity(n: i64) -> bool:
    """Check if number has even parity.

    Example:
        has_even_parity(0b1010)  # true
        has_even_parity(0b1011)  # false
    """
    parity(n) == 0

fn has_odd_parity(n: i64) -> bool:
    """Check if number has odd parity.

    Example:
        has_odd_parity(0b111)  # true
    """
    parity(n) == 1

# ============================================================================
# Bitwise Utilities
# ============================================================================

fn isolate_lowest_set_bit(n: i64) -> i64:
    """Isolate the lowest set bit, clear all others.

    Example:
        isolate_lowest_set_bit(0b1010)  # 0b0010
        isolate_lowest_set_bit(0b1100)  # 0b0100
    """
    n & (-n)

fn clear_lowest_set_bit(n: i64) -> i64:
    """Clear the lowest set bit.

    Example:
        clear_lowest_set_bit(0b1010)  # 0b1000
        clear_lowest_set_bit(0b1111)  # 0b1110
    """
    n & (n - 1)

fn is_subset_bits(subset: i64, set: i64) -> bool:
    """Check if all bits in subset are also set in set.

    Example:
        is_subset_bits(0b0101, 0b1111)  # true
        is_subset_bits(0b1000, 0b0111)  # false
    """
    (subset & set) == subset

fn next_power_of_two(n: i64) -> i64:
    """Find next power of 2 greater than or equal to n.

    Example:
        next_power_of_two(5)  # 8
        next_power_of_two(8)  # 8
    """
    if n <= 0:
        return 1

    if is_power_of_two_bits(n):
        return n

    var power = 1
    while power < n:
        power = power << 1

    power

fn prev_power_of_two(n: i64) -> i64:
    """Find previous power of 2 less than or equal to n.

    Example:
        prev_power_of_two(9)  # 8
        prev_power_of_two(8)  # 8
    """
    if n <= 0:
        return 0

    if is_power_of_two_bits(n):
        return n

    var power = 1
    while (power << 1) <= n:
        power = power << 1

    power

# ============================================================================
# Byte Operations
# ============================================================================

fn get_byte(n: i64, byte_index: i64) -> i64:
    """Extract byte at index (0 = LSB).

    Example:
        get_byte(0x12345678, 1)  # 0x56
    """
    if byte_index < 0 or byte_index >= 8:
        return 0
    (n >> (byte_index * 8)) & 0xFF

fn set_byte(n: i64, byte_index: i64, value: i64) -> i64:
    """Set byte at index.

    Example:
        set_byte(0x12345678, 1, 0xFF)  # 0x1234FF78
    """
    if byte_index < 0 or byte_index >= 8:
        return n

    val shift = byte_index * 8
    val mask = 0xFF << shift
    val cleared = n & ~mask
    val byte_val = (value & 0xFF) << shift

    cleared | byte_val

fn swap_bytes(n: i64) -> i64:
    """Swap byte order (endianness conversion).

    Example:
        swap_bytes(0x12345678)  # 0x78563412 (partial, 64-bit)
    """
    var result = 0
    var i = 0

    while i < 8:
        val byte = get_byte(n, i)
        result = result | (byte << ((7 - i) * 8))
        i = i + 1

    result

# ============================================================================
# Bit String Conversion
# ============================================================================

fn to_bit_string(n: i64, width: i64) -> text:
    """Convert number to binary string representation.

    Example:
        to_bit_string(10, 8)  # "00001010"
        to_bit_string(5, 4)   # "0101"
    """
    var result = ""
    var i = width - 1

    while i >= 0:
        if test_bit(n, i):
            result = result + "1"
        else:
            result = result + "0"
        i = i - 1

    result
