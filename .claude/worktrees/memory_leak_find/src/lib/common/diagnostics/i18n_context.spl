# I18n Context Builders for Diagnostics
#
# Provides helpers for creating message contexts for internationalized diagnostics.
#
# The i18n system works by:
# 1. Creating a MessageContext with key-value pairs (via ctx1, ctx2, ctx3, or ContextBuilder)
# 2. Looking up a message by domain (e.g., "parser", "compiler") and ID (e.g., "E0001")
# 3. Interpolating the message template with the context values
#
# Example:
#     val ctx = ctx2("expected", "identifier", "found", "number")
#     val diag = error_i18n("parser", "E0002", ctx)
#     # Creates: "expected identifier, found number" (English)
#     #      or: "식별자가 필요하지만 숫자가 발견되었습니다" (Korean)

use compiler.diagnostics.{Diagnostic, Severity}

# FFI declarations for i18n functions
extern fn rt_i18n_context_new() -> i64
extern fn rt_i18n_context_insert(handle: i64, key: text, value: text)
extern fn rt_i18n_context_free(handle: i64)
extern fn rt_i18n_get_message(domain: text, id: text, ctx_handle: i64) -> text
extern fn rt_i18n_severity_name(severity: text) -> text

# MessageContext - opaque handle to Rust MessageContext
# This is an FFI type that wraps the Rust simple_i18n::MessageContext
struct MessageContext:
    handle: i64  # Opaque pointer to Rust MessageContext

impl MessageContext:
    # Create a new empty message context
    static fn new() -> MessageContext:
        val handle = rt_i18n_context_new()
        MessageContext(handle: handle)

    # Insert a key-value pair into the context
    me insert(key: text, value: text):
        rt_i18n_context_insert(self.handle, key, value)

    # Free the context (called automatically when dropped)
    me drop():
        rt_i18n_context_free(self.handle)

# Create a message context with one key-value pair
#
# Example:
#     val ctx = ctx1("name", "foo")
#     val diag = error_i18n("compiler", "E1001", ctx)
fn ctx1(key: text, value: text) -> MessageContext:
    val ctx = MessageContext__new()
    ctx.insert(key, value)
    ctx

# Create a message context with two key-value pairs
#
# Example:
#     val ctx = ctx2("expected", "Int", "found", "Bool")
#     val diag = error_i18n("compiler", "E1003", ctx)
fn ctx2(key1: text, value1: text, key2: text, value2: text) -> MessageContext:
    val ctx = MessageContext__new()
    ctx.insert(key1, value1)
    ctx.insert(key2, value2)
    ctx

# Create a message context with three key-value pairs
#
# Example:
#     val ctx = ctx3("expected", "Int", "found", "Bool", "line", "42")
#     val diag = error_i18n("compiler", "E1003", ctx)
fn ctx3(key1: text, value1: text, key2: text, value2: text, key3: text, value3: text) -> MessageContext:
    val ctx = MessageContext__new()
    ctx.insert(key1, value1)
    ctx.insert(key2, value2)
    ctx.insert(key3, value3)
    ctx

# Builder for creating message contexts fluently
#
# Example:
#     val ctx = ContextBuilder.new()
#         .with("expected", "identifier")
#         .with("found", "number")
#         .with("line", "42")
#         .build()
struct ContextBuilder:
    ctx: MessageContext

impl ContextBuilder:
    # Create a new context builder
    static fn new() -> ContextBuilder:
        ContextBuilder(ctx: MessageContext__new())

    # Add a key-value pair to the context
    me with(key: text, value: text) -> ContextBuilder:
        self.ctx.insert(key, value)
        self

    # Build and return the final context
    fn build() -> MessageContext:
        self.ctx

# Create an error diagnostic from an i18n message
#
# Looks up the message in the i18n catalog by domain and ID,
# interpolates it with the context, and creates a diagnostic.
#
# Example:
#     val ctx = ctx2("expected", "identifier", "found", "number")
#     val diag = error_i18n("parser", "E0002", ctx)
#         .with_span(span)
#         .with_help("Check your syntax")
fn error_i18n(domain: text, id: text, ctx: MessageContext) -> Diagnostic:
    val message = rt_i18n_get_message(domain, id, ctx.handle)
    Diagnostic__error(message).with_code(id)

# Create a warning diagnostic from an i18n message
fn warning_i18n(domain: text, id: text, ctx: MessageContext) -> Diagnostic:
    val message = rt_i18n_get_message(domain, id, ctx.handle)
    Diagnostic__warning(message).with_code(id)

# Create a note diagnostic from an i18n message
fn note_i18n(domain: text, id: text, ctx: MessageContext) -> Diagnostic:
    val message = rt_i18n_get_message(domain, id, ctx.handle)
    Diagnostic__note(message).with_code(id)

# Create a help diagnostic from an i18n message
fn help_i18n(domain: text, id: text, ctx: MessageContext) -> Diagnostic:
    val message = rt_i18n_get_message(domain, id, ctx.handle)
    Diagnostic__help_msg(message).with_code(id)

# Create an info diagnostic from an i18n message
fn info_i18n(domain: text, id: text, ctx: MessageContext) -> Diagnostic:
    val message = rt_i18n_get_message(domain, id, ctx.handle)
    Diagnostic__info(message).with_code(id)

# Get a localized severity name
#
# Example:
#     severity_name("error")  # "error" (English) or "오류" (Korean)
fn severity_name(severity: text) -> text:
    rt_i18n_severity_name(severity)

# Public exports
export MessageContext
export ContextBuilder
export ctx1
export ctx2
export ctx3
export error_i18n
export warning_i18n
export note_i18n
export help_i18n
export info_i18n
export severity_name
