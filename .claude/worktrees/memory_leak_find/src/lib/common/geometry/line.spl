# Line Operations
#
# A line is represented as two points: ((x1, y1), (x2, y2))

import "std/math" as math
import "std/geometry/types" as types
import "std/geometry/point" as point

# Create a line from two points
fn line_create(p1: (f64, f64), p2: (f64, f64)) -> ((f64, f64), (f64, f64)):
    (p1, p2)

# Calculate the slope of a line
# Returns nil if the line is vertical
fn line_slope(line: ((f64, f64), (f64, f64))) -> f64?:
    val p1 = line.0
    val p2 = line.1
    val dx = p2.0 - p1.0
    if math.abs(dx) < types.EPSILON:
        nil
    else:
        (p2.1 - p1.1) / dx

# Calculate the y-intercept of a line
# Returns nil if the line is vertical
fn line_y_intercept(line: ((f64, f64), (f64, f64))) -> f64?:
    val slope = line_slope(line)
    if slope == nil:
        nil
    else:
        val p1 = line.0
        p1.1 - slope * p1.0

# Check if two lines are parallel
fn line_parallel(line1: ((f64, f64), (f64, f64)), line2: ((f64, f64), (f64, f64))) -> bool:
    val v1 = point.vector_from_points(line1.0, line1.1)
    val v2 = point.vector_from_points(line2.0, line2.1)
    val cross = point.vector_cross(v1, v2)
    math.abs(cross) < types.EPSILON

# Check if two lines are perpendicular
fn line_perpendicular(line1: ((f64, f64), (f64, f64)), line2: ((f64, f64), (f64, f64))) -> bool:
    val v1 = point.vector_from_points(line1.0, line1.1)
    val v2 = point.vector_from_points(line2.0, line2.1)
    val dot = point.vector_dot(v1, v2)
    math.abs(dot) < types.EPSILON

# Find the intersection point of two lines
# Returns nil if lines are parallel or coincident
fn line_intersection(line1: ((f64, f64), (f64, f64)), line2: ((f64, f64), (f64, f64))) -> (f64, f64)?:
    val p1 = line1.0
    val p2 = line1.1
    val p3 = line2.0
    val p4 = line2.1

    val x1 = p1.0
    val y1 = p1.1
    val x2 = p2.0
    val y2 = p2.1
    val x3 = p3.0
    val y3 = p3.1
    val x4 = p4.0
    val y4 = p4.1

    val denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)

    if math.abs(denom) < types.EPSILON:
        nil
    else:
        val t_num = (x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)
        val t = t_num / denom
        val x = x1 + t * (x2 - x1)
        val y = y1 + t * (y2 - y1)
        (x, y)

# Check if a point lies on a line segment
fn line_point_on_segment(line: ((f64, f64), (f64, f64)), p: (f64, f64)) -> bool:
    val p1 = line.0
    val p2 = line.1

    val cross = point.vector_cross(point.vector_from_points(p1, p), point.vector_from_points(p1, p2))
    if math.abs(cross) > types.EPSILON:
        false
    else:
        val min_x = math.min(p1.0, p2.0)
        val max_x = math.max(p1.0, p2.0)
        val min_y = math.min(p1.1, p2.1)
        val max_y = math.max(p1.1, p2.1)
        p.0 >= min_x - types.EPSILON and p.0 <= max_x + types.EPSILON and p.1 >= min_y - types.EPSILON and p.1 <= max_y + types.EPSILON

# Calculate the length of a line segment
fn line_length(line: ((f64, f64), (f64, f64))) -> f64:
    point.point_distance(line.0, line.1)

# Find the closest point on a line segment to a given point
fn line_closest_point(line: ((f64, f64), (f64, f64)), p: (f64, f64)) -> (f64, f64):
    val p1 = line.0
    val p2 = line.1
    val line_vec = point.vector_from_points(p1, p2)
    val point_vec = point.vector_from_points(p1, p)

    val line_len_sq = point.vector_magnitude_squared(line_vec)

    if math.abs(line_len_sq) < types.EPSILON:
        p1
    else:
        val t = point.vector_dot(point_vec, line_vec) / line_len_sq
        if t < 0.0:
            p1
        else:
            if t > 1.0:
                p2
            else:
                (p1.0 + t * line_vec.0, p1.1 + t * line_vec.1)

# Calculate the perpendicular distance from a point to a line segment
fn line_segment_distance_to_point(seg: ((f64, f64), (f64, f64)), p: (f64, f64)) -> f64:
    val closest = line_closest_point(seg, p)
    point.point_distance(p, closest)

# Check if two line segments intersect
fn line_segment_intersects(seg1: ((f64, f64), (f64, f64)), seg2: ((f64, f64), (f64, f64))) -> bool:
    val p1 = seg1.0
    val p2 = seg1.1
    val p3 = seg2.0
    val p4 = seg2.1

    val d1 = point.vector_cross(point.vector_from_points(p3, p4), point.vector_from_points(p3, p1))
    val d2 = point.vector_cross(point.vector_from_points(p3, p4), point.vector_from_points(p3, p2))
    val d3 = point.vector_cross(point.vector_from_points(p1, p2), point.vector_from_points(p1, p3))
    val d4 = point.vector_cross(point.vector_from_points(p1, p2), point.vector_from_points(p1, p4))

    (d1 * d2 < 0.0 and d3 * d4 < 0.0) or (math.abs(d1) < types.EPSILON and line_point_on_segment(seg2, p1)) or (math.abs(d2) < types.EPSILON and line_point_on_segment(seg2, p2)) or (math.abs(d3) < types.EPSILON and line_point_on_segment(seg1, p3)) or (math.abs(d4) < types.EPSILON and line_point_on_segment(seg1, p4))

# Find the intersection point of two line segments (returns nil if no intersection)
fn line_segment_intersection_point(seg1: ((f64, f64), (f64, f64)), seg2: ((f64, f64), (f64, f64))) -> (f64, f64)?:
    if not line_segment_intersects(seg1, seg2):
        nil
    else:
        line_intersection(seg1, seg2)
