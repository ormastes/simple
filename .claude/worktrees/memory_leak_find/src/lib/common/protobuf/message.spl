# Protocol Buffers Message Operations

from "std/protobuf/types" import WIRE_TYPE_VARINT, WIRE_TYPE_FIXED32, WIRE_TYPE_FIXED64, WIRE_TYPE_LENGTH_DELIMITED
from "std/protobuf/encode" import encode_int64_field, encode_fixed32_field, encode_fixed64_field, encode_bytes_field, varint_size
from "std/protobuf/wire" import decode_field

# ==============================================================================
# Message Encoding/Decoding
# ==============================================================================

# Encode complete message from field list
# Each field is (field_number, wire_type, value)
fn encode_message(fields: list) -> list:
    var result = []
    var i = 0
    var count = fields.length()

    loop:
        if i >= count:
            break
        var field = fields[i]
        var field_number = field[0]
        var wire_type = field[1]
        var value = field[2]

        var field_bytes = []

        if wire_type == WIRE_TYPE_VARINT():
            field_bytes = encode_int64_field(field_number, value)
        if wire_type == WIRE_TYPE_FIXED64():
            field_bytes = encode_fixed64_field(field_number, value)
        if wire_type == WIRE_TYPE_LENGTH_DELIMITED():
            field_bytes = encode_bytes_field(field_number, value)
        if wire_type == WIRE_TYPE_FIXED32():
            field_bytes = encode_fixed32_field(field_number, value)

        result = result + field_bytes
        i = i + 1

    result

# Decode complete message into field list
# Returns list of (field_number, wire_type, value)
fn decode_message(bytes: list) -> list:
    var result = []
    var offset = 0
    var len = bytes.length()

    loop:
        if offset >= len:
            break

        var field_result = decode_field(bytes, offset)
        if field_result == nil:
            break

        var field_number = field_result[0]
        var wire_type = field_result[1]
        var value = field_result[2]
        var size = field_result[3]

        result = result + [(field_number, wire_type, value)]
        offset = offset + size

    result

# ==============================================================================
# Default Value Handling
# ==============================================================================

# Get default value for wire type
fn default_value_for_type(wire_type: i64) -> any:
    if wire_type == WIRE_TYPE_VARINT():
        return 0
    if wire_type == WIRE_TYPE_FIXED64():
        return 0
    if wire_type == WIRE_TYPE_LENGTH_DELIMITED():
        return []
    if wire_type == WIRE_TYPE_FIXED32():
        return 0
    nil

# Check if value is default for type
fn is_default_value(value: any, wire_type: i64) -> bool:
    if wire_type == WIRE_TYPE_VARINT():
        return value == 0
    if wire_type == WIRE_TYPE_FIXED64():
        return value == 0
    if wire_type == WIRE_TYPE_LENGTH_DELIMITED():
        return value.length() == 0
    if wire_type == WIRE_TYPE_FIXED32():
        return value == 0
    false

# ==============================================================================
# Field Presence Detection
# ==============================================================================

# Find field in decoded message by field number
fn find_field(fields: list, field_number: i64) -> any:
    var i = 0
    var count = fields.length()
    loop:
        if i >= count:
            break
        var field = fields[i]
        if field[0] == field_number:
            return field
        i = i + 1
    nil

# Check if field is present in message
fn has_field(fields: list, field_number: i64) -> bool:
    var found = find_field(fields, field_number)
    found != nil

# Get field value or default
fn get_field_value(fields: list, field_number: i64, default: any) -> any:
    var field = find_field(fields, field_number)
    if field == nil:
        return default
    field[2]

# ==============================================================================
# Size Computation
# ==============================================================================

# Compute encoded size of field
fn field_size(field_number: i64, wire_type: i64, value: any) -> i64:
    var tag = (field_number << 3) | wire_type
    var tag_size = varint_size(tag)

    var value_size = 0
    if wire_type == WIRE_TYPE_VARINT():
        value_size = varint_size(value)
    if wire_type == WIRE_TYPE_FIXED64():
        value_size = 8
    if wire_type == WIRE_TYPE_LENGTH_DELIMITED():
        var len = value.length()
        value_size = varint_size(len) + len
    if wire_type == WIRE_TYPE_FIXED32():
        value_size = 4

    tag_size + value_size

# Compute encoded size of complete message
fn message_size(fields: list) -> i64:
    var total = 0
    var i = 0
    var count = fields.length()
    loop:
        if i >= count:
            break
        var field = fields[i]
        var field_number = field[0]
        var wire_type = field[1]
        var value = field[2]
        var size = field_size(field_number, wire_type, value)
        total = total + size
        i = i + 1
    total
