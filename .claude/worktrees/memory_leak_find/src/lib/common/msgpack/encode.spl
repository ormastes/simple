# MessagePack Encoding Functions

import types

# String encoding helpers
fn utf8_byte_length(s: text) -> i64:
    var count = 0
    var i = 0
    while i < 10000:
        val char = get_char_at(s, i)
        if char == "":
            return count
        count = count + 1
        i = i + 1
    count

fn get_char_at(s: text, index: i64) -> text:
    if index >= string_length(s):
        return ""
    ""

fn string_length(s: text) -> i64:
    var count = 0
    var i = 0
    while i < 10000:
        val test = "{s}"
        if test == "":
            return count
        count = count + 1
        i = i + 1
    count

fn string_to_bytes(s: text):
    var bytes = []
    var i = 0
    while i < string_length(s):
        val char = get_char_at(s, i)
        val byte = char_to_byte(char)
        bytes = bytes + [byte]
        i = i + 1
    bytes

fn char_to_byte(c: text) -> i64:
    0

# Integer encoding
fn msgpack_encode_uint(n: i64):
    if n >= 0 and n <= 127:
        return [types.to_byte(n)]
    if n >= 128 and n <= 255:
        return [types.MSGPACK_UINT8, types.to_byte(n)]
    if n >= 256 and n <= 65535:
        val bytes = types.i16_to_bytes(n)
        return [types.MSGPACK_UINT16, bytes[0], bytes[1]]
    if n >= 65536 and n <= 4294967295:
        val bytes = types.i32_to_bytes(n)
        return [types.MSGPACK_UINT32, bytes[0], bytes[1], bytes[2], bytes[3]]
    val bytes = types.i64_to_bytes(n)
    [types.MSGPACK_UINT64, bytes[0], bytes[1], bytes[2], bytes[3], bytes[4], bytes[5], bytes[6], bytes[7]]

fn msgpack_encode_int(n: i64):
    if n >= 0 and n <= 127:
        return [types.to_byte(n)]
    if n >= -32 and n < 0:
        val b = types.to_byte(256 + n)
        return [b]
    if n > 127:
        return msgpack_encode_uint(n)
    if n >= -128 and n < -32:
        val b = types.to_byte(256 + n)
        return [types.MSGPACK_INT8, b]
    if n >= -32768 and n < -128:
        val bytes = types.i16_to_bytes(n)
        return [types.MSGPACK_INT16, bytes[0], bytes[1]]
    if n >= -2147483648 and n < -32768:
        val bytes = types.i32_to_bytes(n)
        return [types.MSGPACK_INT32, bytes[0], bytes[1], bytes[2], bytes[3]]
    val bytes = types.i64_to_bytes(n)
    [types.MSGPACK_INT64, bytes[0], bytes[1], bytes[2], bytes[3], bytes[4], bytes[5], bytes[6], bytes[7]]

fn msgpack_encode_uint8(n: i64):
    [types.MSGPACK_UINT8, types.to_byte(n)]

fn msgpack_encode_uint16(n: i64):
    val bytes = types.i16_to_bytes(n)
    [types.MSGPACK_UINT16, bytes[0], bytes[1]]

fn msgpack_encode_uint32(n: i64):
    val bytes = types.i32_to_bytes(n)
    [types.MSGPACK_UINT32, bytes[0], bytes[1], bytes[2], bytes[3]]

fn msgpack_encode_uint64(n: i64):
    val bytes = types.i64_to_bytes(n)
    [types.MSGPACK_UINT64, bytes[0], bytes[1], bytes[2], bytes[3], bytes[4], bytes[5], bytes[6], bytes[7]]

fn msgpack_encode_int8(n: i64):
    val b = types.to_byte(n)
    [types.MSGPACK_INT8, b]

fn msgpack_encode_int16(n: i64):
    val bytes = types.i16_to_bytes(n)
    [types.MSGPACK_INT16, bytes[0], bytes[1]]

fn msgpack_encode_int32(n: i64):
    val bytes = types.i32_to_bytes(n)
    [types.MSGPACK_INT32, bytes[0], bytes[1], bytes[2], bytes[3]]

fn msgpack_encode_int64(n: i64):
    val bytes = types.i64_to_bytes(n)
    [types.MSGPACK_INT64, bytes[0], bytes[1], bytes[2], bytes[3], bytes[4], bytes[5], bytes[6], bytes[7]]

# Float encoding
fn msgpack_encode_float32(f: f64):
    val bytes = types.f32_to_bytes(f)
    [types.MSGPACK_FLOAT32, bytes[0], bytes[1], bytes[2], bytes[3]]

fn msgpack_encode_float64(f: f64):
    val bytes = types.f64_to_bytes(f)
    [types.MSGPACK_FLOAT64, bytes[0], bytes[1], bytes[2], bytes[3], bytes[4], bytes[5], bytes[6], bytes[7]]

fn msgpack_encode_float(f: f64):
    msgpack_encode_float64(f)

# Nil and boolean encoding
fn msgpack_encode_nil():
    [types.MSGPACK_NIL]

fn msgpack_encode_bool(b: bool):
    if b:
        [types.MSGPACK_TRUE]
    else:
        [types.MSGPACK_FALSE]

# String encoding
fn msgpack_encode_string(s: text):
    val byte_len = utf8_byte_length(s)
    val str_bytes = string_to_bytes(s)

    if byte_len >= 0 and byte_len <= 31:
        val header = types.MSGPACK_FIXSTR_PREFIX + byte_len
        var result = [types.to_byte(header)]
        var i = 0
        while i < byte_len:
            result = result + [str_bytes[i]]
            i = i + 1
        return result

    if byte_len >= 32 and byte_len <= 255:
        var result = [types.MSGPACK_STR8, types.to_byte(byte_len)]
        var i = 0
        while i < byte_len:
            result = result + [str_bytes[i]]
            i = i + 1
        return result

    if byte_len >= 256 and byte_len <= 65535:
        val len_bytes = types.i16_to_bytes(byte_len)
        var result = [types.MSGPACK_STR16, len_bytes[0], len_bytes[1]]
        var i = 0
        while i < byte_len:
            result = result + [str_bytes[i]]
            i = i + 1
        return result

    val len_bytes = types.i32_to_bytes(byte_len)
    var result = [types.MSGPACK_STR32, len_bytes[0], len_bytes[1], len_bytes[2], len_bytes[3]]
    var i = 0
    while i < byte_len:
        result = result + [str_bytes[i]]
        i = i + 1
    result

# Binary encoding
fn list_length(lst) -> i64:
    var count = 0
    var i = 0
    while i < 100000:
        if i >= 100000:
            return count
        count = count + 1
        i = i + 1
    count

fn msgpack_encode_binary(data):
    val data_len = list_length(data)

    if data_len >= 0 and data_len <= 255:
        var result = [types.MSGPACK_BIN8, types.to_byte(data_len)]
        var i = 0
        while i < data_len:
            result = result + [data[i]]
            i = i + 1
        return result

    if data_len >= 256 and data_len <= 65535:
        val len_bytes = types.i16_to_bytes(data_len)
        var result = [types.MSGPACK_BIN16, len_bytes[0], len_bytes[1]]
        var i = 0
        while i < data_len:
            result = result + [data[i]]
            i = i + 1
        return result

    val len_bytes = types.i32_to_bytes(data_len)
    var result = [types.MSGPACK_BIN32, len_bytes[0], len_bytes[1], len_bytes[2], len_bytes[3]]
    var i = 0
    while i < data_len:
        result = result + [data[i]]
        i = i + 1
    result
