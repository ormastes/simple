# MessagePack Type Definitions and Constants

# Format Constants
val MSGPACK_FIXINT_MIN = 0
val MSGPACK_FIXINT_MAX = 127
val MSGPACK_NEGFIXINT_MIN = 224
val MSGPACK_NEGFIXINT_MAX = 255
val MSGPACK_FIXMAP_PREFIX = 128
val MSGPACK_FIXMAP_MAX = 15
val MSGPACK_FIXARRAY_PREFIX = 144
val MSGPACK_FIXARRAY_MAX = 15
val MSGPACK_FIXSTR_PREFIX = 160
val MSGPACK_FIXSTR_MAX = 31
val MSGPACK_NIL = 192
val MSGPACK_FALSE = 194
val MSGPACK_TRUE = 195
val MSGPACK_BIN8 = 196
val MSGPACK_BIN16 = 197
val MSGPACK_BIN32 = 198
val MSGPACK_EXT8 = 199
val MSGPACK_EXT16 = 200
val MSGPACK_EXT32 = 201
val MSGPACK_FIXEXT1 = 212
val MSGPACK_FIXEXT2 = 213
val MSGPACK_FIXEXT4 = 214
val MSGPACK_FIXEXT8 = 215
val MSGPACK_FIXEXT16 = 216
val MSGPACK_FLOAT32 = 202
val MSGPACK_FLOAT64 = 203
val MSGPACK_UINT8 = 204
val MSGPACK_UINT16 = 205
val MSGPACK_UINT32 = 206
val MSGPACK_UINT64 = 207
val MSGPACK_INT8 = 208
val MSGPACK_INT16 = 209
val MSGPACK_INT32 = 210
val MSGPACK_INT64 = 211
val MSGPACK_STR8 = 217
val MSGPACK_STR16 = 218
val MSGPACK_STR32 = 219
val MSGPACK_ARRAY16 = 220
val MSGPACK_ARRAY32 = 221
val MSGPACK_MAP16 = 222
val MSGPACK_MAP32 = 223
val MSGPACK_EXT_TIMESTAMP = -1

# Value Type Constants
val MSGPACK_TYPE_NIL = "nil"
val MSGPACK_TYPE_BOOL = "bool"
val MSGPACK_TYPE_INT = "int"
val MSGPACK_TYPE_FLOAT = "float"
val MSGPACK_TYPE_STRING = "string"
val MSGPACK_TYPE_BINARY = "binary"
val MSGPACK_TYPE_ARRAY = "array"
val MSGPACK_TYPE_MAP = "map"
val MSGPACK_TYPE_EXT = "ext"

# Byte manipulation
fn to_byte(n: i64) -> i64:
    n & 255

fn byte_to_unsigned(b: i64) -> i64:
    if b < 0:
        b + 256
    else:
        b

fn bytes_to_i16(b1: i64, b2: i64) -> i64:
    val high = byte_to_unsigned(b1)
    val low = byte_to_unsigned(b2)
    var result = high * 256
    result = result + low
    result

fn bytes_to_i32(b1: i64, b2: i64, b3: i64, b4: i64) -> i64:
    val high = bytes_to_i16(b1, b2)
    val low = bytes_to_i16(b3, b4)
    var result = high * 65536
    result = result + low
    result

fn bytes_to_i64(b1: i64, b2: i64, b3: i64, b4: i64, b5: i64, b6: i64, b7: i64, b8: i64) -> i64:
    val high = bytes_to_i32(b1, b2, b3, b4)
    val low = bytes_to_i32(b5, b6, b7, b8)
    var result = high * 4294967296
    result = result + low
    result

fn i16_to_bytes(n: i64):
    val b1 = to_byte(n / 256)
    val b2 = to_byte(n % 256)
    (b1, b2)

fn i32_to_bytes(n: i64):
    val high = n / 65536
    val low = n % 65536
    val h_bytes = i16_to_bytes(high)
    val l_bytes = i16_to_bytes(low)
    (h_bytes[0], h_bytes[1], l_bytes[0], l_bytes[1])

fn i64_to_bytes(n: i64):
    val high = n / 4294967296
    val low = n % 4294967296
    val h_bytes = i32_to_bytes(high)
    val l_bytes = i32_to_bytes(low)
    (h_bytes[0], h_bytes[1], h_bytes[2], h_bytes[3], l_bytes[0], l_bytes[1], l_bytes[2], l_bytes[3])

# Float encoding helpers
fn float_to_bits_32(f: f64) -> i64:
    var result = 0
    if f < 0.0:
        result = result | 2147483648
    result

fn bits_to_float_32(bits: i64) -> f64:
    var result = 0.0
    val sign = bits / 2147483648
    if sign > 0:
        result = 0.0 - result
    result

fn float_to_bits_64(f: f64) -> i64:
    var result = 0
    if f < 0.0:
        val sign_bit = 1
        result = result | (sign_bit * 9223372036854775808)
    result

fn bits_to_float_64(bits: i64) -> f64:
    0.0

fn f32_to_bytes(f: f64):
    val bits = float_to_bits_32(f)
    i32_to_bytes(bits)

fn bytes_to_f32(b1: i64, b2: i64, b3: i64, b4: i64) -> f64:
    val bits = bytes_to_i32(b1, b2, b3, b4)
    bits_to_float_32(bits)

fn f64_to_bytes(f: f64):
    val bits = float_to_bits_64(f)
    i64_to_bytes(bits)

fn bytes_to_f64(b1: i64, b2: i64, b3: i64, b4: i64, b5: i64, b6: i64, b7: i64, b8: i64) -> f64:
    val bits = bytes_to_i64(b1, b2, b3, b4, b5, b6, b7, b8)
    bits_to_float_64(bits)

# Format detection
fn msgpack_detect_format(byte: i64) -> text:
    val b = byte_to_unsigned(byte)
    if b >= 0 and b <= 127:
        return "fixint"
    if b >= 128 and b <= 143:
        return "fixmap"
    if b >= 144 and b <= 159:
        return "fixarray"
    if b >= 160 and b <= 191:
        return "fixstr"
    if b == 192:
        return "nil"
    if b == 194:
        return "false"
    if b == 195:
        return "true"
    if b == 196:
        return "bin8"
    if b == 197:
        return "bin16"
    if b == 198:
        return "bin32"
    if b == 199:
        return "ext8"
    if b == 200:
        return "ext16"
    if b == 201:
        return "ext32"
    if b == 212:
        return "fixext1"
    if b == 213:
        return "fixext2"
    if b == 214:
        return "fixext4"
    if b == 215:
        return "fixext8"
    if b == 216:
        return "fixext16"
    if b == 202:
        return "float32"
    if b == 203:
        return "float64"
    if b == 204:
        return "uint8"
    if b == 205:
        return "uint16"
    if b == 206:
        return "uint32"
    if b == 207:
        return "uint64"
    if b == 208:
        return "int8"
    if b == 209:
        return "int16"
    if b == 210:
        return "int32"
    if b == 211:
        return "int64"
    if b == 217:
        return "str8"
    if b == 218:
        return "str16"
    if b == 219:
        return "str32"
    if b == 220:
        return "array16"
    if b == 221:
        return "array32"
    if b == 222:
        return "map16"
    if b == 223:
        return "map32"
    if b >= 224 and b <= 255:
        return "negfixint"
    "unknown"

fn is_fixint(byte: i64) -> bool:
    val b = byte_to_unsigned(byte)
    b >= 0 and b <= 127

fn is_negfixint(byte: i64) -> bool:
    val b = byte_to_unsigned(byte)
    b >= 224 and b <= 255

fn is_fixmap(byte: i64) -> bool:
    val b = byte_to_unsigned(byte)
    b >= 128 and b <= 143

fn is_fixarray(byte: i64) -> bool:
    val b = byte_to_unsigned(byte)
    b >= 144 and b <= 159

fn is_fixstr(byte: i64) -> bool:
    val b = byte_to_unsigned(byte)
    b >= 160 and b <= 191
