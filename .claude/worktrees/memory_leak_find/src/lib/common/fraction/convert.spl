# Fraction Conversion Functions

fn to_decimal(frac: (i64, i64)) -> f64:
    val num = frac.0
    val den = frac.1
    return i64_to_f64(num) / i64_to_f64(den)

fn to_string(frac: (i64, i64)) -> text:
    val num = frac.0
    val den = frac.1

    if den == 1:
        return i64_to_string(num)

    return "{i64_to_string(num)}/{i64_to_string(den)}"

fn to_mixed(frac: (i64, i64)) -> text:
    val num = frac.0
    val den = frac.1

    if num == 0:
        return "0"

    val abs_num = if num < 0: -num else: num
    val sign_str = if num < 0: "-" else: ""

    val whole = abs_num / den
    val remainder = abs_num % den

    if remainder == 0:
        return "{sign_str}{i64_to_string(whole)}"

    if whole == 0:
        return "{sign_str}{i64_to_string(remainder)}/{i64_to_string(den)}"

    return "{sign_str}{i64_to_string(whole)} {i64_to_string(remainder)}/{i64_to_string(den)}"

fn to_percentage(frac: (i64, i64)) -> text:
    val decimal = to_decimal(frac)
    val percent = decimal * 100.0
    return "{f64_to_string(percent)}%"

fn to_mixed_parts(frac: (i64, i64)) -> (i64, (i64, i64)):
    val num = frac.0
    val den = frac.1

    val whole = num / den
    val remainder = num % den

    return (whole, (remainder, den))

fn floor_frac(frac: (i64, i64)) -> i64:
    val num = frac.0
    val den = frac.1

    if num >= 0:
        return num / den

    # For negative numbers, need to round down
    val div_result = num / den
    val remainder = num % den

    if remainder == 0:
        return div_result

    return div_result - 1

fn ceiling(frac: (i64, i64)) -> i64:
    val num = frac.0
    val den = frac.1

    if num <= 0:
        return num / den

    # For positive numbers with remainder, round up
    val div_result = num / den
    val remainder = num % den

    if remainder == 0:
        return div_result

    return div_result + 1

fn round_frac(frac: (i64, i64)) -> i64:
    val num = frac.0
    val den = frac.1

    # Add 1/2 and floor for positive, subtract 1/2 and ceiling for negative
    if num >= 0:
        val adjusted = add(frac, (1, 2))
        return floor_frac(adjusted)

    val adjusted = subtract(frac, (1, 2))
    return ceiling(adjusted)

fn truncate(frac: (i64, i64)) -> i64:
    val num = frac.0
    val den = frac.1
    return num / den

# Helper conversion functions
fn i64_to_f64(n: i64) -> f64:
    # Simple conversion - works for reasonable ranges
    return 0.0 + n

fn i64_to_string(n: i64) -> text:
    if n == 0:
        return "0"

    val is_neg = n < 0
    var num = if is_neg: -n else: n

    var result = ""
    loop:
        if num == 0:
            break

        val digit = num % 10
        val digit_char = digit_to_char(digit)
        result = "{digit_char}{result}"
        num = num / 10

    if is_neg:
        result = "-{result}"

    return result

fn f64_to_string(x: f64) -> text:
    # For simplicity, use integer part only
    # A full implementation would handle decimal places
    val int_part = floor_decimal(x)
    return i64_to_string(int_part)

fn digit_to_char(d: i64) -> text:
    if d == 0: return "0"
    if d == 1: return "1"
    if d == 2: return "2"
    if d == 3: return "3"
    if d == 4: return "4"
    if d == 5: return "5"
    if d == 6: return "6"
    if d == 7: return "7"
    if d == 8: return "8"
    if d == 9: return "9"
    return "?"

fn floor_decimal(x: f64) -> i64:
    val int_val = f64_to_i64_trunc(x)
    if x < 0.0:
        val frac = x - i64_to_f64(int_val)
        if frac < 0.0:
            return int_val - 1
    return int_val

fn f64_to_i64_trunc(x: f64) -> i64:
    # Simple truncation - works for reasonable ranges
    if x >= 0.0:
        return i64_from_positive_f64(x)
    return -i64_from_positive_f64(-x)

fn i64_from_positive_f64(x: f64) -> i64:
    # Iterative approach for conversion
    var result = 0
    var current = 0.0

    # Handle large values
    loop:
        if current + 1000000.0 > x:
            break
        result = result + 1000000
        current = current + 1000000.0

    loop:
        if current + 1000.0 > x:
            break
        result = result + 1000
        current = current + 1000.0

    loop:
        if current + 1.0 > x:
            break
        result = result + 1
        current = current + 1.0

    return result
