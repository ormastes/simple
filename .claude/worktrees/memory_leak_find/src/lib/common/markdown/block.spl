# =============================================================================
# Block-level Pattern Detection (15 functions)
# =============================================================================

fn is_heading_line(line: text) -> bool:
    val trimmed = trim_start(line)
    if trimmed.length() == 0:
        return false
    val first = trimmed.char_at(0)
    if first != "#":
        return false
    val hashes = count_leading_chars(trimmed, "#")
    if hashes < 1 or hashes > 6:
        return false
    if trimmed.length() == hashes:
        return true
    val after = trimmed.char_at(hashes)
    is_whitespace(after)

fn parse_heading_level(line: text) -> i64:
    val trimmed = trim_start(line)
    count_leading_chars(trimmed, "#")

fn parse_heading_content(line: text) -> text:
    val trimmed = trim_start(line)
    val hashes = count_leading_chars(trimmed, "#")
    var content = trimmed.substring(hashes, trimmed.length())
    content = trim(content)
    val trailing = count_trailing_chars(content, "#")
    if trailing > 0:
        content = content.substring(0, content.length() - trailing)
        content = trim_end(content)
    content

fn is_horizontal_rule(line: text) -> bool:
    val trimmed = trim(line)
    if trimmed.length() < 3:
        return false
    val first = trimmed.char_at(0)
    if first != "-" and first != "*" and first != "_":
        return false
    var count = 0
    var i = 0
    var len = trimmed.length()
    while i < len:
        val c = trimmed.char_at(i)
        if c == first:
            count = count + 1
        else:
            if c != " " and c != "\t":
                return false
        i = i + 1
    count >= 3

fn is_code_fence(line: text) -> bool:
    val trimmed = trim_start(line)
    if trimmed.length() < 3:
        return false
    val backticks = count_leading_chars(trimmed, "`")
    if backticks >= 3:
        return true
    val tildes = count_leading_chars(trimmed, "~")
    tildes >= 3

fn get_code_fence_char(line: text) -> text:
    val trimmed = trim_start(line)
    if trimmed.length() == 0:
        return ""
    val first = trimmed.char_at(0)
    if first == "`" or first == "~":
        return first
    ""

fn parse_code_fence_lang(line: text) -> text:
    val trimmed = trim_start(line)
    val backticks = count_leading_chars(trimmed, "`")
    val tildes = count_leading_chars(trimmed, "~")
    var fence_len = 0
    if backticks >= 3:
        fence_len = backticks
    else:
        fence_len = tildes
    var lang = trimmed.substring(fence_len, trimmed.length())
    lang = trim(lang)
    lang

fn is_blockquote_line(line: text) -> bool:
    val trimmed = trim_start(line)
    if trimmed.length() == 0:
        return false
    val first = trimmed.char_at(0)
    first == ">"

fn parse_blockquote_content(line: text) -> text:
    val trimmed = trim_start(line)
    var content = trimmed.substring(1, trimmed.length())
    if content.length() > 0:
        val first = content.char_at(0)
        if is_whitespace(first):
            content = content.substring(1, content.length())
    content

fn is_unordered_list_line(line: text) -> bool:
    val trimmed = trim_start(line)
    if trimmed.length() < 2:
        return false
    val first = trimmed.char_at(0)
    val marker = first == "-" or first == "*" or first == "+"
    if not marker:
        return false
    val second = trimmed.char_at(1)
    is_whitespace(second)

fn parse_unordered_list_content(line: text) -> text:
    val trimmed = trim_start(line)
    var content = trimmed.substring(1, trimmed.length())
    content = trim_start(content)
    content

fn is_ordered_list_line(line: text) -> bool:
    val trimmed = trim_start(line)
    if trimmed.length() < 3:
        return false
    var i = 0
    var digits = 0
    var len = trimmed.length()
    while i < len:
        val c = trimmed.char_at(i)
        if is_digit(c):
            digits = digits + 1
        else:
            break
        i = i + 1
    if digits == 0:
        return false
    if i >= len:
        return false
    val dot = trimmed.char_at(i)
    if dot != ".":
        return false
    if i + 1 >= len:
        return false
    val after = trimmed.char_at(i + 1)
    is_whitespace(after)

fn parse_ordered_list_number(line: text) -> i64:
    val trimmed = trim_start(line)
    var num_str = ""
    var i = 0
    var len = trimmed.length()
    while i < len:
        val c = trimmed.char_at(i)
        if is_digit(c):
            num_str = num_str + c
        else:
            break
        i = i + 1
    num_str.to_int()

fn parse_ordered_list_content(line: text) -> text:
    val trimmed = trim_start(line)
    var i = 0
    var len = trimmed.length()
    while i < len:
        val c = trimmed.char_at(i)
        if is_digit(c):
            i = i + 1
        else:
            break
    i = i + 1
    var content = trimmed.substring(i, len)
    content = trim_start(content)
    content

fn is_list_item_line(line: text) -> bool:
    is_unordered_list_line(line) or is_ordered_list_line(line)

