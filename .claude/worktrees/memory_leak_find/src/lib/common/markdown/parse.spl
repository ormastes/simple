
# =============================================================================
# Block Parsing (8 functions)
# =============================================================================

fn parse_heading_block(line: text) -> tuple:
    val level = parse_heading_level(line)
    val content = parse_heading_content(line)
    val tokens = parse_inline_tokens(content)
    ("heading", level, tokens)

fn parse_code_block(lines: array, start: i64) -> tuple:
    val first_line = lines.get(start)
    val fence_char = get_code_fence_char(first_line)
    val trimmed = trim_start(first_line)
    val fence_count = count_leading_chars(trimmed, fence_char)
    val lang = parse_code_fence_lang(first_line)
    var code_lines = []
    var i = start + 1
    var len = lines.length()
    while i < len:
        val line = lines.get(i)
        if is_code_fence(line):
            val line_trimmed = trim_start(line)
            val line_char = get_code_fence_char(line)
            if line_char == fence_char:
                val close_count = count_leading_chars(line_trimmed, line_char)
                if close_count >= fence_count:
                    i = i + 1
                    break
        code_lines = code_lines.push(line)
        i = i + 1
    val code = join_lines(code_lines, "\n")
    val block = ("code_block", lang, code)
    (block, i - start)

fn parse_blockquote_block(lines: array, start: i64) -> tuple:
    var content_lines = []
    var i = start
    var len = lines.length()
    while i < len:
        val line = lines.get(i)
        if not is_blockquote_line(line):
            break
        val content = parse_blockquote_content(line)
        content_lines = content_lines.push(content)
        i = i + 1
    val child_blocks = parse_blocks(content_lines)
    val block = ("blockquote", child_blocks)
    (block, i - start)

fn parse_unordered_list_block(lines: array, start: i64) -> tuple:
    var items = []
    var i = start
    var len = lines.length()
    while i < len:
        val line = lines.get(i)
        if not is_unordered_list_line(line):
            break
        val content = parse_unordered_list_content(line)
        val tokens = parse_inline_tokens(content)
        items = items.push(tokens)
        i = i + 1
    val block = ("unordered_list", items)
    (block, i - start)

fn parse_ordered_list_block(lines: array, start: i64) -> tuple:
    var items = []
    var i = start
    var len = lines.length()
    val first_line = lines.get(start)
    val start_num = parse_ordered_list_number(first_line)
    while i < len:
        val line = lines.get(i)
        if not is_ordered_list_line(line):
            break
        val content = parse_ordered_list_content(line)
        val tokens = parse_inline_tokens(content)
        items = items.push(tokens)
        i = i + 1
    val block = ("ordered_list", start_num, items)
    (block, i - start)

fn parse_table_block(lines: array, start: i64) -> tuple:
    val header_line = lines.get(start)
    val sep_line = lines.get(start + 1)
    val headers = parse_table_row(header_line)
    val alignments = parse_table_alignments(sep_line)
    var rows = []
    var i = start + 2
    var len = lines.length()
    while i < len:
        val line = lines.get(i)
        val trimmed = trim(line)
        if not starts_with(trimmed, "|"):
            break
        val row = parse_table_row(line)
        rows = rows.push(row)
        i = i + 1
    val block = ("table", headers, alignments, rows)
    (block, i - start)

fn parse_paragraph_block(lines: array, start: i64) -> tuple:
    var content_lines = []
    var i = start
    var len = lines.length()
    while i < len:
        val line = lines.get(i)
        if is_blank_line(line):
            break
        if is_heading_line(line):
            break
        if is_horizontal_rule(line):
            break
        if is_code_fence(line):
            break
        if is_blockquote_line(line):
            break
        if is_unordered_list_line(line):
            break
        if is_ordered_list_line(line):
            break
        content_lines = content_lines.push(line)
        i = i + 1
    val content = join_lines(content_lines, " ")
    val tokens = parse_inline_tokens(content)
    val block = ("paragraph", tokens)
    (block, i - start)

fn parse_blocks(lines: array) -> array:
    var blocks = []
    var i = 0
    var len = lines.length()
    while i < len:
        val line = lines.get(i)
        if is_blank_line(line):
            i = i + 1
        else:
            if is_heading_line(line):
                val block = parse_heading_block(line)
                blocks = blocks.push(block)
                i = i + 1
            else:
                if is_horizontal_rule(line):
                    val block = ("horizontal_rule")
                    blocks = blocks.push(block)
                    i = i + 1
                else:
                    if is_code_fence(line):
                        val result = parse_code_block(lines, i)
                        val block = result.0
                        val consumed = result.1
                        blocks = blocks.push(block)
                        i = i + consumed
                    else:
                        if is_blockquote_line(line):
                            val result = parse_blockquote_block(lines, i)
                            val block = result.0
                            val consumed = result.1
                            blocks = blocks.push(block)
                            i = i + consumed
                        else:
                            if is_unordered_list_line(line):
                                val result = parse_unordered_list_block(lines, i)
                                val block = result.0
                                val consumed = result.1
                                blocks = blocks.push(block)
                                i = i + consumed
                            else:
                                if is_ordered_list_line(line):
                                    val result = parse_ordered_list_block(lines, i)
                                    val block = result.0
                                    val consumed = result.1
                                    blocks = blocks.push(block)
                                    i = i + consumed
                                else:
                                    if i + 1 < len:
                                        val next_line = lines.get(i + 1)
                                        if is_table_separator_line(next_line):
                                            val result = parse_table_block(lines, i)
                                            val block = result.0
                                            val consumed = result.1
                                            blocks = blocks.push(block)
                                            i = i + consumed
                                        else:
                                            val result = parse_paragraph_block(lines, i)
                                            val block = result.0
                                            val consumed = result.1
                                            blocks = blocks.push(block)
                                            i = i + consumed
                                    else:
                                        val result = parse_paragraph_block(lines, i)
                                        val block = result.0
                                        val consumed = result.1
                                        blocks = blocks.push(block)
                                        i = i + consumed
    blocks
