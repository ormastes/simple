# Scrypt Validation Module
# Parameter validation and utility functions

import scrypt.types

# =============================================================================
# UTILITY FUNCTIONS
# =============================================================================

fn is_power_of_two(n: i64) -> i64:
    """Check if n is a power of 2.

    Returns: 1 if power of 2, 0 otherwise

    Example:
        is_power_of_two(16)  # 1
        is_power_of_two(15)  # 0
    """
    if n <= 0:
        return 0
    (n & (n - 1)) == 0

fn log2(n: i64) -> i64:
    """Calculate log2 of n (assuming n is power of 2).

    Example:
        log2(16384)  # 14
    """
    var result = 0
    var temp = n
    while temp > 1:
        temp = temp >> 1
        result = result + 1
    result

fn validate_params(params) -> i64:
    """Validate scrypt parameters.

    Checks:
    - N must be power of 2 and > 1
    - r must be positive
    - p must be positive
    - dkLen must be positive and <= 2^32-1
    - Memory requirement must not overflow

    Returns: 1 if valid, 0 if invalid

    Example:
        val is_valid = validate_params(params)
    """
    val (N, r, p, dkLen) = params

    # Check N is power of 2 and > 1
    var n_check = is_power_of_two(N)
    if n_check == 0:
        return 0
    if N <= 1:
        return 0

    # Check r is positive
    if r <= 0:
        return 0

    # Check p is positive
    if p <= 0:
        return 0

    # Check dkLen is positive and reasonable
    if dkLen <= 0:
        return 0
    if dkLen > 2147483647:  # 2^31-1
        return 0

    # Check memory requirement doesn't overflow
    # Memory = 128 * N * r
    val max_memory = 1073741824  # 1 GB limit
    var memory_needed = 128 * N
    memory_needed = memory_needed * r
    if memory_needed > max_memory:
        return 0

    1

fn estimate_memory_usage(params) -> i64:
    """Estimate memory usage in bytes for given parameters.

    Memory = 128 * N * r bytes

    Example:
        val memory = estimate_memory_usage(params)
        print "Needs {memory} bytes"
    """
    val (N, r, p, dkLen) = params
    var memory = 128 * N
    memory = memory * r
    memory

fn estimate_time(params) -> text:
    """Estimate hashing time for given parameters.

    Returns approximate time description.

    Example:
        val time = estimate_time(params)
    """
    val (N, r, p, dkLen) = params

    # Rough estimates based on N parameter
    if N <= 4096:
        return "~50-100ms"
    if N <= 16384:
        return "~200-400ms"
    if N <= 32768:
        return "~400-800ms"
    if N <= 65536:
        return "~1-2 seconds"
    "~several seconds"

fn compare_constant_time(a: list, b: list) -> i64:
    """Constant-time comparison of byte arrays.

    Prevents timing attacks by always comparing all bytes.

    Returns: 1 if equal, 0 if not equal

    Example:
        val equal = compare_constant_time(hash1, hash2)
    """
    if a.len() != b.len():
        return 0

    var result = 0
    var i = 0
    while i < a.len():
        val a_byte = a.get(i)
        val b_byte = b.get(i)
        result = result | (a_byte ^ b_byte)
        i = i + 1

    if result == 0:
        return 1
    0
