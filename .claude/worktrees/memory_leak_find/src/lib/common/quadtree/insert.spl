# Quadtree Insert Operations

from "std/quadtree/types" import node_bounds, node_is_leaf, node_points, node_capacity, node_tag, node_children, node_child_nw, node_child_ne, node_child_sw, node_child_se, node_new_internal, bounds_contains_point
from "std/quadtree/split" import node_subdivide, quadrant_for_point, point_new

# === Quadtree Insert Operations ===

fn node_insert_point(node, point):
    # Insert a point into the node
    val bounds = node_bounds(node)
    val contains = bounds_contains_point(bounds, point)
    if not contains:
        node
    else:
        val is_leaf = node_is_leaf(node)
        if is_leaf:
            val points = node_points(node)
            val capacity = node_capacity(node)
            val count = len(points)
            val has_space = count < capacity
            if has_space:
                val new_points = points + [point]
                val tag = node_tag(node)
                val children = node_children(node)
                (tag, bounds, capacity, new_points, children)
            else:
                # Need to subdivide
                val subdivided = node_subdivide(node)
                node_insert_point(subdivided, point)
        else:
            # Internal node - insert into appropriate child
            val quadrant = quadrant_for_point(bounds, point)
            val nw = node_child_nw(node)
            val ne = node_child_ne(node)
            val sw = node_child_sw(node)
            val se = node_child_se(node)

            if quadrant == 0:
                val new_nw = node_insert_point(nw, point)
                node_new_internal(bounds, new_nw, ne, sw, se)
            else:
                if quadrant == 1:
                    val new_ne = node_insert_point(ne, point)
                    node_new_internal(bounds, nw, new_ne, sw, se)
                else:
                    if quadrant == 2:
                        val new_sw = node_insert_point(sw, point)
                        node_new_internal(bounds, nw, ne, new_sw, se)
                    else:
                        val new_se = node_insert_point(se, point)
                        node_new_internal(bounds, nw, ne, sw, new_se)

fn quadtree_insert(tree, x, y, data):
    # Insert a point into the quadtree
    val point = point_new(x, y, data)
    node_insert_point(tree, point)

# === Quadtree Remove Operations ===

fn node_remove_point_helper(node, target_point):
    # Helper to remove a point from the tree
    val bounds = node_bounds(node)
    val contains = bounds_contains_point(bounds, target_point)
    if not contains:
        (node, false)
    else:
        val is_leaf = node_is_leaf(node)
        if is_leaf:
            val points = node_points(node)
            var new_points = []
            var i = 0
            val count = len(points)
            var found = false
            while i < count:
                val point = points[i]
                val is_match = point_equals(point, target_point)
                if is_match and not found:
                    found = true
                else:
                    new_points = new_points + [point]
                i = i + 1

            if found:
                val tag = node_tag(node)
                val capacity = node_capacity(node)
                val children = node_children(node)
                val new_node = (tag, bounds, capacity, new_points, children)
                (new_node, true)
            else:
                (node, false)
        else:
            # Try removing from children
            val quadrant = quadrant_for_point(bounds, target_point)
            val nw = node_child_nw(node)
            val ne = node_child_ne(node)
            val sw = node_child_sw(node)
            val se = node_child_se(node)

            if quadrant == 0:
                val result = node_remove_point_helper(nw, target_point)
                val new_nw = result[0]
                val removed = result[1]
                val new_node = node_new_internal(bounds, new_nw, ne, sw, se)
                (new_node, removed)
            else:
                if quadrant == 1:
                    val result = node_remove_point_helper(ne, target_point)
                    val new_ne = result[0]
                    val removed = result[1]
                    val new_node = node_new_internal(bounds, nw, new_ne, sw, se)
                    (new_node, removed)
                else:
                    if quadrant == 2:
                        val result = node_remove_point_helper(sw, target_point)
                        val new_sw = result[0]
                        val removed = result[1]
                        val new_node = node_new_internal(bounds, nw, ne, new_sw, se)
                        (new_node, removed)
                    else:
                        val result = node_remove_point_helper(se, target_point)
                        val new_se = result[0]
                        val removed = result[1]
                        val new_node = node_new_internal(bounds, nw, ne, sw, new_se)
                        (new_node, removed)

fn node_remove_point(node, target_point):
    # Remove a point from the tree
    val result = node_remove_point_helper(node, target_point)
    result[0]

fn quadtree_remove(tree, x, y):
    # Remove a point at given coordinates
    val point = point_new(x, y, nil)
    node_remove_point(tree, point)
