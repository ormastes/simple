# Quadtree Type Definitions and Basic Operations

# Point representation: (x, y, data)
# Bounds representation: (min_x, min_y, max_x, max_y)
# Quadtree node: (tag, bounds, capacity, points, children)
#   tag: "leaf" or "internal"
#   bounds: bounding box tuple
#   capacity: max points before split (leaf only)
#   points: list of points (leaf only)
#   children: (nw, ne, sw, se) quadrants (internal only)

# === Point Operations ===

fn point_new(x, y, data):
    # Create a new point with coordinates and associated data
    (x, y, data)

fn point_x(point):
    # Get x coordinate of point
    val p = point
    p[0]

fn point_y(point):
    # Get y coordinate of point
    val p = point
    p[1]

fn point_data(point):
    # Get associated data from point
    val p = point
    p[2]

fn point_distance(p1, p2):
    # Calculate Euclidean distance between two points
    val x1 = point_x(p1)
    val y1 = point_y(p1)
    val x2 = point_x(p2)
    val y2 = point_y(p2)
    val dx = x2 - x1
    val dy = y2 - y1
    val sum = dx * dx + dy * dy
    sqrt(sum)

fn point_distance_squared(p1, p2):
    # Calculate squared distance (faster, no sqrt)
    val x1 = point_x(p1)
    val y1 = point_y(p1)
    val x2 = point_x(p2)
    val y2 = point_y(p2)
    val dx = x2 - x1
    val dy = y2 - y1
    dx * dx + dy * dy

fn point_equals(p1, p2):
    # Check if two points have same coordinates
    val x1 = point_x(p1)
    val y1 = point_y(p1)
    val x2 = point_x(p2)
    val y2 = point_y(p2)
    val same_x = x1 == x2
    val same_y = y1 == y2
    same_x and same_y

fn point_midpoint(p1, p2):
    # Calculate midpoint between two points
    val x1 = point_x(p1)
    val y1 = point_y(p1)
    val x2 = point_x(p2)
    val y2 = point_y(p2)
    val mx = (x1 + x2) / 2.0
    val my = (y1 + y2) / 2.0
    point_new(mx, my, nil)

fn point_to_string(point):
    # Convert point to string representation
    val x = point_x(point)
    val y = point_y(point)
    val data = point_data(point)
    "Point({x}, {y}, {data})"

# === Bounds Operations ===

fn bounds_new(min_x, min_y, max_x, max_y):
    # Create a new bounding box
    (min_x, min_y, max_x, max_y)

fn bounds_min_x(bounds):
    # Get minimum x coordinate
    val b = bounds
    b[0]

fn bounds_min_y(bounds):
    # Get minimum y coordinate
    val b = bounds
    b[1]

fn bounds_max_x(bounds):
    # Get maximum x coordinate
    val b = bounds
    b[2]

fn bounds_max_y(bounds):
    # Get maximum y coordinate
    val b = bounds
    b[3]

fn bounds_width(bounds):
    # Calculate width of bounds
    val min_x = bounds_min_x(bounds)
    val max_x = bounds_max_x(bounds)
    max_x - min_x

fn bounds_height(bounds):
    # Calculate height of bounds
    val min_y = bounds_min_y(bounds)
    val max_y = bounds_max_y(bounds)
    max_y - min_y

fn bounds_center_x(bounds):
    # Get center x coordinate
    val min_x = bounds_min_x(bounds)
    val max_x = bounds_max_x(bounds)
    (min_x + max_x) / 2.0

fn bounds_center_y(bounds):
    # Get center y coordinate
    val min_y = bounds_min_y(bounds)
    val max_y = bounds_max_y(bounds)
    (min_y + max_y) / 2.0

fn bounds_center(bounds):
    # Get center point of bounds
    val cx = bounds_center_x(bounds)
    val cy = bounds_center_y(bounds)
    point_new(cx, cy, nil)

fn bounds_contains_point(bounds, point):
    # Check if bounds contains a point
    val x = point_x(point)
    val y = point_y(point)
    val min_x = bounds_min_x(bounds)
    val min_y = bounds_min_y(bounds)
    val max_x = bounds_max_x(bounds)
    val max_y = bounds_max_y(bounds)
    val in_x = x >= min_x and x <= max_x
    val in_y = y >= min_y and y <= max_y
    in_x and in_y

fn bounds_intersects_bounds(b1, b2):
    # Check if two bounds intersect
    val min_x1 = bounds_min_x(b1)
    val max_x1 = bounds_max_x(b1)
    val min_y1 = bounds_min_y(b1)
    val max_y1 = bounds_max_y(b1)
    val min_x2 = bounds_min_x(b2)
    val max_x2 = bounds_max_x(b2)
    val min_y2 = bounds_min_y(b2)
    val max_y2 = bounds_max_y(b2)
    val no_overlap_x = max_x1 < min_x2 or max_x2 < min_x1
    val no_overlap_y = max_y1 < min_y2 or max_y2 < min_y1
    val overlaps = not no_overlap_x
    val overlaps_y = not no_overlap_y
    overlaps and overlaps_y

fn bounds_contains_bounds(outer, inner):
    # Check if outer bounds completely contains inner bounds
    val min_x1 = bounds_min_x(outer)
    val max_x1 = bounds_max_x(outer)
    val min_y1 = bounds_min_y(outer)
    val max_y1 = bounds_max_y(outer)
    val min_x2 = bounds_min_x(inner)
    val max_x2 = bounds_max_x(inner)
    val min_y2 = bounds_min_y(inner)
    val max_y2 = bounds_max_y(inner)
    val contains_x = min_x2 >= min_x1 and max_x2 <= max_x1
    val contains_y = min_y2 >= min_y1 and max_y2 <= max_y1
    contains_x and contains_y

fn bounds_intersects_circle(bounds, center_x, center_y, radius):
    # Check if bounds intersects with a circle
    val min_x = bounds_min_x(bounds)
    val max_x = bounds_max_x(bounds)
    val min_y = bounds_min_y(bounds)
    val max_y = bounds_max_y(bounds)

    # Find closest point on bounds to circle center
    var closest_x = center_x
    if center_x < min_x:
        closest_x = min_x
    if center_x > max_x:
        closest_x = max_x

    var closest_y = center_y
    if center_y < min_y:
        closest_y = min_y
    if center_y > max_y:
        closest_y = max_y

    # Check if closest point is within radius
    val dx = center_x - closest_x
    val dy = center_y - closest_y
    val dist_sq = dx * dx + dy * dy
    val radius_sq = radius * radius
    dist_sq <= radius_sq

fn bounds_area(bounds):
    # Calculate area of bounds
    val w = bounds_width(bounds)
    val h = bounds_height(bounds)
    w * h

fn bounds_to_string(bounds):
    # Convert bounds to string representation
    val min_x = bounds_min_x(bounds)
    val min_y = bounds_min_y(bounds)
    val max_x = bounds_max_x(bounds)
    val max_y = bounds_max_y(bounds)
    "Bounds({min_x}, {min_y}, {max_x}, {max_y})"

# === Quadtree Node Operations ===

fn node_new_leaf(bounds, capacity):
    # Create a new leaf node
    val tag = "leaf"
    val points = []
    val children = nil
    (tag, bounds, capacity, points, children)

fn node_new_internal(bounds, nw, ne, sw, se):
    # Create a new internal node with four children
    val tag = "internal"
    val capacity = 0
    val points = nil
    val children = (nw, ne, sw, se)
    (tag, bounds, capacity, points, children)

fn node_tag(node):
    # Get node tag (leaf or internal)
    val n = node
    n[0]

fn node_bounds(node):
    # Get node bounds
    val n = node
    n[1]

fn node_capacity(node):
    # Get node capacity (leaf only)
    val n = node
    n[2]

fn node_points(node):
    # Get node points (leaf only)
    val n = node
    n[3]

fn node_children(node):
    # Get node children (internal only)
    val n = node
    n[4]

fn node_is_leaf(node):
    # Check if node is a leaf
    val tag = node_tag(node)
    tag == "leaf"

fn node_is_internal(node):
    # Check if node is internal
    val tag = node_tag(node)
    tag == "internal"

fn node_child_nw(node):
    # Get northwest child
    val children = node_children(node)
    val c = children
    c[0]

fn node_child_ne(node):
    # Get northeast child
    val children = node_children(node)
    val c = children
    c[1]

fn node_child_sw(node):
    # Get southwest child
    val children = node_children(node)
    val c = children
    c[2]

fn node_child_se(node):
    # Get southeast child
    val children = node_children(node)
    val c = children
    c[3]

fn node_point_count(node):
    # Count total points in node and descendants
    val is_leaf = node_is_leaf(node)
    if is_leaf:
        val points = node_points(node)
        len(points)
    else:
        val nw = node_child_nw(node)
        val ne = node_child_ne(node)
        val sw = node_child_sw(node)
        val se = node_child_se(node)
        val count_nw = node_point_count(nw)
        val count_ne = node_point_count(ne)
        val count_sw = node_point_count(sw)
        val count_se = node_point_count(se)
        val sum1 = count_nw + count_ne
        val sum2 = count_sw + count_se
        sum1 + sum2

fn node_depth(node):
    # Calculate depth of tree from this node
    val is_leaf = node_is_leaf(node)
    if is_leaf:
        1
    else:
        val nw = node_child_nw(node)
        val ne = node_child_ne(node)
        val sw = node_child_sw(node)
        val se = node_child_se(node)
        val depth_nw = node_depth(nw)
        val depth_ne = node_depth(ne)
        val depth_sw = node_depth(sw)
        val depth_se = node_depth(se)
        var max_depth = depth_nw
        if depth_ne > max_depth:
            max_depth = depth_ne
        if depth_sw > max_depth:
            max_depth = depth_sw
        if depth_se > max_depth:
            max_depth = depth_se
        max_depth + 1
