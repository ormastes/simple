# Segment Tree Utilities - Facade Module
#
# A comprehensive implementation of segment trees for efficient range queries
# and updates. Segment trees allow O(log n) time complexity for both range
# queries and point/range updates.
#
# THEORY:
# A segment tree is a binary tree where each node represents an interval [l, r].
# The root represents the entire array [0, n-1], and each leaf represents a
# single element. Internal nodes store aggregate information (sum, min, max, etc.)
# about their corresponding interval.
#
# COMPLEXITY:
# - Build: O(n) time, O(n) space
# - Query: O(log n) time
# - Point Update: O(log n) time
# - Range Update (with lazy propagation): O(log n) time
#
# STRUCTURE:
# Tree is stored as array where for node at index i:
# - Left child: 2*i + 1
# - Right child: 2*i + 2
# - Parent: (i-1)/2
#
# ORGANIZATION:
# This facade module re-exports functionality from categorized submodules:
# - types: Type definitions and accessors
# - utilities: Helper functions, validation, array conversion
# - build: Tree construction for different types
# - query: Range query operations
# - update: Point update operations
# - range_ops: Advanced range operations
# - lazy: Lazy propagation for range updates

# Import all submodules
import std.segment_tree.types
import std.segment_tree.utilities
import std.segment_tree.build
import std.segment_tree.query
import std.segment_tree.update
import std.segment_tree.range_ops
import std.segment_tree.lazy

# Re-export type functions
fn get_tree_type(tree_tuple: (list, i64, text)) -> text:
    return types.get_tree_type(tree_tuple)

fn get_array_size(tree_tuple: (list, i64, text)) -> i64:
    return types.get_array_size(tree_tuple)

fn get_internal_size(tree_tuple: (list, i64, text)) -> i64:
    return types.get_internal_size(tree_tuple)

# Re-export utility functions
fn get_tree_size(n: i64) -> i64:
    return utilities.get_tree_size(n)

fn get_height(n: i64) -> i64:
    return utilities.get_height(n)

fn parent(i: i64) -> i64:
    return utilities.parent(i)

fn left_child(i: i64) -> i64:
    return utilities.left_child(i)

fn right_child(i: i64) -> i64:
    return utilities.right_child(i)

fn is_leaf(start: i64, end: i64) -> i64:
    return utilities.is_leaf(start, end)

fn get_mid(start: i64, end: i64) -> i64:
    return utilities.get_mid(start, end)

fn gcd(a: i64, b: i64) -> i64:
    return utilities.gcd(a, b)

fn lcm(a: i64, b: i64) -> i64:
    return utilities.lcm(a, b)

fn is_valid_tree(tree_tuple: (list, i64, text)) -> i64:
    return utilities.is_valid_tree(tree_tuple)

fn is_valid_lazy_tree(tree_tuple: (list, list, i64, text)) -> i64:
    return utilities.is_valid_lazy_tree(tree_tuple)

fn merge_arrays(arr1: list, arr2: list) -> list:
    return utilities.merge_arrays(arr1, arr2)

fn clone_tree(tree_tuple: (list, i64, text)) -> (list, i64, text):
    return utilities.clone_tree(tree_tuple)

fn clone_lazy_tree(tree_tuple: (list, list, i64, text)) -> (list, list, i64, text):
    return utilities.clone_lazy_tree(tree_tuple)

fn print_tree(tree_tuple: (list, i64, text)):
    return utilities.print_tree(tree_tuple)

# Re-export build functions
fn build_sum_tree(arr: list) -> (list, i64, text):
    return build.build_sum_tree(arr)

fn build_min_tree(arr: list) -> (list, i64, text):
    return build.build_min_tree(arr)

fn build_max_tree(arr: list) -> (list, i64, text):
    return build.build_max_tree(arr)

fn build_gcd_tree(arr: list) -> (list, i64, text):
    return build.build_gcd_tree(arr)

fn build_xor_tree(arr: list) -> (list, i64, text):
    return build.build_xor_tree(arr)

fn build_lcm_tree(arr: list) -> (list, i64, text):
    return build.build_lcm_tree(arr)

fn create_segment_tree(arr: list) -> (list, i64, text):
    return build.create_segment_tree(arr)

fn create_typed_segment_tree(arr: list, tree_type: text) -> (list, i64, text):
    return build.create_typed_segment_tree(arr, tree_type)

fn rebuild_tree(tree_tuple: (list, i64, text), arr: list) -> (list, i64, text):
    return build.rebuild_tree(tree_tuple, arr)

fn build_all_trees(arr: list) -> ((list, i64, text), (list, i64, text), (list, i64, text)):
    return build.build_all_trees(arr)

fn merge_trees(tree1: (list, i64, text), tree2: (list, i64, text)) -> (list, i64, text):
    return build.merge_trees(tree1, tree2)

# Re-export query functions
fn range_sum(tree_tuple: (list, i64, text), l: i64, r: i64) -> i64:
    return query.range_sum(tree_tuple, l, r)

fn range_min(tree_tuple: (list, i64, text), l: i64, r: i64) -> i64:
    return query.range_min(tree_tuple, l, r)

fn range_max(tree_tuple: (list, i64, text), l: i64, r: i64) -> i64:
    return query.range_max(tree_tuple, l, r)

fn range_gcd(tree_tuple: (list, i64, text), l: i64, r: i64) -> i64:
    return query.range_gcd(tree_tuple, l, r)

fn range_lcm(tree_tuple: (list, i64, text), l: i64, r: i64) -> i64:
    return query.range_lcm(tree_tuple, l, r)

fn range_average(tree_tuple: (list, i64, text), l: i64, r: i64) -> i64:
    return query.range_average(tree_tuple, l, r)

fn get_element(tree_tuple: (list, i64, text), index: i64) -> i64:
    return query.get_element(tree_tuple, index)

fn tree_to_array(tree_tuple: (list, i64, text)) -> list:
    return query.tree_to_array(tree_tuple)

fn verify_sum_tree(tree_tuple: (list, i64, text), arr: list) -> i64:
    return query.verify_sum_tree(tree_tuple, arr)

fn count_elements_greater(tree_tuple: (list, i64, text), l: i64, r: i64, threshold: i64, arr: list) -> i64:
    return query.count_elements_greater(tree_tuple, l, r, threshold, arr)

fn first_at_least(tree_tuple: (list, i64, text), target: i64) -> i64:
    return query.first_at_least(tree_tuple, target)

fn last_at_most(tree_tuple: (list, i64, text), target: i64) -> i64:
    return query.last_at_most(tree_tuple, target)

fn range_all_equal(tree_tuple: (list, i64, text), l: i64, r: i64) -> i64:
    return query.range_all_equal(tree_tuple, l, r)

fn longest_increasing(tree_tuple: (list, i64, text), l: i64, r: i64) -> i64:
    return query.longest_increasing(tree_tuple, l, r)

fn longest_decreasing(tree_tuple: (list, i64, text), l: i64, r: i64) -> i64:
    return query.longest_decreasing(tree_tuple, l, r)

# Re-export update functions
fn update_point_sum(tree_tuple: (list, i64, text), index: i64, value: i64) -> (list, i64, text):
    return update.update_point_sum(tree_tuple, index, value)

fn update_point_min(tree_tuple: (list, i64, text), index: i64, value: i64) -> (list, i64, text):
    return update.update_point_min(tree_tuple, index, value)

fn update_point_max(tree_tuple: (list, i64, text), index: i64, value: i64) -> (list, i64, text):
    return update.update_point_max(tree_tuple, index, value)

fn update_point(tree_tuple: (list, i64, text), index: i64, value: i64) -> (list, i64, text):
    return update.update_point(tree_tuple, index, value)

fn batch_update_points(tree_tuple: (list, i64, text), updates: list) -> (list, i64, text):
    return update.batch_update_points(tree_tuple, updates)

# Re-export range operation functions
fn max_sum_range(tree_tuple: (list, i64, text), range_size: i64) -> (i64, i64):
    return range_ops.max_sum_range(tree_tuple, range_size)

fn count_ranges_with_sum(tree_tuple: (list, i64, text), target: i64) -> i64:
    return range_ops.count_ranges_with_sum(tree_tuple, target)

fn range_set(tree_tuple: (list, i64, text), l: i64, r: i64, value: i64) -> (list, i64, text):
    return range_ops.range_set(tree_tuple, l, r, value)

fn range_multiply(tree_tuple: (list, i64, text), l: i64, r: i64, factor: i64) -> (list, i64, text):
    return range_ops.range_multiply(tree_tuple, l, r, factor)

fn count_inversions(tree_tuple: (list, i64, text), l: i64, r: i64) -> i64:
    return range_ops.count_inversions(tree_tuple, l, r)

# Re-export lazy propagation functions
fn create_lazy_tree(arr: list) -> (list, list, i64, text):
    return lazy.create_lazy_tree(arr)

fn update_range(tree_tuple: (list, list, i64, text), l: i64, r: i64, value: i64) -> (list, list, i64, text):
    return lazy.update_range(tree_tuple, l, r, value)

fn range_add(tree_tuple: (list, list, i64, text), l: i64, r: i64, value: i64) -> (list, list, i64, text):
    return lazy.range_add(tree_tuple, l, r, value)

fn range_sum_lazy(tree_tuple: (list, list, i64, text), l: i64, r: i64) -> i64:
    return lazy.range_sum_lazy(tree_tuple, l, r)
