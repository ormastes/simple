# Segment Tree Utility Functions
#
# This module contains helper functions for tree size calculations,
# navigation, and structural operations.

# Calculate the size needed for segment tree array
# For array of size n, we need approximately 4*n space
fn get_tree_size(n: i64) -> i64:
    if n == 0:
        return 0

    # Calculate next power of 2
    var power = 1
    while power < n:
        power = power * 2

    # Segment tree needs 2*power - 1 nodes
    return 2 * power - 1

# Calculate height of segment tree
fn get_height(n: i64) -> i64:
    if n == 0:
        return 0

    var height = 0
    var power = 1
    while power < n:
        power = power * 2
        height = height + 1

    return height

# Get parent index of node i
fn parent(i: i64) -> i64:
    if i == 0:
        return 0
    return (i - 1) / 2

# Get left child index of node i
fn left_child(i: i64) -> i64:
    return 2 * i + 1

# Get right child index of node i
fn right_child(i: i64) -> i64:
    return 2 * i + 2

# Check if node is leaf
fn is_leaf(start: i64, end: i64) -> i64:
    if start == end:
        return 1
    return 0

# Get middle point of range [start, end]
fn get_mid(start: i64, end: i64) -> i64:
    return start + (end - start) / 2

# Calculate GCD of two numbers using Euclidean algorithm
fn gcd(a: i64, b: i64) -> i64:
    var x = a
    var y = b

    # Make both positive
    if x < 0:
        x = -x
    if y < 0:
        y = -y

    # Handle zero cases
    if x == 0:
        return y
    if y == 0:
        return x

    # Euclidean algorithm
    while y != 0:
        val temp = y
        y = x % y
        x = temp

    return x

# Calculate LCM of two numbers
fn lcm(a: i64, b: i64) -> i64:
    if a == 0:
        return 0
    if b == 0:
        return 0

    val gcd_val = gcd(a, b)
    if gcd_val == 0:
        return 0

    # LCM = (a * b) / GCD(a, b)
    val product = a * b
    if product < 0:
        return -((-product) / gcd_val)

    return product / gcd_val

# Check if tree structure is valid
fn is_valid_tree(tree_tuple: (list, i64, text)) -> i64:
    val tree = tree_tuple.0
    val n = tree_tuple.1

    if n == 0:
        return 1

    val expected_size = get_tree_size(n)
    val actual_size = tree.length()

    if actual_size < expected_size:
        return 0

    return 1

# Check if lazy tree is valid
fn is_valid_lazy_tree(tree_tuple: (list, list, i64, text)) -> i64:
    val tree = tree_tuple.0
    val lazy = tree_tuple.1
    val n = tree_tuple.2

    if n == 0:
        return 1

    val expected_size = get_tree_size(n)
    val tree_size = tree.length()
    val lazy_size = lazy.length()

    if tree_size < expected_size:
        return 0
    if lazy_size < expected_size:
        return 0

    return 1

# Merge two arrays
fn merge_arrays(arr1: list, arr2: list) -> list:
    var result = []

    var i = 0
    while i < arr1.length():
        result.append(arr1.get(i))
        i = i + 1

    i = 0
    while i < arr2.length():
        result.append(arr2.get(i))
        i = i + 1

    return result

# Clone segment tree (create independent copy)
fn clone_tree(tree_tuple: (list, i64, text)) -> (list, i64, text):
    val tree = tree_tuple.0
    val n = tree_tuple.1
    val tree_type = tree_tuple.2

    var new_tree = []
    var i = 0
    while i < tree.length():
        new_tree.append(tree.get(i))
        i = i + 1

    return (new_tree, n, tree_type)

# Clone lazy tree
fn clone_lazy_tree(tree_tuple: (list, list, i64, text)) -> (list, list, i64, text):
    val tree = tree_tuple.0
    val lazy = tree_tuple.1
    val n = tree_tuple.2
    val tree_type = tree_tuple.3

    var new_tree = []
    var new_lazy = []

    var i = 0
    while i < tree.length():
        new_tree.append(tree.get(i))
        i = i + 1

    i = 0
    while i < lazy.length():
        new_lazy.append(lazy.get(i))
        i = i + 1

    return (new_tree, new_lazy, n, tree_type)

# Print segment tree structure (simple version)
fn print_tree_helper(tree: list, node: i64, start: i64, end: i64, depth: i64):
    if node >= tree.length():
        return ()

    # Print indentation
    var i = 0
    while i < depth:
        print "  "
        i = i + 1

    val value = tree.get(node)
    print "Node [{start}-{end}]: {value}"

    var leaf_check = is_leaf(start, end)
    if leaf_check == 1:
        return ()

    val mid = get_mid(start, end)
    val left = left_child(node)
    val right = right_child(node)

    print_tree_helper(tree, left, start, mid, depth + 1)
    print_tree_helper(tree, right, mid + 1, end, depth + 1)

# Print segment tree
fn print_tree(tree_tuple: (list, i64, text)):
    val tree = tree_tuple.0
    val n = tree_tuple.1
    val tree_type = tree_tuple.2

    print "Segment Tree (type: {tree_type}, size: {n})"

    if n == 0:
        print "Empty tree"
        return ()

    print_tree_helper(tree, 0, 0, n - 1, 0)
