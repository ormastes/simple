# Rope Modification Module
# Functions for modifying ropes (insert, delete, replace)

# ============================================================================
# INSERTION
# ============================================================================

fn rope_insert_at(node: any, index: i64, s: text) -> any:
    # Insert string at index
    if s.length() == 0:
        return node

    var parts = rope_split_at(node, index)
    var left = parts.0
    var right = parts.1
    var middle = rope_create_from_string(s)

    var temp = rope_concat(left, middle)
    rope_concat(temp, right)

fn rope_insert_rope_at(node: any, index: i64, insert: any) -> any:
    # Insert another rope at index
    if insert == nil or rope_is_empty(insert):
        return node

    var parts = rope_split_at(node, index)
    var left = parts.0
    var right = parts.1

    var temp = rope_concat(left, insert)
    rope_concat(temp, right)

fn rope_insert_line(node: any, line_num: i64, line: text) -> any:
    # Insert line at position
    var lines = rope_to_lines(node)

    if line_num < 0:
        line_num = 0
    if line_num > lines.length():
        line_num = lines.length()

    var new_lines = []
    var i = 0

    while i < line_num:
        new_lines = new_lines.append(lines[i])
        i = i + 1

    new_lines = new_lines.append(line)

    while i < lines.length():
        new_lines = new_lines.append(lines[i])
        i = i + 1

    var joined = new_lines.join("\n")
    rope_create_from_string(joined)

# ============================================================================
# DELETION
# ============================================================================

fn rope_delete_range(node: any, start: i64, end: i64) -> any:
    # Delete characters in range [start, end)
    if start >= end:
        return node

    var len = rope_length(node)
    if start < 0:
        start = 0
    if end > len:
        end = len

    var parts1 = rope_split_at(node, start)
    var left = parts1.0
    var middle_right = parts1.1

    var delete_len = end - start
    var parts2 = rope_split_at(middle_right, delete_len)
    var right = parts2.1

    rope_concat(left, right)

fn rope_delete_at(node: any, index: i64) -> any:
    # Delete single character at index
    rope_delete_range(node, index, index + 1)

fn rope_delete_line(node: any, line_num: i64) -> any:
    # Delete specific line
    var lines = rope_to_lines(node)

    if line_num < 0 or line_num >= lines.length():
        return node

    var new_lines = []
    var i = 0

    while i < lines.length():
        if i != line_num:
            new_lines = new_lines.append(lines[i])
        i = i + 1

    var joined = new_lines.join("\n")
    rope_create_from_string(joined)

# ============================================================================
# REPLACEMENT
# ============================================================================

fn rope_replace(node: any, old: text, new: text) -> any:
    # Replace all occurrences of old with new
    var s = rope_to_string(node)
    var result = s.replace(old, new)
    rope_create_from_string(result)

fn rope_replace_range(node: any, start: i64, end: i64, replacement: text) -> any:
    # Replace range with new text
    var deleted = rope_delete_range(node, start, end)
    rope_insert_at(deleted, start, replacement)

fn rope_replace_line(node: any, line_num: i64, new_line: text) -> any:
    # Replace specific line
    var lines = rope_to_lines(node)

    if line_num < 0 or line_num >= lines.length():
        return node

    var new_lines = []
    var i = 0

    while i < lines.length():
        if i == line_num:
            new_lines = new_lines.append(new_line)
        else:
            new_lines = new_lines.append(lines[i])
        i = i + 1

    var joined = new_lines.join("\n")
    rope_create_from_string(joined)
