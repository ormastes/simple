# Rope Utilities Module
# Conversion, iteration, formatting, validation, and other utility functions

# ============================================================================
# CONVERSION
# ============================================================================

fn rope_to_string(node: any) -> text:
    # Convert rope to string
    if node == nil:
        return ""

    if rope_is_leaf(node):
        return node.4

    var left = node.2
    var right = node.3
    var left_str = rope_to_string(left)
    var right_str = rope_to_string(right)

    "{left_str}{right_str}"

fn rope_to_string_builder(node: any, acc: any) -> any:
    # Convert rope to string using accumulator
    if node == nil:
        return acc

    if rope_is_leaf(node):
        var value = node.4
        return acc.append(value)

    var left = node.2
    var right = node.3
    var acc2 = rope_to_string_builder(left, acc)
    rope_to_string_builder(right, acc2)

fn rope_to_lines(node: any) -> any:
    # Convert rope to list of lines
    var s = rope_to_string(node)
    s.split("\n")

# ============================================================================
# ITERATION
# ============================================================================

fn rope_iter_chars(node: any) -> any:
    # Create character iterator (returns list of chars)
    var s = rope_to_string(node)
    var result = []
    var i = 0

    while i < s.length():
        var ch = s.substring(i, i + 1)
        result = result.append(ch)
        i = i + 1

    result

fn rope_iter_leaves(node: any) -> any:
    # Create leaf iterator (returns list of leaves)
    rope_to_leaf_list(node)

fn rope_for_each_char(node: any, fn_proc: any) -> any:
    # Apply function to each character
    var chars = rope_iter_chars(node)
    var i = 0

    while i < chars.length():
        fn_proc(chars[i], i)
        i = i + 1

    nil

fn rope_map_chars(node: any, fn_map: any) -> any:
    # Map function over characters
    var chars = rope_iter_chars(node)
    var result = []
    var i = 0

    while i < chars.length():
        var mapped = fn_map(chars[i])
        result = result.append(mapped)
        i = i + 1

    var joined = result.join("")
    rope_create_from_string(joined)

# ============================================================================
# TEXT TRANSFORMATIONS
# ============================================================================

fn rope_reverse(node: any) -> any:
    # Reverse the rope
    var s = rope_to_string(node)
    var result = ""
    var i = s.length() - 1

    while i >= 0:
        var ch = s.substring(i, i + 1)
        result = "{result}{ch}"
        i = i - 1

    rope_create_from_string(result)

fn rope_trim(node: any) -> any:
    # Trim whitespace from both ends
    var s = rope_to_string(node)
    var trimmed = s.trim()
    rope_create_from_string(trimmed)

fn rope_trim_start(node: any) -> any:
    # Trim whitespace from start
    var s = rope_to_string(node)
    var i = 0

    while i < s.length():
        var ch = s.substring(i, i + 1)
        var is_space = ch == " " or ch == "\t" or ch == "\n" or ch == "\r"
        if not is_space:
            break
        i = i + 1

    var trimmed = s.substring(i, s.length())
    rope_create_from_string(trimmed)

fn rope_trim_end(node: any) -> any:
    # Trim whitespace from end
    var s = rope_to_string(node)
    var i = s.length() - 1

    while i >= 0:
        var ch = s.substring(i, i + 1)
        var is_space = ch == " " or ch == "\t" or ch == "\n" or ch == "\r"
        if not is_space:
            break
        i = i - 1

    var trimmed = s.substring(0, i + 1)
    rope_create_from_string(trimmed)

fn rope_to_upper(node: any) -> any:
    # Convert to uppercase
    var s = rope_to_string(node)
    var upper = s.to_upper()
    rope_create_from_string(upper)

fn rope_to_lower(node: any) -> any:
    # Convert to lowercase
    var s = rope_to_string(node)
    var lower = s.to_lower()
    rope_create_from_string(lower)

# ============================================================================
# LINE OPERATIONS
# ============================================================================

fn rope_line_count(node: any) -> i64:
    # Count number of lines
    var lines = rope_to_lines(node)
    lines.length()

fn rope_get_line(node: any, line_num: i64) -> text:
    # Get specific line (0-indexed)
    var lines = rope_to_lines(node)
    if line_num < 0 or line_num >= lines.length():
        return ""
    lines[line_num]

# ============================================================================
# WORD OPERATIONS
# ============================================================================

fn rope_word_count(node: any) -> i64:
    # Count number of words (whitespace-separated)
    var s = rope_to_string(node)
    var words = s.split(" ")
    var count = 0
    var i = 0

    while i < words.length():
        var word = words[i].trim()
        if word.length() > 0:
            count = count + 1
        i = i + 1

    count

fn rope_split_words(node: any) -> any:
    # Split rope into words
    var s = rope_to_string(node)
    var words = s.split(" ")
    var result = []
    var i = 0

    while i < words.length():
        var word = words[i].trim()
        if word.length() > 0:
            result = result.append(word)
        i = i + 1

    result

fn rope_join_words(words: any, separator: text) -> any:
    # Join words into rope
    var s = words.join(separator)
    rope_create_from_string(s)

# ============================================================================
# FILTERING
# ============================================================================

fn rope_filter_lines(node: any, predicate: any) -> any:
    # Filter lines based on predicate function
    var lines = rope_to_lines(node)
    var result = []
    var i = 0

    while i < lines.length():
        var line = lines[i]
        var keep = predicate(line)
        if keep:
            result = result.append(line)
        i = i + 1

    var joined = result.join("\n")
    rope_create_from_string(joined)

fn rope_filter_chars(node: any, predicate: any) -> any:
    # Filter characters based on predicate function
    var chars = rope_iter_chars(node)
    var result = []
    var i = 0

    while i < chars.length():
        var ch = chars[i]
        var keep = predicate(ch)
        if keep:
            result = result.append(ch)
        i = i + 1

    var joined = result.join("")
    rope_create_from_string(joined)

# ============================================================================
# SLICING
# ============================================================================

fn rope_slice(node: any, start: i64, end: i64, step: i64) -> any:
    # Slice rope with step (Python-like slicing)
    if step <= 0:
        step = 1

    var len = rope_length(node)
    if start < 0:
        start = 0
    if end > len:
        end = len

    var result = []
    var i = start

    while i < end:
        var ch = rope_char_at(node, i)
        result = result.append(ch)
        i = i + step

    var joined = result.join("")
    rope_create_from_string(joined)

fn rope_take(node: any, n: i64) -> any:
    # Take first n characters
    if n <= 0:
        return rope_create_empty()

    var len = rope_length(node)
    if n > len:
        n = len

    var parts = rope_split_at(node, n)
    parts.0

fn rope_drop(node: any, n: i64) -> any:
    # Drop first n characters
    if n <= 0:
        return node

    var len = rope_length(node)
    if n >= len:
        return rope_create_empty()

    var parts = rope_split_at(node, n)
    parts.1

fn rope_take_while(node: any, predicate: any) -> any:
    # Take characters while predicate is true
    var chars = rope_iter_chars(node)
    var result = []
    var i = 0

    while i < chars.length():
        var ch = chars[i]
        var keep = predicate(ch)
        if not keep:
            break
        result = result.append(ch)
        i = i + 1

    var joined = result.join("")
    rope_create_from_string(joined)

fn rope_drop_while(node: any, predicate: any) -> any:
    # Drop characters while predicate is true
    var chars = rope_iter_chars(node)
    var i = 0

    while i < chars.length():
        var ch = chars[i]
        var drop = predicate(ch)
        if not drop:
            break
        i = i + 1

    var rest = []
    while i < chars.length():
        rest = rest.append(chars[i])
        i = i + 1

    var joined = rest.join("")
    rope_create_from_string(joined)

# ============================================================================
# AGGREGATION
# ============================================================================

fn rope_fold_left(node: any, init: any, fn_fold: any) -> any:
    # Fold left over characters
    var chars = rope_iter_chars(node)
    var acc = init
    var i = 0

    while i < chars.length():
        acc = fn_fold(acc, chars[i])
        i = i + 1

    acc

fn rope_fold_right(node: any, init: any, fn_fold: any) -> any:
    # Fold right over characters
    var chars = rope_iter_chars(node)
    var acc = init
    var i = chars.length() - 1

    while i >= 0:
        acc = fn_fold(chars[i], acc)
        i = i - 1

    acc

fn rope_reduce(node: any, fn_reduce: any) -> any:
    # Reduce rope using function
    var chars = rope_iter_chars(node)
    if chars.length() == 0:
        return nil

    var acc = chars[0]
    var i = 1

    while i < chars.length():
        acc = fn_reduce(acc, chars[i])
        i = i + 1

    acc

# ============================================================================
# PARTITIONING
# ============================================================================

fn rope_partition(node: any, predicate: any) -> any:
    # Partition rope into two ropes based on predicate
    # Returns (matching, non_matching) tuple
    var chars = rope_iter_chars(node)
    var matching = []
    var non_matching = []
    var i = 0

    while i < chars.length():
        var ch = chars[i]
        var matches = predicate(ch)
        if matches:
            matching = matching.append(ch)
        else:
            non_matching = non_matching.append(ch)
        i = i + 1

    var matched_str = matching.join("")
    var non_matched_str = non_matching.join("")
    var matched_rope = rope_create_from_string(matched_str)
    var non_matched_rope = rope_create_from_string(non_matched_str)

    (matched_rope, non_matched_rope)

fn rope_span(node: any, predicate: any) -> any:
    # Span rope into prefix matching predicate and rest
    # Returns (prefix, rest) tuple
    var chars = rope_iter_chars(node)
    var prefix = []
    var i = 0

    while i < chars.length():
        var ch = chars[i]
        var matches = predicate(ch)
        if not matches:
            break
        prefix = prefix.append(ch)
        i = i + 1

    var rest = []
    while i < chars.length():
        rest = rest.append(chars[i])
        i = i + 1

    var prefix_str = prefix.join("")
    var rest_str = rest.join("")
    var prefix_rope = rope_create_from_string(prefix_str)
    var rest_rope = rope_create_from_string(rest_str)

    (prefix_rope, rest_rope)

# ============================================================================
# FORMATTING
# ============================================================================

fn rope_pad_left(node: any, total_len: i64, pad_char: text) -> any:
    # Pad rope on the left to total length
    var len = rope_length(node)
    if len >= total_len:
        return node

    var pad_len = total_len - len
    var padding = ""
    var i = 0

    while i < pad_len:
        padding = "{padding}{pad_char}"
        i = i + 1

    var pad_rope = rope_create_from_string(padding)
    rope_concat(pad_rope, node)

fn rope_pad_right(node: any, total_len: i64, pad_char: text) -> any:
    # Pad rope on the right to total length
    var len = rope_length(node)
    if len >= total_len:
        return node

    var pad_len = total_len - len
    var padding = ""
    var i = 0

    while i < pad_len:
        padding = "{padding}{pad_char}"
        i = i + 1

    var pad_rope = rope_create_from_string(padding)
    rope_concat(node, pad_rope)

fn rope_center(node: any, total_len: i64, pad_char: text) -> any:
    # Center rope with padding
    var len = rope_length(node)
    if len >= total_len:
        return node

    var total_pad = total_len - len
    var left_pad = total_pad / 2
    var right_pad = total_pad - left_pad

    var result = node
    result = rope_pad_left(result, len + left_pad, pad_char)
    result = rope_pad_right(result, total_len, pad_char)

    result

# ============================================================================
# STATISTICS
# ============================================================================

fn rope_stats(node: any) -> any:
    # Get rope statistics as tuple
    # Returns: (length, depth, leaf_count, avg_leaf_size)
    var len = rope_length(node)
    var depth = rope_depth(node)
    var leaves = rope_to_leaf_list(node)
    var leaf_count = leaves.length()

    var total_leaf_size = 0
    var i = 0
    while i < leaf_count:
        var leaf = leaves[i]
        total_leaf_size = total_leaf_size + rope_length(leaf)
        i = i + 1

    var avg_leaf_size = 0
    if leaf_count > 0:
        avg_leaf_size = total_leaf_size / leaf_count

    (len, depth, leaf_count, avg_leaf_size)

fn rope_print_stats(node: any) -> any:
    # Print rope statistics
    var stats = rope_stats(node)
    var len = stats.0
    var depth = stats.1
    var leaf_count = stats.2
    var avg_leaf_size = stats.3

    print "Rope Statistics:"
    print "  Length: {len}"
    print "  Depth: {depth}"
    print "  Leaf count: {leaf_count}"
    print "  Avg leaf size: {avg_leaf_size}"

    nil

# ============================================================================
# VALIDATION
# ============================================================================

fn rope_validate(node: any) -> bool:
    # Validate rope structure integrity
    if node == nil:
        return true

    if rope_is_leaf(node):
        var len = node.1
        var value = node.4
        var actual_len = value.length()
        return len == actual_len

    # Validate concat node
    var weight = node.1
    var left = node.2
    var right = node.3

    if left == nil or right == nil:
        return false

    var left_len = rope_length(left)
    if weight != left_len:
        return false

    var left_valid = rope_validate(left)
    var right_valid = rope_validate(right)

    left_valid and right_valid

fn rope_debug_print(node: any, indent: i64) -> any:
    # Print rope structure for debugging
    if node == nil:
        print "{rope_indent_str(indent)}nil"
        return nil

    var indent_str = rope_indent_str(indent)

    if rope_is_leaf(node):
        var len = node.1
        var value = node.4
        print "{indent_str}Leaf(len={len}, value=\"{value}\")"
        return nil

    var weight = node.1
    print "{indent_str}Concat(weight={weight})"

    var left = node.2
    var right = node.3
    rope_debug_print(left, indent + 2)
    rope_debug_print(right, indent + 2)

    nil

fn rope_indent_str(indent: i64) -> text:
    # Helper: create indentation string
    var result = ""
    var i = 0

    while i < indent:
        result = "{result} "
        i = i + 1

    result
