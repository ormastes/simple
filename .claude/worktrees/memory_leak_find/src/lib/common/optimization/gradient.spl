# Gradient Computation Module
# Numerical gradient and Hessian computation

fn finite_difference_gradient(f: fn(List<f64>) -> f64, x: List<f64>, epsilon: f64) -> List<f64>:
    val grad = []
    val f_x = f(x)
    var i = 0
    while i < x.length():
        val x_plus = vector_copy(x)
        x_plus[i] = x_plus[i] + epsilon
        val f_plus = f(x_plus)
        val derivative = (f_plus - f_x) / epsilon
        grad.append(derivative)
        i = i + 1
    grad

fn central_difference_gradient(f: fn(List<f64>) -> f64, x: List<f64>, epsilon: f64) -> List<f64>:
    val grad = []
    var i = 0
    while i < x.length():
        val x_plus = vector_copy(x)
        val x_minus = vector_copy(x)
        x_plus[i] = x_plus[i] + epsilon
        x_minus[i] = x_minus[i] - epsilon
        val f_plus = f(x_plus)
        val f_minus = f(x_minus)
        val derivative = (f_plus - f_minus) / (2.0 * epsilon)
        grad.append(derivative)
        i = i + 1
    grad

fn numerical_hessian(f: fn(List<f64>) -> f64, x: List<f64>, epsilon: f64) -> List<List<f64>>:
    val n = x.length()
    val H = []
    var i = 0
    while i < n:
        val row = []
        var j = 0
        while j < n:
            val x_pp = vector_copy(x)
            val x_pm = vector_copy(x)
            val x_mp = vector_copy(x)
            val x_mm = vector_copy(x)

            x_pp[i] = x_pp[i] + epsilon
            x_pp[j] = x_pp[j] + epsilon

            x_pm[i] = x_pm[i] + epsilon
            x_pm[j] = x_pm[j] - epsilon

            x_mp[i] = x_mp[i] - epsilon
            x_mp[j] = x_mp[j] + epsilon

            x_mm[i] = x_mm[i] - epsilon
            x_mm[j] = x_mm[j] - epsilon

            val f_pp = f(x_pp)
            val f_pm = f(x_pm)
            val f_mp = f(x_mp)
            val f_mm = f(x_mm)

            val h_ij = (f_pp - f_pm - f_mp + f_mm) / (4.0 * epsilon * epsilon)
            row.append(h_ij)
            j = j + 1
        H.append(row)
        i = i + 1
    H
