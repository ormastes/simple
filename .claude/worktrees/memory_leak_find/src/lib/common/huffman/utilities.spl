# Huffman Utilities Module
# Compression utilities, statistics, and helper functions

import huffman.types
import huffman.tree
import huffman.codes
import huffman.encode
import huffman.decode

# ============================================================================
# COMPRESSION UTILITIES
# ============================================================================

fn huffman_bits_to_bytes(bits):
    """Convert bit string to byte array (pad with zeros)"""
    val bits_len = string_length(bits)
    val padding = 8 - bits_len % 8
    val final_padding = if padding == 8: 0 else: padding

    var padded = bits
    var p = 0
    while p < final_padding:
        padded = string_concat(padded, HUFFMAN_BIT_ZERO)
        p = p + 1

    val padded_len = string_length(padded)
    val byte_count = padded_len / 8
    var bytes = []
    var i = 0

    while i < byte_count:
        val start = i * 8
        val end = start + 8
        val byte_bits = string_substring(padded, start, end)
        val byte_val = huffman_binary_to_int(byte_bits)
        bytes = array_append(bytes, byte_val)
        i = i + 1

    bytes

fn huffman_binary_to_int(bits):
    """Convert binary string to integer"""
    var result = 0
    var i = 0
    val bits_len = string_length(bits)

    while i < bits_len:
        val bit = string_char_at(bits, i)
        result = result * 2
        if bit == HUFFMAN_BIT_ONE:
            result = result + 1
        i = i + 1

    result

fn huffman_bytes_to_bits(bytes):
    """Convert byte array to bit string"""
    var result = ""
    var i = 0
    val bytes_len = array_length(bytes)

    while i < bytes_len:
        val byte_val = array_get(bytes, i)
        val bits = huffman_int_to_binary(byte_val, 8)
        result = string_concat(result, bits)
        i = i + 1

    result

fn huffman_compression_ratio(original_size, compressed_size):
    """Calculate compression ratio"""
    if original_size == 0:
        0
    else:
        compressed_size / original_size

fn huffman_space_savings(original_size, compressed_size):
    """Calculate space savings percentage"""
    if original_size == 0:
        0
    else:
        val saved = original_size - compressed_size
        saved * 100 / original_size

# ============================================================================
# STATISTICS AND REPORTING
# ============================================================================

fn huffman_calculate_entropy(freq_table, total_symbols):
    """Calculate Shannon entropy of data"""
    var entropy = 0
    var i = 0

    while i < HUFFMAN_MAX_SYMBOLS:
        val freq = array_get(freq_table, i)
        if freq > 0:
            val prob = freq / total_symbols
            val log_prob = math_log2(prob)
            entropy = entropy - prob * log_prob
        i = i + 1

    entropy

fn huffman_compression_efficiency(avg_code_len, entropy):
    """Calculate compression efficiency (ratio of avg code length to entropy)"""
    if entropy == 0:
        0
    else:
        avg_code_len / entropy

fn huffman_total_data_size(data):
    """Get total size of data in bytes"""
    string_length(data)

fn huffman_compressed_bit_count(encoded_bits):
    """Get bit count of encoded data"""
    string_length(encoded_bits)

fn huffman_compressed_byte_count(encoded_bits):
    """Get byte count of encoded data (with padding)"""
    val bit_count = string_length(encoded_bits)
    val byte_count = bit_count / 8
    val remainder = bit_count % 8
    if remainder > 0:
        byte_count + 1
    else:
        byte_count

fn huffman_calculate_redundancy(avg_code_len, entropy):
    """Calculate coding redundancy"""
    avg_code_len - entropy

fn huffman_theoretical_compression_limit(entropy):
    """Calculate theoretical compression limit based on entropy"""
    entropy

fn huffman_actual_compression_achieved(original_bits, compressed_bits):
    """Calculate actual compression achieved"""
    if original_bits == 0:
        0
    else:
        val saved = original_bits - compressed_bits
        saved / original_bits

# ============================================================================
# UTILITY HELPERS
# ============================================================================

fn huffman_create_single_symbol_tree(symbol):
    """Create tree for data with single unique symbol"""
    huffman_create_leaf(symbol, 1)

fn huffman_is_empty_tree(tree):
    """Check if tree is empty"""
    tree == nil

fn huffman_get_tree_root(tree):
    """Get root node of tree (identity function)"""
    tree

# ============================================================================
# MAIN COMPRESSION/DECOMPRESSION PIPELINE
# ============================================================================

fn huffman_compress(data):
    """Full compression pipeline with tree and encoded data"""
    val unique_count = huffman_get_unique_symbols(data)
    if unique_count == 0:
        nil
    else:
        val tree = huffman_build_tree_from_data(data)
        val code_table = huffman_build_code_table(tree)
        val encoded = huffman_encode_data(data, code_table)
        val tree_str = huffman_serialize_tree(tree)
        (tree_str, encoded)

fn huffman_decompress(tree_str, encoded):
    """Full decompression pipeline"""
    val tree = huffman_deserialize_tree(tree_str)
    if tree == nil:
        nil
    else:
        val symbols = huffman_decode(tree, encoded)
        if symbols == nil:
            nil
        else:
            huffman_symbols_to_string(symbols)

fn huffman_compress_to_bytes(data):
    """Compress data to byte array"""
    val compressed = huffman_compress(data)
    if compressed == nil:
        nil
    else:
        val tree_str = compressed[0]
        val encoded = compressed[1]
        val bytes = huffman_bits_to_bytes(encoded)
        (tree_str, bytes)

fn huffman_decompress_from_bytes(tree_str, bytes):
    """Decompress from byte array"""
    val bits = huffman_bytes_to_bits(bytes)
    huffman_decompress(tree_str, bits)
