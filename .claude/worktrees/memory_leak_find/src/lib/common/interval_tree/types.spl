# Interval Tree - Core Data Structures and Types
# Type definitions for intervals, nodes, and colors

# ============================================================================
# Interval Type
# ============================================================================

# Interval representation: (low, high, data)
# Closed intervals [low, high] with associated data value
fn interval_new(low: i64, high: i64, data: i64) -> (i64, i64, i64):
    (low, high, data)

fn interval_low(interval: (i64, i64, i64)) -> i64:
    interval.0

fn interval_high(interval: (i64, i64, i64)) -> i64:
    interval.1

fn interval_data(interval: (i64, i64, i64)) -> i64:
    interval.2

fn interval_set_data(interval: (i64, i64, i64), data: i64) -> (i64, i64, i64):
    (interval.0, interval.1, data)

# ============================================================================
# Color Constants for Red-Black Tree
# ============================================================================

fn color_red() -> i64:
    0

fn color_black() -> i64:
    1

# ============================================================================
# Node Type
# ============================================================================

# Node structure: (color, interval, max_end, left, right)
# max_end: maximum high value in subtree (augmentation)
# nil represents empty tree
fn node_new(color: i64, interval: (i64, i64, i64)) -> (i64, (i64, i64, i64), i64, any, any):
    val max_end = interval_high(interval)
    (color, interval, max_end, nil, nil)

fn node_color(node: (i64, (i64, i64, i64), i64, any, any)) -> i64:
    node.0

fn node_interval(node: (i64, (i64, i64, i64), i64, any, any)) -> (i64, i64, i64):
    node.1

fn node_max_end(node: (i64, (i64, i64, i64), i64, any, any)) -> i64:
    node.2

fn node_left(node: (i64, (i64, i64, i64), i64, any, any)) -> any:
    node.3

fn node_right(node: (i64, (i64, i64, i64), i64, any, any)) -> any:
    node.4

fn node_set_color(node: (i64, (i64, i64, i64), i64, any, any), color: i64) -> (i64, (i64, i64, i64), i64, any, any):
    (color, node.1, node.2, node.3, node.4)

fn node_set_interval(node: (i64, (i64, i64, i64), i64, any, any), interval: (i64, i64, i64)) -> (i64, (i64, i64, i64), i64, any, any):
    val new_max = compute_max_end(interval, node.3, node.4)
    (node.0, interval, new_max, node.3, node.4)

fn node_set_max_end(node: (i64, (i64, i64, i64), i64, any, any), max_end: i64) -> (i64, (i64, i64, i64), i64, any, any):
    (node.0, node.1, max_end, node.3, node.4)

fn node_set_left(node: (i64, (i64, i64, i64), i64, any, any), left: any) -> (i64, (i64, i64, i64), i64, any, any):
    val new_max = compute_max_end(node.1, left, node.4)
    (node.0, node.1, new_max, left, node.4)

fn node_set_right(node: (i64, (i64, i64, i64), i64, any, any), right: any) -> (i64, (i64, i64, i64), i64, any, any):
    val new_max = compute_max_end(node.1, node.3, right)
    (node.0, node.1, new_max, node.3, right)

fn node_set_children(node: (i64, (i64, i64, i64), i64, any, any), left: any, right: any) -> (i64, (i64, i64, i64), i64, any, any):
    val new_max = compute_max_end(node.1, left, right)
    (node.0, node.1, new_max, left, right)

# ============================================================================
# Max End Computation (Augmentation)
# ============================================================================

fn compute_max_end(interval: (i64, i64, i64), left: any, right: any) -> i64:
    val current_high = interval_high(interval)
    var max_val = current_high

    if left != nil:
        val left_node = left as (i64, (i64, i64, i64), i64, any, any)
        val left_max = node_max_end(left_node)
        if left_max > max_val:
            max_val = left_max
        else:
            ()
    else:
        ()

    if right != nil:
        val right_node = right as (i64, (i64, i64, i64), i64, any, any)
        val right_max = node_max_end(right_node)
        if right_max > max_val:
            max_val = right_max
        else:
            ()
    else:
        ()

    max_val

fn update_max_end(node: any) -> any:
    if node == nil:
        nil
    else:
        val n = node as (i64, (i64, i64, i64), i64, any, any)
        val interval = node_interval(n)
        val left = node_left(n)
        val right = node_right(n)
        val new_max = compute_max_end(interval, left, right)
        node_set_max_end(n, new_max)

# ============================================================================
# Color Helpers
# ============================================================================

fn is_red(node: any) -> bool:
    if node == nil:
        false
    else:
        val n = node as (i64, (i64, i64, i64), i64, any, any)
        val c = node_color(n)
        c == color_red()

fn is_black(node: any) -> bool:
    if node == nil:
        true
    else:
        val n = node as (i64, (i64, i64, i64), i64, any, any)
        val c = node_color(n)
        c == color_black()

# ============================================================================
# Exports
# ============================================================================

export interval_new, interval_low, interval_high, interval_data, interval_set_data
export color_red, color_black
export node_new, node_color, node_interval, node_max_end, node_left, node_right
export node_set_color, node_set_interval, node_set_max_end, node_set_left, node_set_right, node_set_children
export compute_max_end, update_max_end
export is_red, is_black
