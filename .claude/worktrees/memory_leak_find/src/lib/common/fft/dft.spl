# FFT DFT Module
# Direct Discrete Fourier Transform implementation

# ============================================================================
# Direct DFT (for any size)
# ============================================================================

fn dft(data: [(f64, f64)]) -> [(f64, f64)]:
    val n = array_len(data)
    var result = []
    var k = 0
    while k < n:
        var sum_real = 0.0
        var sum_imag = 0.0
        var m = 0
        while m < n:
            val angle = -2.0 * math_pi() * k as f64 * m as f64 / n as f64
            val twiddle = complex_exp(angle)
            val sample = array_get(data, m)
            val product = complex_mul(sample, twiddle)
            sum_real = sum_real + product.0
            sum_imag = sum_imag + product.1
            m = m + 1
        result = array_push(result, (sum_real, sum_imag))
        k = k + 1
    result

fn idft(data: [(f64, f64)]) -> [(f64, f64)]:
    val n = array_len(data)
    var result = []
    var k = 0
    while k < n:
        var sum_real = 0.0
        var sum_imag = 0.0
        var m = 0
        while m < n:
            val angle = 2.0 * math_pi() * k as f64 * m as f64 / n as f64
            val twiddle = complex_exp(angle)
            val sample = array_get(data, m)
            val product = complex_mul(sample, twiddle)
            sum_real = sum_real + product.0
            sum_imag = sum_imag + product.1
            m = m + 1
        val scaled = (sum_real / n as f64, sum_imag / n as f64)
        result = array_push(result, scaled)
        k = k + 1
    result

# ============================================================================
# Spectral Analysis
# ============================================================================

fn power_spectrum(fft_data: [(f64, f64)]) -> [f64]:
    var result = []
    var i = 0
    val n = array_len(fft_data)
    while i < n:
        val c = array_get(fft_data, i)
        val power = complex_magnitude_squared(c)
        result = array_push(result, power)
        i = i + 1
    result

fn magnitude_spectrum(fft_data: [(f64, f64)]) -> [f64]:
    var result = []
    var i = 0
    val n = array_len(fft_data)
    while i < n:
        val c = array_get(fft_data, i)
        val mag = complex_magnitude(c)
        result = array_push(result, mag)
        i = i + 1
    result

fn phase_spectrum(fft_data: [(f64, f64)]) -> [f64]:
    var result = []
    var i = 0
    val n = array_len(fft_data)
    while i < n:
        val c = array_get(fft_data, i)
        val phase = complex_phase(c)
        result = array_push(result, phase)
        i = i + 1
    result

fn power_spectral_density(fft_data: [(f64, f64)], sample_rate: f64) -> [f64]:
    val n = array_len(fft_data)
    val scale = 1.0 / (sample_rate * n as f64)
    var result = []
    var i = 0
    while i < n:
        val c = array_get(fft_data, i)
        val psd = complex_magnitude_squared(c) * scale
        result = array_push(result, psd)
        i = i + 1
    result

fn db_spectrum(fft_data: [(f64, f64)]) -> [f64]:
    var result = []
    var i = 0
    val n = array_len(fft_data)
    while i < n:
        val c = array_get(fft_data, i)
        val mag = complex_magnitude(c)
        val db = if mag > 0.0: 20.0 * math_log10(mag) else: -100.0
        result = array_push(result, db)
        i = i + 1
    result
