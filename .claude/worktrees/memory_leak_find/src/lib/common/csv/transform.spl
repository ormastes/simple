# CSV Table Transformation and Operations

# ============================================================================

fn get_row_count(table: CsvTable) -> i64:
    table.rows.length()

fn get_row(table: CsvTable, index: i64) -> list:
    val row_count = table.rows.length()
    if index < 0 or index >= row_count:
        return []
    table.rows.at(index)

fn get_first_row(table: CsvTable) -> list:
    get_row(table, 0)

fn get_last_row(table: CsvTable) -> list:
    val row_count = table.rows.length()
    if row_count == 0:
        return []
    val last_index = row_count - 1
    get_row(table, last_index)

fn slice_rows(table: CsvTable, start: i64, end: i64) -> CsvTable:
    var sliced = []
    var i = start
    val row_count = table.rows.length()
    val actual_end = end

    loop:
        if i >= actual_end or i >= row_count:
            break
        val row = table.rows.at(i)
        sliced = sliced.append(row)
        i = i + 1

    CsvTable(headers: table.headers, rows: sliced, config: table.config)

fn take_rows(table: CsvTable, n: i64) -> CsvTable:
    slice_rows(table, 0, n)

fn skip_rows(table: CsvTable, n: i64) -> CsvTable:
    val row_count = table.rows.length()
    slice_rows(table, n, row_count)

fn reverse_rows(table: CsvTable) -> CsvTable:
    var reversed = []
    var i = table.rows.length()
    loop:
        if i <= 0:
            break
        i = i - 1
        val row = table.rows.at(i)
        reversed = reversed.append(row)
    CsvTable(headers: table.headers, rows: reversed, config: table.config)

# ============================================================================
# Table Operations - Column Access
# ============================================================================

fn get_column_count(table: CsvTable) -> i64:
    val row_count = table.rows.length()
    if row_count == 0:
        return 0
    val first_row = table.rows.at(0)
    first_row.length()

fn find_column_index(table: CsvTable, column_name: text) -> i64:
    var i = 0
    val header_count = table.headers.length()

    loop:
        if i >= header_count:
            break
        val header = table.headers.at(i)
        if header == column_name:
            return i
        i = i + 1

    -1

fn get_column_by_index(table: CsvTable, col_index: i64) -> list:
    var column = []
    var i = 0
    val row_count = table.rows.length()

    loop:
        if i >= row_count:
            break
        val row = table.rows.at(i)
        val field_count = row.length()
        if col_index >= 0 and col_index < field_count:
            val value = row.at(col_index)
            column = column.append(value)
        else:
            column = column.append("")
        i = i + 1

    column

fn get_column_by_name(table: CsvTable, column_name: text) -> list:
    val col_index = find_column_index(table, column_name)
    if col_index == -1:
        return []
    get_column_by_index(table, col_index)

fn get_field(table: CsvTable, row_index: i64, col_index: i64) -> text:
    val row_count = table.rows.length()
    if row_index < 0 or row_index >= row_count:
        return ""
    val row = table.rows.at(row_index)
    val field_count = row.length()
    if col_index < 0 or col_index >= field_count:
        return ""
    row.at(col_index)

fn get_field_by_name(table: CsvTable, row_index: i64, column_name: text) -> text:
    val col_index = find_column_index(table, column_name)
    if col_index == -1:
        return ""
    get_field(table, row_index, col_index)

# ============================================================================
# Table Operations - Column Modifications
# ============================================================================

fn select_columns_by_indices(table: CsvTable, col_indices: list) -> CsvTable:
    var new_headers = []
    val has_headers = table.headers.length() > 0

    if has_headers:
        var i = 0
        val index_count = col_indices.length()
        loop:
            if i >= index_count:
                break
            val col_index = col_indices.at(i)
            val header_count = table.headers.length()
            if col_index >= 0 and col_index < header_count:
                val header = table.headers.at(col_index)
                new_headers = new_headers.append(header)
            i = i + 1

    var new_rows = []
    var row_i = 0
    val row_count = table.rows.length()
    loop:
        if row_i >= row_count:
            break
        val row = table.rows.at(row_i)
        var new_row = []
        var col_i = 0
        val index_count = col_indices.length()
        loop:
            if col_i >= index_count:
                break
            val col_index = col_indices.at(col_i)
            val field_count = row.length()
            if col_index >= 0 and col_index < field_count:
                val field = row.at(col_index)
                new_row = new_row.append(field)
            else:
                new_row = new_row.append("")
            col_i = col_i + 1
        new_rows = new_rows.append(new_row)
        row_i = row_i + 1

    CsvTable(headers: new_headers, rows: new_rows, config: table.config)

fn select_columns_by_names(table: CsvTable, column_names: list) -> CsvTable:
    var col_indices = []
    var i = 0
    val name_count = column_names.length()

    loop:
        if i >= name_count:
            break
        val column_name = column_names.at(i)
        val col_index = find_column_index(table, column_name)
        if col_index != -1:
            col_indices = col_indices.append(col_index)
        i = i + 1

    select_columns_by_indices(table, col_indices)

fn add_column(table: CsvTable, column_name: text, values: list) -> CsvTable:
    var new_headers = table.headers
    val has_headers = table.headers.length() > 0
    if has_headers:
        new_headers = new_headers.append(column_name)

    var new_rows = []
    var i = 0
    val row_count = table.rows.length()

    loop:
        if i >= row_count:
            break
        val row = table.rows.at(i)
        var new_row = row
        val value_count = values.length()
        if i < value_count:
            val value = values.at(i)
            new_row = new_row.append(value)
        else:
            new_row = new_row.append("")
        new_rows = new_rows.append(new_row)
        i = i + 1

    CsvTable(headers: new_headers, rows: new_rows, config: table.config)

fn remove_column_by_index(table: CsvTable, col_index: i64) -> CsvTable:
    var new_headers = []
    val has_headers = table.headers.length() > 0

    if has_headers:
        var i = 0
        val header_count = table.headers.length()
        loop:
            if i >= header_count:
                break
            if i != col_index:
                val header = table.headers.at(i)
                new_headers = new_headers.append(header)
            i = i + 1

    var new_rows = []
    var row_i = 0
    val row_count = table.rows.length()
    loop:
        if row_i >= row_count:
            break
        val row = table.rows.at(row_i)
        var new_row = []
        var col_i = 0
        val field_count = row.length()
        loop:
            if col_i >= field_count:
                break
            if col_i != col_index:
                val field = row.at(col_i)
                new_row = new_row.append(field)
            col_i = col_i + 1
        new_rows = new_rows.append(new_row)
        row_i = row_i + 1

    CsvTable(headers: new_headers, rows: new_rows, config: table.config)

fn remove_column_by_name(table: CsvTable, column_name: text) -> CsvTable:
    val col_index = find_column_index(table, column_name)
    if col_index == -1:
        return table
    remove_column_by_index(table, col_index)

fn rename_column(table: CsvTable, old_name: text, new_name: text) -> CsvTable:
    val col_index = find_column_index(table, old_name)
    if col_index == -1:
        return table

    var new_headers = []
    var i = 0
    val header_count = table.headers.length()
    loop:
        if i >= header_count:
            break
        if i == col_index:
            new_headers = new_headers.append(new_name)
        else:
            val header = table.headers.at(i)
            new_headers = new_headers.append(header)
        i = i + 1

    CsvTable(headers: new_headers, rows: table.rows, config: table.config)

# ============================================================================
# Data Validation
# ============================================================================

fn validate_row_length(row: list, expected_length: i64) -> bool:
    val actual_length = row.length()
    actual_length == expected_length

fn validate_table_uniform_rows(table: CsvTable) -> bool:
    val row_count = table.rows.length()
    if row_count == 0:
        return true

    val first_row = table.rows.at(0)
    val expected_length = first_row.length()

    var i = 1
    loop:
        if i >= row_count:
            break
        val row = table.rows.at(i)
        val is_valid = validate_row_length(row, expected_length)
        if not is_valid:
            return false
        i = i + 1

    true

fn validate_headers_match_columns(table: CsvTable) -> bool:
    val header_count = table.headers.length()
    if header_count == 0:
        return true
    val col_count = get_column_count(table)
    header_count == col_count

fn is_numeric_field(field: text) -> bool:
    val trimmed = trim_whitespace(field)
    val len = trimmed.length()
    if len == 0:
        return false

    var i = 0
    var has_digit = false
    var has_dot = false

    loop:
        if i >= len:
            break
        val c = char_at(trimmed, i)
        val is_minus = c == "-"
        val is_plus = c == "+"
        val is_dot = c == "."
        val is_digit = c >= "0" and c <= "9"

        if is_minus or is_plus:
            if i != 0:
                return false
        else:
            if is_dot:
                if has_dot:
                    return false
                has_dot = true
            else:
                if is_digit:
                    has_digit = true
                else:
                    return false
        i = i + 1

    has_digit

fn validate_column_numeric(table: CsvTable, col_index: i64) -> bool:
    var i = 0
    val row_count = table.rows.length()

    loop:
        if i >= row_count:
            break
        val row = table.rows.at(i)
        val field_count = row.length()
        if col_index >= 0 and col_index < field_count:
            val field = row.at(col_index)
            val is_num = is_numeric_field(field)
            if not is_num:
                return false
        i = i + 1

    true

fn validate_column_not_empty(table: CsvTable, col_index: i64) -> bool:
    var i = 0
    val row_count = table.rows.length()

    loop:
        if i >= row_count:
            break
        val row = table.rows.at(i)
        val field_count = row.length()
        if col_index >= 0 and col_index < field_count:
            val field = row.at(col_index)
            val trimmed = trim_whitespace(field)
            val len = trimmed.length()
            if len == 0:
                return false
        i = i + 1

    true

fn validate_row_not_empty(table: CsvTable, row_index: i64) -> bool:
    val row = get_row(table, row_index)
    val field_count = row.length()
    var i = 0
    loop:
        if i >= field_count:
            break
        val field = row.at(i)
        val trimmed = trim_whitespace(field)
        val len = trimmed.length()
        if len > 0:
            return true
        i = i + 1
    false

# ============================================================================
# Delimiter Detection
# ============================================================================

fn count_char_occurrences(s: text, c: text) -> i64:
    var count = 0
    var i = 0
    val len = s.length()

    loop:
        if i >= len:
            break
        val current = char_at(s, i)
        if current == c:
            count = count + 1
        i = i + 1

    count

fn detect_delimiter_in_line(line: text) -> text:
    val comma_count = count_char_occurrences(line, ",")
    val tab_count = count_char_occurrences(line, "\t")
    val semicolon_count = count_char_occurrences(line, ";")
    val pipe_count = count_char_occurrences(line, "|")

    var max_count = comma_count
    var delimiter = ","

    if tab_count > max_count:
        max_count = tab_count
        delimiter = "\t"

    if semicolon_count > max_count:
        max_count = semicolon_count
        delimiter = ";"

    if pipe_count > max_count:
        max_count = pipe_count
        delimiter = "|"

    delimiter

fn detect_delimiter(content: text) -> text:
    val lines = split_lines(content)
    val line_count = lines.length()
    if line_count == 0:
        return ","

    val first_line = lines.at(0)
    detect_delimiter_in_line(first_line)

# ============================================================================
# Advanced Parsing Options
# ============================================================================

fn parse_tsv(content: text) -> CsvTable:
    parse_csv_with_delimiter(content, "\t")

fn parse_ssv(content: text) -> CsvTable:
    parse_csv_with_delimiter(content, ";")

fn parse_psv(content: text) -> CsvTable:
    parse_csv_with_delimiter(content, "|")

fn parse_csv_auto_delimiter(content: text) -> CsvTable:
    val delimiter = detect_delimiter(content)
    parse_csv_with_delimiter(content, delimiter)

fn create_config_with_trim(delimiter: text, should_trim: bool) -> CsvConfig:
    val base = default_csv_config()
    CsvConfig(
        delimiter: delimiter,
        quote_char: base.quote_char,
        escape_char: base.escape_char,
        line_ending: base.line_ending,
        trim_whitespace: should_trim,
        skip_empty_lines: base.skip_empty_lines
    )

fn parse_csv_with_trim(content: text, should_trim: bool) -> CsvTable:
    val config = create_config_with_trim(",", should_trim)
    parse_csv_string(content, config)

fn create_config_skip_empty(delimiter: text, skip_empty: bool) -> CsvConfig:
    val base = default_csv_config()
    CsvConfig(
        delimiter: delimiter,
        quote_char: base.quote_char,
        escape_char: base.escape_char,
        line_ending: base.line_ending,
        trim_whitespace: base.trim_whitespace,
        skip_empty_lines: skip_empty
    )

fn parse_csv_skip_empty_lines(content: text) -> CsvTable:
    val config = create_config_skip_empty(",", true)
    parse_csv_string(content, config)

# ============================================================================
# Table Transformation
# ============================================================================

fn transpose_table(table: CsvTable) -> CsvTable:
    val row_count = table.rows.length()
    if row_count == 0:
        val empty_headers = []
        val empty_rows = []
        return CsvTable(headers: empty_headers, rows: empty_rows, config: table.config)

    val col_count = get_column_count(table)
    var new_rows = []

    var col_i = 0
    loop:
        if col_i >= col_count:
            break
        var new_row = []
        var row_i = 0
        loop:
            if row_i >= row_count:
                break
            val row = table.rows.at(row_i)
            val field_count = row.length()
            if col_i < field_count:
                val field = row.at(col_i)
                new_row = new_row.append(field)
            else:
                new_row = new_row.append("")
            row_i = row_i + 1
        new_rows = new_rows.append(new_row)
        col_i = col_i + 1

    val empty_headers = []
    CsvTable(headers: empty_headers, rows: new_rows, config: table.config)

fn merge_tables_vertical(table1: CsvTable, table2: CsvTable) -> CsvTable:
    var merged_rows = []
    var i = 0
    val row_count1 = table1.rows.length()
    loop:
        if i >= row_count1:
            break
        val row = table1.rows.at(i)
        merged_rows = merged_rows.append(row)
        i = i + 1

    var j = 0
    val row_count2 = table2.rows.length()
    loop:
        if j >= row_count2:
            break
        val row = table2.rows.at(j)
        merged_rows = merged_rows.append(row)
        j = j + 1

    CsvTable(headers: table1.headers, rows: merged_rows, config: table1.config)

