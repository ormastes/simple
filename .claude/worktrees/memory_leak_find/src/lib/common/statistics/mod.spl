# statistics/mod.spl - Statistics Module Facade
#
# Provides statistical functions for data analysis including:
# - Descriptive statistics (mean, median, mode, quartiles, percentiles)
# - Measures of spread (variance, standard deviation, MAD, CV)
# - Measures of shape (skewness, kurtosis)
# - Correlation analysis (Pearson, Spearman, Kendall)
# - Regression analysis (linear regression, R-squared)
# - Probability distributions (normal, uniform, binomial, Poisson)
# - Statistical tests (t-test, chi-square, z-score)
# - Data transformations (normalization, standardization, log)
# - Frequency analysis (frequency tables, histogram bins)
# - Moving statistics (moving average, exponential moving average)
# - Utility functions (sum, product, cumulative operations)

import types from "./types"
import utilities from "./utilities"
import descriptive from "./descriptive"
import distributions from "./distributions"
import correlation from "./correlation"
import regression from "./regression"
import inference from "./inference"

# ============================================================================
# RE-EXPORT CONSTANTS (TYPES)
# ============================================================================

val EPSILON = types.EPSILON
val PI = types.PI
val E = types.E
val SQRT_2PI = types.SQRT_2PI

# ============================================================================
# RE-EXPORT UTILITIES
# ============================================================================

fn sum(data: List<f64>) -> f64:
    utilities.sum(data)

fn product(data: List<f64>) -> f64:
    utilities.product(data)

fn count(data: List<f64>) -> i64:
    utilities.count(data)

fn count_non_zero(data: List<f64>) -> i64:
    utilities.count_non_zero(data)

fn cumsum(data: List<f64>) -> List<f64>:
    utilities.cumsum(data)

fn cumprod(data: List<f64>) -> List<f64>:
    utilities.cumprod(data)

fn diff(data: List<f64>) -> List<f64>:
    utilities.diff(data)

fn pct_change(data: List<f64>) -> List<f64>:
    utilities.pct_change(data)

fn clip(data: List<f64>, min_val: f64, max_val: f64) -> List<f64>:
    utilities.clip(data, min_val, max_val)

fn interpolate_linear(x: f64, x0: f64, y0: f64, x1: f64, y1: f64) -> f64:
    utilities.interpolate_linear(x, x0, y0, x1, y1)

fn sample_with_replacement(data: List<f64>, size: i64, seed: i64) -> List<f64>:
    utilities.sample_with_replacement(data, size, seed)

fn factorial(n: i64) -> f64:
    utilities.factorial(n)

fn binomial_coefficient(n: i64, k: i64) -> f64:
    utilities.binomial_coefficient(n, k)

fn rank_data(data: List<f64>) -> List<f64>:
    utilities.rank_data(data)

fn frequency_table(data: List<f64>) -> List<List<f64>>:
    utilities.frequency_table(data)

fn histogram_bins(data: List<f64>, num_bins: i64) -> Option<List<f64>>:
    utilities.histogram_bins(data, num_bins)

fn relative_frequency(data: List<f64>) -> List<List<f64>>:
    utilities.relative_frequency(data)

fn min_value(data: List<f64>) -> Option<f64>:
    utilities.min_value(data)

fn max_value(data: List<f64>) -> Option<f64>:
    utilities.max_value(data)

fn entropy(probabilities: List<f64>) -> Option<f64>:
    utilities.entropy(probabilities)

fn gini_impurity(probabilities: List<f64>) -> Option<f64>:
    utilities.gini_impurity(probabilities)

fn mean_squared_error(actual: List<f64>, predicted: List<f64>) -> Option<f64>:
    utilities.mean_squared_error(actual, predicted)

fn root_mean_squared_error(actual: List<f64>, predicted: List<f64>) -> Option<f64>:
    utilities.root_mean_squared_error(actual, predicted)

fn mean_absolute_error(actual: List<f64>, predicted: List<f64>) -> Option<f64>:
    utilities.mean_absolute_error(actual, predicted)

fn mean_absolute_percentage_error(actual: List<f64>, predicted: List<f64>) -> Option<f64>:
    utilities.mean_absolute_percentage_error(actual, predicted)

# ============================================================================
# RE-EXPORT DESCRIPTIVE STATISTICS
# ============================================================================

fn mean(data: List<f64>) -> Option<f64>:
    descriptive.mean(data)

fn geometric_mean(data: List<f64>) -> Option<f64>:
    descriptive.geometric_mean(data)

fn harmonic_mean(data: List<f64>) -> Option<f64>:
    descriptive.harmonic_mean(data)

fn median(data: List<f64>) -> Option<f64>:
    descriptive.median(data)

fn mode(data: List<f64>) -> Option<f64>:
    descriptive.mode(data)

fn range_value(data: List<f64>) -> Option<f64>:
    descriptive.range_value(data)

fn quantile(data: List<f64>, q: f64) -> Option<f64>:
    descriptive.quantile(data, q)

fn percentile(data: List<f64>, p: f64) -> Option<f64>:
    descriptive.percentile(data, p)

fn quartile_1(data: List<f64>) -> Option<f64>:
    descriptive.quartile_1(data)

fn quartile_2(data: List<f64>) -> Option<f64>:
    descriptive.quartile_2(data)

fn quartile_3(data: List<f64>) -> Option<f64>:
    descriptive.quartile_3(data)

fn iqr(data: List<f64>) -> Option<f64>:
    descriptive.iqr(data)

fn variance(data: List<f64>) -> Option<f64>:
    descriptive.variance(data)

fn variance_sample(data: List<f64>) -> Option<f64>:
    descriptive.variance_sample(data)

fn stddev(data: List<f64>) -> Option<f64>:
    descriptive.stddev(data)

fn stddev_sample(data: List<f64>) -> Option<f64>:
    descriptive.stddev_sample(data)

fn mad(data: List<f64>) -> Option<f64>:
    descriptive.mad(data)

fn median_absolute_deviation(data: List<f64>) -> Option<f64>:
    descriptive.median_absolute_deviation(data)

fn coefficient_of_variation(data: List<f64>) -> Option<f64>:
    descriptive.coefficient_of_variation(data)

fn standard_error(data: List<f64>) -> Option<f64>:
    descriptive.standard_error(data)

fn skewness(data: List<f64>) -> Option<f64>:
    descriptive.skewness(data)

fn kurtosis(data: List<f64>) -> Option<f64>:
    descriptive.kurtosis(data)

fn trimmed_mean(data: List<f64>, trim_pct: f64) -> Option<f64>:
    descriptive.trimmed_mean(data, trim_pct)

fn moment(data: List<f64>, order: i64) -> Option<f64>:
    descriptive.moment(data, order)

fn weighted_mean(values: List<f64>, weights: List<f64>) -> Option<f64>:
    descriptive.weighted_mean(values, weights)

fn weighted_variance(values: List<f64>, weights: List<f64>) -> Option<f64>:
    descriptive.weighted_variance(values, weights)

fn winsorize(data: List<f64>, lower_pct: f64, upper_pct: f64) -> Option<List<f64>>:
    descriptive.winsorize(data, lower_pct, upper_pct)

fn remove_outliers(data: List<f64>, num_stddev: f64) -> Option<List<f64>>:
    descriptive.remove_outliers(data, num_stddev)

fn detect_outliers_iqr(data: List<f64>, multiplier: f64) -> Option<List<bool>>:
    descriptive.detect_outliers_iqr(data, multiplier)

fn expanding_mean(data: List<f64>) -> Option<List<f64>>:
    descriptive.expanding_mean(data)

fn expanding_stddev(data: List<f64>) -> Option<List<f64>>:
    descriptive.expanding_stddev(data)

fn moving_average(data: List<f64>, window: i64) -> Option<List<f64>>:
    descriptive.moving_average(data, window)

fn exponential_moving_average(data: List<f64>, alpha: f64) -> Option<List<f64>>:
    descriptive.exponential_moving_average(data, alpha)

fn weighted_moving_average(data: List<f64>, weights: List<f64>) -> Option<List<f64>>:
    descriptive.weighted_moving_average(data, weights)

fn moving_stddev(data: List<f64>, window: i64) -> Option<List<f64>>:
    descriptive.moving_stddev(data, window)

fn moving_min(data: List<f64>, window: i64) -> Option<List<f64>>:
    descriptive.moving_min(data, window)

fn moving_max(data: List<f64>, window: i64) -> Option<List<f64>>:
    descriptive.moving_max(data, window)

fn rolling_sum(data: List<f64>, window: i64) -> Option<List<f64>>:
    descriptive.rolling_sum(data, window)

# ============================================================================
# RE-EXPORT DISTRIBUTIONS
# ============================================================================

fn erf(x: f64) -> f64:
    distributions.erf(x)

fn normal_pdf(x: f64, mu: f64, sigma: f64) -> f64:
    distributions.normal_pdf(x, mu, sigma)

fn normal_cdf(x: f64, mu: f64, sigma: f64) -> f64:
    distributions.normal_cdf(x, mu, sigma)

fn uniform_pdf(x: f64, a: f64, b: f64) -> f64:
    distributions.uniform_pdf(x, a, b)

fn uniform_cdf(x: f64, a: f64, b: f64) -> f64:
    distributions.uniform_cdf(x, a, b)

fn binomial_pmf(k: i64, n: i64, p: f64) -> f64:
    distributions.binomial_pmf(k, n, p)

fn poisson_pmf(k: i64, lambda: f64) -> f64:
    distributions.poisson_pmf(k, lambda)

# ============================================================================
# RE-EXPORT CORRELATION
# ============================================================================

fn covariance(x: List<f64>, y: List<f64>) -> Option<f64>:
    correlation.covariance(x, y)

fn covariance_sample(x: List<f64>, y: List<f64>) -> Option<f64>:
    correlation.covariance_sample(x, y)

fn correlation_pearson(x: List<f64>, y: List<f64>) -> Option<f64>:
    correlation.correlation_pearson(x, y)

fn correlation_spearman(x: List<f64>, y: List<f64>) -> Option<f64>:
    correlation.correlation_spearman(x, y)

fn correlation_kendall(x: List<f64>, y: List<f64>) -> Option<f64>:
    correlation.correlation_kendall(x, y)

fn autocorrelation(data: List<f64>, lag: i64) -> Option<f64>:
    correlation.autocorrelation(data, lag)

fn cross_correlation(x: List<f64>, y: List<f64>, lag: i64) -> Option<f64>:
    correlation.cross_correlation(x, y, lag)

# ============================================================================
# RE-EXPORT REGRESSION
# ============================================================================

fn linear_regression(x: List<f64>, y: List<f64>) -> Option<List<f64>>:
    regression.linear_regression(x, y)

fn r_squared(x: List<f64>, y: List<f64>) -> Option<f64>:
    regression.r_squared(x, y)

fn residuals(x: List<f64>, y: List<f64>) -> Option<List<f64>>:
    regression.residuals(x, y)

# ============================================================================
# RE-EXPORT INFERENCE
# ============================================================================

fn z_score(x: f64, mu: f64, sigma: f64) -> Option<f64>:
    inference.z_score(x, mu, sigma)

fn z_scores(data: List<f64>) -> Option<List<f64>>:
    inference.z_scores(data)

fn t_statistic(sample: List<f64>, pop_mean: f64) -> Option<f64>:
    inference.t_statistic(sample, pop_mean)

fn t_statistic_two_sample(x: List<f64>, y: List<f64>) -> Option<f64>:
    inference.t_statistic_two_sample(x, y)

fn chi_square_statistic(observed: List<f64>, expected: List<f64>) -> Option<f64>:
    inference.chi_square_statistic(observed, expected)

fn confidence_interval_mean(data: List<f64>, confidence: f64) -> Option<List<f64>>:
    inference.confidence_interval_mean(data, confidence)

fn bootstrap_mean(data: List<f64>, num_samples: i64, seed: i64) -> Option<List<f64>>:
    inference.bootstrap_mean(data, num_samples, seed)

fn normalize(data: List<f64>) -> Option<List<f64>>:
    inference.normalize(data)

fn standardize(data: List<f64>) -> Option<List<f64>>:
    inference.standardize(data)

fn log_transform(data: List<f64>) -> Option<List<f64>>:
    inference.log_transform(data)

fn log10_transform(data: List<f64>) -> Option<List<f64>>:
    inference.log10_transform(data)

fn sqrt_transform(data: List<f64>) -> Option<List<f64>>:
    inference.sqrt_transform(data)

fn box_cox_transform(data: List<f64>, lambda: f64) -> Option<List<f64>>:
    inference.box_cox_transform(data, lambda)
