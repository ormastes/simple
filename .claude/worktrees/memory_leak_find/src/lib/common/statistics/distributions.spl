# statistics/distributions.spl - Probability distribution functions

import math from "std/math"
import types from "./types"
import utilities from "./utilities"

# ============================================================================
# PROBABILITY DISTRIBUTIONS
# ============================================================================

fn erf(x: f64) -> f64:
    """Error function (approximation)."""
    val sign = if x >= 0.0: 1.0 else: -1.0
    val abs_x = math.abs(x)

    val a1 = 0.254829592
    val a2 = -0.284496736
    val a3 = 1.421413741
    val a4 = -1.453152027
    val a5 = 1.061405429
    val p = 0.3275911

    val t = 1.0 / (1.0 + p * abs_x)
    val t2 = t * t
    val t3 = t2 * t
    val t4 = t3 * t
    val t5 = t4 * t

    val poly = a1 * t + a2 * t2 + a3 * t3 + a4 * t4 + a5 * t5
    val result = 1.0 - poly * math.exp(-abs_x * abs_x)

    sign * result

fn normal_pdf(x: f64, mu: f64, sigma: f64) -> f64:
    """Normal distribution probability density function."""
    if sigma < types.EPSILON:
        return 0.0

    val z = (x - mu) / sigma
    val exp_term = math.exp(-0.5 * z * z)
    exp_term / (sigma * types.SQRT_2PI)

fn normal_cdf(x: f64, mu: f64, sigma: f64) -> f64:
    """Normal distribution cumulative distribution function (approximation)."""
    if sigma < types.EPSILON:
        return 0.0

    val z = (x - mu) / (sigma * math.sqrt(2.0))
    0.5 * (1.0 + erf(z))

fn uniform_pdf(x: f64, a: f64, b: f64) -> f64:
    """Uniform distribution probability density function."""
    if x < a or x > b:
        return 0.0

    if b - a < types.EPSILON:
        return 0.0

    1.0 / (b - a)

fn uniform_cdf(x: f64, a: f64, b: f64) -> f64:
    """Uniform distribution cumulative distribution function."""
    if x < a:
        return 0.0

    if x > b:
        return 1.0

    if b - a < types.EPSILON:
        return 0.0

    (x - a) / (b - a)

fn binomial_pmf(k: i64, n: i64, p: f64) -> f64:
    """Binomial distribution probability mass function."""
    if k < 0 or k > n or n < 0:
        return 0.0

    if p < 0.0 or p > 1.0:
        return 0.0

    val binom_coef = utilities.binomial_coefficient(n, k)
    val pk = math.pow(p, k)
    val p1k = math.pow(1.0 - p, n - k)

    binom_coef * pk * p1k

fn poisson_pmf(k: i64, lambda: f64) -> f64:
    """Poisson distribution probability mass function."""
    if k < 0 or lambda < 0.0:
        return 0.0

    val exp_term = math.exp(-lambda)
    val lambda_k = math.pow(lambda, k)
    val k_fact = utilities.factorial(k)

    exp_term * lambda_k / k_fact
