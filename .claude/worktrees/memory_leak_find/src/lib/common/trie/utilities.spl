# Trie Utility Operations
#
# Utility functions for trie properties, conversion, set operations, and validation.

# Returns the number of words in the trie
# Args:
#   trie: The trie root node
# Returns: Count of words
fn trie_size(trie):
    var count = 0
    trie_count_words(trie, count)

# Helper function to count words in the trie
# Args:
#   node: Current trie node
#   count: Current count (passed by value, need to sum results)
# Returns: Total count of words from this node
fn trie_count_words(node, count):
    var total = count
    if node["is_end"]:
        total = total + 1

    var children = node["children"]
    var keys = children.keys()
    var i = 0
    var len = keys.length()

    while i < len:
        var ch = keys[i]
        var child = children[ch]
        total = trie_count_words(child, total)
        i = i + 1

    total

# Checks if the trie is empty
# Args:
#   trie: The trie root node
# Returns: true if trie has no words, false otherwise
fn trie_is_empty(trie):
    var children = trie["children"]
    children.size() == 0

# Returns the maximum depth of the trie
# Args:
#   trie: The trie root node
# Returns: Maximum depth (longest word length)
fn trie_depth(trie):
    trie_max_depth(trie, 0)

# Helper function to find maximum depth
# Args:
#   node: Current trie node
#   current_depth: Current depth level
# Returns: Maximum depth from this node
fn trie_max_depth(node, current_depth):
    var children = node["children"]
    if children.size() == 0:
        return current_depth

    var max = current_depth
    var keys = children.keys()
    var i = 0
    var len = keys.length()

    while i < len:
        var ch = keys[i]
        var child = children[ch]
        var depth = trie_max_depth(child, current_depth + 1)
        if depth > max:
            max = depth
        i = i + 1

    max

# Returns the minimum depth where a word ends
# Args:
#   trie: The trie root node
# Returns: Minimum depth (shortest word length), or 0 if empty
fn trie_min_depth(trie):
    trie_min_depth_helper(trie, 0)

# Helper function to find minimum depth
# Args:
#   node: Current trie node
#   current_depth: Current depth level
# Returns: Minimum depth from this node, or very large number if no words
fn trie_min_depth_helper(node, current_depth):
    if node["is_end"]:
        return current_depth

    var children = node["children"]
    if children.size() == 0:
        return 999999

    var min = 999999
    var keys = children.keys()
    var i = 0
    var len = keys.length()

    while i < len:
        var ch = keys[i]
        var child = children[ch]
        var depth = trie_min_depth_helper(child, current_depth + 1)
        if depth < min:
            min = depth
        i = i + 1

    min

# Finds the shortest word in the trie
# Args:
#   trie: The trie root node
# Returns: Shortest word, or nil if trie is empty
fn trie_shortest_word(trie):
    var words = trie_all_words(trie)
    if words.length() == 0:
        return nil

    var shortest = words[0]
    var shortest_len = shortest.length()
    var i = 1
    var len = words.length()

    while i < len:
        var word = words[i]
        var word_len = word.length()
        if word_len < shortest_len:
            shortest = word
            shortest_len = word_len
        i = i + 1

    shortest

# Finds the longest word in the trie
# Args:
#   trie: The trie root node
# Returns: Longest word, or nil if trie is empty
fn trie_longest_word(trie):
    var words = trie_all_words(trie)
    if words.length() == 0:
        return nil

    var longest = words[0]
    var longest_len = longest.length()
    var i = 1
    var len = words.length()

    while i < len:
        var word = words[i]
        var word_len = word.length()
        if word_len > longest_len:
            longest = word
            longest_len = word_len
        i = i + 1

    longest

# Merges two tries into a new trie
# Args:
#   trie1: First trie
#   trie2: Second trie
# Returns: New trie containing all words from both tries
fn trie_merge(trie1, trie2):
    var result = trie_create()
    var words1 = trie_all_words(trie1)
    var words2 = trie_all_words(trie2)

    var i = 0
    var len1 = words1.length()
    while i < len1:
        trie_insert(result, words1[i])
        i = i + 1

    var j = 0
    var len2 = words2.length()
    while j < len2:
        trie_insert(result, words2[j])
        j = j + 1

    result

# Creates a trie from a list of words
# Args:
#   words: List of strings to insert
# Returns: New trie containing all words
fn trie_from_list(words):
    var trie = trie_create()
    var i = 0
    var len = words.length()

    while i < len:
        trie_insert(trie, words[i])
        i = i + 1

    trie

# Converts a trie to a list of words
# Args:
#   trie: The trie root node
# Returns: List of all words in the trie
fn trie_to_list(trie):
    trie_all_words(trie)

# Clears all words from the trie
# Args:
#   trie: The trie root node
# Returns: nil
fn trie_clear(trie):
    trie["children"] = {}
    trie["is_end"] = false
    nil

# Gets the number of children of the root node
# Args:
#   trie: The trie root node
# Returns: Number of direct children
fn trie_branch_count(trie):
    var children = trie["children"]
    children.size()

# Finds all words of a specific length
# Args:
#   trie: The trie root node
#   length: Desired word length
# Returns: List of words with the specified length
fn trie_words_of_length(trie, length):
    var all_words = trie_all_words(trie)
    var results = []
    var i = 0
    var len = all_words.length()

    while i < len:
        var word = all_words[i]
        if word.length() == length:
            results.append(word)
        i = i + 1

    results

# Finds all words within a length range
# Args:
#   trie: The trie root node
#   min_len: Minimum word length (inclusive)
#   max_len: Maximum word length (inclusive)
# Returns: List of words within the length range
fn trie_words_in_range(trie, min_len, max_len):
    var all_words = trie_all_words(trie)
    var results = []
    var i = 0
    var len = all_words.length()

    while i < len:
        var word = all_words[i]
        var word_len = word.length()
        if word_len >= min_len and word_len <= max_len:
            results.append(word)
        i = i + 1

    results

# Counts the total number of nodes in the trie
# Args:
#   trie: The trie root node
# Returns: Total number of nodes (including root)
fn trie_node_count(trie):
    trie_count_nodes_helper(trie)

# Helper function to count all nodes
# Args:
#   node: Current trie node
# Returns: Total number of nodes from this node (inclusive)
fn trie_count_nodes_helper(node):
    var count = 1
    var children = node["children"]
    var keys = children.keys()
    var i = 0
    var len = keys.length()

    while i < len:
        var ch = keys[i]
        var child = children[ch]
        count = count + trie_count_nodes_helper(child)
        i = i + 1

    count

# Converts trie to a simple string representation (all words separated by newlines)
# Args:
#   trie: The trie root node
# Returns: String with all words, one per line
fn trie_to_string(trie):
    var words = trie_all_words(trie)
    var result = ""
    var i = 0
    var len = words.length()

    while i < len:
        result = result + words[i]
        if i < len - 1:
            result = result + "\n"
        i = i + 1

    result

# Creates a trie from a string with words separated by newlines
# Args:
#   str: String containing words separated by newlines
# Returns: New trie containing all words
fn trie_from_string(str):
    var trie = trie_create()
    var lines = str.split("\n")
    var i = 0
    var len = lines.length()

    while i < len:
        var line = lines[i].trim()
        if line.length() > 0:
            trie_insert(trie, line)
        i = i + 1

    trie

# Computes the average word length in the trie
# Args:
#   trie: The trie root node
# Returns: Average word length as floating point
fn trie_average_word_length(trie):
    var words = trie_all_words(trie)
    var count = words.length()
    if count == 0:
        return 0

    var total = 0
    var i = 0

    while i < count:
        total = total + words[i].length()
        i = i + 1

    total / count

# Gets frequency distribution of word lengths
# Args:
#   trie: The trie root node
# Returns: Dictionary mapping length to count
fn trie_length_distribution(trie):
    var words = trie_all_words(trie)
    var distribution = {}
    var i = 0
    var len = words.length()

    while i < len:
        var word_len = words[i].length()
        if not distribution.has_key(word_len):
            distribution[word_len] = 0
        distribution[word_len] = distribution[word_len] + 1
        i = i + 1

    distribution

# Computes intersection of two tries (words in both)
# Args:
#   trie1: First trie
#   trie2: Second trie
# Returns: New trie containing only common words
fn trie_intersection(trie1, trie2):
    var result = trie_create()
    var words1 = trie_all_words(trie1)
    var i = 0
    var len = words1.length()

    while i < len:
        var word = words1[i]
        if trie_contains(trie2, word):
            trie_insert(result, word)
        i = i + 1

    result

# Computes union of two tries (words in either)
# Args:
#   trie1: First trie
#   trie2: Second trie
# Returns: New trie containing all words from both tries
fn trie_union(trie1, trie2):
    trie_merge(trie1, trie2)

# Computes difference of two tries (words in first but not second)
# Args:
#   trie1: First trie
#   trie2: Second trie
# Returns: New trie containing words only in first trie
fn trie_difference(trie1, trie2):
    var result = trie_create()
    var words1 = trie_all_words(trie1)
    var i = 0
    var len = words1.length()

    while i < len:
        var word = words1[i]
        if not trie_contains(trie2, word):
            trie_insert(result, word)
        i = i + 1

    result

# Computes symmetric difference of two tries (words in either but not both)
# Args:
#   trie1: First trie
#   trie2: Second trie
# Returns: New trie containing words in exactly one trie
fn trie_symmetric_difference(trie1, trie2):
    var result = trie_create()
    var words1 = trie_all_words(trie1)
    var words2 = trie_all_words(trie2)

    var i = 0
    var len1 = words1.length()
    while i < len1:
        var word = words1[i]
        if not trie_contains(trie2, word):
            trie_insert(result, word)
        i = i + 1

    var j = 0
    var len2 = words2.length()
    while j < len2:
        var word = words2[j]
        if not trie_contains(trie1, word):
            trie_insert(result, word)
        j = j + 1

    result

# Checks if trie1 is a subset of trie2 (all words in trie1 are in trie2)
# Args:
#   trie1: First trie (potential subset)
#   trie2: Second trie (potential superset)
# Returns: true if trie1 is subset of trie2, false otherwise
fn trie_is_subset(trie1, trie2):
    var words1 = trie_all_words(trie1)
    var i = 0
    var len = words1.length()

    while i < len:
        if not trie_contains(trie2, words1[i]):
            return false
        i = i + 1

    true

# Checks if two tries are equal (contain same words)
# Args:
#   trie1: First trie
#   trie2: Second trie
# Returns: true if tries contain same words, false otherwise
fn trie_equals(trie1, trie2):
    var words1 = trie_all_words(trie1)
    var words2 = trie_all_words(trie2)

    if words1.length() != words2.length():
        return false

    trie_is_subset(trie1, trie2)

# Checks if trie structure is valid
# Args:
#   trie: The trie root node
# Returns: true if valid, false otherwise
fn trie_is_valid(trie):
    if trie == nil:
        return false
    if not trie.has_key("children"):
        return false
    if not trie.has_key("is_end"):
        return false
    trie_is_valid_helper(trie)

# Helper for validating trie structure
# Args:
#   node: Current trie node
# Returns: true if subtree is valid, false otherwise
fn trie_is_valid_helper(node):
    if not node.has_key("children"):
        return false
    if not node.has_key("is_end"):
        return false

    var children = node["children"]
    var keys = children.keys()
    var i = 0
    var len = keys.length()

    while i < len:
        var ch = keys[i]
        var child = children[ch]
        if not trie_is_valid_helper(child):
            return false
        i = i + 1

    true

# Estimates memory usage (number of nodes)
# Args:
#   trie: The trie root node
# Returns: Approximate memory usage metric
fn trie_memory_usage(trie):
    trie_node_count(trie)

# Computes compression ratio (nodes vs total characters)
# Args:
#   trie: The trie root node
# Returns: Compression ratio
fn trie_compression_ratio(trie):
    var node_count = trie_node_count(trie)
    var words = trie_all_words(trie)
    var total_chars = 0
    var i = 0
    var len = words.length()

    while i < len:
        total_chars = total_chars + words[i].length()
        i = i + 1

    if total_chars == 0:
        return 0

    node_count / total_chars

# Forward declarations (defined in other modules)
fn trie_create():
    {
        "children": {},
        "is_end": false
    }

fn trie_insert(trie, word):
    var current = trie
    var i = 0
    var len = word.length()

    while i < len:
        var ch = word.char_at(i)
        var children = current["children"]

        if not children.has_key(ch):
            children[ch] = trie_node()

        current = children[ch]
        i = i + 1

    current["is_end"] = true
    nil

fn trie_node():
    {
        "children": {},
        "is_end": false
    }

fn trie_all_words(trie):
    var results = []
    trie_collect_words(trie, "", results)
    results

fn trie_collect_words(node, current, results):
    if node["is_end"]:
        results.append(current)

    var children = node["children"]
    var keys = children.keys()
    var i = 0
    var len = keys.length()

    while i < len:
        var ch = keys[i]
        var child = children[ch]
        var next_str = current + ch
        trie_collect_words(child, next_str, results)
        i = i + 1

    nil

fn trie_contains(trie, word):
    trie_search(trie, word)

fn trie_search(trie, word):
    var node = trie_find_node(trie, word)
    if node == nil:
        false
    else:
        node["is_end"]

fn trie_find_node(trie, str):
    var current = trie
    var i = 0
    var len = str.length()

    while i < len:
        var ch = str.char_at(i)
        var children = current["children"]

        if not children.has_key(ch):
            return nil

        current = children[ch]
        i = i + 1

    current
