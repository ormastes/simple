# Persistent Dictionary
#
# Immutable dictionary with structural sharing (parallel array implementation).
# Every mutation returns a NEW dictionary â€” original is never modified.

class PersistentDict:
    dict_keys: []
    dict_values: []

    fn len() -> i64:
        self.dict_keys.len()

    fn is_empty() -> bool:
        self.dict_keys.len() == 0

    fn set(key, value) -> PersistentDict:
        var new_keys = []
        var new_values = []
        var found = false
        var idx = 0
        for k in self.dict_keys:
            if k == key:
                new_keys.push(k)
                new_values.push(value)
                found = true
            else:
                new_keys.push(k)
                new_values.push(self.dict_values[idx])
            idx = idx + 1
        if not found:
            new_keys.push(key)
            new_values.push(value)
        PersistentDict(dict_keys: new_keys, dict_values: new_values)

    fn get(key):
        var idx = 0
        for k in self.dict_keys:
            if k == key:
                return self.dict_values[idx]
            idx = idx + 1
        nil

    fn remove(key) -> PersistentDict:
        var new_keys = []
        var new_values = []
        var idx = 0
        for k in self.dict_keys:
            if k != key:
                new_keys.push(k)
                new_values.push(self.dict_values[idx])
            idx = idx + 1
        PersistentDict(dict_keys: new_keys, dict_values: new_values)

    fn contains(key) -> bool:
        for k in self.dict_keys:
            if k == key:
                return true
        false

    fn get_or(key, default_val):
        var idx = 0
        for k in self.dict_keys:
            if k == key:
                return self.dict_values[idx]
            idx = idx + 1
        default_val

    fn merge(other: PersistentDict) -> PersistentDict:
        var result = self.copy()
        var idx = 0
        for k in other.dict_keys:
            result = result.set(k, other.dict_values[idx])
            idx = idx + 1
        result

    fn filter(pred: fn()) -> PersistentDict:
        var new_keys = []
        var new_values = []
        var idx = 0
        for k in self.dict_keys:
            val v = self.dict_values[idx]
            if pred(k, v):
                new_keys.push(k)
                new_values.push(v)
            idx = idx + 1
        PersistentDict(dict_keys: new_keys, dict_values: new_values)

    fn map_values(f: fn()) -> PersistentDict:
        var new_keys = []
        var new_values = []
        var idx = 0
        for k in self.dict_keys:
            new_keys.push(k)
            new_values.push(f(self.dict_values[idx]))
            idx = idx + 1
        PersistentDict(dict_keys: new_keys, dict_values: new_values)

    fn update(key, f: fn()) -> PersistentDict:
        val current = self.get(key)
        val new_val = f(current)
        self.set(key, new_val)

    fn entries():
        var result = []
        var idx = 0
        for k in self.dict_keys:
            result.push([k, self.dict_values[idx]])
            idx = idx + 1
        result

    fn keys():
        var result = []
        for k in self.dict_keys:
            result.push(k)
        result

    fn values():
        var result = []
        for v in self.dict_values:
            result.push(v)
        result

    fn to_dict():
        var result = {}
        var idx = 0
        for k in self.dict_keys:
            result[k] = self.dict_values[idx]
            idx = idx + 1
        result

    fn copy() -> PersistentDict:
        var new_keys = []
        var new_values = []
        var idx = 0
        for k in self.dict_keys:
            new_keys.push(k)
            new_values.push(self.dict_values[idx])
            idx = idx + 1
        PersistentDict(dict_keys: new_keys, dict_values: new_values)

fn PersistentDict__empty() -> PersistentDict:
    PersistentDict(dict_keys: [], dict_values: [])

fn PersistentDict__from_entries(entries) -> PersistentDict:
    var new_keys = []
    var new_values = []
    for entry in entries:
        new_keys.push(entry[0])
        new_values.push(entry[1])
    PersistentDict(dict_keys: new_keys, dict_values: new_values)

fn PersistentDict__from_dict(d) -> PersistentDict:
    var new_keys = []
    var new_values = []
    for k in d:
        new_keys.push(k)
        new_values.push(d[k])
    PersistentDict(dict_keys: new_keys, dict_values: new_values)

export PersistentDict, PersistentDict__empty, PersistentDict__from_entries, PersistentDict__from_dict
