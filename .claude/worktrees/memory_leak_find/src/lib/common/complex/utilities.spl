# Complex Number Utility Functions
#
# Purpose: Conversions, predicates, and math helper functions
#
# Contains:
# - Conversion functions (to_polar, to_cartesian, to_string)
# - Predicates (is_real, is_imaginary, is_zero, is_unit, equal)
# - Advanced operations (normalize, distance, scale, rotate, reflect)
# - Math helper functions (pure Simple approximations)

# ============================================================================
# Conversion
# ============================================================================

fn to_polar(z):
    """Convert complex number to polar form (r, theta).

    Example:
        to_polar((1.0, 1.0))  # (1.414..., 0.785...)
    """
    val r = magnitude(z)
    val theta = argument(z)
    (r, theta)

fn to_cartesian(z):
    """Identity - complex number is already in cartesian form.

    Example:
        to_cartesian((3.0, 4.0))  # (3.0, 4.0)
    """
    z

fn to_string(z) -> text:
    """Convert complex number to string representation.

    Example:
        to_string((3.0, 4.0))   # "3.0 + 4.0i"
        to_string((3.0, -4.0))  # "3.0 - 4.0i"
        to_string((0.0, 1.0))   # "0.0 + 1.0i"
    """
    val real = z.0
    val imag = z.1

    if abs_f64(imag) < EPSILON:
        return "{real}"

    if abs_f64(real) < EPSILON:
        return "{imag}i"

    if imag >= 0.0:
        "{real} + {imag}i"
    else:
        val pos_imag = -imag
        "{real} - {pos_imag}i"

# ============================================================================
# Predicates
# ============================================================================

fn is_real(z) -> bool:
    """Check if complex number is real (imaginary part ≈ 0).

    Example:
        is_real((5.0, 0.0))  # true
    """
    abs_f64(z.1) < EPSILON

fn is_imaginary(z) -> bool:
    """Check if complex number is purely imaginary (real part ≈ 0).

    Example:
        is_imaginary((0.0, 5.0))  # true
    """
    abs_f64(z.0) < EPSILON

fn is_zero(z) -> bool:
    """Check if complex number is zero.

    Example:
        is_zero((0.0, 0.0))  # true
    """
    abs_f64(z.0) < EPSILON and abs_f64(z.1) < EPSILON

fn is_unit(z) -> bool:
    """Check if complex number has magnitude 1.

    Example:
        is_unit((1.0, 0.0))  # true
    """
    val mag = magnitude(z)
    abs_f64(mag - 1.0) < EPSILON

fn equal(z1, z2) -> bool:
    """Check if two complex numbers are approximately equal.

    Example:
        equal((1.0, 2.0), (1.0, 2.0))  # true
    """
    val real_diff = z1.0 - z2.0
    val imag_diff = z1.1 - z2.1

    var real_check = false
    if real_diff >= 0.0:
        real_check = real_diff < EPSILON
    else:
        real_check = -real_diff < EPSILON

    var imag_check = false
    if imag_diff >= 0.0:
        imag_check = imag_diff < EPSILON
    else:
        imag_check = -imag_diff < EPSILON

    real_check and imag_check

# ============================================================================
# Advanced Operations
# ============================================================================

fn normalize(z):
    """Normalize complex number to unit magnitude.

    Example:
        normalize((3.0, 4.0))  # (0.6, 0.8)
    """
    val mag = magnitude(z)

    if mag < EPSILON:
        return zero()

    (z.0 / mag, z.1 / mag)

fn distance(z1, z2) -> f64:
    """Compute distance between two complex numbers.

    Example:
        distance((1.0, 2.0), (4.0, 6.0))  # 5.0
    """
    val diff = subtract(z1, z2)
    magnitude(diff)

fn scale(z, factor: f64):
    """Scale complex number by real factor.

    Example:
        scale((3.0, 4.0), 2.0)  # (6.0, 8.0)
    """
    (z.0 * factor, z.1 * factor)

fn rotate(z, angle: f64):
    """Rotate complex number by angle (in radians).

    Example:
        rotate((1.0, 0.0), PI / 2.0)  # (0.0, 1.0)
    """
    val rotation = from_polar(1.0, angle)
    multiply(z, rotation)

fn reflect_real(z):
    """Reflect complex number across real axis (same as conjugate).

    Example:
        reflect_real((3.0, 4.0))  # (3.0, -4.0)
    """
    conjugate(z)

fn reflect_imag(z):
    """Reflect complex number across imaginary axis.

    Example:
        reflect_imag((3.0, 4.0))  # (-3.0, 4.0)
    """
    (-z.0, z.1)

# ============================================================================
# Helper Math Functions (Pure Simple Approximations)
# ============================================================================

fn abs_f64(x: f64) -> f64:
    """Absolute value of float."""
    if x < 0.0:
        -x
    else:
        x

fn to_f64(n: i64) -> f64:
    """Convert integer to float (simple coercion)."""
    n * 1.0

fn sqrt_approx(x: f64) -> f64:
    """Newton's method square root approximation."""
    if x < 0.0:
        return 0.0

    if x < EPSILON:
        return 0.0

    var guess = x / 2.0
    var i = 0

    while i < 20:
        val next_guess = (guess + x / guess) / 2.0
        val diff = guess - next_guess

        var abs_diff = diff
        if abs_diff < 0.0:
            abs_diff = -abs_diff

        if abs_diff < EPSILON:
            return next_guess

        guess = next_guess
        i = i + 1

    guess

fn sin_approx(x: f64) -> f64:
    """Sine using Taylor series (accurate for small angles)."""
    var normalized = x

    while normalized > PI:
        normalized = normalized - 2.0 * PI

    while normalized < -PI:
        normalized = normalized + 2.0 * PI

    var term = normalized
    var result = term
    var i = 1

    while i < 15:
        term = -term * normalized * normalized / (to_f64(2 * i) * to_f64(2 * i + 1))
        result = result + term
        i = i + 1

    result

fn cos_approx(x: f64) -> f64:
    """Cosine using Taylor series."""
    var normalized = x

    while normalized > PI:
        normalized = normalized - 2.0 * PI

    while normalized < -PI:
        normalized = normalized + 2.0 * PI

    var term = 1.0
    var result = term
    var i = 1

    while i < 15:
        term = -term * normalized * normalized / (to_f64(2 * i - 1) * to_f64(2 * i))
        result = result + term
        i = i + 1

    result

fn exp_approx(x: f64) -> f64:
    """Exponential using Taylor series."""
    var term = 1.0
    var result = term
    var i = 1

    while i < 20:
        term = term * x / to_f64(i)
        result = result + term
        i = i + 1

    result

fn log_approx(x: f64) -> f64:
    """Natural logarithm using Newton's method (ln(x))."""
    if x <= 0.0:
        return -999999999999.0

    if abs_f64(x - 1.0) < EPSILON:
        return 0.0

    var guess = 0.0
    if x > 1.0:
        guess = (x - 1.0) / x
    else:
        guess = -(1.0 - x) / x

    var i = 0
    while i < 20:
        val exp_guess = exp_approx(guess)
        val next_guess = guess + (x - exp_guess) / exp_guess

        val diff = guess - next_guess
        var abs_diff = diff
        if abs_diff < 0.0:
            abs_diff = -abs_diff

        if abs_diff < EPSILON:
            return next_guess

        guess = next_guess
        i = i + 1

    guess

fn pow_approx(base: f64, exp: f64) -> f64:
    """Power function: base^exp = e^(exp * ln(base))."""
    if base <= 0.0:
        return 0.0

    val ln_base = log_approx(base)
    val result = exp_approx(exp * ln_base)
    result

fn sinh_approx(x: f64) -> f64:
    """Hyperbolic sine: sinh(x) = (e^x - e^(-x)) / 2."""
    val exp_x = exp_approx(x)
    val exp_neg_x = exp_approx(-x)
    (exp_x - exp_neg_x) / 2.0

fn cosh_approx(x: f64) -> f64:
    """Hyperbolic cosine: cosh(x) = (e^x + e^(-x)) / 2."""
    val exp_x = exp_approx(x)
    val exp_neg_x = exp_approx(-x)
    (exp_x + exp_neg_x) / 2.0

fn atan2_approx(y: f64, x: f64) -> f64:
    """Approximate atan2 for argument calculation."""
    if abs_f64(x) < EPSILON and abs_f64(y) < EPSILON:
        return 0.0

    if abs_f64(x) < EPSILON:
        if y > 0.0:
            return PI / 2.0
        else:
            return -PI / 2.0

    val ratio = y / x
    var atan = atan_approx(ratio)

    if x < 0.0:
        if y >= 0.0:
            atan = atan + PI
        else:
            atan = atan - PI

    atan

fn atan_approx(x: f64) -> f64:
    """Approximate arctangent using polynomial approximation."""
    if abs_f64(x) > 1.0:
        val result = PI / 2.0 - atan_small_approx(1.0 / x)
        if x < 0.0:
            return -result
        else:
            return result

    atan_small_approx(x)

fn atan_small_approx(x: f64) -> f64:
    """Arctangent for |x| <= 1 using Taylor series."""
    var term = x
    var result = term
    var i = 1

    while i < 15:
        val power = 2 * i + 1
        term = -term * x * x
        result = result + term / to_f64(power)
        i = i + 1

    result

# ============================================================================
# Helper stub functions (from other modules)
# ============================================================================

val PI = 3.141592653589793
val EPSILON = 0.0000000001

fn magnitude(z) -> f64:
    """Stub - implemented in arithmetic."""
    val a = z.0
    val b = z.1
    sqrt_approx(a * a + b * b)

fn argument(z) -> f64:
    """Stub - implemented in arithmetic."""
    atan2_approx(z.1, z.0)

fn zero():
    """Stub - implemented in types."""
    (0.0, 0.0)

fn subtract(z1, z2):
    """Stub - implemented in arithmetic."""
    (z1.0 - z2.0, z1.1 - z2.1)

fn multiply(z1, z2):
    """Stub - implemented in arithmetic."""
    val a = z1.0
    val b = z1.1
    val c = z2.0
    val d = z2.1
    val real = a * c - b * d
    val imag = a * d + b * c
    (real, imag)

fn from_polar(r: f64, theta: f64):
    """Stub - implemented in types."""
    val real = r * cos_approx(theta)
    val imag = r * sin_approx(theta)
    (real, imag)

fn conjugate(z):
    """Stub - implemented in arithmetic."""
    (z.0, -z.1)

export to_polar, to_cartesian, to_string
export is_real, is_imaginary, is_zero, is_unit, equal
export normalize, distance, scale, rotate
export reflect_real, reflect_imag
export abs_f64, to_f64, sqrt_approx, sin_approx, cos_approx
export exp_approx, log_approx, pow_approx, sinh_approx, cosh_approx
export atan2_approx, atan_approx, atan_small_approx
