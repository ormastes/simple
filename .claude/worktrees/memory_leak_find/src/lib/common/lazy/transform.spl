# Stream Transformation Operations
#
# Functions for transforming streams:
# - Map, filter, flatmap
# - Take, drop, take_while, drop_while
# - Distinct, peek
# - Enumerate, chunks, windows
# - Scan
# - Flatten, partition, group_by

import types: stream_next_internal
import create: stream_from_list, stream_empty
import evaluate: stream_to_list

# ============================================================================
# Exports
# ============================================================================

export lazy_map
export stream_map, stream_filter, stream_take, stream_drop
export stream_take_while, stream_drop_while
export stream_flatmap, stream_distinct, stream_peek
export stream_enumerate, stream_chunks, stream_windows
export stream_scan
export stream_flatten, stream_partition, stream_group_by

# ============================================================================
# Lazy Value Transformation
# ============================================================================

fn lazy_map(lazy_val, f):
    """Map a function over a lazy value without forcing evaluation.

    Example:
        val lv = lazy_value(\: 10)
        val doubled = lazy_map(lv, \x: x * 2)
        force_lazy(doubled)  # 20
    """
    # Need to import from evaluate module
    # For now, create a new lazy value directly
    {
        "type": "lazy",
        "evaluated": false,
        "thunk": \: f(lazy_val["value"] if lazy_val["evaluated"] else: lazy_val["thunk"]()),
        "value": nil
    }

# ============================================================================
# Stream Operations - Map and Filter
# ============================================================================

fn stream_map(stream, f):
    """Transform each element of a stream using function f.

    Example:
        val s = stream_from_list([1, 2, 3])
        val doubled = stream_map(s, \x: x * 2)
        stream_to_list(doubled)  # [2, 4, 6]
    """
    var result = []
    var continue = true

    while continue:
        val next_result = stream_next_internal(stream)
        val elem = next_result[0]
        val has_next = next_result[1]

        if has_next:
            result.push(f(elem))
        else:
            continue = false

    stream_from_list(result)

fn stream_filter(stream, predicate):
    """Keep only elements that satisfy the predicate.

    Example:
        val s = stream_from_list([1, 2, 3, 4, 5])
        val evens = stream_filter(s, \x: x % 2 == 0)
        stream_to_list(evens)  # [2, 4]
    """
    var result = []
    var continue = true

    while continue:
        val next_result = stream_next_internal(stream)
        val elem = next_result[0]
        val has_next = next_result[1]

        if has_next:
            if predicate(elem):
                result.push(elem)
        else:
            continue = false

    stream_from_list(result)

# ============================================================================
# Stream Operations - Take and Drop
# ============================================================================

fn stream_take(stream, n):
    """Take first n elements from stream.

    Example:
        val s = stream_count(0)
        val first_five = stream_take(s, 5)
        stream_to_list(first_five)  # [0, 1, 2, 3, 4]
    """
    var result = []
    var count = 0

    while count < n:
        val next_result = stream_next_internal(stream)
        val elem = next_result[0]
        val has_next = next_result[1]

        if has_next:
            result.push(elem)
            count = count + 1
        else:
            count = n  # Force exit

    stream_from_list(result)

fn stream_drop(stream, n):
    """Drop first n elements from stream.

    Example:
        val s = stream_from_list([1, 2, 3, 4, 5])
        val dropped = stream_drop(s, 2)
        stream_to_list(dropped)  # [3, 4, 5]
    """
    var count = 0

    # Skip n elements
    while count < n:
        val next_result = stream_next_internal(stream)
        val has_next = next_result[1]

        if has_next:
            count = count + 1
        else:
            count = n  # Force exit

    # Collect remaining
    var result = []
    var continue = true

    while continue:
        val next_result = stream_next_internal(stream)
        val elem = next_result[0]
        val has_next = next_result[1]

        if has_next:
            result.push(elem)
        else:
            continue = false

    stream_from_list(result)

# ============================================================================
# Stream Operations - Conditional Take/Drop
# ============================================================================

fn stream_take_while(stream, predicate):
    """Take elements while predicate is true, stop at first false.

    Example:
        val s = stream_from_list([2, 4, 6, 7, 8, 10])
        val evens = stream_take_while(s, \x: x % 2 == 0)
        stream_to_list(evens)  # [2, 4, 6]
    """
    var result = []
    var continue = true

    while continue:
        val next_result = stream_next_internal(stream)
        val elem = next_result[0]
        val has_next = next_result[1]

        if has_next:
            if predicate(elem):
                result.push(elem)
            else:
                continue = false
        else:
            continue = false

    stream_from_list(result)

fn stream_drop_while(stream, predicate):
    """Drop elements while predicate is true, keep rest.

    Example:
        val s = stream_from_list([2, 4, 6, 7, 8, 10])
        val rest = stream_drop_while(s, \x: x % 2 == 0)
        stream_to_list(rest)  # [7, 8, 10]
    """
    var dropping = true

    # Skip while predicate is true
    while dropping:
        val next_result = stream_next_internal(stream)
        val elem = next_result[0]
        val has_next = next_result[1]

        if has_next:
            if not predicate(elem):
                dropping = false
                # Keep this element
                var result = [elem]

                # Collect remaining
                var continue = true
                while continue:
                    val next_result2 = stream_next_internal(stream)
                    val elem2 = next_result2[0]
                    val has_next2 = next_result2[1]

                    if has_next2:
                        result.push(elem2)
                    else:
                        continue = false

                return stream_from_list(result)
        else:
            dropping = false

    stream_empty()

# ============================================================================
# Stream Advanced Operations
# ============================================================================

fn stream_flatmap(stream, f):
    """Map each element to a list and flatten the results.

    Example:
        val s = stream_from_list([1, 2, 3])
        val doubled = stream_flatmap(s, \x: [x, x])
        stream_to_list(doubled)  # [1, 1, 2, 2, 3, 3]
    """
    var result = []
    var continue = true

    while continue:
        val next_result = stream_next_internal(stream)
        val elem = next_result[0]
        val has_next = next_result[1]

        if has_next:
            val mapped = f(elem)
            for item in mapped:
                result.push(item)
        else:
            continue = false

    stream_from_list(result)

fn stream_distinct(stream):
    """Remove duplicate elements from stream (keeps first occurrence).

    Example:
        val s = stream_from_list([1, 2, 2, 3, 1, 4])
        stream_to_list(stream_distinct(s))  # [1, 2, 3, 4]
    """
    var seen = []
    var result = []
    var continue = true

    while continue:
        val next_result = stream_next_internal(stream)
        val elem = next_result[0]
        val has_next = next_result[1]

        if has_next:
            if not seen.contains(elem):
                seen.push(elem)
                result.push(elem)
        else:
            continue = false

    stream_from_list(result)

fn stream_peek(stream, action):
    """Execute action on each element while passing it through unchanged.

    Useful for side effects like logging.

    Example:
        val s = stream_from_list([1, 2, 3])
        val peeked = stream_peek(s, \x: print("Saw: {x}"))
        stream_to_list(peeked)  # [1, 2, 3] (with print side effects)
    """
    var result = []
    var continue = true

    while continue:
        val next_result = stream_next_internal(stream)
        val elem = next_result[0]
        val has_next = next_result[1]

        if has_next:
            action(elem)
            result.push(elem)
        else:
            continue = false

    stream_from_list(result)

# ============================================================================
# Stream Utilities - Enumerate, Chunks, Windows
# ============================================================================

fn stream_enumerate(stream):
    """Add indices to stream elements as tuples (index, element).

    Example:
        val s = stream_from_list([10, 20, 30])
        stream_to_list(stream_enumerate(s))  # [(0, 10), (1, 20), (2, 30)]
    """
    var result = []
    var index = 0
    var continue = true

    while continue:
        val next_result = stream_next_internal(stream)
        val elem = next_result[0]
        val has_next = next_result[1]

        if has_next:
            result.push((index, elem))
            index = index + 1
        else:
            continue = false

    stream_from_list(result)

fn stream_chunks(stream, size):
    """Split stream into chunks of given size. Last chunk may be smaller.

    Example:
        val s = stream_from_list([1, 2, 3, 4, 5])
        stream_to_list(stream_chunks(s, 2))  # [[1, 2], [3, 4], [5]]
    """
    if size <= 0:
        return stream_empty()

    var result = []
    var current_chunk = []
    var continue = true

    while continue:
        val next_result = stream_next_internal(stream)
        val elem = next_result[0]
        val has_next = next_result[1]

        if has_next:
            current_chunk.push(elem)
            if current_chunk.len() == size:
                result.push(current_chunk)
                current_chunk = []
        else:
            if current_chunk.len() > 0:
                result.push(current_chunk)
            continue = false

    stream_from_list(result)

fn stream_windows(stream, size):
    """Create sliding windows of given size over stream.

    Example:
        val s = stream_from_list([1, 2, 3, 4])
        stream_to_list(stream_windows(s, 2))  # [[1, 2], [2, 3], [3, 4]]
    """
    if size <= 0:
        return stream_empty()

    # Collect all elements first (needed for sliding window)
    val all_items = stream_to_list(stream)

    if all_items.len() < size:
        return stream_empty()

    var result = []
    var i = 0
    while i <= all_items.len() - size:
        var window = []
        var j = 0
        while j < size:
            window.push(all_items[i + j])
            j = j + 1
        result.push(window)
        i = i + 1

    stream_from_list(result)

fn stream_scan(stream, init, f):
    """Like fold, but returns stream of intermediate results.

    Example:
        val s = stream_from_list([1, 2, 3, 4])
        stream_to_list(stream_scan(s, 0, \acc, x: acc + x))  # [0, 1, 3, 6, 10]
    """
    var result = [init]
    var acc = init
    var continue = true

    while continue:
        val next_result = stream_next_internal(stream)
        val elem = next_result[0]
        val has_next = next_result[1]

        if has_next:
            acc = f(acc, elem)
            result.push(acc)
        else:
            continue = false

    stream_from_list(result)

# ============================================================================
# Additional Stream Operations
# ============================================================================

fn stream_flatten(stream_of_lists):
    """Flatten a stream of lists into a stream of elements.

    Example:
        val s = stream_from_list([[1, 2], [3, 4], [5]])
        stream_to_list(stream_flatten(s))  # [1, 2, 3, 4, 5]
    """
    var result = []
    var continue = true

    while continue:
        val next_result = stream_next_internal(stream_of_lists)
        val elem = next_result[0]
        val has_next = next_result[1]

        if has_next:
            for item in elem:
                result.push(item)
        else:
            continue = false

    stream_from_list(result)

fn stream_partition(stream, predicate):
    """Partition stream into two lists: (matching, not_matching).

    Example:
        val s = stream_from_list([1, 2, 3, 4, 5])
        stream_partition(s, \x: x % 2 == 0)  # ([2, 4], [1, 3, 5])
    """
    var matching = []
    var not_matching = []
    var continue = true

    while continue:
        val next_result = stream_next_internal(stream)
        val elem = next_result[0]
        val has_next = next_result[1]

        if has_next:
            if predicate(elem):
                matching.push(elem)
            else:
                not_matching.push(elem)
        else:
            continue = false

    (matching, not_matching)

fn stream_group_by(stream, key_fn):
    """Group stream elements by key function.

    Returns a dict mapping keys to lists of elements.

    Example:
        val s = stream_from_list([1, 2, 3, 4, 5])
        stream_group_by(s, \x: x % 2)  # {0: [2, 4], 1: [1, 3, 5]}
    """
    var groups = {}
    var continue = true

    while continue:
        val next_result = stream_next_internal(stream)
        val elem = next_result[0]
        val has_next = next_result[1]

        if has_next:
            val key = "{key_fn(elem)}"
            if not groups.contains(key):
                groups[key] = []
            groups[key].push(elem)
        else:
            continue = false

    groups
