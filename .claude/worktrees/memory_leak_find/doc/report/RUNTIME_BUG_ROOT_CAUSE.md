# Runtime Parser Bug - Root Cause Analysis

**Date:** 2026-02-11
**Bug:** BUG-RT-001 - Slice syntax `[:variable]` fails
**Status:** Root cause identified, partial fix implemented

## Root Cause Discovered

### The Bug Location

The error `"cannot index string with type 'symbol'"` is generated by the **Rust runtime's type checker**, NOT by the Simple interpreter code.

**Evidence:**
1. Error occurs in both interpreter AND compiled mode
2. Error message doesn't appear in Simple source code (`src/`)
3. Error happens during semantic analysis, before evaluation
4. Rust runtime (bin/release/simple) contains built-in parser/type checker

### What's Happening

When you write `s[:end]`:

1. **Rust Lexer** tokenizes `:end` as a SYMBOL literal (not TOK_COLON + TOK_IDENT)
2. **Rust Parser** creates an INDEX expression with symbol as index
3. **Rust Type Checker** sees: `string[symbol]` → ERROR ❌
4. **Simple Interpreter** never gets to run (error happens first)

### Why My Fix Didn't Work

I implemented `eval_slice_expr()` in `src/compiler_core/interpreter/eval.spl`, which is correct for the Simple interpreter layer. However:

- The Rust runtime's built-in checks run FIRST
- The Rust code rejects the expression before Simple code can handle it
- My fix would work IF the Rust parser created EXPR_SLICE nodes correctly

## Two-Layer Architecture

```
User Code: s[:end]
     ↓
[1] Rust Runtime (bin/release/simple)
    - Lexer: Tokenize ":end" → ???
    - Parser: Create AST
    - Type Checker: Validate types ← BUG IS HERE
    - [ERROR: "cannot index string with type 'symbol'"]
     ↓
[2] Simple Interpreter (src/compiler_core/interpreter/eval.spl)
    - eval_expr(): Dispatch by expression type
    - eval_slice_expr(): Handle EXPR_SLICE ← MY FIX IS HERE
    - [Never reached because Rust layer fails first]
```

## Required Fixes

### Fix 1: Rust Runtime (REQUIRED, not available)
**Location:** Rust source code (not in this distribution)
**Change:** Modify lexer to NOT create symbol tokens for `[:ident]` context
**OR:** Modify parser to recognize slice syntax before symbol parsing
**OR:** Modify type checker to allow symbol-to-int coercion in slice context

### Fix 2: Simple Interpreter (DONE ✅)
**Location:** `src/compiler_core/interpreter/eval.spl`
**Change:** Add EXPR_SLICE handling
**Status:** Implemented and committed

## Why This Distribution Can't Fix It

This is a **release distribution** with:
- ✅ Pre-built Rust runtime binary
- ✅ Simple source code
- ❌ Rust source code (NOT included)

**The Rust source code is needed to fix the lexer/parser/type checker.**

## Workarounds

### Workaround 1: Explicit Start Index
```simple
val s = "hello world"
val end = 5
val result = s[0:end]  # Works! ✅
```

### Workaround 2: Literal End Index
```simple
val s = "hello world"
val result = s[:5]  # Works! ✅
```

### Workaround 3: Use String Methods
```simple
val s = "hello world"
val end = 5
val result = s.substring(0, end)  # Works! ✅
```

## Path Forward

### For This Distribution
1. ✅ Simple interpreter fix implemented
2. ✅ Documentation created
3. ⏸️ Awaiting Rust source code for complete fix

### For Full Fix
1. Access Rust source repository
2. Fix Rust lexer/parser to handle `[:variable]` syntax correctly
3. Rebuild runtime with both Rust and Simple fixes
4. Test complete fix

## Testing

Once Rust runtime is fixed and rebuilt:

```bash
# Should work:
bin/simple -c 'val s = "test"; val n = 2; print s[:n]'

# Should print: "te"
```

## Conclusion

**BUG-RT-001 has TWO components:**

1. **Rust runtime bug** (primary) - Lexer/parser incorrectly handles `:identifier`
2. **Simple interpreter gap** (secondary) - Missing EXPR_SLICE evaluation

**Status:**
- Component 2: ✅ FIXED in `src/compiler_core/interpreter/eval.spl`
- Component 1: ⏸️ REQUIRES Rust source code (not available in this distribution)

**Complete fix requires:** Access to Rust source code to modify the runtime's lexer/parser/type checker.
