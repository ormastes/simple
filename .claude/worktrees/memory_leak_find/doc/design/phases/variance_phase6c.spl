"""
Variance Inference - Phase 6C: Variance Checking

Implements subtyping validation using inferred variances.

Status: Phase 6C In Progress
"""

type Symbol = text

# ============================================================================
# Import from Phase 6A/6B
# ============================================================================

# Variance enum
enum Variance:
    Covariant
    Contravariant
    Inv
    Bivariant

impl Variance:
    fn to_string() -> text:
        match self:
            case Covariant: "+"
            case Contravariant: "-"
            case Inv: "="
            case Bivariant: "Â±"

# VarianceOps
class VarianceOps:
    static fn flip(v: Variance) -> Variance:
        match v:
            case Covariant: Variance.Contravariant
            case Contravariant: Variance.Covariant
            case Inv: Variance.Inv
            case Bivariant: Variance.Bivariant

    static fn compose(outer: Variance, inner: Variance) -> Variance:
        match outer:
            case Covariant: inner
            case Contravariant: VarianceOps.flip(inner)
            case Inv: Variance.Inv
            case Bivariant: Variance.Bivariant

    static fn combine(v1: Variance, v2: Variance) -> Variance:
        match (v1, v2):
            case (Bivariant, v): v
            case (v, Bivariant): v
            case (Covariant, Covariant): Variance.Covariant
            case (Contravariant, Contravariant): Variance.Contravariant
            case (Inv, Inv): Variance.Inv
            case _: Variance.Inv

# Type system
enum HirType:
    Int
    Str
    Bool
    TypeParam(id: i64)
    Arrow(from: HirType, to: HirType)
    Generic(name: Symbol, args: [HirType])
    MutRef(inner: HirType)

impl HirType:
    fn to_string() -> text:
        match self:
            case Int: "i32"
            case Str: "String"
            case Bool: "bool"
            case TypeParam(id): "T{id}"
            case Arrow(from, to):
                "fn({from.to_string()}) -> {to.to_string()}"
            case Generic(name, args):
                if args.len() == 0:
                    name
                else:
                    val arg_strs = []
                    for arg in args:
                        arg_strs.push(arg.to_string())
                    val args_str = if arg_strs.len() > 0: arg_strs[0] else: ""
                    "{name}<{args_str}>"
            case MutRef(inner):
                "mut {inner.to_string()}"

# ============================================================================
# Subtyping Hierarchy
# ============================================================================

class SubtypeEnv:
    """
    Environment tracking subtyping relationships

    Examples:
        Cat <: Animal
        Dog <: Animal
        Animal <: Any
    """
    subtypes: text  # Dict<Symbol, [Symbol]> - type â†’ list of supertypes

impl SubtypeEnv:
    static fn empty() -> SubtypeEnv:
        SubtypeEnv(subtypes: {})

    me add_subtype(sub: Symbol, sup: Symbol):
        """Declare sub <: sup"""
        if sub not in self.subtypes:
            self.subtypes[sub] = []

        var supers = self.subtypes[sub]
        supers.push(sup)
        self.subtypes[sub] = supers

    fn is_subtype(sub: Symbol, sup: Symbol) -> bool:
        """Check if sub <: sup (direct or transitive)"""
        if sub == sup:
            return true

        if sub not in self.subtypes:
            return false

        val supers = self.subtypes[sub]

        # Direct subtype
        if sup in supers:
            return true

        # Transitive: check if any supertype is subtype of sup
        for s in supers:
            if self.is_subtype(s, sup):
                return true

        false

# ============================================================================
# Variance Checker
# ============================================================================

class VarianceChecker:
    """
    Check subtyping using variance information

    Rules:
        Covariant:     F<A> <: F<B> if A <: B
        Contravariant: F<A> <: F<B> if B <: A (flipped!)
        Invariant:     F<A> <: F<B> only if A = B
        Bivariant:     F<A> <: F<B> always
    """
    variance_env: text   # Dict<Symbol, [Variance]> - type â†’ variances
    subtype_env: SubtypeEnv

impl VarianceChecker:
    static fn new_checker(subtype_env: SubtypeEnv) -> VarianceChecker:
        VarianceChecker(
            variance_env: {},
            subtype_env: subtype_env
        )

    me set_variance(type_name: Symbol, variances: [Variance]):
        """Set variance for a type"""
        self.variance_env[type_name] = variances

    fn check_subtype(sub: HirType, sup: HirType) -> bool:
        """
        Check if sub <: sup

        Uses variance to determine if generic types are subtypes
        """
        match (sub, sup):
            case (Int, Int): true
            case (Str, Str): true
            case (Bool, Bool): true

            case (Generic(name1, args1), Generic(name2, args2)):
                if name1 != name2:
                    return false

                # Check type arguments according to variance
                if name1 not in self.variance_env:
                    # No variance info â†’ assume invariant
                    return self.types_equal(sub, sup)

                val variances = self.variance_env[name1]

                for i, (arg1, arg2) in args1.zip(args2).enumerate():
                    if i >= variances.len():
                        # No variance for this param â†’ invariant
                        if not self.types_equal(arg1, arg2):
                            return false
                    else:
                        val variance = variances[i]

                        match variance:
                            case Covariant:
                                # F<A> <: F<B> if A <: B
                                if not self.check_subtype(arg1, arg2):
                                    return false

                            case Contravariant:
                                # F<A> <: F<B> if B <: A (flipped!)
                                if not self.check_subtype(arg2, arg1):
                                    return false

                            case Inv:
                                # F<A> <: F<B> only if A = B
                                if not self.types_equal(arg1, arg2):
                                    return false

                            case Bivariant:
                                # F<A> <: F<B> always (unused parameter)
                                ()

                true

            case (Arrow(from1, to1), Arrow(from2, to2)):
                # fn(A) -> B <: fn(C) -> D
                # if C <: A (contravariant param) and B <: D (covariant return)
                self.check_subtype(from2, from1) and self.check_subtype(to1, to2)

            case _:
                # Structural subtyping not implemented
                false

    fn types_equal(ty1: HirType, ty2: HirType) -> bool:
        """Check if two types are equal"""
        match (ty1, ty2):
            case (Int, Int): true
            case (Str, Str): true
            case (Bool, Bool): true
            case (TypeParam(id1), TypeParam(id2)): id1 == id2

            case (Arrow(from1, to1), Arrow(from2, to2)):
                self.types_equal(from1, from2) and self.types_equal(to1, to2)

            case (Generic(name1, args1), Generic(name2, args2)):
                if name1 != name2:
                    return false
                if args1.len() != args2.len():
                    return false

                for i, (arg1, arg2) in args1.zip(args2).enumerate():
                    if not self.types_equal(arg1, arg2):
                        return false

                true

            case _: false

# ============================================================================
# Named types for testing
# ============================================================================

class NamedType:
    """Named type for subtyping tests (Cat, Animal, etc.)"""
    name: Symbol

# Helper to create named generic types
fn box_of(name: Symbol) -> HirType:
    HirType.Generic(name: "Box", args: [HirType.Generic(name: name, args: [])])

fn cell_of(name: Symbol) -> HirType:
    HirType.Generic(name: "Cell", args: [HirType.Generic(name: name, args: [])])

fn fn_type(param: Symbol, ret: Symbol) -> HirType:
    HirType.Arrow(
        from: HirType.Generic(name: param, args: []),
        to: HirType.Generic(name: ret, args: [])
    )

# ============================================================================
# Tests
# ============================================================================

fn test_covariant_subtyping():
    """Test covariant subtyping (Box<Cat> <: Box<Animal>)"""
    val subtype_env = SubtypeEnv.empty()
    subtype_env.add_subtype("Cat", "Animal")

    val checker = VarianceChecker.new_checker(subtype_env)
    checker.set_variance("Box", [Variance.Covariant])

    # Box<Cat> <: Box<Animal>?
    val box_cat = box_of("Cat")
    val box_animal = box_of("Animal")

    assert checker.check_subtype(box_cat, box_animal), "Box<Cat> <: Box<Animal>"

    # Box<Animal> <: Box<Cat>? No.
    assert not checker.check_subtype(box_animal, box_cat), "Box<Animal> not <: Box<Cat>"

    print "âœ… Covariant subtyping"

fn test_inv_rejection():
    """Test invariant rejection (Cell<Cat> not <: Cell<Animal>)"""
    val subtype_env = SubtypeEnv.empty()
    subtype_env.add_subtype("Cat", "Animal")

    val checker = VarianceChecker.new_checker(subtype_env)
    checker.set_variance("Cell", [Variance.Inv])

    # Cell<Cat> <: Cell<Animal>? No.
    val cell_cat = cell_of("Cat")
    val cell_animal = cell_of("Animal")

    assert not checker.check_subtype(cell_cat, cell_animal), "Cell<Cat> not <: Cell<Animal>"

    # Cell<Animal> <: Cell<Cat>? No.
    assert not checker.check_subtype(cell_animal, cell_cat), "Cell<Animal> not <: Cell<Cat>"

    # Cell<Cat> <: Cell<Cat>? Yes (same type)
    assert checker.check_subtype(cell_cat, cell_cat), "Cell<Cat> <: Cell<Cat>"

    print "âœ… Invariant rejection"

fn test_contravariant_function():
    """Test contravariant function parameters"""
    val subtype_env = SubtypeEnv.empty()
    subtype_env.add_subtype("Cat", "Animal")

    val checker = VarianceChecker.new_checker(subtype_env)

    # fn(Animal) -> () <: fn(Cat) -> ()?
    # Check: fn(A) -> B <: fn(C) -> D if C <: A and B <: D
    # Here: Cat <: Animal (param) and () <: () (return)
    # Result: Yes
    val feed_animal = fn_type("Animal", "Unit")
    val feed_cat = fn_type("Cat", "Unit")

    assert checker.check_subtype(feed_animal, feed_cat), "fn(Animal) <: fn(Cat)"

    # fn(Cat) -> () <: fn(Animal) -> ()? No.
    assert not checker.check_subtype(feed_cat, feed_animal), "fn(Cat) not <: fn(Animal)"

    print "âœ… Contravariant function parameters"

fn test_nested_variance():
    """Test nested variance checking"""
    val subtype_env = SubtypeEnv.empty()
    subtype_env.add_subtype("Cat", "Animal")

    val checker = VarianceChecker.new_checker(subtype_env)
    checker.set_variance("Box", [Variance.Covariant])

    # Box<Box<Cat>> <: Box<Box<Animal>>?
    # Outer Box is covariant, inner Box is covariant
    # Result: Yes
    val box_box_cat = HirType.Generic(
        name: "Box",
        args: [box_of("Cat")]
    )
    val box_box_animal = HirType.Generic(
        name: "Box",
        args: [box_of("Animal")]
    )

    assert checker.check_subtype(box_box_cat, box_box_animal), "Box<Box<Cat>> <: Box<Box<Animal>>"

    print "âœ… Nested variance"

fn test_bivariant_always():
    """Test bivariant (unused parameter)"""
    val subtype_env = SubtypeEnv.empty()
    subtype_env.add_subtype("Cat", "Animal")

    val checker = VarianceChecker.new_checker(subtype_env)
    checker.set_variance("Marker", [Variance.Bivariant])

    # Marker<Cat> <: Marker<Animal>? Yes (bivariant)
    val marker_cat = HirType.Generic(name: "Marker", args: [HirType.Generic(name: "Cat", args: [])])
    val marker_animal = HirType.Generic(name: "Marker", args: [HirType.Generic(name: "Animal", args: [])])

    assert checker.check_subtype(marker_cat, marker_animal), "Marker<Cat> <: Marker<Animal>"

    # Marker<Animal> <: Marker<Cat>? Yes (bivariant)
    assert checker.check_subtype(marker_animal, marker_cat), "Marker<Animal> <: Marker<Cat>"

    print "âœ… Bivariant always"

fn test_types_equal():
    """Test type equality"""
    val subtype_env = SubtypeEnv.empty()
    val checker = VarianceChecker.new_checker(subtype_env)

    val ty1 = HirType.Int
    val ty2 = HirType.Int
    val ty3 = HirType.Str

    assert checker.types_equal(ty1, ty2), "Int = Int"
    assert not checker.types_equal(ty1, ty3), "Int â‰  Str"

    val box1 = box_of("Cat")
    val box2 = box_of("Cat")
    val box3 = box_of("Dog")

    assert checker.types_equal(box1, box2), "Box<Cat> = Box<Cat>"
    assert not checker.types_equal(box1, box3), "Box<Cat> â‰  Box<Dog>"

    print "âœ… Type equality"

fn main():
    print ""
    print "Variance Inference Phase 6C Tests"
    print "=================================="

    test_covariant_subtyping()
    test_inv_rejection()
    test_contravariant_function()
    test_nested_variance()
    test_bivariant_always()
    test_types_equal()

    print ""
    print "ðŸŽ‰ Phase 6C Complete!"
    print ""
    print "Implemented:"
    print "  âœ… VarianceChecker - subtyping with variance"
    print "  âœ… Covariant subtyping (Box<Cat> <: Box<Animal>)"
    print "  âœ… Invariant rejection (Cell<Cat> not <: Cell<Animal>)"
    print "  âœ… Contravariant functions (fn(Animal) <: fn(Cat))"
    print "  âœ… Nested variance checking"
    print "  âœ… Bivariant (always subtypes)"
    print "  âœ… Type equality checking"
    print ""
    print "Progress: 7/8 hours (87.5% of Phase 6)"
    print "Next: Phase 6D - Integration & Advanced Cases (1h)"
