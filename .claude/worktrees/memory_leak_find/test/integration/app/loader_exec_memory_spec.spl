use compiler.loader.smf_mmap_native.{
    native_alloc_exec_memory,
    native_write_exec_memory,
    native_make_executable,
    native_call_function_0,
    native_free_exec_memory
}
use std.io_runtime.{host_arch}

describe "Exec memory mapping":
    context "x86_64 only":
        if host_arch() != "x86_64":
            skip_it "skips on non-x86_64 hosts":
                expect true
        else:
            it "maps executable memory and runs a tiny function":
                # Machine code: mov eax, 42; ret
                val code: [u8] = [184, 42, 0, 0, 0, 195]

                val addr = native_alloc_exec_memory(code.len() as i64)
                expect(addr > 0)

                val written = native_write_exec_memory(addr, code, 0)
                expect(written).to_equal(code.len() as i64)

                val made_exec = native_make_executable(addr, code.len() as i64)
                expect(made_exec)

                val result = native_call_function_0(addr)
                expect(result).to_equal(42)

                val freed = native_free_exec_memory(addr, code.len() as i64)
                expect(freed)

            it "fails gracefully on oversized allocation":
                val huge_size = 1_099_511_627_776i64  # 1 TB
                val addr = native_alloc_exec_memory(huge_size)
                expect(addr).to_equal(0)
