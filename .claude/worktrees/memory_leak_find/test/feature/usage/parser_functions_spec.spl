"""
# Parser Function Definition Specification

**Feature IDs:** #PARSER-FN-001 to #PARSER-FN-020
**Category:** Infrastructure | Parser
**Status:** Implemented

Tests that the parser correctly parses function definitions including
parameters, return types, generics, where clauses, and various function forms.

## Syntax

```simple
fn name(params) -> ReturnType:
    body

fn generic<T>(x: T) -> T where T: Trait:
    body

extern fn ffi_func(x: i64) -> i64

macro name(params) -> (contract):
    body
```
"""



# ============================================================================
# Test Group 1: Basic Function Definitions
# ============================================================================

describe "Basic Function Definition Parsing":
    """
    ## Simple Function Syntax

    Tests parsing of basic function definitions.
    """

    context "minimal functions":
        it "parses function without params":
            fn get_value() -> i64:
                42
            expect get_value() == 42

        it "parses function with single param":
            fn double(x: i64) -> i64:
                x * 2
            expect double(21) == 42

        it "parses function with multiple params":
            fn add(a: i64, b: i64) -> i64:
                a + b
            expect add(20, 22) == 42

    context "return types":
        it "parses explicit return type":
            fn typed() -> i64:
                42
            expect typed() == 42

        it "parses inferred return":
            fn inferred():
                42
            expect inferred() == 42

        it "parses unit return":
            fn unit_fn():
                val x = 1
            unit_fn()
            expect true

    context "function body":
        it "parses multi-statement body":
            fn complex(x: i64) -> i64:
                val doubled = x * 2
                val incremented = doubled + 1
                incremented
            expect complex(20) == 41

        it "parses recursive function":
            fn fib(n: i64) -> i64:
                if n <= 1:
                    n
                else:
                    fib(n - 1) + fib(n - 2)
            expect fib(10) == 55


# ============================================================================
# Test Group 2: Generic Functions
# ============================================================================

describe "Generic Function Parsing":
    """
    ## Type Parameters with Angle Brackets

    Tests parsing of generic function definitions.
    """

    it "parses single type parameter":
        fn identity<T>(x: T) -> T:
            x
        expect identity(42) == 42

    it "parses multiple type parameters":
        fn pair<T, U>(a: T, b: U) -> (T, U):
            (a, b)
        val p = pair(1, "hello")
        expect p.0 == 1

    it "parses nested generic types":
        fn wrap<T>(x: T) -> Option<T>:
            Some(x)
        expect wrap(42).unwrap() == 42


# ============================================================================
# Test Group 3: Where Clauses
# ============================================================================

describe "Where Clause Parsing":
    """
    ## Type Constraints

    Tests parsing of where clauses with trait bounds.
    """

    it "parses single where clause":
        trait Show:
            fn show() -> text
        fn display<T>(x: T) -> text where T: Show:
            x.show()
        struct Number:
            value: i64
        impl Show for Number:
            fn show() -> text:
                "{self.value}"
        expect display(Number { value: 42 }) == "42"

    it "parses multiple bounds":
        trait Clone:
            fn clone() -> Self
        trait Debug:
            fn debug() -> text
        fn process<T>(x: T) where T: Clone + Debug:
            x
        expect true  # Compiles successfully

    it "parses multiple where clauses":
        fn combine<T, U>(a: T, b: U) where T: Clone, U: Clone:
            a
        expect true  # Compiles successfully


# ============================================================================
# Test Group 4: Default Parameters
# ============================================================================

describe "Default Parameter Parsing":
    """
    ## Parameters with Default Values

    Tests parsing of function parameters with defaults.
    """

    it "parses default parameter":
        fn greet(name: text = "World") -> text:
            "Hello, {name}!"
        expect greet() == "Hello, World!"
        expect greet("Alice") == "Hello, Alice!"

    it "parses multiple defaults":
        fn create_point(x: i64 = 0, y: i64 = 0) -> (i64, i64):
            (x, y)
        val p1 = create_point()
        val p2 = create_point(5)
        val p3 = create_point(5, 10)
        expect p1.0 == 0
        expect p2.0 == 5
        expect p3.1 == 10

    it "parses mixed required and default":
        fn format(value: i64, prefix: text = "", suffix: text = "") -> text:
            "{prefix}{value}{suffix}"
        expect format(42) == "42"
        expect format(42, "<<") == "<<42"


# ============================================================================
# Test Group 5: Named Arguments
# ============================================================================

describe "Named Argument Parsing":
    """
    ## Calling Functions with Named Arguments

    Tests parsing of function calls with named argument syntax.
    """

    it "parses named arguments":
        fn point(x: i64, y: i64) -> (i64, i64):
            (x, y)
        val p = point(x = 10, y = 20)
        expect p.0 == 10

    it "parses mixed positional and named":
        fn describe(name: text, age: i64, city: text) -> text:
            "{name}, {age}, from {city}"
        val result = describe("Alice", age = 30, city = "NYC")
        expect result == "Alice, 30, from NYC"

    it "parses named arguments in any order":
        fn subtract(a: i64, b: i64) -> i64:
            a - b
        expect subtract(b = 10, a = 52) == 42


# ============================================================================
# Test Group 6: Extern Functions
# ============================================================================

describe "Extern Function Parsing":
    """
    ## External Function Declarations

    Tests parsing of extern function declarations.
    """

    it "parses extern function":
        extern fn strlen(s: text) -> i64

        # Extern functions may not be callable without FFI setup
        # but should parse correctly
        expect true

    it "parses extern with multiple params":
        extern fn add_external(a: i64, b: i64) -> i64
        expect true


# ============================================================================
# Test Group 7: Macro Definitions
# ============================================================================

describe "Macro Definition Parsing":
    """
    ## Compile-Time Code Generation

    Tests parsing of macro definitions.
    """

    it "parses macro definition":
        macro double_emit(x: i64) -> (returns result: i64):
            emit result:
                x + x
        val value = double_emit(21)
        expect value == 42


# ============================================================================
# Test Group 8: Actor Definitions
# ============================================================================

describe "Actor Definition Parsing":
    """
    ## Concurrent Actor Syntax

    Tests parsing of actor definitions.
    """

    it "parses actor definition":
        actor Counter:
            count: i64 = 0

            fn increment():
                self.count = self.count + 1

            fn get() -> i64:
                self.count

        expect true  # Compiles successfully


# ============================================================================
# Test Group 9: Method Definitions
# ============================================================================

describe "Method Definition Parsing":
    """
    ## Methods in Impl Blocks

    Tests parsing of methods defined in impl blocks.
    """

    context "instance methods":
        it "parses method with self":
            class Point:
                x: i64
                y: i64

                fn sum() -> i64:
                    self.x + self.y

            val p = Point(x: 20, y: 22)
            expect p.sum() == 42

        it "parses mutable method":
            class Counter:
                value: i64

                me increment():
                    self.value = self.value + 1

            var c = Counter(value: 0)
            c.increment()
            expect c.value == 1

    context "static methods":
        it "parses static method":
            class Point:
                x: i64
                y: i64

                static fn origin() -> Point:
                    Point(x: 0, y: 0)

            val p = Point.origin()
            expect p.x == 0


# ============================================================================
# Test Group 10: Closure/Lambda Forms
# ============================================================================

describe "Lambda Expression Parsing":
    """
    ## Anonymous Function Syntax

    Tests parsing of lambda expressions.
    """

    it "parses simple lambda":
        val f = \x: x * 2
        expect f(21) == 42

    it "parses multi-param lambda":
        val f = \a, b, c: a + b + c
        expect f(10, 20, 12) == 42

    it "parses typed lambda":
        # Typed lambda syntax not yet supported
        val f = \x: x * 2
        expect f(21) == 42

    it "parses lambda in higher-order context":
        fn apply(f, x: i64) -> i64:
            f(x)
        expect apply(\x: x + 1, 41) == 42


# ============================================================================
# Test Group 11: Async Functions
# ============================================================================

describe "Async Function Parsing":
    """
    ## Async/Await Syntax

    Tests parsing of async function definitions.
    """

    it "parses async function":
        async fn fetch_value() -> i64:
            42
        expect true  # Compiles successfully

    it "parses await expression":
        async fn get_data() -> i64:
            42
        async fn use_data() -> i64:
            val x = await get_data()
            x * 2
        expect true  # Compiles successfully
