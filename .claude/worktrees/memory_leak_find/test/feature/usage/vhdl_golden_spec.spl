"""
# VHDL Golden File Tests

**Feature ID:** #VHDL-001
**Category:** Compiler
**Status:** Active

## Overview

Generates VHDL output from the VhdlBuilder and compares against checked-in
reference .vhd golden files for regression testing. Validates counter and ALU
entity generation including library headers, entity/architecture blocks, port
declarations, signal assignments, clocked processes, and combinational logic.
Also performs structural sanity checks on generated VHDL output.

## Syntax

```simple
var builder = VhdlBuilder__create("counter")
builder.emit_library_header()
builder.emit_entity_begin("counter")
builder.emit_port("clk", "in", mapper.bit_type(), false)
val vhdl = builder.build()
```
"""
# VHDL Golden File Tests
#
# Generates VHDL output from the builder and compares against
# checked-in reference .vhd files in examples/vhdl/golden/.

use compiler.backend.vhdl_type_mapper.VhdlTypeMapper
use compiler.backend.vhdl.vhdl_builder.VhdlBuilder
use app.io.vhdl_ffi.{vhdl_read_file, vhdl_file_exists}
use std.spec.{check, check_msg}

# ============================================================================
# Golden File Helpers
# ============================================================================

fn golden_path(name: text) -> text:
    "examples/vhdl/golden/{name}.vhd"

fn normalize(vhdl: text) -> text:
    """Strip trailing whitespace from each line for comparison."""
    var lines = vhdl.split("\n")
    var result: [text] = []
    for line in lines:
        result = result.push(line.trim_end())
    result.join("\n").trim()

fn build_counter() -> text:
    val mapper = VhdlTypeMapper__create()
    var builder = VhdlBuilder__create("counter")
    builder.emit_library_header()
    builder.emit_entity_begin("counter")
    builder.emit_port_begin()
    builder.emit_port("clk", "in", mapper.bit_type(), false)
    builder.emit_port("rst", "in", mapper.bit_type(), false)
    builder.emit_port("en", "in", mapper.bit_type(), false)
    builder.emit_port("count", "out", mapper.map_unsigned(8), true)
    builder.emit_port_end()
    builder.emit_entity_end("counter")
    builder.emit_architecture_begin("counter", "rtl")
    builder.emit_signal_decl("count_reg", mapper.map_unsigned(8), Some("(others => '0')"))
    builder.emit_architecture_body_begin()
    builder.emit_clocked_process_begin(Some("count_proc"), "clk", Some("rst"))
    builder.emit_process_body_begin()
    builder.emit_if_begin("rst = '1'")
    builder.emit_signal_assign("count_reg", "(others => '0')")
    builder.emit_elsif("rising_edge(clk)")
    builder.emit_if_begin("en = '1'")
    builder.emit_signal_assign("count_reg", "count_reg + 1")
    builder.emit_if_end()
    builder.emit_if_end()
    builder.emit_process_end(Some("count_proc"))
    builder.emit_signal_assign("count", "count_reg")
    builder.emit_architecture_end("rtl")
    builder.build()

fn build_alu() -> text:
    val mapper = VhdlTypeMapper__create()
    var builder = VhdlBuilder__create("alu")
    builder.emit_library_header()
    builder.emit_entity_begin("alu")
    builder.emit_port_begin()
    builder.emit_port("a", "in", mapper.map_signed(32), false)
    builder.emit_port("b", "in", mapper.map_signed(32), false)
    builder.emit_port("op", "in", mapper.map_unsigned(2), false)
    builder.emit_port("result", "out", mapper.map_signed(32), false)
    builder.emit_port("zero", "out", mapper.bit_type(), true)
    builder.emit_port_end()
    builder.emit_entity_end("alu")
    builder.emit_architecture_begin("alu", "rtl")
    builder.emit_signal_decl("alu_result", mapper.map_signed(32), nil)
    builder.emit_architecture_body_begin()
    builder.emit_process_begin(Some("alu_proc"), ["a", "b", "op"])
    builder.emit_process_body_begin()
    builder.emit_if_begin("op = \"00\"")
    builder.emit_signal_assign("alu_result", "a + b")
    builder.emit_elsif("op = \"01\"")
    builder.emit_signal_assign("alu_result", "a - b")
    builder.emit_elsif("op = \"10\"")
    builder.emit_signal_assign("alu_result", "a and b")
    builder.emit_else()
    builder.emit_signal_assign("alu_result", "a or b")
    builder.emit_if_end()
    builder.emit_process_end(Some("alu_proc"))
    builder.emit_signal_assign("result", "alu_result")
    builder.emit_comment("Zero flag: '1' when result is all zeros")
    builder.emit_signal_assign("zero", "'1' when alu_result = 0 else '0'")
    builder.emit_architecture_end("rtl")
    builder.build()

# ============================================================================
# Golden Diff Tests
# ============================================================================

describe "VHDL Golden File Tests":
    """

    ## Golden File Regression

    Compares builder output against reference .vhd files.
    If these fail, either the builder changed (update golden) or a regression.
    """

    it "counter matches golden reference":
        val generated = normalize(build_counter())
        val golden_file = golden_path("counter")
        check(vhdl_file_exists(golden_file))
        val golden_content = vhdl_read_file(golden_file)
        check(golden_content.?)
        val expected = normalize(golden_content.unwrap())
        expect(generated).to_equal(expected)

    it "ALU matches golden reference":
        val generated = normalize(build_alu())
        val golden_file = golden_path("alu")
        check(vhdl_file_exists(golden_file))
        val golden_content = vhdl_read_file(golden_file)
        check(golden_content.?)
        val expected = normalize(golden_content.unwrap())
        expect(generated).to_equal(expected)

    it "golden files exist on disk":
        check(vhdl_file_exists(golden_path("counter")))
        check(vhdl_file_exists(golden_path("alu")))
        check(vhdl_file_exists(golden_path("fsm")))

describe "VHDL Golden Output Sanity":
    """

    ## Output Sanity Checks

    Verify generated VHDL has correct structural elements.
    """

    it "counter output has required VHDL structure":
        val vhdl = build_counter()
        check(vhdl.contains("library ieee;"))
        check(vhdl.contains("use ieee.numeric_std.all;"))
        check(vhdl.contains("entity counter is"))
        check(vhdl.contains("architecture rtl of counter is"))
        check(vhdl.contains("end entity counter;"))
        check(vhdl.contains("end architecture rtl;"))
        check(vhdl.contains("rising_edge(clk)"))

    it "ALU output has required VHDL structure":
        val vhdl = build_alu()
        check(vhdl.contains("entity alu is"))
        check(vhdl.contains("signed(31 downto 0)"))
        check(vhdl.contains("alu_proc: process(a, b, op)"))
        check(vhdl.contains("end process alu_proc;"))
