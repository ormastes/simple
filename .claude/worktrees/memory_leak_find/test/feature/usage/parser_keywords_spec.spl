"""
# Parser Keywords Specification

**Feature IDs:** #PARSER-KW-001 to #PARSER-KW-020
**Category:** Infrastructure | Parser
**Status:** Implemented

Tests that all Simple language keywords are correctly recognized and
parsed in their appropriate contexts.
"""


# Module-level test type definitions
struct TestPoint:
    x: i64
    y: i64

impl TestPoint:
    fn get_x() -> i64:
        self.x

    fn get_y() -> i64:
        self.y


# ============================================================================
# Test Group 1: Variable Keywords
# ============================================================================

describe "Variable Keyword Parsing":
    it "val declares immutable variable":
        val x = 42
        expect x == 42

    it "var declares mutable variable":
        var x = 0
        x = 42
        expect x == 42


# ============================================================================
# Test Group 2: Control Flow Keywords
# ============================================================================

describe "Control Flow Keyword Parsing":
    it "parses if statement":
        val result = if true:
            1
        else:
            0
        expect result == 1

    it "parses elif statement":
        val x = 2
        val result = if x == 1:
            "one"
        elif x == 2:
            "two"
        else:
            "other"
        expect result == "two"

    it "parses while loop":
        var x = 0
        while x < 3:
            x = x + 1
        expect x == 3

    it "parses for loop":
        var sum = 0
        for i in [1, 2, 3]:
            sum = sum + i
        expect sum == 6

    it "parses break in loop":
        var x = 0
        while true:
            x = x + 1
            if x >= 5:
                break
        expect x == 5

    it "parses continue in loop":
        var sum = 0
        for i in [1, 2, 3, 4, 5]:
            if i == 3:
                continue
            sum = sum + i
        expect sum == 12

    it "parses return statement":
        fn early_return(x: i64) -> i64:
            if x < 0:
                return 0
            x
        expect early_return(-1) == 0
        expect early_return(5) == 5

    it "parses match expression":
        val result = match 42:
            case 0 => "zero"
            case 42 => "forty-two"
            case _ => "other"
        expect result == "forty-two"


# ============================================================================
# Test Group 3: Logic Keywords
# ============================================================================

describe "Logic Keyword Parsing":
    it "parses and operator":
        expect (true and true) == true
        expect (true and false) == false
        expect (false and true) == false

    it "parses or operator":
        expect (true or true) == true
        expect (true or false) == true
        expect (false or false) == false

    it "parses not operator":
        expect (not false) == true
        expect (not true) == false

    it "parses in operator":
        expect 2 in [1, 2, 3]
        expect not (5 in [1, 2, 3])


# ============================================================================
# Test Group 4: Special Keywords
# ============================================================================

describe "Special Keyword Parsing":
    it "parses true":
        val x = true
        expect x

    it "parses false":
        val x = false
        expect not x

    it "parses nil":
        val x = nil
        expect x == nil

    it "parses self in method":
        val p = TestPoint(x: 42, y: 10)
        expect p.get_x() == 42
        expect p.get_y() == 10


# ============================================================================
# Test Group 5: Function Keywords
# ============================================================================

describe "Function Keyword Parsing":
    it "parses fn declaration":
        fn add(a: i64, b: i64) -> i64:
            a + b
        expect add(3, 4) == 7

    it "parses nested function":
        fn outer(x: i64) -> i64:
            fn inner(y: i64) -> i64:
                y * 2
            inner(x) + 1
        expect outer(5) == 11

    it "parses lambda expression":
        val double = \x: x * 2
        expect double(5) == 10

    it "parses higher-order function":
        fn apply(f: fn(i64) -> i64, x: i64) -> i64:
            f(x)
        expect apply(\n: n + 1, 5) == 6
