"""
# Lambdas and Closures Specification


**Feature IDs:** #2300
**Category:** Language
**Status:** Implemented

Lambdas (anonymous functions) and closures enable functional programming patterns.

## Key Concepts

| Concept | Description |
|---------|-------------|
| Lambda | Anonymous function defined inline with `\` syntax |
| Closure | Function that captures variables from enclosing scope |
| Higher-Order Function | Function taking or returning other functions |
"""



# ============================================================================
# Test Group 1: Basic Lambdas
# ============================================================================

describe "Basic Lambdas":
    """
    ## Basic Lambda Definition

    Tests simple lambda creation and invocation.
    """

    it "creates simple lambda":
        val double = \x: x * 2
        expect double(21) == 42

    it "creates lambda with multiple params":
        val add = \x, y: x + y
        expect add(15, 27) == 42

    it "creates lambda with no params":
        val answer = \: 42
        expect answer() == 42

    it "invokes lambda immediately":
        val result = (\x: x + 5)(37)
        expect result == 42


# ============================================================================
# Test Group 2: Closures
# ============================================================================

describe "Closures":
    """
    ## Closure Variable Capture

    Tests closures capturing variables from outer scope.
    """

    it "captures outer variable":
        val multiplier = 10
        val multiply = \x: x * multiplier
        expect multiply(4) == 40

    it "captures multiple variables":
        val a = 10
        val b = 5
        val calc = \x: x * a + b
        expect calc(3) == 35

    it "nested lambda calls":
        val double = \x: x * 2
        val add_one = \x: x + 1
        expect add_one(double(20)) == 41


# ============================================================================
# Test Group 3: Lambdas with Collections
# ============================================================================

describe "Lambdas with Collections":
    """
    ## Higher-Order Functions

    Tests lambdas with collection methods.
    """

    it "maps with lambda":
        val numbers = [1, 2, 3]
        val doubled = numbers.map(\x: x * 2)
        expect doubled[0] == 2
        expect doubled[1] == 4
        expect doubled[2] == 6

    it "filters with lambda":
        val numbers = [1, 2, 3, 4, 5, 6]
        val evens = numbers.filter(\x: x % 2 == 0)
        expect evens.len() == 3

    it "reduces with lambda":
        val numbers = [1, 2, 3, 4]
        val sum = numbers.reduce(0, \acc, x: acc + x)
        expect sum == 10


# ============================================================================
# Test Group 4: Lambda Edge Cases
# ============================================================================

describe "Lambda Edge Cases":
    """
    ## Special Cases

    Tests edge cases for lambda behavior.
    """

    it "lambda returning lambda":
        fn make_adder(n):
            return \x: x + n
        val add_five = make_adder(5)
        expect add_five(10) == 15

    it "lambda as function parameter":
        fn apply(f, x):
            return f(x)
        expect apply(\x: x * 2, 21) == 42

    it "lambda with conditional":
        val abs = \x: if x < 0: -x else: x
        expect abs(-5) == 5
        expect abs(5) == 5

