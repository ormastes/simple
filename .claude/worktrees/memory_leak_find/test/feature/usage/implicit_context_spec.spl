"""
# Implicit Context Parameters

**Feature ID:** #CTX-001
**Category:** Language
**Status:** Active

## Overview

Tests implicit context parameters declared with `context val` and bound with
`with_context`. Verifies that context variables work as module-level state
shared across all functions, that nested function calls share the same context,
that context can be swapped between loggers, and that the save-set-restore
pattern correctly preserves outer context after inner scope execution.

## Syntax

```simple
context val logger: TestLogger
with_context(logger: inner_logger):
    _lex("x")
```
"""
# Feature 7: Implicit Context Parameters - End-to-End Tests
#
# Tests demonstrate that context variables declared with `context val`
# and bound with `with_context` work as module-level state shared across
# all functions in the module.
#
# The desugar pass has already transformed these patterns before the
# runtime sees the code, so these tests exercise the generated output
# directly using module-level var semantics.

# ============================================================================
# Simulated Logger for testing
# ============================================================================

class TestLogger:
    messages: i64
    last_msg: text
    me log(msg: text):
        self.messages = self.messages + 1
        self.last_msg = msg
    fn count() -> i64:
        self.messages
    fn last() -> text:
        self.last_msg

# ============================================================================
# Context variable (as desugared by the desugar pass)
# This is what `context val logger: TestLogger` produces after desugar:
# ============================================================================

var __ctx_logger: TestLogger = nil

# ============================================================================
# Functions that use the context variable (as desugared)
# ============================================================================

fn _lex(source: text):
    __ctx_logger.log("lexing: {source}")

fn _parse(source: text):
    __ctx_logger.log("parsing: {source}")
    _lex(source)

fn _compile(source: text):
    __ctx_logger.log("compiling: {source}")
    _parse(source)

# ============================================================================
# Tests
# ============================================================================

describe "Feature 7: Implicit Context Parameters":

    it "context variable is accessible in functions":
        val logger = TestLogger(messages: 0, last_msg: "")
        __ctx_logger = logger
        _lex("x = 1")
        expect(__ctx_logger.count()).to_be_greater_than(0)

    it "functions share the same context variable":
        val logger = TestLogger(messages: 0, last_msg: "")
        __ctx_logger = logger
        _compile("x = 1")
        # _compile calls _parse which calls _lex - all 3 log calls go to same logger
        expect(__ctx_logger.count()).to_equal(3)

    it "last logged message is from deepest function call":
        val logger = TestLogger(messages: 0, last_msg: "")
        __ctx_logger = logger
        _compile("hello")
        # _lex is called last, logs "lexing: hello"
        expect(__ctx_logger.last()).to_start_with("lexing:")

    it "context variable can be swapped for different loggers":
        val logger1 = TestLogger(messages: 0, last_msg: "first")
        val logger2 = TestLogger(messages: 0, last_msg: "second")

        __ctx_logger = logger1
        _lex("a")
        val count1 = __ctx_logger.count()

        __ctx_logger = logger2
        _lex("b")
        val count2 = __ctx_logger.count()

        expect(count1).to_equal(1)
        expect(count2).to_equal(1)

    it "save-set-restore pattern preserves outer context":
        val outer_logger = TestLogger(messages: 0, last_msg: "outer")
        val inner_logger = TestLogger(messages: 0, last_msg: "inner")

        __ctx_logger = outer_logger

        # Simulate: with_context(logger: inner_logger): _lex("x")
        val __saved_logger_0 = __ctx_logger
        __ctx_logger = inner_logger
        _lex("x")
        __ctx_logger = __saved_logger_0

        # After restore, outer logger is active again
        _lex("y")
        expect(__ctx_logger.last()).to_start_with("lexing: y")
        expect(__ctx_logger.count()).to_equal(1)  # outer logger only saw "y"

    it "nil context is default before any with_context":
        __ctx_logger = nil
        val is_nil = __ctx_logger == nil
        expect(is_nil).to_equal(true)

describe "Feature 7: Multiple Context Variables":

    var __ctx_config: text = nil

    fn _print_config():
        __ctx_logger.log("config: {__ctx_config}")

    it "multiple context vars are independent":
        val lg = TestLogger(messages: 0, last_msg: "")
        __ctx_logger = lg
        __ctx_config = "production"
        _print_config()
        expect(__ctx_logger.last()).to_contain("production")

    it "setting one ctx var does not affect others":
        val lg = TestLogger(messages: 0, last_msg: "unchanged")
        __ctx_logger = lg
        __ctx_config = "dev"
        # Changing config should not affect logger
        __ctx_config = "prod"
        val unchanged = __ctx_logger.last() == "unchanged"
        expect(unchanged).to_equal(true)
