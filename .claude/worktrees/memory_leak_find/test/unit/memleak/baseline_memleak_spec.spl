# Baseline Memory Leak Measurement Spec
#
# This spec file is designed to be run as part of a 3-file sequential test
# to measure parent-process memory growth via the --mem-check flag.
#
# Usage:
#   bin/simple test test/unit/memleak/
#
# == Investigation Results (2026-02-22) ==
#
# RESULT: NO parent-side memory leak detected.
#
# The parent test runner's RSS stays flat after initial warmup (~600 kB).
# After the first test file, subsequent tests show 0 kB growth.
# Verified across 3, 74, and 100+ test file runs.
#
# The originally suspected leak sources (below) do NOT cause measurable growth:
#   1. Building child args (array of strings) — negligible
#   2. Capturing stdout/stderr from child (strings) — freed after print
#   3. Creating TestFileResult struct — ~200 bytes each
#   4. Pushing to results/completed_files arrays — absorbed by page allocator
#   5. String interpolation for print_result output — temporary, freed
#
# The REAL memory issue is in CHILD processes that import compiler.core.*
# modules (ast, parser, lexer) — these can consume up to 16GB per child.
# Since each child is a separate process, this does NOT leak into the parent.

extern fn rt_file_read_text(path: text) -> text

describe "Baseline memleak - file 1":
    it "performs string operations to generate typical stdout":
        # Generate output similar to real tests
        # Note: nested fn can't mutate outer closure vars, so we return the array
        fn do_work() -> [text]:
            var out: [text] = []
            var k = 0
            while k < 10:
                out.push("test_{k}_result_string_with_some_padding_data")
                k = k + 1
            out
        val results = do_work()
        print "  Generated {results.len()} result strings"
        expect(results.len()).to_equal(10)

    it "reads /proc/self/status for RSS measurement":
        val status = rt_file_read_text("/proc/self/status") ?? ""
        var rss_line = ""
        if status != "":
            val lines = status.split("\n")
            for line in lines:
                if line.starts_with("VmRSS:"):
                    rss_line = line
        if rss_line != "":
            print "  [RSS] {rss_line}"
        else:
            print "  [RSS] Could not read /proc/self/status"
        expect(1).to_equal(1)

    it "verifies this is a clean child process":
        # This runs in a child process spawned by test runner.
        # The child exits after this file, and OS reclaims all memory.
        # Any leak in the child does NOT affect the parent.
        # The parent's leak is from processing this child's output.
        print "  Child process running - all memory freed on exit"
        expect(1).to_equal(1)
