# Core Simple â€” Option Type Parser Branch Coverage
# Ensures 100% branch coverage for parser_parse_type() Option handling

use compiler.core.parser.{parse_module, parser_has_errors}
use compiler.core.ast.{ast_reset, module_get_decls, decl_get_ret_type}
use compiler.core.types.{TYPE_I64, TYPE_F64, TYPE_TEXT, TYPE_BOOL, TYPE_VOID}
use compiler.core.types.{TYPE_ARRAY_I64, TYPE_ARRAY_TEXT, TYPE_ARRAY_BOOL, TYPE_ARRAY_ANY}
use compiler.core.types.{TYPE_OPTION_I64, TYPE_OPTION_F64, TYPE_OPTION_TEXT, TYPE_OPTION_BOOL}
use compiler.core.types.{TYPE_OPTION, TYPE_RESULT}

fn parse(source: text, path: text):
    ast_reset()
    parse_module(source, path)

fn get_ret_type(source: text) -> i64:
    parse(source, "test.spl")
    val decls = module_get_decls()
    decl_get_ret_type(decls[0])


describe "Option Generic Type Branches":
    # Covers: Option<i64> -> TYPE_OPTION_I64
    it "Option<i64> returns TYPE_OPTION_I64":
        val ret = get_ret_type("fn f() -> Option<i64>:\n    nil\n")
        expect(ret).to_equal(TYPE_OPTION_I64)

    # Covers: Option<f64> -> TYPE_OPTION_F64
    it "Option<f64> returns TYPE_OPTION_F64":
        val ret = get_ret_type("fn f() -> Option<f64>:\n    nil\n")
        expect(ret).to_equal(TYPE_OPTION_F64)

    # Covers: Option<text> -> TYPE_OPTION_TEXT
    it "Option<text> returns TYPE_OPTION_TEXT":
        val ret = get_ret_type("fn f() -> Option<text>:\n    nil\n")
        expect(ret).to_equal(TYPE_OPTION_TEXT)

    # Covers: Option<bool> -> TYPE_OPTION_BOOL
    it "Option<bool> returns TYPE_OPTION_BOOL":
        val ret = get_ret_type("fn f() -> Option<bool>:\n    nil\n")
        expect(ret).to_equal(TYPE_OPTION_BOOL)

    # Covers: Option<Unknown> -> TYPE_OPTION (fallback)
    it "Option<CustomType> returns TYPE_OPTION":
        val ret = get_ret_type("fn f() -> Option<CustomType>:\n    nil\n")
        expect(ret).to_equal(TYPE_OPTION)


describe "Result Generic Type Branches":
    # Covers: Result<T> -> TYPE_RESULT
    it "Result<i64> returns TYPE_RESULT":
        val ret = get_ret_type("fn f() -> Result<i64>:\n    nil\n")
        expect(ret).to_equal(TYPE_RESULT)

    it "Result<text> returns TYPE_RESULT":
        val ret = get_ret_type("fn f() -> Result<text>:\n    nil\n")
        expect(ret).to_equal(TYPE_RESULT)


describe "Unknown Generic Type Branches":
    # Covers: Unknown<T> -> TYPE_VOID (unknown generic)
    it "List<i64> returns TYPE_VOID (unknown generic)":
        val ret = get_ret_type("fn f() -> List<i64>:\n    nil\n")
        expect(ret).to_equal(TYPE_VOID)

    it "Set<text> returns TYPE_VOID (unknown generic)":
        val ret = get_ret_type("fn f() -> Set<text>:\n    nil\n")
        expect(ret).to_equal(TYPE_VOID)


describe "Postfix ? Type Branches":
    # Covers: i64? -> TYPE_OPTION_I64
    it "i64? returns TYPE_OPTION_I64":
        val ret = get_ret_type("fn f() -> i64?:\n    nil\n")
        expect(ret).to_equal(TYPE_OPTION_I64)

    # Covers: f64? -> TYPE_OPTION_F64
    it "f64? returns TYPE_OPTION_F64":
        val ret = get_ret_type("fn f() -> f64?:\n    nil\n")
        expect(ret).to_equal(TYPE_OPTION_F64)

    # Covers: text? -> TYPE_OPTION_TEXT
    it "text? returns TYPE_OPTION_TEXT":
        val ret = get_ret_type("fn f() -> text?:\n    nil\n")
        expect(ret).to_equal(TYPE_OPTION_TEXT)

    # Covers: bool? -> TYPE_OPTION_BOOL
    it "bool? returns TYPE_OPTION_BOOL":
        val ret = get_ret_type("fn f() -> bool?:\n    nil\n")
        expect(ret).to_equal(TYPE_OPTION_BOOL)

    # Covers: CustomType? -> TYPE_OPTION (fallback)
    it "CustomType? returns TYPE_OPTION":
        val ret = get_ret_type("fn f() -> CustomType?:\n    nil\n")
        expect(ret).to_equal(TYPE_OPTION)


describe "Simple Type Branches":
    # Covers: i64 -> TYPE_I64
    it "i64 returns TYPE_I64":
        val ret = get_ret_type("fn f() -> i64:\n    0\n")
        expect(ret).to_equal(TYPE_I64)

    # Covers: f64 -> TYPE_F64
    it "f64 returns TYPE_F64":
        val ret = get_ret_type("fn f() -> f64:\n    0.0\n")
        expect(ret).to_equal(TYPE_F64)

    # Covers: text -> TYPE_TEXT
    it "text returns TYPE_TEXT":
        val ret = get_ret_type("fn f() -> text:\n    \"\"\n")
        expect(ret).to_equal(TYPE_TEXT)

    # Covers: bool -> TYPE_BOOL
    it "bool returns TYPE_BOOL":
        val ret = get_ret_type("fn f() -> bool:\n    true\n")
        expect(ret).to_equal(TYPE_BOOL)

    # Covers: Option (bare) -> TYPE_OPTION
    it "Option (bare) returns TYPE_OPTION":
        val ret = get_ret_type("fn f() -> Option:\n    nil\n")
        expect(ret).to_equal(TYPE_OPTION)

    # Covers: Result (bare) -> TYPE_RESULT
    it "Result (bare) returns TYPE_RESULT":
        val ret = get_ret_type("fn f() -> Result:\n    nil\n")
        expect(ret).to_equal(TYPE_RESULT)

    # Covers: Unknown identifier -> TYPE_VOID
    it "UnknownType returns TYPE_VOID":
        val ret = get_ret_type("fn f() -> UnknownType:\n    nil\n")
        expect(ret).to_equal(TYPE_VOID)


describe "Array Type Branches":
    # Covers: [i64] -> TYPE_ARRAY_I64
    it "[i64] returns TYPE_ARRAY_I64":
        val ret = get_ret_type("fn f() -> [i64]:\n    []\n")
        expect(ret).to_equal(TYPE_ARRAY_I64)

    # Covers: [text] -> TYPE_ARRAY_TEXT
    it "[text] returns TYPE_ARRAY_TEXT":
        val ret = get_ret_type("fn f() -> [text]:\n    []\n")
        expect(ret).to_equal(TYPE_ARRAY_TEXT)

    # Covers: [bool] -> TYPE_ARRAY_BOOL
    it "[bool] returns TYPE_ARRAY_BOOL":
        val ret = get_ret_type("fn f() -> [bool]:\n    []\n")
        expect(ret).to_equal(TYPE_ARRAY_BOOL)

    # Covers: [[i64]] (nested) -> TYPE_ARRAY_ANY
    it "[[i64]] returns TYPE_ARRAY_ANY":
        val ret = get_ret_type("fn f() -> [[i64]]:\n    []\n")
        expect(ret).to_equal(TYPE_ARRAY_ANY)

    # Covers: [[text]] (nested) -> TYPE_ARRAY_ANY
    it "[[text]] returns TYPE_ARRAY_ANY":
        val ret = get_ret_type("fn f() -> [[text]]:\n    []\n")
        expect(ret).to_equal(TYPE_ARRAY_ANY)

    # Covers: [[bool]] (nested) -> TYPE_ARRAY_ANY
    it "[[bool]] returns TYPE_ARRAY_ANY":
        val ret = get_ret_type("fn f() -> [[bool]]:\n    []\n")
        expect(ret).to_equal(TYPE_ARRAY_ANY)

    # Covers: [[[i64]]] (deeply nested) -> TYPE_ARRAY_ANY
    it "[[[i64]]] returns TYPE_ARRAY_ANY":
        val ret = get_ret_type("fn f() -> [[[i64]]]:\n    []\n")
        expect(ret).to_equal(TYPE_ARRAY_ANY)

    # Covers: [unknown] -> TYPE_ARRAY_I64 (default fallback)
    it "[f64] returns TYPE_ARRAY_I64 (default)":
        val ret = get_ret_type("fn f() -> [f64]:\n    []\n")
        expect(ret).to_equal(TYPE_ARRAY_I64)
