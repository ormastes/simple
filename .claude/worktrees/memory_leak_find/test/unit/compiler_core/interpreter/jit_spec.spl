# Core Interpreter â€” JIT Engine Tests
#
# Tests jit.spl threshold tracking, compilation status, and state management.

use compiler.core.interpreter.jit.{jit_init, jit_cleanup}
use compiler.core.interpreter.jit.{jit_record_call, jit_get_call_count}
use compiler.core.interpreter.jit.{jit_should_compile, jit_is_compiled, jit_mark_compiled}
use compiler.core.interpreter.jit.{jit_is_enabled, jit_compiled_count, jit_total_tracked}

describe "Core JIT Engine":
    describe "initialization":
        it "starts disabled with high threshold":
            jit_init(999999, 0)
            expect(jit_is_enabled()).to_equal(false)
            jit_cleanup()

        it "starts enabled with normal threshold":
            jit_init(10, 0)
            expect(jit_is_enabled()).to_equal(true)
            jit_cleanup()

        it "resets state on init":
            jit_init(5, 0)
            jit_record_call("foo")
            jit_mark_compiled("foo")
            jit_init(5, 0)
            expect(jit_get_call_count("foo")).to_equal(0)
            expect(jit_is_compiled("foo")).to_equal(false)
            jit_cleanup()

    describe "call tracking":
        it "tracks call counts":
            jit_init(10, 0)
            jit_record_call("my_fn")
            jit_record_call("my_fn")
            jit_record_call("my_fn")
            expect(jit_get_call_count("my_fn")).to_equal(3)
            jit_cleanup()

        it "tracks multiple functions independently":
            jit_init(10, 0)
            jit_record_call("fn_a")
            jit_record_call("fn_b")
            jit_record_call("fn_a")
            expect(jit_get_call_count("fn_a")).to_equal(2)
            expect(jit_get_call_count("fn_b")).to_equal(1)
            jit_cleanup()

        it "returns zero for untracked functions":
            jit_init(10, 0)
            expect(jit_get_call_count("unknown")).to_equal(0)
            jit_cleanup()

        it "does not track when disabled":
            jit_init(999999, 0)
            jit_record_call("foo")
            expect(jit_get_call_count("foo")).to_equal(0)
            jit_cleanup()

    describe "compilation threshold":
        it "should not compile below threshold":
            jit_init(3, 0)
            jit_record_call("slow_fn")
            jit_record_call("slow_fn")
            expect(jit_should_compile("slow_fn")).to_equal(false)
            jit_cleanup()

        it "should compile at threshold":
            jit_init(3, 0)
            jit_record_call("hot_fn")
            jit_record_call("hot_fn")
            jit_record_call("hot_fn")
            expect(jit_should_compile("hot_fn")).to_equal(true)
            jit_cleanup()

        it "should compile above threshold":
            jit_init(2, 0)
            jit_record_call("very_hot")
            jit_record_call("very_hot")
            jit_record_call("very_hot")
            expect(jit_should_compile("very_hot")).to_equal(true)
            jit_cleanup()

    describe "compilation status":
        it "marks function as compiled":
            jit_init(10, 0)
            expect(jit_is_compiled("fn_x")).to_equal(false)
            jit_mark_compiled("fn_x")
            expect(jit_is_compiled("fn_x")).to_equal(true)
            jit_cleanup()

        it "does not double-mark":
            jit_init(10, 0)
            jit_mark_compiled("fn_y")
            jit_mark_compiled("fn_y")
            expect(jit_compiled_count()).to_equal(1)
            jit_cleanup()

        it "counts compiled functions":
            jit_init(10, 0)
            jit_mark_compiled("a")
            jit_mark_compiled("b")
            jit_mark_compiled("c")
            expect(jit_compiled_count()).to_equal(3)
            jit_cleanup()

    describe "status accessors":
        it "tracks total functions":
            jit_init(10, 0)
            jit_record_call("fn1")
            jit_record_call("fn2")
            jit_record_call("fn3")
            expect(jit_total_tracked()).to_equal(3)
            jit_cleanup()
