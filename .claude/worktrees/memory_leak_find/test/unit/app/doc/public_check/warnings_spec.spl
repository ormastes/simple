# Public Documentation Check - Warning System Tests
#
# Tests for warning generation and formatting

use std.spec
use app.io
use app.doc.public_check.warnings.{
    PublicWarning,
    check_public_comments,
    format_warning,
    emit_warnings,
    warnings_to_json
}

describe "PublicWarning":
    it "creates warning with correct fields":
        val warning = PublicWarning.new(
            "test/module.spl",
            "my_function",
            "function",
            "test/module.spl",
            42
        )

        expect(warning.module_path).to_equal("test/module.spl")
        expect(warning.symbol_name).to_equal("my_function")
        expect(warning.symbol_type).to_equal("function")
        expect(warning.source_file).to_equal("test/module.spl")
        expect(warning.line_number).to_equal(42)
        expect(warning.message).to_contain("my_function")
        expect(warning.message).to_contain("function")

    it "generates descriptive message":
        val warning = PublicWarning.new(
            "src/app/test.spl",
            "TestClass",
            "class",
            "src/app/test.spl",
            10
        )

        expect(warning.message).to_equal("Public class 'TestClass' lacks docstring")

describe "format_warning":
    it "formats warning in compiler style":
        val warning = PublicWarning.new(
            "src/test.spl",
            "test_fn",
            "function",
            "src/test.spl",
            42
        )

        val formatted = format_warning(warning)
        expect(formatted).to_start_with("src/test.spl:42:")
        expect(formatted).to_contain("warning:")
        expect(formatted).to_contain("test_fn")

    it "includes all required components":
        val warning = PublicWarning.new(
            "/home/user/code/module.spl",
            "SomeStruct",
            "struct",
            "/home/user/code/module.spl",
            100
        )

        val formatted = format_warning(warning)
        expect(formatted).to_contain("/home/user/code/module.spl")
        expect(formatted).to_contain("100")
        expect(formatted).to_contain("warning:")
        expect(formatted).to_contain("SomeStruct")

describe "warnings_to_json":
    it "returns empty array for no warnings":
        val json = warnings_to_json([])
        expect(json).to_equal("[]")

    it "generates valid JSON for single warning":
        val warning = PublicWarning.new(
            "test.spl",
            "foo",
            "function",
            "test.spl",
            1
        )

        val json = warnings_to_json([warning])
        expect(json).to_contain("\"module_path\":")
        expect(json).to_contain("\"symbol_name\":")
        expect(json).to_contain("\"symbol_type\":")
        expect(json).to_contain("\"source_file\":")
        expect(json).to_contain("\"line_number\":")
        expect(json).to_contain("\"message\":")
        expect(json).to_start_with("[")
        expect(json).to_end_with("]")

    it "generates valid JSON for multiple warnings":
        val w1 = PublicWarning.new("a.spl", "foo", "function", "a.spl", 1)
        val w2 = PublicWarning.new("b.spl", "bar", "struct", "b.spl", 2)

        val json = warnings_to_json([w1, w2])
        expect(json).to_contain("foo")
        expect(json).to_contain("bar")
        expect(json).to_contain(",")

    it "escapes special JSON characters":
        val warning = PublicWarning.new(
            "test\"quote.spl",
            "test_func",
            "function",
            "test\"quote.spl",
            1
        )

        val json = warnings_to_json([warning])
        expect(json).to_contain("\\\"")
        expect(json).not.to_contain("test\"quote")

describe "check_public_comments with test file":
    before_each:
        # Create a test file with exports but no docstrings
        val test_content = """
# Test module

export undocumented_function
export DocumentedStruct
export another_undocumented

fn undocumented_function():
    pass

\"\"\"Documented struct with docstring.\"\"\"
struct DocumentedStruct:
    field: i64

fn another_undocumented():
    pass
"""
        file_write("/tmp/test_public_check.spl", test_content)

    it "detects missing docstrings":
        val warnings = check_public_comments("/tmp/test_public_check.spl")

        # Should have warnings for undocumented_function and another_undocumented
        # but not for DocumentedStruct
        expect(warnings.len()).to_be_greater_than(0)

    it "does not warn for documented symbols":
        val warnings = check_public_comments("/tmp/test_public_check.spl")

        var found_documented = false
        for warning in warnings:
            if warning.symbol_name == "DocumentedStruct":
                found_documented = true

        expect(found_documented).to_equal(false)

describe "check_public_comments edge cases":
    it "returns empty list for non-existent file":
        val warnings = check_public_comments("/tmp/does_not_exist_123456.spl")
        expect(warnings.len()).to_equal(0)

    it "handles file with no exports":
        val test_content = """
# Module with no exports

fn private_function():
    pass
"""
        file_write("/tmp/test_no_exports.spl", test_content)

        val warnings = check_public_comments("/tmp/test_no_exports.spl")
        expect(warnings.len()).to_equal(0)

    it "handles comma-separated exports":
        val test_content = """
export foo, bar, baz

fn foo():
    pass

fn bar():
    pass

fn baz():
    pass
"""
        file_write("/tmp/test_comma_exports.spl", test_content)

        val warnings = check_public_comments("/tmp/test_comma_exports.spl")
        # Should have 3 warnings, one for each undocumented function
        expect(warnings.len()).to_equal(3)

describe "emit_warnings":
    it "prints warnings to stdout":
        val warning = PublicWarning.new(
            "test.spl",
            "test_fn",
            "function",
            "test.spl",
            10
        )

        # This will print to stdout - we can't easily capture it in tests
        # but we verify it doesn't crash
        emit_warnings([warning])

    it "handles empty warning list":
        # Should not crash
        emit_warnings([])

describe "symbol type detection":
    it "detects function exports":
        val test_content = """
export my_func

fn my_func(x: i64) -> i64:
    x * 2
"""
        file_write("/tmp/test_func_detect.spl", test_content)

        val warnings = check_public_comments("/tmp/test_func_detect.spl")
        expect(warnings.len()).to_equal(1)
        expect(warnings[0].symbol_type).to_equal("function")

    it "detects struct exports":
        val test_content = """
export MyStruct

struct MyStruct:
    field: i64
"""
        file_write("/tmp/test_struct_detect.spl", test_content)

        val warnings = check_public_comments("/tmp/test_struct_detect.spl")
        expect(warnings.len()).to_equal(1)
        expect(warnings[0].symbol_type).to_equal("struct")

    it "detects class exports":
        val test_content = """
export MyClass

class MyClass:
    value: i64
"""
        file_write("/tmp/test_class_detect.spl", test_content)

        val warnings = check_public_comments("/tmp/test_class_detect.spl")
        expect(warnings.len()).to_equal(1)
        expect(warnings[0].symbol_type).to_equal("class")
