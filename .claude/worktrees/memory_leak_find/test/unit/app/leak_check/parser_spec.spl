# Parser spec for leak_check/parser.spl
#
# Tests extract_number_before, extract_number_after, strip_valgrind_prefix,
# parse_asan_output, and parse_valgrind_output.

use app.leak_check.parser.{extract_number_before, extract_number_after, strip_valgrind_prefix, parse_asan_output, parse_valgrind_output}

describe "extract_number_before":
    it "extracts bytes from ASan leak line":
        fn run():
            val line = "Direct leak of 128 byte(s) in 1 object(s) allocated from:"
            val result = extract_number_before(line, " byte(s)")
            expect(result).to_equal(128)
        run()

    it "extracts objects from ASan leak line":
        fn run():
            val line = "Direct leak of 128 byte(s) in 3 object(s) allocated from:"
            val result = extract_number_before(line, " object(s)")
            expect(result).to_equal(3)
        run()

    it "returns 0 when keyword not found":
        fn run():
            val result = extract_number_before("no match here", " byte(s)")
            expect(result).to_equal(0)
        run()

describe "extract_number_after":
    it "extracts number after keyword":
        fn run():
            val line = "definitely lost: 256 bytes in 2 blocks"
            val result = extract_number_after(line, "definitely lost:")
            expect(result).to_equal(256)
        run()

    it "handles comma-separated numbers":
        fn run():
            val line = "definitely lost: 1,024 bytes in 2 blocks"
            val result = extract_number_after(line, "definitely lost:")
            expect(result).to_equal(1024)
        run()

    it "returns 0 when keyword not found":
        fn run():
            val result = extract_number_after("no match", "missing:")
            expect(result).to_equal(0)
        run()

describe "strip_valgrind_prefix":
    it "strips ==PID== prefix":
        fn run():
            val line = "==12345== LEAK SUMMARY:"
            val result = strip_valgrind_prefix(line)
            expect(result).to_equal("LEAK SUMMARY:")
        run()

    it "leaves non-valgrind lines unchanged":
        fn run():
            val line = "normal line"
            val result = strip_valgrind_prefix(line)
            expect(result).to_equal("normal line")
        run()

describe "parse_asan_output":
    it "returns empty report for clean output":
        fn run():
            val output = "program output\nno leaks here"
            val report = parse_asan_output(output)
            expect(report.definitely_lost_bytes).to_equal(0)
            expect(report.leaks.len()).to_equal(0)
            expect(report.tool).to_equal("asan")
        run()

    it "parses a single direct leak without double-counting":
        fn run():
            val output = "Direct leak of 64 byte(s) in 1 object(s) allocated from:\n    #0 0xABCD in malloc\n    #1 0x1234 in main test.c:10\n\nSUMMARY: AddressSanitizer: 64 byte(s) leaked in 1 allocation(s)."
            val report = parse_asan_output(output)
            expect(report.leaks.len()).to_equal(1)
            expect(report.definitely_lost_bytes).to_equal(64)
            expect(report.leaks[0].category).to_equal("definitely_lost")
            expect(report.leaks[0].bytes).to_equal(64)
            expect(report.leaks[0].stack_frames.len()).to_equal(2)
        run()

describe "parse_valgrind_output":
    it "parses LEAK SUMMARY section":
        fn run():
            val output = "==1234== LEAK SUMMARY:\n==1234==    definitely lost: 128 bytes in 2 blocks\n==1234==    indirectly lost: 0 bytes in 0 blocks\n==1234==    possibly lost: 64 bytes in 1 blocks\n==1234==    still reachable: 32 bytes in 1 blocks\n==1234== "
            val report = parse_valgrind_output(output)
            expect(report.tool).to_equal("valgrind")
            expect(report.definitely_lost_bytes).to_equal(128)
            expect(report.possibly_lost_bytes).to_equal(64)
            expect(report.still_reachable_bytes).to_equal(32)
        run()
