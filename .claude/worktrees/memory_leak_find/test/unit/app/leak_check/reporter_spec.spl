# Reporter spec for leak_check/reporter.spl
#
# Tests format_bytes, report_console (no-leak verdict), and escape_sdn.

use app.leak_check.reporter.{format_bytes, report_console, escape_sdn}
use app.leak_check.types.{empty_leak_check_result}

describe "format_bytes":
    it "formats small byte counts":
        fn run():
            val r0 = format_bytes(0)
            expect(r0).to_contain("0")
            val r512 = format_bytes(512)
            expect(r512).to_contain("512")
        run()

    it "formats KB range":
        fn run():
            val r1k = format_bytes(1024)
            expect(r1k).to_contain("KB")
            val r2k = format_bytes(2048)
            expect(r2k).to_contain("KB")
        run()

    it "formats MB range":
        fn run():
            val r1m = format_bytes(1048576)
            expect(r1m).to_contain("MB")
            val r2m = format_bytes(2097152)
            expect(r2m).to_contain("MB")
        run()

describe "report_console":
    it "shows no leaks verdict for clean result":
        fn run():
            val result = empty_leak_check_result()
            val output = report_console(result)
            expect(output).to_contain("No leaks detected")
            expect(output).to_contain("VERDICT")
        run()

    it "shows mode in report":
        fn run():
            val result = empty_leak_check_result()
            val output = report_console(result)
            expect(output).to_contain("Mode: internal")
        run()

describe "escape_sdn":
    it "escapes backslashes":
        fn run():
            val result = escape_sdn("hello world")
            expect(result).to_equal("hello world")
        run()

    it "leaves clean strings unchanged":
        fn run():
            val result = escape_sdn("hello world")
            expect(result).to_equal("hello world")
        run()
