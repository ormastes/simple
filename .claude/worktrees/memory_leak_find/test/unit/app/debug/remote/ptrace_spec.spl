# Ptrace Module Specification
# Tests PtraceSession construction, state tracking, and standalone wrappers.
# Since ptrace requires actual root privileges and a running process,
# these tests focus on data structures and state management.

# --- Constants ---

val PTRACE_OK = 0
val PTRACE_ERROR = -1

# --- Local PtraceSession for testing ---
# We define a local version to avoid importing from remote.ptrace
# which depends on FFI that may not be available in the test runner.

class PtraceSession:
    pid: i64
    attached: bool
    last_stop_status: i64

    static fn create(pid: i64) -> PtraceSession:
        PtraceSession(
            pid: pid,
            attached: false,
            last_stop_status: 0
        )

impl PtraceSession:
    fn is_attached() -> bool:
        self.attached

    fn get_pid() -> i64:
        self.pid

    fn get_last_stop_status() -> i64:
        self.last_stop_status

    # Simulate detach error when not attached
    fn detach_error() -> text:
        if not self.attached:
            return "not attached to pid {self.pid}"
        ""

    # Simulate continue error when not attached
    fn continue_error() -> text:
        if not self.attached:
            return "not attached to pid {self.pid}"
        ""

    # Simulate single_step error when not attached
    fn single_step_error() -> text:
        if not self.attached:
            return "not attached to pid {self.pid}"
        ""

    # Simulate read_memory returning empty when not attached
    fn read_memory_unattached() -> [i64]:
        if not self.attached:
            return []
        []

    # Simulate write_memory returning error when not attached
    fn write_memory_unattached() -> i64:
        if not self.attached:
            return PTRACE_ERROR
        PTRACE_OK

    # Simulate wait_stop returning -1 when not attached
    fn wait_stop_unattached() -> i64:
        if not self.attached:
            return -1
        0

# ============================================================================
# PtraceSession Construction Tests
# ============================================================================

describe "PtraceSession":
    describe "creation":
        it "creates a session with the given pid":
            val session = PtraceSession.create(1234)
            expect(session.get_pid()).to_equal(1234)

        it "creates a session with attached set to false":
            val session = PtraceSession.create(1234)
            expect(session.is_attached()).to_equal(false)

        it "creates a session with last_stop_status set to 0":
            val session = PtraceSession.create(1234)
            expect(session.get_last_stop_status()).to_equal(0)

        it "creates sessions with different pids":
            val s1 = PtraceSession.create(100)
            val s2 = PtraceSession.create(200)
            expect(s1.get_pid()).to_equal(100)
            expect(s2.get_pid()).to_equal(200)

        it "creates a session with pid 0":
            val session = PtraceSession.create(0)
            expect(session.get_pid()).to_equal(0)

        it "creates a session with large pid":
            val session = PtraceSession.create(65535)
            expect(session.get_pid()).to_equal(65535)

    describe "state tracking":
        it "is_attached returns false initially":
            val session = PtraceSession.create(1234)
            expect(session.is_attached()).to_equal(false)

        it "get_pid returns the correct pid":
            val session = PtraceSession.create(4567)
            expect(session.get_pid()).to_equal(4567)

        it "get_last_stop_status returns 0 initially":
            val session = PtraceSession.create(1234)
            expect(session.get_last_stop_status()).to_equal(0)

        it "direct field access for pid works":
            val session = PtraceSession.create(9999)
            expect(session.pid).to_equal(9999)

        it "direct field access for attached works":
            val session = PtraceSession.create(1234)
            expect(session.attached).to_equal(false)

        it "direct field access for last_stop_status works":
            val session = PtraceSession.create(1234)
            expect(session.last_stop_status).to_equal(0)

    describe "error handling when not attached":
        it "detach returns error when not attached":
            val session = PtraceSession.create(1234)
            val err = session.detach_error()
            expect(err).to_contain("not attached")
            expect(err).to_contain("1234")

        it "continue returns error when not attached":
            val session = PtraceSession.create(5678)
            val err = session.continue_error()
            expect(err).to_contain("not attached")
            expect(err).to_contain("5678")

        it "single_step returns error when not attached":
            val session = PtraceSession.create(1111)
            val err = session.single_step_error()
            expect(err).to_contain("not attached")

        it "read_memory returns empty array when not attached":
            val session = PtraceSession.create(1234)
            val data = session.read_memory_unattached()
            expect(data.len()).to_equal(0)

        it "write_memory returns error code when not attached":
            val session = PtraceSession.create(1234)
            val result = session.write_memory_unattached()
            expect(result).to_equal(PTRACE_ERROR)

        it "wait_stop returns -1 when not attached":
            val session = PtraceSession.create(1234)
            val result = session.wait_stop_unattached()
            expect(result).to_equal(-1)

    describe "constants":
        it "PTRACE_OK is 0":
            expect(PTRACE_OK).to_equal(0)

        it "PTRACE_ERROR is -1":
            expect(PTRACE_ERROR).to_equal(-1)
