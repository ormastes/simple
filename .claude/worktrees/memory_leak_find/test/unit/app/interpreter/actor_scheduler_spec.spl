# ActorScheduler Tests
#
# Tests for reductions-based fair scheduling.

use std.spec.{check, check_msg}
use std.actor_scheduler.{
    ActorScheduler, ActorScheduler__new, ActorScheduler__default,
    SchedulerConfig, SchedulerConfig__default, SchedulerConfig__single_threaded,
    SchedulerConfig__low_latency, SchedulerConfig__high_throughput,
    RunQueue, RunQueue__new,
    ActorContext, ActorContext__with_defaults,
    ActorPriority__from_i64,
    ActorState__is_alive, ActorState__can_run, ActorState__fmt,
    SchedulerStats, SchedulerStats__new
}

describe "SchedulerConfig":
    it "creates default config":
        val config = SchedulerConfig__default()

        check(config.reductions_per_timeslice.value == 2000)
        check(config.scheduler_count.value == 4)
        check(config.work_stealing_enabled)
        check(config.priority_scheduling)

    it "creates single-threaded config":
        val config = SchedulerConfig__single_threaded()

        check(config.scheduler_count.value == 1)
        check(not config.work_stealing_enabled)

    it "creates low-latency config":
        val config = SchedulerConfig__low_latency()

        check(config.reductions_per_timeslice.value == 500)

    it "creates high-throughput config":
        val config = SchedulerConfig__high_throughput()

        check(config.reductions_per_timeslice.value == 8000)
        check(not config.priority_scheduling)

describe "ActorPriority":
    it "converts from i64":
        check(ActorPriority__from_i64(0) == 0)
        check(ActorPriority__from_i64(1) == 1)
        check(ActorPriority__from_i64(2) == 2)
        check(ActorPriority__from_i64(99) == 3)

describe "ActorState":
    it "checks alive status":
        check(ActorState__is_alive("runnable"))
        check(ActorState__is_alive("running"))
        check(ActorState__is_alive("waiting"))
        check(ActorState__is_alive("suspended"))
        check(not ActorState__is_alive("exiting"))
        check(not ActorState__is_alive("dead"))

    it "checks can_run status":
        check(ActorState__can_run("runnable"))
        check(not ActorState__can_run("running"))
        check(not ActorState__can_run("waiting"))
        check(not ActorState__can_run("dead"))

    it "formats for display":
        check(ActorState__fmt("runnable") == "runnable")
        check(ActorState__fmt("dead") == "dead")

describe "RunQueue":
    it "creates empty queue":
        val queue = RunQueue__new()

        check(queue.is_empty())
        check(queue.len() == 0)

    it "enqueues by priority":
        var queue = RunQueue__new()

        queue.enqueue(1, 2)  # Normal
        queue.enqueue(2, 1)  # High
        queue.enqueue(3, 3)  # Low

        check(queue.len() == 3)
        check(queue.len_by_priority(2) == 1)
        check(queue.len_by_priority(1) == 1)
        check(queue.len_by_priority(3) == 1)

    it "dequeues by priority order":
        var queue = RunQueue__new()

        queue.enqueue(1, 3)  # Low
        queue.enqueue(2, 2)  # Normal
        queue.enqueue(3, 0)  # Max

        # Should get max priority first
        val first = queue.dequeue()
        check(first == 3)

        val second = queue.dequeue()
        check(second == 2)

        val third = queue.dequeue()
        check(third == 1)

    it "returns nil when empty":
        var queue = RunQueue__new()
        val result = queue.dequeue()

        check(not result.?)

    it "removes specific entry":
        var queue = RunQueue__new()

        queue.enqueue(1, 2)
        queue.enqueue(2, 2)
        queue.enqueue(3, 2)

        queue.remove(2)

        check(queue.len() == 2)

describe "ActorContext":
    it "creates with defaults":
        val ctx = ActorContext__with_defaults(1, "test", 2000)

        check(ctx.id.value == 1)
        check(ctx.has_name)
        check(ctx.priority == 2)
        check(ctx.state == "runnable")
        check(ctx.reductions_left.value == 2000)

    it "consumes reductions":
        var ctx = ActorContext__with_defaults(1, nil, 2000)

        val exhausted1 = ctx.consume_reductions(500)
        check(not exhausted1)
        check(ctx.reductions_left.value == 1500)

        val exhausted2 = ctx.consume_reductions(2000)
        check(exhausted2)
        check(ctx.reductions_left.value < 0)

    it "resets reductions":
        var ctx = ActorContext__with_defaults(1, nil, 2000)

        ctx.consume_reductions(2000)
        ctx.reset_reductions(2000)

        check(ctx.reductions_left.value == 2000)
        check(ctx.timeslice_count.value == 1)

    it "transitions states":
        var ctx = ActorContext__with_defaults(1, nil, 2000)

        ctx.set_running()
        check(ctx.state == "running")

        ctx.set_waiting()
        check(ctx.state == "waiting")

        ctx.set_suspended()
        check(ctx.state == "suspended")

        ctx.set_runnable()
        check(ctx.state == "runnable")

        ctx.set_dead()
        check(ctx.state == "dead")

    it "manages links":
        var ctx = ActorContext__with_defaults(1, nil, 2000)

        ctx.link(2)
        ctx.link(3)

        check(ctx.links.len() == 2)

        ctx.unlink(2)

        check(ctx.links.len() == 1)
        check(ctx.links[0] == 3)

    it "manages monitors":
        var ctx = ActorContext__with_defaults(1, nil, 2000)

        ctx.monitor(5)
        ctx.add_monitored_by(10)

        check(ctx.monitors.len() == 1)
        check(ctx.monitored_by.len() == 1)

        ctx.demonitor(5)
        ctx.remove_monitored_by(10)

        check(ctx.monitors.len() == 0)
        check(ctx.monitored_by.len() == 0)

    it "formats for display":
        val ctx = ActorContext__with_defaults(1, "worker", 2000)
        val s = ctx.fmt()

        check(s.contains("Actor"))
        check(s.contains("worker"))

describe "ActorScheduler - Spawning":
    it "spawns actors":
        var scheduler = ActorScheduler__default()

        val id1 = scheduler.spawn_actor("actor1")
        val id2 = scheduler.spawn_actor("actor2")

        check(id1 == 0)
        check(id2 == 1)
        check(scheduler.actor_count() == 2)

    it "spawns with priority":
        var scheduler = ActorScheduler__default()

        val id = scheduler.spawn_with_priority("high", 1)
        val act = scheduler.get_actor(id)

        check(act.?)
        check(act.priority == 1)

    it "updates stats on spawn":
        var scheduler = ActorScheduler__default()

        scheduler.spawn_actor(nil)
        scheduler.spawn_actor(nil)

        val stats = scheduler.get_stats()
        check(stats.total_actors_created.value == 2)
        check(stats.current_actor_count.value == 2)
        check(stats.peak_actor_count.value == 2)

describe "ActorScheduler - Termination":
    it "terminates actors":
        var scheduler = ActorScheduler__default()

        val id = scheduler.spawn_actor("test")
        scheduler.terminate(id)

        val act = scheduler.get_actor(id)
        check(act.?)
        check(act.state == "dead")

    it "updates stats on termination":
        var scheduler = ActorScheduler__default()

        val id = scheduler.spawn_actor(nil)
        scheduler.terminate(id)

        val stats = scheduler.get_stats()
        check(stats.total_actors_terminated.value == 1)
        check(stats.current_actor_count.value == 0)

describe "ActorScheduler - Scheduling":
    it "runs one timeslice":
        var scheduler = ActorScheduler__default()
        scheduler.spawn_actor(nil)

        val did_work = scheduler.run_one_timeslice()

        check(did_work)

    it "returns false when no runnable":
        var scheduler = ActorScheduler__default()

        val did_work = scheduler.run_one_timeslice()

        check(not did_work)

    it "tracks context switches":
        var scheduler = ActorScheduler__default()
        scheduler.spawn_actor(nil)

        scheduler.run_one_timeslice()
        scheduler.run_one_timeslice()

        val stats = scheduler.get_stats()
        check(stats.total_context_switches.value >= 2)

    it "runs n timeslices":
        var scheduler = ActorScheduler__new(SchedulerConfig__single_threaded())

        scheduler.spawn_actor(nil)
        scheduler.spawn_actor(nil)

        scheduler.start()
        scheduler.run_n_timeslices(5)

        val stats = scheduler.get_stats()
        check(stats.total_timeslices.value == 5)

    it "checks runnable status":
        var scheduler = ActorScheduler__default()

        check(not scheduler.has_runnable())

        scheduler.spawn_actor(nil)
        check(scheduler.has_runnable())

describe "ActorScheduler - Wake/Suspend":
    it "suspends actor":
        var scheduler = ActorScheduler__default()
        val id = scheduler.spawn_actor(nil)

        scheduler.suspend_actor(id)

        val act = scheduler.get_actor(id)
        check(act.?)
        check(act.state == "suspended")

    it "resumes actor":
        var scheduler = ActorScheduler__default()
        val id = scheduler.spawn_actor(nil)

        scheduler.suspend_actor(id)
        scheduler.resume_actor(id)

        val act = scheduler.get_actor(id)
        check(act.?)
        check(act.state == "runnable")

describe "ActorScheduler - Messaging":
    it "sends message":
        var scheduler = ActorScheduler__default()
        val id = scheduler.spawn_actor(nil)

        val success = scheduler.send_message(id, 12345, 100, nil)

        check(success)

        val act = scheduler.get_actor(id)
        check(act.?)
        check(act.mailbox.total_size() == 1)

    it "sends high priority message":
        var scheduler = ActorScheduler__default()
        val id = scheduler.spawn_actor(nil)

        val success = scheduler.send_high_priority(id, 12345, 100, nil)

        check(success)

    it "fails to send to nonexistent":
        var scheduler = ActorScheduler__default()

        val success = scheduler.send_message(999, 12345, 100, nil)

        check(not success)

describe "ActorScheduler - Linking":
    it "links actors":
        var scheduler = ActorScheduler__default()
        val id1 = scheduler.spawn_actor(nil)
        val id2 = scheduler.spawn_actor(nil)

        scheduler.link_actors(id1, id2)

        val act1 = scheduler.get_actor(id1)
        val act2 = scheduler.get_actor(id2)

        check(act1.?)
        check(act1.links.contains(id2))
        check(act2.?)
        check(act2.links.contains(id1))

    it "unlinks actors":
        var scheduler = ActorScheduler__default()
        val id1 = scheduler.spawn_actor(nil)
        val id2 = scheduler.spawn_actor(nil)

        scheduler.link_actors(id1, id2)
        scheduler.unlink_actors(id1, id2)

        val act1 = scheduler.get_actor(id1)
        check(act1.?)
        check(not act1.links.contains(id2))

describe "ActorScheduler - Monitoring":
    it "sets up monitoring":
        var scheduler = ActorScheduler__default()
        val monitor_id = scheduler.spawn_actor("monitor_actor")
        val target_id = scheduler.spawn_actor("target")

        scheduler.monitor_actor(monitor_id, target_id)

        val mon = scheduler.get_actor(monitor_id)
        val tgt = scheduler.get_actor(target_id)

        check(mon.?)
        check(mon.monitors.contains(target_id))
        check(tgt.?)
        check(tgt.monitored_by.contains(monitor_id))

    it "removes monitoring":
        var scheduler = ActorScheduler__default()
        val monitor_id = scheduler.spawn_actor(nil)
        val target_id = scheduler.spawn_actor(nil)

        scheduler.monitor_actor(monitor_id, target_id)
        scheduler.demonitor_actor(monitor_id, target_id)

        val mon = scheduler.get_actor(monitor_id)
        check(mon.?)
        check(not mon.monitors.contains(target_id))

describe "ActorScheduler - Statistics":
    it "reports utilization":
        var scheduler = ActorScheduler__default()
        scheduler.spawn_actor(nil)
        scheduler.run_one_timeslice()

        val stats = scheduler.get_stats()
        check(stats.utilization() >= 0.0)

    it "tracks reductions":
        var scheduler = ActorScheduler__default()
        scheduler.spawn_actor(nil)
        scheduler.run_one_timeslice()

        val stats = scheduler.get_stats()
        check(stats.total_reductions_executed.value == 2000)

describe "ActorScheduler - Display":
    it "formats scheduler for display":
        val scheduler = ActorScheduler__default()
        val s = scheduler.fmt()

        check(s.contains("ActorScheduler"))

    it "formats stats for display":
        val stats = SchedulerStats__new()
        val s = stats.fmt()

        check(s.contains("SchedulerStats"))
