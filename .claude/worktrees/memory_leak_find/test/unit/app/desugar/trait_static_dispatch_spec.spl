# Trait Static Dispatch Rewrite Tests
#
# Tests the trait_static_dispatch module which rewrites function signatures
# with trait-typed parameters into generic (monomorphized) signatures.
#
# Key behavior:
#   fn f(x: Trait)       -> fn f<__T0: Trait>(x: __T0)     (static)
#   fn f(x: dyn Trait)   -> unchanged                       (dynamic)
#   fn f(x: Interface)   -> unchanged                       (interface = dynamic)

use app.desugar.trait_static_dispatch (desugar_trait_static_dispatch)

describe "desugar_trait_static_dispatch":

    context "basic trait param rewrite":
        it "rewrites single trait param to generic":
            var src = "trait Printable:" + "\n"
            src = src + "    fn print_text() -> text" + "\n"
            src = src + "\n"
            src = src + "fn process(x: Printable):" + "\n"
            src = src + "    x.print_text()" + "\n"
            val out = desugar_trait_static_dispatch(src)
            expect(out).to_contain("fn process<__T0: Printable>(x: __T0):")

        it "rewrites multiple trait params to multiple type vars":
            var src = "trait Printable:" + "\n"
            src = src + "    fn print_text() -> text" + "\n"
            src = src + "\n"
            src = src + "trait Sortable:" + "\n"
            src = src + "    fn sort_key() -> i64" + "\n"
            src = src + "\n"
            src = src + "fn both(a: Printable, b: Sortable):" + "\n"
            src = src + "    pass_do_nothing" + "\n"
            val out = desugar_trait_static_dispatch(src)
            expect(out).to_contain("fn both<__T0: Printable, __T1: Sortable>(a: __T0, b: __T1):")

        it "rewrites mixed trait and non-trait params":
            var src = "trait Printable:" + "\n"
            src = src + "    fn print_text() -> text" + "\n"
            src = src + "\n"
            src = src + "fn show(x: Printable, n: i64):" + "\n"
            src = src + "    pass_do_nothing" + "\n"
            val out = desugar_trait_static_dispatch(src)
            expect(out).to_contain("fn show<__T0: Printable>(x: __T0, n: i64):")

    context "me methods":
        it "rewrites me method same as fn":
            var src = "trait Updatable:" + "\n"
            src = src + "    me update(val: i64)" + "\n"
            src = src + "\n"
            src = src + "me apply(target: Updatable):" + "\n"
            src = src + "    target.update(42)" + "\n"
            val out = desugar_trait_static_dispatch(src)
            expect(out).to_contain("me apply<__T0: Updatable>(target: __T0):")

    context "dyn prefix preserves dynamic dispatch":
        it "does not rewrite dyn Trait params":
            var src = "trait Printable:" + "\n"
            src = src + "    fn print_text() -> text" + "\n"
            src = src + "\n"
            src = src + "fn process(x: dyn Printable):" + "\n"
            src = src + "    x.print_text()" + "\n"
            val out = desugar_trait_static_dispatch(src)
            expect(out).to_contain("fn process(x: dyn Printable):")

    context "interface params stay dynamic":
        it "does not rewrite interface-typed params":
            var src = "interface Drawable:" + "\n"
            src = src + "    fn draw()" + "\n"
            src = src + "\n"
            src = src + "fn render(x: Drawable):" + "\n"
            src = src + "    x.draw()" + "\n"
            val out = desugar_trait_static_dispatch(src)
            expect(out).to_contain("fn render(x: Drawable):")

    context "no-rewrite cases":
        it "does not rewrite non-trait types":
            var src = "trait Printable:" + "\n"
            src = src + "    fn print_text() -> text" + "\n"
            src = src + "\n"
            src = src + "fn add(a: i64, b: i64) -> i64:" + "\n"
            src = src + "    a + b" + "\n"
            val out = desugar_trait_static_dispatch(src)
            expect(out).to_contain("fn add(a: i64, b: i64) -> i64:")

        it "does not rewrite already-generic functions":
            var src = "trait Printable:" + "\n"
            src = src + "    fn print_text() -> text" + "\n"
            src = src + "\n"
            src = src + "fn process<T: Printable>(x: T):" + "\n"
            src = src + "    x.print_text()" + "\n"
            val out = desugar_trait_static_dispatch(src)
            expect(out).to_contain("fn process<T: Printable>(x: T):")

        it "does not rewrite array-typed trait params":
            var src = "trait Printable:" + "\n"
            src = src + "    fn print_text() -> text" + "\n"
            src = src + "\n"
            src = src + "fn process_all(items: [Printable]):" + "\n"
            src = src + "    pass_do_nothing" + "\n"
            val out = desugar_trait_static_dispatch(src)
            expect(out).to_contain("fn process_all(items: [Printable]):")

        it "source without traits returns unchanged":
            var src = "fn add(a: i64, b: i64) -> i64:" + "\n"
            src = src + "    a + b" + "\n"
            val out = desugar_trait_static_dispatch(src)
            expect(out).to_contain("fn add(a: i64, b: i64) -> i64:")

    context "return type preservation":
        it "preserves return type after rewrite":
            var src = "trait Printable:" + "\n"
            src = src + "    fn print_text() -> text" + "\n"
            src = src + "\n"
            src = src + "fn describe(x: Printable) -> text:" + "\n"
            src = src + "    x.print_text()" + "\n"
            val out = desugar_trait_static_dispatch(src)
            expect(out).to_contain("fn describe<__T0: Printable>(x: __T0) -> text:")

    context "indentation preservation":
        it "preserves leading indentation":
            var src = "trait Printable:" + "\n"
            src = src + "    fn print_text() -> text" + "\n"
            src = src + "\n"
            src = src + "    fn process(x: Printable):" + "\n"
            src = src + "        x.print_text()" + "\n"
            val out = desugar_trait_static_dispatch(src)
            expect(out).to_contain("    fn process<__T0: Printable>(x: __T0):")
