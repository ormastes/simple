# Static Methods Desugaring Extended Tests
#
# Tests the exported function desugar_static_methods from app.desugar.static_methods
# which transforms static method definitions in impl blocks into module-level functions.
#
# Internal functions tested indirectly:
# - parse_impl_header: impl header parsing
# - split_on_for: splitting "Trait for Type" patterns
# - strip_generics: removing generic parameters
# - extract_generics: extracting generic parameters
# - process_impl_block: separating static and instance methods
# - extract_methods: parsing method blocks from impl body
# - parse_method_header: identifying fn/me/static fn
# - hoist_static_method: transforming static methods to module-level
# - get_indent: measuring leading whitespace

use app.desugar.static_methods (desugar_static_methods)

describe "desugar_static_methods":

    # ================================================================
    # Basic Static Method Hoisting
    # ================================================================

    it "hoists a static fn to module level":
        val input = "impl Point:\n    static fn origin() -> Point:\n        Point(x: 0, y: 0)\n"
        val output = desugar_static_methods(input)
        expect(output).to_contain("fn Point__origin() -> Point:")
        expect(output).to_contain("Point(x: 0, y: 0)")

    it "removes static keyword from hoisted function":
        val input = "impl Foo:\n    static fn bar() -> i64:\n        42\n"
        val output = desugar_static_methods(input)
        expect(output).to_contain("fn Foo__bar() -> i64:")
        # Should not contain "static fn" in the hoisted version
        val has_static = output.contains("static fn Foo__bar")
        expect(has_static).to_equal(false)

    it "hoists multiple static methods from same impl":
        val input = "impl Builder:\n    static fn create() -> Builder:\n        Builder(items: [])\n    static fn from_list(items: [text]) -> Builder:\n        Builder(items: items)\n"
        val output = desugar_static_methods(input)
        expect(output).to_contain("fn Builder__create() -> Builder:")
        expect(output).to_contain("fn Builder__from_list(items: [text]) -> Builder:")

    it "preserves function parameters in hoisted method":
        val input = "impl Parser:\n    static fn new(src: text, mode: i64) -> Parser:\n        Parser(source: src, pos: 0)\n"
        val output = desugar_static_methods(input)
        expect(output).to_contain("fn Parser__new(src: text, mode: i64) -> Parser:")

    it "preserves multi-line body in hoisted method":
        val input = "impl Config:\n    static fn defaults() -> Config:\n        val x = 10\n        val y = 20\n        Config(x: x, y: y)\n"
        val output = desugar_static_methods(input)
        expect(output).to_contain("fn Config__defaults() -> Config:")
        expect(output).to_contain("val x = 10")
        expect(output).to_contain("val y = 20")

    # ================================================================
    # Instance Method Preservation
    # ================================================================

    it "preserves instance methods in impl block":
        val input = "impl Point:\n    static fn origin() -> Point:\n        Point(x: 0, y: 0)\n    fn distance() -> f64:\n        (self.x ** 2 + self.y ** 2).sqrt()\n"
        val output = desugar_static_methods(input)
        expect(output).to_contain("impl Point:")
        expect(output).to_contain("fn distance() -> f64:")

    it "preserves mutable methods (me keyword)":
        val input = "impl Counter:\n    static fn zero() -> Counter:\n        Counter(count: 0)\n    me increment():\n        self.count = self.count + 1\n"
        val output = desugar_static_methods(input)
        expect(output).to_contain("fn Counter__zero() -> Counter:")
        expect(output).to_contain("me increment():")
        expect(output).to_contain("impl Counter:")

    it "keeps multiple instance methods intact":
        val input = "impl Widget:\n    fn width() -> i64:\n        self.w\n    fn height() -> i64:\n        self.h\n"
        val output = desugar_static_methods(input)
        expect(output).to_contain("fn width() -> i64:")
        expect(output).to_contain("fn height() -> i64:")

    # ================================================================
    # Empty Impl Block Handling
    # ================================================================

    it "drops empty impl block when all methods are static":
        val input = "impl Config:\n    static fn defaults() -> Config:\n        Config(value: 0)\n"
        val output = desugar_static_methods(input)
        expect(output).to_contain("fn Config__defaults() -> Config:")
        # Should not have an empty impl block
        val has_impl = output.contains("impl Config:")
        expect(has_impl).to_equal(false)

    it "drops impl when multiple static methods removed":
        val input = "impl Factory:\n    static fn create() -> Factory:\n        Factory()\n    static fn build(x: i64) -> Factory:\n        Factory(val: x)\n"
        val output = desugar_static_methods(input)
        expect(output).to_contain("fn Factory__create()")
        expect(output).to_contain("fn Factory__build(x: i64)")
        val has_impl = output.contains("impl Factory:")
        expect(has_impl).to_equal(false)

    # ================================================================
    # Trait Impl Handling
    # ================================================================

    it "handles trait for type impl pattern":
        val input = "impl Display for Point:\n    fn format() -> text:\n        return self.x\n"
        val output = desugar_static_methods(input)
        expect(output).to_contain("impl Display for Point:")
        expect(output).to_contain("fn format() -> text:")

    it "hoists static from trait impl":
        val input = "impl Parseable for Config:\n    static fn parse(s: text) -> Config:\n        Config(value: s)\n    fn to_string() -> text:\n        self.value\n"
        val output = desugar_static_methods(input)
        expect(output).to_contain("fn Config__parse(s: text) -> Config:")
        expect(output).to_contain("impl Parseable for Config:")
        expect(output).to_contain("fn to_string() -> text:")

    # ================================================================
    # Non-Impl Lines Preservation
    # ================================================================

    it "preserves non-impl code untouched":
        val input = "val x = 10\nfn helper() -> i64:\n    42\n"
        val output = desugar_static_methods(input)
        expect(output).to_contain("val x = 10")
        expect(output).to_contain("fn helper() -> i64:")
        expect(output).to_contain("42")

    it "preserves struct definitions":
        val input = "struct Point:\n    x: i64\n    y: i64\n\nimpl Point:\n    static fn origin() -> Point:\n        Point(x: 0, y: 0)\n"
        val output = desugar_static_methods(input)
        expect(output).to_contain("struct Point:")
        expect(output).to_contain("x: i64")
        expect(output).to_contain("y: i64")

    it "preserves comments":
        val input = "# This is a comment\nimpl Foo:\n    static fn bar() -> i64:\n        1\n"
        val output = desugar_static_methods(input)
        expect(output).to_contain("# This is a comment")

    it "preserves blank lines between non-impl code":
        val input = "val a = 1\n\nval b = 2\n"
        val output = desugar_static_methods(input)
        expect(output).to_contain("val a = 1")
        expect(output).to_contain("val b = 2")

    # ================================================================
    # Multiple Impl Blocks
    # ================================================================

    it "handles multiple separate impl blocks":
        val input = "impl Foo:\n    static fn create() -> Foo:\n        Foo()\n\nimpl Bar:\n    static fn build() -> Bar:\n        Bar()\n"
        val output = desugar_static_methods(input)
        expect(output).to_contain("fn Foo__create() -> Foo:")
        expect(output).to_contain("fn Bar__build() -> Bar:")

    it "handles impl block with mixed methods followed by another impl":
        val input = "impl A:\n    static fn make() -> A:\n        A()\n    fn get() -> i64:\n        self.val\n\nimpl B:\n    fn show() -> text:\n        self.name\n"
        val output = desugar_static_methods(input)
        expect(output).to_contain("fn A__make() -> A:")
        expect(output).to_contain("impl A:")
        expect(output).to_contain("fn get() -> i64:")
        expect(output).to_contain("impl B:")
        expect(output).to_contain("fn show() -> text:")

    # ================================================================
    # Generic Types
    # ================================================================

    it "handles impl with generic type":
        val input = "impl Container<T>:\n    static fn empty() -> Container:\n        Container(items: [])\n"
        val output = desugar_static_methods(input)
        expect(output).to_contain("fn Container__empty")

    it "strips generics from type name in hoisted function":
        val input = "impl Option<T>:\n    static fn none() -> Option:\n        nil\n"
        val output = desugar_static_methods(input)
        expect(output).to_contain("fn Option__none")

    # ================================================================
    # Indentation Handling
    # ================================================================

    it "de-indents hoisted method body to module level":
        val input = "impl Math:\n    static fn add(a: i64, b: i64) -> i64:\n        a + b\n"
        val output = desugar_static_methods(input)
        expect(output).to_contain("fn Math__add(a: i64, b: i64) -> i64:")
        expect(output).to_contain("a + b")

    it "handles deeply nested body in hoisted method":
        val input = "impl Logic:\n    static fn check(x: i64) -> bool:\n        if x > 0:\n            return true\n        false\n"
        val output = desugar_static_methods(input)
        expect(output).to_contain("fn Logic__check(x: i64) -> bool:")
        expect(output).to_contain("if x > 0:")
        expect(output).to_contain("return true")

    # ================================================================
    # Edge Cases
    # ================================================================

    it "handles empty input":
        val output = desugar_static_methods("")
        expect(output).to_equal("")

    it "handles input with no impl blocks":
        val input = "fn standalone():\n    pass\n"
        val output = desugar_static_methods(input)
        expect(output).to_contain("fn standalone():")

    it "handles impl with only instance methods unchanged":
        val input = "impl Simple:\n    fn value() -> i64:\n        0\n"
        val output = desugar_static_methods(input)
        expect(output).to_contain("impl Simple:")
        expect(output).to_contain("fn value() -> i64:")

    it "handles static fn with no return type":
        val input = "impl Logger:\n    static fn init():\n        print \"init\"\n"
        val output = desugar_static_methods(input)
        expect(output).to_contain("fn Logger__init():")

    it "preserves return type annotation":
        val input = "impl Creator:\n    static fn make(n: i64) -> Creator:\n        Creator(n: n)\n"
        val output = desugar_static_methods(input)
        expect(output).to_contain("fn Creator__make(n: i64) -> Creator:")

    it "handles static method with complex body":
        val input = "impl Validator:\n    static fn is_valid(s: text) -> bool:\n        val len = s.len()\n        if len == 0:\n            return false\n        if len > 100:\n            return false\n        true\n"
        val output = desugar_static_methods(input)
        expect(output).to_contain("fn Validator__is_valid(s: text) -> bool:")
        expect(output).to_contain("val len = s.len()")
