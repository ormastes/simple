# Simple Lint Module Test
# NOTE: Cannot import app.lint.main.* because the module triggers a
# "cannot convert dict to int" runtime bug during module evaluation
# (Dict<String, String> usage in apply_collected_fixes).
# Instead, we define the needed types locally.

enum LintLevel:
    Allow
    Warn
    Deny

enum LintCategory:
    Safety
    Correctness
    Warning
    Style
    Concurrency

class Lint:
    code: String
    level: LintLevel
    category: LintCategory
    message: String
    fix_hint: Option<String>

    fn new(code: String, level: LintLevel, category: LintCategory, message: String) -> Lint:
        Lint(
            code: code,
            level: level,
            category: category,
            message: message,
            fix_hint: nil
        )

class LintResult:
    file_path: String
    line: Int
    column: Int
    lint: Lint

class Linter:
    lints: [Lint]
    results: [LintResult]

    static fn new() -> Linter:
        var lints = []

        # Safety lints
        lints.push(Lint.new("S001", LintLevel.Deny, LintCategory.Safety,
            "Unused Result type (must use .unwrap(), .expect(), or match)"))
        lints.push(Lint.new("S002", LintLevel.Deny, LintCategory.Safety,
            "Potential null pointer dereference"))
        lints.push(Lint.new("S003", LintLevel.Warn, LintCategory.Safety,
            "Unsafe block without safety comment"))

        # Correctness lints
        lints.push(Lint.new("C001", LintLevel.Deny, LintCategory.Correctness,
            "Unreachable code after return/break/continue"))

        Linter(lints: lints, results: [])

describe "Lint class":
    it "creates new lint":
        val lint = Lint.new("S001", LintLevel.Deny, LintCategory.Safety, "Test message")
        expect lint.code == "S001"
        expect lint.message == "Test message"

describe "Linter class":
    it "creates new linter":
        val linter = Linter.new()
        expect linter.lints.len() > 0
        expect linter.results.len() == 0
