"""
Feature: Simple Dependency Extraction
Category: MCP Integration
Status: Complete

Tests for dependency extraction logic and module import patterns.
"""

use std.spec
use app.mcp.helpers.{LB, RB, jp, js, jo1, jo2, jo3, extract_json_string}

describe "Simple dependency extraction":
    it "parses use statements":
        val source_line = "use std.io as io"
        val has_use = source_line.starts_with("use ")
        expect(has_use).to_equal(true)

    it "parses selective imports":
        val source_line = "use std.math.{abs, max}"
        val has_use = source_line.starts_with("use ")
        val has_selective = source_line.contains("{")
        expect(has_use).to_equal(true)
        expect(has_selective).to_equal(true)

    it "parses from-use imports":
        val source_line = "from utils.helpers use trim, slug"
        val has_from = source_line.starts_with("from ")
        expect(has_from).to_equal(true)

    it "parses pub use reexports":
        val source_line = "pub use app.api"
        val has_pub_use = source_line.starts_with("pub use ")
        expect(has_pub_use).to_equal(true)

    it "detects self-referential cycle":
        val module_name = "core"
        val import_name = "core"
        val is_cycle = module_name == import_name
        expect(is_cycle).to_equal(true)

    it "detects no cycle for different modules":
        val module_name = "app"
        val import_name = "std"
        val is_cycle = module_name == import_name
        expect(is_cycle).to_equal(false)

    it "tracks symbol usage by function":
        val usage = jo2(jp("std.io", js("run")), jp("abs", js("run")))
        val io_fn = extract_json_string(usage, "std.io")
        val abs_fn = extract_json_string(usage, "abs")
        expect(io_fn).to_equal("run")
        expect(abs_fn).to_equal("run")

    it "tracks multiple functions using same symbol":
        val slug_usage = "helper,formatter"
        val used_by_helper = slug_usage.contains("helper")
        val used_by_formatter = slug_usage.contains("formatter")
        expect(used_by_helper).to_equal(true)
        expect(used_by_formatter).to_equal(true)

    it "extracts module path from qualified import":
        val import_path = "foo.bar.baz"
        val has_dots = import_path.contains(".")
        expect(has_dots).to_equal(true)

    it "identifies aliased imports":
        val source_line = "use std.io as io"
        val has_alias = source_line.contains(" as ")
        expect(has_alias).to_equal(true)
