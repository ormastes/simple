"""
Folding Range Specification
Feature: LSP textDocument/foldingRange
Category: LSP, FoldingRange
Status: Complete
"""

use app.mcp.outline_renderer.{scan_source_symbols, OutlineSym}

describe "LSP FoldingRange - compute from outline symbols":
    context "empty source":
        it "returns empty ranges for empty input":
            val lines: [text] = []
            val syms = scan_source_symbols(lines)
            expect(syms.len()).to_equal(0)

    context "single function":
        it "emits range covering function span":
            val lines = ["fn foo():", "    x = 1", "    x"]
            val syms = scan_source_symbols(lines)
            expect(syms.len()).to_equal(1)
            expect(syms[0].start_line).to_equal(1)
            expect(syms[0].end_line).to_equal(3)

        it "single-line function has end_line equal to start_line":
            val lines = ["fn add(x: i64, y: i64) -> i64: x + y"]
            val syms = scan_source_symbols(lines)
            expect(syms.len()).to_equal(1)
            expect(syms[0].start_line).to_equal(syms[0].end_line)

    context "class includes all members":
        it "class span covers all fields and methods":
            val lines = ["class Point:", "    x: i64", "    y: i64", "    fn len() -> f64:", "        0.0"]
            val syms = scan_source_symbols(lines)
            expect(syms.len()).to_equal(1)
            expect(syms[0].kind).to_equal("class")
            expect(syms[0].start_line).to_equal(1)
            expect(syms[0].end_line).to_equal(5)

    context "multiple symbols":
        it "computes non-overlapping spans":
            val lines = ["fn foo():", "    1", "fn bar():", "    2"]
            val syms = scan_source_symbols(lines)
            expect(syms.len()).to_equal(2)
            val first_end = syms[0].end_line
            val second_start = syms[1].start_line
            expect(first_end).to_be_less_than(second_start)

        it "last symbol extends to end of file":
            val lines = ["fn foo():", "    1", "fn bar():", "    2"]
            val syms = scan_source_symbols(lines)
            expect(syms[1].end_line).to_equal(4)

    context "trait and impl support":
        it "trait spans included in ranges":
            val lines = ["trait Drawable:", "    fn draw():"]
            val syms = scan_source_symbols(lines)
            expect(syms.len()).to_equal(1)
            expect(syms[0].kind).to_equal("trait")
            expect(syms[0].start_line).to_equal(1)

        it "impl spans included in ranges":
            val lines = ["impl Drawable:", "    fn draw():", "        ()"]
            val syms = scan_source_symbols(lines)
            expect(syms.len()).to_equal(1)
            expect(syms[0].kind).to_equal("impl")
            expect(syms[0].end_line).to_equal(3)

    context "struct spans":
        it "struct span covers all fields":
            val lines = ["struct Vec2:", "    x: f64", "    y: f64"]
            val syms = scan_source_symbols(lines)
            expect(syms.len()).to_equal(1)
            expect(syms[0].kind).to_equal("struct")
            expect(syms[0].end_line).to_equal(3)

    context "enum spans":
        it "enum span covers all variants":
            val lines = ["enum Status:", "    Ok", "    Err", "    Pending"]
            val syms = scan_source_symbols(lines)
            expect(syms.len()).to_equal(1)
            expect(syms[0].kind).to_equal("enum")
            expect(syms[0].end_line).to_equal(4)
