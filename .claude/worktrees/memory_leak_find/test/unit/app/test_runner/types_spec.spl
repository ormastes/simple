# Test Runner Types Specification
#
# Tests for the test runner type definitions:
# - TestExecutionMode enum
# - TestLevel enum
# - OutputFormat enum
# - TestOptions struct
# - TestFileResult struct (with is_ok method)
# - TestRunResult struct (with is_ok method)
# - SkipFeatureInfo struct

# =========================================================================
# TestExecutionMode enum
# =========================================================================

enum TestExecutionMode:
    Interpreter
    Smf
    Native

# =========================================================================
# TestLevel enum
# =========================================================================

enum TestLevel:
    All
    Unit
    Integration
    System

# =========================================================================
# OutputFormat enum
# =========================================================================

enum OutputFormat:
    Default
    Doc

# =========================================================================
# TestFileResult struct
# =========================================================================

struct TestFileResult:
    path: text
    passed: i64
    failed: i64
    skipped: i64
    pending: i64
    duration_ms: i64
    error: text
    timed_out: bool

fn file_result_is_ok(r: TestFileResult) -> bool:
    r.failed == 0 and r.error == "" and not r.timed_out

# =========================================================================
# TestRunResult struct
# =========================================================================

struct TestRunResult:
    total_passed: i64
    total_failed: i64
    total_skipped: i64
    total_pending: i64
    total_timed_out: i64
    total_duration_ms: i64

fn run_result_is_ok(r: TestRunResult) -> bool:
    r.total_failed == 0 and r.total_timed_out == 0

# =========================================================================
# SkipFeatureInfo struct
# =========================================================================

struct SkipFeatureInfo:
    file_path: text
    title: text
    feature_ids: text
    category: text
    status: text

# =========================================================================
# Tests
# =========================================================================

describe "TestExecutionMode":
    it "creates Interpreter variant":
        val mode = TestExecutionMode.Interpreter
        expect(mode == TestExecutionMode.Interpreter).to_equal(true)

    it "creates Smf variant":
        val mode = TestExecutionMode.Smf
        expect(mode == TestExecutionMode.Smf).to_equal(true)

    it "creates Native variant":
        val mode = TestExecutionMode.Native
        expect(mode == TestExecutionMode.Native).to_equal(true)

    it "distinguishes Interpreter from Smf":
        val a = TestExecutionMode.Interpreter
        val b = TestExecutionMode.Smf
        expect(a == b).to_equal(false)

    it "distinguishes Interpreter from Native":
        val a = TestExecutionMode.Interpreter
        val b = TestExecutionMode.Native
        expect(a == b).to_equal(false)

    it "distinguishes Smf from Native":
        val a = TestExecutionMode.Smf
        val b = TestExecutionMode.Native
        expect(a == b).to_equal(false)

    it "compares equal variants":
        val a = TestExecutionMode.Native
        val b = TestExecutionMode.Native
        expect(a == b).to_equal(true)

describe "TestLevel":
    it "creates All variant":
        val level = TestLevel.All
        expect(level == TestLevel.All).to_equal(true)

    it "creates Unit variant":
        val level = TestLevel.Unit
        expect(level == TestLevel.Unit).to_equal(true)

    it "creates Integration variant":
        val level = TestLevel.Integration
        expect(level == TestLevel.Integration).to_equal(true)

    it "creates System variant":
        val level = TestLevel.System
        expect(level == TestLevel.System).to_equal(true)

    it "distinguishes Unit from Integration":
        expect(TestLevel.Unit == TestLevel.Integration).to_equal(false)

    it "distinguishes All from System":
        expect(TestLevel.All == TestLevel.System).to_equal(false)

describe "OutputFormat":
    it "creates Default variant":
        val fmt = OutputFormat.Default
        expect(fmt == OutputFormat.Default).to_equal(true)

    it "creates Doc variant":
        val fmt = OutputFormat.Doc
        expect(fmt == OutputFormat.Doc).to_equal(true)

    it "distinguishes Default from Doc":
        expect(OutputFormat.Default == OutputFormat.Doc).to_equal(false)

describe "TestFileResult":
    it "creates a result with all fields":
        val r = TestFileResult(
            path: "test/example_spec.spl",
            passed: 10,
            failed: 0,
            skipped: 2,
            pending: 1,
            duration_ms: 500,
            error: "",
            timed_out: false
        )
        expect(r.path).to_equal("test/example_spec.spl")
        expect(r.passed).to_equal(10)
        expect(r.failed).to_equal(0)
        expect(r.skipped).to_equal(2)
        expect(r.pending).to_equal(1)
        expect(r.duration_ms).to_equal(500)
        expect(r.error).to_equal("")
        expect(r.timed_out).to_equal(false)

    it "is_ok returns true when no failures and no error and not timed out":
        val r = TestFileResult(
            path: "passing.spl",
            passed: 5,
            failed: 0,
            skipped: 0,
            pending: 0,
            duration_ms: 100,
            error: "",
            timed_out: false
        )
        expect(file_result_is_ok(r)).to_equal(true)

    it "is_ok returns false when there are failures":
        val r = TestFileResult(
            path: "failing.spl",
            passed: 3,
            failed: 2,
            skipped: 0,
            pending: 0,
            duration_ms: 200,
            error: "",
            timed_out: false
        )
        expect(file_result_is_ok(r)).to_equal(false)

    it "is_ok returns false when there is an error message":
        val r = TestFileResult(
            path: "error.spl",
            passed: 0,
            failed: 0,
            skipped: 0,
            pending: 0,
            duration_ms: 50,
            error: "parse error on line 5",
            timed_out: false
        )
        expect(file_result_is_ok(r)).to_equal(false)

    it "is_ok returns false when timed out":
        val r = TestFileResult(
            path: "slow.spl",
            passed: 0,
            failed: 0,
            skipped: 0,
            pending: 0,
            duration_ms: 120000,
            error: "",
            timed_out: true
        )
        expect(file_result_is_ok(r)).to_equal(false)

    it "is_ok returns false when both failed and error":
        val r = TestFileResult(
            path: "bad.spl",
            passed: 1,
            failed: 1,
            skipped: 0,
            pending: 0,
            duration_ms: 300,
            error: "runtime error",
            timed_out: false
        )
        expect(file_result_is_ok(r)).to_equal(false)

    it "is_ok returns false when all bad conditions":
        val r = TestFileResult(
            path: "worst.spl",
            passed: 0,
            failed: 5,
            skipped: 0,
            pending: 0,
            duration_ms: 120000,
            error: "crash",
            timed_out: true
        )
        expect(file_result_is_ok(r)).to_equal(false)

    it "handles zero counts":
        val r = TestFileResult(
            path: "empty.spl",
            passed: 0,
            failed: 0,
            skipped: 0,
            pending: 0,
            duration_ms: 0,
            error: "",
            timed_out: false
        )
        expect(file_result_is_ok(r)).to_equal(true)
        expect(r.passed).to_equal(0)

    it "stores skipped count separately from failures":
        val r = TestFileResult(
            path: "skipped.spl",
            passed: 0,
            failed: 0,
            skipped: 10,
            pending: 5,
            duration_ms: 10,
            error: "",
            timed_out: false
        )
        expect(file_result_is_ok(r)).to_equal(true)
        expect(r.skipped).to_equal(10)
        expect(r.pending).to_equal(5)

describe "TestRunResult":
    it "creates a result with aggregate counts":
        val r = TestRunResult(
            total_passed: 100,
            total_failed: 0,
            total_skipped: 5,
            total_pending: 3,
            total_timed_out: 0,
            total_duration_ms: 5000
        )
        expect(r.total_passed).to_equal(100)
        expect(r.total_failed).to_equal(0)
        expect(r.total_skipped).to_equal(5)
        expect(r.total_pending).to_equal(3)
        expect(r.total_timed_out).to_equal(0)
        expect(r.total_duration_ms).to_equal(5000)

    it "is_ok returns true when no failures and no timeouts":
        val r = TestRunResult(
            total_passed: 50,
            total_failed: 0,
            total_skipped: 2,
            total_pending: 1,
            total_timed_out: 0,
            total_duration_ms: 3000
        )
        expect(run_result_is_ok(r)).to_equal(true)

    it "is_ok returns false when there are failures":
        val r = TestRunResult(
            total_passed: 48,
            total_failed: 2,
            total_skipped: 0,
            total_pending: 0,
            total_timed_out: 0,
            total_duration_ms: 3000
        )
        expect(run_result_is_ok(r)).to_equal(false)

    it "is_ok returns false when there are timeouts":
        val r = TestRunResult(
            total_passed: 49,
            total_failed: 0,
            total_skipped: 0,
            total_pending: 0,
            total_timed_out: 1,
            total_duration_ms: 125000
        )
        expect(run_result_is_ok(r)).to_equal(false)

    it "is_ok returns false when both failures and timeouts":
        val r = TestRunResult(
            total_passed: 40,
            total_failed: 5,
            total_skipped: 0,
            total_pending: 0,
            total_timed_out: 3,
            total_duration_ms: 360000
        )
        expect(run_result_is_ok(r)).to_equal(false)

    it "handles all zeros":
        val r = TestRunResult(
            total_passed: 0,
            total_failed: 0,
            total_skipped: 0,
            total_pending: 0,
            total_timed_out: 0,
            total_duration_ms: 0
        )
        expect(run_result_is_ok(r)).to_equal(true)

describe "SkipFeatureInfo":
    it "creates with all fields":
        val info = SkipFeatureInfo(
            file_path: "test/features/pattern_matching_spec.spl",
            title: "Pattern Matching Exhaustiveness",
            feature_ids: "PM-001,PM-002",
            category: "pattern_matching",
            status: "planned"
        )
        expect(info.file_path).to_equal("test/features/pattern_matching_spec.spl")
        expect(info.title).to_equal("Pattern Matching Exhaustiveness")
        expect(info.feature_ids).to_equal("PM-001,PM-002")
        expect(info.category).to_equal("pattern_matching")
        expect(info.status).to_equal("planned")

    it "handles empty fields":
        val info = SkipFeatureInfo(
            file_path: "",
            title: "",
            feature_ids: "",
            category: "",
            status: ""
        )
        expect(info.file_path).to_equal("")
        expect(info.title).to_equal("")

    it "handles various status values":
        val planned = SkipFeatureInfo(
            file_path: "a.spl",
            title: "Feature A",
            feature_ids: "F-001",
            category: "core",
            status: "planned"
        )
        expect(planned.status).to_equal("planned")

        val in_progress = SkipFeatureInfo(
            file_path: "b.spl",
            title: "Feature B",
            feature_ids: "F-002",
            category: "core",
            status: "in_progress"
        )
        expect(in_progress.status).to_equal("in_progress")

        val blocked = SkipFeatureInfo(
            file_path: "c.spl",
            title: "Feature C",
            feature_ids: "F-003",
            category: "core",
            status: "blocked"
        )
        expect(blocked.status).to_equal("blocked")
