# Test Runner Client Module Tests
#
# Tests for the embedded test client: output, harness, and assertions.

fn main():
    print "=================================================="
    print "      Test Runner Client Module Tests"
    print "=================================================="
    print ""

    var passed = 0
    var failed = 0

    # =========================================================================
    # Output Tests
    # =========================================================================

    # Test: MessageSender sends ready message
    if test_sender_ready():
        print "[PASS] MessageSender sends ready message"
        passed = passed + 1
    else:
        print "[FAIL] MessageSender sends ready message"
        failed = failed + 1

    # Test: MessageSender sends test_pass message
    if test_sender_test_pass():
        print "[PASS] MessageSender sends test_pass message"
        passed = passed + 1
    else:
        print "[FAIL] MessageSender sends test_pass message"
        failed = failed + 1

    # Test: MessageSender sends test_fail message
    if test_sender_test_fail():
        print "[PASS] MessageSender sends test_fail message"
        passed = passed + 1
    else:
        print "[FAIL] MessageSender sends test_fail message"
        failed = failed + 1

    # Test: MessageSender sends complete message
    if test_sender_complete():
        print "[PASS] MessageSender sends complete message"
        passed = passed + 1
    else:
        print "[FAIL] MessageSender sends complete message"
        failed = failed + 1

    # =========================================================================
    # Harness Tests
    # =========================================================================

    # Test: TestHarness creation
    if test_harness_creation():
        print "[PASS] TestHarness creation"
        passed = passed + 1
    else:
        print "[FAIL] TestHarness creation"
        failed = failed + 1

    # Test: TestHarness pass_test increments count
    if test_harness_pass():
        print "[PASS] TestHarness pass_test increments count"
        passed = passed + 1
    else:
        print "[FAIL] TestHarness pass_test increments count"
        failed = failed + 1

    # Test: TestHarness fail_test increments count
    if test_harness_fail():
        print "[PASS] TestHarness fail_test increments count"
        passed = passed + 1
    else:
        print "[FAIL] TestHarness fail_test increments count"
        failed = failed + 1

    # Test: TestHarness skip_test increments count
    if test_harness_skip():
        print "[PASS] TestHarness skip_test increments count"
        passed = passed + 1
    else:
        print "[FAIL] TestHarness skip_test increments count"
        failed = failed + 1

    # Test: TestHarness is_success
    if test_harness_is_success():
        print "[PASS] TestHarness is_success"
        passed = passed + 1
    else:
        print "[FAIL] TestHarness is_success"
        failed = failed + 1

    # =========================================================================
    # Assert Tests
    # =========================================================================

    # Test: assert_true passes on true
    if test_assert_true_passes():
        print "[PASS] assert_true passes on true"
        passed = passed + 1
    else:
        print "[FAIL] assert_true passes on true"
        failed = failed + 1

    # Test: assert_true fails on false
    if test_assert_true_fails():
        print "[PASS] assert_true fails on false"
        passed = passed + 1
    else:
        print "[FAIL] assert_true fails on false"
        failed = failed + 1

    # Test: assert_eq_i32 passes on equal
    if test_assert_eq_i32_passes():
        print "[PASS] assert_eq_i32 passes on equal"
        passed = passed + 1
    else:
        print "[FAIL] assert_eq_i32 passes on equal"
        failed = failed + 1

    # Test: assert_eq_i32 fails on unequal
    if test_assert_eq_i32_fails():
        print "[PASS] assert_eq_i32 fails on unequal"
        passed = passed + 1
    else:
        print "[FAIL] assert_eq_i32 fails on unequal"
        failed = failed + 1

    # Test: assert_ne_i32 passes on unequal
    if test_assert_ne_i32_passes():
        print "[PASS] assert_ne_i32 passes on unequal"
        passed = passed + 1
    else:
        print "[FAIL] assert_ne_i32 passes on unequal"
        failed = failed + 1

    # Test: AssertCollector collects results
    if test_assert_collector():
        print "[PASS] AssertCollector collects results"
        passed = passed + 1
    else:
        print "[FAIL] AssertCollector collects results"
        failed = failed + 1

    # Test: AssertCollector failure count
    if test_assert_collector_failures():
        print "[PASS] AssertCollector failure count"
        passed = passed + 1
    else:
        print "[FAIL] AssertCollector failure count"
        failed = failed + 1

    # =========================================================================
    # Summary
    # =========================================================================

    print ""
    print "=================================================="
    print "  Summary: {passed}/{passed + failed} passed, {failed} failed"
    print "=================================================="

    if failed == 0:
        print "ALL TESTS PASSED"
    else:
        print "SOME TESTS FAILED"

# =========================================================================
# Output Test Implementations
# =========================================================================

fn test_sender_ready() -> bool:
    var sender = MessageSender_memory()
    sender.send_ready(5)

    val bytes = sender.get_sent_bytes()
    # Should have: magic(1) + version(1) + type(1) + len(2) + payload(8) = 13 bytes
    if bytes.len() != 13:
        return false

    # Check magic and version
    if bytes[0] != 0xAB:
        return false
    if bytes[1] != 0x01:
        return false

    # Check message type (MSG_READY = 0x01)
    if bytes[2] != 0x01:
        return false

    # Check payload length (8 bytes = version + count)
    if bytes[3] != 8 or bytes[4] != 0:
        return false

    true

fn test_sender_test_pass() -> bool:
    var sender = MessageSender_memory()
    sender.send_test_pass(42, 100)

    val bytes = sender.get_sent_bytes()
    # Should have: header(5) + payload(8) = 13 bytes
    if bytes.len() != 13:
        return false

    # Check message type (MSG_TEST_PASS = 0x21)
    if bytes[2] != 0x21:
        return false

    # Check test_id in payload (42 = 0x2A)
    if bytes[5] != 0x2A:
        return false

    true

fn test_sender_test_fail() -> bool:
    var sender = MessageSender_memory()
    sender.send_test_fail(1, 50, 10, 20, 100)

    val bytes = sender.get_sent_bytes()
    # Should have: header(5) + payload(20) = 25 bytes
    if bytes.len() != 25:
        return false

    # Check message type (MSG_TEST_FAIL = 0x22)
    if bytes[2] != 0x22:
        return false

    true

fn test_sender_complete() -> bool:
    var sender = MessageSender_memory()
    sender.send_complete(10, 8, 2, 0)

    val bytes = sender.get_sent_bytes()
    # Should have: header(5) + payload(16) = 21 bytes
    if bytes.len() != 21:
        return false

    # Check message type (MSG_COMPLETE = 0xFF)
    if bytes[2] != 0xFF:
        return false

    true

# =========================================================================
# Harness Test Implementations
# =========================================================================

fn test_harness_creation() -> bool:
    var sender = MessageSender_memory()
    val harness = TestHarness_create(sender, 10)

    harness.get_passed() == 0 and harness.get_failed() == 0 and harness.get_skipped() == 0

fn test_harness_pass() -> bool:
    var sender = MessageSender_memory()
    var harness = TestHarness_create(sender, 10)

    harness.begin_test(1)
    harness.pass_test()

    harness.get_passed() == 1

fn test_harness_fail() -> bool:
    var sender = MessageSender_memory()
    var harness = TestHarness_create(sender, 10)

    harness.begin_test(1)
    harness.fail_test(0, 0, 0)

    harness.get_failed() == 1

fn test_harness_skip() -> bool:
    var sender = MessageSender_memory()
    var harness = TestHarness_create(sender, 10)

    harness.begin_test(1)
    harness.skip_test()

    harness.get_skipped() == 1

fn test_harness_is_success() -> bool:
    var sender = MessageSender_memory()
    var harness = TestHarness_create(sender, 10)

    # No tests yet - should be success
    if not harness.is_success():
        return false

    # Pass a test - still success
    harness.begin_test(1)
    harness.pass_test()
    if not harness.is_success():
        return false

    # Fail a test - no longer success
    harness.begin_test(2)
    harness.fail_test(0, 0, 0)
    if harness.is_success():
        return false

    true

# =========================================================================
# Assert Test Implementations
# =========================================================================

fn test_assert_true_passes() -> bool:
    val result = assert_true(true, 0, 0, 0)
    result.passed

fn test_assert_true_fails() -> bool:
    val result = assert_true(false, 1, 2, 42)
    not result.passed and result.line == 42

fn test_assert_eq_i32_passes() -> bool:
    val result = assert_eq_i32(42, 42, 0, 0, 0)
    result.passed

fn test_assert_eq_i32_fails() -> bool:
    val result = assert_eq_i32(42, 100, 0, 0, 0)
    not result.passed

fn test_assert_ne_i32_passes() -> bool:
    val result = assert_ne_i32(42, 100, 0, 0, 0)
    result.passed

fn test_assert_collector() -> bool:
    var collector = AssertCollector_create()
    collector.add(assert_true(true, 0, 0, 0))
    collector.add(assert_eq_i32(1, 1, 0, 0, 0))

    collector.is_passed()

fn test_assert_collector_failures() -> bool:
    var collector = AssertCollector_create()
    collector.add(assert_true(true, 0, 0, 0))
    collector.add(assert_true(false, 0, 0, 10))  # Fail
    collector.add(assert_true(false, 0, 0, 20))  # Fail

    not collector.is_passed() and collector.failure_count() == 2

# =========================================================================
# Type Definitions (imported from client modules)
# =========================================================================

# From output.spl
class OutputBackend:
    backend_type: i32
    buffer: [i32]

fn OutputBackend_memory() -> OutputBackend:
    OutputBackend(backend_type: 3, buffer: [])

impl OutputBackend:
    me write_byte(b: i32):
        self.buffer.push(b)

    me write_bytes(bytes: [i32]):
        for b in bytes:
            self.write_byte(b)

    fn get_buffer() -> [i32]:
        self.buffer

class MessageSender:
    backend: OutputBackend

fn MessageSender_memory() -> MessageSender:
    MessageSender(backend: OutputBackend_memory())

fn encode_u32(value: i32) -> [i32]:
    [value & 0xFF, (value >> 8) & 0xFF, (value >> 16) & 0xFF, (value >> 24) & 0xFF]

fn encode_u16(value: i32) -> [i32]:
    [value & 0xFF, (value >> 8) & 0xFF]

impl MessageSender:
    me send_message(msg_type: i32, payload: [i32]):
        self.backend.write_byte(0xAB)
        self.backend.write_byte(0x01)
        self.backend.write_byte(msg_type)
        val len_bytes = encode_u16(payload.len() as i32)
        self.backend.write_bytes(len_bytes)
        self.backend.write_bytes(payload)

    me send_ready(test_count: i32):
        var payload: [i32] = []
        for b in encode_u32(1):
            payload.push(b)
        for b in encode_u32(test_count):
            payload.push(b)
        self.send_message(0x01, payload)

    me send_test_start(test_id: i32):
        self.send_message(0x20, encode_u32(test_id))

    me send_test_pass(test_id: i32, duration_ms: i32):
        var payload: [i32] = []
        for b in encode_u32(test_id):
            payload.push(b)
        for b in encode_u32(duration_ms):
            payload.push(b)
        self.send_message(0x21, payload)

    me send_test_fail(test_id: i32, duration_ms: i32, msg_handle: i32, file_handle: i32, line: i32):
        var payload: [i32] = []
        for b in encode_u32(test_id):
            payload.push(b)
        for b in encode_u32(duration_ms):
            payload.push(b)
        for b in encode_u32(msg_handle):
            payload.push(b)
        for b in encode_u32(file_handle):
            payload.push(b)
        for b in encode_u32(line):
            payload.push(b)
        self.send_message(0x22, payload)

    me send_test_skip(test_id: i32):
        self.send_message(0x23, encode_u32(test_id))

    me send_complete(total: i32, passed: i32, failed: i32, skipped: i32):
        var payload: [i32] = []
        for b in encode_u32(total):
            payload.push(b)
        for b in encode_u32(passed):
            payload.push(b)
        for b in encode_u32(failed):
            payload.push(b)
        for b in encode_u32(skipped):
            payload.push(b)
        self.send_message(0xFF, payload)

    fn get_sent_bytes() -> [i32]:
        self.backend.get_buffer()

# From harness.spl
class TestHarness:
    sender: MessageSender
    test_count: i32
    current_test: i32
    test_start_time: i64
    passed: i32
    failed: i32
    skipped: i32

fn TestHarness_create(sender: MessageSender, test_count: i32) -> TestHarness:
    TestHarness(
        sender: sender,
        test_count: test_count,
        current_test: 0,
        test_start_time: 0,
        passed: 0,
        failed: 0,
        skipped: 0
    )

impl TestHarness:
    me begin_test(test_id: i32):
        self.current_test = test_id
        self.sender.send_test_start(test_id)

    me pass_test():
        self.passed = self.passed + 1
        self.sender.send_test_pass(self.current_test, 0)

    me fail_test(msg_handle: i32, file_handle: i32, line: i32):
        self.failed = self.failed + 1
        self.sender.send_test_fail(self.current_test, 0, msg_handle, file_handle, line)

    me skip_test():
        self.skipped = self.skipped + 1
        self.sender.send_test_skip(self.current_test)

    fn get_passed() -> i32:
        self.passed

    fn get_failed() -> i32:
        self.failed

    fn get_skipped() -> i32:
        self.skipped

    fn is_success() -> bool:
        self.failed == 0

# From assert.spl
class AssertResult:
    passed: bool
    msg_handle: i32
    file_handle: i32
    line: i32

fn AssertResult_pass() -> AssertResult:
    AssertResult(passed: true, msg_handle: 0, file_handle: 0, line: 0)

fn AssertResult_fail(msg_handle: i32, file_handle: i32, line: i32) -> AssertResult:
    AssertResult(passed: false, msg_handle: msg_handle, file_handle: file_handle, line: line)

fn assert_true(condition: bool, msg_handle: i32, file_handle: i32, line: i32) -> AssertResult:
    if condition:
        AssertResult_pass()
    else:
        AssertResult_fail(msg_handle, file_handle, line)

fn assert_eq_i32(actual: i32, expected: i32, msg_handle: i32, file_handle: i32, line: i32) -> AssertResult:
    if actual == expected:
        AssertResult_pass()
    else:
        AssertResult_fail(msg_handle, file_handle, line)

fn assert_ne_i32(actual: i32, expected: i32, msg_handle: i32, file_handle: i32, line: i32) -> AssertResult:
    if actual != expected:
        AssertResult_pass()
    else:
        AssertResult_fail(msg_handle, file_handle, line)

class AssertCollector:
    results: [AssertResult]
    all_passed: bool

fn AssertCollector_create() -> AssertCollector:
    AssertCollector(results: [], all_passed: true)

impl AssertCollector:
    me add(result: AssertResult):
        self.results.push(result)
        if not result.passed:
            self.all_passed = false

    fn is_passed() -> bool:
        self.all_passed

    fn failure_count() -> i32:
        var count: i32 = 0
        for r in self.results:
            if not r.passed:
                count = count + 1
        count
