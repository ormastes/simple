# Test Runner Core Module Tests
#
# Tests for the core test runner types, protocol, and formatting.

"""
# Test Runner Core Specification
**Feature IDs:** #TR-001
**Category:** Testing
**Status:** In Progress
"""

# =========================================================================
# Main Test Entry
# =========================================================================

fn main():
    # Test Status Constants
    val TEST_STATUS_PENDING: i32 = 0
    val TEST_STATUS_RUNNING: i32 = 1
    val TEST_STATUS_PASSED: i32 = 2
    val TEST_STATUS_FAILED: i32 = 3
    val TEST_STATUS_SKIPPED: i32 = 4
    val TEST_STATUS_TIMEOUT: i32 = 5
    val TEST_STATUS_CRASHED: i32 = 6

    # Protocol constants
    val PROTO_MAGIC: i32 = 0xAB
    val PROTO_VERSION: i32 = 0x01

    val MSG_READY: i32 = 0x01
    val MSG_TEST_START: i32 = 0x20
    val MSG_TEST_PASS: i32 = 0x21
    val MSG_TEST_FAIL: i32 = 0x22
    val MSG_COMPLETE: i32 = 0xFF

    print "=================================================="
    print "      Test Runner Core Module Tests"
    print "=================================================="
    print ""

    var total = 0
    var passed = 0
    var failed = 0

    # Test 1: TestCase creation
    total = total + 1
    val tc = TestCase_create(1, "should work", "Parser", TEST_STATUS_PENDING)
    if tc.id == 1 and tc.name == "should work" and tc.suite == "Parser":
        print "[PASS] TestCase creation"
        passed = passed + 1
    else:
        print "[FAIL] TestCase creation"
        failed = failed + 1

    # Test 2: TestCase default status
    total = total + 1
    if tc.status == TEST_STATUS_PENDING:
        print "[PASS] TestCase default status is PENDING"
        passed = passed + 1
    else:
        print "[FAIL] TestCase default status is PENDING"
        failed = failed + 1

    # Test 3: TestSuite creation
    total = total + 1
    val suite = TestSuite_create("Parser Tests", "parser_spec.spl")
    if suite.name == "Parser Tests" and suite.test_count == 0:
        print "[PASS] TestSuite creation"
        passed = passed + 1
    else:
        print "[FAIL] TestSuite creation"
        failed = failed + 1

    # Test 4: TestResults empty
    total = total + 1
    val results = TestResults_empty()
    if results.total == 0 and results.passed == 0 and results.failed == 0:
        print "[PASS] TestResults empty"
        passed = passed + 1
    else:
        print "[FAIL] TestResults empty"
        failed = failed + 1

    # Test 5: encode_u32
    total = total + 1
    val bytes = encode_u32(0x12345678)
    if bytes[0] == 0x78 and bytes[1] == 0x56 and bytes[2] == 0x34 and bytes[3] == 0x12:
        print "[PASS] encode_u32 little-endian"
        passed = passed + 1
    else:
        print "[FAIL] encode_u32 little-endian"
        failed = failed + 1

    # Test 6: decode_u32
    total = total + 1
    val decoded = decode_u32(0x78, 0x56, 0x34, 0x12)
    if decoded == 0x12345678:
        print "[PASS] decode_u32"
        passed = passed + 1
    else:
        print "[FAIL] decode_u32 (got {decoded})"
        failed = failed + 1

    # Test 7: encode_u16
    total = total + 1
    val u16_bytes = encode_u16(0x1234)
    if u16_bytes[0] == 0x34 and u16_bytes[1] == 0x12:
        print "[PASS] encode_u16 little-endian"
        passed = passed + 1
    else:
        print "[FAIL] encode_u16 little-endian"
        failed = failed + 1

    # Test 8: decode_u16
    total = total + 1
    val u16_decoded = decode_u16(0x34, 0x12)
    if u16_decoded == 0x1234:
        print "[PASS] decode_u16"
        passed = passed + 1
    else:
        print "[FAIL] decode_u16"
        failed = failed + 1

    # Test 9: Protocol message encoding (test_pass)
    total = total + 1
    val msg = ProtocolMessage_test_pass(42, 100, PROTO_MAGIC, PROTO_VERSION, MSG_TEST_PASS)
    val encoded = msg.encode(PROTO_MAGIC, PROTO_VERSION)
    if encoded[0] == PROTO_MAGIC and encoded[1] == PROTO_VERSION and encoded[2] == MSG_TEST_PASS:
        print "[PASS] ProtocolMessage test_pass encoding"
        passed = passed + 1
    else:
        print "[FAIL] ProtocolMessage test_pass encoding"
        failed = failed + 1

    # Test 10: Protocol parser
    total = total + 1
    var parser = ProtocolParser_create()
    val test_msg = ProtocolMessage_test_pass(1, 50, PROTO_MAGIC, PROTO_VERSION, MSG_TEST_PASS)
    val test_bytes = test_msg.encode(PROTO_MAGIC, PROTO_VERSION)
    parser.feed(test_bytes, PROTO_MAGIC, PROTO_VERSION)
    if parser.has_messages():
        val parsed = parser.pop_message()
        if parsed.valid and parsed.msg_type == MSG_TEST_PASS:
            print "[PASS] ProtocolParser decodes message"
            passed = passed + 1
        else:
            print "[FAIL] ProtocolParser decodes message (invalid)"
            failed = failed + 1
    else:
        print "[FAIL] ProtocolParser decodes message (no messages)"
        failed = failed + 1

    # Test 11: TestPassPayload decode
    total = total + 1
    var parser2 = ProtocolParser_create()
    val msg2 = ProtocolMessage_test_pass(123, 456, PROTO_MAGIC, PROTO_VERSION, MSG_TEST_PASS)
    parser2.feed(msg2.encode(PROTO_MAGIC, PROTO_VERSION), PROTO_MAGIC, PROTO_VERSION)
    if parser2.has_messages():
        val parsed2 = parser2.pop_message()
        val payload = TestPassPayload_decode(parsed2.payload)
        if payload.valid and payload.test_id == 123 and payload.duration_ms == 456:
            print "[PASS] TestPassPayload decode"
            passed = passed + 1
        else:
            print "[FAIL] TestPassPayload decode (got id={payload.test_id}, dur={payload.duration_ms})"
            failed = failed + 1
    else:
        print "[FAIL] TestPassPayload decode (no message)"
        failed = failed + 1

    # Test 12: format_status
    total = total + 1
    val status_str = format_status(TEST_STATUS_PASSED)
    if status_str == "[PASS]":
        print "[PASS] format_status PASSED"
        passed = passed + 1
    else:
        print "[FAIL] format_status PASSED (got {status_str})"
        failed = failed + 1

    # Test 13: format_status FAILED
    total = total + 1
    val fail_str = format_status(TEST_STATUS_FAILED)
    if fail_str == "[FAIL]":
        print "[PASS] format_status FAILED"
        passed = passed + 1
    else:
        print "[FAIL] format_status FAILED"
        failed = failed + 1

    # Test 14: format_duration milliseconds
    total = total + 1
    val dur_str = format_duration(42)
    if dur_str == "42ms":
        print "[PASS] format_duration ms"
        passed = passed + 1
    else:
        print "[FAIL] format_duration ms (got {dur_str})"
        failed = failed + 1

    # Test 15: format_duration seconds
    total = total + 1
    val dur_sec = format_duration(2500)
    if dur_sec == "2.5s":
        print "[PASS] format_duration sec"
        passed = passed + 1
    else:
        print "[FAIL] format_duration sec (got {dur_sec})"
        failed = failed + 1

    # Test 16: StringInternTable
    total = total + 1
    var table = StringInternTable_empty()
    val h1 = table.intern("hello")
    val h2 = table.intern("world")
    val h3 = table.intern("hello")  # Should return same handle
    if h1 == h3 and h1 != h2:
        print "[PASS] StringInternTable reuses handles"
        passed = passed + 1
    else:
        print "[FAIL] StringInternTable reuses handles"
        failed = failed + 1

    # Test 17: StringInternTable get
    total = total + 1
    val retrieved = table.get(h1)
    if retrieved == "hello":
        print "[PASS] StringInternTable get"
        passed = passed + 1
    else:
        print "[FAIL] StringInternTable get (got {retrieved})"
        failed = failed + 1

    # Test 18: TestResults add_test_result
    total = total + 1
    var results2 = TestResults_empty()
    results2.add_test_result(TEST_STATUS_PASSED, 100)
    results2.add_test_result(TEST_STATUS_PASSED, 50)
    results2.add_test_result(TEST_STATUS_FAILED, 200)
    if results2.total == 3 and results2.passed == 2 and results2.failed == 1:
        print "[PASS] TestResults add_test_result"
        passed = passed + 1
    else:
        print "[FAIL] TestResults add_test_result"
        failed = failed + 1

    # Test 19: TestResults success_rate
    total = total + 1
    val rate = results2.success_rate()
    if rate > 66.0 and rate < 67.0:  # Should be ~66.67%
        print "[PASS] TestResults success_rate"
        passed = passed + 1
    else:
        print "[FAIL] TestResults success_rate (got {rate})"
        failed = failed + 1

    # Test 20: Complete message
    total = total + 1
    val complete_msg = ProtocolMessage_complete(10, 8, 2, 0, MSG_COMPLETE)
    var parser3 = ProtocolParser_create()
    parser3.feed(complete_msg.encode(PROTO_MAGIC, PROTO_VERSION), PROTO_MAGIC, PROTO_VERSION)
    if parser3.has_messages():
        val parsed3 = parser3.pop_message()
        if parsed3.msg_type == MSG_COMPLETE:
            val comp_payload = CompletePayload_decode(parsed3.payload)
            if comp_payload.valid and comp_payload.total == 10 and comp_payload.passed == 8:
                print "[PASS] CompletePayload decode"
                passed = passed + 1
            else:
                print "[FAIL] CompletePayload decode (values)"
                failed = failed + 1
        else:
            print "[FAIL] CompletePayload decode (msg_type)"
            failed = failed + 1
    else:
        print "[FAIL] CompletePayload decode (no message)"
        failed = failed + 1

    # Summary
    print ""
    print "=================================================="
    print "  Summary: {passed}/{total} passed, {failed} failed"
    print "=================================================="

    if failed > 0:
        print "SOME TESTS FAILED"
    else:
        print "ALL TESTS PASSED"

# =========================================================================
# Type Implementations
# =========================================================================

class TestCase:
    id: i32
    name: text
    suite: text
    status: i32
    duration_ms: i64
    message: text
    file: text
    line: i32

fn TestCase_create(id: i32, name: text, suite: text, pending_status: i32) -> TestCase:
    TestCase(
        id: id,
        name: name,
        suite: suite,
        status: pending_status,
        duration_ms: 0,
        message: "",
        file: "",
        line: 0
    )

class TestSuite:
    name: text
    file: text
    test_count: i32
    passed_count: i32
    failed_count: i32
    skipped_count: i32
    duration_ms: i64

fn TestSuite_create(name: text, file: text) -> TestSuite:
    TestSuite(
        name: name,
        file: file,
        test_count: 0,
        passed_count: 0,
        failed_count: 0,
        skipped_count: 0,
        duration_ms: 0
    )

class TestResults:
    total: i32
    passed: i32
    failed: i32
    skipped: i32
    timeout: i32
    crashed: i32
    duration_ms: i64
    start_time_ms: i64
    end_time_ms: i64

fn TestResults_empty() -> TestResults:
    TestResults(
        total: 0,
        passed: 0,
        failed: 0,
        skipped: 0,
        timeout: 0,
        crashed: 0,
        duration_ms: 0,
        start_time_ms: 0,
        end_time_ms: 0
    )

impl TestResults:
    fn success_rate() -> f64:
        val executed = self.total - self.skipped
        if executed == 0:
            100.0
        else:
            (self.passed as f64 / executed as f64) * 100.0

    me add_test_result(status: i32, duration: i64):
        self.total = self.total + 1
        self.duration_ms = self.duration_ms + duration
        if status == 2:  # PASSED
            self.passed = self.passed + 1
        elif status == 3:  # FAILED
            self.failed = self.failed + 1
        elif status == 4:  # SKIPPED
            self.skipped = self.skipped + 1
        elif status == 5:  # TIMEOUT
            self.timeout = self.timeout + 1
        elif status == 6:  # CRASHED
            self.crashed = self.crashed + 1

# =========================================================================
# Protocol Implementations
# =========================================================================

fn encode_u16(v: i32) -> [i32]:
    [v & 0xFF, (v >> 8) & 0xFF]

fn decode_u16(b0: i32, b1: i32) -> i32:
    b0 | (b1 << 8)

fn encode_u32(v: i32) -> [i32]:
    [v & 0xFF, (v >> 8) & 0xFF, (v >> 16) & 0xFF, (v >> 24) & 0xFF]

fn decode_u32(b0: i32, b1: i32, b2: i32, b3: i32) -> i32:
    b0 | (b1 << 8) | (b2 << 16) | (b3 << 24)

class ProtocolMessage:
    msg_type: i32
    payload: [i32]

fn ProtocolMessage_test_pass(test_id: i32, duration_ms: i32, magic: i32, version: i32, msg_type: i32) -> ProtocolMessage:
    var payload: [i32] = []
    for b in encode_u32(test_id):
        payload.push(b)
    for b in encode_u32(duration_ms):
        payload.push(b)
    ProtocolMessage(msg_type: msg_type, payload: payload)

fn ProtocolMessage_complete(total: i32, passed: i32, failed: i32, skipped: i32, msg_type: i32) -> ProtocolMessage:
    var payload: [i32] = []
    for b in encode_u32(total):
        payload.push(b)
    for b in encode_u32(passed):
        payload.push(b)
    for b in encode_u32(failed):
        payload.push(b)
    for b in encode_u32(skipped):
        payload.push(b)
    ProtocolMessage(msg_type: msg_type, payload: payload)

impl ProtocolMessage:
    fn payload_len() -> i32:
        self.payload.len() as i32

    fn encode(magic: i32, version: i32) -> [i32]:
        var bytes: [i32] = []
        bytes.push(magic)
        bytes.push(version)
        bytes.push(self.msg_type)
        for b in encode_u16(self.payload_len()):
            bytes.push(b)
        for b in self.payload:
            bytes.push(b)
        bytes

class ParsedMessage:
    msg_type: i32
    payload: [i32]
    valid: bool

fn ParsedMessage_invalid() -> ParsedMessage:
    ParsedMessage(msg_type: 0, payload: [], valid: false)

fn ParsedMessage_create(msg_type: i32, payload: [i32]) -> ParsedMessage:
    ParsedMessage(msg_type: msg_type, payload: payload, valid: true)

class ProtocolParser:
    buffer: [i32]
    messages: [ParsedMessage]

fn ProtocolParser_create() -> ProtocolParser:
    ProtocolParser(buffer: [], messages: [])

impl ProtocolParser:
    me feed(data: [i32], magic: i32, version: i32):
        for b in data:
            self.buffer.push(b)
        self.process_buffer(magic, version)

    me process_buffer(magic: i32, version: i32):
        while self.buffer.len() >= 5:
            if self.buffer[0] != magic:
                self.buffer.remove(0)
                continue
            if self.buffer[1] != version:
                self.buffer.remove(0)
                continue
            val msg_type = self.buffer[2]
            val payload_len = decode_u16(self.buffer[3], self.buffer[4])
            val total_len = 5 + payload_len
            if self.buffer.len() < total_len as i64:
                return
            var payload: [i32] = []
            for i in 5..total_len:
                payload.push(self.buffer[i])
            for _ in 0..total_len:
                self.buffer.remove(0)
            self.messages.push(ParsedMessage_create(msg_type, payload))

    fn has_messages() -> bool:
        self.messages.len() > 0

    me pop_message() -> ParsedMessage:
        if self.messages.len() == 0:
            ParsedMessage_invalid()
        else:
            val msg = self.messages[0]
            self.messages.remove(0)
            msg

class TestPassPayload:
    test_id: i32
    duration_ms: i32
    valid: bool

fn TestPassPayload_decode(payload: [i32]) -> TestPassPayload:
    if payload.len() < 8:
        TestPassPayload(test_id: 0, duration_ms: 0, valid: false)
    else:
        TestPassPayload(
            test_id: decode_u32(payload[0], payload[1], payload[2], payload[3]),
            duration_ms: decode_u32(payload[4], payload[5], payload[6], payload[7]),
            valid: true
        )

class CompletePayload:
    total: i32
    passed: i32
    failed: i32
    skipped: i32
    valid: bool

fn CompletePayload_decode(payload: [i32]) -> CompletePayload:
    if payload.len() < 16:
        CompletePayload(total: 0, passed: 0, failed: 0, skipped: 0, valid: false)
    else:
        CompletePayload(
            total: decode_u32(payload[0], payload[1], payload[2], payload[3]),
            passed: decode_u32(payload[4], payload[5], payload[6], payload[7]),
            failed: decode_u32(payload[8], payload[9], payload[10], payload[11]),
            skipped: decode_u32(payload[12], payload[13], payload[14], payload[15]),
            valid: true
        )

# =========================================================================
# Format Implementations
# =========================================================================

fn format_status(status: i32) -> text:
    if status == 0:
        "[    ]"
    elif status == 1:
        "[....]"
    elif status == 2:
        "[PASS]"
    elif status == 3:
        "[FAIL]"
    elif status == 4:
        "[SKIP]"
    elif status == 5:
        "[TIME]"
    elif status == 6:
        "[BOOM]"
    else:
        "[????]"

fn format_duration(ms: i64) -> text:
    if ms < 1000:
        "{ms}ms"
    elif ms < 60000:
        val secs = ms / 1000
        val rem = ms % 1000
        "{secs}.{rem / 100}s"
    else:
        val mins = ms / 60000
        val secs = (ms % 60000) / 1000
        "{mins}m {secs}s"

# =========================================================================
# StringInternTable
# =========================================================================

class StringInternEntry:
    handle: i32
    value: text

fn StringInternEntry_create(handle: i32, value: text) -> StringInternEntry:
    StringInternEntry(handle: handle, value: value)

class StringInternTable:
    entries: [StringInternEntry]
    next_handle: i32

fn StringInternTable_empty() -> StringInternTable:
    StringInternTable(entries: [], next_handle: 1)

impl StringInternTable:
    fn has_entries() -> bool:
        self.entries.len() > 0

    fn get(handle: i32) -> text:
        for entry in self.entries:
            if entry.handle == handle:
                return entry.value
        "#{handle}"

    me intern(value: text) -> i32:
        for entry in self.entries:
            if entry.value == value:
                return entry.handle
        val handle = self.next_handle
        self.next_handle = self.next_handle + 1
        self.entries.push(StringInternEntry_create(handle, value))
        handle
