# Module-Level Type Checking Tests
#
# Tests for module_check.spl - two-pass checking, forward references, mutual recursion.

use compiler.type_system.module_check*
use compiler.type_system.checker (TypeChecker)
use compiler.inference.types*
use ast*

# ============================================================================
# Test Helpers
# ============================================================================

fn create_checker() -> TypeChecker:
    """Create a fresh type checker for testing."""
    TypeChecker.create()

fn make_span() -> Span:
    """Create a dummy span for testing."""
    Span(start: 0, end: 0, line: 1, column: 1)

fn make_param(name: text) -> Parameter:
    """Create a simple parameter."""
    Parameter(
        span: make_span(),
        name: name,
        ty: Some(ast.Type.Simple("i64")),
        default: nil,
        mutability: Mutability.Immutable,
        inject: false,
        variadic: false,
        call_site_label: nil
    )

fn make_function(name: text, body_stmts: [Node]) -> FunctionDef:
    """Create a simple function definition."""
    FunctionDef(
        span: make_span(),
        name: name,
        generic_params: [],
        params: [],
        return_type: Some(ast.Type.Simple("i64")),
        where_clause: [],
        body: Block(span: make_span(), statements: body_stmts),
        visibility: Visibility.Private,
        effects: [],
        decorators: [],
        attributes: [],
        doc_comment: nil,
        contract: nil,
        is_abstract: false,
        is_sync: true,
        bounds_block: nil,
        is_static: false,
        is_me_method: false,
        is_generator: false,
        return_constraint: nil,
        is_generic_template: false,
        specialization_of: nil,
        type_bindings: {}
    )

# ============================================================================
# Function Registration Tests
# ============================================================================

describe "Function Registration":
    it "registers function signature":
        val checker = create_checker()
        val func = make_function("test_fn", [])

        val result = register_function_signature(checker, func)

        expect(result.ok.?).to_equal(true)
        expect(checker.env.contains("test_fn")).to_equal(true)

    it "registers function with parameters":
        val checker = create_checker()
        var func = make_function("add", [])
        func.params = [make_param("x"), make_param("y")]

        val result = register_function_signature(checker, func)

        expect(result.ok.?).to_equal(true)
        # Function type should be registered
        val func_ty = checker.env["add"]
        match func_ty:
            case Function(params, ret):
                expect(params.len()).to_equal(2)
            case _:
                fail("Expected Function type")

# ============================================================================
# Struct Registration Tests
# ============================================================================

describe "Struct Registration":
    it "registers struct type and constructor":
        val checker = create_checker()
        val struct_def = StructDef(
            span: make_span(),
            name: "Point",
            generic_params: [],
            fields: [
                Field(
                    span: make_span(),
                    name: "x",
                    ty: ast.Type.Simple("i64"),
                    default: nil,
                    mutability: Mutability.Immutable,
                    visibility: Visibility.Public
                ),
                Field(
                    span: make_span(),
                    name: "y",
                    ty: ast.Type.Simple("i64"),
                    default: nil,
                    mutability: Mutability.Immutable,
                    visibility: Visibility.Public
                )
            ],
            visibility: Visibility.Public,
            attributes: [],
            doc_comment: nil,
            where_clause: []
        )

        val result = register_struct(checker, struct_def)

        expect(result.ok.?).to_equal(true)
        expect(checker.env.contains("Point")).to_equal(true)

# ============================================================================
# Enum Registration Tests
# ============================================================================

describe "Enum Registration":
    it "registers enum type and variants":
        val checker = create_checker()
        val enum_def = EnumDef(
            span: make_span(),
            name: "Option",
            generic_params: [],
            variants: [
                EnumVariant(
                    span: make_span(),
                    name: "Some",
                    fields: Some([
                        EnumField(name: nil, ty: ast.Type.Simple("i64"))
                    ]),
                    discriminant: nil
                ),
                EnumVariant(
                    span: make_span(),
                    name: "None",
                    fields: nil,
                    discriminant: nil
                )
            ],
            visibility: Visibility.Public,
            attributes: [],
            doc_comment: nil
        )

        val result = register_enum(checker, enum_def)

        expect(result.ok.?).to_equal(true)
        expect(checker.env.contains("Option")).to_equal(true)
        expect(checker.env.contains("Option.Some")).to_equal(true)
        expect(checker.env.contains("Option.None")).to_equal(true)

# ============================================================================
# Two-Pass Algorithm Tests
# ============================================================================

describe "Two-Pass Module Checking":
    it "handles forward references":
        val checker = create_checker()

        # Create module with forward reference:
        # fn main(): helper()
        # fn helper(): 42

        val main_func = make_function("main", [])
        val helper_func = make_function("helper", [])

        val module = Module(
            name: Some("test"),
            items: [
                Node.Function(main_func),
                Node.Function(helper_func)
            ]
        )

        # Pass 1 should register both functions
        val result = check_module(checker, module)

        # Should succeed - both functions registered before body checking
        expect(result.ok.?).to_equal(true)

    it "handles mutual recursion":
        val checker = create_checker()

        # Create mutually recursive functions:
        # fn is_even(n): if n == 0: true else: is_odd(n - 1)
        # fn is_odd(n): if n == 0: false else: is_even(n - 1)

        val is_even = make_function("is_even", [])
        val is_odd = make_function("is_odd", [])

        val module = Module(
            name: Some("test"),
            items: [
                Node.Function(is_even),
                Node.Function(is_odd)
            ]
        )

        # Pass 1 registers both, Pass 2 checks both
        val result = check_module(checker, module)

        # Should succeed - mutual recursion handled
        expect(result.ok.?).to_equal(true)

# ============================================================================
# Const/Static Registration Tests
# ============================================================================

describe "Const and Static Registration":
    it "registers const binding":
        val checker = create_checker()
        val const_stmt = ConstStmt(
            span: make_span(),
            name: "MAX_SIZE",
            ty: Some(ast.Type.Simple("i64")),
            value: Expr.Integer(100),
            visibility: Visibility.Public
        )

        val result = register_const(checker, const_stmt)

        expect(result.ok.?).to_equal(true)
        expect(checker.env.contains("MAX_SIZE")).to_equal(true)

    it "registers static binding":
        val checker = create_checker()
        val static_stmt = StaticStmt(
            span: make_span(),
            name: "counter",
            ty: Some(ast.Type.Simple("i64")),
            value: Expr.Integer(0),
            mutability: Mutability.Mutable,
            visibility: Visibility.Private
        )

        val result = register_static(checker, static_stmt)

        expect(result.ok.?).to_equal(true)
        expect(checker.env.contains("counter")).to_equal(true)

# ============================================================================
# AST Type Conversion Tests
# ============================================================================

describe "AST Type to Inference Type Conversion":
    it "converts simple types":
        val checker = create_checker()

        val i64_ty = ast_type_to_inference_type(ast.Type.Simple("i64"), checker)
        expect(i64_ty).to_equal(Type.Int(bits: 64, signed: true))

        val bool_ty = ast_type_to_inference_type(ast.Type.Simple("bool"), checker)
        expect(bool_ty).to_equal(Type.Bool)

        val text_ty = ast_type_to_inference_type(ast.Type.Simple("text"), checker)
        expect(text_ty).to_equal(Type.Str)

    it "converts optional types":
        val checker = create_checker()
        val ast_ty = ast.Type.Optional(ast.Type.Simple("i64"))

        val result = ast_type_to_inference_type(ast_ty, checker)

        match result:
            case Optional(inner):
                expect(inner).to_equal(Type.Int(bits: 64, signed: true))
            case _:
                fail("Expected Optional type")

    it "converts tuple types":
        val checker = create_checker()
        val ast_ty = ast.Type.Tuple([
            ast.Type.Simple("i64"),
            ast.Type.Simple("bool")
        ])

        val result = ast_type_to_inference_type(ast_ty, checker)

        match result:
            case Tuple(elems):
                expect(elems.len()).to_equal(2)
            case _:
                fail("Expected Tuple type")

    it "converts array types":
        val checker = create_checker()
        val ast_ty = ast.Type.Array(
            element: ast.Type.Simple("i64"),
            size: nil
        )

        val result = ast_type_to_inference_type(ast_ty, checker)

        match result:
            case Array(elem, _):
                expect(elem).to_equal(Type.Int(bits: 64, signed: true))
            case _:
                fail("Expected Array type")

# ============================================================================
# Integration Tests
# ============================================================================

describe "Module Checking Integration":
    it "type checks a complete simple module":
        val checker = create_checker()

        # Module with function, struct, and const
        val func = make_function("get_max", [])

        val struct_def = StructDef(
            span: make_span(),
            name: "Config",
            generic_params: [],
            fields: [],
            visibility: Visibility.Public,
            attributes: [],
            doc_comment: nil,
            where_clause: []
        )

        val const_stmt = ConstStmt(
            span: make_span(),
            name: "DEFAULT_SIZE",
            ty: Some(ast.Type.Simple("i64")),
            value: Expr.Integer(100),
            visibility: Visibility.Public
        )

        val module = Module(
            name: Some("example"),
            items: [
                Node.Function(func),
                Node.Struct(struct_def),
                Node.Const(const_stmt)
            ]
        )

        val result = check_module(checker, module)

        expect(result.ok.?).to_equal(true)
        # All three items should be registered
        expect(checker.env.contains("get_max")).to_equal(true)
        expect(checker.env.contains("Config")).to_equal(true)
        expect(checker.env.contains("DEFAULT_SIZE")).to_equal(true)

# ============================================================================
# Summary
# ============================================================================

# Total test count: 15+ tests covering:
# - Function registration (2 tests)
# - Struct registration (1 test)
# - Enum registration (1 test)
# - Two-pass algorithm (2 tests)
# - Const/static registration (2 tests)
# - AST type conversion (4 tests)
# - Integration (1 test)
