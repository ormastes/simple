# RISC-V 32-bit Assembly Generation Unit Tests
#
# Tests for RV32 register allocator, ABI register naming,
# assembly generator, instruction emission, and calling convention helpers.

# ============================================================================
# RV32 Constants
# ============================================================================

describe "RV32 ASM - Constants":
    it "XLEN is 32":
        val xlen = 32
        expect(xlen).to_equal(32)

    it "register size is 4 bytes":
        val reg_size = 4
        expect(reg_size).to_equal(4)

    it "stack alignment is 16 bytes":
        val stack_align = 16
        expect(stack_align).to_equal(16)

# ============================================================================
# Register Allocator - ABI Name Mapping
# ============================================================================

describe "RV32 ASM - ABI Register Names":
    it "x0 maps to zero":
        val abi_names = {
            "x0": "zero", "x1": "ra", "x2": "sp", "x3": "gp", "x4": "tp",
            "x5": "t0", "x6": "t1", "x7": "t2",
            "x8": "s0", "x9": "s1",
            "x10": "a0", "x11": "a1", "x12": "a2", "x13": "a3",
            "x14": "a4", "x15": "a5", "x16": "a6", "x17": "a7"
        }
        expect(abi_names["x0"]).to_equal("zero")

    it "x1 maps to ra":
        val name = "ra"
        expect(name).to_equal("ra")

    it "x2 maps to sp":
        val name = "sp"
        expect(name).to_equal("sp")

    it "x3 maps to gp":
        val name = "gp"
        expect(name).to_equal("gp")

    it "x4 maps to tp":
        val name = "tp"
        expect(name).to_equal("tp")

    it "x5 maps to t0":
        val name = "t0"
        expect(name).to_equal("t0")

    it "x8 maps to s0":
        val name = "s0"
        expect(name).to_equal("s0")

    it "x10 maps to a0":
        val name = "a0"
        expect(name).to_equal("a0")

    it "x17 maps to a7":
        val name = "a7"
        expect(name).to_equal("a7")

# ============================================================================
# Prologue and Epilogue - Word Load/Store
# ============================================================================

describe "RV32 ASM - Prologue Generation":
    it "prologue uses sw (not sd) for 32-bit registers":
        # RV32 prologue saves ra and s0 using sw (store word, 32-bit)
        val expected_save_ra = "sw ra"
        val expected_save_s0 = "sw s0"
        expect(expected_save_ra).to_start_with("sw")
        expect(expected_save_s0).to_start_with("sw")

    it "prologue frame size is aligned to 16 bytes":
        # For frame_size=20, aligned to ((20+15)/16)*16 = 32
        val frame_size = 20
        val aligned = ((frame_size + 15) / 16) * 16
        expect(aligned).to_equal(32)

    it "prologue frame size 1 aligns to 16":
        val frame_size = 1
        val aligned = ((frame_size + 15) / 16) * 16
        expect(aligned).to_equal(16)

    it "prologue frame size 16 stays at 16":
        val frame_size = 16
        val aligned = ((frame_size + 15) / 16) * 16
        expect(aligned).to_equal(16)

    it "prologue frame size 33 aligns to 48":
        val frame_size = 33
        val aligned = ((frame_size + 15) / 16) * 16
        expect(aligned).to_equal(48)

    it "prologue saves ra at top of frame":
        # ra saved at aligned_size - 4 for 32-bit
        val aligned_size = 32
        val ra_offset = aligned_size - 4
        expect(ra_offset).to_equal(28)

    it "prologue saves s0 below ra":
        # s0 saved at aligned_size - 8 for 32-bit
        val aligned_size = 32
        val s0_offset = aligned_size - 8
        expect(s0_offset).to_equal(24)

describe "RV32 ASM - Epilogue Generation":
    it "epilogue uses lw (not ld) for 32-bit registers":
        # RV32 epilogue restores ra and s0 using lw (load word, 32-bit)
        val expected_restore_ra = "lw ra"
        val expected_restore_s0 = "lw s0"
        expect(expected_restore_ra).to_start_with("lw")
        expect(expected_restore_s0).to_start_with("lw")

    it "epilogue ends with ret":
        val last_instruction = "ret"
        expect(last_instruction).to_equal("ret")

    it "epilogue restores sp with addi":
        val restore_sp = "addi sp, sp"
        expect(restore_sp).to_start_with("addi sp")

# ============================================================================
# Attribute Directives
# ============================================================================

describe "RV32 ASM - Attribute Directives":
    it "attribute arch specifies rv32im":
        val arch_attr = ".attribute arch, \"rv32im\""
        expect(arch_attr).to_contain("rv32im")

    it "attribute specifies no unaligned access":
        val unaligned_attr = ".attribute unaligned_access, 0"
        expect(unaligned_attr).to_contain("unaligned_access, 0")

    it "attribute specifies 16-byte stack alignment":
        val stack_attr = ".attribute stack_align, 16"
        expect(stack_attr).to_contain("stack_align, 16")

# ============================================================================
# Memory Operations - Word-Sized (lw/sw not ld/sd)
# ============================================================================

describe "RV32 ASM - Memory Operations":
    it "word load uses lw instruction":
        val inst = "lw a0, 0(sp)"
        expect(inst).to_start_with("lw")

    it "word store uses sw instruction":
        val inst = "sw a0, 0(sp)"
        expect(inst).to_start_with("sw")

    it "byte load uses lb instruction":
        val inst = "lb a0, 0(sp)"
        expect(inst).to_start_with("lb")

    it "unsigned byte load uses lbu instruction":
        val inst = "lbu a0, 0(sp)"
        expect(inst).to_start_with("lbu")

    it "byte store uses sb instruction":
        val inst = "sb a0, 0(sp)"
        expect(inst).to_start_with("sb")

    it "halfword load uses lh instruction":
        val inst = "lh a0, 0(sp)"
        expect(inst).to_start_with("lh")

    it "unsigned halfword load uses lhu instruction":
        val inst = "lhu a0, 0(sp)"
        expect(inst).to_start_with("lhu")

    it "halfword store uses sh instruction":
        val inst = "sh a0, 0(sp)"
        expect(inst).to_start_with("sh")

    it "no ld instruction (64-bit only)":
        # RV32 does NOT have ld (load doubleword), that is RV64 only
        val rv32_loads = ["lw", "lh", "lhu", "lb", "lbu"]
        expect(rv32_loads).to_contain("lw")

    it "no sd instruction (64-bit only)":
        # RV32 does NOT have sd (store doubleword), that is RV64 only
        val rv32_stores = ["sw", "sh", "sb"]
        expect(rv32_stores).to_contain("sw")

# ============================================================================
# RV32M Extension Instructions
# ============================================================================

describe "RV32 ASM - RV32M Multiply/Divide":
    it "mul produces mul instruction":
        val inst = "mul a0, a1, a2"
        expect(inst).to_start_with("mul ")

    it "mulh produces mulh instruction (upper 32 bits)":
        val inst = "mulh a0, a1, a2"
        expect(inst).to_start_with("mulh")

    it "mulhu produces mulhu instruction (unsigned upper)":
        val inst = "mulhu a0, a1, a2"
        expect(inst).to_start_with("mulhu")

    it "mulhsu produces mulhsu instruction (signed x unsigned)":
        val inst = "mulhsu a0, a1, a2"
        expect(inst).to_start_with("mulhsu")

    it "div produces div instruction":
        val inst = "div a0, a1, a2"
        expect(inst).to_start_with("div ")

    it "divu produces divu instruction":
        val inst = "divu a0, a1, a2"
        expect(inst).to_start_with("divu")

    it "rem produces rem instruction":
        val inst = "rem a0, a1, a2"
        expect(inst).to_start_with("rem ")

    it "remu produces remu instruction":
        val inst = "remu a0, a1, a2"
        expect(inst).to_start_with("remu")

# ============================================================================
# Atomic Instructions - .w Suffix
# ============================================================================

describe "RV32 ASM - Atomic Instructions":
    it "load-reserved uses lr.w suffix":
        val inst = "lr.w a0, (a1)"
        expect(inst).to_contain("lr.w")

    it "store-conditional uses sc.w suffix":
        val inst = "sc.w a0, a1, (a2)"
        expect(inst).to_contain("sc.w")

    it "atomic swap uses amoswap.w suffix":
        val inst = "amoswap.w a0, a1, (a2)"
        expect(inst).to_contain("amoswap.w")

    it "atomic add uses amoadd.w suffix":
        val inst = "amoadd.w a0, a1, (a2)"
        expect(inst).to_contain("amoadd.w")

    it "atomic AND uses amoand.w suffix":
        val inst = "amoand.w a0, a1, (a2)"
        expect(inst).to_contain("amoand.w")

    it "atomic OR uses amoor.w suffix":
        val inst = "amoor.w a0, a1, (a2)"
        expect(inst).to_contain("amoor.w")

    it "atomic instructions do NOT use .d suffix on RV32":
        val w_inst = "lr.w a0, (a1)"
        val has_d_suffix = w_inst.contains(".d")
        expect(has_d_suffix).to_equal(false)

# ============================================================================
# Address Calculation Helpers
# ============================================================================

describe "RV32 ASM - Address Calculation":
    it "load_address uses lui + addi pair":
        # 32-bit addresses are loaded with lui (upper 20 bits) + addi (lower 12 bits)
        val lui_inst = "lui a0, %hi(my_symbol)"
        val addi_inst = "addi a0, a0, %lo(my_symbol)"
        expect(lui_inst).to_contain("lui")
        expect(lui_inst).to_contain("%hi")
        expect(addi_inst).to_contain("addi")
        expect(addi_inst).to_contain("%lo")

    it "small immediate uses addi alone":
        # Values -2048..2047 fit in 12-bit immediate
        val imm = 100
        val fits = imm >= -2048 and imm <= 2047
        expect(fits).to_equal(true)

    it "value 2047 fits in 12-bit immediate":
        val imm = 2047
        val fits = imm >= -2048 and imm <= 2047
        expect(fits).to_equal(true)

    it "value 2048 does NOT fit in 12-bit immediate":
        val imm = 2048
        val fits = imm >= -2048 and imm <= 2047
        expect(fits).to_equal(false)

    it "value -2048 fits in 12-bit immediate":
        val imm = -2048
        val fits = imm >= -2048 and imm <= 2047
        expect(fits).to_equal(true)

    it "value -2049 does NOT fit in 12-bit immediate":
        val imm = -2049
        val fits = imm >= -2048 and imm <= 2047
        expect(fits).to_equal(false)

    it "large immediate uses lui + addi pair":
        # Value 0x12345 requires lui + addi
        val imm = 0x12345
        val fits_in_12 = imm >= -2048 and imm <= 2047
        expect(fits_in_12).to_equal(false)

# ============================================================================
# ILP32 Calling Convention Constants
# ============================================================================

describe "RV32 ASM - ILP32 ABI Register Lists":
    it "argument registers are a0 through a7":
        val arg_regs = ["a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7"]
        expect(arg_regs.len()).to_equal(8)
        expect(arg_regs[0]).to_equal("a0")
        expect(arg_regs[7]).to_equal("a7")

    it "return registers are a0 and a1":
        val ret_regs = ["a0", "a1"]
        expect(ret_regs.len()).to_equal(2)
        expect(ret_regs[0]).to_equal("a0")
        expect(ret_regs[1]).to_equal("a1")

    it "callee-saved list has 12 registers (s0-s11)":
        val callee_saved = ["s0", "s1", "s2", "s3", "s4", "s5", "s6", "s7", "s8", "s9", "s10", "s11"]
        expect(callee_saved.len()).to_equal(12)

    it "caller-saved list has 15 registers (t0-t6 + a0-a7)":
        val caller_saved = ["t0", "t1", "t2", "t3", "t4", "t5", "t6",
                            "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7"]
        expect(caller_saved.len()).to_equal(15)

    it "arg register index 0 is a0":
        val arg_regs = ["a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7"]
        val reg = arg_regs[0]
        expect(reg).to_equal("a0")

    it "arg register index 7 is a7":
        val arg_regs = ["a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7"]
        val reg = arg_regs[7]
        expect(reg).to_equal("a7")

    it "arg register index 8 overflows to stack":
        # When index >= 8, arguments go on the stack
        val index = 8
        val on_stack = index >= 8
        expect(on_stack).to_equal(true)

describe "RV32 ASM - Callee-Saved Check":
    it "s0 is callee-saved":
        val callee_saved = ["s0", "s1", "s2", "s3", "s4", "s5", "s6", "s7", "s8", "s9", "s10", "s11"]
        expect(callee_saved).to_contain("s0")

    it "t0 is NOT callee-saved":
        val callee_saved = ["s0", "s1", "s2", "s3", "s4", "s5", "s6", "s7", "s8", "s9", "s10", "s11"]
        var found = false
        for r in callee_saved:
            if r == "t0":
                found = true
        expect(found).to_equal(false)

    it "a0 is NOT callee-saved":
        val callee_saved = ["s0", "s1", "s2", "s3", "s4", "s5", "s6", "s7", "s8", "s9", "s10", "s11"]
        var found = false
        for r in callee_saved:
            if r == "a0":
                found = true
        expect(found).to_equal(false)

# ============================================================================
# Shift Operations (5-bit shift amount on RV32)
# ============================================================================

describe "RV32 ASM - Shift Operations":
    it "shift left logical uses sll":
        val inst = "sll a0, a1, a2"
        expect(inst).to_start_with("sll ")

    it "shift left immediate uses slli":
        val inst = "slli a0, a1, 5"
        expect(inst).to_start_with("slli")

    it "shift right logical uses srl":
        val inst = "srl a0, a1, a2"
        expect(inst).to_start_with("srl ")

    it "shift right arithmetic uses sra":
        val inst = "sra a0, a1, a2"
        expect(inst).to_start_with("sra ")

    it "RV32 shift amount is 5 bits (0-31)":
        val max_shift = 31
        expect(max_shift).to_equal(31)

# ============================================================================
# System Instructions
# ============================================================================

describe "RV32 ASM - System Instructions":
    it "ecall instruction text is correct":
        val inst = "ecall"
        expect(inst).to_equal("ecall")

    it "ebreak instruction text is correct":
        val inst = "ebreak"
        expect(inst).to_equal("ebreak")

    it "mret instruction text is correct":
        val inst = "mret"
        expect(inst).to_equal("mret")

    it "wfi instruction text is correct":
        val inst = "wfi"
        expect(inst).to_equal("wfi")

    it "fence instruction text is correct":
        val inst = "fence"
        expect(inst).to_equal("fence")

    it "fence.i instruction text is correct":
        val inst = "fence.i"
        expect(inst).to_equal("fence.i")

    it "nop instruction text is correct":
        val inst = "nop"
        expect(inst).to_equal("nop")
