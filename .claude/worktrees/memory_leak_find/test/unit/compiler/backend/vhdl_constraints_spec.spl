# VHDL Constraints Specification
#
# Tests for VhdlConstraintChecker: two-layer verification system.

"""
# VHDL Constraints Specification

**Feature IDs:** #vhdl-constraints
**Category:** Backend
**Difficulty:** 4/5
**Status:** In Progress

## Overview

Tests VhdlConstraintChecker which enforces VHDL-specific verification
constraints at compile time: width matching, CDC safety, sensitivity lists,
combinational loops, latch inference, bounded loops, single-driver enforcement.

## Related Files
- `src/compiler/vhdl_constraints.spl` - Constraint checker implementation
"""

use compiler.vhdl_constraints.*
use compiler.mir_data.{VhdlClockDomain, VhdlClockEdge}
use compiler.core.lexer.Span
use std.spec.{check, check_msg}

# ============================================================================
# Test Utilities
# ============================================================================

fn test_span() -> Span:
    Span(start: 0, end: 10, line: 1, col: 1)

fn test_span_at(line: i64, col: i64) -> Span:
    Span(start: 0, end: 10, line: line, col: col)

fn make_clock_domain(name: text, clk: text, rst: text?) -> VhdlClockDomain:
    VhdlClockDomain(
        name: name,
        clock_signal: clk,
        reset_signal: rst,
        edge: VhdlClockEdge.Rising
    )

# ============================================================================
# Width Constraints (E0700)
# ============================================================================

describe "VhdlConstraintChecker width matching":
    """
    ## Width Equal Constraints (E0700)

    Signal widths must match for assignments and connections.
    """

    it "passes when widths match":
        var checker = VhdlConstraintChecker__create()
        checker.add_constraint(VhdlConstraint.WidthEqual(
            signal1: "a", signal2: "b",
            width1: 32, width2: 32,
            span: test_span()
        ))
        val result = checker.check_all()
        check(result.is_ok())

    it "fails when widths differ":
        var checker = VhdlConstraintChecker__create()
        checker.add_constraint(VhdlConstraint.WidthEqual(
            signal1: "narrow", signal2: "wide",
            width1: 8, width2: 16,
            span: test_span()
        ))
        val result = checker.check_all()
        check(result.is_err())
        val errors = result.unwrap_err()
        expect(errors.len()).to_equal(1)
        expect(errors[0].code).to_equal("E0700")
        check(errors[0].message.contains("narrow"))
        check(errors[0].message.contains("wide"))
        check(errors[0].message.contains("8"))
        check(errors[0].message.contains("16"))

    it "detects width mismatch error kind":
        var checker = VhdlConstraintChecker__create()
        checker.add_constraint(VhdlConstraint.WidthEqual(
            signal1: "a", signal2: "b",
            width1: 32, width2: 64,
            span: test_span()
        ))
        val result = checker.check_all()
        val errors = result.unwrap_err()
        match errors[0].kind:
            case WidthMismatch: check(true)
            case _: check(false)

# ============================================================================
# Width Safety Constraints (E0701)
# ============================================================================

describe "VhdlConstraintChecker width safety":
    """
    ## Width Safe Constraints (E0701)

    Arithmetic results must fit in the destination width.
    """

    context "addition overflow":
        it "passes when result width is sufficient for addition":
            var checker = VhdlConstraintChecker__create()
            checker.add_constraint(VhdlConstraint.WidthSafe(
                operands: [16, 16],
                operator: "+",
                result_width: 17,
                span: test_span()
            ))
            val result = checker.check_all()
            check(result.is_ok())

        it "fails when result width is insufficient for addition":
            var checker = VhdlConstraintChecker__create()
            checker.add_constraint(VhdlConstraint.WidthSafe(
                operands: [16, 16],
                operator: "+",
                result_width: 16,
                span: test_span()
            ))
            val result = checker.check_all()
            check(result.is_err())
            val errors = result.unwrap_err()
            expect(errors[0].code).to_equal("E0701")
            check(errors[0].message.contains("overflow"))

    context "multiplication overflow":
        it "passes when result width covers full product":
            var checker = VhdlConstraintChecker__create()
            checker.add_constraint(VhdlConstraint.WidthSafe(
                operands: [16, 16],
                operator: "*",
                result_width: 32,
                span: test_span()
            ))
            val result = checker.check_all()
            check(result.is_ok())

        it "fails when result width is too narrow for product":
            var checker = VhdlConstraintChecker__create()
            checker.add_constraint(VhdlConstraint.WidthSafe(
                operands: [16, 16],
                operator: "*",
                result_width: 16,
                span: test_span()
            ))
            val result = checker.check_all()
            check(result.is_err())
            val errors = result.unwrap_err()
            expect(errors[0].code).to_equal("E0701")

    context "other operators":
        it "passes bitwise operations with matching widths":
            var checker = VhdlConstraintChecker__create()
            checker.add_constraint(VhdlConstraint.WidthSafe(
                operands: [32, 32],
                operator: "and",
                result_width: 32,
                span: test_span()
            ))
            val result = checker.check_all()
            check(result.is_ok())

# ============================================================================
# Clock Domain Constraints (E0710)
# ============================================================================

describe "VhdlConstraintChecker clock domain crossing":
    """
    ## CDC Constraints (E0710)

    Signals must not cross clock domains without synchronization.
    """

    context "same domain check":
        it "passes when signals are in the same domain":
            var checker = VhdlConstraintChecker__create()
            checker.register_signal_domain("sig_a", "clk_100")
            checker.register_signal_domain("sig_b", "clk_100")
            checker.add_constraint(VhdlConstraint.SameClockDomain(
                signal1: "sig_a", signal2: "sig_b",
                span: test_span()
            ))
            val result = checker.check_all()
            check(result.is_ok())

        it "fails when signals are in different domains":
            var checker = VhdlConstraintChecker__create()
            checker.register_signal_domain("sig_a", "clk_100")
            checker.register_signal_domain("sig_b", "clk_50")
            checker.add_constraint(VhdlConstraint.SameClockDomain(
                signal1: "sig_a", signal2: "sig_b",
                span: test_span()
            ))
            val result = checker.check_all()
            check(result.is_err())
            val errors = result.unwrap_err()
            expect(errors[0].code).to_equal("E0710")
            check(errors[0].message.contains("clk_100"))
            check(errors[0].message.contains("clk_50"))

        it "passes when signal domain is unknown":
            var checker = VhdlConstraintChecker__create()
            checker.register_signal_domain("sig_a", "clk_100")
            # sig_b has no registered domain
            checker.add_constraint(VhdlConstraint.SameClockDomain(
                signal1: "sig_a", signal2: "sig_b",
                span: test_span()
            ))
            val result = checker.check_all()
            check(result.is_ok())

    context "explicit CDC violation":
        it "always fails for unsynchronized crossing":
            var checker = VhdlConstraintChecker__create()
            checker.add_constraint(VhdlConstraint.ClockDomainCrossing(
                source: "data_out", dest: "data_in",
                source_domain: "clk_a", dest_domain: "clk_b",
                span: test_span()
            ))
            val result = checker.check_all()
            check(result.is_err())
            val errors = result.unwrap_err()
            expect(errors[0].code).to_equal("E0710")
            check(errors[0].message.contains("unsynchronized"))

# ============================================================================
# Sensitivity List Constraints (E0720)
# ============================================================================

describe "VhdlConstraintChecker sensitivity list":
    """
    ## Sensitivity Completeness (E0720)

    Combinational processes must list all read signals in sensitivity list.
    """

    it "passes when sensitivity list is complete":
        var checker = VhdlConstraintChecker__create()
        checker.add_constraint(VhdlConstraint.SensitivityComplete(
            process_label: "comb_proc",
            used_signals: ["a", "b", "sel"],
            sensitivity: ["a", "b", "sel"],
            span: test_span()
        ))
        val result = checker.check_all()
        check(result.is_ok())

    it "fails when sensitivity list is incomplete":
        var checker = VhdlConstraintChecker__create()
        checker.add_constraint(VhdlConstraint.SensitivityComplete(
            process_label: "mux_proc",
            used_signals: ["a", "b", "sel"],
            sensitivity: ["a", "b"],
            span: test_span()
        ))
        val result = checker.check_all()
        check(result.is_err())
        val errors = result.unwrap_err()
        expect(errors[0].code).to_equal("E0720")
        check(errors[0].message.contains("mux_proc"))
        check(errors[0].message.contains("sel"))

    it "passes when sensitivity list has extra signals":
        var checker = VhdlConstraintChecker__create()
        checker.add_constraint(VhdlConstraint.SensitivityComplete(
            process_label: "proc",
            used_signals: ["a"],
            sensitivity: ["a", "b", "c"],
            span: test_span()
        ))
        val result = checker.check_all()
        check(result.is_ok())

# ============================================================================
# Combinational Loop Constraints (E0721)
# ============================================================================

describe "VhdlConstraintChecker combinational loops":
    """
    ## No Combinational Loops (E0721)

    No signal may depend on itself combinationally.
    """

    it "passes with no loops":
        var checker = VhdlConstraintChecker__create()
        checker.add_constraint(VhdlConstraint.NoCombLoop(
            signals: ["a", "b", "c"],
            dependencies: [("a", "b"), ("b", "c")],
            span: test_span()
        ))
        val result = checker.check_all()
        check(result.is_ok())

    it "detects self-loop":
        var checker = VhdlConstraintChecker__create()
        checker.add_constraint(VhdlConstraint.NoCombLoop(
            signals: ["a"],
            dependencies: [("a", "a")],
            span: test_span()
        ))
        val result = checker.check_all()
        check(result.is_err())
        val errors = result.unwrap_err()
        expect(errors[0].code).to_equal("E0721")
        check(errors[0].message.contains("combinational loop"))
        check(errors[0].message.contains("a"))

    it "passes with no dependencies":
        var checker = VhdlConstraintChecker__create()
        checker.add_constraint(VhdlConstraint.NoCombLoop(
            signals: ["a", "b"],
            dependencies: [],
            span: test_span()
        ))
        val result = checker.check_all()
        check(result.is_ok())

    it "detects two-node cycle (a -> b -> a)":
        var checker = VhdlConstraintChecker__create()
        checker.add_constraint(VhdlConstraint.NoCombLoop(
            signals: ["a", "b"],
            dependencies: [("a", "b"), ("b", "a")],
            span: test_span()
        ))
        val result = checker.check_all()
        check(result.is_err())
        val errors = result.unwrap_err()
        expect(errors[0].code).to_equal("E0721")
        check(errors[0].message.contains("combinational loop"))

    it "detects three-node cycle (a -> b -> c -> a)":
        var checker = VhdlConstraintChecker__create()
        checker.add_constraint(VhdlConstraint.NoCombLoop(
            signals: ["a", "b", "c"],
            dependencies: [("a", "b"), ("b", "c"), ("c", "a")],
            span: test_span()
        ))
        val result = checker.check_all()
        check(result.is_err())
        val errors = result.unwrap_err()
        expect(errors[0].code).to_equal("E0721")

    it "passes with diamond shape (no cycle)":
        var checker = VhdlConstraintChecker__create()
        checker.add_constraint(VhdlConstraint.NoCombLoop(
            signals: ["a", "b", "c", "d"],
            dependencies: [("a", "b"), ("a", "c"), ("b", "d"), ("c", "d")],
            span: test_span()
        ))
        val result = checker.check_all()
        check(result.is_ok())

    it "detects cycle in larger graph with acyclic nodes":
        var checker = VhdlConstraintChecker__create()
        checker.add_constraint(VhdlConstraint.NoCombLoop(
            signals: ["a", "b", "c", "d", "e"],
            dependencies: [("a", "b"), ("b", "c"), ("c", "b"), ("d", "e")],
            span: test_span()
        ))
        val result = checker.check_all()
        check(result.is_err())
        val errors = result.unwrap_err()
        expect(errors[0].code).to_equal("E0721")

# ============================================================================
# Latch Inference Constraints (E0722)
# ============================================================================

describe "VhdlConstraintChecker latch inference":
    """
    ## No Latch Inference (E0722)

    All signals must be assigned in all branches of combinational processes.
    """

    it "passes when all branches covered":
        var checker = VhdlConstraintChecker__create()
        checker.add_constraint(VhdlConstraint.NoLatchInference(
            process_label: "comb_proc",
            assigned_signals: ["out1", "out2"],
            branch_coverage: [("out1", true), ("out2", true)],
            span: test_span()
        ))
        val result = checker.check_all()
        check(result.is_ok())

    it "fails when signal not assigned in all branches":
        var checker = VhdlConstraintChecker__create()
        checker.add_constraint(VhdlConstraint.NoLatchInference(
            process_label: "mux_proc",
            assigned_signals: ["out1", "out2"],
            branch_coverage: [("out1", true), ("out2", false)],
            span: test_span()
        ))
        val result = checker.check_all()
        check(result.is_err())
        val errors = result.unwrap_err()
        expect(errors[0].code).to_equal("E0722")
        check(errors[0].message.contains("latch"))
        check(errors[0].message.contains("mux_proc"))
        check(errors[0].message.contains("out2"))

    it "fails when multiple signals not covered":
        var checker = VhdlConstraintChecker__create()
        checker.add_constraint(VhdlConstraint.NoLatchInference(
            process_label: "proc",
            assigned_signals: ["a", "b", "c"],
            branch_coverage: [("a", false), ("b", true), ("c", false)],
            span: test_span()
        ))
        val result = checker.check_all()
        check(result.is_err())
        val errors = result.unwrap_err()
        check(errors[0].message.contains("a"))
        check(errors[0].message.contains("c"))

# ============================================================================
# Loop Bound Constraints (E0730)
# ============================================================================

describe "VhdlConstraintChecker loop bounds":
    """
    ## Bounded Loops (E0730)

    Loops must have positive static bounds for synthesis.
    """

    it "passes with positive bound":
        var checker = VhdlConstraintChecker__create()
        checker.add_constraint(VhdlConstraint.LoopBounded(
            bound_expr: "8",
            max_iterations: 8,
            span: test_span()
        ))
        val result = checker.check_all()
        check(result.is_ok())

    it "fails with zero bound":
        var checker = VhdlConstraintChecker__create()
        checker.add_constraint(VhdlConstraint.LoopBounded(
            bound_expr: "0",
            max_iterations: 0,
            span: test_span()
        ))
        val result = checker.check_all()
        check(result.is_err())
        val errors = result.unwrap_err()
        expect(errors[0].code).to_equal("E0730")

    it "fails with negative bound":
        var checker = VhdlConstraintChecker__create()
        checker.add_constraint(VhdlConstraint.LoopBounded(
            bound_expr: "-1",
            max_iterations: -1,
            span: test_span()
        ))
        val result = checker.check_all()
        check(result.is_err())

# ============================================================================
# Single Driver Constraints (E0740)
# ============================================================================

describe "VhdlConstraintChecker single driver":
    """
    ## Single Driver (E0740)

    Unresolved signals must have exactly one driver.
    """

    it "passes with single driver":
        var checker = VhdlConstraintChecker__create()
        checker.add_constraint(VhdlConstraint.SingleDriver(
            signal: "data",
            drivers: ["proc_a"],
            span: test_span()
        ))
        val result = checker.check_all()
        check(result.is_ok())

    it "fails with multiple drivers":
        var checker = VhdlConstraintChecker__create()
        checker.add_constraint(VhdlConstraint.SingleDriver(
            signal: "bus_data",
            drivers: ["proc_a", "proc_b"],
            span: test_span()
        ))
        val result = checker.check_all()
        check(result.is_err())
        val errors = result.unwrap_err()
        expect(errors[0].code).to_equal("E0740")
        check(errors[0].message.contains("bus_data"))
        check(errors[0].message.contains("proc_a"))
        check(errors[0].message.contains("proc_b"))

    it "passes with no drivers":
        var checker = VhdlConstraintChecker__create()
        checker.add_constraint(VhdlConstraint.SingleDriver(
            signal: "unused",
            drivers: [],
            span: test_span()
        ))
        val result = checker.check_all()
        check(result.is_ok())

# ============================================================================
# Resolved Type Constraints
# ============================================================================

describe "VhdlConstraintChecker resolved type":
    it "passes with multi-driver resolved signal":
        var checker = VhdlConstraintChecker__create()
        checker.add_constraint(VhdlConstraint.ResolvedType(
            signal: "bus",
            has_multiple_drivers: true,
            span: test_span()
        ))
        val result = checker.check_all()
        check(result.is_ok())

    it "passes with single-driver signal":
        var checker = VhdlConstraintChecker__create()
        checker.add_constraint(VhdlConstraint.ResolvedType(
            signal: "data",
            has_multiple_drivers: false,
            span: test_span()
        ))
        val result = checker.check_all()
        check(result.is_ok())

# ============================================================================
# Multiple Constraints
# ============================================================================

describe "VhdlConstraintChecker multiple constraints":
    it "collects all errors from multiple failing constraints":
        var checker = VhdlConstraintChecker__create()
        # Width mismatch
        checker.add_constraint(VhdlConstraint.WidthEqual(
            signal1: "a", signal2: "b",
            width1: 8, width2: 16,
            span: test_span_at(10, 5)
        ))
        # Multiple drivers
        checker.add_constraint(VhdlConstraint.SingleDriver(
            signal: "bus",
            drivers: ["p1", "p2"],
            span: test_span_at(20, 5)
        ))
        val result = checker.check_all()
        check(result.is_err())
        val errors = result.unwrap_err()
        expect(errors.len()).to_equal(2)

    it "passes when all constraints satisfied":
        var checker = VhdlConstraintChecker__create()
        checker.add_constraint(VhdlConstraint.WidthEqual(
            signal1: "a", signal2: "b",
            width1: 32, width2: 32,
            span: test_span()
        ))
        checker.add_constraint(VhdlConstraint.LoopBounded(
            bound_expr: "10",
            max_iterations: 10,
            span: test_span()
        ))
        checker.add_constraint(VhdlConstraint.SingleDriver(
            signal: "out",
            drivers: ["main_proc"],
            span: test_span()
        ))
        val result = checker.check_all()
        check(result.is_ok())

    it "passes with no constraints added":
        var checker = VhdlConstraintChecker__create()
        val result = checker.check_all()
        check(result.is_ok())

# ============================================================================
# Error Formatting
# ============================================================================

describe "VhdlConstraintError formatting":
    it "formats error with code and message":
        val err = VhdlConstraintError(
            code: "E0700",
            message: "width mismatch: signal 'a' is 8 bits, 'b' is 16 bits",
            span: test_span_at(42, 10),
            kind: VhdlConstraintErrorKind.WidthMismatch
        )
        val formatted = err.format()
        check(formatted.contains("error[E0700]"))
        check(formatted.contains("width mismatch"))
        check(formatted.contains("line 42"))

    it "formats error with all E07xx codes":
        val codes = ["E0700", "E0701", "E0710", "E0720", "E0721", "E0722", "E0730", "E0740"]
        for code in codes:
            val err = VhdlConstraintError(
                code: code,
                message: "test",
                span: test_span(),
                kind: VhdlConstraintErrorKind.WidthMismatch
            )
            val formatted = err.format()
            check(formatted.contains(code))

# ============================================================================
# Registration Methods
# ============================================================================

describe "VhdlConstraintChecker registration":
    it "registers clock domain":
        var checker = VhdlConstraintChecker__create()
        val domain = make_clock_domain("sys_clk", "clk", Some("rst"))
        checker.register_clock_domain(domain)
        # No error - just verifying it doesn't crash
        check(true)

    it "registers signal to domain":
        var checker = VhdlConstraintChecker__create()
        checker.register_signal_domain("data_out", "sys_clk")
        # Verified via CDC check
        checker.register_signal_domain("data_in", "sys_clk")
        checker.add_constraint(VhdlConstraint.SameClockDomain(
            signal1: "data_out", signal2: "data_in",
            span: test_span()
        ))
        val result = checker.check_all()
        check(result.is_ok())

    it "registers driver for signal":
        var checker = VhdlConstraintChecker__create()
        checker.register_driver("bus_data", "proc_a")
        checker.register_driver("bus_data", "proc_b")
        # Verified via single driver check
        checker.add_constraint(VhdlConstraint.SingleDriver(
            signal: "bus_data",
            drivers: ["proc_a", "proc_b"],
            span: test_span()
        ))
        val result = checker.check_all()
        check(result.is_err())

    it "registers dependency edge":
        var checker = VhdlConstraintChecker__create()
        checker.register_dependency("a", "b")
        checker.register_dependency("b", "c")
        # No error - just verifying it doesn't crash
        check(true)
