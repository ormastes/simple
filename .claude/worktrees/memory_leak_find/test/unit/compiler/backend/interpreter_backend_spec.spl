# Interpreter Backend Adapter Tests
#
# Verifies that create_interpreter_backend() returns a valid BackendPort
# with the expected name, target triple, and capability flags.
#
# These tests do NOT invoke the interpreter (run_fn); they verify
# that the BackendPort contract is fulfilled by the adapter.

use compiler.feature.codegen.backends.interpreter.backend.{create_interpreter_backend}

describe "Interpreter backend adapter":

    it "creates a BackendPort with correct name":
        val backend = create_interpreter_backend()
        expect(backend.name).to_equal("interpreter")

    it "target triple identifies interpreter runtime":
        val backend = create_interpreter_backend()
        val f = backend.target_triple_fn
        val triple = f()
        expect(triple).to_equal("interpreter-simple-runtime")

    it "reports JIT as supported":
        val backend = create_interpreter_backend()
        val f = backend.supports_jit_fn
        val jit = f()
        expect(jit).to_equal(true)

    it "has a non-nil run_fn":
        val backend = create_interpreter_backend()
        val f = backend.run_fn
        expect(f).to_equal(f)

    it "each factory call produces independent BackendPort":
        val b1 = create_interpreter_backend()
        val b2 = create_interpreter_backend()
        expect(b1.name).to_equal(b2.name)

    it "target_triple is stable across calls":
        val backend = create_interpreter_backend()
        val f = backend.target_triple_fn
        val r1 = f()
        val r2 = f()
        expect(r1).to_equal(r2)

    it "supports_jit is stable across calls":
        val backend = create_interpreter_backend()
        val f = backend.supports_jit_fn
        val r1 = f()
        val r2 = f()
        expect(r1).to_equal(r2)
