# MonoCache Efficiency Specification
#
# Tests for the memory efficiency fixes in monomorphization cache:
# 1. Stats direct field mutation (no full struct reconstruction per hit/miss)
# 2. oldest_key tracking for O(1) amortized LRU eviction
# 3. Correct stats accumulation across operations
#
# These tests verify the MonoCache class behaves correctly after
# replacing MonoCacheStats full reconstruction with direct mutation,
# and adding oldest_key tracking for efficient eviction.

use compiler.mono.monomorphize.cache.*

# ============================================================================
# Test Group 1: MonoCacheStats Initialization
# ============================================================================

describe "MonoCacheStats":
    it "empty() creates zeroed stats":
        val stats = MonoCacheStats.empty()

        expect(stats.hits).to_equal(0)
        expect(stats.misses).to_equal(0)
        expect(stats.evictions).to_equal(0)
        expect(stats.invalidations).to_equal(0)
        expect(stats.function_entries).to_equal(0)
        expect(stats.struct_entries).to_equal(0)
        expect(stats.class_entries).to_equal(0)

    it "hit_ratio returns 0 when no accesses":
        val stats = MonoCacheStats.empty()
        expect(stats.hit_ratio()).to_equal(0.0)

    it "total_entries sums all entry types":
        val stats = MonoCacheStats(
            hits: 0, misses: 0, evictions: 0, invalidations: 0,
            function_entries: 10, struct_entries: 5, class_entries: 3
        )
        expect(stats.total_entries()).to_equal(18)


# ============================================================================
# Test Group 2: MonoCacheConfig
# ============================================================================

describe "MonoCacheConfig":
    it "default_config has 10000 max entries":
        val config = MonoCacheConfig.default_config()

        expect(config.max_entries).to_equal(10000)
        expect(config.validate_timestamps).to_equal(true)
        expect(config.persist_to_disk).to_equal(false)

    it "memory_only config disables persistence":
        val config = MonoCacheConfig.memory_only()

        expect(config.persist_to_disk).to_equal(false)
        expect(config.max_entries).to_equal(10000)


# ============================================================================
# Test Group 3: MonoCache Creation with oldest_key
# ============================================================================

describe "MonoCache creation":
    it "create() initializes with empty oldest_key":
        val config = MonoCacheConfig.default_config()
        val cache = MonoCache.create(config)

        expect(cache.oldest_key).to_equal("")

    it "create() initializes with empty entries":
        val config = MonoCacheConfig.default_config()
        val cache = MonoCache.create(config)
        val stats = cache.get_stats()

        expect(stats.hits).to_equal(0)
        expect(stats.misses).to_equal(0)
        expect(stats.evictions).to_equal(0)

    it "create() initializes with zeroed stats":
        val config = MonoCacheConfig.default_config()
        val cache = MonoCache.create(config)
        val stats = cache.get_stats()

        expect(stats.function_entries).to_equal(0)
        expect(stats.struct_entries).to_equal(0)
        expect(stats.class_entries).to_equal(0)
        expect(stats.invalidations).to_equal(0)


# ============================================================================
# Test Group 4: Stats Direct Field Mutation (no struct reconstruction)
# ============================================================================

describe "Stats direct field mutation on lookup":
    # Verifies that lookup() increments ONLY the relevant counter
    # without disturbing other stats fields. This tests the fix
    # from full MonoCacheStats(...) reconstruction to self.stats.hits += 1.

    it "cache miss increments only misses counter":
        val config = MonoCacheConfig.default_config()
        val cache = MonoCache.create(config)

        val result = cache.lookup("nonexistent_key")
        expect(result.?).to_equal(false)

        val stats = cache.get_stats()
        expect(stats.misses).to_equal(1)
        expect(stats.hits).to_equal(0)
        expect(stats.evictions).to_equal(0)
        expect(stats.invalidations).to_equal(0)
        expect(stats.function_entries).to_equal(0)
        expect(stats.struct_entries).to_equal(0)
        expect(stats.class_entries).to_equal(0)

    it "cache hit increments only hits counter":
        val config = MonoCacheConfig.default_config()
        val cache = MonoCache.create(config)

        # Store an entry first
        cache.store("key1", 42, 12345)

        # Lookup should hit
        val result = cache.lookup("key1")
        expect(result.?).to_equal(true)

        val stats = cache.get_stats()
        expect(stats.hits).to_equal(1)
        expect(stats.misses).to_equal(0)
        expect(stats.evictions).to_equal(0)
        expect(stats.invalidations).to_equal(0)

    it "multiple misses accumulate correctly":
        val config = MonoCacheConfig.default_config()
        val cache = MonoCache.create(config)

        fn run_misses() -> i64:
            var i = 0
            while i < 5:
                val r = cache.lookup("miss_{i}")
                i = i + 1
            cache.get_stats().misses

        expect(run_misses()).to_equal(5)

    it "multiple hits accumulate correctly":
        val config = MonoCacheConfig.default_config()
        val cache = MonoCache.create(config)

        cache.store("stable_key", 100, 999)

        fn run_hits() -> i64:
            var i = 0
            while i < 7:
                val r = cache.lookup("stable_key")
                i = i + 1
            cache.get_stats().hits

        expect(run_hits()).to_equal(7)

    it "mixed hits and misses accumulate independently":
        val config = MonoCacheConfig.default_config()
        val cache = MonoCache.create(config)

        cache.store("exists", 42, 111)

        # 3 hits
        val r1 = cache.lookup("exists")
        val r2 = cache.lookup("exists")
        val r3 = cache.lookup("exists")

        # 2 misses
        val m1 = cache.lookup("nope1")
        val m2 = cache.lookup("nope2")

        val stats = cache.get_stats()
        expect(stats.hits).to_equal(3)
        expect(stats.misses).to_equal(2)
        expect(stats.evictions).to_equal(0)
        expect(stats.invalidations).to_equal(0)

    it "stats fields are independent — mutation of hits does not affect evictions":
        val config = MonoCacheConfig.default_config()
        val cache = MonoCache.create(config)

        cache.store("k1", 1, 100)
        cache.store("k2", 2, 200)

        # Generate some hits
        val r1 = cache.lookup("k1")
        val r2 = cache.lookup("k2")
        val r3 = cache.lookup("k1")

        val stats = cache.get_stats()
        # Hits should be 3, nothing else modified
        expect(stats.hits).to_equal(3)
        expect(stats.misses).to_equal(0)
        expect(stats.evictions).to_equal(0)
        expect(stats.invalidations).to_equal(0)
        expect(stats.function_entries).to_equal(0)
        expect(stats.struct_entries).to_equal(0)
        expect(stats.class_entries).to_equal(0)


# ============================================================================
# Test Group 5: Store and oldest_key Tracking
# ============================================================================

describe "Store and oldest_key tracking":
    it "first store sets oldest_key":
        val config = MonoCacheConfig.default_config()
        val cache = MonoCache.create(config)

        cache.store("first_entry", 1, 100)

        expect(cache.oldest_key).to_equal("first_entry")

    it "second store keeps oldest_key as first entry":
        val config = MonoCacheConfig.default_config()
        val cache = MonoCache.create(config)

        cache.store("entry_a", 1, 100)
        cache.store("entry_b", 2, 200)

        # oldest_key should still be entry_a (stored first = lower timestamp)
        expect(cache.oldest_key).to_equal("entry_a")

    it "store multiple entries tracks oldest":
        val config = MonoCacheConfig.default_config()
        val cache = MonoCache.create(config)

        cache.store("e1", 1, 100)
        cache.store("e2", 2, 200)
        cache.store("e3", 3, 300)
        cache.store("e4", 4, 400)
        cache.store("e5", 5, 500)

        # First entry should still be oldest
        expect(cache.oldest_key).to_equal("e1")


# ============================================================================
# Test Group 6: Eviction Behavior
# ============================================================================

describe "Eviction behavior":
    it "eviction increments evictions counter via direct mutation":
        # Use a tiny cache to trigger eviction
        val config = MonoCacheConfig(
            max_entries: 3,
            validate_timestamps: true,
            persist_to_disk: false,
            cache_dir: nil
        )
        val cache = MonoCache.create(config)

        # Fill the cache
        cache.store("k1", 1, 100)
        cache.store("k2", 2, 200)
        cache.store("k3", 3, 300)

        # This should trigger eviction (cache was full)
        cache.store("k4", 4, 400)

        val stats = cache.get_stats()
        expect(stats.evictions).to_equal(1)
        # Other stats should be unaffected
        expect(stats.hits).to_equal(0)
        expect(stats.misses).to_equal(0)
        expect(stats.invalidations).to_equal(0)

    it "eviction removes oldest entry":
        val config = MonoCacheConfig(
            max_entries: 3,
            validate_timestamps: true,
            persist_to_disk: false,
            cache_dir: nil
        )
        val cache = MonoCache.create(config)

        cache.store("oldest", 1, 100)
        cache.store("middle", 2, 200)
        cache.store("newest", 3, 300)

        # Trigger eviction — oldest should be removed
        cache.store("newcomer", 4, 400)

        val oldest_gone = cache.lookup("oldest")
        expect(oldest_gone.?).to_equal(false)

        # Others should still be present
        val middle_found = cache.lookup("middle")
        expect(middle_found.?).to_equal(true)

        val newest_found = cache.lookup("newest")
        expect(newest_found.?).to_equal(true)

        val newcomer_found = cache.lookup("newcomer")
        expect(newcomer_found.?).to_equal(true)

    it "multiple evictions increment counter correctly":
        val config = MonoCacheConfig(
            max_entries: 2,
            validate_timestamps: true,
            persist_to_disk: false,
            cache_dir: nil
        )
        val cache = MonoCache.create(config)

        cache.store("a", 1, 100)
        cache.store("b", 2, 200)
        # Eviction 1: removes "a"
        cache.store("c", 3, 300)
        # Eviction 2: removes "b"
        cache.store("d", 4, 400)
        # Eviction 3: removes "c"
        cache.store("e", 5, 500)

        val stats = cache.get_stats()
        expect(stats.evictions).to_equal(3)

    it "eviction updates oldest_key to new oldest":
        val config = MonoCacheConfig(
            max_entries: 3,
            validate_timestamps: true,
            persist_to_disk: false,
            cache_dir: nil
        )
        val cache = MonoCache.create(config)

        cache.store("first", 1, 100)
        cache.store("second", 2, 200)
        cache.store("third", 3, 300)

        # Before eviction, oldest is "first"
        expect(cache.oldest_key).to_equal("first")

        # Trigger eviction — "first" removed, new oldest should be "second"
        cache.store("fourth", 4, 400)

        expect(cache.oldest_key).to_equal("second")

    it "cache size stays at max_entries after evictions":
        val config = MonoCacheConfig(
            max_entries: 3,
            validate_timestamps: true,
            persist_to_disk: false,
            cache_dir: nil
        )
        val cache = MonoCache.create(config)

        cache.store("a", 1, 100)
        cache.store("b", 2, 200)
        cache.store("c", 3, 300)
        cache.store("d", 4, 400)  # evicts "a"
        cache.store("e", 5, 500)  # evicts "b"

        # Should have exactly 3 entries: c, d, e
        val c_found = cache.lookup("c")
        val d_found = cache.lookup("d")
        val e_found = cache.lookup("e")

        expect(c_found.?).to_equal(true)
        expect(d_found.?).to_equal(true)
        expect(e_found.?).to_equal(true)

        # a and b should be gone
        val a_found = cache.lookup("a")
        val b_found = cache.lookup("b")

        expect(a_found.?).to_equal(false)
        expect(b_found.?).to_equal(false)


# ============================================================================
# Test Group 7: Clear and Reset
# ============================================================================

describe "Cache clear":
    it "clear empties all entries":
        val config = MonoCacheConfig.default_config()
        val cache = MonoCache.create(config)

        cache.store("x", 1, 100)
        cache.store("y", 2, 200)
        cache.store("z", 3, 300)

        cache.clear()

        val x = cache.lookup("x")
        val y = cache.lookup("y")
        val z = cache.lookup("z")

        expect(x.?).to_equal(false)
        expect(y.?).to_equal(false)
        expect(z.?).to_equal(false)

    it "stats survive after clear":
        val config = MonoCacheConfig.default_config()
        val cache = MonoCache.create(config)

        cache.store("a", 1, 100)
        val hit = cache.lookup("a")
        val miss = cache.lookup("nonexistent")

        cache.clear()

        # Stats should reflect pre-clear activity
        val stats = cache.get_stats()
        expect(stats.hits).to_be_greater_than(0)


# ============================================================================
# Test Group 8: Stress Test — Many Entries
# ============================================================================

describe "Cache stress with many entries":
    it "handles 100 sequential stores without crash":
        val config = MonoCacheConfig(
            max_entries: 50,
            validate_timestamps: true,
            persist_to_disk: false,
            cache_dir: nil
        )
        val cache = MonoCache.create(config)

        fn run_stress() -> i64:
            var i = 0
            while i < 100:
                cache.store("key_{i}", i, i * 7)
                i = i + 1
            cache.get_stats().evictions

        val evictions = run_stress()
        # Should have evicted 50 entries (100 stored, capacity 50)
        expect(evictions).to_equal(50)

    it "handles interleaved store and lookup":
        val config = MonoCacheConfig(
            max_entries: 10,
            validate_timestamps: true,
            persist_to_disk: false,
            cache_dir: nil
        )
        val cache = MonoCache.create(config)

        fn run_interleaved() -> bool:
            var i = 0
            while i < 20:
                cache.store("item_{i}", i, i * 3)
                # Lookup a recent key
                if i > 0:
                    val prev_key = "item_{i - 1}"
                    val r = cache.lookup(prev_key)
                i = i + 1

            val stats = cache.get_stats()
            # Should have some evictions (20 entries, capacity 10)
            stats.evictions > 0

        expect(run_interleaved()).to_equal(true)

    it "oldest_key stays valid through many evictions":
        val config = MonoCacheConfig(
            max_entries: 5,
            validate_timestamps: true,
            persist_to_disk: false,
            cache_dir: nil
        )
        val cache = MonoCache.create(config)

        fn run_oldest_tracking() -> bool:
            var i = 0
            while i < 30:
                cache.store("entry_{i}", i, i)
                # oldest_key should never be empty after first store
                if cache.oldest_key == "" and i > 0:
                    return false
                i = i + 1
            true

        expect(run_oldest_tracking()).to_equal(true)


# ============================================================================
# Test Group 9: Edge Cases
# ============================================================================

describe "Cache edge cases":
    it "lookup on empty cache returns nil":
        val config = MonoCacheConfig.default_config()
        val cache = MonoCache.create(config)

        val result = cache.lookup("anything")
        expect(result.?).to_equal(false)

    it "store replaces existing entry":
        val config = MonoCacheConfig.default_config()
        val cache = MonoCache.create(config)

        cache.store("key", 100, 111)
        cache.store("key", 200, 222)

        val result = cache.lookup("key")
        expect(result.?).to_equal(true)
        expect(result.unwrap()).to_equal(200)

    it "max_entries of 1 works correctly":
        val config = MonoCacheConfig(
            max_entries: 1,
            validate_timestamps: true,
            persist_to_disk: false,
            cache_dir: nil
        )
        val cache = MonoCache.create(config)

        cache.store("only", 1, 100)

        val found = cache.lookup("only")
        expect(found.?).to_equal(true)

        # Storing another should evict the first
        cache.store("replacement", 2, 200)

        val old_gone = cache.lookup("only")
        expect(old_gone.?).to_equal(false)

        val new_found = cache.lookup("replacement")
        expect(new_found.?).to_equal(true)

        val stats = cache.get_stats()
        expect(stats.evictions).to_equal(1)

    it "evict_oldest on empty cache does not crash":
        val config = MonoCacheConfig.default_config()
        val cache = MonoCache.create(config)

        # Directly call evict_oldest on empty cache — should be safe
        cache.evict_oldest()

        val stats = cache.get_stats()
        expect(stats.evictions).to_equal(0)


# ============================================================================
# Test Group 10: Lookup Return Values
# ============================================================================

describe "Lookup return values":
    it "returns stored integer value":
        val config = MonoCacheConfig.default_config()
        val cache = MonoCache.create(config)

        cache.store("int_key", 42, 100)

        val result = cache.lookup("int_key")
        expect(result.?).to_equal(true)
        expect(result.unwrap()).to_equal(42)

    it "returns stored text value":
        val config = MonoCacheConfig.default_config()
        val cache = MonoCache.create(config)

        cache.store("text_key", "hello world", 200)

        val result = cache.lookup("text_key")
        expect(result.?).to_equal(true)
        expect(result.unwrap()).to_equal("hello world")

    it "returns nil for missing key":
        val config = MonoCacheConfig.default_config()
        val cache = MonoCache.create(config)

        cache.store("present", 1, 100)

        val result = cache.lookup("absent")
        expect(result.?).to_equal(false)

    it "returns correct value after overwrite":
        val config = MonoCacheConfig.default_config()
        val cache = MonoCache.create(config)

        cache.store("key", "first", 100)
        cache.store("key", "second", 200)
        cache.store("key", "third", 300)

        val result = cache.lookup("key")
        expect(result.?).to_equal(true)
        expect(result.unwrap()).to_equal("third")
