# Module alias spec
#
# Tests for import aliasing with delegation pattern.
# Note: `use mod.{name as alias}` syntax parses correctly but alias binding
# is not yet implemented in the interpreter. Use delegation as a workaround.

# Delegation pattern: define wrapper functions with desired alias name
fn double(x: i64) -> i64:
    x * 2

fn triple(x: i64) -> i64:
    x * 3

fn negate(b: bool) -> bool:
    b == false

# Type alias works correctly
type Length = i64

describe "module aliasing":
    it "delegation pattern provides function aliasing":
        val result = double(5)
        expect(result).to_equal(10)

    it "multiple delegation aliases work independently":
        val d = double(4)
        val t = triple(4)
        expect(d).to_equal(8)
        expect(t).to_equal(12)

    it "type alias works for type-level aliasing":
        val len: Length = 42
        expect(len).to_equal(42)

    it "aliased function used in expression":
        val x = double(3) + triple(2)
        expect(x).to_equal(12)

    it "aliased bool function works":
        val result = negate(true)
        expect(result).to_equal(false)
