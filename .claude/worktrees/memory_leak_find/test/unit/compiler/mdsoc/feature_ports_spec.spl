# Feature Port Struct Tests
#
# Tests that feature stage port structs can be constructed and
# that their fields are accessible.
#
# NOTE: Due to runtime limitation, only the FIRST struct in each imported
# module supports direct field construction. Subsequent structs are tested
# via the first struct's import scope.

use compiler.feature.lexing.app.ports.{LexerInputPort, LexerOutputPort}
use compiler.feature.parsing.app.ports.{ParseError, ParserInputPort, ParserOutputPort}
use compiler.feature.desugaring.app.ports.{DesugarInputPort, DesugarOutputPort}
use compiler.feature.codegen.app.ports.{CodegenInputPort, CodegenOutputPort}
use compiler.feature.monomorphization.app.ports.{MonomorphizeInputPort, MonomorphizeOutputPort}
use compiler.feature.optimization.app.ports.{OptimizeInputPort, OptimizeOutputPort}
use compiler.feature.linking.app.ports.{LinkerInputPort, LinkerOutputPort}

# ============================================================================
# LexerInputPort - first struct in lexing/app/ports.spl
# ============================================================================

describe "LexerInputPort":
    it "constructs with source_text":
        val port = LexerInputPort(source_text: "val x = 1")
        expect(port.source_text).to_equal("val x = 1")

    it "constructs with empty source":
        val port = LexerInputPort(source_text: "")
        expect(port.source_text).to_equal("")

    it "constructs with multiline source":
        val port = LexerInputPort(source_text: "fn foo():\n    1")
        expect(port.source_text).to_start_with("fn foo")

# ============================================================================
# LexerOutputPort - second struct in lexing/app/ports.spl
# Direct construction: fields will be nil due to runtime limitation.
# Test only that it constructs without error.
# ============================================================================

describe "LexerOutputPort":
    it "constructs with token data":
        val port = LexerOutputPort(
            token_tags: [1, 2, 3],
            token_texts: ["val", "x", "="],
            token_lines: [1, 1, 1],
            token_cols: [1, 5, 7],
            token_count: 3
        )
        expect(port.token_count).to_equal(3)

    it "constructs with empty token arrays":
        val port = LexerOutputPort(
            token_tags: [],
            token_texts: [],
            token_lines: [],
            token_cols: [],
            token_count: 0
        )
        expect(port.token_count).to_equal(0)

# ============================================================================
# ParseError - first struct in parsing/app/ports.spl
# ============================================================================

describe "ParseError":
    it "constructs with message and location":
        val err = ParseError(message: "unexpected token", line: 5, col: 12)
        expect(err.message).to_equal("unexpected token")
        expect(err.line).to_equal(5)
        expect(err.col).to_equal(12)

    it "stores zero location for start of file":
        val err = ParseError(message: "syntax error", line: 1, col: 1)
        expect(err.line).to_equal(1)
        expect(err.col).to_equal(1)

    it "stores large line numbers":
        val err = ParseError(message: "eof", line: 9999, col: 80)
        expect(err.line).to_equal(9999)

# ============================================================================
# ParserInputPort - second struct in parsing/app/ports.spl
# ============================================================================

describe "ParserInputPort":
    it "constructs with token stream data":
        val port = ParserInputPort(
            token_tags: [1, 2],
            token_texts: ["val", "x"],
            token_lines: [1, 1],
            token_cols: [1, 5],
            token_count: 2,
            source_text: "val x"
        )
        expect(port.token_count).to_equal(2)

# ============================================================================
# ParserOutputPort - third struct in parsing/app/ports.spl
# ============================================================================

describe "ParserOutputPort":
    it "constructs empty output":
        val port = ParserOutputPort(
            expr_count: 0,
            stmt_count: 0,
            decl_count: 0,
            root_decls: [],
            errors: [],
            error_count: 0
        )
        expect(port.error_count).to_equal(0)

    it "constructs output with counts":
        val port = ParserOutputPort(
            expr_count: 10,
            stmt_count: 5,
            decl_count: 3,
            root_decls: [0, 1, 2],
            errors: [],
            error_count: 0
        )
        expect(port.expr_count).to_equal(10)
        expect(port.stmt_count).to_equal(5)
        expect(port.decl_count).to_equal(3)

# ============================================================================
# DesugarInputPort - first struct in desugaring/app/ports.spl
# ============================================================================

describe "DesugarInputPort":
    it "constructs with source and module name":
        val port = DesugarInputPort(source_text: "fn foo(): 1", module_name: "test")
        expect(port.module_name).to_equal("test")
        expect(port.source_text).to_equal("fn foo(): 1")

    it "holds the module name":
        val port = DesugarInputPort(source_text: "", module_name: "my_module")
        expect(port.module_name).to_equal("my_module")

# ============================================================================
# DesugarOutputPort - second struct in desugaring/app/ports.spl
# ============================================================================

describe "DesugarOutputPort":
    it "constructs with desugared source":
        val port = DesugarOutputPort(
            desugared_source: "fn foo(): 1",
            injected_fn_names: [],
            pass_count: 5
        )
        expect(port.pass_count).to_equal(5)

    it "constructs with injected function names":
        val port = DesugarOutputPort(
            desugared_source: "fn foo(): 1\nfn __foo_impl(): 1",
            injected_fn_names: ["__foo_impl"],
            pass_count: 5
        )
        expect(port.pass_count).to_equal(5)

# ============================================================================
# CodegenInputPort - first struct in codegen/app/ports.spl
# ============================================================================

describe "CodegenInputPort":
    it "constructs with function counts":
        val port = CodegenInputPort(
            function_count: 3,
            extern_fn_count: 1,
            string_literal_count: 2
        )
        expect(port.function_count).to_equal(3)
        expect(port.extern_fn_count).to_equal(1)
        expect(port.string_literal_count).to_equal(2)

    it "constructs with zero counts":
        val port = CodegenInputPort(
            function_count: 0,
            extern_fn_count: 0,
            string_literal_count: 0
        )
        expect(port.function_count).to_equal(0)

# ============================================================================
# CodegenOutputPort - second struct in codegen/app/ports.spl
# ============================================================================

describe "CodegenOutputPort":
    it "reports success":
        val port = CodegenOutputPort(
            object_byte_count: 1024,
            symbol_count: 5,
            target_triple: "x86_64-linux-gnu",
            success: true
        )
        expect(port.success).to_equal(true)
        expect(port.target_triple).to_equal("x86_64-linux-gnu")

    it "reports failure":
        val port = CodegenOutputPort(
            object_byte_count: 0,
            symbol_count: 0,
            target_triple: "x86_64-linux-gnu",
            success: false
        )
        expect(port.success).to_equal(false)

    it "stores object byte count":
        val port = CodegenOutputPort(
            object_byte_count: 4096,
            symbol_count: 10,
            target_triple: "aarch64-linux-gnu",
            success: true
        )
        expect(port.object_byte_count).to_equal(4096)
        expect(port.symbol_count).to_equal(10)

# ============================================================================
# MonomorphizeInputPort - first struct in monomorphization/app/ports.spl
# ============================================================================

describe "MonomorphizeInputPort":
    it "constructs with generic function count":
        val port = MonomorphizeInputPort(
            typed_decl_count: 10,
            generic_fn_count: 3,
            has_generics: true
        )
        expect(port.typed_decl_count).to_equal(10)
        expect(port.generic_fn_count).to_equal(3)
        expect(port.has_generics).to_equal(true)

    it "constructs with no generics":
        val port = MonomorphizeInputPort(
            typed_decl_count: 5,
            generic_fn_count: 0,
            has_generics: false
        )
        expect(port.generic_fn_count).to_equal(0)
        expect(port.has_generics).to_equal(false)

    it "stores typed declaration count":
        val port = MonomorphizeInputPort(
            typed_decl_count: 42,
            generic_fn_count: 7,
            has_generics: true
        )
        expect(port.typed_decl_count).to_equal(42)

# ============================================================================
# MonomorphizeOutputPort - second struct in monomorphization/app/ports.spl
# ============================================================================

describe "MonomorphizeOutputPort":
    it "constructs with specialization counts":
        val port = MonomorphizeOutputPort(
            mono_decl_count: 15,
            specialized_count: 6
        )
        expect(port.mono_decl_count).to_equal(15)
        expect(port.specialized_count).to_equal(6)

    it "constructs with zero specializations":
        val port = MonomorphizeOutputPort(
            mono_decl_count: 5,
            specialized_count: 0
        )
        expect(port.specialized_count).to_equal(0)

# ============================================================================
# OptimizeInputPort - first struct in optimization/app/ports.spl
# ============================================================================

describe "OptimizeInputPort":
    it "constructs with basic optimization level":
        val port = OptimizeInputPort(
            mir_fn_count: 8,
            mir_inst_count: 120,
            optimization_level: 1
        )
        expect(port.mir_fn_count).to_equal(8)
        expect(port.mir_inst_count).to_equal(120)
        expect(port.optimization_level).to_equal(1)

    it "constructs with no optimization":
        val port = OptimizeInputPort(
            mir_fn_count: 3,
            mir_inst_count: 40,
            optimization_level: 0
        )
        expect(port.optimization_level).to_equal(0)

    it "constructs with aggressive optimization":
        val port = OptimizeInputPort(
            mir_fn_count: 20,
            mir_inst_count: 500,
            optimization_level: 3
        )
        expect(port.optimization_level).to_equal(3)
        expect(port.mir_fn_count).to_equal(20)

# ============================================================================
# OptimizeOutputPort - second struct in optimization/app/ports.spl
# ============================================================================

describe "OptimizeOutputPort":
    it "constructs with eliminated instruction count":
        val port = OptimizeOutputPort(
            mir_fn_count: 8,
            mir_inst_count: 90,
            eliminated_count: 30
        )
        expect(port.mir_fn_count).to_equal(8)
        expect(port.mir_inst_count).to_equal(90)
        expect(port.eliminated_count).to_equal(30)

    it "constructs with no eliminated instructions":
        val port = OptimizeOutputPort(
            mir_fn_count: 3,
            mir_inst_count: 40,
            eliminated_count: 0
        )
        expect(port.eliminated_count).to_equal(0)

# ============================================================================
# LinkerInputPort - first struct in linking/app/ports.spl
# ============================================================================

describe "LinkerInputPort":
    it "constructs for executable output":
        val port = LinkerInputPort(
            object_file_count: 3,
            library_count: 2,
            output_type: "exe",
            output_path: "/tmp/out"
        )
        expect(port.object_file_count).to_equal(3)
        expect(port.library_count).to_equal(2)
        expect(port.output_type).to_equal("exe")
        expect(port.output_path).to_equal("/tmp/out")

    it "constructs for library output":
        val port = LinkerInputPort(
            object_file_count: 1,
            library_count: 0,
            output_type: "lib",
            output_path: "/tmp/libfoo.a"
        )
        expect(port.output_type).to_equal("lib")

    it "constructs for smf output":
        val port = LinkerInputPort(
            object_file_count: 2,
            library_count: 1,
            output_type: "smf",
            output_path: "/tmp/mod.smf"
        )
        expect(port.output_type).to_equal("smf")
        expect(port.object_file_count).to_equal(2)

# ============================================================================
# LinkerOutputPort - second struct in linking/app/ports.spl
# ============================================================================

describe "LinkerOutputPort":
    it "constructs successful link result":
        val port = LinkerOutputPort(
            output_path: "/tmp/out",
            output_size_bytes: 65536,
            success: true,
            error_message: ""
        )
        expect(port.output_path).to_equal("/tmp/out")
        expect(port.output_size_bytes).to_equal(65536)
        expect(port.success).to_equal(true)

    it "constructs failed link result":
        val port = LinkerOutputPort(
            output_path: "",
            output_size_bytes: 0,
            success: false,
            error_message: "undefined symbol: main"
        )
        expect(port.success).to_equal(false)
        expect(port.error_message).to_equal("undefined symbol: main")
