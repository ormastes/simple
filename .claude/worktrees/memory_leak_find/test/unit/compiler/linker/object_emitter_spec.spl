use compiler.linker.object_emitter.{assemble_code_units}
use compiler.linker.object_provider_adapter.{make_object_code_unit}
use app.io.mod {file_exists, file_size, shell}
use std.system.{host_arch}

describe "object_emitter":
    it "writes ELF64 object without clang fallback":
        val arch = host_arch()
        # Use a minimal 'ret' instruction per arch
        val code = if arch == "aarch64":
            # AArch64: ret -> 0xd65f03c0 little endian bytes
            [0xC0, 0x03, 0x5F, 0xD6]
        else:
            # x86_64: ret
            [0xC3]

        val code_unit = make_object_code_unit("test_fn", code)
        val obj_path = "/tmp/object_emitter_test.o"

        val res = assemble_code_units([code_unit], obj_path, false)
        expect(res.is_ok()).to_equal(true)
        expect(file_exists(obj_path)).to_equal(true)
        expect(file_size(obj_path) > 0).to_equal(true)

        # cleanup
        _ = shell("rm -f '{obj_path}' '{obj_path}.S'")
