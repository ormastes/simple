# Tests for link section and address space attribute parsing.
# No imports - uses module-level helper functions to replicate logic.

# ============================================================================
# Module-level helpers (replicate link_attrs.spl logic without imports)
# ============================================================================

fn helper_link_section_attr_default() -> text:
    # Returns a summary of a default attr: "section='' has_section=false addr_space='' has_addr_space=false"
    "section='' has_section=false addr_space='' has_addr_space=false"

fn helper_make_attr(section: text, addr_space: text) -> [text]:
    # Returns [section, has_section, addr_space, has_addr_space] as text array
    val has_section = section.len() > 0
    val has_addr = addr_space.len() > 0
    var has_section_str = "false"
    if has_section:
        has_section_str = "true"
    var has_addr_str = "false"
    if has_addr:
        has_addr_str = "true"
    [section, has_section_str, addr_space, has_addr_str]

fn helper_has_placement(has_section: bool, has_addr_space: bool) -> bool:
    has_section or has_addr_space

fn helper_is_flash(has_addr_space: bool, addr_space: text) -> bool:
    has_addr_space and addr_space == "flash"

fn helper_is_ram(has_addr_space: bool, addr_space: text) -> bool:
    if not has_addr_space:
        return false
    addr_space == "ram" or addr_space == "sram"

fn helper_codegen_hint(has_section: bool, section: text, has_addr_space: bool, addr_space: text) -> text:
    if has_section and has_addr_space:
        return "section=" + section + " addr_space=" + addr_space
    elif has_section:
        return "section=" + section
    elif has_addr_space:
        return "addr_space=" + addr_space
    else:
        return ""

fn helper_extract_link_string_arg_empty() -> text:
    ""

fn helper_extract_link_string_arg_quoted(arg: text) -> text:
    val alen = arg.len()
    if alen >= 2:
        val first = arg[0:1]
        val last = arg[alen-1:alen]
        if first == "\"" and last == "\"":
            return arg[1:alen-1]
    arg

# ============================================================================
# Specs
# ============================================================================

describe "link section attribute parsing":

    describe "default attributes":
        it "default_no_section: default attr has no section":
            val has_section = false
            expect(has_section).to_equal(false)

        it "default_no_addr_space: default attr has no addr_space":
            val has_addr_space = false
            expect(has_addr_space).to_equal(false)

        it "default_section_empty: default section is empty string":
            val section = ""
            expect(section).to_equal("")

        it "default_addr_space_empty: default addr_space is empty string":
            val addr_space = ""
            expect(addr_space).to_equal("")

    describe "@link_section annotation":
        it "link_section_rodata: @link_section('.rodata') sets section":
            val attr = helper_make_attr(".rodata", "")
            expect(attr[0]).to_equal(".rodata")

        it "link_section_has_section_true: @link_section sets has_section=true":
            val attr = helper_make_attr(".rodata", "")
            expect(attr[1]).to_equal("true")

        it "link_section_isr: @link_section('.isr_vector') sets section":
            val attr = helper_make_attr(".isr_vector", "")
            expect(attr[0]).to_equal(".isr_vector")

    describe "@addr_space annotation":
        it "addr_space_flash: @addr_space('flash') sets addr_space":
            val attr = helper_make_attr("", "flash")
            expect(attr[2]).to_equal("flash")

        it "addr_space_has_addr_space_true: @addr_space sets has_addr_space=true":
            val attr = helper_make_attr("", "flash")
            expect(attr[3]).to_equal("true")

        it "addr_space_ram: @addr_space('ram') sets addr_space":
            val attr = helper_make_attr("", "ram")
            expect(attr[2]).to_equal("ram")

    describe "both annotations together":
        it "both_section_and_addr: section and addr_space can coexist":
            val attr = helper_make_attr(".isr_vector", "flash")
            expect(attr[0]).to_equal(".isr_vector")
            expect(attr[2]).to_equal("flash")
            expect(attr[1]).to_equal("true")
            expect(attr[3]).to_equal("true")

    describe "link_attr_has_placement":
        it "has_placement_false_when_no_attrs: no attrs means no placement":
            val result = helper_has_placement(false, false)
            expect(result).to_equal(false)

        it "has_placement_true_with_section: section alone means has placement":
            val result = helper_has_placement(true, false)
            expect(result).to_equal(true)

        it "has_placement_true_with_addr_space: addr_space alone means has placement":
            val result = helper_has_placement(false, true)
            expect(result).to_equal(true)

        it "has_placement_true_with_both: both section and addr_space means has placement":
            val result = helper_has_placement(true, true)
            expect(result).to_equal(true)

    describe "link_attr_is_flash":
        it "is_flash_true_for_flash: addr_space flash returns true":
            val result = helper_is_flash(true, "flash")
            expect(result).to_equal(true)

        it "is_flash_false_for_ram: addr_space ram returns false":
            val result = helper_is_flash(true, "ram")
            expect(result).to_equal(false)

        it "is_flash_false_when_no_addr_space: no addr_space returns false":
            val result = helper_is_flash(false, "flash")
            expect(result).to_equal(false)

    describe "link_attr_is_ram":
        it "is_ram_true_for_ram: addr_space ram returns true":
            val result = helper_is_ram(true, "ram")
            expect(result).to_equal(true)

        it "is_ram_true_for_sram: addr_space sram returns true":
            val result = helper_is_ram(true, "sram")
            expect(result).to_equal(true)

        it "is_ram_false_for_flash: addr_space flash is not ram":
            val result = helper_is_ram(true, "flash")
            expect(result).to_equal(false)

        it "is_ram_false_when_no_addr_space: no addr_space returns false":
            val result = helper_is_ram(false, "ram")
            expect(result).to_equal(false)

    describe "link_attr_codegen_hint":
        it "codegen_hint_empty_when_no_placement: no attrs gives empty hint":
            val hint = helper_codegen_hint(false, "", false, "")
            expect(hint).to_equal("")

        it "codegen_hint_section_only: section attr formats as section=X":
            val hint = helper_codegen_hint(true, ".text.cold", false, "")
            expect(hint).to_equal("section=.text.cold")

        it "codegen_hint_addr_space_only: addr_space attr formats as addr_space=X":
            val hint = helper_codegen_hint(false, "", true, "flash")
            expect(hint).to_equal("addr_space=flash")

        it "codegen_hint_both: both attrs format as section=X addr_space=Y":
            val hint = helper_codegen_hint(true, ".isr_vector", true, "flash")
            expect(hint).to_equal("section=.isr_vector addr_space=flash")

    describe "extract_link_string_arg":
        it "extract_empty_args_returns_empty: no args gives empty string":
            val result = helper_extract_link_string_arg_empty()
            expect(result).to_equal("")

        it "extract_quoted_arg_strips_quotes: quoted string is unquoted":
            val result = helper_extract_link_string_arg_quoted("\".rodata\"")
            expect(result).to_equal(".rodata")

        it "extract_unquoted_arg_unchanged: unquoted arg is returned as-is":
            val result = helper_extract_link_string_arg_quoted(".rodata")
            expect(result).to_equal(".rodata")
