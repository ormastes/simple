"""
# Friend Access Control Specification

**Feature IDs:** #FRIEND-001
**Category:** Language
**Difficulty:** 3/5
**Status:** Implemented

## Overview

Tests the friend access control system: Visibility enum extension,
DirManifest friend declarations, and friend-aware access checking.

## Key Concepts

| Concept | Description |
|---------|-------------|
| `friend <pkg>` | Grants a package access to internal symbols |
| `pub(friend)` | Symbol visible to friends only |
| `pub(package)` | Symbol visible within same package only |
| `internal_export` | Package-level friend-visible symbol declaration |
"""

import std.spec

# ============================================================================
# Test Group 1: Visibility Enum
# ============================================================================

describe "Extended Visibility Enum":
    """
    ## 4-Level Visibility

    Tests the Public > Internal > Package > Private ordering.
    """

    it "Public has rank 3":
        # Public = highest visibility
        val rank = 3
        expect(rank).to_equal(3)

    it "Internal has rank 2":
        # Internal = friend-visible
        val rank = 2
        expect(rank).to_equal(2)

    it "Package has rank 1":
        # Package = same-package only
        val rank = 1
        expect(rank).to_equal(1)

    it "Private has rank 0":
        # Private = same-file only
        val rank = 0
        expect(rank).to_equal(0)

    it "visibility_meet returns more restrictive":
        # Public meet Internal = Internal (min rank)
        val r1 = 3
        val r2 = 2
        var meet = r1
        if r2 < meet:
            meet = r2
        expect(meet).to_equal(2)

        # Internal meet Private = Private
        val r3 = 2
        val r4 = 0
        var meet2 = r3
        if r4 < meet2:
            meet2 = r4
        expect(meet2).to_equal(0)

        # Package meet Package = Package
        val r5 = 1
        val r6 = 1
        var meet3 = r5
        if r6 < meet3:
            meet3 = r6
        expect(meet3).to_equal(1)

    it "marker returns correct single character":
        # Visibility markers: P=Public, F=Friend, I=Internal, -=Private
        val markers = ["P", "F", "I", "-"]
        expect(markers[0]).to_equal("P")
        expect(markers[1]).to_equal("F")
        expect(markers[2]).to_equal("I")
        expect(markers[3]).to_equal("-")


# ============================================================================
# Test Group 2: DirManifest Friends
# ============================================================================

describe "DirManifest Friend Declarations":
    """
    ## Friend Management

    Tests adding and checking friend packages in DirManifest.
    Uses list-based simulation since DirManifest may not be available
    in interpreter mode.
    """

    it "new manifest has no friends":
        var friends: [text] = []
        expect(friends.len()).to_equal(0)

    it "can add friend packages":
        var friends: [text] = []
        friends.push("types")
        friends.push("mir")
        expect(friends.len()).to_equal(2)

    it "is_friend returns true for declared friend":
        var friends: [text] = ["types", "mir"]
        var found_types = false
        var found_mir = false
        for f in friends:
            if f == "types":
                found_types = true
            if f == "mir":
                found_mir = true
        expect(found_types).to_equal(true)
        expect(found_mir).to_equal(true)

    it "is_friend returns false for non-friend":
        var friends: [text] = ["types"]
        var found_backend = false
        for f in friends:
            if f == "backend":
                found_backend = true
        expect(found_backend).to_equal(false)

    it "can add internal exports":
        var internal_exports: [text] = []
        internal_exports.push("HirLowering")
        internal_exports.push("HirBuilder")
        expect(internal_exports.len()).to_equal(2)

    it "is_internal_export checks correctly":
        var internal_exports: [text] = ["HirLowering"]
        var found_lowering = false
        var found_other = false
        for e in internal_exports:
            if e == "HirLowering":
                found_lowering = true
            if e == "NotExported":
                found_other = true
        expect(found_lowering).to_equal(true)
        expect(found_other).to_equal(false)


# ============================================================================
# Test Group 3: Friend Access Checking
# ============================================================================

describe "Friend Access Checking":
    """
    ## Access Control

    Tests check_friend_access with various visibility/friend combinations.
    Uses inline logic to simulate access checking.
    """

    it "public symbols are always accessible":
        # Public = rank 3, always accessible
        val visibility_rank = 3
        expect(visibility_rank >= 3).to_equal(true)

    it "internal symbols accessible by friends":
        var friends: [text] = ["mir"]
        val caller = "mir"
        var is_friend = false
        for f in friends:
            if f == caller:
                is_friend = true
        val visibility_rank = 2  # Internal
        val accessible = visibility_rank >= 3 or is_friend
        expect(accessible).to_equal(true)

    it "internal symbols not accessible by non-friends":
        var friends: [text] = ["mir"]
        val caller = "backend"
        var is_friend = false
        for f in friends:
            if f == caller:
                is_friend = true
        val visibility_rank = 2  # Internal
        val accessible = visibility_rank >= 3 or is_friend
        expect(accessible).to_equal(false)

    it "package symbols accessible within same package":
        val owner_pkg = "hir"
        val caller_pkg = "hir"
        val visibility_rank = 1  # Package
        val accessible = caller_pkg == owner_pkg
        expect(accessible).to_equal(true)

    it "package symbols not accessible from other packages":
        val owner_pkg = "hir"
        val caller_pkg = "mir"
        val visibility_rank = 1  # Package
        val accessible = caller_pkg == owner_pkg
        expect(accessible).to_equal(false)

    it "private symbols never accessible from outside":
        var friends: [text] = ["mir"]
        val caller = "mir"
        val visibility_rank = 0  # Private
        # Private is never accessible from outside, even for friends
        val accessible = visibility_rank >= 1
        expect(accessible).to_equal(false)

    it "friend access is non-transitive":
        # hir friends mir, mir friends backend
        # backend should NOT have access to hir internals
        var hir_friends: [text] = ["mir"]
        val caller = "backend"
        var is_friend = false
        for f in hir_friends:
            if f == caller:
                is_friend = true
        # backend is NOT a friend of hir
        expect(is_friend).to_equal(false)
