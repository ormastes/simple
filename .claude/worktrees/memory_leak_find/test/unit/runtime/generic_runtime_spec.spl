# Runtime Generics Implementation Tests
#
# Tests for runtime monomorphization of generic functions.
# Verifies that generics work in interpreter mode (not just compiled mode).

describe "Runtime Generic Functions":
    it "specializes identity function with integers":
        fn identity<T>(x: T) -> T:
            x

        val result = identity(42)
        expect(result).to_equal(42)

    it "specializes identity function with text":
        fn identity<T>(x: T) -> T:
            x

        val result = identity("hello")
        expect(result).to_equal("hello")

    it "specializes identity function with floats":
        fn identity<T>(x: T) -> T:
            x

        val result = identity(3.14)
        expect(result).to_equal(3.14)

    it "specializes identity function with booleans":
        fn identity<T>(x: T) -> T:
            x

        val result = identity(true)
        expect(result).to_equal(true)

    it "caches specialized versions":
        fn identity<T>(x: T) -> T:
            x

        # First call creates specialization
        val result1 = identity(10)
        # Second call should use cached version
        val result2 = identity(20)

        expect(result1).to_equal(10)
        expect(result2).to_equal(20)

    it "creates separate specializations for different types":
        fn identity<T>(x: T) -> T:
            x

        val int_result = identity(42)
        val text_result = identity("world")

        expect(int_result).to_equal(42)
        expect(text_result).to_equal("world")

describe "Generic Functions with Multiple Type Parameters":
    it "handles two type parameters":
        fn pair<T, U>(first: T, second: U) -> T:
            first

        val result = pair(42, "hello")
        expect(result).to_equal(42)

    it "handles three type parameters":
        fn pick_first<A, B, C>(a: A, b: B, c: C) -> A:
            a

        val result = pick_first(1, 2.5, "three")
        expect(result).to_equal(1)

    it "caches multi-param specializations independently":
        fn pair<T, U>(first: T, second: U) -> T:
            first

        val result1 = pair(10, 20)        # i64, i64
        val result2 = pair(10, "twenty")  # i64, text
        val result3 = pair("ten", 20)     # text, i64

        expect(result1).to_equal(10)
        expect(result2).to_equal(10)
        expect(result3).to_equal("ten")

describe "Generic Functions with Complex Bodies":
    it "works with conditionals":
        fn safe_div<T>(x: T, y: T) -> T:
            if y == 0:
                return 0
            x

        val result1 = safe_div(10, 2)
        val result2 = safe_div(10, 0)

        expect(result1).to_equal(10)
        expect(result2).to_equal(0)

    it "works with loops":
        fn count<T>(x: T, times: i64) -> i64:
            var counter: i64 = 0
            for i in 0..times:
                counter = counter + 1
            counter

        val result = count(42, 5)
        expect(result).to_equal(5)

    it "works with multiple statements":
        fn process<T>(x: T) -> T:
            val temp = x
            val result = temp
            result

        val int_result = process(42)
        val text_result = process("test")

        expect(int_result).to_equal(42)
        expect(text_result).to_equal("test")

describe "Generic Function Edge Cases":
    it "handles nil values":
        fn passthrough<T>(x: T) -> T:
            x

        val result = passthrough(nil)
        expect(result).to_be_nil()

    it "handles nested generic calls":
        fn outer<T>(x: T) -> T:
            fn inner<U>(y: U) -> U:
                y
            inner(x)

        val result = outer(42)
        expect(result).to_equal(42)

    it "handles arrays of different types":
        fn first_elem<T>(arr: [T]) -> i64:
            arr.len()

        val int_arr_len = first_elem([1, 2, 3])
        val text_arr_len = first_elem(["a", "b"])

        expect(int_arr_len).to_equal(3)
        expect(text_arr_len).to_equal(2)

    it "handles empty parameter lists":
        fn constant<T>() -> i64:
            42

        val result = constant()
        expect(result).to_equal(42)

describe "Generic Struct Integration":
    it "works with generic struct construction":
        fn make_pair<T>(x: T, y: T) -> [T]:
            [x, y]

        val int_pair = make_pair(1, 2)
        val text_pair = make_pair("a", "b")

        expect(int_pair[0]).to_equal(1)
        expect(int_pair[1]).to_equal(2)
        expect(text_pair[0]).to_equal("a")
        expect(text_pair[1]).to_equal("b")

    it "works with option-like patterns":
        fn wrap<T>(x: T) -> [T]:
            [x]

        fn unwrap<T>(arr: [T]) -> T:
            arr[0]

        val wrapped = wrap(42)
        val unwrapped = unwrap(wrapped)

        expect(unwrapped).to_equal(42)

describe "Generic Function Type Inference":
    it "infers types from integer literals":
        fn double<T>(x: T) -> T:
            x

        val result = double(21)
        expect(result).to_equal(21)

    it "infers types from float literals":
        fn double<T>(x: T) -> T:
            x

        val result = double(2.5)
        expect(result).to_equal(2.5)

    it "infers types from string literals":
        fn double<T>(x: T) -> T:
            x

        val result = double("test")
        expect(result).to_equal("test")

    it "infers types from boolean literals":
        fn double<T>(x: T) -> T:
            x

        val result = double(false)
        expect(result).to_equal(false)

    it "infers types from variables":
        fn passthrough<T>(x: T) -> T:
            x

        val my_var: i64 = 100
        val result = passthrough(my_var)
        expect(result).to_equal(100)

describe "Generic Cache Behavior":
    it "uses cache for repeated calls with same type":
        fn expensive<T>(x: T) -> T:
            x

        # All these should hit the same cached specialization
        val r1 = expensive(1)
        val r2 = expensive(2)
        val r3 = expensive(3)

        expect(r1).to_equal(1)
        expect(r2).to_equal(2)
        expect(r3).to_equal(3)

    it "creates new cache entries for different types":
        fn identity<T>(x: T) -> T:
            x

        # Each type creates a new cache entry
        val int_val = identity(42)
        val float_val = identity(3.14)
        val text_val = identity("hello")
        val bool_val = identity(true)

        expect(int_val).to_equal(42)
        expect(float_val).to_equal(3.14)
        expect(text_val).to_equal("hello")
        expect(bool_val).to_equal(true)

    it "handles interleaved calls to different generic functions":
        fn id1<T>(x: T) -> T:
            x

        fn id2<T>(x: T) -> T:
            x

        val r1 = id1(10)
        val r2 = id2(20)
        val r3 = id1(30)
        val r4 = id2(40)

        expect(r1).to_equal(10)
        expect(r2).to_equal(20)
        expect(r3).to_equal(30)
        expect(r4).to_equal(40)
