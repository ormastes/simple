"""
# Report Specification

**Feature IDs:** #RPT-003
**Category:** Infrastructure
**Difficulty:** 3/5
**Status:** Implemented

## Overview

Tests for the Report class from the unified reporting system.
Verifies report creation, builder pattern, and formatting.

## Key Concepts

| Concept | Description |
|---------|-------------|
| Report | Core diagnostic message with level, code, location |
| ReportKind | Category of report (ParseError, TypeError, etc.) |
| Suggestion | Machine-applicable fix with confidence level |
| FixConfidence | How safe it is to auto-apply a fix |
"""

use std.report.*

# ============================================================================
# Test Group 1: Report Creation
# ============================================================================

describe "Report":
    """
    ## Report Creation

    Tests for creating reports with factory methods.
    """

    context "factory methods":
        """
        ### Report Factory Methods

        Reports can be created with error, warning, info, debug, fatal methods.
        """

        it "creates error report":
            val report = Report.error("test error")
            expect(report.level).to_equal(ReportLevel.Error)
            expect(report.message).to_equal("test error")

        it "creates warning report":
            val report = Report.warning("test warning")
            expect(report.level).to_equal(ReportLevel.Warning)

        it "creates info report":
            val report = Report.info("test info")
            expect(report.level).to_equal(ReportLevel.Info)

        it "creates debug report":
            val report = Report.debug("test debug")
            expect(report.level).to_equal(ReportLevel.Debug)

        it "creates fatal report":
            val report = Report.fatal("test fatal")
            expect(report.level).to_equal(ReportLevel.Fatal)

    context "builder pattern":
        """
        ### Builder Pattern

        Reports can be built incrementally with with_* methods.
        """

        it "adds code with_code":
            val report = Report.error("message")
                .with_code("E0001")
            expect(report.code.?).to_be_true()
            expect(report.code.unwrap()).to_equal("E0001")

        it "adds kind with_kind":
            val report = Report.error("message")
                .with_kind(ReportKind.TypeError)
            expect(report.kind).to_equal(ReportKind.TypeError)

        it "adds location with at":
            val report = Report.error("message")
                .at("test.spl", 10, 5)
            expect(report.location.?).to_be_true()
            expect(report.location.unwrap().file).to_equal("test.spl")

        it "adds location with with_location":
            val loc = SourceLocation.at("test.spl", 10, 5)
            val report = Report.error("message")
                .with_location(loc)
            expect(report.location.?).to_be_true()

        it "adds note with_note":
            val report = Report.error("message")
                .with_note("additional info")
            expect(report.notes.len()).to_equal(1)
            expect(report.notes[0]).to_equal("additional info")

        it "adds help with_help":
            val report = Report.error("message")
                .with_help("try this")
            expect(report.help.len()).to_equal(1)
            expect(report.help[0]).to_equal("try this")

        it "adds source with_source":
            val report = Report.error("message")
                .with_source("compiler")
            expect(report.source_name.?).to_be_true()
            expect(report.source_name.unwrap()).to_equal("compiler")

        it "chains multiple builders":
            val report = Report.error("type mismatch")
                .with_code("E0308")
                .at("main.spl", 10, 5)
                .with_note("expected i64")
                .with_help("add type annotation")
            expect(report.code.unwrap()).to_equal("E0308")
            expect(report.location.unwrap().file).to_equal("main.spl")
            expect(report.notes.len()).to_equal(1)
            expect(report.help.len()).to_equal(1)

    context "labels":
        """
        ### Report Labels

        Reports can have multiple labeled spans.
        """

        it "adds primary label":
            val loc = SourceLocation.at("test.spl", 10, 5)
            val report = Report.error("message")
                .with_primary_label(loc, "error here")
            expect(report.labels.len()).to_equal(1)
            expect(report.labels[0].primary).to_be_true()

        it "adds secondary label":
            val loc = SourceLocation.at("test.spl", 10, 5)
            val report = Report.error("message")
                .with_secondary_label(loc, "related")
            expect(report.labels.len()).to_equal(1)
            expect(report.labels[0].primary).to_be_false()

        it "adds multiple labels":
            val loc1 = SourceLocation.at("test.spl", 10, 5)
            val loc2 = SourceLocation.at("test.spl", 15, 3)
            val report = Report.error("message")
                .with_primary_label(loc1, "error")
                .with_secondary_label(loc2, "note")
            expect(report.labels.len()).to_equal(2)

    context "suggestions":
        """
        ### Fix Suggestions

        Reports can include machine-applicable fix suggestions.
        """

        it "adds suggestion":
            val loc = SourceLocation.at("test.spl", 10, 5)
            val suggestion = Suggestion.replace(loc, "new_code", "fix it")
            val report = Report.error("message")
                .with_suggestion(suggestion)
            expect(report.suggestions.len()).to_equal(1)
            expect(report.has_suggestions()).to_be_true()

        it "has_suggestions returns false when empty":
            val report = Report.error("message")
            expect(report.has_suggestions()).to_be_false()

    context "accessors":
        """
        ### Report Accessors

        Reports provide accessor methods for common checks.
        """

        it "is_error for Error level":
            val report = Report.error("message")
            expect(report.is_error()).to_be_true()

        it "is_error for Fatal level":
            val report = Report.fatal("message")
            expect(report.is_error()).to_be_true()

        it "is_error returns false for Warning":
            val report = Report.warning("message")
            expect(report.is_error()).to_be_false()

        it "is_warning for Warning level":
            val report = Report.warning("message")
            expect(report.is_warning()).to_be_true()

        it "has_location returns true when set":
            val report = Report.error("message")
                .at("test.spl", 10, 5)
            expect(report.has_location()).to_be_true()

        it "has_location returns false when not set":
            val report = Report.error("message")
            expect(report.has_location()).to_be_false()

        it "get_file returns file when location set":
            val report = Report.error("message")
                .at("test.spl", 10, 5)
            expect(report.get_file().?).to_be_true()
            expect(report.get_file().unwrap()).to_equal("test.spl")

        it "get_line returns line when location set":
            val report = Report.error("message")
                .at("test.spl", 10, 5)
            expect(report.get_line()).to_equal(10)

    context "formatting":
        """
        ### Report Formatting

        Reports can be formatted as strings.
        """

        it "format_short includes level and message":
            val report = Report.error("test error")
            val formatted = report.format_short()
            expect(formatted).to_contain("error")
            expect(formatted).to_contain("test error")

        it "format_short includes code when set":
            val report = Report.error("test error")
                .with_code("E0001")
            val formatted = report.format_short()
            expect(formatted).to_contain("E0001")

        it "format_short includes location when set":
            val report = Report.error("test error")
                .at("main.spl", 10, 5)
            val formatted = report.format_short()
            expect(formatted).to_contain("main.spl:10:5")

# ============================================================================
# Test Group 2: ReportKind
# ============================================================================

describe "ReportKind":
    """
    ## ReportKind

    Tests for report kind categories.
    """

    context "category detection":
        """
        ### Category Detection

        Report kinds belong to compiler, runtime, or tool categories.
        """

        it "ParseError is compiler":
            expect(ReportKind.ParseError.is_compiler()).to_be_true()

        it "TypeError is compiler":
            expect(ReportKind.TypeError.is_compiler()).to_be_true()

        it "RuntimeError is runtime":
            expect(ReportKind.RuntimeError.is_runtime()).to_be_true()

        it "Panic is runtime":
            expect(ReportKind.Panic.is_runtime()).to_be_true()

        it "BuildError is tool":
            expect(ReportKind.BuildError.is_tool()).to_be_true()

        it "TestFailure is tool":
            expect(ReportKind.TestFailure.is_tool()).to_be_true()

    context "names":
        """
        ### Kind Names

        Each kind has a human-readable name.
        """

        it "ParseError name is parse error":
            expect(ReportKind.ParseError.name()).to_equal("parse error")

        it "TypeError name is type error":
            expect(ReportKind.TypeError.name()).to_equal("type error")

# ============================================================================
# Test Group 3: Suggestion and FixConfidence
# ============================================================================

describe "Suggestion":
    """
    ## Suggestion

    Tests for fix suggestion creation and confidence levels.
    """

    context "creation":
        """
        ### Suggestion Creation

        Suggestions can be created for replacement, insertion, or deletion.
        """

        it "creates replacement suggestion":
            val loc = SourceLocation.at("test.spl", 10, 5)
            val suggestion = Suggestion.replace(loc, "new_text", "description")
            expect(suggestion.new_text).to_equal("new_text")
            expect(suggestion.message).to_equal("description")
            expect(suggestion.confidence).to_equal(FixConfidence.MachineApplicable)

        it "creates deletion suggestion":
            val loc = SourceLocation.at("test.spl", 10, 5)
            val suggestion = Suggestion.delete(loc, "remove this")
            expect(suggestion.new_text).to_equal("")

        it "creates suggestion with confidence":
            val loc = SourceLocation.at("test.spl", 10, 5)
            val suggestion = Suggestion.with_confidence(
                loc, "maybe", "uncertain fix", FixConfidence.MaybeIncorrect)
            expect(suggestion.confidence).to_equal(FixConfidence.MaybeIncorrect)

describe "FixConfidence":
    """
    ## FixConfidence

    Tests for fix confidence levels.
    """

    context "names":
        """
        ### Confidence Names

        Each confidence level has a name.
        """

        it "MachineApplicable name is safe":
            expect(FixConfidence.MachineApplicable.name()).to_equal("safe")

        it "MaybeIncorrect name is likely":
            expect(FixConfidence.MaybeIncorrect.name()).to_equal("likely")

        it "HasPlaceholders name is placeholder":
            expect(FixConfidence.HasPlaceholders.name()).to_equal("placeholder")

    context "safety checks":
        """
        ### Safety Checks

        Confidence levels have safety check methods.
        """

        it "MachineApplicable is safe to auto apply":
            expect(FixConfidence.MachineApplicable.is_safe_to_auto_apply()).to_be_true()

        it "MaybeIncorrect is not safe to auto apply":
            expect(FixConfidence.MaybeIncorrect.is_safe_to_auto_apply()).to_be_false()

        it "MachineApplicable is likely correct":
            expect(FixConfidence.MachineApplicable.is_likely_correct()).to_be_true()

        it "MaybeIncorrect is likely correct":
            expect(FixConfidence.MaybeIncorrect.is_likely_correct()).to_be_true()

        it "HasPlaceholders is not likely correct":
            expect(FixConfidence.HasPlaceholders.is_likely_correct()).to_be_false()
