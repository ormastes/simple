"""
Panic Isolation Tests
Feature: Panic Catching and Recovery
Category: FailSafe
Status: In Progress
"""

use std.failsafe.core.*
use std.failsafe.panic.*

describe "PanicInfo":
    it "creates basic panic info":
        val info = PanicInfo.new("Something went wrong")
        expect(info.message == "Something went wrong")

    it "adds location":
        val info = PanicInfo.new("Error").with_location("main.spl", 42)
        expect(info.file == "main.spl")
        expect(info.line == 42)

    it "converts to error":
        val info = PanicInfo.new("Panic!")
        val error = info.to_error()
        expect(error.category == ErrorCategory.Panic)
        expect(not error.recoverable)

describe "PanicHandler":
    it "creates handler":
        val handler = PanicHandler.new()
        expect(handler.panic_count == 0)
        expect(handler.enabled)

    it "tracks panic count":
        var handler = PanicHandler.new()
        val info = PanicInfo.new("Test panic")
        handler.on_panic(info)
        expect(handler.panic_count == 1)
        handler.on_panic(info)
        expect(handler.panic_count == 2)

    it "indicates shutdown needed":
        var handler = PanicHandler.new()
        handler.max_panics_before_shutdown = 3
        val info = PanicInfo.new("Panic")
        handler.on_panic(info)
        handler.on_panic(info)
        expect(not handler.should_shutdown())
        handler.on_panic(info)
        expect(handler.should_shutdown())

    it "resets state":
        var handler = PanicHandler.new()
        handler.on_panic(PanicInfo.new("Panic"))
        handler.reset()
        expect(handler.panic_count == 0)

    it "can be disabled":
        var handler = PanicHandler.new()
        handler.disable()
        handler.on_panic(PanicInfo.new("Ignored"))
        expect(handler.panic_count == 0)

describe "safe_div":
    it "performs safe division":
        match safe_div(10, 2):
            case FailSafeResult.Ok(v):
                expect(v == 5)
            case FailSafeResult.Err(_):
                expect(false)

    it "handles division by zero":
        match safe_div(10, 0):
            case FailSafeResult.Ok(_):
                expect(false)
            case FailSafeResult.Err(e):
                expect(e.category == ErrorCategory.DivisionByZero)

describe "safe_get":
    it "performs safe array access":
        val arr = [10, 20, 30]
        match safe_get(arr, 1):
            case FailSafeResult.Ok(v):
                expect(v == 20)
            case FailSafeResult.Err(_):
                expect(false)

    it "handles index out of bounds":
        val arr = [10, 20, 30]
        match safe_get(arr, 5):
            case FailSafeResult.Ok(_):
                expect(false)
            case FailSafeResult.Err(e):
                expect(e.category == ErrorCategory.Overflow)

describe "soft_assert":
    it "passes on true condition":
        expect(soft_assert(true, "Should pass").is_ok())

    it "fails on false condition":
        match soft_assert(false, "Should fail"):
            case FailSafeResult.Err(e):
                expect(e.category == ErrorCategory.Validation)
            case _:
                expect(false)

describe "assert_some":
    it "passes on Some value":
        val opt: Option<i64> = Some(42)
        match assert_some(opt, "Should have value"):
            case FailSafeResult.Ok(v):
                expect(v == 42)
            case FailSafeResult.Err(_):
                expect(false)

    it "fails on None":
        val opt: Option<i64> = nil
        expect(assert_some(opt, "Missing").is_err())

describe "with_fallback":
    it "returns primary on success":
        val result = with_fallback(
            \: FailSafeResult.Ok(42),
            \: FailSafeResult.Ok(99)
        )
        match result:
            case FailSafeResult.Ok(v):
                expect(v == 42)
            case _:
                expect(false)

    it "returns fallback on error":
        val result = with_fallback(
            \: FailSafeResult.Err(FailSafeError.new(ErrorCategory.Network, "Failed")),
            \: FailSafeResult.Ok(99)
        )
        match result:
            case FailSafeResult.Ok(v):
                expect(v == 99)
            case _:
                expect(false)

describe "with_default":
    it "returns value on success":
        val result = with_default(\: FailSafeResult.Ok(42), 99)
        expect(result == 42)

    it "returns default on error":
        val result = with_default(
            \: FailSafeResult.Err(FailSafeError.new(ErrorCategory.Network, "Failed")),
            99
        )
        expect(result == 99)
