# Memory Tracker API Spec
#
# Tests the mem_tracker module's pure logic using mock implementations.
# The C runtime memtrack functions (spl_memtrack_*) are not available in
# the interpreter binary, so we mock them here.

# ============================================================================
# Mock memtrack state (replaces C runtime spl_memtrack_*)
# ============================================================================

var mock_enabled = false
var mock_snapshot_counter = 0
var mock_alloc_count = 0
var mock_alloc_bytes = 0

fn mock_enable():
    mock_enabled = true

fn mock_disable():
    mock_enabled = false

fn mock_is_enabled() -> bool:
    mock_enabled

fn mock_snapshot() -> i64:
    mock_snapshot_counter = mock_snapshot_counter + 1
    mock_snapshot_counter

fn mock_live_count() -> i64:
    mock_alloc_count

fn mock_live_bytes() -> i64:
    mock_alloc_bytes

fn mock_reset():
    mock_enabled = false
    mock_snapshot_counter = 0
    mock_alloc_count = 0
    mock_alloc_bytes = 0

fn mock_simulate_alloc(size: i64):
    mock_alloc_count = mock_alloc_count + 1
    mock_alloc_bytes = mock_alloc_bytes + size

# ============================================================================
# Mock MemSnapshot struct (mirrors types.spl)
# ============================================================================

struct MemSnapshot:
    id: i64
    live_count: i64
    live_bytes: i64

struct MemLeakEntry:
    alloc_id: i64
    size: i64
    tag: text

fn mock_capture_snapshot() -> MemSnapshot:
    MemSnapshot(
        id: mock_snapshot(),
        live_count: mock_live_count(),
        live_bytes: mock_live_bytes()
    )

# ============================================================================
# parse_leak_dump â€” pure function, no FFI needed
# ============================================================================

fn parse_leak_dump_text(content: text) -> [MemLeakEntry]:
    var entries: [MemLeakEntry] = []
    if content == "":
        return entries
    val lines = content.split("\n")
    for line in lines:
        val trimmed = line.trim()
        if trimmed != "":
            val parts = trimmed.split(" ")
            if parts.len() >= 3:
                val alloc_id = to_int(parts[0])
                val size = to_int(parts[1])
                val tag = parts[2]
                entries = entries + [MemLeakEntry(alloc_id: alloc_id, size: size, tag: tag)]
    entries

# ============================================================================
# Tests
# ============================================================================

describe "MemTracker":
    it "can enable and disable tracking":
        mock_reset()
        mock_enable()
        expect(mock_is_enabled()).to_equal(true)
        mock_disable()
        expect(mock_is_enabled()).to_equal(false)

    it "snapshot returns monotonic IDs":
        mock_reset()
        mock_enable()
        val snap1 = mock_snapshot()
        val snap2 = mock_snapshot()
        expect(snap2 > snap1).to_equal(true)
        mock_disable()

    it "live_count tracks allocations when enabled":
        mock_reset()
        mock_enable()
        val before = mock_live_count()
        mock_simulate_alloc(64)
        val after = mock_live_count()
        expect(after > before).to_equal(true)
        mock_disable()

    it "capture_snapshot returns structured data":
        mock_reset()
        mock_enable()
        mock_simulate_alloc(128)
        val snap = mock_capture_snapshot()
        expect(snap.id > 0).to_equal(true)
        expect(snap.live_count).to_equal(1)
        expect(snap.live_bytes).to_equal(128)
        mock_disable()

    it "dump and parse round-trip works":
        # Test the parse function with known input
        val dump_content = "100 64 str\n200 128 arr\n"
        val entries = parse_leak_dump_text(dump_content)
        expect(entries.len()).to_equal(2)
        expect(entries[0].alloc_id).to_equal(100)
        expect(entries[0].size).to_equal(64)
        expect(entries[0].tag).to_equal("str")

    it "parse_leak_dump handles empty input":
        val entries = parse_leak_dump_text("")
        expect(entries.len()).to_equal(0)

    it "parse_leak_dump parses formatted entries":
        val content = "100 64 str\n200 128 arr\n300 256 dict\n"
        val entries = parse_leak_dump_text(content)
        expect(entries.len()).to_equal(3)
        expect(entries[0].alloc_id).to_equal(100)
        expect(entries[0].size).to_equal(64)
        expect(entries[0].tag).to_equal("str")
        expect(entries[1].alloc_id).to_equal(200)
        expect(entries[1].size).to_equal(128)
        expect(entries[1].tag).to_equal("arr")
        expect(entries[2].alloc_id).to_equal(300)
        expect(entries[2].size).to_equal(256)
        expect(entries[2].tag).to_equal("dict")
