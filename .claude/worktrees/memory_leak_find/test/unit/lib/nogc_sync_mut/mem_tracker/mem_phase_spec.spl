# Memory Tracker â€” Phase Snapshot & Report Spec
#
# Tests phase-based snapshot API and report building.
# Uses mock implementations since spl_memtrack_* C functions
# are not available in the interpreter binary.

# ============================================================================
# Type definitions (mirrors types.spl)
# ============================================================================

struct MemSnapshot:
    id: i64
    live_count: i64
    live_bytes: i64

struct MemLeakEntry:
    alloc_id: i64
    size: i64
    tag: text

struct MemDiff:
    before_id: i64
    before_count: i64
    before_bytes: i64
    after_id: i64
    after_count: i64
    after_bytes: i64
    added_count: i64
    added_bytes: i64
    leaked_entries: [MemLeakEntry]

struct MemPhaseSnapshot:
    name: text
    snapshot: MemSnapshot

struct MemTagGroup:
    tag: text
    count: i64
    total_bytes: i64

struct MemLeakReport:
    phases: [MemPhaseSnapshot]
    diffs: [MemDiff]
    tag_groups: [MemTagGroup]
    total_leaked_count: i64
    total_leaked_bytes: i64

# ============================================================================
# Mock memtrack state
# ============================================================================

var mock_snapshot_counter = 0
var mock_alloc_count = 0
var mock_alloc_bytes = 0

fn mock_reset():
    mock_snapshot_counter = 0
    mock_alloc_count = 0
    mock_alloc_bytes = 0

fn mock_snapshot() -> i64:
    mock_snapshot_counter = mock_snapshot_counter + 1
    mock_snapshot_counter

fn mock_capture_snapshot() -> MemSnapshot:
    MemSnapshot(
        id: mock_snapshot(),
        live_count: mock_alloc_count,
        live_bytes: mock_alloc_bytes
    )

fn mock_simulate_alloc(size: i64):
    mock_alloc_count = mock_alloc_count + 1
    mock_alloc_bytes = mock_alloc_bytes + size

# ============================================================================
# Pure functions under test (from mod.spl)
# ============================================================================

fn mem_phase(name: text) -> MemPhaseSnapshot:
    MemPhaseSnapshot(
        name: name,
        snapshot: mock_capture_snapshot()
    )

fn mem_diff_quick(before: MemSnapshot, after: MemSnapshot) -> MemDiff:
    val added_count = after.live_count - before.live_count
    val added_bytes = after.live_bytes - before.live_bytes
    var empty_entries: [MemLeakEntry] = []
    MemDiff(
        before_id: before.id,
        before_count: before.live_count,
        before_bytes: before.live_bytes,
        after_id: after.id,
        after_count: after.live_count,
        after_bytes: after.live_bytes,
        added_count: added_count,
        added_bytes: added_bytes,
        leaked_entries: empty_entries
    )

fn mem_group_by_tag(entries: [MemLeakEntry]) -> [MemTagGroup]:
    var tags: [text] = []
    var counts: [i64] = []
    var bytes_arr: [i64] = []
    for entry in entries:
        val idx = tags.index_of(entry.tag)
        if idx >= 0:
            fn set_i64(arr: [i64], at: i64, val_: i64) -> [i64]:
                var result: [i64] = []
                var i = 0
                while i < arr.len():
                    if i == at:
                        result = result + [val_]
                    else:
                        result = result + [arr[i]]
                    i = i + 1
                result
            counts = set_i64(counts, idx, counts[idx] + 1)
            bytes_arr = set_i64(bytes_arr, idx, bytes_arr[idx] + entry.size)
        else:
            tags = tags + [entry.tag]
            counts = counts + [1]
            bytes_arr = bytes_arr + [entry.size]
    var groups: [MemTagGroup] = []
    var gi = 0
    while gi < tags.len():
        groups = groups + [MemTagGroup(tag: tags[gi], count: counts[gi], total_bytes: bytes_arr[gi])]
        gi = gi + 1
    groups

fn mem_build_report(phases: [MemPhaseSnapshot], diffs: [MemDiff]) -> MemLeakReport:
    var total_count: i64 = 0
    var total_bytes: i64 = 0
    var all_entries: [MemLeakEntry] = []
    for diff in diffs:
        total_count = total_count + diff.added_count
        total_bytes = total_bytes + diff.added_bytes
        for entry in diff.leaked_entries:
            all_entries = all_entries + [entry]
    val tag_groups = mem_group_by_tag(all_entries)
    MemLeakReport(
        phases: phases,
        diffs: diffs,
        tag_groups: tag_groups,
        total_leaked_count: total_count,
        total_leaked_bytes: total_bytes
    )

fn mem_print_report(report: MemLeakReport):
    print ""
    print "=== Memory Leak Report ==="
    print ""
    print "Phases:"
    for phase in report.phases:
        print "  {phase.name}: snap#{phase.snapshot.id} ({phase.snapshot.live_count} allocs, {phase.snapshot.live_bytes} bytes)"
    print ""
    var di = 0
    while di < report.diffs.len():
        val diff = report.diffs[di]
        if diff.added_count > 0:
            print "Diff (snap#{diff.before_id} -> snap#{diff.after_id}):"
            print "  Added: {diff.added_count} allocations, {diff.added_bytes} bytes"
        di = di + 1
    if report.tag_groups.len() > 0:
        print ""
        print "By tag:"
        for tg in report.tag_groups:
            print "  [{tg.tag}] {tg.count} allocs, {tg.total_bytes} bytes"
    print ""
    if report.total_leaked_count > 0:
        print "TOTAL LEAKED: {report.total_leaked_count} allocations, {report.total_leaked_bytes} bytes"
    else:
        print "No memory leaks detected."
    print "==========================="

# ============================================================================
# Tests: Phase snapshots
# ============================================================================

describe "mem_phase":

    it "creates a named phase snapshot":
        mock_reset()
        val phase = mem_phase("test-phase")
        expect(phase.name).to_equal("test-phase")
        expect(phase.snapshot.id > 0).to_equal(true)
        expect(phase.snapshot.live_count >= 0).to_equal(true)
        expect(phase.snapshot.live_bytes >= 0).to_equal(true)

    it "different phases have increasing snapshot IDs":
        mock_reset()
        val p1 = mem_phase("phase-1")
        mock_simulate_alloc(64)
        val p2 = mem_phase("phase-2")
        expect(p2.snapshot.id > p1.snapshot.id).to_equal(true)

    it "captures distinct names":
        mock_reset()
        val before = mem_phase("before-load")
        val after = mem_phase("after-unload")
        expect(before.name).to_equal("before-load")
        expect(after.name).to_equal("after-unload")

# ============================================================================
# Tests: Full lifecycle simulation
# ============================================================================

describe "Test runner 4-phase lifecycle":

    it "captures all four phases":
        mock_reset()
        val p0 = mem_phase("before-load")
        mock_simulate_alloc(1024)
        mock_simulate_alloc(2048)
        val p1 = mem_phase("after-load")
        mock_simulate_alloc(256)
        val p2 = mem_phase("after-tests")
        val p3 = mem_phase("after-unload")
        expect(p0.name).to_equal("before-load")
        expect(p1.name).to_equal("after-load")
        expect(p2.name).to_equal("after-tests")
        expect(p3.name).to_equal("after-unload")
        expect(p1.snapshot.id > p0.snapshot.id).to_equal(true)
        expect(p2.snapshot.id > p1.snapshot.id).to_equal(true)
        expect(p3.snapshot.id > p2.snapshot.id).to_equal(true)

    it "quick diffs between phases are consistent":
        mock_reset()
        val p0 = mem_phase("before-load")
        mock_simulate_alloc(100)
        val p1 = mem_phase("after-load")
        mock_simulate_alloc(200)
        val p2 = mem_phase("after-tests")
        val p3 = mem_phase("after-unload")
        val load_diff = mem_diff_quick(p0.snapshot, p1.snapshot)
        val test_diff = mem_diff_quick(p1.snapshot, p2.snapshot)
        val unload_diff = mem_diff_quick(p2.snapshot, p3.snapshot)
        expect(load_diff.added_count >= 0).to_equal(true)
        expect(test_diff.added_count >= 0).to_equal(true)
        expect(unload_diff.added_count >= 0).to_equal(true)

# ============================================================================
# Tests: Report building
# ============================================================================

describe "mem_build_report":

    it "builds report with no diffs":
        var phases: [MemPhaseSnapshot] = []
        var diffs: [MemDiff] = []
        val report = mem_build_report(phases, diffs)
        expect(report.total_leaked_count).to_equal(0)
        expect(report.total_leaked_bytes).to_equal(0)
        expect(report.phases.len()).to_equal(0)
        expect(report.diffs.len()).to_equal(0)
        expect(report.tag_groups.len()).to_equal(0)

    it "builds report with phases and empty diffs":
        mock_reset()
        val p0 = mem_phase("start")
        val p1 = mem_phase("end")
        var phases: [MemPhaseSnapshot] = []
        phases = phases + [p0]
        phases = phases + [p1]
        var diffs: [MemDiff] = []
        val diff = mem_diff_quick(p0.snapshot, p1.snapshot)
        diffs = diffs + [diff]
        val report = mem_build_report(phases, diffs)
        expect(report.phases.len()).to_equal(2)
        expect(report.diffs.len()).to_equal(1)

    it "aggregates leaked entries into tag groups":
        var leaked: [MemLeakEntry] = []
        leaked = leaked + [MemLeakEntry(alloc_id: 1, size: 64, tag: "str")]
        leaked = leaked + [MemLeakEntry(alloc_id: 2, size: 128, tag: "arr")]
        leaked = leaked + [MemLeakEntry(alloc_id: 3, size: 32, tag: "str")]
        val diff = MemDiff(
            before_id: 0, before_count: 0, before_bytes: 0,
            after_id: 3, after_count: 3, after_bytes: 224,
            added_count: 3, added_bytes: 224,
            leaked_entries: leaked
        )
        var phases: [MemPhaseSnapshot] = []
        var diffs: [MemDiff] = []
        diffs = diffs + [diff]
        val report = mem_build_report(phases, diffs)
        expect(report.total_leaked_count).to_equal(3)
        expect(report.total_leaked_bytes).to_equal(224)
        expect(report.tag_groups.len()).to_equal(2)

    it "sums across multiple diffs":
        var leaked1: [MemLeakEntry] = []
        leaked1 = leaked1 + [MemLeakEntry(alloc_id: 1, size: 100, tag: "str")]
        val diff1 = MemDiff(
            before_id: 0, before_count: 0, before_bytes: 0,
            after_id: 1, after_count: 1, after_bytes: 100,
            added_count: 1, added_bytes: 100,
            leaked_entries: leaked1
        )
        var leaked2: [MemLeakEntry] = []
        leaked2 = leaked2 + [MemLeakEntry(alloc_id: 2, size: 200, tag: "arr")]
        val diff2 = MemDiff(
            before_id: 1, before_count: 1, before_bytes: 100,
            after_id: 2, after_count: 2, after_bytes: 300,
            added_count: 1, added_bytes: 200,
            leaked_entries: leaked2
        )
        var phases: [MemPhaseSnapshot] = []
        var diffs: [MemDiff] = []
        diffs = diffs + [diff1]
        diffs = diffs + [diff2]
        val report = mem_build_report(phases, diffs)
        expect(report.total_leaked_count).to_equal(2)
        expect(report.total_leaked_bytes).to_equal(300)
        expect(report.tag_groups.len()).to_equal(2)

# ============================================================================
# Tests: Report printing (smoke test)
# ============================================================================

describe "mem_print_report":

    it "prints empty report without crash":
        var phases: [MemPhaseSnapshot] = []
        var diffs: [MemDiff] = []
        val report = mem_build_report(phases, diffs)
        mem_print_report(report)
        expect(report.total_leaked_count).to_equal(0)

    it "prints report with data without crash":
        var leaked: [MemLeakEntry] = []
        leaked = leaked + [MemLeakEntry(alloc_id: 10, size: 512, tag: "buf")]
        val diff = MemDiff(
            before_id: 0, before_count: 0, before_bytes: 0,
            after_id: 10, after_count: 1, after_bytes: 512,
            added_count: 1, added_bytes: 512,
            leaked_entries: leaked
        )
        val snap = MemSnapshot(id: 0, live_count: 0, live_bytes: 0)
        val phase = MemPhaseSnapshot(name: "test", snapshot: snap)
        var phases: [MemPhaseSnapshot] = []
        phases = phases + [phase]
        var diffs: [MemDiff] = []
        diffs = diffs + [diff]
        val report = mem_build_report(phases, diffs)
        mem_print_report(report)
        expect(report.total_leaked_count).to_equal(1)

# ============================================================================
# Tests: Edge cases
# ============================================================================

describe "Edge cases":

    it "enable/disable is idempotent":
        mock_reset()
        mock_reset()
        expect(true).to_equal(true)

    it "snapshot works when tracking is disabled":
        mock_reset()
        val snap = mock_capture_snapshot()
        expect(snap.id > 0).to_equal(true)

    it "diff_quick with same snapshot returns zero added":
        mock_reset()
        val snap = mock_capture_snapshot()
        val diff = mem_diff_quick(snap, snap)
        expect(diff.before_id).to_equal(diff.after_id)
        expect(diff.added_count).to_equal(0)
        expect(diff.added_bytes).to_equal(0)
