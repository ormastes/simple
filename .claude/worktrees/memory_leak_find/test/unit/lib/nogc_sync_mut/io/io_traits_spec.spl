"""
# I/O Traits Specification

**Feature IDs:** #IO-TRAITS
**Category:** Stdlib
**Difficulty:** 3/5
**Status:** Implemented

## Overview

Fine-grained I/O traits (Read, Write, Seek, Close) form the core
abstraction for all synchronous I/O. Async mirrors (AsyncRead, AsyncWrite,
AsyncSeek, AsyncClose) wrap return types in Future.

## Syntax

```simple
class MyReader with Read:
    fn read(size: i64) -> Result<[u8], IoError>:
        Ok([])
    # ... other Read methods
```

## Key Concepts

| Concept | Description |
|---------|-------------|
| Read | Byte/text input: read, read_exact, read_all, read_text, read_line |
| Write | Byte/text output: write, write_all, write_text, flush |
| Seek | Random access: seek, position, rewind |
| Close | Resource cleanup: close (me), is_open |
| Mirror traits | AsyncRead/Write/Seek/Close — same names, Future returns |

## Behavior

- Traits are independent — implementors mix in only what they support
- `me` keyword on close() marks it as mutating (transitions state)
- BufferedReader/Writer accept any Read/Write implementor (composition)
"""

use std.spec

# ============================================================================
# Mock Implementations for Testing Trait Composition
# ============================================================================

class MockReader with Read, Close:
    """Mock reader for testing Read and Close traits."""
    data: [u8]
    pos: i64
    open: bool

    static fn from_bytes(data: [u8]) -> MockReader:
        MockReader(data: data, pos: 0, open: true)

    fn read(size: i64) -> Result<[u8], IoError>:
        if not self.open:
            return Err(IoError.new(IoErrorKind.Other, "closed"))
        val end = if self.pos + size > self.data.len(): self.data.len() else: self.pos + size
        val chunk = self.data.slice(self.pos, end)
        self.pos = end
        Ok(chunk)

    fn read_exact(size: i64) -> Result<[u8], IoError>:
        val result = self.read(size)?
        if result.len() != size:
            return Err(IoError.new(IoErrorKind.UnexpectedEof, "short read"))
        Ok(result)

    fn read_all() -> Result<[u8], IoError>:
        self.read(self.data.len() - self.pos)

    fn read_text() -> Result<text, IoError>:
        val bytes = self.read_all()?
        Ok(rt_bytes_to_text(bytes))

    fn read_line() -> Result<text, IoError>:
        self.read_text()

    me close() -> Result<(), IoError>:
        self.open = false
        Ok(())

    fn is_open() -> bool:
        self.open

class MockWriter with Write, Close:
    """Mock writer for testing Write and Close traits."""
    buffer: [u8]
    flushed: bool
    open: bool

    static fn new() -> MockWriter:
        MockWriter(buffer: [], flushed: false, open: true)

    fn write(data: [u8]) -> Result<i64, IoError>:
        if not self.open:
            return Err(IoError.new(IoErrorKind.Other, "closed"))
        self.buffer = self.buffer + data
        Ok(data.len())

    fn write_all(data: [u8]) -> Result<(), IoError>:
        self.write(data)?
        Ok(())

    fn write_text(s: text) -> Result<(), IoError>:
        val bytes = rt_text_to_bytes(s)
        self.write_all(bytes)

    fn flush() -> Result<(), IoError>:
        self.flushed = true
        Ok(())

    me close() -> Result<(), IoError>:
        self.open = false
        Ok(())

    fn is_open() -> bool:
        self.open

# ============================================================================
# Read Trait Tests
# ============================================================================

describe "Read Trait":
    """
    ## Byte-Level Input

    The Read trait provides methods for reading bytes and text
    from any source. Implementors define how bytes are produced.
    """

    context "reading bytes":
        """
        ### Basic Byte Reading

        read(size) returns up to `size` bytes.
        """

        it "reads requested number of bytes":
            val reader = MockReader.from_bytes([72, 101, 108, 108, 111])
            val result = reader.read(3)
            match result:
                case Ok(data):
                    expect(data.len()).to_equal(3)
                    expect(data[0]).to_equal(72)
                case Err(_): pass

        it "reads remaining bytes when fewer available":
            val reader = MockReader.from_bytes([65, 66])
            val result = reader.read(10)
            match result:
                case Ok(data):
                    expect(data.len()).to_equal(2)
                case Err(_): pass

    context "read_exact":
        """
        ### Exact Byte Reading

        read_exact(size) returns exactly `size` bytes or UnexpectedEof.
        """

        it "reads exact count when available":
            val reader = MockReader.from_bytes([1, 2, 3, 4, 5])
            val result = reader.read_exact(5)
            match result:
                case Ok(data):
                    expect(data.len()).to_equal(5)
                case Err(_): pass

        it "returns error when insufficient bytes":
            val reader = MockReader.from_bytes([1, 2])
            val result = reader.read_exact(5)
            match result:
                case Ok(_): pass
                case Err(e):
                    expect(e.kind).to_equal(IoErrorKind.UnexpectedEof)

    context "read_all and read_text":
        """
        ### Reading All Content

        read_all() reads all remaining bytes.
        read_text() reads all remaining content as text.
        """

        it "reads all remaining bytes":
            val reader = MockReader.from_bytes([72, 101, 108, 108, 111])
            val result = reader.read_all()
            match result:
                case Ok(data):
                    expect(data.len()).to_equal(5)
                case Err(_): pass

# ============================================================================
# Write Trait Tests
# ============================================================================

describe "Write Trait":
    """
    ## Byte-Level Output

    The Write trait provides methods for writing bytes and text
    to any destination, with explicit flush support.
    """

    context "writing bytes":
        it "writes bytes and returns count":
            val writer = MockWriter.new()
            val result = writer.write([72, 105])
            match result:
                case Ok(n):
                    expect(n).to_equal(2)
                case Err(_): pass

        it "accumulates writes":
            val writer = MockWriter.new()
            writer.write_all([72, 101])?
            writer.write_all([108, 108, 111])?
            expect(writer.buffer.len()).to_equal(5)

    context "flush":
        it "marks writer as flushed":
            val writer = MockWriter.new()
            expect(writer.flushed).to_equal(false)
            writer.flush()?
            expect(writer.flushed).to_equal(true)

    context "writing text":
        it "writes text content":
            val writer = MockWriter.new()
            writer.write_text("hello")?
            expect(writer.buffer.len()).to_be_greater_than(0)

# ============================================================================
# Close Trait Tests
# ============================================================================

describe "Close Trait":
    """
    ## Resource Cleanup

    The Close trait transitions a resource from open to closed state.
    Uses `me` keyword since close() mutates the object.
    """

    context "closing a reader":
        it "transitions from open to closed":
            val reader = MockReader.from_bytes([1, 2, 3])
            expect(reader.is_open()).to_equal(true)
            reader.close()?
            expect(reader.is_open()).to_equal(false)

        it "returns error when reading after close":
            val reader = MockReader.from_bytes([1, 2, 3])
            reader.close()?
            val result = reader.read(1)
            match result:
                case Ok(_): pass
                case Err(e):
                    expect(e.message).to_contain("closed")

    context "closing a writer":
        it "transitions from open to closed":
            val writer = MockWriter.new()
            expect(writer.is_open()).to_equal(true)
            writer.close()?
            expect(writer.is_open()).to_equal(false)

# ============================================================================
# Trait Composition Tests
# ============================================================================

describe "Trait Composition":
    """
    ## Mixing Multiple Traits

    Types can implement multiple I/O traits simultaneously.
    This enables generic I/O code that works with any implementor.
    """

    context "Read + Close composition":
        it "reader implements both Read and Close":
            val reader = MockReader.from_bytes([72, 101, 108])
            val data = reader.read(3)?
            expect(reader.is_open()).to_equal(true)
            reader.close()?
            expect(reader.is_open()).to_equal(false)

    context "Write + Close composition":
        it "writer implements both Write and Close":
            val writer = MockWriter.new()
            writer.write_text("test")?
            writer.flush()?
            writer.close()?
            expect(writer.is_open()).to_equal(false)

# ============================================================================
# FFI Helpers (for mocks)
# ============================================================================

extern fn rt_bytes_to_text(data: [u8]) -> text
extern fn rt_text_to_bytes(s: text) -> [u8]
