use std.maybe_uninit.{MaybeUninit, new_uninit, mu_write, mu_assume_init, mu_is_initialized}

describe "MaybeUninit":
    describe "new_uninit":
        it "creates uninitialized slot":
            val mu = new_uninit()
            expect(mu_is_initialized(mu)).to_equal(false)

        it "assume_init on uninitialized returns nil":
            val mu = new_uninit()
            val result = mu_assume_init(mu)
            expect(result == nil).to_equal(true)

    describe "mu_write":
        it "write creates initialized slot":
            val mu = new_uninit()
            val mu2 = mu_write(mu, 42)
            expect(mu_is_initialized(mu2)).to_equal(true)

        it "original slot remains uninitialized after write":
            val mu = new_uninit()
            val mu2 = mu_write(mu, 42)
            expect(mu_is_initialized(mu)).to_equal(false)

        it "written value is retrievable":
            val mu = new_uninit()
            val mu2 = mu_write(mu, 99)
            val result = mu_assume_init(mu2)
            expect(result).to_equal(99)

    describe "mu_assume_init":
        it "returns written i64 value":
            val mu = mu_write(new_uninit(), 100)
            expect(mu_assume_init(mu)).to_equal(100)

        it "returns written text value":
            val mu = mu_write(new_uninit(), "hello")
            expect(mu_assume_init(mu)).to_equal("hello")

        it "returns written bool value":
            val mu = mu_write(new_uninit(), true)
            expect(mu_assume_init(mu)).to_equal(true)

    describe "chained operations":
        it "write then read roundtrip":
            val mu0 = new_uninit()
            val mu1 = mu_write(mu0, 777)
            val got = mu_assume_init(mu1)
            expect(got).to_equal(777)

        it "multiple writes keep last value":
            val mu0 = new_uninit()
            val mu1 = mu_write(mu0, 1)
            val mu2 = mu_write(mu1, 2)
            val mu3 = mu_write(mu2, 3)
            expect(mu_assume_init(mu3)).to_equal(3)
