# Semihost Transport Unit Tests
#
# Tests transport constants, config struct defaults, and capability
# flag disjointness. Interpreter-mode tests (no QEMU needed).

describe "Transport Constants":
    it "WRITEC is 1":
        val TRANSPORT_WRITEC = 1
        expect(TRANSPORT_WRITEC).to_equal(1)

    it "WRITE0 is 2":
        val TRANSPORT_WRITE0 = 2
        expect(TRANSPORT_WRITE0).to_equal(2)

    it "WRITE is 3":
        val TRANSPORT_WRITE = 3
        expect(TRANSPORT_WRITE).to_equal(3)

    it "BATCH_N is 4":
        val TRANSPORT_BATCH_N = 4
        expect(TRANSPORT_BATCH_N).to_equal(4)

    it "BUFFERED is 5":
        val TRANSPORT_BUFFERED = 5
        expect(TRANSPORT_BUFFERED).to_equal(5)

    it "UART is 6":
        val TRANSPORT_UART = 6
        expect(TRANSPORT_UART).to_equal(6)

    it "RAW_BINARY is 7":
        val TRANSPORT_RAW_BINARY = 7
        expect(TRANSPORT_RAW_BINARY).to_equal(7)

    it "INTERNED is 8":
        val TRANSPORT_INTERNED = 8
        expect(TRANSPORT_INTERNED).to_equal(8)

    it "all transport constants are unique":
        val values = [1, 2, 3, 4, 5, 6, 7, 8]
        expect(values.len()).to_equal(8)

describe "Capability Flags":
    it "CAP_WRITEC is 1":
        val CAP_WRITEC = 1
        expect(CAP_WRITEC).to_equal(1)

    it "CAP_WRITE0 is 2":
        val CAP_WRITE0 = 2
        expect(CAP_WRITE0).to_equal(2)

    it "CAP_WRITE is 4":
        val CAP_WRITE = 4
        expect(CAP_WRITE).to_equal(4)

    it "CAP_UART is 8":
        val CAP_UART = 8
        expect(CAP_UART).to_equal(8)

    it "CAP_INTERNED is 16":
        val CAP_INTERNED = 16
        expect(CAP_INTERNED).to_equal(16)

    it "capability flags are disjoint powers of 2":
        val caps = [1, 2, 4, 8, 16]
        # Each pair OR'd must differ from each individual
        var i = 0
        var all_disjoint = true
        while i < 5:
            var j = i + 1
            while j < 5:
                val combined = caps[i] | caps[j]
                if combined == caps[i]:
                    all_disjoint = false
                if combined == caps[j]:
                    all_disjoint = false
                j = j + 1
            i = i + 1
        expect(all_disjoint).to_equal(true)

    it "full capability mask combines all flags":
        val all_caps = 1 | 2 | 4 | 8 | 16
        expect(all_caps).to_equal(31)

describe "Config Defaults":
    it "default batch_size is 3":
        val default_batch = 3
        expect(default_batch).to_equal(3)

    it "default UART base is 0x10000000":
        val default_uart = 0x10000000
        expect(default_uart).to_equal(268435456)

    it "RAW_BINARY_MAGIC is 0x53 (ASCII S)":
        val magic = 0x53
        expect(magic).to_equal(83)

describe "Ring Buffer Power-of-2":
    it "next_power_of_2 for 1 is 1":
        var v = 0
        v = v | (v >> 1)
        v = v | (v >> 2)
        v = v | (v >> 4)
        v = v | (v >> 8)
        v = v | (v >> 16)
        # n=1 => v = 1-1 = 0, result = 0+1 = 1
        expect(v + 1).to_equal(1)

    it "next_power_of_2 for 5 is 8":
        var v = 5 - 1  # 4
        v = v | (v >> 1)   # 4|2 = 6
        v = v | (v >> 2)   # 6|1 = 7
        v = v | (v >> 4)   # 7|0 = 7
        v = v | (v >> 8)   # 7
        v = v | (v >> 16)  # 7
        expect(v + 1).to_equal(8)

    it "next_power_of_2 for 16 is 16":
        var v = 16 - 1  # 15
        v = v | (v >> 1)   # 15
        v = v | (v >> 2)   # 15
        v = v | (v >> 4)   # 15
        v = v | (v >> 8)   # 15
        v = v | (v >> 16)  # 15
        expect(v + 1).to_equal(16)

    it "bitmask wrapping works for capacity 4":
        val mask = 3  # capacity 4 - 1
        var idx = 0
        idx = (idx + 1) & mask
        expect(idx).to_equal(1)
        idx = (idx + 1) & mask
        expect(idx).to_equal(2)
        idx = (idx + 1) & mask
        expect(idx).to_equal(3)
        idx = (idx + 1) & mask
        expect(idx).to_equal(0)  # wraps around
