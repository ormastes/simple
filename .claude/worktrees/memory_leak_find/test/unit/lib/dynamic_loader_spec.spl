# DynLoader / DynLib SFFI Tests
#
# Tests for src/lib/ffi/dynamic.spl — convention-based dynamic library loading.
#
# NOTE: These tests require compiled mode. In interpreter mode spl_dlopen is not
# whitelisted, so the file will load but the it-block bodies won't execute.
#
# Run in compiled mode:
#   bin/simple build && bin/simple test test/unit/lib/dynamic_loader_spec.spl

use std.ffi.dynamic.{DynLib, DynLoader, sffi_lib_path, sffi_call}

describe "DynLoader":

    # =========================================================================
    # sffi_lib_path — convention helper
    # =========================================================================

    describe "sffi_lib_path":
        """
        ## sffi_lib_path convention tests

        Verifies that sffi_lib_path produces paths that follow the
        libspl_{prefix}.so naming convention. The default base directory
        is "build" when SIMPLE_SFFI_PATH is not set.
        """

        it "maps torch prefix to libspl_torch.so":
            val path = sffi_lib_path("torch")
            expect(path).to_contain("libspl_torch")

        it "uses build/ as default base":
            val path = sffi_lib_path("test")
            expect(path).to_start_with("build/")

        it "includes .so suffix":
            val path = sffi_lib_path("audio")
            expect(path).to_end_with(".so")

    # =========================================================================
    # DynLib — single library handle
    # =========================================================================

    describe "DynLib":
        """
        ## DynLib load and symbol lookup tests

        DynLib.load returns an Option<DynLib>. A missing library returns nil;
        a present library returns a valid handle. Symbol lookup returns 0 for
        unknown symbols.
        """

        skip_it "returns nil for nonexistent library":
            val result = DynLib.load("/nonexistent/libfake_12345.so")
            expect(result.?).to_equal(false)

        skip_it "loads libm.so successfully":
            val result = DynLib.load("libm.so.6")
            expect(result.?).to_equal(true)

        skip_it "returns 0 for unknown symbol":
            val result = DynLib.load("libm.so.6")
            if result.?:
                val lib = result.unwrap()
                val fptr = lib.sym("__nonexistent_symbol_xyz__")
                expect(fptr).to_equal(0)

    # =========================================================================
    # DynLoader — singleton registry with caching
    # =========================================================================

    describe "DynLoader":
        """
        ## DynLoader singleton and caching tests

        DynLoader.instance() returns a view of the module-level singleton.
        ensure_loaded returns true if the library can be opened, and caches
        the handle so a second call with the same path succeeds immediately
        without reopening.
        """

        skip_it "loads library and caches it":
            val loader = DynLoader.instance()
            val ok = loader.ensure_loaded("libm.so.6")
            expect(ok).to_equal(true)
            val ok2 = loader.ensure_loaded("libm.so.6")
            expect(ok2).to_equal(true)

        skip_it "returns false for missing library":
            val loader = DynLoader.instance()
            val ok = loader.ensure_loaded("/nonexistent/libfake_99999.so")
            expect(ok).to_equal(false)

    # =========================================================================
    # sffi_call — convention-based dispatch
    # =========================================================================

    describe "sffi_call":
        """
        ## sffi_call graceful failure test

        sffi_call parses the prefix from "rt_{prefix}_{fn}", resolves the
        library path via sffi_lib_path, and dispatches through DynLoader.
        When the library does not exist it must return 0 without crashing.
        """

        skip_it "returns 0 gracefully when library is missing":
            val result = sffi_call("rt_fake_nonexistent_function", [])
            expect(result).to_equal(0)

    # =========================================================================
    # DynLib call variants — dispatch methods
    # =========================================================================

    describe "DynLib call variants":
        """
        ## DynLib call0 and call_n dispatch tests

        Verifies that call0 and call_n are callable without crashing when
        supplied a valid library and symbol. Return value semantics for
        wrong-type calls are undefined (UB), so we only assert no crash
        by checking that the result satisfies a tautology.
        """

        skip_it "call0 runs without error on a real symbol":
            val result = DynLib.load("libm.so.6")
            if result.?:
                val lib = result.unwrap()
                # floor has wrong arity/type for i64 but we only test dispatch
                val r = lib.call0("floor")
                # Tautology — true regardless of return value; proves no crash
                expect(r == r).to_equal(true)

        skip_it "call_n accepts empty args array":
            val result = DynLib.load("libm.so.6")
            if result.?:
                val lib = result.unwrap()
                var empty_args: [i64] = []
                val r = lib.call_n("floor", empty_args)
                expect(r == r).to_equal(true)
