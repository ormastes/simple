# Tests for Pure Simple Pooling Layers

use std.pure.tensor.{PureTensor, tensor_from_data, tensor_zeros}
use std.pure.nn.pooling.{MaxPool2d, AvgPool2d, maxpool2d_create, avgpool2d_create}

describe "Pooling Layers":
    describe "MaxPool2d":
        describe "Layer Creation":
            it "creates maxpool2d layer with specified parameters":
                val pool = MaxPool2d.create(kernel_size: 2, stride: 2, padding: 0)
                expect(pool.kernel_size).to_equal(2)
                expect(pool.stride).to_equal(2)
                expect(pool.padding).to_equal(0)
                expect(pool.training).to_equal(true)

            it "uses kernel_size as default stride when stride is 0":
                val pool = MaxPool2d.create(kernel_size: 3, stride: 0, padding: 0)
                expect(pool.stride).to_equal(3)

            it "creates layer with padding":
                val pool = MaxPool2d.create(kernel_size: 2, stride: 2, padding: 1)
                expect(pool.padding).to_equal(1)

            it "creates layer via factory function":
                val pool = maxpool2d_create(2, 2, 0)
                expect(pool.kernel_size).to_equal(2)
                expect(pool.stride).to_equal(2)

        describe "Forward Pass":
            it "performs 2x2 max pooling with stride 2":
                val pool = MaxPool2d.create(kernel_size: 2, stride: 2, padding: 0)

                # Input: [1, 1, 4, 4] - single batch, single channel, 4x4 spatial
                val input_data = [
                    1.0, 2.0, 3.0, 4.0,
                    5.0, 6.0, 7.0, 8.0,
                    9.0, 10.0, 11.0, 12.0,
                    13.0, 14.0, 15.0, 16.0
                ]
                val input = tensor_from_data(input_data, [1, 1, 4, 4])

                val output = pool.forward(input)

                # Output should be [1, 1, 2, 2]
                expect(output.shape[0]).to_equal(1)
                expect(output.shape[1]).to_equal(1)
                expect(output.shape[2]).to_equal(2)
                expect(output.shape[3]).to_equal(2)

                # Max of each 2x2 block: [6, 8, 14, 16]
                expect(output.data[0]).to_equal(6.0)   # max(1,2,5,6)
                expect(output.data[1]).to_equal(8.0)   # max(3,4,7,8)
                expect(output.data[2]).to_equal(14.0)  # max(9,10,13,14)
                expect(output.data[3]).to_equal(16.0)  # max(11,12,15,16)

            it "performs 2x2 max pooling with stride 1":
                val pool = MaxPool2d.create(kernel_size: 2, stride: 1, padding: 0)

                val input_data = [
                    1.0, 2.0, 3.0,
                    4.0, 5.0, 6.0,
                    7.0, 8.0, 9.0
                ]
                val input = tensor_from_data(input_data, [1, 1, 3, 3])

                val output = pool.forward(input)

                # Output should be [1, 1, 2, 2] (3-2+1 = 2)
                expect(output.shape[2]).to_equal(2)
                expect(output.shape[3]).to_equal(2)

                # Max values: [5, 6, 8, 9]
                expect(output.data[0]).to_equal(5.0)  # max(1,2,4,5)
                expect(output.data[1]).to_equal(6.0)  # max(2,3,5,6)
                expect(output.data[2]).to_equal(8.0)  # max(4,5,7,8)
                expect(output.data[3]).to_equal(9.0)  # max(5,6,8,9)

            it "handles multiple channels":
                val pool = MaxPool2d.create(kernel_size: 2, stride: 2, padding: 0)

                # Input: [1, 2, 2, 2] - 2 channels
                val input_data = [
                    # Channel 0
                    1.0, 2.0,
                    3.0, 4.0,
                    # Channel 1
                    5.0, 6.0,
                    7.0, 8.0
                ]
                val input = tensor_from_data(input_data, [1, 2, 2, 2])

                val output = pool.forward(input)

                # Output should be [1, 2, 1, 1]
                expect(output.shape).to_equal([1, 2, 1, 1])

                # Max per channel
                expect(output.data[0]).to_equal(4.0)  # Channel 0: max(1,2,3,4)
                expect(output.data[1]).to_equal(8.0)  # Channel 1: max(5,6,7,8)

            it "handles batch dimension":
                val pool = MaxPool2d.create(kernel_size: 2, stride: 2, padding: 0)

                # Input: [2, 1, 2, 2] - batch size 2
                val input_data = [
                    # Batch 0
                    1.0, 2.0,
                    3.0, 4.0,
                    # Batch 1
                    5.0, 6.0,
                    7.0, 8.0
                ]
                val input = tensor_from_data(input_data, [2, 1, 2, 2])

                val output = pool.forward(input)

                # Output should be [2, 1, 1, 1]
                expect(output.shape).to_equal([2, 1, 1, 1])

                expect(output.data[0]).to_equal(4.0)  # Batch 0: max(1,2,3,4)
                expect(output.data[1]).to_equal(8.0)  # Batch 1: max(5,6,7,8)

            it "handles 3x3 kernel":
                val pool = MaxPool2d.create(kernel_size: 3, stride: 3, padding: 0)

                val input_data = [
                    1.0, 2.0, 3.0,
                    4.0, 9.0, 6.0,
                    7.0, 8.0, 5.0
                ]
                val input = tensor_from_data(input_data, [1, 1, 3, 3])

                val output = pool.forward(input)

                # Output should be [1, 1, 1, 1]
                expect(output.shape).to_equal([1, 1, 1, 1])

                # Max of entire 3x3 window
                expect(output.data[0]).to_equal(9.0)

            it "handles padding":
                val pool = MaxPool2d.create(kernel_size: 3, stride: 1, padding: 1)

                val input_data = [
                    1.0, 2.0,
                    3.0, 4.0
                ]
                val input = tensor_from_data(input_data, [1, 1, 2, 2])

                val output = pool.forward(input)

                # With padding=1, effective input is 4x4, output is 2x2
                expect(output.shape).to_equal([1, 1, 2, 2])

        describe "Backward Pass":
            it "routes gradients to max positions":
                val pool = MaxPool2d.create(kernel_size: 2, stride: 2, padding: 0)

                # Input: [1, 1, 2, 2]
                val input_data = [1.0, 2.0, 3.0, 4.0]
                val input = tensor_from_data(input_data, [1, 1, 2, 2])

                # Forward to set indices
                val output = pool.forward(input)

                # Gradient: all ones
                val grad_output = tensor_from_data([1.0], [1, 1, 1, 1])

                val grad_input = pool.backward(grad_output)

                # Gradient should only be at position 3 (value 4.0 was max)
                expect(grad_input.shape).to_equal([1, 1, 2, 2])
                expect(grad_input.data[0]).to_equal(0.0)
                expect(grad_input.data[1]).to_equal(0.0)
                expect(grad_input.data[2]).to_equal(0.0)
                expect(grad_input.data[3]).to_equal(1.0)

            it "accumulates gradients from overlapping windows":
                val pool = MaxPool2d.create(kernel_size: 2, stride: 1, padding: 0)

                val input_data = [
                    1.0, 2.0, 3.0,
                    4.0, 9.0, 6.0,
                    7.0, 8.0, 5.0
                ]
                val input = tensor_from_data(input_data, [1, 1, 3, 3])

                val output = pool.forward(input)

                # All output gradients = 1.0
                val grad_output_data = [1.0, 1.0, 1.0, 1.0]
                val grad_output = tensor_from_data(grad_output_data, [1, 1, 2, 2])

                val grad_input = pool.backward(grad_output)

                # Position (1,1) with value 9.0 should receive all gradients
                expect(grad_input.shape).to_equal([1, 1, 3, 3])
                # Center position (index 4) should have accumulated gradient
                expect(grad_input.data[4]).to_be_greater_than(0.0)

        describe "Layer Interface":
            it "has no trainable parameters":
                val pool = MaxPool2d.create(kernel_size: 2, stride: 2, padding: 0)
                val params = pool.parameters()
                expect(params.len()).to_equal(0)

            it "switches between train and eval modes":
                val pool = MaxPool2d.create(kernel_size: 2, stride: 2, padding: 0)
                expect(pool.training).to_equal(true)

                pool.eval()
                expect(pool.training).to_equal(false)

                pool.train()
                expect(pool.training).to_equal(true)

            it "has string representation":
                val pool = MaxPool2d.create(kernel_size: 3, stride: 2, padding: 1)
                val s = pool.to_string()
                expect(s.contains("MaxPool2d")).to_equal(true)
                expect(s.contains("3")).to_equal(true)
                expect(s.contains("2")).to_equal(true)
                expect(s.contains("1")).to_equal(true)

    describe "AvgPool2d":
        describe "Layer Creation":
            it "creates avgpool2d layer with specified parameters":
                val pool = AvgPool2d.create(kernel_size: 2, stride: 2, padding: 0)
                expect(pool.kernel_size).to_equal(2)
                expect(pool.stride).to_equal(2)
                expect(pool.padding).to_equal(0)
                expect(pool.training).to_equal(true)

            it "uses kernel_size as default stride when stride is 0":
                val pool = AvgPool2d.create(kernel_size: 3, stride: 0, padding: 0)
                expect(pool.stride).to_equal(3)

            it "creates layer via factory function":
                val pool = avgpool2d_create(2, 2, 0)
                expect(pool.kernel_size).to_equal(2)
                expect(pool.stride).to_equal(2)

        describe "Forward Pass":
            it "performs 2x2 average pooling with stride 2":
                val pool = AvgPool2d.create(kernel_size: 2, stride: 2, padding: 0)

                # Input: [1, 1, 4, 4]
                val input_data = [
                    1.0, 2.0, 3.0, 4.0,
                    5.0, 6.0, 7.0, 8.0,
                    9.0, 10.0, 11.0, 12.0,
                    13.0, 14.0, 15.0, 16.0
                ]
                val input = tensor_from_data(input_data, [1, 1, 4, 4])

                val output = pool.forward(input)

                # Output should be [1, 1, 2, 2]
                expect(output.shape).to_equal([1, 1, 2, 2])

                # Average of each 2x2 block
                expect(output.data[0]).to_equal(3.5)   # avg(1,2,5,6) = 14/4
                expect(output.data[1]).to_equal(5.5)   # avg(3,4,7,8) = 22/4
                expect(output.data[2]).to_equal(11.5)  # avg(9,10,13,14) = 46/4
                expect(output.data[3]).to_equal(13.5)  # avg(11,12,15,16) = 54/4

            it "performs 2x2 average pooling with stride 1":
                val pool = AvgPool2d.create(kernel_size: 2, stride: 1, padding: 0)

                val input_data = [
                    1.0, 2.0, 3.0,
                    4.0, 5.0, 6.0,
                    7.0, 8.0, 9.0
                ]
                val input = tensor_from_data(input_data, [1, 1, 3, 3])

                val output = pool.forward(input)

                # Output should be [1, 1, 2, 2]
                expect(output.shape).to_equal([1, 1, 2, 2])

                # Average values
                expect(output.data[0]).to_equal(3.0)  # avg(1,2,4,5) = 12/4
                expect(output.data[1]).to_equal(4.0)  # avg(2,3,5,6) = 16/4
                expect(output.data[2]).to_equal(6.0)  # avg(4,5,7,8) = 24/4
                expect(output.data[3]).to_equal(7.0)  # avg(5,6,8,9) = 28/4

            it "handles multiple channels":
                val pool = AvgPool2d.create(kernel_size: 2, stride: 2, padding: 0)

                # Input: [1, 2, 2, 2] - 2 channels
                val input_data = [
                    # Channel 0
                    1.0, 2.0,
                    3.0, 4.0,
                    # Channel 1
                    5.0, 6.0,
                    7.0, 8.0
                ]
                val input = tensor_from_data(input_data, [1, 2, 2, 2])

                val output = pool.forward(input)

                # Output should be [1, 2, 1, 1]
                expect(output.shape).to_equal([1, 2, 1, 1])

                # Average per channel
                expect(output.data[0]).to_equal(2.5)  # Channel 0: avg(1,2,3,4) = 10/4
                expect(output.data[1]).to_equal(6.5)  # Channel 1: avg(5,6,7,8) = 26/4

            it "handles batch dimension":
                val pool = AvgPool2d.create(kernel_size: 2, stride: 2, padding: 0)

                # Input: [2, 1, 2, 2] - batch size 2
                val input_data = [
                    # Batch 0
                    2.0, 4.0,
                    6.0, 8.0,
                    # Batch 1
                    1.0, 3.0,
                    5.0, 7.0
                ]
                val input = tensor_from_data(input_data, [2, 1, 2, 2])

                val output = pool.forward(input)

                # Output should be [2, 1, 1, 1]
                expect(output.shape).to_equal([2, 1, 1, 1])

                expect(output.data[0]).to_equal(5.0)  # Batch 0: avg(2,4,6,8) = 20/4
                expect(output.data[1]).to_equal(4.0)  # Batch 1: avg(1,3,5,7) = 16/4

            it "handles 3x3 kernel":
                val pool = AvgPool2d.create(kernel_size: 3, stride: 3, padding: 0)

                val input_data = [
                    1.0, 2.0, 3.0,
                    4.0, 5.0, 6.0,
                    7.0, 8.0, 9.0
                ]
                val input = tensor_from_data(input_data, [1, 1, 3, 3])

                val output = pool.forward(input)

                # Output should be [1, 1, 1, 1]
                expect(output.shape).to_equal([1, 1, 1, 1])

                # Average of entire 3x3 window: (1+2+...+9)/9 = 45/9 = 5.0
                expect(output.data[0]).to_equal(5.0)

        describe "Backward Pass":
            it "distributes gradients uniformly":
                val pool = AvgPool2d.create(kernel_size: 2, stride: 2, padding: 0)

                # Input: [1, 1, 2, 2]
                val input_data = [1.0, 2.0, 3.0, 4.0]
                val input = tensor_from_data(input_data, [1, 1, 2, 2])

                # Forward
                val output = pool.forward(input)

                # Gradient: single value
                val grad_output = tensor_from_data([4.0], [1, 1, 1, 1])

                val grad_input = pool.backward(grad_output)

                # Each input should receive grad_output / 4 = 1.0
                expect(grad_input.shape).to_equal([1, 1, 2, 2])
                expect(grad_input.data[0]).to_equal(1.0)
                expect(grad_input.data[1]).to_equal(1.0)
                expect(grad_input.data[2]).to_equal(1.0)
                expect(grad_input.data[3]).to_equal(1.0)

            it "handles overlapping windows in backward":
                val pool = AvgPool2d.create(kernel_size: 2, stride: 1, padding: 0)

                val input_data = [
                    1.0, 2.0, 3.0,
                    4.0, 5.0, 6.0,
                    7.0, 8.0, 9.0
                ]
                val input = tensor_from_data(input_data, [1, 1, 3, 3])

                val output = pool.forward(input)

                # All output gradients = 1.0
                val grad_output_data = [1.0, 1.0, 1.0, 1.0]
                val grad_output = tensor_from_data(grad_output_data, [1, 1, 2, 2])

                val grad_input = pool.backward(grad_output)

                expect(grad_input.shape).to_equal([1, 1, 3, 3])
                # Center position should have contributions from all 4 windows
                # Each window contributes 1.0/4 = 0.25, so total = 1.0
                expect(grad_input.data[4]).to_equal(1.0)

        describe "Layer Interface":
            it "has no trainable parameters":
                val pool = AvgPool2d.create(kernel_size: 2, stride: 2, padding: 0)
                val params = pool.parameters()
                expect(params.len()).to_equal(0)

            it "switches between train and eval modes":
                val pool = AvgPool2d.create(kernel_size: 2, stride: 2, padding: 0)
                expect(pool.training).to_equal(true)

                pool.eval()
                expect(pool.training).to_equal(false)

                pool.train()
                expect(pool.training).to_equal(true)

            it "has string representation":
                val pool = AvgPool2d.create(kernel_size: 3, stride: 2, padding: 1)
                val s = pool.to_string()
                expect(s.contains("AvgPool2d")).to_equal(true)
                expect(s.contains("3")).to_equal(true)
                expect(s.contains("2")).to_equal(true)
                expect(s.contains("1")).to_equal(true)

    describe "Integration":
        describe "Compatibility with Other Layers":
            it "can be used in a neural network pipeline":
                # This test verifies pooling layers work with the layer interface
                val pool1 = MaxPool2d.create(kernel_size: 2, stride: 2, padding: 0)
                val pool2 = AvgPool2d.create(kernel_size: 2, stride: 2, padding: 0)

                # Create input
                val input_data = [
                    1.0, 2.0, 3.0, 4.0,
                    5.0, 6.0, 7.0, 8.0,
                    9.0, 10.0, 11.0, 12.0,
                    13.0, 14.0, 15.0, 16.0
                ]
                val input = tensor_from_data(input_data, [1, 1, 4, 4])

                # Forward through max pool
                val maxpool_out = pool1.forward(input)
                expect(maxpool_out.shape).to_equal([1, 1, 2, 2])

                # Forward through avg pool
                val avgpool_out = pool2.forward(input)
                expect(avgpool_out.shape).to_equal([1, 1, 2, 2])

                # Both should be poolable
                expect(maxpool_out.data.len()).to_equal(4)
                expect(avgpool_out.data.len()).to_equal(4)

        describe "Edge Cases":
            it "handles single pixel output":
                val pool = MaxPool2d.create(kernel_size: 4, stride: 4, padding: 0)

                val input_data = [
                    1.0, 2.0, 3.0, 4.0,
                    5.0, 6.0, 7.0, 8.0,
                    9.0, 10.0, 11.0, 12.0,
                    13.0, 14.0, 15.0, 16.0
                ]
                val input = tensor_from_data(input_data, [1, 1, 4, 4])

                val output = pool.forward(input)

                expect(output.shape).to_equal([1, 1, 1, 1])
                expect(output.data[0]).to_equal(16.0)

            it "handles uniform input in avgpool":
                val pool = AvgPool2d.create(kernel_size: 2, stride: 2, padding: 0)

                # All values are 5.0
                val input_data = [5.0, 5.0, 5.0, 5.0]
                val input = tensor_from_data(input_data, [1, 1, 2, 2])

                val output = pool.forward(input)

                # Average should still be 5.0
                expect(output.data[0]).to_equal(5.0)
