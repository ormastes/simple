# Tests for Pure Simple Weight Initialization

use std.pure.tensor.{PureTensor, tensor_from_data, tensor_zeros}
use std.pure.nn.init.{init_zeros, init_ones, init_constant, init_uniform, init_normal, init_xavier_uniform, init_xavier_normal, init_kaiming_uniform, init_kaiming_normal}

describe "Weight Initialization":
    describe "init_zeros":
        it "fills tensor with zeros":
            val t = tensor_from_data([1.0, 2.0, 3.0, 4.0], [2, 2])
            val result = init_zeros(t)
            expect(result.shape).to_equal([2, 2])
            expect(result.data[0]).to_equal(0.0)
            expect(result.data[1]).to_equal(0.0)
            expect(result.data[2]).to_equal(0.0)
            expect(result.data[3]).to_equal(0.0)

        it "preserves original shape":
            val t = tensor_from_data([1.0, 2.0, 3.0, 4.0, 5.0, 6.0], [2, 3])
            val result = init_zeros(t)
            expect(result.shape).to_equal([2, 3])
            expect(result.data.len()).to_equal(6)

    describe "init_ones":
        it "fills tensor with ones":
            val t = tensor_from_data([0.0, 0.0, 0.0, 0.0], [2, 2])
            val result = init_ones(t)
            expect(result.shape).to_equal([2, 2])
            expect(result.data[0]).to_equal(1.0)
            expect(result.data[1]).to_equal(1.0)
            expect(result.data[2]).to_equal(1.0)
            expect(result.data[3]).to_equal(1.0)

    describe "init_constant":
        it "fills tensor with specified value":
            val t = tensor_from_data([0.0, 0.0, 0.0, 0.0], [2, 2])
            val result = init_constant(t, 3.14)
            expect(result.shape).to_equal([2, 2])
            expect(result.data[0]).to_equal(3.14)
            expect(result.data[1]).to_equal(3.14)
            expect(result.data[2]).to_equal(3.14)
            expect(result.data[3]).to_equal(3.14)

        it "handles negative constant":
            val t = tensor_from_data([0.0, 0.0], [2])
            val result = init_constant(t, -2.5)
            expect(result.data[0]).to_equal(-2.5)
            expect(result.data[1]).to_equal(-2.5)

    describe "init_uniform":
        it "generates values within specified range":
            val t = tensor_from_data([0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [2, 4])
            val result = init_uniform(t, -1.0, 1.0)
            expect(result.shape).to_equal([2, 4])
            # All values should be in [-1, 1)
            var i = 0
            while i < 8:
                expect(result.data[i]).to_be_greater_than(-1.1)
                expect(result.data[i]).to_be_less_than(1.0)
                i = i + 1

        it "is deterministic (same shape gives same values)":
            val t1 = tensor_from_data([0.0, 0.0, 0.0, 0.0], [2, 2])
            val t2 = tensor_from_data([0.0, 0.0, 0.0, 0.0], [2, 2])
            val r1 = init_uniform(t1, 0.0, 1.0)
            val r2 = init_uniform(t2, 0.0, 1.0)
            expect(r1.data[0]).to_equal(r2.data[0])
            expect(r1.data[1]).to_equal(r2.data[1])

        it "respects range bounds":
            val t = tensor_from_data([0.0, 0.0, 0.0, 0.0], [4])
            val result = init_uniform(t, 2.0, 5.0)
            var i = 0
            while i < 4:
                expect(result.data[i]).to_be_greater_than(1.9)
                expect(result.data[i]).to_be_less_than(5.1)
                i = i + 1

    describe "init_normal":
        it "generates values centered around mean":
            val t = tensor_zeros([10])
            val result = init_normal(t, 0.0, 1.0)
            expect(result.shape).to_equal([10])
            # Compute mean of results
            var sum = 0.0
            var i = 0
            while i < 10:
                sum = sum + result.data[i]
                i = i + 1
            val avg = sum / 10.0
            # Mean should be roughly near 0 (within 2 for small sample)
            expect(avg).to_be_greater_than(-2.0)
            expect(avg).to_be_less_than(2.0)

        it "is deterministic":
            val t1 = tensor_zeros([4])
            val t2 = tensor_zeros([4])
            val r1 = init_normal(t1, 0.0, 1.0)
            val r2 = init_normal(t2, 0.0, 1.0)
            expect(r1.data[0]).to_equal(r2.data[0])

    describe "init_xavier_uniform":
        it "generates values scaled by fan_in and fan_out":
            val t = tensor_zeros([4, 6])
            val result = init_xavier_uniform(t, 1.0)
            expect(result.shape).to_equal([4, 6])
            # For [4, 6]: fan_in=6, fan_out=4. a = sqrt(6/10) ~ 0.775
            # Values should be in roughly [-0.8, 0.8]
            var i = 0
            while i < 24:
                expect(result.data[i]).to_be_greater_than(-1.0)
                expect(result.data[i]).to_be_less_than(1.0)
                i = i + 1

        it "scales with gain parameter":
            val t = tensor_zeros([4, 4])
            val r1 = init_xavier_uniform(t, 1.0)
            val r2 = init_xavier_uniform(t, 2.0)
            # With gain=2, values should have larger magnitude on average
            var sum1 = 0.0
            var sum2 = 0.0
            var i = 0
            while i < 16:
                val v1 = r1.data[i]
                val v2 = r2.data[i]
                sum1 = sum1 + (if v1 < 0.0: 0.0 - v1 else: v1)
                sum2 = sum2 + (if v2 < 0.0: 0.0 - v2 else: v2)
                i = i + 1
            expect(sum2).to_be_greater_than(sum1)

    describe "init_xavier_normal":
        it "generates normally distributed values":
            val t = tensor_zeros([8, 8])
            val result = init_xavier_normal(t, 1.0)
            expect(result.shape).to_equal([8, 8])
            expect(result.data.len()).to_equal(64)

    describe "init_kaiming_uniform":
        it "generates values for relu nonlinearity":
            val t = tensor_zeros([4, 6])
            val result = init_kaiming_uniform(t, "fan_in", "relu")
            expect(result.shape).to_equal([4, 6])
            expect(result.data.len()).to_equal(24)

        it "supports fan_out mode":
            val t = tensor_zeros([8, 4])
            val result = init_kaiming_uniform(t, "fan_out", "relu")
            expect(result.shape).to_equal([8, 4])
            expect(result.data.len()).to_equal(32)

    describe "init_kaiming_normal":
        it "generates values for relu nonlinearity":
            val t = tensor_zeros([4, 6])
            val result = init_kaiming_normal(t, "fan_in", "relu")
            expect(result.shape).to_equal([4, 6])
            expect(result.data.len()).to_equal(24)

        it "supports different nonlinearities":
            val t = tensor_zeros([4, 4])
            val r_relu = init_kaiming_normal(t, "fan_in", "relu")
            val r_tanh = init_kaiming_normal(t, "fan_in", "tanh")
            # Both should produce valid tensors
            expect(r_relu.data.len()).to_equal(16)
            expect(r_tanh.data.len()).to_equal(16)

    describe "Shape Preservation":
        it "preserves 1D shape":
            val t = tensor_zeros([5])
            val result = init_zeros(t)
            expect(result.shape).to_equal([5])

        it "preserves 4D convolutional shape":
            val t = tensor_zeros([16, 3, 3, 3])
            val result = init_ones(t)
            expect(result.shape).to_equal([16, 3, 3, 3])
            expect(result.data.len()).to_equal(432)
