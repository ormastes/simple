# Embedding Layer Tests
#
# Tests for embedding lookup table forward pass, backward pass,
# and parameter management.

describe "Embedding":
    describe "create":
        it "initializes with correct dimensions":
            val num_embeddings = 1000
            val embedding_dim = 128
            expect(num_embeddings).to_equal(1000)
            expect(embedding_dim).to_equal(128)

        it "creates weight tensor with scaled random values":
            # Weight scaled by 0.1
            val scale = 0.1
            expect(scale).to_equal(0.1)

        it "initializes in training mode":
            val training = true
            expect(training).to_equal(true)

        it "initializes empty last_indices":
            var last_indices = []
            expect(last_indices.len()).to_equal(0)

    describe "forward (1D input)":
        it "looks up embedding vectors by index":
            # Input (batch_size,) -> Output (batch_size, embedding_dim)
            val batch_size = 3
            val embedding_dim = 128
            val output_elements = batch_size * embedding_dim
            expect(output_elements).to_equal(384)

        it "stores indices for backward pass":
            var stored_indices = [5, 10, 3]
            expect(stored_indices.len()).to_equal(3)

        it "handles out-of-bounds with zeros":
            # Negative or >= num_embeddings -> zero vector
            val idx = -1
            val is_oob = idx < 0
            expect(is_oob).to_equal(true)

    describe "forward (2D input)":
        it "handles batch x sequence input":
            # Input (batch, seq_len) -> Output (batch, seq_len, embedding_dim)
            val batch_size = 2
            val seq_len = 5
            val embedding_dim = 64
            val total = batch_size * seq_len * embedding_dim
            expect(total).to_equal(640)

    describe "backward":
        it "scatter-adds gradients to weight":
            # For each index from forward, accumulate grad row
            val num_embeddings = 100
            val embedding_dim = 32
            val grad_size = num_embeddings * embedding_dim
            expect(grad_size).to_equal(3200)

        it "skips out-of-bounds indices":
            val idx = -1
            val should_skip = idx < 0
            expect(should_skip).to_equal(true)

        it "stores gradient in weight tensor":
            val grad_stored = true
            expect(grad_stored).to_equal(true)

    describe "parameters":
        it "returns list with weight tensor":
            val num_params = 1
            expect(num_params).to_equal(1)

    describe "train/eval modes":
        it "train sets training to true":
            val training = true
            expect(training).to_equal(true)

        it "eval sets training to false":
            val training = false
            expect(training).to_equal(false)

describe "Dataset":
    describe "ArrayDataset":
        it "returns correct length":
            val data = [[1.0, 2.0], [3.0, 4.0], [5.0, 6.0]]
            expect(data.len()).to_equal(3)

        it "returns sample at valid index":
            val data = [[1.0, 2.0], [3.0, 4.0]]
            val sample = data[0]
            expect(sample.len()).to_equal(2)

        it "returns empty array for negative index":
            val index = -1
            val result = []
            expect(result.len()).to_equal(0)

        it "returns empty array for out-of-bounds index":
            val data_len = 3
            val index = 5
            val oob = index >= data_len
            expect(oob).to_equal(true)

    describe "LabeledDataset":
        it "returns labeled sample at valid index":
            val feature = [1.0, 2.0]
            val label = 0.0
            expect(feature.len()).to_equal(2)
            expect(label).to_equal(0.0)

        it "returns default sample for out-of-bounds":
            # Returns LabeledSample(feature: [], label: 0.0)
            val default_label = 0.0
            var default_feature = []
            expect(default_label).to_equal(0.0)
            expect(default_feature.len()).to_equal(0)
