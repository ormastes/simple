# @platform: all
"""
If-Else Implicit Return Specification

Tests that if-else blocks return values implicitly without requiring an explicit
return keyword. This enables expression-oriented programming where conditional
branches naturally evaluate to values.
"""

# If-Else Implicit Return Support
# Tests that if-else blocks return values implicitly without explicit return keyword
# NOTE: No imports needed - describe/it/expect are built-in

describe "If-else implicit return":
    """
    Validates implicit return behavior for if-else expressions including
    basic conditionals, elif chains, nested conditions, type inference,
    and mixed explicit/implicit return patterns.
    """
    describe "basic if-else":
        it "returns value from if branch":
            fn get_sign(x: i64) -> text:
                if x >= 0:
                    "positive"
                else:
                    "negative"

            expect get_sign(5) == "positive"
            expect get_sign(-5) == "negative"

        it "returns value from else branch":
            fn is_even(x: i64) -> bool:
                if x % 2 == 0:
                    true
                else:
                    false

            expect is_even(4) == true
            expect is_even(3) == false

        it "returns complex expressions":
            fn double_or_triple(x: i64, double: bool) -> i64:
                if double:
                    x * 2
                else:
                    x * 3

            expect double_or_triple(5, true) == 10
            expect double_or_triple(5, false) == 15

    describe "if-elif-else chain":
        it "returns from elif branch":
            fn classify(x: i64) -> text:
                if x < 0:
                    "negative"
                elif x == 0:
                    "zero"
                else:
                    "positive"

            expect classify(-5) == "negative"
            expect classify(0) == "zero"
            expect classify(5) == "positive"

        it "returns from multiple elif branches":
            fn grade(score: i64) -> text:
                if score >= 90:
                    "A"
                elif score >= 80:
                    "B"
                elif score >= 70:
                    "C"
                elif score >= 60:
                    "D"
                else:
                    "F"

            expect grade(95) == "A"
            expect grade(85) == "B"
            expect grade(75) == "C"
            expect grade(65) == "D"
            expect grade(55) == "F"

    describe "nested if-else":
        it "returns from nested if-else":
            fn nested_check(a: bool, b: bool) -> text:
                if a:
                    if b:
                        "both"
                    else:
                        "only a"
                else:
                    if b:
                        "only b"
                    else:
                        "neither"

            expect nested_check(true, true) == "both"
            expect nested_check(true, false) == "only a"
            expect nested_check(false, true) == "only b"
            expect nested_check(false, false) == "neither"

    describe "with other statements before":
        it "returns after variable declaration":
            fn add_with_check(a: i64, b: i64) -> i64:
                val sum = a + b
                if sum > 100:
                    100
                else:
                    sum

            expect add_with_check(30, 40) == 70
            expect add_with_check(80, 50) == 100

        it "returns after loop":
            fn sum_until(limit: i64) -> i64:
                var total = 0
                var i = 1
                while i <= limit:
                    total = total + i
                    i = i + 1
                if total > 100:
                    100
                else:
                    total

            expect sum_until(5) == 15
            expect sum_until(20) == 100

    describe "return type inference":
        it "works with integer return":
            fn max_val(a: i64, b: i64) -> i64:
                if a > b:
                    a
                else:
                    b

            expect max_val(10, 5) == 10
            expect max_val(5, 10) == 10

        it "works with text return":
            fn greeting(formal: bool) -> text:
                if formal:
                    "Good day"
                else:
                    "Hi"

            expect greeting(true) == "Good day"
            expect greeting(false) == "Hi"

        it "works with boolean return":
            fn both_positive(a: i64, b: i64) -> bool:
                if a > 0 and b > 0:
                    true
                else:
                    false

            expect both_positive(1, 2) == true
            expect both_positive(-1, 2) == false

    describe "mixed with explicit return":
        it "works with early return and implicit else":
            fn absolute(x: i64) -> i64:
                if x < 0:
                    return -x
                x

            expect absolute(-5) == 5
            expect absolute(5) == 5

        it "works with guard clause pattern":
            fn safe_divide(a: i64, b: i64) -> i64:
                if b == 0:
                    return 0
                if a < 0:
                    -1
                else:
                    a / b

            expect safe_divide(10, 2) == 5
            expect safe_divide(10, 0) == 0
            expect safe_divide(-10, 2) == -1

    describe "with function calls":
        it "returns function call result":
            fn double(x: i64) -> i64:
                x * 2

            fn conditional_double(x: i64, should_double: bool) -> i64:
                if should_double:
                    double(x)
                else:
                    x

            expect conditional_double(5, true) == 10
            expect conditional_double(5, false) == 5
