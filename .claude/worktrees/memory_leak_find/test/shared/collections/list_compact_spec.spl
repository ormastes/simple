# @platform: all
"""
List<Option<T>>.compact() Tests

Tests for the compact method that removes None values from a list of Options
and unwraps the remaining Some values, similar to Ruby's Array#compact.
"""

describe "List<Option<T>>.compact()":
    """
    Tests for the compact method covering basic functionality, different types,
    Ruby-style usage patterns, and performance characteristics.
    """

    describe "basic functionality":
    
        it "removes None values and unwraps Some values":
            val items: List<Option<i64>> = [Some(1), None, Some(2), None, Some(3)]
            val compacted = items.compact()
            expect(compacted.len()).to_equal(3)
            expect(compacted[0]).to_equal(1)
            expect(compacted[1]).to_equal(2)
            expect(compacted[2]).to_equal(3)
        
        it "handles empty list":
            val empty: List<Option<i64>> = []
            val compacted = empty.compact()
            expect(compacted.len()).to_equal(0)
        
        it "handles list with all None values":
            val all_none: List<Option<i64>> = [None, None, None]
            val compacted = all_none.compact()
            expect(compacted.len()).to_equal(0)
        
        it "handles list with all Some values":
            val all_some: List<Option<i64>> = [Some(1), Some(2), Some(3)]
            val compacted = all_some.compact()
            expect(compacted.len()).to_equal(3)
            expect(compacted[0]).to_equal(1)
            expect(compacted[1]).to_equal(2)
            expect(compacted[2]).to_equal(3)

    describe "with different types":
    
        it "works with text values":
            val words: List<Option<text>> = [Some("hello"), None, Some("world"), None]
            val compacted = words.compact()
            expect(compacted.len()).to_equal(2)
            expect(compacted[0]).to_equal("hello")
            expect(compacted[1]).to_equal("world")
        
        it "works with nested structures":
            val items: List<Option<List<i64>>> = [
                Some([1, 2]),
                None,
                Some([3, 4]),
                None,
                Some([5])
            ]
            val compacted = items.compact()
            expect(compacted.len()).to_equal(3)
            expect(compacted[0].len()).to_equal(2)
            expect(compacted[1].len()).to_equal(2)
            expect(compacted[2].len()).to_equal(1)

    describe "Ruby-style usage":
    
        it "chains with map and compact":
            val numbers = [1, 2, 3, 4, 5]
            # Map to Option, filter evens - use helper fn instead of inline fn()
            fn map_even(x):
                if x % 2 == 0:
                    return Some(x * 10)
                return None
            val mapped = numbers.map(\x: map_even(x))
            val result = mapped.compact()
            expect(result.len()).to_equal(2)
            expect(result[0]).to_equal(20)
            expect(result[1]).to_equal(40)
        
        it "similar to Ruby's compact method":
            # Ruby: [1, nil, 2, nil, 3].compact => [1, 2, 3]
            # Simple: [Some(1), None, Some(2), None, Some(3)].compact() => [1, 2, 3]
            val items: List<Option<i64>> = [Some(1), None, Some(2), None, Some(3)]
            val result = items.compact()
            expect(result).to_equal([1, 2, 3])

    describe "performance characteristics":
    
        it "creates new list without modifying original":
            val original: List<Option<i64>> = [Some(1), None, Some(2)]
            val compacted = original.compact()
            # Original unchanged
            expect(original.len()).to_equal(3)
            # New list created
            expect(compacted.len()).to_equal(2)
