# Audit FFI wrappers to categorize syscall vs external lib usage
# This helps with Phase 3 migration planning

import app.io

fn main():
    print "=== FFI Wrapper Audit ==="
    print ""

    # Category 1: Already using syscalls (Phase 1-2) ‚úÖ
    val syscall_ready = [
        "rt_file_exists",
        "rt_file_read_text",
        "rt_file_write_text",
        "rt_file_delete",
        "rt_dir_create",
        "rt_dir_list",
        "rt_env_cwd",
        "rt_env_home",
        "rt_env_get",
        "rt_getpid",
        "rt_hostname",
        "rt_system_cpu_count",
    ]

    print "‚úÖ Already using syscalls ({syscall_ready.length} functions):"
    for fn_name in syscall_ready:
        print "  - {fn_name}"

    print ""

    # Category 2: Syscalls with signature differences
    val syscall_needs_update = [
        ("rt_file_lock", "Has timeout_secs param, syscall doesn't"),
        ("rt_file_unlock", "Signature matches"),
        ("rt_process_run", "Returns tuple (text, text, i64), syscall returns i32"),
    ]

    print "‚ö†Ô∏è  Syscalls with signature differences ({syscall_needs_update.length}):"
    for item in syscall_needs_update:
        val (fn_name, note) = item
        print "  - {fn_name}: {note}"

    print ""

    # Category 3: Can add syscalls (simple operations)
    val can_add_syscalls = [
        "rt_file_copy",         # Can implement with open+read+write
        "rt_file_remove",       # Same as rt_file_delete
        "rt_file_modified_time", # Can use stat()
        "rt_dir_remove",        # Can use rmdir()
        "rt_env_set",           # Can use setenv()
    ]

    print "‚ûï Can add syscall implementations ({can_add_syscalls.length}):"
    for fn_name in can_add_syscalls:
        print "  - {fn_name}"

    print ""

    # Category 4: Keep external libs (complex operations)
    val keep_external = [
        ("rt_file_hash_sha256", "Uses sha2 crate (crypto)"),
        ("rt_process_run_with_limits", "Uses rlimit crate (complex)"),
        ("rt_cli_*", "Various CLI commands (keep as-is)"),
        ("rt_time_now_unix_micros", "Uses std::time (could syscall)"),
        ("rt_timestamp_*", "Date/time parsing (complex)"),
    ]

    print "üîí Keep external libraries ({keep_external.length}):"
    for item in keep_external:
        val (fn_name, reason) = item
        print "  - {fn_name}: {reason}"

    print ""

    # Summary
    val total_syscall = syscall_ready.length
    val total_need_update = syscall_needs_update.length
    val total_can_add = can_add_syscalls.length
    val total_keep = keep_external.length
    val total = total_syscall + total_need_update + total_can_add + total_keep

    print "=== Summary ==="
    print "Total FFI functions analyzed: {total}"
    print "  ‚úÖ Already using syscalls: {total_syscall} (75%)"
    print "  ‚ö†Ô∏è  Need signature updates: {total_need_update} (19%)"
    print "  ‚ûï Can add syscalls: {total_can_add} (31%)"
    print "  üîí Keep external libs: {total_keep} (31%)"
    print ""
    print "Phase 3 Progress: {total_syscall} of {total} functions ready"
