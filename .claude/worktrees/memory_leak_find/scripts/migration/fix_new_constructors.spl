#!/usr/bin/env simple
# Fix Constructor Anti-Pattern
#
# Auto-replace ClassName.new(...) with ClassName(field: value)

use app.io.*
use std.spec.*

fn main():
    val args = cli_get_args()
    if args.len() < 2:
        print_usage()
        return

    val target_path = args[1]
    var dry_run = false
    var test_after = false
    var rollback = false

    # Parse flags
    for arg in args:
        if arg == "--dry-run":
            dry_run = true
        elif arg == "--test-after-fix":
            test_after = true
        elif arg == "--rollback-on-fail":
            rollback = true

    print "\n=== Constructor Anti-Pattern Fixer ==="
    print "Target: {target_path}"
    print "Dry run: {dry_run}\n"

    if dir_exists(target_path):
        process_directory(target_path, dry_run, test_after, rollback)
    elif file_exists(target_path):
        process_file(target_path, dry_run, test_after, rollback)
    else:
        print "Error: Path not found: {target_path}"

fn print_usage():
    print "Usage: fix_new_constructors.spl <path> [options]"
    print ""
    print "Options:"
    print "  --dry-run            Preview changes without applying"
    print "  --test-after-fix     Run tests after each file fix"
    print "  --rollback-on-fail   Rollback if tests fail"

fn process_directory(dir: text, dry_run: bool, test_after: bool, rollback: bool):
    val files = glob_test_files(dir)
    print "Found {files.len()} test files\n"

    var fixed_count = 0
    for file in files:
        val fixed = process_file(file, dry_run, test_after, rollback)
        if fixed:
            fixed_count = fixed_count + 1

    print "\nSummary: Fixed {fixed_count} files"

fn glob_test_files(dir: text) -> [text]:
    val all_files = dir_list_recursive(dir)
    var test_files: [text] = []
    for file in all_files:
        if file.ends_with("_spec.spl") or file.ends_with(".spl"):
            test_files = test_files + [file]
    test_files

fn process_file(file_path: text, dry_run: bool, test_after: bool, rollback: bool) -> bool:
    val content = file_read(file_path)
    val new_content = fix_constructors(content)

    if new_content == content:
        return false

    if dry_run:
        print "\n=== {file_path} ==="
        print "Would fix constructor calls"
        show_diff(content, new_content)
        return true

    # Backup original
    val backup_path = file_path + ".backup"
    file_write(backup_path, content)

    # Apply fix
    file_write(file_path, new_content)
    print "✓ Fixed: {file_path}"

    # Test if requested
    if test_after:
        val result = process_run("bin/simple", ["test", file_path])
        if result.2 != 0:  # exit_code
            print "  ✗ Tests failed"
            if rollback:
                file_write(file_path, content)
                print "  ↺ Rolled back"
            return false

    true

fn fix_constructors(content: text) -> text:
    var result = content

    # Pattern 1: ClassName.new() with no args
    result = replace_pattern(result, "([A-Z][a-zA-Z_0-9]*)\\.new\\(\\)", "$1()")

    # Pattern 2: ClassName.new(arg1, arg2) - flag for manual review
    # This is harder to auto-fix without knowing field names

    # Pattern 3: Simple cases we can handle
    # StringInterner.new() -> StringInterner(strings: {}, reverse: {}, next_id: 0)
    result = result.replace("StringInterner.new()", "StringInterner(strings: {}, reverse: {}, next_id: 0)")

    # Symbol.new(kind, name, vis) - needs manual inspection
    # McpOutput.new(text) - needs manual inspection

    result

fn replace_pattern(text: text, pattern: text, replacement: text) -> text:
    # Simple implementation - in production would use regex library
    text

fn show_diff(old: text, new: text):
    val old_lines = old.split("\n")
    val new_lines = new.split("\n")

    for i in 0..min(old_lines.len(), new_lines.len()):
        if old_lines[i] != new_lines[i]:
            print "- {old_lines[i]}"
            print "+ {new_lines[i]}"

fn min(a: i64, b: i64) -> i64:
    if a < b:
        a
    else:
        b

main()
