# Option Type - Represents optional values
# Core type for handling nullable values safely

enum Option[T]:
    Some(T)
    None

impl Option[T]:
    # Check if option has a value
    fn is_some(self) -> bool:
        match self:
            case Some(_): return true
            case None: return false

    fn is_none(self) -> bool:
        return not self.is_some()

    # Unwrap with panic on None - prefer expect() for better error messages
    fn unwrap(self) -> T:
        match self:
            case Some(v): return v
            case None: panic("called unwrap on None")

    # Unwrap with custom panic message - preferred over unwrap()
    fn expect(self, msg: str) -> T:
        match self:
            case Some(v): return v
            case None: panic(msg)

    # Unwrap with default value
    fn unwrap_or(self, default: T) -> T:
        match self:
            case Some(v): return v
            case None: return default

    # Unwrap with lazy default
    fn unwrap_or_else(self, f: fn() -> T) -> T:
        match self:
            case Some(v): return v
            case None: return f()

    # Map the inner value
    fn map[U](self, f: fn(T) -> U) -> Option[U]:
        match self:
            case Some(v): return Some(f(v))
            case None: return None

    # Flat map (and_then)
    fn and_then[U](self, f: fn(T) -> Option[U]) -> Option[U]:
        match self:
            case Some(v): return f(v)
            case None: return None

    # Filter - returns new Option (immutable operation)
    fn filtered(self, predicate: fn(&T) -> bool) -> Option[T]:
        match self:
            case Some(v):
                if predicate(&v):
                    return Some(v)
                return None
            case None:
                return None

    # Or combinator
    fn or(self, other: Option[T]) -> Option[T]:
        match self:
            case Some(_): return self
            case None: return other

    # Or with lazy evaluation
    fn or_else(self, f: fn() -> Option[T]) -> Option[T]:
        match self:
            case Some(_): return self
            case None: return f()

    # Get reference to inner value
    fn as_ref(self) -> Option[&T]:
        match self:
            case Some(v): return Some(&v)
            case None: return None

    # Convert to Result
    fn ok_or[E](self, err: E) -> Result[T, E]:
        match self:
            case Some(v): return Ok(v)
            case None: return Err(err)

    fn ok_or_else[E](self, f: fn() -> E) -> Result[T, E]:
        match self:
            case Some(v): return Ok(v)
            case None: return Err(f())

    # Take value, leaving None
    fn take(self) -> Option[T]:
        let result = self
        self = None
        return result

    # Replace value
    fn replace(self, value: T) -> Option[T]:
        let old = self
        self = Some(value)
        return old

    # Zip with another option
    fn zip[U](self, other: Option[U]) -> Option[(T, U)]:
        match (self, other):
            case (Some(a), Some(b)): return Some((a, b))
            case _: return None

    # Flatten nested option
    fn flatten(self: Option[Option[T]]) -> Option[T]:
        match self:
            case Some(inner): return inner
            case None: return None

    # Convert to array (0 or 1 elements)
    fn to_array(self) -> Array[T]:
        match self:
            case Some(v): return [v]
            case None: return []

# Helper functions
fn some[T](value: T) -> Option[T]:
    return Some(value)

fn none[T]() -> Option[T]:
    return None
