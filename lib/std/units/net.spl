# Network Unit Types
# IP addresses, ports, MAC addresses, and socket addresses

# IP address - v4 or v6 (multi-base unit)
# Accepts both string ("127.0.0.1"_ip) and numeric (0x7F000001_ip) literals
unit IpAddr: str | u32 as ip

# Specific IP versions
unit Ipv4Addr: str | u32 as ipv4    # Both "127.0.0.1" and 0x7F000001
unit Ipv6Addr: str | u128 as ipv6   # Both "::1" and numeric

# Port number (0-65535)
unit Port: u16 as port

# Socket address (IP + port combination)
unit SocketAddr: str as sock

# MAC address (48-bit, string or numeric)
unit MacAddr: str | u64 as mac

# Network mask / CIDR prefix
unit CidrPrefix: u8 as cidr

# Error types
enum AddrError:
    InvalidFormat
    InvalidOctet
    InvalidPort
    OutOfRange
    Ipv4Only
    Ipv6Only

# IpAddr implementation
impl IpAddr:
    # Construction from components
    fn v4(a: u8, b: u8, c: u8, d: u8) -> Ipv4Addr:
        let n = ((a as u32) << 24) | ((b as u32) << 16) | ((c as u32) << 8) | (d as u32)
        return n_ipv4

    fn v6(segments: [u16; 8]) -> Ipv6Addr:
        # Build string representation
        let parts = []
        for seg in segments:
            parts.push(seg.to_hex())
        return parts.join(":")_ipv6

    fn localhost() -> IpAddr:
        return "127.0.0.1"_ip

    fn any() -> IpAddr:
        return "0.0.0.0"_ip

    fn broadcast() -> IpAddr:
        return "255.255.255.255"_ip

    # Construction from literals (both formats)
    fn from_str(s: str) -> Result[IpAddr, AddrError]:
        # Try IPv4 first
        if s.contains("."):
            let parts = s.split(".")
            if parts.len() != 4:
                return Err(AddrError::InvalidFormat)
            return Ok(s_ip)
        # Try IPv6
        if s.contains(":"):
            return Ok(s_ip)
        return Err(AddrError::InvalidFormat)

    fn from_u32(n: u32) -> Ipv4Addr:
        return n_ipv4

    fn from_u128(n: u128) -> Ipv6Addr:
        return n_ipv6

    # Properties
    fn is_v4(self) -> bool:
        let s = self as str
        return s.contains(".") and not s.contains(":")

    fn is_v6(self) -> bool:
        let s = self as str
        return s.contains(":")

    fn is_loopback(self) -> bool:
        if self.is_v4():
            let s = self as str
            return s.starts_with("127.")
        return (self as str) == "::1"

    fn is_private(self) -> bool:
        if self.is_v4():
            let s = self as str
            return s.starts_with("10.") or
                   s.starts_with("192.168.") or
                   s.starts_with("172.16.") or
                   s.starts_with("172.17.") or
                   s.starts_with("172.18.") or
                   s.starts_with("172.19.") or
                   s.starts_with("172.20.") or
                   s.starts_with("172.21.") or
                   s.starts_with("172.22.") or
                   s.starts_with("172.23.") or
                   s.starts_with("172.24.") or
                   s.starts_with("172.25.") or
                   s.starts_with("172.26.") or
                   s.starts_with("172.27.") or
                   s.starts_with("172.28.") or
                   s.starts_with("172.29.") or
                   s.starts_with("172.30.") or
                   s.starts_with("172.31.")
        return false

    fn is_multicast(self) -> bool:
        if self.is_v4():
            let s = self as str
            # 224.0.0.0 - 239.255.255.255
            return s.starts_with("224.") or
                   s.starts_with("225.") or
                   s.starts_with("226.") or
                   s.starts_with("227.") or
                   s.starts_with("228.") or
                   s.starts_with("229.") or
                   s.starts_with("230.") or
                   s.starts_with("231.") or
                   s.starts_with("232.") or
                   s.starts_with("233.") or
                   s.starts_with("234.") or
                   s.starts_with("235.") or
                   s.starts_with("236.") or
                   s.starts_with("237.") or
                   s.starts_with("238.") or
                   s.starts_with("239.")
        return false

    # Conversion
    fn to_v4(self) -> Option[Ipv4Addr]:
        if self.is_v4():
            return Some((self as str)_ipv4)
        return None

    fn to_v6(self) -> Ipv6Addr:
        if self.is_v6():
            return (self as str)_ipv6
        # IPv4-mapped IPv6 address: ::ffff:a.b.c.d
        return ("::ffff:" + (self as str))_ipv6

    fn to_str(self) -> str:
        return self as str

# Ipv4Addr implementation
impl Ipv4Addr:
    fn octets(self) -> [u8; 4]:
        let s = self as str
        let parts = s.split(".")
        return [
            parts[0].parse_u8().unwrap_or(0),
            parts[1].parse_u8().unwrap_or(0),
            parts[2].parse_u8().unwrap_or(0),
            parts[3].parse_u8().unwrap_or(0)
        ]

    fn to_u32(self) -> u32:
        let octets = self.octets()
        return ((octets[0] as u32) << 24) |
               ((octets[1] as u32) << 16) |
               ((octets[2] as u32) << 8) |
               (octets[3] as u32)

    fn from_u32(n: u32) -> Ipv4Addr:
        let a = (n >> 24) & 0xFF
        let b = (n >> 16) & 0xFF
        let c = (n >> 8) & 0xFF
        let d = n & 0xFF
        return f"{a}.{b}.{c}.{d}"_ipv4

# Port implementation
impl Port:
    fn from_u16(n: u16) -> Port:
        return n_port

    fn to_u16(self) -> u16:
        return self as u16

    fn is_privileged(self) -> bool:
        return (self as u16) < 1024

    fn is_ephemeral(self) -> bool:
        let p = self as u16
        return p >= 49152 and p <= 65535

    # Well-known ports
    fn http() -> Port:
        return 80_port

    fn https() -> Port:
        return 443_port

    fn ssh() -> Port:
        return 22_port

    fn ftp() -> Port:
        return 21_port

    fn ftp_data() -> Port:
        return 20_port

    fn dns() -> Port:
        return 53_port

# SocketAddr implementation
impl SocketAddr:
    fn new(ip: IpAddr, port: Port) -> SocketAddr:
        if ip.is_v6():
            return f"[{ip as str}]:{port as u16}"_sock
        return f"{ip as str}:{port as u16}"_sock

    fn from_str(s: str) -> Result[SocketAddr, AddrError]:
        # Check for IPv6 format: [::1]:8080
        if s.starts_with("["):
            let close = s.find("]:")
            match close:
                case Some(_): return Ok(s_sock)
                case None: return Err(AddrError::InvalidFormat)
        # IPv4 format: 127.0.0.1:8080
        if s.contains(":"):
            return Ok(s_sock)
        return Err(AddrError::InvalidFormat)

    fn ip(self) -> IpAddr:
        let s = self as str
        if s.starts_with("["):
            # IPv6: [::1]:8080
            let close = s.find("]").unwrap_or(s.len())
            return s.slice(1, close)_ip
        # IPv4: 127.0.0.1:8080
        let colon = s.rfind(":").unwrap_or(s.len())
        return s.slice(0, colon)_ip

    fn port(self) -> Port:
        let s = self as str
        let colon = s.rfind(":").unwrap_or(0)
        let port_str = s.slice(colon + 1, s.len())
        return port_str.parse_u16().unwrap_or(0)_port

    fn localhost(port: Port) -> SocketAddr:
        return f"127.0.0.1:{port as u16}"_sock

# MacAddr implementation
impl MacAddr:
    fn from_str(s: str) -> Result[MacAddr, AddrError]:
        # Accept formats: 00:1A:2B:3C:4D:5E or 00-1A-2B-3C-4D-5E
        let normalized = s.replace("-", ":")
        let parts = normalized.split(":")
        if parts.len() != 6:
            return Err(AddrError::InvalidFormat)
        return Ok(normalized_mac)

    fn from_u64(n: u64) -> MacAddr:
        let bytes = [
            ((n >> 40) & 0xFF) as u8,
            ((n >> 32) & 0xFF) as u8,
            ((n >> 24) & 0xFF) as u8,
            ((n >> 16) & 0xFF) as u8,
            ((n >> 8) & 0xFF) as u8,
            (n & 0xFF) as u8
        ]
        return f"{bytes[0]:02X}:{bytes[1]:02X}:{bytes[2]:02X}:{bytes[3]:02X}:{bytes[4]:02X}:{bytes[5]:02X}"_mac

    fn to_u64(self) -> u64:
        let s = self as str
        let parts = s.replace("-", ":").split(":")
        let mut result: u64 = 0
        for part in parts:
            result = (result << 8) | part.parse_hex_u8().unwrap_or(0) as u64
        return result

    fn is_broadcast(self) -> bool:
        return (self as str) == "FF:FF:FF:FF:FF:FF"

    fn is_multicast(self) -> bool:
        let s = self as str
        let first_byte = s.slice(0, 2).parse_hex_u8().unwrap_or(0)
        return (first_byte & 0x01) != 0

    fn broadcast() -> MacAddr:
        return "FF:FF:FF:FF:FF:FF"_mac

# CidrPrefix implementation
impl CidrPrefix:
    fn from_u8(n: u8) -> Result[CidrPrefix, AddrError]:
        if n > 128:
            return Err(AddrError::OutOfRange)
        return Ok(n_cidr)

    fn to_ipv4_mask(self) -> Ipv4Addr:
        let prefix = self as u8
        if prefix > 32:
            return "255.255.255.255"_ipv4
        let mask = if prefix == 0:
            0_u32
        else:
            0xFFFFFFFF_u32 << (32 - prefix)
        return Ipv4Addr::from_u32(mask)

    fn is_host(self) -> bool:
        return (self as u8) == 32 or (self as u8) == 128
