# TestDatabase Extended Tests

# @skip - Uses unsupported keyword: with
use lib.database.test_extended.*
use lib.database.core.{StringInterner}
use app.io.{file_write, file_exists, file_delete}

describe "TestDatabase Extended":
    context "StringInterner":
        it "interns strings and returns IDs":
            var interner = StringInterner(next_id: 0, str_to_id: {}, id_to_str: {})
            val id1 = interner.intern("hello")
            val id2 = interner.intern("world")
            val id3 = interner.intern("hello")  # Duplicate

            expect id1 == 0
            expect id2 == 1
            expect id3 == 0  # Same as first "hello"

        it "retrieves strings by ID":
            var interner = StringInterner(next_id: 0, str_to_id: {}, id_to_str: {})
            val id = interner.intern("test")
            val retrieved = interner.get(id)

            expect retrieved.?
            expect retrieved? == "test"

        it "returns None for unknown ID":
            val interner = StringInterner(next_id: 0, str_to_id: {}, id_to_str: {})
            val retrieved = interner.get(999)
            expect not retrieved.?

        it "handles empty strings":
            var interner = StringInterner(next_id: 0, str_to_id: {}, id_to_str: {})
            val id = interner.intern("")
            expect id == 0
            expect interner.get(0)? == ""

        it "maintains unique IDs for different strings":
            var interner = StringInterner(next_id: 0, str_to_id: {}, id_to_str: {})
            val ids = [
                interner.intern("alpha"),
                interner.intern("beta"),
                interner.intern("gamma"),
                interner.intern("alpha")  # Duplicate
            ]

            expect ids[0] == 0
            expect ids[1] == 1
            expect ids[2] == 2
            expect ids[3] == 0  # Same as first "alpha"

    context "Schema Creation":
        it "creates all 8 tables":
            val db = create_test_database_extended(":memory:")

            # Verify tables exist via attempting to access them
            val strings_opt = db.db.get_table("strings")
            val files_opt = db.db.get_table("files")
            val suites_opt = db.db.get_table("suites")
            val tests_opt = db.db.get_table("tests")
            val counters_opt = db.db.get_table("counters")
            val timing_opt = db.db.get_table("timing")
            val timing_runs_opt = db.db.get_table("timing_runs")
            val changes_opt = db.db.get_table("changes")

            expect strings_opt.?
            expect files_opt.?
            expect suites_opt.?
            expect tests_opt.?
            expect counters_opt.?
            expect timing_opt.?
            expect timing_runs_opt.?
            expect changes_opt.?

    context "Test Hierarchy Creation":
        it "creates file, suite, and test hierarchy":
            var db = create_test_database_extended(":memory:")

            db.update_test_result(
                "test/sample_spec.spl",
                "Sample Suite",
                "test_case_1",
                "passed",
                125.5,
                "run_001"
            )

            # Verify file was created
            val file_id_opt = db.get_file_id("test/sample_spec.spl")
            expect file_id_opt.?

            # Verify suite was created
            val suite_id_opt = db.get_suite_id("test/sample_spec.spl", "Sample Suite")
            expect suite_id_opt.?

            # Verify test was created
            val test_id_opt = db.get_test_id("test/sample_spec.spl", "Sample Suite", "test_case_1")
            expect test_id_opt.?

        it "reuses existing file IDs":
            var db = create_test_database_extended(":memory:")

            db.update_test_result("test/file.spl", "Suite1", "Test1", "passed", 10.0, "run_1")
            db.update_test_result("test/file.spl", "Suite2", "Test2", "passed", 20.0, "run_1")

            val file_id1_opt = db.get_file_id("test/file.spl")
            val file_id2_opt = db.get_file_id("test/file.spl")

            expect file_id1_opt.?
            expect file_id2_opt.?
            expect file_id1_opt? == file_id2_opt?  # Same file ID reused

        it "reuses existing suite IDs":
            var db = create_test_database_extended(":memory:")

            db.update_test_result("test/file.spl", "Suite1", "Test1", "passed", 10.0, "run_1")
            db.update_test_result("test/file.spl", "Suite1", "Test2", "passed", 20.0, "run_1")

            val suite_id1_opt = db.get_suite_id("test/file.spl", "Suite1")
            val suite_id2_opt = db.get_suite_id("test/file.spl", "Suite1")

            expect suite_id1_opt.?
            expect suite_id2_opt.?
            expect suite_id1_opt? == suite_id2_opt?  # Same suite ID reused

        it "creates different IDs for different tests":
            var db = create_test_database_extended(":memory:")

            db.update_test_result("test/file.spl", "Suite", "Test1", "passed", 10.0, "run_1")
            db.update_test_result("test/file.spl", "Suite", "Test2", "passed", 20.0, "run_1")

            val test_id1_opt = db.get_test_id("test/file.spl", "Suite", "Test1")
            val test_id2_opt = db.get_test_id("test/file.spl", "Suite", "Test2")

            expect test_id1_opt.?
            expect test_id2_opt.?
            val test_id1 = test_id1_opt?
            val test_id2 = test_id2_opt?

            expect test_id1 != test_id2  # Different test IDs

    context "Counter Updates":
        it "initializes counter on first result":
            var db = create_test_database_extended(":memory:")

            db.update_test_result("test/file.spl", "Suite", "Test", "passed", 10.0, "run_1")

            val test_id_opt = db.get_test_id("test/file.spl", "Suite", "Test")
            expect test_id_opt.?
            val test_id = test_id_opt?
            val counter_opt = db.get_counter(test_id)

            expect counter_opt.?
            val counter = counter_opt?
            expect counter.total_runs == 1
            expect counter.passed == 1
            expect counter.failed == 0

        it "increments counter on subsequent results":
            var db = create_test_database_extended(":memory:")

            db.update_test_result("test/file.spl", "Suite", "Test", "passed", 10.0, "run_1")
            db.update_test_result("test/file.spl", "Suite", "Test", "passed", 12.0, "run_2")
            db.update_test_result("test/file.spl", "Suite", "Test", "failed", 15.0, "run_3")

            val test_id_opt = db.get_test_id("test/file.spl", "Suite", "Test")
            expect test_id_opt.?
            val test_id = test_id_opt?
            val counter_opt = db.get_counter(test_id)
            expect counter_opt.?
            val counter = counter_opt?

            expect counter.total_runs == 3
            expect counter.passed == 2
            expect counter.failed == 1

        it "tracks consecutive passes":
            var db = create_test_database_extended(":memory:")

            db.update_test_result("test/file.spl", "Suite", "Test", "passed", 10.0, "run_1")
            db.update_test_result("test/file.spl", "Suite", "Test", "passed", 10.0, "run_2")
            db.update_test_result("test/file.spl", "Suite", "Test", "passed", 10.0, "run_3")

            val test_id_opt = db.get_test_id("test/file.spl", "Suite", "Test")
            expect test_id_opt.?
            val test_id = test_id_opt?
            val counter_opt = db.get_counter(test_id)
            expect counter_opt.?
            val counter = counter_opt?

            expect counter.consecutive_passes == 3

        it "resets consecutive passes on failure":
            var db = create_test_database_extended(":memory:")

            db.update_test_result("test/file.spl", "Suite", "Test", "passed", 10.0, "run_1")
            db.update_test_result("test/file.spl", "Suite", "Test", "passed", 10.0, "run_2")
            db.update_test_result("test/file.spl", "Suite", "Test", "failed", 10.0, "run_3")
            db.update_test_result("test/file.spl", "Suite", "Test", "passed", 10.0, "run_4")

            val test_id_opt = db.get_test_id("test/file.spl", "Suite", "Test")
            expect test_id_opt.?
            val test_id = test_id_opt?
            val counter_opt = db.get_counter(test_id)
            expect counter_opt.?
            val counter = counter_opt?

            expect counter.consecutive_passes == 1  # Reset after failure

        it "tracks crashed tests":
            var db = create_test_database_extended(":memory:")

            db.update_test_result("test/file.spl", "Suite", "Test", "crashed", 0.0, "run_1")

            val test_id_opt = db.get_test_id("test/file.spl", "Suite", "Test")
            expect test_id_opt.?
            val test_id = test_id_opt?
            val counter_opt = db.get_counter(test_id)
            expect counter_opt.?
            val counter = counter_opt?

            expect counter.total_runs == 1
            expect counter.crashed == 1

        it "tracks timed out tests":
            var db = create_test_database_extended(":memory:")

            db.update_test_result("test/file.spl", "Suite", "Test", "timed_out", 5000.0, "run_1")

            val test_id_opt = db.get_test_id("test/file.spl", "Suite", "Test")
            expect test_id_opt.?
            val test_id = test_id_opt?
            val counter_opt = db.get_counter(test_id)
            expect counter_opt.?
            val counter = counter_opt?

            expect counter.total_runs == 1
            expect counter.timed_out == 1

    context "Timing Statistics":
        it "computes statistics from timing runs":
            var db = create_test_database_extended(":memory:")

            # Add multiple runs with different timings
            db.update_test_result("test/file.spl", "Suite", "Test", "passed", 100.0, "run_1")
            db.update_test_result("test/file.spl", "Suite", "Test", "passed", 110.0, "run_2")
            db.update_test_result("test/file.spl", "Suite", "Test", "passed", 105.0, "run_3")
            db.update_test_result("test/file.spl", "Suite", "Test", "passed", 115.0, "run_4")

            val test_id_opt = db.get_test_id("test/file.spl", "Suite", "Test")
            expect test_id_opt.?
            val test_id = test_id_opt?
            val timing_opt = db.get_timing_summary(test_id)

            expect timing_opt.?
            val timing = timing_opt?
            expect timing.mean > 100.0
            expect timing.mean < 115.0
            expect timing.p50 > 0.0

        it "updates baseline on significant change":
            var db = create_test_database_extended(":memory:")

            # Add runs with stable timing
            db.update_test_result("test/file.spl", "Suite", "Test", "passed", 100.0, "run_1")
            db.update_test_result("test/file.spl", "Suite", "Test", "passed", 102.0, "run_2")
            db.update_test_result("test/file.spl", "Suite", "Test", "passed", 98.0, "run_3")

            # Add run with significant change (>20%)
            db.update_test_result("test/file.spl", "Suite", "Test", "passed", 150.0, "run_4")

            val test_id_opt = db.get_test_id("test/file.spl", "Suite", "Test")
            expect test_id_opt.?
            val test_id = test_id_opt?
            val timing_opt = db.get_timing_summary(test_id)
            expect timing_opt.?
            val timing = timing_opt?

            expect timing.has_baseline == true
            expect timing.baseline_p50 > 0.0

        it "maintains last 10 runs":
            var db = create_test_database_extended(":memory:")

            # Add 15 runs
            for i in 0..15:
                val duration = 100.0 + i.to_f64()
                db.update_test_result("test/file.spl", "Suite", "Test", "passed", duration, "run_{i}")

            val test_id_opt = db.get_test_id("test/file.spl", "Suite", "Test")
            expect test_id_opt.?
            val test_id = test_id_opt?
            val runs = db.collect_timing_runs(test_id, 10)

            expect runs.len() <= 10  # At most 10 runs

    context "Flaky Test Detection":
        it "detects flaky tests with high variance":
            var db = create_test_database_extended(":memory:")

            # Add runs with high variance (flaky behavior)
            db.update_test_result("test/file.spl", "Suite", "Test", "passed", 10.0, "run_1")
            db.update_test_result("test/file.spl", "Suite", "Test", "passed", 100.0, "run_2")
            db.update_test_result("test/file.spl", "Suite", "Test", "passed", 15.0, "run_3")
            db.update_test_result("test/file.spl", "Suite", "Test", "passed", 95.0, "run_4")
            db.update_test_result("test/file.spl", "Suite", "Test", "passed", 20.0, "run_5")

            val test_id_opt = db.get_test_id("test/file.spl", "Suite", "Test")
            expect test_id_opt.?
            val test_id = test_id_opt?
            val is_flaky = db.is_flaky_test(test_id)

            expect is_flaky == true

        it "does not flag stable tests as flaky":
            var db = create_test_database_extended(":memory:")

            # Add runs with low variance (stable)
            db.update_test_result("test/file.spl", "Suite", "Test", "passed", 100.0, "run_1")
            db.update_test_result("test/file.spl", "Suite", "Test", "passed", 102.0, "run_2")
            db.update_test_result("test/file.spl", "Suite", "Test", "passed", 98.0, "run_3")
            db.update_test_result("test/file.spl", "Suite", "Test", "passed", 101.0, "run_4")

            val test_id_opt = db.get_test_id("test/file.spl", "Suite", "Test")
            expect test_id_opt.?
            val test_id = test_id_opt?
            val is_flaky = db.is_flaky_test(test_id)

            expect is_flaky == false

        it "requires minimum runs for flaky detection":
            var db = create_test_database_extended(":memory:")

            # Add only 2 runs (not enough for reliable detection)
            db.update_test_result("test/file.spl", "Suite", "Test", "passed", 10.0, "run_1")
            db.update_test_result("test/file.spl", "Suite", "Test", "passed", 100.0, "run_2")

            val test_id_opt = db.get_test_id("test/file.spl", "Suite", "Test")
            expect test_id_opt.?
            val test_id = test_id_opt?
            val is_flaky = db.is_flaky_test(test_id)

            # With only 2 runs, may not be flagged as flaky
            # (depends on implementation's minimum run threshold)

    context "Run Management":
        it "starts a new run":
            var db = create_test_database_extended(":memory:")
            val run_id = db.start_run()

            expect run_id.len() > 0
            expect run_id.contains("_")  # Timestamp format

        it "completes a run":
            var db = create_test_database_extended(":memory:")
            val run_id = db.start_run()

            db.complete_run(run_id, 10, 8, 2, 0)

            # Verify run was marked as completed
            # (would need a get_run() method to verify fully)

        it "cleans up stale runs":
            var db = create_test_database_extended(":memory:")

            # This test would require mocking time or waiting
            # For now, just verify method runs without error
            val cleaned = db.cleanup_stale_runs(2)
            expect cleaned >= 0

        it "prunes old runs":
            var db = create_test_database_extended(":memory:")

            # Create multiple runs
            for i in 0..10:
                val run_id = db.start_run()
                db.complete_run(run_id, 1, 1, 0, 0)

            # Prune to keep only 5
            val deleted = db.prune_runs(5)
            expect deleted >= 0

        it "lists runs":
            var db = create_test_database_extended(":memory:")

            # Create a few runs
            val run1 = db.start_run()
            val run2 = db.start_run()

            val runs = db.list_runs("")
            expect runs.len() >= 2

    context "Persistence":
        it "saves and loads database":
            val temp_path = "/tmp/test_db_extended_test.sdn"

            # Create and populate database
            var db = create_test_database_extended(temp_path)
            db.update_test_result("test/file.spl", "Suite", "Test", "passed", 100.0, "run_1")

            val saved = db.save()
            expect saved == true
            expect file_exists(temp_path)

            # Load database
            val loaded_opt = load_test_database_extended(temp_path)
            expect loaded_opt.?

            # Verify data persisted
            var loaded = loaded_opt?
            val test_id = loaded.get_test_id("test/file.spl", "Suite", "Test")
            expect test_id.?

            # Cleanup
            file_delete(temp_path)

        it "handles missing file on load":
            val loaded_opt = load_test_database_extended("/nonexistent/path.sdn")
            expect not loaded_opt.?

    context "Integration":
        it "tracks complete test lifecycle":
            var db = create_test_database_extended(":memory:")

            # Start run
            val run_id = db.start_run()

            # Add test results
            db.update_test_result("test/spec1.spl", "Suite A", "Test 1", "passed", 50.0, run_id)
            db.update_test_result("test/spec1.spl", "Suite A", "Test 2", "failed", 75.0, run_id)
            db.update_test_result("test/spec2.spl", "Suite B", "Test 3", "passed", 100.0, run_id)

            # Complete run
            db.complete_run(run_id, 3, 2, 1, 0)

            # Verify hierarchy
            expect db.get_file_id("test/spec1.spl").?
            expect db.get_file_id("test/spec2.spl").?
            expect db.get_suite_id("test/spec1.spl", "Suite A").?
            expect db.get_test_id("test/spec1.spl", "Suite A", "Test 1").?

            # Verify counters
            val test1_id_opt = db.get_test_id("test/spec1.spl", "Suite A", "Test 1")
            expect test1_id_opt.?
            val test1_id = test1_id_opt?
            val counter_opt = db.get_counter(test1_id)
            expect counter_opt.?
            val counter = counter_opt?
            expect counter.passed == 1

        it "handles multiple runs for same test":
            var db = create_test_database_extended(":memory:")

            # Run 1
            val run1 = db.start_run()
            db.update_test_result("test/spec.spl", "Suite", "Test", "passed", 100.0, run1)
            db.complete_run(run1, 1, 1, 0, 0)

            # Run 2
            val run2 = db.start_run()
            db.update_test_result("test/spec.spl", "Suite", "Test", "passed", 110.0, run2)
            db.complete_run(run2, 1, 1, 0, 0)

            # Run 3
            val run3 = db.start_run()
            db.update_test_result("test/spec.spl", "Suite", "Test", "failed", 120.0, run3)
            db.complete_run(run3, 1, 0, 1, 0)

            # Verify aggregated data
            val test_id_opt = db.get_test_id("test/spec.spl", "Suite", "Test")
            expect test_id_opt.?
            val test_id = test_id_opt?
            val counter_opt = db.get_counter(test_id)
            expect counter_opt.?
            val counter = counter_opt?
            expect counter.total_runs == 3
            expect counter.passed == 2
            expect counter.failed == 1

    context "Migration":
        it "migrates from dual-file to single-file":
            val stable_path = "/tmp/test_db_stable_migration.sdn"
            val volatile_path = "/tmp/test_db_runs_migration.sdn"
            val target_path = "/tmp/test_db_unified_migration.sdn"

            # Create stable database with files/suites/tests
            var stable_db = create_test_database_extended(stable_path)
            stable_db.update_test_result("test/file.spl", "Suite", "Test1", "passed", 100.0, "run_1")
            stable_db.update_test_result("test/file.spl", "Suite", "Test2", "passed", 200.0, "run_1")
            stable_db.save()

            # Create volatile database with counters/timing (simulate separate file)
            var volatile_db = create_test_database_extended(volatile_path)
            volatile_db.update_test_result("test/file.spl", "Suite", "Test1", "passed", 110.0, "run_2")
            volatile_db.save()

            # Migrate
            val success = migrate_from_dual_file(stable_path, volatile_path, target_path)
            expect success == true
            expect file_exists(target_path)

            # Verify migrated database
            val migrated_opt = load_test_database_extended(target_path)
            expect migrated_opt.?

            var migrated = migrated_opt?
            expect migrated.get_test_id("test/file.spl", "Suite", "Test1").?
            expect migrated.get_test_id("test/file.spl", "Suite", "Test2").?

            # Cleanup
            file_delete(stable_path)
            file_delete(volatile_path)
            file_delete(target_path)

        it "load_with_migration prefers unified file":
            val base_path = "/tmp/test_db_prefer_unified"
            val unified_path = "{base_path}.sdn"

            # Create unified database
            var db = create_test_database_extended(unified_path)
            db.update_test_result("test/file.spl", "Suite", "Test", "passed", 100.0, "run_1")
            db.save()

            # Load with migration (should use unified file)
            val loaded_opt = load_with_migration(base_path)
            expect loaded_opt.?

            var loaded = loaded_opt?
            expect loaded.get_test_id("test/file.spl", "Suite", "Test").?

            # Cleanup
            file_delete(unified_path)

        it "load_with_migration migrates dual-file":
            val base_path = "/tmp/test_db_auto_migrate"
            val stable_path = "{base_path}_stable.sdn"
            val volatile_path = "{base_path}_runs.sdn"
            val unified_path = "{base_path}.sdn"

            # Create dual-file databases
            var stable_db = create_test_database_extended(stable_path)
            stable_db.update_test_result("test/file.spl", "Suite", "Test", "passed", 100.0, "run_1")
            stable_db.save()

            var volatile_db = create_test_database_extended(volatile_path)
            volatile_db.save()

            # Load with migration (should auto-migrate)
            val loaded_opt = load_with_migration(base_path)
            expect loaded_opt.?
            expect file_exists(unified_path)  # Unified file created

            var loaded = loaded_opt?
            expect loaded.get_test_id("test/file.spl", "Suite", "Test").?

            # Cleanup
            file_delete(stable_path)
            file_delete(volatile_path)
            file_delete(unified_path)

        it "load_with_migration returns None for missing files":
            val loaded_opt = load_with_migration("/nonexistent/base")
            expect not loaded_opt.?
