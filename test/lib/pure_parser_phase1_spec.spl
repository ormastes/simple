# Pure Parser Phase 1.1 Tests
# Tests for foundation features: indentation, operators, methods, arrays

use lib.pure.parser (parse, parse_expr)
use lib.pure.ast (Expr, BinOp, Literal)

describe "Pure Parser Phase 1.1":
    it "parses simple arithmetic":
        val source = "1 + 2 * 3"
        val result = parse_expr(source)
        match result:
            case Ok(expr):
                expect(true).to_equal(true)
            case Err(e):
                expect(e.message).to_equal("")  # Force failure with error message

    it "parses power operator":
        val source = "2 ** 3 ** 4"  # Right-associative
        val result = parse_expr(source)
        match result:
            case Ok(expr):
                expect(true).to_equal(true)
            case Err(e):
                expect(e.message).to_equal("")

    it "parses pipeline operator":
        val source = "x |> f |> g"
        val result = parse_expr(source)
        match result:
            case Ok(expr):
                expect(true).to_equal(true)
            case Err(e):
                expect(e.message).to_equal("")

    it "parses coalesce operator":
        val source = "x ?? y ?? z"
        val result = parse_expr(source)
        match result:
            case Ok(expr):
                expect(true).to_equal(true)
            case Err(e):
                expect(e.message).to_equal("")

    it "parses logical operators":
        val source = "a && b || c"
        val result = parse_expr(source)
        match result:
            case Ok(expr):
                expect(true).to_equal(true)
            case Err(e):
                expect(e.message).to_equal("")

    it "parses bitwise operators":
        val source = "a & b | c ^ d"
        val result = parse_expr(source)
        match result:
            case Ok(expr):
                expect(true).to_equal(true)
            case Err(e):
                expect(e.message).to_equal("")

    it "parses field access":
        val source = "obj.field"
        val result = parse_expr(source)
        match result:
            case Ok(expr):
                match expr:
                    case Expr.Field(_, name):
                        expect(name).to_equal("field")
                    case _:
                        expect("wrong").to_equal("Field")
            case Err(e):
                expect(e.message).to_equal("")

    it "parses method call":
        val source = "obj.method(arg1, arg2)"
        val result = parse_expr(source)
        match result:
            case Ok(expr):
                match expr:
                    case Expr.Method(_, name, args):
                        expect(name).to_equal("method")
                        expect(args.len()).to_equal(2)
                    case _:
                        expect("wrong").to_equal("Method")
            case Err(e):
                expect(e.message).to_equal("")

    it "parses chained method calls":
        val source = "obj.method1().method2().field"
        val result = parse_expr(source)
        match result:
            case Ok(expr):
                expect(true).to_equal(true)
            case Err(e):
                expect(e.message).to_equal("")

    it "parses array literal":
        val source = "[1, 2, 3]"
        val result = parse_expr(source)
        match result:
            case Ok(expr):
                match expr:
                    case Expr.List(elems):
                        expect(elems.len()).to_equal(3)
                    case _:
                        expect("wrong").to_equal("List")
            case Err(e):
                expect(e.message).to_equal("")

    it "parses empty array":
        val source = "[]"
        val result = parse_expr(source)
        match result:
            case Ok(expr):
                match expr:
                    case Expr.List(elems):
                        expect(elems.len()).to_equal(0)
                    case _:
                        expect("wrong").to_equal("List")
            case Err(e):
                expect(e.message).to_equal("")

    it "parses array indexing":
        val source = "arr[0]"
        val result = parse_expr(source)
        match result:
            case Ok(expr):
                match expr:
                    case Expr.Index(_, _):
                        expect(true).to_equal(true)
                    case _:
                        expect("wrong").to_equal("Index")
            case Err(e):
                expect(e.message).to_equal("")

    it "parses array slicing":
        val source = "arr[1:5]"
        val result = parse_expr(source)
        match result:
            case Ok(expr):
                match expr:
                    case Expr.Slice(_, _, _, _):
                        expect(true).to_equal(true)
                    case _:
                        expect("wrong").to_equal("Slice")
            case Err(e):
                expect(e.message).to_equal("")

    it "parses slice with step":
        val source = "arr[::2]"
        val result = parse_expr(source)
        match result:
            case Ok(expr):
                match expr:
                    case Expr.Slice(_, _, _, _):
                        expect(true).to_equal(true)
                    case _:
                        expect("wrong").to_equal("Slice")
            case Err(e):
                expect(e.message).to_equal("")

    it "parses complex precedence":
        val source = "a + b * c ** d"
        val result = parse_expr(source)
        match result:
            case Ok(expr):
                # Should parse as: a + (b * (c ** d))
                expect(true).to_equal(true)
            case Err(e):
                expect(e.message).to_equal("")

    it "parses complex expression":
        val source = "data |> filter.apply(pred) |> map.transform(fn)"
        val result = parse_expr(source)
        match result:
            case Ok(expr):
                expect(true).to_equal(true)
            case Err(e):
                expect(e.message).to_equal("")
