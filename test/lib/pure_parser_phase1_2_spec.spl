# Pure Parser Phase 1.2 Tests
# Tests for: lambdas, string interpolation, import/export

use lib.pure.parser (parse_expr, parse_stmt)
use lib.pure.ast (Expr, Stmt)

describe "Pure Parser Phase 1.2":
    describe "Lambda Expressions":
        it "parses short lambda with one param":
            val result = parse_expr("\\x: x * 2")
            match result:
                case Ok(expr):
                    match expr:
                        case Expr.Lambda(params, _):
                            expect(params.len()).to_equal(1)
                            expect(params[0]).to_equal("x")
                        case _:
                            expect("wrong").to_equal("Lambda")
                case Err(e):
                    expect(e.message).to_equal("")

        it "parses short lambda with multiple params":
            val result = parse_expr("\\x, y: x + y")
            match result:
                case Ok(expr):
                    match expr:
                        case Expr.Lambda(params, _):
                            expect(params.len()).to_equal(2)
                            expect(params[0]).to_equal("x")
                            expect(params[1]).to_equal("y")
                        case _:
                            expect("wrong").to_equal("Lambda")
                case Err(e):
                    expect(e.message).to_equal("")

        it "parses long lambda with one param":
            val result = parse_expr("fn(x): x * 2")
            match result:
                case Ok(expr):
                    match expr:
                        case Expr.Lambda(params, _):
                            expect(params.len()).to_equal(1)
                            expect(params[0]).to_equal("x")
                        case _:
                            expect("wrong").to_equal("Lambda")
                case Err(e):
                    expect(e.message).to_equal("")

        it "parses long lambda with multiple params":
            val result = parse_expr("fn(x, y): x + y")
            match result:
                case Ok(expr):
                    match expr:
                        case Expr.Lambda(params, _):
                            expect(params.len()).to_equal(2)
                        case _:
                            expect("wrong").to_equal("Lambda")
                case Err(e):
                    expect(e.message).to_equal("")

        it "parses long lambda with no params":
            val result = parse_expr("fn(): 42")
            match result:
                case Ok(expr):
                    match expr:
                        case Expr.Lambda(params, _):
                            expect(params.len()).to_equal(0)
                        case _:
                            expect("wrong").to_equal("Lambda")
                case Err(e):
                    expect(e.message).to_equal("")

    describe "String Interpolation":
        it "parses plain string without interpolation":
            val result = parse_expr("\"Hello World\"")
            match result:
                case Ok(expr):
                    match expr:
                        case Expr.Literal(_):
                            expect(true).to_equal(true)
                        case _:
                            expect("wrong").to_equal("Literal")
                case Err(e):
                    expect(e.message).to_equal("")

        it "parses string with simple interpolation":
            val result = parse_expr("\"Hello {name}\"")
            match result:
                case Ok(expr):
                    match expr:
                        case Expr.StringInterpolation(parts):
                            expect(parts.len() > 0).to_equal(true)
                        case _:
                            expect("wrong").to_equal("StringInterpolation")
                case Err(e):
                    expect(e.message).to_equal("")

        it "parses string with expression interpolation":
            val result = parse_expr("\"Result: {x + 1}\"")
            match result:
                case Ok(expr):
                    match expr:
                        case Expr.StringInterpolation(parts):
                            expect(parts.len() > 0).to_equal(true)
                        case _:
                            expect("wrong").to_equal("StringInterpolation")
                case Err(e):
                    expect(e.message).to_equal("")

    describe "Import Statements":
        it "parses simple use statement":
            val result = parse_stmt("use module")
            match result:
                case Ok(stmt):
                    match stmt:
                        case Stmt.Import(path, names):
                            expect(path).to_equal("module")
                            expect(names.len()).to_equal(0)
                        case _:
                            expect("wrong").to_equal("Import")
                case Err(e):
                    expect(e.message).to_equal("")

        it "parses use with module path":
            val result = parse_stmt("use lib.pure.parser")
            match result:
                case Ok(stmt):
                    match stmt:
                        case Stmt.Import(path, names):
                            expect(path).to_equal("lib.pure.parser")
                        case _:
                            expect("wrong").to_equal("Import")
                case Err(e):
                    expect(e.message).to_equal("")

        it "parses use with names":
            val result = parse_stmt("use module.{name1, name2}")
            match result:
                case Ok(stmt):
                    match stmt:
                        case Stmt.Import(path, names):
                            expect(path).to_equal("module")
                            expect(names.len()).to_equal(2)
                        case _:
                            expect("wrong").to_equal("Import")
                case Err(e):
                    expect(e.message).to_equal("")

    describe "Export Statements":
        it "parses export with single name":
            val result = parse_stmt("export foo")
            match result:
                case Ok(stmt):
                    match stmt:
                        case Stmt.Export(names):
                            expect(names.len()).to_equal(1)
                            expect(names[0]).to_equal("foo")
                        case _:
                            expect("wrong").to_equal("Export")
                case Err(e):
                    expect(e.message).to_equal("")

        it "parses export with multiple names":
            val result = parse_stmt("export foo, bar, baz")
            match result:
                case Ok(stmt):
                    match stmt:
                        case Stmt.Export(names):
                            expect(names.len()).to_equal(3)
                        case _:
                            expect("wrong").to_equal("Export")
                case Err(e):
                    expect(e.message).to_equal("")
