# Unified Execution System Tests
# Tests the DAP adapter layer and unified execution framework
# Demonstrates transparent local/remote execution

use std.spec
use lib.execution.mod.{ExecutionConfig, TestExecutor, parse_target}
use lib.qemu.test_session.{QemuTestSession, QemuMultiTestRunner}
use lib.qemu.mod.QemuArch
use app.dap.adapter.mod.{DebugAdapter, AdapterConfig, AdapterCapabilities}
use app.dap.adapter.local.LocalAdapter
use app.dap.adapter.gdb_mi.GdbMiAdapter

# ===========================================================================
# Adapter Layer Tests
# ===========================================================================

describe "Debug Adapter Layer":
    it "creates local adapter from config":
        val config = AdapterConfig.local("test.spl")
        val adapter = LocalAdapter.create(config)

        expect(adapter.name()).to_equal("local-interpreter")
        expect(adapter.is_attached()).to_be(false)

    it "local adapter has correct capabilities":
        val config = AdapterConfig.local("test.spl")
        val adapter = LocalAdapter.create(config)
        val caps = adapter.get_capabilities()

        expect(caps.can_reset).to_be(true)
        expect(caps.can_reload).to_be(true)
        expect(caps.can_clear_context).to_be(true)
        expect(caps.supports_memory).to_be(false)
        expect(caps.supports_registers).to_be(false)

    skip "creates GDB MI adapter from config":
        # Requires running QEMU instance
        val config = AdapterConfig.gdb("localhost", 1234, "test.elf")
        val adapter_result = GdbMiAdapter.connect(config)

        match adapter_result:
            Ok(adapter):
                expect(adapter.name()).to_equal("gdb-mi")
                expect(adapter.is_attached()).to_be(true)
            Err(e):
                # Expected to fail without QEMU running
                expect(e.contains("failed")).to_be(true)

    it "GDB adapter has correct capabilities":
        # Test capability structure without connection
        val caps = AdapterCapabilities.basic()
            .with_reset()
            .with_memory()
            .with_registers()

        expect(caps.can_reset).to_be(true)
        expect(caps.supports_memory).to_be(true)
        expect(caps.supports_registers).to_be(true)
        expect(caps.can_clear_context).to_be(false)

# ===========================================================================
# Execution Config Tests
# ===========================================================================

describe "Execution Configuration":
    it "creates local execution config":
        val config = ExecutionConfig.local("test.spl")

        expect(config.target).to_equal("local")
        expect(config.program).to_equal("test.spl")
        expect(config.is_local()).to_be(true)
        expect(config.is_remote()).to_be(false)
        expect(config.clear_context).to_be(true)

    it "creates QEMU RISC-V 32 config":
        val config = ExecutionConfig.qemu_riscv32("test.elf", 1234)

        expect(config.target).to_equal("riscv32-qemu")
        expect(config.program).to_equal("test.elf")
        expect(config.host).to_equal("localhost")
        expect(config.port).to_equal(1234)
        expect(config.is_remote()).to_be(true)
        expect(config.uses_gdb()).to_be(true)
        expect(config.reload_program).to_be(true)

    it "creates QEMU x86_64 config":
        val config = ExecutionConfig.qemu_x86_64("test.elf", 5678)

        expect(config.target).to_equal("x86_64-qemu")
        expect(config.port).to_equal(5678)
        expect(config.uses_gdb()).to_be(true)

    it "parses local target string":
        val config_result = parse_target("local", "test.spl")

        match config_result:
            Ok(config):
                expect(config.target).to_equal("local")
                expect(config.program).to_equal("test.spl")
            Err(e):
                fail_assertion("should parse local target: {e}")

    it "parses riscv32-qemu target string":
        val config_result = parse_target("riscv32-qemu", "test.elf")

        match config_result:
            Ok(config):
                expect(config.target).to_equal("riscv32-qemu")
                expect(config.program).to_equal("test.elf")
                expect(config.port).to_equal(1234)
            Err(e):
                fail_assertion("should parse riscv32-qemu target: {e}")

    it "parses custom target with port":
        val config_result = parse_target("riscv32-qemu:localhost:5555", "test.elf")

        match config_result:
            Ok(config):
                expect(config.target).to_equal("riscv32-qemu")
                expect(config.host).to_equal("localhost")
                expect(config.port).to_equal(5555)
            Err(e):
                fail_assertion("should parse custom target: {e}")

# ===========================================================================
# Test Executor Tests
# ===========================================================================

describe "Test Executor":
    it "creates executor for local target":
        val config = ExecutionConfig.local("test.spl")
        val executor_result = TestExecutor.create(config)

        match executor_result:
            Ok(executor):
                expect(executor.initialized).to_be(true)
            Err(e):
                fail_assertion("should create local executor: {e}")

    skip "creates executor for QEMU target":
        # Requires QEMU running
        val config = ExecutionConfig.qemu_riscv32("test.elf", 1234)
        val executor_result = TestExecutor.create(config)

        match executor_result:
            Ok(executor):
                expect(executor.initialized).to_be(true)
            Err(e):
                # Expected to fail without QEMU
                expect(e.contains("failed") or e.contains("connect")).to_be(true)

# ===========================================================================
# QEMU Test Session Tests
# ===========================================================================

describe "QEMU Test Session":
    it "creates test session":
        val session = QemuTestSession.create(QemuArch.RiscV32, "test.elf")

        expect(session.arch).to_equal(QemuArch.RiscV32)
        expect(session.binary_path).to_equal("test.elf")
        expect(session.running).to_be(false)
        expect(session.auto_reset).to_be(true)

    it "configures session with custom GDB port":
        val session = QemuTestSession.create(QemuArch.RiscV32, "test.elf")
            .with_gdb_port(5555)

        expect(session.gdb_port).to_equal(5555)

    it "configures session with auto-reset disabled":
        val session = QemuTestSession.create(QemuArch.RiscV32, "test.elf")
            .with_auto_reset(false)

        expect(session.auto_reset).to_be(false)

    skip "starts and stops QEMU session":
        # Requires QEMU binary and test.elf
        val session = QemuTestSession.create(QemuArch.RiscV32, "examples/baremetal/timer_riscv32.elf")

        # Start session
        val start_result = session.start()
        match start_result:
            Ok(msg):
                expect(msg.contains("started")).to_be(true)
                expect(session.running).to_be(true)

                # Stop session
                session.stop()
                expect(session.running).to_be(false)
            Err(e):
                # Expected to fail if binary doesn't exist
                expect(e.contains("not found") or e.contains("failed")).to_be(true)

# ===========================================================================
# Multi-Test Runner Tests
# ===========================================================================

describe "QEMU Multi-Test Runner":
    it "creates multi-test runner":
        val runner = QemuMultiTestRunner.create(QemuArch.RiscV32, "test.elf")

        expect(runner.tests.len()).to_equal(0)
        expect(runner.results.len()).to_equal(0)

    it "adds tests to runner":
        var runner = QemuMultiTestRunner.create(QemuArch.RiscV32, "test.elf")

        runner.add_test(\: Ok("test 1"))
        runner.add_test(\: Ok("test 2"))

        expect(runner.tests.len()).to_equal(2)

    skip "runs multiple tests with single QEMU instance":
        # Requires QEMU and test binary
        var runner = QemuMultiTestRunner.create(
            QemuArch.RiscV32,
            "examples/baremetal/timer_riscv32.elf"
        )

        # Add test functions
        runner.add_test(\: Ok("test 1 passed"))
        runner.add_test(\: Ok("test 2 passed"))

        # Run all tests
        val results = runner.run_all()
        match results:
            Ok(res):
                expect(res.len()).to_equal(2)
                expect(runner.passed_count()).to_equal(2)
                expect(runner.failed_count()).to_equal(0)
            Err(e):
                # Expected to fail without QEMU/binary
                expect(e.contains("not found") or e.contains("failed")).to_be(true)

# ===========================================================================
# Integration Tests
# ===========================================================================

describe "Unified Execution Integration":
    it "transparent execution - local":
        # Create config for local execution
        val config = ExecutionConfig.local("test.spl")
        val executor_result = TestExecutor.create(config)

        match executor_result:
            Ok(executor):
                # Execute (will use LocalAdapter internally)
                # Note: actual execution would need test.spl to exist
                expect(executor.initialized).to_be(true)
                executor.cleanup()
            Err(e):
                fail_assertion("local executor should initialize: {e}")

    skip "transparent execution - remote QEMU":
        # Same API, different config - routes to GDB adapter
        val config = ExecutionConfig.qemu_riscv32("test.elf", 1234)
        val executor_result = TestExecutor.create(config)

        match executor_result:
            Ok(executor):
                # Execute (will use GdbMiAdapter internally)
                expect(executor.initialized).to_be(true)
                executor.cleanup()
            Err(e):
                # Expected to fail without QEMU
                pass

# ===========================================================================
# Example Usage Documentation
# ===========================================================================

# Example 1: Run test locally
fn example_run_local():
    val config = ExecutionConfig.local("my_test.spl")
    val executor = TestExecutor.create(config)?
    val result = executor.execute()?
    executor.cleanup()
    Ok(result)

# Example 2: Run same test on QEMU
fn example_run_qemu():
    val config = ExecutionConfig.qemu_riscv32("my_test.elf", 1234)
    val executor = TestExecutor.create(config)?
    val result = executor.execute()?
    executor.cleanup()
    Ok(result)

# Example 3: Run multiple tests with lifecycle management
fn example_multi_test():
    var runner = QemuMultiTestRunner.create(QemuArch.RiscV32, "test.elf")

    runner.add_test(\: test_boot())
    runner.add_test(\: test_memory())
    runner.add_test(\: test_interrupts())

    val results = runner.run_all()?
    print("Tests passed: {runner.passed_count()}/{runner.tests.len()}")
    Ok(results)

# Example 4: Session with manual control
fn example_manual_session():
    val session = QemuTestSession.create(QemuArch.RiscV32, "test.elf")
        .with_gdb_port(1234)
        .with_auto_reset(true)

    session.start()?

    # Run test 1
    session.run_test(\: test_basic())?

    # Reset and run test 2
    session.reset()?
    session.run_test(\: test_advanced())?

    session.stop()
    Ok("tests completed")
