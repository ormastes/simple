#!/usr/bin/env simple
# Integration tests for skip/ignore system - demonstrates real-world usage

use std.spec.*
use std.spec.decorators.*
use std.spec.env_detect.*

describe "Skip/Ignore Integration Tests":
    describe "Platform-specific tests":
        it "demonstrates platform detection in action":
            val current_os = get_platform_os()
            print "  Current platform: {current_os}"

            if is_windows():
                print "  Running on Windows"

            if is_linux():
                print "  Running on Linux"

            if is_macos():
                print "  Running on macOS"

            check(current_os != "")

        it "demonstrates Unix vs Windows distinction":
            if is_unix():
                print "  Unix-like system detected"
                check(has_permissions() == true)
            else:
                print "  Windows system detected"
                check(is_windows() == true)

    describe "Runtime mode detection":
        it "identifies current runtime mode":
            val mode = get_runtime_mode()
            print "  Runtime mode: {mode}"

            if is_interpreter():
                print "  Interpreter mode active"

            if is_compiled():
                print "  Compiled mode active"

            check(mode != "")

    describe "Architecture detection":
        it "identifies CPU architecture":
            val arch = get_architecture()
            val bits = get_pointer_size()
            print "  Architecture: {arch} ({bits}-bit)"

            if is_x86_64():
                print "  x86_64 architecture"
                check(bits == 64)

            if is_aarch64():
                print "  ARM64 architecture"
                check(bits == 64)

    describe "Hardware capabilities":
        it "checks available hardware":
            val cores = get_cpu_cores()
            print "  CPU cores: {cores}"

            if has_gpu():
                print "  GPU detected"

            if has_cuda():
                print "  CUDA available"

            if has_simd():
                print "  SIMD instructions available"

            if has_avx2():
                print "  AVX2 instructions available"

            check(cores > 0)

    describe "Complete environment profile":
        it "prints complete environment information":
            print "  === Environment Profile ==="
            print "  Platform: {get_platform_os()}"
            print "  Runtime: {get_runtime_mode()}"
            print "  Profile: {get_build_profile()}"
            print "  Architecture: {get_architecture()}"
            print "  Pointer size: {get_pointer_size()}-bit"
            print "  CPU cores: {get_cpu_cores()}"
            print "  Unix: {is_unix()}"
            print "  Has symlinks: {has_symlinks()}"
            print "  Has permissions: {has_permissions()}"
            print "  Case sensitive: {is_case_sensitive()}"
            print "  =========================="
            check(true)

    describe "Real-world skip patterns":
        it "example: skip on Windows (will implement later)":
            val skip_win = skip(
                platforms: ["windows"],
                runtimes: [],
                profiles: [],
                architectures: [],
                features: [],
                version: "",
                hardware: [],
                requires: [],
                env_vars: {},
                fs_features: [],
                network: false,
                tags: [],
                reason: "chmod() not yet implemented on Windows"
            )

            # In real usage:
            # skip_win("Unix permissions test", fn():
            #     chmod("/tmp/file", 0o644)
            # )

            check(skip_win != nil)

        it "example: skip in interpreter mode":
            val skip_interp = skip(
                platforms: [],
                runtimes: ["interpreter"],
                profiles: [],
                architectures: [],
                features: [],
                version: "",
                hardware: [],
                requires: [],
                env_vars: {},
                fs_features: [],
                network: false,
                tags: [],
                reason: "Generics require static compilation"
            )

            check(skip_interp != nil)

        it "example: skip without GPU":
            val skip_no_gpu = skip(
                platforms: [],
                runtimes: [],
                profiles: [],
                architectures: [],
                features: [],
                version: "",
                hardware: ["gpu"],
                requires: [],
                env_vars: {},
                fs_features: [],
                network: false,
                tags: [],
                reason: "GPU acceleration required"
            )

            check(skip_no_gpu != nil)

    describe "Real-world ignore patterns":
        it "example: ignore Unix fork on Windows":
            val ignore_win = ignore(
                platforms: ["windows"],
                runtimes: [],
                profiles: [],
                architectures: [],
                features: [],
                version: "",
                hardware: [],
                requires: [],
                env_vars: {},
                fs_features: [],
                network: false,
                tags: [],
                reason: "fork() is Unix-only, no Windows equivalent"
            )

            # In real usage:
            # ignore_win("process fork test", fn():
            #     pid = fork()
            #     check(pid > 0)
            # )

            check(ignore_win != nil)

        it "example: ignore 32-bit architecture":
            val ignore_32bit = ignore(
                platforms: [],
                runtimes: [],
                profiles: [],
                architectures: ["x86", "arm32"],
                features: [],
                version: "",
                hardware: [],
                requires: [],
                env_vars: {},
                fs_features: [],
                network: false,
                tags: [],
                reason: "64-bit pointers required, no 32-bit support planned"
            )

            check(ignore_32bit != nil)

    describe "Simplified decorator usage":
        it "example: using skip_on_windows":
            val skip_win = skip_on_windows("Not yet ported")

            # Much simpler than full skip() call!
            # skip_win("Windows-specific test", fn():
            #     test_body()
            # )

            check(skip_win != nil)

        it "example: using skip_on_interpreter":
            val skip_interp = skip_on_interpreter("Requires compiled mode")

            check(skip_interp != nil)

        it "example: using ignore_on_windows":
            val ignore_win = ignore_on_windows("Unix-only API")

            check(ignore_win != nil)

    describe "Complex multi-condition examples":
        it "example: CI-only network test":
            val skip_no_ci = skip(
                platforms: [],
                runtimes: [],
                profiles: [],
                architectures: [],
                features: [],
                version: "",
                hardware: [],
                requires: [],
                env_vars: {"CI": "true"},
                fs_features: [],
                network: true,
                tags: ["network", "integration"],
                reason: "Network test only in CI environment"
            )

            check(skip_no_ci != nil)

        it "example: Windows interpreter skip":
            val skip_win_interp = skip(
                platforms: ["windows"],
                runtimes: ["interpreter"],
                profiles: [],
                architectures: [],
                features: [],
                version: "",
                hardware: [],
                requires: [],
                env_vars: {},
                fs_features: [],
                network: false,
                tags: [],
                reason: "Windows interpreter mode not fully supported yet"
            )

            check(skip_win_interp != nil)

        it "example: GPU + CUDA required":
            val skip_no_cuda = skip(
                platforms: [],
                runtimes: [],
                profiles: [],
                architectures: [],
                features: [],
                version: "",
                hardware: ["gpu", "cuda"],
                requires: [],
                env_vars: {},
                fs_features: [],
                network: false,
                tags: ["gpu", "cuda"],
                reason: "CUDA GPU required for kernel test"
            )

            check(skip_no_cuda != nil)

    describe "Conditional skip with skip_if":
        it "example: skip if no CI environment":
            val skip_no_ci = skip_if(
                fn(): get_env("CI") == "",
                "CI environment required"
            )

            check(skip_no_ci != nil)

        it "example: skip if file doesn't exist":
            val skip_no_file = skip_if(
                fn():
                    # In real code, would check file_exists()
                    false,
                "Required file not found"
            )

            check(skip_no_file != nil)

        it "example: skip on complex condition":
            val skip_complex = skip_if(
                fn():
                    val is_win = is_windows()
                    val is_32 = is_32bit()
                    val is_debug = is_debug()
                    is_win and is_32 and is_debug,
                "Not supported on Windows 32-bit debug builds"
            )

            check(skip_complex != nil)

    describe "only_on usage":
        it "example: Linux-only test":
            val only_linux = only_on(
                platforms: ["linux"],
                runtimes: [],
                profiles: [],
                architectures: [],
                features: [],
                version: "",
                hardware: [],
                requires: [],
                env_vars: {},
                fs_features: [],
                network: false,
                tags: []
            )

            check(only_linux != nil)

        it "example: Unix-only test":
            val only_unix = only_on(
                platforms: ["unix"],
                runtimes: [],
                profiles: [],
                architectures: [],
                features: [],
                version: "",
                hardware: [],
                requires: [],
                env_vars: {},
                fs_features: [],
                network: false,
                tags: []
            )

            check(only_unix != nil)

        it "example: compiled mode only":
            val only_compiled = only_on(
                platforms: [],
                runtimes: ["compiled", "jit"],
                profiles: [],
                architectures: [],
                features: [],
                version: "",
                hardware: [],
                requires: [],
                env_vars: {},
                fs_features: [],
                network: false,
                tags: []
            )

            check(only_compiled != nil)

    describe "Performance with multiple decorators":
        it "creates 10 different decorators quickly":
            var i = 0
            while i < 10:
                val decorator = skip(
                    platforms: ["windows"],
                    runtimes: [],
                    profiles: [],
                    architectures: [],
                    features: [],
                    version: "",
                    hardware: [],
                    requires: [],
                    env_vars: {},
                    fs_features: [],
                    network: false,
                    tags: [],
                    reason: "Test {i}"
                )
                check(decorator != nil)
                i = i + 1

    describe "Documentation examples":
        it "README example: platform-specific skip":
            val skip_win = skip(
                platforms: ["windows"],
                runtimes: [],
                profiles: [],
                architectures: [],
                features: [],
                version: "",
                hardware: [],
                requires: [],
                env_vars: {},
                fs_features: [],
                network: false,
                tags: [],
                reason: "chmod() not available on Windows"
            )
            check(skip_win != nil)

        it "README example: hardware requirement":
            val skip_no_gpu = skip(
                platforms: [],
                runtimes: [],
                profiles: [],
                architectures: [],
                features: [],
                version: "",
                hardware: ["gpu"],
                requires: [],
                env_vars: {},
                fs_features: [],
                network: false,
                tags: [],
                reason: "GPU required for neural network test"
            )
            check(skip_no_gpu != nil)

        it "README example: ignore fundamentally unsupported":
            val ignore_win = ignore(
                platforms: ["windows"],
                runtimes: [],
                profiles: [],
                architectures: [],
                features: [],
                version: "",
                hardware: [],
                requires: [],
                env_vars: {},
                fs_features: [],
                network: false,
                tags: [],
                reason: "Unix fork() API - no Windows equivalent exists"
            )
            check(ignore_win != nil)
