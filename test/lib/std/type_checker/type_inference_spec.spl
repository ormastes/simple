# @skip - type inference syntax issues (mixin pattern)
# SSpec Test: Type Inference Engine (Intensive Coverage)
# Feature: Core type inference and unification
# Coverage Target: 100% line + branch coverage

import std.type_checker.type_inference.{Type, TypeUnifier, TypeChecker, MixinInfo, MixinResolver, DispatchMode}

feature "Type Representation":
    """Test all Type enum variants and to_string()"""

    it "represents primitive types correctly":
        assert Type.Int.to_string() == "Int"
        assert Type.Bool.to_string() == "Bool"
        assert Type.Str.to_string() == "Str"
        assert Type.Float.to_string() == "Float"
        assert Type.Unit.to_string() == "Unit"

    it "represents type variables":
        val tv = Type.Var(42)
        assert tv.to_string() == "T42"

    it "represents function types":
        val fn_type = Type.Function(
            params: [Type.Int, Type.Str],
            ret: Type.Bool
        )
        assert fn_type.to_string() == "fn(Int, Str) -> Bool"

    it "represents generic types":
        val generic = Type.Generic(
            name: "List",
            args: [Type.Int]
        )
        assert generic.to_string() == "List<Int>"

    it "represents dyn trait types":
        val dyn_trait = Type.DynTrait("Show")
        assert dyn_trait.to_string() == "dyn Show"

    it "represents tuple types":
        val tuple = Type.Tuple([Type.Int, Type.Str, Type.Bool])
        assert tuple.to_string() == "(Int, Str, Bool)"

    it "represents array types":
        val array = Type.Array(Type.Int)
        assert array.to_string() == "[Int]"

    it "represents optional types":
        val opt = Type.Optional(Type.Str)
        assert opt.to_string() == "Option<Str>"

feature "Type Unification - Basic Cases":
    """Test basic unification rules"""

    it "unifies identical primitive types":
        var unifier = TypeUnifier.new()
        val result = unifier.unify(Type.Int, Type.Int)
        assert result.is_ok()

    it "fails to unify different primitive types":
        var unifier = TypeUnifier.new()
        val result = unifier.unify(Type.Int, Type.Bool)
        assert result.is_err()

    it "unifies type variable with concrete type":
        var unifier = TypeUnifier.new()
        val tv = Type.Var(0)
        val result = unifier.unify(tv, Type.Int)
        assert result.is_ok()
        assert unifier.resolve(tv) == Type.Int

    it "unifies two type variables":
        var unifier = TypeUnifier.new()
        val tv1 = Type.Var(0)
        val tv2 = Type.Var(1)
        val result = unifier.unify(tv1, tv2)
        assert result.is_ok()

    it "follows substitution chains":
        var unifier = TypeUnifier.new()
        val tv1 = Type.Var(0)
        val tv2 = Type.Var(1)
        unifier.unify(tv1, tv2).unwrap()
        unifier.unify(tv2, Type.Int).unwrap()
        assert unifier.resolve(tv1) == Type.Int

feature "Type Unification - Occurs Check":
    """Test occurs check prevents infinite types"""

    it "detects direct occurs check violation":
        var unifier = TypeUnifier.new()
        val tv = Type.Var(0)
        val array_of_tv = Type.Array(tv)
        val result = unifier.unify(tv, array_of_tv)
        assert result.is_err()
        assert result.unwrap_err().contains("Occurs check failed")

    it "detects occurs check in function types":
        var unifier = TypeUnifier.new()
        val tv = Type.Var(0)
        val fn_type = Type.Function(params: [tv], ret: Type.Int)
        val result = unifier.unify(tv, fn_type)
        assert result.is_err()

    it "detects occurs check in nested structures":
        var unifier = TypeUnifier.new()
        val tv = Type.Var(0)
        val nested = Type.Optional(Type.Array(tv))
        val result = unifier.unify(tv, nested)
        assert result.is_err()

feature "Type Unification - DynTrait (Feature #2301)":
    """Test DynTrait unification rules"""

    it "unifies same dyn trait types":
        var unifier = TypeUnifier.new()
        val dt1 = Type.DynTrait("Show")
        val dt2 = Type.DynTrait("Show")
        val result = unifier.unify(dt1, dt2)
        assert result.is_ok()

    it "fails to unify different dyn trait types":
        var unifier = TypeUnifier.new()
        val dt1 = Type.DynTrait("Show")
        val dt2 = Type.DynTrait("Debug")
        val result = unifier.unify(dt1, dt2)
        assert result.is_err()
        assert result.unwrap_err().contains("Cannot unify dyn Show with dyn Debug")

    it "fails to unify dyn trait with concrete type":
        var unifier = TypeUnifier.new()
        val dt = Type.DynTrait("Show")
        val result = unifier.unify(dt, Type.Int)
        assert result.is_err()
        assert result.unwrap_err().contains("Cannot unify dyn Show with concrete type")

    it "fails to unify concrete type with dyn trait":
        var unifier = TypeUnifier.new()
        val dt = Type.DynTrait("Show")
        val result = unifier.unify(Type.Int, dt)
        assert result.is_err()
        assert result.unwrap_err().contains("Cannot unify concrete type with dyn Show")

    it "unifies dyn trait in array types":
        var unifier = TypeUnifier.new()
        val arr1 = Type.Array(Type.DynTrait("Show"))
        val arr2 = Type.Array(Type.DynTrait("Show"))
        val result = unifier.unify(arr1, arr2)
        assert result.is_ok()

    it "unifies dyn trait in optional types":
        var unifier = TypeUnifier.new()
        val opt1 = Type.Optional(Type.DynTrait("Logger"))
        val opt2 = Type.Optional(Type.DynTrait("Logger"))
        val result = unifier.unify(opt1, opt2)
        assert result.is_ok()

feature "Type Unification - Complex Types":
    """Test unification of complex type structures"""

    it "unifies function types with matching signatures":
        var unifier = TypeUnifier.new()
        val fn1 = Type.Function(params: [Type.Int, Type.Str], ret: Type.Bool)
        val fn2 = Type.Function(params: [Type.Int, Type.Str], ret: Type.Bool)
        val result = unifier.unify(fn1, fn2)
        assert result.is_ok()

    it "fails to unify functions with different arity":
        var unifier = TypeUnifier.new()
        val fn1 = Type.Function(params: [Type.Int], ret: Type.Bool)
        val fn2 = Type.Function(params: [Type.Int, Type.Str], ret: Type.Bool)
        val result = unifier.unify(fn1, fn2)
        assert result.is_err()
        assert result.unwrap_err().contains("arity mismatch")

    it "unifies generic types with same name and args":
        var unifier = TypeUnifier.new()
        val gen1 = Type.Generic(name: "List", args: [Type.Int])
        val gen2 = Type.Generic(name: "List", args: [Type.Int])
        val result = unifier.unify(gen1, gen2)
        assert result.is_ok()

    it "fails to unify generics with different names":
        var unifier = TypeUnifier.new()
        val gen1 = Type.Generic(name: "List", args: [Type.Int])
        val gen2 = Type.Generic(name: "Vec", args: [Type.Int])
        val result = unifier.unify(gen1, gen2)
        assert result.is_err()

    it "unifies tuple types with same structure":
        var unifier = TypeUnifier.new()
        val tup1 = Type.Tuple([Type.Int, Type.Str])
        val tup2 = Type.Tuple([Type.Int, Type.Str])
        val result = unifier.unify(tup1, tup2)
        assert result.is_ok()

    it "fails to unify tuples with different arity":
        var unifier = TypeUnifier.new()
        val tup1 = Type.Tuple([Type.Int, Type.Str])
        val tup2 = Type.Tuple([Type.Int])
        val result = unifier.unify(tup1, tup2)
        assert result.is_err()

feature "Transitive Mixin Resolution (Feature #2201)":
    """Test BFS-based transitive mixin dependency resolution"""

    fn create_base_mixin() -> MixinInfo:
        var mixin_val = MixinInfo.new("Base")
        mixin_val.fields.push(("id", Type.Int))
        mixin_val

    fn create_timestamped_mixin() -> MixinInfo:
        var mixin = MixinInfo.new("Timestamped")
        mixin.fields.push(("created_at", Type.Int))
        mixin.fields.push(("updated_at", Type.Int))
        mixin.required_mixins.push("Base")
        mixin

    fn create_versioned_mixin() -> MixinInfo:
        var mixin = MixinInfo.new("Versioned")
        mixin.fields.push(("version", Type.Int))
        mixin.required_mixins.push("Timestamped")
        mixin

    it "resolves empty mixin list":
        val resolver = MixinResolver.new()
        val result = resolver.resolve_transitive([])
        assert result.is_empty()

    it "resolves single mixin with no dependencies":
        var resolver = MixinResolver.new()
        resolver.register_mixin(create_base_mixin())
        val result = resolver.resolve_transitive(["Base"])
        assert result.len() == 1
        assert result.contains("Base")

    it "resolves two-level transitive dependencies":
        var resolver = MixinResolver.new()
        resolver.register_mixin(create_base_mixin())
        resolver.register_mixin(create_timestamped_mixin())
        val result = resolver.resolve_transitive(["Timestamped"])
        assert result.len() == 2
        assert result.contains("Base")
        assert result.contains("Timestamped")

    it "resolves three-level transitive dependencies":
        var resolver = MixinResolver.new()
        resolver.register_mixin(create_base_mixin())
        resolver.register_mixin(create_timestamped_mixin())
        resolver.register_mixin(create_versioned_mixin())
        val result = resolver.resolve_transitive(["Versioned"])
        assert result.len() == 3
        assert result.contains("Base")
        assert result.contains("Timestamped")
        assert result.contains("Versioned")

    it "deduplicates diamond dependencies":
        var resolver = MixinResolver.new()

        # Create diamond: Combined -> Left -> Base, Combined -> Right -> Base
        val base = create_base_mixin()

        var left = MixinInfo.new("Left")
        left.fields.push(("left_field", Type.Int))
        left.required_mixins.push("Base")

        var right = MixinInfo.new("Right")
        right.fields.push(("right_field", Type.Str))
        right.required_mixins.push("Base")

        var combined = MixinInfo.new("Combined")
        combined.required_mixins.push("Left")
        combined.required_mixins.push("Right")

        resolver.register_mixin(base)
        resolver.register_mixin(left)
        resolver.register_mixin(right)
        resolver.register_mixin(combined)

        val result = resolver.resolve_transitive(["Combined"])

        # Base should appear exactly once (diamond dedup)
        val base_count = result.filter(\name: name == "Base").len()
        assert base_count == 1
        assert result.len() == 4  # Base, Left, Right, Combined

    it "returns empty for non-existent mixin":
        val resolver = MixinResolver.new()
        val result = resolver.resolve_transitive(["NonExistent"])
        assert result.is_empty()

    it "handles partial non-existent mixins":
        var resolver = MixinResolver.new()
        resolver.register_mixin(create_base_mixin())
        val result = resolver.resolve_transitive(["Base", "NonExistent"])
        assert result.len() == 1
        assert result.contains("Base")

feature "Mixin Field Collection":
    """Test field collection from transitively resolved mixins"""

    it "collects fields from single mixin":
        var resolver = MixinResolver.new()
        var mixin = MixinInfo.new("Test")
        mixin.fields.push(("field1", Type.Int))
        mixin.fields.push(("field2", Type.Str))
        resolver.register_mixin(mixin)

        val fields = resolver.get_all_fields("TestClass", ["Test"])
        assert fields.len() == 2

    it "collects fields from transitive mixins":
        var resolver = MixinResolver.new()
        resolver.register_mixin(create_base_mixin())
        resolver.register_mixin(create_timestamped_mixin())

        val fields = resolver.get_all_fields("Article", ["Timestamped"])
        assert fields.len() == 3  # id, created_at, updated_at

    it "deduplicates field names":
        var resolver = MixinResolver.new()

        var mixin1 = MixinInfo.new("Mixin1")
        mixin1.fields.push(("shared_field", Type.Int))

        var mixin2 = MixinInfo.new("Mixin2")
        mixin2.fields.push(("shared_field", Type.Int))

        resolver.register_mixin(mixin1)
        resolver.register_mixin(mixin2)

        val fields = resolver.get_all_fields("Combined", ["Mixin1", "Mixin2"])

        # shared_field should appear once
        val shared_count = fields.filter(\(name, _): name == "shared_field").len()
        assert shared_count == 1

feature "Type Checker Integration":
    """Test full TypeChecker with inference, mixins, and dyn traits"""

    it "creates fresh type variables":
        var checker = TypeChecker.new()
        val tv1 = checker.fresh_var()
        val tv2 = checker.fresh_var()

        match (tv1, tv2):
            (Type.Var(id1), Type.Var(id2)) ->
                assert id1 != id2  # Different IDs
            _ -> assert false

    it "resolves trait type without binding to dyn trait":
        var checker = TypeChecker.new()
        val resolved = checker.resolve_trait_type("Show")
        assert resolved == Type.DynTrait("Show")

    it "resolves trait type with binding to concrete type":
        var checker = TypeChecker.new()
        checker.bind_interface("Show", Type.Int)
        val resolved = checker.resolve_trait_type("Show")
        assert resolved == Type.Int

    it "determines static dispatch mode with binding":
        var checker = TypeChecker.new()
        checker.bind_interface("Serializer", Type.Generic(name: "JsonSerializer", args: []))
        val mode = checker.get_dispatch_mode("Serializer")
        assert mode == DispatchMode.Static

    it "determines dynamic dispatch mode without binding":
        var checker = TypeChecker.new()
        val mode = checker.get_dispatch_mode("Serializer")
        assert mode == DispatchMode.Dynamic

    it "checks coercion to dyn trait with impl":
        var checker = TypeChecker.new()
        val concrete = Type.Generic(name: "Point", args: [])
        checker.register_trait_impl("Show", concrete)

        val can_coerce = checker.can_coerce_to_dyn_trait(concrete, "Show")
        assert can_coerce

    it "rejects coercion to dyn trait without impl":
        var checker = TypeChecker.new()
        val concrete = Type.Generic(name: "Point", args: [])

        val can_coerce = checker.can_coerce_to_dyn_trait(concrete, "Show")
        assert not can_coerce

    it "registers and resolves transitive mixins":
        var checker = TypeChecker.new()

        var base = MixinInfo.new("Base")
        base.fields.push(("id", Type.Int))

        var timestamped = MixinInfo.new("Timestamped")
        timestamped.fields.push(("created_at", Type.Int))
        timestamped.required_mixins.push("Base")

        checker.register_mixin(base)
        checker.register_mixin(timestamped)

        val resolved = checker.resolve_transitive_mixins(["Timestamped"])
        assert resolved.len() == 2
        assert resolved.contains("Base")
        assert resolved.contains("Timestamped")

feature "Verification Properties":
    """Test properties that will generate Lean theorems"""

    it "unification is symmetric":
        var checker = TypeChecker.new()
        val t1 = Type.Int
        val t2 = Type.Int

        val r1 = checker.unify(t1, t2)
        val r2 = checker.unify(t2, t1)

        assert r1.is_ok() == r2.is_ok()

    it "unification is idempotent":
        var checker = TypeChecker.new()
        val t = Type.Int
        val result = checker.unify(t, t)
        assert result.is_ok()

    it "transitive resolution terminates":
        var checker = TypeChecker.new()

        # Create deep hierarchy
        for i in 0..10:
            var mixin = MixinInfo.new("Mixin{i}")
            if i > 0:
                mixin.required_mixins.push("Mixin{i-1}")
            checker.register_mixin(mixin)

        # Should terminate and return result
        val result = checker.resolve_transitive_mixins(["Mixin9"])
        assert result.len() == 10

# Coverage measurement directive
coverage:
    target: 100
    measure: [line, branch, path]
    report: "doc/test/type_inference_coverage.md"
