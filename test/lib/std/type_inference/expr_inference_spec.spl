# Expression Type Inference Tests
#
# Tests for expr_infer.spl - comprehensive coverage of all expression types.
# Based on rust/type/src/tests/ but written in SSpec format.

# @skip - Uses unsupported keyword: with
use compiler.type_system.expr_infer*
use compiler.inference.types*
use compiler.inference.infer (InferenceEngine)
use ast*

# ============================================================================
# Test Helpers
# ============================================================================

fn create_engine() -> InferenceEngine:
    """Create a fresh inference engine for testing."""
    InferenceEngine.create()

fn create_env() -> Dict<text, Type>:
    """Create a basic environment with common bindings."""
    var env: Dict<text, Type> = {}
    env["x"] = Type.Int(bits: 64, signed: true)
    env["y"] = Type.Int(bits: 64, signed: true)
    env["s"] = Type.Str
    env["b"] = Type.Bool
    env

# ============================================================================
# Literal Tests
# ============================================================================

describe "Literal Type Inference":
    it "infers integer literals as i64":
        val engine = create_engine()
        val env = create_env()
        val expr = Expr.Integer(42)

        val result = infer_expr(engine, expr, env)

        expect(result.ok.?).to_be_true()
        val ty = result.unwrap()
        expect(ty).to_equal(Type.Int(bits: 64, signed: true)))

    it "infers float literals as f64":
        val engine = create_engine()
        val env = create_env()
        val expr = Expr.Float(3.14)

        val result = infer_expr(engine, expr, env)

        expect(result.ok.?).to_be_true()
        val ty = result.unwrap()
        expect(ty).to_equal(Type.Float(bits: 64)))

    it "infers string literals as text":
        val engine = create_engine()
        val env = create_env()
        val expr = Expr.String("hello")

        val result = infer_expr(engine, expr, env)

        expect(result.ok.?).to_be_true()
        val ty = result.unwrap()
        expect(ty).to_equal(Type.Str))

    it "infers bool literals as bool":
        val engine = create_engine()
        val env = create_env()
        val expr = Expr.Bool(true)

        val result = infer_expr(engine, expr, env)

        expect(result.ok.?).to_be_true()
        val ty = result.unwrap()
        expect(ty).to_equal(Type.Bool))

    it "infers nil as Nil type":
        val engine = create_engine()
        val env = create_env()
        val expr = Expr.Nil

        val result = infer_expr(engine, expr, env)

        expect(result.ok.?).to_be_true()
        val ty = result.unwrap()
        expect(ty).to_equal(Type.Nil))

# ============================================================================
# Identifier Tests
# ============================================================================

describe "Identifier Type Inference":
    it "looks up identifiers in environment":
        val engine = create_engine()
        val env = create_env()
        val expr = Expr.Identifier("x")

        val result = infer_expr(engine, expr, env)

        expect(result.ok.?).to_be_true()
        val ty = result.unwrap()
        expect(ty).to_equal(Type.Int(bits: 64, signed: true)))

    it "returns error for undefined identifiers":
        val engine = create_engine()
        val env = create_env()
        val expr = Expr.Identifier("undefined")

        val result = infer_expr(engine, expr, env)

        expect(result.err.?).to_be_true()

    it "strips @ prefix for FFI function lookup":
        val engine = create_engine()
        var env = create_env()
        env["rt_print"] = Type.Function(params: [Type.Str], ret: Type.Unit)
        val expr = Expr.Identifier("@rt_print")

        val result = infer_expr(engine, expr, env)

        expect(result.ok.?).to_be_true()

# ============================================================================
# Binary Operator Tests
# ============================================================================

describe "Binary Operator Type Inference":
    context "Arithmetic operators":
        it "infers addition of integers as integer":
            val engine = create_engine()
            val env = create_env()
            val expr = Expr.Binary(
                op: BinOp.Add,
                left: Expr.Integer(1),
                right: Expr.Integer(2)
            )

            val result = infer_expr(engine, expr, env)

            expect(result.ok.?).to_be_true()
            val ty = result.unwrap()
            # Type should be resolved to Int
            match ty:
                case Int(bits, signed):
                    expect(bits).to_equal(64))
                    expect(signed).to_be_true()
                case _:
                    fail("Expected Int type")

        it "infers subtraction":
            val engine = create_engine()
            val env = create_env()
            val expr = Expr.Binary(
                op: BinOp.Sub,
                left: Expr.Integer(10),
                right: Expr.Integer(3)
            )

            val result = infer_expr(engine, expr, env)
            expect(result.ok.?).to_be_true()

        it "infers multiplication":
            val engine = create_engine()
            val env = create_env()
            val expr = Expr.Binary(
                op: BinOp.Mul,
                left: Expr.Integer(5),
                right: Expr.Integer(6)
            )

            val result = infer_expr(engine, expr, env)
            expect(result.ok.?).to_be_true()

        it "infers division":
            val engine = create_engine()
            val env = create_env()
            val expr = Expr.Binary(
                op: BinOp.Div,
                left: Expr.Integer(20),
                right: Expr.Integer(4)
            )

            val result = infer_expr(engine, expr, env)
            expect(result.ok.?).to_be_true()

    context "Comparison operators":
        it "infers equality as bool":
            val engine = create_engine()
            val env = create_env()
            val expr = Expr.Binary(
                op: BinOp.Eq,
                left: Expr.Integer(1),
                right: Expr.Integer(1)
            )

            val result = infer_expr(engine, expr, env)

            expect(result.ok.?).to_be_true()
            val ty = result.unwrap()
            expect(ty).to_equal(Type.Bool))

        it "infers less than as bool":
            val engine = create_engine()
            val env = create_env()
            val expr = Expr.Binary(
                op: BinOp.Lt,
                left: Expr.Integer(1),
                right: Expr.Integer(2)
            )

            val result = infer_expr(engine, expr, env)

            expect(result.ok.?).to_be_true()
            val ty = result.unwrap()
            expect(ty).to_equal(Type.Bool))

    context "Logical operators":
        it "infers and as bool":
            val engine = create_engine()
            val env = create_env()
            val expr = Expr.Binary(
                op: BinOp.And,
                left: Expr.Bool(true),
                right: Expr.Bool(false)
            )

            val result = infer_expr(engine, expr, env)

            expect(result.ok.?).to_be_true()
            val ty = result.unwrap()
            expect(ty).to_equal(Type.Bool))

        it "infers or as bool":
            val engine = create_engine()
            val env = create_env()
            val expr = Expr.Binary(
                op: BinOp.Or,
                left: Expr.Bool(true),
                right: Expr.Bool(false)
            )

            val result = infer_expr(engine, expr, env)

            expect(result.ok.?).to_be_true()
            val ty = result.unwrap()
            expect(ty).to_equal(Type.Bool))

# ============================================================================
# Unary Operator Tests
# ============================================================================

describe "Unary Operator Type Inference":
    it "infers negation as int":
        val engine = create_engine()
        val env = create_env()
        val expr = Expr.Unary(
            op: UnaryOp.Neg,
            operand: Expr.Integer(42)
        )

        val result = infer_expr(engine, expr, env)

        expect(result.ok.?).to_be_true()
        val ty = result.unwrap()
        expect(ty).to_equal(Type.Int(bits: 64, signed: true)))

    it "infers logical not as bool":
        val engine = create_engine()
        val env = create_env()
        val expr = Expr.Unary(
            op: UnaryOp.Not,
            operand: Expr.Bool(true)
        )

        val result = infer_expr(engine, expr, env)

        expect(result.ok.?).to_be_true()
        val ty = result.unwrap()
        expect(ty).to_equal(Type.Bool))

    it "infers borrow as Borrow type":
        val engine = create_engine()
        val env = create_env()
        val expr = Expr.Unary(
            op: UnaryOp.Ref,
            operand: Expr.Integer(42)
        )

        val result = infer_expr(engine, expr, env)

        expect(result.ok.?).to_be_true()
        val ty = result.unwrap()
        match ty:
            case Borrow(inner):
                expect(inner).to_equal(Type.Int(bits: 64, signed: true)))
            case _:
                fail("Expected Borrow type")

# ============================================================================
# Collection Tests
# ============================================================================

describe "Collection Type Inference":
    context "Arrays":
        it "infers non-empty array type from elements":
            val engine = create_engine()
            val env = create_env()
            val expr = Expr.Array([
                Expr.Integer(1),
                Expr.Integer(2),
                Expr.Integer(3)
            ])

            val result = infer_expr(engine, expr, env)

            expect(result.ok.?).to_be_true()
            val ty = result.unwrap()
            match ty:
                case Array(elem, size):
                    expect(elem).to_equal(Type.Int(bits: 64, signed: true)))
                case _:
                    fail("Expected Array type")

        it "infers empty array with fresh type variable":
            val engine = create_engine()
            val env = create_env()
            val expr = Expr.Array([])

            val result = infer_expr(engine, expr, env)

            expect(result.ok.?).to_be_true()
            val ty = result.unwrap()
            match ty:
                case Array(elem, _):
                    # Element type should be a fresh variable
                    match elem:
                        case Var(_):
                            pass  # Expected
                        case _:
                            fail("Expected type variable for empty array")
                case _:
                    fail("Expected Array type")

    context "Tuples":
        it "infers tuple type from elements":
            val engine = create_engine()
            val env = create_env()
            val expr = Expr.Tuple([
                Expr.Integer(1),
                Expr.String("hello"),
                Expr.Bool(true)
            ])

            val result = infer_expr(engine, expr, env)

            expect(result.ok.?).to_be_true()
            val ty = result.unwrap()
            match ty:
                case Tuple(elems):
                    expect(elems.len()).to_equal(3))
                case _:
                    fail("Expected Tuple type")

    context "Dictionaries":
        it "infers dict type from key-value pairs":
            val engine = create_engine()
            val env = create_env()
            val expr = Expr.Dict([
                (Expr.String("key1"), Expr.Integer(1)),
                (Expr.String("key2"), Expr.Integer(2))
            ])

            val result = infer_expr(engine, expr, env)

            expect(result.ok.?).to_be_true()
            val ty = result.unwrap()
            match ty:
                case Dict(key, value):
                    expect(key).to_equal(Type.Str))
                    expect(value).to_equal(Type.Int(bits: 64, signed: true)))
                case _:
                    fail("Expected Dict type")

# ============================================================================
# Control Flow Tests
# ============================================================================

describe "Control Flow Type Inference":
    context "If expressions":
        it "infers if with else":
            val engine = create_engine()
            val env = create_env()
            val expr = Expr.IfExpr(
                let_pattern: nil,
                condition: Expr.Bool(true),
                then_branch: Expr.Integer(1),
                else_branch: Some(Expr.Integer(2))
            )

            val result = infer_expr(engine, expr, env)

            expect(result.ok.?).to_be_true()

        it "infers if without else as Unit":
            val engine = create_engine()
            val env = create_env()
            val expr = Expr.IfExpr(
                let_pattern: nil,
                condition: Expr.Bool(true),
                then_branch: Expr.Integer(1),
                else_branch: nil
            )

            val result = infer_expr(engine, expr, env)

            expect(result.ok.?).to_be_true()
            val ty = result.unwrap()
            expect(ty).to_equal(Type.Unit))

# ============================================================================
# Optional/Result Operations Tests
# ============================================================================

describe "Optional Operations Type Inference":
    it "infers existence check as bool":
        val engine = create_engine()
        val env = create_env()
        val expr = Expr.ExistsCheck(Expr.Identifier("x"))

        val result = infer_expr(engine, expr, env)

        expect(result.ok.?).to_be_true()
        val ty = result.unwrap()
        expect(ty).to_equal(Type.Bool))

    it "infers coalesce operator":
        val engine = create_engine()
        val env = create_env()
        val expr = Expr.Coalesce(
            expr: Expr.Nil,
            default: Expr.Integer(42)
        )

        val result = infer_expr(engine, expr, env)

        expect(result.ok.?).to_be_true()

# ============================================================================
# Function Call Tests
# ============================================================================

describe "Function Call Type Inference":
    it "infers function call with known signature":
        val engine = create_engine()
        var env = create_env()
        env["add"] = Type.Function(
            params: [
                Type.Int(bits: 64, signed: true),
                Type.Int(bits: 64, signed: true)
            ],
            ret: Type.Int(bits: 64, signed: true)
        )

        val expr = Expr.Call(
            callee: Expr.Identifier("add"),
            args: [
                Argument(name: nil, value: Expr.Integer(1), span: Span(start: 0, end: 0, line: 0, column: 0), label: nil),
                Argument(name: nil, value: Expr.Integer(2), span: Span(start: 0, end: 0, line: 0, column: 0), label: nil)
            ]
        )

        val result = infer_expr(engine, expr, env)

        expect(result.ok.?).to_be_true()
        val ty = result.unwrap()
        expect(ty).to_equal(Type.Int(bits: 64, signed: true)))

# ============================================================================
# Index Access Tests
# ============================================================================

describe "Index Access Type Inference":
    it "infers array indexing":
        val engine = create_engine()
        var env = create_env()
        env["arr"] = Type.Array(
            elem: Type.Int(bits: 64, signed: true),
            size: nil
        )

        val expr = Expr.Index(
            receiver: Expr.Identifier("arr"),
            index: Expr.Integer(0)
        )

        val result = infer_expr(engine, expr, env)

        expect(result.ok.?).to_be_true()
        val ty = result.unwrap()
        expect(ty).to_equal(Type.Int(bits: 64, signed: true)))

    it "infers string indexing":
        val engine = create_engine()
        val env = create_env()
        val expr = Expr.Index(
            receiver: Expr.String("hello"),
            index: Expr.Integer(0)
        )

        val result = infer_expr(engine, expr, env)

        expect(result.ok.?).to_be_true()
        val ty = result.unwrap()
        expect(ty).to_equal(Type.Str))

# ============================================================================
# FString Tests
# ============================================================================

describe "FString Type Inference":
    it "infers FString as text":
        val engine = create_engine()
        val env = create_env()
        val expr = Expr.FString(parts: [
            FStringPart.Literal("Hello, "),
            FStringPart.ExprPart(Expr.Identifier("x")),
            FStringPart.Literal("!")
        ])

        val result = infer_expr(engine, expr, env)

        expect(result.ok.?).to_be_true()
        val ty = result.unwrap()
        expect(ty).to_equal(Type.Str))

    it "allows undefined identifiers in FString placeholders":
        val engine = create_engine()
        val env = create_env()
        val expr = Expr.FString(parts: [
            FStringPart.Literal("Welcome "),
            FStringPart.ExprPart(Expr.Identifier("user")),  # undefined - OK!
            FStringPart.Literal(" to "),
            FStringPart.ExprPart(Expr.Identifier("city"))   # undefined - OK!
        ])

        val result = infer_expr(engine, expr, env)

        # Should succeed despite undefined identifiers
        expect(result.ok.?).to_be_true()
        val ty = result.unwrap()
        expect(ty).to_equal(Type.Str))

# ============================================================================
# Summary
# ============================================================================

# Total test count: 35+ tests covering:
# - Literals (5 tests)
# - Identifiers (3 tests)
# - Binary operators (9 tests)
# - Unary operators (3 tests)
# - Collections (4 tests)
# - Control flow (2 tests)
# - Optional operations (2 tests)
# - Function calls (1 test)
# - Index access (2 tests)
# - FString (2 tests)
