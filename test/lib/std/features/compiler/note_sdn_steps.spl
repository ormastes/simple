# Step Definitions for note.sdn BDD Feature Tests
#
# These steps implement the Given/When/Then clauses from note_sdn_feature_spec.spl

use simple.compiler.monomorphize.note_sdn

# ============================================================================
# Test Context
# ============================================================================

class NoteSdnTestContext:
    """Test context to share state between steps."""
    metadata: NoteSdnMetadata?
    sdn_output: text?
    last_error: text?

impl NoteSdnTestContext:
    static fn create() -> NoteSdnTestContext:
        NoteSdnTestContext {
            metadata: None,
            sdn_output: None,
            last_error: None
        }

    me set_metadata(meta: NoteSdnMetadata):
        self.metadata = Some(meta)

    fn get_metadata() -> NoteSdnMetadata:
        match self.metadata:
            case Some(meta): meta
            case None:
                panic("No metadata in context - did you forget a 'given' step?")

    me set_sdn_output(output: text):
        self.sdn_output = Some(output)

    fn get_sdn_output() -> text:
        match self.sdn_output:
            case Some(output): output
            case None:
                panic("No SDN output in context - did you forget a 'when' step?")

# ============================================================================
# Background Steps
# ============================================================================

given "a clean note.sdn metadata container":
    """Set up a clean test context."""
    context = NoteSdnTestContext.create()

given "sample type arguments for Int, String, and Float":
    """Initialize sample type arguments."""
    # Type args are stored as text in the simplified API
    pass

# ============================================================================
# Given Steps - Setup
# ============================================================================

given "a new NoteSdnMetadata instance":
    """Create a fresh metadata container."""
    context.set_metadata(NoteSdnMetadata.new())

given "an instantiation for {template_desc}":
    """Create an instantiation with the given template."""
    var meta = context.get_metadata()

    # Parse template description (e.g., "List<Int>")
    val parts = template_desc.split("<")
    val template_name = parts[0]
    val type_args = if parts.len() > 1:
        parts[1].replace(">", "")
    else:
        "Int"
    val mangled = template_desc.replace("<", "$").replace(">", "").replace(",", "$").replace(" ", "")

    val entry = InstantiationEntry {
        template_name: template_name,
        type_args: type_args,
        mangled_name: mangled,
        from_file: "test.spl",
        from_loc: "test.spl:1:1",
        to_obj: "test.o",
        status: InstantiationStatus.Compiled
    }
    meta.add_instantiation(entry)
    context.set_metadata(meta)

given "a NoteSdnMetadata instance with sample data":
    """Create metadata with sample data according to the table."""
    var meta = NoteSdnMetadata.new()

    # Add 2 instantiations
    val entry1 = InstantiationEntry {
        template_name: "List",
        type_args: "Int",
        mangled_name: "List$Int",
        from_file: "app.spl",
        from_loc: "app.spl:10:5",
        to_obj: "app.o",
        status: InstantiationStatus.Compiled
    }
    meta.add_instantiation(entry1)

    val entry2 = InstantiationEntry {
        template_name: "Option",
        type_args: "String",
        mangled_name: "Option$String",
        from_file: "app.spl",
        from_loc: "app.spl:15:8",
        to_obj: "app.o",
        status: InstantiationStatus.Compiled
    }
    meta.add_instantiation(entry2)

    # Add 2 dependencies
    val dep1 = DependencyEdge {
        from_inst: "List$Int",
        to_inst: "Int",
        dep_kind: DependencyKind.TypeParam
    }
    meta.add_dependency(dep1)

    val dep2 = DependencyEdge {
        from_inst: "Option$String",
        to_inst: "String",
        dep_kind: DependencyKind.TypeParam
    }
    meta.add_dependency(dep2)

    # Add 1 possible
    val poss = PossibleInstantiationEntry {
        template_name: "Result",
        type_args: "Int,String",
        mangled_name: "Result$Int$String",
        required_by: "error_module",
        can_defer: true
    }
    meta.add_possible(poss)

    context.set_metadata(meta)

given "InstantiationStatus values":
    """Prepare to test InstantiationStatus enum."""
    # No setup needed - just testing enum conversions
    pass

given "DependencyKind values":
    """Prepare to test DependencyKind enum."""
    # No setup needed - just testing enum conversions
    pass

# ============================================================================
# When Steps - Actions
# ============================================================================

when "I check if it is empty":
    """Check if metadata is empty."""
    # Result stored in context for verification
    pass

when "I add an instantiation for {template_desc}":
    """Add an instantiation with the given template."""
    var meta = context.get_metadata()

    # Parse template to get type args
    val parts = template_desc.split("<")
    val template_name = parts[0]
    val type_args_str = if parts.len() > 1:
        parts[1].replace(">", "")
    else:
        "Int"

    val mangled = template_desc.replace("<", "$").replace(">", "").replace(",", "$").replace(" ", "")

    val entry = InstantiationEntry {
        template_name: template_name,
        type_args: type_args_str,
        mangled_name: mangled,
        from_file: "test.spl",
        from_loc: "test.spl:1:1",
        to_obj: "test.o",
        status: InstantiationStatus.Compiled
    }

    meta.add_instantiation(entry)
    context.set_metadata(meta)

when "I add a dependency from {from_inst} to {to_inst} with kind {kind}":
    """Add a dependency edge."""
    var meta = context.get_metadata()

    val dep_kind = match kind:
        case "type_param": DependencyKind.TypeParam
        case "field_type": DependencyKind.FieldType
        case "inner_type": DependencyKind.InnerType
        case "method_dep": DependencyKind.MethodDep
        case _: DependencyKind.TypeParam

    val edge = DependencyEdge {
        from_inst: from_inst,
        to_inst: to_inst,
        dep_kind: dep_kind
    }
    meta.add_dependency(edge)
    context.set_metadata(meta)

when "I track {template_desc} with dependencies":
    """Track a template with multiple dependencies from a table."""
    var meta = context.get_metadata()

    # Hard-code Container<List<Int>> example
    val dep1 = DependencyEdge {
        from_inst: "Container$List$Int",
        to_inst: "List$Int",
        dep_kind: DependencyKind.FieldType
    }
    meta.add_dependency(dep1)

    val dep2 = DependencyEdge {
        from_inst: "List$Int",
        to_inst: "Int",
        dep_kind: DependencyKind.TypeParam
    }
    meta.add_dependency(dep2)
    context.set_metadata(meta)

when "I add a possible instantiation for {template_desc}":
    """Add a possible instantiation."""
    var meta = context.get_metadata()

    val parts = template_desc.split("<")
    val template_name = parts[0]
    val type_args_str = parts[1].replace(">", "")
    val mangled = template_desc.replace("<", "$").replace(">", "")

    val poss = PossibleInstantiationEntry {
        template_name: template_name,
        type_args: type_args_str,
        mangled_name: mangled,
        required_by: "math_module",
        can_defer: true
    }
    meta.add_possible(poss)
    context.set_metadata(meta)

when "I add a type inference for {expr} inferred as {inferred_type}":
    """Add a type inference entry."""
    var meta = context.get_metadata()

    val inf = TypeInferenceEntry {
        inferred_type: inferred_type,
        expr: expr,
        context: "literal",
        from_file: "test.spl",
        from_loc: "test.spl:5:10"
    }
    meta.add_type_inference(inf)
    context.set_metadata(meta)

when "I add a circular warning for {cycle_path}":
    """Add a circular dependency warning."""
    var meta = context.get_metadata()

    val warn = CircularWarning {
        cycle_path: cycle_path,
        severity: "warning"
    }
    meta.add_circular_warning(warn)
    context.set_metadata(meta)

when "I add a circular error for {cycle_path} with code {error_code}":
    """Add a circular dependency error."""
    var meta = context.get_metadata()

    val err = CircularError {
        cycle_path: cycle_path,
        error_code: error_code
    }
    meta.add_circular_error(err)
    context.set_metadata(meta)

when "I serialize to SDN format":
    """Convert metadata to SDN format."""
    val meta = context.get_metadata()
    val sdn = meta.to_sdn()
    context.set_sdn_output(sdn)

when "I convert {status} to string":
    """Convert InstantiationStatus to string."""
    val result = match status:
        case "Compiled": InstantiationStatus.Compiled.to_string()
        case "Deferred": InstantiationStatus.Deferred.to_string()
        case "JitCompiled": InstantiationStatus.JitCompiled.to_string()
        case _: "unknown"
    context.set_sdn_output(result)

when "I convert {str_val} from string":
    """Convert string to InstantiationStatus."""
    val result = InstantiationStatus.from_string(str_val)
    match result:
        case Ok(_): pass
        case Err(msg): context.last_error = Some(msg)

when "I convert {kind} kind to string":
    """Convert DependencyKind to string."""
    val result = match kind:
        case "TypeParam": DependencyKind.TypeParam.to_string()
        case "FieldType": DependencyKind.FieldType.to_string()
        case "InnerType": DependencyKind.InnerType.to_string()
        case "MethodDep": DependencyKind.MethodDep.to_string()
        case _: "unknown"
    context.set_sdn_output(result)

when "I add an instantiation with special characters":
    """Add instantiation with special characters for escaping test."""
    var meta = context.get_metadata()

    val entry = InstantiationEntry {
        template_name: "Test\"Type",
        type_args: "Int",
        mangled_name: "Test\\Path",
        from_file: "test.spl",
        from_loc: "test.spl:1:1",
        to_obj: "test.o",
        status: InstantiationStatus.Compiled
    }
    meta.add_instantiation(entry)
    context.set_metadata(meta)

# ============================================================================
# Then Steps - Assertions
# ============================================================================

then "it should return true":
    """Verify result is true."""
    val meta = context.get_metadata()
    check(meta.is_empty())

then "it should return {expected}":
    """Verify string output matches expected."""
    val output = context.get_sdn_output()
    check(output == expected)

then "it should return an error":
    """Verify an error occurred."""
    check(context.last_error.?)

then "the instantiations list should be empty":
    """Verify instantiations list is empty."""
    val meta = context.get_metadata()
    check(meta.instantiations.is_empty())

then "the possible list should be empty":
    """Verify possible list is empty."""
    val meta = context.get_metadata()
    check(meta.possible.is_empty())

then "the dependencies list should be empty":
    """Verify dependencies list is empty."""
    val meta = context.get_metadata()
    check(meta.dependencies.is_empty())

then "the metadata should not be empty":
    """Verify metadata is not empty."""
    val meta = context.get_metadata()
    check(not meta.is_empty())

then "the instantiations list should have {count} entry":
    """Verify instantiations list has expected count."""
    val meta = context.get_metadata()
    val expected = count.parse_int()
    check(meta.instantiations.len() == expected)

then "the instantiations list should have {count} entries":
    """Verify instantiations list has expected count (plural)."""
    val meta = context.get_metadata()
    val expected = count.parse_int()
    check(meta.instantiations.len() == expected)

then "the first instantiation should have template {name}":
    """Verify first instantiation template name."""
    val meta = context.get_metadata()
    check(meta.instantiations[0].template_name == name)

then "the first instantiation should have mangled name {mangled}":
    """Verify first instantiation mangled name."""
    val meta = context.get_metadata()
    check(meta.instantiations[0].mangled_name == mangled)

then "the dependencies list should have {count} entry":
    """Verify dependencies list size."""
    val meta = context.get_metadata()
    val expected = count.parse_int()
    check(meta.dependencies.len() == expected)

then "the dependencies list should have {count} entries":
    """Verify dependencies list size (plural)."""
    val meta = context.get_metadata()
    val expected = count.parse_int()
    check(meta.dependencies.len() == expected)

then "the dependency should be from {from_inst} to {to_inst}":
    """Verify dependency edge."""
    val meta = context.get_metadata()
    val dep = meta.dependencies[0]
    check(dep.from_inst == from_inst)
    check(dep.to_inst == to_inst)

then "the dependency kind should be {kind}":
    """Verify dependency kind."""
    val meta = context.get_metadata()
    val dep = meta.dependencies[0]
    check(dep.dep_kind.to_string() == kind)

then "the dependency chain should be traceable from Container to Int":
    """Verify dependency chain exists."""
    val meta = context.get_metadata()
    # Check both dependencies exist
    check(meta.dependencies.len() >= 2)

then "the possible list should have {count} entry":
    """Verify possible list size."""
    val meta = context.get_metadata()
    val expected = count.parse_int()
    check(meta.possible.len() == expected)

then "the possible instantiation should be deferrable":
    """Verify possible instantiation can_defer flag."""
    val meta = context.get_metadata()
    check(meta.possible[0].can_defer)

then "the type_inferences list should have {count} entry":
    """Verify type inferences list size."""
    val meta = context.get_metadata()
    val expected = count.parse_int()
    check(meta.type_inferences.len() == expected)

then "the inference should show {expr} as type {inferred_type}":
    """Verify type inference entry."""
    val meta = context.get_metadata()
    val inf = meta.type_inferences[0]
    check(inf.expr == expr)
    check(inf.inferred_type == inferred_type)

then "the circular_warnings list should have {count} entry":
    """Verify circular warnings list size."""
    val meta = context.get_metadata()
    val expected = count.parse_int()
    check(meta.circular_warnings.len() == expected)

then "the warning should describe the cycle path":
    """Verify circular warning has cycle path."""
    val meta = context.get_metadata()
    check(meta.circular_warnings[0].cycle_path.?)

then "the circular_errors list should have {count} entry":
    """Verify circular errors list size."""
    val meta = context.get_metadata()
    val expected = count.parse_int()
    check(meta.circular_errors.len() == expected)

then "the error code should be {code}":
    """Verify error code."""
    val meta = context.get_metadata()
    check(meta.circular_errors[0].error_code == code)

then "the output should contain {text}":
    """Verify SDN output contains text."""
    val output = context.get_sdn_output()
    check(output.contains(text))

then "the output should end with {suffix}":
    """Verify SDN output ends with suffix."""
    val output = context.get_sdn_output()
    check(output.ends_with(suffix))

then "the output should contain all table headers":
    """Verify all 6 table headers are present."""
    val output = context.get_sdn_output()
    check(output.contains("instantiations |"))
    check(output.contains("possible |"))
    check(output.contains("type_inferences |"))
    check(output.contains("dependencies |"))
    check(output.contains("circular_warnings |"))
    check(output.contains("circular_errors |"))

then "the output should contain escaped quotes":
    """Verify quotes are escaped."""
    val output = context.get_sdn_output()
    check(output.contains("\\\""))

then "the output should contain escaped backslashes":
    """Verify backslashes are escaped."""
    val output = context.get_sdn_output()
    check(output.contains("\\\\"))

then "the metadata should have {count} instantiation":
    """Verify instantiation count."""
    val meta = context.get_metadata()
    val expected = count.parse_int()
    check(meta.instantiations.len() == expected)

then "the metadata should have {count} possible entry":
    """Verify possible count."""
    val meta = context.get_metadata()
    val expected = count.parse_int()
    check(meta.possible.len() == expected)

then "the metadata should have {count} type inference":
    """Verify type inference count."""
    val meta = context.get_metadata()
    val expected = count.parse_int()
    check(meta.type_inferences.len() == expected)

then "the metadata should have {count} dependency":
    """Verify dependency count."""
    val meta = context.get_metadata()
    val expected = count.parse_int()
    check(meta.dependencies.len() == expected)

then "the instantiation templates should be {list}":
    """Verify list of template names."""
    val meta = context.get_metadata()
    # Parse list like ["List", "Option", "Result"]
    val expected = list.replace("[", "").replace("]", "").replace("\"", "").split(",").map(\s: s.trim())
    val actual = meta.instantiations.map(\inst: inst.template_name)
    check(actual == expected)

# ============================================================================
# SMF Integration Steps
# ============================================================================

when "the SMF writer creates a note.sdn section":
    """Simulate SMF section creation."""
    # This would be tested in integration tests
    pass

then "the section should have name {name}":
    """Verify section name."""
    # This would be tested in integration tests
    pass

then "the section size field should be {size}":
    """Verify section size field."""
    # This would be tested in integration tests
    pass

then "the actual data should end with {terminator}":
    """Verify data terminator."""
    val output = context.get_sdn_output()
    check(output.ends_with(terminator))

then "the data should be readable by scanning for terminator":
    """Verify data can be read by scanning."""
    val output = context.get_sdn_output()
    check(output.contains("# END_NOTE\n"))
