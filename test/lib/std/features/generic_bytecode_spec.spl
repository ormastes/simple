# Generic Template Bytecode in SMF - Feature Specification
#
# Tests for storing generic templates in .smf files and deferred monomorphization.

feature "Generic Template Bytecode in SMF":
    """Store generic function templates in .smf for deferred instantiation.

    This feature enables library-style generic imports where downstream code
    can instantiate new type combinations even if the library didn't compile them.

    Example:
        # Library compiles List<Int>
        # Downstream can use List<Float> by instantiating from template
    """

    status: Implemented
    priority: P1
    category: Compiler

    # =========================================================================
    # Scenario Group 1: Template Storage
    # =========================================================================

    scenario "Compile generic function to SMF":
        given "A generic function fn identity<T>(x: T) -> T"
        when "Compiled to .smf without any call sites"
        then "SMF contains TemplateCode section with MIR"
        and "Symbol table marks function as generic template"
        and "Template section has GTPL magic number"

        # Implementation test
        it "should store function template in TemplateCode section":
            val source = """
                fn identity<T>(x: T) -> T:
                    x
            """

            val smf = compile_to_smf(source)

            # Check for TemplateCode section
            expect(smf.has_section(SectionType.TemplateCode)).to_be(true)

            # Check magic number
            val template_section = smf.get_section(SectionType.TemplateCode)
            val magic = read_u32(template_section, 0)
            expect(magic).to_equal(0x4C54504E)  # "GTPL"

            # Check symbol table
            val symbol = smf.find_symbol("identity")
            expect(symbol.flags & GENERIC_TEMPLATE).to_equal(GENERIC_TEMPLATE)
            expect(symbol.template_param_count).to_equal(1)

    scenario "Compile generic struct to SMF":
        given "A generic struct Container<T>"
        when "Compiled to .smf"
        then "Template section includes struct definition"
        and "Generic parameter count is stored"

        it "should store struct template":
            val source = """
                struct Container<T>:
                    value: T

                    fn get() -> T:
                        self.value
            """

            val smf = compile_to_smf(source)
            val templates = extract_templates(smf)

            expect(templates.structs.len()).to_equal(1)
            expect(templates.structs[0].name).to_equal("Container")
            expect(templates.structs[0].generic_params.len()).to_equal(1)

    scenario "Compile generic enum to SMF":
        given "A generic enum Result<T, E>"
        when "Compiled to .smf"
        then "Both type parameters are preserved"
        and "Variants are stored correctly"

        it "should store enum template with multiple type params":
            val source = """
                enum Result<T, E>:
                    Ok(T)
                    Err(E)
            """

            val smf = compile_to_smf(source)
            val templates = extract_templates(smf)

            expect(templates.enums.len()).to_equal(1)
            expect(templates.enums[0].name).to_equal("Result")
            expect(templates.enums[0].generic_params).to_equal(["T", "E"])

    # =========================================================================
    # Scenario Group 2: Specialization Tracking
    # =========================================================================

    scenario "Specialized functions included":
        given "Generic function with call site: identity(42)"
        when "Compiled to .smf"
        then "SMF contains both template AND specialized identity$Int"
        and "Monomorphization metadata tracks specialization"

        it "should include both template and specialization":
            val source = """
                fn identity<T>(x: T) -> T:
                    x

                fn main():
                    val result = identity(42)
            """

            val smf = compile_to_smf(source)

            # Check template exists
            expect(smf.has_section(SectionType.TemplateCode)).to_be(true)

            # Check specialized version exists in code section
            expect(smf.has_symbol("identity$Int")).to_be(true)

            # Check metadata tracks this specialization
            val metadata = extract_metadata(smf)
            expect(metadata.functions.contains_key("identity")).to_be(true)

            val func_meta = metadata.functions["identity"]
            expect(func_meta.specializations.len()).to_equal(1)
            expect(func_meta.specializations[0].mangled_name).to_equal("identity$Int")

    scenario "Multiple specializations tracked":
        given "Generic function called with Int and Float"
        when "Compiled to .smf"
        then "Metadata lists both specializations"
        and "Each has correct type arguments"

        it "should track multiple specializations":
            val source = """
                fn square<T>(x: T) -> T:
                    x * x

                fn main():
                    val i = square(5)
                    val f = square(3.14)
            """

            val smf = compile_to_smf(source)
            val metadata = extract_metadata(smf)

            val func_meta = metadata.functions["square"]
            expect(func_meta.specializations.len()).to_equal(2)

            val names = func_meta.specializations.map(\s: s.mangled_name)
            expect(names).to_contain("square$Int")
            expect(names).to_contain("square$Float")

    # =========================================================================
    # Scenario Group 3: Deferred Instantiation
    # =========================================================================

    scenario "Load and instantiate from SMF":
        given "SMF file with generic List<T> implementation"
        when "Module imports and uses List<Float>"
        then "Deferred monomorphizer instantiates List$Float"
        and "Compiled code can call specialized methods"

        it "should instantiate new specialization from template":
            # Step 1: Compile library with List<Int> only
            val lib_source = """
                struct List<T>:
                    data: [T]

                    fn append(item: T):
                        self.data.push(item)

                fn use_int_list():
                    val list = List<Int>()
                    list.append(42)
            """

            val lib_smf = compile_to_smf(lib_source)

            # Step 2: Use library with List<Float>
            val app_source = """
                import lib.List

                fn main():
                    val list = List<Float>()
                    list.append(3.14)
            """

            # Deferred monomorphization should work
            val mono = DeferredMonomorphizer.new(InstantiationMode.LinkTime)
            mono.load_templates_from_smf(lib_smf)

            # Instantiate List<Float> from template
            val list_float = mono.instantiate_struct("List", [ConcreteType.Float])

            expect(list_float.name).to_match("List\\$Float")
            expect(list_float.generic_params).to_be_empty()
            expect(list_float.is_generic_template).to_be(false)

    scenario "Link-time instantiation":
        given "Object file using generic type not in library"
        when "Linker processes files"
        then "Template instantiated automatically"
        and "Final binary contains specialized code"

        # This test requires full linker integration (future work)
        skip "Requires linker integration":
            val lib = compile("lib.spl", "lib.smf")
            val app = compile("app.spl", "app.o")

            val binary = link([app], [lib])

            expect(binary.has_symbol("List$Float")).to_be(true)

    scenario "JIT-time instantiation":
        given ".smf file loaded in JIT mode"
        when "Code calls generic function with new type"
        then "Instantiation happens on demand"
        and "Result is cached for subsequent calls"

        it "should instantiate on first use in JIT mode":
            val smf = compile_to_smf("""
                fn identity<T>(x: T) -> T:
                    x
            """)

            val mono = DeferredMonomorphizer.new(InstantiationMode.JitTime)
            mono.load_templates_from_smf(smf)

            # First call - triggers instantiation
            val start = now()
            val func1 = mono.instantiate_function("identity", [ConcreteType.String])
            val first_time = now() - start

            # Second call - uses cache
            val start2 = now()
            val func2 = mono.instantiate_function("identity", [ConcreteType.String])
            val cached_time = now() - start2

            # Cache should be faster
            expect(cached_time).to_be_less_than(first_time)

            # Both should be same specialization
            expect(func1.name).to_equal(func2.name)

    # =========================================================================
    # Scenario Group 4: Complex Generic Constructs
    # =========================================================================

    scenario "Generic class with methods":
        given "Generic class with multiple methods"
        when "Compiled and instantiated"
        then "All methods are specialized correctly"

        it "should specialize class methods":
            val source = """
                class Stack<T>:
                    items: [T]

                    fn push(item: T):
                        self.items.push(item)

                    fn pop() -> T?:
                        if self.items.is_empty():
                            None
                        else:
                            Some(self.items.pop())
            """

            val smf = compile_to_smf(source)
            val mono = DeferredMonomorphizer.new(InstantiationMode.LinkTime)
            mono.load_templates_from_smf(smf)

            val stack_int = mono.instantiate_class("Stack", [ConcreteType.Int])

            expect(stack_int.methods.len()).to_equal(2)
            expect(stack_int.methods[0].name).to_equal("push")
            expect(stack_int.methods[1].name).to_equal("pop")

    scenario "Generic trait definitions":
        given "Generic trait with associated methods"
        when "Stored in template section"
        then "Trait can be instantiated for new types"

        skip "Trait instantiation not fully implemented":
            val source = """
                trait Comparable<T>:
                    fn compare(other: T) -> i32
            """

            val smf = compile_to_smf(source)
            val templates = extract_templates(smf)

            expect(templates.traits.len()).to_equal(1)
            expect(templates.traits[0].generic_params).to_equal(["T"])

    scenario "Nested generics":
        given "Generic type with nested generic parameter"
        when "Instantiated as List<Result<Int, String>>"
        then "Nested specialization works correctly"

        it "should handle nested type arguments":
            val source = """
                struct List<T>:
                    data: [T]

                enum Result<T, E>:
                    Ok(T)
                    Err(E)
            """

            val smf = compile_to_smf(source)
            val mono = DeferredMonomorphizer.new(InstantiationMode.LinkTime)
            mono.load_templates_from_smf(smf)

            # Create nested type: Result<Int, String>
            val result_type = ConcreteType.Generic(
                "Result",
                [ConcreteType.Int, ConcreteType.String]
            )

            # Instantiate List<Result<Int, String>>
            val nested = mono.instantiate_struct("List", [result_type])

            expect(nested.name).to_match("List\\$Result\\$Int\\$String")

    # =========================================================================
    # Scenario Group 5: Error Handling
    # =========================================================================

    scenario "Wrong number of type arguments":
        given "Template requiring 2 type parameters"
        when "Instantiated with 1 type argument"
        then "Error is reported with clear message"

        it "should reject wrong type argument count":
            val source = """
                struct Pair<T, U>:
                    first: T
                    second: U
            """

            val smf = compile_to_smf(source)
            val mono = DeferredMonomorphizer.new(InstantiationMode.LinkTime)
            mono.load_templates_from_smf(smf)

            # Try with only 1 type arg (should fail)
            val result = mono.instantiate_struct("Pair", [ConcreteType.Int])

            expect(result).to_be_err()
            expect(result.err_message()).to_contain("Wrong number of type arguments")
            expect(result.err_message()).to_contain("expected 2, got 1")

    scenario "Template not found":
        given "SMF file without requested template"
        when "Attempting to instantiate"
        then "Error indicates template missing"

        it "should report missing template":
            val smf = compile_to_smf("fn regular(): pass")
            val mono = DeferredMonomorphizer.new(InstantiationMode.LinkTime)
            mono.load_templates_from_smf(smf)

            val result = mono.instantiate_function("identity", [ConcreteType.Int])

            expect(result).to_be_err()
            expect(result.err_message()).to_contain("No template found")
            expect(result.err_message()).to_contain("identity")

    scenario "Malformed template section":
        given "SMF file with corrupted template data"
        when "Loader attempts to read templates"
        then "Error is caught and reported"

        skip "Requires full deserialization implementation":
            val corrupted_smf = create_corrupted_smf()
            val mono = DeferredMonomorphizer.new(InstantiationMode.LinkTime)

            val result = mono.load_templates_from_smf(corrupted_smf)

            expect(result).to_be_err()
            expect(result.err_message()).to_contain("Invalid template section")

    # =========================================================================
    # Scenario Group 6: Backward Compatibility
    # =========================================================================

    scenario "SMF without templates loads correctly":
        given "Older .smf file without TemplateCode section"
        when "Loaded by new compiler"
        then "Works normally as non-generic module"

        it "should handle SMF files without template sections":
            val source = """
                fn regular_function():
                    print("Hello")
            """

            val smf = compile_to_smf_v0(source)  # Old format

            # Should load without errors
            expect(smf.has_section(SectionType.TemplateCode)).to_be(false)
            expect(smf.has_section(SectionType.Code)).to_be(true)

            # Can still execute non-generic code
            val result = execute_smf(smf, "regular_function", [])
            expect(result).to_be_ok()

    scenario "Mixed generic and non-generic code":
        given "Module with both generic and regular functions"
        when "Compiled to .smf"
        then "Templates stored for generic functions only"
        and "Regular functions in code section only"

        it "should separate generic from non-generic correctly":
            val source = """
                fn identity<T>(x: T) -> T:
                    x

                fn regular_add(a: i32, b: i32) -> i32:
                    a + b
            """

            val smf = compile_to_smf(source)

            # Template section has identity<T>
            val templates = extract_templates(smf)
            expect(templates.functions.len()).to_equal(1)
            expect(templates.functions[0].name).to_equal("identity")

            # Code section has regular_add (not identity<T>)
            expect(smf.has_symbol("regular_add")).to_be(true)
            expect(smf.get_symbol("regular_add").flags & GENERIC_TEMPLATE).to_equal(0)

# ============================================================================
# Helper Functions (Test Infrastructure)
# ============================================================================

fn compile_to_smf(source: text) -> SmfFile:
    """Compile Simple source to SMF file."""
    # TODO: Implement test harness
    pass

fn compile_to_smf_v0(source: text) -> SmfFile:
    """Compile to old SMF format (no template sections)."""
    # TODO: Implement for backward compat tests
    pass

fn extract_templates(smf: SmfFile) -> GenericTemplates:
    """Extract generic templates from TemplateCode section."""
    # TODO: Implement template extraction
    pass

fn extract_metadata(smf: SmfFile) -> MonomorphizationMetadata:
    """Extract monomorphization metadata from TemplateMeta section."""
    # TODO: Implement metadata extraction
    pass

fn execute_smf(smf: SmfFile, entry: text, args: [i64]) -> Result<i64, text>:
    """Execute SMF file entry point."""
    # TODO: Implement SMF execution harness
    pass

fn create_corrupted_smf() -> SmfFile:
    """Create SMF with corrupted template section for error testing."""
    # TODO: Implement for error case testing
    pass

fn read_u32(data: [u8], offset: i32) -> i32:
    """Read little-endian u32 from byte array."""
    # TODO: Implement binary parsing
    pass

# ============================================================================
# Type Definitions (Test Support)
# ============================================================================

struct SmfFile:
    sections: [SmfSection]
    symbols: [SmfSymbol]

impl SmfFile:
    fn has_section(type_: SectionType) -> bool:
        self.sections.any(\s: s.section_type == type_)

    fn get_section(type_: SectionType) -> [u8]:
        val section = self.sections.find(\s: s.section_type == type_)
        section?.data ?? []

    fn has_symbol(name: text) -> bool:
        self.symbols.any(\s: s.name == name)

    fn find_symbol(name: text) -> SmfSymbol?:
        self.symbols.find(\s: s.name == name)

    fn get_symbol(name: text) -> SmfSymbol:
        self.find_symbol(name).unwrap()

struct SmfSection:
    section_type: SectionType
    data: [u8]

enum SectionType:
    Code
    Data
    TemplateCode
    TemplateMeta

struct SmfSymbol:
    name: text
    flags: u8
    template_param_count: u8

val GENERIC_TEMPLATE: u8 = 0x10
val SPECIALIZED: u8 = 0x20
