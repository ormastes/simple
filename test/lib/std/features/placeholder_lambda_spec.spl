# @pending
# @skip
"""
# Placeholder Lambda Specification
**Feature IDs:** #PLACEHOLDER-LAMBDA
**Category:** Syntax
**Status:** In Progress

Placeholder `_` syntax for creating concise lambda expressions.
`nums.map(_ * 2)` desugars to `nums.map(\__p0: __p0 * 2)`
"""
use std.spec.*

describe "Placeholder Lambda":
    """
    Verifies the placeholder `_` syntax for creating concise lambda expressions.
    Tests single and multiple placeholders, field access, method calls, chained
    operations, slicing, tuple creation, and scope isolation with nested lambdas.
    The placeholder desugars into a lambda parameter (e.g., `_ * 2` becomes
    `\__p0: __p0 * 2`), enabling functional-style collection operations without
    verbose lambda syntax.
    """

    context "single placeholder":
        it "transforms _ * 2 to lambda":
            val nums = [1, 2, 3]
            expect nums.map(_ * 2) == [2, 4, 6]

        it "transforms _ + 10 to lambda":
            val nums = [1, 2, 3]
            expect nums.map(_ + 10) == [11, 12, 13]

        it "transforms _ - 1 to lambda":
            val nums = [5, 10, 15]
            expect nums.map(_ - 1) == [4, 9, 14]

        it "transforms _ / 2 to lambda":
            val nums = [10, 20, 30]
            expect nums.map(_ / 2) == [5, 10, 15]

        it "transforms unary negation -_":
            val nums = [1, -2, 3]
            expect nums.map(-_) == [-1, 2, -3]

    context "field access":
        it "accesses field with _.field":
            struct Point:
                x: i64
                y: i64
            val points = [Point(x=1, y=2), Point(x=3, y=4)]
            expect points.map(_.x) == [1, 3]
            expect points.map(_.y) == [2, 4]

    context "method call":
        it "calls method with _.method()":
            val texts = ["hello", "world"]
            expect texts.map(_.len()) == [5, 5]

    context "multiple placeholders":
        it "reduces with _ + _":
            val nums = [1, 2, 3, 4]
            # reduce requires (init, lambda) form with explicit lambda
            expect nums.reduce(0, \acc, x: acc + x) == 10

        it "reduces with _ * _":
            val nums = [1, 2, 3, 4]
            # reduce requires (init, lambda) form with explicit lambda
            expect nums.reduce(1, \acc, x: acc * x) == 24

        it "compares with _ < _":
            val a = 3
            val b = 5
            val compare = \x, y: x < y
            # This tests that _ < _ creates a two-argument lambda
            expect compare(a, b) == true

    context "with filter":
        it "filters with _ > threshold":
            val nums = [1, 5, 3, 8, 2]
            expect nums.filter(_ > 3) == [5, 8]

        it "filters with _ < threshold":
            val nums = [1, 5, 3, 8, 2]
            expect nums.filter(_ < 4) == [1, 3, 2]

        it "filters with _ == value":
            val nums = [1, 2, 2, 3, 2]
            expect nums.filter(_ == 2) == [2, 2, 2]

    context "chained operations":
        it "chains map and filter":
            val nums = [1, 2, 3, 4, 5]
            expect nums.map(_ * 2).filter(_ > 5) == [6, 8, 10]

        it "chains filter and map":
            val nums = [1, 2, 3, 4, 5]
            expect nums.filter(_ > 2).map(_ * 10) == [30, 40, 50]

    context "indexing":
        it "accesses array element with _[index]":
            val arrays = [[1, 2, 3], [4, 5, 6]]
            expect arrays.map(_[0]) == [1, 4]
            expect arrays.map(_[1]) == [2, 5]

    context "complex expressions":
        it "combines operators in expression":
            val nums = [1, 2, 3]
            expect nums.map(_ * 2 + 1) == [3, 5, 7]
            expect nums.map((_ + 1) * 2) == [4, 6, 8]

        # Note: inline if-else in lambda body has parsing issues
        # Use a named function instead; wrap with explicit lambda since
        # passing bare function name to map is not supported
        it "maps with conditional classification":
            val nums = [1, 2, 3, 4, 5]
            fn classify(x: i64) -> text:
                if x > 3:
                    return "big"
                else:
                    return "small"
            expect nums.map(\x: classify(x)) == ["small", "small", "small", "big", "big"]

    context "no transformation when no placeholder":
        it "leaves expressions without _ unchanged":
            val nums = [1, 2, 3]
            expect nums.map(\x: x * 2) == [2, 4, 6]

    context "edge cases":
        it "handles single element list":
            val nums = [42]
            expect nums.map(_ * 2) == [84]

        it "handles empty list":
            val nums: [i64] = []
            expect nums.map(_ * 2) == []

        it "handles nested function calls":
            fn double(x: i64) -> i64:
                x * 2
            val nums = [1, 2, 3]
            # double(_) placeholder in function args not supported, use explicit lambda
            expect nums.map(\x: double(x)) == [2, 4, 6]

    context "null coalescing":
        it "coalesces with _ ?? default":
            val opts: [Option<i64>] = [Some(1), None, Some(3)]
            expect opts.map(_ ?? 0) == [1, 0, 3]

        it "coalesces with expression on right side":
            val opts: [Option<i64>] = [Some(10), None, Some(30)]
            expect opts.map(_ ?? -1 * 100) == [10, -100, 30]

    context "slicing":
        it "slices with _[start:end]":
            val texts = ["hello", "world"]
            expect texts.map(_[1:4]) == ["ell", "orl"]

        it "slices with _[:end]":
            val texts = ["hello", "world"]
            expect texts.map(_[:3]) == ["hel", "wor"]

        it "slices with _[start:]":
            val texts = ["hello", "world"]
            expect texts.map(_[2:]) == ["llo", "rld"]

        it "slices with step _[::step]":
            val texts = ["abcdef", "ghijkl"]
            expect texts.map(_[::2]) == ["ace", "gik"]

    context "tuple with placeholders":
        it "creates tuple with placeholder (_, constant)":
            val nums = [1, 2, 3]
            expect nums.map((_, 0)) == [(1, 0), (2, 0), (3, 0)]

        it "creates tuple with constant first (constant, _)":
            val nums = [1, 2, 3]
            expect nums.map((100, _)) == [(100, 1), (100, 2), (100, 3)]

        it "creates 3-tuple with placeholder":
            val nums = [1, 2, 3]
            expect nums.map((_, "x", 0)) == [(1, "x", 0), (2, "x", 0), (3, "x", 0)]

    context "method call with arguments":
        it "calls method with explicit args _.method(arg)":
            val texts = ["hello", "world"]
            expect texts.map(_.slice(0, 3)) == ["hel", "wor"]

        it "calls method with placeholder in args _.method(_) from outer scope":
            # Note: placeholder in function call args not supported, use explicit lambda
            val nums = [1, 2, 3]
            fn add(a: i64, b: i64) -> i64:
                a + b
            expect nums.map(\x: add(x, 10)) == [11, 12, 13]

    context "chained method calls":
        it "chains method calls _.method1().method2()":
            val texts = ["  hello  ", "  world  "]
            expect texts.map(_.trim().len()) == [5, 5]

        it "chains multiple string methods":
            val texts = ["HELLO", "WORLD"]
            expect texts.map(_.lower().len()) == [5, 5]

        it "chains slice with length":
            val texts = ["hello world", "foo bar baz"]
            expect texts.map(_[:5].len()) == [5, 5]

    context "scope isolation with nested lambdas":
        it "does not transform _ inside nested lambda":
            val nums = [1, 2, 3]
            # The outer _ is transformed, inner \x: x stays as is
            expect nums.map(_ + (\x: x * 2)(10)) == [21, 22, 23]

        it "nested lambda with its own _ is independent":
            val nums = [1, 2, 3]
            # Outer _ becomes __p0, inner _ is separate lambda scope
            # This should work because inner lambda is not traversed
            val transform = \x: x * 2
            expect nums.map(_ + transform(5)) == [11, 12, 13]

    context "comparison operators":
        it "uses _ in greater-or-equal comparison":
            val nums = [1, 2, 3, 4, 5]
            expect nums.filter(_ >= 3) == [3, 4, 5]

        it "uses _ in less-or-equal comparison":
            val nums = [1, 2, 3, 4, 5]
            expect nums.filter(_ <= 3) == [1, 2, 3]

        it "uses _ in not-equal comparison":
            val nums = [1, 2, 2, 3, 2]
            expect nums.filter(_ != 2) == [1, 3]

    context "logical operators":
        # Note: multiple _ in one expression creates multi-arg lambda
        # which doesn't work with filter (single arg)
        # Use explicit lambda for compound conditions
        it "uses explicit lambda with logical and":
            val nums = [1, 2, 3, 4, 5]
            expect nums.filter(\x: x > 1 && x < 5) == [2, 3, 4]

        it "uses explicit lambda with logical or":
            val nums = [1, 2, 3, 4, 5]
            expect nums.filter(\x: x == 1 || x == 5) == [1, 5]

    context "modulo and other operators":
        it "uses _ with modulo":
            val nums = [1, 2, 3, 4, 5, 6]
            expect nums.filter(_ % 2 == 0) == [2, 4, 6]

        it "uses _ with bitwise and":
            val nums = [1, 2, 3, 4, 5]
            expect nums.map(_ & 1) == [1, 0, 1, 0, 1]
