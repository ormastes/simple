# HM Type Inference Specification
#
# Tests for Hindley-Milner type inference with level-based generalization.
# Verifies that the type inference correctly handles:
# - Polymorphic functions (identity, compose)
# - Let-polymorphism (multiple instantiations)
# - Unification with occurs check
# - Level-based generalization
#
# Feature: #2500 - HM Type Inference
# Status: in_progress
#
# NOTE: Full tests require self-hosting compiler modules (simple/compiler/*).
#       These simplified tests verify core concepts using built-in primitives.

use std.spec.*

# ============================================================================
# Simplified Type Inference Primitives
# ============================================================================

# Simulated inference variable ID
var next_var_id: i64 = 0

fn fresh_var() -> i64:
    """Create a fresh type variable ID."""
    val id = next_var_id
    next_var_id = next_var_id + 1
    id

fn reset_vars():
    """Reset variable counter for tests."""
    next_var_id = 0

# Simple type representation for testing
enum SimpleType:
    TyVar(id: i64, level: i64)    # Type variable with level
    TyInt                          # Integer type
    TyBool                         # Boolean type
    TyStr                          # String type
    TyUnit                         # Unit type
    TyFn(param: SimpleType, ret: SimpleType)  # Function type

fn ty_var(level: i64) -> SimpleType:
    SimpleType.TyVar(id: fresh_var(), level: level)

fn ty_int() -> SimpleType:
    SimpleType.TyInt

fn ty_bool() -> SimpleType:
    SimpleType.TyBool

fn ty_str() -> SimpleType:
    SimpleType.TyStr

fn ty_fn(p: SimpleType, r: SimpleType) -> SimpleType:
    SimpleType.TyFn(param: p, ret: r)

fn is_var(t: SimpleType) -> bool:
    match t:
        case TyVar(_, _): true
        case _: false

fn get_var_id(t: SimpleType) -> i64:
    match t:
        case TyVar(id, _): id
        case _: -1

fn get_var_level(t: SimpleType) -> i64:
    match t:
        case TyVar(_, level): level
        case _: -1

# ============================================================================
# Simple Substitution
# ============================================================================

struct SimpleSubst:
    entries: [(i64, SimpleType)]

fn empty_subst() -> SimpleSubst:
    SimpleSubst(entries: [])

fn subst_add(s: SimpleSubst, id: i64, ty: SimpleType) -> SimpleSubst:
    var new_entries = s.entries
    new_entries = new_entries.push((id, ty))
    SimpleSubst(entries: new_entries)

fn subst_get(s: SimpleSubst, id: i64) -> SimpleType?:
    for (k, v) in s.entries:
        if k == id:
            return Some(v)
    nil

fn subst_apply(s: SimpleSubst, t: SimpleType) -> SimpleType:
    match t:
        case TyVar(id, level):
            match subst_get(s, id):
                case Some(resolved): subst_apply(s, resolved)
                case _: t
        case TyFn(param, ret):
            ty_fn(subst_apply(s, param), subst_apply(s, ret))
        case _: t

# ============================================================================
# Unification
# ============================================================================

enum UnifyResult:
    Ok(subst: SimpleSubst)
    Err(msg: text)

fn occurs_check(id: i64, t: SimpleType) -> bool:
    """Check if variable id occurs in type t (prevents infinite types)."""
    match t:
        case TyVar(other_id, _): id == other_id
        case TyFn(param, ret): occurs_check(id, param) or occurs_check(id, ret)
        case _: false

fn unify(s: SimpleSubst, t1: SimpleType, t2: SimpleType) -> UnifyResult:
    """Unify two types, extending the substitution."""
    # Apply current substitution first
    val ty1 = subst_apply(s, t1)
    val ty2 = subst_apply(s, t2)

    match (ty1, ty2):
        # Same primitive types
        case (TyInt, TyInt): UnifyResult.Ok(subst: s)
        case (TyBool, TyBool): UnifyResult.Ok(subst: s)
        case (TyStr, TyStr): UnifyResult.Ok(subst: s)
        case (TyUnit, TyUnit): UnifyResult.Ok(subst: s)

        # Type variable unification
        case (TyVar(id1, _), TyVar(id2, _)):
            if id1 == id2:
                UnifyResult.Ok(subst: s)
            else:
                UnifyResult.Ok(subst: subst_add(s, id1, ty2))

        case (TyVar(id, _), _):
            if occurs_check(id, ty2):
                UnifyResult.Err(msg: "occurs check failed")
            else:
                UnifyResult.Ok(subst: subst_add(s, id, ty2))

        case (_, TyVar(id, _)):
            if occurs_check(id, ty1):
                UnifyResult.Err(msg: "occurs check failed")
            else:
                UnifyResult.Ok(subst: subst_add(s, id, ty1))

        # Function type unification
        case (TyFn(p1, r1), TyFn(p2, r2)):
            match unify(s, p1, p2):
                case Ok(s1):
                    unify(s1, r1, r2)
                case Err(msg):
                    UnifyResult.Err(msg: msg)

        case _:
            UnifyResult.Err(msg: "type mismatch")

fn unify_ok(t1: SimpleType, t2: SimpleType) -> bool:
    match unify(empty_subst(), t1, t2):
        case Ok(_): true
        case Err(_): false

fn unify_err(t1: SimpleType, t2: SimpleType) -> bool:
    match unify(empty_subst(), t1, t2):
        case Ok(_): false
        case Err(_): true

# ============================================================================
# Level-Based Generalization
# ============================================================================

fn collect_free_vars(t: SimpleType, level: i64) -> [i64]:
    """Collect type variables with level > given level (generalizable)."""
    match t:
        case TyVar(id, var_level):
            if var_level > level:
                [id]
            else:
                []
        case TyFn(param, ret):
            var result = collect_free_vars(param, level)
            for v in collect_free_vars(ret, level):
                var found = false
                for r in result:
                    if r == v:
                        found = true
                if not found:
                    result = result.push(v)
            result
        case _:
            []

fn can_generalize(t: SimpleType, current_level: i64) -> bool:
    """Check if type has variables that can be generalized."""
    collect_free_vars(t, current_level).len() > 0

# ============================================================================
# Specifications
# ============================================================================

describe "HM Type Inference Core":
    context "Fresh Type Variables":
        it "creates unique type variable IDs":
            reset_vars()
            val v1 = fresh_var()
            val v2 = fresh_var()
            val v3 = fresh_var()

            check(v1 == 0, "first var should be 0")
            check(v2 == 1, "second var should be 1")
            check(v3 == 2, "third var should be 2")

        it "creates type variables with levels":
            reset_vars()
            val t1 = ty_var(0)
            val t2 = ty_var(1)

            check(is_var(t1), "t1 should be var")
            check(is_var(t2), "t2 should be var")
            check(get_var_level(t1) == 0, "t1 at level 0")
            check(get_var_level(t2) == 1, "t2 at level 1")

    context "Unification":
        it "unifies same primitive types":
            check(unify_ok(ty_int(), ty_int()), "int = int")
            check(unify_ok(ty_bool(), ty_bool()), "bool = bool")
            check(unify_ok(ty_str(), ty_str()), "str = str")

        it "fails to unify different primitive types":
            check(unify_err(ty_int(), ty_bool()), "int != bool")
            check(unify_err(ty_str(), ty_int()), "str != int")
            check(unify_err(ty_bool(), ty_str()), "bool != str")

        it "unifies type variable with concrete type":
            reset_vars()
            val v = ty_var(0)

            match unify(empty_subst(), v, ty_int()):
                case Ok(s):
                    val resolved = subst_apply(s, v)
                    match resolved:
                        case TyInt: assert true
                        case _: assert false, "expected int"
                case Err(_):
                    check(false, "unification should succeed")

        it "unifies two type variables":
            reset_vars()
            val v1 = ty_var(0)
            val v2 = ty_var(0)

            # Unify v1 with v2
            match unify(empty_subst(), v1, v2):
                case Ok(s1):
                    # Then unify v1 with int
                    match unify(s1, v1, ty_int()):
                        case Ok(s2):
                            # Both should resolve to int
                            val r1 = subst_apply(s2, v1)
                            val r2 = subst_apply(s2, v2)
                            match (r1, r2):
                                case (TyInt, TyInt): assert true
                                case _: assert false, "both should be int"
                        case Err(_):
                            check(false, "second unification failed")
                case Err(_):
                    check(false, "first unification failed")

        it "detects occurs check violation":
            reset_vars()
            val v = ty_var(0)
            val fn_of_v = ty_fn(v, ty_int())  # v -> int

            # Try to unify v = v -> int (would create infinite type)
            check(unify_err(v, fn_of_v), "should fail occurs check")

        it "unifies function types":
            reset_vars()
            val f1 = ty_fn(ty_int(), ty_bool())
            val f2 = ty_fn(ty_int(), ty_bool())

            check(unify_ok(f1, f2), "same function types should unify")

        it "unifies function types with variables":
            reset_vars()
            val v = ty_var(0)
            val f1 = ty_fn(v, ty_bool())        # a -> bool
            val f2 = ty_fn(ty_int(), ty_bool()) # int -> bool

            match unify(empty_subst(), f1, f2):
                case Ok(s):
                    val resolved = subst_apply(s, v)
                    match resolved:
                        case TyInt: assert true
                        case _: assert false, "v should be int"
                case Err(_):
                    check(false, "unification should succeed")

    context "Level-Based Generalization":
        it "identifies variables at higher level as generalizable":
            reset_vars()
            # Simulate entering a let-binding (level 1)
            val v = ty_var(1)  # Created at level 1
            val fn_ty = ty_fn(v, v)  # a -> a at level 1

            # At level 0, variables at level 1 are generalizable
            val free_vars = collect_free_vars(fn_ty, 0)
            check(free_vars.len() == 1, "should have one generalizable var")

        it "does not generalize variables at same level":
            reset_vars()
            # Variable created at level 0
            val v = ty_var(0)
            val fn_ty = ty_fn(v, v)

            # At level 0, variables at level 0 are NOT generalizable
            val free_vars = collect_free_vars(fn_ty, 0)
            check(free_vars.len() == 0, "should have no generalizable vars")

        it "generalizes only higher-level vars in mixed type":
            reset_vars()
            val v0 = ty_var(0)  # At level 0 (bound in env)
            val v1 = ty_var(1)  # At level 1 (free)
            val fn_ty = ty_fn(v0, v1)  # v0 -> v1

            # At level 0, only v1 is generalizable
            val free_vars = collect_free_vars(fn_ty, 0)
            check(free_vars.len() == 1, "should have one generalizable var")
            check(free_vars[0] == get_var_id(v1), "v1 should be generalizable")

    context "Let-Polymorphism Concept":
        it "demonstrates identity can be used at multiple types":
            # Simulates: let id = \x: x in (id 1, id true)
            # The key insight: after generalizing id's type (forall a. a -> a),
            # each use gets fresh instantiation

            reset_vars()

            # First use: id(1) - instantiate with fresh var, unify with int
            val inst1_param = ty_var(0)
            val inst1 = ty_fn(inst1_param, inst1_param)
            val use1_arg = ty_int()

            match unify(empty_subst(), inst1_param, use1_arg):
                case Ok(s1):
                    val resolved1 = subst_apply(s1, inst1)
                    # inst1 should be int -> int
                    match resolved1:
                        case TyFn(TyInt, TyInt): assert true
                        case _: assert false, "expected int -> int"
                case Err(_):
                    check(false, "first use unification failed")

            # Second use: id(true) - NEW fresh var (independent instantiation)
            reset_vars()  # Reset to simulate fresh instantiation
            val inst2_param = ty_var(0)
            val inst2 = ty_fn(inst2_param, inst2_param)
            val use2_arg = ty_bool()

            match unify(empty_subst(), inst2_param, use2_arg):
                case Ok(s2):
                    val resolved2 = subst_apply(s2, inst2)
                    # inst2 should be bool -> bool
                    match resolved2:
                        case TyFn(TyBool, TyBool): assert true
                        case _: assert false, "expected bool -> bool"
                case Err(_):
                    check(false, "second use unification failed")

    context "Algorithm W Core Steps":
        it "infers identity function type":
            # Simulate: fn identity(x): x
            # 1. Create fresh var for param: a
            # 2. Return type = param type (since body is just x)
            # 3. Function type = a -> a
            reset_vars()
            val param_ty = ty_var(0)
            val return_ty = param_ty  # Body is just x
            val fn_ty = ty_fn(param_ty, return_ty)

            check(is_var(param_ty), "param is variable")
            match fn_ty:
                case TyFn(p, r):
                    check(get_var_id(p) == get_var_id(r), "param and return same var")
                case _:
                    check(false, "expected function type")

        it "infers application type":
            # Simulate: f(x) where f: a -> b, x: a
            # Result type should be b
            reset_vars()
            val a = ty_var(0)
            val b = ty_var(1)
            val f_ty = ty_fn(a, b)
            val x_ty = ty_int()

            # Unify param with arg
            match unify(empty_subst(), a, x_ty):
                case Ok(s):
                    # Result is b with substitution applied
                    val result = subst_apply(s, b)
                    # b is still a variable (no constraint on return)
                    check(is_var(result), "result is still variable")
                case Err(_):
                    check(false, "unification failed")
