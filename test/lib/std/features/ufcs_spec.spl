# @pending
# @skip - Uses unsupported keyword: with
"""
# UFCS (Uniform Function Call Syntax) Specification

**Feature IDs:** #3100-3120
**Category:** Syntax
**Difficulty:** 4/5
**Status:** Implemented

## Overview

UFCS (Uniform Function Call Syntax) allows calling free functions using method syntax.
When `x.method()` is called, the compiler resolves in priority order:
1. Instance method on x's type (highest priority)
2. Trait method implemented by x's type
3. Free function `method(x)` where first param matches x's type (UFCS)

This enables fluent API chaining without requiring methods to be defined on types.

## Syntax

```simple
# Free function
fn double(x: i64) -> i64:
    x * 2

# Usage via UFCS
val n = 5
val result = n.double()    # Resolves to: double(n)
```

## Key Concepts

| Concept | Description |
|---------|-------------|
| UFCS | Uniform Function Call Syntax - call free functions as methods |
| Resolution Priority | Instance > Trait > FreeFunction |
| Type Matching | First parameter type must be compatible with receiver |

## Implementation Notes

Files involved:
- `simple/compiler/hir.spl` - MethodResolution enum
- `simple/compiler/resolve.spl` - Resolution pass
- `simple/compiler/mir.spl` - Codegen support
- `simple/compiler/driver.spl` - Pipeline integration
"""
use std.spec.*

# ============================================================================
# Test Group 1: Basic UFCS Functionality
# ============================================================================

describe "UFCS Basic Functionality":
    """
    ## Basic UFCS Usage

    Tests basic UFCS functionality where free functions are called
    using method syntax on values.
    """

    context "with integer values":
        it "calls math.abs via dot notation":
            val n = -5
            val result = n.abs()
            expect result == 5

        it "calls math.sqrt via dot notation":
            val x = 16.0
            val result = x.sqrt()
            expect result == 4.0

    context "with array values":
        it "calls array.len via dot notation":
            val arr = [1, 2, 3, 4, 5]
            val result = arr.len()
            expect result == 5

        it "calls array.first via dot notation":
            val arr = [10, 20, 30]
            val result = arr.first()
            expect result == Some(10)

        it "calls array.last via dot notation":
            val arr = [10, 20, 30]
            val result = arr.last()
            expect result == Some(30)

# ============================================================================
# Test Group 2: Method Chaining
# ============================================================================

describe "UFCS Method Chaining":
    """
    ## Chaining UFCS Calls

    Multiple UFCS calls can be chained together for fluent APIs.
    """

    context "chaining multiple UFCS calls":
        it "chains abs and to_string":
            val n = -42
            val result = n.abs().to_string()
            expect result == "42"

        it "chains array operations":
            val arr = [1, 2, 3]
            val result = arr.len().to_string()
            expect result == "3"

# ============================================================================
# Test Group 3: Priority Ordering
# ============================================================================

describe "UFCS Priority Ordering":
    """
    ## Resolution Priority

    Method calls resolve in priority order:
    1. Instance method on receiver's type (highest)
    2. Trait method implemented by receiver's type
    3. Free function (UFCS) (lowest)

    This ensures existing methods are not accidentally overridden.
    """

    context "instance method takes priority":
        it "calls string.len method not free function":
            val s = "hello"
            val result = s.len()
            expect result == 5

        it "calls array.push method":
            var arr = [1, 2, 3]
            arr = arr.push(4)
            expect arr.len() == 4

# ============================================================================
# Test Group 4: Type Matching
# ============================================================================

describe "UFCS Type Matching":
    """
    ## Type Compatibility

    For UFCS, the receiver type must be compatible with the
    first parameter type of the free function.
    """

    context "exact type matching":
        it "matches i64 receiver with i64 parameter":
            val n: i64 = -5
            val result = n.abs()
            expect result == 5

        it "matches f64 receiver with f64 parameter":
            val x: f64 = 16.0
            val result = x.sqrt()
            expect result == 4.0

# ============================================================================
# Test Group 5: Edge Cases
# ============================================================================

describe "UFCS Edge Cases":
    """
    ## Edge Cases and Special Scenarios

    Tests for edge cases in UFCS resolution and usage.
    """

    context "with zero and negative values":
        it "works with zero":
            val n = 0
            val result = n.abs()
            expect result == 0

        it "works with negative float":
            val x = -3.14
            val result = x.abs()
            expect result == 3.14

    context "with empty collections":
        it "len of empty array is zero":
            val arr: [i64] = []
            val result = arr.len()
            expect result == 0

        it "first of empty array is None":
            val arr: [i64] = []
            val result = arr.first()
            expect result == None

    context "receiver as expression":
        it "works with literal receiver":
            val result = (-5).abs()
            expect result == 5

        it "works with arithmetic expression receiver":
            val result = (3 - 8).abs()
            expect result == 5
