"""
# Guard Clause Specification

**Feature IDs:** #GUARD-CLAUSE
**Category:** Syntax
**Status:** Implemented

Guard clauses (pattern guards) allow conditional matching within pattern match arms.
They combine pattern matching with boolean conditions using the `if` keyword after
the pattern to provide additional filtering before the arm body executes.

## Syntax

```simple
match value:
    case pattern if condition:
        body
```

## Key Behaviors

- Guard conditions are evaluated after pattern matching succeeds
- Variables bound in the pattern are available in the guard condition
- If the guard evaluates to false, matching continues to the next arm
- Guards can reference external variables from the enclosing scope
"""
use std.spec.*

describe "Guard Clauses":
    """
    ## Pattern Guard Specification

    Guard clauses provide conditional matching within match expressions.
    This test suite verifies:
    - Basic guard syntax with `case pattern if condition`
    - Variable binding access within guards
    - Guard evaluation order and fallthrough behavior
    - Interaction with different pattern types (literals, tuples, enums)
    - Complex guard expressions including comparisons and logical operators
    """

    context "basic integer guards":
        it "matches when guard is true":
            fn classify(x: i64) -> text:
                match x:
                    case n if n > 10:
                        "large"
                    case n if n > 0:
                        "small"
                    case _:
                        "non-positive"
            expect classify(15) == "large"

        it "falls through when guard is false":
            fn classify(x: i64) -> text:
                match x:
                    case n if n > 10:
                        "large"
                    case n if n > 0:
                        "small"
                    case _:
                        "non-positive"
            expect classify(5) == "small"

        it "reaches default case when all guards fail":
            fn classify(x: i64) -> text:
                match x:
                    case n if n > 10:
                        "large"
                    case n if n > 0:
                        "small"
                    case _:
                        "non-positive"
            expect classify(-5) == "non-positive"

    context "guards with equality checks":
        it "matches exact value via guard":
            fn identify(x: i64) -> text:
                match x:
                    case n if n == 0:
                        "zero"
                    case n if n == 42:
                        "answer"
                    case _:
                        "other"
            expect identify(0) == "zero"
            expect identify(42) == "answer"
            expect identify(99) == "other"

    context "guards with tuple patterns":
        it "uses bound variables in guard":
            fn check_sum(pair: (i64, i64)) -> text:
                match pair:
                    case (a, b) if a + b > 100:
                        "big sum"
                    case (a, b) if a == b:
                        "equal"
                    case _:
                        "other"
            expect check_sum((60, 50)) == "big sum"
            expect check_sum((5, 5)) == "equal"
            expect check_sum((1, 2)) == "other"

        it "guards with multiple comparisons":
            fn check_range(pair: (i64, i64)) -> text:
                match pair:
                    case (a, b) if a > 0 && b > 0:
                        "both positive"
                    case (a, b) if a < 0 && b < 0:
                        "both negative"
                    case _:
                        "mixed"
            expect check_range((5, 10)) == "both positive"
            expect check_range((-5, -10)) == "both negative"
            expect check_range((5, -10)) == "mixed"

    context "guards with enum patterns":
        it "filters enum payload with guard":
            enum Value:
                Num(i64)
                Empty

            fn categorize(v: Value) -> text:
                match v:
                    case Value::Num(n) if n > 100:
                        "large number"
                    case Value::Num(n) if n > 0:
                        "small number"
                    case Value::Num(n):
                        "non-positive"
                    case Value::Empty:
                        "empty"
            expect categorize(Value::Num(200)) == "large number"
            expect categorize(Value::Num(50)) == "small number"
            expect categorize(Value::Num(-5)) == "non-positive"
            expect categorize(Value::Empty) == "empty"

    context "guards with external variables":
        it "references variables from outer scope":
            val threshold = 50
            fn above_threshold(x: i64) -> bool:
                match x:
                    case n if n > threshold:
                        true
                    case _:
                        false
            expect above_threshold(75) == true
            expect above_threshold(25) == false

    context "guards with complex expressions":
        it "uses modulo in guard":
            fn parity(x: i64) -> text:
                match x:
                    case n if n % 2 == 0:
                        "even"
                    case _:
                        "odd"
            expect parity(10) == "even"
            expect parity(7) == "odd"

        it "uses logical or in guard":
            fn is_special(x: i64) -> bool:
                match x:
                    case n if n == 1 || n == 42 || n == 100:
                        true
                    case _:
                        false
            expect is_special(1) == true
            expect is_special(42) == true
            expect is_special(100) == true
            expect is_special(50) == false
