# Console I/O Framework - Basic E2E Test
# Uses MockPTY for testing without actual PTY system calls

import std.spec

# Mock PTY class for testing console operations
class MockPTY:
    is_open: bool
    buffer: text

impl MockPTY:
    static fn open() -> MockPTY:
        MockPTY(is_open: true, buffer: "")

    me write(data: text) -> ():
        self.buffer = self.buffer + data

    fn read() -> text:
        self.buffer

    me close() -> ():
        self.is_open = false

# Mock ConsoleSession for testing
class MockConsoleSession:
    output: text
    input_buffer: text

impl MockConsoleSession:
    static fn start(cmd: text) -> MockConsoleSession:
        # Mock start - simulates running a command
        MockConsoleSession(output: "test output", input_buffer: "")

    me send_keystroke(key: text) -> ():
        self.input_buffer = self.input_buffer + key

    fn get_output() -> text:
        self.output

describe "Console Framework":
    context "PTY operations":
        it "can open and close a PTY pair":
            val pty = MockPTY.open()
            expect pty.is_open == true
            pty.close()
            expect pty.is_open == false

        it "can write and read from PTY":
            val pty = MockPTY.open()
            pty.write("hello")
            expect pty.read() == "hello"
            pty.write(" world")
            expect pty.read() == "hello world"

    context "ConsoleSession":
        it "can spawn echo command":
            val session = MockConsoleSession.start("echo test")
            val output = session.get_output()
            expect output == "test output"

        it "can send keystrokes":
            val session = MockConsoleSession.start("cat")
            session.send_keystroke("a")
            session.send_keystroke("b")
            expect session.input_buffer == "ab"
