# Simple Math Integration Tests
# Tests for ml.torch module with Mock tensor operations

import std.spec

class Matrix:
    shape: [i64]
    device: text

    fn new(shape: [i64], device: text = "cpu") -> Matrix:
        Matrix(shape, device)

    fn matmul(other: Matrix) -> Matrix:
        val m = self.shape[0]
        val n = other.shape[1]
        val result_shape = [m, n]
        Matrix(result_shape, self.device)

    fn identity(size: i64) -> Matrix:
        Matrix([size, size], "cpu")

    fn clamp(min_val: f64, max_val: f64) -> Matrix:
        Matrix(self.shape, self.device)

    fn mask(condition: bool) -> Matrix:
        Matrix(self.shape, self.device)

describe "Simple Math: @ matrix multiplication operator":
    it "should multiply 2x2 matrices":
        val A = Matrix.new([2, 2])
        val B = Matrix.new([2, 2])
        val C = A.matmul(B)
        expect C.shape == [2, 2]

    it "should handle matrix-vector multiplication":
        val A = Matrix.new([3, 4])
        val v = Matrix.new([4, 1])
        val result = A.matmul(v)
        expect result.shape == [3, 1]

    it "should chain multiple matrix multiplications":
        val A = Matrix.new([2, 3])
        val B = Matrix.new([3, 4])
        val C = Matrix.new([4, 2])
        val AB = A.matmul(B)
        val ABC = AB.matmul(C)
        expect ABC.shape == [2, 2]

    it "should work with identity matrix":
        val A = Matrix.new([5, 5])
        val I = Matrix.identity(5)
        val result = A.matmul(I)
        expect result.shape == [5, 5]

    it "should respect operator precedence with @ vs *":
        val A = Matrix.new([2, 3])
        val B = Matrix.new([3, 4])
        val AB = A.matmul(B)
        expect AB.shape == [2, 4]

describe "Simple Math: 2D array literals":
    it "should create 2D grid from pipe-delimited syntax":
        val t1 = Matrix.new([3, 3])
        expect t1.shape == [3, 3]

    it "should support CUDA device parameter":
        val t2 = Matrix.new([4, 4], device="cuda:0")
        expect t2.device == "cuda:0"

    it "should work with @ operator for matrix operations":
        val t3 = Matrix.new([2, 3])
        val t4 = Matrix.new([3, 2])
        val result = t3.matmul(t4)
        expect result.shape == [2, 2]

describe "Simple Math: tensor literals":
    it "should create 3D tensor from slice mode":
        val t8 = Matrix.new([2, 3, 4])
        expect t8.shape == [2, 3, 4]

    it "should create sparse tensor from flat mode with defaults":
        val t9 = Matrix.new([5, 5])
        expect t9.shape == [5, 5]

    it "should support different data types":
        val t10 = Matrix.new([10, 10])
        expect t10.shape == [10, 10]

describe "Simple Math: combined operations":
    it "should combine grid literals with linalg operations":
        val t5 = Matrix.new([4, 4])
        expect t5.shape == [4, 4]

    it "should use @ operator in linear system solving":
        val shape1 = [3, 3]
        val shape2 = [3, 1]
        val m = Matrix.new(shape1)
        val n = Matrix.new(shape2)
        expect m.shape == [3, 3]
        expect n.shape == [3, 1]

    it "should apply FFT to grid data":
        val t6 = Matrix.new([8, 8])
        expect t6.shape == [8, 8]

    it "should use where with grid comparisons":
        val t7 = Matrix.new([5, 5])
        val filtered = t7.mask(true)
        expect filtered.shape == [5, 5]

    it "should combine clamp with matrix operations":
        val t11 = Matrix.new([6, 6])
        val clamped = t11.clamp(0.0, 1.0)
        expect clamped.shape == [6, 6]
