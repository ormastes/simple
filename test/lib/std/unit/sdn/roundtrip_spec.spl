"""
Feature: SDN Round-trip Serialization
Category: SDN Parser
Status: Complete
"""

# Tests for parse -> serialize -> parse idempotency.
#
# Ensures that:
# - Parsing SDN produces correct values
# - Serializing produces valid SDN
# - Re-parsing produces identical values

use std.spec.*
use sdn.parser.parse
use sdn.serializer.to_sdn
use sdn.value.SdnValue

describe "SDN Round-trip":
    """
    Verify parse -> serialize -> parse idempotency for all SDN value types.
    """
    context "parse -> serialize -> parse":
        it "preserves primitives":
            val source = "int_val: 42\nfloat_val: 3.14\nstr_val: hello\nbool_val: true\nnull_val: null"
            match parse(source):
                case Ok(original):
                    # Serialize
                    val serialized = to_sdn(original)

                    # Re-parse
                    match parse(serialized):
                        case Ok(reparsed):
                            # Verify values preserved
                            expect reparsed.get("int_val").flatmap(|v| v.as_i64()) == Some(42)
                            expect reparsed.get("str_val").flatmap(|v| v.as_str()) == Some("hello")
                            expect reparsed.get("bool_val").flatmap(|v| v.as_bool()) == Some(true)
                            expect reparsed.get("null_val").map(|v| v.is_null()) == Some(true)
                        case Err(e):
                            fail("Re-parse error: ${e.to_string()}")
                case Err(e):
                    fail("Parse error: ${e.to_string()}")

        it "preserves inline dicts":
            val source = "point = " + "{" + "xval: 10, yval: 20, zval: 30" + "}"
            match parse(source):
                case Ok(original):
                    val serialized = to_sdn(original)
                    match parse(serialized):
                        case Ok(reparsed):
                            match reparsed.get("point"):
                                case Some(reparsed_point):
                                    expect reparsed_point.get("xval").flatmap(|v| v.as_i64()) == Some(10)
                                    expect reparsed_point.get("yval").flatmap(|v| v.as_i64()) == Some(20)
                                    expect reparsed_point.get("zval").flatmap(|v| v.as_i64()) == Some(30)
                                case None:
                                    fail("Expected 'point' key")
                        case Err(e):
                            fail("Re-parse error: $${e.to_string()}")
                case Err(e):
                    fail("Parse error: $${e.to_string()}")

        it "preserves inline arrays":
            val source = "items = [1, 2, 3, 4, 5]"
            match parse(source):
                case Ok(original):
                    val serialized = to_sdn(original)
                    match parse(serialized):
                        case Ok(reparsed):
                            match reparsed.get("items"):
                                case Some(arr):
                                    match arr.as_array():
                                        case Some(list):
                                            expect list.len() == 5
                                            expect list[0].as_i64() == Some(1)
                                            expect list[4].as_i64() == Some(5)
                                        case None:
                                            fail("Expected array")
                                case None:
                                    fail("Expected 'items' key")
                        case Err(e):
                            fail("Re-parse error: ${e.to_string()}")
                case Err(e):
                    fail("Parse error: ${e.to_string()}")

        it "preserves block dicts":
            val source = "server:\n    host: localhost\n    port: 8080"
            match parse(source):
                case Ok(original):
                    val serialized = to_sdn(original)
                    match parse(serialized):
                        case Ok(reparsed):
                            expect reparsed.get_path("server.host").flatmap(|v| v.as_str()) == Some("localhost")
                            expect reparsed.get_path("server.port").flatmap(|v| v.as_i64()) == Some(8080)
                        case Err(e):
                            fail("Re-parse error: ${e.to_string()}")
                case Err(e):
                    fail("Parse error: ${e.to_string()}")

        it "preserves block arrays":
            val source = "fruits:\n    apple\n    banana\n    cherry"
            match parse(source):
                case Ok(original):
                    val serialized = to_sdn(original)
                    match parse(serialized):
                        case Ok(reparsed):
                            match reparsed.get("fruits"):
                                case Some(arr):
                                    expect arr.is_array() == true
                                    match arr.as_array():
                                        case Some(list):
                                            expect list.len() == 3
                                        case None:
                                            fail("Expected array")
                                case None:
                                    fail("Expected 'fruits' key")
                        case Err(e):
                            fail("Re-parse error: ${e.to_string()}")
                case Err(e):
                    fail("Parse error: ${e.to_string()}")

        it "preserves nested structures":
            val source = "config:\n    server:\n        host: localhost\n        port: 8080\n    database:\n        name: mydb\n        port: 5432"
            match parse(source):
                case Ok(original):
                    val serialized = to_sdn(original)
                    match parse(serialized):
                        case Ok(reparsed):
                            expect reparsed.get_path("config.server.host").flatmap(|v| v.as_str()) == Some("localhost")
                            expect reparsed.get_path("config.server.port").flatmap(|v| v.as_i64()) == Some(8080)
                            expect reparsed.get_path("config.database.name").flatmap(|v| v.as_str()) == Some("mydb")
                            expect reparsed.get_path("config.database.port").flatmap(|v| v.as_i64()) == Some(5432)
                        case Err(e):
                            fail("Re-parse error: ${e.to_string()}")
                case Err(e):
                    fail("Parse error: ${e.to_string()}")

        it "preserves tables":
            val source = "users |id, name, age|\n    1, Alice, 30\n    2, Bob, 25"
            match parse(source):
                case Ok(original):
                    val serialized = to_sdn(original)
                    match parse(serialized):
                        case Ok(reparsed):
                            match reparsed.get("users"):
                                case Some(table):
                                    expect table.is_table() == true
                                    expect table.row_count() == Some(2)
                                    expect table.column_count() == Some(3)
                                case None:
                                    fail("Expected 'users' table")
                        case Err(e):
                            fail("Re-parse error: ${e.to_string()}")
                case Err(e):
                    fail("Parse error: ${e.to_string()}")
