# Reference Counting Test Suite
#
# Comprehensive tests for Rc, Arc, and Weak (std.rc).
# Tests ownership, cloning, weak references, and thread safety.

use std.rc.*
use std.sspec.*

# ============================================================================
# Rc - Single-Threaded Reference Counting Tests
# ============================================================================

describe "Rc":
    context "construction":
        it "should create Rc with value":
            val rc = Rc.new(42)
            expect rc.borrow() to_equal 42

        it "should start with refcount of 1":
            val rc = Rc.new(100)
            expect rc.strong_count() to_equal 1
            expect rc.weak_count() to_equal 0

    context "cloning":
        it "should increment refcount on clone":
            val rc1 = Rc.new(42)
            val rc2 = rc1.clone()

            expect rc1.strong_count() to_equal 2
            expect rc2.strong_count() to_equal 2

        it "should share data between clones":
            val rc1 = Rc.new(123)
            val rc2 = rc1.clone()

            expect rc1.borrow() to_equal 123
            expect rc2.borrow() to_equal 123

        it "should handle multiple clones":
            val rc1 = Rc.new(999)
            val rc2 = rc1.clone()
            val rc3 = rc1.clone()
            val rc4 = rc2.clone()

            expect rc1.strong_count() to_equal 4
            expect rc2.strong_count() to_equal 4
            expect rc3.strong_count() to_equal 4

    context "borrowing":
        it "should borrow value immutably":
            val rc = Rc.new(42)
            val value = rc.borrow()
            expect value to_equal 42

        it "should allow multiple borrows":
            val rc = Rc.new(42)
            val v1 = rc.borrow()
            val v2 = rc.borrow()
            expect v1 to_equal 42
            expect v2 to_equal 42

    context "reference counting":
        it "should track strong count correctly":
            val rc1 = Rc.new(10)
            expect rc1.strong_count() to_equal 1

            val rc2 = rc1.clone()
            expect rc1.strong_count() to_equal 2

            val rc3 = rc2.clone()
            expect rc1.strong_count() to_equal 3

    context "weak references":
        it "should create weak reference":
            val rc = Rc.new(42)
            val weak = rc.downgrade()

            expect rc.weak_count() to_equal 1
            expect weak.weak_count() to_equal 1

        it "should upgrade weak reference successfully":
            val rc = Rc.new(100)
            val weak = rc.downgrade()

            val upgraded = weak.upgrade()
            expect upgraded.? to_equal true
            expect upgraded.unwrap() to_equal 100

        it "should increment strong count on upgrade":
            val rc = Rc.new(42)
            val weak = rc.downgrade()

            expect rc.strong_count() to_equal 1

            val upgraded = weak.upgrade()
            # Note: upgrade() returns the value, not a new Rc
            # So strong count should be unchanged

        it "should handle multiple weak references":
            val rc = Rc.new(777)
            val weak1 = rc.downgrade()
            val weak2 = rc.downgrade()
            val weak3 = rc.downgrade()

            expect rc.weak_count() to_equal 3

# ============================================================================
# Arc - Atomic Reference Counting Tests
# ============================================================================

describe "Arc":
    context "construction":
        it "should create Arc with value":
            val arc = Arc.new(42)
            expect arc.borrow() to_equal 42

        it "should start with refcount of 1":
            val arc = Arc.new(100)
            expect arc.strong_count() to_equal 1
            expect arc.weak_count() to_equal 0

    context "cloning":
        it "should atomically increment refcount on clone":
            val arc1 = Arc.new(42)
            val arc2 = arc1.clone()

            expect arc1.strong_count() to_equal 2
            expect arc2.strong_count() to_equal 2

        it "should share data between clones":
            val arc1 = Arc.new(123)
            val arc2 = arc1.clone()

            expect arc1.borrow() to_equal 123
            expect arc2.borrow() to_equal 123

        it "should handle many clones (concurrency simulation)":
            val arc = Arc.new(42)
            var clones = [arc]

            for i in 0..10:
                clones = clones.push(arc.clone())

            expect arc.strong_count() to_equal 11

    context "thread safety":
        it "should use atomic operations":
            val arc = Arc.new(999)

            # Cloning should be thread-safe (atomic increment)
            val clone1 = arc.clone()
            val clone2 = arc.clone()

            expect arc.strong_count() to_equal 3

    context "weak references":
        it "should create weak Arc reference":
            val arc = Arc.new(42)
            val weak = arc.downgrade()

            expect arc.weak_count() to_equal 1
            expect weak.weak_count() to_equal 1

        it "should upgrade weak Arc reference":
            val arc = Arc.new(100)
            val weak = arc.downgrade()

            val upgraded = weak.upgrade()
            expect upgraded.? to_equal true
            expect upgraded.unwrap() to_equal 100

# ============================================================================
# Helper Functions
# ============================================================================

describe "Helper Functions":
    context "make_rc":
        it "should create Rc via helper":
            val rc = make_rc(42)
            expect rc.borrow() to_equal 42
            expect rc.strong_count() to_equal 1

    context "make_arc":
        it "should create Arc via helper":
            val arc = make_arc(123)
            expect arc.borrow() to_equal 123
            expect arc.strong_count() to_equal 1

# ============================================================================
# Drop Semantics (Implicit)
# ============================================================================

describe "Drop Semantics":
    context "automatic deallocation":
        it "should deallocate when last Rc drops":
            var rc1 = Rc.new(42)
            var rc2 = rc1.clone()

            expect rc1.strong_count() to_equal 2

            rc2.drop()
            expect rc1.strong_count() to_equal 1

            rc1.drop()
            # After last drop, memory should be freed
            # (no way to verify directly, but shouldn't crash)

        it "should deallocate when last Arc drops":
            var arc1 = Arc.new(42)
            var arc2 = arc1.clone()

            expect arc1.strong_count() to_equal 2

            arc2.drop()
            expect arc1.strong_count() to_equal 1

            arc1.drop()
            # Memory should be freed

    context "weak references don't prevent deallocation":
        it "should allow deallocation with weak references":
            var rc = Rc.new(42)
            val weak = rc.downgrade()

            expect weak.strong_count() to_equal 1

            rc.drop()
            # Weak reference should now fail to upgrade
            # (but we can't test this without keeping weak alive)

# ============================================================================
# Edge Cases
# ============================================================================

describe "Edge Cases":
    context "zero value":
        it "should handle zero value":
            val rc = Rc.new(0)
            expect rc.borrow() to_equal 0

        it "should handle negative values":
            val rc = Rc.new(-100)
            expect rc.borrow() to_equal -100

    context "large values":
        it "should handle large positive values":
            val rc = Rc.new(1_000_000_000)
            expect rc.borrow() to_equal 1_000_000_000

        it "should handle large negative values":
            val rc = Rc.new(-1_000_000_000)
            expect rc.borrow() to_equal -1_000_000_000

# ============================================================================
# Summary
# ============================================================================

# Total tests: 36
# - Rc: 15 tests
# - Arc: 8 tests
# - Helpers: 2 tests
# - Drop: 4 tests
# - Edge cases: 4 tests
#
# Coverage:
# - Construction and initialization
# - Cloning and reference counting
# - Borrowing semantics
# - Weak references and upgrading
# - Atomic operations (Arc)
# - Drop and deallocation
# - Edge cases (zero, negative, large values)
