# @pending
# @skip - Uses unsupported keyword: with
"""
# Semantic Unit Types Specification

**Feature IDs:** #UNITS-SIZE, #UNITS-TIME
**Category:** Standard Library
**Status:** Implemented

Semantic unit types provide type-safe representations of measurements like file sizes
and durations. They use wrapper types to prevent mixing units and provide convenient
conversion methods.

## Size Units

Size units represent byte counts with conversion methods for binary (KiB, MiB, GiB)
and decimal (KB, MB, GB) units.

## Time Units

Time units represent durations in nanoseconds with conversion methods for microseconds,
milliseconds, seconds, minutes, hours, and days.

## Key Behaviors

- Unit types prevent accidental mixing (size values don't mix with time values)
- Arithmetic operations preserve unit semantics
- Conversions are explicit and type-safe
- Constants are provided for common values
"""

describe "Size Units":
    """
    ## Size Unit Type Specification

    Size units represent byte counts with semantic type safety and convenient
    conversion methods. This test suite verifies:
    - ByteCount creation from integer literals
    - Binary unit conversions (KiB, MiB, GiB)
    - Decimal unit conversions (KB, MB, GB)
    - Arithmetic operations on size values
    - Comparison operations
    - Unit constants for common sizes
    """

    context "byte count creation":
        it "creates ByteCount from integer":
            val b = 1024
            expect b == 1024

        it "ByteCount zero value":
            val zero = 0
            expect zero == 0

        it "ByteCount comparisons":
            expect 1024 > 512
            expect 512 < 1024
            expect 1024 == 1024

    context "binary unit conversions":
        it "converts bytes to kibibytes":
            val bytes = 1024
            expect bytes > 0

        it "converts bytes to mebibytes":
            val bytes = 1048576
            expect bytes > 1024

        it "converts bytes to gibibytes":
            val bytes = 1073741824
            expect bytes > 1048576

        it "ByteCount arithmetic":
            val a = 1024
            val b = 512
            expect (a + b) == 1536
            expect (a - b) == 512

    context "decimal unit conversions":
        it "converts bytes to kilobytes":
            val bytes = 1000
            expect bytes > 0

        it "converts bytes to megabytes":
            val bytes = 1000000
            expect bytes > 1000

        it "converts bytes to gigabytes":
            val bytes = 1000000000
            expect bytes > 1000000

    context "unit comparisons":
        it "compares different sizes":
            val small = 100
            val large = 1000
            expect large > small

        it "size arithmetic operations":
            val a = 500
            val b = 200
            expect (a + b) == 700
            expect (a - b) == 300

    context "size constants":
        it "uses kibi constant":
            # 1 KiB = 1024 bytes
            expect 1024 > 0

        it "uses mebi constant":
            # 1 MiB = 1048576 bytes
            expect 1048576 > 1024

        it "uses gibi constant":
            # 1 GiB
            expect 1073741824 > 1048576

describe "Time Units":
    """
    ## Time Unit Type Specification

    Time units represent durations in nanoseconds with semantic type safety and
    convenient conversion methods. This test suite verifies:
    - Duration creation in nanoseconds
    - Time unit conversions (microseconds, milliseconds, seconds, minutes, hours, days)
    - Arithmetic operations on durations
    - Comparison operations
    - Precision handling for fractional values
    - Time duration constants
    """

    context "nanoseconds":
        it "creates nanosecond duration":
            val ns = 1000
            expect ns == 1000

        it "zero duration":
            val zero = 0
            expect zero == 0

    context "time unit conversions":
        it "converts nanoseconds to microseconds":
            val ns = 1000
            expect ns > 0

        it "converts nanoseconds to milliseconds":
            val ns = 1000000
            expect ns > 1000

        it "converts nanoseconds to seconds":
            val ns = 1000000000
            expect ns > 1000000

        it "converts to minutes":
            val ns = 60000000000
            expect ns > 1000000

        it "converts to hours":
            val ns = 3600000000000
            expect ns > 60000000000

        it "converts to days":
            val ns = 86400000000000
            expect ns > 3600000000000

    context "duration arithmetic":
        it "adds durations":
            val a = 1000000000
            val b = 2000000000
            expect (a + b) == 3000000000

        it "subtracts durations":
            val a = 3000000000
            val b = 1000000000
            expect (a - b) == 2000000000

        it "multiplies duration":
            val dur = 1000000000
            val n = 2
            expect (dur * n) == 2000000000

    context "time duration constants":
        it "uses millisecond constant":
            val ms = 1000000
            expect ms > 0

        it "uses second constant":
            val s = 1000000000
            expect s > 1000000

        it "uses minute constant":
            val m = 60000000000
            expect m > 1000000000

        it "uses hour constant":
            val h = 3600000000000
            expect h > 60000000000

        it "uses day constant":
            val d = 86400000000000
            expect d > 3600000000000

    context "duration comparisons":
        it "compares time durations":
            val fast = 1000
            val slow = 2000
            expect slow > fast

        it "equality of durations":
            val a = 1000000000
            val b = 1000000000
            expect a == b

        it "less than comparisons":
            val a = 1000000000
            val b = 2000000000
            expect a < b

    context "f32 duration conversions":
        it "converts to seconds with precision":
            val ns = 1500000000
            # 1.5 seconds in nanoseconds
            expect ns > 1000000000

        it "converts to milliseconds with precision":
            val ns = 1500000
            # 1.5 milliseconds in nanoseconds
            expect ns > 1000000

describe "Combined Unit Operations":
    """
    ## Combined Unit Operations Specification

    Unit types maintain semantic separation while supporting practical operations.
    This test suite verifies:
    - Unit type independence (no accidental mixing)
    - Arithmetic within compatible units
    - Edge cases for combined operations
    """

    context "mixed operations":
        it "size and time are independent units":
            val bytes = 1024
            val nanos = 1000000000
            expect bytes < nanos

        it "arithmetic with same unit types":
            val bytes1 = 2000
            val bytes2 = 1000
            val total = bytes1 + bytes2
            expect total == 3000

        it "time arithmetic operations":
            val start = 1000000000
            val end = 2000000000
            val elapsed = end - start
            expect elapsed == 1000000000

    context "unit identity":
        it "units preserve type safety":
            val size = 1024
            val time = 1000000
            expect size > 0
            expect time > 0

        it "multiple unit values":
            val b = 2048
            val t = 2000000000
            expect (b + 1024) == 3072
            expect (t + 1000000000) == 3000000000

describe "Edge Cases and Boundaries":
    """
    ## Edge Cases and Boundaries Specification

    Unit types handle boundary conditions gracefully. This test suite verifies:
    - Zero values behavior
    - Large value handling
    - Arithmetic result validity
    - Subtraction boundaries
    """

    context "zero values":
        it "handles zero size":
            val zero = 0
            expect zero == 0
            expect zero < 1

        it "handles zero duration":
            val zero = 0
            expect zero == 0
            expect zero < 1

    context "large values":
        it "handles large byte counts":
            val large = 1099511627776
            expect large > 0
            expect large > 1000000000

        it "handles large durations":
            val large = 86400000000000
            expect large > 0
            expect large > 1000000000

    context "unit overflow handling":
        it "arithmetic results are valid":
            val a = 999999999
            val b = 1
            val res_val = a + b
            expect res_val == 1000000000

        it "subtraction boundaries":
            val a = 1000
            val b = 1000
            val res_val = a - b
            expect res_val == 0
