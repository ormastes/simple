# BDD Tests for ArchDiagramGenerator
# Feature: Diagram Generation - Architecture Diagrams
#
# Tests the Mermaid architecture diagram generator that shows
# only @architectural tagged entities and packages (default architectural).

import std.spec
import diagram.{CallEvent, CallEventRecorder, CallType}
import diagram.{ArchDiagramGenerator, generate_arch_diagram, to_mermaid_arch}
import diagram.{DiagramConfig}

describe "ArchDiagramGenerator":
    context "Basic structure":
        it "should generate mermaid flowchart header":
            val rec = CallEventRecorder.new("test")
            rec.mark_architectural("UserService")
            rec.record_call("method", Some("UserService"), [], CallType.Method)

            val output = to_mermaid_arch(rec)

            expect output.contains("```mermaid") == true
            expect output.contains("flowchart TD") == true
            expect output.contains("```") == true

    context "Architectural entity detection":
        it "should include @architectural tagged entities":
            val rec = CallEventRecorder.new("test")
            rec.mark_architectural("UserService")
            rec.mark_architectural("AuthService")
            rec.record_call("m", Some("UserService"), [], CallType.Method)
            rec.record_call("m", Some("AuthService"), [], CallType.Method)

            val output = to_mermaid_arch(rec)

            expect output.contains("UserService") == true
            expect output.contains("AuthService") == true

        it "should exclude non-architectural entities":
            val rec = CallEventRecorder.new("test")
            rec.mark_architectural("Service")
            rec.record_call("m", Some("Service"), [], CallType.Method)
            rec.record_call("m", Some("HelperClass"), [], CallType.Method)

            val output = to_mermaid_arch(rec)

            expect output.contains("Service") == true
            # HelperClass is not marked architectural and not a package
            # So it should be excluded (unless it matches package patterns)

        it "should treat packages as architectural by default":
            val rec = CallEventRecorder.new("test")
            # Qualified names with dots are treated as packages
            rec.record_call("method", Some("app.services.UserService"), [], CallType.Method)

            val output = to_mermaid_arch(rec)

            expect output.contains("app") == true

        it "should treat module paths as architectural":
            val rec = CallEventRecorder.new("test")
            # Double-colon paths (Rust style) are treated as packages
            rec.record_call("method", Some("crate::services::UserService"), [], CallType.Method)

            val output = to_mermaid_arch(rec)

            expect output.contains("crate") == true

    context "Package grouping":
        it "should group entities by package in subgraphs":
            val rec = CallEventRecorder.new("test")
            rec.mark_architectural("app.services.UserService")
            rec.mark_architectural("app.services.AuthService")
            rec.record_call("m", Some("app.services.UserService"), [], CallType.Method)
            rec.record_call("m", Some("app.services.AuthService"), [], CallType.Method)

            val output = to_mermaid_arch(rec)

            expect output.contains("subgraph") == true
            expect output.contains("app") == true

        it "should handle standalone entities without subgraph":
            val rec = CallEventRecorder.new("test")
            rec.mark_architectural("StandaloneService")
            rec.record_call("m", Some("StandaloneService"), [], CallType.Method)

            val output = to_mermaid_arch(rec)

            expect output.contains("StandaloneService") == true

    context "Dependency extraction":
        it "should show dependencies between architectural entities":
            val rec = CallEventRecorder.new("test")
            rec.mark_architectural("Controller")
            rec.mark_architectural("Service")

            rec.record_call("handleRequest", Some("Controller"), [], CallType.Method)
            rec.record_call("processData", Some("Service"), [], CallType.Method)

            val output = to_mermaid_arch(rec)

            expect output.contains("Controller") == true
            expect output.contains("Service") == true
            expect output.contains("-->") == true

        it "should not show dependencies to non-architectural entities":
            val rec = CallEventRecorder.new("test")
            rec.mark_architectural("Service")

            rec.record_call("method", Some("Service"), [], CallType.Method)
            rec.record_call("helper", Some("InternalHelper"), [], CallType.Method)

            val output = to_mermaid_arch(rec)

            expect output.contains("Service") == true
            # Dependency to InternalHelper should not be shown

        it "should track package-level dependencies":
            val rec = CallEventRecorder.new("test")
            rec.mark_architectural("app.controllers.UserController")
            rec.mark_architectural("app.services.UserService")

            rec.record_call("m", Some("app.controllers.UserController"), [], CallType.Method)
            rec.record_call("m", Some("app.services.UserService"), [], CallType.Method)

            val output = to_mermaid_arch(rec)

            # Should show package-level dependency
            expect output.contains("app") == true

        it "should not create self-dependencies":
            val rec = CallEventRecorder.new("test")
            rec.mark_architectural("Service")

            rec.record_call("method1", Some("Service"), [], CallType.Method)
            rec.record_call("method2", Some("Service"), [], CallType.Method)

            val output = to_mermaid_arch(rec)

            expect output.contains("Service --> Service") == false

    context "ID sanitization":
        it "should sanitize special characters in IDs":
            val rec = CallEventRecorder.new("test")
            rec.mark_architectural("app.services.UserService")
            rec.record_call("m", Some("app.services.UserService"), [], CallType.Method)

            val output = to_mermaid_arch(rec)

            # Dots should be replaced with underscores in IDs
            expect output.contains("app_services_UserService") == true

    context "Filtering":
        it "should apply include filter to architectural entities":
            val rec = CallEventRecorder.new("test")
            rec.mark_architectural("UserService")
            rec.mark_architectural("InternalService")

            rec.record_call("m", Some("UserService"), [], CallType.Method)
            rec.record_call("m", Some("InternalService"), [], CallType.Method)

            val config = DiagramConfig.new()
                .with_architecture()
                .with_include("User*")

            val output = generate_arch_diagram(rec, config)

            expect output.contains("UserService") == true
            expect output.contains("InternalService") == false

        it "should apply exclude filter":
            val rec = CallEventRecorder.new("test")
            rec.mark_architectural("UserService")
            rec.mark_architectural("DebugService")

            rec.record_call("m", Some("UserService"), [], CallType.Method)
            rec.record_call("m", Some("DebugService"), [], CallType.Method)

            val config = DiagramConfig.new()
                .with_architecture()
                .with_exclude("Debug*")

            val output = generate_arch_diagram(rec, config)

            expect output.contains("UserService") == true
            expect output.contains("DebugService") == false

describe "ArchEntity":
    context "Package detection":
        it "should detect package from dot notation":
            val rec = CallEventRecorder.new("test")
            rec.mark_architectural("app.services.User")
            rec.record_call("m", Some("app.services.User"), [], CallType.Method)

            val output = to_mermaid_arch(rec)
            expect output.contains("app") == true

        it "should detect package from double-colon notation":
            val rec = CallEventRecorder.new("test")
            rec.mark_architectural("crate::module::Service")
            rec.record_call("m", Some("crate::module::Service"), [], CallType.Method)

            val output = to_mermaid_arch(rec)
            expect output.contains("crate") == true

describe "ArchLayer":
    context "Layer classification":
        it "should handle unknown layer by default":
            val rec = CallEventRecorder.new("test")
            rec.mark_architectural("SomeService")
            rec.record_call("m", Some("SomeService"), [], CallType.Method)

            # Entities start with Unknown layer
            val output = to_mermaid_arch(rec)
            expect output.contains("SomeService") == true
