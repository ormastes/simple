# @pending
# @skip
"""
Mock Library Specification

Mock library for creating test doubles (mocks, stubs, spies) to isolate
units under test. Provides fluent API for stubbing methods and verifying
behavior.

Feature IDs: Testing Infrastructure - Mocking
Category: Testing
Status: Planned (Blocked on trait objects)
Priority: Medium

Key Concepts:
- Mock: Pre-programmed with expectations, verifies behavior
- Stub: Provides canned answers, no verification
- Spy: Records calls on real object
- Fake: Working implementation for testing
"""

# Local definitions (import system doesn't yet support cross-module types)

struct CallRecord:
    args: [text]
    timestamp: i64
    call_number: i32

struct Expectation:
    method_name: text
    expected_times: i32
    expected_args: Option<[text]>

class VerificationResult:
    passed: bool
    error_message: text

    static fn success() -> VerificationResult:
        VerificationResult(passed: true, error_message: "")

    static fn failure(message: text) -> VerificationResult:
        VerificationResult(passed: false, error_message: message)

    fn is_ok() -> bool:
        self.passed

    fn is_err() -> bool:
        not self.passed

    fn unwrap_err() -> text:
        self.error_message

class MockFunction:
    name: text
    calls: [CallRecord]
    return_values: [text]
    return_index: i32
    should_panic: bool
    panic_message: text
    expectations: [Expectation]

    static fn new(name: text) -> MockFunction:
        MockFunction(
            name: name,
            calls: [],
            return_values: [],
            return_index: 0,
            should_panic: false,
            panic_message: "",
            expectations: []
        )

    me record_call(args: [text]):
        val record = CallRecord(
            args: args,
            timestamp: 0,
            call_number: self.calls.len() as i32
        )
        self.calls.append(record)

    me set_return_values(values: [text]):
        self.return_values = values
        self.return_index = 0

    me set_panic(message: text):
        self.should_panic = true
        self.panic_message = message

    fn next_return_value() -> Option<text>:
        if self.return_index >= self.return_values.len() as i32:
            return nil
        val idx = self.return_index
        self.return_index = self.return_index + 1
        Some(self.return_values[idx])

    fn call_count() -> i32:
        self.calls.len() as i32

    fn was_called() -> bool:
        self.calls.len() > 0

    fn was_called_with(expected_args: [text]) -> bool:
        for call in self.calls:
            if call.args.len() == expected_args.len():
                var matches = true
                for i in 0..call.args.len():
                    if call.args[i] != expected_args[i]:
                        matches = false
                        break
                if matches:
                    return true
        false

    fn was_called_n_times(times: i32) -> bool:
        self.call_count() == times

    fn get_call(index: i32) -> Option<CallRecord>:
        if index >= 0 and index < self.calls.len() as i32:
            Some(self.calls[index as usize])
        else:
            nil

    fn get_last_call() -> Option<CallRecord>:
        if self.calls.len() > 0:
            Some(self.calls[self.calls.len() - 1])
        else:
            nil

    me reset():
        self.calls = []
        self.return_values = []
        self.return_index = 0
        self.should_panic = false
        self.panic_message = ""
        self.expectations = []

    fn summary() -> text:
        if self.calls.len() == 0:
            return "Mock '{self.name}': not called"
        var result = "Mock '{self.name}': called {self.call_count()} time(s)\n"
        for call in self.calls:
            result = result + "  {call.args}\n"
        result

struct MockBuilder:
    name: text

    static fn new(name: text) -> MockBuilder:
        MockBuilder(name: name)

    fn returns(self, values: [text]) -> MockFunction:
        val result = MockFunction.new(self.name)
        result.set_return_values(values)
        result

    fn panics(self, message: text) -> MockFunction:
        val result = MockFunction.new(self.name)
        result.set_panic(message)
        result

    fn build(self) -> MockFunction:
        MockFunction.new(self.name)

struct RegistryEntry:
    key: text
    mockfn: MockFunction

class MockRegistry:
    entries: [RegistryEntry]

    static fn new() -> MockRegistry:
        MockRegistry(entries: [])

    me register(key: text, mockfn: MockFunction):
        self.entries.append(RegistryEntry(key: key, mockfn: mockfn))

    fn get(key: text) -> Option<MockFunction>:
        for entry in self.entries:
            if entry.key == key:
                return Some(entry.mockfn)
        nil

    me reset_all():
        for entry in self.entries:
            entry.mockfn.reset()

fn create_mock(name: text) -> MockFunction:
    MockFunction.new(name)

fn verify_called(mockfn: MockFunction, times: i32) -> bool:
    mockfn.was_called_n_times(times)

fn verify_called_with(mockfn: MockFunction, args: [text]) -> bool:
    mockfn.was_called_with(args)

# ============================================================================
# Tests
# ============================================================================

describe "Mock Library - Phase 1 (Call Tracking)":
    """
    Test suite for Phase 1 of the Mock Library focusing on call tracking.

    Tests cover:
    - MockFunction Creation: Creating mocks with names, initializing call history
    - Call Recording: Recording function calls, tracking call counts, multiple calls with arguments
    - Argument Verification: Verifying calls with specific arguments, finding matches
    - Call Inspection: Retrieving specific calls by index, getting last call
    - Call Count Verification: Verifying exact call counts
    - Return Values: Sequential return values, handling exhausted values
    - Reset Functionality: Clearing call history and return value state
    - MockBuilder: Building mocks with return values or panic behavior
    - MockRegistry: Registering, retrieving, and resetting multiple mocks
    - Helper Functions: Convenience functions for creating and verifying mocks
    - Summary Output: Generating human-readable summaries of mock state
    """
    context "MockFunction Creation":
        it "creates mock with name":
            val m = MockFunction.new("save_user")
            expect m.call_count() == 0

        it "initializes empty call history":
            val m = MockFunction.new("test_fn")
            expect m.was_called() == false

    context "Call Recording":
        it "records function calls":
            val mfn = MockFunction.new("fetch_data")
            mfn.record_call(["user_id", "123"])
            expect mfn.was_called() == true

        it "tracks call count":
            val mfn = MockFunction.new("process")
            mfn.record_call([])
            mfn.record_call([])
            mfn.record_call([])
            expect mfn.call_count() == 3

        it "tracks multiple calls with different arguments":
            val mfn = MockFunction.new("send_message")
            mfn.record_call(["email", "user@test.com"])
            mfn.record_call(["sms", "555-1234"])
            expect mfn.call_count() == 2
            expect mfn.was_called_with(["email", "user@test.com"])
            expect mfn.was_called_with(["sms", "555-1234"])

    context "Argument Verification":
        it "verifies call with specific arguments":
            val mfn = MockFunction.new("update_user")
            mfn.record_call(["user_123", "Alice"])
            expect mfn.was_called_with(["user_123", "Alice"])

        it "returns false for unmatched arguments":
            val mfn = MockFunction.new("delete_record")
            mfn.record_call(["record_456"])
            expect mfn.was_called_with(["record_123"]) == false

        it "finds argument match in multiple calls":
            val mfn = MockFunction.new("log")
            mfn.record_call(["info", "Application started"])
            mfn.record_call(["error", "Connection failed"])
            mfn.record_call(["info", "Application stopped"])
            expect mfn.was_called_with(["error", "Connection failed"])

    context "Call Inspection":
        it "retrieves specific call by index":
            val mfn = MockFunction.new("api_call")
            mfn.record_call(["GET", "/users"])
            mfn.record_call(["POST", "/users"])
            val first_call = mfn.get_call(0)
            match first_call:
                Some(call): expect call.args[0] == "GET"
                nil: expect false

        it "returns none for out of bounds call":
            val mfn = MockFunction.new("my_fn")
            mfn.record_call(["arg"])
            val result = mfn.get_call(5)
            match result:
                Some(_): expect false
                nil: expect true

        it "retrieves last call":
            val mfn = MockFunction.new("sequence")
            mfn.record_call(["first"])
            mfn.record_call(["second"])
            mfn.record_call(["third"])
            val last = mfn.get_last_call()
            match last:
                Some(call): expect call.args[0] == "third"
                nil: expect false

    context "Call Count Verification":
        it "verifies exact call count":
            val mfn = MockFunction.new("handler")
            mfn.record_call([])
            mfn.record_call([])
            expect mfn.was_called_n_times(2)

        it "returns false for mismatched count":
            val mfn = MockFunction.new("processor")
            mfn.record_call([])
            expect mfn.was_called_n_times(5) == false

    context "Return Values":
        it "provides sequential return values":
            val mfn = MockFunction.new("fetch_config")
            mfn.set_return_values(["config_v1", "config_v2", "config_v3"])

            val r1 = mfn.next_return_value()
            val r2 = mfn.next_return_value()
            val r3 = mfn.next_return_value()

            expect r1 == Some("config_v1")
            expect r2 == Some("config_v2")
            expect r3 == Some("config_v3")

        it "returns none when return values exhausted":
            val mfn = MockFunction.new("limited")
            mfn.set_return_values(["one", "two"])

            mfn.next_return_value()
            mfn.next_return_value()
            val third = mfn.next_return_value()

            match third:
                Some(_): expect false
                nil: expect true

        it "resets return value index on reset":
            val mfn = MockFunction.new("reusable")
            mfn.set_return_values(["value"])

            mfn.next_return_value()
            mfn.reset()

            val after_reset = mfn.next_return_value()
            expect after_reset == Some("value")

    context "Reset Functionality":
        it "clears call history":
            val mfn = MockFunction.new("clearable")
            mfn.record_call(["arg1"])
            mfn.record_call(["arg2"])

            mfn.reset()
            expect mfn.call_count() == 0
            expect mfn.was_called() == false

        it "clears return value state":
            val mfn = MockFunction.new("return_reset")
            mfn.set_return_values(["a", "b"])
            mfn.next_return_value()

            mfn.reset()
            val value = mfn.next_return_value()
            expect value == Some("a")

    context "MockBuilder":
        it "builds mock with return values":
            val builder_mock = MockBuilder.new("get_user").returns(["user_data"])
            expect builder_mock.call_count() == 0
            val value = builder_mock.next_return_value()
            expect value == Some("user_data")

        it "builds mock that panics":
            val panic_mock = MockBuilder.new("fail_op").panics("Error occurred")
            expect panic_mock.should_panic == true
            expect panic_mock.panic_message == "Error occurred"

        it "builds basic mock":
            val basic_mock = MockBuilder.new("simple").build()
            expect basic_mock.call_count() == 0

    context "MockRegistry":
        it "registers and retrieves mocks":
            val registry = MockRegistry.new()
            val mfn = MockFunction.new("save_data")

            registry.register("save", mfn)
            val retrieved = registry.get("save")
            match retrieved:
                Some(_): expect true
                nil: expect false

        it "returns none for unregistered mock":
            val registry = MockRegistry.new()
            val result = registry.get("nonexistent")
            match result:
                Some(_): expect false
                nil: expect true

        it "resets all mocks":
            val registry = MockRegistry.new()
            val mock1 = MockFunction.new("mock1")
            val mock2 = MockFunction.new("mock2")

            mock1.record_call(["data"])
            mock2.record_call(["info"])

            registry.register("mock1", mock1)
            registry.register("mock2", mock2)

            registry.reset_all()

            expect mock1.was_called() == false
            expect mock2.was_called() == false

    context "Helper Functions":
        it "creates mock with helper":
            val mfn = create_mock("fetch_user")
            expect mfn.was_called() == false

        it "verifies call count with helper":
            val mfn = create_mock("process")
            mfn.record_call(["item1"])
            mfn.record_call(["item2"])
            expect verify_called(mfn, 2)

        it "verifies arguments with helper":
            val mfn = create_mock("save")
            mfn.record_call(["id_123", "data"])
            expect verify_called_with(mfn, ["id_123", "data"])

    context "Summary Output":
        it "generates summary for uncalled mock":
            val mfn = MockFunction.new("unused")
            val summary = mfn.summary()
            expect summary.contains("unused")
            expect summary.contains("not called")

        it "generates summary for called mock":
            val mfn = MockFunction.new("active")
            mfn.record_call(["arg1"])
            val summary = mfn.summary()
            expect summary.contains("active")
            expect summary.contains("1")

# ============================================================================
# Phase 2+ Features (Blocked on Trait Objects)
# ============================================================================

describe "Mock Library - Phase 2+ (Trait-based Mocking)":
    """
    Test suite for Phase 2+ of the Mock Library focusing on trait-based mocking.

    Note: These features are blocked on trait object support in Simple.

    Tests cover (planned):
    - MockBuilder: Creating mocks for traits, method chaining
    - Stubbing (when/returns): Stubbing methods to return values, throws, returns_once
    - Expectations (expect/verify): Verifying method calls, call counts, never called
    - Argument matching: Verifying with specific arguments, any(), gt(), contains(), predicates
    - Call recording: Recording all method calls, call counts per method, was_called helper
    - Reset functionality: Clearing call history, expectations, and stubs
    - Spy functionality: Wrapping real objects, partial stubbing
    - SSpec integration: Using mocks in test contexts, verifying expectations
    - Error cases: Reporting failed expectations, unexpected calls
    """
    context "MockBuilder":
        it "creates mock for trait":
            # trait Database:
            #     fn get_user(id: i32) -> Option<User>
            #
            # val mock_db = mock!(Database)
            # expect mock_db.is_some()
            expect true

        it "allows method chaining":
            # val mock_db = mock!(Database)
            #     .when("get_user").returns(None)
            #     .when("save_user").returns(Ok(()))
            #
            # expect mock_db.stubs.len() == 2
            expect true

    context "Stubbing (when/returns)":
        it "stubs method to return value":
            # val mock_db = mock!(Database)
            # mock_db.when("get_user").returns(Some(user))
            #
            # val result = mock_db.get_user(123)
            # expect result.is_some()
            # expect result.unwrap().id == 123
            expect true

        it "stubs different methods independently":
            # val mock = mock!(Service)
            # mocking.when("method_a").returns(42)
            # mocking.when("method_b").returns("hello")
            #
            # expect mocking.method_a() == 42
            # expect mocking.method_b() == "hello"
            expect true

        it "supports returns_once for one-time stub":
            # val mock = mock!(Service)
            # mocking.when("fetch").returns_once(Some(data))
            #
            # expect mocking.fetch().is_some()
            # expect mocking.fetch().is_none()  # Second call returns None
            expect true

        it "supports error results for error simulation":
            # NOTE: Use Result<T, text> pattern instead of exceptions
            # val mock = mock!(Service)
            # mocking.when("dangerous").returns_error("Simulated error")
            #
            # val result = mocking.dangerous()
            # match result:
            #     case Err(msg): check(msg == "Simulated error")
            #     case Ok(_): check(false)  # Should not succeed
            check(true)  # Placeholder until Result pattern is implemented

    context "Expectations (expect/verify)":
        it "verifies method was called":
            # val mock = mock!(Service)
            # mocking.expect("send").once()
            #
            # mocking.send("test")
            #
            # val result = mocking.verify()
            # expect result.is_ok()
            expect true

        it "verifies method was not called":
            # val mock = mock!(Service)
            # mocking.expect("send").never()
            #
            # # Don't call send()
            #
            # val result = mocking.verify()
            # expect result.is_ok()
            expect true

        it "verifies method called specific times":
            # val mock = mock!(Service)
            # mocking.expect("process").times(3)
            #
            # mocking.process()
            # mocking.process()
            # mocking.process()
            #
            # expect mocking.verify().is_ok()
            expect true

        it "fails verification when expectation not met":
            # val mock = mock!(Service)
            # mocking.expect("send").once()
            #
            # # Don't call send()
            #
            # val result = mocking.verify()
            # expect result.is_err()
            expect true

    context "Argument matching":
        it "verifies with specific arguments":
            # val mock = mock!(Service)
            # mocking.expect("send")
            #     .with_args([42, "test"])
            #     .once()
            #
            # mocking.send(42, "test")
            # expect mocking.verify().is_ok()
            expect true

        it "supports any() matcher":
            # val mock = mock!(Service)
            # mocking.expect("send")
            #     .with_args([any(), eq("test")])
            #     .once()
            #
            # mocking.send(999, "test")  # Any number accepted
            # expect mocking.verify().is_ok()
            expect true

        it "supports gt() matcher":
            # val mock = mock!(Service)
            # mocking.expect("process")
            #     .with_args([gt(10)])
            #
            # mocking.process(15)
            # expect mocking.verify().is_ok()
            expect true

        it "supports contains() matcher for strings":
            # val mock = mock!(Service)
            # mocking.expect("log")
            #     .with_args([contains("error")])
            #
            # mocking.log("Fatal error occurred")
            # expect mocking.verify().is_ok()
            expect true

        it "supports custom predicate matcher":
            # val mock = mock!(Service)
            # mocking.expect("validate")
            #     .with_args([predicate(\x: x % 2 == 0)])  # Even numbers
            #
            # mocking.validate(42)
            # expect mocking.verify().is_ok()
            expect true

    context "Call recording":
        it "records all method calls":
            # val mock = mock!(Service)
            #
            # mocking.method_a(1)
            # mocking.method_b("test")
            # mocking.method_a(2)
            #
            # expect mocking.calls.len() == 3
            # expect mocking.calls[0].method == "method_a"
            # expect mocking.calls[1].method == "method_b"
            expect true

        it "provides call count per method":
            # val mock = mock!(Service)
            #
            # mocking.process(1)
            # mocking.process(2)
            # mocking.send("test")
            #
            # expect mocking.call_count("process") == 2
            # expect mocking.call_count("send") == 1
            expect true

        it "provides was_called() helper":
            # val mock = mock!(Service)
            #
            # mocking.send("test")
            #
            # expect mocking.was_called("send")
            # expect not mocking.was_called("process")
            expect true

    context "Reset functionality":
        it "clears call history":
            # val mock = mock!(Service)
            # mocking.send("test")
            # expect mocking.calls.len() == 1
            #
            # mocking.reset()
            # expect mocking.calls.len() == 0
            expect true

        it "clears expectations":
            # val mock = mock!(Service)
            # mocking.expect("send").once()
            #
            # mocking.reset()
            # expect mocking.expectations.is_empty()
            expect true

        it "clears stubs":
            # val mock = mock!(Service)
            # mocking.when("get").returns(42)
            #
            # mocking.reset()
            # expect mocking.stubs.is_empty()
            expect true

    context "Spy functionality":
        it "wraps real object":
            # val real = RealService.new()
            # val spy = spy!(real)
            #
            # # Calls real implementation + records
            # val result = spy.compute(5)
            # expect result == real.compute(5)
            # expect spy.was_called("compute")
            expect true

        it "allows partial stubbing":
            # val real = RealService.new()
            # val spy = spy!(real)
            # spy.when("fetch").returns(Some(fake_data))
            #
            # # fetch() uses stub, other methods use real
            # expect spy.fetch() == Some(fake_data)
            # expect spy.compute(5) == real.compute(5)
            expect true

    context "Integration with SSpec":
        it "works in test context":
            # describe "UserService":
            #     it "fetches user from database":
            #         val mock_db = mock!(Database)
            #         mock_db.when("get_user").returns(Some(user))
            #
            #         val service = UserService(db: mock_db)
            #         val result = service.find_user(123)
            #
            #         expect result.is_some()
            expect true

        it "verifies expectations in test":
            # describe "EmailService":
            #     it "sends email on registration":
            #         val mock_email = mock!(EmailService)
            #         mock_email.expect("send").once()
            #
            #         register_user(mock_email)
            #
            #         expect mock_email.verify().is_ok()
            expect true

    context "Error cases":
        it "reports which expectation failed":
            # val mock = mock!(Service)
            # mocking.expect("send").times(2)
            # mocking.send("once")
            #
            # val result = mocking.verify()
            # expect result.is_err()
            # expect result.unwrap_err().contains("send")
            # expect result.unwrap_err().contains("expected 2")
            expect true

        it "reports unexpected calls":
            # val mock = mock!(Service)
            # mocking.expect("allowed").once()
            #
            # mocking.allowed()
            # mocking.unexpected()  # Not in expectations
            #
            # # Strict mode would fail here
            expect true
