# List<Option<T>>::compact() Tests
# Tests for the compact method that removes None values

describe "List<Option<T>>::compact()":

    describe "basic functionality":
    
        it "removes None values and unwraps Some values":
            val items: List<Option<i64>> = [Some(1), None, Some(2), None, Some(3)]
            val compacted = items.compact()
            expect(compacted.len()).to(eq(3))
            expect(compacted[0]).to(eq(1))
            expect(compacted[1]).to(eq(2))
            expect(compacted[2]).to(eq(3))
        
        it "handles empty list":
            val empty: List<Option<i64>> = []
            val compacted = empty.compact()
            expect(compacted.len()).to(eq(0))
        
        it "handles list with all None values":
            val all_none: List<Option<i64>> = [None, None, None]
            val compacted = all_none.compact()
            expect(compacted.len()).to(eq(0))
        
        it "handles list with all Some values":
            val all_some: List<Option<i64>> = [Some(1), Some(2), Some(3)]
            val compacted = all_some.compact()
            expect(compacted.len()).to(eq(3))
            expect(compacted[0]).to(eq(1))
            expect(compacted[1]).to(eq(2))
            expect(compacted[2]).to(eq(3))

    describe "with different types":
    
        it "works with text values":
            val words: List<Option<text>> = [Some("hello"), None, Some("world"), None]
            val compacted = words.compact()
            expect(compacted.len()).to(eq(2))
            expect(compacted[0]).to(eq("hello"))
            expect(compacted[1]).to(eq("world"))
        
        it "works with nested structures":
            val items: List<Option<List<i64>>> = [
                Some([1, 2]),
                None,
                Some([3, 4]),
                None,
                Some([5])
            ]
            val compacted = items.compact()
            expect(compacted.len()).to(eq(3))
            expect(compacted[0].len()).to(eq(2))
            expect(compacted[1].len()).to(eq(2))
            expect(compacted[2].len()).to(eq(1))

    describe "Ruby-style usage":
    
        it "chains with map and compact":
            val numbers = [1, 2, 3, 4, 5]
            # Map to Option, filter evens
            val mapped = numbers.map(fn(x): 
                if x % 2 == 0:
                    Some(x * 10)
                else:
                    None
            )
            val result = mapped.compact()
            expect(result.len()).to(eq(2))
            expect(result[0]).to(eq(20))
            expect(result[1]).to(eq(40))
        
        it "similar to Ruby's compact method":
            # Ruby: [1, nil, 2, nil, 3].compact => [1, 2, 3]
            # Simple: [Some(1), None, Some(2), None, Some(3)].compact() => [1, 2, 3]
            val items: List<Option<i64>> = [Some(1), None, Some(2), None, Some(3)]
            val result = items.compact()
            expect(result).to(eq([1, 2, 3]))

    describe "performance characteristics":
    
        it "creates new list without modifying original":
            val original: List<Option<i64>> = [Some(1), None, Some(2)]
            val compacted = original.compact()
            # Original unchanged
            expect(original.len()).to(eq(3))
            # New list created
            expect(compacted.len()).to(eq(2))
