# Memory Capabilities Model Tests
# Tests for reference capability system (Imm/Mut/Iso)

import std.spec
import std.verification.models.memory_capabilities as mc

describe "Memory Capabilities":

    # =========================================================================
    # Batch 1: Basic Types (3 tests)
    # =========================================================================

    context "RefCapability":
        it "converts to Lean names":
            assert mc.RefCapability.Imm.to_lean_name() == "Shared"
            assert mc.RefCapability.Mut.to_lean_name() == "Exclusive"
            assert mc.RefCapability.Iso.to_lean_name() == "Isolated"

    context "CapType":
        it "creates capability type with imm_type":
            val cap = mc.CapType.imm_type("Int")
            assert cap.cap == mc.RefCapability.Imm
            assert cap.type_name == "Int"

        it "converts to Lean syntax":
            val cap = mc.CapType.imm_type("Int")
            val lean = cap.to_lean()
            assert lean.size() > 0

    # =========================================================================
    # Batch 2: Reference (1 test)
    # =========================================================================

    context "Reference":
        it "creates reference through RefEnv":
            val env = mc.RefEnv.new()
            val cap_type = mc.CapType.mut_type("Int")
            env.add("x", cap_type)
            val ref_opt = env.get("x")
            assert ref_opt.is_some()

    # =========================================================================
    # Batch 3: RefEnv Shared References (3 tests)
    # =========================================================================

    context "RefEnv - Shared References":
        it "allows creating shared reference in empty environment":
            val env = mc.RefEnv.new()
            val cap_type = mc.CapType.imm_type("Int")
            env.add("x", cap_type)
            assert env.get("x").is_some()

        it "allows multiple shared references":
            val env = mc.RefEnv.new()
            val cap_type = mc.CapType.imm_type("Int")
            env.add("x", cap_type)
            env.add("y", cap_type)
            assert env.get("x").is_some()
            assert env.get("y").is_some()

        it "can add both imm and mut references":
            val env = mc.RefEnv.new()
            val imm_cap = mc.CapType.imm_type("Int")
            val mut_cap = mc.CapType.mut_type("Int")
            env.add("x", imm_cap)
            env.add("y", mut_cap)
            assert env.get("x").is_some()
            assert env.get("y").is_some()

    # =========================================================================
    # Batch 4: RefEnv Exclusive References (2 tests)
    # =========================================================================

    context "RefEnv - Exclusive References":
        it "allows exclusive reference in empty environment":
            val env = mc.RefEnv.new()
            val cap_type = mc.CapType.mut_type("Int")
            env.add("x", cap_type)
            assert env.get("x").is_some()

        it "can add multiple different capabilities":
            val env = mc.RefEnv.new()
            val mut_cap = mc.CapType.mut_type("Int")
            val imm_cap = mc.CapType.imm_type("String")
            env.add("x", mut_cap)
            env.add("y", imm_cap)
            assert env.get("x").is_some()
            assert env.get("y").is_some()

    # =========================================================================
    # Batch 5: RefEnv Isolated References (2 tests)
    # =========================================================================

    context "RefEnv - Isolated References":
        it "allows isolated reference in empty environment":
            val env = mc.RefEnv.new()
            val cap_type = mc.CapType.iso_type("Int")
            env.add("x", cap_type)
            assert env.get("x").is_some()

        it "can add iso with other capabilities":
            val env = mc.RefEnv.new()
            val iso_cap = mc.CapType.iso_type("Int")
            val imm_cap = mc.CapType.imm_type("String")
            env.add("x", iso_cap)
            env.add("y", imm_cap)
            assert env.get("x").is_some()
            assert env.get("y").is_some()

    # =========================================================================
    # Batch 6: Conversions (7 tests)
    # =========================================================================

    context "Capability Conversions":
        it "allows same capability conversion":
            assert mc.can_convert(mc.RefCapability.Mut, mc.RefCapability.Mut)
            assert mc.can_convert(mc.RefCapability.Iso, mc.RefCapability.Iso)
            assert mc.can_convert(mc.RefCapability.Imm, mc.RefCapability.Imm)

        it "allows exclusive to shared":
            assert mc.can_convert(mc.RefCapability.Mut, mc.RefCapability.Imm)

        it "allows isolated to exclusive":
            assert mc.can_convert(mc.RefCapability.Iso, mc.RefCapability.Mut)

        it "allows isolated to shared":
            assert mc.can_convert(mc.RefCapability.Iso, mc.RefCapability.Imm)

        it "prevents shared to exclusive":
            assert not mc.can_convert(mc.RefCapability.Imm, mc.RefCapability.Mut)

        it "prevents shared to isolated":
            assert not mc.can_convert(mc.RefCapability.Imm, mc.RefCapability.Iso)

        it "prevents exclusive to isolated":
            assert not mc.can_convert(mc.RefCapability.Mut, mc.RefCapability.Iso)

    # =========================================================================
    # Batch 7: Access Control (4 tests)
    # =========================================================================

    context "Memory Access":
        it "checks read access with all capabilities":
            val env = mc.RefEnv.new()
            val imm_cap = mc.CapType.imm_type("Int")
            val mut_cap = mc.CapType.mut_type("Int")
            val iso_cap = mc.CapType.iso_type("Int")
            env.add("imm_ref", imm_cap)
            env.add("mut_ref", mut_cap)
            env.add("iso_ref", iso_cap)

            match env.get("imm_ref"):
                case Some(ref):
                    assert mc.allows_access(ref, "read")
                case None:
                    assert false

        it "prevents write with immutable capability":
            val env = mc.RefEnv.new()
            val cap = mc.CapType.imm_type("Int")
            env.add("x", cap)
            match env.get("x"):
                case Some(ref):
                    assert not mc.allows_access(ref, "write")
                case None:
                    assert false

        it "allows write with exclusive capability":
            val env = mc.RefEnv.new()
            val cap = mc.CapType.mut_type("Int")
            env.add("x", cap)
            match env.get("x"):
                case Some(ref):
                    assert mc.allows_access(ref, "write")
                case None:
                    assert false

        it "allows write with isolated capability":
            val env = mc.RefEnv.new()
            val cap = mc.CapType.iso_type("Int")
            env.add("x", cap)
            match env.get("x"):
                case Some(ref):
                    assert mc.allows_access(ref, "write")
                case None:
                    assert false

    # =========================================================================
    # Batch 8: Concurrency Modes (4 tests)
    # =========================================================================

    context "Concurrency Modes":
        it "allows shared in actor mode":
            assert mc.capability_allowed_in_mode(
                mc.RefCapability.Imm,
                mc.ConcurrencyMode.Actor
            )

        it "allows isolated in actor mode":
            assert mc.capability_allowed_in_mode(
                mc.RefCapability.Iso,
                mc.ConcurrencyMode.Actor
            )

        it "prevents exclusive in actor mode":
            assert not mc.capability_allowed_in_mode(
                mc.RefCapability.Mut,
                mc.ConcurrencyMode.Actor
            )

        it "allows all in lock-based mode":
            assert mc.capability_allowed_in_mode(
                mc.RefCapability.Imm,
                mc.ConcurrencyMode.LockBase
            )
            assert mc.capability_allowed_in_mode(
                mc.RefCapability.Mut,
                mc.ConcurrencyMode.LockBase
            )
            assert mc.capability_allowed_in_mode(
                mc.RefCapability.Iso,
                mc.ConcurrencyMode.LockBase
            )
