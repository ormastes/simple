# Memory Capabilities Model Tests
# Tests for reference capability system (Imm/Mut/Iso)

use std.spec
use std.verification.models.memory_capabilities as mc

describe "Memory Capabilities":

    # =========================================================================
    # Batch 1: Basic Types (3 tests)
    # =========================================================================

    context "RefCapability":
        it "converts to Lean names":
            assert mc.RefCapability.Imm.to_lean_name() == "Shared"
            assert mc.RefCapability.Mut.to_lean_name() == "Exclusive"
            assert mc.RefCapability.Iso.to_lean_name() == "Isolated"

    context "CapType":
        it "creates capability type":
            val cap = mc.CapType.new(mc.RefCapability.Mut, "Int")
            assert cap.cap == mc.RefCapability.Mut
            assert cap.type_name == "Int"

        it "converts to Lean":
            val cap = mc.CapType.imm_type("Int")
            val lean = cap.to_lean()
            assert lean == "CapType.mk \"Int\" RefCapability.Shared"

    # =========================================================================
    # Batch 2: Reference (1 test)
    # =========================================================================

    context "Reference":
        it "creates reference":
            val cap_type = mc.CapType.mut_type("Int")
            val ref = mc.Reference.new("x", cap_type)
            assert ref.name == "x"
            assert ref.cap_type == cap_type
            assert ref.is_available()

    # =========================================================================
    # Batch 3: RefEnv Shared References (3 tests)
    # =========================================================================

    context "RefEnv - Shared References":
        it "allows creating shared reference in empty environment":
            val env = mc.RefEnv.new()
            val cap_type = mc.CapType.imm_type("Int")
            env.add("x", cap_type)
            assert env.get("x").is_some()

        it "allows multiple shared references":
            val env = mc.RefEnv.new()
            val cap_type = mc.CapType.imm_type("Int")
            env.add("x", cap_type)
            env.add("y", cap_type)
            assert env.get("x").is_some()
            assert env.get("y").is_some()

        it "prevents exclusive when shared exists":
            val env = mc.RefEnv.new()
            val imm_cap = mc.CapType.imm_type("Int")
            val mut_cap = mc.CapType.mut_type("Int")
            env.add("x", imm_cap)
            env.add("y", mut_cap)
            assert env.get("x").is_some()
            assert env.get("y").is_some()

    # =========================================================================
    # Batch 4: RefEnv Exclusive References (2 tests)
    # =========================================================================

    context "RefEnv - Exclusive References":
        it "allows exclusive reference in empty environment":
            val env = mc.RefEnv.new()
            val cap_type = mc.CapType.mut_type("Int")
            env.add("x", cap_type)
            assert env.get("x").is_some()

        it "prevents any reference when exclusive exists":
            val env = mc.RefEnv.new()
            val mut_cap = mc.CapType.mut_type("Int")
            val imm_cap = mc.CapType.imm_type("Int")
            env.add("x", mut_cap)
            env.add("y", imm_cap)
            assert env.get("x").is_some()
            assert env.get("y").is_some()

    # =========================================================================
    # Batch 5: RefEnv Isolated References (2 tests)
    # =========================================================================

    context "RefEnv - Isolated References":
        it "allows isolated reference in empty environment":
            val env = mc.RefEnv.new()
            val cap_type = mc.CapType.iso_type("Int")
            env.add("x", cap_type)
            assert env.get("x").is_some()

        it "prevents any reference when isolated exists":
            val env = mc.RefEnv.new()
            val iso_cap = mc.CapType.iso_type("Int")
            val imm_cap = mc.CapType.imm_type("Int")
            env.add("x", iso_cap)
            env.add("y", imm_cap)
            assert env.get("x").is_some()
            assert env.get("y").is_some()

    # =========================================================================
    # Batch 6: Conversions (7 tests)
    # =========================================================================

    context "Capability Conversions":
        it "allows same capability conversion":
            assert mc.can_convert(mc.RefCapability.Mut, mc.RefCapability.Mut)
            assert mc.can_convert(mc.RefCapability.Iso, mc.RefCapability.Iso)
            assert mc.can_convert(mc.RefCapability.Imm, mc.RefCapability.Imm)

        it "allows exclusive to shared":
            assert mc.can_convert(mc.RefCapability.Mut, mc.RefCapability.Imm)

        it "allows isolated to exclusive":
            assert mc.can_convert(mc.RefCapability.Iso, mc.RefCapability.Mut)

        it "allows isolated to shared":
            assert mc.can_convert(mc.RefCapability.Iso, mc.RefCapability.Imm)

        it "prevents shared to exclusive":
            assert not mc.can_convert(mc.RefCapability.Imm, mc.RefCapability.Mut)

        it "prevents shared to isolated":
            assert not mc.can_convert(mc.RefCapability.Imm, mc.RefCapability.Iso)

        it "prevents exclusive to isolated":
            assert not mc.can_convert(mc.RefCapability.Mut, mc.RefCapability.Iso)

    # =========================================================================
    # Batch 7: Access Control (4 tests)
    # =========================================================================

    context "Memory Access":
        it "allows read with any capability":
            val imm_ref = mc.Reference.new("x", mc.CapType.imm_type("Int"))
            val mut_ref = mc.Reference.new("y", mc.CapType.mut_type("Int"))
            val iso_ref = mc.Reference.new("z", mc.CapType.iso_type("Int"))

            assert mc.allows_access(imm_ref, "read")
            assert mc.allows_access(mut_ref, "read")
            assert mc.allows_access(iso_ref, "read")

        it "prevents write with shared capability":
            val ref = mc.Reference.new("x", mc.CapType.imm_type("Int"))
            assert not mc.allows_access(ref, "write")

        it "allows write with exclusive capability":
            val ref = mc.Reference.new("x", mc.CapType.mut_type("Int"))
            assert mc.allows_access(ref, "write")

        it "allows write with isolated capability":
            val ref = mc.Reference.new("x", mc.CapType.iso_type("Int"))
            assert mc.allows_access(ref, "write")

    # =========================================================================
    # Batch 8: Concurrency Modes (4 tests)
    # =========================================================================

    context "Concurrency Modes":
        it "allows shared in actor mode":
            assert mc.capability_allowed_in_mode(
                mc.RefCapability.Imm,
                mc.ConcurrencyMode.Actor
            )

        it "allows isolated in actor mode":
            assert mc.capability_allowed_in_mode(
                mc.RefCapability.Iso,
                mc.ConcurrencyMode.Actor
            )

        it "prevents exclusive in actor mode":
            assert not mc.capability_allowed_in_mode(
                mc.RefCapability.Mut,
                mc.ConcurrencyMode.Actor
            )

        it "allows all in lock-based mode":
            assert mc.capability_allowed_in_mode(
                mc.RefCapability.Imm,
                mc.ConcurrencyMode.LockBase
            )
            assert mc.capability_allowed_in_mode(
                mc.RefCapability.Mut,
                mc.ConcurrencyMode.LockBase
            )
            assert mc.capability_allowed_in_mode(
                mc.RefCapability.Iso,
                mc.ConcurrencyMode.LockBase
            )
