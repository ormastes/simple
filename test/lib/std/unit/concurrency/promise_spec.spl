/**
Promise<T> Specification Tests

Tests for the Promise type implementing async-by-default semantics.

NOTE: Simple language uses Result<T, E> for error handling, not exceptions.
Promise module has been updated to work without try-catch blocks.
*/

import spec

# Inline Promise implementation for testing
# (Using inline until module import works)

enum PromiseState:
    Pending
    Resolved(value)
    Rejected(error)

impl PromiseState:
    fn is_pending() -> bool:
        match self:
            case Pending: true
            case _: false

    fn is_resolved() -> bool:
        match self:
            case Resolved(_): true
            case _: false

    fn is_rejected() -> bool:
        match self:
            case Rejected(_): true
            case _: false

class Promise<T>:
    state: PromiseState
    callbacks: List

    fn new(executor) -> Promise<T>:
        var promise = Promise {
            state: PromiseState.Pending,
            callbacks: []
        }

        fn resolve(value):
            if promise.state.is_pending():
                promise.state = PromiseState.Resolved(value)

        fn reject(error):
            if promise.state.is_pending():
                promise.state = PromiseState.Rejected(error)

        executor(resolve, reject)
        return promise


    fn is_pending() -> bool:
        return self.state.is_pending()

    fn is_resolved() -> bool:
        return self.state.is_resolved()

    fn is_rejected() -> bool:
        return self.state.is_rejected()

# Helper functions for creating promises
fn make_resolved<T>(v: T) -> Promise<T>:
    return Promise {
        state: PromiseState.Resolved(v),
        callbacks: []
    }

fn make_rejected<T>(err) -> Promise<T>:
    return Promise {
        state: PromiseState.Rejected(err),
        callbacks: []
    }

describe "Promise<T> - Basic Operations":
    it "creates a resolved promise":
        val p = make_resolved(42)
        expect p.is_resolved()
        expect not p.is_pending()

    it "creates a rejected promise":
        val p = make_rejected("error")
        expect p.is_rejected()
        expect not p.is_pending()

    it "creates a promise with executor that resolves":
        val p = Promise.new(\resolve, reject: resolve(100))
        expect p.is_resolved()

    it "creates a promise with executor that rejects":
        val p = Promise.new(\resolve, reject: reject("failed"))
        expect p.is_rejected()

    it "starts as pending before executor runs":
        # For immediate executors, promise resolves synchronously
        # This tests the initial state construction
        val p = Promise {
            state: PromiseState.Pending,
            callbacks: []
        }
        expect p.is_pending()

describe "Promise<T> - State Management":
    it "resolves only once":
        var resolve_count = 0
        val p = Promise.new(\resolve, reject:
            resolve(1)
            resolve(2)  # Should be ignored
        )
        expect p.is_resolved()
        # Verify first value was used (can't check exact value without await)

    it "rejects only once":
        var reject_count = 0
        val p = Promise.new(\resolve, reject:
            reject("first")
            reject("second")  # Should be ignored
        )
        expect p.is_rejected()

    it "cannot transition from resolved to rejected":
        val p = Promise.new(\resolve, reject:
            resolve(42)
            reject("error")  # Should be ignored
        )
        expect p.is_resolved()
        expect not p.is_rejected()

    it "cannot transition from rejected to resolved":
        val p = Promise.new(\resolve, reject:
            reject("error")
            resolve(42)  # Should be ignored
        )
        expect p.is_rejected()
        expect not p.is_resolved()

    it "preserves state after creation":
        val p1 = make_resolved(10)
        val p2 = make_rejected("err")

        # Check states are stable
        expect p1.is_resolved()
        expect p2.is_rejected()

describe "Promise<T> - Type Safety":
    it "can hold integer values":
        val p = make_resolved(42)
        expect p.is_resolved()

    it "can hold string values":
        val p = make_resolved("hello")
        expect p.is_resolved()

    it "can hold errors as strings":
        val p = make_rejected("error message")
        expect p.is_rejected()

describe "Promise<T> - Edge Cases":
    it "handles nil resolution":
        val p = make_resolved(nil)
        expect p.is_resolved()

    it "handles nil rejection":
        val p = make_rejected(nil)
        expect p.is_rejected()

    it "handles empty callback list":
        val p = Promise {
            state: PromiseState.Resolved(42),
            callbacks: []
        }
        expect p.is_resolved()

describe "Promise<T> - Integration":
    it "works with match expressions on state":
        val p = make_resolved(100)
        var matched = false

        match p.state:
            case PromiseState.Resolved(v):
                matched = true
            case _:
                matched = false

        expect matched

    it "works with match expressions for rejection":
        val p = make_rejected("error")
        var matched = false

        match p.state:
            case PromiseState.Rejected(e):
                matched = true
            case _:
                matched = false

        expect matched

    it "executor receives both callbacks":
        var resolve_called = false
        var reject_called = false

        val p1 = Promise.new(\resolve, reject:
            resolve_called = true
            resolve(1)
        )

        val p2 = Promise.new(\resolve, reject:
            reject_called = true
            reject("err")
        )

        expect resolve_called
        expect reject_called
