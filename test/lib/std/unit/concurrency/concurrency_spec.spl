"""
Concurrency Specification Tests

Comprehensive tests for Simple's concurrency primitives including generators,
futures, async execution modes, isolated threads, and channel communication.
"""

# extern FFI declarations for concurrency tests
extern fn rt_thread_available_parallelism() -> i64
extern fn rt_thread_sleep(millis: i64)
extern fn rt_thread_yield()
extern fn rt_thread_spawn_isolated2(closure: Any, data1: Any, data2: Any) -> i64
extern fn rt_thread_join(handle: i64) -> Any
extern fn rt_channel_new() -> i64
extern fn rt_channel_send(channel_id: i64, value: Any)
extern fn rt_channel_try_recv(channel_id: i64) -> Any
extern fn rt_channel_recv(channel_id: i64) -> Any
extern fn rt_channel_close(channel_id: i64)
extern fn rt_channel_is_closed(channel_id: i64) -> i64
extern fn rt_time_now_seconds() -> f64

# Helper structs and functions
struct Channel:
    _id: i64

    fn send(value: Any):
        rt_channel_send(self._id, value)

    fn try_recv() -> Any:
        return rt_channel_try_recv(self._id)

    fn recv() -> Any:
        return rt_channel_recv(self._id)

    fn close():
        rt_channel_close(self._id)

    fn is_closed() -> bool:
        return rt_channel_is_closed(self._id) == 1

struct ThreadHandle:
    _handle: i64

    fn join() -> Any:
        return rt_thread_join(self._handle)

fn new_channel() -> Channel:
    val id = rt_channel_new()
    return Channel(_id: id)

fn available_parallelism() -> i64:
    return rt_thread_available_parallelism()

fn sleep(millis: i64):
    rt_thread_sleep(millis)

fn yield_thread():
    rt_thread_yield()

fn spawn_isolated2(data1: Any, data2: Any, closure: fn(Any, Any) -> Any) -> ThreadHandle:
    val handle = rt_thread_spawn_isolated2(closure=closure, data1=data1, data2=data2)
    return ThreadHandle(_handle: handle)

fn time_now() -> f64:
    return rt_time_now_seconds()

# BoundedChannel for testing (Python-style construction)
struct BoundedChannel<T>:
    capacity: i32
    buffer: List<T>
    closed: bool

    fn new(capacity: i32) -> BoundedChannel<T>:
        return BoundedChannel(capacity: capacity, buffer: [], closed: false)

    fn is_empty() -> bool:
        return self.buffer.is_empty()

    fn is_full() -> bool:
        return len(self.buffer) >= self.capacity

    fn is_closed() -> bool:
        return self.closed

    fn len() -> i32:
        return len(self.buffer)

    fn available() -> i32:
        return self.capacity - len(self.buffer)

    fn can_send() -> bool:
        return not self.closed and not self.is_full()

    fn send(value: T) -> bool:
        if self.closed:
            return false
        if len(self.buffer) >= self.capacity:
            return false
        self.buffer.push(value)
        return true

    fn recv() -> Any:
        if self.buffer.is_empty:
            return nil
        return self.buffer.pop_front()

    fn close():
        self.closed = true

describe "Concurrency":
    """
    Tests for all concurrency features including generators, futures,
    async execution modes, threads, and channels.
    """

    describe "Generators":
        describe "Basic generator operations":
            it "creates and yields single value":
                val gen = generator(\: yield 42)
                expect next(gen) == 42

            it "yields multiple values in sequence":
                val gen = generator(\: [yield 1, yield 2, yield 3])
                expect next(gen) == 1
                expect next(gen) == 2
                expect next(gen) == 3

            it "returns nil when exhausted":
                val gen = generator(\: yield 10)
                val first = next(gen)
                val second = next(gen)
                expect first == 10
                expect second == nil

        describe "Generator with captures":
            it "captures outer variables":
                val base = 100
                val gen = generator(\: [yield base, yield (base + 1)])
                expect next(gen) == 100
                expect next(gen) == 101

            it "captures multiple variables":
                val a = 10
                val b = 20
                val c = 30
                val gen = generator(\: [yield a, yield b, yield c])
                expect next(gen) + next(gen) + next(gen) == 60

        describe "Generator with computation":
            it "computes values before yield":
                val value = 2 * 3
                val gen = generator(\: yield value)
                expect next(gen) == 6

            it "performs arithmetic in yield":
                val x = 5
                val y = 3
                val gen = generator(\: yield (x * y + x))
                expect next(gen) == 20

        describe "Generator state machine":
            it "preserves state across yields":
                val gen = generator(\: (yield 10, yield 15)[1])
                val a = next(gen)
                val b = next(gen)
                expect a + b == 25

            it "handles nested iteration":
                val gen = generator(\: [yield 1, yield 2, yield 3, yield 4])
                val sum = next(gen) + next(gen) + next(gen) + next(gen)
                expect sum == 10

            it "handles exhaustion with capture":
                val value = 42
                val gen = generator(\: yield value)
                val first = next(gen)
                val second = next(gen)
                expect first == 42

    describe "Futures":
        describe "Basic future operations":
            it "creates and awaits a value":
                val f = future(42)
                expect await f == 42

            it "awaits computation result":
                val f = future(10 + 20 + 30)
                expect await f == 60

            it "awaits future-wrapped value":
                val x = future(42)
                expect await x == 42

        describe "Multiple futures":
            it "awaits multiple futures":
                val f1 = future(10)
                val f2 = future(20)
                val f3 = future(30)
                expect await f1 + await f2 + await f3 == 60

        describe "Future with captures":
            it "captures outer variable":
                val base = 40
                val f = future(base + 2)
                expect await f == 42

            it "captures multiple variables":
                val a = 10
                val b = 20
                val c = 12
                val f = future(a + b + c)
                expect await f == 42

    describe "Interpreter/Codegen Parity":
        describe "Generators":
            it "parity: basic sequence":
                val gen = generator(\: [yield 1, yield 2, yield 3])
                expect next(gen) + next(gen) + next(gen) == 6

            it "parity: single value":
                val gen = generator(\: yield 42)
                expect next(gen) == 42

            it "parity: multiple captures":
                val a = 10
                val b = 20
                val c = 30
                val gen = generator(\: [yield a, yield b, yield c])
                expect next(gen) + next(gen) + next(gen) == 60

        describe "Futures":
            it "parity: basic future":
                val f = future(42)
                expect await f == 42

            it "parity: future with capture":
                val base = 40
                val f = future(base + 2)
                expect await f == 42

            it "parity: multiple captures":
                val a = 10
                val b = 20
                val c = 12
                val f = future(a + b + c)
                expect await f == 42

    describe "Async Execution Modes":
        describe "Threaded Mode (default)":
            it "is in threaded mode by default":
                val mode = async_mode()
                expect mode == "threaded"

            it "futures execute in background":
                val f = future(42)
                expect await f == 42

            it "multiple concurrent futures":
                val f1 = future(10)
                val f2 = future(20)
                val f3 = future(30)
                expect await f1 + await f2 + await f3 == 60

            it "futures with computation":
                val f = future(10 + 20 + 30)
                expect await f == 60

            it "futures with captures":
                val base = 40
                val f = future(base + 2)
                expect await f == 42

        describe "Resolved and Rejected Futures":
            it "creates already-resolved future":
                val f = resolved(100)
                expect is_ready(f)
                expect await f == 100

            it "resolved future with different types":
                val f1 = resolved(42)
                val f2 = resolved("hello")
                expect await f1 == 42
                expect await f2 == "hello"

        describe "is_ready check":
            it "resolved future is ready immediately":
                val f = resolved(42)
                expect is_ready(f)

            it "can check and await":
                val f = future(42)
                val result = await f
                expect is_ready(f)
                expect result == 42

        describe "Worker Configuration":
            it "can configure worker count":
                async_workers(2)
                val f = future(42)
                expect await f == 42
                # Reset to default
                async_workers(4)

    describe "Isolated Threads":
        # Note: Full thread tests require interpreter FFI integration
        # which is implemented at the runtime level. These tests are
        # placeholders until the interpreter can call rt_thread_* functions.
        describe "Basic thread operations":
            it "reports available parallelism":
                # Requires FFI: rt_thread_available_parallelism
                val cores = available_parallelism()
                expect cores >= 1

            it "can sleep thread":
                # Requires FFI: rt_thread_sleep
                val start = time_now()
                sleep(10)
                val elapsed = time_now() - start
                expect elapsed >= 5

            it "can yield thread":
                # Requires FFI: rt_thread_yield
                yield_thread()
                expect true

        describe "Thread spawning":
            it "creates thread handle":
                # Test that spawn_isolated2 returns a valid handle
                val handle = spawn_isolated2(data1=42, data2=10) \x, y: nil
                expect handle != nil
                expect handle._handle >= 1

            it "joins thread and gets result":
                # Test basic join operation (synchronous for now)
                val handle = spawn_isolated2(data1=5, data2=3) \x, y: nil
                val result = handle.join()
                # Currently returns nil since closure execution is stub
                expect result == nil

            it "passes data to thread":
                # Test that data parameters are accepted
                val data1 = [1, 2, 3]
                val data2 = "test"
                val handle = spawn_isolated2(data1=data1, data2=data2) \d1, d2: nil
                expect handle != nil

            it "spawns isolated thread with channel communication":
                # Test that closures can execute and send values via channels
                # Uses raw channel ID instead of Channel struct for simplicity
                val ch_id = rt_channel_new()
                val handle = spawn_isolated2(data1=6, data2=ch_id) \data, channel_id:
                    # Send data directly via FFI
                    rt_channel_send(channel_id, data)
                    return nil
                val result = rt_channel_recv(ch_id)
                handle.join()
                expect result == 6

        describe "Channel FFI":
            # Channel tests using runtime FFI
            it "creates channel":
                # Requires FFI: rt_channel_new
                val ch = new_channel()
                expect ch != nil

            it "sends and receives on channel":
                # Requires FFI: rt_channel_send, rt_channel_try_recv
                val ch = new_channel()
                ch.send(42)
                val result = ch.try_recv()
                expect result == 42

            it "try_recv returns nil on empty channel":
                val ch = new_channel()
                val result = ch.try_recv()
                expect result == nil

            it "sends multiple values":
                val ch = new_channel()
                ch.send(1)
                ch.send(2)
                ch.send(3)
                expect ch.try_recv() == 1
                expect ch.try_recv() == 2
                expect ch.try_recv() == 3

            it "closes channel":
                # Requires FFI: rt_channel_close, rt_channel_is_closed
                val ch = new_channel()
                ch.send(42)
                ch.close()
                expect ch.is_closed()

    describe "BoundedChannel (Pure Simple)":
        # BoundedChannel tests - these don't require FFI
        describe "Basic operations":
            it "creates channel with capacity":
                val ch = BoundedChannel(10)
                expect ch.capacity == 10
                expect ch.is_empty()

            it "sends and receives values":
                val ch = BoundedChannel(10)
                ch.send(42)
                expect ch.len() == 1
                val result = ch.recv()
                expect result == 42

            it "handles empty channel recv":
                val ch = BoundedChannel(10)
                val result = ch.recv()
                expect result == nil

            it "respects capacity limit":
                val ch = BoundedChannel(2)
                expect ch.send(1)
                expect ch.send(2)
                expect not ch.send(3)  # Should fail, at capacity

            it "tracks channel state":
                val ch = BoundedChannel(5)
                ch.send(1)
                ch.send(2)
                expect ch.len() == 2
                expect ch.available() == 3
                expect not ch.is_full()
                expect ch.can_send()

            it "closes channel":
                val ch = BoundedChannel(10)
                ch.send(42)
                ch.close()
                expect ch.is_closed()
                expect not ch.send(99)  # Should fail, closed
