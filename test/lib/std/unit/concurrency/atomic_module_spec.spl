# Atomic Module Specification
#
# Tests for src/std/atomic.spl - the higher-level atomic API
# with MemoryOrdering support, built on rt_atomic_int_*/rt_atomic_bool_* SFFI.

use std.spec

# --- SFFI declarations (self-contained test) ---
extern fn rt_atomic_int_new(initial: i64) -> i64
extern fn rt_atomic_int_load(handle: i64) -> i64
extern fn rt_atomic_int_store(handle: i64, value: i64)
extern fn rt_atomic_int_swap(handle: i64, value: i64) -> i64
extern fn rt_atomic_int_compare_exchange(handle: i64, current: i64, new_value: i64) -> bool
extern fn rt_atomic_int_fetch_add(handle: i64, value: i64) -> i64
extern fn rt_atomic_int_fetch_sub(handle: i64, value: i64) -> i64
extern fn rt_atomic_int_fetch_and(handle: i64, value: i64) -> i64
extern fn rt_atomic_int_fetch_or(handle: i64, value: i64) -> i64
extern fn rt_atomic_int_fetch_xor(handle: i64, value: i64) -> i64
extern fn rt_atomic_int_free(handle: i64)

extern fn rt_atomic_bool_new(initial: bool) -> i64
extern fn rt_atomic_bool_load(handle: i64) -> bool
extern fn rt_atomic_bool_store(handle: i64, value: bool)
extern fn rt_atomic_bool_swap(handle: i64, value: bool) -> bool
extern fn rt_atomic_bool_free(handle: i64)

# ============================================================================
# MemoryOrdering enum (replicated for self-contained test)
# ============================================================================

enum MemoryOrdering:
    Relaxed
    Acquire
    Release
    AcqRel
    SeqCst

# ============================================================================
# AtomicI64 class (replicated for self-contained test)
# ============================================================================

class AtomicI64:
    _handle: i64

    fn load(ordering: MemoryOrdering) -> i64:
        rt_atomic_int_load(self._handle)

    fn store(value: i64, ordering: MemoryOrdering):
        rt_atomic_int_store(self._handle, value)

    fn swap(value: i64, ordering: MemoryOrdering) -> i64:
        rt_atomic_int_swap(self._handle, value)

    fn compare_exchange(expected: i64, new_value: i64, success_order: MemoryOrdering, failure_order: MemoryOrdering) -> bool:
        rt_atomic_int_compare_exchange(self._handle, expected, new_value)

    fn fetch_add(value: i64, ordering: MemoryOrdering) -> i64:
        rt_atomic_int_fetch_add(self._handle, value)

    fn fetch_sub(value: i64, ordering: MemoryOrdering) -> i64:
        rt_atomic_int_fetch_sub(self._handle, value)

    fn fetch_and(value: i64, ordering: MemoryOrdering) -> i64:
        rt_atomic_int_fetch_and(self._handle, value)

    fn fetch_or(value: i64, ordering: MemoryOrdering) -> i64:
        rt_atomic_int_fetch_or(self._handle, value)

    fn fetch_xor(value: i64, ordering: MemoryOrdering) -> i64:
        rt_atomic_int_fetch_xor(self._handle, value)

    fn increment(ordering: MemoryOrdering) -> i64:
        self.fetch_add(1, ordering)

    fn decrement(ordering: MemoryOrdering) -> i64:
        self.fetch_sub(1, ordering)

    fn free():
        rt_atomic_int_free(self._handle)

# ============================================================================
# AtomicUsize class (replicated for self-contained test)
# ============================================================================

class AtomicUsize:
    _handle: i64

    fn load(ordering: MemoryOrdering) -> i64:
        rt_atomic_int_load(self._handle)

    fn store(value: i64, ordering: MemoryOrdering):
        rt_atomic_int_store(self._handle, value)

    fn swap(value: i64, ordering: MemoryOrdering) -> i64:
        rt_atomic_int_swap(self._handle, value)

    fn compare_exchange(expected: i64, new_value: i64, success_order: MemoryOrdering, failure_order: MemoryOrdering) -> bool:
        rt_atomic_int_compare_exchange(self._handle, expected, new_value)

    fn fetch_add(value: i64, ordering: MemoryOrdering) -> i64:
        rt_atomic_int_fetch_add(self._handle, value)

    fn fetch_sub(value: i64, ordering: MemoryOrdering) -> i64:
        rt_atomic_int_fetch_sub(self._handle, value)

    fn free():
        rt_atomic_int_free(self._handle)

# ============================================================================
# AtomicBool class (replicated for self-contained test)
# ============================================================================

class AtomicBool:
    _handle: i64

    fn load(ordering: MemoryOrdering) -> bool:
        rt_atomic_bool_load(self._handle)

    fn store(value: bool, ordering: MemoryOrdering):
        rt_atomic_bool_store(self._handle, value)

    fn swap(value: bool, ordering: MemoryOrdering) -> bool:
        rt_atomic_bool_swap(self._handle, value)

    fn free():
        rt_atomic_bool_free(self._handle)

# ============================================================================
# AtomicI64 Tests
# ============================================================================

describe "AtomicI64":
    it "creates and loads initial value":
        val a = AtomicI64(_handle: rt_atomic_int_new(42))
        expect(a.load(MemoryOrdering.SeqCst)).to_equal(42)
        a.free()

    it "stores and loads new value":
        val a = AtomicI64(_handle: rt_atomic_int_new(0))
        a.store(100, MemoryOrdering.SeqCst)
        expect(a.load(MemoryOrdering.SeqCst)).to_equal(100)
        a.free()

    it "swaps value and returns old":
        val a = AtomicI64(_handle: rt_atomic_int_new(10))
        val old = a.swap(20, MemoryOrdering.SeqCst)
        expect(old).to_equal(10)
        expect(a.load(MemoryOrdering.SeqCst)).to_equal(20)
        a.free()

    it "compare_exchange succeeds on match":
        val a = AtomicI64(_handle: rt_atomic_int_new(10))
        val ok = a.compare_exchange(10, 20, MemoryOrdering.SeqCst, MemoryOrdering.SeqCst)
        expect(ok).to_equal(true)
        expect(a.load(MemoryOrdering.SeqCst)).to_equal(20)
        a.free()

    it "compare_exchange fails on mismatch":
        val a = AtomicI64(_handle: rt_atomic_int_new(10))
        val ok = a.compare_exchange(99, 20, MemoryOrdering.SeqCst, MemoryOrdering.SeqCst)
        expect(ok).to_equal(false)
        expect(a.load(MemoryOrdering.SeqCst)).to_equal(10)
        a.free()

    it "fetch_add returns old value":
        val a = AtomicI64(_handle: rt_atomic_int_new(10))
        val old = a.fetch_add(5, MemoryOrdering.SeqCst)
        expect(old).to_equal(10)
        expect(a.load(MemoryOrdering.SeqCst)).to_equal(15)
        a.free()

    it "fetch_sub returns old value":
        val a = AtomicI64(_handle: rt_atomic_int_new(20))
        val old = a.fetch_sub(7, MemoryOrdering.SeqCst)
        expect(old).to_equal(20)
        expect(a.load(MemoryOrdering.SeqCst)).to_equal(13)
        a.free()

    it "fetch_and bitwise operation":
        val a = AtomicI64(_handle: rt_atomic_int_new(15))
        val old = a.fetch_and(9, MemoryOrdering.SeqCst)
        expect(old).to_equal(15)
        expect(a.load(MemoryOrdering.SeqCst)).to_equal(9)
        a.free()

    it "fetch_or bitwise operation":
        val a = AtomicI64(_handle: rt_atomic_int_new(6))
        val old = a.fetch_or(9, MemoryOrdering.SeqCst)
        expect(old).to_equal(6)
        expect(a.load(MemoryOrdering.SeqCst)).to_equal(15)
        a.free()

    it "fetch_xor bitwise operation":
        val a = AtomicI64(_handle: rt_atomic_int_new(15))
        val old = a.fetch_xor(9, MemoryOrdering.SeqCst)
        expect(old).to_equal(15)
        expect(a.load(MemoryOrdering.SeqCst)).to_equal(6)
        a.free()

    it "increment and decrement":
        val a = AtomicI64(_handle: rt_atomic_int_new(10))
        val old_inc = a.increment(MemoryOrdering.SeqCst)
        expect(old_inc).to_equal(10)
        expect(a.load(MemoryOrdering.SeqCst)).to_equal(11)
        val old_dec = a.decrement(MemoryOrdering.SeqCst)
        expect(old_dec).to_equal(11)
        expect(a.load(MemoryOrdering.SeqCst)).to_equal(10)
        a.free()

# ============================================================================
# AtomicUsize Tests
# ============================================================================

describe "AtomicUsize":
    it "creates and loads initial value":
        val a = AtomicUsize(_handle: rt_atomic_int_new(42))
        expect(a.load(MemoryOrdering.SeqCst)).to_equal(42)
        a.free()

    it "stores and loads":
        val a = AtomicUsize(_handle: rt_atomic_int_new(0))
        a.store(100, MemoryOrdering.SeqCst)
        expect(a.load(MemoryOrdering.SeqCst)).to_equal(100)
        a.free()

    it "swaps and returns old":
        val a = AtomicUsize(_handle: rt_atomic_int_new(10))
        val old = a.swap(20, MemoryOrdering.SeqCst)
        expect(old).to_equal(10)
        expect(a.load(MemoryOrdering.SeqCst)).to_equal(20)
        a.free()

    it "compare_exchange works":
        val a = AtomicUsize(_handle: rt_atomic_int_new(5))
        val ok = a.compare_exchange(5, 10, MemoryOrdering.SeqCst, MemoryOrdering.SeqCst)
        expect(ok).to_equal(true)
        expect(a.load(MemoryOrdering.SeqCst)).to_equal(10)
        a.free()

    it "fetch_add and fetch_sub":
        val a = AtomicUsize(_handle: rt_atomic_int_new(100))
        a.fetch_add(50, MemoryOrdering.SeqCst)
        expect(a.load(MemoryOrdering.SeqCst)).to_equal(150)
        a.fetch_sub(30, MemoryOrdering.SeqCst)
        expect(a.load(MemoryOrdering.SeqCst)).to_equal(120)
        a.free()

# ============================================================================
# AtomicBool Tests
# ============================================================================

describe "AtomicBool via std.atomic":
    it "creates and loads initial value":
        val a = AtomicBool(_handle: rt_atomic_bool_new(true))
        expect(a.load(MemoryOrdering.SeqCst)).to_equal(true)
        a.free()

    it "stores and loads":
        val a = AtomicBool(_handle: rt_atomic_bool_new(false))
        a.store(true, MemoryOrdering.SeqCst)
        expect(a.load(MemoryOrdering.SeqCst)).to_equal(true)
        a.free()

    it "swaps and returns old":
        val a = AtomicBool(_handle: rt_atomic_bool_new(true))
        val old = a.swap(false, MemoryOrdering.SeqCst)
        expect(old).to_equal(true)
        expect(a.load(MemoryOrdering.SeqCst)).to_equal(false)
        a.free()

    it "works with Relaxed ordering":
        val a = AtomicBool(_handle: rt_atomic_bool_new(false))
        a.store(true, MemoryOrdering.Relaxed)
        expect(a.load(MemoryOrdering.Relaxed)).to_equal(true)
        a.free()
