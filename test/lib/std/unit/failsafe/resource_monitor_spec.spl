# @pending
"""
Resource Monitor Tests
Feature: Resource Monitoring and Protection
Category: FailSafe, Resources
Status: In Progress

Tests for resource usage tracking, alerts, and limits.
"""

use std.failsafe.core.*
use std.failsafe.resource_monitor.*

describe "ResourceType":
    it "converts to string":
        expect(ResourceType.Memory.to_string() == "memory")
        expect(ResourceType.FileHandles.to_string() == "file_handles")
        expect(ResourceType.Connections.to_string() == "connections")
        expect(ResourceType.Threads.to_string() == "threads")

describe "AlertLevel":
    it "converts to string":
        expect(AlertLevel.Info.to_string() == "info")
        expect(AlertLevel.Warning.to_string() == "warning")
        expect(AlertLevel.Critical.to_string() == "critical")
        expect(AlertLevel.Emergency.to_string() == "emergency")

describe "ResourceUsage":
    it "creates usage snapshot":
        val usage = ResourceUsage.new(ResourceType.Memory, 500, 1000)
        expect(usage.resource_type == ResourceType.Memory)
        expect(usage.current == 500)
        expect(usage.limit == 1000)

    it "calculates usage percent":
        val usage = ResourceUsage.new(ResourceType.Memory, 750, 1000)
        expect(usage.usage_percent() == 0.75)

    it "checks threshold":
        val usage = ResourceUsage.new(ResourceType.Memory, 850, 1000)
        expect(usage.is_over_threshold(0.8))
        expect(not usage.is_over_threshold(0.9))

    it "calculates available resources":
        val usage = ResourceUsage.new(ResourceType.Memory, 600, 1000)
        expect(usage.available() == 400)

    it "handles at-limit usage":
        val usage = ResourceUsage.new(ResourceType.Memory, 1000, 1000)
        expect(usage.available() == 0)
        expect(usage.usage_percent() == 1.0)

describe "ResourceLimits":
    it "creates default limits":
        val limits = ResourceLimits.default()
        expect(limits.memory_bytes == 1024 * 1024 * 1024)  # 1 GB
        expect(limits.max_file_handles == 1024)
        expect(limits.max_connections == 256)
        expect(limits.max_threads == 100)
        expect(limits.warning_threshold == 0.75)
        expect(limits.critical_threshold == 0.90)

    it "creates strict limits":
        val limits = ResourceLimits.strict()
        expect(limits.memory_bytes == 512 * 1024 * 1024)  # 512 MB
        expect(limits.max_file_handles == 256)
        expect(limits.warning_threshold == 0.60)
        expect(limits.critical_threshold == 0.80)

    it "creates permissive limits":
        val limits = ResourceLimits.permissive()
        expect(limits.memory_bytes == 4 * 1024 * 1024 * 1024)  # 4 GB
        expect(limits.max_file_handles == 4096)
        expect(limits.warning_threshold == 0.85)
        expect(limits.critical_threshold == 0.95)

describe "ResourceAlert":
    it "creates alert":
        val alert = ResourceAlert.new("alert_1", ResourceType.Memory, AlertLevel.Warning, "Memory high")

        expect(alert.id == "alert_1")
        expect(alert.resource_type == ResourceType.Memory)
        expect(alert.level == AlertLevel.Warning)
        expect(alert.message == "Memory high")
        expect(not alert.acknowledged)

    it "acknowledges alert":
        var alert = ResourceAlert.new("alert_1", ResourceType.Memory, AlertLevel.Warning, "Memory high")

        alert.acknowledge()
        expect(alert.acknowledged)

describe "ResourceMonitor":
    it "creates monitor with limits":
        val monitor = ResourceMonitor.new(ResourceLimits.default())
        expect(monitor.enabled)

    it "creates default monitor":
        val monitor = ResourceMonitor.default()
        expect(monitor.limits.memory_bytes == 1024 * 1024 * 1024)

    it "gets unacknowledged alerts":
        var monitor = ResourceMonitor.default()

        var alert1 = ResourceAlert.new("a1", ResourceType.Memory, AlertLevel.Warning, "Alert 1")
        var alert2 = ResourceAlert.new("a2", ResourceType.Memory, AlertLevel.Warning, "Alert 2")

        alert1.acknowledge()

        monitor.alerts.append(alert1)
        monitor.alerts.append(alert2)

        val unacked = monitor.get_unacknowledged_alerts()
        expect(unacked.len() == 1)

    it "acknowledges all alerts":
        var monitor = ResourceMonitor.default()

        monitor.alerts.append(ResourceAlert.new("a1", ResourceType.Memory, AlertLevel.Warning, "Alert 1"))
        monitor.alerts.append(ResourceAlert.new("a2", ResourceType.Memory, AlertLevel.Warning, "Alert 2"))

        monitor.acknowledge_all()

        val unacked = monitor.get_unacknowledged_alerts()
        expect(unacked.len() == 0)

    it "enables and disables monitoring":
        var monitor = ResourceMonitor.default()

        monitor.disable()
        expect(not monitor.enabled)

        monitor.enable()
        expect(monitor.enabled)

    it "resets state":
        var monitor = ResourceMonitor.default()

        monitor.alerts.append(ResourceAlert.new("a1", ResourceType.Memory, AlertLevel.Warning, "Alert 1"))
        monitor.stats.checks_performed = 100

        monitor.reset()

        expect(monitor.alerts.len() == 0)
        expect(monitor.stats.checks_performed == 0)

    it "checks all resources":
        var monitor = ResourceMonitor.default()

        match monitor.check_all():
            case FailSafeResult.Ok(_):
                expect(true)
            case FailSafeResult.Err(_):
                expect(false)

describe "ResourceMonitorStats":
    it "creates stats":
        val stats = ResourceMonitorStats.new()
        expect(stats.checks_performed == 0)
        expect(stats.threshold_violations == 0)
        expect(stats.alerts_raised == 0)

    it "calculates violation rate":
        var stats = ResourceMonitorStats.new()
        stats.checks_performed = 100
        stats.threshold_violations = 25

        expect(stats.violation_rate() == 0.25)

    it "handles zero division":
        val stats = ResourceMonitorStats.new()
        expect(stats.violation_rate() == 0.0)
