# Static Method Codegen Specification
#
# Tests that static methods work correctly in all execution modes:
# - Interpreter mode (tree-walking)
# - SMF mode (bytecode)
# - Native mode (AOT/JIT compilation)

describe "Static Method Codegen":
    context "Basic static method calls":
        it "compiles simple static method with no parameters":
            val code = """
            class Point:
                x: i64
                y: i64

                static fn origin() -> Point:
                    Point(x: 0, y: 0)

            fn main() -> i64:
                val p = Point.origin()
                p.x + p.y
            """

            # Should return 0 (0 + 0)
            # Test will be enabled when native mode is working
            skip "native mode not ready"

        it "compiles static method with parameters":
            val code = """
            class Rectangle:
                width: i64
                height: i64

                static fn create(w: i64, h: i64) -> Rectangle:
                    Rectangle(width: w, height: h)

            fn main() -> i64:
                val r = Rectangle.create(5, 3)
                r.width * r.height
            """

            # Should return 15 (5 * 3)
            skip "native mode not ready"

        it "compiles static method with return value":
            val code = """
            class Math:
                static fn add(a: i64, b: i64) -> i64:
                    a + b

                static fn multiply(a: i64, b: i64) -> i64:
                    a * b

            fn main() -> i64:
                val sum = Math.add(5, 3)
                val product = Math.multiply(4, 2)
                sum + product
            """

            # Should return 16 (8 + 8)
            skip "native mode not ready"

    context "Static method chaining":
        it "compiles chained static and instance methods":
            val code = """
            class Builder:
                value: i64

                static fn new() -> Builder:
                    Builder(value: 0)

                me set(v: i64):
                    self.value = v

                fn get() -> i64:
                    self.value

            fn main() -> i64:
                var b = Builder.new()
                b.set(42)
                b.get()
            """

            # Should return 42
            skip "native mode not ready"

        it "compiles multiple static calls in sequence":
            val code = """
            class Counter:
                count: i64

                static fn zero() -> Counter:
                    Counter(count: 0)

                static fn from(n: i64) -> Counter:
                    Counter(count: n)

            fn main() -> i64:
                val c1 = Counter.zero()
                val c2 = Counter.from(10)
                c1.count + c2.count
            """

            # Should return 10 (0 + 10)
            skip "native mode not ready"

    context "Static vs instance disambiguation":
        it "correctly distinguishes static and instance methods":
            val code = """
            class Calculator:
                value: i64

                # Static method - no self
                static fn create(init: i64) -> Calculator:
                    Calculator(value: init)

                # Instance method - has self
                fn double() -> i64:
                    self.value * 2

                # Instance method - modifies self
                me add(x: i64):
                    self.value = self.value + x

            fn main() -> i64:
                var calc = Calculator.create(5)
                val doubled = calc.double()
                calc.add(3)
                doubled + calc.value
            """

            # Should return 18 (10 + 8)
            skip "native mode not ready"

        it "handles same method name as static and instance":
            val code = """
            class Factory:
                name: text

                # Static version
                static fn get_name() -> text:
                    "Factory"

                # Instance version
                fn get_name() -> text:
                    self.name

            fn main() -> i64:
                val static_name = Factory.get_name()
                val instance = Factory(name: "MyFactory")
                val instance_name = instance.get_name()

                if static_name == "Factory" and instance_name == "MyFactory":
                    1
                else:
                    0
            """

            # Should return 1 (both work correctly)
            skip "native mode not ready"

    context "Static methods calling other methods":
        it "compiles static method calling another static method":
            val code = """
            class Math:
                static fn square(x: i64) -> i64:
                    x * x

                static fn sum_of_squares(a: i64, b: i64) -> i64:
                    Math.square(a) + Math.square(b)

            fn main() -> i64:
                Math.sum_of_squares(3, 4)
            """

            # Should return 25 (9 + 16)
            skip "native mode not ready"

        it "compiles static method calling instance method on created object":
            val code = """
            class Point:
                x: i64
                y: i64

                static fn origin() -> Point:
                    Point(x: 0, y: 0)

                static fn manhattan_from_origin(x: i64, y: i64) -> i64:
                    val p = Point(x: x, y: y)
                    p.manhattan()

                fn manhattan() -> i64:
                    self.x + self.y

            fn main() -> i64:
                Point.manhattan_from_origin(3, 4)
            """

            # Should return 7 (3 + 4)
            skip "native mode not ready"

    context "Edge cases":
        it "handles static method with no return value":
            val code = """
            class Logger:
                static fn log(message: text):
                    print message

            fn main() -> i64:
                Logger.log("test")
                42
            """

            # Should return 42 (and print "test")
            skip "native mode not ready"

        it "handles static method in nested class":
            val code = """
            class Outer:
                class Inner:
                    static fn value() -> i64:
                        100

            fn main() -> i64:
                Outer.Inner.value()
            """

            # Should return 100
            skip "native mode not ready - nested classes not implemented"

        it "handles static method with multiple return points":
            val code = """
            class Validator:
                static fn validate(x: i64) -> i64:
                    if x < 0:
                        return 0
                    if x > 100:
                        return 100
                    x

            fn main() -> i64:
                val a = Validator.validate(-5)
                val b = Validator.validate(50)
                val c = Validator.validate(150)
                a + b + c
            """

            # Should return 150 (0 + 50 + 100)
            skip "native mode not ready"

    context "Performance and stress tests":
        slow_it "handles 1000 static method calls efficiently":
            val code = """
            class Counter:
                static fn increment(x: i64) -> i64:
                    x + 1

            fn main() -> i64:
                var result = 0
                for i in 0..1000:
                    result = Counter.increment(result)
                result
            """

            # Should return 1000
            skip "native mode not ready"

        slow_it "handles deep call stack with static methods":
            val code = """
            class Fibonacci:
                static fn fib(n: i64) -> i64:
                    if n <= 1:
                        n
                    else:
                        Fibonacci.fib(n - 1) + Fibonacci.fib(n - 2)

            fn main() -> i64:
                Fibonacci.fib(10)
            """

            # Should return 55 (10th Fibonacci number)
            skip "native mode not ready"

        slow_it "handles static method with many parameters":
            val code = """
            class Calculator:
                static fn sum8(a: i64, b: i64, c: i64, d: i64, e: i64, f: i64, g: i64, h: i64) -> i64:
                    a + b + c + d + e + f + g + h

            fn main() -> i64:
                Calculator.sum8(1, 2, 3, 4, 5, 6, 7, 8)
            """

            # Should return 36 (sum of 1..8)
            skip "native mode not ready"

    context "Type system integration":
        it "handles generic static methods":
            val code = """
            class Container<T>:
                value: T

                static fn create<T>(v: T) -> Container<T>:
                    Container(value: v)

            fn main() -> i64:
                val c = Container.create(42)
                c.value
            """

            # Should return 42
            skip "generics + native mode not ready"

        it "handles static method returning Option":
            val code = """
            class Parser:
                static fn parse_int(s: text) -> i64?:
                    if s == "42":
                        Some(42)
                    else:
                        None

            fn main() -> i64:
                val result = Parser.parse_int("42")
                if result.?:
                    result.unwrap()
                else:
                    0
            """

            # Should return 42
            skip "native mode not ready"

# TODO: Enable tests once native codegen is complete
# Run with: simple test test/lib/std/unit/codegen/static_method_spec.spl --only-slow
