"""
CLI Library Unit Tests

Tests for command-line argument parsing functionality including
flags, options, positional arguments, subcommands, and help generation.
"""

use std.cli
use std.cli.types.ArgType

describe "CLI Library":
    """
    Tests for the CLI argument parser covering all parsing modes
    and argument types.
    """
    context "ArgParser":
        it "creates a parser with program name and description":
            val parser = cli.simple_parser("myapp", "My application")
            assert parser.get_program_name() == "myapp"
            assert parser.get_description() == "My application"

        it "adds flags to the parser":
            val parser = cli.simple_parser("myapp", "desc")
                .flag("verbose", "v", "Enable verbose output")
                .flag("debug", "d", "Enable debug mode")
            assert parser.arg_count() == 2

        it "adds options to the parser":
            val parser = cli.simple_parser("myapp", "desc")
                .option("output", "o", "Output file", false, nil)
                .required_option("input", "i", "Input file")
            assert parser.arg_count() == 2
            assert parser.has_required_args()

        it "adds positional arguments to the parser":
            val parser = cli.simple_parser("myapp", "desc")
                .positional("file", "File to process", true)
                .positional("dest", "Destination", false)
            assert parser.arg_count() == 2

        it "chains multiple argument definitions":
            val parser = cli.simple_parser("myapp", "desc")
                .flag("verbose", "v", "Verbose")
                .option("output", "o", "Output", false, nil)
                .positional("file", "File", true)
            assert parser.arg_count() == 3

    context "Parsing Flags":
        it "parses long-form flags":
            val parser = cli.simple_parser("myapp", "desc")
                .flag("verbose", "v", "Verbose")
            val result = parser.parse(["--verbose"])
            assert result.is_ok()
            val args = result.unwrap()
            assert args.get_flag("verbose") == true

        it "parses short-form flags":
            val parser = cli.simple_parser("myapp", "desc")
                .flag("verbose", "v", "Verbose")
            val result = parser.parse(["-v"])
            assert result.is_ok()
            val args = result.unwrap()
            assert args.get_flag("verbose") == true

        it "parses combined short flags":
            val parser = cli.simple_parser("myapp", "desc")
                .flag("all", "a", "All")
                .flag("brief", "b", "Brief")
                .flag("count", "c", "Count")
            val result = parser.parse(["-abc"])
            assert result.is_ok()
            val args = result.unwrap()
            assert args.get_flag("all") == true
            assert args.get_flag("brief") == true
            assert args.get_flag("count") == true

        it "defaults flag to false when not present":
            val parser = cli.simple_parser("myapp", "desc")
                .flag("verbose", "v", "Verbose")
            val result = parser.parse([])
            assert result.is_ok()
            val args = result.unwrap()
            assert args.get_flag("verbose") == false

    context "Parsing Options":
        it "parses long-form options":
            val parser = cli.simple_parser("myapp", "desc")
                .option("output", "o", "Output file", false, nil)
            val result = parser.parse(["--output", "file.txt"])
            assert result.is_ok()
            val args = result.unwrap()
            assert args.get_option("output") == Some("file.txt")

        it "parses short-form options":
            val parser = cli.simple_parser("myapp", "desc")
                .option("output", "o", "Output file", false, nil)
            val result = parser.parse(["-o", "file.txt"])
            assert result.is_ok()
            val args = result.unwrap()
            assert args.get_option("output") == Some("file.txt")

        it "parses options with equals sign":
            val parser = cli.simple_parser("myapp", "desc")
                .option("output", "o", "Output file", false, nil)
            val result = parser.parse(["--output=file.txt"])
            assert result.is_ok()
            val args = result.unwrap()
            assert args.get_option("output") == Some("file.txt")

        it "uses default value when option not present":
            val parser = cli.simple_parser("myapp", "desc")
                .optional_option("format", "f", "Format", "json")
            val result = parser.parse([])
            assert result.is_ok()
            val args = result.unwrap()
            assert args.get_option_or("format", "xml") == "json"

        it "reports error for missing required option":
            val parser = cli.simple_parser("myapp", "desc")
                .required_option("input", "i", "Input file")
            val result = parser.parse([])
            assert result.is_err()

    context "Parsing Positional Arguments":
        it "parses positional arguments in order":
            val parser = cli.simple_parser("myapp", "desc")
                .no_auto_stage()
                .positional("src", "Source", true)
                .positional("dst", "Destination", true)
            val result = parser.parse(["file1.txt", "file2.txt"])
            assert result.is_ok()
            val args = result.unwrap()
            assert args.get_positional_at(0) == Some("file1.txt")
            assert args.get_positional_at(1) == Some("file2.txt")

        it "reports error for missing required positional":
            val parser = cli.simple_parser("myapp", "desc")
                .no_auto_stage()
                .required_positional("file", "File to process")
            val result = parser.parse([])
            assert result.is_err()

        it "collects variadic positional arguments":
            val parser = cli.simple_parser("myapp", "desc")
                .no_auto_stage()
                .positional("files", "Files", false)
            val result = parser.parse(["a.txt", "b.txt", "c.txt"])
            assert result.is_ok()
            val args = result.unwrap()
            assert args.positional_count() == 3
            assert args.get_all_positionals() == ["a.txt", "b.txt", "c.txt"]

    context "Help Generation":
        it "generates usage string":
            val parser = cli.simple_parser("myapp", "My application")
                .flag("verbose", "v", "Verbose")
            # Help is auto-generated by print_help()
            assert parser.get_program_name() == "myapp"
            assert parser.has_args()

        it "generates help text":
            val parser = cli.simple_parser("myapp", "My application")
                .flag("verbose", "v", "Enable verbose output")
                .option("output", "o", "Output file", false, nil)
            # parser.print_help() would output the help text
            assert parser.arg_count() == 2

    context "Subcommands":
        it "parses subcommand name":
            val parser = cli.simple_parser("myapp", "desc")
                .subcommand("init", "Initialize project")
                .subcommand("build", "Build project")
            val result = parser.parse(["init"])
            assert result.is_ok()
            val args = result.unwrap()
            assert args.has_subcommand()
            assert args.get_subcommand() == Some("init")

        it "passes remaining args to subcommand parser":
            val parser = cli.simple_parser("myapp", "desc")
                .subcommand("run", "Run command")
            val result = parser.parse(["run", "--verbose", "script.spl"])
            assert result.is_ok()
            val args = result.unwrap()
            assert args.get_subcommand() == Some("run")
            val subcmd_args = args.get_subcommand_args()
            assert subcmd_args.len() == 2
            assert subcmd_args[0] == "--verbose"
            assert subcmd_args[1] == "script.spl"

    context "Combined Flags with Options":
        it "handles option value attached to combined flags":
            val parser = cli.simple_parser("myapp", "desc")
                .flag("verbose", "v", "Verbose")
                .option("output", "o", "Output", false, nil)
            val result = parser.parse(["-vofile.txt"])
            assert result.is_ok()
            val args = result.unwrap()
            assert args.get_flag("verbose") == true
            assert args.get_option("output") == Some("file.txt")

    context "Subcommand Aliases":
        it "parses subcommand by alias":
            val parser = cli.simple_parser("myapp", "desc")
                .subcommand_with_aliases("initialize", "Initialize project", ["init", "i"])
            val result = parser.parse(["init"])
            assert result.is_ok()
            val args = result.unwrap()
            assert args.get_subcommand() == Some("initialize")

    context "Helper Methods":
        it "provides summary information":
            val parser = cli.simple_parser("myapp", "desc")
                .flag("verbose", "v", "Verbose")
                .subcommand("run", "Run")
            assert parser.has_args()
            assert parser.has_subcommands()
            assert parser.subcommand_count() == 1

        it "provides parsed args summary":
            val parser = cli.simple_parser("myapp", "desc")
                .flag("verbose", "v", "Verbose")
            val result = parser.parse(["-v"])
            assert result.is_ok()
            val args = result.unwrap()
            assert args.has_flags()
            assert args.flag_count() == 1
