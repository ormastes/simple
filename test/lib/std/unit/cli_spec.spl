# @pending
# @skip
"""
CLI Library Unit Tests

Tests for command-line argument parsing functionality including
flags, options, positional arguments, subcommands, and help generation.
"""

use std.cli
use std.cli.types.ArgType
use std.spec.{check, check_msg}

describe "CLI Library":
    """
    Tests for the CLI argument parser covering all parsing modes
    and argument types.
    """
    context "ArgParser":
        it "creates a parser with program name and description":
            val parser = cli.simple_parser("myapp", "My application")
            check(parser.get_program_name() == "myapp")
            check(parser.get_description() == "My application")

        it "adds flags to the parser":
            val parser = cli.simple_parser("myapp", "desc")
                .flag("verbose", "v", "Enable verbose output")
                .flag("debug", "d", "Enable debug mode")
            check(parser.arg_count() == 2)

        it "adds options to the parser":
            val parser = cli.simple_parser("myapp", "desc")
                .option("output", "o", "Output file", false, nil)
                .required_option("input", "i", "Input file")
            check(parser.arg_count() == 2)
            check(parser.has_required_args())

        it "adds positional arguments to the parser":
            val parser = cli.simple_parser("myapp", "desc")
                .positional("file", "File to process", true)
                .positional("dest", "Destination", false)
            check(parser.arg_count() == 2)

        it "chains multiple argument definitions":
            val parser = cli.simple_parser("myapp", "desc")
                .flag("verbose", "v", "Verbose")
                .option("output", "o", "Output", false, nil)
                .positional("file", "File", true)
            check(parser.arg_count() == 3)

    context "Parsing Flags":
        it "parses long-form flags":
            val parser = cli.simple_parser("myapp", "desc")
                .flag("verbose", "v", "Verbose")
            val result = parser.parse(["--verbose"])
            check(result.is_ok())
            val args = result.unwrap()
            check(args.get_flag("verbose") == true)

        it "parses short-form flags":
            val parser = cli.simple_parser("myapp", "desc")
                .flag("verbose", "v", "Verbose")
            val result = parser.parse(["-v"])
            check(result.is_ok())
            val args = result.unwrap()
            check(args.get_flag("verbose") == true)

        it "parses combined short flags":
            val parser = cli.simple_parser("myapp", "desc")
                .flag("all", "a", "All")
                .flag("brief", "b", "Brief")
                .flag("count", "c", "Count")
            val result = parser.parse(["-abc"])
            check(result.is_ok())
            val args = result.unwrap()
            check(args.get_flag("all") == true)
            check(args.get_flag("brief") == true)
            check(args.get_flag("count") == true)

        it "defaults flag to false when not present":
            val parser = cli.simple_parser("myapp", "desc")
                .flag("verbose", "v", "Verbose")
            val result = parser.parse([])
            check(result.is_ok())
            val args = result.unwrap()
            check(args.get_flag("verbose") == false)

    context "Parsing Options":
        it "parses long-form options":
            val parser = cli.simple_parser("myapp", "desc")
                .option("output", "o", "Output file", false, nil)
            val result = parser.parse(["--output", "file.txt"])
            check(result.is_ok())
            val args = result.unwrap()
            check(args.get_option("output") == Some("file.txt"))

        it "parses short-form options":
            val parser = cli.simple_parser("myapp", "desc")
                .option("output", "o", "Output file", false, nil)
            val result = parser.parse(["-o", "file.txt"])
            check(result.is_ok())
            val args = result.unwrap()
            check(args.get_option("output") == Some("file.txt"))

        it "parses options with equals sign":
            val parser = cli.simple_parser("myapp", "desc")
                .option("output", "o", "Output file", false, nil)
            val result = parser.parse(["--output=file.txt"])
            check(result.is_ok())
            val args = result.unwrap()
            check(args.get_option("output") == Some("file.txt"))

        it "uses default value when option not present":
            val parser = cli.simple_parser("myapp", "desc")
                .optional_option("format", "f", "Format", "json")
            val result = parser.parse([])
            check(result.is_ok())
            val args = result.unwrap()
            check(args.get_option_or("format", "xml") == "json")

        it "reports error for missing required option":
            val parser = cli.simple_parser("myapp", "desc")
                .required_option("input", "i", "Input file")
            val result = parser.parse([])
            check(result.is_err())

    context "Parsing Positional Arguments":
        it "parses positional arguments in order":
            val parser = cli.simple_parser("myapp", "desc")
                .no_auto_stage()
                .positional("src", "Source", true)
                .positional("dst", "Destination", true)
            val result = parser.parse(["file1.txt", "file2.txt"])
            check(result.is_ok())
            val args = result.unwrap()
            check(args.get_positional_at(0) == Some("file1.txt"))
            check(args.get_positional_at(1) == Some("file2.txt"))

        it "reports error for missing required positional":
            val parser = cli.simple_parser("myapp", "desc")
                .no_auto_stage()
                .required_positional("file", "File to process")
            val result = parser.parse([])
            check(result.is_err())

        it "collects variadic positional arguments":
            val parser = cli.simple_parser("myapp", "desc")
                .no_auto_stage()
                .positional("files", "Files", false)
            val result = parser.parse(["a.txt", "b.txt", "c.txt"])
            check(result.is_ok())
            val args = result.unwrap()
            check(args.positional_count() == 3)
            check(args.get_all_positionals() == ["a.txt", "b.txt", "c.txt"])

    context "Help Generation":
        it "generates usage string":
            val parser = cli.simple_parser("myapp", "My application")
                .flag("verbose", "v", "Verbose")
            # Help is auto-generated by print_help()
            check(parser.get_program_name() == "myapp")
            check(parser.has_args())

        it "generates help text":
            val parser = cli.simple_parser("myapp", "My application")
                .flag("verbose", "v", "Enable verbose output")
                .option("output", "o", "Output file", false, nil)
            # parser.print_help() would output the help text
            check(parser.arg_count() == 2)

    context "Subcommands":
        it "parses subcommand name":
            val parser = cli.simple_parser("myapp", "desc")
                .subcommand("init", "Initialize project")
                .subcommand("build", "Build project")
            val result = parser.parse(["init"])
            check(result.is_ok())
            val args = result.unwrap()
            check(args.has_subcommand())
            check(args.get_subcommand() == Some("init"))

        it "passes remaining args to subcommand parser":
            val parser = cli.simple_parser("myapp", "desc")
                .subcommand("run", "Run command")
            val result = parser.parse(["run", "--verbose", "script.spl"])
            check(result.is_ok())
            val args = result.unwrap()
            check(args.get_subcommand() == Some("run"))
            val subcmd_args = args.get_subcommand_args()
            check(subcmd_args.len() == 2)
            check(subcmd_args[0] == "--verbose")
            check(subcmd_args[1] == "script.spl")

    context "Combined Flags with Options":
        it "handles option value attached to combined flags":
            val parser = cli.simple_parser("myapp", "desc")
                .flag("verbose", "v", "Verbose")
                .option("output", "o", "Output", false, nil)
            val result = parser.parse(["-vofile.txt"])
            check(result.is_ok())
            val args = result.unwrap()
            check(args.get_flag("verbose") == true)
            check(args.get_option("output") == Some("file.txt"))

    context "Subcommand Aliases":
        it "parses subcommand by alias":
            val parser = cli.simple_parser("myapp", "desc")
                .subcommand_with_aliases("initialize", "Initialize project", ["init", "i"])
            val result = parser.parse(["init"])
            check(result.is_ok())
            val args = result.unwrap()
            check(args.get_subcommand() == Some("initialize"))

    context "Helper Methods":
        it "provides summary information":
            val parser = cli.simple_parser("myapp", "desc")
                .flag("verbose", "v", "Verbose")
                .subcommand("run", "Run")
            check(parser.has_args())
            check(parser.has_subcommands())
            check(parser.subcommand_count() == 1)

        it "provides parsed args summary":
            val parser = cli.simple_parser("myapp", "desc")
                .flag("verbose", "v", "Verbose")
            val result = parser.parse(["-v"])
            check(result.is_ok())
            val args = result.unwrap()
            check(args.has_flags())
            check(args.flag_count() == 1)
