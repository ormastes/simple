"""
Feature: Process Execution FFI Functions
Category: Shell FFI
Status: Active
"""
# @skip

# Process Execution FFI Specification
# Tests for process execution operations using FFI functions from shell module

use spec.{describe, context, it, expect}
use shell.{shell, CommandResult}

describe "Process Execution FFI Functions":
    """
    FFI functions for executing external processes, capturing output,
    and handling process results with exit codes.
    """
    context "shell.run command execution":
        it "should execute simple command without arguments":
            # Test echo command (works on all systems)
            val result = shell.run("echo", ["Hello"])
            expect(result.ok()).to_be(true)
            expect(result.stdout).to_contain("Hello")
            expect(result.exit_code).to_equal(0)

        it "should execute command with multiple arguments":
            # Test echo with multiple words
            val result = shell.run("echo", ["Hello", "World"])
            expect(result.ok()).to_be(true)
            expect(result.stdout).to_contain("Hello")
            expect(result.stdout).to_contain("World")

        it "should capture stdout correctly":
            val result = shell.run("echo", ["test output"])
            expect(result.ok()).to_be(true)
            expect(result.stdout).to_not_equal("")
            expect(result.stderr).to_equal("")

        it "should handle command that returns non-zero exit code":
            # Test with a command that fails (ls on non-existent file)
            val result = shell.run("ls", ["/nonexistent/path/that/does/not/exist"])
            expect(result.err()).to_be(true)
            expect(result.exit_code).to_not_equal(0)

        it "should handle empty arguments list":
            val result = shell.run("pwd", [])
            expect(result.ok()).to_be(true)
            expect(result.stdout).to_not_equal("")

        it "should distinguish stdout from stderr":
            # Write to stderr using shell redirection if available
            # This test is platform-dependent, so just verify basic functionality
            val result = shell.run("ls", ["/"])
            expect(result.stdout).to_not_equal("")

    context "CommandResult helper methods":
        it "should correctly identify successful execution with ok()":
            val result = shell.run("echo", ["test"])
            expect(result.ok()).to_be(true)

        it "should correctly identify failed execution with err()":
            val result = shell.run("ls", ["/nonexistent"])
            expect(result.err()).to_be(true)

        it "should have inverse relationship between ok() and err()":
            val result1 = shell.run("echo", ["test"])
            expect(result1.ok()).to_equal(not result1.err())

            val result2 = shell.run("ls", ["/nonexistent"])
            expect(result2.ok()).to_equal(not result2.err())

    context "edge cases":
        it "should handle commands with special characters in arguments":
            # Test with arguments containing spaces (properly quoted)
            val result = shell.run("echo", ["hello world", "test"])
            expect(result.ok()).to_be(true)

        it "should handle long command output":
            # List a directory that likely has many files
            val result = shell.run("ls", ["-la", "/usr/bin"])
            expect(result.ok()).to_be(true)
            expect(result.stdout.len()).to_be_greater_than(0)

        it "should execute command in current environment":
            # Test that environment is accessible
            val result = shell.run("pwd", [])
            expect(result.ok()).to_be(true)
            expect(result.stdout).to_not_equal("")
