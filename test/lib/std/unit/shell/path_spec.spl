# @pending
# @skip
"""
Feature: Path Manipulation
Category: Filesystem
Status: Active
"""

# Path Manipulation Specification
# Tests for pure Simple path manipulation functions.
# Uses inline functions instead of imported Path class to avoid
# bootstrap runtime bug where self.field returns nil on imported classes.

use spec.{describe, context, it, expect}

# --- Pure Simple path helpers (no class, no imports) ---

fn path_basename(path: text) -> text:
    if path == "":
        return ""
    # Strip trailing slashes
    var p = path
    while p.len() > 1 and p.ends_with("/"):
        p = p[0:p.len() - 1]
    if p == "/":
        return ""
    val parts = p.split("/")
    if parts.len() > 0:
        parts[parts.len() - 1]
    else:
        p

fn path_dirname(path: text) -> text:
    if path == "":
        return ""
    # rfind returns Option, use ?? -1 workaround for bootstrap runtime
    val last = path.rfind("/") ?? -1
    if last < 0:
        return ""
    if last == 0:
        return "/"
    path[0:last]

fn path_ext(path: text) -> text:
    val name = path_basename(path)
    if name == "":
        return ""
    # rfind returns Option, use ?? -1 workaround for bootstrap runtime
    val dot = name.rfind(".") ?? -1
    if dot < 0:
        return ""
    # Hidden file with no extension (e.g. ".bashrc")
    if dot == 0:
        return ""
    name[dot + 1:]

fn path_is_absolute(path: text) -> bool:
    path.starts_with("/")

fn path_join_two(base: text, other: text) -> text:
    if base == "":
        return other
    if other == "":
        return base
    var b = base
    # Remove trailing slash from base
    if b.ends_with("/"):
        b = b[0:b.len() - 1]
    # Remove leading slash from other
    var o = other
    if o.starts_with("/"):
        o = o[1:]
    "{b}/{o}"

fn path_join_many(parts: [text]) -> text:
    if parts.len() == 0:
        return ""
    var result = parts[0]
    var i = 1
    while i < parts.len():
        result = path_join_two(result, parts[i])
        i = i + 1
    result

describe "Path Manipulation":
    """
    Pure Simple path manipulation functions for analyzing file system paths,
    including basename, dirname, extension extraction, and path joining.
    """
    context "basename":
        it "should extract filename from path":
            val result = path_basename("/home/user/file.txt")
            expect(result).to_equal("file.txt")

        it "should handle path with no directory":
            val result = path_basename("file.txt")
            expect(result).to_equal("file.txt")

        it "should handle directory path":
            val result = path_basename("/home/user/dir/")
            expect(result).to_equal("dir")

        it "should handle root path":
            val result = path_basename("/")
            expect(result).to_equal("")

        it "should handle empty path":
            val result = path_basename("")
            expect(result).to_equal("")

    context "dirname":
        it "should extract directory from path":
            val result = path_dirname("/home/user/file.txt")
            expect(result).to_equal("/home/user")

        it "should handle path with single directory":
            val result = path_dirname("/file.txt")
            expect(result).to_equal("/")

        it "should handle relative path":
            val result = path_dirname("dir/file.txt")
            expect(result).to_equal("dir")

        it "should handle file with no directory":
            val result = path_dirname("file.txt")
            expect(result).to_equal("")

        it "should handle empty path":
            val result = path_dirname("")
            expect(result).to_equal("")

    context "extension":
        it "should extract file extension":
            val result = path_ext("/home/user/file.txt")
            expect(result).to_equal("txt")

        it "should handle multiple dots":
            val result = path_ext("file.tar.gz")
            expect(result).to_equal("gz")

        it "should handle no extension":
            val result = path_ext("/home/user/file")
            expect(result).to_equal("")

        it "should handle hidden file with extension":
            val result = path_ext(".bashrc")
            expect(result).to_equal("")

        it "should handle hidden file with dot and extension":
            val result = path_ext(".config.json")
            expect(result).to_equal("json")

    context "is_absolute":
        it "should detect absolute path":
            val result = path_is_absolute("/tmp")
            expect(result).to_equal(true)

        it "should detect relative path":
            val result = path_is_absolute("relative/path")
            expect(result).to_equal(false)

        it "should handle current directory as relative":
            val result = path_is_absolute(".")
            expect(result).to_equal(false)

        it "should handle parent directory as relative":
            val result = path_is_absolute("..")
            expect(result).to_equal(false)

    context "join":
        it "should join path components":
            val result = path_join_many(["home", "user", "file.txt"])
            expect(result).to_equal("home/user/file.txt")

        it "should handle single component":
            val result = path_join_many(["home"])
            expect(result).to_equal("home")

        it "should handle empty list":
            val result = path_join_many([])
            expect(result).to_equal("")

        it "should not add separator if already present":
            val result = path_join_two("home/", "user")
            expect(result).to_equal("home/user")
