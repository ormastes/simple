# @pending
"""
# Union Keyword and Impl Blocks Specification

**Feature IDs:** #UNION-KEYWORD, #ENUM-IMPL
**Category:** Language Features
**Status:** Implemented

The union keyword provides syntactic sugar for defining algebraic data types (enums)
with variants that can carry payloads. Union definitions can have impl blocks that
add methods to the union type.

## Syntax

```simple
union Status:
    Active
    Inactive

union Result:
    Ok(value: Int)
    Err(msg: String)

impl Result:
    fn is_ok() -> bool:
        match self:
            case Result.Ok(_):
                true
            case _:
                false
```

## Key Behaviors

- Union is an alias for enum - fully interchangeable
- Variants can be simple (no payload) or have associated data
- Impl blocks can be used to add methods
- Pattern matching works with union variants
- Union values are constructed with VariantName or VariantName(payload)
"""

# ============================================================================
# Union Type Definitions
# ============================================================================

union Status:
    """
    Simple union with two variants representing application status.
    """
    Active
    Inactive

union MyResult:
    """
    Union with parameterized variants for result handling.
    """
    Ok(value: i32)
    Err(msg: text)

union MyOption:
    """
    Union representing an optional value.
    """
    Some(value: i32)
    Nothing

# ============================================================================
# Union Methods via Impl
# ============================================================================

impl Status:
    """
    Methods for Status union type.
    """
    fn is_active() -> bool:
        match self:
            case Status.Active:
                true
            case _:
                false

    fn display() -> text:
        match self:
            case Status.Active:
                "Active"
            case Status.Inactive:
                "Inactive"

impl MyResult:
    """
    Methods for MyResult union type.
    """
    fn is_ok() -> bool:
        match self:
            case MyResult.Ok(_):
                true
            case _:
                false

    fn is_err() -> bool:
        match self:
            case MyResult.Err(_):
                true
            case _:
                false

    fn get_value() -> i32?:
        match self:
            case MyResult.Ok(v):
                v.?
            case _:
                none

impl MyOption:
    """
    Methods for MyOption union type.
    """
    fn is_some() -> bool:
        match self:
            case MyOption.Some(_):
                true
            case _:
                false

    fn get_or(default: i32) -> i32:
        match self:
            case MyOption.Some(v):
                v
            case _:
                default

# ============================================================================
# Union Keyword Tests
# ============================================================================

describe "Union keyword":
    """
    ## Union Type Specification

    The union keyword provides syntactic sugar for defining algebraic data types.
    This test suite verifies:
    - Union type parsing and variant creation
    - Simple variants (no payload)
    - Parameterized variants with associated data
    - Pattern matching on union types
    - Methods defined via impl blocks
    - Union method invocation and behavior
    """

    context "basic union creation":
        it "parses union types correctly":
            # Union is an alias for enum in Simple
            val s = Status.Active
            expect true

        it "creates inactive status variant":
            val s = Status.Inactive
            expect true

        it "creates union variant with string":
            val r = MyResult.Err("failed")
            expect true

    context "union variants with payloads":
        it "supports union variants with payloads":
            val r1 = MyResult.Ok(42)
            val r2 = MyResult.Err("failed")
            expect true

        it "creates option with value":
            val opt = MyOption.Some(10)
            expect true

        it "creates empty option":
            val opt = MyOption.Nothing
            expect true

    context "basic variant creation":
        it "works with basic variant creation":
            val opt = MyOption.Some(10)
            # Union types work, pattern matching is separate feature
            expect true

        it "creates multiple variants of same type":
            val opt1 = MyOption.Some(1)
            val opt2 = MyOption.Some(2)
            val opt3 = MyOption.Nothing
            expect true

# ============================================================================
# Union Methods
# ============================================================================

describe "Union Impl Methods":
    """
    ## Union Methods Specification

    Methods defined on union types via impl blocks. This test suite verifies:
    - Method invocation on union variants
    - Pattern matching in method bodies
    - Boolean predicates (is_ok, is_some, etc.)
    - Extracting values from variants
    - Default value handling
    """

    context "Status union methods":
        it "checks if status is active":
            val s = Status.Active
            expect s.is_active() == true

        it "checks if status is inactive":
            val s = Status.Inactive
            expect s.is_active() == false

        it "displays status as string":
            val s = Status.Active
            expect s.display() == "Active"

        it "displays inactive status":
            val s = Status.Inactive
            expect s.display() == "Inactive"

    context "MyResult union methods":
        it "checks if result is ok":
            val r = MyResult.Ok(42)
            expect r.is_ok() == true

        it "checks if result is error":
            val r = MyResult.Err("failed")
            expect r.is_ok() == false
            expect r.is_err() == true

        it "checks error predicate":
            val r = MyResult.Ok(10)
            expect r.is_err() == false

    context "MyOption union methods":
        it "checks if option has value":
            val opt = MyOption.Some(10)
            expect opt.is_some() == true

        it "checks if option is empty":
            val opt = MyOption.Nothing
            expect opt.is_some() == false

        it "gets value or default":
            val opt1 = MyOption.Some(42)
            expect opt1.get_or(0) == 42

        it "uses default when none":
            val opt2 = MyOption.Nothing
            expect opt2.get_or(100) == 100

# ============================================================================
# Union Pattern Matching
# ============================================================================

describe "Union Pattern Matching":
    """
    ## Union Pattern Matching Specification

    Pattern matching on union types with variant extraction. This test suite verifies:
    - Exhaustive pattern matching
    - Extracting payloads from variants
    - Combining pattern matching with conditionals
    - Nested pattern matching
    """

    context "simple pattern matching":
        it "matches active status":
            val s = Status.Active
            val result = match s:
                case Status.Active:
                    "active"
                case Status.Inactive:
                    "inactive"
            expect result == "active"

        it "matches inactive status":
            val s = Status.Inactive
            val result = match s:
                case Status.Active:
                    "active"
                case Status.Inactive:
                    "inactive"
            expect result == "inactive"

    context "pattern matching with payloads":
        it "extracts ok value":
            val r = MyResult.Ok(42)
            val result = match r:
                case MyResult.Ok(v):
                    v
                case MyResult.Err(_):
                    0
            expect result == 42

        it "extracts error message":
            val r = MyResult.Err("test error")
            val result = match r:
                case MyResult.Ok(_):
                    "ok"
                case MyResult.Err(msg):
                    msg
            expect result == "test error"

    context "pattern matching on option":
        it "matches some variant with value":
            val opt = MyOption.Some(25)
            val result = match opt:
                case MyOption.Some(v):
                    v * 2
                case MyOption.Nothing:
                    0
            expect result == 50

        it "matches nothing variant":
            val opt = MyOption.Nothing
            val result = match opt:
                case MyOption.Some(v):
                    v
                case MyOption.Nothing:
                    -1
            expect result == -1

# ============================================================================
# Union Type Safety
# ============================================================================

describe "Union Type Safety":
    """
    ## Union Type Safety Specification

    Type safety guarantees for union types. This test suite verifies:
    - Variant creation with correct types
    - Type consistency across variants
    - Exhaustiveness of pattern matching
    - Proper handling of different union types
    """

    context "variant type consistency":
        it "creates result with integer":
            val r = MyResult.Ok(42)
            expect true

        it "creates result with string":
            val r = MyResult.Err("error message")
            expect true

        it "creates option with integer":
            val opt = MyOption.Some(100)
            expect true

    context "multiple union types":
        it "handles different union types independently":
            val status = Status.Active
            val result = MyResult.Ok(1)
            val option = MyOption.Some(2)
            expect true

        it "union method calls preserve type":
            val s1 = Status.Active
            val s2 = Status.Inactive
            val isActive = s1.is_active()
            expect isActive == true
