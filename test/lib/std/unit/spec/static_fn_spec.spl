"""
# Static Function Method Specification

**Feature IDs:** #STATIC-FN, #FACTORY-METHODS
**Category:** Language Features
**Status:** Implemented

Static functions are methods defined on a class or enum that don't require an instance
(no implicit self parameter). They are commonly used as factory methods to create
instances with special initialization logic.

## Syntax

```simple
class Point:
    x: i64
    y: i64

impl Point:
    static fn origin() -> Point:
        Point(x: 0, y: 0)

    static fn from_pair(pair: (i64, i64)) -> Point:
        val (x, y) = pair
        Point(x: x, y: y)

# Usage:
val p = Point.origin()
val q = Point.from_pair((5, 10))
```

## Key Behaviors

- Static functions are called on the class/enum name, not instances
- Return type is automatically inferred to be the containing class
- Can call other static or instance methods
- No implicit self parameter in the parameter list
- Useful for factory patterns and special constructors
"""
import std.spec

# ============================================================================
# Test Classes and Enums
# ============================================================================

class Point:
    """
    A simple point class with coordinate values.
    """
    x: i64
    y: i64

class Color:
    """
    A color representation with RGB components.
    """
    r: i32
    g: i32
    b: i32

enum Direction:
    """
    Directional enum with optional magnitude.
    """
    North
    South
    East
    West
    Custom(degrees: i32)

class CallEventRecorder:
    """
    Mock class for testing static method creation.
    """
    events: [text]

    static fn new() -> CallEventRecorder:
        """
        Factory method to create a new recorder with empty events list.
        """
        CallEventRecorder(events: [])

    static fn with_initial_event(event: text) -> CallEventRecorder:
        """
        Factory method to create recorder with initial event.
        """
        CallEventRecorder(events: [event])

# ============================================================================
# Static Method Implementations
# ============================================================================

impl Point:
    """
    Factory methods for Point creation.
    """
    static fn origin() -> Point:
        """
        Creates a point at the origin (0, 0).
        """
        Point(x: 0, y: 0)

    static fn from_pair(pair: (i64, i64)) -> Point:
        """
        Creates a point from a coordinate pair.
        """
        val (x, y) = pair
        Point(x: x, y: y)

    static fn on_diagonal(coord: i64) -> Point:
        """
        Creates a point on the main diagonal where x == y.
        """
        Point(x: coord, y: coord)

    static fn unit_x() -> Point:
        """
        Creates a unit vector pointing along x-axis.
        """
        Point(x: 1, y: 0)

    static fn unit_y() -> Point:
        """
        Creates a unit vector pointing along y-axis.
        """
        Point(x: 0, y: 1)

impl Color:
    """
    Factory methods for Color creation.
    """
    static fn black() -> Color:
        """
        Creates a black color (0, 0, 0).
        """
        Color(r: 0, g: 0, b: 0)

    static fn white() -> Color:
        """
        Creates a white color (255, 255, 255).
        """
        Color(r: 255, g: 255, b: 255)

    static fn red() -> Color:
        """
        Creates a pure red color.
        """
        Color(r: 255, g: 0, b: 0)

    static fn from_hex(hex_value: i32) -> Color:
        """
        Creates a color from a hex value.
        """
        val r = (hex_value >> 16) & 0xFF
        val g = (hex_value >> 8) & 0xFF
        val b = hex_value & 0xFF
        Color(r: r.to_i32(), g: g.to_i32(), b: b.to_i32())

impl Direction:
    """
    Factory methods for Direction enum.
    """
    static fn northeast() -> Direction:
        """
        Creates a custom direction at 45 degrees (northeast).
        """
        Direction.Custom(degrees: 45)

    static fn southeast() -> Direction:
        """
        Creates a custom direction at 135 degrees (southeast).
        """
        Direction.Custom(degrees: 135)

    static fn southwest() -> Direction:
        """
        Creates a custom direction at 225 degrees (southwest).
        """
        Direction.Custom(degrees: 225)

    static fn northwest() -> Direction:
        """
        Creates a custom direction at 315 degrees (northwest).
        """
        Direction.Custom(degrees: 315)

# ============================================================================
# Static Method Tests
# ============================================================================

describe "Static Function Methods":
    """
    ## Static Function Method Specification

    Static methods provide factory patterns and class-level utilities without
    requiring instance creation. This test suite verifies:
    - Static method declaration and invocation
    - Factory method pattern for special initialization
    - Return type inference for static methods
    - Multiple static factories on same class
    - Static methods on different class types
    """

    context "basic static method invocation":
        it "can call static fn new on CallEventRecorder":
            val recorder = CallEventRecorder.new()
            expect recorder.events.len() == 0

        it "calls CallEventRecorder factory with initial event":
            val recorder = CallEventRecorder.with_initial_event("startup")
            expect recorder.events.len() == 1

    context "Point factory methods":
        it "creates origin point":
            val p = Point.origin()
            expect p.x == 0
            expect p.y == 0

        it "creates point from pair":
            val p = Point.from_pair((5, 10))
            expect p.x == 5
            expect p.y == 10

        it "creates diagonal point":
            val p = Point.on_diagonal(7)
            expect p.x == 7
            expect p.y == 7

        it "creates unit x vector":
            val p = Point.unit_x()
            expect p.x == 1
            expect p.y == 0

        it "creates unit y vector":
            val p = Point.unit_y()
            expect p.x == 0
            expect p.y == 1

    context "Color factory methods":
        it "creates black color":
            val c = Color.black()
            expect c.r == 0
            expect c.g == 0
            expect c.b == 0

        it "creates white color":
            val c = Color.white()
            expect c.r == 255
            expect c.g == 255
            expect c.b == 255

        it "creates red color":
            val c = Color.red()
            expect c.r == 255
            expect c.g == 0
            expect c.b == 0

    context "Direction factory methods":
        it "creates northeast direction":
            val d = Direction.northeast()
            match d:
                case Direction.Custom(deg):
                    expect deg == 45
                case _:
                    expect false

        it "creates southeast direction":
            val d = Direction.southeast()
            match d:
                case Direction.Custom(deg):
                    expect deg == 135
                case _:
                    expect false

        it "creates southwest direction":
            val d = Direction.southwest()
            match d:
                case Direction.Custom(deg):
                    expect deg == 225
                case _:
                    expect false

        it "creates northwest direction":
            val d = Direction.northwest()
            match d:
                case Direction.Custom(deg):
                    expect deg == 315
                case _:
                    expect false

# ============================================================================
# Static Method Return Types
# ============================================================================

describe "Static Method Return Types":
    """
    ## Static Method Return Type Specification

    Static methods automatically infer their return type as the containing class.
    This test suite verifies:
    - Return type inference for static methods
    - Type consistency across multiple static factories
    - Return type compatibility with usage patterns
    """

    context "return type inference":
        it "returns correct instance type":
            val p = Point.origin()
            expect p.x == 0

        it "returns multiple instances correctly":
            val p1 = Point.origin()
            val p2 = Point.unit_x()
            expect p1.x == 0
            expect p2.x == 1

        it "color factory returns Color type":
            val black = Color.black()
            val white = Color.white()
            expect black.r == 0
            expect white.r == 255

# ============================================================================
# Static Method Patterns
# ============================================================================

describe "Static Method Patterns":
    """
    ## Static Method Pattern Specification

    Common patterns for using static methods. This test suite verifies:
    - Factory pattern for specialized construction
    - Named constructor pattern
    - Builder-like initialization
    - Default value factories
    """

    context "factory pattern":
        it "provides specialized factory for common case":
            val origin = Point.origin()
            expect origin.x == 0 && origin.y == 0

        it "provides multiple factories for different cases":
            val origin = Point.origin()
            val unit_x = Point.unit_x()
            val unit_y = Point.unit_y()
            expect origin.x == 0
            expect unit_x.x == 1
            expect unit_y.y == 1

    context "named constructor pattern":
        it "uses descriptive factory name":
            val diagonal = Point.on_diagonal(5)
            expect diagonal.x == 5
            expect diagonal.y == 5

        it "stacks multiple named constructors":
            val p1 = Point.origin()
            val p2 = Point.unit_x()
            val p3 = Point.from_pair((3, 4))
            expect [p1.x, p2.x, p3.x] == [0, 1, 3]

    context "color factory variations":
        it "provides named color factories":
            val black = Color.black()
            val white = Color.white()
            val red = Color.red()
            expect black.r == 0
            expect white.r == 255
            expect red.r == 255

# ============================================================================
# Static Method Edge Cases
# ============================================================================

describe "Static Method Edge Cases":
    """
    ## Static Method Edge Cases Specification

    Edge cases and special scenarios for static methods. This test suite verifies:
    - Static methods with no parameters
    - Static methods with various parameter types
    - Chaining factory calls
    - Multiple instances from same factory
    """

    context "parameterless static methods":
        it "calls static method with no parameters":
            val p = Point.origin()
            expect true

        it "multiple calls to same parameterless factory":
            val p1 = Point.origin()
            val p2 = Point.origin()
            expect p1.x == p2.x && p1.y == p2.y

    context "multiple instances":
        it "creates independent instances":
            val p1 = Point.origin()
            val p2 = Point.unit_x()
            expect p1.x != p2.x || p1.y != p2.y

        it "records instances independently":
            val r1 = CallEventRecorder.new()
            val r2 = CallEventRecorder.with_initial_event("test")
            expect r1.events.len() == 0
            expect r2.events.len() == 1
