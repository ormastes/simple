# @pending
# Integration test for macros with other language features
# Tests macros working with test helpers, pattern matching, generics, etc.
# @skip - Uses unsupported keyword: with
"""
Macro integration tests validating macro expansion with other language features.
Tests basic macros, pattern matching in macro bodies, function generation,
property patterns, and built-in macros like vec!, assert!, dbg!, and format!.
"""


# ============================================================================
# Module-level macro definitions
# ============================================================================

# Basic integration macros
macro integ_make_test_value(n: Int) -> (returns result: Int):
    emit result:
        n * 10

macro integ_answer() -> (returns result: Int):
    emit result:
        42

# Pattern matching macros
macro integ_make_pair_sum() -> (returns result: Int):
    emit result:
        let (x, y) = (10, 32)
        x + y

macro integ_sum_array() -> (returns result: Int):
    emit result:
        let [a, b, c] = [10, 20, 12]
        a + b + c

# Function generation macros
macro integ_make_identity() -> (
    intro id_fn: enclosing.module.fn "integ_identity"(x: Int) -> Int
):
    emit id_fn:
        fn integ_identity(x: Int) -> Int:
            return x

# Property pattern macros
macro integ_make_getter(name: Str const, value: Int const) -> (
    intro getter: enclosing.module.fn "integ_get_prop_{name}"() -> Int
):
    emit getter:
        fn "integ_get_prop_{name}"() -> Int:
            return value

macro integ_make_props() -> (
    intro getter1: enclosing.module.fn "integ_get_x"() -> Int,
    intro getter2: enclosing.module.fn "integ_get_y"() -> Int
):
    emit getter1:
        fn integ_get_x() -> Int:
            return 10

    emit getter2:
        fn integ_get_y() -> Int:
            return 32

# Helper function
fn integ_helper() -> Int:
    return integ_make_test_value!(4)

# ============================================================================
# Invoke macros that generate functions at module level
# ============================================================================
integ_make_identity!()
integ_make_getter!("answer", 42)
integ_make_props!()

# ============================================================================
# Tests
# ============================================================================

describe "Macro Integration":
    """
    Tests macro system integration with language features including test helpers,
    pattern matching, function generation, and built-in macros.
    """
    describe "Basic integration":
        it "uses macros in test helpers":
            expect(integ_helper()).to_equal(40))

        it "uses simple macro results":
            val x = integ_answer!()
            val y = integ_answer!()
            expect(x + y).to_equal(84))

    describe "Pattern matching integration":
        it "uses destructuring in macro expansion":
            val sum = integ_make_pair_sum!()
            expect(sum).to_equal(42))

        it "uses arrays with macros":
            val sum = integ_sum_array!()
            expect(sum).to_equal(42))

    describe "Function generation":
        it "generates identity function":
            expect(integ_identity(42)).to_equal(42))
            expect(integ_identity(100)).to_equal(100))

    describe "Property pattern":
        it "implements getter pattern":
            expect(integ_get_prop_answer()).to_equal(42))

        it "implements multiple property getters":
            expect(integ_get_x() + integ_get_y()).to_equal(42))

    describe "Built-in macros":
        it "uses vec! macro":
            val arr = vec!(1, 2, 3, 4, 5)
            expect(arr.len()).to_equal(5))

        it "uses assert! macro":
            assert!(true)
            assert!(1 == 1)
            # If we get here, assertions passed
            expect(1).to_equal(1))

        it "uses assert_eq! macro":
            val x = 10
            val y = 10
            assert_eq!(x, y)
            expect(true).to_be_true()

        it "uses dbg! macro":
            val x = dbg!(42)
            expect(x).to_equal(42))

        it "uses format! macro":
            val s = format!("hello", " ", "world")
            expect(s).to_equal("hello world"))

        it "uses stringify! macro":
            val s = stringify!(x + 3)
            # Binary expressions are wrapped in parens: "(x + 3)"
            expect(s).to_equal("(x + 3)"))
