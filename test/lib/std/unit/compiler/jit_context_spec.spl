"""
# JIT CompilationContext Specification

**Feature IDs:** #CC-031 to #CC-040
**Category:** Infrastructure
**Difficulty:** 3/5
**Status:** In Progress

## Overview

Tests for JitCompilationContext which handles load-time JIT instantiation.
Templates are loaded from SMF TemplateCode sections.

## Behavior

- Uses ContractMode.Boundary (lighter than full contracts)
- Coverage is always disabled for JIT
- Templates come from SMF metadata
- AOP/DI config is reconstructed from note.sdn
"""

use compiler.compilation_context
use compiler.loader.jit_context
use compiler.instantiation
use compiler.backend_types

# ============================================================================
# Test Group 1: JitCompilationContext Creation
# ============================================================================

describe "JitCompilationContext":
    """
    ## JIT Context

    Validates JIT context creation and configuration.
    """

    context "when created from SMF":
        it "initializes with provided templates":
            var templates: Dict<text, GenericTemplate> = {}
            templates["Vec"] = GenericTemplate(name: "Vec", type_params: ["T"], ast_data: nil)
            val ctx = JitCompilationContext.from_smf(templates, nil, nil)
            expect ctx.has_template("Vec")
            expect not ctx.has_template("Map")

        it "uses Boundary contract mode":
            val ctx = JitCompilationContext.from_smf({}, nil, nil)
            expect ctx.contract_mode().to_string() == "boundary"

        it "disables coverage":
            val ctx = JitCompilationContext.from_smf({}, nil, nil)
            expect not ctx.coverage_enabled()

        it "reports JitTime instantiation mode":
            val ctx = JitCompilationContext.from_smf({}, nil, nil)
            expect ctx.instantiation_mode().to_string() == "jit_time"

        it "starts with no recorded instantiations":
            val ctx = JitCompilationContext.from_smf({}, nil, nil)
            expect ctx.recorded.is_empty()

    context "template loading":
        it "loads existing template":
            var templates: Dict<text, GenericTemplate> = {}
            templates["Option"] = GenericTemplate(name: "Option", type_params: ["T"], ast_data: nil)
            val ctx = JitCompilationContext.from_smf(templates, nil, nil)

            val result = ctx.load_template("Option")
            expect result.is_ok()
            expect result.unwrap().name == "Option"

        it "returns error for missing template":
            val ctx = JitCompilationContext.from_smf({}, nil, nil)
            val result = ctx.load_template("Missing")
            expect result.is_err()
            expect result.unwrap_err().contains("not in SMF")

    context "compilation":
        it "compiles template through pipeline":
            var templates: Dict<text, GenericTemplate> = {}
            templates["List"] = GenericTemplate(name: "List", type_params: ["T"], ast_data: nil)
            val ctx = JitCompilationContext.from_smf(templates, nil, nil)

            val tmpl = ctx.load_template("List").unwrap()
            val args = [ConcreteType(name: "Int")]
            val result = ctx.compile_template(tmpl, args)
            expect result.is_ok()
            expect result.unwrap().name == "List$Int"

    context "with AOP/DI config":
        it "returns nil for no AOP config":
            val ctx = JitCompilationContext.from_smf({}, nil, nil)
            expect not ctx.aop_weaver().?

        it "returns nil for no DI config":
            val ctx = JitCompilationContext.from_smf({}, nil, nil)
            expect not ctx.di_container().?


# ============================================================================
# Test Group 2: JIT Instantiation via TemplateInstantiator
# ============================================================================

describe "JIT Instantiation Pipeline":
    """
    ## End-to-End JIT Instantiation

    Validates the full pipeline: JitCompilationContext + TemplateInstantiator.
    """

    it "instantiates template through JIT context":
        var templates: Dict<text, GenericTemplate> = {}
        templates["Result"] = GenericTemplate(name: "Result", type_params: ["T", "E"], ast_data: nil)
        val ctx = JitCompilationContext.from_smf(templates, nil, nil)
        var inst = TemplateInstantiator(context: ctx, in_progress: {}, cache: {})

        val args = [ConcreteType(name: "String"), ConcreteType(name: "Error")]
        val result = inst.instantiate("Result", args)
        expect result.is_ok()
        expect result.unwrap().name == "Result$String,Error"
        expect inst.cache_size() == 1

    it "fails for template not in SMF":
        val ctx = JitCompilationContext.from_smf({}, nil, nil)
        var inst = TemplateInstantiator(context: ctx, in_progress: {}, cache: {})

        val result = inst.instantiate("NotInSmf", [ConcreteType(name: "Int")])
        expect result.is_err()
