"""
# Linker CompilationContext Specification

**Feature IDs:** #CC-041 to #CC-050
**Category:** Infrastructure
**Difficulty:** 3/5
**Status:** In Progress

## Overview

Tests for LinkerCompilationContext which handles link-time lazy instantiation.
Templates are loaded from input SMF object files.

## Behavior

- Uses ContractMode.All (full contract checking)
- Coverage is always disabled for linker
- Templates come from input object file SMFs
- AOP/DI config from project configuration
"""

use compiler.compilation_context
use compiler.linker.linker_context
use compiler.instantiation
use compiler.backend_types

# ============================================================================
# Test Group 1: LinkerCompilationContext Creation
# ============================================================================

describe "LinkerCompilationContext":
    """
    ## Linker Context

    Validates linker context creation and configuration.
    """

    context "when created from objects":
        it "initializes with provided templates":
            var templates: Dict<text, GenericTemplate> = {}
            templates["Array"] = GenericTemplate(name: "Array", type_params: ["T"], ast_data: nil)
            val ctx = LinkerCompilationContext.from_objects(templates, nil, nil)
            expect ctx.has_template("Array")
            expect not ctx.has_template("Vec")

        it "uses All contract mode":
            val ctx = LinkerCompilationContext.from_objects({}, nil, nil)
            expect ctx.contract_mode().to_string() == "all"

        it "disables coverage":
            val ctx = LinkerCompilationContext.from_objects({}, nil, nil)
            expect not ctx.coverage_enabled()

        it "reports LinkTime instantiation mode":
            val ctx = LinkerCompilationContext.from_objects({}, nil, nil)
            expect ctx.instantiation_mode().to_string() == "link_time"

        it "starts with no recorded instantiations":
            val ctx = LinkerCompilationContext.from_objects({}, nil, nil)
            expect ctx.recorded.is_empty()

    context "template loading":
        it "loads existing template":
            var templates: Dict<text, GenericTemplate> = {}
            templates["Set"] = GenericTemplate(name: "Set", type_params: ["T"], ast_data: nil)
            val ctx = LinkerCompilationContext.from_objects(templates, nil, nil)

            val result = ctx.load_template("Set")
            expect result.is_ok()
            expect result.unwrap().name == "Set"

        it "returns error for missing template":
            val ctx = LinkerCompilationContext.from_objects({}, nil, nil)
            val result = ctx.load_template("Missing")
            expect result.is_err()
            expect result.unwrap_err().contains("not in objects")

    context "compilation":
        it "compiles template through pipeline":
            var templates: Dict<text, GenericTemplate> = {}
            templates["HashMap"] = GenericTemplate(name: "HashMap", type_params: ["K", "V"], ast_data: nil)
            val ctx = LinkerCompilationContext.from_objects(templates, nil, nil)

            val tmpl = ctx.load_template("HashMap").unwrap()
            val args = [ConcreteType(name: "String"), ConcreteType(name: "Int")]
            val result = ctx.compile_template(tmpl, args)
            expect result.is_ok()
            expect result.unwrap().name == "HashMap$String,Int"


# ============================================================================
# Test Group 2: Linker Instantiation via TemplateInstantiator
# ============================================================================

describe "Linker Instantiation Pipeline":
    """
    ## End-to-End Linker Instantiation

    Validates the full pipeline: LinkerCompilationContext + TemplateInstantiator.
    """

    it "instantiates template through linker context":
        var templates: Dict<text, GenericTemplate> = {}
        templates["Queue"] = GenericTemplate(name: "Queue", type_params: ["T"], ast_data: nil)
        val ctx = LinkerCompilationContext.from_objects(templates, nil, nil)
        var inst = TemplateInstantiator(context: ctx, in_progress: {}, cache: {},)

        val args = [ConcreteType(name: "Message")]
        val result = inst.instantiate("Queue", args)
        expect result.is_ok()
        expect result.unwrap().name == "Queue$Message"
        expect inst.cache_size() == 1

    it "fails for template not in objects":
        val ctx = LinkerCompilationContext.from_objects({}, nil, nil)
        var inst = TemplateInstantiator(context: ctx, in_progress: {}, cache: {})

        val result = inst.instantiate("NotInObjects", [ConcreteType(name: "Int")])
        expect result.is_err()

    it "handles multiple instantiations of same template":
        var templates: Dict<text, GenericTemplate> = {}
        templates["Stack"] = GenericTemplate(name: "Stack", type_params: ["T"], ast_data: nil)
        val ctx = LinkerCompilationContext.from_objects(templates, nil, nil)
        var inst = TemplateInstantiator(context: ctx, in_progress: {}, cache: {})

        val r1 = inst.instantiate("Stack", [ConcreteType(name: "Int")])
        val r2 = inst.instantiate("Stack", [ConcreteType(name: "String")])
        val r3 = inst.instantiate("Stack", [ConcreteType(name: "Float")])
        expect r1.is_ok()
        expect r2.is_ok()
        expect r3.is_ok()
        expect inst.cache_size() == 3
