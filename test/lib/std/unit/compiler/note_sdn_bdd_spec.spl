# @pending
# @skip
# BDD-Style Unit Tests for note.sdn
#
# These tests use describe.context.it blocks in BDD style
# to test the note.sdn implementation comprehensively.

use simple.compiler.monomorphize.note_sdn

describe "NoteSdnMetadata":
    context "when newly created":
        it "should be empty":
            val note = NoteSdnMetadata.new()
            assert note.is_empty()

        it "should have empty instantiations list":
            val note = NoteSdnMetadata.new()
            assert note.instantiations.is_empty()

        it "should have empty possible list":
            val note = NoteSdnMetadata.new()
            assert note.possible.is_empty()

        it "should have empty dependencies list":
            val note = NoteSdnMetadata.new()
            assert note.dependencies.is_empty()

    context "when adding an instantiation":
        it "should not be empty":
            var note = NoteSdnMetadata.new()
            val entry = InstantiationEntry {
                template_name: "List",
                type_args: "Int",
                mangled_name: "List$Int",
                from_file: "app.spl",
                from_loc: "app.spl:10:5",
                to_obj: "app.o",
                status: InstantiationStatus.Compiled
            }
            note.add_instantiation(entry)
            assert not note.is_empty()

        it "should have one instantiation":
            var note = NoteSdnMetadata.new()
            val entry = InstantiationEntry {
                template_name: "List",
                type_args: "Int",
                mangled_name: "List$Int",
                from_file: "app.spl",
                from_loc: "app.spl:10:5",
                to_obj: "app.o",
                status: InstantiationStatus.Compiled
            }
            note.add_instantiation(entry)
            assert note.instantiations.len() == 1

        it "should store correct template name":
            var note = NoteSdnMetadata.new()
            val entry = InstantiationEntry {
                template_name: "List",
                type_args: "Int",
                mangled_name: "List$Int",
                from_file: "app.spl",
                from_loc: "app.spl:10:5",
                to_obj: "app.o",
                status: InstantiationStatus.Compiled
            }
            note.add_instantiation(entry)
            assert note.instantiations[0].template_name == "List"

        it "should store correct mangled name":
            var note = NoteSdnMetadata.new()
            val entry = InstantiationEntry {
                template_name: "List",
                type_args: "Int",
                mangled_name: "List$Int",
                from_file: "app.spl",
                from_loc: "app.spl:10:5",
                to_obj: "app.o",
                status: InstantiationStatus.Compiled
            }
            note.add_instantiation(entry)
            assert note.instantiations[0].mangled_name == "List$Int"

    context "when adding multiple instantiations":
        it "should track all instantiations":
            var note = NoteSdnMetadata.new()

            val entry1 = InstantiationEntry {
                template_name: "List",
                type_args: "Int",
                mangled_name: "List$Int",
                from_file: "app.spl",
                from_loc: "app.spl:10:5",
                to_obj: "app.o",
                status: InstantiationStatus.Compiled
            }
            note.add_instantiation(entry1)

            val entry2 = InstantiationEntry {
                template_name: "Option",
                type_args: "String",
                mangled_name: "Option$String",
                from_file: "app.spl",
                from_loc: "app.spl:15:8",
                to_obj: "app.o",
                status: InstantiationStatus.Compiled
            }
            note.add_instantiation(entry2)

            assert note.instantiations.len() == 2

        it "should preserve order of instantiations":
            var note = NoteSdnMetadata.new()

            val entry1 = InstantiationEntry {
                template_name: "List",
                type_args: "Int",
                mangled_name: "List$Int",
                from_file: "app.spl",
                from_loc: "app.spl:10:5",
                to_obj: "app.o",
                status: InstantiationStatus.Compiled
            }
            note.add_instantiation(entry1)

            val entry2 = InstantiationEntry {
                template_name: "Option",
                type_args: "String",
                mangled_name: "Option$String",
                from_file: "app.spl",
                from_loc: "app.spl:15:8",
                to_obj: "app.o",
                status: InstantiationStatus.Compiled
            }
            note.add_instantiation(entry2)

            assert note.instantiations[0].template_name == "List"
            assert note.instantiations[1].template_name == "Option"

describe "DependencyEdge":
    context "when creating a dependency":
        it "should store from_inst":
            val dep = DependencyEdge {
                from_inst: "List$Int",
                to_inst: "Int",
                dep_kind: DependencyKind.TypeParam
            }
            assert dep.from_inst == "List$Int"

        it "should store to_inst":
            val dep = DependencyEdge {
                from_inst: "List$Int",
                to_inst: "Int",
                dep_kind: DependencyKind.TypeParam
            }
            assert dep.to_inst == "Int"

        it "should store dependency kind":
            val dep = DependencyEdge {
                from_inst: "List$Int",
                to_inst: "Int",
                dep_kind: DependencyKind.TypeParam
            }
            assert dep.dep_kind == DependencyKind.TypeParam

    context "when adding to metadata":
        it "should be tracked":
            var note = NoteSdnMetadata.new()
            val dep = DependencyEdge {
                from_inst: "List$Int",
                to_inst: "Int",
                dep_kind: DependencyKind.TypeParam
            }
            note.add_dependency(dep)
            assert note.dependencies.len() == 1

        it "should allow multiple dependencies":
            var note = NoteSdnMetadata.new()

            val dep1 = DependencyEdge {
                from_inst: "List$Int",
                to_inst: "Int",
                dep_kind: DependencyKind.TypeParam
            }
            note.add_dependency(dep1)

            val dep2 = DependencyEdge {
                from_inst: "Container$List$Int",
                to_inst: "List$Int",
                dep_kind: DependencyKind.FieldType
            }
            note.add_dependency(dep2)

            assert note.dependencies.len() == 2

describe "InstantiationStatus":
    context "when converting to string":
        it "should convert Compiled to 'compiled'":
            assert InstantiationStatus.Compiled.to_string() == "compiled"

        it "should convert Deferred to 'deferred'":
            assert InstantiationStatus.Deferred.to_string() == "deferred"

        it "should convert JitCompiled to 'jit_compiled'":
            assert InstantiationStatus.JitCompiled.to_string() == "jit_compiled"

    context "when parsing from string":
        it "should parse 'compiled' successfully":
            val result = InstantiationStatus.from_string("compiled")
            assert result.ok.?

        it "should parse 'deferred' successfully":
            val result = InstantiationStatus.from_string("deferred")
            assert result.ok.?

        it "should parse 'jit_compiled' successfully":
            val result = InstantiationStatus.from_string("jit_compiled")
            assert result.ok.?

        it "should return error for invalid string":
            val result = InstantiationStatus.from_string("invalid")
            assert result.err.?

describe "DependencyKind":
    context "when converting to string":
        it "should convert TypeParam to 'type_param'":
            assert DependencyKind.TypeParam.to_string() == "type_param"

        it "should convert FieldType to 'field_type'":
            assert DependencyKind.FieldType.to_string() == "field_type"

        it "should convert InnerType to 'inner_type'":
            assert DependencyKind.InnerType.to_string() == "inner_type"

        it "should convert MethodDep to 'method_dep'":
            assert DependencyKind.MethodDep.to_string() == "method_dep"

    context "when parsing from string":
        it "should parse 'type_param' successfully":
            val result = DependencyKind.from_string("type_param")
            assert result.ok.?

        it "should parse 'field_type' successfully":
            val result = DependencyKind.from_string("field_type")
            assert result.ok.?

        it "should return error for invalid string":
            val result = DependencyKind.from_string("invalid")
            assert result.err.?

describe "SDN Serialization":
    context "when serializing empty metadata":
        it "should include header":
            val note = NoteSdnMetadata.new()
            val sdn = note.to_sdn()
            assert sdn.contains("# Instantiation To/From Metadata")

        it "should include format version":
            val note = NoteSdnMetadata.new()
            val sdn = note.to_sdn()
            assert sdn.contains("# Format version: 1.0")

        it "should include all table headers":
            val note = NoteSdnMetadata.new()
            val sdn = note.to_sdn()
            assert sdn.contains("instantiations |")
            assert sdn.contains("possible |")
            assert sdn.contains("type_inferences |")
            assert sdn.contains("dependencies |")
            assert sdn.contains("circular_warnings |")
            assert sdn.contains("circular_errors |")

        it "should include terminator":
            val note = NoteSdnMetadata.new()
            val sdn = note.to_sdn()
            assert sdn.contains("# END_NOTE")

    context "when serializing with data":
        it "should include instantiation data":
            var note = NoteSdnMetadata.new()
            val entry = InstantiationEntry {
                template_name: "List",
                type_args: "Int",
                mangled_name: "List$Int",
                from_file: "app.spl",
                from_loc: "app.spl:10:5",
                to_obj: "app.o",
                status: InstantiationStatus.Compiled
            }
            note.add_instantiation(entry)

            val sdn = note.to_sdn()
            assert sdn.contains("List")
            assert sdn.contains("Int")
            assert sdn.contains("List$Int")

        it "should include dependency data":
            var note = NoteSdnMetadata.new()
            val dep = DependencyEdge {
                from_inst: "List$Int",
                to_inst: "Int",
                dep_kind: DependencyKind.TypeParam
            }
            note.add_dependency(dep)

            val sdn = note.to_sdn()
            assert sdn.contains("List$Int")
            assert sdn.contains("Int")
            assert sdn.contains("type_param")

describe "String Escaping":
    context "when escaping special characters":
        it "should not escape normal strings":
            assert escape_sdn("hello world") == "hello world"

describe "Circular Dependencies":
    context "when adding warnings":
        it "should track circular warnings":
            var note = NoteSdnMetadata.new()
            val warn = CircularWarning {
                cycle_path: "Node$T->Option$Node$T->Node$T",
                severity: "warning"
            }
            note.add_circular_warning(warn)
            assert note.circular_warnings.len() == 1

        it "should store cycle path":
            var note = NoteSdnMetadata.new()
            val warn = CircularWarning {
                cycle_path: "Node$T->Option$Node$T->Node$T",
                severity: "warning"
            }
            note.add_circular_warning(warn)
            assert note.circular_warnings[0].cycle_path == "Node$T->Option$Node$T->Node$T"

    context "when adding errors":
        it "should track circular errors":
            var note = NoteSdnMetadata.new()
            val err = CircularError {
                cycle_path: "A$T->B$T->C$T->A$T",
                error_code: "E0420"
            }
            note.add_circular_error(err)
            assert note.circular_errors.len() == 1

        it "should store error code":
            var note = NoteSdnMetadata.new()
            val err = CircularError {
                cycle_path: "A$T->B$T->C$T->A$T",
                error_code: "E0420"
            }
            note.add_circular_error(err)
            assert note.circular_errors[0].error_code == "E0420"

describe "Complete Workflow":
    context "end-to-end scenario":
        it "should handle full instantiation tracking workflow":
            var note = NoteSdnMetadata.new()

            # Add instantiation
            val entry = InstantiationEntry {
                template_name: "List",
                type_args: "Int",
                mangled_name: "List$Int",
                from_file: "app.spl",
                from_loc: "app.spl:10:5",
                to_obj: "app.o",
                status: InstantiationStatus.Compiled
            }
            note.add_instantiation(entry)

            # Add dependency
            val dep = DependencyEdge {
                from_inst: "List$Int",
                to_inst: "Int",
                dep_kind: DependencyKind.TypeParam
            }
            note.add_dependency(dep)

            # Add possible
            val poss = PossibleInstantiationEntry {
                template_name: "Option",
                type_args: "String",
                mangled_name: "Option$String",
                required_by: "string_module",
                can_defer: true
            }
            note.add_possible(poss)

            # Add type inference
            val inf = TypeInferenceEntry {
                inferred_type: "Int",
                expr: "42",
                context: "literal",
                from_file: "app.spl",
                from_loc: "app.spl:5:10"
            }
            note.add_type_inference(inf)

            # Serialize
            val sdn = note.to_sdn()

            # Verify
            assert sdn.contains("List$Int")
            assert sdn.contains("Option$String")
            assert sdn.contains("42")
            assert sdn.contains("# END_NOTE")
            assert note.instantiations.len() == 1
            assert note.dependencies.len() == 1
            assert note.possible.len() == 1
            assert note.type_inferences.len() == 1
