# @pending
# @skip
# BDD-Style Unit Tests for note.sdn
#
# These tests use describe.context.it blocks in BDD style
# to test the note.sdn implementation comprehensively.

use simple.compiler.monomorphize.note_sdn
use std.spec.{check, check_msg}

describe "NoteSdnMetadata":
    context "when newly created":
        it "should be empty":
            val note = NoteSdnMetadata.new()
            check(note.is_empty())

        it "should have empty instantiations list":
            val note = NoteSdnMetadata.new()
            check(note.instantiations.is_empty())

        it "should have empty possible list":
            val note = NoteSdnMetadata.new()
            check(note.possible.is_empty())

        it "should have empty dependencies list":
            val note = NoteSdnMetadata.new()
            check(note.dependencies.is_empty())

    context "when adding an instantiation":
        it "should not be empty":
            var note = NoteSdnMetadata.new()
            val entry = InstantiationEntry {
                template_name: "List",
                type_args: "Int",
                mangled_name: "List$Int",
                from_file: "app.spl",
                from_loc: "app.spl:10:5",
                to_obj: "app.o",
                status: InstantiationStatus.Compiled
            }
            note.add_instantiation(entry)
            check(not note.is_empty())

        it "should have one instantiation":
            var note = NoteSdnMetadata.new()
            val entry = InstantiationEntry {
                template_name: "List",
                type_args: "Int",
                mangled_name: "List$Int",
                from_file: "app.spl",
                from_loc: "app.spl:10:5",
                to_obj: "app.o",
                status: InstantiationStatus.Compiled
            }
            note.add_instantiation(entry)
            check(note.instantiations.len() == 1)

        it "should store correct template name":
            var note = NoteSdnMetadata.new()
            val entry = InstantiationEntry {
                template_name: "List",
                type_args: "Int",
                mangled_name: "List$Int",
                from_file: "app.spl",
                from_loc: "app.spl:10:5",
                to_obj: "app.o",
                status: InstantiationStatus.Compiled
            }
            note.add_instantiation(entry)
            check(note.instantiations[0].template_name == "List")

        it "should store correct mangled name":
            var note = NoteSdnMetadata.new()
            val entry = InstantiationEntry {
                template_name: "List",
                type_args: "Int",
                mangled_name: "List$Int",
                from_file: "app.spl",
                from_loc: "app.spl:10:5",
                to_obj: "app.o",
                status: InstantiationStatus.Compiled
            }
            note.add_instantiation(entry)
            check(note.instantiations[0].mangled_name == "List$Int")

    context "when adding multiple instantiations":
        it "should track all instantiations":
            var note = NoteSdnMetadata.new()

            val entry1 = InstantiationEntry {
                template_name: "List",
                type_args: "Int",
                mangled_name: "List$Int",
                from_file: "app.spl",
                from_loc: "app.spl:10:5",
                to_obj: "app.o",
                status: InstantiationStatus.Compiled
            }
            note.add_instantiation(entry1)

            val entry2 = InstantiationEntry {
                template_name: "Option",
                type_args: "String",
                mangled_name: "Option$String",
                from_file: "app.spl",
                from_loc: "app.spl:15:8",
                to_obj: "app.o",
                status: InstantiationStatus.Compiled
            }
            note.add_instantiation(entry2)

            check(note.instantiations.len() == 2)

        it "should preserve order of instantiations":
            var note = NoteSdnMetadata.new()

            val entry1 = InstantiationEntry {
                template_name: "List",
                type_args: "Int",
                mangled_name: "List$Int",
                from_file: "app.spl",
                from_loc: "app.spl:10:5",
                to_obj: "app.o",
                status: InstantiationStatus.Compiled
            }
            note.add_instantiation(entry1)

            val entry2 = InstantiationEntry {
                template_name: "Option",
                type_args: "String",
                mangled_name: "Option$String",
                from_file: "app.spl",
                from_loc: "app.spl:15:8",
                to_obj: "app.o",
                status: InstantiationStatus.Compiled
            }
            note.add_instantiation(entry2)

            check(note.instantiations[0].template_name == "List")
            check(note.instantiations[1].template_name == "Option")

describe "DependencyEdge":
    context "when creating a dependency":
        it "should store from_inst":
            val dep = DependencyEdge {
                from_inst: "List$Int",
                to_inst: "Int",
                dep_kind: DependencyKind.TypeParam
            }
            check(dep.from_inst == "List$Int")

        it "should store to_inst":
            val dep = DependencyEdge {
                from_inst: "List$Int",
                to_inst: "Int",
                dep_kind: DependencyKind.TypeParam
            }
            check(dep.to_inst == "Int")

        it "should store dependency kind":
            val dep = DependencyEdge {
                from_inst: "List$Int",
                to_inst: "Int",
                dep_kind: DependencyKind.TypeParam
            }
            check(dep.dep_kind == DependencyKind.TypeParam)

    context "when adding to metadata":
        it "should be tracked":
            var note = NoteSdnMetadata.new()
            val dep = DependencyEdge {
                from_inst: "List$Int",
                to_inst: "Int",
                dep_kind: DependencyKind.TypeParam
            }
            note.add_dependency(dep)
            check(note.dependencies.len() == 1)

        it "should allow multiple dependencies":
            var note = NoteSdnMetadata.new()

            val dep1 = DependencyEdge {
                from_inst: "List$Int",
                to_inst: "Int",
                dep_kind: DependencyKind.TypeParam
            }
            note.add_dependency(dep1)

            val dep2 = DependencyEdge {
                from_inst: "Container$List$Int",
                to_inst: "List$Int",
                dep_kind: DependencyKind.FieldType
            }
            note.add_dependency(dep2)

            check(note.dependencies.len() == 2)

describe "InstantiationStatus":
    context "when converting to string":
        it "should convert Compiled to 'compiled'":
            check(InstantiationStatus.Compiled.to_string() == "compiled")

        it "should convert Deferred to 'deferred'":
            check(InstantiationStatus.Deferred.to_string() == "deferred")

        it "should convert JitCompiled to 'jit_compiled'":
            check(InstantiationStatus.JitCompiled.to_string() == "jit_compiled")

    context "when parsing from string":
        it "should parse 'compiled' successfully":
            val result = InstantiationStatus.from_string("compiled")
            check(result.ok.?)

        it "should parse 'deferred' successfully":
            val result = InstantiationStatus.from_string("deferred")
            check(result.ok.?)

        it "should parse 'jit_compiled' successfully":
            val result = InstantiationStatus.from_string("jit_compiled")
            check(result.ok.?)

        it "should return error for invalid string":
            val result = InstantiationStatus.from_string("invalid")
            check(result.err.?)

describe "DependencyKind":
    context "when converting to string":
        it "should convert TypeParam to 'type_param'":
            check(DependencyKind.TypeParam.to_string() == "type_param")

        it "should convert FieldType to 'field_type'":
            check(DependencyKind.FieldType.to_string() == "field_type")

        it "should convert InnerType to 'inner_type'":
            check(DependencyKind.InnerType.to_string() == "inner_type")

        it "should convert MethodDep to 'method_dep'":
            check(DependencyKind.MethodDep.to_string() == "method_dep")

    context "when parsing from string":
        it "should parse 'type_param' successfully":
            val result = DependencyKind.from_string("type_param")
            check(result.ok.?)

        it "should parse 'field_type' successfully":
            val result = DependencyKind.from_string("field_type")
            check(result.ok.?)

        it "should return error for invalid string":
            val result = DependencyKind.from_string("invalid")
            check(result.err.?)

describe "SDN Serialization":
    context "when serializing empty metadata":
        it "should include header":
            val note = NoteSdnMetadata.new()
            val sdn = note.to_sdn()
            check(sdn.contains("# Instantiation To/From Metadata"))

        it "should include format version":
            val note = NoteSdnMetadata.new()
            val sdn = note.to_sdn()
            check(sdn.contains("# Format version: 1.0"))

        it "should include all table headers":
            val note = NoteSdnMetadata.new()
            val sdn = note.to_sdn()
            check(sdn.contains("instantiations |"))
            check(sdn.contains("possible |"))
            check(sdn.contains("type_inferences |"))
            check(sdn.contains("dependencies |"))
            check(sdn.contains("circular_warnings |"))
            check(sdn.contains("circular_errors |"))

        it "should include terminator":
            val note = NoteSdnMetadata.new()
            val sdn = note.to_sdn()
            check(sdn.contains("# END_NOTE"))

    context "when serializing with data":
        it "should include instantiation data":
            var note = NoteSdnMetadata.new()
            val entry = InstantiationEntry {
                template_name: "List",
                type_args: "Int",
                mangled_name: "List$Int",
                from_file: "app.spl",
                from_loc: "app.spl:10:5",
                to_obj: "app.o",
                status: InstantiationStatus.Compiled
            }
            note.add_instantiation(entry)

            val sdn = note.to_sdn()
            check(sdn.contains("List"))
            check(sdn.contains("Int"))
            check(sdn.contains("List$Int"))

        it "should include dependency data":
            var note = NoteSdnMetadata.new()
            val dep = DependencyEdge {
                from_inst: "List$Int",
                to_inst: "Int",
                dep_kind: DependencyKind.TypeParam
            }
            note.add_dependency(dep)

            val sdn = note.to_sdn()
            check(sdn.contains("List$Int"))
            check(sdn.contains("Int"))
            check(sdn.contains("type_param"))

describe "String Escaping":
    context "when escaping special characters":
        it "should not escape normal strings":
            check(escape_sdn("hello world") == "hello world")

describe "Circular Dependencies":
    context "when adding warnings":
        it "should track circular warnings":
            var note = NoteSdnMetadata.new()
            val warn = CircularWarning {
                cycle_path: "Node$T->Option$Node$T->Node$T",
                severity: "warning"
            }
            note.add_circular_warning(warn)
            check(note.circular_warnings.len() == 1)

        it "should store cycle path":
            var note = NoteSdnMetadata.new()
            val warn = CircularWarning {
                cycle_path: "Node$T->Option$Node$T->Node$T",
                severity: "warning"
            }
            note.add_circular_warning(warn)
            check(note.circular_warnings[0].cycle_path == "Node$T->Option$Node$T->Node$T")

    context "when adding errors":
        it "should track circular errors":
            var note = NoteSdnMetadata.new()
            val err = CircularError {
                cycle_path: "A$T->B$T->C$T->A$T",
                error_code: "E0420"
            }
            note.add_circular_error(err)
            check(note.circular_errors.len() == 1)

        it "should store error code":
            var note = NoteSdnMetadata.new()
            val err = CircularError {
                cycle_path: "A$T->B$T->C$T->A$T",
                error_code: "E0420"
            }
            note.add_circular_error(err)
            check(note.circular_errors[0].error_code == "E0420")

describe "Complete Workflow":
    context "end-to-end scenario":
        it "should handle full instantiation tracking workflow":
            var note = NoteSdnMetadata.new()

            # Add instantiation
            val entry = InstantiationEntry {
                template_name: "List",
                type_args: "Int",
                mangled_name: "List$Int",
                from_file: "app.spl",
                from_loc: "app.spl:10:5",
                to_obj: "app.o",
                status: InstantiationStatus.Compiled
            }
            note.add_instantiation(entry)

            # Add dependency
            val dep = DependencyEdge {
                from_inst: "List$Int",
                to_inst: "Int",
                dep_kind: DependencyKind.TypeParam
            }
            note.add_dependency(dep)

            # Add possible
            val poss = PossibleInstantiationEntry {
                template_name: "Option",
                type_args: "String",
                mangled_name: "Option$String",
                required_by: "string_module",
                can_defer: true
            }
            note.add_possible(poss)

            # Add type inference
            val inf = TypeInferenceEntry {
                inferred_type: "Int",
                expr: "42",
                context: "literal",
                from_file: "app.spl",
                from_loc: "app.spl:5:10"
            }
            note.add_type_inference(inf)

            # Serialize
            val sdn = note.to_sdn()

            # Verify
            check(sdn.contains("List$Int"))
            check(sdn.contains("Option$String"))
            check(sdn.contains("42"))
            check(sdn.contains("# END_NOTE"))
            check(note.instantiations.len() == 1)
            check(note.dependencies.len() == 1)
            check(note.possible.len() == 1)
            check(note.type_inferences.len() == 1)
