# BDD-Style Unit Tests for note.sdn
#
# These tests use describe/context/it blocks in BDD style
# to test the note.sdn implementation comprehensively.

use simple/compiler/monomorphize/note_sdn.*
use simple/compiler/monomorphize/metadata.ConcreteType

describe "NoteSdnMetadata":
    context "when newly created":
        it "should be empty":
            val note = NoteSdnMetadata.new()
            assert note.is_empty()

        it "should have empty instantiations list":
            val note = NoteSdnMetadata.new()
            assert note.instantiations.is_empty()

        it "should have empty possible list":
            val note = NoteSdnMetadata.new()
            assert note.possible.is_empty()

        it "should have empty dependencies list":
            val note = NoteSdnMetadata.new()
            assert note.dependencies.is_empty()

    context "when adding an instantiation":
        it "should not be empty":
            var note = NoteSdnMetadata.new()
            note.add_instantiation(InstantiationEntry.new(
                template: "List",
                type_args: [ConcreteType.Named("Int", [])],
                mangled_name: "List$Int",
                from_file: "app.spl",
                from_loc: "app.spl:10:5",
                to_obj: "app.o",
                status: InstantiationStatus.Compiled
            ))
            assert not note.is_empty()

        it "should have one instantiation":
            var note = NoteSdnMetadata.new()
            note.add_instantiation(InstantiationEntry.new(
                template: "List",
                type_args: [ConcreteType.Named("Int", [])],
                mangled_name: "List$Int",
                from_file: "app.spl",
                from_loc: "app.spl:10:5",
                to_obj: "app.o",
                status: InstantiationStatus.Compiled
            ))
            assert note.instantiations.len() == 1

        it "should store correct template name":
            var note = NoteSdnMetadata.new()
            note.add_instantiation(InstantiationEntry.new(
                template: "List",
                type_args: [ConcreteType.Named("Int", [])],
                mangled_name: "List$Int",
                from_file: "app.spl",
                from_loc: "app.spl:10:5",
                to_obj: "app.o",
                status: InstantiationStatus.Compiled
            ))
            assert note.instantiations[0].template == "List"

        it "should store correct mangled name":
            var note = NoteSdnMetadata.new()
            note.add_instantiation(InstantiationEntry.new(
                template: "List",
                type_args: [ConcreteType.Named("Int", [])],
                mangled_name: "List$Int",
                from_file: "app.spl",
                from_loc: "app.spl:10:5",
                to_obj: "app.o",
                status: InstantiationStatus.Compiled
            ))
            assert note.instantiations[0].mangled_name == "List$Int"

    context "when adding multiple instantiations":
        it "should track all instantiations":
            var note = NoteSdnMetadata.new()

            note.add_instantiation(InstantiationEntry.new(
                template: "List",
                type_args: [ConcreteType.Named("Int", [])],
                mangled_name: "List$Int",
                from_file: "app.spl",
                from_loc: "app.spl:10:5",
                to_obj: "app.o",
                status: InstantiationStatus.Compiled
            ))

            note.add_instantiation(InstantiationEntry.new(
                template: "Option",
                type_args: [ConcreteType.Named("String", [])],
                mangled_name: "Option$String",
                from_file: "app.spl",
                from_loc: "app.spl:15:8",
                to_obj: "app.o",
                status: InstantiationStatus.Compiled
            ))

            assert note.instantiations.len() == 2

        it "should preserve order of instantiations":
            var note = NoteSdnMetadata.new()

            note.add_instantiation(InstantiationEntry.new(
                template: "List",
                type_args: [ConcreteType.Named("Int", [])],
                mangled_name: "List$Int",
                from_file: "app.spl",
                from_loc: "app.spl:10:5",
                to_obj: "app.o",
                status: InstantiationStatus.Compiled
            ))

            note.add_instantiation(InstantiationEntry.new(
                template: "Option",
                type_args: [ConcreteType.Named("String", [])],
                mangled_name: "Option$String",
                from_file: "app.spl",
                from_loc: "app.spl:15:8",
                to_obj: "app.o",
                status: InstantiationStatus.Compiled
            ))

            assert note.instantiations[0].template == "List"
            assert note.instantiations[1].template == "Option"

describe "DependencyEdge":
    context "when creating a dependency":
        it "should store from_inst":
            val dep = DependencyEdge.new(
                from_inst: "List$Int",
                to_inst: "Int",
                dep_kind: DependencyKind.TypeParam
            )
            assert dep.from_inst == "List$Int"

        it "should store to_inst":
            val dep = DependencyEdge.new(
                from_inst: "List$Int",
                to_inst: "Int",
                dep_kind: DependencyKind.TypeParam
            )
            assert dep.to_inst == "Int"

        it "should store dependency kind":
            val dep = DependencyEdge.new(
                from_inst: "List$Int",
                to_inst: "Int",
                dep_kind: DependencyKind.TypeParam
            )
            assert dep.dep_kind == DependencyKind.TypeParam

    context "when adding to metadata":
        it "should be tracked":
            var note = NoteSdnMetadata.new()
            note.add_dependency(DependencyEdge.new(
                from_inst: "List$Int",
                to_inst: "Int",
                dep_kind: DependencyKind.TypeParam
            ))
            assert note.dependencies.len() == 1

        it "should allow multiple dependencies":
            var note = NoteSdnMetadata.new()

            note.add_dependency(DependencyEdge.new(
                from_inst: "List$Int",
                to_inst: "Int",
                dep_kind: DependencyKind.TypeParam
            ))

            note.add_dependency(DependencyEdge.new(
                from_inst: "Container$List$Int",
                to_inst: "List$Int",
                dep_kind: DependencyKind.FieldType
            ))

            assert note.dependencies.len() == 2

describe "InstantiationStatus":
    context "when converting to string":
        it "should convert Compiled to 'compiled'":
            assert InstantiationStatus.Compiled.to_string() == "compiled"

        it "should convert Deferred to 'deferred'":
            assert InstantiationStatus.Deferred.to_string() == "deferred"

        it "should convert JitCompiled to 'jit_compiled'":
            assert InstantiationStatus.JitCompiled.to_string() == "jit_compiled"

    context "when parsing from string":
        it "should parse 'compiled' to Compiled":
            val result = InstantiationStatus.from_string("compiled")
            assert result.ok.? == InstantiationStatus.Compiled

        it "should parse 'deferred' to Deferred":
            val result = InstantiationStatus.from_string("deferred")
            assert result.ok.? == InstantiationStatus.Deferred

        it "should parse 'jit_compiled' to JitCompiled":
            val result = InstantiationStatus.from_string("jit_compiled")
            assert result.ok.? == InstantiationStatus.JitCompiled

        it "should return error for invalid string":
            val result = InstantiationStatus.from_string("invalid")
            assert result.err.?

describe "DependencyKind":
    context "when converting to string":
        it "should convert TypeParam to 'type_param'":
            assert DependencyKind.TypeParam.to_string() == "type_param"

        it "should convert FieldType to 'field_type'":
            assert DependencyKind.FieldType.to_string() == "field_type"

        it "should convert InnerType to 'inner_type'":
            assert DependencyKind.InnerType.to_string() == "inner_type"

        it "should convert MethodDep to 'method_dep'":
            assert DependencyKind.MethodDep.to_string() == "method_dep"

    context "when parsing from string":
        it "should parse 'type_param' to TypeParam":
            val result = DependencyKind.from_string("type_param")
            assert result.ok.? == DependencyKind.TypeParam

        it "should parse 'field_type' to FieldType":
            val result = DependencyKind.from_string("field_type")
            assert result.ok.? == DependencyKind.FieldType

        it "should return error for invalid string":
            val result = DependencyKind.from_string("invalid")
            assert result.err.?

describe "SDN Serialization":
    context "when serializing empty metadata":
        it "should include header":
            val note = NoteSdnMetadata.new()
            val sdn = note.to_sdn()
            assert sdn.contains("# Instantiation To/From Metadata")

        it "should include format version":
            val note = NoteSdnMetadata.new()
            val sdn = note.to_sdn()
            assert sdn.contains("# Format version: 1.0")

        it "should include all table headers":
            val note = NoteSdnMetadata.new()
            val sdn = note.to_sdn()
            assert sdn.contains("instantiations |")
            assert sdn.contains("possible |")
            assert sdn.contains("type_inferences |")
            assert sdn.contains("dependencies |")
            assert sdn.contains("circular_warnings |")
            assert sdn.contains("circular_errors |")

        it "should include terminator":
            val note = NoteSdnMetadata.new()
            val sdn = note.to_sdn()
            assert sdn.contains("# END_NOTE\n")

    context "when serializing with data":
        it "should include instantiation data":
            var note = NoteSdnMetadata.new()
            note.add_instantiation(InstantiationEntry.new(
                template: "List",
                type_args: [ConcreteType.Named("Int", [])],
                mangled_name: "List$Int",
                from_file: "app.spl",
                from_loc: "app.spl:10:5",
                to_obj: "app.o",
                status: InstantiationStatus.Compiled
            ))

            val sdn = note.to_sdn()
            assert sdn.contains("\"List\"")
            assert sdn.contains("\"Int\"")
            assert sdn.contains("\"List$Int\"")

        it "should include dependency data":
            var note = NoteSdnMetadata.new()
            note.add_dependency(DependencyEdge.new(
                from_inst: "List$Int",
                to_inst: "Int",
                dep_kind: DependencyKind.TypeParam
            ))

            val sdn = note.to_sdn()
            assert sdn.contains("\"List$Int\", \"Int\", \"type_param\"")

describe "String Escaping":
    context "when escaping special characters":
        it "should escape double quotes":
            assert escape_sdn("test\"quote") == "test\\\"quote"

        it "should escape backslashes":
            assert escape_sdn("back\\slash") == "back\\\\slash"

        it "should escape newlines":
            assert escape_sdn("new\nline") == "new\\nline"

        it "should escape tabs":
            assert escape_sdn("tab\there") == "tab\\there"

        it "should not escape normal strings":
            assert escape_sdn("hello world") == "hello world"

describe "Circular Dependencies":
    context "when adding warnings":
        it "should track circular warnings":
            var note = NoteSdnMetadata.new()
            note.add_circular_warning(CircularWarning.new(
                cycle_path: "Node$T->Option$Node$T->Node$T",
                severity: "warning"
            ))
            assert note.circular_warnings.len() == 1

        it "should store cycle path":
            var note = NoteSdnMetadata.new()
            note.add_circular_warning(CircularWarning.new(
                cycle_path: "Node$T->Option$Node$T->Node$T",
                severity: "warning"
            ))
            assert note.circular_warnings[0].cycle_path == "Node$T->Option$Node$T->Node$T"

    context "when adding errors":
        it "should track circular errors":
            var note = NoteSdnMetadata.new()
            note.add_circular_error(CircularError.new(
                cycle_path: "A$T->B$T->C$T->A$T",
                error_code: "E0420"
            ))
            assert note.circular_errors.len() == 1

        it "should store error code":
            var note = NoteSdnMetadata.new()
            note.add_circular_error(CircularError.new(
                cycle_path: "A$T->B$T->C$T->A$T",
                error_code: "E0420"
            ))
            assert note.circular_errors[0].error_code == "E0420"

describe "Complete Workflow":
    context "end-to-end scenario":
        it "should handle full instantiation tracking workflow":
            var note = NoteSdnMetadata.new()

            # Add instantiation
            note.add_instantiation(InstantiationEntry.new(
                template: "List",
                type_args: [ConcreteType.Named("Int", [])],
                mangled_name: "List$Int",
                from_file: "app.spl",
                from_loc: "app.spl:10:5",
                to_obj: "app.o",
                status: InstantiationStatus.Compiled
            ))

            # Add dependency
            note.add_dependency(DependencyEdge.new(
                from_inst: "List$Int",
                to_inst: "Int",
                dep_kind: DependencyKind.TypeParam
            ))

            # Add possible
            note.add_possible(PossibleInstantiationEntry.new(
                template: "Option",
                type_args: [ConcreteType.Named("String", [])],
                mangled_name: "Option$String",
                required_by: "string_module",
                can_defer: true
            ))

            # Add type inference
            note.add_type_inference(TypeInferenceEntry.new(
                inferred_type: "Int",
                expr: "42",
                context: "literal",
                from_file: "app.spl",
                from_loc: "app.spl:5:10"
            ))

            # Serialize
            val sdn = note.to_sdn()

            # Verify
            assert sdn.contains("List$Int")
            assert sdn.contains("Option$String")
            assert sdn.contains("42")
            assert sdn.contains("# END_NOTE\n")
            assert note.instantiations.len() == 1
            assert note.dependencies.len() == 1
            assert note.possible.len() == 1
            assert note.type_inferences.len() == 1
