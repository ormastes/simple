# Note SDN Section Tests
#
# Tests for the note.sdn section in SMF files that tracks instantiation metadata.

# @skip
use simple.compiler.monomorphize.note_sdn

describe "NoteSdnMetadata":
    it "creates empty metadata":
        val note = NoteSdnMetadata.new()
        expect note.is_empty()
        expect note.instantiations.is_empty()
        expect note.possible.is_empty()
        expect note.type_inferences.is_empty()
        expect note.dependencies.is_empty()
        expect note.circular_warnings.is_empty()
        expect note.circular_errors.is_empty()

    it "is not empty after adding instantiation":
        var note = NoteSdnMetadata.new()
        val entry = InstantiationEntry { template_name: "List", type_args: "Int", mangled_name: "List$Int", from_file: "app.spl", from_loc: "app.spl:10:5", to_obj: "app.o", status: InstantiationStatus.Compiled }
        note.add_instantiation(entry)
        expect not note.is_empty()
        expect note.instantiations.len() == 1

    it "serializes to SDN format":
        var note = NoteSdnMetadata.new()
        val entry = InstantiationEntry { template_name: "List", type_args: "Int", mangled_name: "List$Int", from_file: "app.spl", from_loc: "app.spl:10:5", to_obj: "app.o", status: InstantiationStatus.Compiled }
        note.add_instantiation(entry)

        val sdn = note.to_sdn()

        # Check header
        expect sdn.contains("# Instantiation To/From Metadata")
        expect sdn.contains("# Format version: 1.0")

        # Check instantiations table
        expect sdn.contains("instantiations |")

        # Check terminator
        expect sdn.contains("# END_NOTE")

describe "InstantiationStatus":
    it "converts Compiled to string":
        expect InstantiationStatus.Compiled.to_string() == "compiled"

    it "converts Deferred to string":
        expect InstantiationStatus.Deferred.to_string() == "deferred"

    it "converts JitCompiled to string":
        expect InstantiationStatus.JitCompiled.to_string() == "jit_compiled"

describe "DependencyKind":
    it "converts TypeParam to string":
        expect DependencyKind.TypeParam.to_string() == "type_param"

    it "converts FieldType to string":
        expect DependencyKind.FieldType.to_string() == "field_type"

    it "converts InnerType to string":
        expect DependencyKind.InnerType.to_string() == "inner_type"

    it "converts MethodDep to string":
        expect DependencyKind.MethodDep.to_string() == "method_dep"

describe "DependencyEdge":
    it "creates dependency edge":
        val dep = DependencyEdge { from_inst: "List$Int", to_inst: "Int", dep_kind: DependencyKind.TypeParam }
        expect dep.from_inst == "List$Int"
        expect dep.to_inst == "Int"

    it "tracks multiple dependencies":
        var note = NoteSdnMetadata.new()
        val dep1 = DependencyEdge { from_inst: "List$Int", to_inst: "Int", dep_kind: DependencyKind.TypeParam }
        val dep2 = DependencyEdge { from_inst: "Container$List$Int", to_inst: "List$Int", dep_kind: DependencyKind.FieldType }
        note.add_dependency(dep1)
        note.add_dependency(dep2)
        expect note.dependencies.len() == 2

describe "CircularWarning":
    it "creates and adds warning":
        var note = NoteSdnMetadata.new()
        val warn = CircularWarning { cycle_path: "cycle", severity: "warning" }
        note.add_circular_warning(warn)
        expect note.circular_warnings.len() == 1

describe "CircularError":
    it "creates and adds error":
        var note = NoteSdnMetadata.new()
        val err = CircularError { cycle_path: "cycle", error_code: "E0420" }
        note.add_circular_error(err)
        expect note.circular_errors.len() == 1

describe "PossibleInstantiationEntry":
    it "creates and adds possible":
        var note = NoteSdnMetadata.new()
        val poss = PossibleInstantiationEntry { template_name: "Opt", type_args: "S", mangled_name: "Opt$S", required_by: "mod", can_defer: true }
        note.add_possible(poss)
        expect note.possible.len() == 1

describe "TypeInferenceEntry":
    it "creates and adds inference":
        var note = NoteSdnMetadata.new()
        val inf = TypeInferenceEntry { inferred_type: "Int", expr: "42", context: "lit", from_file: "a.spl", from_loc: "a:1" }
        note.add_type_inference(inf)
        expect note.type_inferences.len() == 1

describe "Complete Workflow":
    it "handles full instantiation tracking":
        var note = NoteSdnMetadata.new()

        # Add instantiation
        val entry = InstantiationEntry { template_name: "List", type_args: "Int", mangled_name: "List$Int", from_file: "app.spl", from_loc: "app.spl:10:5", to_obj: "app.o", status: InstantiationStatus.Compiled }
        note.add_instantiation(entry)

        # Add dependency
        val dep = DependencyEdge { from_inst: "List$Int", to_inst: "Int", dep_kind: DependencyKind.TypeParam }
        note.add_dependency(dep)

        # Add possible
        val poss = PossibleInstantiationEntry { template_name: "Option", type_args: "String", mangled_name: "Option$String", required_by: "string_module", can_defer: true }
        note.add_possible(poss)

        # Add type inference
        val inf = TypeInferenceEntry { inferred_type: "Int", expr: "42", context: "literal", from_file: "app.spl", from_loc: "app.spl:5:10" }
        note.add_type_inference(inf)

        # Serialize
        val sdn = note.to_sdn()

        # Verify
        expect sdn.contains("List$Int")
        expect sdn.contains("Option$String")
        expect sdn.contains("42")
        expect sdn.contains("# END_NOTE")
        expect note.instantiations.len() == 1
        expect note.dependencies.len() == 1
        expect note.possible.len() == 1
        expect note.type_inferences.len() == 1
