# Note SDN Section Tests
#
# Tests for the note.sdn section in SMF files that tracks instantiation metadata.

use simple/compiler/monomorphize/note_sdn.*
use simple/compiler/monomorphize/metadata.ConcreteType

describe "NoteSdnMetadata":
    it "creates empty metadata":
        val note = NoteSdnMetadata.new()
        assert note.is_empty()
        assert note.instantiations.is_empty()
        assert note.possible.is_empty()
        assert note.type_inferences.is_empty()
        assert note.dependencies.is_empty()
        assert note.circular_warnings.is_empty()
        assert note.circular_errors.is_empty()

    it "adds instantiation entry":
        var note = NoteSdnMetadata.new()

        val entry = InstantiationEntry.new(
            template: "List",
            type_args: [ConcreteType.Named("Int", [])],
            mangled_name: "List$Int",
            from_file: "app.spl",
            from_loc: "app.spl:10:5",
            to_obj: "app.o",
            status: InstantiationStatus.Compiled
        )

        note.add_instantiation(entry)

        assert not note.is_empty()
        assert note.instantiations.len() == 1
        assert note.instantiations[0].template == "List"
        assert note.instantiations[0].type_args == "Int"
        assert note.instantiations[0].mangled_name == "List$Int"

    it "adds possible instantiation entry":
        var note = NoteSdnMetadata.new()

        val entry = PossibleInstantiationEntry.new(
            template: "Option",
            type_args: [ConcreteType.Named("Float", [])],
            mangled_name: "Option$Float",
            required_by: "math_module",
            can_defer: true
        )

        note.add_possible(entry)

        assert note.possible.len() == 1
        assert note.possible[0].template == "Option"
        assert note.possible[0].can_defer

    it "adds dependency edge":
        var note = NoteSdnMetadata.new()

        val edge = DependencyEdge.new(
            from_inst: "List$Int",
            to_inst: "Int",
            dep_kind: DependencyKind.TypeParam
        )

        note.add_dependency(edge)

        assert note.dependencies.len() == 1
        assert note.dependencies[0].from_inst == "List$Int"
        assert note.dependencies[0].to_inst == "Int"

    it "serializes to SDN format":
        var note = NoteSdnMetadata.new()

        val inst = InstantiationEntry.new(
            template: "List",
            type_args: [ConcreteType.Named("Int", [])],
            mangled_name: "List$Int",
            from_file: "app.spl",
            from_loc: "app.spl:10:5",
            to_obj: "app.o",
            status: InstantiationStatus.Compiled
        )
        note.add_instantiation(inst)

        val dep = DependencyEdge.new(
            from_inst: "List$Int",
            to_inst: "Int",
            dep_kind: DependencyKind.TypeParam
        )
        note.add_dependency(dep)

        val sdn = note.to_sdn()

        # Check header
        assert sdn.contains("# Instantiation To/From Metadata")
        assert sdn.contains("# Format version: 1.0")

        # Check instantiations table
        assert sdn.contains("instantiations |")
        assert sdn.contains("\"List\"")
        assert sdn.contains("\"Int\"")
        assert sdn.contains("\"List$Int\"")
        assert sdn.contains("\"compiled\"")

        # Check dependencies table
        assert sdn.contains("dependencies |")
        assert sdn.contains("\"List$Int\", \"Int\", \"type_param\"")

        # Check terminator
        assert sdn.contains("# END_NOTE\n")

describe "InstantiationStatus":
    it "converts to string":
        assert InstantiationStatus.Compiled.to_string() == "compiled"
        assert InstantiationStatus.Deferred.to_string() == "deferred"
        assert InstantiationStatus.JitCompiled.to_string() == "jit_compiled"

    it "parses from string":
        assert InstantiationStatus.from_string("compiled").ok.? == InstantiationStatus.Compiled
        assert InstantiationStatus.from_string("deferred").ok.? == InstantiationStatus.Deferred
        assert InstantiationStatus.from_string("jit_compiled").ok.? == InstantiationStatus.JitCompiled
        assert InstantiationStatus.from_string("invalid").err.?

describe "DependencyKind":
    it "converts to string":
        assert DependencyKind.TypeParam.to_string() == "type_param"
        assert DependencyKind.FieldType.to_string() == "field_type"
        assert DependencyKind.InnerType.to_string() == "inner_type"
        assert DependencyKind.MethodDep.to_string() == "method_dep"

    it "parses from string":
        assert DependencyKind.from_string("type_param").ok.? == DependencyKind.TypeParam
        assert DependencyKind.from_string("field_type").ok.? == DependencyKind.FieldType
        assert DependencyKind.from_string("inner_type").ok.? == DependencyKind.InnerType
        assert DependencyKind.from_string("method_dep").ok.? == DependencyKind.MethodDep
        assert DependencyKind.from_string("invalid").err.?

describe "CircularWarning and CircularError":
    it "creates circular warning":
        val warning = CircularWarning.new(
            cycle_path: "Node$T->Option$Node$T->Node$T",
            severity: "warning"
        )

        assert warning.cycle_path == "Node$T->Option$Node$T->Node$T"
        assert warning.severity == "warning"

    it "creates circular error":
        val error = CircularError.new(
            cycle_path: "A$T->B$T->C$T->A$T",
            error_code: "E0420"
        )

        assert error.cycle_path == "A$T->B$T->C$T->A$T"
        assert error.error_code == "E0420"

describe "SDN escaping":
    it "escapes special characters":
        assert escape_sdn("hello") == "hello"
        assert escape_sdn("test\"quote") == "test\\\"quote"
        assert escape_sdn("back\\slash") == "back\\\\slash"
        assert escape_sdn("new\nline") == "new\\nline"
        assert escape_sdn("tab\there") == "tab\\there"

describe "Complete note.sdn example":
    it "generates full note.sdn with all tables":
        var note = NoteSdnMetadata.new()

        # Add instantiation
        note.add_instantiation(InstantiationEntry.new(
            template: "List",
            type_args: [ConcreteType.Named("Int", [])],
            mangled_name: "List$Int",
            from_file: "app.spl",
            from_loc: "app.spl:10:5",
            to_obj: "app.o",
            status: InstantiationStatus.Compiled
        ))

        # Add possible instantiation
        note.add_possible(PossibleInstantiationEntry.new(
            template: "Option",
            type_args: [ConcreteType.Named("String", [])],
            mangled_name: "Option$String",
            required_by: "string_module",
            can_defer: true
        ))

        # Add type inference
        note.add_type_inference(TypeInferenceEntry.new(
            inferred_type: "Int",
            expr: "42",
            context: "literal",
            from_file: "app.spl",
            from_loc: "app.spl:5:10"
        ))

        # Add dependency
        note.add_dependency(DependencyEdge.new(
            from_inst: "List$Int",
            to_inst: "Int",
            dep_kind: DependencyKind.TypeParam
        ))

        # Add circular warning
        note.add_circular_warning(CircularWarning.new(
            cycle_path: "Node$T->Option$Node$T->Node$T",
            severity: "warning"
        ))

        val sdn = note.to_sdn()

        # Verify all sections are present
        assert sdn.contains("instantiations |")
        assert sdn.contains("possible |")
        assert sdn.contains("type_inferences |")
        assert sdn.contains("dependencies |")
        assert sdn.contains("circular_warnings |")
        assert sdn.contains("circular_errors |")
        assert sdn.contains("# END_NOTE\n")

        # Verify content
        assert sdn.contains("\"List$Int\"")
        assert sdn.contains("\"Option$String\"")
        assert sdn.contains("\"42\"")
        assert sdn.contains("\"Node$T->Option$Node$T->Node$T\"")
