# @pending
# @skip
"""
# Linker with Shared Type Inference Specification

**Feature IDs:** #LINKER-001 to #LINKER-010
**Category:** Tooling
**Difficulty:** 4/5
**Status:** In Progress

## Overview

The Simple linker provides link-time and load-time generic instantiation
using shared HM type inference (HmInferContext from type_infer.spl).

Key components:
- ObjTaker: Shared object extraction with type inference
- SmfReader: SMF file reading
- Linker: Cross-module linking with type unification
- MoldBackend: Native binary generation via mold/lld/ld
- ModuleLoader: Runtime loading with JIT instantiation

## Key Concepts

| Concept | Description |
|---------|-------------|
| HmInferContext | Hindley-Milner inference context shared across components |
| ObjTaker | Extracts objects from SMF, instantiates generics with inferred types |
| Cross-module unification | Types unified across module boundaries during linking |

## Behavior

- All components share the same HmInferContext for consistent type inference
- Generic templates can be instantiated at link-time or load-time
- Mold backend generates native ELF binaries (fallback: lld, ld)
"""

use compiler.linker
use compiler.type_infer
use compiler.lexer_types.Span

# ============================================================================
# Test Group 1: ObjTaker with Type Inference
# ============================================================================

describe "ObjTaker":
    """
    ## ObjTaker Component

    Validates that ObjTaker correctly uses HmInferContext for type inference
    during object extraction and generic instantiation.
    """

    context "when created with defaults":
        """
        ### Scenario: Default Configuration

        ObjTaker should initialize with empty caches and a fresh inference context.
        """

        it "initializes with empty caches":
            # Arrange & Act
            val taker = ObjTaker.with_defaults()
            val stats = taker.cache_stats()

            # Assert
            expect(stats.template_count).to_equal(0))
            expect(stats.instance_count).to_equal(0))

        it "has HmInferContext at level 0":
            # Arrange & Act
            val config = ObjTakerConfig.default()
            val taker = ObjTaker.new(config)

            # Assert
            expect(taker.infer_ctx.level).to_equal(0))

    context "when sharing inference context":
        """
        ### Scenario: Shared HmInferContext

        Multiple components should share the same inference context
        to enable cross-module type unification.
        """

        it "shares context modifications":
            # Arrange
            val shared_ctx = HmInferContext.with_builtins()
            val config = ObjTakerConfig.default()
            val taker = ObjTaker.with_inference_context(shared_ctx, config)

            # Act - modify shared context
            val span = Span(start: 0, end: 0, line: 0, col: 0)
            val fresh = shared_ctx.fresh_var(span)

            # Assert - taker sees the update
            expect(taker.infer_ctx.next_var).to_equal(shared_ctx.next_var))


# ============================================================================
# Test Group 2: Linker Configuration
# ============================================================================

describe "LinkConfig":
    """
    ## Link Configuration

    Validates link configuration for SMF and native output formats.
    """

    context "with default settings":
        it "uses SMF output format":
            val config = LinkConfig.default()
            expect(config.output_format).to_equal(OutputFormat.Smf))

        it "enables PIE by default":
            val config = LinkConfig.default()
            expect(config.pie).to_equal(true))

        it "disables verbose by default":
            val config = LinkConfig.default()
            expect(config.verbose).to_equal(false))

    context "with native output":
        it "creates native config correctly":
            val config = LinkConfig.native("output.bin")
            expect(config.output_format).to_equal(OutputFormat.Native))
            expect(config.output_path).to_equal("output.bin"))

    context "with SMF output":
        it "creates SMF config correctly":
            val config = LinkConfig.smf("output.smf")
            expect(config.output_format).to_equal(OutputFormat.Smf))
            expect(config.output_path).to_equal("output.smf"))


# ============================================================================
# Test Group 3: Linker with Shared Inference
# ============================================================================

describe "Linker":
    """
    ## Linker Component

    Validates that the linker shares HmInferContext with ObjTaker
    for cross-module type unification.
    """

    context "when created":
        it "shares inference context with obj_taker":
            # Arrange
            val config = LinkConfig.default()
            val linker = Linker.new(config)
            val span = Span(start: 0, end: 0, line: 0, col: 0)

            # Act
            val fresh = linker.infer_ctx.fresh_var(span)

            # Assert - ObjTaker sees the same next_var
            expect(linker.obj_taker.infer_ctx.next_var).to_equal(linker.infer_ctx.next_var))


# ============================================================================
# Test Group 4: Mold Backend
# ============================================================================

describe "MoldBackend":
    """
    ## Mold Backend

    Validates mold/lld/ld linker detection and configuration.
    Note: Mold 2.0+ is MIT licensed and can be bundled with Simple.
    """

    context "linker detection":
        it "finds at least one linker":
            val result = find_linker()
            expect(result.is_ok()).to_equal(true))

    context "configuration":
        it "enables PIE by default":
            val config = MoldConfig.default()
            expect(config.pie).to_equal(true))

        it "disables verbose by default":
            val config = MoldConfig.default()
            expect(config.verbose).to_equal(false))


# ============================================================================
# Test Group 5: Module Loader
# ============================================================================

describe "ModuleLoader":
    """
    ## Module Loader

    Validates runtime module loading with JIT instantiation support.
    """

    context "configuration":
        it "enables JIT by default":
            val config = ModuleLoaderConfig.default()
            expect(config.enable_jit).to_equal(true))

        it "enables caching by default":
            val config = ModuleLoaderConfig.default()
            expect(config.enable_cache).to_equal(true))

        it "disables hot reload by default":
            val config = ModuleLoaderConfig.default()
            expect(config.hot_reload).to_equal(false))

    context "when created":
        it "initializes with empty module list":
            val loader = ModuleLoader.with_defaults()
            val stats = loader.stats()
            expect(stats.module_count).to_equal(0))
            expect(stats.symbol_count).to_equal(0))

        it "shares inference context with obj_taker":
            # Arrange
            val loader = ModuleLoader.with_defaults()
            val span = Span(start: 0, end: 0, line: 0, col: 0)

            # Act
            val fresh = loader.infer_ctx.fresh_var(span)

            # Assert
            expect(loader.obj_taker.infer_ctx.next_var).to_equal(loader.infer_ctx.next_var))


# ============================================================================
# Test Group 6: Cross-Module Type Inference
# ============================================================================

describe "Cross-Module Type Inference":
    """
    ## Type Inference Integration

    Validates that HM type inference works correctly across module boundaries.
    """

    context "type unification":
        """
        ### Scenario: Cross-Module Unification

        Types from different modules should unify correctly when used together.
        """

        it "unifies types from different modules":
            # Arrange
            val ctx = HmInferContext.with_builtins()
            val span = Span(start: 0, end: 0, line: 0, col: 0)

            # Create type variables from different modules
            val module_a_type = ctx.fresh_var(span)
            val module_b_type = ctx.fresh_var(span)

            # Act - unify both with Int
            val int_type = HirType(kind: HirTypeKind.Int(64, true), span: span)
            ctx.unify(module_a_type, int_type)
            ctx.unify(module_b_type, int_type)

            # Assert - both resolve to Int
            val resolved_a = ctx.subst.apply(module_a_type)
            val resolved_b = ctx.subst.apply(module_b_type)

            match resolved_a.kind:
                case Int(bits, signed):
                    expect(bits).to_equal(64))
                    expect(signed).to_equal(true))
                case _:
                    fail("Expected Int type for module A")

            match resolved_b.kind:
                case Int(bits, signed):
                    expect(bits).to_equal(64))
                    expect(signed).to_equal(true))
                case _:
                    fail("Expected Int type for module B")

    context "generic instantiation":
        """
        ### Scenario: Type Argument Inference

        Generic type arguments should be inferred from usage context.
        """

        it "infers type arguments from call site":
            # Arrange
            val ctx = HmInferContext.with_builtins()
            val span = Span(start: 0, end: 0, line: 0, col: 0)

            # Simulate identity<T>(x: T) called with Int
            val t_var = ctx.fresh_var(span)
            val arg_type = HirType(kind: HirTypeKind.Int(64, true), span: span)

            # Act - unify T with Int
            ctx.unify(t_var, arg_type)

            # Assert - T resolves to Int
            val resolved = ctx.subst.apply(t_var)
            match resolved.kind:
                case Int(bits, _):
                    expect(bits).to_equal(64))
                case _:
                    fail("Expected Int type")
