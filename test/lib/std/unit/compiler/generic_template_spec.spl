# Generic Template Storage Tests
#
# Unit tests for generic template bytecode storage and deferred monomorphization.

# @skip
use simple.compiler.monomorphize.partition (
    partition_generic_constructs,
    GenericTemplates,
    SpecializedInstances
)
use simple.compiler.monomorphize.metadata (
    MonomorphizationMetadata,
    ConcreteType,
    SpecializationKey
)
use simple.compiler.monomorphize.deferred (
    DeferredMonomorphizer,
    InstantiationMode,
    GenericTemplate,
    CompiledCode
)
use simple.compiler.ast (Module, FunctionDef, StructDef)

describe "Generic Template Partitioning":
    """Test template/specialized instance separation."""

    # status: Implemented
    # priority: P1
    # category: Compiler

    it "Partition generic function from module":
        # given "A module with generic function identity<T>"
        # when "Partitioning generic constructs"
        # then "Function is in templates collection"
        # and "Generic parameters are preserved"
        pass

        it "should separate generic function into templates":
            val module = create_test_module_with_generic_function()

            val (templates, specialized, metadata) = partition_generic_constructs(module)

            # Should have 1 template function
            expect(templates.functions.len()).to_equal(1)
            expect(templates.functions[0].name).to_equal("identity")
            expect(templates.functions[0].generic_params.len()).to_equal(1)
            expect(templates.functions[0].is_generic_template).to_be(true)

            # No specializations
            expect(specialized.functions.len()).to_equal(0)

    scenario "Partition generic struct":
        given "A generic struct Container<T>"
        when "Partitioning constructs"
        then "Struct is in templates"

        it "should separate generic struct":
            val module = create_test_module_with_generic_struct()

            val (templates, specialized, _) = partition_generic_constructs(module)

            expect(templates.structs.len()).to_equal(1)
            expect(templates.structs[0].name).to_equal("Container")
            expect(templates.structs[0].is_generic_template).to_be(true)

    scenario "Partition mixed generic and non-generic":
        given "Module with generic identity<T> and regular add"
        when "Partitioning"
        then "identity<T> in templates, add in specialized"

        it "should separate correctly":
            val module = create_test_module_with_mixed_functions()

            val (templates, specialized, _) = partition_generic_constructs(module)

            # identity<T> in templates
            expect(templates.functions.any(\f: f.name == "identity")).to_be(true)

            # add in specialized
            expect(specialized.functions.any(\f: f.name == "add")).to_be(true)

    scenario "Empty templates object has zero count":
        given "Empty GenericTemplates"
        when "Checking count"
        then "Returns 0"

        it "should report zero for empty templates":
            val empty = GenericTemplates.empty()

            expect(empty.count()).to_equal(0)
            expect(empty.is_empty()).to_be(true)

    scenario "Templates with multiple constructs":
        given "Templates with function, struct, enum"
        when "Counting"
        then "Returns total count"

        it "should count all template types":
            val templates = create_test_templates_with_all_types()

            # Should have at least 3 (function, struct, enum)
            expect(templates.count()).to_be_greater_than_or_equal(3)
            expect(templates.is_empty()).to_be(false)

describe "Monomorphization Metadata":
    """Test metadata tracking for specializations."""

    status: Implemented
    priority: P1
    category: Compiler

    scenario "Metadata tracks template":
        given "Generic function template"
        when "Building metadata"
        then "Template is registered"

        it "should register function template in metadata":
            val templates = create_templates_with_one_function()
            val specialized = SpecializedInstances.empty()

            val metadata = build_monomorphization_metadata(templates, specialized)

            expect(metadata.functions.contains_key("identity")).to_be(true)

    scenario "Metadata tracks specializations":
        given "Template with specialization"
        when "Building metadata"
        then "Specialization is tracked under template"

        it "should track specialization entry":
            val (templates, specialized) = create_template_with_specialization()

            val metadata = build_monomorphization_metadata(templates, specialized)

            val func_meta = metadata.functions["identity"]
            expect(func_meta.specializations.len()).to_equal(1)
            expect(func_meta.specializations[0].mangled_name).to_equal("identity$Int")

    scenario "Metadata with multiple specializations":
        given "Template with Int and Float specializations"
        when "Building metadata"
        then "Both are tracked"

        it "should track multiple specializations":
            val (templates, specialized) = create_template_with_multiple_specializations()

            val metadata = build_monomorphization_metadata(templates, specialized)

            val func_meta = metadata.functions["square"]
            expect(func_meta.specializations.len()).to_equal(2)

            val names = func_meta.specializations.map(\s: s.mangled_name)
            expect(names).to_contain("square$Int")
            expect(names).to_contain("square$Float")

describe "Deferred Monomorphization":
    """Test on-demand template instantiation."""

    status: Implemented
    priority: P1
    category: Compiler

    scenario "Create deferred monomorphizer":
        given "Instantiation mode"
        when "Creating monomorphizer"
        then "Initializes correctly"

        it "should initialize with empty caches":
            val mono = DeferredMonomorphizer.new(InstantiationMode.LinkTime)

            val stats = mono.get_stats()
            expect(stats.template_count).to_equal(0)
            expect(stats.specialization_count).to_equal(0)
            expect(stats.mode).to_equal(InstantiationMode.LinkTime)

    scenario "Cache template in monomorphizer":
        given "Generic function template"
        when "Adding to cache"
        then "Can retrieve template"

        it "should cache and retrieve template":
            var mono = DeferredMonomorphizer.new(InstantiationMode.LinkTime)

            val template = create_test_function_def("identity", ["T"])
            mono.template_cache["identity"] = GenericTemplate.Function(template)

            val retrieved = mono.get_template("identity")
            expect(retrieved.?).to_be(true)

            match retrieved.unwrap():
                GenericTemplate.Function(f):
                    expect(f.name).to_equal("identity")
                _:
                    fail("Expected function template")

    scenario "Instantiate function from template":
        given "Template in cache"
        when "Requesting instantiation with type args"
        then "Returns specialized function"

        it "should instantiate function with concrete types":
            var mono = DeferredMonomorphizer.new(InstantiationMode.LinkTime)

            # Add template
            val template = create_test_function_def("identity", ["T"])
            mono.template_cache["identity"] = GenericTemplate.Function(template)

            # Instantiate with Int
            val type_args = [ConcreteType.Int]
            val result = mono.instantiate_function("identity", type_args)

            match result:
                Ok(specialized):
                    expect(specialized.name).to_contain("identity")
                    expect(specialized.is_generic_template).to_be(false)
                Err(e):
                    # Expected if monomorphizer integration incomplete
                    expect(e.message).to_contain("Monomorphizer")

    scenario "Error on wrong type argument count":
        given "Template with 2 type parameters"
        when "Instantiating with 1 type arg"
        then "Returns error"

        it "should reject wrong type arg count":
            var mono = DeferredMonomorphizer.new(InstantiationMode.LinkTime)

            val template = create_test_function_def("pair", ["T", "U"])
            mono.template_cache["pair"] = GenericTemplate.Function(template)

            # Try with 1 arg (should fail)
            val result = mono.instantiate_function("pair", [ConcreteType.Int])

            expect(result.is_err()).to_be(true)
            expect(result.err_message()).to_contain("Wrong number")

    scenario "Error on missing template":
        given "Empty monomorphizer"
        when "Requesting non-existent template"
        then "Returns error"

        it "should report missing template":
            var mono = DeferredMonomorphizer.new(InstantiationMode.LinkTime)

            val result = mono.instantiate_function("nonexistent", [ConcreteType.Int])

            expect(result.is_err()).to_be(true)
            expect(result.err_message()).to_contain("No template found")

    scenario "Cache specializations":
        given "Successful instantiation"
        when "Requesting same specialization again"
        then "Returns cached result"

        it "should cache instantiated specializations":
            var mono = DeferredMonomorphizer.new(InstantiationMode.JitTime)

            val template = create_test_function_def("identity", ["T"])
            mono.template_cache["identity"] = GenericTemplate.Function(template)

            # Manually add to specialization cache
            val specialized = create_test_function_def("identity$Int", [])
            val key = SpecializationKey.new("identity", [ConcreteType.Int])
            mono.specialization_cache[key] = CompiledCode.Function(specialized)

            # Retrieve from cache
            val cached = mono.get_specialization(key)
            expect(cached.?).to_be(true)

            match cached.unwrap():
                CompiledCode.Function(f):
                    expect(f.name).to_equal("identity$Int")
                _:
                    fail("Expected function")

describe "Specialization Keys":
    """Test specialization key equality and hashing."""

    status: Implemented
    priority: P2
    category: Compiler

    scenario "Specialization keys are equal":
        given "Two keys with same name and type args"
        when "Comparing"
        then "They are equal"

        it "should compare keys correctly":
            val key1 = SpecializationKey.new("identity", [ConcreteType.Int])
            val key2 = SpecializationKey.new("identity", [ConcreteType.Int])

            expect(key1).to_equal(key2)

    scenario "Different type args not equal":
        given "Keys with different type args"
        when "Comparing"
        then "They are not equal"

        it "should differentiate by type args":
            val key1 = SpecializationKey.new("identity", [ConcreteType.Int])
            val key2 = SpecializationKey.new("identity", [ConcreteType.Float])

            expect(key1).not_to_equal(key2)

    scenario "Nested type args in keys":
        given "Key with nested generic type"
        when "Creating key"
        then "Preserves nesting"

        it "should handle nested types":
            val inner = ConcreteType.Generic("Result", [ConcreteType.Int, ConcreteType.String])
            val outer = ConcreteType.Generic("List", [inner])

            val key = SpecializationKey.new("process", [outer])

            expect(key.name).to_equal("process")
            expect(key.type_args.len()).to_equal(1)

describe "Concrete Types":
    """Test concrete type representation."""

    status: Implemented
    priority: P2
    category: Compiler

    scenario "Primitive types not equal":
        given "Different primitive types"
        when "Comparing"
        then "They are distinct"

        it "should differentiate primitives":
            expect(ConcreteType.Int).not_to_equal(ConcreteType.Float)
            expect(ConcreteType.Int).not_to_equal(ConcreteType.Bool)
            expect(ConcreteType.Int).not_to_equal(ConcreteType.String)

    scenario "Array types with different elements":
        given "Array<Int> and Array<Float>"
        when "Comparing"
        then "They are different"

        it "should differentiate array element types":
            val array_int = ConcreteType.Array(ConcreteType.Int)
            val array_float = ConcreteType.Array(ConcreteType.Float)

            expect(array_int).not_to_equal(array_float)

    scenario "Tuple types preserve order":
        given "Tuple (Int, String)"
        when "Inspecting"
        then "Elements in correct order"

        it "should preserve tuple element order":
            val tuple = ConcreteType.Tuple([ConcreteType.Int, ConcreteType.String])

            match tuple:
                ConcreteType.Tuple(elems):
                    expect(elems.len()).to_equal(2)
                    expect(elems[0]).to_equal(ConcreteType.Int)
                    expect(elems[1]).to_equal(ConcreteType.String)
                _:
                    fail("Expected tuple type")

# ============================================================================
# Test Helper Functions
# ============================================================================

fn create_test_module_with_generic_function() -> Module:
    # TODO: Implement module creation
    Module(items: [], name: Some("test"))

fn create_test_module_with_generic_struct() -> Module:
    Module(items: [], name: Some("test"))

fn create_test_module_with_mixed_functions() -> Module:
    Module(items: [], name: Some("test"))

fn create_test_templates_with_all_types() -> GenericTemplates:
    GenericTemplates(
        functions: [create_test_function_def("identity", ["T"])],
        structs: [create_test_struct_def("Container", ["T"])],
        classes: [],
        enums: [create_test_enum_def("Option", ["T"])],
        traits: []
    )

fn create_templates_with_one_function() -> GenericTemplates:
    GenericTemplates(
        functions: [create_test_function_def("identity", ["T"])],
        structs: [],
        classes: [],
        enums: [],
        traits: []
    )

fn create_template_with_specialization() -> (GenericTemplates, SpecializedInstances):
    var template = create_test_function_def("identity", ["T"])
    template.is_generic_template = true

    var specialized = create_test_function_def("identity$Int", [])
    specialized.is_generic_template = false
    specialized.specialization_of = Some("identity")

    val templates = GenericTemplates(
        functions: [template],
        structs: [],
        classes: [],
        enums: [],
        traits: []
    )

    val instances = SpecializedInstances(
        functions: [specialized],
        structs: [],
        classes: [],
        enums: [],
        traits: []
    )

    (templates, instances)

fn create_template_with_multiple_specializations() -> (GenericTemplates, SpecializedInstances):
    var template = create_test_function_def("square", ["T"])
    template.is_generic_template = true

    var spec_int = create_test_function_def("square$Int", [])
    spec_int.specialization_of = Some("square")

    var spec_float = create_test_function_def("square$Float", [])
    spec_float.specialization_of = Some("square")

    val templates = GenericTemplates(
        functions: [template],
        structs: [],
        classes: [],
        enums: [],
        traits: []
    )

    val instances = SpecializedInstances(
        functions: [spec_int, spec_float],
        structs: [],
        classes: [],
        enums: [],
        traits: []
    )

    (templates, instances)

fn create_test_function_def(name: text, generic_params: [text]) -> FunctionDef:
    FunctionDef(
        name: name,
        generic_params: generic_params,
        params: [],
        return_type: None,
        body: None,
        is_generic_template: not generic_params.is_empty(),
        specialization_of: None,
        type_bindings: {},
        attributes: [],
        where_clause: None,
        effects: [],
        contracts: None
    )

fn create_test_struct_def(name: text, generic_params: [text]) -> StructDef:
    StructDef(
        name: name,
        generic_params: generic_params,
        fields: [],
        is_generic_template: not generic_params.is_empty(),
        specialization_of: None,
        type_bindings: {},
        where_clause: None,
        attributes: [],
        invariant: None
    )

fn create_test_enum_def(name: text, generic_params: [text]) -> EnumDef:
    EnumDef(
        name: name,
        generic_params: generic_params,
        variants: [],
        is_generic_template: not generic_params.is_empty(),
        specialization_of: None,
        type_bindings: {},
        where_clause: None,
        attributes: []
    )
