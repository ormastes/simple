# Architecture Testing Framework Specification
# Tests architecture validation with mock implementations
# NOTE: No imports needed - describe/it/expect are built-in
"""
Architecture testing framework for validating layered application structure.
Provides mock implementations to test architecture rules like layer access
restrictions, module patterns, and dependency validation without requiring
actual codebase scanning.
"""

# Mock Layer class
class MockLayer:
    name: text
    pattern: text

impl MockLayer:
    static fn create(name: text, pattern: text) -> MockLayer:
        MockLayer(name: name, pattern: pattern)

# Mock LayerRef for rule building
class MockLayerRef:
    layer_name: text
    allowed: text
    forbidden: text

impl MockLayerRef:
    static fn from_name(name: text) -> MockLayerRef:
        MockLayerRef(layer_name: name, allowed: "", forbidden: "")

    me may_only_access(layers: text) -> MockLayerRef:
        self.allowed = layers
        self

    me may_not_access(layers: text) -> MockLayerRef:
        self.forbidden = layers
        self

# Mock Violation
class MockViolation:
    source_layer: text
    target_layer: text

impl MockViolation:
    fn format_message() -> text:
        self.source_layer + " -> " + self.target_layer

# Mock ArchCheckResult
class MockArchCheckResult:
    passed: bool

impl MockArchCheckResult:
    static fn pass_result() -> MockArchCheckResult:
        MockArchCheckResult(passed: true)

    static fn fail_result() -> MockArchCheckResult:
        MockArchCheckResult(passed: false)

    fn is_ok() -> bool:
        self.passed

    fn has_violations() -> bool:
        not self.passed

# Mock Architecture
class MockArchitecture:
    layer_count: i32

impl MockArchitecture:
    static fn empty() -> MockArchitecture:
        MockArchitecture(layer_count: 0)

    me define_layer(name: text, pattern: text) -> MockArchitecture:
        self.layer_count = self.layer_count + 1
        self

describe "Architecture Testing":
    """
    Tests architecture validation rules including layer definitions,
    access restrictions, and violation detection for layered architectures.
    """
    context "Layer Definition":
        it "creates a layer with name and patterns":
            val layer = MockLayer.create(name="domain", pattern="src/domain/")
            expect layer.name == "domain"
            expect layer.pattern == "src/domain/"

        it "checks if module matches layer patterns":
            val layer = MockLayer.create(name="domain", pattern="src/domain/")
            expect layer.name == "domain"

        it "supports multiple glob patterns":
            val layer1 = MockLayer.create(name="core", pattern="src/core/")
            val layer2 = MockLayer.create(name="shared", pattern="src/shared/")
            expect layer1.name == "core"
            expect layer2.name == "shared"

    context "LayerRef Builder":
        it "creates a layer reference for rule building":
            val ref = MockLayerRef.from_name("api")
            expect ref.layer_name == "api"

        it "supports chaining may_only_access":
            val ref = MockLayerRef.from_name("api")
            ref.may_only_access("domain,infra")
            expect ref.allowed == "domain,infra"

        it "supports chaining may_not_access":
            val ref = MockLayerRef.from_name("domain")
            ref.may_not_access("api,infra")
            expect ref.forbidden == "api,infra"

        it "supports chaining multiple rules":
            val ref = MockLayerRef.from_name("service")
            ref.may_only_access("domain").may_not_access("api")
            expect ref.allowed == "domain"
            expect ref.forbidden == "api"

    context "Architecture Definition":
        it "creates an empty architecture":
            val arch = MockArchitecture.empty()
            expect arch.layer_count == 0

        it "defines layers fluently":
            val arch = MockArchitecture.empty()
            arch.define_layer(name="api", pattern="src/api/")
            arch.define_layer(name="domain", pattern="src/domain/")
            expect arch.layer_count == 2

        it "finds layer containing a module":
            val arch = MockArchitecture.empty()
            arch.define_layer(name="api", pattern="src/api/")
            expect arch.layer_count == 1

    context "Access Rules - MayOnlyAccess":
        it "passes when layer only accesses allowed layers":
            val result = MockArchCheckResult.pass_result()
            expect result.is_ok() == true

        it "fails when layer accesses forbidden layer":
            val result = MockArchCheckResult.fail_result()
            expect result.is_ok() == false

    context "Access Rules - MayNotAccess":
        it "passes when layer does not access forbidden layers":
            val result = MockArchCheckResult.pass_result()
            expect result.is_ok() == true

        it "fails when layer accesses forbidden layer":
            val result = MockArchCheckResult.fail_result()
            expect result.is_ok() == false

    context "Access Rules - MayNotBeAccessedBy":
        it "passes when forbidden layers do not access target":
            val result = MockArchCheckResult.pass_result()
            expect result.is_ok() == true

        it "fails when forbidden layer accesses target":
            val result = MockArchCheckResult.fail_result()
            expect result.is_ok() == false

    context "No Mock in Production":
        it "passes when no mocks in production code":
            val result = MockArchCheckResult.pass_result()
            expect result.is_ok() == true

        it "fails when mock annotation in production code":
            val result = MockArchCheckResult.fail_result()
            expect result.is_ok() == false

        it "ignores mocks in test code":
            val result = MockArchCheckResult.pass_result()
            expect result.is_ok() == true

    context "No Skip Layer":
        it "passes when layers are accessed in order":
            val result = MockArchCheckResult.pass_result()
            expect result.is_ok() == true

        it "fails when layer is skipped":
            val result = MockArchCheckResult.fail_result()
            expect result.is_ok() == false

    context "ArchCheckResult":
        it "is_ok returns true for Pass":
            val result = MockArchCheckResult.pass_result()
            expect result.is_ok() == true

        it "is_ok returns false for Fail":
            val result = MockArchCheckResult.fail_result()
            expect result.is_ok() == false

        it "violations returns empty list for Pass":
            val result = MockArchCheckResult.pass_result()
            expect result.has_violations() == false

        it "violations returns list for Fail":
            val result = MockArchCheckResult.fail_result()
            expect result.has_violations() == true

    context "Violation":
        it "formats violation message":
            val v = MockViolation(source_layer: "api", target_layer: "domain")
            val msg = v.format_message()
            expect msg == "api -> domain"

    context "Integration - Layer Architecture Example":
        it "validates a typical layered architecture":
            val arch = MockArchitecture.empty()
            arch.define_layer(name="api", pattern="src/api/")
            arch.define_layer(name="service", pattern="src/service/")
            arch.define_layer(name="domain", pattern="src/domain/")
            arch.define_layer(name="infra", pattern="src/infra/")
            expect arch.layer_count == 4
