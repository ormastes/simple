# JSON Test Suite
#
# Comprehensive tests for JSON parsing, serialization, querying,
# and MessagePack support (std.json).

use std.json.*
use std.error.*
use std.test.sspec.*

# ============================================================================
# JsonValue Tests
# ============================================================================

describe "JsonValue":
    context "parse":
        it "should parse null":
            val result = JsonValue.parse("null")
            expect result.ok.? to_be_true

            val json = result.unwrap()
            expect json.is_null() to_be_true

        it "should parse boolean true":
            val result = JsonValue.parse("true")
            expect result.ok.? to_be_true

            val json = result.unwrap()
            expect json.as_bool().? to_be_true
            expect json.as_bool().unwrap() to_be_true

        it "should parse boolean false":
            val result = JsonValue.parse("false")
            expect result.ok.? to_be_true

            val json = result.unwrap()
            expect json.as_bool().? to_be_true
            expect json.as_bool().unwrap() to_be_false

        it "should parse number":
            val result = JsonValue.parse("42")
            expect result.ok.? to_be_true

            val json = result.unwrap()
            expect json.as_number().? to_be_true
            expect json.as_number().unwrap() to_equal 42.0

        it "should parse float number":
            val result = JsonValue.parse("3.14")
            expect result.ok.? to_be_true

            val json = result.unwrap()
            val num = json.as_number().unwrap()
            expect (num - 3.14).abs() < 0.001 to_be_true

        it "should parse negative number":
            val result = JsonValue.parse("-123")
            expect result.ok.? to_be_true

            val json = result.unwrap()
            expect json.as_number().unwrap() to_equal -123.0

        it "should parse string":
            val result = JsonValue.parse("\"hello\"")
            expect result.ok.? to_be_true

            val json = result.unwrap()
            expect json.as_string().? to_be_true
            expect json.as_string().unwrap() to_equal "hello"

        it "should parse empty string":
            val result = JsonValue.parse("\"\"")
            expect result.ok.? to_be_true

            val json = result.unwrap()
            expect json.as_string().unwrap() to_equal ""

        it "should parse string with escapes":
            val result = JsonValue.parse("\"hello\\nworld\"")
            expect result.ok.? to_be_true

            val json = result.unwrap()
            val str = json.as_string().unwrap()
            expect str to_contain "hello"
            expect str to_contain "world"

        it "should parse empty array":
            val result = JsonValue.parse("[]")
            expect result.ok.? to_be_true

            val json = result.unwrap()
            expect json.as_array().? to_be_true
            expect json.as_array().unwrap().len() to_equal 0

        it "should parse array with elements":
            val result = JsonValue.parse("[1, 2, 3]")
            expect result.ok.? to_be_true

            val json = result.unwrap()
            val arr = json.as_array().unwrap()
            expect arr.len() to_equal 3
            expect arr[0].as_number().unwrap() to_equal 1.0
            expect arr[1].as_number().unwrap() to_equal 2.0
            expect arr[2].as_number().unwrap() to_equal 3.0

        it "should parse nested array":
            val result = JsonValue.parse("[[1, 2], [3, 4]]")
            expect result.ok.? to_be_true

            val json = result.unwrap()
            val arr = json.as_array().unwrap()
            expect arr.len() to_equal 2
            expect arr[0].as_array().unwrap().len() to_equal 2
            expect arr[1].as_array().unwrap().len() to_equal 2

        it "should parse empty object":
            val result = JsonValue.parse(r"{}")
            expect result.ok.? to_be_true

            val json = result.unwrap()
            expect json.as_object().? to_be_true
            expect json.as_object().unwrap().len() to_equal 0

        it "should parse object with fields":
            val result = JsonValue.parse("{\"name\": \"Alice\", \"age\": 30}")
            expect result.ok.? to_be_true

            val json = result.unwrap()
            val obj = json.as_object().unwrap()
            expect obj.len() to_equal 2
            expect obj["name"].as_string().unwrap() to_equal "Alice"
            expect obj["age"].as_number().unwrap() to_equal 30.0

        it "should parse nested object":
            val result = JsonValue.parse("{\"user\": {\"name\": \"Bob\"}}")
            expect result.ok.? to_be_true

            val json = result.unwrap()
            val user = json.get("user").unwrap()
            expect user.get("name").unwrap().as_string().unwrap() to_equal "Bob"

        it "should fail on invalid JSON":
            val result = JsonValue.parse(r"{invalid")
            expect result.err.? to_be_true

    context "serialize":
        it "should serialize null":
            val json = JsonValue.Null
            val text = json.serialize()
            expect text to_equal "null"

        it "should serialize boolean":
            val json = JsonValue.Bool(true)
            expect json.serialize() to_equal "true"

        it "should serialize number":
            val json = JsonValue.Number(42.0)
            val text = json.serialize()
            expect text to_contain "42"

        it "should serialize string":
            val json = JsonValue.String("hello")
            expect json.serialize() to_equal "\"hello\""

        it "should serialize empty array":
            val json = JsonValue.Array([])
            expect json.serialize() to_equal "[]"

        it "should serialize array":
            val json = JsonValue.Array([
                JsonValue.Number(1.0),
                JsonValue.Number(2.0),
                JsonValue.Number(3.0)
            ])
            val text = json.serialize()
            expect text to_contain "1"
            expect text to_contain "2"
            expect text to_contain "3"

        it "should serialize empty object":
            val json = JsonValue.Object({})
            expect json.serialize() to_equal "{}"

        it "should serialize object":
            val json = JsonValue.Object({
                "name": JsonValue.String("Alice"),
                "age": JsonValue.Number(30.0)
            })
            val text = json.serialize()
            expect text to_contain "name"
            expect text to_contain "Alice"
            expect text to_contain "age"

    context "pretty":
        it "should pretty print object":
            val json = JsonValue.Object({
                "name": JsonValue.String("Alice"),
                "age": JsonValue.Number(30.0)
            })
            val text = json.pretty()
            expect text to_contain "name"
            expect text to_contain "Alice"
            # Pretty output should have indentation
            expect text.len() > json.serialize().len() to_be_true

    context "get":
        it "should get object field":
            val json = JsonValue.Object({
                "name": JsonValue.String("Alice")
            })
            val name = json.get("name")
            expect name.? to_be_true
            expect name.unwrap().as_string().unwrap() to_equal "Alice"

        it "should return None for missing field":
            val json = JsonValue.Object({})
            val missing = json.get("missing")
            expect missing.? to_be_false

        it "should return None for non-object":
            val json = JsonValue.String("not an object")
            val result = json.get("field")
            expect result.? to_be_false

    context "get_index":
        it "should get array element":
            val json = JsonValue.Array([
                JsonValue.String("first"),
                JsonValue.String("second")
            ])
            val first = json.get_index(0)
            expect first.? to_be_true
            expect first.unwrap().as_string().unwrap() to_equal "first"

        it "should return None for out of bounds":
            val json = JsonValue.Array([])
            val result = json.get_index(0)
            expect result.? to_be_false

        it "should return None for non-array":
            val json = JsonValue.String("not an array")
            val result = json.get_index(0)
            expect result.? to_be_false

    context "type_name":
        it "should return correct type names":
            expect JsonValue.Null.type_name() to_equal "null"
            expect JsonValue.Bool(true).type_name() to_equal "boolean"
            expect JsonValue.Number(42.0).type_name() to_equal "number"
            expect JsonValue.String("text").type_name() to_equal "string"
            expect JsonValue.Array([]).type_name() to_equal "array"
            expect JsonValue.Object({}).type_name() to_equal "object"

# ============================================================================
# JsonPath Tests
# ============================================================================

describe "JsonPath":
    context "query":
        it "should query simple field":
            val json = JsonValue.Object({
                "name": JsonValue.String("Alice")
            })
            val path = JsonPath.new("name")
            val result = path.query(json)
            expect result.? to_be_true
            expect result.unwrap().as_string().unwrap() to_equal "Alice"

        it "should query nested field":
            val json = JsonValue.Object({
                "user": JsonValue.Object({
                    "name": JsonValue.String("Bob")
                })
            })
            val path = JsonPath.new("user.name")
            val result = path.query(json)
            expect result.? to_be_true
            expect result.unwrap().as_string().unwrap() to_equal "Bob"

        it "should query array index":
            val json = JsonValue.Array([
                JsonValue.String("first"),
                JsonValue.String("second")
            ])
            val path = JsonPath.new("0")
            val result = path.query(json)
            expect result.? to_be_true
            expect result.unwrap().as_string().unwrap() to_equal "first"

        it "should query mixed path":
            val json = JsonValue.Object({
                "users": JsonValue.Array([
                    JsonValue.Object({
                        "name": JsonValue.String("Alice")
                    })
                ])
            })
            val path = JsonPath.new("users.0.name")
            val result = path.query(json)
            expect result.? to_be_true
            expect result.unwrap().as_string().unwrap() to_equal "Alice"

        it "should return None for invalid path":
            val json = JsonValue.Object({})
            val path = JsonPath.new("missing.field")
            val result = path.query(json)
            expect result.? to_be_false

# ============================================================================
# JsonBuilder Tests
# ============================================================================

describe "JsonBuilder":
    context "construction":
        it "should build empty object":
            val builder = JsonBuilder.new()
            val json = builder.build()
            expect json.as_object().unwrap().len() to_equal 0

        it "should build object with fields":
            val json = JsonBuilder.new()
                .put("name", JsonValue.String("Alice"))
                .put("age", JsonValue.Number(30.0))
                .build()

            val obj = json.as_object().unwrap()
            expect obj.len() to_equal 2
            expect obj["name"].as_string().unwrap() to_equal "Alice"
            expect obj["age"].as_number().unwrap() to_equal 30.0

    context "convenience methods":
        it "should put string":
            val json = JsonBuilder.new()
                .put_string("name", "Alice")
                .build()

            val name = json.get("name").unwrap().as_string().unwrap()
            expect name to_equal "Alice"

        it "should put number":
            val json = JsonBuilder.new()
                .put_number("age", 30.0)
                .build()

            val age = json.get("age").unwrap().as_number().unwrap()
            expect age to_equal 30.0

        it "should put boolean":
            val json = JsonBuilder.new()
                .put_bool("active", true)
                .build()

            val active = json.get("active").unwrap().as_bool().unwrap()
            expect active to_be_true

        it "should put null":
            val json = JsonBuilder.new()
                .put_null("value")
                .build()

            val value = json.get("value").unwrap()
            expect value.is_null() to_be_true

# ============================================================================
# JsonArray Tests
# ============================================================================

describe "JsonArray":
    context "construction":
        it "should build empty array":
            val builder = JsonArray.new()
            val json = builder.build()
            expect json.as_array().unwrap().len() to_equal 0

        it "should build array with elements":
            val json = JsonArray.new()
                .push(JsonValue.Number(1.0))
                .push(JsonValue.Number(2.0))
                .push(JsonValue.Number(3.0))
                .build()

            val arr = json.as_array().unwrap()
            expect arr.len() to_equal 3
            expect arr[0].as_number().unwrap() to_equal 1.0
            expect arr[2].as_number().unwrap() to_equal 3.0

    context "convenience methods":
        it "should push string":
            val json = JsonArray.new()
                .push_string("hello")
                .build()

            val arr = json.as_array().unwrap()
            expect arr[0].as_string().unwrap() to_equal "hello"

        it "should push number":
            val json = JsonArray.new()
                .push_number(42.0)
                .build()

            val arr = json.as_array().unwrap()
            expect arr[0].as_number().unwrap() to_equal 42.0

        it "should push boolean":
            val json = JsonArray.new()
                .push_bool(true)
                .build()

            val arr = json.as_array().unwrap()
            expect arr[0].as_bool().unwrap() to_be_true

        it "should push null":
            val json = JsonArray.new()
                .push_null()
                .build()

            val arr = json.as_array().unwrap()
            expect arr[0].is_null() to_be_true

# ============================================================================
# ToJson/FromJson Traits Tests
# ============================================================================

describe "ToJson/FromJson":
    context "custom type serialization":
        it "should serialize custom type":
            # This test demonstrates the trait pattern
            # In real code, you'd implement ToJson for your types
            val json = JsonBuilder.new()
                .put_string("name", "Alice")
                .put_number("age", 30.0)
                .build()

            expect json.as_object().? to_be_true

        it "should deserialize custom type":
            # This test demonstrates the trait pattern
            val json = JsonValue.parse("{\"name\": \"Bob\", \"age\": 25}").unwrap()
            val name = json.get("name").unwrap().as_string().unwrap()
            val age = json.get("age").unwrap().as_number().unwrap()

            expect name to_equal "Bob"
            expect age to_equal 25.0

# ============================================================================
# Convenience Functions Tests
# ============================================================================

describe "Convenience Functions":
    context "parse_json":
        it "should parse JSON text":
            val result = parse_json("{\"key\": \"value\"}")
            expect result.ok.? to_be_true

            val json = result.unwrap()
            expect json.get("key").unwrap().as_string().unwrap() to_equal "value"

    context "to_json_string":
        it "should serialize to string":
            val json = JsonValue.Object({
                "key": JsonValue.String("value")
            })
            val text = to_json_string(json)
            expect text to_contain "key"
            expect text to_contain "value"

    context "to_json_pretty":
        it "should serialize to pretty string":
            val json = JsonValue.Object({
                "key": JsonValue.String("value")
            })
            val text = to_json_pretty(json)
            expect text to_contain "key"
            expect text to_contain "value"

    context "object":
        it "should create object from pairs":
            val json = object([
                ("name", JsonValue.String("Alice")),
                ("age", JsonValue.Number(30.0))
            ])

            val obj = json.as_object().unwrap()
            expect obj["name"].as_string().unwrap() to_equal "Alice"
            expect obj["age"].as_number().unwrap() to_equal 30.0

    context "array":
        it "should create array from values":
            val json = array([
                JsonValue.Number(1.0),
                JsonValue.Number(2.0),
                JsonValue.Number(3.0)
            ])

            val arr = json.as_array().unwrap()
            expect arr.len() to_equal 3
            expect arr[1].as_number().unwrap() to_equal 2.0

# ============================================================================
# MsgPack Tests
# ============================================================================

describe "MsgPack":
    context "encode":
        it "should encode null":
            val json = JsonValue.Null
            val bytes = MsgPack.encode(json)
            expect bytes.len() > 0 to_be_true

        it "should encode boolean":
            val json = JsonValue.Bool(true)
            val bytes = MsgPack.encode(json)
            expect bytes.len() > 0 to_be_true

        it "should encode number":
            val json = JsonValue.Number(42.0)
            val bytes = MsgPack.encode(json)
            expect bytes.len() > 0 to_be_true

        it "should encode string":
            val json = JsonValue.String("hello")
            val bytes = MsgPack.encode(json)
            expect bytes.len() > 0 to_be_true

        it "should encode array":
            val json = JsonValue.Array([
                JsonValue.Number(1.0),
                JsonValue.Number(2.0)
            ])
            val bytes = MsgPack.encode(json)
            expect bytes.len() > 0 to_be_true

        it "should encode object":
            val json = JsonValue.Object({
                "key": JsonValue.String("value")
            })
            val bytes = MsgPack.encode(json)
            expect bytes.len() > 0 to_be_true

    context "decode":
        it "should decode encoded data":
            val original = JsonValue.Number(42.0)
            val bytes = MsgPack.encode(original)
            val decoded = MsgPack.decode(bytes)

            expect decoded.? to_be_true
            expect decoded.unwrap().as_number().unwrap() to_equal 42.0

    context "round-trip":
        it "should round-trip null":
            val original = JsonValue.Null
            val bytes = MsgPack.encode(original)
            val decoded = MsgPack.decode(bytes).unwrap()
            expect decoded.is_null() to_be_true

        it "should round-trip boolean":
            val original = JsonValue.Bool(true)
            val bytes = MsgPack.encode(original)
            val decoded = MsgPack.decode(bytes).unwrap()
            expect decoded.as_bool().unwrap() to_be_true

        it "should round-trip string":
            val original = JsonValue.String("hello world")
            val bytes = MsgPack.encode(original)
            val decoded = MsgPack.decode(bytes).unwrap()
            expect decoded.as_string().unwrap() to_equal "hello world"

        it "should round-trip array":
            val original = JsonValue.Array([
                JsonValue.Number(1.0),
                JsonValue.Number(2.0),
                JsonValue.Number(3.0)
            ])
            val bytes = MsgPack.encode(original)
            val decoded = MsgPack.decode(bytes).unwrap()
            val arr = decoded.as_array().unwrap()
            expect arr.len() to_equal 3

        it "should round-trip object":
            val original = JsonValue.Object({
                "name": JsonValue.String("Alice"),
                "age": JsonValue.Number(30.0)
            })
            val bytes = MsgPack.encode(original)
            val decoded = MsgPack.decode(bytes).unwrap()
            val obj = decoded.as_object().unwrap()
            expect obj["name"].as_string().unwrap() to_equal "Alice"

# ============================================================================
# Integration Tests
# ============================================================================

describe "Integration":
    context "JSON round-trip":
        it "should round-trip complex object":
            val original = JsonValue.Object({
                "user": JsonValue.Object({
                    "name": JsonValue.String("Alice"),
                    "age": JsonValue.Number(30.0),
                    "active": JsonValue.Bool(true)
                }),
                "tags": JsonValue.Array([
                    JsonValue.String("admin"),
                    JsonValue.String("user")
                ])
            })

            val text = original.serialize()
            val parsed = JsonValue.parse(text).unwrap()

            val user = parsed.get("user").unwrap()
            expect user.get("name").unwrap().as_string().unwrap() to_equal "Alice"
            expect user.get("age").unwrap().as_number().unwrap() to_equal 30.0
            expect user.get("active").unwrap().as_bool().unwrap() to_be_true

            val tags = parsed.get("tags").unwrap().as_array().unwrap()
            expect tags.len() to_equal 2

    context "Path query on complex data":
        it "should query deeply nested data":
            val json = JsonValue.Object({
                "data": JsonValue.Object({
                    "users": JsonValue.Array([
                        JsonValue.Object({
                            "profile": JsonValue.Object({
                                "name": JsonValue.String("Alice")
                            })
                        })
                    ])
                })
            })

            val path = JsonPath.new("data.users.0.profile.name")
            val result = path.query(json)
            expect result.? to_be_true
            expect result.unwrap().as_string().unwrap() to_equal "Alice"

# ============================================================================
# Use Cases
# ============================================================================

describe "Use Cases":
    context "API response parsing":
        it "should parse API response":
            val response = "{\"status\": \"ok\", \"data\": {\"id\": 123}}"
            val json = JsonValue.parse(response).unwrap()

            val status = json.get("status").unwrap().as_string().unwrap()
            expect status to_equal "ok"

            val data = json.get("data").unwrap()
            val id = data.get("id").unwrap().as_number().unwrap()
            expect id to_equal 123.0

    context "Config file":
        it "should build config object":
            val config = JsonBuilder.new()
                .put_string("host", "localhost")
                .put_number("port", 8080.0)
                .put_bool("debug", true)
                .build()

            val text = config.pretty()
            expect text to_contain "host"
            expect text to_contain "localhost"
            expect text to_contain "port"

    context "Data transformation":
        it "should transform data structure":
            val input = JsonValue.parse("[1, 2, 3]").unwrap()
            val arr = input.as_array().unwrap()

            var builder = JsonArray.new()
            for val in arr:
                val num = val.as_number().unwrap()
                builder = builder.push_number(num * 2.0)

            val output = builder.build()
            val result = output.as_array().unwrap()
            expect result[0].as_number().unwrap() to_equal 2.0
            expect result[1].as_number().unwrap() to_equal 4.0
            expect result[2].as_number().unwrap() to_equal 6.0

# ============================================================================
# Summary
# ============================================================================

# Total tests: 60+
# - JsonValue: 26 tests (parse, serialize, accessors, types)
# - JsonPath: 5 tests (query simple, nested, array, mixed, invalid)
# - JsonBuilder: 5 tests (construction, convenience methods)
# - JsonArray: 5 tests (construction, convenience methods)
# - ToJson/FromJson: 2 tests (trait pattern demonstration)
# - Convenience: 4 tests (parse, serialize, object, array)
# - MsgPack: 11 tests (encode, decode, round-trip all types)
# - Integration: 2 tests (complex round-trip, path query)
# - Use Cases: 3 tests (API, config, transformation)
#
# Coverage:
# - JSON parsing (all types: null, bool, number, string, array, object)
# - JSON serialization (compact and pretty)
# - Type extraction (as_* methods)
# - Object/array access (get, get_index)
# - Path queries (simple, nested, array index)
# - Builder patterns (JsonBuilder, JsonArray)
# - MessagePack encoding/decoding
# - Round-trip correctness
# - Real-world use cases
