# @skip - GC test syntax issues
# Garbage Collector Test Suite
#
# Comprehensive tests for mark-and-sweep GC (std.gc).
# Tests allocation, marking, sweeping, and edge cases.

use std.gc.*
use std.runtime_value.*
use std.test.sspec.*

# ============================================================================
# GcObjectHeader Tests
# ============================================================================

describe "GcObjectHeader":
    context "construction":
        it "should create header with size and type":
            val header = GcObjectHeader.new(size: 128, type_id: 1)
            expect header.size to_equal 128
            expect header.type_id to_equal 1
            expect header.generation to_equal 0

        it "should initialize as white":
            val header = GcObjectHeader.new(size: 64, type_id: 1)
            expect header.color to_equal GcColor.White
            expect header.marked to_be_false

    context "marking":
        it "should mark object":
            var header = GcObjectHeader.new(size: 64, type_id: 1)
            expect header.is_marked() to_be_false

            header.mark()
            expect header.is_marked() to_be_true
            expect header.color to_equal GcColor.Gray

        it "should unmark object":
            var header = GcObjectHeader.new(size: 64, type_id: 1)
            header.mark()
            expect header.is_marked() to_be_true

            header.unmark()
            expect header.is_marked() to_be_false
            expect header.color to_equal GcColor.White

        it "should make object black":
            var header = GcObjectHeader.new(size: 64, type_id: 1)
            header.make_black()
            expect header.color to_equal GcColor.Black

    context "generation":
        it "should start in young generation":
            val header = GcObjectHeader.new(size: 64, type_id: 1)
            expect header.is_young() to_be_true
            expect header.generation to_equal 0

        it "should promote to old generation":
            var header = GcObjectHeader.new(size: 64, type_id: 1)
            header.promote()
            expect header.is_young() to_be_false
            expect header.generation to_equal 1

# ============================================================================
# GcConfig Tests
# ============================================================================

describe "GcConfig":
    context "default config":
        it "should create default configuration":
            val config = GcConfig.default()
            expect config.young_size to_equal (1024 * 1024)
            expect config.old_size to_equal (4 * 1024 * 1024)

        it "should have reasonable thresholds":
            val config = GcConfig.default()
            expect (config.gc_threshold > 0) to_equal true
            expect (config.max_heap_size > config.min_heap_size) to_equal true

    context "custom config":
        it "should create config with specific heap size":
            val config = GcConfig.with_heap_size(10 * 1024 * 1024)
            expect config.young_size to_equal (2 * 1024 * 1024)  # 20%
            expect config.old_size to_equal (8 * 1024 * 1024)    # 80%

# ============================================================================
# GcStats Tests
# ============================================================================

describe "GcStats":
    context "initialization":
        it "should start with zero stats":
            val stats = GcStats.new()
            expect stats.collections to_equal 0
            expect stats.objects_allocated to_equal 0
            expect stats.objects_freed to_equal 0

    context "calculations":
        it "should calculate average pause time":
            var stats = GcStats.new()
            stats.collections = 5
            stats.total_pause_time = 1000  # 1ms total
            expect stats.avg_pause_time() to_equal 200  # 200μs average

        it "should handle zero collections":
            val stats = GcStats.new()
            expect stats.avg_pause_time() to_equal 0

        it "should calculate survival rate":
            var stats = GcStats.new()
            stats.objects_allocated = 100
            stats.objects_freed = 30
            val rate = stats.survival_rate()
            expect rate to_equal 0.7  # 70% survival

# ============================================================================
# GcHeap Basic Tests
# ============================================================================

describe "GcHeap - Basic":
    context "construction":
        it "should create heap with default config":
            val gc = GcHeap.new()
            expect gc.allocated_bytes() to_equal 0

        it "should create heap with custom config":
            val config = GcConfig.with_heap_size(1024 * 1024)
            val gc = GcHeap.with_config(config)
            expect gc.allocated_bytes() to_equal 0

    context "allocation":
        it "should allocate object":
            val gc = GcHeap.new()
            val ptr = gc.allocate_i64(64)
            expect ptr.? to_be_true
            expect gc.stats.objects_allocated to_equal 1

        it "should track allocated bytes":
            val gc = GcHeap.new()
            gc.allocate_i64(100)
            expect gc.allocated_bytes() to_equal 100

        it "should allocate multiple objects":
            val gc = GcHeap.new()
            for i in 0..10:
                val ptr = gc.allocate_i64(64)
                expect ptr.? to_be_true
            expect gc.stats.objects_allocated to_equal 10

    context "collection triggering":
        it "should trigger GC when threshold reached":
            val config = GcConfig.default()
            config.gc_threshold = 1000  # Low threshold for testing
            val gc = GcHeap.with_config(config)

            # Allocate until GC triggers
            for i in 0..20:
                gc.allocate_i64(100)

            # GC should have run
            expect (gc.stats.collections > 0) to_equal true

        it "should check if collection needed":
            val gc = GcHeap.new()
            expect gc.should_collect() to_be_false

            # Allocate a lot
            for i in 0..100:
                gc.allocate_i64(10000)

            expect gc.should_collect() to_be_true

# ============================================================================
# GcHeap Root Management Tests
# ============================================================================

describe "GcHeap - Roots":
    context "root operations":
        it "should add root":
            val gc = GcHeap.new()
            val ptr = gc.allocate_i64(64)
            if ptr.?:
                gc.add_root(ptr.unwrap())
                # Root added (no direct way to verify, but shouldn't crash)

        it "should remove root":
            val gc = GcHeap.new()
            val ptr = gc.allocate_i64(64)
            if ptr.?:
                gc.add_root(ptr.unwrap())
                gc.remove_root(ptr.unwrap())

        it "should clear all roots":
            val gc = GcHeap.new()
            val ptr1 = gc.allocate_i64(64)
            val ptr2 = gc.allocate_i64(64)
            if ptr1.?:
                gc.add_root(ptr1.unwrap())
            if ptr2.?:
                gc.add_root(ptr2.unwrap())
            gc.clear_roots()

# ============================================================================
# GcHeap Collection Tests
# ============================================================================

describe "GcHeap - Collection":
    context "basic collection":
        it "should run collection":
            val gc = GcHeap.new()

            # Allocate some objects
            val ptr1 = gc.allocate_i64(100)
            val ptr2 = gc.allocate_i64(200)

            # Run GC
            gc.collect()

            # Stats updated
            expect gc.stats.collections to_equal 1

        it "should prevent recursive collection":
            val gc = GcHeap.new()
            gc.collect()  # First collection
            expect gc.is_collecting() to_be_false

        it "should update pause time stats":
            val gc = GcHeap.new()
            gc.allocate_i64(100)
            gc.collect()

            val stats = gc.stats
            expect (stats.last_pause_time > 0) to_equal true
            expect stats.total_pause_time to_equal stats.last_pause_time

    context "garbage reclamation":
        it "should free unreachable objects":
            val gc = GcHeap.new()

            # Allocate object without adding to roots
            gc.allocate_i64(100)
            val allocated_before = gc.allocated_bytes()

            # Collect - object should be freed
            gc.collect()

            # Stats show objects freed
            expect (gc.stats.objects_freed > 0) to_equal true

        it "should keep reachable objects":
            val gc = GcHeap.new()

            # Allocate and add to roots
            val ptr = gc.allocate_i64(100)
            if ptr.?:
                gc.add_root(ptr.unwrap())

            val allocated_before = gc.allocated_bytes()

            # Collect - object should survive
            gc.collect()

            # Object still allocated
            expect gc.allocated_bytes() to_equal allocated_before

    context "young generation collection":
        it "should collect young generation":
            val gc = GcHeap.new()
            gc.allocate_i64(100)

            gc.collect_young()

            expect (gc.stats.collections > 0) to_equal true

# ============================================================================
# GcHeap Mark Phase Tests
# ============================================================================

describe "GcHeap - Mark Phase":
    context "marking from roots":
        it "should mark reachable objects":
            val gc = GcHeap.new()

            # Allocate and root
            val ptr = gc.allocate_i64(100)
            if ptr.?:
                gc.add_root(ptr.unwrap())

            # Run mark phase
            gc.mark_phase()

            # Object should be marked (tested indirectly via collection)

    context "transitive closure":
        it "should mark object graph":
            val gc = GcHeap.new()

            # Create object graph: root -> obj1 -> obj2
            val obj1 = gc.allocate_i64(100)
            val obj2 = gc.allocate_i64(100)

            # Root obj1
            if obj1.?:
                gc.add_root(obj1.unwrap())

            # Mark phase should reach obj1
            gc.mark_phase()

            # Both objects marked (tested via sweep not freeing them)

# ============================================================================
# GcHeap Sweep Phase Tests
# ============================================================================

describe "GcHeap - Sweep Phase":
    context "sweeping unmarked objects":
        it "should free unmarked objects":
            val gc = GcHeap.new()

            # Allocate without rooting
            gc.allocate_i64(100)

            val freed_before = gc.stats.objects_freed

            # Mark phase (nothing marked)
            gc.mark_phase()

            # Sweep phase
            gc.sweep_phase()

            # Object should be freed
            expect (gc.stats.objects_freed > freed_before) to_equal true

        it "should keep marked objects":
            val gc = GcHeap.new()

            # Allocate and root
            val ptr = gc.allocate_i64(100)
            if ptr.?:
                gc.add_root(ptr.unwrap())

            val freed_before = gc.stats.objects_freed

            # Mark and sweep
            gc.mark_phase()
            gc.sweep_phase()

            # No objects freed
            expect gc.stats.objects_freed to_equal freed_before

# ============================================================================
# GcPtr Smart Pointer Tests
# ============================================================================

describe "GcPtr":
    context "construction":
        it "should create smart pointer":
            val gc = GcHeap.new()
            val ptr = gc.allocate_i64(64)
            if ptr.?:
                val gc_ptr = GcPtr<i64>.new(gc, ptr.unwrap())
                expect gc_ptr.get().? to_be_true

    context "root management":
        it "should automatically register as root":
            val gc = GcHeap.new()
            val ptr = gc.allocate_i64(64)
            if ptr.?:
                var gc_ptr = GcPtr<i64>.new(gc, ptr.unwrap())
                # Automatically registered (tested via GC not freeing it)

        it "should unregister on drop":
            val gc = GcHeap.new()
            val ptr = gc.allocate_i64(64)
            if ptr.?:
                var gc_ptr = GcPtr<i64>.new(gc, ptr.unwrap())
                gc_ptr.drop()
                # Unregistered

    context "write barrier":
        it "should update pointer with write barrier":
            val gc = GcHeap.new()
            val ptr1 = gc.allocate_i64(64)
            val ptr2 = gc.allocate_i64(64)
            if ptr1.? and ptr2.?:
                var gc_ptr = GcPtr<i64>.new(gc, ptr1.unwrap())
                gc_ptr.set(ptr2.unwrap())
                expect gc_ptr.get().? to_be_true

# ============================================================================
# Integration Tests
# ============================================================================

describe "GC Integration":
    context "allocation and collection cycle":
        it "should handle multiple collection cycles":
            val gc = GcHeap.new()

            for cycle in 0..5:
                # Allocate objects
                for i in 0..10:
                    gc.allocate_i64(100)

                # Collect
                gc.collect()

            expect gc.stats.collections to_equal 5

        it "should maintain correct stats":
            val gc = GcHeap.new()

            # Allocate 10 objects
            for i in 0..10:
                gc.allocate_i64(100)

            expect gc.stats.objects_allocated to_equal 10
            expect gc.stats.bytes_allocated to_equal 1000

            # Collect (all garbage)
            gc.collect()

            expect gc.stats.objects_freed to_equal 10
            expect gc.stats.bytes_freed to_equal 1000

    context "survival rate":
        it "should calculate survival rate correctly":
            val gc = GcHeap.new()

            # Allocate 10 objects, root 5
            var rooted: [[u8]] = []
            for i in 0..10:
                val ptr = gc.allocate_i64(100)
                if ptr.? and i < 5:
                    gc.add_root(ptr.unwrap())
                    rooted = rooted.push(ptr.unwrap())

            # Collect
            gc.collect()

            # 5 survived, 5 died
            val rate = gc.stats.survival_rate()
            expect rate to_equal 0.5  # 50%

    context "stress test":
        it "should handle many allocations":
            val gc = GcHeap.new()

            for i in 0..100:
                gc.allocate_i64(64)

            # GC should have run automatically
            expect (gc.stats.collections > 0) to_equal true

        it "should handle alternating alloc/collect":
            val gc = GcHeap.new()

            for i in 0..20:
                gc.allocate_i64(100)
                if i % 5 == 0:
                    gc.collect()

            expect (gc.stats.collections > 0) to_equal true

# ============================================================================
# Use Cases
# ============================================================================

describe "GC Use Cases":
    context "temporary objects":
        it "should clean up temporary allocations":
            val gc = GcHeap.new()

            # Allocate temporary objects
            for i in 0..50:
                gc.allocate_i64(100)

            # None are rooted - all garbage
            gc.collect()

            # All should be freed
            expect gc.stats.objects_freed to_equal 50

    context "long-lived objects":
        it "should keep rooted objects across collections":
            val gc = GcHeap.new()

            # Allocate and root long-lived object
            val long_lived = gc.allocate_i64(1000)
            if long_lived.?:
                gc.add_root(long_lived.unwrap())

            # Allocate many temporary objects
            for i in 0..100:
                gc.allocate_i64(100)

            # Collect multiple times
            for i in 0..5:
                gc.collect()

            # Long-lived object survives
            expect (gc.allocated_bytes() > 0) to_equal true

# ============================================================================
# NEW BRANCH COVERAGE TESTS - Week 2
# ============================================================================

# ============================================================================
# Tri-Color Marking Edge Cases
# ============================================================================

describe "Tri-Color Marking Transitions":
    context "White to Gray transition":
        it "should mark white object as gray when discovered":
            var header = GcObjectHeader.new(size: 128, type_id: 1)
            expect header.color to_equal GcColor.White

            header.mark()
            expect header.color to_equal GcColor.Gray
            expect header.marked to_equal true

        it "should add newly marked object to gray stack":
            val gc = GcHeap.new()
            val obj = gc.allocate_i64(64)

            # Initially white, allocation adds to gray stack for marking
            expect obj.? to_equal true

    context "Gray to Black transition":
        it "should transition gray to black after scanning children":
            var header = GcObjectHeader.new(size: 128, type_id: 1)
            header.mark()  # White → Gray
            expect header.color to_equal GcColor.Gray

            header.make_black()  # Gray → Black
            expect header.color to_equal GcColor.Black

        it "should not revisit black objects during marking":
            var header = GcObjectHeader.new(size: 128, type_id: 1)
            header.make_black()
            val initial_color = header.color

            # Attempt to mark again
            header.mark()
            # Should remain black (already fully scanned)
            expect header.is_marked() to_equal true

    context "Black object invariant":
        it "should maintain invariant that black objects point only to gray or black":
            # This is a logical test - in practice enforced by write barriers
            var parent = GcObjectHeader.new(size: 128, type_id: 1)
            var child = GcObjectHeader.new(size: 64, type_id: 1)

            parent.make_black()
            child.mark()  # At least gray

            expect parent.color to_equal GcColor.Black
            expect (child.color == GcColor.Gray or child.color == GcColor.Black) to_equal true

    context "Color reset between cycles":
        it "should reset all colors to white before new cycle":
            var header = GcObjectHeader.new(size: 128, type_id: 1)
            header.mark()
            header.make_black()
            expect header.color to_equal GcColor.Black

            header.unmark()  # New cycle
            expect header.color to_equal GcColor.White
            expect header.marked to_equal false

# ============================================================================
# Generational Collection Edge Cases
# ============================================================================

describe "Generational Collection":
    context "Generation promotion":
        it "should promote young object that survives collection":
            var header = GcObjectHeader.new(size: 128, type_id: 1)
            expect header.is_young() to_equal true
            expect header.generation to_equal 0

            header.promote()
            expect header.generation to_equal 1
            expect header.is_young() to_equal false

        it "should promote multiple times for tenured objects":
            var header = GcObjectHeader.new(size: 128, type_id: 1)

            for i in 0..5:
                header.promote()

            expect header.generation to_equal 5
            expect header.is_young() to_equal false

    context "Young generation collection":
        it "should collect young generation more frequently":
            val gc = GcHeap.with_config(
                GcConfig(
                    young_size: 1024,
                    old_size: 4096,
                    growth_factor: 2.0,
                    min_heap_size: 1024,
                    max_heap_size: 1024000,
                    gc_threshold: 512,
                    incremental: false,
                    concurrent: false
                )
            )

            val initial_young_collections = gc.stats.young_collections

            # Allocate many small objects to trigger young GC
            for i in 0..20:
                val obj = gc.allocate_i64(32)

            expect (gc.stats.young_collections > initial_young_collections) to_equal true

        it "should promote survivors from young to old":
            val gc = GcHeap.new()

            val obj = gc.allocate_i64(64)
            gc.add_root(obj.unwrap())

            # Multiple collections should promote to old generation
            for i in 0..3:
                gc.collect_young()

            expect gc.stats.young_collections to_equal 3

    context "Full heap collection":
        it "should collect both young and old generations":
            val gc = GcHeap.new()

            # Allocate in young
            val young = gc.allocate_i64(64)

            # Force promotion to old
            gc.add_root(young.unwrap())
            for i in 0..3:
                gc.collect_young()

            val initial_full = gc.stats.full_collections
            gc.collect()  # Full collection
            expect gc.stats.full_collections to_equal (initial_full + 1)

    context "Write barriers for generational GC":
        it "should track old-to-young pointers":
            # When old object gets pointer to young object,
            # must ensure young object isn't collected prematurely
            val gc = GcHeap.new()

            val old_obj = gc.allocate_i64(128)
            gc.add_root(old_obj.unwrap())

            # Promote to old
            for i in 0..3:
                gc.collect_young()

            val young_obj = gc.allocate_i64(64)
            # Write barrier should record this pointer
            # (in real implementation)

            gc.collect_young()
            # Young object should survive because old object references it

# ============================================================================
# Mark Phase Edge Cases
# ============================================================================

describe "Mark Phase Edge Cases":
    context "Empty roots":
        it "should handle collection with no roots":
            val gc = GcHeap.new()

            # Allocate without adding roots
            val obj = gc.allocate_i64(64)

            gc.collect()
            # Should collect everything
            expect gc.allocated_bytes() to_equal 0

    context "Single root":
        it "should preserve single rooted object":
            val gc = GcHeap.new()

            val obj = gc.allocate_i64(64)
            gc.add_root(obj.unwrap())

            gc.collect()
            expect (gc.allocated_bytes() > 0) to_equal true

    context "Deep object graph":
        it "should mark deeply nested objects":
            val gc = GcHeap.new()

            # Create chain: root → obj1 → obj2 → obj3 (depth 3)
            val obj3 = gc.allocate_i64(64)
            val obj2 = gc.allocate_i64(64)
            val obj1 = gc.allocate_i64(64)

            gc.add_root(obj1.unwrap())
            # In real implementation, would set obj1.next = obj2, obj2.next = obj3

            gc.collect()
            # All reachable objects should survive

    context "Cyclic references":
        it "should handle simple cycles (A → B → A)":
            val gc = GcHeap.new()

            val objA = gc.allocate_i64(64)
            val objB = gc.allocate_i64(64)
            # A.next = B, B.next = A (cycle)

            gc.add_root(objA.unwrap())

            gc.collect()
            # Both should survive (reachable from root)

        it "should collect unreachable cycles":
            val gc = GcHeap.new()

            # Create cycle without roots
            val objA = gc.allocate_i64(64)
            val objB = gc.allocate_i64(64)
            # A.next = B, B.next = A

            val initial_allocated = gc.allocated_bytes()
            gc.collect()
            # Cycle should be collected (not reachable)
            expect gc.allocated_bytes() to_equal 0

        it "should handle complex cycles with multiple objects":
            val gc = GcHeap.new()

            # Create cycle: root → A → B → C → A
            val objA = gc.allocate_i64(64)
            val objB = gc.allocate_i64(64)
            val objC = gc.allocate_i64(64)

            gc.add_root(objA.unwrap())
            # A.next = B, B.next = C, C.next = A

            gc.collect()
            # All should survive (reachable from root)

# ============================================================================
# Sweep Phase Edge Cases
# ============================================================================

describe "Sweep Phase Edge Cases":
    context "Empty heap":
        it "should handle sweep on empty heap":
            val gc = GcHeap.new()

            gc.collect()
            expect gc.allocated_bytes() to_equal 0
            expect gc.stats.objects_freed to_equal 0

    context "All objects marked":
        it "should free no objects when all are reachable":
            val gc = GcHeap.new()

            val obj1 = gc.allocate_i64(64)
            val obj2 = gc.allocate_i64(64)
            val obj3 = gc.allocate_i64(64)

            gc.add_root(obj1.unwrap())
            gc.add_root(obj2.unwrap())
            gc.add_root(obj3.unwrap())

            val initial_freed = gc.stats.objects_freed
            gc.collect()

            expect gc.stats.objects_freed to_equal initial_freed

    context "All objects unmarked":
        it "should free all objects when none are reachable":
            val gc = GcHeap.new()

            val obj1 = gc.allocate_i64(64)
            val obj2 = gc.allocate_i64(64)
            val obj3 = gc.allocate_i64(64)
            # No roots added

            gc.collect()

            expect gc.allocated_bytes() to_equal 0
            expect gc.stats.objects_freed to_equal 3

    context "Mixed marked and unmarked":
        it "should free only unmarked objects":
            val gc = GcHeap.new()

            val obj1 = gc.allocate_i64(64)  # Will be rooted
            val obj2 = gc.allocate_i64(64)  # Garbage
            val obj3 = gc.allocate_i64(64)  # Will be rooted

            gc.add_root(obj1.unwrap())
            gc.add_root(obj3.unwrap())

            val initial_freed = gc.stats.objects_freed
            gc.collect()

            # Should free obj2 only
            expect gc.stats.objects_freed to_equal (initial_freed + 1)

    context "Sweep ordering":
        it "should handle objects in any order in linked list":
            val gc = GcHeap.new()

            # Allocate in order: A, B, C (list order: C → B → A)
            val objA = gc.allocate_i64(64)
            val objB = gc.allocate_i64(64)
            val objC = gc.allocate_i64(64)

            gc.add_root(objB.unwrap())  # Keep middle one

            gc.collect()
            # Should correctly sweep regardless of list order

# ============================================================================
# Finalization Edge Cases
# ============================================================================

describe "Finalization":
    context "Finalizer execution":
        it "should mark objects with finalizers":
            var header = GcObjectHeader.new(size: 128, type_id: 1)
            header.finalize = true

            expect header.finalize to_equal true

        it "should run finalizers before reclaiming memory":
            val gc = GcHeap.new()

            val obj = gc.allocate_i64(64)
            # Set finalizer (in real implementation)

            gc.collect()
            # Finalizer should have run before object freed

    context "Finalizer resurrection":
        it "should handle object resurrection in finalizer":
            # When finalizer makes object reachable again
            val gc = GcHeap.new()

            val obj = gc.allocate_i64(64)
            # Finalizer adds obj back to roots

            gc.collect()
            # Object should survive if resurrected

    context "Finalizer chains":
        it "should handle finalizer that references other finalizable objects":
            val gc = GcHeap.new()

            val obj1 = gc.allocate_i64(64)
            val obj2 = gc.allocate_i64(64)
            # obj1 finalizer references obj2

            gc.collect()
            # Should handle dependency correctly

    context "Finalizer ordering":
        it "should run finalizers in dependency order":
            # If A depends on B, B's finalizer should run after A's
            val gc = GcHeap.new()

            val objA = gc.allocate_i64(64)
            val objB = gc.allocate_i64(64)
            # A references B

            gc.collect()
            # Finalizer ordering should respect dependencies

# ============================================================================
# Memory Pressure and Threshold Edge Cases
# ============================================================================

describe "Memory Pressure":
    context "Collection triggering":
        it "should trigger GC when threshold exceeded":
            val gc = GcHeap.with_config(
                GcConfig(
                    young_size: 1024,
                    old_size: 4096,
                    growth_factor: 2.0,
                    min_heap_size: 1024,
                    max_heap_size: 1024000,
                    gc_threshold: 256,  # Low threshold
                    incremental: false,
                    concurrent: false
                )
            )

            val initial_collections = gc.stats.collections

            # Allocate beyond threshold
            for i in 0..20:
                val obj = gc.allocate_i64(32)

            # Should have triggered at least one GC
            expect (gc.stats.collections > initial_collections) to_equal true

        it "should not trigger GC when below threshold":
            val gc = GcHeap.with_config(
                GcConfig(
                    young_size: 1024,
                    old_size: 4096,
                    growth_factor: 2.0,
                    min_heap_size: 1024,
                    max_heap_size: 1024000,
                    gc_threshold: 10000,  # High threshold
                    incremental: false,
                    concurrent: false
                )
            )

            val initial_collections = gc.stats.collections

            # Small allocation
            val obj = gc.allocate_i64(64)

            # Should not trigger GC
            expect gc.stats.collections to_equal initial_collections

    context "Heap growth":
        it "should grow heap when needed":
            val gc = GcHeap.with_config(
                GcConfig(
                    young_size: 512,
                    old_size: 2048,
                    growth_factor: 2.0,
                    min_heap_size: 512,
                    max_heap_size: 1024000,
                    gc_threshold: 256,
                    incremental: false,
                    concurrent: false
                )
            )

            # Allocate many objects, all rooted (can't be collected)
            for i in 0..10:
                val obj = gc.allocate_i64(64)
                gc.add_root(obj.unwrap())

            # Heap should have grown to accommodate

        it "should respect maximum heap size":
            val gc = GcHeap.with_config(
                GcConfig(
                    young_size: 512,
                    old_size: 2048,
                    growth_factor: 2.0,
                    min_heap_size: 512,
                    max_heap_size: 4096,  # Low max
                    gc_threshold: 256,
                    incremental: false,
                    concurrent: false
                )
            )

            # Try to allocate beyond max
            var success_count = 0
            for i in 0..100:
                val obj = gc.allocate_i64(64)
                if obj.?:
                    gc.add_root(obj.unwrap())
                    success_count = success_count + 1

            # Should eventually fail due to max heap size
            expect success_count to_be_less_than 100

    context "OOM handling":
        it "should return None when out of memory":
            val gc = GcHeap.with_config(
                GcConfig(
                    young_size: 256,
                    old_size: 512,
                    growth_factor: 1.0,  # No growth
                    min_heap_size: 256,
                    max_heap_size: 768,
                    gc_threshold: 128,
                    incremental: false,
                    concurrent: false
                )
            )

            # Fill heap
            for i in 0..20:
                val obj = gc.allocate_i64(64)
                if obj.?:
                    gc.add_root(obj.unwrap())

            # Next allocation should fail
            val overflow = gc.allocate_i64(1000)
            expect overflow.? to_equal false

        it "should handle repeated OOM gracefully":
            val gc = GcHeap.with_config(
                GcConfig(
                    young_size: 128,
                    old_size: 256,
                    growth_factor: 1.0,
                    min_heap_size: 128,
                    max_heap_size: 384,
                    gc_threshold: 64,
                    incremental: false,
                    concurrent: false
                )
            )

            # Repeatedly try to allocate when full
            for i in 0..10:
                val obj = gc.allocate_i64(500)
                # Should consistently return None

# ============================================================================
# Statistics and Metrics Edge Cases
# ============================================================================

describe "GC Statistics":
    context "Pause time tracking":
        it "should record pause time for each collection":
            val gc = GcHeap.new()

            val obj = gc.allocate_i64(64)

            val initial_pause = gc.stats.last_pause_time
            gc.collect()

            expect (gc.stats.last_pause_time > 0) to_equal true

        it "should accumulate total pause time":
            val gc = GcHeap.new()

            val initial_total = gc.stats.total_pause_time

            # Multiple collections
            for i in 0..3:
                val obj = gc.allocate_i64(64)
                gc.collect()

            expect (gc.stats.total_pause_time > initial_total) to_equal true

        it "should calculate average pause time correctly":
            val gc = GcHeap.new()

            gc.collect()
            gc.collect()
            gc.collect()

            val avg = gc.stats.avg_pause_time()
            expect (avg > 0) to_equal true

    context "Survival rate calculation":
        it "should calculate survival rate correctly":
            val gc = GcHeap.new()

            # Allocate 10 objects
            for i in 0..10:
                val obj = gc.allocate_i64(64)

            # Root 5 of them
            for i in 0..5:
                val obj = gc.allocate_i64(64)
                gc.add_root(obj.unwrap())

            gc.collect()

            val survival_rate = gc.stats.survival_rate()
            # Should be approximately 0.5 (5 survived out of 10)
            expect (survival_rate > 0.3 and survival_rate < 0.7) to_equal true

        it "should handle 100% survival rate":
            val gc = GcHeap.new()

            for i in 0..5:
                val obj = gc.allocate_i64(64)
                gc.add_root(obj.unwrap())

            gc.collect()

            val survival_rate = gc.stats.survival_rate()
            expect survival_rate to_equal 1.0

        it "should handle 0% survival rate":
            val gc = GcHeap.new()

            for i in 0..5:
                val obj = gc.allocate_i64(64)

            gc.collect()

            val survival_rate = gc.stats.survival_rate()
            expect survival_rate to_equal 0.0

    context "Collection counters":
        it "should track young generation collections separately":
            val gc = GcHeap.new()

            val initial_young = gc.stats.young_collections
            gc.collect_young()
            expect gc.stats.young_collections to_equal (initial_young + 1)

        it "should track full collections separately":
            val gc = GcHeap.new()

            val initial_full = gc.stats.full_collections
            gc.collect()
            expect gc.stats.full_collections to_equal (initial_full + 1)

        it "should increment total collection counter for any collection":
            val gc = GcHeap.new()

            val initial_total = gc.stats.collections

            gc.collect_young()
            gc.collect()

            expect gc.stats.collections to_equal (initial_total + 2)

# ============================================================================
# Object Size Variations
# ============================================================================

describe "Object Size Edge Cases":
    context "Small objects":
        it "should handle minimum size objects":
            val gc = GcHeap.new()

            val obj = gc.allocate_i64(1)
            expect obj.? to_equal true

        it "should handle zero-size objects":
            val gc = GcHeap.new()

            val obj = gc.allocate_i64(0)
            # Should either succeed or fail consistently
            expect (obj.? == true or obj.? == false) to_equal true

    context "Large objects":
        it "should handle large objects":
            val gc = GcHeap.new()

            val obj = gc.allocate_i64(100000)  # 100 KB
            expect obj.? to_equal true

        it "should handle very large objects":
            val gc = GcHeap.new()

            val obj = gc.allocate_i64(1000000)  # 1 MB
            # May succeed or fail depending on heap size
            expect (obj.? == true or obj.? == false) to_equal true

    context "Mixed sizes":
        it "should handle mix of small and large objects":
            val gc = GcHeap.new()

            val small1 = gc.allocate_i64(16)
            val large1 = gc.allocate_i64(10000)
            val medium1 = gc.allocate_i64(256)
            val small2 = gc.allocate_i64(32)

            expect small1.? to_equal true
            expect large1.? to_equal true
            expect medium1.? to_equal true
            expect small2.? to_equal true

# ============================================================================
# Incremental and Concurrent GC Edge Cases
# ============================================================================

describe "Incremental GC":
    context "Incremental marking":
        it "should support incremental marking mode":
            val gc = GcHeap.with_config(
                GcConfig(
                    young_size: 1024,
                    old_size: 4096,
                    growth_factor: 2.0,
                    min_heap_size: 1024,
                    max_heap_size: 1024000,
                    gc_threshold: 512,
                    incremental: true,  # Enable incremental
                    concurrent: false
                )
            )

            # Allocation should work with incremental GC
            val obj = gc.allocate_i64(64)
            expect obj.? to_equal true

        it "should pause and resume marking":
            val gc = GcHeap.with_config(
                GcConfig(
                    young_size: 1024,
                    old_size: 4096,
                    growth_factor: 2.0,
                    min_heap_size: 1024,
                    max_heap_size: 1024000,
                    gc_threshold: 512,
                    incremental: true,
                    concurrent: false
                )
            )

            # Start incremental marking
            gc.collect_incremental_step()

            # Allocate during marking
            val obj = gc.allocate_i64(64)

            # Complete marking
            gc.collect_incremental_finish()

    context "Write barriers":
        it "should install write barriers for incremental GC":
            val gc = GcHeap.with_config(
                GcConfig(
                    young_size: 1024,
                    old_size: 4096,
                    growth_factor: 2.0,
                    min_heap_size: 1024,
                    max_heap_size: 1024000,
                    gc_threshold: 512,
                    incremental: true,
                    concurrent: false
                )
            )

            # Write barriers should track pointer updates
            # during incremental marking

describe "Concurrent GC":
    context "Concurrent marking":
        it "should support concurrent marking mode":
            val gc = GcHeap.with_config(
                GcConfig(
                    young_size: 1024,
                    old_size: 4096,
                    growth_factor: 2.0,
                    min_heap_size: 1024,
                    max_heap_size: 1024000,
                    gc_threshold: 512,
                    incremental: false,
                    concurrent: true  # Enable concurrent
                )
            )

            # Should handle concurrent allocation during GC
            val obj = gc.allocate_i64(64)
            expect obj.? to_equal true

        it "should use atomic operations for concurrent access":
            val gc = GcHeap.new()

            # Check that collecting flag is atomic
            expect gc.collecting.load() to_equal false

            # Simulated: Start concurrent GC
            # gc.collecting.store(true)
            # Should prevent data races

# ============================================================================
# Stress Tests
# ============================================================================

describe "GC Stress Tests":
    context "Rapid allocation":
        it "should handle rapid allocation and collection cycles":
            val gc = GcHeap.new()

            for i in 0..100:
                val obj = gc.allocate_i64(64)
                if i % 10 == 0:
                    gc.collect()

            # Should complete without errors

        it "should handle alternating allocation and collection":
            val gc = GcHeap.new()

            for i in 0..50:
                val obj = gc.allocate_i64(128)
                gc.collect()
                val obj2 = gc.allocate_i64(64)

            # Should remain stable

    context "Memory thrashing":
        it "should handle repeated full heap allocations":
            val gc = GcHeap.with_config(
                GcConfig(
                    young_size: 512,
                    old_size: 2048,
                    growth_factor: 1.5,
                    min_heap_size: 512,
                    max_heap_size: 10240,
                    gc_threshold: 256,
                    incremental: false,
                    concurrent: false
                )
            )

            for cycle in 0..10:
                # Fill heap
                for i in 0..20:
                    val obj = gc.allocate_i64(64)

                # Clear all
                gc.collect()

            # Should handle repeated cycles

    context "Fragmentation":
        it "should handle fragmentation from mixed sizes":
            val gc = GcHeap.new()

            # Allocate pattern: large, small, large, small...
            for i in 0..20:
                if i % 2 == 0:
                    val large = gc.allocate_i64(1000)
                else:
                    val small = gc.allocate_i64(16)

            gc.collect()
            # Should handle fragmented heap

# ============================================================================
# Summary
# ============================================================================

# Total tests: 60+
# - GcObjectHeader: 7 tests
# - GcConfig: 4 tests
# - GcStats: 4 tests
# - GcHeap Basic: 9 tests
# - GcHeap Roots: 3 tests
# - GcHeap Collection: 8 tests
# - GcHeap Mark Phase: 2 tests
# - GcHeap Sweep Phase: 2 tests
# - GcPtr: 5 tests
# - Integration: 7 tests
# - Use Cases: 9 tests
#
# Coverage:
# - All GC phases (mark, sweep)
# - Object lifecycle (allocate, mark, free)
# - Root management
# - Statistics tracking
# - Smart pointers
# - Stress tests
