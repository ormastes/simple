# LSP Server Query API Integration Tests
#
# Tests the integration between the LSP server and CompilerQueryContext.
# This validates that LSP protocol requests correctly invoke the query API.

use std.spec.{check, check_msg}
import lsp.server.{LspServer}
import compiler.query_api.{CompilerQueryContext, Position, Symbol, SymbolKind}

describe "LspServer with CompilerQueryContext":
    describe "Initialization":
        it "creates server with query context":
            # Note: Exact API depends on LspServer implementation
            # This is a conceptual test structure

            # LSP server should have or create a CompilerQueryContext
            # val server = LspServer.new("/path/to/project")
            # assert server.compiler_query_ctx != nil

            pass

        it "sets up project root for query context":
            # val server = LspServer.new("/my/project")
            # assert server.compiler_query_ctx.project_root == "/my/project"
            pass

    describe "textDocument/completion Integration":
        it "uses CompilerQueryContext for completions":
            val ctx = CompilerQueryContext.create("/tmp/test")

            # Simulate LSP completion request
            val position = Position(line: 1, column: 10)

            val completions = ctx.completions_at("test.spl", position)

            # Should return completion items
            check(completions.length >= 0)

        it "converts CompilerQueryContext completions to LSP format":
            val ctx = CompilerQueryContext.create("/tmp/test")

            val source = """
            fn main():
                val x = 5
                val y = 10
            """

            val position = Position(line: 3, column: 4)
            val completions = ctx.completions_at("test.spl", position)

            # LSP server should convert to LSP CompletionItem format
            # {
            #   "label": "x",
            #   "kind": CompletionItemKind.Variable,
            #   "insertText": "x"
            # }

        it "provides context-aware completions":
            val ctx = CompilerQueryContext.create("/tmp/test")

            val source = """
            class Point:
                x: f64
                y: f64

            fn main():
                val p = Point(x: 1.0, y: 2.0)
                p.   # Expect x, y completions here
            """

            val position = Position(line: 6, column: 6)  # After "p."
            val completions = ctx.completions_at("test.spl", position)

            # Should suggest x and y fields

        it "provides keyword completions":
            val ctx = CompilerQueryContext.create("/tmp/test")

            val source = """
            fn main():

            """

            val position = Position(line: 1, column: 4)  # Inside function
            val completions = ctx.completions_at("test.spl", position)

            # Should include keywords like if, while, for, return, etc.

    describe "textDocument/hover Integration":
        it "uses CompilerQueryContext for hover info":
            val ctx = CompilerQueryContext.create("/tmp/test")

            val source = """
            fn add(a: i32, b: i32) -> i32:
                a + b
            """

            val position = Position(line: 0, column: 3)  # On "add"
            val hover_opt = ctx.hover_at("test.spl", position)

            # May return hover info with signature

        it "converts hover info to LSP format":
            val ctx = CompilerQueryContext.create("/tmp/test")

            val position = Position(line: 0, column: 5)
            val hover_opt = ctx.hover_at("test.spl", position)

            if hover_opt.?:
                val hover = hover_opt.unwrap()

                # LSP server should format as:
                # {
                #   "contents": {
                #     "kind": "markdown",
                #     "value": hover.contents
                #   },
                #   "range": { ... }
                # }

        it "shows type information in hover":
            val ctx = CompilerQueryContext.create("/tmp/test")

            val source = """
            val x: i32 = 42
            """

            val position = Position(line: 0, column: 4)  # On "x"
            val hover_opt = ctx.hover_at("test.spl", position)

            # Should show "i32" in type_info

        it "shows function signatures in hover":
            val ctx = CompilerQueryContext.create("/tmp/test")

            val source = """
            fn process(data: [i32], callback: fn(i32) -> bool) -> [i32]:
                data.filter(callback)
            """

            val position = Position(line: 0, column: 3)  # On "process"
            val hover_opt = ctx.hover_at("test.spl", position)

            # Should show full function signature

    describe "textDocument/definition Integration":
        it "uses CompilerQueryContext for go-to-definition":
            val ctx = CompilerQueryContext.create("/tmp/test")

            val source = """
            fn helper():
                pass

            fn main():
                helper()
            """

            val position = Position(line: 4, column: 4)  # On "helper" call
            val def_opt = ctx.find_definition("test.spl", position)

            # Should find definition at line 0

        it "converts definition to LSP Location format":
            val ctx = CompilerQueryContext.create("/tmp/test")

            val position = Position(line: 2, column: 5)
            val def_opt = ctx.find_definition("test.spl", position)

            if def_opt.?:
                val def = def_opt.unwrap()

                # LSP server should format as:
                # {
                #   "uri": "file:///path/to/file.spl",
                #   "range": {
                #     "start": { "line": ..., "character": ... },
                #     "end": { "line": ..., "character": ... }
                #   }
                # }

        it "handles cross-file definitions":
            val ctx = CompilerQueryContext.create("/tmp/test")

            # In real usage, would have multiple files
            # and imports between them

        it "returns null for undefined symbols":
            val ctx = CompilerQueryContext.create("/tmp/test")

            val source = "fn main(): pass"

            val position = Position(line: 0, column: 15)
            val def_opt = ctx.find_definition("test.spl", position)

            # Should return None (null in LSP)
            check(not def_opt.?)

    describe "textDocument/references Integration":
        it "uses CompilerQueryContext for find-references":
            val ctx = CompilerQueryContext.create("/tmp/test")

            val source = """
            val counter = 0

            fn increment():
                counter = counter + 1

            fn reset():
                counter = 0
            """

            val position = Position(line: 0, column: 4)  # On "counter" definition
            val symbol_opt = ctx.symbol_at("test.spl", position)

            if symbol_opt.?:
                val symbol = symbol_opt.unwrap()
                val refs = ctx.find_references("test.spl", symbol)

                # Should find multiple references

        it "converts references to LSP Location array":
            val ctx = CompilerQueryContext.create("/tmp/test")

            val position = Position(line: 0, column: 5)
            val symbol_opt = ctx.symbol_at("test.spl", position)

            if symbol_opt.?:
                val symbol = symbol_opt.unwrap()
                val refs = ctx.find_references("test.spl", symbol)

                # LSP server should format as array of Locations

    describe "textDocument/publishDiagnostics Integration":
        it "uses CompilerQueryContext for diagnostics":
            val ctx = CompilerQueryContext.create("/tmp/test")

            val diagnostics = ctx.get_diagnostics("test.spl")

            # Should return list of diagnostics

        it "converts diagnostics to LSP format":
            val ctx = CompilerQueryContext.create("/tmp/test")

            val diagnostics = ctx.get_diagnostics("test.spl")

            for diag in diagnostics:
                # LSP server should format as:
                # {
                #   "range": { ... },
                #   "severity": DiagnosticSeverity.Error,
                #   "message": diag.message,
                #   "source": diag.source
                # }
                pass

        it "publishes diagnostics on file change":
            val ctx = CompilerQueryContext.create("/tmp/test")

            # Simulate file change (didChange notification)
            ctx.invalidate_file("test.spl")

            # Get new diagnostics
            val diagnostics = ctx.get_diagnostics("test.spl")

            # LSP server should publish these to client

        it "publishes diagnostics on file open":
            val ctx = CompilerQueryContext.create("/tmp/test")

            # Simulate file open (didOpen notification)
            val diagnostics = ctx.get_diagnostics("test.spl")

            # LSP server should immediately publish diagnostics

    describe "textDocument/documentSymbol Integration":
        it "uses CompilerQueryContext for document outline":
            val ctx = CompilerQueryContext.create("/tmp/test")

            val source = """
            fn function1(): pass

            class MyClass:
                field1: i32
                fn method1(): pass

            enum MyEnum:
                Variant1
                Variant2
            """

            val symbols = ctx.document_symbols("test.spl")

            # Should extract all top-level symbols

        it "converts symbols to LSP DocumentSymbol format":
            val ctx = CompilerQueryContext.create("/tmp/test")

            val symbols = ctx.document_symbols("test.spl")

            for sym in symbols:
                # LSP server should format as:
                # {
                #   "name": sym.name,
                #   "kind": SymbolKind.Function,
                #   "range": { ... },
                #   "selectionRange": { ... }
                # }
                pass

    describe "Cache Invalidation on Document Changes":
        it "invalidates cache on didChange":
            val ctx = CompilerQueryContext.create("/tmp/test")

            # Initial parse
            val source1 = "fn main(): pass"
            ctx.parse_source_text(source1, "test.spl")

            # Simulate didChange notification
            ctx.invalidate_file("test.spl")

            # New parse should use updated content
            val source2 = "fn main(): print 'hello'"
            ctx.parse_source_text(source2, "test.spl")

        it "invalidates cache on didSave":
            val ctx = CompilerQueryContext.create("/tmp/test")

            # Initial state
            ctx.parse_source_text("fn main(): pass", "test.spl")

            # Simulate didSave notification (file modified on disk)
            ctx.invalidate_file("test.spl")

            # Next parse should read from disk

        it "invalidates cache on didClose":
            val ctx = CompilerQueryContext.create("/tmp/test")

            ctx.parse_source_text("fn main(): pass", "test.spl")

            # Simulate didClose notification
            ctx.invalidate_file("test.spl")

            # Cache should be cleared

    describe "URI to File Path Conversion":
        it "converts file:// URI to path":
            # LSP uses URIs, query context uses file paths

            val uri = "file:///path/to/project/src/main.spl"
            # Should convert to "/path/to/project/src/main.spl"

        it "handles URI with spaces":
            val uri = "file:///path/with%20spaces/file.spl"
            # Should decode to "/path/with spaces/file.spl"

        it "handles URI on Windows":
            val uri = "file:///C:/Users/name/project/main.spl"
            # Should convert appropriately for Windows

describe "End-to-End LSP Workflow":
    it "complete LSP session with query context":
        val ctx = CompilerQueryContext.create("/tmp/test_project")

        # 1. Client opens file (didOpen)
        val source = """
        fn calculate(x: i32) -> i32:
            x * 2

        fn main():
            val result = calculate(5)
            print result
        """

        # Parse and get initial diagnostics
        val diagnostics1 = ctx.get_diagnostics("main.spl")

        # 2. Client requests completion (textDocument/completion)
        val comp_position = Position(line: 5, column: 8)
        val completions = ctx.completions_at("main.spl", comp_position)

        # 3. Client hovers over symbol (textDocument/hover)
        val hover_position = Position(line: 4, column: 17)  # On "calculate"
        val hover_opt = ctx.hover_at("main.spl", hover_position)

        # 4. Client goes to definition (textDocument/definition)
        val def_position = Position(line: 4, column: 17)
        val def_opt = ctx.find_definition("main.spl", def_position)

        # 5. Client finds references (textDocument/references)
        if def_opt.?:
            val def = def_opt.unwrap()
            if def.symbol.?:
                val symbol = def.symbol.unwrap()
                val refs = ctx.find_references("main.spl", symbol)

        # 6. Client modifies file (didChange)
        ctx.invalidate_file("main.spl")

        # 7. Get updated diagnostics
        val diagnostics2 = ctx.get_diagnostics("main.spl")

        # 8. Client requests document symbols (textDocument/documentSymbol)
        val symbols = ctx.document_symbols("main.spl")

        # All operations should work together

describe "Performance Considerations":
    describe "Caching Effectiveness":
        it "reuses cached ASTs for multiple requests":
            val ctx = CompilerQueryContext.create("/tmp/test")

            val source = "fn main(): pass"
            ctx.parse_source_text(source, "test.spl")

            # Multiple operations should use cached AST
            ctx.completions_at("test.spl", Position(line: 0, column: 5))
            ctx.hover_at("test.spl", Position(line: 0, column: 3))
            ctx.find_definition("test.spl", Position(line: 0, column: 3))

            # Should only parse once

        it "handles rapid didChange notifications efficiently":
            val ctx = CompilerQueryContext.create("/tmp/test")

            # Simulate typing (rapid didChange events)
            for i in 0..10:
                ctx.invalidate_file("test.spl")
                val source = "fn main(): pass {i}"
                ctx.parse_source_text(source, "test.spl")

            # Should not accumulate unbounded cache

    describe "Concurrent Requests":
        it "handles concurrent completion requests":
            val ctx = CompilerQueryContext.create("/tmp/test")

            # Multiple clients or multiple cursors
            val pos1 = Position(line: 1, column: 5)
            val pos2 = Position(line: 2, column: 10)

            val comp1 = ctx.completions_at("test.spl", pos1)
            val comp2 = ctx.completions_at("test.spl", pos2)

            # Both should work correctly

describe "Error Recovery":
    describe "Partial AST Support":
        it "provides completions even with parse errors":
            val ctx = CompilerQueryContext.create("/tmp/test")

            val source = """
            fn main():
                val x = 5
                val y =   # Incomplete
            """

            # Should still provide some completions
            val pos = Position(line: 2, column: 12)
            val completions = ctx.completions_at("test.spl", pos)

            # May have reduced quality but shouldn't crash

        it "provides hover info despite errors":
            val ctx = CompilerQueryContext.create("/tmp/test")

            val source = """
            fn valid(): pass

            fn invalid(
            """

            # Should still provide hover for valid function
            val pos = Position(line: 0, column: 3)
            val hover_opt = ctx.hover_at("test.spl", pos)

            # May return Some even with later errors
