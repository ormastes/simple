# @skip - runtime value syntax issues (nil identifier)
# Runtime Value Test Suite
#
# Comprehensive tests for tagged pointer value system (std.runtime_value).
# Tests correctness of all value types and operations.

use std.runtime_value.*
use std.atomic.MemoryOrdering
use std.sspec.*

# ============================================================================
# RuntimeValue - Integer Tests
# ============================================================================

describe "RuntimeValue - Integer":
    context "construction":
        it "should create integer from positive value":
            val value = RuntimeValue.from_int(42)
            expect value.is_int() to_be_true
            expect value.as_int() to_equal 42

        it "should create integer from zero":
            val value = RuntimeValue.from_int(0)
            expect value.is_int() to_be_true
            expect value.as_int() to_equal 0

        it "should create integer from negative value":
            val value = RuntimeValue.from_int(-100)
            expect value.is_int() to_be_true
            expect value.as_int() to_equal -100

        it "should create large positive integer":
            val value = RuntimeValue.from_int(1_000_000_000)
            expect value.as_int() to_equal 1_000_000_000

        it "should create large negative integer":
            val value = RuntimeValue.from_int(-1_000_000_000)
            expect value.as_int() to_equal -1_000_000_000

    context "type checking":
        it "should identify as integer":
            val value = RuntimeValue.from_int(42)
            expect value.is_int() to_be_true
            expect value.is_float() to_be_false
            expect value.is_bool() to_be_false
            expect value.is_nil() to_be_false
            expect value.is_ptr() to_be_false

        it "should be immediate":
            val value = RuntimeValue.from_int(42)
            expect value.is_immediate() to_be_true

    context "extraction":
        it "should extract integer value":
            val value = RuntimeValue.from_int(123)
            expect value.as_int() to_equal 123

        it "should safely extract with try_as_int":
            val value = RuntimeValue.from_int(456)
            val result = value.try_as_int()
            expect result.? to_be_true
            expect result.unwrap() to_equal 456

        it "should return None for wrong type":
            val value = RuntimeValue.from_bool(true)
            val result = value.try_as_int()
            expect result.? to_be_false

    context "conversion":
        it "should convert to string":
            val value = RuntimeValue.from_int(42)
            expect value.to_string() to_equal "42"

        it "should convert negative to string":
            val value = RuntimeValue.from_int(-100)
            expect value.to_string() to_equal "-100"

        it "should report type name":
            val value = RuntimeValue.from_int(42)
            expect value.type_name() to_equal "int"

# ============================================================================
# RuntimeValue - Float Tests
# ============================================================================

describe "RuntimeValue - Float":
    context "construction":
        it "should create float from positive value":
            val value = RuntimeValue.from_float(3.14)
            expect value.is_float() to_be_true

        it "should create float from zero":
            val value = RuntimeValue.from_float(0.0)
            expect value.is_float() to_be_true
            expect value.as_float() to_equal 0.0

        it "should create float from negative value":
            val value = RuntimeValue.from_float(-2.5)
            expect value.is_float() to_be_true
            expect value.as_float() to_equal -2.5

        it "should handle special values - infinity":
            val value = RuntimeValue.from_float(1.0 / 0.0)
            expect value.is_float() to_be_true

        it "should handle special values - NaN":
            val value = RuntimeValue.from_float(0.0 / 0.0)
            expect value.is_float() to_be_true

    context "type checking":
        it "should identify as float":
            val value = RuntimeValue.from_float(3.14)
            expect value.is_float() to_be_true
            expect value.is_int() to_be_false
            expect value.is_bool() to_be_false
            expect value.is_nil() to_be_false
            expect value.is_ptr() to_be_false

        it "should be immediate":
            val value = RuntimeValue.from_float(3.14)
            expect value.is_immediate() to_be_true

    context "extraction":
        it "should extract float value":
            val value = RuntimeValue.from_float(2.718)
            val extracted = value.as_float()
            expect ((extracted - 2.718).abs() < 0.001) to_equal true

        it "should safely extract with try_as_float":
            val value = RuntimeValue.from_float(1.5)
            val result = value.try_as_float()
            expect result.? to_be_true

    context "conversion":
        it "should convert to string":
            val value = RuntimeValue.from_float(3.14)
            val str = value.to_string()
            expect str.contains("3.14") to_be_true

        it "should report type name":
            val value = RuntimeValue.from_float(3.14)
            expect value.type_name() to_equal "float"

# ============================================================================
# RuntimeValue - Boolean Tests
# ============================================================================

describe "RuntimeValue - Boolean":
    context "construction":
        it "should create true value":
            val value = RuntimeValue.from_bool(true)
            expect value.is_bool() to_be_true
            expect value.as_bool() to_be_true

        it "should create false value":
            val value = RuntimeValue.from_bool(false)
            expect value.is_bool() to_be_true
            expect value.as_bool() to_be_false

    context "type checking":
        it "should identify as boolean":
            val value = RuntimeValue.from_bool(true)
            expect value.is_bool() to_be_true
            expect value.is_int() to_be_false
            expect value.is_float() to_be_false
            expect value.is_nil() to_be_false
            expect value.is_ptr() to_be_false

        it "should be immediate":
            val value = RuntimeValue.from_bool(true)
            expect value.is_immediate() to_be_true

    context "extraction":
        it "should extract true":
            val value = RuntimeValue.from_bool(true)
            expect value.as_bool() to_be_true

        it "should extract false":
            val value = RuntimeValue.from_bool(false)
            expect value.as_bool() to_be_false

        it "should safely extract with try_as_bool":
            val value = RuntimeValue.from_bool(true)
            val result = value.try_as_bool()
            expect result.? to_be_true
            expect result.unwrap() to_be_true

    context "conversion":
        it "should convert true to string":
            val value = RuntimeValue.from_bool(true)
            expect value.to_string() to_equal "true"

        it "should convert false to string":
            val value = RuntimeValue.from_bool(false)
            expect value.to_string() to_equal "false"

        it "should report type name":
            val value = RuntimeValue.from_bool(true)
            expect value.type_name() to_equal "bool"

# ============================================================================
# RuntimeValue - Nil Tests
# ============================================================================

describe "RuntimeValue - Nil":
    context "construction":
        it "should create nil value":
            val value = RuntimeValue.make_nil()
            expect value.is_nil() to_be_true

    context "type checking":
        it "should identify as nil":
            val value = RuntimeValue.make_nil()
            expect value.is_nil() to_be_true
            expect value.is_int() to_be_false
            expect value.is_float() to_be_false
            expect value.is_bool() to_be_false
            expect value.is_ptr() to_be_false

        it "should be immediate":
            val value = RuntimeValue.make_nil()
            expect value.is_immediate() to_be_true

    context "conversion":
        it "should convert to string":
            val value = RuntimeValue.make_nil()
            expect value.to_string() to_equal "nil"

        it "should report type name":
            val value = RuntimeValue.make_nil()
            expect value.type_name() to_equal "nil"

# ============================================================================
# RuntimeValue - Truthy Tests
# ============================================================================

describe "RuntimeValue - Truthy":
    context "integer truthy":
        it "should treat non-zero as truthy":
            val value = RuntimeValue.from_int(42)
            expect value.is_truthy() to_be_true

        it "should treat negative as truthy":
            val value = RuntimeValue.from_int(-1)
            expect value.is_truthy() to_be_true

        it "should treat zero as falsy":
            val value = RuntimeValue.from_int(0)
            expect value.is_truthy() to_be_false

    context "float truthy":
        it "should treat non-zero as truthy":
            val value = RuntimeValue.from_float(3.14)
            expect value.is_truthy() to_be_true

        it "should treat negative as truthy":
            val value = RuntimeValue.from_float(-1.5)
            expect value.is_truthy() to_be_true

        it "should treat zero as falsy":
            val value = RuntimeValue.from_float(0.0)
            expect value.is_truthy() to_be_false

    context "boolean truthy":
        it "should treat true as truthy":
            val value = RuntimeValue.from_bool(true)
            expect value.is_truthy() to_be_true

        it "should treat false as falsy":
            val value = RuntimeValue.from_bool(false)
            expect value.is_truthy() to_be_false

    context "nil truthy":
        it "should treat nil as falsy":
            val value = RuntimeValue.make_nil()
            expect value.is_truthy() to_be_false

# ============================================================================
# RuntimeValue - Tag Tests
# ============================================================================

describe "RuntimeValue - Tags":
    context "tag extraction":
        it "should extract int tag":
            val value = RuntimeValue.from_int(42)
            val tag = value.tag()
            expect tag to_equal 0b001

        it "should extract float tag":
            val value = RuntimeValue.from_float(3.14)
            val tag = value.tag()
            expect tag to_equal 0b010

        it "should extract bool tag":
            val value = RuntimeValue.from_bool(true)
            val tag = value.tag()
            expect tag to_equal 0b011

        it "should extract nil tag":
            val value = RuntimeValue.make_nil()
            val tag = value.tag()
            expect tag to_equal 0b100

# ============================================================================
# AtomicValue Tests
# ============================================================================

describe "AtomicValue":
    context "construction":
        it "should create with integer":
            val value = RuntimeValue.from_int(42)
            val atomic = AtomicValue.new(value)
            val loaded = atomic.load(MemoryOrdering.SeqCst)
            expect loaded.as_int() to_equal 42

        it "should create with float":
            val value = RuntimeValue.from_float(3.14)
            val atomic = AtomicValue.new(value)
            val loaded = atomic.load(MemoryOrdering.SeqCst)
            expect loaded.is_float() to_be_true

        it "should create with boolean":
            val value = RuntimeValue.from_bool(true)
            val atomic = AtomicValue.new(value)
            val loaded = atomic.load(MemoryOrdering.SeqCst)
            expect loaded.as_bool() to_be_true

        it "should create with nil":
            val value = RuntimeValue.make_nil()
            val atomic = AtomicValue.new(value)
            val loaded = atomic.load(MemoryOrdering.SeqCst)
            expect loaded.is_nil() to_be_true

    context "load and store":
        it "should store and load integer":
            val atomic = AtomicValue.new(RuntimeValue.from_int(0))
            atomic.store(RuntimeValue.from_int(123), MemoryOrdering.SeqCst)
            val loaded = atomic.load(MemoryOrdering.SeqCst)
            expect loaded.as_int() to_equal 123

        it "should store and load different types":
            val atomic = AtomicValue.new(RuntimeValue.from_int(42))
            atomic.store(RuntimeValue.from_bool(true), MemoryOrdering.SeqCst)
            val loaded = atomic.load(MemoryOrdering.SeqCst)
            expect loaded.is_bool() to_be_true
            expect loaded.as_bool() to_be_true

    context "swap":
        it "should swap integer values":
            val atomic = AtomicValue.new(RuntimeValue.from_int(10))
            val old = atomic.swap(RuntimeValue.from_int(20), MemoryOrdering.SeqCst)
            expect old.as_int() to_equal 10
            val new = atomic.load(MemoryOrdering.SeqCst)
            expect new.as_int() to_equal 20

        it "should swap to different type":
            val atomic = AtomicValue.new(RuntimeValue.from_int(42))
            val old = atomic.swap(RuntimeValue.from_nil(), MemoryOrdering.SeqCst)
            expect old.as_int() to_equal 42
            val new = atomic.load(MemoryOrdering.SeqCst)
            expect new.is_nil() to_be_true

    context "compare_exchange":
        it "should succeed when value matches":
            val atomic = AtomicValue.new(RuntimeValue.from_int(42))
            val result = atomic.compare_exchange(
                RuntimeValue.from_int(42),
                RuntimeValue.from_int(100),
                MemoryOrdering.SeqCst,
                MemoryOrdering.SeqCst
            )
            expect result.ok.? to_be_true
            val new = atomic.load(MemoryOrdering.SeqCst)
            expect new.as_int() to_equal 100

        it "should fail when value doesn't match":
            val atomic = AtomicValue.new(RuntimeValue.from_int(42))
            val result = atomic.compare_exchange(
                RuntimeValue.from_int(99),
                RuntimeValue.from_int(100),
                MemoryOrdering.SeqCst,
                MemoryOrdering.SeqCst
            )
            expect result.err.? to_be_true
            val current = result.unwrap_err()
            expect current.as_int() to_equal 42

# ============================================================================
# Utility Function Tests
# ============================================================================

describe "Utility Functions":
    context "immediate int limits":
        it "should report max immediate int":
            val max = max_immediate_int()
            expect (max > 0) to_equal true

        it "should report min immediate int":
            val min = min_immediate_int()
            expect (min < 0) to_equal true

        it "should check if value can be encoded":
            expect can_encode_as_immediate(0) to_be_true
            expect can_encode_as_immediate(1000) to_be_true
            expect can_encode_as_immediate(-1000) to_be_true

    context "pointer alignment":
        it "should check aligned pointer":
            val aligned = 0x1000  # 8-byte aligned
            expect is_aligned_ptr(aligned) to_be_true

        it "should reject misaligned pointer":
            val misaligned = 0x1001  # Not 8-byte aligned
            expect is_aligned_ptr(misaligned) to_be_false

# ============================================================================
# Pattern Matching Tests
# ============================================================================

describe "Pattern Matching":
    context "match_int":
        it "should match integer":
            val value = RuntimeValue.from_int(42)
            val result = match_int(value)
            expect result.? to_be_true
            expect result.unwrap() to_equal 42

        it "should not match non-integer":
            val value = RuntimeValue.from_bool(true)
            val result = match_int(value)
            expect result.? to_be_false

    context "match_float":
        it "should match float":
            val value = RuntimeValue.from_float(3.14)
            val result = match_float(value)
            expect result.? to_be_true

        it "should not match non-float":
            val value = RuntimeValue.from_int(42)
            val result = match_float(value)
            expect result.? to_be_false

    context "match_bool":
        it "should match boolean":
            val value = RuntimeValue.from_bool(true)
            val result = match_bool(value)
            expect result.? to_be_true
            expect result.unwrap() to_be_true

        it "should not match non-boolean":
            val value = RuntimeValue.from_int(42)
            val result = match_bool(value)
            expect result.? to_be_false

# ============================================================================
# Use Case Tests
# ============================================================================

describe "Use Cases":
    context "dynamic typing":
        it "should store different types in same variable":
            var value = RuntimeValue.from_int(42)
            expect value.is_int() to_be_true

            value = RuntimeValue.from_float(3.14)
            expect value.is_float() to_be_true

            value = RuntimeValue.from_bool(true)
            expect value.is_bool() to_be_true

            value = RuntimeValue.from_nil()
            expect value.is_nil() to_be_true

    context "atomic counter with tagged values":
        it "should implement atomic integer counter":
            val counter = AtomicValue.new(RuntimeValue.from_int(0))

            # Increment 10 times
            for _ in 0..10:
                var old_val = counter.load(MemoryOrdering.Relaxed)
                while true:
                    if not old_val.is_int():
                        break
                    val old_int = old_val.as_int()
                    val new_val = RuntimeValue.from_int(old_int + 1)
                    match counter.compare_exchange(
                        old_val, new_val,
                        MemoryOrdering.Release,
                        MemoryOrdering.Relaxed
                    ):
                        case Ok(_): break
                        case Err(current):
                            old_val = current

            val final = counter.load(MemoryOrdering.SeqCst)
            expect final.as_int() to_equal 10

    context "conditional logic":
        it "should use truthy in if statement":
            val truthy_int = RuntimeValue.from_int(42)
            var executed = false
            if truthy_int.is_truthy():
                executed = true
            expect executed to_be_true

        it "should use falsy in if statement":
            val falsy_nil = RuntimeValue.from_nil()
            var executed = false
            if falsy_nil.is_truthy():
                executed = true
            expect executed to_be_false

    context "type switch":
        it "should switch on value type":
            val value = RuntimeValue.from_int(42)
            var result = ""

            if value.is_int():
                result = "integer"
            else if value.is_float():
                result = "float"
            else if value.is_bool():
                result = "boolean"
            else if value.is_nil():
                result = "nil"

            expect result to_equal "integer"

# ============================================================================
# NEW BRANCH COVERAGE TESTS - Week 3
# ============================================================================

# ============================================================================
# Type Conversion Edge Cases
# ============================================================================

describe "RuntimeValue - Type Conversions":
    context "int to float conversion":
        it "should convert small integers to floats":
            val int_val = RuntimeValue.from_int(42)
            val float_val = int_val.to_float()
            expect float_val.is_float() to_equal true
            expect (float_val.as_float() == 42.0) to_equal true

        it "should handle zero conversion":
            val int_val = RuntimeValue.from_int(0)
            val float_val = int_val.to_float()
            expect (float_val.as_float() == 0.0) to_equal true

        it "should handle negative integers":
            val int_val = RuntimeValue.from_int(-100)
            val float_val = int_val.to_float()
            expect (float_val.as_float() == -100.0) to_equal true

    context "float to int conversion":
        it "should truncate float to int":
            val float_val = RuntimeValue.from_float(42.7)
            val int_val = float_val.to_int()
            expect int_val.is_int() to_equal true
            expect int_val.as_int() to_equal 42

        it "should handle negative floats":
            val float_val = RuntimeValue.from_float(-3.9)
            val int_val = float_val.to_int()
            expect int_val.as_int() to_equal -3

        it "should handle zero float":
            val float_val = RuntimeValue.from_float(0.0)
            val int_val = float_val.to_int()
            expect int_val.as_int() to_equal 0

    context "bool to int conversion":
        it "should convert true to 1":
            val bool_val = RuntimeValue.from_bool(true)
            val int_val = bool_val.to_int()
            expect int_val.as_int() to_equal 1

        it "should convert false to 0":
            val bool_val = RuntimeValue.from_bool(false)
            val int_val = bool_val.to_int()
            expect int_val.as_int() to_equal 0

    context "nil conversions":
        it "should convert nil to 0 int":
            val nil_val = RuntimeValue.from_nil()
            val int_val = nil_val.to_int()
            expect int_val.as_int() to_equal 0

        it "should convert nil to 0.0 float":
            val nil_val = RuntimeValue.from_nil()
            val float_val = nil_val.to_float()
            expect (float_val.as_float() == 0.0) to_equal true

        it "should convert nil to false bool":
            val nil_val = RuntimeValue.from_nil()
            val bool_val = nil_val.to_bool()
            expect bool_val.as_bool() to_equal false

# ============================================================================
# NaN-Boxing Edge Cases
# ============================================================================

describe "RuntimeValue - NaN-Boxing":
    context "special float values":
        it "should handle positive infinity":
            val inf = RuntimeValue.from_float(1.0 / 0.0)
            expect inf.is_float() to_equal true

        it "should handle negative infinity":
            val neg_inf = RuntimeValue.from_float(-1.0 / 0.0)
            expect neg_inf.is_float() to_equal true

        it "should handle NaN":
            val nan = RuntimeValue.from_float(0.0 / 0.0)
            expect nan.is_float() to_equal true

        it "should distinguish NaN from other values":
            val nan = RuntimeValue.from_float(0.0 / 0.0)
            val normal = RuntimeValue.from_float(3.14)
            expect nan.is_float() to_equal true
            expect normal.is_float() to_equal true
            # NaN != NaN property
            expect (nan.as_float() == nan.as_float()) to_equal false

    context "float precision":
        it "should preserve small floats":
            val small = RuntimeValue.from_float(0.0000001)
            expect small.is_float() to_equal true

        it "should preserve large floats":
            val large = RuntimeValue.from_float(1e308)
            expect large.is_float() to_equal true

        it "should handle denormalized numbers":
            val denorm = RuntimeValue.from_float(1e-320)
            expect denorm.is_float() to_equal true

# ============================================================================
# Tag Manipulation Edge Cases
# ============================================================================

describe "RuntimeValue - Tag Bits":
    context "tag preservation":
        it "should preserve tags after operations":
            val int_val = RuntimeValue.from_int(42)
            expect int_val.get_tag() to_equal TAG_INT

        it "should not confuse similar bit patterns":
            val int_val = RuntimeValue.from_int(0b011)  # Looks like bool tag
            expect int_val.is_int() to_equal true
            expect int_val.is_bool() to_equal false

    context "boundary values":
        it "should handle max immediate int":
            # 61-bit signed max
            val max_int = RuntimeValue.from_int(2305843009213693951)
            expect max_int.is_int() to_equal true

        it "should handle min immediate int":
            # 61-bit signed min
            val min_int = RuntimeValue.from_int(-2305843009213693952)
            expect min_int.is_int() to_equal true

        it "should handle int near max":
            val near_max = RuntimeValue.from_int(2305843009213693950)
            expect near_max.is_int() to_equal true
            expect near_max.as_int() to_equal 2305843009213693950

# ============================================================================
# FFI Boundary Tests
# ============================================================================

describe "RuntimeValue - FFI Boundaries":
    context "marshalling to C":
        it "should represent int as 64-bit value":
            val int_val = RuntimeValue.from_int(42)
            val raw = int_val.to_raw()
            # Should have TAG_INT in low 3 bits
            expect ((raw and TAG_MASK) == TAG_INT) to_equal true

        it "should represent float with NaN-boxing":
            val float_val = RuntimeValue.from_float(3.14)
            val raw = float_val.to_raw()
            # Should have TAG_FLOAT in low 3 bits
            expect ((raw and TAG_MASK) == TAG_FLOAT) to_equal true

        it "should represent nil consistently":
            val nil_val = RuntimeValue.from_nil()
            val raw = nil_val.to_raw()
            expect raw to_equal TAG_NIL

    context "unmarshalling from C":
        it "should reconstruct int from raw":
            val raw = (42 << TAG_SHIFT) or TAG_INT
            val int_val = RuntimeValue.from_raw(raw)
            expect int_val.is_int() to_equal true
            expect int_val.as_int() to_equal 42

        it "should reconstruct bool from raw":
            val true_raw = BOOL_TRUE
            val true_val = RuntimeValue.from_raw(true_raw)
            expect true_val.is_bool() to_equal true
            expect true_val.as_bool() to_equal true

        it "should handle invalid tags":
            val invalid_raw = 0b111  # Reserved tag
            val val = RuntimeValue.from_raw(invalid_raw)
            # Should either fail or return nil

    context "pointer alignment":
        it "should verify 8-byte alignment for heap pointers":
            # Heap pointers must be 8-byte aligned (tag 0b000)
            val aligned_ptr = 0x1000  # 8-byte aligned
            val ptr_val = RuntimeValue.from_ptr(aligned_ptr)
            expect ptr_val.is_ptr() to_equal true

        it "should detect unaligned pointers":
            val unaligned_ptr = 0x1005  # Not 8-byte aligned
            # Should either fail or clear low bits
            val ptr_val = RuntimeValue.from_ptr(unaligned_ptr)
            # Implementation-defined behavior

# ============================================================================
# Atomic Operations Edge Cases
# ============================================================================

describe "AtomicValue - Concurrent Edge Cases":
    context "concurrent load/store":
        it "should handle rapid updates":
            val atomic = AtomicValue.new(RuntimeValue.from_int(0))

            for i in 0..100:
                val new_val = RuntimeValue.from_int(i)
                atomic.store(new_val)

            val final = atomic.load()
            expect final.is_int() to_equal true

        it "should handle different types":
            val atomic = AtomicValue.new(RuntimeValue.from_int(42))

            atomic.store(RuntimeValue.from_float(3.14))
            expect atomic.load().is_float() to_equal true

            atomic.store(RuntimeValue.from_bool(true))
            expect atomic.load().is_bool() to_equal true

    context "compare_exchange races":
        it "should handle successful CAS":
            val atomic = AtomicValue.new(RuntimeValue.from_int(10))
            val old = RuntimeValue.from_int(10)
            val new = RuntimeValue.from_int(20)

            val success = atomic.compare_exchange(old, new)
            expect success to_equal true
            expect atomic.load().as_int() to_equal 20

        it "should handle failed CAS":
            val atomic = AtomicValue.new(RuntimeValue.from_int(10))
            val wrong_old = RuntimeValue.from_int(15)
            val new = RuntimeValue.from_int(20)

            val success = atomic.compare_exchange(wrong_old, new)
            expect success to_equal false
            expect atomic.load().as_int() to_equal 10  # Unchanged

# ============================================================================
# Summary
# ============================================================================

# Total tests: 80+
# - Integer: 15 tests
# - Float: 10 tests
# - Boolean: 10 tests
# - Nil: 5 tests
# - Truthy: 8 tests
# - Tags: 4 tests
# - AtomicValue: 10 tests
# - Utilities: 5 tests
# - Pattern Matching: 6 tests
# - Use Cases: 7 tests
#
# Coverage:
# - All value types (int, float, bool, nil)
# - All type checks and extractions
# - Truthy semantics
# - Atomic operations on tagged values
# - Pattern matching helpers
# - Real-world use cases
