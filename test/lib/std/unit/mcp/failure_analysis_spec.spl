"""
# MCP Failure Analysis Tools Specification

**Feature IDs:** #MCP-001, #MCP-002, #MCP-003
**Category:** Testing | Tooling | MCP
**Difficulty:** 3/5
**Status:** Complete

## Overview

Comprehensive testing for MCP database query tools that analyze test failures,
classify errors, extract needed features, and provide actionable insights for
fixing failed tests.

## Key Features

| Feature | Description |
|---------|-------------|
| Error Classification | Categorizes errors by type (parse, semantic, timeout, etc.) |
| Feature Extraction | Identifies missing language features from error messages |
| Failure Analysis | Groups failures and prioritizes feature implementation |
| Cross-Reference | Links failed tests with feature database |

## Related Specifications

- [MCP Core](../../../../../src/lib/std/src/mcp/README.md)
- [Testing Framework](../../../../../doc/spec/testing_framework_spec.md)
- [SDN Format](../../../../../doc/spec/sdn_format.md)
"""

use std.spec.*
use mcp.simple_lang.db_tools.*
use mcp.core.*
use infra.file_io.{write_file, read_file}
use sdn.*


# ============================================================================
# Test Group 1: Error Classification
# ============================================================================

describe "Error Classification":
    """
    ## Error Type Detection

    Tests the classify_error() function which categorizes error messages
    into specific types for better analysis and reporting.
    """

    context "when error is a parse error":
        """
        ### Parse Error Detection

        Should detect various parse error patterns including:
        - Explicit "parse error" messages
        - "Unexpected token" messages
        - Syntax errors
        """

        it "classifies explicit parse error":
            val error = "parse error: Unexpected token: expected Fn, found Static"
            val result = classify_error(error)
            expect(result).to(eq("parse_error"))

        it "classifies unexpected token error":
            val error = "Unexpected token: expected expression, found Default"
            val result = classify_error(error)
            expect(result).to(eq("parse_error"))

        it "classifies indentation error":
            val error = "Unexpected token: expected indented block after ':', found Dedent"
            val result = classify_error(error)
            expect(result).to(eq("parse_error"))

    context "when error is a semantic error":
        """
        ### Semantic Error Detection

        Should detect semantic analysis errors including:
        - Undefined identifier errors
        - Type errors
        - Mutability violations
        """

        it "classifies function not found error":
            val error = "compile failed: semantic: function `filter_internal_flags` not found"
            val result = classify_error(error)
            expect(result).to(eq("semantic_error"))

        it "classifies method not found error":
            val error = "compile failed: semantic: method `char_at` not found on type `array`"
            val result = classify_error(error)
            expect(result).to(eq("semantic_error"))

        it "classifies mutability error":
            val error = "compile failed: semantic: cannot modify self.features in immutable fn method"
            val result = classify_error(error)
            expect(result).to(eq("semantic_error"))

    context "when error is a file system error":
        """
        ### File System Error Detection

        Should detect file-related errors.
        """

        it "classifies file not found error":
            val error = "failed to read /tmp/test_spec.spl: No such file or directory (os error 2)"
            val result = classify_error(error)
            expect(result).to(eq("file_not_found"))

    context "when error is a timeout":
        """
        ### Timeout Error Detection

        Should detect test timeout errors.
        """

        it "classifies timeout error":
            val error = "Test timed out after 30 seconds"
            val result = classify_error(error)
            expect(result).to(eq("timeout"))

        it "classifies alternative timeout message":
            val error = "Execution timeout: exceeded maximum time"
            val result = classify_error(error)
            expect(result).to(eq("timeout"))

    context "when error is a UTF-8 encoding error":
        """
        ### UTF-8 Error Detection

        Should detect file encoding errors.
        """

        it "classifies UTF-8 error":
            val error = "failed to read test.spl: stream did not contain valid UTF-8"
            val result = classify_error(error)
            expect(result).to(eq("utf8_error"))

    context "when error type is unknown":
        """
        ### Unknown Error Handling

        Should return 'unknown_error' for unrecognized patterns.
        """

        it "classifies unknown error":
            val error = "Something completely unexpected happened"
            val result = classify_error(error)
            expect(result).to(eq("unknown_error"))


# ============================================================================
# Test Group 2: Feature Extraction
# ============================================================================

describe "Feature Extraction from Errors":
    """
    ## Missing Feature Detection

    Tests the extract_needed_features() function which identifies missing
    language features from error messages to guide implementation priorities.
    """

    context "when error indicates missing parser features":
        """
        ### Parser Feature Detection

        Should extract parser-related features.
        """

        it "extracts static fields feature":
            val error = "parse error: expected Fn, found Static"
            val features = extract_needed_features(error)
            expect(features).to(contain("static_fields"))

        it "extracts default parameters feature":
            val error = "parse error: expected expression, found Default"
            val features = extract_needed_features(error)
            expect(features).to(contain("default_parameters"))

        it "extracts implicit val/var feature":
            val error = "parse error: expected expression, found Assign"
            val features = extract_needed_features(error)
            expect(features).to(contain("implicit_val_var"))

        it "extracts matrix multiplication feature":
            val error = "compile failed: parse: Unexpected token: expected expression, found At"
            val features = extract_needed_features(error)
            expect(features).to(contain("matrix_multiplication"))

        it "extracts XOR keyword feature":
            val error = "compile failed: parse: Unexpected token: expected identifier, found Xor"
            val features = extract_needed_features(error)
            expect(features).to(contain("xor_keyword"))

        it "extracts dict literal syntax feature":
            val error = "compile failed: parse: Unexpected token: expected Comma, found Colon"
            val features = extract_needed_features(error)
            expect(features).to(contain("dict_literal_syntax"))

        it "extracts val pattern matching feature":
            val error = "parse error: Unexpected token: expected pattern, found Val"
            val features = extract_needed_features(error)
            expect(features).to(contain("val_pattern_matching"))

        it "extracts where clause feature":
            val error = "parse error: expected identifier, found Where"
            val features = extract_needed_features(error)
            expect(features).to(contain("where_clause"))

        it "extracts list comprehension feature":
            val error = "parse error: expected expression, found For"
            val features = extract_needed_features(error)
            expect(features).to(contain("list_comprehension"))

        it "extracts pub val declaration feature":
            val error = "compile failed: parse: expected fn, struct, class, enum, trait, actor, const, static, type, extern, macro, mod, use, or import after 'pub', found Val"
            val features = extract_needed_features(error)
            expect(features).to(contain("pub_val_declaration"))

        it "extracts parallel operator feature":
            val error = "parse error: expected expression, found Slash"
            val features = extract_needed_features(error)
            expect(features).to(contain("parallel_operator"))

        it "extracts from pattern feature":
            val error = "parse error: expected pattern, found From"
            val features = extract_needed_features(error)
            expect(features).to(contain("from_pattern"))

        it "extracts return expression feature":
            val error = "compile failed: parse: expected expression, found Return"
            val features = extract_needed_features(error)
            expect(features).to(contain("return_expression"))

        it "extracts class var fields feature":
            val error = "compile failed: parse: expected Fn, found Var"
            val features = extract_needed_features(error)
            expect(features).to(contain("class_var_fields"))

        it "extracts array literal syntax feature":
            val error = "parse error: expected RBracket, found Comma"
            val features = extract_needed_features(error)
            expect(features).to(contain("array_literal_syntax"))

    context "when error indicates missing semantic features":
        """
        ### Semantic Feature Detection

        Should extract semantic analysis features.
        """

        it "extracts string method feature":
            val error = "compile failed: semantic: method `char_at` not found on type `array`"
            val features = extract_needed_features(error)
            expect(features).to(contain("string_char_at_method"))

        it "extracts mutability checking feature":
            val error = "compile failed: semantic: cannot modify self.features in immutable fn method"
            val features = extract_needed_features(error)
            expect(features).to(contain("mutability_checking"))

    context "when error has multiple feature indicators":
        """
        ### Multiple Feature Extraction

        Should extract all relevant features from complex errors.
        """

        it "extracts multiple features from compound error":
            val error = "parse error: expected expression, found Assign at line 10, expected Comma, found Colon at line 15"
            val features = extract_needed_features(error)
            expect(features.len()).to(eq(2))
            expect(features).to(contain("implicit_val_var"))
            expect(features).to(contain("dict_literal_syntax"))

    context "when error has no recognizable features":
        """
        ### No Feature Match

        Should return empty list for unrecognized errors.
        """

        it "returns empty list for generic error":
            val error = "Something went wrong"
            val features = extract_needed_features(error)
            expect(features.len()).to(eq(0))


# ============================================================================
# Test Group 3: Text Truncation Helper
# ============================================================================

describe "Text Truncation":
    """
    ## Truncate Long Text

    Tests the truncate_text() helper for limiting output length.
    """

    it "keeps short text unchanged":
        val text = "Short text"
        val result = truncate_text(text, 100)
        expect(result).to(eq("Short text"))

    it "truncates long text and adds ellipsis":
        val text = "This is a very long text that should be truncated to a reasonable length for display purposes"
        val result = truncate_text(text, 20)
        expect(result).to(eq("This is a very long ..."))
        expect(result.len()).to(eq(23))  # 20 + "..."

    it "handles exact length match":
        val text = "Exactly twenty chars"
        val result = truncate_text(text, 20)
        expect(result).to(eq("Exactly twenty chars"))


# ============================================================================
# Test Group 4: Query Failed Test Details Tool
# ============================================================================

describe "Query Failed Test Details Tool":
    """
    ## Detailed Failed Test Query

    Tests the query_failed_test_details MCP tool which provides comprehensive
    information about failed tests including error messages and needed features.
    """

    before_each:
        """Setup test database"""
        @test_db_content = """
tests |test_id, test_name, file, status, category, error_message, last_run|
    1, test_static_spec, tmp/test_static_spec.spl, failed, Unit, "parse error: expected Fn, found Static", 2026-01-29T10:00:00Z
    2, test_default_spec, tmp/test_default_spec.spl, failed, Unit, "parse error: expected expression, found Default", 2026-01-29T10:00:00Z
    3, test_pass_spec, tmp/test_pass_spec.spl, passed, Unit, "", 2026-01-29T10:00:00Z
    4, test_matrix_spec, tmp/test_matrix_spec.spl, failed, Integration, "compile failed: parse: expected expression, found At", 2026-01-29T10:00:00Z
    5, test_timeout_spec, tmp/test_timeout_spec.spl, failed, Unit, "Test timed out after 30 seconds", 2026-01-29T10:00:00Z
"""
        write_file("doc/test/test_db.sdn", @test_db_content)

    after_each:
        """Cleanup"""
        # Cleanup handled by test framework

    context "when querying with default parameters":
        """
        ### Default Query Behavior

        Should return failed tests with basic information.
        """

        it "returns failed tests with error messages":
            val tool = create_query_failed_test_details_tool()
            val args = {"limit": 10}
            val result = tool.execute(args)

            expect(result).to(contain("test_static_spec"))
            expect(result).to(contain("test_default_spec"))
            expect(result).to(contain("test_matrix_spec"))
            expect(result).to(contain("test_timeout_spec"))
            expect(result).not_to(contain("test_pass_spec"))

        it "includes error type classification":
            val tool = create_query_failed_test_details_tool()
            val args = {"limit": 10}
            val result = tool.execute(args)

            expect(result).to(contain("parse_error"))
            expect(result).to(contain("timeout"))

    context "when filtering by category":
        """
        ### Category Filtering

        Should filter failed tests by category.
        """

        it "returns only Unit category failures":
            val tool = create_query_failed_test_details_tool()
            val args = {"category": "Unit", "limit": 10}
            val result = tool.execute(args)

            expect(result).to(contain("test_static_spec"))
            expect(result).to(contain("test_default_spec"))
            expect(result).to(contain("test_timeout_spec"))
            expect(result).not_to(contain("test_matrix_spec"))

        it "returns only Integration category failures":
            val tool = create_query_failed_test_details_tool()
            val args = {"category": "Integration", "limit": 10}
            val result = tool.execute(args)

            expect(result).to(contain("test_matrix_spec"))
            expect(result).not_to(contain("test_static_spec"))

    context "when including needed features":
        """
        ### Feature Extraction

        Should include extracted features when requested.
        """

        it "includes needed features in output":
            val tool = create_query_failed_test_details_tool()
            val args = {"limit": 10, "include_features": true}
            val result = tool.execute(args)

            expect(result).to(contain("static_fields"))
            expect(result).to(contain("default_parameters"))
            expect(result).to(contain("matrix_multiplication"))

    context "when excluding error messages":
        """
        ### Error Message Exclusion

        Should omit error messages when include_error is false.
        """

        it "excludes error messages from output":
            val tool = create_query_failed_test_details_tool()
            val args = {"limit": 10, "include_error": false}
            val result = tool.execute(args)

            # Should not contain actual error text
            expect(result).not_to(contain("parse error:"))
            # But should still have test names
            expect(result).to(contain("test_static_spec"))

    context "when applying limit":
        """
        ### Result Limiting

        Should respect the limit parameter.
        """

        it "limits results to specified count":
            val tool = create_query_failed_test_details_tool()
            val args = {"limit": 2}
            val result = tool.execute(args)

            # Count rows in markdown table (excluding header)
            val lines = result.split("\n")
            var data_rows = 0
            var found_header = false
            for line in lines:
                if found_header and line.starts_with("|") and not line.contains("---"):
                    data_rows = data_rows + 1
                if line.contains("---"):
                    found_header = true

            expect(data_rows).to(be_lte(2))


# ============================================================================
# Test Group 5: Analyze Failures Tool
# ============================================================================

describe "Analyze Failures Tool":
    """
    ## Failure Pattern Analysis

    Tests the analyze_failures MCP tool which groups failures by error type,
    identifies the most needed features, and provides priority guidance.
    """

    before_each:
        """Setup test database with diverse failures"""
        @test_db_content = """
tests |test_id, test_name, file, status, category, error_message, last_run|
    1, test_static_1, tmp/test1.spl, failed, Unit, "parse error: expected Fn, found Static", 2026-01-29T10:00:00Z
    2, test_static_2, tmp/test2.spl, failed, Unit, "parse error: expected Fn, found Static", 2026-01-29T10:00:00Z
    3, test_static_3, tmp/test3.spl, failed, Unit, "parse error: expected Fn, found Static", 2026-01-29T10:00:00Z
    4, test_default_1, tmp/test4.spl, failed, Unit, "parse error: expected expression, found Default", 2026-01-29T10:00:00Z
    5, test_default_2, tmp/test5.spl, failed, Unit, "parse error: expected expression, found Default", 2026-01-29T10:00:00Z
    6, test_matrix_1, tmp/test6.spl, failed, Unit, "parse error: expected expression, found At", 2026-01-29T10:00:00Z
    7, test_timeout_1, tmp/test7.spl, failed, Unit, "Test timed out after 30 seconds", 2026-01-29T10:00:00Z
    8, test_semantic_1, tmp/test8.spl, failed, Unit, "semantic: method `char_at` not found", 2026-01-29T10:00:00Z
    9, test_pass, tmp/test9.spl, passed, Unit, "", 2026-01-29T10:00:00Z
"""
        write_file("doc/test/test_db.sdn", @test_db_content)

    context "when analyzing failure patterns":
        """
        ### Pattern Recognition

        Should identify and group common failure patterns.
        """

        it "groups failures by error type":
            val tool = create_analyze_failures_tool()
            val args = {}
            val result = tool.execute(args)

            expect(result).to(contain("Failures by Error Type"))
            expect(result).to(contain("parse_error"))
            expect(result).to(contain("timeout"))
            expect(result).to(contain("semantic_error"))

        it "calculates correct percentages":
            val tool = create_analyze_failures_tool()
            val args = {}
            val result = tool.execute(args)

            # 6 parse errors out of 8 total = 75%
            expect(result).to(contain("parse_error"))
            # Should show percentage around 75%

        it "shows total failed test count":
            val tool = create_analyze_failures_tool()
            val args = {}
            val result = tool.execute(args)

            expect(result).to(contain("Total Failed Tests:"))
            expect(result).to(contain("8"))

    context "when ranking needed features":
        """
        ### Feature Prioritization

        Should rank features by how many tests they would unblock.
        """

        it "ranks features by test count":
            val tool = create_analyze_failures_tool()
            val args = {}
            val result = tool.execute(args)

            expect(result).to(contain("Most Needed Features"))
            # static_fields appears in 3 tests (most)
            expect(result).to(contain("static_fields"))
            # default_parameters appears in 2 tests
            expect(result).to(contain("default_parameters"))

        it "assigns priority labels based on test count":
            val tool = create_analyze_failures_tool()
            val args = {}
            val result = tool.execute(args)

            # Features blocking 10+ tests should be Critical
            # Features blocking 5-9 tests should be High
            # Features blocking 2-4 tests should be Medium
            # Features blocking 1 test should be Low
            expect(result).to(contain("ğŸŸ¡ Medium"))  # 2-4 tests
            expect(result).to(contain("ğŸŸ¢ Low"))     # 1 test

        it "limits feature list to top 20":
            val tool = create_analyze_failures_tool()
            val args = {}
            val result = tool.execute(args)

            # Count feature rows in output
            val lines = result.split("\n")
            var feature_count = 0
            var in_features_section = false

            for line in lines:
                if line.contains("Most Needed Features"):
                    in_features_section = true
                elif in_features_section and line.starts_with("|") and not line.contains("---") and not line.contains("Feature"):
                    feature_count = feature_count + 1

            expect(feature_count).to(be_lte(20))


# ============================================================================
# Test Group 6: Find Features for Failed Tests Tool
# ============================================================================

describe "Find Features for Failed Tests Tool":
    """
    ## Feature Database Cross-Reference

    Tests the find_features_for_failed_tests MCP tool which links failed
    tests with the feature database to show implementation status.
    """

    before_each:
        """Setup test and feature databases"""
        @test_db_content = """
tests |test_id, test_name, file, status, category, error_message, last_run|
    1, test_static_1, tmp/test1.spl, failed, Unit, "parse error: expected Fn, found Static", 2026-01-29T10:00:00Z
    2, test_static_2, tmp/test2.spl, failed, Unit, "parse error: expected Fn, found Static", 2026-01-29T10:00:00Z
    3, test_matrix_1, tmp/test3.spl, failed, Unit, "parse error: expected expression, found At", 2026-01-29T10:00:00Z
"""
        write_file("doc/test/test_db.sdn", @test_db_content)

        @feature_db_content = """
features |id, name, category, status, description|
    1, static_fields, Parser, planned, "Static field declarations in classes"
    2, matrix_multiplication, Operators, in_progress, "Matrix multiplication operator (@)"
    3, generics, Types, complete, "Generic type parameters"
"""
        write_file("doc/feature/feature_db.sdn", @feature_db_content)

    context "when cross-referencing features":
        """
        ### Feature Status Lookup

        Should match needed features with their database entries.
        """

        it "shows feature implementation status":
            val tool = create_find_features_for_failed_tests_tool()
            val args = {}
            val result = tool.execute(args)

            expect(result).to(contain("static_fields"))
            expect(result).to(contain("Status: planned"))
            expect(result).to(contain("matrix_multiplication"))
            expect(result).to(contain("Status: in_progress"))

        it "shows feature categories":
            val tool = create_find_features_for_failed_tests_tool()
            val args = {}
            val result = tool.execute(args)

            expect(result).to(contain("Category: Parser"))
            expect(result).to(contain("Category: Operators"))

        it "counts blocked tests per feature":
            val tool = create_find_features_for_failed_tests_tool()
            val args = {}
            val result = tool.execute(args)

            expect(result).to(contain("Tests Blocked: 2"))  # static_fields
            expect(result).to(contain("Tests Blocked: 1"))  # matrix_multiplication

        it "lists affected test names":
            val tool = create_find_features_for_failed_tests_tool()
            val args = {}
            val result = tool.execute(args)

            expect(result).to(contain("test_static_1"))
            expect(result).to(contain("test_static_2"))
            expect(result).to(contain("test_matrix_1"))

        it "limits test list to 5 per feature":
            # Add more tests
            @test_db_extended = """
tests |test_id, test_name, file, status, category, error_message, last_run|
    1, test_static_1, tmp/test1.spl, failed, Unit, "parse error: expected Fn, found Static", 2026-01-29T10:00:00Z
    2, test_static_2, tmp/test2.spl, failed, Unit, "parse error: expected Fn, found Static", 2026-01-29T10:00:00Z
    3, test_static_3, tmp/test3.spl, failed, Unit, "parse error: expected Fn, found Static", 2026-01-29T10:00:00Z
    4, test_static_4, tmp/test4.spl, failed, Unit, "parse error: expected Fn, found Static", 2026-01-29T10:00:00Z
    5, test_static_5, tmp/test5.spl, failed, Unit, "parse error: expected Fn, found Static", 2026-01-29T10:00:00Z
    6, test_static_6, tmp/test6.spl, failed, Unit, "parse error: expected Fn, found Static", 2026-01-29T10:00:00Z
    7, test_static_7, tmp/test7.spl, failed, Unit, "parse error: expected Fn, found Static", 2026-01-29T10:00:00Z
"""
            write_file("doc/test/test_db.sdn", @test_db_extended)

            val tool = create_find_features_for_failed_tests_tool()
            val args = {}
            val result = tool.execute(args)

            # Should show "(+2 more)" or similar
            expect(result).to(contain("more"))

    context "when feature is not in database":
        """
        ### Unknown Feature Handling

        Should handle features not found in feature database.
        """

        it "marks unknown features appropriately":
            @test_db_unknown = """
tests |test_id, test_name, file, status, category, error_message, last_run|
    1, test_unknown, tmp/test1.spl, failed, Unit, "parse error: expected expression, found FutureKeyword", 2026-01-29T10:00:00Z
"""
            write_file("doc/test/test_db.sdn", @test_db_unknown)

            val tool = create_find_features_for_failed_tests_tool()
            val args = {}
            val result = tool.execute(args)

            # Should handle missing feature gracefully
            expect(result).to(contain("Status: unknown"))


# ============================================================================
# Test Group 7: Integration Tests
# ============================================================================

describe "MCP Tool Integration":
    """
    ## End-to-End MCP Tool Testing

    Tests the tools working together as part of the MCP server.
    """

    before_each:
        """Setup realistic test scenario"""
        @test_db_content = """
tests |test_id, test_name, file, status, category, error_message, last_run|
    1, parser_static_spec, test/parser/static_spec.spl, failed, System, "parse error: expected Fn, found Static", 2026-01-29T10:00:00Z
    2, parser_default_spec, test/parser/default_spec.spl, failed, System, "parse error: expected expression, found Default", 2026-01-29T10:00:00Z
    3, ml_matrix_spec, test/ml/matrix_spec.spl, failed, Unit, "parse error: expected expression, found At", 2026-01-29T10:00:00Z
    4, string_methods_spec, test/core/string_spec.spl, failed, Unit, "semantic: method `char_at` not found", 2026-01-29T10:00:00Z
    5, passing_test_spec, test/core/pass_spec.spl, passed, Unit, "", 2026-01-29T10:00:00Z
"""
        write_file("doc/test/test_db.sdn", @test_db_content)

    it "creates all tools successfully":
        val tools = create_db_query_tools()
        expect(tools.len()).to(eq(8))

    it "query and analyze workflow":
        # First query failed tests
        val query_tool = create_query_failed_test_details_tool()
        val query_result = query_tool.execute({"limit": 10, "include_features": true})

        expect(query_result).to(contain("parser_static_spec"))
        expect(query_result).to(contain("static_fields"))

        # Then analyze patterns
        val analyze_tool = create_analyze_failures_tool()
        val analyze_result = analyze_tool.execute({})

        expect(analyze_result).to(contain("parse_error"))
        expect(analyze_result).to(contain("semantic_error"))
        expect(analyze_result).to(contain("Most Needed Features"))

    it "handles empty test database gracefully":
        @empty_db = """
tests |test_id, test_name, file, status, category, error_message, last_run|
"""
        write_file("doc/test/test_db.sdn", @empty_db)

        val tool = create_analyze_failures_tool()
        val result = tool.execute({})

        expect(result).to(contain("Total Failed Tests: 0"))

    it "handles database read errors":
        # Remove the database file
        # (Note: This test may need adjustment based on file cleanup)
        val tool = create_analyze_failures_tool()
        # Should return error message instead of crashing


# ============================================================================
# Test Group 8: Edge Cases and Error Handling
# ============================================================================

describe "Edge Cases and Error Handling":
    """
    ## Robustness Testing

    Tests edge cases, malformed data, and error conditions.
    """

    context "when handling malformed data":
        """
        ### Malformed Data Resilience

        Should handle incomplete or malformed test records.
        """

        it "handles missing error messages":
            @test_db_missing = """
tests |test_id, test_name, file, status, category, error_message, last_run|
    1, test_no_error, tmp/test.spl, failed, Unit, , 2026-01-29T10:00:00Z
"""
            write_file("doc/test/test_db.sdn", @test_db_missing)

            val tool = create_query_failed_test_details_tool()
            val result = tool.execute({"limit": 10})

            # Should not crash
            expect(result).to(contain("test_no_error"))

        it "handles missing category":
            @test_db_missing_cat = """
tests |test_id, test_name, file, status, category, error_message, last_run|
    1, test_no_cat, tmp/test.spl, failed, , "parse error", 2026-01-29T10:00:00Z
"""
            write_file("doc/test/test_db.sdn", @test_db_missing_cat)

            val tool = create_query_failed_test_details_tool()
            val result = tool.execute({"limit": 10})

            expect(result).to(contain("test_no_cat"))

    context "when handling large datasets":
        """
        ### Performance with Large Data

        Should handle large numbers of test records efficiently.
        """

        it "processes many failed tests":
            # Generate database with 100 failed tests
            var large_db = "tests |test_id, test_name, file, status, category, error_message, last_run|\n"
            for i in 0..100:
                large_db = large_db + "    " + i.to_string() + ", test_" + i.to_string() + ", tmp/test" + i.to_string() + ".spl, failed, Unit, \"parse error\", 2026-01-29T10:00:00Z\n"

            write_file("doc/test/test_db.sdn", large_db)

            val tool = create_analyze_failures_tool()
            val result = tool.execute({})

            expect(result).to(contain("Total Failed Tests: 100"))

    context "when handling special characters":
        """
        ### Special Character Handling

        Should properly escape special characters in output.
        """

        it "handles special characters in error messages":
            @test_db_special = """
tests |test_id, test_name, file, status, category, error_message, last_run|
    1, test_special, tmp/test.spl, failed, Unit, "Error: expected '|' but found '&'", 2026-01-29T10:00:00Z
"""
            write_file("doc/test/test_db.sdn", @test_db_special)

            val tool = create_query_failed_test_details_tool()
            val result = tool.execute({"limit": 10})

            # Should handle markdown special chars
            expect(result).to(contain("test_special"))


# ============================================================================
# Helper Functions
# ============================================================================

fn setup_minimal_test_db() -> text:
    """Create minimal valid test database"""
    """
tests |test_id, test_name, file, status, category, error_message, last_run|
    1, test_one, tmp/test.spl, failed, Unit, "parse error", 2026-01-29T10:00:00Z
"""

fn count_markdown_rows(table: text) -> i64:
    """Count data rows in markdown table (excluding header and separator)"""
    val lines = table.split("\n")
    var count = 0
    var found_separator = false

    for line in lines:
        if line.contains("---"):
            found_separator = true
        elif found_separator and line.starts_with("|") and line.trim().len() > 1:
            count = count + 1

    count
