# @pending
# @skip - Uses unsupported keyword: with
"""
MCP Capability Negotiation Tests
Feature: MCP Capability Negotiation
Category: MCP, Protocol
Status: In Progress

Tests for capability negotiation between MCP clients and servers.
"""

use std.mcp.core.capabilities.*

describe "ClientCapabilities":
    it "creates empty capabilities":
        val caps = ClientCapabilities(roots: false, sampling: false, list_changed: false)
        expect(not caps.has_roots())
        expect(not caps.has_sampling())

    it "creates full capabilities":
        val caps = ClientCapabilities.full()
        expect(caps.has_roots())
        expect(caps.has_sampling())

    it "checks list_changed support":
        val caps = ClientCapabilities.full()
        expect(caps.supports_list_changed())

    it "converts to dict":
        val caps = ClientCapabilities.full()
        val dict = caps.to_dict()
        expect(dict.has_key("roots"))
        expect(dict.has_key("sampling"))

    it "creates from dict":
        var dict: Dict<text, Any> = {}
        dict.set("roots", {"listChanged": true})
        val caps = ClientCapabilities.from_dict(dict)
        expect(caps.has_roots())

describe "ServerCapabilities":
    it "creates empty capabilities":
        val caps = ServerCapabilities(resources: nil, tools: nil, prompts: nil, logging: nil)
        expect(not caps.has_resources())
        expect(not caps.has_tools())
        expect(not caps.has_prompts())

    it "creates default capabilities":
        val caps = ServerCapabilities.default()
        expect(caps.has_resources())
        expect(caps.has_tools())
        expect(caps.has_prompts())
        expect(caps.has_logging())

    it "creates full capabilities":
        val caps = ServerCapabilities.full()
        expect(caps.supports_resource_subscribe())
        expect(caps.supports_resource_list_changed())
        expect(caps.supports_tool_list_changed())
        expect(caps.supports_prompt_list_changed())

    it "converts to dict":
        val caps = ServerCapabilities.default()
        val dict = caps.to_dict()
        expect(dict.has_key("resources"))
        expect(dict.has_key("tools"))
        expect(dict.has_key("prompts"))

    it "creates from dict":
        var dict: Dict<text, Any> = {}
        dict.set("resources", {"subscribe": true, "listChanged": true})
        dict.set("tools", {"listChanged": false})
        val caps = ServerCapabilities.from_dict(dict)
        expect(caps.has_resources())
        expect(caps.has_tools())

describe "ResourceCapabilities":
    it "creates default capabilities":
        val caps = ResourceCapabilities.default()
        expect(not caps.subscribe)
        expect(not caps.list_changed)

    it "creates full capabilities":
        val caps = ResourceCapabilities.full()
        expect(caps.subscribe)
        expect(caps.list_changed)

    it "converts to dict":
        val caps = ResourceCapabilities.full()
        val dict = caps.to_dict()
        expect(dict.get("subscribe") == true)
        expect(dict.get("listChanged") == true)

describe "CapabilityNegotiator":
    it "negotiates compatible versions":
        val server_caps = ServerCapabilities.default()
        val negotiator = CapabilityNegotiator(server_capabilities: server_caps)

        val client_caps = ClientCapabilities(roots: false, sampling: false, list_changed: false)
        val result = negotiator.negotiate(client_caps, "2024-11-05")

        match result:
            case Ok(negotiated):
                expect(negotiated.protocol_version == "2024-11-05")
            case Err(_):
                expect(false)

    it "rejects incompatible versions":
        val server_caps = ServerCapabilities.default()
        val negotiator = CapabilityNegotiator(server_capabilities: server_caps)

        val client_caps = ClientCapabilities(roots: false, sampling: false, list_changed: false)
        val result = negotiator.negotiate(client_caps, "2020-01-01")

        match result:
            case Ok(_):
                expect(false)
            case Err(msg):
                expect(msg.contains("Unsupported"))

    it "negotiates down to max supported version":
        val server_caps = ServerCapabilities.default()
        val negotiator = CapabilityNegotiator(server_capabilities: server_caps)

        val client_caps = ClientCapabilities(roots: false, sampling: false, list_changed: false)
        val result = negotiator.negotiate(client_caps, "2099-12-31")

        match result:
            case Ok(negotiated):
                # Should use max supported version
                expect(negotiated.protocol_version == "2025-11-25")
            case Err(_):
                expect(false)

describe "NegotiatedCapabilities":
    it "checks resource subscription support":
        val client = ClientCapabilities(roots: false, sampling: false, list_changed: false)
        val server = ServerCapabilities.full()
        val negotiated = NegotiatedCapabilities(client_capabilities: client, server_capabilities: server, protocol_version: "2024-11-05")

        expect(negotiated.can_subscribe_resources())

    it "checks roots support":
        val client = ClientCapabilities.full()
        val server = ServerCapabilities.default()
        val negotiated = NegotiatedCapabilities(client_capabilities: client, server_capabilities: server, protocol_version: "2024-11-05")

        expect(negotiated.can_use_roots())

    it "checks sampling support":
        val client = ClientCapabilities.full()
        val server = ServerCapabilities.default()
        val negotiated = NegotiatedCapabilities(client_capabilities: client, server_capabilities: server, protocol_version: "2024-11-05")

        expect(negotiated.can_use_sampling())

describe "InitializeRequest":
    it "creates with all fields":
        val caps = ClientCapabilities(roots: false, sampling: false, list_changed: false)
        val info = ClientInfo(name: "test-client", version: "1.0.0")
        val request = InitializeRequest(protocol_version: "2024-11-05", capabilities: caps, client_info: info)

        expect(request.protocol_version == "2024-11-05")
        expect(request.client_info.name == "test-client")

    it "converts to dict":
        val caps = ClientCapabilities(roots: false, sampling: false, list_changed: false)
        val info = ClientInfo(name: "test", version: "1.0")
        val request = InitializeRequest(protocol_version: "2024-11-05", capabilities: caps, client_info: info)
        val dict = request.to_dict()

        expect(dict.get("protocolVersion") == "2024-11-05")
        expect(dict.has_key("capabilities"))
        expect(dict.has_key("clientInfo"))

describe "InitializeResponse":
    it "creates with all fields":
        val caps = ServerCapabilities.default()
        val info = ServerInfo(name: "test-server", version: "2.0.0")
        val response = InitializeResponse(protocol_version: "2024-11-05", capabilities: caps, server_info: info, instructions: nil)

        expect(response.protocol_version == "2024-11-05")
        expect(response.server_info.name == "test-server")

    it "adds instructions":
        val caps = ServerCapabilities.default()
        val info = ServerInfo(name: "test", version: "1.0")
        val response = InitializeResponse(protocol_version: "2024-11-05", capabilities: caps, server_info: info, instructions: nil)
            .with_instructions("Please follow these guidelines...")

        match response.instructions:
            case Some(inst):
                expect(inst.contains("guidelines"))
            case nil:
                expect(false)

    it "converts to dict":
        val caps = ServerCapabilities.default()
        val info = ServerInfo(name: "test", version: "1.0")
        val response = InitializeResponse(protocol_version: "2024-11-05", capabilities: caps, server_info: info, instructions: nil)
        val dict = response.to_dict()

        expect(dict.get("protocolVersion") == "2024-11-05")
        expect(dict.has_key("capabilities"))
        expect(dict.has_key("serverInfo"))
