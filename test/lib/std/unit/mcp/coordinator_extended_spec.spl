"""
Debug Coordinator Extended Tests
Feature: Debug Backend Coordination - Lifecycle & Error Handling
Category: MCP, Debug
Status: In Progress

Extended tests for DebugCoordinator routing, backend lifecycle,
error propagation, and multi-backend scenarios.
"""


# ----------- Inline type definitions -----------

class FrameInfo:
    index: Int
    function_name: String
    file: String
    line: Int
    column: Int

    static fn of(index: Int, function_name: String, file: String, line: Int) -> FrameInfo:
        FrameInfo(index: index, function_name: function_name, file: file, line: line, column: 0)

class VarInfo:
    name: String
    value: String
    type_name: String

    static fn of(name: String, value: String, type_name: String) -> VarInfo:
        VarInfo(name: name, value: value, type_name: type_name)

class LocationInfo:
    file: String
    line: Int
    column: Int
    function_name: String

    static fn at(file: String, line: Int, function_name: String) -> LocationInfo:
        LocationInfo(file: file, line: line, column: 0, function_name: function_name)

# Mock backend with error injection
class MockBackend:
    name_val: String
    attached: Bool
    running: Bool
    paused: Bool
    breakpoints: List<String>
    step_count: Int
    last_step_mode: String
    fail_attach: Bool
    fail_run: Bool

    static fn create(name: String) -> MockBackend:
        MockBackend(
            name_val: name,
            attached: false,
            running: false,
            paused: false,
            breakpoints: [],
            step_count: 0,
            last_step_mode: "",
            fail_attach: false,
            fail_run: false
        )

    static fn failing(name: String) -> MockBackend:
        MockBackend(
            name_val: name,
            attached: false,
            running: false,
            paused: false,
            breakpoints: [],
            step_count: 0,
            last_step_mode: "",
            fail_attach: true,
            fail_run: true
        )

impl MockBackend:
    fn name() -> String:
        self.name_val

    me attach(program_path: String, args: List<String>) -> Result<Nil, String>:
        if self.fail_attach:
            return Err("Attach failed: {program_path}")
        self.attached = true
        Ok(nil)

    me detach() -> Result<Nil, String>:
        self.attached = false
        self.running = false
        Ok(nil)

    me run() -> Result<Nil, String>:
        if not self.attached:
            return Err("Not attached")
        if self.fail_run:
            return Err("Run failed")
        self.running = true
        Ok(nil)

    me pause() -> Result<Nil, String>:
        self.paused = true
        self.running = false
        Ok(nil)

    me resume() -> Result<Nil, String>:
        self.paused = false
        self.running = true
        Ok(nil)

    me step_over() -> Result<Nil, String>:
        self.step_count = self.step_count + 1
        self.last_step_mode = "over"
        Ok(nil)

    me step_in() -> Result<Nil, String>:
        self.step_count = self.step_count + 1
        self.last_step_mode = "in"
        Ok(nil)

    me step_out() -> Result<Nil, String>:
        self.step_count = self.step_count + 1
        self.last_step_mode = "out"
        Ok(nil)

    me add_breakpoint(file: String, line: Int) -> Result<Int, String>:
        val key = "{file}:{line}"
        self.breakpoints.push(key)
        Ok(self.breakpoints.len())

    me remove_breakpoint(file: String, line: Int) -> Result<Nil, String>:
        val key = "{file}:{line}"
        self.breakpoints = self.breakpoints.filter(\bp: bp != key)
        Ok(nil)

    fn stack_trace() -> Result<List<FrameInfo>, String>:
        Ok([
            FrameInfo.of(0, "main", "test.spl", 1),
            FrameInfo.of(1, "helper", "test.spl", 10),
            FrameInfo.of(2, "deep", "lib.spl", 42)
        ])

    fn locals() -> Result<List<VarInfo>, String>:
        Ok([
            VarInfo.of("x", "42", "Int"),
            VarInfo.of("name", "Alice", "String"),
            VarInfo.of("flag", "true", "Bool")
        ])

    fn evaluate(expr: String) -> Result<String, String>:
        if expr == "error":
            return Err("Evaluation failed")
        Ok("(result of {expr})")

    fn current_location() -> Result<LocationInfo, String>:
        Ok(LocationInfo.at("test.spl", 5, "main"))

# ----------- Tests -----------

describe "MockBackend lifecycle":
    context "attach and run":
        it "full lifecycle: attach -> run -> pause -> resume -> detach":
            var backend = MockBackend.create("test")
            backend.attach("prog.spl", [])
            expect(backend.attached)
            backend.run()
            expect(backend.running)
            backend.pause()
            expect(backend.paused)
            expect(not backend.running)
            backend.resume()
            expect(backend.running)
            expect(not backend.paused)
            backend.detach()
            expect(not backend.attached)
            expect(not backend.running)

        it "fails to run when not attached":
            var backend = MockBackend.create("test")
            match backend.run():
                case Ok(_): expect(false)
                case Err(e): expect(e == "Not attached")

    context "error injection":
        it "failing backend returns attach error":
            var backend = MockBackend.failing("fail")
            match backend.attach("prog.spl", []):
                case Ok(_): expect(false)
                case Err(e): expect(e.contains("Attach failed"))

        it "failing backend returns run error after forced attach":
            var backend = MockBackend.failing("fail")
            backend.fail_attach = false
            backend.attach("prog.spl", [])
            match backend.run():
                case Ok(_): expect(false)
                case Err(e): expect(e.contains("Run failed"))

describe "MockBackend stepping":
    it "step modes are independent":
        var backend = MockBackend.create("test")
        backend.step_over()
        expect(backend.last_step_mode == "over")
        backend.step_in()
        expect(backend.last_step_mode == "in")
        backend.step_out()
        expect(backend.last_step_mode == "out")

    it "step count accumulates correctly":
        var backend = MockBackend.create("test")
        backend.step_over()
        backend.step_over()
        backend.step_in()
        backend.step_out()
        backend.step_over()
        expect(backend.step_count == 5)

describe "MockBackend breakpoints":
    it "adds breakpoints with increasing ids":
        var backend = MockBackend.create("test")
        match backend.add_breakpoint("test.spl", 10):
            case Ok(id1):
                match backend.add_breakpoint("test.spl", 20):
                    case Ok(id2): expect(id2 > id1)
                    case Err(_): expect(false)
            case Err(_): expect(false)

    it "removes specific breakpoint":
        var backend = MockBackend.create("test")
        backend.add_breakpoint("test.spl", 10)
        backend.add_breakpoint("test.spl", 20)
        backend.add_breakpoint("test.spl", 30)
        backend.remove_breakpoint("test.spl", 20)
        expect(backend.breakpoints.len() == 2)

    it "remove non-existent breakpoint is safe":
        var backend = MockBackend.create("test")
        backend.add_breakpoint("test.spl", 10)
        backend.remove_breakpoint("other.spl", 99)
        expect(backend.breakpoints.len() == 1)

    it "clear all breakpoints by removing each":
        var backend = MockBackend.create("test")
        backend.add_breakpoint("a.spl", 1)
        backend.add_breakpoint("b.spl", 2)
        backend.add_breakpoint("c.spl", 3)
        backend.remove_breakpoint("a.spl", 1)
        backend.remove_breakpoint("b.spl", 2)
        backend.remove_breakpoint("c.spl", 3)
        expect(backend.breakpoints.len() == 0)

describe "MockBackend inspection":
    context "stack trace":
        it "returns three frames":
            val backend = MockBackend.create("test")
            match backend.stack_trace():
                case Ok(frames):
                    expect(frames.len() == 3)
                case Err(_): expect(false)

        it "frames have correct indices":
            val backend = MockBackend.create("test")
            match backend.stack_trace():
                case Ok(frames):
                    expect(frames[0].index == 0)
                    expect(frames[1].index == 1)
                    expect(frames[2].index == 2)
                case Err(_): expect(false)

        it "frames span multiple files":
            val backend = MockBackend.create("test")
            match backend.stack_trace():
                case Ok(frames):
                    expect(frames[0].file == "test.spl")
                    expect(frames[2].file == "lib.spl")
                case Err(_): expect(false)

    context "locals":
        it "returns three variables":
            val backend = MockBackend.create("test")
            match backend.locals():
                case Ok(vars):
                    expect(vars.len() == 3)
                case Err(_): expect(false)

        it "variables have correct types":
            val backend = MockBackend.create("test")
            match backend.locals():
                case Ok(vars):
                    expect(vars[0].type_name == "Int")
                    expect(vars[1].type_name == "String")
                    expect(vars[2].type_name == "Bool")
                case Err(_): expect(false)

        it "variables have correct values":
            val backend = MockBackend.create("test")
            match backend.locals():
                case Ok(vars):
                    expect(vars[0].value == "42")
                    expect(vars[1].value == "Alice")
                case Err(_): expect(false)

    context "evaluate":
        it "evaluates simple expression":
            val backend = MockBackend.create("test")
            match backend.evaluate("x + 1"):
                case Ok(result): expect(result.contains("x + 1"))
                case Err(_): expect(false)

        it "returns error for error expression":
            val backend = MockBackend.create("test")
            match backend.evaluate("error"):
                case Ok(_): expect(false)
                case Err(e): expect(e.contains("Evaluation failed"))

    context "location":
        it "returns current file and line":
            val backend = MockBackend.create("test")
            match backend.current_location():
                case Ok(loc):
                    expect(loc.file == "test.spl")
                    expect(loc.line == 5)
                    expect(loc.function_name == "main")
                case Err(_): expect(false)

        it "location has zero column default":
            val backend = MockBackend.create("test")
            match backend.current_location():
                case Ok(loc): expect(loc.column == 0)
                case Err(_): expect(false)

describe "FrameInfo":
    it "creates with all fields":
        val f = FrameInfo.of(3, "process", "worker.spl", 99)
        expect(f.index == 3)
        expect(f.function_name == "process")
        expect(f.file == "worker.spl")
        expect(f.line == 99)
        expect(f.column == 0)

describe "VarInfo":
    it "stores name value and type":
        val v = VarInfo.of("counter", "100", "Int")
        expect(v.name == "counter")
        expect(v.value == "100")
        expect(v.type_name == "Int")

describe "LocationInfo":
    it "stores file line and function":
        val loc = LocationInfo.at("app.spl", 42, "handle_request")
        expect(loc.file == "app.spl")
        expect(loc.line == 42)
        expect(loc.function_name == "handle_request")
        expect(loc.column == 0)
