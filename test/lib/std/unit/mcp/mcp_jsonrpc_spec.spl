"""
MCP JSON-RPC Protocol Integration Tests
Feature: MCP JSON-RPC Request Routing
Category: MCP, Protocol, Integration
Status: In Progress

Integration tests for the MCP server's JSON-RPC request routing,
including initialize handshake, tool listing, tool calling,
shutdown, and error handling.
"""

import std.spec

# ----------- Inline reimplementations -----------

fn LB() -> String:
    123 as char

fn RB() -> String:
    125 as char

fn unwrap_idx(opt) -> Int:
    match opt:
        case Some(i):
            return i
        case None:
            return -1

fn extract_json_string(json: String, key: String) -> String:
    val search = "\"" + key + "\":"
    val idx = unwrap_idx(json.index_of(search))
    if idx < 0:
        return ""
    val slen = search.len()
    val start = idx + slen
    val after = json.substring(start)
    val trimmed = after.trim()
    if trimmed.starts_with("\""):
        val rest = trimmed.substring(1)
        val end = unwrap_idx(rest.index_of("\""))
        if end >= 0:
            return rest.substring(0, end)
    ""

fn extract_json_value(json: String, key: String) -> String:
    val search = "\"" + key + "\":"
    val idx = unwrap_idx(json.index_of(search))
    if idx < 0:
        return "null"
    val slen = search.len()
    val start = idx + slen
    val after = json.substring(start)
    val trimmed = after.trim()
    var end = 0
    for ch in trimmed:
        if ch == "," or ch == RB() or ch == "]":
            break
        end = end + 1
    trimmed.substring(0, end).trim()

fn extract_nested_string(json: String, outer_key: String, inner_key: String) -> String:
    val search = "\"" + outer_key + "\":"
    val idx = unwrap_idx(json.index_of(search))
    if idx < 0:
        return ""
    val slen = search.len()
    val start = idx + slen
    val after = json.substring(start)
    extract_json_string(after, inner_key)

fn escape_json(text: String) -> String:
    var result = text
    result = result.replace("\\", "\\\\")
    result = result.replace("\"", "\\\"")
    result = result.replace("\n", "\\n")
    result = result.replace("\r", "\\r")
    result = result.replace("\t", "\\t")
    result

fn jobj(pairs: List<String>) -> String:
    var r = LB()
    var first = true
    for p in pairs:
        if not first:
            r = r + ","
        r = r + p
        first = false
    r + RB()

fn jpair(key: String, val_str: String) -> String:
    "\"" + key + "\":" + val_str

fn jstr(s: String) -> String:
    "\"" + s + "\""

fn make_initialize_response(id: String) -> String:
    val server_info = jobj([jpair("name", jstr("simple-mcp")), jpair("version", jstr("1.0.0"))])
    val caps = jobj([jpair("tools", jobj([]))])
    val result = jobj([jpair("protocolVersion", jstr("2024-11-05")), jpair("capabilities", caps), jpair("serverInfo", server_info)])
    jobj([jpair("jsonrpc", jstr("2.0")), jpair("id", id), jpair("result", result)])

fn make_tool_result(id: String, content: String) -> String:
    val text_obj = jobj([jpair("type", jstr("text")), jpair("text", jstr(content))])
    val result = jobj([jpair("content", "[" + text_obj + "]")])
    jobj([jpair("jsonrpc", jstr("2.0")), jpair("id", id), jpair("result", result)])

fn make_result_response(id: String, result: String) -> String:
    jobj([jpair("jsonrpc", jstr("2.0")), jpair("id", id), jpair("result", result)])

fn make_error_response(id: String, code: Int, message: String) -> String:
    val err = jobj([jpair("code", code.to_string()), jpair("message", jstr(escape_json(message)))])
    jobj([jpair("jsonrpc", jstr("2.0")), jpair("id", id), jpair("error", err)])

fn make_tools_list_response(id: String) -> String:
    val t1 = jobj([jpair("name", jstr("read_code")), jpair("description", jstr("Read a Simple language source file"))])
    val t2 = jobj([jpair("name", jstr("list_files")), jpair("description", jstr("List Simple language files"))])
    val t3 = jobj([jpair("name", jstr("search_code")), jpair("description", jstr("Search for code patterns"))])
    val t4 = jobj([jpair("name", jstr("file_info")), jpair("description", jstr("Get file information"))])
    val tools = "[" + t1 + "," + t2 + "," + t3 + "," + t4 + "]"
    jobj([jpair("jsonrpc", jstr("2.0")), jpair("id", id), jpair("result", jobj([jpair("tools", tools)]))])

# Simulate handle_jsonrpc without FFI dependencies
fn handle_jsonrpc(body: String) -> String:
    val method = extract_json_string(body, "method")
    val id = extract_json_value(body, "id")

    if method == "initialize":
        return make_initialize_response(id)
    elif method == "initialized":
        return ""
    elif method == "shutdown":
        return make_result_response(id, "null")
    elif method == "tools/list":
        return make_tools_list_response(id)
    elif method == "tools/call":
        val tool_name = extract_nested_string(body, "params", "name")
        if tool_name == "read_code":
            val path = extract_nested_string(body, "arguments", "path")
            val escaped = escape_json("(mock content of " + path + ")")
            return make_tool_result(id, escaped)
        elif tool_name == "file_info":
            return make_tool_result(id, "File: test.spl")
        elif tool_name == "list_files":
            return make_tool_result(id, "file1.spl\\nfile2.spl")
        elif tool_name == "search_code":
            val query = extract_nested_string(body, "arguments", "query")
            return make_tool_result(id, "Results for: " + query)
        else:
            return make_error_response(id, -32602, "Unknown tool: " + tool_name)
    else:
        return make_error_response(id, -32601, "Method not found: " + method)

# Helper to build JSON-RPC request strings
fn make_req(id: String, method: String) -> String:
    jobj([jpair("jsonrpc", jstr("2.0")), jpair("id", id), jpair("method", jstr(method))])

fn make_req_params(id: String, method: String, params: String) -> String:
    jobj([jpair("jsonrpc", jstr("2.0")), jpair("id", id), jpair("method", jstr(method)), jpair("params", params)])

fn make_tool_call_req(id: String, tool: String, args: String) -> String:
    val params = jobj([jpair("name", jstr(tool)), jpair("arguments", args)])
    make_req_params(id, "tools/call", params)

# ----------- Tests -----------

describe "JSON-RPC Protocol":
    context "initialize handshake":
        it "responds to initialize request":
            val req = make_req_params("1", "initialize", jobj([]))
            val resp = handle_jsonrpc(req)
            expect(resp.contains("\"jsonrpc\""))
            expect(resp.contains("\"id\":1"))
            expect(resp.contains("\"protocolVersion\""))

        it "returns empty for initialized notification":
            val req = jobj([jpair("jsonrpc", jstr("2.0")), jpair("method", jstr("initialized"))])
            val resp = handle_jsonrpc(req)
            expect(resp == "")

        it "handles initialize with string id":
            val req = make_req("\"abc\"", "initialize")
            val resp = handle_jsonrpc(req)
            expect(resp.contains("\"protocolVersion\""))

    context "shutdown":
        it "responds to shutdown with null result":
            val req = make_req("5", "shutdown")
            val resp = handle_jsonrpc(req)
            expect(resp.contains("\"result\":null"))
            expect(resp.contains("\"id\":5"))

    context "tools/list":
        it "returns list of available tools":
            val req = make_req("2", "tools/list")
            val resp = handle_jsonrpc(req)
            expect(resp.contains("\"read_code\""))
            expect(resp.contains("\"list_files\""))
            expect(resp.contains("\"search_code\""))
            expect(resp.contains("\"file_info\""))

    context "tools/call":
        it "calls read_code tool":
            val req = make_tool_call_req("3", "read_code", jobj([jpair("path", jstr("test.spl"))]))
            val resp = handle_jsonrpc(req)
            expect(resp.contains("\"content\""))
            expect(resp.contains("\"type\":\"text\""))

        it "calls file_info tool":
            val req = make_tool_call_req("4", "file_info", jobj([jpair("path", jstr("test.spl"))]))
            val resp = handle_jsonrpc(req)
            expect(resp.contains("\"content\""))

        it "calls list_files tool":
            val req = make_tool_call_req("5", "list_files", jobj([jpair("path", jstr("."))]))
            val resp = handle_jsonrpc(req)
            expect(resp.contains("\"content\""))

        it "calls search_code tool":
            val req = make_tool_call_req("6", "search_code", jobj([jpair("query", jstr("fn main"))]))
            val resp = handle_jsonrpc(req)
            expect(resp.contains("\"content\""))

        it "returns error for unknown tool":
            val req = make_tool_call_req("7", "nonexistent", jobj([]))
            val resp = handle_jsonrpc(req)
            expect(resp.contains("\"error\""))
            expect(resp.contains("-32602"))
            expect(resp.contains("Unknown tool"))

    context "error handling":
        it "returns method not found for unknown method":
            val req = make_req("10", "unknown/method")
            val resp = handle_jsonrpc(req)
            expect(resp.contains("\"error\""))
            expect(resp.contains("-32601"))
            expect(resp.contains("Method not found"))

        it "returns method not found for empty method":
            val req = make_req("11", "")
            val resp = handle_jsonrpc(req)
            expect(resp.contains("\"error\""))

    context "response format":
        it "all responses contain jsonrpc version":
            val init = handle_jsonrpc(make_req("1", "initialize"))
            val tools = handle_jsonrpc(make_req("2", "tools/list"))
            val shutdown = handle_jsonrpc(make_req("3", "shutdown"))
            expect(init.contains("\"jsonrpc\""))
            expect(tools.contains("\"jsonrpc\""))
            expect(shutdown.contains("\"jsonrpc\""))

        it "all responses contain request id":
            val resp = handle_jsonrpc(make_req("99", "shutdown"))
            expect(resp.contains("\"id\":99"))

        it "tool results use content array format":
            val req = make_tool_call_req("1", "file_info", jobj([jpair("path", jstr("x"))]))
            val resp = handle_jsonrpc(req)
            expect(resp.contains("\"content\":["))
            expect(resp.contains("\"type\":\"text\""))

        it "error responses have code and message":
            val resp = handle_jsonrpc(make_req("1", "bad"))
            expect(resp.contains("\"code\":"))
            expect(resp.contains("\"message\":"))
