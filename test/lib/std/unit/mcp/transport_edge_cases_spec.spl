# @pending
# @skip - Uses unsupported keyword: with
"""
MCP Transport Edge Cases Tests
Feature: MCP Transport Error Handling
Category: MCP, Transport, Error Handling
Status: Complete

Tests for edge cases, error conditions, and crash prevention in transport layer.
"""

# @slow
# Performance note: ~1.5 seconds runtime. Exclude for quick dev cycles.

use std.mcp.core.transport.*
use std.mcp.core.protocol.*
use std.mcp.core.error_handler.*

# Error code constants (re-declared for test access)
val ERROR_VALIDATION: i64 = -32002

describe "StdioTransport - negative content length":
    it "rejects negative content length in header":
        var transport = StdioTransport.new()

        # Try to parse invalid header with negative length
        val result = transport.parse_content_length("Content-Length: -100")

        expect(result.is_none())

describe "StdioTransport - excessive content length":
    it "rejects content length exceeding limit":
        var transport = StdioTransport.new()

        # Try to parse header with excessive length (>10MB)
        val result = transport.parse_content_length("Content-Length: 20000000")

        expect(result.is_none())

    it "accepts content length at exact limit":
        var transport = StdioTransport.new()

        val result = transport.parse_content_length("Content-Length: 10000000")

        expect(result.?)

describe "StdioTransport - malformed content length":
    it "handles non-numeric content length":
        var transport = StdioTransport.new()

        val result = transport.parse_content_length("Content-Length: abc")

        # Should parse as 0 and be rejected
        expect(result.is_none() or result.unwrap() == 0)

    it "handles content length with trailing garbage":
        var transport = StdioTransport.new()

        val result = transport.parse_content_length("Content-Length: 123abc")

        # Should parse first 123, then stop
        match result:
            case Some(len):
                expect(len == 123)
            case None:
                fail("Should parse partial number")

    it "handles content length with spaces":
        var transport = StdioTransport.new()

        val result = transport.parse_content_length("Content-Length:  456  ")

        match result:
            case Some(len):
                expect(len == 456)
            case None:
                fail("Should handle spaces")

describe "StdioTransport - malformed JSON":
    it "rejects invalid JSON":
        var transport = StdioTransport.new()

        val result = transport.parse_request(r"{invalid json}")

        expect(result.err.?)

    it "rejects JSON with missing method":
        var transport = StdioTransport.new()

        val result = transport.parse_request("{\"id\": 1, \"params\": {}}")

        expect(result.err.?)
        match result:
            case Err(msg):
                expect(msg.contains("method"))
            case _:
                fail("Expected error")

    it "handles JSON with invalid method type":
        var transport = StdioTransport.new()

        val result = transport.parse_request("{\"id\": 1, \"method\": 123}")

        expect(result.err.?)

    it "handles non-object JSON":
        var transport = StdioTransport.new()

        val result = transport.parse_request("[1, 2, 3]")

        expect(result.err.?)
        match result:
            case Err(msg):
                expect(msg.contains("object"))
            case _:
                fail("Expected error")

describe "StdioTransport - ID handling":
    it "handles integer ID":
        var transport = StdioTransport.new()

        val result = transport.parse_request("{\"id\": 42, \"method\": \"test\"}")

        match result:
            case Ok(request):
                expect(request.id == 42)
            case _:
                fail("Should parse integer ID")

    it "handles string ID as zero":
        var transport = StdioTransport.new()

        val result = transport.parse_request("{\"id\": \"abc\", \"method\": \"test\"}")

        match result:
            case Ok(request):
                expect(request.id == 0)
            case _:
                fail("Should accept string ID")

    it "handles missing ID":
        var transport = StdioTransport.new()

        val result = transport.parse_request("{\"method\": \"test\"}")

        match result:
            case Ok(request):
                expect(request.id == 0)
            case _:
                fail("Should accept missing ID")

describe "StdioTransport - params handling":
    it "handles missing params":
        var transport = StdioTransport.new()

        val result = transport.parse_request("{\"id\": 1, \"method\": \"test\"}")

        match result:
            case Ok(request):
                expect(request.params.is_empty())
            case _:
                fail("Should accept missing params")

    it "handles empty params object":
        var transport = StdioTransport.new()

        val result = transport.parse_request("{\"id\": 1, \"method\": \"test\", \"params\": {}}")

        match result:
            case Ok(request):
                expect(request.params.is_empty())
            case _:
                fail("Should accept empty params")

    it "handles non-object params":
        var transport = StdioTransport.new()

        val result = transport.parse_request("{\"id\": 1, \"method\": \"test\", \"params\": \"invalid\"}")

        match result:
            case Ok(request):
                # Non-object params are ignored
                expect(request.params.is_empty())
            case _:
                fail("Should ignore non-object params")

describe "MockTransport - out of bounds":
    it "returns None when no requests available":
        var transport = MockTransport.new([])

        val result = transport.read_message()

        expect(result.is_none())

    it "returns None after all requests consumed":
        val req = JsonRpcRequest(id: 1, method: "test", params: {})
        var transport = MockTransport.new([req])

        # First read succeeds
        expect(transport.read_message().?)

        # Second read returns None
        expect(not transport.read_message().?)

describe "MockTransport - add_json_request":
    it "parses and adds valid JSON request":
        var transport = MockTransport.new([])

        val result = transport.add_json_request("{\"id\": 1, \"method\": \"ping\"}")

        expect(result.ok.?)
        expect(transport.requests.len() == 1)

    it "rejects invalid JSON":
        var transport = MockTransport.new([])

        val result = transport.add_json_request(r"{invalid}")

        expect(result.err.?)

    it "rejects non-object JSON":
        var transport = MockTransport.new([])

        val result = transport.add_json_request("\"string\"")

        expect(result.err.?)

describe "Transport - alive status":
    it "StdioTransport starts alive":
        var transport = StdioTransport.new()
        expect(transport.is_alive())

    it "MockTransport is alive when requests remain":
        val req = JsonRpcRequest(id: 1, method: "test", params: {})
        var transport = MockTransport.new([req])
        expect(transport.is_alive())

    it "MockTransport is not alive when requests exhausted":
        var transport = MockTransport.new([])
        expect(not transport.is_alive())

describe "Error tracking":
    it "tracks error count in StdioTransport":
        var transport = StdioTransport.new()

        # Initial error count is zero
        expect(transport.error_count == 0)

        # Trigger error by parsing invalid content length
        transport.parse_content_length("Content-Length: -1")

        # Error count should increment
        expect(transport.error_count > 0)

describe "Debug mode":
    it "can enable debug mode":
        var transport = StdioTransport.new()
        expect(not transport.debug_mode)

        transport.enable_debug()
        expect(transport.debug_mode)

describe "Response serialization":
    it "serializes response with result":
        var transport = StdioTransport.new()
        val response = JsonRpcResponse(id: 1, result: {"status": "ok"})

        val json = transport.serialize_response(response)

        expect(json.contains("\"jsonrpc\":\"2.0\""))
        expect(json.contains("\"id\":1"))
        expect(json.contains("\"result\""))

    it "serializes error response":
        var transport = StdioTransport.new()

        val json = transport.serialize_error(1, -32600, "Invalid request")

        expect(json.contains("\"jsonrpc\":\"2.0\""))
        expect(json.contains("\"id\":1"))
        expect(json.contains("\"error\""))
        expect(json.contains("\"code\":-32600"))
        expect(json.contains("\"message\":\"Invalid request\""))

describe "Content-Length header format":
    it "parses standard header":
        var transport = StdioTransport.new()

        val result = transport.parse_content_length("Content-Length: 123")

        match result:
            case Some(len):
                expect(len == 123)
            case _:
                fail("Should parse standard header")

    it "rejects header without colon":
        var transport = StdioTransport.new()

        val result = transport.parse_content_length("Content-Length 123")

        expect(result.is_none())

    it "rejects completely wrong header":
        var transport = StdioTransport.new()

        val result = transport.parse_content_length("X-Custom-Header: 123")

        expect(result.is_none())

describe "Zero-length content":
    it "accepts zero content length":
        var transport = StdioTransport.new()

        val result = transport.parse_content_length("Content-Length: 0")

        match result:
            case Some(len):
                expect(len == 0)
            case _:
                fail("Should accept zero")

describe "Large valid requests":
    it "accepts request at size limit":
        var transport = StdioTransport.new()

        # Just under 1MB string limit
        val large_json = "{\"id\": 1, \"method\": \"test\", \"params\": {}}"
        val result = transport.parse_request(large_json)

        expect(result.ok.?)

describe "Validator integration":
    it "uses validator for content length":
        var transport = StdioTransport.new()

        # This should fail validation (>10MB)
        val result = transport.parse_content_length("Content-Length: 50000000")

        expect(result.is_none())

    it "uses validator for JSON parsing":
        var transport = StdioTransport.new()

        # Valid JSON but let's check it validates
        val result = transport.parse_request("{\"id\": 1, \"method\": \"test\"}")

        expect(result.ok.?)
