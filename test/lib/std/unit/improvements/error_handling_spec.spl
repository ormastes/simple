# Error Handling Improvement Tests
# Tests for error handling stdlib improvements (? operator)

import std.spec

describe "Error Handling Improvements":

    context "Question Mark Operator":
        # Helper functions for ? operator testing
        fn safe_divide(a: i64, b: i64) -> Result<i64, text>:
            if b == 0:
                return Err("division by zero")
            return Ok(a / b)

        fn wrapper_divide(a: i64, b: i64) -> Result<i64, text>:
            val result = safe_divide(a=a, b=b)?
            return Ok(result * 2)

        fn find_item(items: [i64], target: i64) -> Option<i64>:
            for i in 0..items.len():
                if items[i] == target:
                    return Some(i)
            return None

        fn get_doubled_index(items: [i64], target: i64) -> Option<i64>:
            val idx = find_item(items=items, target=target)?
            return Some(idx * 2)

        fn chain_operations(a: i64, b: i64, c: i64) -> Result<i64, text>:
            val step1 = safe_divide(a=a, b=b)?
            val step2 = safe_divide(a=step1, b=c)?
            return Ok(step2)

        it "propagates Result errors":
            # Test that ? propagates Err values
            val success = wrapper_divide(a=10, b=2)
            expect success.is_ok() == true
            expect success.unwrap() == 10

            val failure = wrapper_divide(a=10, b=0)
            expect failure.is_err() == true

        it "propagates Option None":
            # Test that ? propagates None values
            val items = [10, 20, 30]

            val found = get_doubled_index(items=items, target=20)
            expect found.is_some() == true
            expect found.unwrap() == 2  # index 1 * 2

            val not_found = get_doubled_index(items=items, target=99)
            expect not_found.is_none() == true

        it "chains multiple ? operations":
            # Test chaining multiple ? in sequence
            val success = chain_operations(a=100, b=5, c=2)
            # 100 / 5 = 20, 20 / 2 = 10
            expect success.is_ok() == true
            expect success.unwrap() == 10

            # First division fails
            val fail_first = chain_operations(a=100, b=0, c=2)
            expect fail_first.is_err() == true

            # Second division fails
            val fail_second = chain_operations(a=100, b=5, c=0)
            expect fail_second.is_err() == true
