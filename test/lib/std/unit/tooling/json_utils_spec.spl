"""
# JSON Utilities Specification

**Feature IDs:** #JSON-001 to #JSON-020
**Category:** Tooling | Data Format
**Difficulty:** 2/5
**Status:** In Progress

## Overview

This specification covers JSON utility functions for formatting, parsing, and building JSON structures:
1. JSON value formatting (string, number, boolean, null)
2. JSON array and object construction
3. JSON builder classes for fluent API
4. Common JSON patterns (API responses, pagination)
5. JSON validation (structure, balance checking)

## Key Concepts

| Concept | Description |
|---------|-------------|
| JSON Formatting | Convert values to JSON-compliant text |
| Escaping | Handle special characters and escape sequences |
| Builder Pattern | Fluent API for constructing complex structures |
| Validation | Check JSON structure validity |
| Common Patterns | API responses, pagination metadata |

## Behavior

- String values are properly escaped and quoted
- Null values produce "null" text
- Booleans produce "true" or "false"
- Numbers are converted to string representation
- Builders provide mutable construction API
- Validation checks for balanced braces and valid structure
"""

use std.spec

# =====================================
# JSON Utility Implementations
# =====================================

fn json_string(s: text) -> text:
    var escaped = s
    escaped = escaped.replace("\\", "\\\\")
    escaped = escaped.replace("\"", "\\\"")
    escaped = escaped.replace("\n", "\\n")
    "\"" + escaped + "\""

fn json_number(n: i64) -> text:
    n.to_string()

fn json_bool(b: bool) -> text:
    if b: "true" else: "false"

fn json_null() -> text:
    "null"

fn json_array_strings(items: [text]) -> text:
    var parts: [text] = []
    for item in items:
        parts = parts + [json_string(item)]
    "[" + parts.join(", ") + "]"

fn json_array_numbers(items: [i64]) -> text:
    var parts: [text] = []
    for item in items:
        parts = parts + [item.to_string()]
    "[" + parts.join(", ") + "]"

fn json_array(items: [text]) -> text:
    "[" + items.join(", ") + "]"

fn json_pair(key: text, value: text) -> text:
    json_string(key) + ": " + value

fn json_object(pairs: [(text, text)]) -> text:
    if pairs.len() == 0: return r"{}"
    var parts: [text] = []
    for pair in pairs:
        parts = parts + [json_pair(key=pair.0, value=pair.1)]
    r"{" + parts.join(", ") + r"}"

class JsonBuilder:
    pairs: [(text, text)]

impl JsonBuilder:
    static fn create() -> JsonBuilder:
        JsonBuilder(pairs: [])

    me add_string(key: text, value: text):
        self.pairs = self.pairs + [(key, json_string(value))]

    me add_number(key: text, value: i64):
        self.pairs = self.pairs + [(key, json_number(value))]

    me add_bool(key: text, value: bool):
        self.pairs = self.pairs + [(key, json_bool(value))]

    me add_null(key: text):
        self.pairs = self.pairs + [(key, json_null())]

    me add_array(key: text, items: [text]):
        self.pairs = self.pairs + [(key, json_array(items))]

    me add_raw(key: text, raw_json: text):
        self.pairs = self.pairs + [(key, raw_json)]

    fn build() -> text:
        json_object(self.pairs)

class JsonArrayBuilder:
    items: [text]

impl JsonArrayBuilder:
    static fn create() -> JsonArrayBuilder:
        JsonArrayBuilder(items: [])

    me add_string(s: text):
        self.items = self.items + [json_string(s)]

    me add_number(n: i64):
        self.items = self.items + [json_number(n)]

    me add_bool(b: bool):
        self.items = self.items + [json_bool(b)]

    me add_null():
        self.items = self.items + [json_null()]

    fn build() -> text:
        json_array(self.items)

fn json_success(message: text) -> text:
    var builder = JsonBuilder.create()
    builder.add_string(key="status", value="success")
    builder.add_string(key="message", value=message)
    builder.build()

fn json_error(message: text, code: i64) -> text:
    var builder = JsonBuilder.create()
    builder.add_string(key="status", value="error")
    builder.add_string(key="message", value=message)
    builder.add_number("code", code)
    builder.build()

fn json_data(data: text) -> text:
    var builder = JsonBuilder.create()
    builder.add_string(key="status", value="success")
    builder.add_raw(key="data", raw_json=data)
    builder.build()

fn looks_like_json(s: text) -> bool:
    if s.len() == 0:
        return false
    val trimmed = s.trim()
    if trimmed.len() == 0:
        return false
    val first_char = trimmed.chars()[0]
    # Compare char codes: 123 = '{', 91 = '['
    val code = first_char as i64
    code == 123 or code == 91

fn has_balanced_braces(s: text) -> bool:
    var brace_count = 0
    var bracket_count = 0
    # Char codes: '{' = 123, '}' = 125, '[' = 91, ']' = 93
    for c in s.chars():
        val code = c as i64
        if code == 123:
            brace_count = brace_count + 1
        if code == 125:
            brace_count = brace_count - 1
        if code == 91:
            bracket_count = bracket_count + 1
        if code == 93:
            bracket_count = bracket_count - 1
        if brace_count < 0 or bracket_count < 0:
            return false
    brace_count == 0 and bracket_count == 0

fn api_response(success: bool, message: text, data: Option<text>) -> text:
    var builder = JsonBuilder.create()
    builder.add_bool("success", success)
    builder.add_string(key="message", value=message)
    match data:
        case Some(d): builder.add_raw(key="data", raw_json=d)
        case nil: builder.add_null("data")
    builder.build()

fn pagination_meta(page: i64, per_page: i64, total: i64) -> text:
    val total_pages = (total + per_page - 1) / per_page
    var builder = JsonBuilder.create()
    builder.add_number("page", page)
    builder.add_number("per_page", per_page)
    builder.add_number("total", total)
    builder.add_number("total_pages", total_pages)
    builder.build()

fn timestamp_json(unix: i64, iso: text) -> text:
    var builder = JsonBuilder.create()
    builder.add_number("unix", unix)
    builder.add_string(key="iso", value=iso)
    builder.build()

# =====================================
# BDD Tests
# =====================================

describe "JSON Utilities":
    """
    ## JSON Formatting and Building

    Verifies JSON utility implementations for formatting values, building
    objects and arrays, and validating JSON structure.
    """

    describe "JSON Value Formatting":
        """
        ## JSON Primitive Formatting

        Tests conversion of primitive values to JSON format.
        """

        it "formats string":
            expect json_string("hello") == "\"hello\""

        it "escapes quotes in string":
            val result = json_string("She said \"hi\"")
            expect result.contains("\\\"")

        it "escapes newlines in string":
            val result = json_string("line1\nline2")
            expect result.contains("\\n")

        it "formats number":
            expect json_number(42) == "42"
            expect json_number(-10) == "-10"

        it "formats boolean":
            expect json_bool(true) == "true"
            expect json_bool(false) == "false"

        it "formats null":
            expect json_null() == "null"

    describe "JSON Arrays":
        """
        ## JSON Array Construction

        Tests formatting of arrays with different element types.
        """

        it "formats string array":
            val result = json_array_strings(["apple", "banana", "cherry"])
            expect result.contains("[")
            expect result.contains("]")
            expect result.contains("\"apple\"")
            expect result.contains("\"banana\"")

        it "formats number array":
            val result = json_array_numbers([1, 2, 3])
            expect result == "[1, 2, 3]"

        it "formats mixed array":
            val items = [json_string("text"), json_number(42), json_bool(true)]
            val result = json_array(items)
            expect result.contains("\"text\"")
            expect result.contains("42")
            expect result.contains("true")

    describe "JSON Objects":
        """
        ## JSON Object Construction

        Tests formatting of key-value pairs and objects.
        """

        it "formats key-value pair":
            val result = json_pair(key="name", value=json_string("Alice"))
            expect result.contains("\"name\"")
            expect result.contains("\"Alice\"")

        it "formats object":
            val pairs = [
                ("name", json_string("Alice")),
                ("age", json_number(30))
            ]
            val result = json_object(pairs)
            expect result.contains(r"{")
            expect result.contains(r"}")
            expect result.contains("\"name\"")
            expect result.contains("\"Alice\"")
            expect result.contains("\"age\"")
            expect result.contains("30")

    describe "JSON Builder":
        """
        ## JsonBuilder Class

        Tests the fluent builder API for constructing JSON objects.
        """

        it "builds basic object":
            var builder = JsonBuilder.create()
            builder.add_string(key="name", value="Bob")
            builder.add_number("age", 25)
            builder.add_bool("active", true)
            val result = builder.build()
            expect result.contains("\"name\"")
            expect result.contains("\"Bob\"")
            expect result.contains("\"age\"")
            expect result.contains("25")
            expect result.contains("\"active\"")
            expect result.contains("true")

        it "builds with null":
            var builder = JsonBuilder.create()
            builder.add_string(key="name", value="Test")
            builder.add_null("data")
            val result = builder.build()
            expect result.contains("null")

        it "builds with array":
            var builder = JsonBuilder.create()
            val items = [json_string("a"), json_string("b")]
            builder.add_array("items", items)
            val result = builder.build()
            expect result.contains("\"items\"")
            expect result.contains("[")

    describe "JSON Array Builder":
        """
        ## JsonArrayBuilder Class

        Tests the fluent builder API for constructing JSON arrays.
        """

        it "builds mixed array":
            var builder = JsonArrayBuilder.create()
            builder.add_string("apple")
            builder.add_number(42)
            builder.add_bool(true)
            builder.add_null()
            val result = builder.build()
            expect result.contains("\"apple\"")
            expect result.contains("42")
            expect result.contains("true")
            expect result.contains("null")

    describe "Common Structures":
        """
        ## Common JSON Patterns

        Tests generation of common JSON response patterns.
        """

        it "creates success response":
            val result = json_success("Operation completed")
            expect result.contains("\"status\"")
            expect result.contains("\"success\"")
            expect result.contains("\"message\"")

        it "creates error response":
            val result = json_error("Not found", 404)
            expect result.contains("\"status\"")
            expect result.contains("\"error\"")
            expect result.contains("\"code\"")
            expect result.contains("404")

        it "creates data response":
            val data = json_object([("id", json_number(1))])
            val result = json_data(data)
            expect result.contains("\"status\"")
            expect result.contains("\"data\"")

    describe "Validation":
        """
        ## JSON Structure Validation

        Tests validation functions for JSON format and structure.
        """

        it "detects JSON object":
            val json_obj = '{"key": "value"}'
            expect looks_like_json(json_obj)
            expect not looks_like_json("not json")

        it "detects JSON array":
            expect looks_like_json("[1, 2, 3]")
            expect not looks_like_json("plain text")

        it "handles empty string":
            expect not looks_like_json("")

        it "validates balanced braces":
            val balanced = '{"a": [1, 2]}'
            expect has_balanced_braces(balanced)

        it "detects unbalanced braces":
            val unbalanced1 = '{"a": [1, 2}'
            val unbalanced2 = '{"a": 1]]'
            expect not has_balanced_braces(unbalanced1)
            expect not has_balanced_braces(unbalanced2)

    describe "Common Patterns":
        """
        ## API Response Patterns

        Tests generation of common API response patterns.
        """

        it "creates API response with data":
            val data = json_string("result")
            val result = api_response(true, "Success", Some(data))
            expect result.contains("\"success\"")
            expect result.contains("true")
            expect result.contains("\"data\"")

        it "creates API response without data":
            val result = api_response(false, "Failed", nil)
            expect result.contains("\"success\"")
            expect result.contains("false")
            expect result.contains("null")

        it "creates pagination meta":
            val result = pagination_meta(page=2, per_page=10, total=45)
            expect result.contains("\"page\"")
            expect result.contains("2")
            expect result.contains("\"total\"")
            expect result.contains("45")
            expect result.contains("\"total_pages\"")
            expect result.contains("5")

        it "creates timestamp JSON":
            val result = timestamp_json(unix=1640000000, iso="2021-12-20T12:00:00Z")
            expect result.contains("\"unix\"")
            expect result.contains("1640000000")
            expect result.contains("\"iso\"")
            expect result.contains("2021-12-20")

    describe "Edge Cases":
        """
        ## Edge Cases and Special Scenarios

        Tests handling of edge cases and special characters.
        """

        it "escapes backslash in string":
            val result = json_string("path\\to\\file")
            expect result.contains("\\\\")

        it "formats empty object":
            val result = json_object([])
            expect result == r"{}"

        it "formats empty array":
            val result = json_array([])
            expect result == "[]"

        it "handles nested objects":
            var inner = JsonBuilder.create()
            inner.add_string(key="city", value="NYC")

            var outer = JsonBuilder.create()
            outer.add_string(key="name", value="Alice")
            outer.add_raw(key="address", raw_json=inner.build())

            val result = outer.build()
            expect result.contains("\"name\"")
            expect result.contains("\"address\"")
            expect result.contains("\"city\"")
