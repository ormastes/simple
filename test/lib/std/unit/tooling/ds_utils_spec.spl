# Tests for Data Structure utilities
# NOTE: Implementations provided locally

# =====================================
# Data Structure Implementations
# =====================================

class Stack<T>:
    items: [T]

impl Stack<T>:
    static fn create() -> Stack<T>:
        Stack(items: [])

    fn is_empty() -> bool:
        self.items.len() == 0

    fn size() -> i64:
        self.items.len()

    me push(item: T):
        self.items = self.items + [item]

    me pop() -> Option<T>:
        if self.items.len() == 0: return nil
        val last = self.items[self.items.len() - 1]
        self.items = self.items[..self.items.len() - 1]
        Some(last)

    fn peek() -> Option<T>:
        if self.items.len() == 0: return nil
        Some(self.items[self.items.len() - 1])

    me clear():
        self.items = []

    fn to_list() -> [T]:
        self.items

class Queue<T>:
    items: [T]

impl Queue<T>:
    static fn create() -> Queue<T>:
        Queue(items: [])

    fn is_empty() -> bool:
        self.items.len() == 0

    fn size() -> i64:
        self.items.len()

    me enqueue(item: T):
        self.items = self.items + [item]

    me dequeue() -> Option<T>:
        if self.items.len() == 0: return nil
        val first = self.items[0]
        self.items = self.items[1..]
        Some(first)

    fn peek() -> Option<T>:
        if self.items.len() == 0: return nil
        Some(self.items[0])

    me clear():
        self.items = []

class Deque<T>:
    items: [T]

impl Deque<T>:
    static fn create() -> Deque<T>:
        Deque(items: [])

    fn is_empty() -> bool:
        self.items.len() == 0

    fn size() -> i64:
        self.items.len()

    me push_front(item: T):
        self.items = [item] + self.items

    me push_back(item: T):
        self.items = self.items + [item]

    me pop_front() -> Option<T>:
        if self.items.len() == 0: return nil
        val first = self.items[0]
        self.items = self.items[1..]
        Some(first)

    me pop_back() -> Option<T>:
        if self.items.len() == 0: return nil
        val last = self.items[self.items.len() - 1]
        self.items = self.items[..self.items.len() - 1]
        Some(last)

    fn peek_front() -> Option<T>:
        if self.items.len() == 0: return nil
        Some(self.items[0])

    fn peek_back() -> Option<T>:
        if self.items.len() == 0: return nil
        Some(self.items[self.items.len() - 1])

    me clear():
        self.items = []

fn stack_from_list(items: [i64]) -> Stack<i64>:
    var stack = Stack.create()
    for item in items:
        stack.push(item)
    stack

fn queue_from_list(items: [i64]) -> Queue<i64>:
    var queue = Queue.create()
    for item in items:
        queue.enqueue(item)
    queue

fn deque_from_list(items: [i64]) -> Deque<i64>:
    var deque = Deque.create()
    for item in items:
        deque.push_back(item)
    deque

fn stack_get(stack: Stack<i64>, idx: i64) -> Option<i64>:
    val list = stack.to_list()
    if idx >= list.len(): return nil
    Some(list[list.len() - 1 - idx])

fn queue_get(queue: Queue<i64>, idx: i64) -> Option<i64>:
    if idx >= queue.size(): return nil
    Some(queue.items[idx])

fn reverse_stack(stack: Stack<i64>) -> Stack<i64>:
    var result = Stack.create()
    val items = stack.to_list()
    for item in items:
        result.push(item)
    var reversed = Stack.create()
    for i in 0..items.len():
        match result.pop():
            case Some(v): reversed.push(v)
            case nil: expect true
    reversed

fn merge_queues(q1: Queue<i64>, q2: Queue<i64>) -> Queue<i64>:
    var result = Queue.create()
    for item in q1.items:
        result.enqueue(item)
    for item in q2.items:
        result.enqueue(item)
    result

# =====================================
# BDD Tests
# =====================================

describe "Data Structure Utilities":
    describe "Stack":
        it "creates empty stack":
            val stack: Stack<i64> = Stack.create()
            expect stack.is_empty()
            expect stack.size() == 0

        it "pushes items":
            var stack: Stack<i64> = Stack.create()
            stack.push(1)
            stack.push(2)
            stack.push(3)
            expect stack.size() == 3
            expect not stack.is_empty()

        it "pops items in LIFO order":
            var stack: Stack<i64> = Stack.create()
            stack.push(1)
            stack.push(2)
            stack.push(3)
            match stack.pop():
                case Some(v): expect v == 3
                case nil: expect false
            match stack.pop():
                case Some(v): expect v == 2
                case nil: expect false
            expect stack.size() == 1

        it "returns nil when popping empty stack":
            var stack: Stack<i64> = Stack.create()
            match stack.pop():
                case Some(_): expect false
                case nil: expect true

        it "peeks without removing":
            var stack: Stack<i64> = Stack.create()
            stack.push(1)
            stack.push(2)
            match stack.peek():
                case Some(v): expect v == 2
                case nil: expect false
            expect stack.size() == 2

        it "clears all items":
            var stack: Stack<i64> = Stack.create()
            stack.push(1)
            stack.push(2)
            stack.clear()
            expect stack.is_empty()
            expect stack.size() == 0

        it "converts to list":
            var stack: Stack<i64> = Stack.create()
            stack.push(1)
            stack.push(2)
            stack.push(3)
            val list = stack.to_list()
            expect list.len() == 3
            expect list[0] == 1
            expect list[2] == 3

    describe "Queue":
        it "creates empty queue":
            val queue: Queue<i64> = Queue.create()
            expect queue.is_empty()
            expect queue.size() == 0

        it "enqueues items":
            var queue: Queue<i64> = Queue.create()
            queue.enqueue(1)
            queue.enqueue(2)
            queue.enqueue(3)
            expect queue.size() == 3
            expect not queue.is_empty()

        it "dequeues items in FIFO order":
            var queue: Queue<i64> = Queue.create()
            queue.enqueue(1)
            queue.enqueue(2)
            queue.enqueue(3)
            match queue.dequeue():
                case Some(v): expect v == 1
                case nil: expect false
            match queue.dequeue():
                case Some(v): expect v == 2
                case nil: expect false
            expect queue.size() == 1

        it "returns nil when dequeuing empty queue":
            var queue: Queue<i64> = Queue.create()
            match queue.dequeue():
                case Some(_): expect false
                case nil: expect true

        it "peeks without removing":
            var queue: Queue<i64> = Queue.create()
            queue.enqueue(1)
            queue.enqueue(2)
            match queue.peek():
                case Some(v): expect v == 1
                case nil: expect false
            expect queue.size() == 2

        it "clears all items":
            var queue: Queue<i64> = Queue.create()
            queue.enqueue(1)
            queue.enqueue(2)
            queue.clear()
            expect queue.is_empty()
            expect queue.size() == 0

    describe "Deque":
        it "creates empty deque":
            val deque: Deque<i64> = Deque.create()
            expect deque.is_empty()
            expect deque.size() == 0

        it "pushes to front":
            var deque: Deque<i64> = Deque.create()
            deque.push_front(1)
            deque.push_front(2)
            deque.push_front(3)
            expect deque.size() == 3
            match deque.peek_front():
                case Some(v): expect v == 3
                case nil: expect false

        it "pushes to back":
            var deque: Deque<i64> = Deque.create()
            deque.push_back(1)
            deque.push_back(2)
            deque.push_back(3)
            expect deque.size() == 3
            match deque.peek_back():
                case Some(v): expect v == 3
                case nil: expect false

        it "pops from front":
            var deque: Deque<i64> = Deque.create()
            deque.push_back(1)
            deque.push_back(2)
            deque.push_back(3)
            match deque.pop_front():
                case Some(v): expect v == 1
                case nil: expect false
            expect deque.size() == 2

        it "pops from back":
            var deque: Deque<i64> = Deque.create()
            deque.push_back(1)
            deque.push_back(2)
            deque.push_back(3)
            match deque.pop_back():
                case Some(v): expect v == 3
                case nil: expect false
            expect deque.size() == 2

        it "returns nil when popping empty deque":
            var deque: Deque<i64> = Deque.create()
            match deque.pop_front():
                case Some(_): expect false
                case nil: expect true
            match deque.pop_back():
                case Some(_): expect false
                case nil: expect true

        it "clears all items":
            var deque: Deque<i64> = Deque.create()
            deque.push_back(1)
            deque.push_back(2)
            deque.clear()
            expect deque.is_empty()

    describe "Helper Functions":
        it "creates stack from list":
            val stack = stack_from_list([1, 2, 3])
            expect stack.size() == 3
            match stack.peek():
                case Some(v): expect v == 3
                case nil: expect false

        it "creates queue from list":
            val queue = queue_from_list([1, 2, 3])
            expect queue.size() == 3
            match queue.peek():
                case Some(v): expect v == 1
                case nil: expect false

        it "creates deque from list":
            val deque = deque_from_list([1, 2, 3])
            expect deque.size() == 3

        it "gets element from stack by index":
            val stack = stack_from_list([1, 2, 3])
            match stack_get(stack, 0):
                case Some(v): expect v == 3
                case nil: expect false
            match stack_get(stack, 2):
                case Some(v): expect v == 1
                case nil: expect false

        it "returns nil for out of bounds stack access":
            val stack = stack_from_list([1, 2, 3])
            match stack_get(stack, 10):
                case Some(_): expect false
                case nil: expect true

        it "gets element from queue by index":
            val queue = queue_from_list([1, 2, 3])
            match queue_get(queue, 0):
                case Some(v): expect v == 1
                case nil: expect false
            match queue_get(queue, 2):
                case Some(v): expect v == 3
                case nil: expect false

        it "returns nil for out of bounds queue access":
            val queue = queue_from_list([1, 2, 3])
            match queue_get(queue, 10):
                case Some(_): expect false
                case nil: expect true

        it "reverses stack":
            val stack = stack_from_list([1, 2, 3])
            val reversed = reverse_stack(stack)
            match reversed.peek():
                case Some(v): expect v == 1
                case nil: expect false

        it "merges queues":
            val q1 = queue_from_list([1, 2])
            val q2 = queue_from_list([3, 4])
            val merged = merge_queues(q1=q1, q2=q2)
            expect merged.size() == 4

    describe "Complex Scenarios":
        it "handles multiple stack operations":
            var stack: Stack<i64> = Stack.create()
            stack.push(1)
            stack.push(2)
            stack.pop()
            stack.push(3)
            stack.push(4)
            expect stack.size() == 3
            match stack.pop():
                case Some(v): expect v == 4
                case nil: expect false

        it "handles multiple queue operations":
            var queue: Queue<i64> = Queue.create()
            queue.enqueue(1)
            queue.enqueue(2)
            queue.dequeue()
            queue.enqueue(3)
            queue.enqueue(4)
            expect queue.size() == 3
            match queue.dequeue():
                case Some(v): expect v == 2
                case nil: expect false

        it "handles mixed deque operations":
            var deque: Deque<i64> = Deque.create()
            deque.push_back(1)
            deque.push_front(2)
            deque.push_back(3)
            deque.pop_front()
            expect deque.size() == 2
