"""
Path Utilities Tests

Tests for file path manipulation including extraction, joining, normalization,
and conversion between absolute and relative paths.

Feature:
  File path manipulation and utilities

Category:
  Tooling/File System

Status:
  Complete

Implementation:
  All path utility functions are provided locally in this test file.
  This allows tests to be independent of external dependencies.
"""

import std.spec

# =====================================
# Path Utility Implementations
# =====================================

fn get_filename(path: text) -> text:
    if path.len() == 0: return ""
    val normalized = normalize_path(path)
    val idx = normalized.rfind("/")
    match idx:
        case Some(i): normalized[i+1..]
        case nil: normalized

fn get_dir_name(path: text) -> text:
    val base_path = normalize_path(path)
    # Remove trailing slash
    var normalized = base_path
    if normalized.ends_with("/") and normalized.len() > 1:
        normalized = normalized[..normalized.len()-1]
    val idx = normalized.rfind("/")
    match idx:
        case Some(i): normalized[i+1..]
        case nil: normalized

fn get_parent_dir(path: text) -> text:
    val normalized = normalize_path(path)
    var working = normalized
    # Remove trailing slash
    if working.ends_with("/") and working.len() > 1:
        working = working[..working.len()-1]
    val idx = working.rfind("/")
    match idx:
        case Some(i):
            if i == 0:
                ""
            else:
                working[..i]
        case nil: ""

fn get_parent_dir_option(path: text) -> Option<text>:
    val normalized = normalize_path(path)
    val idx = normalized.rfind("/")
    match idx:
        case Some(i):
            if i == 0: nil
            else: Some(normalized[..i])
        case nil: nil

fn join_path(base: text, child: text) -> text:
    if base.len() == 0: return child
    if child.len() == 0: return base

    var result = base
    if not result.ends_with("/") and not result.ends_with("\\"):
        result = result + "/"
    if child.starts_with("/") or child.starts_with("\\"):
        result + child[1..]
    else:
        result + child

fn get_extension(path: text) -> text:
    val filename = get_filename(path)
    if filename.len() == 0:
        return ""
    if filename.starts_with(".") and not filename[1..].contains("."):
        return ""
    match filename.rfind("."):
        case Some(i):
            if i == 0:
                ""
            else:
                filename[i+1..]
        case nil: ""

fn get_stem(path: text) -> text:
    val filename = get_filename(path)
    if filename.len() == 0:
        return ""
    match filename.rfind("."):
        case Some(i):
            if i == 0:
                filename
            else:
                filename[..i]
        case nil: filename

fn has_extension(path: text, ext: text) -> bool:
    var target = ext
    if target.starts_with("."):
        target = target[1..]
    get_extension(path).to_lowercase() == target.to_lowercase()

fn normalize_path(path: text) -> text:
    path.replace("\\", "/")

fn is_absolute_path(path: text) -> bool:
    if path.len() == 0:
        return false
    if path.starts_with("/"):
        return true
    # Windows drive letter
    if path.len() >= 2:
        val chars = path.chars()
        val first = "{chars[0]}"
        val second = "{chars[1]}"
        if (first >= "A" and first <= "Z") or (first >= "a" and first <= "z"):
            if second == ":":
                return true
    false

fn make_relative(path: text, base: text) -> text:
    val norm_path = normalize_path(path)
    val norm_base = normalize_path(base)

    if not norm_path.starts_with(norm_base):
        return path

    var result = norm_path[norm_base.len()..]
    if result.starts_with("/"):
        result = result[1..]
    result

fn split_path(path: text) -> [text]:
    if path.len() == 0: return []
    val normalized = normalize_path(path)
    var result: [text] = []
    val parts = normalized.split("/")
    for part in parts:
        if part.len() > 0:
            result = result + [part]
    result

# =====================================
# BDD Tests
# =====================================

describe "Path Utilities":
    """
    Comprehensive tests for path utility functions covering filename extraction,
    directory operations, path joining, normalization, and cross-platform support.
    """

    describe "Filename Extraction":
        it "extracts filename from unix path":
            expect get_filename("/home/user/file.txt") == "file.txt"
            expect get_filename("/home/user/") == ""
            expect get_filename("file.txt") == "file.txt"

        it "extracts filename from windows path":
            expect get_filename("C:\\Users\\user\\file.txt") == "file.txt"
            expect get_filename("C:\\Program Files\\app.exe") == "app.exe"

        it "handles edge cases":
            expect get_filename("") == ""
            expect get_filename("/") == ""
            expect get_filename("simple_file") == "simple_file"

    describe "Directory Name":
        it "gets directory name":
            expect get_dir_name("/home/user/documents") == "documents"
            expect get_dir_name("/home/user/documents/") == "documents"

    describe "Parent Directory":
        it "gets parent dir unix":
            expect get_parent_dir("/home/user/file.txt") == "/home/user"
            expect get_parent_dir("/home/user/") == "/home"
            expect get_parent_dir("/home") == ""

        it "returns option for parent":
            match get_parent_dir_option("/home/user/file.txt"):
                case Some(parent): expect parent == "/home/user"
                case nil: expect false

        it "returns nil for no parent":
            match get_parent_dir_option("file.txt"):
                case Some(_): expect false
                case nil: expect true

    describe "Path Joining":
        it "joins unix paths":
            expect join_path(base="/home/user", child="file.txt") == "/home/user/file.txt"
            expect join_path(base="/home/user/", child="file.txt") == "/home/user/file.txt"

        it "handles edge cases":
            expect join_path(base="", child="file.txt") == "file.txt"
            expect join_path(base="/home", child="") == "/home"
            expect join_path(base="", child="") == ""

    describe "Extension":
        it "gets extension":
            expect get_extension("file.txt") == "txt"
            expect get_extension("archive.tar.gz") == "gz"
            expect get_extension("/path/to/file.json") == "json"

        it "returns empty for no extension":
            expect get_extension("README") == ""
            expect get_extension("/path/to/file") == ""
            expect get_extension("") == ""

        it "handles hidden files":
            expect get_extension(".gitignore") == ""
            expect get_extension(".config.yml") == "yml"

    describe "Stem":
        it "gets stem":
            expect get_stem("file.txt") == "file"
            expect get_stem("archive.tar.gz") == "archive.tar"
            expect get_stem("/path/to/document.pdf") == "document"

        it "handles no extension":
            expect get_stem("README") == "README"
            expect get_stem("Makefile") == "Makefile"

    describe "Has Extension":
        it "checks extension":
            expect has_extension(path="file.txt", ext="txt")
            expect has_extension(path="file.txt", ext=".txt")
            expect has_extension(path="archive.TAR", ext="tar")

        it "returns false for wrong extension":
            expect not has_extension(path="file.txt", ext="pdf")
            expect not has_extension(path="README", ext="txt")

    describe "Path Normalization":
        it "normalizes backslashes":
            expect normalize_path("C:\\Users\\user\\file.txt") == "C:/Users/user/file.txt"
            expect normalize_path("/home/user/file.txt") == "/home/user/file.txt"
            expect normalize_path("path\\to\\file") == "path/to/file"

    describe "Absolute Path":
        it "detects unix absolute paths":
            expect is_absolute_path("/home/user/file.txt")
            expect is_absolute_path("/")
            expect not is_absolute_path("relative/path")

        it "detects windows absolute paths":
            expect is_absolute_path("C:\\Users\\user\\file.txt")
            expect is_absolute_path("D:/data/file.dat")
            expect not is_absolute_path("relative\\path")

        it "handles edge cases":
            expect not is_absolute_path("")
            expect not is_absolute_path("file.txt")

    describe "Make Relative":
        it "makes path relative":
            expect make_relative(path="/home/user/docs/file.txt", base="/home/user") == "docs/file.txt"
            expect make_relative(path="/home/user/file.txt", base="/home/user") == "file.txt"

        it "returns original for no common prefix":
            val result = make_relative(path="/var/log/file.txt", base="/home/user")
            expect result == "/var/log/file.txt"

    describe "Split Path":
        it "splits unix path":
            val parts = split_path("/home/user/documents/file.txt")
            expect parts.len() == 4
            expect parts[0] == "home"
            expect parts[1] == "user"
            expect parts[2] == "documents"
            expect parts[3] == "file.txt"

        it "splits relative path":
            val parts = split_path("docs/file.txt")
            expect parts.len() == 2
            expect parts[0] == "docs"
            expect parts[1] == "file.txt"

        it "handles empty path":
            val parts = split_path("")
            expect parts.len() == 0

    describe "Complex Scenarios":
        it "manipulates complex path":
            val path = "/home/user/projects/simple/src/main.spl"
            expect get_filename(path) == "main.spl"
            expect get_extension(path) == "spl"
            expect get_stem(path) == "main"
            expect get_parent_dir(path) == "/home/user/projects/simple/src"

        it "builds path from components":
            val base = "/home/user"
            val subdir = "projects"
            val filename = "main.spl"
            val step1 = join_path(base=base, child=subdir)
            val final_path = join_path(base=step1, child=filename)
            expect final_path == "/home/user/projects/main.spl"

        it "converts relative path":
            val absolute = "/home/user/projects/simple/src/main.spl"
            val base = "/home/user/projects"
            val relative = make_relative(path=absolute, base=base)
            expect relative == "simple/src/main.spl"
            val parts = split_path(relative)
            expect parts.len() == 3
