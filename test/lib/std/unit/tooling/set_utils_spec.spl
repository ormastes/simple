# Tests for set utilities
# NOTE: Implementations provided locally

fn set_contains(set: [i64], x: i64) -> bool:
    for item in set:
        if item == x:
            return true
    false

fn set_add(set: [i64], x: i64) -> [i64]:
    if set_contains(set, x):
        return set
    set + [x]

fn set_remove(set: [i64], x: i64) -> [i64]:
    var result: [i64] = []
    for item in set:
        if item != x:
            result = result + [item]
    result

fn set_union(a: [i64], b: [i64]) -> [i64]:
    var result = a
    for x in b:
        result = set_add(result, x)
    result

fn set_intersection(a: [i64], b: [i64]) -> [i64]:
    var result: [i64] = []
    for x in a:
        if set_contains(b, x):
            result = set_add(result, x)
    result

fn is_subset(a: [i64], b: [i64]) -> bool:
    for x in a:
        if not set_contains(b, x):
            return false
    true

describe "Set Utilities":
    describe "Basic Operations":
        it "contains checks membership":
            expect set_contains([1, 2, 3], 2)
            expect not set_contains([1, 2, 3], 5)

        it "add adds element if not present":
            val set = set_add([1, 2], 3)
            expect set_contains(set, 3)

        it "remove removes element":
            val set = set_remove([1, 2, 3], 2)
            expect not set_contains(set, 2)

    describe "Set Operations":
        it "union combines sets":
            val result = set_union(a=[1, 2], b=[2, 3])
            expect set_contains(result, 1)
            expect set_contains(result, 3)

        it "intersection finds common elements":
            val result = set_intersection(a=[1, 2, 3], b=[2, 3, 4])
            expect set_contains(result, 2)
            expect set_contains(result, 3)
            expect not set_contains(result, 1)

        it "is_subset checks subset relationship":
            expect is_subset(a=[1, 2], b=[1, 2, 3])
            expect not is_subset(a=[1, 4], b=[1, 2, 3])
