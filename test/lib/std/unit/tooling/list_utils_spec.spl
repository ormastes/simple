"""
Feature: List Utilities
Category: Standard Library / Tooling
Status: Complete

Comprehensive list manipulation utilities including reverse, chunk, rotate,
deduplicate, flatten, and other common list operations.
"""

use std.spec

# =====================================
# List Utility Implementations
# =====================================

fn reverse_list(list: [i64]) -> [i64]:
    var result: [i64] = []
    for i in 0..list.len():
        result = [list[list.len() - 1 - i]] + result
    result

fn take(list: [i64], n: i64) -> [i64]:
    var result: [i64] = []
    val count = if n < list.len(): n else: list.len()
    for i in 0..count:
        result = result + [list[i]]
    result

fn drop(list: [i64], n: i64) -> [i64]:
    if n >= list.len(): return []
    var result: [i64] = []
    for i in n..list.len():
        result = result + [list[i]]
    result

fn chunk(list: [i64], size: i64) -> [[i64]]:
    if size <= 0: return []
    var result: [[i64]] = []
    var current: [i64] = []
    for i in 0..list.len():
        current = current + [list[i]]
        if current.len() == size:
            result = result + [current]
            current = []
    if current.len() > 0:
        result = result + [current]
    result

fn interleave(a: [i64], b: [i64]) -> [i64]:
    var result: [i64] = []
    val max_len = if a.len() > b.len(): a.len() else: b.len()
    for i in 0..max_len:
        if i < a.len():
            result = result + [a[i]]
        if i < b.len():
            result = result + [b[i]]
    result

fn rotate_left(list: [i64], n: i64) -> [i64]:
    if list.len() == 0: return []
    val shift = n % list.len()
    drop(list, shift) + take(list, shift)

fn rotate_right(list: [i64], n: i64) -> [i64]:
    if list.len() == 0: return []
    val shift = n % list.len()
    rotate_left(list, list.len() - shift)

fn dedup(list: [i64]) -> [i64]:
    if list.len() == 0: return []
    var result: [i64] = [list[0]]
    for i in 1..list.len():
        if list[i] != list[i - 1]:
            result = result + [list[i]]
    result

fn dedup_all(list: [i64]) -> [i64]:
    var result: [i64] = []
    for x in list:
        var found = false
        for y in result:
            if x == y:
                found = true
        if not found:
            result = result + [x]
    result

fn flatten(nested: [[i64]]) -> [i64]:
    var result: [i64] = []
    for inner in nested:
        for x in inner:
            result = result + [x]
    result

fn windows(list: [i64], size: i64) -> [[i64]]:
    if size > list.len() or size <= 0: return []
    var result: [[i64]] = []
    for i in 0..(list.len() - size + 1):
        var window: [i64] = []
        for j in 0..size:
            window = window + [list[i + j]]
        result = result + [window]
    result

fn intersperse(list: [i64], sep: i64) -> [i64]:
    if list.len() <= 1: return list
    var result: [i64] = [list[0]]
    for i in 1..list.len():
        result = result + [sep, list[i]]
    result

fn is_sorted(list: [i64]) -> bool:
    if list.len() <= 1: return true
    for i in 0..(list.len() - 1):
        if list[i] > list[i + 1]:
            return false
    true

fn list_equals(a: [i64], b: [i64]) -> bool:
    if a.len() != b.len(): return false
    for i in 0..a.len():
        if a[i] != b[i]:
            return false
    true

# =====================================
# BDD Tests
# =====================================

describe "List Utilities":
    """
    Tests for list manipulation utilities covering reversing, chunking,
    rotation, deduplication, flattening, and other sequence operations.
    """

    describe "Reverse":
        """Test list reversal operations"""
        it "reverses list":
            expect list_equals(a=reverse_list([1, 2, 3, 4]), b=[4, 3, 2, 1])

        it "handles single element":
            expect list_equals(a=reverse_list([1]), b=[1])

        it "handles empty list":
            val empty: [i64] = []
            expect reverse_list(empty).len() == 0

    describe "Chunk":
        """Test list chunking/partitioning operations"""
        it "chunks list into parts":
            val chunks_list = chunk([1, 2, 3, 4, 5], 2)
            expect chunks_list.len() == 3

        it "handles exact fit":
            val chunks_list = chunk([1, 2, 3, 4], 2)
            expect chunks_list.len() == 2

        it "handles size larger than list":
            val chunks_list = chunk([1, 2], 5)
            expect chunks_list.len() == 1

    describe "Interleave":
        """Test list interleaving operations"""
        it "interleaves equal length lists":
            val result = interleave(a=[1, 2, 3], b=[4, 5, 6])
            expect list_equals(a=result, b=[1, 4, 2, 5, 3, 6])

        it "handles different lengths":
            val result = interleave(a=[1, 2], b=[3, 4, 5, 6])
            expect result.len() == 6

    describe "Rotation":
        """Test list rotation operations (left and right)"""
        it "rotates left":
            expect list_equals(a=rotate_left([1, 2, 3, 4, 5], 2), b=[3, 4, 5, 1, 2])

        it "rotates left by zero":
            expect list_equals(a=rotate_left([1, 2, 3], 0), b=[1, 2, 3])

        it "rotates right":
            expect list_equals(a=rotate_right([1, 2, 3, 4, 5], 2), b=[4, 5, 1, 2, 3])

    describe "Deduplication":
        """Test deduplication operations for removing duplicate elements"""
        it "removes consecutive duplicates":
            expect list_equals(a=dedup([1, 1, 2, 2, 3, 3]), b=[1, 2, 3])

        it "keeps non-consecutive duplicates":
            expect list_equals(a=dedup([1, 2, 1, 2]), b=[1, 2, 1, 2])

        it "dedup_all removes all duplicates":
            expect list_equals(a=dedup_all([1, 2, 1, 3, 2]), b=[1, 2, 3])

    describe "Flatten":
        """Test flattening nested list structures"""
        it "flattens nested lists":
            val nested = [[1, 2], [3, 4], [5]]
            expect list_equals(a=flatten(nested), b=[1, 2, 3, 4, 5])

        it "handles empty nested list":
            val empty: [[i64]] = []
            expect flatten(empty).len() == 0

    describe "Windows":
        """Test sliding window operations on lists"""
        it "creates sliding windows":
            val wins = windows([1, 2, 3, 4], 2)
            expect wins.len() == 3

        it "handles size too large":
            val wins = windows([1, 2], 5)
            expect wins.len() == 0

    describe "Intersperse":
        """Test interspersing separator elements between list items"""
        it "inserts separator between elements":
            expect list_equals(a=intersperse([1, 2, 3], 0), b=[1, 0, 2, 0, 3])

        it "handles single element":
            expect list_equals(a=intersperse([1], 0), b=[1])

    describe "Slicing":
        """Test take and drop operations for list slicing"""
        it "take gets first n elements":
            expect list_equals(a=take([1, 2, 3, 4, 5], 3), b=[1, 2, 3])

        it "take handles oversized n":
            expect list_equals(a=take([1, 2], 5), b=[1, 2])

        it "drop removes first n elements":
            expect list_equals(a=drop([1, 2, 3, 4, 5], 2), b=[3, 4, 5])

        it "drop handles oversized n":
            val dropped = drop([1, 2], 5)
            expect dropped.len() == 0

    describe "Comparison":
        """Test list equality checking"""
        it "list_equals returns true for equal":
            expect list_equals(a=[1, 2, 3], b=[1, 2, 3])

        it "list_equals returns false for different":
            expect not list_equals(a=[1, 2], b=[1, 2, 3])
            expect not list_equals(a=[1, 2, 3], b=[1, 3, 2])

    describe "Sorting Check":
        """Test detection of sorted sequences"""
        it "is_sorted detects sorted":
            expect is_sorted([1, 2, 3, 4])

        it "is_sorted detects unsorted":
            expect not is_sorted([1, 3, 2, 4])

        it "is_sorted handles empty":
            val empty: [i64] = []
            expect is_sorted(empty)

        it "is_sorted handles single element":
            expect is_sorted([1])
