# Test Database Integrity Validation Specification
#
# Tests the data integrity validation system that detects stale/inconsistent
# test run data early in debug mode. This prevents false "hanging test" reports
# by validating database records when loaded.
#
# Validation checks:
# 1. Stale runs - Running status >2 hours old
# 2. Dead processes - Running status but PID doesn't exist
# 3. Timestamp consistency - end_time > start_time, no future timestamps
# 4. Count consistency - passed+failed+crashed+timed_out ≤ test_count
# 5. Status consistency - Completed/Crashed must have end_time
use app.io.mod (getpid, time_now_unix_micros)
use app.test_runner_new.test_db_compat (micros_to_rfc3339, parse_rfc3339_to_micros)
use app.test_runner_new.test_db_types (RunRecord)
use app.test_runner_new.test_db_validation (validate_run_record, ValidationReport)

use std.spec.*

# Helper: Create test run with specified fields
fn create_test_run(run_id: text, status: text, start_time: text, end_time: text, pid: i64, test_count: i64, passed: i64, failed: i64, crashed: i64, timed_out: i64) -> RunRecord:
    RunRecord(
        run_id: run_id,
        start_time: start_time,
        end_time: end_time,
        pid: pid,
        hostname: "localhost",
        status: status,
        test_count: test_count,
        passed: passed,
        failed: failed,
        crashed: crashed,
        timed_out: timed_out
    )

# Helper: Get timestamp from hours ago
fn hours_ago(hours: i64) -> text:
    val now_micros = time_now_unix_micros()
    val hours_in_micros = hours * 3600 * 1000000
    val past_micros = now_micros - hours_in_micros
    micros_to_rfc3339(past_micros)

# Helper: Get future timestamp
fn future_time() -> text:
    val now_micros = time_now_unix_micros()
    val one_hour_micros = 3600 * 1000000
    val future_micros = now_micros + one_hour_micros
    micros_to_rfc3339(future_micros)

# Helper: Get current timestamp
fn now_time() -> text:
    micros_to_rfc3339(time_now_unix_micros())

# Helper: Create valid run
fn create_valid_run(run_id: text) -> RunRecord:
    create_test_run(
        run_id,
        "Running",
        hours_ago(1),  # 1 hour ago - not stale
        "",
        getpid(),  # Current process - alive
        10,
        0,
        0,
        0,
        0
    )

# Helper: Create stale run (>2 hours old)
fn create_stale_run(run_id: text) -> RunRecord:
    create_test_run(
        run_id,
        "Running",
        hours_ago(3),  # 3 hours ago - stale
        "",
        getpid(),
        10,
        0,
        0,
        0,
        0
    )

# Helper: Create dead process run
fn create_dead_process_run(run_id: text) -> RunRecord:
    create_test_run(
        run_id,
        "Running",
        hours_ago(1),
        "",
        999999,  # Non-existent PID
        10,
        0,
        0,
        0,
        0
    )

# Helper: Validate a test run record
fn validate_run(run: RunRecord) -> ValidationReport:
    validate_run_record(run)

describe "Test Database Integrity Validation":

    describe "Stale Run Detection":

        it "detects run running for >2 hours":
            val run = create_stale_run("stale_run_1")
            val report = validate_run(run)

            expect(report.has_violations()).to_be(true)
            expect(report.violations.len()).to_be_greater_than(0)

            val stale_found = report.violations.filter(\v: v.violation_type == "StaleRunning")
            expect(stale_found.len() > 0).to_be(true)
            expect(report.auto_fixable).to_be(true)

        it "ignores recent runs (<2 hours)":
            val run = create_valid_run("recent_run_1")
            val report = validate_run(run)

            val stale_violations = report.violations.filter(\v: v.violation_type == "StaleRunning")
            expect(stale_violations.len()).to_be(0)

        it "ignores completed runs":
            val run = create_test_run(
                "completed_run_1",
                "Completed",
                hours_ago(5),  # 5 hours ago
                hours_ago(4),  # Ended 4 hours ago
                getpid(),
                10,
                10,
                0,
                0,
                0
            )
            val report = validate_run(run)

            val stale_violations = report.violations.filter(\v: v.violation_type == "StaleRunning")
            expect(stale_violations.len()).to_be(0)

    describe "Dead Process Detection":

        it "detects dead process with running status":
            val run = create_dead_process_run("dead_proc_1")
            val report = validate_run(run)

            expect(report.has_violations()).to_be(true)

            val dead_found = report.violations.filter(\v: v.violation_type == "DeadProcess")
            expect(dead_found.len() > 0).to_be(true)
            expect(report.auto_fixable).to_be(true)

        it "ignores completed runs with dead process":
            val run = create_test_run(
                "completed_dead_1",
                "Completed",
                hours_ago(2),
                hours_ago(1),
                999999,  # Dead PID but status is Completed
                10,
                10,
                0,
                0,
                0
            )
            val report = validate_run(run)

            val dead_violations = report.violations.filter(\v: v.violation_type == "DeadProcess")
            expect(dead_violations.len()).to_be(0)

    describe "Timestamp Validation":

        it "detects end_time before start_time":
            val run = create_test_run(
                "bad_timestamp_1",
                "Completed",
                "2026-01-30T10:00:00Z",
                "2026-01-30T09:00:00Z",  # Before start_time
                getpid(),
                10,
                10,
                0,
                0,
                0
            )
            val report = validate_run(run)

            expect(report.has_violations()).to_be(true)

            val ts_found = report.violations.filter(\v: v.violation_type == "TimestampInconsistent")
            expect(ts_found.len() > 0).to_be(true)

        it "detects future start_time":
            val run = create_test_run(
                "future_start_1",
                "Running",
                future_time(),  # Future timestamp
                "",
                getpid(),
                10,
                0,
                0,
                0,
                0
            )
            val report = validate_run(run)

            expect(report.has_violations()).to_be(true)

            val future_found = report.violations.filter(\v: v.violation_type == "FutureTimestamp")
            expect(future_found.len() > 0).to_be(true)

        it "accepts valid timestamp ordering":
            val run = create_test_run(
                "valid_timestamps_1",
                "Completed",
                hours_ago(2),
                hours_ago(1),  # After start_time
                getpid(),
                10,
                10,
                0,
                0,
                0
            )
            val report = validate_run(run)

            val timestamp_violations = report.violations.filter(\v:
                v.violation_type == "TimestampInconsistent" or v.violation_type == "FutureTimestamp"
            )
            expect(timestamp_violations.len()).to_be(0)

        it "detects invalid timestamp format":
            val run = create_test_run(
                "bad_format_1",
                "Completed",
                "not-a-timestamp",  # Invalid format
                hours_ago(1),
                getpid(),
                10,
                10,
                0,
                0,
                0
            )
            val report = validate_run(run)

            expect(report.has_violations()).to_be(true)

            val invalid_found = report.violations.filter(\v: v.violation_type == "InvalidValue")
            expect(invalid_found.len() > 0).to_be(true)

    describe "Count Consistency":

        it "detects count sum exceeding test_count":
            val run = create_test_run(
                "count_overflow_1",
                "Completed",
                hours_ago(2),
                hours_ago(1),
                getpid(),
                10,  # test_count
                8,   # passed
                3,   # failed (8 + 3 = 11 > 10)
                0,
                0
            )
            val report = validate_run(run)

            expect(report.has_violations()).to_be(true)

            val count_found = report.violations.filter(\v: v.violation_type == "CountInconsistent")
            expect(count_found.len() > 0).to_be(true)

        it "accepts valid count distribution":
            val run = create_test_run(
                "valid_counts_1",
                "Completed",
                hours_ago(2),
                hours_ago(1),
                getpid(),
                10,
                7,
                2,
                1,
                0  # 7 + 2 + 1 = 10 ≤ 10
            )
            val report = validate_run(run)

            val count_violations = report.violations.filter(\v: v.violation_type == "CountInconsistent")
            expect(count_violations.len()).to_be(0)

        it "accepts partial counts (some tests skipped)":
            val run = create_test_run(
                "partial_counts_1",
                "Completed",
                hours_ago(2),
                hours_ago(1),
                getpid(),
                20,
                10,
                3,
                2,
                1  # 10 + 3 + 2 + 1 = 16 < 20 (4 skipped)
            )
            val report = validate_run(run)

            val count_violations = report.violations.filter(\v: v.violation_type == "CountInconsistent")
            expect(count_violations.len()).to_be(0)

    describe "Status Consistency":

        it "detects missing end_time for completed status":
            val run = create_test_run(
                "missing_end_1",
                "Completed",
                hours_ago(2),
                "",  # Missing end_time
                getpid(),
                10,
                10,
                0,
                0,
                0
            )
            val report = validate_run(run)

            expect(report.has_violations()).to_be(true)

            val status_found = report.violations.filter(\v: v.violation_type == "StatusInconsistent")
            expect(status_found.len() > 0).to_be(true)

        it "detects unexpected end_time for running status":
            val run = create_test_run(
                "unexpected_end_1",
                "Running",
                hours_ago(1),
                hours_ago(0),  # Shouldn't have end_time when Running
                getpid(),
                10,
                5,
                0,
                0,
                0
            )
            val report = validate_run(run)

            expect(report.has_violations()).to_be(true)

            val status_found2 = report.violations.filter(\v: v.violation_type == "StatusInconsistent")
            expect(status_found2.len() > 0).to_be(true)

        it "accepts valid status/timestamp combinations":
            # Running with no end_time
            val running = create_test_run(
                "valid_running_1",
                "Running",
                hours_ago(1),
                "",
                getpid(),
                10,
                5,
                0,
                0,
                0
            )
            val report1 = validate_run(running)
            val status_violations1 = report1.violations.filter(\v: v.violation_type == "StatusInconsistent")
            expect(status_violations1.len()).to_be(0)

            # Completed with end_time
            val completed = create_test_run(
                "valid_completed_1",
                "Completed",
                hours_ago(2),
                hours_ago(1),
                getpid(),
                10,
                10,
                0,
                0,
                0
            )
            val report2 = validate_run(completed)
            val status_violations2 = report2.violations.filter(\v: v.violation_type == "StatusInconsistent")
            expect(status_violations2.len()).to_be(0)

    describe "Multiple Violations":

        it "reports multiple violations for single record":
            val run = create_test_run(
                "multi_bad_1",
                "Running",
                hours_ago(3),  # Stale
                hours_ago(2),  # Shouldn't have end_time
                999999,        # Dead process
                10,
                8,
                3,   # Count overflow
                0,
                0
            )
            val report = validate_run(run)

            expect(report.has_violations()).to_be(true)
            expect(report.violations.len()).to_be_greater_than(2)

        it "calculates max severity correctly":
            val run = create_test_run(
                "severity_test_1",
                "Running",
                future_time(),  # Critical - FutureTimestamp
                "",
                999999,  # Error - DeadProcess
                10,
                0,
                0,
                0,
                0
            )
            val report = validate_run(run)

            expect(report.max_severity()).to_be("Critical")

    # Note: Database-level and cleanup integration tests removed temporarily
    # TODO: Implement after adding TestDatabase.validate_all() and cleanup methods

    describe "Auto-Fixable Detection":

        it "marks stale/dead runs as auto-fixable":
            val stale = create_stale_run("stale_1")
            val report1 = validate_run(stale)
            expect(report1.auto_fixable).to_be(true)

            val dead = create_dead_process_run("dead_1")
            val report2 = validate_run(dead)
            expect(report2.auto_fixable).to_be(true)

        it "does not mark timestamp errors as auto-fixable":
            val bad_timestamp = create_test_run(
                "bad_ts_1",
                "Completed",
                "2026-01-30T10:00:00Z",
                "2026-01-30T09:00:00Z",
                getpid(),
                10,
                10,
                0,
                0,
                0
            )
            val report = validate_run(bad_timestamp)

            expect(report.has_violations()).to_be(true)
            expect(report.auto_fixable).to_be(false)
