"""
Feature: Format Utilities
Category: Tooling
Status: Complete

Unit tests for text formatting utilities including tables, progress bars,
spinners, indentation, boxes, trees, ANSI colors, number/byte/duration formatting.
"""

import std.spec

# =====================================
# Format Utility Implementations
# =====================================

struct TableRow:
    cells: [text]

struct Table:
    headers: [text]
    rows: [TableRow]
    column_widths: [i64]

fn create_table(headers: [text]) -> Table:
    var widths: [i64] = []
    for h in headers:
        widths = widths + [h.len()]
    Table(headers: headers, rows: [], column_widths: widths)

fn add_row(table: Table, cells: [text]) -> Table:
    var new_widths = table.column_widths
    for i in 0..cells.len():
        if i < new_widths.len() and cells[i].len() > new_widths[i]:
            new_widths = new_widths[..i] + [cells[i].len()] + new_widths[i+1..]
    Table(
        headers: table.headers,
        rows: table.rows + [TableRow(cells: cells)],
        column_widths: new_widths
    )

fn format_table(table: Table) -> text:
    var result = ""

    # Top border
    result = result + "+"
    for w in table.column_widths:
        for _ in 0..w+2:
            result = result + "-"
        result = result + "+"
    result = result + "\n"

    # Headers
    result = result + "|"
    for i in 0..table.headers.len():
        result = result + " " + table.headers[i] + " |"
    result = result + "\n"

    # Separator
    result = result + "+"
    for w in table.column_widths:
        for _ in 0..w+2:
            result = result + "-"
        result = result + "+"
    result = result + "\n"

    # Rows
    for row in table.rows:
        result = result + "|"
        for cell in row.cells:
            result = result + " " + cell + " |"
        result = result + "\n"

    # Bottom border
    result = result + "+"
    for w in table.column_widths:
        for _ in 0..w+2:
            result = result + "-"
        result = result + "+"
    result = result + "\n"

    result

fn progress_bar(current: i64, total: i64, width: i64) -> text:
    if total == 0:
        return "[" + repeat_char(" ", width) + "] 0%"

    val percent = (current * 100) / total
    val filled = (current * width) / total
    val empty = width - filled

    var bar = "["
    for _ in 0..filled:
        bar = bar + "="
    for _ in 0..empty:
        bar = bar + " "
    bar = bar + "] " + percent.to_string() + "%"
    bar

fn repeat_char(c: text, n: i64) -> text:
    var result = ""
    for _ in 0..n:
        result = result + c
    result

fn spinner_frame(frame: i64) -> text:
    val frames = ["|", "/", "-", "\\"]
    frames[frame % 4]

fn indent_text(txt: text, spaces: i64) -> text:
    var prefix = ""
    for _ in 0..spaces:
        prefix = prefix + " "

    val lines = txt.split("\n")
    var result: [text] = []
    for line in lines:
        result = result + [prefix + line]
    result.join("\n")

struct TreeNode:
    label: text
    children: [TreeNode]

fn format_tree(node: TreeNode, prefix: text, is_last: bool) -> text:
    var result = prefix
    if is_last:
        result = result + "└── "
    else:
        result = result + "├── "
    result = result + node.label + "\n"

    val child_prefix = prefix + (if is_last: "    " else: "│   ")
    for i in 0..node.children.len():
        val is_child_last = i == node.children.len() - 1
        result = result + format_tree(node.children[i], child_prefix, is_child_last)

    result

fn box_text(txt: text, style: text) -> text:
    val lines = txt.split("\n")
    var max_len = 0
    for line in lines:
        if line.len() > max_len:
            max_len = line.len()

    var top_left = "+"
    var top_right = "+"
    var bottom_left = "+"
    var bottom_right = "+"
    var horizontal = "-"
    var vertical = "|"

    if style == "single":
        top_left = "┌"
        top_right = "┐"
        bottom_left = "└"
        bottom_right = "┘"
        horizontal = "─"
        vertical = "│"
    else if style == "double":
        top_left = "╔"
        top_right = "╗"
        bottom_left = "╚"
        bottom_right = "╝"
        horizontal = "═"
        vertical = "║"
    else if style == "rounded":
        top_left = "╭"
        top_right = "╮"
        bottom_left = "╰"
        bottom_right = "╯"
        horizontal = "─"
        vertical = "│"

    var result = top_left
    for _ in 0..max_len+2:
        result = result + horizontal
    result = result + top_right + "\n"

    for line in lines:
        result = result + vertical + " " + line
        for _ in 0..max_len - line.len():
            result = result + " "
        result = result + " " + vertical + "\n"

    result = result + bottom_left
    for _ in 0..max_len+2:
        result = result + horizontal
    result = result + bottom_right + "\n"

    result

fn ansi_color(txt: text, color: text) -> text:
    # Simplified - just return text (no ANSI codes for mock)
    txt

fn ansi_style(txt: text, style: text) -> text:
    txt

fn styled_text(txt: text, color: text, style: text) -> text:
    txt

fn format_number(n: i64, separator: text) -> text:
    val str = n.to_string()
    if str.len() <= 3: return str

    var result = ""
    var count = 0
    for i in 0..str.len():
        val idx = str.len() - 1 - i
        if count > 0 and count % 3 == 0:
            result = separator + result
        result = str.chars()[idx].to_string() + result
        count = count + 1
    result

fn format_bytes(bytes: i64) -> text:
    if bytes < 1024:
        return bytes.to_string() + " B"
    else if bytes < 1024 * 1024:
        return (bytes / 1024).to_string() + " KB"
    else if bytes < 1024 * 1024 * 1024:
        return (bytes / (1024 * 1024)).to_string() + " MB"
    else:
        return (bytes / (1024 * 1024 * 1024)).to_string() + " GB"

fn format_duration_ms(ms: i64) -> text:
    if ms < 1000:
        return ms.to_string() + "ms"
    else if ms < 60000:
        return (ms / 1000).to_string() + "s"
    else if ms < 3600000:
        val minutes = ms / 60000
        val seconds = (ms % 60000) / 1000
        return minutes.to_string() + "m " + seconds.to_string() + "s"
    else:
        val hours = ms / 3600000
        val minutes = (ms % 3600000) / 60000
        return hours.to_string() + "h " + minutes.to_string() + "m"

# =====================================
# BDD Tests
# =====================================

describe "Format Utilities":
    """Tests for various text formatting operations."""

    describe "Table Formatting":
        it "creates table with headers":
            val table = create_table(["Name", "Age", "City"])
            expect table.headers.len() == 3
            expect table.rows.len() == 0
            expect table.column_widths.len() == 3

        it "adds rows":
            var table = create_table(["Name", "Age"])
            table = add_row(table, ["Alice", "30"])
            table = add_row(table, ["Bob", "25"])
            expect table.rows.len() == 2
            expect table.rows[0].cells[0] == "Alice"
            expect table.rows[1].cells[0] == "Bob"

        it "updates column widths":
            var table = create_table(["ID", "Name"])
            table = add_row(table, ["1", "Alice"])
            table = add_row(table, ["2", "VeryLongName"])
            expect table.column_widths[1] >= 12

        it "formats table with borders":
            var table = create_table(["Name", "Age"])
            table = add_row(table, ["Alice", "30"])
            table = add_row(table, ["Bob", "25"])
            val output = format_table(table)
            expect output.contains("+")
            expect output.contains("|")
            expect output.contains("Name")
            expect output.contains("Alice")
            expect output.contains("Bob")

    describe "Progress Bar":
        it "shows empty bar":
            val bar = progress_bar(current=0, total=100, width=20)
            expect bar.contains("[")
            expect bar.contains("]")
            expect bar.contains("0%")

        it "shows half bar":
            val bar = progress_bar(current=50, total=100, width=20)
            expect bar.contains("50%")

        it "shows full bar":
            val bar = progress_bar(current=100, total=100, width=20)
            expect bar.contains("100%")

        it "handles zero total":
            val bar = progress_bar(current=0, total=0, width=20)
            expect bar.contains("[")

    describe "Spinner":
        it "returns correct frames":
            expect spinner_frame(0) == "|"
            expect spinner_frame(1) == "/"
            expect spinner_frame(2) == "-"
            expect spinner_frame(3) == "\\"

        it "wraps around":
            expect spinner_frame(4) == "|"
            expect spinner_frame(5) == "/"

    describe "Indentation":
        it "indents single line":
            val result = indent_text("Hello", 4)
            expect result == "    Hello"

        it "indents multiple lines":
            val result = indent_text("Line1\nLine2\nLine3", 2)
            expect result.contains("  Line1")
            expect result.contains("  Line2")
            expect result.contains("  Line3")

        it "handles zero spaces":
            val result = indent_text("Hello", 0)
            expect result == "Hello"

    describe "Box Text":
        it "creates single border box":
            val result = box_text(txt="Hello", style="single")
            expect result.contains("┌")
            expect result.contains("┐")
            expect result.contains("└")
            expect result.contains("┘")
            expect result.contains("Hello")

        it "creates double border box":
            val result = box_text(txt="Test", style="double")
            expect result.contains("╔")
            expect result.contains("╗")
            expect result.contains("╚")
            expect result.contains("╝")

        it "creates rounded border box":
            val result = box_text(txt="Test", style="rounded")
            expect result.contains("╭")
            expect result.contains("╮")
            expect result.contains("╰")
            expect result.contains("╯")

        it "creates ASCII border box":
            val result = box_text(txt="Test", style="ascii")
            expect result.contains("+")
            expect result.contains("-")
            expect result.contains("|")

        it "handles multiline text":
            val result = box_text(txt="Line1\nLine2", style="single")
            expect result.contains("Line1")
            expect result.contains("Line2")

    describe "Tree Formatting":
        it "formats single node":
            val node = TreeNode(label: "Root", children: [])
            val result = format_tree(node, "", true)
            expect result.contains("Root")
            expect result.contains("└──")

        it "formats tree with children":
            val child1 = TreeNode(label: "Child1", children: [])
            val child2 = TreeNode(label: "Child2", children: [])
            val root = TreeNode(label: "Root", children: [child1, child2])
            val result = format_tree(root, "", true)
            expect result.contains("Root")
            expect result.contains("Child1")
            expect result.contains("Child2")
            expect result.contains("├──")
            expect result.contains("└──")

    describe "ANSI Colors and Styles":
        it "applies color":
            val result = ansi_color(txt="Error", color="red")
            expect result.contains("Error")

        it "applies style":
            val result = ansi_style(txt="Bold", style="bold")
            expect result.contains("Bold")

        it "applies combined styling":
            val result = styled_text(txt="Important", color="red", style="bold")
            expect result.contains("Important")

    describe "Number Formatting":
        it "formats small numbers":
            expect format_number(123, ",") == "123"

        it "formats thousands":
            expect format_number(1234, ",") == "1,234"

        it "formats millions":
            expect format_number(1234567, ",") == "1,234,567"

        it "uses custom separator":
            expect format_number(1234567, ".") == "1.234.567"

        it "formats zero":
            expect format_number(0, ",") == "0"

    describe "Byte Formatting":
        it "formats bytes":
            val result = format_bytes(512)
            expect result.contains("512")
            expect result.contains("B")

        it "formats kilobytes":
            val result = format_bytes(2048)
            expect result.contains("2")
            expect result.contains("KB")

        it "formats megabytes":
            val result = format_bytes(2 * 1024 * 1024)
            expect result.contains("2")
            expect result.contains("MB")

        it "formats gigabytes":
            val result = format_bytes(2 * 1024 * 1024 * 1024)
            expect result.contains("2")
            expect result.contains("GB")

    describe "Duration Formatting":
        it "formats milliseconds":
            val result = format_duration_ms(500)
            expect result == "500ms"

        it "formats seconds":
            val result = format_duration_ms(5000)
            expect result.contains("5")
            expect result.contains("s")

        it "formats minutes":
            val result = format_duration_ms(125000)
            expect result.contains("m")
            expect result.contains("s")

        it "formats hours":
            val result = format_duration_ms(7200000)
            expect result.contains("h")
            expect result.contains("m")
