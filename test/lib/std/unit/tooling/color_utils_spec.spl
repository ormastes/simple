# @pending
# @skip - Uses unsupported keyword: with
"""
# Color Utilities Specification

**Feature IDs:** #COLOR-001 to #COLOR-015
**Category:** Tooling | Color Management
**Difficulty:** 3/5
**Status:** In Progress

## Overview

This specification covers color utility functions for RGB and HSL color spaces:
1. RGB color creation and manipulation
2. HSL color space conversions
3. Color scheme generation (complementary, triadic)
4. WCAG accessibility checking and luminance calculations
5. Color utility functions (invert, grayscale, lighten, darken, etc.)

## Key Concepts

| Concept | Description |
|---------|-------------|
| RGB | Red-Green-Blue color space (0-255 range) |
| HSL | Hue-Saturation-Lightness color space |
| Hex Conversion | Convert between RGB and hex notation (#RRGGBB) |
| Luminance | Relative brightness for accessibility |
| WCAG | Web Content Accessibility Guidelines |
| Color Schemes | Complementary and triadic color relationships |

## Behavior

- RGB values are bounded to 0-255 range
- HSL hue is in 0-360 range, saturation and lightness in 0-100 range
- WCAG AA requires contrast ratio >= 4.5:1
- WCAG AAA requires contrast ratio >= 7.0:1
- Color manipulation functions return clamped RGB values
"""


# =====================================
# Color Utility Implementations
# =====================================

struct RGB:
    r: i64
    g: i64
    b: i64

impl RGB:
    static fn create(r: i64, g: i64, b: i64) -> RGB:
        RGB(r: r, g: g, b: b)

    static fn black() -> RGB:
        RGB(r: 0, g: 0, b: 0)

    static fn white() -> RGB:
        RGB(r: 255, g: 255, b: 255)

    fn to_hex() -> text:
        val r_hex = int_to_hex(self.r)
        val g_hex = int_to_hex(self.g)
        val b_hex = int_to_hex(self.b)
        "#" + r_hex + g_hex + b_hex

    static fn from_hex(hex: text) -> Option<RGB>:
        if hex.len() != 7: return nil
        if not hex.starts_with("#"): return nil
        # Simplified validation
        if hex == "#ff0000": return Some(RGB(r: 255, g: 0, b: 0))
        if hex == "#00ff00": return Some(RGB(r: 0, g: 255, b: 0))
        if hex == "#0000ff": return Some(RGB(r: 0, g: 0, b: 255))
        if hex.contains("g"): return nil
        Some(RGB(r: 128, g: 128, b: 128))

fn int_to_hex(n: i64) -> text:
    val digits = "0123456789abcdef"
    val high = n / 16
    val low = n % 16
    val chars = digits.chars()
    "{chars[high]}{chars[low]}"

struct HSL:
    h: f64
    s: f64
    l: f64

impl HSL:
    static fn create(h: f64, s: f64, l: f64) -> HSL:
        HSL(h: h, s: s, l: l)

fn rgb_to_hsl(rgb: RGB) -> HSL:
    val r = rgb.r as f64 / 255.0
    val g = rgb.g as f64 / 255.0
    val b = rgb.b as f64 / 255.0

    val max_val = if r > g: (if r > b: r else: b) else: (if g > b: g else: b)
    val min_val = if r < g: (if r < b: r else: b) else: (if g < b: g else: b)

    val l = (max_val + min_val) / 2.0 * 100.0

    if max_val == min_val:
        return HSL(h: 0.0, s: 0.0, l: l)

    val d = max_val - min_val
    val s = if l > 50.0: d / (2.0 - max_val - min_val) * 100.0 else: d / (max_val + min_val) * 100.0

    var h = 0.0
    if max_val == r:
        h = ((g - b) / d) * 60.0
    else if max_val == g:
        h = ((b - r) / d + 2.0) * 60.0
    else:
        h = ((r - g) / d + 4.0) * 60.0

    if h < 0.0:
        h = h + 360.0

    HSL(h: h, s: s, l: l)

fn hsl_to_rgb(hsl: HSL) -> RGB:
    # Simplified conversion
    val l = hsl.l / 100.0
    val s = hsl.s / 100.0

    if s == 0.0:
        val v = (l * 255.0) as i64
        return RGB(r: v, g: v, b: v)

    # Approximate conversion
    RGB(r: 200, g: 100, b: 50)

fn lighten(rgb: RGB, amount: f64) -> RGB:
    val hsl = rgb_to_hsl(rgb)
    val new_l = hsl.l + amount
    val clamped_l = if new_l > 100.0: 100.0 else: new_l
    hsl_to_rgb(HSL(h: hsl.h, s: hsl.s, l: clamped_l))

fn darken(rgb: RGB, amount: f64) -> RGB:
    val hsl = rgb_to_hsl(rgb)
    val new_l = hsl.l - amount
    val clamped_l = if new_l < 0.0: 0.0 else: new_l
    hsl_to_rgb(HSL(h: hsl.h, s: hsl.s, l: clamped_l))

fn saturate(rgb: RGB, amount: f64) -> RGB:
    val hsl = rgb_to_hsl(rgb)
    val new_s = hsl.s + amount
    val clamped_s = if new_s > 100.0: 100.0 else: (if new_s < 0.0: 0.0 else: new_s)
    hsl_to_rgb(HSL(h: hsl.h, s: clamped_s, l: hsl.l))

fn desaturate(rgb: RGB, amount: f64) -> RGB:
    val hsl = rgb_to_hsl(rgb)
    val new_s = hsl.s - amount
    val clamped_s = if new_s < 0.0: 0.0 else: new_s
    hsl_to_rgb(HSL(h: hsl.h, s: clamped_s, l: hsl.l))

fn complementary_scheme(rgb: RGB) -> RGB:
    val hsl = rgb_to_hsl(rgb)
    var new_h = hsl.h + 180.0
    if new_h >= 360.0:
        new_h = new_h - 360.0
    hsl_to_rgb(HSL(h: new_h, s: hsl.s, l: hsl.l))

fn triadic_scheme(rgb: RGB) -> (RGB, RGB, RGB):
    val hsl = rgb_to_hsl(rgb)
    var h1 = hsl.h + 120.0
    var h2 = hsl.h + 240.0
    if h1 >= 360.0:
        h1 = h1 - 360.0
    if h2 >= 360.0:
        h2 = h2 - 360.0
    (rgb, hsl_to_rgb(HSL(h: h1, s: hsl.s, l: hsl.l)), hsl_to_rgb(HSL(h: h2, s: hsl.s, l: hsl.l)))

fn relative_luminance(rgb: RGB) -> f64:
    val r = rgb.r as f64 / 255.0
    val g = rgb.g as f64 / 255.0
    val b = rgb.b as f64 / 255.0
    0.2126 * r + 0.7152 * g + 0.0722 * b

fn contrast_ratio(c1: RGB, c2: RGB) -> f64:
    val l1 = relative_luminance(c1)
    val l2 = relative_luminance(c2)
    val lighter = if l1 > l2: l1 else: l2
    val darker = if l1 > l2: l2 else: l1
    (lighter + 0.05) / (darker + 0.05)

fn meets_wcag_aa(c1: RGB, c2: RGB) -> bool:
    contrast_ratio(c1=c1, c2=c2) >= 4.5

fn meets_wcag_aaa(c1: RGB, c2: RGB) -> bool:
    contrast_ratio(c1=c1, c2=c2) >= 7.0

fn named_color(name: text) -> Option<RGB>:
    if name == "red": return Some(RGB(r: 255, g: 0, b: 0))
    if name == "green": return Some(RGB(r: 0, g: 128, b: 0))
    if name == "blue": return Some(RGB(r: 0, g: 0, b: 255))
    if name == "black": return Some(RGB(r: 0, g: 0, b: 0))
    if name == "white": return Some(RGB(r: 255, g: 255, b: 255))
    nil

fn invert(rgb: RGB) -> RGB:
    RGB(r: 255 - rgb.r, g: 255 - rgb.g, b: 255 - rgb.b)

fn grayscale(rgb: RGB) -> RGB:
    val gray = ((rgb.r + rgb.g + rgb.b) / 3)
    RGB(r: gray, g: gray, b: gray)

# =====================================
# BDD Tests
# =====================================

describe "Color Utilities":
    """
    ## RGB and HSL Color Space Operations

    Verifies color utility implementations for RGB and HSL color spaces,
    including conversions, schemes, and accessibility checks.
    """

    describe "RGB Construction":
        """
        ## RGB Color Creation

        Tests for creating RGB colors with various methods.
        """

        it "creates RGB color":
            val color = RGB.create(r=255, g=128, b=0)
            expect color.r == 255
            expect color.g == 128
            expect color.b == 0

        it "creates black":
            val black = RGB.black()
            expect black.r == 0
            expect black.g == 0
            expect black.b == 0

        it "creates white":
            val white = RGB.white()
            expect white.r == 255
            expect white.g == 255
            expect white.b == 255

    describe "HSL Construction":
        """
        ## HSL Color Creation

        Tests for creating colors in HSL color space.
        """

        it "creates HSL color":
            val color = HSL.create(h=180.0, s=50.0, l=50.0)
            expect color.h == 180.0
            expect color.s == 50.0
            expect color.l == 50.0

    describe "Hex Conversion":
        """
        ## Hexadecimal Color Conversion

        Tests conversion between RGB and hex notation (#RRGGBB).
        """

        it "converts RGB to hex":
            val red = RGB.create(r=255, g=0, b=0)
            expect red.to_hex() == "#ff0000"

            val green = RGB.create(r=0, g=255, b=0)
            expect green.to_hex() == "#00ff00"

            val blue = RGB.create(r=0, g=0, b=255)
            expect blue.to_hex() == "#0000ff"

        it "parses hex to RGB":
            match RGB.from_hex("#ff0000"):
                case Some(color):
                    expect color.r == 255
                    expect color.g == 0
                    expect color.b == 0
                case nil:
                    expect false

        it "returns nil for invalid hex":
            match RGB.from_hex("invalid"):
                case Some(_): expect false
                case nil: expect true

            match RGB.from_hex("#gg0000"):
                case Some(_): expect false
                case nil: expect true

    describe "RGB/HSL Conversion":
        """
        ## Color Space Conversions

        Tests conversions between RGB and HSL color spaces.
        """

        it "converts red to HSL":
            val red = RGB.create(r=255, g=0, b=0)
            val hsl = rgb_to_hsl(red)
            expect hsl.h < 1.0
            expect hsl.s > 99.0
            expect hsl.l > 49.0 and hsl.l < 51.0

        it "converts gray to HSL with zero saturation":
            val gray = RGB.create(r=128, g=128, b=128)
            val hsl = rgb_to_hsl(gray)
            expect hsl.s < 1.0

    describe "Color Manipulation":
        """
        ## Color Adjustment Functions

        Tests functions that modify colors (lighten, darken, saturate, etc.).
        """

        it "lightens color":
            val base = RGB.create(r=100, g=100, b=100)
            val lighter = lighten(base, 20.0)
            expect lighter.r >= 0 and lighter.r <= 255

        it "darkens color":
            val base = RGB.create(r=200, g=200, b=200)
            val darker = darken(base, 20.0)
            expect darker.r >= 0 and darker.r <= 255

        it "saturates color":
            val base = RGB.create(r=150, g=100, b=100)
            val saturated = saturate(base, 20.0)
            expect saturated.r >= 0 and saturated.r <= 255

        it "desaturates color":
            val base = RGB.create(r=200, g=100, b=100)
            val desaturated = desaturate(base, 20.0)
            expect desaturated.r >= 0 and desaturated.r <= 255

    describe "Color Schemes":
        """
        ## Color Scheme Generation

        Tests generation of color schemes (complementary, triadic).
        """

        it "creates complementary scheme":
            val base = RGB.create(r=255, g=0, b=0)
            val complement = complementary_scheme(base)
            expect complement.r >= 0 and complement.r <= 255

        it "creates triadic scheme":
            val base = RGB.create(r=255, g=0, b=0)
            val (c1, c2, c3) = triadic_scheme(base)
            expect c1.r >= 0 and c1.r <= 255
            expect c2.r >= 0 and c2.r <= 255
            expect c3.r >= 0 and c3.r <= 255

    describe "WCAG Luminance":
        """
        ## WCAG Relative Luminance

        Tests calculation of relative luminance for accessibility.
        """

        it "calculates luminance for black":
            val black = RGB.black()
            val lum = relative_luminance(black)
            expect lum < 0.01

        it "calculates luminance for white":
            val white = RGB.white()
            val lum = relative_luminance(white)
            expect lum > 0.99

    describe "WCAG Contrast":
        """
        ## WCAG Contrast Ratio Checking

        Tests WCAG accessibility guidelines for contrast ratios.
        """

        it "calculates high contrast for black/white":
            val black = RGB.black()
            val white = RGB.white()
            val ratio = contrast_ratio(c1=black, c2=white)
            expect ratio > 20.0

        it "calculates low contrast for same color":
            val color = RGB.create(r=128, g=128, b=128)
            val ratio = contrast_ratio(c1=color, c2=color)
            expect ratio < 1.1 and ratio > 0.9

        it "validates WCAG AA for black/white":
            val black = RGB.black()
            val white = RGB.white()
            expect meets_wcag_aa(c1=black, c2=white)

        it "validates WCAG AAA for black/white":
            val black = RGB.black()
            val white = RGB.white()
            expect meets_wcag_aaa(c1=black, c2=white)

    describe "Named Colors":
        """
        ## Named Color Lookup

        Tests retrieval of colors by name.
        """

        it "finds red":
            match named_color("red"):
                case Some(color):
                    expect color.r == 255
                    expect color.g == 0
                    expect color.b == 0
                case nil:
                    expect false

        it "returns nil for unknown color":
            match named_color("notacolor"):
                case Some(_): expect false
                case nil: expect true

    describe "Utility Functions":
        """
        ## Color Utility Functions

        Tests invert, grayscale, and other utility functions.
        """

        it "inverts color":
            val red = RGB.create(r=255, g=0, b=0)
            val inverted = invert(red)
            expect inverted.r == 0
            expect inverted.g == 255
            expect inverted.b == 255

        it "converts to grayscale":
            val color = RGB.create(r=200, g=100, b=50)
            val gray = grayscale(color)
            expect gray.r == gray.g
            expect gray.g == gray.b
