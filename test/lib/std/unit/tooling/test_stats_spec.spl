"""
# Test Statistics Module Specification

**Feature IDs:** #STATS
**Category:** Tooling
**Status:** Implemented

## Overview

Tests statistics computation: mean, std_dev, percentiles, outlier detection,
regression detection, and flaky test classification.
"""

use std.spec.*
use app.test_runner_new.test_stats.*

# ============================================================================
# Test Group 1: Basic Statistics
# ============================================================================

describe "compute_statistics":
    it "returns zeros for empty input":
        val stats = compute_statistics([])
        expect(stats.count).to_equal(0))
        expect(stats.mean).to_equal(0.0))
        expect(stats.std_dev).to_equal(0.0))

    it "computes stats for single value":
        val stats = compute_statistics([42.0])
        expect(stats.count).to_equal(1))
        expect(stats.mean).to_equal(42.0))
        expect(stats.median).to_equal(42.0))
        expect(stats.min).to_equal(42.0))
        expect(stats.max).to_equal(42.0))

    it "computes mean correctly":
        val stats = compute_statistics([10.0, 20.0, 30.0])
        expect(stats.mean).to_equal(20.0))

    it "computes min and max":
        val stats = compute_statistics([5.0, 1.0, 9.0, 3.0])
        expect(stats.min).to_equal(1.0))
        expect(stats.max).to_equal(9.0))

    it "computes count":
        val stats = compute_statistics([1.0, 2.0, 3.0, 4.0, 5.0])
        expect(stats.count).to_equal(5))

    it "computes median for odd count":
        val stats = compute_statistics([3.0, 1.0, 2.0])
        expect(stats.median).to_equal(2.0))

    it "computes IQR":
        val stats = compute_statistics([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0])
        expect(stats.iqr > 0.0).to_equal(true))

    it "computes cv_pct as percentage":
        val stats = compute_statistics([100.0, 100.0, 100.0])
        expect(stats.cv_pct).to_equal(0.0))

# ============================================================================
# Test Group 2: Percentiles
# ============================================================================

describe "percentile_at":
    it "returns single element for single-element list":
        expect(percentile_at([5.0], 0.5)).to_equal(5.0))

    it "returns 0 for empty list":
        expect(percentile_at([], 0.5)).to_equal(0.0))

    it "returns min for p0":
        val sorted = [1.0, 2.0, 3.0, 4.0, 5.0]
        expect(percentile_at(sorted, 0.0)).to_equal(1.0))

    it "returns max for p100":
        val sorted = [1.0, 2.0, 3.0, 4.0, 5.0]
        expect(percentile_at(sorted, 1.0)).to_equal(5.0))

    it "interpolates for p50 with even count":
        val sorted = [1.0, 2.0, 3.0, 4.0]
        val p50 = percentile_at(sorted, 0.5)
        expect(p50 > 2.0).to_equal(true))
        expect(p50 < 3.0).to_equal(true))

describe "compute_percentiles":
    it "returns zeros for empty input":
        val (p50, p90, p95, p99) = compute_percentiles([])
        expect(p50).to_equal(0.0))
        expect(p90).to_equal(0.0))

    it "returns same value for single element":
        val (p50, p90, p95, p99) = compute_percentiles([42.0])
        expect(p50).to_equal(42.0))
        expect(p99).to_equal(42.0))

    it "computes increasing percentiles":
        val samples = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]
        val (p50, p90, p95, p99) = compute_percentiles(samples)
        expect(p50 <= p90).to_equal(true))
        expect(p90 <= p95).to_equal(true))
        expect(p95 <= p99).to_equal(true))

# ============================================================================
# Test Group 3: Sort
# ============================================================================

describe "sort_f64":
    it "sorts empty list":
        val result = sort_f64([])
        expect(result.len()).to_equal(0))

    it "sorts single element":
        val result = sort_f64([5.0])
        expect(result[0]).to_equal(5.0))

    it "sorts unsorted list":
        val result = sort_f64([3.0, 1.0, 4.0, 1.0, 5.0])
        expect(result[0]).to_equal(1.0))
        expect(result[1]).to_equal(1.0))
        expect(result[2]).to_equal(3.0))
        expect(result[3]).to_equal(4.0))
        expect(result[4]).to_equal(5.0))

    it "preserves already sorted list":
        val result = sort_f64([1.0, 2.0, 3.0])
        expect(result[0]).to_equal(1.0))
        expect(result[2]).to_equal(3.0))

# ============================================================================
# Test Group 4: Outlier Detection
# ============================================================================

describe "detect_outliers_iqr":
    it "returns all as inliers for small samples":
        val result = detect_outliers_iqr([1.0, 2.0, 3.0], 1.5)
        expect(result.inliers.len()).to_equal(3))
        expect(result.outliers.len()).to_equal(0))

    it "detects outliers in data with extreme values":
        val samples = [1.0, 2.0, 2.0, 3.0, 3.0, 3.0, 4.0, 100.0]
        val result = detect_outliers_iqr(samples, 1.5)
        expect(result.outliers.len() > 0).to_equal(true))

    it "keeps all inliers for uniform data":
        val samples = [5.0, 5.0, 5.0, 5.0, 5.0]
        val result = detect_outliers_iqr(samples, 1.5)
        expect(result.inliers.len()).to_equal(5))

describe "detect_outliers_mad":
    it "returns all as inliers for small samples":
        val result = detect_outliers_mad([1.0, 2.0])
        expect(result.inliers.len()).to_equal(2))

    it "detects extreme outliers":
        val samples = [10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 1000.0]
        val result = detect_outliers_mad(samples)
        expect(result.outliers.len() > 0).to_equal(true))

describe "detect_outliers_zscore":
    it "returns all as inliers for small samples":
        val result = detect_outliers_zscore([1.0, 2.0])
        expect(result.inliers.len()).to_equal(2))

    it "detects outliers beyond 3 std devs":
        val samples = [10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 5000.0]
        val result = detect_outliers_zscore(samples)
        expect(result.outliers.len() > 0).to_equal(true))

    it "keeps all for zero variance":
        val samples = [5.0, 5.0, 5.0, 5.0, 5.0]
        val result = detect_outliers_zscore(samples)
        expect(result.inliers.len()).to_equal(5))

describe "detect_outliers dispatcher":
    it "dispatches IQR method":
        val result = detect_outliers([1.0, 2.0, 3.0, 4.0, 5.0], OutlierMethod.IQR)
        expect(result.inliers.len()).to_equal(5))

    it "dispatches MAD method":
        val result = detect_outliers([1.0, 2.0, 3.0, 4.0, 5.0], OutlierMethod.MAD)
        expect(result.inliers.len()).to_equal(5))

    it "dispatches ZScore method":
        val result = detect_outliers([1.0, 2.0, 3.0, 4.0, 5.0], OutlierMethod.ZScore)
        expect(result.inliers.len()).to_equal(5))

# ============================================================================
# Test Group 5: Regression Detection
# ============================================================================

describe "has_regression":
    it "returns false for zero baseline":
        expect(has_regression(100.0, 0.0, 0.0, 2.0)).to_equal(false))

    it "returns false for small change":
        expect(has_regression(101.0, 100.0, 10.0, 2.0)).to_equal(false))

    it "returns true for large change":
        expect(has_regression(150.0, 100.0, 10.0, 2.0)).to_equal(true))

describe "has_significant_change":
    it "returns false for zero baseline":
        expect(has_significant_change(100.0, 0.0, 20.0)).to_equal(false))

    it "returns false for small percentage change":
        expect(has_significant_change(110.0, 100.0, 20.0)).to_equal(false))

    it "returns true for large percentage change":
        expect(has_significant_change(130.0, 100.0, 20.0)).to_equal(true))

# ============================================================================
# Test Group 6: Flaky Detection
# ============================================================================

describe "detect_flaky_test":
    it "returns false for too few runs":
        expect(detect_flaky_test(3, "pass,fail,pass", 33.3)).to_equal(false))

    it "returns false for low failure rate":
        expect(detect_flaky_test(100, "pass,pass,pass,pass,pass", 2.0)).to_equal(false))

    it "returns false for high failure rate":
        expect(detect_flaky_test(100, "fail,fail,fail,fail,fail", 98.0)).to_equal(false))

    it "returns true for mixed results in range":
        expect(detect_flaky_test(20, "pass,fail,pass,fail,pass", 40.0)).to_equal(true))

    it "returns false when all pass":
        expect(detect_flaky_test(10, "pass,pass,pass,pass,pass", 0.0)).to_equal(false))

# ============================================================================
# Test Group 7: Math Helpers
# ============================================================================

describe "sqrt_f64":
    it "returns 0 for 0":
        expect(sqrt_f64(0.0)).to_equal(0.0))

    it "returns 0 for negative":
        expect(sqrt_f64(-1.0)).to_equal(0.0))

    it "computes sqrt of 4":
        val result = sqrt_f64(4.0)
        expect(result > 1.99).to_equal(true))
        expect(result < 2.01).to_equal(true))

    it "computes sqrt of 9":
        val result = sqrt_f64(9.0)
        expect(result > 2.99).to_equal(true))
        expect(result < 3.01).to_equal(true))

describe "abs_f64":
    it "returns positive for positive":
        expect(abs_f64(5.0)).to_equal(5.0))

    it "returns positive for negative":
        expect(abs_f64(-5.0)).to_equal(5.0))

    it "returns 0 for 0":
        expect(abs_f64(0.0)).to_equal(0.0))
