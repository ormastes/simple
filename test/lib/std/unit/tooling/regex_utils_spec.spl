# SSpec Tests for Regex Utilities

import sspec.{describe, it, expect, should}
import tooling.regex_utils.{regex_is_match, regex_find, regex_find_all, regex_captures, regex_replace, regex_replace_all, regex_split, is_valid_email, is_valid_url, extract_emails, extract_numbers}

describe "Regex Pattern Matching":
    """
    Tests for basic regex pattern matching functionality
    """

    it "matches simple patterns":
        """
        Given a pattern and text
        When checking if pattern matches
        Then returns correct boolean result
        """
        expect(regex_is_match(r"\d+", "Hello 123")).to_be(true)
        expect(regex_is_match(r"\d+", "Hello")).to_be(false)
        expect(regex_is_match(r"^\d+$", "123")).to_be(true)
        expect(regex_is_match(r"^\d+$", "123abc")).to_be(false)

    it "matches word boundaries":
        """
        Given pattern with word boundaries
        When matching text
        Then respects word boundaries
        """
        expect(regex_is_match(r"\bcat\b", "the cat sat")).to_be(true)
        expect(regex_is_match(r"\bcat\b", "concatenate")).to_be(false)

    it "matches character classes":
        """
        Given pattern with character classes
        When matching text
        Then applies character class rules
        """
        expect(regex_is_match(r"[a-z]+", "hello")).to_be(true)
        expect(regex_is_match(r"[A-Z]+", "HELLO")).to_be(true)
        expect(regex_is_match(r"[0-9]+", "123")).to_be(true)

describe "Regex Finding":
    """
    Tests for finding matches in text
    """

    it "finds first match":
        """
        Given a pattern
        When finding first match
        Then returns match with correct position
        """
        match regex_find(r"\d+", "Price: $42.99"):
            case Some(m):
                expect(m.text).to_equal("42")
                expect(m.start).to_be_greater_than(0)
            case None:
                fail("Expected to find match")

    it "finds all matches":
        """
        Given a pattern that matches multiple times
        When finding all matches
        Then returns all match instances
        """
        val matches = regex_find_all(r"\d+", "12 apples, 34 oranges, 56 bananas")
        expect(matches.len()).to_equal(3)
        expect(matches[0].text).to_equal("12")
        expect(matches[1].text).to_equal("34")
        expect(matches[2].text).to_equal("56")

    it "returns empty list when no matches":
        """
        Given a pattern with no matches
        When finding all matches
        Then returns empty list
        """
        val matches = regex_find_all(r"\d+", "no numbers here")
        expect(matches.len()).to_equal(0)

describe "Regex Captures":
    """
    Tests for capture groups
    """

    it "captures groups":
        """
        Given pattern with capture groups
        When matching text
        Then extracts all groups correctly
        """
        val pattern = r"(\d{3})-(\d{3})-(\d{4})"
        match regex_captures(pattern, "Call 555-123-4567"):
            case Some(caps):
                expect(caps.full_match).to_equal("555-123-4567")
                expect(caps.groups[0].unwrap()).to_equal("555")
                expect(caps.groups[1].unwrap()).to_equal("123")
                expect(caps.groups[2].unwrap()).to_equal("4567")
            case None:
                fail("Expected to find captures")

    # TODO: [runtime][P2] Named captures require dict support in FFI
    # it "handles named captures":
    #     """
    #     Given pattern with named groups
    #     When matching text
    #     Then extracts named groups
    #     """
    #     val pattern = r"(?P<year>\d{4})-(?P<month>\d{2})-(?P<day>\d{2})"
    #     match regex_captures(pattern, "Date: 2026-01-20"):
    #         case Some(caps):
    #             expect(caps.named["year"]).to_equal("2026")
    #             expect(caps.named["month"]).to_equal("01")
    #             expect(caps.named["day"]).to_equal("20")
    #         case None:
    #             fail("Expected to find captures")

describe "Regex Replace":
    """
    Tests for search and replace operations
    """

    it "replaces first match":
        """
        Given a pattern and replacement
        When replacing first match
        Then replaces only first occurrence
        """
        val result = regex_replace(r"\d+", "I have 5 apples and 3 oranges", "many")
        expect(result).to_equal("I have many apples and 3 oranges")

    it "replaces all matches":
        """
        Given a pattern and replacement
        When replacing all matches
        Then replaces all occurrences
        """
        val result = regex_replace_all(r"\d+", "I have 5 apples and 3 oranges", "X")
        expect(result).to_equal("I have X apples and X oranges")

    it "handles replacement with capture references":
        """
        Given pattern with captures
        When using capture references in replacement
        Then substitutes capture groups
        """
        val result = regex_replace_all(r"(\w+)\s+(\w+)", "hello world", "$2 $1")
        expect(result).to_equal("world hello")

describe "Regex Split":
    """
    Tests for splitting text by patterns
    """

    it "splits by pattern":
        """
        Given a delimiter pattern
        When splitting text
        Then returns array of parts
        """
        val parts = regex_split(r"\s+", "one  two   three")
        expect(parts.len()).to_equal(3)
        expect(parts[0]).to_equal("one")
        expect(parts[1]).to_equal("two")
        expect(parts[2]).to_equal("three")

    it "splits with limit":
        """
        Given a delimiter pattern and limit
        When splitting text
        Then returns limited number of parts
        """
        val parts = regex_split_n(r"\s+", "one two three four", 2)
        expect(parts.len()).to_equal(2)
        expect(parts[0]).to_equal("one")

    it "splits by comma with optional spaces":
        """
        Given CSV-like data
        When splitting by comma pattern
        Then handles optional whitespace
        """
        val parts = regex_split(r",\s*", "apple,orange, banana , grape")
        expect(parts.len()).to_equal(4)

describe "Regex Validation Helpers":
    """
    Tests for common validation patterns
    """

    it "validates email addresses":
        """
        Given various email formats
        When validating
        Then correctly identifies valid emails
        """
        expect(is_valid_email("test@example.com")).to_be(true)
        expect(is_valid_email("user.name+tag@example.co.uk")).to_be(true)
        expect(is_valid_email("invalid")).to_be(false)
        expect(is_valid_email("@example.com")).to_be(false)

    it "validates URLs":
        """
        Given various URL formats
        When validating
        Then correctly identifies valid URLs
        """
        expect(is_valid_url("https://example.com")).to_be(true)
        expect(is_valid_url("http://localhost:8080/path")).to_be(true)
        expect(is_valid_url("not a url")).to_be(false)

    it "validates IPv4 addresses":
        """
        Given IP address strings
        When validating
        Then correctly identifies valid IPs
        """
        expect(is_valid_ipv4("192.168.1.1")).to_be(true)
        expect(is_valid_ipv4("0.0.0.0")).to_be(true)
        expect(is_valid_ipv4("256.1.1.1")).to_be(false)
        expect(is_valid_ipv4("not.an.ip")).to_be(false)

describe "Regex Extraction Helpers":
    """
    Tests for text extraction utilities
    """

    it "extracts all email addresses":
        """
        Given text with multiple emails
        When extracting emails
        Then returns all email addresses
        """
        val text = "Contact alice@example.com or bob@test.org for info"
        val emails = extract_emails(text)
        expect(emails.len()).to_equal(2)
        expect(emails).to_contain("alice@example.com")
        expect(emails).to_contain("bob@test.org")

    it "extracts all numbers":
        """
        Given text with multiple numbers
        When extracting numbers
        Then returns all numeric strings
        """
        val text = "There are 42 apples, 17 oranges, and 99 bananas"
        val numbers = extract_numbers(text)
        expect(numbers.len()).to_equal(3)
        expect(numbers[0]).to_equal("42")
        expect(numbers[1]).to_equal("17")
        expect(numbers[2]).to_equal("99")

    it "extracts all URLs":
        """
        Given text with multiple URLs
        When extracting URLs
        Then returns all URL strings
        """
        val text = "Visit https://example.com or http://test.org"
        val urls = extract_urls(text)
        expect(urls.len()).to_equal(2)

describe "Regex Edge Cases":
    """
    Tests for edge cases and error handling
    """

    it "handles empty strings":
        """
        Given empty string as input
        When applying regex operations
        Then handles gracefully
        """
        expect(regex_is_match(r"\d+", "")).to_be(false)
        expect(regex_find_all(r"\d+", "")).to_be_empty()
        expect(regex_split(r"\s+", "")).to_have_length(1)

    it "handles special regex characters":
        """
        Given text with regex special characters
        When matching patterns
        Then escapes are handled correctly
        """
        expect(regex_is_match(r"\$\d+\.\d{2}", "$42.99")).to_be(true)
        expect(regex_is_match(r"\(.*\)", "(test)")).to_be(true)

    it "handles unicode text":
        """
        Given unicode text
        When applying regex
        Then handles unicode correctly
        """
        expect(regex_is_match(r"café", "café")).to_be(true)
        expect(regex_is_match(r"[α-ω]+", "αβγ")).to_be(true)
