# @pending
"""
# TODO Parser Specification

**Feature IDs:** #3110
**Category:** Tooling
**Status:** Blocked by Interpreter Limitations

Parser for extracting and categorizing TODO/FIXME comments from source files.
Supports multiple languages (Rust, Simple, Markdown), priority normalization,
and area categorization.

## Format Specification

Expected format:
```
TODO: [area][priority] description [#issue] [blocked:#issue,#issue]
FIXME: [area][priority] description [#issue] [blocked:#issue,#issue]
```

Valid areas: runtime, codegen, compiler, parser, type, stdlib, gpu, ui, test, driver, loader, pkg, doc
Valid priorities: P0, P1, P2, P3, critical, high, medium, low

## Implementation Status

✅ **Fully Implemented**: The TODO parser is production-ready:
- Simple implementation: `src/lib/std/src/tooling/todo_parser.spl` (444 lines)
- Rust implementation: `src/rust/driver/src/todo_parser.rs` with 7 integration tests
- CLI command: `simple todo-scan` (scans codebase, updates database, generates docs)
- Database: `doc/todo/todo_db.sdn` (140+ entries tracked)
- Lint rules: T001-T004 (format validation with Rust tests)

## Test Status - ⚠️ PARTIAL COVERAGE DUE TO MULTIPLE LIMITATIONS

**Interpreter Limitations**:
- ❌ Static method calls: `TodoParser.new()`, `Pattern.new()` - Error: "unsupported path call"
- ❌ Instance method calls: `item.is_valid()`, `item.normalized_priority()` - Error: "method not found on type"
- ❌ Module functions: `detect_language()`, `normalize_priority()` - Error: "function not found"
- ❌ Module constants: `TODO_AREAS`, `TODO_PRIORITIES` - Error: "variable not found"

**Path-Dependent Parse Bug**:
- ❌ Tests fail when run from project directory: `./target/debug/simple_old test test/lib/std/unit/tooling/todo_parser_spec.spl`
  - Error: "parse: Unexpected token: expected expression, found Dot"
- ✅ Tests pass when run from /tmp: `cp test/lib/std/unit/tooling/todo_parser_spec.spl /tmp && cd /tmp && ./path/to/simple_old todo_parser_spec.spl`
  - Result: **8 examples, 0 failures** ✅

**What Works (Tested Below)**:
- Direct construction of TodoItem, ParseResult, ParseError
- Field access on constructed instances
- Verification that data structures can be created with correct field values

**What's Blocked**:
- All business logic (validation, parsing, formatting, normalization) due to interpreter not supporting method calls
- Running from project directory due to path-dependent module resolution bug

## Full Verification

The TODO parser functionality IS thoroughly tested in Rust:
```bash
# Run Rust integration tests (7 passing tests)
cargo test -p simple-driver todo_parser

# Run lint tests (T001-T003 rules, all passing)
cargo test -p simple-compiler test_todo_format
```

##  Test Coverage Summary

**Planned**: 50+ tests covering all TODO parser functionality
**Implemented**: 8 basic tests (field access only)
**Blocked**: 42+ tests (requires method call support in interpreter)

Once the Simple interpreter supports method calls on imported classes, this spec
should be expanded to include the full test suite from the implementation plan.
"""

# NOTE: describe/it/expect are built-in
use tooling.TodoItem.*
use tooling.ParseResult.*
use tooling.ParseError.*

# =========================================================================
# TodoItem Construction Tests (Field Access Only)
# =========================================================================

describe "TodoItem construction and field access":
    """
    Minimal tests verifying TodoItem instances can be created and fields accessed.

    Note: Methods like is_valid(), validation_errors(), normalized_priority(),
    and to_string() cannot be tested due to interpreter limitations.
    """

    it "should construct TodoItem with all fields and access them":
        val item = TodoItem {
            keyword: "TODO",
            area: "runtime",
            priority: "P1",
            description: "Add GC optimization",
            issue: Some("123"),
            blocked: ["456", "789"],
            file: "gc.spl",
            line: 42,
            raw_text: "# TODO: [runtime][P1] Add GC optimization [#123] [blocked:#456,#789]"
        }

        # Verify all fields are accessible and have correct values
        expect item.keyword == "TODO"
        expect item.area == "runtime"
        expect item.priority == "P1"
        expect item.description == "Add GC optimization"
        expect item.file == "gc.spl"
        expect item.line == 42

    it "should construct TodoItem with FIXME keyword":
        val item = TodoItem {
            keyword: "FIXME",
            area: "parser",
            priority: "P0",
            description: "Fix crash on invalid input",
            issue: nil,
            blocked: [],
            file: "parser.rs",
            line: 100,
            raw_text: "// FIXME: [parser][P0] Fix crash on invalid input"
        }
        expect item.keyword == "FIXME"
        expect item.area == "parser"
        expect item.priority == "P0"

    it "should construct TodoItem with issue number":
        val item = TodoItem {
            keyword: "TODO",
            area: "compiler",
            priority: "P1",
            description: "Implement feature X",
            issue: Some("456"),
            blocked: [],
            file: "compiler.spl",
            line: 200,
            raw_text: "# TODO: [compiler][P1] Implement feature X [#456]"
        }
        expect item.issue.is_some
        expect item.issue.unwrap == "456"

    it "should construct TodoItem with blocked issues":
        val item = TodoItem {
            keyword: "TODO",
            area: "codegen",
            priority: "P2",
            description: "Optimize code generation",
            issue: nil,
            blocked: ["100", "200", "300"],
            file: "codegen.spl",
            line: 50,
            raw_text: "# TODO: [codegen][P2] Optimize code generation [blocked:#100,#200,#300]"
        }
        expect item.blocked.len == 3
        expect item.blocked[0] == "100"
        expect item.blocked[1] == "200"
        expect item.blocked[2] == "300"

    it "should construct TodoItem with both issue and blocked":
        val item = TodoItem {
            keyword: "FIXME",
            area: "stdlib",
            priority: "P1",
            description: "Add string methods",
            issue: Some("500"),
            blocked: ["600"],
            file: "string.spl",
            line: 75,
            raw_text: "# FIXME: [stdlib][P1] Add string methods [#500] [blocked:#600]"
        }
        expect item.issue.is_some
        expect item.blocked.len == 1

# =========================================================================
# ParseResult Construction Tests (Field Access Only)
# =========================================================================

describe "ParseResult construction and field access":
    """
    Minimal tests verifying ParseResult instances can be created and fields accessed.

    Note: Methods like add_todo(), add_error(), and merge() cannot be tested
    due to interpreter limitations.
    """

    it "should construct empty ParseResult":
        val result = ParseResult {
            todos: [],
            errors: []
        }
        expect result.todos.len == 0
        expect result.errors.len == 0

    it "should construct ParseResult with todos":
        val item = TodoItem {
            keyword: "TODO",
            area: "test",
            priority: "P3",
            description: "Write more tests",
            issue: nil,
            blocked: [],
            file: "test.spl",
            line: 1,
            raw_text: "# TODO: [test][P3] Write more tests"
        }
        val result = ParseResult {
            todos: [item],
            errors: []
        }
        expect result.todos.len == 1
        expect result.todos[0].description == "Write more tests"

# =========================================================================
# ParseError Construction Tests (Field Access Only)
# =========================================================================

describe "ParseError construction and field access":
    """
    Minimal tests verifying ParseError instances can be created and fields accessed.

    Note: The to_string() method cannot be tested due to interpreter limitations.
    """

    it "should construct ParseError with all fields":
        val error = ParseError {
            file: "bad.spl",
            line: 42,
            message: "Invalid TODO format: missing [area][priority]",
            raw_text: "# TODO: fix this"
        }
        expect error.file == "bad.spl"
        expect error.line == 42
        expect error.message.contains("Invalid TODO format")
        expect error.raw_text == "# TODO: fix this"
