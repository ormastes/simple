# Tests for Option and Result utilities

use tooling.option_utils.*

# =====================================
# Option Utilities Tests
# =====================================

fn test_map_option_some():
    val opt = Some(5)
    val result = map_option(opt, \x: x * 2)
    match result:
        Some(value) => assert(value == 10)
        None => assert(false)

fn test_map_option_none():
    val opt: Option<i32> = None
    val result = map_option(opt, \x: x * 2)
    match result:
        Some(_) => assert(false)
        None => assert(true)

fn test_flat_map_option_some():
    val opt = Some(5)
    val result = flat_map_option(opt, \x: if x > 0: Some(x * 2) else: None)
    match result:
        Some(value) => assert(value == 10)
        None => assert(false)

fn test_flat_map_option_none():
    val opt: Option<i32> = None
    val result = flat_map_option(opt, \x: Some(x * 2))
    match result:
        Some(_) => assert(false)
        None => assert(true)

fn test_flat_map_option_returns_none():
    val opt = Some(-5)
    val result = flat_map_option(opt, \x: if x > 0: Some(x * 2) else: None)
    match result:
        Some(_) => assert(false)
        None => assert(true)

fn test_unwrap_or_some():
    val opt = Some(42)
    val result = unwrap_or(opt, 0)
    assert(result == 42)

fn test_unwrap_or_none():
    val opt: Option<i32> = None
    val result = unwrap_or(opt, 99)
    assert(result == 99)

fn test_unwrap_or_else_some():
    val opt = Some(42)
    val result = unwrap_or_else(opt, \: 0)
    assert(result == 42)

fn test_unwrap_or_else_none():
    val opt: Option<i32> = None
    val result = unwrap_or_else(opt, \: 99)
    assert(result == 99)

fn test_ok_or_some():
    val opt = Some(42)
    val result = ok_or(opt, "error")
    match result:
        Ok(value) => assert(value == 42)
        Err(_) => assert(false)

fn test_ok_or_none():
    val opt: Option<i32> = None
    val result = ok_or(opt, "not found")
    match result:
        Ok(_) => assert(false)
        Err(msg) => assert(msg == "not found")

fn test_is_some_true():
    val opt = Some(42)
    assert(is_some(opt))

fn test_is_some_false():
    val opt: Option<i32> = None
    assert(not is_some(opt))

fn test_is_none_true():
    val opt: Option<i32> = None
    assert(is_none(opt))

fn test_is_none_false():
    val opt = Some(42)
    assert(not is_none(opt))

fn test_filter_option_predicate_true():
    val opt = Some(42)
    val result = filter_option(opt, \x: x > 10)
    match result:
        Some(value) => assert(value == 42)
        None => assert(false)

fn test_filter_option_predicate_false():
    val opt = Some(5)
    val result = filter_option(opt, \x: x > 10)
    match result:
        Some(_) => assert(false)
        None => assert(true)

fn test_filter_option_none():
    val opt: Option<i32> = None
    val result = filter_option(opt, \x: x > 10)
    match result:
        Some(_) => assert(false)
        None => assert(true)

fn test_zip_option_both_some():
    val opt_a = Some(10)
    val opt_b = Some(20)
    val result = zip_option(opt_a, opt_b)
    match result:
        Some((a, b)) =>
            assert(a == 10)
            assert(b == 20)
        None => assert(false)

fn test_zip_option_first_none():
    val opt_a: Option<i32> = None
    val opt_b = Some(20)
    val result = zip_option(opt_a, opt_b)
    match result:
        Some(_) => assert(false)
        None => assert(true)

fn test_zip_option_second_none():
    val opt_a = Some(10)
    val opt_b: Option<i32> = None
    val result = zip_option(opt_a, opt_b)
    match result:
        Some(_) => assert(false)
        None => assert(true)

fn test_zip_option_both_none():
    val opt_a: Option<i32> = None
    val opt_b: Option<i32> = None
    val result = zip_option(opt_a, opt_b)
    match result:
        Some(_) => assert(false)
        None => assert(true)

# =====================================
# Result Utilities Tests
# =====================================

fn test_map_result_ok():
    val result: Result<i32, text> = Ok(5)
    val mapped = map_result(result, \x: x * 2)
    match mapped:
        Ok(value) => assert(value == 10)
        Err(_) => assert(false)

fn test_map_result_err():
    val result: Result<i32, text> = Err("error")
    val mapped = map_result(result, \x: x * 2)
    match mapped:
        Ok(_) => assert(false)
        Err(msg) => assert(msg == "error")

fn test_map_err_ok():
    val result: Result<i32, text> = Ok(42)
    val mapped = map_err(result, \msg: msg.to_uppercase())
    match mapped:
        Ok(value) => assert(value == 42)
        Err(_) => assert(false)

fn test_map_err_err():
    val result: Result<i32, text> = Err("error")
    val mapped = map_err(result, \msg: msg.to_uppercase())
    match mapped:
        Ok(_) => assert(false)
        Err(msg) => assert(msg == "ERROR")

fn test_flat_map_result_ok():
    val result: Result<i32, text> = Ok(5)
    val mapped = flat_map_result(result, \x: if x > 0: Ok(x * 2) else: Err("negative"))
    match mapped:
        Ok(value) => assert(value == 10)
        Err(_) => assert(false)

fn test_flat_map_result_ok_to_err():
    val result: Result<i32, text> = Ok(-5)
    val mapped = flat_map_result(result, \x: if x > 0: Ok(x * 2) else: Err("negative"))
    match mapped:
        Ok(_) => assert(false)
        Err(msg) => assert(msg == "negative")

fn test_flat_map_result_err():
    val result: Result<i32, text> = Err("original error")
    val mapped = flat_map_result(result, \x: Ok(x * 2))
    match mapped:
        Ok(_) => assert(false)
        Err(msg) => assert(msg == "original error")

fn test_unwrap_or_result_ok():
    val result: Result<i32, text> = Ok(42)
    val value = unwrap_or_result(result, 0)
    assert(value == 42)

fn test_unwrap_or_result_err():
    val result: Result<i32, text> = Err("error")
    val value = unwrap_or_result(result, 99)
    assert(value == 99)

fn test_unwrap_or_else_result_ok():
    val result: Result<i32, text> = Ok(42)
    val value = unwrap_or_else_result(result, \msg: 0)
    assert(value == 42)

fn test_unwrap_or_else_result_err():
    val result: Result<i32, text> = Err("error")
    val value = unwrap_or_else_result(result, \msg: 99)
    assert(value == 99)

fn test_is_ok_true():
    val result: Result<i32, text> = Ok(42)
    assert(is_ok(result))

fn test_is_ok_false():
    val result: Result<i32, text> = Err("error")
    assert(not is_ok(result))

fn test_is_err_true():
    val result: Result<i32, text> = Err("error")
    assert(is_err(result))

fn test_is_err_false():
    val result: Result<i32, text> = Ok(42)
    assert(not is_err(result))

fn test_ok_from_ok_result():
    val result: Result<i32, text> = Ok(42)
    val opt = ok(result)
    match opt:
        Some(value) => assert(value == 42)
        None => assert(false)

fn test_ok_from_err_result():
    val result: Result<i32, text> = Err("error")
    val opt = ok(result)
    match opt:
        Some(_) => assert(false)
        None => assert(true)

fn test_err_from_ok_result():
    val result: Result<i32, text> = Ok(42)
    val opt = err(result)
    match opt:
        Some(_) => assert(false)
        None => assert(true)

fn test_err_from_err_result():
    val result: Result<i32, text> = Err("failure")
    val opt = err(result)
    match opt:
        Some(msg) => assert(msg == "failure")
        None => assert(false)

# =====================================
# Collection Utilities Tests
# =====================================

fn test_sequence_options_all_some():
    val list = [Some(1), Some(2), Some(3)]
    val result = sequence_options(list)
    match result:
        Some(values) =>
            assert(values.len() == 3)
            assert(values[0] == 1)
            assert(values[1] == 2)
            assert(values[2] == 3)
        None => assert(false)

fn test_sequence_options_contains_none():
    val list = [Some(1), None, Some(3)]
    val result = sequence_options(list)
    match result:
        Some(_) => assert(false)
        None => assert(true)

fn test_sequence_options_empty():
    val list: List<Option<i32>> = []
    val result = sequence_options(list)
    match result:
        Some(values) => assert(values.len() == 0)
        None => assert(false)

fn test_sequence_results_all_ok():
    val list: List<Result<i32, text>> = [Ok(1), Ok(2), Ok(3)]
    val result = sequence_results(list)
    match result:
        Ok(values) =>
            assert(values.len() == 3)
            assert(values[0] == 1)
            assert(values[1] == 2)
            assert(values[2] == 3)
        Err(_) => assert(false)

fn test_sequence_results_contains_err():
    val list: List<Result<i32, text>> = [Ok(1), Err("failure"), Ok(3)]
    val result = sequence_results(list)
    match result:
        Ok(_) => assert(false)
        Err(msg) => assert(msg == "failure")

fn test_sequence_results_empty():
    val list: List<Result<i32, text>> = []
    val result = sequence_results(list)
    match result:
        Ok(values) => assert(values.len() == 0)
        Err(_) => assert(false)

fn test_flatten_options_all_some():
    val list = [Some(1), Some(2), Some(3)]
    val result = flatten_options(list)
    assert(result.len() == 3)
    assert(result[0] == 1)
    assert(result[1] == 2)
    assert(result[2] == 3)

fn test_flatten_options_mixed():
    val list = [Some(1), None, Some(3), None, Some(5)]
    val result = flatten_options(list)
    assert(result.len() == 3)
    assert(result[0] == 1)
    assert(result[1] == 3)
    assert(result[2] == 5)

fn test_flatten_options_all_none():
    val list: List<Option<i32>> = [None, None, None]
    val result = flatten_options(list)
    assert(result.len() == 0)

fn test_partition_results_all_ok():
    val list: List<Result<i32, text>> = [Ok(1), Ok(2), Ok(3)]
    val (successes, failures) = partition_results(list)
    assert(successes.len() == 3)
    assert(failures.len() == 0)

fn test_partition_results_all_err():
    val list: List<Result<i32, text>> = [Err("a"), Err("b"), Err("c")]
    val (successes, failures) = partition_results(list)
    assert(successes.len() == 0)
    assert(failures.len() == 3)

fn test_partition_results_mixed():
    val list: List<Result<i32, text>> = [Ok(1), Err("a"), Ok(3), Err("b"), Ok(5)]
    val (successes, failures) = partition_results(list)
    assert(successes.len() == 3)
    assert(successes[0] == 1)
    assert(successes[1] == 3)
    assert(successes[2] == 5)
    assert(failures.len() == 2)
    assert(failures[0] == "a")
    assert(failures[1] == "b")

# =====================================
# Combinator Tests
# =====================================

fn test_first_ok_first_succeeds():
    val ops = [
        \: Ok(1),
        \: Ok(2),
        \: Ok(3)
    ]
    val result: Result<i32, List<text>> = first_ok(ops)
    match result:
        Ok(value) => assert(value == 1)
        Err(_) => assert(false)

fn test_first_ok_second_succeeds():
    val ops = [
        \: Err("fail1"),
        \: Ok(2),
        \: Ok(3)
    ]
    val result: Result<i32, List<text>> = first_ok(ops)
    match result:
        Ok(value) => assert(value == 2)
        Err(_) => assert(false)

fn test_first_ok_all_fail():
    val ops = [
        \: Err("fail1"),
        \: Err("fail2"),
        \: Err("fail3")
    ]
    val result: Result<i32, List<text>> = first_ok(ops)
    match result:
        Ok(_) => assert(false)
        Err(errors) => assert(errors.len() == 3)

fn test_all_ok_success():
    val ops = [
        \: Ok(1),
        \: Ok(2),
        \: Ok(3)
    ]
    val result: Result<List<i32>, text> = all_ok(ops)
    match result:
        Ok(values) =>
            assert(values.len() == 3)
            assert(values[0] == 1)
            assert(values[1] == 2)
            assert(values[2] == 3)
        Err(_) => assert(false)

fn test_all_ok_failure():
    val ops = [
        \: Ok(1),
        \: Err("fail"),
        \: Ok(3)
    ]
    val result: Result<List<i32>, text> = all_ok(ops)
    match result:
        Ok(_) => assert(false)
        Err(msg) => assert(msg == "fail")

fn test_try_or_success():
    val result = try_or(\: Ok(42), 0)
    assert(result == 42)

fn test_try_or_failure():
    val result = try_or(\: Err("fail"), 99)
    assert(result == 99)

fn test_chain_success():
    val result: Result<i32, text> = chain(\: Ok(5), \x: Ok(x * 2))
    match result:
        Ok(value) => assert(value == 10)
        Err(_) => assert(false)

fn test_chain_first_fails():
    val result: Result<i32, text> = chain(\: Err("fail"), \x: Ok(x * 2))
    match result:
        Ok(_) => assert(false)
        Err(msg) => assert(msg == "fail")

fn test_chain_second_fails():
    val result: Result<i32, text> = chain(\: Ok(5), \x: Err("fail"))
    match result:
        Ok(_) => assert(false)
        Err(msg) => assert(msg == "fail")

fn test_transpose_result_option_ok_some():
    val result: Result<Option<i32>, text> = Ok(Some(42))
    val transposed = transpose_result_option(result)
    match transposed:
        Some(inner_result) =>
            match inner_result:
                Ok(value) => assert(value == 42)
                Err(_) => assert(false)
        None => assert(false)

fn test_transpose_result_option_ok_none():
    val result: Result<Option<i32>, text> = Ok(None)
    val transposed = transpose_result_option(result)
    match transposed:
        Some(_) => assert(false)
        None => assert(true)

fn test_transpose_result_option_err():
    val result: Result<Option<i32>, text> = Err("error")
    val transposed = transpose_result_option(result)
    match transposed:
        Some(inner_result) =>
            match inner_result:
                Ok(_) => assert(false)
                Err(msg) => assert(msg == "error")
        None => assert(false)

fn test_transpose_option_result_some_ok():
    val opt: Option<Result<i32, text>> = Some(Ok(42))
    val transposed = transpose_option_result(opt)
    match transposed:
        Ok(inner_opt) =>
            match inner_opt:
                Some(value) => assert(value == 42)
                None => assert(false)
        Err(_) => assert(false)

fn test_transpose_option_result_some_err():
    val opt: Option<Result<i32, text>> = Some(Err("error"))
    val transposed = transpose_option_result(opt)
    match transposed:
        Ok(_) => assert(false)
        Err(msg) => assert(msg == "error")

fn test_transpose_option_result_none():
    val opt: Option<Result<i32, text>> = None
    val transposed = transpose_option_result(opt)
    match transposed:
        Ok(inner_opt) =>
            match inner_opt:
                Some(_) => assert(false)
                None => assert(true)
        Err(_) => assert(false)

fn test_result_to_option_ok():
    val result: Result<i32, text> = Ok(42)
    val opt = result_to_option(result)
    match opt:
        Some(value) => assert(value == 42)
        None => assert(false)

fn test_result_to_option_err():
    val result: Result<i32, text> = Err("error")
    val opt = result_to_option(result)
    match opt:
        Some(_) => assert(false)
        None => assert(true)

fn test_flatten_result_ok_ok():
    val result: Result<Result<i32, text>, text> = Ok(Ok(42))
    val flattened = flatten_result(result)
    match flattened:
        Ok(value) => assert(value == 42)
        Err(_) => assert(false)

fn test_flatten_result_ok_err():
    val result: Result<Result<i32, text>, text> = Ok(Err("inner"))
    val flattened = flatten_result(result)
    match flattened:
        Ok(_) => assert(false)
        Err(msg) => assert(msg == "inner")

fn test_flatten_result_err():
    val result: Result<Result<i32, text>, text> = Err("outer")
    val flattened = flatten_result(result)
    match flattened:
        Ok(_) => assert(false)
        Err(msg) => assert(msg == "outer")

fn test_bimap_ok():
    val result: Result<i32, text> = Ok(5)
    val mapped = bimap(result, \x: x * 2, \msg: msg.to_uppercase())
    match mapped:
        Ok(value) => assert(value == 10)
        Err(_) => assert(false)

fn test_bimap_err():
    val result: Result<i32, text> = Err("error")
    val mapped = bimap(result, \x: x * 2, \msg: msg.to_uppercase())
    match mapped:
        Ok(_) => assert(false)
        Err(msg) => assert(msg == "ERROR")

fn test_recover_ok():
    val result: Result<i32, text> = Ok(42)
    val recovered = recover(result, \msg: 0)
    match recovered:
        Ok(value) => assert(value == 42)
        Err(_) => assert(false)

fn test_recover_err():
    val result: Result<i32, text> = Err("error")
    val recovered = recover(result, \msg: 99)
    match recovered:
        Ok(value) => assert(value == 99)
        Err(_) => assert(false)

fn test_combine_results_both_ok():
    val result1: Result<i32, text> = Ok(10)
    val result2: Result<i32, text> = Ok(20)
    val combined = combine_results(result1, result2, \a, b: a + b)
    match combined:
        Ok(value) => assert(value == 30)
        Err(_) => assert(false)

fn test_combine_results_first_err():
    val result1: Result<i32, text> = Err("fail1")
    val result2: Result<i32, text> = Ok(20)
    val combined = combine_results(result1, result2, \a, b: a + b)
    match combined:
        Ok(_) => assert(false)
        Err(msg) => assert(msg == "fail1")

fn test_combine_results_second_err():
    val result1: Result<i32, text> = Ok(10)
    val result2: Result<i32, text> = Err("fail2")
    val combined = combine_results(result1, result2, \a, b: a + b)
    match combined:
        Ok(_) => assert(false)
        Err(msg) => assert(msg == "fail2")

fn test_combine_results3_all_ok():
    val result1: Result<i32, text> = Ok(10)
    val result2: Result<i32, text> = Ok(20)
    val result3: Result<i32, text> = Ok(30)
    val combined = combine_results3(result1, result2, result3, \a, b, c: a + b + c)
    match combined:
        Ok(value) => assert(value == 60)
        Err(_) => assert(false)

fn test_combine_results3_first_err():
    val result1: Result<i32, text> = Err("fail1")
    val result2: Result<i32, text> = Ok(20)
    val result3: Result<i32, text> = Ok(30)
    val combined = combine_results3(result1, result2, result3, \a, b, c: a + b + c)
    match combined:
        Ok(_) => assert(false)
        Err(msg) => assert(msg == "fail1")

fn test_inspect_ok_called():
    var called = false
    var inspected_value = 0

    val result: Result<i32, text> = Ok(42)
    inspect_ok(result, \x:
        called = true
        inspected_value = x
    )

    assert(called)
    assert(inspected_value == 42)

fn test_inspect_ok_not_called():
    var called = false

    val result: Result<i32, text> = Err("error")
    inspect_ok(result, \x:
        called = true
    )

    assert(not called)

fn test_inspect_err_called():
    var called = false
    var inspected_msg = ""

    val result: Result<i32, text> = Err("failure")
    inspect_err(result, \msg:
        called = true
        inspected_msg = msg
    )

    assert(called)
    assert(inspected_msg == "failure")

fn test_inspect_err_not_called():
    var called = false

    val result: Result<i32, text> = Ok(42)
    inspect_err(result, \msg:
        called = true
    )

    assert(not called)
