"""
Algorithm Utilities Tests

Tests for sorting algorithms, searching algorithms, list manipulation,
and utility functions for working with i64 lists.

Feature:
  Algorithm utility functions

Category:
  Tooling/Algorithms

Status:
  Complete

Implementation:
  All algorithm utility functions are provided locally in this test file.
  This allows tests to be independent of external dependencies.
"""

import std.spec

# =====================================
# Helper Functions
# =====================================

fn is_sorted(list: [i64]) -> bool:
    if list.len() <= 1:
        return true
    for i in 0..(list.len() - 1):
        if list[i] > list[i + 1]:
            return false
    true

fn lists_equal(a: [i64], b: [i64]) -> bool:
    if a.len() != b.len():
        return false
    for i in 0..a.len():
        if a[i] != b[i]:
            return false
    true

fn swap(list: [i64], i: i64, j: i64) -> [i64]:
    var result = list
    val temp = result[i]
    result[i] = result[j]
    result[j] = temp
    result

# =====================================
# Sorting Algorithms
# =====================================

fn bubble_sort(list: [i64]) -> [i64]:
    var result = list
    val n = result.len()
    for i in 0..n:
        for j in 0..(n - i - 1):
            if result[j] > result[j + 1]:
                result = swap(result, i=j, j=j + 1)
    result

fn selection_sort(list: [i64]) -> [i64]:
    var result = list
    val n = result.len()
    for i in 0..n:
        var min_idx = i
        for j in (i + 1)..n:
            if result[j] < result[min_idx]:
                min_idx = j
        if min_idx != i:
            result = swap(result, i=i, j=min_idx)
    result

fn insertion_sort(list: [i64]) -> [i64]:
    var result = list
    val n = result.len()
    for i in 1..n:
        val key = result[i]
        var j = i - 1
        while j >= 0 and result[j] > key:
            result[j + 1] = result[j]
            j = j - 1
        result[j + 1] = key
    result

fn quick_sort(list: [i64]) -> [i64]:
    if list.len() <= 1:
        return list
    val pivot = list[list.len() / 2]
    var less: [i64] = []
    var equal: [i64] = []
    var greater: [i64] = []
    for x in list:
        if x < pivot:
            less = less + [x]
        else if x == pivot:
            equal = equal + [x]
        else:
            greater = greater + [x]
    quick_sort(less) + equal + quick_sort(greater)

fn merge_sort(list: [i64]) -> [i64]:
    if list.len() <= 1:
        return list
    val mid = list.len() / 2
    var left: [i64] = []
    var right: [i64] = []
    for i in 0..mid:
        left = left + [list[i]]
    for i in mid..list.len():
        right = right + [list[i]]
    merge_sorted(left=merge_sort(left), right=merge_sort(right))

fn merge_sorted(left: [i64], right: [i64]) -> [i64]:
    var result: [i64] = []
    var i = 0
    var j = 0
    while i < left.len() and j < right.len():
        if left[i] <= right[j]:
            result = result + [left[i]]
            i = i + 1
        else:
            result = result + [right[j]]
            j = j + 1
    while i < left.len():
        result = result + [left[i]]
        i = i + 1
    while j < right.len():
        result = result + [right[j]]
        j = j + 1
    result

# =====================================
# Search Algorithms
# =====================================

fn linear_search(list: [i64], target: i64) -> Option<i64>:
    for i in 0..list.len():
        if list[i] == target:
            return Some(i)
    nil

fn binary_search(list: [i64], target: i64) -> Option<i64>:
    var low = 0
    var high = list.len() - 1
    while low <= high:
        val mid = (low + high) / 2
        if list[mid] == target:
            return Some(mid)
        else if list[mid] < target:
            low = mid + 1
        else:
            high = mid - 1
    nil

fn find_min(list: [i64]) -> Option<i64>:
    if list.len() == 0:
        return nil
    var min_val = list[0]
    for x in list:
        if x < min_val:
            min_val = x
    Some(min_val)

fn find_max(list: [i64]) -> Option<i64>:
    if list.len() == 0:
        return nil
    var max_val = list[0]
    for x in list:
        if x > max_val:
            max_val = x
    Some(max_val)

fn find_min_index(list: [i64]) -> Option<i64>:
    if list.len() == 0:
        return nil
    var min_idx = 0
    for i in 1..list.len():
        if list[i] < list[min_idx]:
            min_idx = i
    Some(min_idx)

fn find_max_index(list: [i64]) -> Option<i64>:
    if list.len() == 0:
        return nil
    var max_idx = 0
    for i in 1..list.len():
        if list[i] > list[max_idx]:
            max_idx = i
    Some(max_idx)

# =====================================
# List Manipulation
# =====================================

fn reverse_list(list: [i64]) -> [i64]:
    var result: [i64] = []
    for i in 0..list.len():
        result = [list[i]] + result
    result

fn take(list: [i64], n: i64) -> [i64]:
    var result: [i64] = []
    val count = if n < list.len(): n else: list.len()
    for i in 0..count:
        result = result + [list[i]]
    result

fn drop(list: [i64], n: i64) -> [i64]:
    if n >= list.len():
        return []
    var result: [i64] = []
    for i in n..list.len():
        result = result + [list[i]]
    result

fn sum(list: [i64]) -> i64:
    var total = 0
    for x in list:
        total = total + x
    total

fn count_occurrences(list: [i64], target: i64) -> i64:
    var match_count = 0
    for x in list:
        if x == target:
            match_count = match_count + 1
    match_count

fn find_all_indices(list: [i64], target: i64) -> [i64]:
    var indices: [i64] = []
    for i in 0..list.len():
        if list[i] == target:
            indices = indices + [i]
    indices

fn remove_duplicates(list: [i64]) -> [i64]:
    var result: [i64] = []
    for x in list:
        var found = false
        for y in result:
            if x == y:
                found = true
        if not found:
            result = result + [x]
    result

fn is_prefix(prefix: [i64], list: [i64]) -> bool:
    if prefix.len() > list.len():
        return false
    for i in 0..prefix.len():
        if prefix[i] != list[i]:
            return false
    true

fn is_suffix(suffix: [i64], list: [i64]) -> bool:
    if suffix.len() > list.len():
        return false
    val offset = list.len() - suffix.len()
    for i in 0..suffix.len():
        if suffix[i] != list[offset + i]:
            return false
    true

fn find_sublist(haystack: [i64], needle: [i64]) -> Option<i64>:
    if needle.len() > haystack.len():
        return nil
    for i in 0..(haystack.len() - needle.len() + 1):
        var found = true
        for j in 0..needle.len():
            if haystack[i + j] != needle[j]:
                found = false
        if found:
            return Some(i)
    nil

# =====================================
# BDD Tests
# =====================================

describe "Algorithm Utilities":
    """
    Comprehensive tests for algorithm utility functions covering sorting algorithms,
    search algorithms, list manipulation, and statistical operations on i64 lists.
    """

    describe "Sorting":
        it "bubble sort works":
            val unsorted = [3, 1, 4, 1, 5, 9, 2, 6]
            val sorted = bubble_sort(unsorted)
            expect is_sorted(sorted)
            expect sorted[0] == 1

        it "selection sort works":
            val unsorted = [64, 25, 12, 22, 11]
            val sorted = selection_sort(unsorted)
            expect is_sorted(sorted)
            expect sorted[0] == 11

        it "insertion sort works":
            val unsorted = [12, 11, 13, 5, 6]
            val sorted = insertion_sort(unsorted)
            expect is_sorted(sorted)
            expect sorted[0] == 5

        it "quick sort works":
            val unsorted = [10, 7, 8, 9, 1, 5]
            val sorted = quick_sort(unsorted)
            expect is_sorted(sorted)
            expect sorted[0] == 1

        it "merge sort works":
            val unsorted = [38, 27, 43, 3, 9, 82, 10]
            val sorted = merge_sort(unsorted)
            expect is_sorted(sorted)
            expect sorted[0] == 3

        it "merge sorted lists":
            val left = [1, 3, 5]
            val right = [2, 4, 6]
            val merged = merge_sorted(left=left, right=right)
            expect lists_equal(a=merged, b=[1, 2, 3, 4, 5, 6])

        it "is_sorted detects sorted list":
            expect is_sorted([1, 2, 3, 4, 5])

        it "is_sorted detects unsorted list":
            expect not is_sorted([1, 3, 2, 4, 5])

        it "is_sorted handles empty list":
            val empty: [i64] = []
            expect is_sorted(empty)

    describe "Searching":
        it "linear search finds element":
            val list = [10, 20, 30, 40, 50]
            match linear_search(list, 30):
                case Some(idx): expect idx == 2
                case nil: expect false

        it "linear search returns nil for missing":
            val list = [10, 20, 30, 40, 50]
            match linear_search(list, 25):
                case Some(_): expect false
                case nil: expect true

        it "binary search finds element":
            val list = [1, 3, 5, 7, 9, 11, 13]
            match binary_search(list, 7):
                case Some(idx): expect idx == 3
                case nil: expect false

        it "binary search returns nil for missing":
            val list = [1, 3, 5, 7, 9, 11, 13]
            match binary_search(list, 6):
                case Some(_): expect false
                case nil: expect true

        it "find_min returns minimum":
            val list = [5, 2, 8, 1, 9]
            match find_min(list):
                case Some(min_val): expect min_val == 1
                case nil: expect false

        it "find_max returns maximum":
            val list = [5, 2, 8, 1, 9]
            match find_max(list):
                case Some(max_val): expect max_val == 9
                case nil: expect false

        it "find_min_index returns correct index":
            val list = [5, 2, 8, 1, 9]
            match find_min_index(list):
                case Some(idx): expect idx == 3
                case nil: expect false

        it "find_max_index returns correct index":
            val list = [5, 2, 8, 1, 9]
            match find_max_index(list):
                case Some(idx): expect idx == 4
                case nil: expect false

    describe "List Manipulation":
        it "reverse_list works":
            val list = [1, 2, 3, 4, 5]
            val reversed = reverse_list(list)
            expect lists_equal(a=reversed, b=[5, 4, 3, 2, 1])

        it "take gets first n elements":
            val list = [1, 2, 3, 4, 5]
            val taken = take(list, 3)
            expect lists_equal(a=taken, b=[1, 2, 3])

        it "drop removes first n elements":
            val list = [1, 2, 3, 4, 5]
            val dropped = drop(list, 2)
            expect lists_equal(a=dropped, b=[3, 4, 5])

        it "remove_duplicates works":
            val list = [1, 2, 2, 3, 3, 3, 4]
            val unique = remove_duplicates(list)
            expect lists_equal(a=unique, b=[1, 2, 3, 4])

    describe "Statistics":
        it "sum calculates total":
            val list = [1, 2, 3, 4, 5]
            expect sum(list) == 15

        it "sum of empty list is 0":
            val list: [i64] = []
            expect sum(list) == 0

    describe "Comparisons":
        it "lists_equal returns true for equal lists":
            expect lists_equal(a=[1, 2, 3], b=[1, 2, 3])

        it "lists_equal returns false for different lists":
            expect not lists_equal(a=[1, 2, 3], b=[1, 2, 4])

        it "is_prefix works":
            expect is_prefix(prefix=[1, 2], list=[1, 2, 3, 4])

        it "is_suffix works":
            expect is_suffix(suffix=[3, 4], list=[1, 2, 3, 4])

        it "count_occurrences works":
            val list = [1, 2, 2, 3, 2, 4]
            expect count_occurrences(list, 2) == 3

        it "find_all_indices works":
            val list = [1, 2, 2, 3, 2, 4]
            val indices = find_all_indices(list, 2)
            expect lists_equal(a=indices, b=[1, 2, 4])

    describe "Edge Cases":
        it "sort empty list":
            val empty: [i64] = []
            val sorted = quick_sort(empty)
            expect sorted.len() == 0

        it "sort single element":
            val single = [42]
            val sorted = merge_sort(single)
            expect lists_equal(a=sorted, b=[42])

        it "take more than length":
            val list = [1, 2, 3]
            val taken = take(list, 10)
            expect lists_equal(a=taken, b=[1, 2, 3])

        it "drop more than length":
            val list = [1, 2, 3]
            val dropped = drop(list, 10)
            expect dropped.len() == 0
