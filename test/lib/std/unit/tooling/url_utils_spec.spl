# @pending
"""
Feature: URL Utilities
Category: Standard Library / Tooling
Status: Complete

URL parsing, encoding/decoding, query string manipulation, and URL building
with full support for scheme, auth, host, port, path, query, and fragment.
"""


# =====================================
# URL Encoding/Decoding
# =====================================

fn url_encode(s: text) -> text:
    var result = ""
    for c in s.chars():
        if is_unreserved_char(c):
            result = result + c
        else:
            val code: i64 = c as i64
            result = result + "%" + to_hex_byte(code)
    result

fn url_decode(s: text) -> text:
    var result = ""
    val chars = s.chars()
    var i = 0
    while i < chars.len():
        val c = chars[i]
        if c == '%' and i + 2 < chars.len():
            val hex_str = chars[i + 1] + chars[i + 2]
            match from_hex(hex_str):
                case Some(code): result = result + from_char_code(code)
                case nil: result = result + c
            i = i + 3
        else if c == '+':
            result = result + " "
            i = i + 1
        else:
            result = result + c
            i = i + 1
    result

fn is_unreserved_char(c: text) -> bool:
    (c >= "A" and c <= "Z") or (c >= "a" and c <= "z") or (c >= "0" and c <= "9") or c == "-" or c == "." or c == "_" or c == "~"

# =====================================
# Character Code Functions
# =====================================

fn char_code(s: text) -> i64:
    if s.len() == 0:
        return 0
    s.chars()[0] as i64

fn from_char_code(code: i64) -> text:
    code as char

# =====================================
# Hex Conversion
# =====================================

fn to_hex(n: i64) -> text:
    to_hex_byte(n)

fn to_hex_byte(n: i64) -> text:
    val high = (n / 16) % 16
    val low = n % 16
    hex_digit(high) + hex_digit(low)

fn hex_digit(n: i64) -> text:
    if n < 10:
        from_char_code(48 + n)
    else:
        from_char_code(65 + n - 10)

fn from_hex(s: text) -> Option<i64>:
    if s.len() != 2:
        return nil
    val chars = s.chars()
    match hex_digit_value(chars[0]):
        case Some(high):
            match hex_digit_value(chars[1]):
                case Some(low): Some(high * 16 + low)
                case nil: nil
        case nil: nil

fn hex_digit_value(s: text) -> Option<i64>:
    if s.len() == 0:
        return nil
    val c = s.chars()[0]
    if c >= '0' and c <= '9':
        Some(c as i64 - '0' as i64)
    else if c >= 'A' and c <= 'F':
        Some(c as i64 - 'A' as i64 + 10)
    else if c >= 'a' and c <= 'f':
        Some(c as i64 - 'a' as i64 + 10)
    else:
        nil

# =====================================
# URL Struct
# =====================================

struct Url:
    scheme: text
    username: text
    password: text
    host: text
    port: Option<i64>
    path: text
    query: text
    fragment: text

# =====================================
# URL Parsing
# =====================================

fn parse_url(s: text) -> Option<Url>:
    if not s.contains("://"):
        return nil
    val scheme_end = s.find("://").unwrap()

    val scheme = s.substring(0, scheme_end)
    var rest = s.substring(scheme_end + 3, s.len())

    var username = ""
    var password = ""
    match rest.find("@"):
        case Some(at_idx):
            val auth = rest.substring(0, at_idx)
            rest = rest.substring(at_idx + 1, rest.len())
            match auth.find(":"):
                case Some(colon_idx):
                    username = auth.substring(0, colon_idx)
                    password = auth.substring(colon_idx + 1, auth.len())
                case nil:
                    username = auth
        case nil: ()

    var fragment = ""
    match rest.find("#"):
        case Some(hash_idx):
            fragment = rest.substring(hash_idx + 1, rest.len())
            rest = rest.substring(0, hash_idx)
        case nil: ()

    var query = ""
    match rest.find("?"):
        case Some(q_idx):
            query = rest.substring(q_idx + 1, rest.len())
            rest = rest.substring(0, q_idx)
        case nil: ()

    var path = "/"
    match rest.find("/"):
        case Some(path_idx):
            path = rest.substring(path_idx, rest.len())
            rest = rest.substring(0, path_idx)
        case nil: ()

    var host = rest
    var port: Option<i64> = nil
    match rest.find(":"):
        case Some(port_idx):
            host = rest.substring(0, port_idx)
            val port_str = rest.substring(port_idx + 1, rest.len())
            match parse_int_simple(port_str):
                case Some(p): port = Some(p)
                case nil: port = nil
        case nil: ()

    Some(Url(
        scheme: scheme,
        username: username,
        password: password,
        host: host,
        port: port,
        path: path,
        query: query,
        fragment: fragment
    ))

fn parse_int_simple(s: text) -> Option<i64>:
    if s.len() == 0:
        return nil
    var result: i64 = 0
    for c in s.chars():
        if c >= '0' and c <= '9':
            result = result * 10 + (c as i64 - '0' as i64)
        else:
            return nil
    Some(result)

# =====================================
# URL Building
# =====================================

fn build_url(url: Url) -> text:
    var result = url.scheme + "://"

    if url.username.len() > 0:
        result = result + url.username
        if url.password.len() > 0:
            result = result + ":" + url.password
        result = result + "@"

    result = result + url.host

    match url.port:
        case Some(p):
            if not is_default_port(url.scheme, p):
                result = result + ":{p}"
        case nil: ()

    result = result + url.path

    if url.query.len() > 0:
        result = result + "?" + url.query

    if url.fragment.len() > 0:
        result = result + "#" + url.fragment

    result

fn is_default_port(scheme: text, port: i64) -> bool:
    match scheme:
        case "http": port == 80
        case "https": port == 443
        case "ftp": port == 21
        case _: false

fn get_base_url(url: Url) -> text:
    var result = url.scheme + "://" + url.host
    match url.port:
        case Some(p):
            if not is_default_port(url.scheme, p):
                result = result + ":{p}"
        case nil: ()
    result

fn get_full_path(url: Url) -> text:
    var result = url.path
    if url.query.len() > 0:
        result = result + "?" + url.query
    if url.fragment.len() > 0:
        result = result + "#" + url.fragment
    result

fn join_url(base: text, rel: text) -> text:
    if rel.contains("://"):
        return rel
    if rel.starts_with("/"):
        return match parse_url(base):
            case Some(url): get_base_url(url) + rel
            case nil: base + rel
    if base.ends_with("/"):
        base + rel
    else:
        base + "/" + rel

# =====================================
# Query String Functions
# =====================================

fn parse_query_string(s: text) -> [(text, text)]:
    if s.len() == 0:
        return []
    var result: [(text, text)] = []
    val parts = split_text(s=s, delim="&")
    for part in parts:
        match part.find("="):
            case Some(eq_idx):
                val key = part.substring(0, eq_idx)
                val value = part.substring(eq_idx + 1, part.len())
                result = result + [(key, value)]
            case nil:
                result = result + [(part, "")]
    result

fn build_query_string(params: [(text, text)]) -> text:
    if params.len() == 0:
        return ""
    var result = ""
    var first = true
    for (key, value) in params:
        if not first:
            result = result + "&"
        result = result + url_encode(key) + "=" + url_encode(value)
        first = false
    result

fn add_query_param(query: text, key: text, value: text) -> text:
    val new_param = url_encode(key) + "=" + url_encode(value)
    if query.len() == 0:
        return new_param
    return query + "&" + new_param

fn split_text(s: text, delim: text) -> [text]:
    # Early return for no delimiter case
    if not s.contains(delim):
        return [s]
    # Split with delimiter
    var result: [text] = []
    var current = ""
    var i = 0
    val chars = s.chars()
    while i < chars.len():
        if chars[i] == delim:
            result = result + [current]
            current = ""
        else:
            current = current + chars[i]
        i = i + 1
    result = result + [current]
    result

fn join_texts(parts: [text], sep: text) -> text:
    if parts.len() == 0:
        return ""
    var result = parts[0]
    for i in 1..parts.len():
        result = result + sep + parts[i]
    result

# =====================================
# URL Validation
# =====================================

fn is_valid_url(s: text) -> bool:
    match parse_url(s):
        case Some(_): true
        case nil: false

fn is_absolute_url(s: text) -> bool:
    s.contains("://")

fn is_relative_url(s: text) -> bool:
    not is_absolute_url(s)

fn is_unreserved(s: text) -> bool:
    if s.len() == 0:
        return false
    val c = s.chars()[0]
    is_unreserved_char(c)

# =====================================
# Integer Parsing (for URL tests)
# =====================================

fn parse_int(s: text) -> Option<i64>:
    parse_int_simple(s)

# =====================================
# BDD Tests
# =====================================

describe "URL Utilities":
    """
    Tests for URL parsing, encoding, building, and query string manipulation
    with comprehensive coverage of all URL components and edge cases.
    """

    describe "URL Encoding":
        """Test URL encoding operations for special characters"""
        it "encodes simple string":
            expect url_encode("hello") == "hello"

        it "encodes space":
            val result = url_encode("hello world")
            expect result.contains("%20")

        it "encodes special chars":
            val result = url_encode("a+b")
            expect result.contains("%")

    describe "URL Decoding":
        """Test URL decoding operations for percent-encoded strings"""
        it "decodes simple string":
            expect url_decode("hello") == "hello"

        it "decodes percent-encoded space":
            expect url_decode("hello%20world") == "hello world"

        it "decodes plus as space":
            expect url_decode("hello+world") == "hello world"

        it "round-trip encode/decode":
            val original = "hello world"
            val encoded = url_encode(original)
            val decoded = url_decode(encoded)
            expect decoded == original

    describe "Character Codes":
        """Test character code conversion operations"""
        it "gets char code for letters":
            expect char_code("A") == 65
            expect char_code("a") == 97
            expect char_code("Z") == 90
            expect char_code("z") == 122

        it "gets char code for digits":
            expect char_code("0") == 48
            expect char_code("9") == 57

        it "converts from char code":
            expect from_char_code(65) == "A"
            expect from_char_code(97) == "a"
            expect from_char_code(48) == "0"

        it "round-trip char code":
            val code = char_code("A")
            val ch = from_char_code(code)
            expect ch == "A"

    describe "Hex Conversion":
        """Test hexadecimal encoding/decoding operations"""
        it "converts to hex":
            expect to_hex(0) == "00"
            expect to_hex(15) == "0F"
            expect to_hex(255) == "FF"

        it "converts hex digit":
            expect hex_digit(0) == "0"
            expect hex_digit(9) == "9"
            expect hex_digit(10) == "A"
            expect hex_digit(15) == "F"

        it "parses valid hex":
            match from_hex("00"):
                case Some(n): expect n == 0
                case nil: expect false
            match from_hex("FF"):
                case Some(n): expect n == 255
                case nil: expect false

        it "returns nil for invalid hex":
            match from_hex("GG"):
                case Some(_): expect false
                case nil: expect true

        it "parses hex digit value":
            match hex_digit_value("0"):
                case Some(n): expect n == 0
                case nil: expect false
            match hex_digit_value("F"):
                case Some(n): expect n == 15
                case nil: expect false
            match hex_digit_value("f"):
                case Some(n): expect n == 15
                case nil: expect false

    describe "URL Parsing":
        """Test URL parsing for all components and combinations"""
        it "parses simple URL":
            match parse_url("http://example.com"):
                case Some(url):
                    expect url.scheme == "http"
                    expect url.host == "example.com"
                    expect url.path == "/"
                case nil: expect false

        it "parses URL with path":
            match parse_url("https://example.com/path/to/resource"):
                case Some(url):
                    expect url.scheme == "https"
                    expect url.host == "example.com"
                    expect url.path == "/path/to/resource"
                case nil: expect false

        it "parses URL with port":
            match parse_url("http://example.com:8080/"):
                case Some(url):
                    expect url.host == "example.com"
                    match url.port:
                        case Some(p): expect p == 8080
                        case nil: expect false
                case nil: expect false

        it "parses URL with query":
            match parse_url("http://example.com/path?key=value"):
                case Some(url):
                    expect url.path == "/path"
                    expect url.query == "key=value"
                case nil: expect false

        it "parses URL with fragment":
            match parse_url("http://example.com/page#section"):
                case Some(url):
                    expect url.path == "/page"
                    expect url.fragment == "section"
                case nil: expect false

        it "parses URL with username":
            match parse_url("http://user@example.com/"):
                case Some(url):
                    expect url.username == "user"
                    expect url.host == "example.com"
                case nil: expect false

        it "parses URL with credentials":
            match parse_url("ftp://user:pass@example.com/"):
                case Some(url):
                    expect url.username == "user"
                    expect url.password == "pass"
                    expect url.host == "example.com"
                case nil: expect false

        it "parses complete URL":
            match parse_url("https://user:pass@example.com:443/path?key=val#frag"):
                case Some(url):
                    expect url.scheme == "https"
                    expect url.username == "user"
                    expect url.password == "pass"
                    expect url.host == "example.com"
                    match url.port:
                        case Some(p): expect p == 443
                        case nil: expect false
                    expect url.path == "/path"
                    expect url.query == "key=val"
                    expect url.fragment == "frag"
                case nil: expect false

        it "returns nil for invalid URL":
            match parse_url("not-a-url"):
                case Some(_): expect false
                case nil: expect true

    describe "URL Building":
        """Test URL construction from components"""
        it "builds simple URL":
            val url = Url(
                scheme: "http",
                username: "",
                password: "",
                host: "example.com",
                port: nil,
                path: "/",
                query: "",
                fragment: ""
            )
            val result = build_url(url)
            expect result == "http://example.com/"

        it "builds URL with port":
            val url = Url(
                scheme: "http",
                username: "",
                password: "",
                host: "example.com",
                port: Some(8080),
                path: "/",
                query: "",
                fragment: ""
            )
            val result = build_url(url)
            expect result.contains(":8080")

        it "omits default port":
            val url = Url(
                scheme: "http",
                username: "",
                password: "",
                host: "example.com",
                port: Some(80),
                path: "/",
                query: "",
                fragment: ""
            )
            val result = build_url(url)
            expect not result.contains(":80")

        it "builds URL with query":
            val url = Url(
                scheme: "https",
                username: "",
                password: "",
                host: "example.com",
                port: nil,
                path: "/search",
                query: "q=test",
                fragment: ""
            )
            val result = build_url(url)
            expect result.contains("?q=test")

        it "checks default port":
            expect is_default_port("http", 80)
            expect is_default_port("https", 443)
            expect is_default_port("ftp", 21)
            expect not is_default_port("http", 8080)

    describe "Query String":
        """Test query string parsing and building"""
        it "parses simple query":
            val params = parse_query_string("key=value")
            expect params.len() == 1
            expect params[0].0 == "key"
            expect params[0].1 == "value"

        it "parses multiple params":
            val params = parse_query_string("a=1&b=2&c=3")
            expect params.len() == 3
            expect params[0].0 == "a"
            expect params[1].0 == "b"
            expect params[2].0 == "c"

        it "parses empty value":
            val params = parse_query_string("key=")
            expect params.len() == 1
            expect params[0].0 == "key"
            expect params[0].1 == ""

        it "parses no value":
            val params = parse_query_string("flag")
            expect params.len() == 1
            expect params[0].0 == "flag"
            expect params[0].1 == ""

        it "parses empty string":
            val params = parse_query_string("")
            expect params.len() == 0

        it "builds simple query":
            val params = [("key", "value")]
            val result = build_query_string(params)
            expect result == "key=value"

        it "builds multiple params":
            val params = [("a", "1"), ("b", "2"), ("c", "3")]
            val result = build_query_string(params)
            expect result.contains("a=1")
            expect result.contains("b=2")
            expect result.contains("c=3")
            expect result.contains("&")

        it "builds with encoding":
            val params = [("key", "hello world")]
            val result = build_query_string(params)
            expect result.contains("%20")

        it "adds param to empty query":
            val result = add_query_param(query="", key="key", value="value")
            expect result == "key=value"

        it "adds param to existing query":
            val result = add_query_param(query="a=1", key="b", value="2")
            expect result.contains("a=1")
            expect result.contains("b=2")
            expect result.contains("&")

    describe "URL Validation":
        """Test URL validation operations"""
        it "validates valid URLs":
            expect is_valid_url("http://example.com")
            expect is_valid_url("https://example.com/path")
            expect is_valid_url("ftp://files.example.com")

        it "rejects invalid URLs":
            expect not is_valid_url("example.com")
            expect not is_valid_url("/path/to/file")
            expect not is_valid_url("http:example.com")

        it "checks absolute URL":
            expect is_absolute_url("http://example.com")
            expect is_absolute_url("https://example.com/path")
            expect not is_absolute_url("/path/to/file")
            expect not is_absolute_url("relative/path")

        it "checks relative URL":
            expect is_relative_url("/path/to/file")
            expect is_relative_url("relative/path")
            expect not is_relative_url("http://example.com")

    describe "URL Operations":
        """Test URL component extraction and joining"""
        it "gets base URL":
            val url = Url(
                scheme: "https",
                username: "",
                password: "",
                host: "example.com",
                port: nil,
                path: "/path",
                query: "key=value",
                fragment: "section"
            )
            val base = get_base_url(url)
            expect base == "https://example.com"

        it "gets base URL with port":
            val url = Url(
                scheme: "http",
                username: "",
                password: "",
                host: "example.com",
                port: Some(8080),
                path: "/",
                query: "",
                fragment: ""
            )
            val base = get_base_url(url)
            expect base.contains(":8080")

        it "gets full path":
            val url = Url(
                scheme: "https",
                username: "",
                password: "",
                host: "example.com",
                port: nil,
                path: "/path",
                query: "key=value",
                fragment: "section"
            )
            val full_path = get_full_path(url)
            expect full_path == "/path?key=value#section"

        it "joins absolute URL":
            val result = join_url(base="http://example.com", rel="https://other.com/path")
            expect result == "https://other.com/path"

        it "joins relative URL with slash":
            val result = join_url(base="http://example.com/", rel="/path")
            expect result == "http://example.com/path"

        it "joins relative URL without slash":
            val result = join_url(base="http://example.com", rel="path")
            expect result == "http://example.com/path"

        it "joins both slashes":
            val result = join_url(base="http://example.com/", rel="/path")
            expect not result.contains("//path")

    describe "Integer Parsing":
        """Test integer parsing from strings"""
        it "parses valid int":
            match parse_int("123"):
                case Some(n): expect n == 123
                case nil: expect false

        it "parses zero":
            match parse_int("0"):
                case Some(n): expect n == 0
                case nil: expect false

        it "returns nil for invalid":
            match parse_int("abc"):
                case Some(_): expect false
                case nil: expect true

        it "returns nil for empty":
            match parse_int(""):
                case Some(_): expect false
                case nil: expect true

    describe "Unreserved Characters":
        """Test detection of unreserved URL characters"""
        it "checks alphanumeric":
            expect is_unreserved("A")
            expect is_unreserved("z")
            expect is_unreserved("0")
            expect is_unreserved("9")

        it "checks special allowed chars":
            expect is_unreserved("-")
            expect is_unreserved(".")
            expect is_unreserved("_")
            expect is_unreserved("~")

        it "checks reserved chars":
            expect not is_unreserved("!")
            expect not is_unreserved("@")
            expect not is_unreserved(" ")

    describe "Round-trip":
        """Test round-trip URL parsing and building"""
        it "parse and build URL":
            val original = "https://user:pass@example.com:8080/path?key=val#frag"
            match parse_url(original):
                case Some(url):
                    val rebuilt = build_url(url)
                    expect rebuilt.contains("https://")
                    expect rebuilt.contains("user:pass@")
                    expect rebuilt.contains("example.com")
                    expect rebuilt.contains(":8080")
                    expect rebuilt.contains("/path")
                    expect rebuilt.contains("?key=val")
                    expect rebuilt.contains("#frag")
                case nil: expect false

        it "parse and build query string":
            val original = "a=1&b=2&c=3"
            val params = parse_query_string(original)
            val rebuilt = build_query_string(params)
            expect rebuilt.contains("a=1")
            expect rebuilt.contains("b=2")
            expect rebuilt.contains("c=3")
