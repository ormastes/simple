# Tests for retry utilities

use tooling.retry_utils.*

# =====================================
# RetryConfig Tests
# =====================================

fn test_retry_config_default():
    val config = RetryConfig.default()
    assert(config.max_attempts == 3)
    assert(config.timeout_ms == 30000)

fn test_retry_config_fixed_delay():
    val config = RetryConfig.fixed_delay(5, 1000)
    assert(config.max_attempts == 5)
    match config.strategy:
        case RetryStrategy.FixedDelay(delay):
            assert(delay == 1000)
        case _:
            assert(false)

fn test_retry_config_linear_backoff():
    val config = RetryConfig.linear_backoff(4, 100, 50)
    assert(config.max_attempts == 4)
    match config.strategy:
        case RetryStrategy.LinearBackoff(start, increment):
            assert(start == 100)
            assert(increment == 50)
        case _:
            assert(false)

fn test_retry_config_exponential_backoff():
    val config = RetryConfig.exponential_backoff(5, 100, 5000)
    assert(config.max_attempts == 5)
    match config.strategy:
        case RetryStrategy.ExponentialBackoff(base, max_delay):
            assert(base == 100)
            assert(max_delay == 5000)
        case _:
            assert(false)

fn test_retry_config_no_retry():
    val config = RetryConfig.no_retry()
    assert(config.max_attempts == 1)

# =====================================
# Delay Calculation Tests
# =====================================

fn test_calculate_delay_fixed():
    val strategy = RetryStrategy.FixedDelay(1000)
    assert(calculate_delay(strategy, 1) == 1000)
    assert(calculate_delay(strategy, 2) == 1000)
    assert(calculate_delay(strategy, 5) == 1000)

fn test_calculate_delay_linear():
    val strategy = RetryStrategy.LinearBackoff(100, 50)
    assert(calculate_delay(strategy, 1) == 100)  # 100 + (1-1)*50
    assert(calculate_delay(strategy, 2) == 150)  # 100 + (2-1)*50
    assert(calculate_delay(strategy, 3) == 200)  # 100 + (3-1)*50

fn test_calculate_delay_exponential():
    val strategy = RetryStrategy.ExponentialBackoff(100, 5000)
    assert(calculate_delay(strategy, 1) == 100)   # 2^0 * 100 = 100
    assert(calculate_delay(strategy, 2) == 200)   # 2^1 * 100 = 200
    assert(calculate_delay(strategy, 3) == 400)   # 2^2 * 100 = 400
    assert(calculate_delay(strategy, 4) == 800)   # 2^3 * 100 = 800

    # Should cap at max_delay
    val delay = calculate_delay(strategy, 10)
    assert(delay <= 5000)

fn test_calculate_delay_no_retry():
    val strategy = RetryStrategy.NoRetry
    assert(calculate_delay(strategy, 1) == 0)

# =====================================
# Retry Schedule Tests
# =====================================

fn test_calculate_retry_schedule_fixed():
    val config = RetryConfig.fixed_delay(3, 1000)
    val schedule = calculate_retry_schedule(config)

    assert(schedule.len() == 2)  # max_attempts - 1
    assert(schedule[0] == 1000)
    assert(schedule[1] == 1000)

fn test_calculate_retry_schedule_exponential():
    val config = RetryConfig.exponential_backoff(4, 100, 5000)
    val schedule = calculate_retry_schedule(config)

    assert(schedule.len() == 3)
    assert(schedule[0] == 100)
    assert(schedule[1] == 200)
    assert(schedule[2] == 400)

fn test_calculate_total_retry_time():
    val config = RetryConfig.fixed_delay(3, 1000)
    val total = calculate_total_retry_time(config)
    assert(total == 2000)  # 2 retries * 1000ms

# =====================================
# Error Predicate Tests
# =====================================

fn test_is_transient_error():
    assert(is_transient_error(500))  # Internal Server Error
    assert(is_transient_error(503))  # Service Unavailable
    assert(is_transient_error(429))  # Too Many Requests

    assert(not is_transient_error(200))  # OK
    assert(not is_transient_error(404))  # Not Found
    assert(not is_transient_error(400))  # Bad Request

fn test_is_network_error():
    assert(is_network_error("timeout"))
    assert(is_network_error("connection failed"))
    assert(is_network_error("network unreachable"))

    assert(not is_network_error("invalid input"))
    assert(not is_network_error("parse error"))

# =====================================
# Circuit Breaker Tests
# =====================================

fn test_circuit_breaker_new():
    val cb = CircuitBreaker.new(5, 2)
    assert(cb.failure_threshold == 5)
    assert(cb.success_threshold == 2)
    match cb.state:
        case CircuitState.Closed:
            assert(true)
        case _:
            assert(false)

fn test_circuit_breaker_open_after_failures():
    var cb = CircuitBreaker.new(3, 2)

    # Should be closed initially
    match cb.state:
        case CircuitState.Closed:
            assert(true)
        case _:
            assert(false)

    # Record failures
    cb.on_failure(100)
    cb.on_failure(200)
    cb.on_failure(300)

    # Should be open after threshold
    match cb.state:
        case CircuitState.Open:
            assert(true)
        case _:
            assert(false)

fn test_circuit_breaker_can_attempt():
    var cb = CircuitBreaker.new(2, 1)

    # Should allow attempts when closed
    assert(cb.can_attempt(0, 1000))

    # Open circuit after failures
    cb.on_failure(100)
    cb.on_failure(200)

    # Should not allow immediately
    assert(not cb.can_attempt(250, 1000))

    # Should allow after timeout
    assert(cb.can_attempt(1300, 1000))

# =====================================
# Rate Limiter Tests
# =====================================

fn test_rate_limiter_new():
    val limiter = RateLimiter.new(10, 1000)
    assert(limiter.max_requests == 10)
    assert(limiter.window_ms == 1000)

fn test_rate_limiter_allows_under_limit():
    var limiter = RateLimiter.new(5, 1000)

    # Should allow first requests
    assert(limiter.is_allowed(100))
    limiter.record_request(100)
    assert(limiter.is_allowed(100))
    limiter.record_request(100)

fn test_rate_limiter_rejects_over_limit():
    var limiter = RateLimiter.new(2, 1000)

    limiter.record_request(100)
    limiter.record_request(100)

    # Third request should be rejected
    assert(not limiter.is_allowed(100))

fn test_rate_limiter_resets_window():
    var limiter = RateLimiter.new(2, 1000)

    limiter.record_request(100)
    limiter.record_request(100)

    # Should be rejected at 500ms
    assert(not limiter.is_allowed(500))

    # Should reset after window
    limiter.record_request(1200)
    assert(limiter.is_allowed(1200))

fn test_delay_until_allowed():
    var limiter = RateLimiter.new(1, 1000)

    limiter.record_request(100)

    # Should need to wait
    val delay = limiter.delay_until_allowed(500)
    assert(delay > 0)
    assert(delay <= 1000)

# =====================================
# Timeout Tests
# =====================================

fn test_is_timed_out():
    assert(not is_timed_out(100, 500, 1000))  # Not timed out
    assert(is_timed_out(100, 1200, 1000))     # Timed out

fn test_remaining_time():
    assert(remaining_time(100, 500, 1000) == 600)
    assert(remaining_time(100, 1200, 1000) == 0)  # Already expired

# =====================================
# Retry Statistics Tests
# =====================================

fn test_retry_stats_new():
    val stats = RetryStats.new()
    assert(stats.total_attempts == 0)
    assert(stats.successful_attempts == 0)
    assert(stats.failed_attempts == 0)

fn test_retry_stats_record_success():
    var stats = RetryStats.new()

    stats.record_success(100)
    assert(stats.total_attempts == 1)
    assert(stats.successful_attempts == 1)
    assert(stats.failed_attempts == 0)

fn test_retry_stats_record_failure():
    var stats = RetryStats.new()

    stats.record_failure(200)
    assert(stats.total_attempts == 1)
    assert(stats.successful_attempts == 0)
    assert(stats.failed_attempts == 1)

fn test_retry_stats_success_rate():
    var stats = RetryStats.new()

    stats.record_success(100)
    stats.record_success(100)
    stats.record_failure(100)

    val rate = stats.success_rate()
    assert(rate > 66.0 and rate < 67.0)  # 2/3 = 66.67%

fn test_retry_stats_summary():
    var stats = RetryStats.new()
    stats.record_success(100)
    stats.record_failure(200)

    val summary = stats.summary()
    # Just check it doesn't crash
    assert(summary.len() > 0)
