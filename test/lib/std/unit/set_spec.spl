# Set<T> Type Test Specification
# Comprehensive tests for set behavior using dict-based implementation
#
# Note: The stdlib Set<T> uses Map<T> which calls .hash() on keys,
# but the bootstrap runtime doesn't have a hash method on str type.
# These tests use the built-in dict {} as a set (keys = elements, values = true)
# to verify set-like behavior without depending on .hash().
#
# Important: The bootstrap runtime has a bug where dict mutations inside
# called functions don't propagate back to the caller. Therefore all dict
# mutations (insert, remove, clear) are done inline, not via helper functions.
# Read-only helpers and functions that return new dicts work fine.

# ============================================================================
# Dict-based Set Helper Functions (read-only / return new dict)
# ============================================================================

# Check if dict-set contains item (read-only - works as function)
fn set_contains(s, item):
    s.contains_key(item)

# Clone a dict-set (returns new dict - works as function)
fn set_clone(s):
    var result = {}
    for k in s.keys():
        result[k] = true
    result

# Union of two dict-sets (returns new dict)
fn set_union(s1, s2):
    var result = {}
    for k in s1.keys():
        result[k] = true
    for k in s2.keys():
        result[k] = true
    result

# Intersection of two dict-sets (returns new dict)
fn set_intersection(s1, s2):
    var result = {}
    for k in s1.keys():
        if s2.contains_key(k):
            result[k] = true
    result

# Difference: elements in s1 but not s2 (returns new dict)
fn set_difference(s1, s2):
    var result = {}
    for k in s1.keys():
        if not s2.contains_key(k):
            result[k] = true
    result

# Symmetric difference: elements in either but not both (returns new dict)
fn set_symmetric_difference(s1, s2):
    var result = {}
    for k in s1.keys():
        if not s2.contains_key(k):
            result[k] = true
    for k in s2.keys():
        if not s1.contains_key(k):
            result[k] = true
    result

# Subset check (read-only)
fn set_is_subset(s1, s2):
    for k in s1.keys():
        if not s2.contains_key(k):
            return false
    true

# Superset check (read-only)
fn set_is_superset(s1, s2):
    set_is_subset(s2, s1)

# Disjoint check (read-only)
fn set_is_disjoint(s1, s2):
    for k in s1.keys():
        if s2.contains_key(k):
            return false
    true

# Filter: keep elements matching predicate (returns new dict)
fn set_filter(s, predicate):
    var result = {}
    for k in s.keys():
        if predicate(k):
            result[k] = true
    result

# Map: transform elements (returns new dict)
fn set_map(s, mapper):
    var result = {}
    for k in s.keys():
        val mapped = mapper(k)
        result[mapped] = true
    result

# Any: true if at least one element matches predicate (read-only)
fn set_any(s, predicate):
    for k in s.keys():
        if predicate(k):
            return true
    false

# All: true if all elements match predicate (read-only)
fn set_all(s, predicate):
    for k in s.keys():
        if not predicate(k):
            return false
    true

# Create set from list (returns new dict)
fn set_from_list(items):
    var s = {}
    for item in items:
        s[item] = true
    s

# Intersection of all sets in a list (returns new dict)
fn intersect_all(sets):
    if sets.len() == 0:
        return {}
    var result = set_clone(sets[0])
    for i in 1..sets.len():
        result = set_intersection(result, sets[i])
    result

# Union of all sets in a list (returns new dict)
fn union_all(sets):
    var result = {}
    for s in sets:
        for k in s.keys():
            result[k] = true
    result

# ============================================================================
# Tests
# ============================================================================

describe "Set<T>":
    context "Construction":
        it "creates empty set with new()":
            var s = {}
            expect(s.len()).to_equal(0)

        it "creates empty set with capacity":
            # Dict doesn't have capacity, but empty dict is equivalent
            var s = {}
            expect(s.len()).to_equal(0)

    context "Basic operations":
        it "inserts element into set":
            var s = {}
            val was_new = not s.contains_key("Alice")
            s["Alice"] = true
            expect(was_new).to_be(true)
            expect(s.len()).to_equal(1)

        it "insert returns false for duplicate":
            var s = {}
            s["Alice"] = true
            val was_new = not s.contains_key("Alice")
            s["Alice"] = true
            expect(was_new).to_be(false)
            expect(s.len()).to_equal(1)

        it "contains finds existing element":
            var s = {}
            s["Alice"] = true
            expect(set_contains(s, "Alice")).to_be(true)

        it "contains returns false for missing element":
            var s = {}
            expect(set_contains(s, "Alice")).to_be(false)

        it "removes existing element":
            var s = {}
            s["Alice"] = true
            val existed = s.contains_key("Alice")
            s.remove("Alice")
            expect(existed).to_be(true)
            expect(s.len()).to_equal(0)

        it "remove returns false for missing element":
            var s = {}
            val existed = s.contains_key("Alice")
            expect(existed).to_be(false)

        it "clear removes all elements":
            var s = {}
            s["Alice"] = true
            s["Bob"] = true
            s["Charlie"] = true
            s.clear()
            expect(s.len()).to_equal(0)

    context "Multiple elements":
        it "handles multiple unique elements":
            var s = {}
            s["Alice"] = true
            s["Bob"] = true
            s["Charlie"] = true
            expect(s.len()).to_equal(3)
            expect(set_contains(s, "Alice")).to_be(true)
            expect(set_contains(s, "Bob")).to_be(true)
            expect(set_contains(s, "Charlie")).to_be(true)

        it "deduplicates elements":
            var s = {}
            s["Alice"] = true
            s["Bob"] = true
            s["Alice"] = true
            s["Bob"] = true
            expect(s.len()).to_equal(2)

    context "Conversion":
        it "converts to list":
            var s = {}
            s["Alice"] = true
            s["Bob"] = true
            s["Charlie"] = true
            val list = s.keys()
            expect(list.len()).to_equal(3)

        it "to_list contains all elements":
            var s = {}
            s["Alice"] = true
            s["Bob"] = true
            val list = s.keys()
            expect(list).to_contain("Alice")
            expect(list).to_contain("Bob")

    context "Iteration":
        it "for_each executes action for all elements":
            var s = {}
            s["Alice"] = true
            s["Bob"] = true
            s["Charlie"] = true
            var count = 0
            for k in s.keys():
                count = count + 1
            expect(count).to_equal(3)

    context "Set operations - union":
        it "union combines two sets":
            var s1 = {}
            s1["Alice"] = true
            s1["Bob"] = true
            var s2 = {}
            s2["Charlie"] = true
            s2["David"] = true
            val result = set_union(s1, s2)
            expect(result.len()).to_equal(4)
            expect(set_contains(result, "Alice")).to_be(true)
            expect(set_contains(result, "Bob")).to_be(true)
            expect(set_contains(result, "Charlie")).to_be(true)
            expect(set_contains(result, "David")).to_be(true)

        it "union handles overlapping sets":
            var s1 = {}
            s1["Alice"] = true
            s1["Bob"] = true
            s1["Charlie"] = true
            var s2 = {}
            s2["Bob"] = true
            s2["Charlie"] = true
            s2["David"] = true
            val result = set_union(s1, s2)
            expect(result.len()).to_equal(4)

        it "union doesn't modify original sets":
            var s1 = {}
            s1["Alice"] = true
            var s2 = {}
            s2["Bob"] = true
            val result = set_union(s1, s2)
            expect(s1.len()).to_equal(1)
            expect(s2.len()).to_equal(1)

    context "Set operations - intersection":
        it "intersection finds common elements":
            var s1 = {}
            s1["Alice"] = true
            s1["Bob"] = true
            s1["Charlie"] = true
            var s2 = {}
            s2["Bob"] = true
            s2["Charlie"] = true
            s2["David"] = true
            val result = set_intersection(s1, s2)
            expect(result.len()).to_equal(2)
            expect(set_contains(result, "Bob")).to_be(true)
            expect(set_contains(result, "Charlie")).to_be(true)

        it "intersection returns empty for disjoint sets":
            var s1 = {}
            s1["Alice"] = true
            s1["Bob"] = true
            var s2 = {}
            s2["Charlie"] = true
            s2["David"] = true
            val result = set_intersection(s1, s2)
            expect(result.len()).to_equal(0)

        it "intersection doesn't modify original sets":
            var s1 = {}
            s1["Alice"] = true
            s1["Bob"] = true
            var s2 = {}
            s2["Bob"] = true
            val result = set_intersection(s1, s2)
            expect(s1.len()).to_equal(2)
            expect(s2.len()).to_equal(1)

    context "Set operations - difference":
        it "difference finds elements in first but not second":
            var s1 = {}
            s1["Alice"] = true
            s1["Bob"] = true
            s1["Charlie"] = true
            var s2 = {}
            s2["Bob"] = true
            s2["Charlie"] = true
            s2["David"] = true
            val result = set_difference(s1, s2)
            expect(result.len()).to_equal(1)
            expect(set_contains(result, "Alice")).to_be(true)
            expect(set_contains(result, "Bob")).to_be(false)
            expect(set_contains(result, "Charlie")).to_be(false)

        it "difference returns empty when second is superset":
            var s1 = {}
            s1["Alice"] = true
            s1["Bob"] = true
            var s2 = {}
            s2["Alice"] = true
            s2["Bob"] = true
            s2["Charlie"] = true
            val result = set_difference(s1, s2)
            expect(result.len()).to_equal(0)

    context "Set operations - symmetric difference":
        it "symmetric_difference finds elements in either but not both":
            var s1 = {}
            s1["Alice"] = true
            s1["Bob"] = true
            s1["Charlie"] = true
            var s2 = {}
            s2["Bob"] = true
            s2["Charlie"] = true
            s2["David"] = true
            val result = set_symmetric_difference(s1, s2)
            expect(result.len()).to_equal(2)
            expect(set_contains(result, "Alice")).to_be(true)
            expect(set_contains(result, "David")).to_be(true)
            expect(set_contains(result, "Bob")).to_be(false)
            expect(set_contains(result, "Charlie")).to_be(false)

        it "symmetric_difference returns union for disjoint sets":
            var s1 = {}
            s1["Alice"] = true
            s1["Bob"] = true
            var s2 = {}
            s2["Charlie"] = true
            s2["David"] = true
            val result = set_symmetric_difference(s1, s2)
            expect(result.len()).to_equal(4)

    context "Set predicates - subset":
        it "is_subset returns true when all elements in other":
            var s1 = {}
            s1["Alice"] = true
            s1["Bob"] = true
            var s2 = {}
            s2["Alice"] = true
            s2["Bob"] = true
            s2["Charlie"] = true
            expect(set_is_subset(s1, s2)).to_be(true)

        it "is_subset returns true for equal sets":
            var s1 = {}
            s1["Alice"] = true
            s1["Bob"] = true
            var s2 = {}
            s2["Alice"] = true
            s2["Bob"] = true
            expect(set_is_subset(s1, s2)).to_be(true)

        it "is_subset returns false when element not in other":
            var s1 = {}
            s1["Alice"] = true
            s1["Bob"] = true
            s1["Charlie"] = true
            var s2 = {}
            s2["Alice"] = true
            s2["Bob"] = true
            expect(set_is_subset(s1, s2)).to_be(false)

    context "Set predicates - superset":
        it "is_superset returns true when contains all elements":
            var s1 = {}
            s1["Alice"] = true
            s1["Bob"] = true
            s1["Charlie"] = true
            var s2 = {}
            s2["Alice"] = true
            s2["Bob"] = true
            expect(set_is_superset(s1, s2)).to_be(true)

        it "is_superset returns false when missing element":
            var s1 = {}
            s1["Alice"] = true
            s1["Bob"] = true
            var s2 = {}
            s2["Alice"] = true
            s2["Bob"] = true
            s2["Charlie"] = true
            expect(set_is_superset(s1, s2)).to_be(false)

    context "Set predicates - disjoint":
        it "is_disjoint returns true for no overlap":
            var s1 = {}
            s1["Alice"] = true
            s1["Bob"] = true
            var s2 = {}
            s2["Charlie"] = true
            s2["David"] = true
            expect(set_is_disjoint(s1, s2)).to_be(true)

        it "is_disjoint returns false when sets overlap":
            var s1 = {}
            s1["Alice"] = true
            s1["Bob"] = true
            var s2 = {}
            s2["Bob"] = true
            s2["Charlie"] = true
            expect(set_is_disjoint(s1, s2)).to_be(false)

    context "Functional operations - filter":
        it "filter keeps matching elements":
            var s = {}
            s["1"] = true
            s["2"] = true
            s["3"] = true
            s["4"] = true
            s["5"] = true
            val result = set_filter(s, \x: int(x) % 2 == 0)
            expect(result.len()).to_equal(2)
            expect(set_contains(result, "2")).to_be(true)
            expect(set_contains(result, "4")).to_be(true)

        it "filter returns empty when no matches":
            var s = {}
            s["Alice"] = true
            s["Bob"] = true
            val result = set_filter(s, \x: x == "Charlie")
            expect(result.len()).to_equal(0)

    context "Functional operations - map":
        it "map transforms all elements":
            var s = {}
            s["1"] = true
            s["2"] = true
            s["3"] = true
            val result = set_map(s, \x: int(x) * 2)
            expect(result.len()).to_equal(3)
            expect(set_contains(result, 2)).to_be(true)
            expect(set_contains(result, 4)).to_be(true)
            expect(set_contains(result, 6)).to_be(true)

        it "map deduplicates transformed values":
            var s = {}
            s["1"] = true
            s["2"] = true
            s["3"] = true
            val result = set_map(s, \x: 42)
            expect(result.len()).to_equal(1)
            expect(set_contains(result, 42)).to_be(true)

    context "Functional operations - any":
        it "any returns true when element matches":
            var s = {}
            s["1"] = true
            s["2"] = true
            s["3"] = true
            val result = set_any(s, \x: int(x) > 2)
            expect(result).to_be(true)

        it "any returns false when no element matches":
            var s = {}
            s["1"] = true
            s["2"] = true
            s["3"] = true
            val result = set_any(s, \x: int(x) > 10)
            expect(result).to_be(false)

        it "any returns false for empty set":
            var s = {}
            val result = set_any(s, \x: true)
            expect(result).to_be(false)

    context "Functional operations - all":
        it "all returns true when all elements match":
            var s = {}
            s["1"] = true
            s["2"] = true
            s["3"] = true
            val result = set_all(s, \x: int(x) > 0)
            expect(result).to_be(true)

        it "all returns false when one element doesn't match":
            var s = {}
            s["1"] = true
            s["2"] = true
            s["3"] = true
            val result = set_all(s, \x: int(x) > 1)
            expect(result).to_be(false)

        it "all returns true for empty set":
            var s = {}
            val result = set_all(s, \x: false)
            expect(result).to_be(true)

    context "Utility operations":
        it "clone creates independent copy":
            var s1 = {}
            s1["Alice"] = true
            s1["Bob"] = true
            var s2 = set_clone(s1)
            s2["Charlie"] = true
            expect(s1.len()).to_equal(2)
            expect(s2.len()).to_equal(3)
            expect(set_contains(s1, "Charlie")).to_be(false)

        it "extend adds all items from list":
            var s = {}
            s["Alice"] = true
            val more = ["Bob", "Charlie", "David"]
            for item in more:
                s[item] = true
            expect(s.len()).to_equal(4)
            expect(set_contains(s, "Bob")).to_be(true)
            expect(set_contains(s, "Charlie")).to_be(true)
            expect(set_contains(s, "David")).to_be(true)

        it "extend deduplicates items from list":
            var s = {}
            s["Alice"] = true
            val more = ["Alice", "Bob", "Alice", "Charlie", "Bob"]
            for item in more:
                s[item] = true
            expect(s.len()).to_equal(3)

    context "Helper functions":
        it "set_from_list creates set from list":
            val s = set_from_list(["Alice", "Bob", "Charlie", "Alice", "Bob"])
            expect(s.len()).to_equal(3)
            expect(set_contains(s, "Alice")).to_be(true)
            expect(set_contains(s, "Bob")).to_be(true)
            expect(set_contains(s, "Charlie")).to_be(true)

        it "intersect_all finds common elements in multiple sets":
            var s1 = {}
            s1["Alice"] = true
            s1["Bob"] = true
            s1["Charlie"] = true
            var s2 = {}
            s2["Bob"] = true
            s2["Charlie"] = true
            s2["David"] = true
            var s3 = {}
            s3["Charlie"] = true
            s3["David"] = true
            s3["Eve"] = true
            val result = intersect_all([s1, s2, s3])
            expect(result.len()).to_equal(1)
            expect(set_contains(result, "Charlie")).to_be(true)

        it "intersect_all returns empty for empty list":
            val result = intersect_all([])
            expect(result.len()).to_equal(0)

        it "union_all combines all sets":
            var s1 = {}
            s1["Alice"] = true
            s1["Bob"] = true
            var s2 = {}
            s2["Bob"] = true
            s2["Charlie"] = true
            var s3 = {}
            s3["Charlie"] = true
            s3["David"] = true
            val result = union_all([s1, s2, s3])
            expect(result.len()).to_equal(4)
            expect(set_contains(result, "Alice")).to_be(true)
            expect(set_contains(result, "Bob")).to_be(true)
            expect(set_contains(result, "Charlie")).to_be(true)
            expect(set_contains(result, "David")).to_be(true)

    context "Edge cases":
        it "handles many elements":
            var s = {}
            for i in 0..100:
                s["item{i}"] = true
            expect(s.len()).to_equal(100)

        it "handles element removal during iteration":
            var s = {}
            s["Alice"] = true
            s["Bob"] = true
            s["Charlie"] = true
            val items = s.keys()
            for item in items:
                s.remove(item)
            expect(s.len()).to_equal(0)

        it "handles empty set operations":
            var s1 = {}
            var s2 = {}
            val union_result = set_union(s1, s2)
            expect(union_result.len()).to_equal(0)
            val intersect_result = set_intersection(s1, s2)
            expect(intersect_result.len()).to_equal(0)
            expect(set_is_subset(s1, s2)).to_be(true)
            expect(set_is_disjoint(s1, s2)).to_be(true)
