# DSL Features Tests

import std.spec
import std.{ContextBuilder, DynamicProxy, AttributeDict, QueryBuilder, Pipeline}

describe "Context blocks":
    it "provides context-aware building":
        val builder = ContextBuilder.new()
        expect builder.is_empty() == true

        builder.set("name", "Alice")
        builder.set("age", 30)

        expect builder.has("name") == true
        expect builder.get("name") == "Alice"
        expect builder.size() == 2

describe "Method missing":
    it "handles undefined methods":
        var called_name = ""
        var called_args = []

        val handler = \name, args: (called_name = name, called_args = args, 42)[2]
        val proxy = DynamicProxy.new(handler)

        val result = proxy.method_missing("test_method", [1, 2, 3])
        expect result == 42
        expect called_name == "test_method"

    it "enables dynamic proxies":
        val handler = \name, args: "handled"
        val proxy = DynamicProxy.new(handler)

        expect proxy.has_handler() == true
        val result = proxy.call_handler("any_method", [])
        expect result == "handled"

    it "supports attribute dictionaries":
        val obj = AttributeDict.new()
        expect obj.is_empty() == true

        obj.__setattr__("name", "Alice")
        val name = obj.__getattr__("name")
        expect name == "Alice"
        expect obj.has_attr("name") == true

describe "Fluent interfaces":
    it "enables method chaining":
        val query = QueryBuilder.new()
        query.select("name", "age")
        query.from_table("users")

        expect query.has_table() == true
        expect query.field_count() == 2
        expect query.is_valid() == true

    it "supports pipeline transformations":
        val pipe = Pipeline.new([1, 2, 3, 4, 5])
        expect pipe.size() == 5

        pipe.filter(\x: x > 2)
        expect pipe.size() == 3

        val result = pipe.collect()
        expect len(result) == 3
        expect result[0] == 3
