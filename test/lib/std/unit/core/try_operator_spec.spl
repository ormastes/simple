# @pending
# @skip - Uses unsupported keyword: with
"""
BDD Tests for Try Operator (?).

Feature: Error Handling with ? Operator.
The ? operator provides concise error propagation for Result and Option types.
When applied to a Result, it unwraps Ok or early-returns Err.
When applied to an Option, it unwraps Some or early-returns None.
"""


# Helper functions for testing

fn divide(a: i64, b: i64) -> Result<i64, text>:
    if b == 0:
        return Err("division by zero")
    return Ok(a / b)

fn sqrt_positive(x: i64) -> Result<i64, text>:
    if x < 0:
        return Err("negative number")
    # Simplified integer sqrt
    if x == 0:
        return Ok(0)
    var result = 1
    while result * result <= x:
        result = result + 1
    return Ok(result - 1)

fn find_value(arr: List<i64>, target: i64) -> Option<i64>:
    for i in 0..arr.len():
        if arr[i] == target:
            return Some(i)
    return None

# Functions that use ? operator

fn compute_ratio(a: i64, b: i64, c: i64) -> Result<i64, text>:
    # Uses ? to propagate errors
    val step1 = divide(a=a, b=b)?
    val step2 = divide(a=step1, b=c)?
    return Ok(step2)

fn safe_sqrt_ratio(a: i64, b: i64) -> Result<i64, text>:
    val ratio = divide(a=a, b=b)?
    val root = sqrt_positive(ratio)?
    return Ok(root)

fn get_element(arr: List<i64>, target: i64) -> Option<i64>:
    val idx = find_value(arr, target)?
    return Some(arr[idx])

describe "Try operator (?)":
    """
    Tests for the try operator (?) covering Result and Option types,
    error propagation, early return behavior, and nested function calls.
    """

    context "with Result type":
        it "unwraps Ok values":
            val result = divide(a=10, b=2)
            expect result.is_ok() == true
            expect result.unwrap() == 5

        it "propagates Err on failure":
            val result = compute_ratio(a=100, b=0, c=5)
            expect result.is_err() == true

        it "chains multiple ? operations":
            val result = compute_ratio(a=100, b=5, c=2)
            # 100 / 5 = 20, 20 / 2 = 10
            expect result.is_ok() == true
            expect result.unwrap() == 10

        it "stops at first error in chain":
            val result = safe_sqrt_ratio(a=10, b=0)
            # First division fails
            expect result.is_err() == true

        it "handles negative sqrt error":
            val result = safe_sqrt_ratio(a=-100, b=10)
            # -100 / 10 = -10, sqrt(-10) fails
            expect result.is_err() == true

        it "completes successfully when all succeed":
            val result = safe_sqrt_ratio(a=100, b=4)
            # 100 / 4 = 25, sqrt(25) = 5
            expect result.is_ok() == true
            expect result.unwrap() == 5

    context "with Option type":
        it "unwraps Some values":
            val arr = [10, 20, 30]
            val result = find_value(arr, 20)
            expect result.is_some() == true
            expect result.unwrap() == 1

        it "propagates None on not found":
            arr = [10, 20, 30]
            val result = get_element(arr, 99)
            expect result.is_none() == true

        it "returns value when found":
            arr = [10, 20, 30]
            val result = get_element(arr, 20)
            expect result.is_some() == true
            expect result.unwrap() == 20

    context "early return behavior":
        it "returns immediately on Err":
            # This tests that code after ? doesn't execute on error
            fn test_early_return(x: i64) -> Result<i64, text>:
                val result_val = divide(a=10, b=x)?
                # This line should not execute if x == 0
                return Ok(result_val * 1000)

            val result = test_early_return(0)
            expect result.is_err() == true

        it "continues execution on Ok":
            fn test_continue(x: i64) -> Result<i64, text>:
                val result_val = divide(a=10, b=x)?
                return Ok(result_val * 1000)

            val result = test_continue(2)
            expect result.is_ok() == true
            expect result.unwrap() == 5000

    context "nested function calls":
        it "propagates through call stack":
            fn inner(x: i64) -> Result<i64, text>:
                return divide(a=100, b=x)

            fn middle(x: i64) -> Result<i64, text>:
                val inner_val = inner(x)?
                return Ok(inner_val + 1)

            fn outer(x: i64) -> Result<i64, text>:
                val mid_val = middle(x)?
                return Ok(mid_val * 2)

            # Success case: 100/5=20, 20+1=21, 21*2=42
            val result = outer(5)
            expect result.is_ok() == true
            expect result.unwrap() == 42

            # Failure case: division by zero propagates up
            result_fail = outer(0)
            expect result_fail.is_err() == true
