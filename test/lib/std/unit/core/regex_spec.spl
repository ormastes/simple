"""
BDD Tests for Regex Module.

Feature #230: Regular expression support including pattern compilation,
matching, searching, splitting, and substitution operations.
"""

# @slow
# Performance note: ~1.6 seconds runtime. Regex operations are inherently expensive.

use core.regex

describe "Regex module":
    """
    Tests for the regular expression module covering pattern compilation,
    literal matching, search operations, full match, and splitting.
    """
    context "Pattern compilation":
        it "compiles a simple pattern":
            val pattern = regex.compile("hello")
            expect(pattern.get_pattern()).to eq("hello")

        it "compiles empty pattern":
            val pattern = regex.compile("")
            expect(pattern.get_pattern()).to eq("")

    context "Literal matching":
        it "matches at start of string":
            val result = regex.match(pattern="hello", input="hello world")
            expect(result.is_some()).to be_true()

        it "does not match if pattern not at start":
            val result = regex.match(pattern="world", input="hello world")
            expect(result == nil).to be_true()

        it "matches empty string":
            val result = regex.match(pattern="", input="anything")
            expect(result.is_some()).to be_true()

    context "Search anywhere":
        it "finds pattern in middle of string":
            val result = regex.search(pattern="world", input="hello world")
            expect(result.is_some()).to be_true()

        it "finds pattern at start":
            val result = regex.search(pattern="hello", input="hello world")
            expect(result.is_some()).to be_true()

        it "returns None if not found":
            val result = regex.search(pattern="missing", input="hello world")
            expect(result == nil).to be_true()

    context "Full match":
        it "matches entire string":
            val pattern = regex.compile("hello world")
            val result = pattern.match("hello world")
            expect(result.is_some()).to be_true()

        it "matches at start when using Pattern.match()":
            val pattern = regex.compile("hello")
            val result = pattern.match("hello world")
            expect(result.is_some()).to be_true()

        it "matches empty string":
            val pattern = regex.compile("")
            val result = pattern.match("")
            expect(result.is_some()).to be_true()

    context "Split by pattern":
        it "splits by literal comma":
            val parts = regex.split(pattern=",", input="a,b,c")
            expect(parts.len()).to eq(3)
            expect(parts[0]).to eq("a")
            expect(parts[1]).to eq("b")
            expect(parts[2]).to eq("c")

        it "splits by whitespace":
            val parts = regex.split(pattern=" ", input="hello world test")
            expect(parts.len()).to eq(3)

        it "handles string with no separator":
            val parts = regex.split(pattern=",", input="no separator")
            expect(parts.len()).to eq(1)
            expect(parts[0]).to eq("no separator")

# Advanced regex features
describe "Regex advanced features":
    """
    Tests for advanced regex features including find all matches,
    substitution, escaping special characters, and pattern building helpers.
    """
    context "Find all matches":
        it "find all occurrences":
            val matches = regex.findall(pattern="o", input="hello world")
            expect(matches.len()).to eq(2)

        it "find multiple word occurrences":
            val matches = regex.findall(pattern="test", input="test this test")
            expect(matches.len()).to eq(2)

        it "return empty list if no matches":
            val matches = regex.findall(pattern="xyz", input="hello world")
            expect(matches.len()).to eq(0)

        it "return non-overlapping matches only":
            # Pattern "aa" in "aaaa" should find 2 non-overlapping matches
            # at positions [0,2) and [2,4), not overlapping [0,2), [1,3), [2,4)
            val matches = regex.findall(pattern="aa", input="aaaa")
            expect(matches.len()).to eq(2)
            expect(matches[0].start).to eq(0)
            expect(matches[0].end).to eq(2)
            expect(matches[1].start).to eq(2)
            expect(matches[1].end).to eq(4)

    context "Substitution":
        it "replace all occurrences":
            val result = regex.sub(pattern="o", replacement="X", input="hello world")
            expect(result).to eq("hellX wXrld")

        it "replace first N occurrences":
            val result = regex.sub(pattern="o", replacement="X", input="hello world", count=1)
            expect(result).to eq("hellX world")

        it "handle no matches":
            val result = regex.sub(pattern="xyz", replacement="X", input="hello world")
            expect(result).to eq("hello world")

    context "Escape special characters":
        it "escape backslash":
            val result = regex.escape("\\")
            expect(result).to eq("\\\\")

        it "escape dot":
            val result = regex.escape(".")
            expect(result).to eq("\\.")

        it "escape multiple special chars":
            val result = regex.escape("a.b*c+d?")
            expect(result).to eq("a\\.b\\*c\\+d\\?")

        it "not escape regular characters":
            val result = regex.escape("abc123")
            expect(result).to eq("abc123")

    context "Pattern building helpers":
        it "create digit pattern":
            val pattern = regex.digit()
            expect(pattern).to eq("[0-9]")

        it "create word pattern":
            val pattern = regex.word()
            expect(pattern).to eq("[a-zA-Z0-9_]")

        it "create whitespace pattern":
            val pattern = regex.whitespace()
            expect(pattern).to eq("[ \t\n\r]")

        it "create zero-or-more quantifier":
            val pattern = regex.zero_or_more("a")
            expect(pattern).to eq("a*")

        it "create one-or-more quantifier":
            val pattern = regex.one_or_more("a")
            expect(pattern).to eq("a+")

        it "create optional quantifier":
            val pattern = regex.optional("a")
            expect(pattern).to eq("a?")

        it "create exact count quantifier":
            val pattern = regex.exactly("a", 3)
            expect(pattern).to eq(r"a{3}")

        it "create at-least quantifier":
            val pattern = regex.at_least("a", 2)
            expect(pattern).to eq(r"a{2,}")

        it "create range quantifier":
            val pattern = regex.between("a", 2, 5)
            expect(pattern).to eq(r"a{2,5}")
