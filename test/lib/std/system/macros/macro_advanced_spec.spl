"""
Advanced macro features specification.

Tests nested macros, macro composition, and complex const-eval scenarios
including conditional evaluation and polynomial calculations.
"""

import std.spec

# ============================================================================
# Module-level macro definitions
# ============================================================================

# Nested macros
macro adv_inner() -> (returns result: Int):
    emit result:
        let x = 5
        x

macro adv_outer() -> (returns result: Int):
    emit result:
        let x = 10
        x + adv_inner!()

macro adv_base(n: Int) -> (returns result: Int):
    emit result:
        let temp = n * 2
        temp

macro adv_wrapper() -> (returns result: Int):
    emit result:
        let temp = 5
        let a = adv_base!(temp)
        let b = adv_base!(10)
        temp + a + b

# Composition macros
macro adv_double(x: Int) -> (returns result: Int):
    emit result:
        x * 2

macro adv_triple(x: Int) -> (returns result: Int):
    emit result:
        x * 3

macro adv_add_one(x: Int) -> (returns result: Int):
    emit result:
        x + 1

macro adv_square(x: Int) -> (returns result: Int):
    emit result:
        x * x

# Const-eval edge case macros
macro adv_abs_diff(a: Int, b: Int) -> (returns result: Int):
    emit result:
        if a > b:
            return a - b
        else:
            return b - a

macro adv_classify(x: Int) -> (returns result: Int):
    emit result:
        if x < 0:
            return -1
        else:
            if x == 0:
                return 0
            else:
                return 1

macro adv_polynomial(x: Int) -> (returns result: Int):
    emit result:
        # f(x) = x^2 + 2x + 1 = (x+1)^2
        x * x + 2 * x + 1

# Advanced intro patterns
macro adv_make_accessors(name: Str const) -> (
    intro getter: enclosing.module.fn "adv_get_{name}"() -> Int,
    intro setter: enclosing.module.fn "adv_set_{name}"(v: Int) -> Int
):
    emit getter:
        fn "adv_get_{name}"() -> Int:
            return 42

    emit setter:
        fn "adv_set_{name}"(v: Int) -> Int:
            return v

# ============================================================================
# Invoke macros that generate functions at module level
# ============================================================================
adv_make_accessors!("value")

# ============================================================================
# Tests
# ============================================================================

describe "Advanced Macro Features":
    """
    Tests advanced macro capabilities including nested macro invocations,
    macro composition patterns, const-eval edge cases, and intro patterns.
    """

    describe "Nested macros":
        it "expands nested macro invocations":
            val result = adv_outer!()
            # Should be 10 + 5 = 15
            expect(result).to(eq(15))

        it "chains macro expansions":
            val result = adv_wrapper!()
            # 5 + 10 + 20 = 35
            expect(result).to(eq(35))

    describe "Macro composition":
        it "uses macros in computation":
            val a = adv_double!(10)
            val b = adv_triple!(7)
            # 20 + 21 = 41... let's adjust
            val c = adv_double!(21)
            expect(c).to(eq(42))

        it "composes multiple macro calls":
            val base = 5
            val incremented = adv_add_one!(base)
            val squared = adv_square!(incremented)
            # (5 + 1)^2 = 36
            expect(squared).to(eq(36))

    describe "Const-eval edge cases":
        it "handles const-eval with conditionals":
            expect(adv_abs_diff!(10, 5)).to(eq(5))
            expect(adv_abs_diff!(5, 10)).to(eq(5))
            expect(adv_abs_diff!(7, 7)).to(eq(0))

        it "handles const-eval with nested conditionals":
            expect(adv_classify!(-5)).to(eq(-1))
            expect(adv_classify!(0)).to(eq(0))
            expect(adv_classify!(5)).to(eq(1))

        it "handles const-eval with complex arithmetic":
            # f(5) = 25 + 10 + 1 = 36
            expect(adv_polynomial!(5)).to(eq(36))
            # f(0) = 0 + 0 + 1 = 1
            expect(adv_polynomial!(0)).to(eq(1))

    describe "Advanced intro patterns":
        it "generates multiple related functions":
            val got = adv_get_value()
            val set_result = adv_set_value(100)
            expect(got).to(eq(42))
            expect(set_result).to(eq(100))
