# @pending
"""
Macro contracts specification.

Tests the macro contract system including intro contracts for function
introduction, returns contracts for value emission, and inject contracts
for code injection at specific anchors.
"""


# ============================================================================
# Module-level macro definitions
# ============================================================================

# Intro contract macros
macro contract_make_adder(n: Int const) -> (
    returns result: Int,
    intro add_fn: enclosing.module.fn "contract_add_n"(x: Int) -> Int
):
    emit add_fn:
        fn contract_add_n(x: Int) -> Int:
            return x + n

    emit result:
        0

macro contract_gen_funcs(n: Int const) -> (
    returns result: Int,
    intro funcs:
        for i in 0..n:
            enclosing.module.fn "contract_get_{i}"() -> Int
):
    emit funcs:
        fn contract_get_0() -> Int:
            return 0
        fn contract_get_1() -> Int:
            return 1
        fn contract_get_2() -> Int:
            return 2

    emit result:
        n

# Returns contract macros
macro contract_answer() -> (returns result: Int):
    emit result:
        42

macro contract_compute(a: Int, b: Int) -> (returns result: Int):
    emit result:
        a * b + 2

# Inject contract macros
macro contract_with_cleanup(v: Int) -> (
    returns result: Int,
    inject cleanup: callsite.block.tail.stmt
):
    emit cleanup:
        println!("Cleanup running")

    emit result:
        v

# Combined contract macros
macro contract_make_counter(start: Int const) -> (
    returns result: Int,
    intro getter: enclosing.module.fn "contract_get_count"() -> Int
):
    emit getter:
        fn contract_get_count() -> Int:
            return start

    emit result:
        start

# ============================================================================
# Invoke macros that generate functions at module level
# ============================================================================
let _ = contract_make_adder!(10)
let _ = contract_gen_funcs!(3)
val contract_initial = contract_make_counter!(100)

# Test function for inject
fn contract_test_fn() -> Int:
    let x = contract_with_cleanup!(42)
    println!("After macro, before tail")
    return x

# ============================================================================
# Tests
# ============================================================================

describe "Macro Contracts":
    """
    Tests the macro contract system including intro contracts for introducing
    functions, returns contracts for emitting values, and inject contracts
    for code injection with anchors.
    """

    describe "intro contracts":
        it "introduces functions to enclosing module":
            val x = contract_add_n(32)
            expect(x).to_equal(42)

        it "introduces multiple functions from const-eval loop":
            val sum = contract_get_0() + contract_get_1() + contract_get_2()
            expect(sum).to_equal(3)

    describe "returns contracts":
        it "returns simple values":
            val x = contract_answer!()
            expect(x).to_equal(42)

        it "returns computed values from const-eval":
            val x = contract_compute!(8, 5)
            expect(x).to_equal(42)

    describe "inject contracts":
        it "injects code with tail anchor":
            val result = contract_test_fn()
            expect(result).to_equal(42)

    describe "combined contracts":
        it "uses intro and returns together":
            val retrieved = contract_get_count()
            expect(contract_initial).to_equal(100)
            expect(retrieved).to_equal(100)
