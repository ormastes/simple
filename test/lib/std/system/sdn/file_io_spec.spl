# @skip
# SDN File I/O System Tests
#
# Tests for SdnDocument file operations:
# - from_file: Load and parse SDN files
# - write_file: Write document to file
# - Modification and persistence
"""
Tests for SDN document file I/O operations including loading, parsing,
writing, modification persistence, and concurrent file handling.
"""

use std.fs
use sdn.document.SdnDocument
use sdn.value.SdnValue

# Fixture paths
val FIXTURES_DIR = "test/lib/std/fixtures/sdn"
val PRIMITIVES_FILE = "${FIXTURES_DIR}/primitives.sdn"
val COLLECTIONS_FILE = "${FIXTURES_DIR}/collections.sdn"
val NESTED_FILE = "${FIXTURES_DIR}/nested.sdn"
val CONFIG_FILE = "${FIXTURES_DIR}/config_example.sdn"
val INVALID_DIR = "${FIXTURES_DIR}/invalid"

describe "SDN File I/O System Tests":
    """
    Verifies SdnDocument file operations: from_file for loading SDN files,
    write_file for persisting documents, and modification tracking.
    """
    context "file loading":
        it "loads and parses SDN file":
            match SdnDocument.from_file(PRIMITIVES_FILE):
                case Ok(doc):
                    # Verify we can access values
                    expect doc.get("int_positive").is_some() == true
                    expect doc.get("int_positive").flatmap(|v| v.as_i64()) == Some(42)
                case Err(e):
                    fail("Load error: ${e.to_string()}")

        it "loads nested structures from file":
            match SdnDocument.from_file(NESTED_FILE):
                case Ok(doc):
                    # Test deep path access
                    expect doc.get("application").is_some() == true
                    expect doc.get_path("application.core").is_some() == true
                case Err(e):
                    fail("Load error: ${e.to_string()}")

        it "loads arrays and dicts from file":
            match SdnDocument.from_file(COLLECTIONS_FILE):
                case Ok(doc):
                    # Check for array
                    match doc.get("simple_array"):
                        case Some(arr):
                            expect arr.is_array() == true
                        case None:
                            fail("Expected 'simple_array' key")
                    # Check for dict
                    match doc.get("person"):
                        case Some(person):
                            expect person.is_dict() == true
                        case None:
                            fail("Expected 'person' key")
                case Err(e):
                    fail("Load error: ${e.to_string()}")

        it "handles missing file":
            match SdnDocument.from_file("nonexistent_file.sdn"):
                case Ok(_):
                    fail("Should have failed for missing file")
                case Err(e):
                    # Error expected
                    expect e.to_string().len() > 0

        it "handles malformed SDN file":
            val invalid_file = "${INVALID_DIR}/bad_indent.sdn"
            match SdnDocument.from_file(invalid_file):
                case Ok(_):
                    # Parser may be lenient
                    pass
                case Err(e):
                    # Error expected for malformed content
                    expect e.to_string().len() > 0

    context "file writing":
        it "writes document to file":
            # Create a document
            match SdnDocument.parse("name: Alice\nage: 30"):
                case Ok(doc):
                    val temp_file = "/tmp/test_write_doc.sdn"

                    match doc.write_file(temp_file):
                        case Ok(_):
                            # Verify file exists and has content
                            match fs.read_to_string(temp_file):
                                case Ok(content):
                                    expect content.contains("Alice") == true
                                    expect content.contains("30") == true
                                case Err(e):
                                    fail("Read error: ${e.to_string()}")
                        case Err(e):
                            fail("Write error: ${e.to_string()}")

                    fs.remove(temp_file)
                case Err(e):
                    fail("Parse error: ${e.to_string()}")

        it "preserves structure when writing":
            match SdnDocument.from_file(CONFIG_FILE):
                case Ok(doc):
                    val temp_file = "/tmp/test_preserve_structure.sdn"

                    match doc.write_file(temp_file):
                        case Ok(_):
                            # Re-load and verify structure preserved
                            match SdnDocument.from_file(temp_file):
                                case Ok(reloaded):
                                    expect reloaded.get("app").is_some() == true
                                    expect reloaded.get("server").is_some() == true
                                case Err(e):
                                    fail("Reload error: ${e.to_string()}")
                        case Err(e):
                            fail("Write error: ${e.to_string()}")

                    fs.remove(temp_file)
                case Err(e):
                    fail("Load error: ${e.to_string()}")

        it "handles write errors (invalid path)":
            match SdnDocument.parse("key: value"):
                case Ok(doc):
                    # Try to write to an invalid path
                    match doc.write_file("/nonexistent_directory/file.sdn"):
                        case Ok(_):
                            fail("Should have failed for invalid path")
                        case Err(e):
                            # Error expected
                            expect e.to_string().len() > 0
                case Err(e):
                    fail("Parse error: ${e.to_string()}")

    context "modification and persistence":
        # TODO: Fix SdnDocument mutation methods
        # These tests fail due to issues with mutable document operations
        it "modifies and persists changes":
            val temp_file = "/tmp/test_modify_persist.sdn"
            fs.write(temp_file, "name: Alice\nage: 30")

            match SdnDocument.from_file(temp_file):
                case Ok(mut doc):
                    # Modify
                    doc.set("age", SdnValue.i32(31))
                    expect doc.is_modified() == true

                    # Persist
                    match doc.write_file(temp_file):
                        case Ok(_):
                            # Reload and verify
                            match SdnDocument.from_file(temp_file):
                                case Ok(reloaded):
                                    expect reloaded.get("age").flatmap(|v| v.as_i64()) == Some(31)
                                case Err(e):
                                    fail("Reload error: ${e.to_string()}")
                        case Err(e):
                            fail("Write error: ${e.to_string()}")
                case Err(e):
                    fail("Load error: ${e.to_string()}")

            fs.remove(temp_file)

        it "handles delete and persist":
            val temp_file = "/tmp/test_delete_persist.sdn"
            fs.write(temp_file, "a: 1\nb: 2\nc: 3")

            match SdnDocument.from_file(temp_file):
                case Ok(mut doc):
                    # Delete a key
                    doc.delete("b")

                    # Persist
                    match doc.write_file(temp_file):
                        case Ok(_):
                            # Reload and verify
                            match SdnDocument.from_file(temp_file):
                                case Ok(reloaded):
                                    expect reloaded.get("a").is_some() == true
                                    expect reloaded.get("b").is_none() == true
                                    expect reloaded.get("c").is_some() == true
                                case Err(e):
                                    fail("Reload error: ${e.to_string()}")
                        case Err(e):
                            fail("Write error: ${e.to_string()}")
                case Err(e):
                    fail("Load error: ${e.to_string()}")

            fs.remove(temp_file)

        it "handles array push and persist":
            val temp_file = "/tmp/test_push_persist.sdn"
            fs.write(temp_file, "items = [1, 2, 3]")

            match SdnDocument.from_file(temp_file):
                case Ok(mut doc):
                    # Push to array
                    doc.push("items", SdnValue.i32(4))

                    # Persist
                    match doc.write_file(temp_file):
                        case Ok(_):
                            # Reload and verify
                            match SdnDocument.from_file(temp_file):
                                case Ok(reloaded):
                                    match reloaded.get("items"):
                                        case Some(arr):
                                            match arr.len():
                                                case Some(len):
                                                    expect len == 4
                                                case None:
                                                    fail("Expected array length")
                                        case None:
                                            fail("Expected 'items' key")
                                case Err(e):
                                    fail("Reload error: ${e.to_string()}")
                        case Err(e):
                            fail("Write error: ${e.to_string()}")
                case Err(e):
                    fail("Load error: ${e.to_string()}")

            fs.remove(temp_file)

    context "concurrent file operations":
        it "handles multiple documents from same file":
            match SdnDocument.from_file(CONFIG_FILE):
                case Ok(doc1):
                    match SdnDocument.from_file(CONFIG_FILE):
                        case Ok(doc2):
                            # Both should have the same values
                            val app1 = doc1.get("app.name")
                            val app2 = doc2.get("app.name")
                            expect app1 == app2
                        case Err(e):
                            fail("Load error for doc2: ${e.to_string()}")
                case Err(e):
                    fail("Load error for doc1: ${e.to_string()}")

        it "handles large file operations":
            # Create a large SDN document
            var content = ""
            for i in 0..100:
                content += "key_${i}: value_${i}\n"

            val temp_file = "/tmp/test_large_file.sdn"
            fs.write(temp_file, content)

            match SdnDocument.from_file(temp_file):
                case Ok(doc):
                    # Should be able to access any key
                    expect doc.get("key_0").is_some() == true
                    expect doc.get("key_50").is_some() == true
                    expect doc.get("key_99").is_some() == true
                case Err(e):
                    fail("Load error: ${e.to_string()}")

            fs.remove(temp_file)
