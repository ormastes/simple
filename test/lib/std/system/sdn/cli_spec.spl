# SDN CLI System Tests
#
# Tests for SDN CLI commands via subprocess execution.
#
# Commands tested:
# - check: Validate SDN syntax
# - to-json: Convert SDN to JSON
# - from-json: Convert JSON to SDN
# - get: Extract value at path
# - set: Update value at path
# - fmt: Format SDN file

use std.spec.*
use std.process.{run, ProcessResult}
use std.fs

# Fixture paths
val FIXTURES_DIR = "test/lib/std/fixtures/sdn"
val PRIMITIVES_FILE = "${FIXTURES_DIR}/primitives.sdn"
val COLLECTIONS_FILE = "${FIXTURES_DIR}/collections.sdn"
val NESTED_FILE = "${FIXTURES_DIR}/nested.sdn"
val CONFIG_FILE = "${FIXTURES_DIR}/config_example.sdn"
val INVALID_DIR = "${FIXTURES_DIR}/invalid"

describe "SDN CLI System Tests":
    context "check command":
        it "validates valid SDN file":
            val result = run("./target/debug/simple", ["sdn", "check", PRIMITIVES_FILE])
            expect result.exit_code == 0
            expect result.stdout.contains("valid") == true

        it "reports syntax errors":
            val invalid_file = "${INVALID_DIR}/missing_colon.sdn"
            val result = run("./target/debug/simple", ["sdn", "check", invalid_file])
            expect result.exit_code != 0
            expect result.stderr.len() > 0

        it "handles missing file":
            val result = run("./target/debug/simple", ["sdn", "check", "nonexistent.sdn"])
            expect result.exit_code != 0
            expect result.stderr.contains("Error") == true

    context "to-json command":
        it "converts SDN to JSON":
            val result = run("./target/debug/simple", ["sdn", "to-json", PRIMITIVES_FILE])
            expect result.exit_code == 0
            # JSON output should contain braces
            expect result.stdout.contains("{") == true
            expect result.stdout.contains("}") == true

        it "handles nested structures":
            val result = run("./target/debug/simple", ["sdn", "to-json", NESTED_FILE])
            expect result.exit_code == 0
            # Should produce valid JSON with nested objects
            expect result.stdout.contains("{") == true

        it "handles arrays and dicts":
            val result = run("./target/debug/simple", ["sdn", "to-json", COLLECTIONS_FILE])
            expect result.exit_code == 0
            # Should have both arrays and objects in output
            expect result.stdout.contains("[") == true
            expect result.stdout.contains("{") == true

    context "from-json command":
        it "converts JSON to SDN":
            # Create temp JSON file
            val temp_json = "/tmp/test_from_json.json"
            fs.write(temp_json, "{\"name\": \"Alice\", \"age\": 30}")

            val result = run("./target/debug/simple", ["sdn", "from-json", temp_json])
            expect result.exit_code == 0
            # SDN output should contain the values
            expect result.stdout.contains("Alice") == true
            expect result.stdout.contains("30") == true

            fs.remove(temp_json)

        it "handles nested JSON objects":
            val temp_json = "/tmp/test_nested_json.json"
            fs.write(temp_json, "{\"server\": {\"host\": \"localhost\", \"port\": 8080}}")

            val result = run("./target/debug/simple", ["sdn", "from-json", temp_json])
            expect result.exit_code == 0
            expect result.stdout.contains("localhost") == true
            expect result.stdout.contains("8080") == true

            fs.remove(temp_json)

        it "handles JSON arrays":
            val temp_json = "/tmp/test_array_json.json"
            fs.write(temp_json, "{\"items\": [1, 2, 3]}")

            val result = run("./target/debug/simple", ["sdn", "from-json", temp_json])
            expect result.exit_code == 0
            # Output should reference the array values
            expect result.stdout.len() > 0

            fs.remove(temp_json)

    context "get command":
        it "extracts top-level value":
            val result = run("./target/debug/simple", ["sdn", "get", CONFIG_FILE, "app.name"])
            expect result.exit_code == 0
            expect result.stdout.contains("MyService") == true

        it "extracts nested value via path":
            val result = run("./target/debug/simple", ["sdn", "get", CONFIG_FILE, "server.port"])
            expect result.exit_code == 0
            expect result.stdout.contains("8080") == true

        it "handles missing path":
            val result = run("./target/debug/simple", ["sdn", "get", CONFIG_FILE, "nonexistent.path"])
            expect result.exit_code != 0
            expect result.stderr.contains("not found") == true

    context "set command":
        it "sets top-level value":
            # Create a temp copy of config file
            val temp_file = "/tmp/test_set_toplevel.sdn"
            val content = fs.read_to_string(CONFIG_FILE).unwrap_or("")
            fs.write(temp_file, content)

            val result = run("./target/debug/simple", ["sdn", "set", temp_file, "app.name", "NewService"])
            expect result.exit_code == 0

            # Verify the change
            val verify = run("./target/debug/simple", ["sdn", "get", temp_file, "app.name"])
            expect verify.stdout.contains("NewService") == true

            fs.remove(temp_file)

        it "sets nested value":
            val temp_file = "/tmp/test_set_nested.sdn"
            val content = fs.read_to_string(CONFIG_FILE).unwrap_or("")
            fs.write(temp_file, content)

            val result = run("./target/debug/simple", ["sdn", "set", temp_file, "server.port", "9090"])
            expect result.exit_code == 0

            # Verify the change
            val verify = run("./target/debug/simple", ["sdn", "get", temp_file, "server.port"])
            expect verify.stdout.contains("9090") == true

            fs.remove(temp_file)

        it "handles invalid path":
            val temp_file = "/tmp/test_set_invalid.sdn"
            fs.write(temp_file, "key: value")

            val result = run("./target/debug/simple", ["sdn", "set", temp_file, "nonexistent.deep.path", "value"])
            expect result.exit_code != 0

            fs.remove(temp_file)

    context "fmt command":
        it "formats file to stdout":
            val result = run("./target/debug/simple", ["sdn", "fmt", PRIMITIVES_FILE])
            expect result.exit_code == 0
            # Output should be formatted SDN
            expect result.stdout.len() > 0

        it "formats file in-place with --write":
            # Create temp file with unformatted content
            val temp_file = "/tmp/test_fmt_inplace.sdn"
            fs.write(temp_file, "key:value\n  another:  thing")

            val result = run("./target/debug/simple", ["sdn", "fmt", temp_file, "--write"])
            expect result.exit_code == 0
            expect result.stdout.contains("Formatted") == true

            # Verify file was modified
            val content = fs.read_to_string(temp_file).unwrap_or("")
            expect content.len() > 0

            fs.remove(temp_file)
