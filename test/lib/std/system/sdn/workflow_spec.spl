# SDN Workflow System Tests
#
# Tests for end-to-end SDN workflows:
# - Configuration management
# - Data migration (JSON <-> SDN)
# - Batch operations
# - Pipeline transformations
# - Error recovery

use std.spec.*
use std.fs
use std.process.run
use sdn.document.SdnDocument
use sdn.parser.parse
use sdn.serializer.to_sdn
use sdn.serializer.to_json
use sdn.value.SdnValue

# Helper constants for curly braces (avoids f-string parsing issues)
val LBRACE = "{"
val RBRACE = "}"

describe "SDN Workflow System Tests":
    context "configuration management":
        it "loads config, updates settings, and saves":
            # Create initial config
            val temp_config = "/tmp/test_config_workflow.sdn"
            val initial = "app:\n    name: MyApp\n    version: 1.0.0\n    debug: false"
            fs.write(temp_config, initial)

            # Load, update, save workflow
            match SdnDocument.from_file(temp_config):
                case Ok(mut doc):
                    # Update multiple settings
                    doc.set("app.version", SdnValue.text("2.0.0"))
                    doc.set("app.debug", SdnValue.bool(true))

                    # Save
                    match doc.write_file(temp_config):
                        case Ok(_):
                            # Reload and verify all updates persisted
                            match SdnDocument.from_file(temp_config):
                                case Ok(reloaded):
                                    expect reloaded.get_path("app.version").flatmap(|v| v.as_str()) == Some("2.0.0")
                                    expect reloaded.get_path("app.debug").flatmap(|v| v.as_bool()) == Some(true)
                                    # Original field should be preserved
                                    expect reloaded.get_path("app.name").flatmap(|v| v.as_str()) == Some("MyApp")
                                case Err(e):
                                    fail("Reload error: ${e.to_string()}")
                        case Err(e):
                            fail("Write error: ${e.to_string()}")
                case Err(e):
                    fail("Load error: ${e.to_string()}")

            fs.remove(temp_config)

        it "manages multiple config files":
            val config1 = "/tmp/test_multi_config1.sdn"
            val config2 = "/tmp/test_multi_config2.sdn"

            fs.write(config1, "service: auth\nport: 8001")
            fs.write(config2, "service: api\nport: 8002")

            # Load both configs
            match SdnDocument.from_file(config1):
                case Ok(doc1):
                    match SdnDocument.from_file(config2):
                        case Ok(doc2):
                            # Verify independent configs
                            expect doc1.get("service").flatmap(|v| v.as_str()) == Some("auth")
                            expect doc2.get("service").flatmap(|v| v.as_str()) == Some("api")
                            expect doc1.get("port").flatmap(|v| v.as_i64()) == Some(8001)
                            expect doc2.get("port").flatmap(|v| v.as_i64()) == Some(8002)
                        case Err(e):
                            fail("Load error for config2: ${e.to_string()}")
                case Err(e):
                    fail("Load error for config1: ${e.to_string()}")

            fs.remove(config1)
            fs.remove(config2)

    context "data migration":
        it "migrates JSON config to SDN":
            # Create JSON config
            val json_file = "/tmp/test_migrate_json_to_sdn.json"
            val sdn_file = "/tmp/test_migrate_json_to_sdn.sdn"
            val json_content = "{" + "\"name\": \"MyApp\", \"settings\": " + "{" + "\"debug\": true" + "}" + "}"
            fs.write(json_file, json_content)

            # Use CLI to convert
            val result = run("./target/debug/simple", ["sdn", "from-json", json_file])
            if result.exit_code == 0:
                # Save output to SDN file
                fs.write(sdn_file, result.stdout)

                # Verify SDN file is valid
                match SdnDocument.from_file(sdn_file):
                    case Ok(doc):
                        expect doc.get("name").is_some() == true
                        expect doc.get("settings").is_some() == true
                    case Err(e):
                        fail("Parse error: ${e.to_string()}")
            else:
                fail("CLI conversion failed")

            fs.remove(json_file)
            fs.remove(sdn_file)

        it "migrates SDN data to JSON":
            val sdn_file = "/tmp/test_migrate_sdn_to_json.sdn"
            fs.write(sdn_file, "name: MyApp\nsettings:\n    debug: true\n    level: info")

            # Use CLI to convert
            val result = run("./target/debug/simple", ["sdn", "to-json", sdn_file])
            expect result.exit_code == 0
            # Verify JSON output has expected structure
            expect result.stdout.contains("MyApp") == true
            expect result.stdout.contains("debug") == true
            val brace = "{"
            expect result.stdout.contains(brace) == true

            fs.remove(sdn_file)

    context "batch operations":
        it "updates multiple values in batch":
            val temp_file = "/tmp/test_batch_update.sdn"
            fs.write(temp_file, "a: 1\nb: 2\nc: 3\nd: 4\ne: 5")

            match SdnDocument.from_file(temp_file):
                case Ok(mut doc):
                    # Batch update - multiply all values by 10
                    doc.set("a", SdnValue.i32(10))
                    doc.set("b", SdnValue.i32(20))
                    doc.set("c", SdnValue.i32(30))
                    doc.set("d", SdnValue.i32(40))
                    doc.set("e", SdnValue.i32(50))

                    match doc.write_file(temp_file):
                        case Ok(_):
                            # Verify all updates
                            match SdnDocument.from_file(temp_file):
                                case Ok(reloaded):
                                    expect reloaded.get("a").flatmap(|v| v.as_i64()) == Some(10)
                                    expect reloaded.get("e").flatmap(|v| v.as_i64()) == Some(50)
                                case Err(e):
                                    fail("Reload error: ${e.to_string()}")
                        case Err(e):
                            fail("Write error: ${e.to_string()}")
                case Err(e):
                    fail("Load error: ${e.to_string()}")

            fs.remove(temp_file)

        it "processes multiple files in sequence":
            val files = [
                "/tmp/test_seq_file1.sdn",
                "/tmp/test_seq_file2.sdn",
                "/tmp/test_seq_file3.sdn"
            ]

            # Create files
            for i in 0..3:
                fs.write(files[i], "index: ${i}\nprocessed: false")

            # Process each file
            for file in files:
                match SdnDocument.from_file(file):
                    case Ok(mut doc):
                        doc.set("processed", SdnValue.bool(true))
                        doc.write_file(file)
                    case Err(e):
                        fail("Error processing ${file}: ${e.to_string()}")

            # Verify all processed
            for file in files:
                match SdnDocument.from_file(file):
                    case Ok(doc):
                        expect doc.get("processed").flatmap(|v| v.as_bool()) == Some(true)
                    case Err(e):
                        fail("Verify error: ${e.to_string()}")

            # Cleanup
            for file in files:
                fs.remove(file)

    context "pipeline transformations":
        it "transforms data through multiple stages":
            # Stage 1: Parse raw SDN
            val inner1 = "{" + "name: Alice, age: 30" + "}"
            val inner2 = "{" + "name: Bob, age: 25" + "}"
            val source = "users = [" + inner1 + ", " + inner2 + "]"
            match parse(source):
                case Ok(data):
                    # Stage 2: Transform to JSON
                    val json = to_json(data)
                    expect json.contains("Alice") == true
                    expect json.contains("Bob") == true

                    # Stage 3: Transform back to SDN
                    val sdn = to_sdn(data)
                    expect sdn.len() > 0

                    # Stage 4: Re-parse and verify
                    match parse(sdn):
                        case Ok(final_data):
                            expect final_data.get("users").is_some() == true
                        case Err(e):
                            fail("Re-parse error: ${e.to_string()}")
                case Err(e):
                    fail("Initial parse error: ${e.to_string()}")

    context "error recovery":
        it "handles partial failures gracefully":
            val temp_file = "/tmp/test_partial_failure.sdn"
            fs.write(temp_file, "valid_key: valid_value\nother: 42")

            match SdnDocument.from_file(temp_file):
                case Ok(mut doc):
                    # Successful update
                    doc.set("valid_key", SdnValue.text("updated"))

                    # Try invalid operation (set on non-existent nested path)
                    match doc.set("nonexistent.deep.path", SdnValue.i32(1)):
                        case Ok(_):
                            pass  # Unexpected success
                        case Err(_):
                            # Expected failure - but we can still save valid changes
                            pass

                    # Save what we have
                    match doc.write_file(temp_file):
                        case Ok(_):
                            # Verify the valid update was preserved
                            match SdnDocument.from_file(temp_file):
                                case Ok(reloaded):
                                    expect reloaded.get("valid_key").flatmap(|v| v.as_str()) == Some("updated")
                                case Err(e):
                                    fail("Reload error: ${e.to_string()}")
                        case Err(e):
                            fail("Write error: ${e.to_string()}")
                case Err(e):
                    fail("Load error: ${e.to_string()}")

            fs.remove(temp_file)

        it "recovers from write failures":
            val temp_file = "/tmp/test_write_recovery.sdn"
            fs.write(temp_file, "key: original")

            match SdnDocument.from_file(temp_file):
                case Ok(mut doc):
                    # Make changes
                    doc.set("key", SdnValue.text("modified"))

                    # Attempt to write to invalid path (should fail)
                    match doc.write_file("/invalid/path/file.sdn"):
                        case Ok(_):
                            fail("Should have failed writing to invalid path")
                        case Err(_):
                            # Write failed, but document still has our changes in memory
                            expect doc.get("key").flatmap(|v| v.as_str()) == Some("modified")

                            # Can still write to valid path
                            match doc.write_file(temp_file):
                                case Ok(_):
                                    # Verify recovery
                                    match SdnDocument.from_file(temp_file):
                                        case Ok(reloaded):
                                            expect reloaded.get("key").flatmap(|v| v.as_str()) == Some("modified")
                                        case Err(e):
                                            fail("Reload error: ${e.to_string()}")
                                case Err(e):
                                    fail("Recovery write error: ${e.to_string()}")
                case Err(e):
                    fail("Load error: ${e.to_string()}")

            fs.remove(temp_file)
