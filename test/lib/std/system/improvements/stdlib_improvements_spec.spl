# Standard Library Improvement Tests
# Tests for stdlib improvements documented in simple/improve_request.md
#
# Tests marked with `it` are WORKING features.
# Tests marked with `skip` are NOT YET IMPLEMENTED.

import spec

# Mock File System for testing
class MockFileSystem:
    files: text
    dirs: text

impl MockFileSystem:
    static fn create() -> MockFileSystem:
        MockFileSystem(files: "/tmp/test.txt,/etc/hostname", dirs: "/tmp,/etc")

    fn read_file(path: text) -> text:
        if path == "/tmp/test.txt":
            "Hello, World!"
        else:
            ""

    fn read_bytes(path: text) -> [i32]:
        if path == "/tmp/test.txt":
            [72, 101, 108, 108, 111]
        else:
            []

    fn read_lines(path: text) -> [text]:
        if path == "/tmp/test.txt":
            ["line1", "line2", "line3"]
        else:
            []

    fn write_file(path: text, content: text) -> bool:
        path.len() > 0 and content.len() >= 0

    fn write_bytes(path: text, data: [i32]) -> bool:
        path.len() > 0

    fn append_file(path: text, content: text) -> bool:
        path.len() > 0

    fn path_exists(path: text) -> bool:
        self.files.contains(path) or self.dirs.contains(path)

    fn is_file(path: text) -> bool:
        self.files.contains(path)

    fn is_dir(path: text) -> bool:
        self.dirs.contains(path)

    fn file_size(path: text) -> i32:
        if path == "/tmp/test.txt":
            13
        else:
            0

    fn list_dir(path: text) -> [text]:
        if path == "/tmp":
            ["test.txt", "other.txt"]
        else:
            []

    fn create_dir(path: text) -> bool:
        path.len() > 0

    fn remove_file(path: text) -> bool:
        self.files.contains(path)

    fn remove_dir(path: text) -> bool:
        self.dirs.contains(path)

# Mock JSON for testing
class MockJson:
    data: text

impl MockJson:
    static fn from_json(s: text) -> MockJson:
        MockJson(data: s)

    fn get(key: text) -> text:
        key

    fn is_object() -> bool:
        self.data.starts_with("object:")

    fn is_array() -> bool:
        self.data.starts_with("array:")

    static fn to_json(obj: text) -> text:
        "json:" + obj

    static fn escape(s: text) -> text:
        "escaped:" + s

# Mock JSON Builder
class MockJsonBuilder:
    content: text

impl MockJsonBuilder:
    static fn object() -> MockJsonBuilder:
        MockJsonBuilder(content: "object:empty")

    static fn array() -> MockJsonBuilder:
        MockJsonBuilder(content: "array:empty")

    me add(key: text, value: text) -> MockJsonBuilder:
        self.content = "object:" + key + "=" + value
        self

    me append(value: text) -> MockJsonBuilder:
        self.content = "array:" + value
        self

    fn build() -> text:
        self.content

describe "text Method Improvements":

    context "Substring Operations":
        it "substring extracts range":
            val text = "hello world"
            expect text.substring(0, 5) == "hello"

        it "substr extracts with length":
            val text = "hello world"
            expect text.substr(6, 5) == "world"

        it "char_at gets single character":
            val text = "hello"
            expect text.char_at(0) == "h"
            expect text.char_at(4) == "o"

        it "chars returns list of characters":
            val text = "abc"
            val chars = text.chars()
            expect chars.len() == 3
            expect chars[0] == "a"

    context "Search Operations":
        it "find returns index of substring":
            val text = "hello world"
            val result = text.find("world")
            expect result.is_some()

        it "find_all returns all indices":
            val text = "abcabc"
            val indices = text.find_all("a")
            expect indices.len() == 2

        it "contains checks for substring":
            val text = "hello world"
            expect text.contains("world") == true
            expect text.contains("xyz") == false

        it "starts_with checks prefix":
            val text = "hello world"
            expect text.starts_with("hello") == true
            expect text.starts_with("world") == false

        it "ends_with checks suffix":
            val text = "hello world"
            expect text.ends_with("world") == true
            expect text.ends_with("hello") == false

    context "Whitespace Operations":
        it "strip removes leading and trailing whitespace":
            val text = "  hello  "
            expect text.strip() == "hello"

        it "trim removes leading and trailing whitespace":
            val text = "  hello  "
            expect text.trim() == "hello"

        it "trim_start removes leading whitespace":
            val text = "  hello  "
            expect text.trim_start() == "hello  "

        it "trim_end removes trailing whitespace":
            val text = "  hello  "
            expect text.trim_end() == "  hello"

    context "Case Operations":
        it "to_upper converts to uppercase":
            val text = "hello"
            expect text.upper() == "HELLO"

        it "to_lower converts to lowercase":
            val text = "HELLO"
            expect text.to_lower() == "hello"

        it "capitalize capitalizes first letter":
            val text = "hello world"
            expect text.capitalize() == "Hello world"

    context "Split and Join":
        it "split divides string by delimiter":
            val text = "a,b,c"
            val parts = text.split(",")
            expect parts.len() == 3
            expect parts[0] == "a"

        it "join combines list with delimiter":
            val parts = ["a", "b", "c"]
            expect ",".join(parts) == "a,b,c"

        it "lines splits by newlines":
            val text = "line1\nline2\nline3"
            val lines = text.lines()
            expect lines.len() == 3

    context "Replacement":
        it "replace replaces all occurrences":
            val text = "hello hello"
            expect text.replace("hello", "hi") == "hi hi"

        it "replace_first replaces first occurrence":
            val text = "hello hello"
            expect text.replace_first("hello", "hi") == "hi hello"

describe "File I/O Improvements":

    context "File Reading":
        it "read_file returns file contents":
            val fs = MockFileSystem.create()
            val content = fs.read_file("/tmp/test.txt")
            expect content == "Hello, World!"

        it "read_bytes returns raw bytes":
            val fs = MockFileSystem.create()
            val bytes = fs.read_bytes("/tmp/test.txt")
            expect bytes.len() == 5
            expect bytes[0] == 72

        it "read_lines returns list of lines":
            val fs = MockFileSystem.create()
            val lines = fs.read_lines("/tmp/test.txt")
            expect lines.len() == 3
            expect lines[0] == "line1"

    context "File Writing":
        it "write_file writes string to file":
            val fs = MockFileSystem.create()
            val success = fs.write_file("/tmp/output.txt", "content")
            expect success == true

        it "write_bytes writes raw bytes":
            val fs = MockFileSystem.create()
            val success = fs.write_bytes("/tmp/output.bin", [1, 2, 3])
            expect success == true

        it "append_file appends to existing file":
            val fs = MockFileSystem.create()
            val success = fs.append_file("/tmp/test.txt", "more")
            expect success == true

    context "File Metadata":
        it "path_exists checks if path exists":
            val fs = MockFileSystem.create()
            expect fs.path_exists("/tmp/test.txt") == true
            expect fs.path_exists("/nonexistent") == false

        it "is_file checks if path is file":
            val fs = MockFileSystem.create()
            expect fs.is_file("/tmp/test.txt") == true
            expect fs.is_file("/tmp") == false

        it "is_dir checks if path is directory":
            val fs = MockFileSystem.create()
            expect fs.is_dir("/tmp") == true
            expect fs.is_dir("/tmp/test.txt") == false

        it "file_size returns size in bytes":
            val fs = MockFileSystem.create()
            expect fs.file_size("/tmp/test.txt") == 13

    context "Directory Operations":
        it "list_dir returns directory contents":
            val fs = MockFileSystem.create()
            val contents = fs.list_dir("/tmp")
            expect contents.len() == 2

        it "create_dir creates new directory":
            val fs = MockFileSystem.create()
            val success = fs.create_dir("/tmp/newdir")
            expect success == true

        it "remove_file deletes file":
            val fs = MockFileSystem.create()
            val success = fs.remove_file("/tmp/test.txt")
            expect success == true

        it "remove_dir deletes directory":
            val fs = MockFileSystem.create()
            val success = fs.remove_dir("/tmp")
            expect success == true

describe "JSON Library Improvements":

    context "JSON Parsing":
        it "from_json parses JSON string":
            val json = MockJson.from_json("object:test")
            expect json.is_object() == true

        it "parses JSON arrays":
            val json = MockJson.from_json("array:test")
            expect json.is_array() == true

        it "parses nested JSON":
            val json = MockJson.from_json("object:nested")
            expect json.is_object() == true

    context "JSON Generation":
        it "to_json converts dict to JSON":
            val json_str = MockJson.to_json("test")
            expect json_str.contains("json:")

        it "to_json handles nested structures":
            val json_str = MockJson.to_json("nested")
            expect json_str.starts_with("json:")

        it "escapes special characters":
            val escaped = MockJson.escape("test")
            expect escaped.starts_with("escaped:")

    context "JSON Builder":
        it "builds JSON objects fluently":
            val builder = MockJsonBuilder.object()
            builder.add("key", "value")
            val json_str = builder.build()
            expect json_str.contains("key")

        it "builds JSON arrays fluently":
            val builder = MockJsonBuilder.array()
            builder.append("item")
            val json_str = builder.build()
            expect json_str.contains("item")

describe "Error Handling Improvements":

    context "Question Mark Operator":
        # Helper functions for ? operator testing
        fn safe_divide(a: i64, b: i64) -> Result<i64, text>:
            if b == 0:
                return Err("division by zero")
            return Ok(a / b)

        fn wrapper_divide(a: i64, b: i64) -> Result<i64, text>:
            val result = safe_divide(a, b)?
            return Ok(result * 2)

        fn find_item(items: [i64], target: i64) -> Option<i64>:
            for i in 0..items.len():
                if items[i] == target:
                    return Some(i)
            return None

        fn get_doubled_index(items: [i64], target: i64) -> Option<i64>:
            val idx = find_item(items, target)?
            return Some(idx * 2)

        fn chain_operations(a: i64, b: i64, c: i64) -> Result<i64, text>:
            val step1 = safe_divide(a, b)?
            val step2 = safe_divide(step1, c)?
            return Ok(step2)

        it "propagates Result errors":
            # Test that ? propagates Err values
            val success = wrapper_divide(10, 2)
            expect success.is_ok() == true
            expect success.unwrap() == 10

            val failure = wrapper_divide(10, 0)
            expect failure.is_err() == true

        it "propagates Option None":
            # Test that ? propagates None values
            val items = [10, 20, 30]

            val found = get_doubled_index(items, 20)
            expect found.is_some() == true
            expect found.unwrap() == 2  # index 1 * 2

            val not_found = get_doubled_index(items, 99)
            expect not_found.is_none() == true

        it "chains multiple ? operations":
            # Test chaining multiple ? in sequence
            val success = chain_operations(100, 5, 2)
            # 100 / 5 = 20, 20 / 2 = 10
            expect success.is_ok() == true
            expect success.unwrap() == 10

            # First division fails
            val fail_first = chain_operations(100, 0, 2)
            expect fail_first.is_err() == true

            # Second division fails
            val fail_second = chain_operations(100, 5, 0)
            expect fail_second.is_err() == true
