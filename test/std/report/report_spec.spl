"""
# Report Specification

**Feature IDs:** #RPT-003
**Category:** Infrastructure
**Difficulty:** 3/5
**Status:** Implemented

## Overview

Tests for the Report class from the unified reporting system.
Verifies report creation, builder pattern, and formatting.

## Key Concepts

| Concept | Description |
|---------|-------------|
| Report | Core diagnostic message with level, code, location |
| ReportKind | Category of report (ParseError, TypeError, etc.) |
| Suggestion | Machine-applicable fix with confidence level |
| FixConfidence | How safe it is to auto-apply a fix |
"""

use std.spec.*
use std.report.*

# ============================================================================
# Test Group 1: Report Creation
# ============================================================================

describe "Report":
    """
    ## Report Creation

    Tests for creating reports with factory methods.
    """

    context "factory methods":
        """
        ### Report Factory Methods

        Reports can be created with error, warning, info, debug, fatal methods.
        """

        it "creates error report":
            val report = Report.error("test error")
            expect(report.level).to(eq(ReportLevel.Error))
            expect(report.message).to(eq("test error"))

        it "creates warning report":
            val report = Report.warning("test warning")
            expect(report.level).to(eq(ReportLevel.Warning))

        it "creates info report":
            val report = Report.info("test info")
            expect(report.level).to(eq(ReportLevel.Info))

        it "creates debug report":
            val report = Report.debug("test debug")
            expect(report.level).to(eq(ReportLevel.Debug))

        it "creates fatal report":
            val report = Report.fatal("test fatal")
            expect(report.level).to(eq(ReportLevel.Fatal))

    context "builder pattern":
        """
        ### Builder Pattern

        Reports can be built incrementally with with_* methods.
        """

        it "adds code with_code":
            val report = Report.error("message")
                .with_code("E0001")
            expect(report.code.?).to(be_true())
            expect(report.code.unwrap()).to(eq("E0001"))

        it "adds kind with_kind":
            val report = Report.error("message")
                .with_kind(ReportKind.TypeError)
            expect(report.kind).to(eq(ReportKind.TypeError))

        it "adds location with at":
            val report = Report.error("message")
                .at("test.spl", 10, 5)
            expect(report.location.?).to(be_true())
            expect(report.location.unwrap().file).to(eq("test.spl"))

        it "adds location with with_location":
            val loc = SourceLocation.at("test.spl", 10, 5)
            val report = Report.error("message")
                .with_location(loc)
            expect(report.location.?).to(be_true())

        it "adds note with_note":
            val report = Report.error("message")
                .with_note("additional info")
            expect(report.notes.len()).to(eq(1))
            expect(report.notes[0]).to(eq("additional info"))

        it "adds help with_help":
            val report = Report.error("message")
                .with_help("try this")
            expect(report.help.len()).to(eq(1))
            expect(report.help[0]).to(eq("try this"))

        it "adds source with_source":
            val report = Report.error("message")
                .with_source("compiler")
            expect(report.source_name.?).to(be_true())
            expect(report.source_name.unwrap()).to(eq("compiler"))

        it "chains multiple builders":
            val report = Report.error("type mismatch")
                .with_code("E0308")
                .at("main.spl", 10, 5)
                .with_note("expected i64")
                .with_help("add type annotation")
            expect(report.code.unwrap()).to(eq("E0308"))
            expect(report.location.unwrap().file).to(eq("main.spl"))
            expect(report.notes.len()).to(eq(1))
            expect(report.help.len()).to(eq(1))

    context "labels":
        """
        ### Report Labels

        Reports can have multiple labeled spans.
        """

        it "adds primary label":
            val loc = SourceLocation.at("test.spl", 10, 5)
            val report = Report.error("message")
                .with_primary_label(loc, "error here")
            expect(report.labels.len()).to(eq(1))
            expect(report.labels[0].primary).to(be_true())

        it "adds secondary label":
            val loc = SourceLocation.at("test.spl", 10, 5)
            val report = Report.error("message")
                .with_secondary_label(loc, "related")
            expect(report.labels.len()).to(eq(1))
            expect(report.labels[0].primary).to(be_false())

        it "adds multiple labels":
            val loc1 = SourceLocation.at("test.spl", 10, 5)
            val loc2 = SourceLocation.at("test.spl", 15, 3)
            val report = Report.error("message")
                .with_primary_label(loc1, "error")
                .with_secondary_label(loc2, "note")
            expect(report.labels.len()).to(eq(2))

    context "suggestions":
        """
        ### Fix Suggestions

        Reports can include machine-applicable fix suggestions.
        """

        it "adds suggestion":
            val loc = SourceLocation.at("test.spl", 10, 5)
            val suggestion = Suggestion.replace(loc, "new_code", "fix it")
            val report = Report.error("message")
                .with_suggestion(suggestion)
            expect(report.suggestions.len()).to(eq(1))
            expect(report.has_suggestions()).to(be_true())

        it "has_suggestions returns false when empty":
            val report = Report.error("message")
            expect(report.has_suggestions()).to(be_false())

    context "accessors":
        """
        ### Report Accessors

        Reports provide accessor methods for common checks.
        """

        it "is_error for Error level":
            val report = Report.error("message")
            expect(report.is_error()).to(be_true())

        it "is_error for Fatal level":
            val report = Report.fatal("message")
            expect(report.is_error()).to(be_true())

        it "is_error returns false for Warning":
            val report = Report.warning("message")
            expect(report.is_error()).to(be_false())

        it "is_warning for Warning level":
            val report = Report.warning("message")
            expect(report.is_warning()).to(be_true())

        it "has_location returns true when set":
            val report = Report.error("message")
                .at("test.spl", 10, 5)
            expect(report.has_location()).to(be_true())

        it "has_location returns false when not set":
            val report = Report.error("message")
            expect(report.has_location()).to(be_false())

        it "get_file returns file when location set":
            val report = Report.error("message")
                .at("test.spl", 10, 5)
            expect(report.get_file().?).to(be_true())
            expect(report.get_file().unwrap()).to(eq("test.spl"))

        it "get_line returns line when location set":
            val report = Report.error("message")
                .at("test.spl", 10, 5)
            expect(report.get_line()).to(eq(10))

    context "formatting":
        """
        ### Report Formatting

        Reports can be formatted as strings.
        """

        it "format_short includes level and message":
            val report = Report.error("test error")
            val formatted = report.format_short()
            expect(formatted).to(contain("error"))
            expect(formatted).to(contain("test error"))

        it "format_short includes code when set":
            val report = Report.error("test error")
                .with_code("E0001")
            val formatted = report.format_short()
            expect(formatted).to(contain("E0001"))

        it "format_short includes location when set":
            val report = Report.error("test error")
                .at("main.spl", 10, 5)
            val formatted = report.format_short()
            expect(formatted).to(contain("main.spl:10:5"))

# ============================================================================
# Test Group 2: ReportKind
# ============================================================================

describe "ReportKind":
    """
    ## ReportKind

    Tests for report kind categories.
    """

    context "category detection":
        """
        ### Category Detection

        Report kinds belong to compiler, runtime, or tool categories.
        """

        it "ParseError is compiler":
            expect(ReportKind.ParseError.is_compiler()).to(be_true())

        it "TypeError is compiler":
            expect(ReportKind.TypeError.is_compiler()).to(be_true())

        it "RuntimeError is runtime":
            expect(ReportKind.RuntimeError.is_runtime()).to(be_true())

        it "Panic is runtime":
            expect(ReportKind.Panic.is_runtime()).to(be_true())

        it "BuildError is tool":
            expect(ReportKind.BuildError.is_tool()).to(be_true())

        it "TestFailure is tool":
            expect(ReportKind.TestFailure.is_tool()).to(be_true())

    context "names":
        """
        ### Kind Names

        Each kind has a human-readable name.
        """

        it "ParseError name is parse error":
            expect(ReportKind.ParseError.name()).to(eq("parse error"))

        it "TypeError name is type error":
            expect(ReportKind.TypeError.name()).to(eq("type error"))

# ============================================================================
# Test Group 3: Suggestion and FixConfidence
# ============================================================================

describe "Suggestion":
    """
    ## Suggestion

    Tests for fix suggestion creation and confidence levels.
    """

    context "creation":
        """
        ### Suggestion Creation

        Suggestions can be created for replacement, insertion, or deletion.
        """

        it "creates replacement suggestion":
            val loc = SourceLocation.at("test.spl", 10, 5)
            val suggestion = Suggestion.replace(loc, "new_text", "description")
            expect(suggestion.new_text).to(eq("new_text"))
            expect(suggestion.message).to(eq("description"))
            expect(suggestion.confidence).to(eq(FixConfidence.MachineApplicable))

        it "creates deletion suggestion":
            val loc = SourceLocation.at("test.spl", 10, 5)
            val suggestion = Suggestion.delete(loc, "remove this")
            expect(suggestion.new_text).to(eq(""))

        it "creates suggestion with confidence":
            val loc = SourceLocation.at("test.spl", 10, 5)
            val suggestion = Suggestion.with_confidence(
                loc, "maybe", "uncertain fix", FixConfidence.MaybeIncorrect)
            expect(suggestion.confidence).to(eq(FixConfidence.MaybeIncorrect))

describe "FixConfidence":
    """
    ## FixConfidence

    Tests for fix confidence levels.
    """

    context "names":
        """
        ### Confidence Names

        Each confidence level has a name.
        """

        it "MachineApplicable name is safe":
            expect(FixConfidence.MachineApplicable.name()).to(eq("safe"))

        it "MaybeIncorrect name is likely":
            expect(FixConfidence.MaybeIncorrect.name()).to(eq("likely"))

        it "HasPlaceholders name is placeholder":
            expect(FixConfidence.HasPlaceholders.name()).to(eq("placeholder"))

    context "safety checks":
        """
        ### Safety Checks

        Confidence levels have safety check methods.
        """

        it "MachineApplicable is safe to auto apply":
            expect(FixConfidence.MachineApplicable.is_safe_to_auto_apply()).to(be_true())

        it "MaybeIncorrect is not safe to auto apply":
            expect(FixConfidence.MaybeIncorrect.is_safe_to_auto_apply()).to(be_false())

        it "MachineApplicable is likely correct":
            expect(FixConfidence.MachineApplicable.is_likely_correct()).to(be_true())

        it "MaybeIncorrect is likely correct":
            expect(FixConfidence.MaybeIncorrect.is_likely_correct()).to(be_true())

        it "HasPlaceholders is not likely correct":
            expect(FixConfidence.HasPlaceholders.is_likely_correct()).to(be_false())
