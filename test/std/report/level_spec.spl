"""
# ReportLevel Specification

**Feature IDs:** #RPT-001
**Category:** Infrastructure
**Difficulty:** 2/5
**Status:** Implemented

## Overview

Tests for ReportLevel enum and LevelConfig class from the unified reporting system.
Verifies severity level comparisons, parsing, and configuration overrides.

## Key Concepts

| Concept | Description |
|---------|-------------|
| ReportLevel | Enum with Debug, Info, Warning, Error, Fatal levels |
| LevelConfig | Configuration for level filtering and overrides |
"""

use std.spec.*
use std.report.*

# ============================================================================
# Test Group 1: ReportLevel Basic Functionality
# ============================================================================

describe "ReportLevel":
    """
    ## ReportLevel Enum

    Tests for the ReportLevel enum which represents severity levels.
    """

    context "level names":
        """
        ### Level Name Conversion

        Each level should have a string name representation.
        """

        it "returns correct name for Debug":
            expect(ReportLevel.Debug.name()).to_equal("debug")

        it "returns correct name for Info":
            expect(ReportLevel.Info.name()).to_equal("info")

        it "returns correct name for Warning":
            expect(ReportLevel.Warning.name()).to_equal("warning")

        it "returns correct name for Error":
            expect(ReportLevel.Error.name()).to_equal("error")

        it "returns correct name for Fatal":
            expect(ReportLevel.Fatal.name()).to_equal("fatal")

    context "level values":
        """
        ### Level Numeric Values

        Levels have numeric values for comparison: Debug=0, Info=1, Warning=2, Error=3, Fatal=4.
        """

        it "Debug has lowest value":
            expect(ReportLevel.Debug.value()).to_equal(0)

        it "Fatal has highest value":
            expect(ReportLevel.Fatal.value()).to_equal(4)

        it "levels are ordered correctly":
            expect(ReportLevel.Debug.value()).to(be_less_than(ReportLevel.Info.value()))
            expect(ReportLevel.Info.value()).to(be_less_than(ReportLevel.Warning.value()))
            expect(ReportLevel.Warning.value()).to(be_less_than(ReportLevel.Error.value()))
            expect(ReportLevel.Error.value()).to(be_less_than(ReportLevel.Fatal.value()))

    context "level comparisons":
        """
        ### Level Comparison Methods

        Levels can be compared using is_at_least and is_more_severe_than.
        """

        it "Error is at least Warning":
            expect(ReportLevel.Error.is_at_least(ReportLevel.Warning)).to_be_true()

        it "Warning is not at least Error":
            expect(ReportLevel.Warning.is_at_least(ReportLevel.Error)).to_be_false()

        it "same level is at least itself":
            expect(ReportLevel.Warning.is_at_least(ReportLevel.Warning)).to_be_true()

        it "Fatal is more severe than Error":
            expect(ReportLevel.Fatal.is_more_severe_than(ReportLevel.Error)).to_be_true()

        it "Error is not more severe than itself":
            expect(ReportLevel.Error.is_more_severe_than(ReportLevel.Error)).to_be_false()

    context "error detection":
        """
        ### Error Level Detection

        Only Error and Fatal levels are considered errors.
        """

        it "Error is_error returns true":
            expect(ReportLevel.Error.is_error()).to_be_true()

        it "Fatal is_error returns true":
            expect(ReportLevel.Fatal.is_error()).to_be_true()

        it "Warning is_error returns false":
            expect(ReportLevel.Warning.is_error()).to_be_false()

        it "Info is_error returns false":
            expect(ReportLevel.Info.is_error()).to_be_false()

    context "parsing":
        """
        ### Level Parsing from Strings

        Levels can be parsed from strings (case-insensitive).
        """

        it "parses 'error' correctly":
            val result = ReportLevel.parse("error")
            expect(result.?).to_be_true()
            expect(result.unwrap()).to_equal(ReportLevel.Error)

        it "parses 'WARNING' (uppercase) correctly":
            val result = ReportLevel.parse("WARNING")
            expect(result.?).to_be_true()
            expect(result.unwrap()).to_equal(ReportLevel.Warning)

        it "parses 'warn' shorthand correctly":
            val result = ReportLevel.parse("warn")
            expect(result.?).to_be_true()
            expect(result.unwrap()).to_equal(ReportLevel.Warning)

        it "returns nil for invalid input":
            val result = ReportLevel.parse("invalid")
            expect(result.?).to_be_false()

    context "colors":
        """
        ### ANSI Color Codes

        Each level has an associated ANSI color code.
        """

        it "Error has red color":
            expect(ReportLevel.Error.color()).to_contain("31")  # Red ANSI

        it "Warning has yellow color":
            expect(ReportLevel.Warning.color()).to_contain("33")  # Yellow ANSI

        it "Debug has gray color":
            expect(ReportLevel.Debug.color()).to_contain("90")  # Gray ANSI

# ============================================================================
# Test Group 2: LevelConfig
# ============================================================================

describe "LevelConfig":
    """
    ## LevelConfig Configuration

    Tests for level configuration including filtering and overrides.
    """

    context "default configuration":
        """
        ### Default Settings

        Default config has Info as minimum level and no overrides.
        """

        it "has Info as default min_level":
            val config = LevelConfig.default_config()
            expect(config.min_level).to_equal(ReportLevel.Info)

        it "has warnings_as_errors disabled":
            val config = LevelConfig.default_config()
            expect(config.warnings_as_errors).to_be_false()

    context "strict configuration":
        """
        ### Strict Settings

        Strict config shows all levels and treats warnings as errors.
        """

        it "has Debug as min_level":
            val config = LevelConfig.strict()
            expect(config.min_level).to_equal(ReportLevel.Debug)

        it "has warnings_as_errors enabled":
            val config = LevelConfig.strict()
            expect(config.warnings_as_errors).to_be_true()

    context "quiet configuration":
        """
        ### Quiet Settings

        Quiet config only shows errors.
        """

        it "has Error as min_level":
            val config = LevelConfig.quiet()
            expect(config.min_level).to_equal(ReportLevel.Error)

    context "should_display":
        """
        ### Display Filtering

        Reports are filtered based on minimum level.
        """

        it "displays Error when min_level is Warning":
            val config = LevelConfig.default_config()
            config.set_min_level(ReportLevel.Warning)
            expect(config.should_display(ReportLevel.Error)).to_be_true()

        it "does not display Info when min_level is Warning":
            val config = LevelConfig.default_config()
            config.set_min_level(ReportLevel.Warning)
            expect(config.should_display(ReportLevel.Info)).to_be_false()

        it "displays Warning when min_level is Warning":
            val config = LevelConfig.default_config()
            config.set_min_level(ReportLevel.Warning)
            expect(config.should_display(ReportLevel.Warning)).to_be_true()

    context "effective_level":
        """
        ### Effective Level Calculation

        Effective level considers warnings_as_errors and overrides.
        """

        it "upgrades Warning to Error when warnings_as_errors":
            val config = LevelConfig.strict()
            val effective = config.effective_level(ReportLevel.Warning, nil)
            expect(effective).to_equal(ReportLevel.Error)

        it "does not upgrade Error when warnings_as_errors":
            val config = LevelConfig.strict()
            val effective = config.effective_level(ReportLevel.Error, nil)
            expect(effective).to_equal(ReportLevel.Error)

    context "code overrides":
        """
        ### Per-Code Level Overrides

        Specific error codes can have their levels overridden.
        """

        it "applies code override":
            val config = LevelConfig.default_config()
            config.set_code_level("L:test_rule", ReportLevel.Info)
            val effective = config.effective_level(ReportLevel.Warning, Some("L:test_rule"))
            expect(effective).to_equal(ReportLevel.Info)

        it "uses original level when no override":
            val config = LevelConfig.default_config()
            val effective = config.effective_level(ReportLevel.Warning, Some("L:unknown"))
            expect(effective).to_equal(ReportLevel.Warning)

    context "pattern matching":
        """
        ### Wildcard Pattern Matching

        Level overrides can use wildcard patterns.
        """

        it "matches exact pattern":
            val config = LevelConfig.default_config()
            expect(config.matches_pattern("hello", "hello")).to_be_true()

        it "matches wildcard at end":
            val config = LevelConfig.default_config()
            expect(config.matches_pattern("hello_world", "hello*")).to_be_true()

        it "matches wildcard at start":
            val config = LevelConfig.default_config()
            expect(config.matches_pattern("test_hello", "*hello")).to_be_true()

        it "matches wildcard in middle":
            val config = LevelConfig.default_config()
            expect(config.matches_pattern("deprecated_feature", "*deprecated*")).to_be_true()

        it "does not match non-matching pattern":
            val config = LevelConfig.default_config()
            expect(config.matches_pattern("hello", "world")).to_be_false()
