# @Feature 709.1: Error handling
# @Description: Test Result and Option types for error handling

# NOTE: describe, it, expect are built-in - no imports needed

# @skip - Uses unsupported keyword: with
describe "Result type":
    it "creates Ok result":
        val result: Result<i64, text> = Ok(42)
        match result:
            case Ok(value):
                expect value == 42
            case Err(_):
                expect false

    it "creates Err result":
        val result: Result<i64, text> = Err("failed")
        match result:
            case Err(msg):
                expect msg == "failed"
            case Ok(_):
                expect false

    it "uses is_ok and is_err":
        val ok_result: Result<i64, text> = Ok(42)
        val err_result: Result<i64, text> = Err("failed")

        expect ok_result.is_ok()
        expect not ok_result.is_err()
        expect err_result.is_err()
        expect not err_result.is_ok()

    it "unwraps Ok values":
        val result: Result<i64, text> = Ok(42)
        val value = result.unwrap()
        expect value == 42

    it "provides default on error":
        val result: Result<i64, text> = Err("failed")
        val value = result.unwrap_or(0)
        expect value == 0

    it "maps Ok values":
        val result: Result<i64, text> = Ok(10)
        val doubled = result.map(\x: x * 2)
        match doubled:
            case Ok(value):
                expect value == 20
            case Err(_):
                expect false

    it "maps Err values":
        val result: Result<i64, text> = Err("error")
        val mapped = result.map_err(\msg: msg.upper())
        match mapped:
            case Err(msg):
                expect msg == "ERROR"
            case Ok(_):
                expect false

describe "Option type":
    it "creates Some option":
        val opt: Option<i64> = Some(42)
        match opt:
            case Some(value):
                expect value == 42
            case None:
                expect false

    it "creates None option":
        val opt: Option<i64> = None
        match opt:
            case None:
                expect true
            case Some(_):
                expect false

    it "uses is_some and is_none":
        val some_val: Option<i64> = Some(42)
        val none_val: Option<i64> = None

        expect some_val.is_some()
        expect not some_val.is_none()
        expect none_val.is_none()
        expect not none_val.is_some()

    it "unwraps Some values":
        val opt: Option<i64> = Some(42)
        val value = opt.unwrap()
        expect value == 42

    it "provides default on None":
        val opt: Option<i64> = None
        val value = opt.unwrap_or(0)
        expect value == 0

    it "maps Some values":
        val opt: Option<i64> = Some(10)
        val doubled = opt.map(\x: x * 2)
        match doubled:
            case Some(value):
                expect value == 20
            case None:
                expect false

    it "filters Some values":
        val opt: Option<i64> = Some(10)
        val filtered = opt.filter(\x: x > 5)
        expect filtered.is_some()

        val rejected = opt.filter(\x: x < 5)
        expect rejected.is_none()

describe "Try operator":
    it "propagates errors with ?":
        fn divide(a: i64, b: i64) -> Result<i64, text>:
            if b == 0:
                Err("Division by zero")
            else:
                Ok(a / b)

        fn complex_calc(x: i64) -> Result<i64, text>:
            val step1 = divide(x, 2)?
            val step2 = divide(step1, 3)?
            Ok(step2)

        val result = complex_calc(18)
        match result:
            case Ok(value):
                expect value == 3  # 18/2/3 = 3
            case Err(_):
                expect false

    it "short-circuits on first error":
        fn may_fail_early() -> Result<i64, text>:
            val x = Err("Early error")?
            Ok(x)

        val result = may_fail_early()
        match result:
            case Err(msg):
                expect msg == "Early error"
            case Ok(_):
                expect false

describe "Optional chaining":
    it "chains with ?. operator":
        struct Address:
            city: text

        struct Person:
            address: Option<Address>

        val person = Person(address: Some(Address(city: "NYC")))
        val city = person.address?.city
        match city:
            case Some(c):
                expect c == "NYC"
            case None:
                expect false

    it "returns None on any None in chain":
        struct Address:
            city: text

        struct Person:
            address: Option<Address>

        val person = Person(address: None)
        val city = person.address?.city
        expect city.is_none()

describe "Null coalescing":
    it "uses ?? for default values":
        val maybe_value: Option<i64> = None
        val value = maybe_value ?? 42
        expect value == 42

    it "returns value when Some":
        val maybe_value: Option<i64> = Some(10)
        val value = maybe_value ?? 42
        expect value == 10
