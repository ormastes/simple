# std.path Module - Comprehensive Test Suite
# Tests for pure Simple path manipulation utilities

use std.path as path

describe "std.path - Path Component Extraction":

    describe "basename()":
        it "extracts filename from absolute path":
            expect path.basename("/home/user/file.txt") == "file.txt"

        it "extracts filename from relative path":
            expect path.basename("relative/path/file.txt") == "file.txt"

        it "extracts directory name when path ends with slash":
            expect path.basename("/home/user/") == "user"

        it "returns filename when no directory component":
            expect path.basename("file.txt") == "file.txt"

        it "returns empty string for root path":
            expect path.basename("/") == ""

        it "returns empty string for empty input":
            expect path.basename("") == ""

        it "handles multiple trailing slashes":
            expect path.basename("/home/user///") == "user"

        it "handles path with single component":
            expect path.basename("docs") == "docs"

    describe "dirname()":
        it "extracts directory from absolute path":
            expect path.dirname("/home/user/file.txt") == "/home/user"

        it "extracts directory from nested path":
            expect path.dirname("/a/b/c/d.txt") == "/a/b/c"

        it "returns current directory for relative filename":
            expect path.dirname("file.txt") == "."

        it "returns root for file in root":
            expect path.dirname("/file.txt") == "/"

        it "returns root for root path":
            expect path.dirname("/") == "/"

        it "returns current directory for empty input":
            expect path.dirname("") == "."

        it "handles path with trailing slash":
            expect path.dirname("/home/user/") == "/home"

        it "handles relative path":
            expect path.dirname("a/b/c") == "a/b"

    describe "extension()":
        it "extracts extension from filename":
            expect path.extension("file.txt") == "txt"

        it "extracts last extension from multiple dots":
            expect path.extension("archive.tar.gz") == "gz"

        it "returns empty for no extension":
            expect path.extension("README") == ""

        it "returns empty for hidden files":
            expect path.extension(".gitignore") == ""

        it "extracts extension from path":
            expect path.extension("/home/user/document.pdf") == "pdf"

        it "handles uppercase extensions":
            expect path.extension("IMAGE.JPG") == "JPG"

        it "returns empty for trailing dot":
            expect path.extension("file.") == ""

        it "handles dotfile with extension":
            expect path.extension(".vimrc.bak") == "bak"

    describe "stem()":
        it "returns filename without extension":
            expect path.stem("file.txt") == "file"

        it "returns filename with partial extension removed":
            expect path.stem("archive.tar.gz") == "archive.tar"

        it "returns full name when no extension":
            expect path.stem("README") == "README"

        it "works with full path":
            expect path.stem("/home/user/document.pdf") == "document"

        it "handles hidden files":
            expect path.stem(".gitignore") == ".gitignore"

        it "handles multiple dots":
            expect path.stem("my.config.json") == "my.config"

describe "std.path - Path Construction":

    describe "join()":
        it "joins multiple path components":
            val result = path.join(["home", "user", "documents"])
            expect result == "home/user/documents"

        it "joins absolute and relative paths":
            val result = path.join(["/home", "user", "file.txt"])
            expect result == "/home/user/file.txt"

        it "handles empty list":
            expect path.join([]) == ""

        it "handles single component":
            expect path.join(["home"]) == "home"

        it "removes redundant slashes":
            val result = path.join(["/home/", "user/", "file.txt"])
            expect result == "/home/user/file.txt"

        it "handles empty components":
            val result = path.join(["a", "", "b", "", "c"])
            expect result == "a/b/c"

        it "preserves absolute path from first component":
            val result = path.join(["/", "home", "user"])
            expect result == "/home/user"

    describe "join2()":
        it "joins two paths":
            expect path.join2("/home/user", "file.txt") == "/home/user/file.txt"

        it "handles trailing slash in first path":
            expect path.join2("/home/user/", "file.txt") == "/home/user/file.txt"

        it "handles leading slash in second path":
            expect path.join2("/home/user", "/file.txt") == "/home/user/file.txt"

        it "joins relative paths":
            expect path.join2("a/b", "c/d") == "a/b/c/d"

describe "std.path - Path Normalization":

    describe "normalize()":
        it "removes double slashes":
            expect path.normalize("//home//user") == "/home/user"

        it "resolves current directory references":
            expect path.normalize("/home/./user") == "/home/user"

        it "resolves parent directory references":
            expect path.normalize("/home/foo/../user") == "/home/user"

        it "handles multiple parent references":
            expect path.normalize("/a/b/c/../../d") == "/a/d"

        it "preserves absolute path":
            expect path.normalize("/home/user") == "/home/user"

        it "normalizes relative path":
            expect path.normalize("a/./b/../c") == "a/c"

        it "returns current directory for empty path":
            expect path.normalize("") == "."

        it "handles root path":
            expect path.normalize("/") == "/"

        it "handles complex nested case":
            expect path.normalize("//a/b/./c//d/../e/f") == "/a/b/c/e/f"

        it "handles parent at root for relative":
            expect path.normalize("../a/b") == "../a/b"

        it "cannot go above root for absolute":
            expect path.normalize("/../../a") == "/a"

describe "std.path - Path Predicates":

    describe "is_absolute()":
        it "returns true for absolute path":
            expect path.is_absolute("/home/user")

        it "returns false for relative path":
            expect not path.is_absolute("home/user")

        it "returns true for root":
            expect path.is_absolute("/")

        it "returns false for empty string":
            expect not path.is_absolute("")

        it "returns false for current directory":
            expect not path.is_absolute(".")

        it "returns false for parent directory":
            expect not path.is_absolute("..")

    describe "is_relative()":
        it "returns true for relative path":
            expect path.is_relative("home/user")

        it "returns false for absolute path":
            expect not path.is_relative("/home/user")

        it "returns true for current directory":
            expect path.is_relative(".")

        it "returns true for empty string":
            expect path.is_relative("")

    describe "has_extension()":
        it "returns true when extension matches":
            expect path.has_extension("file.txt", "txt")

        it "handles extension with dot":
            expect path.has_extension("file.txt", ".txt")

        it "returns false when extension differs":
            expect not path.has_extension("file.txt", "pdf")

        it "returns false when no extension":
            expect not path.has_extension("README", "txt")

        it "handles uppercase extension":
            expect path.has_extension("IMAGE.JPG", "JPG")

        it "handles full path":
            expect path.has_extension("/home/user/doc.pdf", "pdf")

describe "std.path - Edge Cases and Integration":

    describe "complex path scenarios":
        it "handles very long paths":
            val long_path = "/a/b/c/d/e/f/g/h/i/j/k/l/m/n/o/p/file.txt"
            expect path.basename(long_path) == "file.txt"
            expect path.dirname(long_path) == "/a/b/c/d/e/f/g/h/i/j/k/l/m/n/o/p"

        it "handles paths with special characters in names":
            expect path.basename("/home/user/my-file_v2.txt") == "my-file_v2.txt"
            expect path.stem("/home/user/my-file_v2.txt") == "my-file_v2"

        it "combines operations correctly":
            val full_path = "/home/user/documents/report.pdf"
            val dir = path.dirname(full_path)
            val name = path.stem(full_path)
            val ext = path.extension(full_path)
            val reconstructed = path.join2(dir, name + "." + ext)
            expect reconstructed == full_path

    describe "normalization preserves meaning":
        it "normalized path has same basename":
            val original = "/home//user/./docs/../file.txt"
            val normalized = path.normalize(original)
            expect path.basename(normalized) == "file.txt"

        it "join and normalize produce clean paths":
            val joined = path.join(["/home", "user", "../admin", "config.txt"])
            val normalized = path.normalize(joined)
            expect normalized == "/home/admin/config.txt"

    describe "empty and degenerate cases":
        it "handles all empty components in join":
            expect path.join(["", "", ""]) == ""

        it "basename of dirname of single file":
            val result = path.dirname("file.txt")
            expect result == "."
            expect path.basename(result) == "."

describe "std.path - Real-World Use Cases":

    it "extracts project name from current directory path":
        val cwd = "/home/user/projects/my-app"
        val project_name = path.basename(cwd)
        expect project_name == "my-app"

    it "constructs output file path":
        val source_dir = "/home/user/src"
        val filename = "main.spl"
        val output_path = path.join2(source_dir, filename)
        expect output_path == "/home/user/src/main.spl"

    it "changes file extension":
        val source = "/home/user/file.spl"
        val dir = path.dirname(source)
        val name = path.stem(source)
        val compiled = path.join2(dir, name + ".smf")
        expect compiled == "/home/user/file.smf"

    it "resolves relative path from working directory":
        val cwd = "/home/user/projects/app"
        val relative = "../lib/utils.spl"
        val absolute = path.normalize(path.join2(cwd, relative))
        expect absolute == "/home/user/projects/lib/utils.spl"

    it "validates file type by extension":
        val filename = "source.spl"
        expect path.has_extension(filename, "spl")
        expect not path.has_extension(filename, "txt")

    it "builds path from components":
        val home = "/home"
        val user = "alice"
        val dir = "documents"
        val file = "report.pdf"
        val full_path = path.join([home, user, dir, file])
        expect full_path == "/home/alice/documents/report.pdf"
