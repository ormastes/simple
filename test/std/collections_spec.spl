# @Feature 707.1: Collections library
# @Description: Test core collection types and operations

# NOTE: describe, it, expect are built-in - no imports needed
use std.set (Set)

describe "List operations":
    it "creates empty list":
        val empty: [i64] = []
        expect empty.len() == 0
        expect empty.is_empty()

    it "creates list with elements":
        val nums = [1, 2, 3, 4, 5]
        expect nums.len() == 5
        expect not nums.is_empty()

    it "accesses elements by index":
        val nums = [10, 20, 30]
        expect nums[0] == 10
        expect nums[1] == 20
        expect nums[2] == 30

    it "uses negative indexing":
        val nums = [10, 20, 30, 40]
        expect nums[-1] == 40  # Last element
        expect nums[-2] == 30  # Second to last

    it "slices lists":
        # Slicing syntax verified working (Phase 5 - TODO âœ…)
        val nums = [0, 1, 2, 3, 4, 5]
        val slice = nums[1:4]  # Elements 1, 2, 3
        expect(slice.len()).to_equal(3)
        expect(slice[0]).to_equal(1)
        expect(slice[1]).to_equal(2)

    it "appends elements":
        var nums = [1, 2, 3]
        nums.push(4)
        expect nums.len() == 4
        expect nums[-1] == 4

    it "maps over elements":
        val nums = [1, 2, 3]
        val doubled = nums.map(\x: x * 2)
        expect doubled == [2, 4, 6]

    it "filters elements":
        val nums = [1, 2, 3, 4, 5, 6]
        val evens = nums.filter(\x: x % 2 == 0)
        expect evens == [2, 4, 6]

    it "reduces elements":
        val nums = [1, 2, 3, 4]
        val sum = nums.reduce(0, \acc, x: acc + x)
        expect sum == 10

describe "Dict operations":
    it "creates empty dict":
        val empty: {text: i64} = {}
        expect empty.len() == 0
        expect empty.is_empty()

    it "creates dict with entries":
        val ages = {"Alice": 30, "Bob": 25}
        expect ages.len() == 2

    it "accesses values by key":
        val ages = {"Alice": 30, "Bob": 25}
        expect ages["Alice"] == 30
        expect ages["Bob"] == 25

    it "checks key existence":
        val ages = {"Alice": 30}
        expect ages.contains_key("Alice")
        expect not ages.contains_key("Bob")

    it "gets keys":
        val ages = {"Alice": 30, "Bob": 25}
        val keys = ages.keys()
        expect keys.len() == 2
        expect keys.contains("Alice")

    it "gets values":
        val ages = {"Alice": 30, "Bob": 25}
        val values = ages.values()
        expect values.len() == 2

    it "inserts new entries":
        var ages = {"Alice": 30}
        ages["Bob"] = 25
        expect ages.len() == 2
        expect ages["Bob"] == 25

    it "updates existing entries":
        var ages = {"Alice": 30}
        ages["Alice"] = 31
        expect ages["Alice"] == 31

describe "Set operations":
    # NOTE: Set tests require Hash trait method resolution
    # The following tests fail in interpreter mode but work in compiled mode
    # because the interpreter doesn't support trait method resolution (i64.hash())

    it "creates empty set":
        val empty = Set.new()
        expect empty.len() == 0

    it "creates set with elements":
        val nums = Set.from([1, 2, 3, 2, 1])  # Duplicates removed
        expect nums.len() == 3

    it "adds elements":
        var nums = Set.new()
        nums.insert(1)
        nums.insert(2)
        nums.insert(1)  # Duplicate, shouldn't increase size
        expect nums.len() == 2

    it "checks membership":
        val nums = Set.from([1, 2, 3])
        expect nums.contains(2)
        expect not nums.contains(5)

    it "computes union":
        val a = Set.from([1, 2, 3])
        val b = Set.from([3, 4, 5])
        val union_set = a.union(b)
        expect union_set.len() == 5

    it "computes intersection":
        val a = Set.from([1, 2, 3])
        val b = Set.from([2, 3, 4])
        val intersection_set = a.intersection(b)
        expect intersection_set.len() == 2

    it "computes difference":
        val a = Set.from([1, 2, 3])
        val b = Set.from([2, 3])
        val diff = a.difference(b)
        expect diff.len() == 1
        expect diff.contains(1)

describe "String operations":
    it "concatenates strings":
        val s1 = "Hello"
        val s2 = "World"
        val combined = s1 + " " + s2
        expect combined == "Hello World"

    it "gets string length":
        val s = "hello"
        expect s.len() == 5

    it "checks string emptiness":
        val empty = ""
        val non_empty = "text"
        expect empty.is_empty()
        expect not non_empty.is_empty()

    it "splits strings":
        val s = "a,b,c"
        val parts = s.split(",")
        expect parts.len() == 3
        expect parts[0] == "a"

    it "joins strings":
        val parts = ["a", "b", "c"]
        val joined = parts.join(",")
        expect joined == "a,b,c"

    it "trims whitespace":
        val s = "  hello  "
        expect s.trim() == "hello"

    it "converts case":
        val s = "Hello"
        expect s.upper() == "HELLO"
        expect s.lower() == "hello"

    it "checks prefixes and suffixes":
        val s = "hello.txt"
        expect s.starts_with("hello")
        expect s.ends_with(".txt")

    it "finds substrings":
        val s = "hello world"
        val pos = s.index_of("world")
        match pos:
            case Some(idx):
                expect idx == 6
            case None:
                expect false
