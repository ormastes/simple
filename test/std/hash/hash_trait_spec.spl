# Hash Trait - Comprehensive SSpec Tests
# Verifies hash function correctness and distribution

use std.hash.*
use sspec.*

describe "Hash trait":
    describe "FNV-1a for strings":
        it "produces consistent hashes for same string":
            val s = "hello"
            assert s.hash() == s.hash()

        it "produces different hashes for different strings":
            val h1 = "hello".hash()
            val h2 = "world".hash()
            assert h1 != h2

        it "handles empty string":
            val h = "".hash()
            assert h == FNV_OFFSET  # Empty string hash = offset

        it "handles unicode strings":
            val h1 = "hello".hash()
            val h2 = "hÃ©llo".hash()
            assert h1 != h2  # Different unicode = different hash

        it "produces good distribution":
            # Generate 1000 strings, check hash distribution
            var hashes: [i64] = []
            for i in 0..1000:
                val h = "string_{i}".hash()
                hashes = hashes.push(h)

            # Count unique hashes (should be close to 1000)
            var unique_set = Set.new()
            for h in hashes:
                unique_set.insert(h)

            # At least 99% unique (allow 1% collisions)
            assert unique_set.len() >= 990

        it "handles long strings efficiently":
            val long_str = "x" * 10000
            val start = time.now()
            val h = long_str.hash()
            val elapsed = time.now() - start

            # Should hash 10k chars in < 1ms
            assert elapsed < 1.ms
            assert h != 0

    describe "Integer hashing":
        it "hashes i32 consistently":
            val x: i32 = 42
            assert x.hash() == x.hash()

        it "different integers produce different hashes":
            val h1 = (42 as i32).hash()
            val h2 = (43 as i32).hash()
            assert h1 != h2

        it "distributes integers well":
            var hashes = Set.new()
            for i in 0..1000:
                hashes.insert((i as i32).hash())

            # Should have 1000 unique hashes
            assert hashes.len() == 1000

        it "handles i64 with MurmurHash3 finalizer":
            val x: i64 = 123456789
            val h = x.hash()

            # Hash should be well-distributed (not just x itself)
            assert h != x
            assert h != 0

        it "handles edge cases":
            assert (0 as i32).hash() != 0
            assert (0 as i64).hash() != 0
            assert (-1 as i32).hash() != (-1 as i64).hash()

    describe "Boolean hashing":
        it "true hashes to 1":
            assert true.hash() == 1

        it "false hashes to 0":
            assert false.hash() == 0

        it "true and false produce different hashes":
            assert true.hash() != false.hash()

    describe "Option hashing":
        it "None hashes to 0":
            val opt: i32? = None
            assert opt.hash() == 0

        it "Some combines with FNV_PRIME":
            val opt = Some(42)
            val expected = 42.hash() * FNV_PRIME
            assert opt.hash() == expected

        it "Some(x) and x produce different hashes":
            val x = 42
            assert Some(x).hash() != x.hash()

    describe "Array hashing":
        it "empty array hashes to FNV_OFFSET":
            val arr: [i32] = []
            assert arr.hash() == FNV_OFFSET

        it "combines element hashes with FNV-1a":
            val arr = [1, 2, 3]
            var h = FNV_OFFSET
            h = h xor 1.hash()
            h = h * FNV_PRIME
            h = h xor 2.hash()
            h = h * FNV_PRIME
            h = h xor 3.hash()
            h = h * FNV_PRIME
            assert arr.hash() == h

        it "different arrays produce different hashes":
            assert [1, 2, 3].hash() != [1, 2, 4].hash()
            assert [1, 2].hash() != [1, 2, 3].hash()

        it "order matters":
            assert [1, 2, 3].hash() != [3, 2, 1].hash()

    describe "Tuple hashing":
        it "combines tuple elements":
            val t = (42, "hello")
            var h = FNV_OFFSET
            h = h xor 42.hash()
            h = h * FNV_PRIME
            h = h xor "hello".hash()
            h = h * FNV_PRIME
            assert t.hash() == h

        it "different tuples produce different hashes":
            assert (1, 2).hash() != (1, 3).hash()
            assert (1, "a").hash() != (2, "a").hash()

    describe "Hash avalanche property":
        it "single bit change causes hash change":
            # Flip one bit in input, entire hash should change
            val s1 = "test"
            val s2 = "tesa"  # Last char differs by 1 bit
            val h1 = s1.hash()
            val h2 = s2.hash()

            # Count differing bits
            val xor = h1 xor h2
            var bit_count = 0
            var n = xor
            while n != 0:
                n = n & (n - 1)
                bit_count = bit_count + 1

            # At least 30% of bits should differ (good avalanche)
            assert bit_count >= 19  # 30% of 64 bits

    describe "Hash collision resistance":
        it "no obvious collisions in common strings":
            val common = [
                "the", "be", "to", "of", "and", "a", "in", "that",
                "have", "I", "it", "for", "not", "on", "with", "he",
                "as", "you", "do", "at", "this", "but", "his", "by"
            ]

            var hashes = Set.new()
            for word in common:
                hashes.insert(word.hash())

            # All should be unique
            assert hashes.len() == common.len()

        it "no collisions in sequential integers":
            var hashes = Set.new()
            for i in 0..10000:
                hashes.insert(i.hash())

            assert hashes.len() == 10000

    describe "Performance characteristics":
        it "hashes large text efficiently":
            val large = "x" * 100000
            val start = time.now()

            for _ in 0..100:
                val _ = large.hash()

            val elapsed = time.now() - start

            # 100 iterations of 100k chars should take < 100ms
            assert elapsed < 100.ms

        it "hashes many small strings efficiently":
            val start = time.now()

            for i in 0..10000:
                val _ = "string_{i}".hash()

            val elapsed = time.now() - start

            # 10k small string hashes should take < 50ms
            assert elapsed < 50.ms
