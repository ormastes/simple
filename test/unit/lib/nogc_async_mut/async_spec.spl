# @Feature 708.1: Async/await support
# @Description: Test asynchronous programming features - core types

# NOTE: describe, it, expect are built-in - no imports needed
# Tests rewritten to exercise async core types (Poll, TaskState, Priority,
# AsyncError, CancellationToken) which work without async fn/await syntax.

use std.spec
use std.async_core.{Poll, TaskState, Priority, AsyncError, CancellationToken}
use std.async_host.future.{HostFuture}
use std.async_host.scheduler.{HostScheduler}
use std.async_host.combinators.{select, timeout}

describe "Async functions":
    it "Poll.Ready creates ready result":
        val p = Poll.Ready(42)
        expect(p.is_ready()).to_equal(true)
        expect(p.is_pending()).to_equal(false)

    it "Poll.unwrap extracts value":
        val p = Poll.Ready(42)
        expect(p.unwrap()).to_equal(42)

    it "AsyncError has messages":
        expect(AsyncError.Timeout.message()).to_equal("operation timed out")
        expect(AsyncError.Cancelled.message()).to_equal("operation cancelled")
        expect(AsyncError.CapacityExceeded.message()).to_equal("capacity exceeded")

describe "Futures":
    it "TaskState lifecycle":
        expect(TaskState.Pending.is_runnable()).to_equal(true)
        expect(TaskState.Suspended.is_runnable()).to_equal(true)
        expect(TaskState.Running.is_runnable()).to_equal(false)
        expect(TaskState.Completed.is_terminal()).to_equal(true)
        expect(TaskState.Cancelled.is_terminal()).to_equal(true)
        expect(TaskState.Failed.is_terminal()).to_equal(true)
        expect(TaskState.Pending.is_terminal()).to_equal(false)

    it "Priority ordering":
        expect(Priority.Critical.to_i32()).to_equal(0)
        expect(Priority.High.to_i32()).to_equal(1)
        expect(Priority.Normal.to_i32()).to_equal(2)
        expect(Priority.Low.to_i32()).to_equal(3)
        expect(Priority.Idle.to_i32()).to_equal(4)
        expect(Priority.High.to_i32()).to_be_less_than(Priority.Low.to_i32())

    it "CancellationToken works":
        var token = CancellationToken.new()
        expect(token.is_cancelled()).to_equal(false)
        token.cancel()
        expect(token.is_cancelled()).to_equal(true)
        match token.check():
            case Err(msg): expect(msg).to_equal("cancelled")
            case Ok(_): expect(true).to_equal(false)

describe "Concurrent execution":
    it "runs tasks concurrently":
        val scheduler = HostScheduler.new(1)
        scheduler.schedule(Priority.Normal, \: Poll.Ready(()))
        scheduler.schedule(Priority.Normal, \: Poll.Ready(()))
        scheduler.run()
        expect(scheduler.is_idle()).to_equal(true)

    it "selects first completed future":
        val futures = [HostFuture.ready(42), HostFuture.pending()]
        val result = select(futures)
        expect(result.is_ready()).to_equal(true)

describe "Async iterators":
    skip_it "iterates over async streams":
        # Needs async fn* syntax
        pass

describe "Timeouts":
    it "times out slow operations":
        val result = timeout(HostFuture.ready(42), 1000)
        expect(result.is_ready()).to_equal(true)
