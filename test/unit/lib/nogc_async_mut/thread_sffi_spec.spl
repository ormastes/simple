# Thread SFFI Tests
#
# Tests for cross-platform threading primitives.

use std.thread_sffi.*

describe "ThreadHandle":
    it "creates invalid handle":
        val handle = ThreadHandle.invalid()
        expect(handle.is_valid()).to_equal(false)

    it "invalid handle join returns false":
        val handle = ThreadHandle.invalid()
        expect(handle.join()).to_equal(false)

    it "invalid handle detach returns false":
        val handle = ThreadHandle.invalid()
        expect(handle.detach()).to_equal(false)

describe "thread_current_id":
    it "returns non-zero thread ID":
        val id = thread_current_id()
        expect(id > 0).to_equal(true)

    it "returns same ID when called twice":
        val id1 = thread_current_id()
        val id2 = thread_current_id()
        expect(id1).to_equal(id2)

describe "thread_sleep":
    it "sleeps for positive duration":
        val start = 0  # Would use time in real test
        thread_sleep(10)
        val end_marker = 1
        expect(end_marker).to_equal(1)

    it "ignores zero sleep":
        thread_sleep(0)
        expect(true).to_equal(true)

    it "ignores negative sleep":
        thread_sleep(-10)
        expect(true).to_equal(true)

describe "thread_yield":
    it "yields without error":
        thread_yield()
        expect(true).to_equal(true)

    it "can yield multiple times":
        thread_yield()
        thread_yield()
        thread_yield()
        expect(true).to_equal(true)

describe "thread_cpu_count":
    it "returns positive CPU count":
        val count = thread_cpu_count()
        expect(count > 0).to_equal(true)

    it "returns reasonable CPU count":
        val count = thread_cpu_count()
        expect(count >= 1).to_equal(true)
        expect(count <= 1024).to_equal(true)

    it "returns consistent CPU count":
        val count1 = thread_cpu_count()
        val count2 = thread_cpu_count()
        expect(count1).to_equal(count2)

describe "MutexHandle":
    it "creates valid mutex":
        val mutex = mutex_create()
        expect(mutex.is_valid()).to_equal(true)
        mutex.destroy()

    it "locks and unlocks mutex":
        val mutex = mutex_create()
        expect(mutex.lock()).to_equal(true)
        expect(mutex.unlock()).to_equal(true)
        mutex.destroy()

    it "try_lock succeeds when unlocked":
        val mutex = mutex_create()
        expect(mutex.try_lock()).to_equal(true)
        mutex.unlock()
        mutex.destroy()

    it "lock/unlock multiple times":
        val mutex = mutex_create()
        expect(mutex.lock()).to_equal(true)
        expect(mutex.unlock()).to_equal(true)
        expect(mutex.lock()).to_equal(true)
        expect(mutex.unlock()).to_equal(true)
        mutex.destroy()

    it "destroy cleans up mutex":
        val mutex = mutex_create()
        mutex.lock()
        mutex.unlock()
        mutex.destroy()
        expect(true).to_equal(true)

    it "invalid mutex lock returns false":
        val mutex = MutexHandle(handle: 0)
        expect(mutex.lock()).to_equal(false)

    it "invalid mutex unlock returns false":
        val mutex = MutexHandle(handle: 0)
        expect(mutex.unlock()).to_equal(false)

    it "invalid mutex try_lock returns false":
        val mutex = MutexHandle(handle: 0)
        expect(mutex.try_lock()).to_equal(false)

describe "CondVarHandle":
    it "creates valid condvar":
        val cv = condvar_create()
        expect(cv.is_valid()).to_equal(true)
        cv.destroy()

    it "signal succeeds":
        val cv = condvar_create()
        expect(cv.signal()).to_equal(true)
        cv.destroy()

    it "broadcast succeeds":
        val cv = condvar_create()
        expect(cv.broadcast()).to_equal(true)
        cv.destroy()

    it "multiple signals succeed":
        val cv = condvar_create()
        expect(cv.signal()).to_equal(true)
        expect(cv.signal()).to_equal(true)
        expect(cv.signal()).to_equal(true)
        cv.destroy()

    it "destroy cleans up condvar":
        val cv = condvar_create()
        cv.signal()
        cv.broadcast()
        cv.destroy()
        expect(true).to_equal(true)

    it "invalid condvar signal returns false":
        val cv = CondVarHandle(handle: 0)
        expect(cv.signal()).to_equal(false)

    it "invalid condvar broadcast returns false":
        val cv = CondVarHandle(handle: 0)
        expect(cv.broadcast()).to_equal(false)

    it "invalid condvar wait returns false":
        val cv = CondVarHandle(handle: 0)
        val mutex = mutex_create()
        expect(cv.wait(mutex)).to_equal(false)
        mutex.destroy()

    it "wait with invalid mutex returns false":
        val cv = condvar_create()
        val mutex = MutexHandle(handle: 0)
        expect(cv.wait(mutex)).to_equal(false)
        cv.destroy()

describe "Mutex stress test":
    it "creates and destroys 100 mutexes":
        var count = 0
        for i in 0..100:
            val mutex = mutex_create()
            if mutex.is_valid():
                count = count + 1
            mutex.destroy()
        expect(count).to_equal(100)

    it "locks/unlocks 1000 times":
        val mutex = mutex_create()
        var count = 0
        for i in 0..1000:
            mutex.lock()
            count = count + 1
            mutex.unlock()
        expect(count).to_equal(1000)
        mutex.destroy()

describe "CondVar stress test":
    it "creates and destroys 100 condvars":
        var count = 0
        for i in 0..100:
            val cv = condvar_create()
            if cv.is_valid():
                count = count + 1
            cv.destroy()
        expect(count).to_equal(100)

    it "signals 1000 times":
        val cv = condvar_create()
        var count = 0
        for i in 0..1000:
            if cv.signal():
                count = count + 1
        expect(count).to_equal(1000)
        cv.destroy()

describe "Mixed operations":
    it "mutex and condvar together":
        val mutex = mutex_create()
        val cv = condvar_create()

        mutex.lock()
        cv.signal()
        mutex.unlock()

        cv.destroy()
        mutex.destroy()
        expect(true).to_equal(true)

    it "multiple mutexes independent":
        val m1 = mutex_create()
        val m2 = mutex_create()

        m1.lock()
        m2.lock()

        m1.unlock()
        m2.unlock()

        m1.destroy()
        m2.destroy()
        expect(true).to_equal(true)

    it "multiple condvars independent":
        val cv1 = condvar_create()
        val cv2 = condvar_create()

        cv1.signal()
        cv2.signal()

        cv1.destroy()
        cv2.destroy()
        expect(true).to_equal(true)
