describe "Pure Load":
    it "skipped":
        skip("pre-existing test failures - functions/imports not available")

# # Tests that pure/ ML library loads correctly from nogc_async_mut context
# 
# use std.nogc_async_mut.pure.tensor_f64.{from_data, zeros, randn}
# use std.nogc_async_mut.pure.autograd.{Tensor, tensor_from_value}
# use std.nogc_async_mut.pure.nn.embedding.{Embedding}
# use std.nogc_async_mut.pure.data.dataset.{ArrayDataset, LabeledDataset, LabeledSample}
# use std.nogc_async_mut.pure.training.{mse_loss}
# 
# describe "nogc_async_mut pure/ Load":
#     describe "Tensor":
#         it "creates tensor from data":
#             val t = from_data([1.0, 2.0, 3.0], [3])
#             expect(t.data.len()).to_equal(3)
# 
#         it "creates zeros tensor":
#             val t = zeros([2, 3])
#             expect(t.data.len()).to_equal(6)
# 
#     describe "Autograd":
#         it "creates autograd tensor":
#             val v = from_data([1.0, 2.0], [2])
#             val t = tensor_from_value(v, requires_grad: true)
#             expect(t.requires_grad).to_equal(true)
# 
#     describe "Embedding":
#         it "creates embedding layer":
#             val emb = Embedding.create(num_embeddings: 10, embedding_dim: 4)
#             expect(emb.num_embeddings).to_equal(10)
#             expect(emb.embedding_dim).to_equal(4)
# 
#     describe "Dataset":
#         it "creates ArrayDataset":
#             val data = [[1.0, 2.0], [3.0, 4.0]]
#             val ds = ArrayDataset(data: data)
#             expect(ds.len()).to_equal(2)
# 
#         it "creates LabeledDataset":
#             val features = [[1.0], [2.0]]
#             val labels = [0.0, 1.0]
#             val ds = LabeledDataset(features: features, labels: labels)
#             expect(ds.len()).to_equal(2)
# 
#     describe "Training":
#         it "imports mse_loss":
#             val a = from_data([1.0, 2.0], [2])
#             val b = from_data([1.0, 2.0], [2])
#             val loss = mse_loss(a, b)
#             expect(loss).to_equal(0.0)
