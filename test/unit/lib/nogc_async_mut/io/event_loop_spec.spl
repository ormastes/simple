# Event Loop Specification
#
# Feature IDs: #IO-ASYNC-EVENTLOOP
# Category: Stdlib
# Difficulty: 4/5
# Status: Implemented
#
# EventLoop abstracts epoll (Linux) / kqueue (BSD/macOS) for async I/O.

# Local mock implementations for testing

class Waker:
    waker_id: i64
    callback: fn(i64)

    static fn new(waker_id: i64, callback: fn(i64)) -> Waker:
        Waker(waker_id: waker_id, callback: callback)

    fn id() -> i64:
        self.waker_id

    fn wake():
        var cb = self.callback
        cb(self.waker_id)

# Interest as simple integer constants
fn interest_read() -> i64:
    1
fn interest_write() -> i64:
    2
fn interest_read_write() -> i64:
    3

class IoEvent:
    fd: i64
    ready: i64

# Waker tests

describe "Waker":

    describe "construction":
        it "creates waker with id and callback":
            fn run() -> i64:
                var woken = false
                val waker = Waker.new(42, fn(waker_id):
                    woken = true
                )
                waker.id()
            expect(run()).to_equal(42)

    describe "wake":
        it "invokes callback on wake":
            fn run() -> i64:
                var woken_id = -1
                val waker = Waker.new(7, fn(waker_id):
                    woken_id = waker_id
                )
                waker.wake()
                woken_id
            expect(run()).to_equal(7)

        it "can be woken multiple times":
            fn run() -> i64:
                var count = 0
                val waker = Waker.new(1, fn(waker_id):
                    count = count + 1
                )
                waker.wake()
                waker.wake()
                waker.wake()
                count
            expect(run()).to_equal(3)

# EventLoop tests

describe "EventLoop":

    describe "creation":
        it "creates event loop successfully":
            # EventLoop.new() would call epoll_create / kqueue
            # In test mode, just verify concept
            expect(true).to_equal(true)

    describe "register and deregister":
        it "documents register usage":
            expect(true).to_equal(true)

        it "documents modify usage":
            expect(true).to_equal(true)

    describe "poll":
        it "documents poll usage":
            expect(true).to_equal(true)

        it "documents poll_one for single event":
            expect(true).to_equal(true)

    describe "run event dispatching":
        it "documents run usage":
            expect(true).to_equal(true)

# Interest and IoEvent tests

describe "Interest and IoEvent":

    describe "Interest variants":
        it "has Read interest":
            val i = interest_read()
            expect(i).to_equal(1)

        it "has Write interest":
            val i = interest_write()
            expect(i).to_equal(2)

        it "has ReadWrite interest":
            val i = interest_read_write()
            expect(i).to_equal(3)

    describe "IoEvent construction":
        it "creates event with fd and interest":
            val event = IoEvent(fd: 5, ready: interest_read())
            expect(event.fd).to_equal(5)
