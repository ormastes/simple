describe "Tensor Advanced":
    it "skipped":
        skip("pre-existing test failures - functions/imports not available")

# # Tests for Advanced Tensor Operations
# 
# use std.pure.tensor_f64 (TensorF64, from_data, zeros, ones)
# use std.pure.tensor_f64_advanced (stack, concat, split, reshape, permute)
# 
# describe "Advanced Tensor Operations":
#     describe "stack":
#         it "stacks 1D tensors along axis 0":
#             val t1 = from_data([1.0, 2.0], [2])
#             val t2 = from_data([3.0, 4.0], [2])
#             val t3 = from_data([5.0, 6.0], [2])
#             val result = stack([t1, t2, t3], 0)
# 
#             expect(result.shape).to_equal([3, 2])
#             expect(result.get([0, 0])).to_equal(1.0)
#             expect(result.get([0, 1])).to_equal(2.0)
#             expect(result.get([1, 0])).to_equal(3.0)
#             expect(result.get([1, 1])).to_equal(4.0)
#             expect(result.get([2, 0])).to_equal(5.0)
#             expect(result.get([2, 1])).to_equal(6.0)
# 
#         it "stacks 1D tensors along axis 1":
#             val t1 = from_data([1.0, 2.0], [2])
#             val t2 = from_data([3.0, 4.0], [2])
#             val result = stack([t1, t2], 1)
# 
#             expect(result.shape).to_equal([2, 2])
#             expect(result.get([0, 0])).to_equal(1.0)
#             expect(result.get([0, 1])).to_equal(3.0)
#             expect(result.get([1, 0])).to_equal(2.0)
#             expect(result.get([1, 1])).to_equal(4.0)
# 
#         it "stacks 2D tensors along axis 0":
#             val t1 = from_data([1.0, 2.0, 3.0, 4.0], [2, 2])
#             val t2 = from_data([5.0, 6.0, 7.0, 8.0], [2, 2])
#             val result = stack([t1, t2], 0)
# 
#             expect(result.shape).to_equal([2, 2, 2])
#             expect(result.get([0, 0, 0])).to_equal(1.0)
#             expect(result.get([0, 1, 1])).to_equal(4.0)
#             expect(result.get([1, 0, 0])).to_equal(5.0)
#             expect(result.get([1, 1, 1])).to_equal(8.0)
# 
#         it "stacks 2D tensors along axis 1":
#             val t1 = from_data([1.0, 2.0, 3.0, 4.0], [2, 2])
#             val t2 = from_data([5.0, 6.0, 7.0, 8.0], [2, 2])
#             val result = stack([t1, t2], 1)
# 
#             expect(result.shape).to_equal([2, 2, 2])
#             expect(result.get([0, 0, 0])).to_equal(1.0)
#             expect(result.get([0, 0, 1])).to_equal(2.0)
#             expect(result.get([0, 1, 0])).to_equal(5.0)
#             expect(result.get([0, 1, 1])).to_equal(6.0)
# 
#         it "handles empty tensor list":
#             val result = stack([], 0)
#             expect(result.shape).to_equal([0])
# 
#     describe "concat":
#         it "concatenates 1D tensors along axis 0":
#             val t1 = from_data([1.0, 2.0], [2])
#             val t2 = from_data([3.0, 4.0, 5.0], [3])
#             val t3 = from_data([6.0], [1])
#             val result = concat([t1, t2, t3], 0)
# 
#             expect(result.shape).to_equal([6])
#             expect(result.get([0])).to_equal(1.0)
#             expect(result.get([1])).to_equal(2.0)
#             expect(result.get([2])).to_equal(3.0)
#             expect(result.get([3])).to_equal(4.0)
#             expect(result.get([4])).to_equal(5.0)
#             expect(result.get([5])).to_equal(6.0)
# 
#         it "concatenates 2D tensors along axis 0":
#             val t1 = from_data([1.0, 2.0, 3.0, 4.0], [2, 2])
#             val t2 = from_data([5.0, 6.0, 7.0, 8.0, 9.0, 10.0], [3, 2])
#             val result = concat([t1, t2], 0)
# 
#             expect(result.shape).to_equal([5, 2])
#             expect(result.get([0, 0])).to_equal(1.0)
#             expect(result.get([1, 1])).to_equal(4.0)
#             expect(result.get([2, 0])).to_equal(5.0)
#             expect(result.get([4, 1])).to_equal(10.0)
# 
#         it "concatenates 2D tensors along axis 1":
#             val t1 = from_data([1.0, 2.0, 3.0, 4.0], [2, 2])
#             val t2 = from_data([5.0, 6.0, 7.0], [2, 1])
#             val t3 = from_data([8.0, 9.0], [2, 1])
#             val result = concat([t1, t2, t3], 1)
# 
#             expect(result.shape).to_equal([2, 4])
#             expect(result.get([0, 0])).to_equal(1.0)
#             expect(result.get([0, 1])).to_equal(2.0)
#             expect(result.get([0, 2])).to_equal(5.0)
#             expect(result.get([0, 3])).to_equal(8.0)
#             expect(result.get([1, 0])).to_equal(3.0)
#             expect(result.get([1, 1])).to_equal(4.0)
#             expect(result.get([1, 2])).to_equal(6.0)
#             expect(result.get([1, 3])).to_equal(9.0)
# 
#         it "handles empty tensor list":
#             val result = concat([], 0)
#             expect(result.shape).to_equal([0])
# 
#     describe "split":
#         it "splits 1D tensor into equal chunks":
#             val t = from_data([1.0, 2.0, 3.0, 4.0, 5.0, 6.0], [6])
#             val chunks = split(t, [2, 2, 2], 0)
# 
#             expect(chunks.len()).to_equal(3)
#             expect(chunks[0].shape).to_equal([2])
#             expect(chunks[0].get([0])).to_equal(1.0)
#             expect(chunks[0].get([1])).to_equal(2.0)
#             expect(chunks[1].get([0])).to_equal(3.0)
#             expect(chunks[2].get([1])).to_equal(6.0)
# 
#         it "splits 1D tensor into unequal chunks":
#             val t = from_data([1.0, 2.0, 3.0, 4.0, 5.0], [5])
#             val chunks = split(t, [1, 3, 1], 0)
# 
#             expect(chunks.len()).to_equal(3)
#             expect(chunks[0].shape).to_equal([1])
#             expect(chunks[1].shape).to_equal([3])
#             expect(chunks[2].shape).to_equal([1])
#             expect(chunks[1].get([0])).to_equal(2.0)
#             expect(chunks[1].get([2])).to_equal(4.0)
# 
#         it "splits 2D tensor along axis 0":
#             val t = from_data([1.0, 2.0, 3.0, 4.0, 5.0, 6.0], [3, 2])
#             val chunks = split(t, [1, 2], 0)
# 
#             expect(chunks.len()).to_equal(2)
#             expect(chunks[0].shape).to_equal([1, 2])
#             expect(chunks[1].shape).to_equal([2, 2])
#             expect(chunks[0].get([0, 0])).to_equal(1.0)
#             expect(chunks[0].get([0, 1])).to_equal(2.0)
#             expect(chunks[1].get([0, 0])).to_equal(3.0)
#             expect(chunks[1].get([1, 1])).to_equal(6.0)
# 
#         it "splits 2D tensor along axis 1":
#             val t = from_data([1.0, 2.0, 3.0, 4.0, 5.0, 6.0], [2, 3])
#             val chunks = split(t, [1, 2], 1)
# 
#             expect(chunks.len()).to_equal(2)
#             expect(chunks[0].shape).to_equal([2, 1])
#             expect(chunks[1].shape).to_equal([2, 2])
#             expect(chunks[0].get([0, 0])).to_equal(1.0)
#             expect(chunks[0].get([1, 0])).to_equal(4.0)
#             expect(chunks[1].get([0, 0])).to_equal(2.0)
#             expect(chunks[1].get([1, 1])).to_equal(6.0)
# 
#     describe "reshape":
#         it "reshapes 1D to 2D":
#             val t = from_data([1.0, 2.0, 3.0, 4.0, 5.0, 6.0], [6])
#             val result = reshape(t, [2, 3])
# 
#             expect(result.shape).to_equal([2, 3])
#             expect(result.get([0, 0])).to_equal(1.0)
#             expect(result.get([0, 2])).to_equal(3.0)
#             expect(result.get([1, 0])).to_equal(4.0)
#             expect(result.get([1, 2])).to_equal(6.0)
# 
#         it "reshapes 2D to 1D":
#             val t = from_data([1.0, 2.0, 3.0, 4.0], [2, 2])
#             val result = reshape(t, [4])
# 
#             expect(result.shape).to_equal([4])
#             expect(result.get([0])).to_equal(1.0)
#             expect(result.get([1])).to_equal(2.0)
#             expect(result.get([2])).to_equal(3.0)
#             expect(result.get([3])).to_equal(4.0)
# 
#         it "infers dimension with -1":
#             val t = from_data([1.0, 2.0, 3.0, 4.0, 5.0, 6.0], [6])
#             val result = reshape(t, [2, -1])
# 
#             expect(result.shape).to_equal([2, 3])
#             expect(result.get([0, 0])).to_equal(1.0)
#             expect(result.get([1, 2])).to_equal(6.0)
# 
#         it "infers first dimension with -1":
#             val t = from_data([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0], [8])
#             val result = reshape(t, [-1, 4])
# 
#             expect(result.shape).to_equal([2, 4])
#             expect(result.get([0, 3])).to_equal(4.0)
#             expect(result.get([1, 3])).to_equal(8.0)
# 
#         it "reshapes 2D to 3D":
#             val t = from_data([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0], [2, 4])
#             val result = reshape(t, [2, 2, 2])
# 
#             expect(result.shape).to_equal([2, 2, 2])
#             expect(result.get([0, 0, 0])).to_equal(1.0)
#             expect(result.get([0, 1, 1])).to_equal(4.0)
#             expect(result.get([1, 0, 0])).to_equal(5.0)
#             expect(result.get([1, 1, 1])).to_equal(8.0)
# 
#         it "reshapes 3D to 2D with -1":
#             val t = from_data([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0], [2, 2, 2])
#             val result = reshape(t, [4, -1])
# 
#             expect(result.shape).to_equal([4, 2])
# 
#     describe "permute":
#         it "transposes 2D tensor":
#             val t = from_data([1.0, 2.0, 3.0, 4.0, 5.0, 6.0], [2, 3])
#             val result = permute(t, [1, 0])
# 
#             expect(result.shape).to_equal([3, 2])
#             expect(result.get([0, 0])).to_equal(1.0)
#             expect(result.get([0, 1])).to_equal(4.0)
#             expect(result.get([1, 0])).to_equal(2.0)
#             expect(result.get([1, 1])).to_equal(5.0)
#             expect(result.get([2, 0])).to_equal(3.0)
#             expect(result.get([2, 1])).to_equal(6.0)
# 
#         it "permutes 3D tensor (0,1,2 -> 2,0,1)":
#             val t = from_data([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0], [2, 2, 2])
#             val result = permute(t, [2, 0, 1])
# 
#             expect(result.shape).to_equal([2, 2, 2])
#             # Original [0,0,0]=1 -> New [0,0,0]=1
#             expect(result.get([0, 0, 0])).to_equal(1.0)
#             # Original [0,0,1]=2 -> New [1,0,0]=2
#             expect(result.get([1, 0, 0])).to_equal(2.0)
#             # Original [0,1,0]=3 -> New [0,0,1]=3
#             expect(result.get([0, 0, 1])).to_equal(3.0)
#             # Original [1,1,1]=8 -> New [1,1,1]=8
#             expect(result.get([1, 1, 1])).to_equal(8.0)
# 
#         it "permutes 3D tensor (0,1,2 -> 1,2,0)":
#             val t = from_data([1.0, 2.0, 3.0, 4.0, 5.0, 6.0], [1, 2, 3])
#             val result = permute(t, [1, 2, 0])
# 
#             expect(result.shape).to_equal([2, 3, 1])
#             expect(result.get([0, 0, 0])).to_equal(1.0)
#             expect(result.get([0, 1, 0])).to_equal(2.0)
#             expect(result.get([1, 2, 0])).to_equal(6.0)
# 
#         it "identity permutation":
#             val t = from_data([1.0, 2.0, 3.0, 4.0], [2, 2])
#             val result = permute(t, [0, 1])
# 
#             expect(result.shape).to_equal([2, 2])
#             expect(result.get([0, 0])).to_equal(1.0)
#             expect(result.get([0, 1])).to_equal(2.0)
#             expect(result.get([1, 0])).to_equal(3.0)
#             expect(result.get([1, 1])).to_equal(4.0)
# 
#     describe "Integration Tests":
#         it "combines reshape and permute":
#             val t = from_data([1.0, 2.0, 3.0, 4.0, 5.0, 6.0], [6])
#             val reshaped = reshape(t, [2, 3])
#             val transposed = permute(reshaped, [1, 0])
# 
#             expect(transposed.shape).to_equal([3, 2])
#             expect(transposed.get([0, 0])).to_equal(1.0)
#             expect(transposed.get([2, 1])).to_equal(6.0)
# 
#         it "splits then stacks":
#             val t = from_data([1.0, 2.0, 3.0, 4.0, 5.0, 6.0], [6])
#             val chunks = split(t, [2, 2, 2], 0)
#             val stacked = stack(chunks, 0)
# 
#             expect(stacked.shape).to_equal([3, 2])
#             expect(stacked.get([0, 0])).to_equal(1.0)
#             expect(stacked.get([2, 1])).to_equal(6.0)
# 
#         it "concat then split":
#             val t1 = from_data([1.0, 2.0], [2])
#             val t2 = from_data([3.0, 4.0], [2])
#             val concatenated = concat([t1, t2], 0)
#             val chunks = split(concatenated, [2, 2], 0)
# 
#             expect(chunks.len()).to_equal(2)
#             expect(chunks[0].get([0])).to_equal(1.0)
#             expect(chunks[1].get([1])).to_equal(4.0)
# 
#         it "reshape with permute for batch operations":
#             # Simulate batch dimension reordering
#             val t = from_data([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0], [2, 4])
#             val reshaped = reshape(t, [2, 2, 2])
#             val permuted = permute(reshaped, [1, 0, 2])
# 
#             expect(permuted.shape).to_equal([2, 2, 2])
