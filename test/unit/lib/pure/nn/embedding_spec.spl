# Tests for Pure Simple Embedding Layer

use std.pure.tensor (PureTensor, tensor_from_data, tensor_zeros)
use std.pure.nn (Embedding)

describe "Embedding Layer":
    describe "Layer Creation":
        it "creates embedding layer with correct shapes":
            val emb = Embedding.create(num_embeddings: 100, embedding_dim: 50)
            assert emb.num_embeddings == 100
            assert emb.embedding_dim == 50
            assert emb.weight.shape == [100, 50]
            assert emb.training == true

        it "creates embedding layer with different dimensions":
            val emb = Embedding.create(num_embeddings: 1000, embedding_dim: 128)
            assert emb.num_embeddings == 1000
            assert emb.embedding_dim == 128
            assert emb.weight.shape == [1000, 128]

        it "initializes weights with small random values":
            val emb = Embedding.create(num_embeddings: 10, embedding_dim: 5)

            # Check that weights are not all zeros
            var non_zero_count = 0
            for val in emb.weight.data:
                if val != 0.0:
                    non_zero_count = non_zero_count + 1

            # Most weights should be non-zero (randomized)
            assert non_zero_count > 0

            # Check that weights are small (scaled by 0.1)
            var all_small = true
            for val in emb.weight.data:
                if val > 1.0 or val < -1.0:
                    all_small = false

            assert all_small

    describe "Forward Pass - 1D Input":
        it "performs forward pass with 1D input":
            val emb = Embedding.create(num_embeddings: 10, embedding_dim: 5)

            # Create indices: [0, 2, 5]
            val indices = tensor_from_data([0.0, 2.0, 5.0], [3])
            val output = emb.forward(indices)

            # Output should be [3, 5] (batch_size=3, embedding_dim=5)
            assert output.shape == [3, 5]

        it "looks up correct embedding vectors":
            val emb = Embedding.create(num_embeddings: 10, embedding_dim: 3)

            # Manually set some weights for testing
            emb.weight.data[0] = 1.0   # Index 0, dim 0
            emb.weight.data[1] = 2.0   # Index 0, dim 1
            emb.weight.data[2] = 3.0   # Index 0, dim 2

            emb.weight.data[3] = 4.0   # Index 1, dim 0
            emb.weight.data[4] = 5.0   # Index 1, dim 1
            emb.weight.data[5] = 6.0   # Index 1, dim 2

            # Lookup index 0
            val indices = tensor_from_data([0.0], [1])
            val output = emb.forward(indices)

            # Should get [1.0, 2.0, 3.0]
            assert output.data[0] == 1.0
            assert output.data[1] == 2.0
            assert output.data[2] == 3.0

        it "handles batch of indices":
            val emb = Embedding.create(num_embeddings: 10, embedding_dim: 4)

            # Set weights for indices 0 and 1
            var i = 0
            while i < 4:
                emb.weight.data[i] = i + 1.0          # Index 0: [1,2,3,4]
                emb.weight.data[4 + i] = (i + 1.0) * 10.0  # Index 1: [10,20,30,40]
                i = i + 1

            # Lookup [0, 1]
            val indices = tensor_from_data([0.0, 1.0], [2])
            val output = emb.forward(indices)

            # Output shape: [2, 4]
            assert output.shape == [2, 4]

            # First row: [1, 2, 3, 4]
            assert output.data[0] == 1.0
            assert output.data[1] == 2.0
            assert output.data[2] == 3.0
            assert output.data[3] == 4.0

            # Second row: [10, 20, 30, 40]
            assert output.data[4] == 10.0
            assert output.data[5] == 20.0
            assert output.data[6] == 30.0
            assert output.data[7] == 40.0

        it "handles out of bounds indices with zeros":
            val emb = Embedding.create(num_embeddings: 10, embedding_dim: 3)

            # Index 15 is out of bounds (>= 10)
            val indices = tensor_from_data([15.0], [1])
            val output = emb.forward(indices)

            # Should return zeros
            assert output.data[0] == 0.0
            assert output.data[1] == 0.0
            assert output.data[2] == 0.0

        it "handles negative indices with zeros":
            val emb = Embedding.create(num_embeddings: 10, embedding_dim: 3)

            # Negative index
            val indices = tensor_from_data([-1.0], [1])
            val output = emb.forward(indices)

            # Should return zeros
            assert output.data[0] == 0.0
            assert output.data[1] == 0.0
            assert output.data[2] == 0.0

    describe "Forward Pass - 2D Input":
        it "performs forward pass with 2D input":
            val emb = Embedding.create(num_embeddings: 10, embedding_dim: 5)

            # Create indices: [[0, 2], [5, 7]]
            # Shape: [2, 2] (batch_size=2, seq_len=2)
            val indices = tensor_from_data([0.0, 2.0, 5.0, 7.0], [2, 2])
            val output = emb.forward(indices)

            # Output should be [2, 2, 5] (batch_size=2, seq_len=2, embedding_dim=5)
            assert output.shape == [2, 2, 5]

        it "looks up correct vectors in 2D input":
            val emb = Embedding.create(num_embeddings: 10, embedding_dim: 2)

            # Set weights for indices 0 and 1
            emb.weight.data[0] = 1.0   # Index 0: [1, 2]
            emb.weight.data[1] = 2.0

            emb.weight.data[2] = 3.0   # Index 1: [3, 4]
            emb.weight.data[3] = 4.0

            # Lookup [[0, 1]]
            # Shape: [1, 2] (batch_size=1, seq_len=2)
            val indices = tensor_from_data([0.0, 1.0], [1, 2])
            val output = emb.forward(indices)

            # Output shape: [1, 2, 2]
            assert output.shape == [1, 2, 2]

            # First position: [1, 2]
            assert output.data[0] == 1.0
            assert output.data[1] == 2.0

            # Second position: [3, 4]
            assert output.data[2] == 3.0
            assert output.data[3] == 4.0

        it "handles batch of sequences":
            val emb = Embedding.create(num_embeddings: 5, embedding_dim: 3)

            # Set weights for testing
            var idx = 0
            while idx < 5:
                var dim = 0
                while dim < 3:
                    emb.weight.data[idx * 3 + dim] = idx * 10.0 + dim
                    dim = dim + 1
                idx = idx + 1

            # Lookup [[0, 1], [2, 3]]
            # Shape: [2, 2] (batch_size=2, seq_len=2)
            val indices = tensor_from_data([0.0, 1.0, 2.0, 3.0], [2, 2])
            val output = emb.forward(indices)

            # Output shape: [2, 2, 3]
            assert output.shape == [2, 2, 3]

            # Batch 0, Seq 0: Index 0 -> [0, 1, 2]
            assert output.data[0] == 0.0
            assert output.data[1] == 1.0
            assert output.data[2] == 2.0

            # Batch 0, Seq 1: Index 1 -> [10, 11, 12]
            assert output.data[3] == 10.0
            assert output.data[4] == 11.0
            assert output.data[5] == 12.0

            # Batch 1, Seq 0: Index 2 -> [20, 21, 22]
            assert output.data[6] == 20.0
            assert output.data[7] == 21.0
            assert output.data[8] == 22.0

            # Batch 1, Seq 1: Index 3 -> [30, 31, 32]
            assert output.data[9] == 30.0
            assert output.data[10] == 31.0
            assert output.data[11] == 32.0

    describe "Parameters and Training":
        it "returns weight as only parameter":
            val emb = Embedding.create(num_embeddings: 100, embedding_dim: 50)
            val params = emb.parameters()

            assert params.len() == 1
            assert params[0].shape == [100, 50]

        it "switches between train and eval modes":
            val emb = Embedding.create(num_embeddings: 10, embedding_dim: 5)
            assert emb.training == true

            emb.eval()
            assert emb.training == false

            emb.train()
            assert emb.training == true

    describe "String Representation":
        it "has correct string representation":
            val emb = Embedding.create(num_embeddings: 1000, embedding_dim: 128)
            val s = emb.to_string()

            assert s.contains("Embedding")
            assert s.contains("1000")
            assert s.contains("128")

    describe "Edge Cases":
        it "handles single embedding":
            val emb = Embedding.create(num_embeddings: 1, embedding_dim: 1)
            val indices = tensor_from_data([0.0], [1])
            val output = emb.forward(indices)

            assert output.shape == [1, 1]

        it "handles large embedding dimension":
            val emb = Embedding.create(num_embeddings: 10, embedding_dim: 512)
            val indices = tensor_from_data([0.0], [1])
            val output = emb.forward(indices)

            assert output.shape == [1, 512]

        it "handles large vocabulary":
            val emb = Embedding.create(num_embeddings: 10000, embedding_dim: 10)
            val indices = tensor_from_data([9999.0], [1])
            val output = emb.forward(indices)

            assert output.shape == [1, 10]

        it "handles empty-like cases gracefully":
            val emb = Embedding.create(num_embeddings: 10, embedding_dim: 5)

            # Single index
            val indices = tensor_from_data([0.0], [1])
            val output = emb.forward(indices)

            assert output.shape == [1, 5]
