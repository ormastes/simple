# Integration tests for Conv2d with other layers

use lib.pure.tensor.{tensor_from_data}
use lib.pure.nn.{Conv2d, ReLU, Sequential, count_parameters}

describe "Conv2d Integration":
    describe "Simple CNN":
        it "builds a simple conv-relu network":
            val conv = Conv2d.create(
                in_channels: 1,
                out_channels: 16,
                kernel_size: 3,
                stride: 1,
                padding: 1,
                bias: true
            )

            val relu = ReLU.create()

            # Create sequential model
            val model = Sequential.create([conv, relu])

            assert model.to_string().contains("Sequential")
            assert model.to_string().contains("Conv2d")
            assert model.to_string().contains("ReLU")

        it "counts parameters in conv layer correctly":
            val conv = Conv2d.create(
                in_channels: 1,
                out_channels: 16,
                kernel_size: 3,
                stride: 1,
                padding: 1,
                bias: true
            )

            # Weight: 16 * 1 * 3 * 3 = 144
            # Bias: 16
            # Total: 160
            val param_count = count_parameters(conv)
            assert param_count == 160

        it "counts parameters in multi-layer conv network":
            val conv1 = Conv2d.create(
                in_channels: 3,
                out_channels: 32,
                kernel_size: 3,
                stride: 1,
                padding: 1,
                bias: true
            )

            val conv2 = Conv2d.create(
                in_channels: 32,
                out_channels: 64,
                kernel_size: 3,
                stride: 1,
                padding: 1,
                bias: true
            )

            val model = Sequential.create([conv1, conv2])

            # Conv1: 3*32*3*3 + 32 = 896
            # Conv2: 32*64*3*3 + 64 = 18496
            # Total: 19392
            val param_count = count_parameters(model)
            assert param_count == 19392

        it "forwards through conv-relu stack":
            val conv = Conv2d.create(
                in_channels: 1,
                out_channels: 2,
                kernel_size: 1,
                stride: 1,
                padding: 0,
                bias: true
            )

            val relu = ReLU.create()
            val model = Sequential.create([conv, relu])

            # Create input
            val input = tensor_from_data([1.0, 2.0, 3.0, 4.0], [1, 1, 2, 2])

            # Forward pass
            val output = model.forward(input)

            # Should have shape [1, 2, 2, 2]
            assert output.shape[0] == 1
            assert output.shape[1] == 2
            assert output.shape[2] == 2
            assert output.shape[3] == 2

        it "handles train and eval mode switching":
            val conv1 = Conv2d.create(
                in_channels: 1,
                out_channels: 8,
                kernel_size: 3,
                stride: 1,
                padding: 1,
                bias: true
            )

            val conv2 = Conv2d.create(
                in_channels: 8,
                out_channels: 16,
                kernel_size: 3,
                stride: 1,
                padding: 1,
                bias: true
            )

            val model = Sequential.create([conv1, conv2])

            # Initially in training mode
            assert model.training == true
            assert conv1.training == true
            assert conv2.training == true

            # Switch to eval
            model.eval()
            assert model.training == false
            assert conv1.training == false
            assert conv2.training == false

            # Switch back to train
            model.train()
            assert model.training == true
            assert conv1.training == true
            assert conv2.training == true

    describe "Multi-layer CNN":
        it "builds a typical MNIST-style CNN":
            # Conv1: 1 -> 32 channels
            val conv1 = Conv2d.create(
                in_channels: 1,
                out_channels: 32,
                kernel_size: 3,
                stride: 1,
                padding: 1,
                bias: true
            )

            val relu1 = ReLU.create()

            # Conv2: 32 -> 64 channels
            val conv2 = Conv2d.create(
                in_channels: 32,
                out_channels: 64,
                kernel_size: 3,
                stride: 1,
                padding: 1,
                bias: true
            )

            val relu2 = ReLU.create()

            val model = Sequential.create([conv1, relu1, conv2, relu2])

            # Test with small input (not full 28x28 for speed)
            var input_data: [f64] = []
            var i = 0
            while i < 1 * 1 * 8 * 8:
                input_data.push(0.5)
                i = i + 1

            val input = tensor_from_data(input_data, [1, 1, 8, 8])
            val output = model.forward(input)

            # Output should be [1, 64, 8, 8]
            assert output.shape[0] == 1
            assert output.shape[1] == 64
            assert output.shape[2] == 8
            assert output.shape[3] == 8

        it "builds a VGG-style block":
            # Two 3x3 conv layers (common VGG pattern)
            val conv1 = Conv2d.create(
                in_channels: 64,
                out_channels: 128,
                kernel_size: 3,
                stride: 1,
                padding: 1,
                bias: true
            )

            val relu1 = ReLU.create()

            val conv2 = Conv2d.create(
                in_channels: 128,
                out_channels: 128,
                kernel_size: 3,
                stride: 1,
                padding: 1,
                bias: true
            )

            val relu2 = ReLU.create()

            val block = Sequential.create([conv1, relu1, conv2, relu2])

            # Count parameters
            # Conv1: 64*128*3*3 + 128 = 73856
            # Conv2: 128*128*3*3 + 128 = 147584
            # Total: 221440
            val param_count = count_parameters(block)
            assert param_count == 221440

    describe "Different Architectures":
        it "creates 1x1 conv for channel reduction":
            # 1x1 convolutions are used to reduce/increase channels
            val conv = Conv2d.create(
                in_channels: 256,
                out_channels: 64,
                kernel_size: 1,
                stride: 1,
                padding: 0,
                bias: true
            )

            # Parameters: 256*64*1*1 + 64 = 16448
            val param_count = count_parameters(conv)
            assert param_count == 16448

        it "creates depthwise-style conv":
            # Depthwise conv has groups=in_channels
            # We simulate with out_channels = in_channels
            val conv = Conv2d.create(
                in_channels: 32,
                out_channels: 32,
                kernel_size: 3,
                stride: 1,
                padding: 1,
                bias: true
            )

            # Parameters: 32*32*3*3 + 32 = 9248
            val param_count = count_parameters(conv)
            assert param_count == 9248

        it "creates stride-2 conv for downsampling":
            # Stride-2 conv reduces spatial dimensions
            val conv = Conv2d.create(
                in_channels: 64,
                out_channels: 128,
                kernel_size: 3,
                stride: 2,
                padding: 1,
                bias: true
            )

            # Input: [1, 64, 8, 8]
            var input_data: [f64] = []
            var i = 0
            while i < 1 * 64 * 8 * 8:
                input_data.push(1.0)
                i = i + 1

            val input = tensor_from_data(input_data, [1, 64, 8, 8])
            val output = conv.forward(input)

            # Output: [1, 128, 4, 4] (half spatial size)
            # (8 + 2*1 - 3)/2 + 1 = 4
            assert output.shape[0] == 1
            assert output.shape[1] == 128
            assert output.shape[2] == 4
            assert output.shape[3] == 4
