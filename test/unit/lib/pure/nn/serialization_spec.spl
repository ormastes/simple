# Tests for Pure Simple Model Serialization

use lib.pure.tensor.{PureTensor, tensor_from_data}
use lib.pure.nn.serialization.{serialize_tensor, deserialize_tensor, serialize_tensors, deserialize_tensors}
use lib.pure.nn.serialization.{save_checkpoint, load_checkpoint_epoch, load_checkpoint_lr}
use lib.pure.nn.serialization.{_ser_float_to_text, _ser_text_to_float}

describe "Model Serialization":
    describe "Helper Functions":
        it "converts float to text":
            val s = _ser_float_to_text(3.14)
            expect(s.contains("3")).to_equal(true)

        it "converts positive integer text to float":
            val v = _ser_text_to_float("42")
            expect(v).to_equal(42.0)

        it "converts decimal text to float":
            val v = _ser_text_to_float("3.5")
            expect(v).to_equal(3.5)

        it "converts negative text to float":
            val v = _ser_text_to_float("-2.5")
            expect(v).to_equal(-2.5)

        it "returns 0.0 for empty text":
            val v = _ser_text_to_float("")
            expect(v).to_equal(0.0)

        it "returns 0.0 for zero":
            val v = _ser_text_to_float("0.0")
            expect(v).to_equal(0.0)

    describe "Single Tensor Serialization":
        it "serializes 1D tensor":
            val t = tensor_from_data([1.0, 2.0, 3.0], [3])
            val s = serialize_tensor(t)
            expect(s.contains("SHAPE:3")).to_equal(true)
            expect(s.contains("DATA:")).to_equal(true)

        it "serializes 2D tensor":
            val t = tensor_from_data([1.0, 2.0, 3.0, 4.0], [2, 2])
            val s = serialize_tensor(t)
            expect(s.contains("SHAPE:2,2")).to_equal(true)
            expect(s.contains("DATA:")).to_equal(true)

        it "round-trips 1D tensor":
            val original = tensor_from_data([1.0, 2.0, 3.0], [3])
            val serialized = serialize_tensor(original)
            val restored = deserialize_tensor(serialized)
            expect(restored.shape).to_equal([3])
            expect(restored.data.len()).to_equal(3)
            expect(restored.data[0]).to_equal(1.0)
            expect(restored.data[1]).to_equal(2.0)
            expect(restored.data[2]).to_equal(3.0)

        it "round-trips 2D tensor":
            val original = tensor_from_data([1.0, 2.0, 3.0, 4.0], [2, 2])
            val serialized = serialize_tensor(original)
            val restored = deserialize_tensor(serialized)
            expect(restored.shape).to_equal([2, 2])
            expect(restored.data.len()).to_equal(4)
            expect(restored.data[0]).to_equal(1.0)
            expect(restored.data[3]).to_equal(4.0)

        it "round-trips 3D tensor shape":
            val original = tensor_from_data([1.0, 2.0, 3.0, 4.0, 5.0, 6.0], [1, 2, 3])
            val serialized = serialize_tensor(original)
            val restored = deserialize_tensor(serialized)
            expect(restored.shape).to_equal([1, 2, 3])
            expect(restored.data.len()).to_equal(6)

    describe "Multiple Tensor Serialization":
        it "serializes and deserializes multiple tensors":
            val t1 = tensor_from_data([1.0, 2.0], [2])
            val t2 = tensor_from_data([3.0, 4.0, 5.0], [3])
            val serialized = serialize_tensors([t1, t2])
            val restored = deserialize_tensors(serialized)
            expect(restored.len()).to_equal(2)
            expect(restored[0].shape).to_equal([2])
            expect(restored[1].shape).to_equal([3])
            expect(restored[0].data[0]).to_equal(1.0)
            expect(restored[1].data[2]).to_equal(5.0)

        it "handles single tensor in list":
            val t1 = tensor_from_data([7.0], [1])
            val serialized = serialize_tensors([t1])
            val restored = deserialize_tensors(serialized)
            expect(restored.len()).to_equal(1)
            expect(restored[0].data[0]).to_equal(7.0)

        it "contains separator between tensors":
            val t1 = tensor_from_data([1.0], [1])
            val t2 = tensor_from_data([2.0], [1])
            val serialized = serialize_tensors([t1, t2])
            expect(serialized.contains("---")).to_equal(true)

    describe "Checkpoint Support":
        it "extracts epoch from checkpoint text":
            val checkpoint = "EPOCH:5\nLR:0.01\nSHAPE:2\nDATA:1.0,2.0"
            val epoch = load_checkpoint_epoch(checkpoint)
            expect(epoch).to_equal(5)

        it "extracts learning rate from checkpoint text":
            val checkpoint = "EPOCH:5\nLR:0.01\nSHAPE:2\nDATA:1.0,2.0"
            val lr = load_checkpoint_lr(checkpoint)
            expect(lr).to_equal(0.01)

        it "extracts epoch zero":
            val checkpoint = "EPOCH:0\nLR:0.001\nSHAPE:1\nDATA:1.0"
            val epoch = load_checkpoint_epoch(checkpoint)
            expect(epoch).to_equal(0)

        it "extracts large epoch number":
            val checkpoint = "EPOCH:100\nLR:0.0001\nSHAPE:1\nDATA:0.5"
            val epoch = load_checkpoint_epoch(checkpoint)
            expect(epoch).to_equal(100)

    describe "Edge Cases":
        it "handles single element tensor":
            val t = tensor_from_data([42.0], [1])
            val s = serialize_tensor(t)
            val restored = deserialize_tensor(s)
            expect(restored.data[0]).to_equal(42.0)
            expect(restored.shape).to_equal([1])

        it "handles zero values":
            val t = tensor_from_data([0.0, 0.0], [2])
            val s = serialize_tensor(t)
            val restored = deserialize_tensor(s)
            expect(restored.data[0]).to_equal(0.0)
            expect(restored.data[1]).to_equal(0.0)
