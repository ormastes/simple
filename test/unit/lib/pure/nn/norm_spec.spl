# Tests for Pure Simple Normalization Layers

use std.pure.tensor.{PureTensor, tensor_from_data, tensor_zeros, tensor_ones}
use std.pure.nn.norm.{BatchNorm2d, GroupNorm, InstanceNorm2d, batchnorm2d_create, groupnorm_create, instancenorm2d_create}

describe "Normalization Layers":
    describe "BatchNorm2d":
        describe "Layer Creation":
            it "creates batchnorm2d with specified parameters":
                val bn = BatchNorm2d__create(num_features: 3, eps: 0.00001, momentum: 0.1)
                expect(bn.num_features).to_equal(3)
                expect(bn.training).to_equal(true)

            it "initializes weight to ones":
                val bn = BatchNorm2d__create(num_features: 2, eps: 0.00001, momentum: 0.1)
                expect(bn.weight.data[0]).to_equal(1.0)
                expect(bn.weight.data[1]).to_equal(1.0)

            it "initializes bias to zeros":
                val bn = BatchNorm2d__create(num_features: 2, eps: 0.00001, momentum: 0.1)
                expect(bn.bias.data[0]).to_equal(0.0)
                expect(bn.bias.data[1]).to_equal(0.0)

            it "creates layer via factory function":
                val bn = batchnorm2d_create(4, 0.00001, 0.1)
                expect(bn.num_features).to_equal(4)

        describe "Forward Pass":
            it "normalizes single channel to zero mean":
                val bn = BatchNorm2d__create(num_features: 1, eps: 0.00001, momentum: 0.1)

                # Input: [2, 1, 1, 1] - 2 batch, 1 channel, 1x1 spatial
                val input = tensor_from_data([2.0, 4.0], [2, 1, 1, 1])

                val output = bn.forward(input)

                # mean=3, var=1, normalized: (2-3)/1=-1, (4-3)/1=1
                expect(output.shape).to_equal([2, 1, 1, 1])
                expect(output.data[0]).to_be_less_than(0.0)
                expect(output.data[1]).to_be_greater_than(0.0)

            it "preserves shape after normalization":
                val bn = BatchNorm2d__create(num_features: 2, eps: 0.00001, momentum: 0.1)

                val input = tensor_from_data([
                    1.0, 2.0, 3.0, 4.0,
                    5.0, 6.0, 7.0, 8.0
                ], [1, 2, 2, 2])

                val output = bn.forward(input)
                expect(output.shape).to_equal([1, 2, 2, 2])
                expect(output.data.len()).to_equal(8)

            it "produces near-zero mean output":
                val bn = BatchNorm2d__create(num_features: 1, eps: 0.00001, momentum: 0.1)

                val input = tensor_from_data([
                    10.0, 20.0,
                    30.0, 40.0
                ], [2, 1, 1, 2])

                val output = bn.forward(input)

                # Sum of normalized values should be near zero
                var sum_val = 0.0
                var i = 0
                while i < output.data.len():
                    sum_val = sum_val + output.data[i]
                    i = i + 1
                val abs_sum = if sum_val < 0.0: -sum_val else: sum_val
                expect(abs_sum).to_be_less_than(0.01)

        describe "Eval Mode":
            it "uses running statistics in eval mode":
                val bn = BatchNorm2d__create(num_features: 1, eps: 0.00001, momentum: 0.1)

                # Training forward to build running stats
                val input = tensor_from_data([2.0, 4.0], [2, 1, 1, 1])
                val train_out = bn.forward(input)

                # Switch to eval mode
                bn.eval_mode()
                expect(bn.training).to_equal(false)

                # Forward in eval mode uses running stats
                val eval_out = bn.forward(input)
                expect(eval_out.shape).to_equal([2, 1, 1, 1])

        describe "Layer Interface":
            it "has two trainable parameters":
                val bn = BatchNorm2d__create(num_features: 3, eps: 0.00001, momentum: 0.1)
                val params = bn.parameters()
                expect(params.len()).to_equal(2)

            it "switches between train and eval modes":
                val bn = BatchNorm2d__create(num_features: 2, eps: 0.00001, momentum: 0.1)
                expect(bn.training).to_equal(true)

                bn.eval_mode()
                expect(bn.training).to_equal(false)

                bn.train_mode()
                expect(bn.training).to_equal(true)

            it "has string representation":
                val bn = BatchNorm2d__create(num_features: 16, eps: 0.00001, momentum: 0.1)
                val s = bn.to_string()
                expect(s).to_contain("BatchNorm2d")
                expect(s).to_contain("16")

    describe "GroupNorm":
        describe "Layer Creation":
            it "creates groupnorm with specified parameters":
                val gn = GroupNorm__create(num_groups: 2, num_channels: 4, eps: 0.00001)
                expect(gn.num_groups).to_equal(2)
                expect(gn.num_channels).to_equal(4)
                expect(gn.training).to_equal(true)

            it "initializes weight and bias correctly":
                val gn = GroupNorm__create(num_groups: 2, num_channels: 4, eps: 0.00001)
                expect(gn.weight.data[0]).to_equal(1.0)
                expect(gn.bias.data[0]).to_equal(0.0)

            it "creates layer via factory function":
                val gn = groupnorm_create(2, 6, 0.00001)
                expect(gn.num_groups).to_equal(2)
                expect(gn.num_channels).to_equal(6)

        describe "Forward Pass":
            it "normalizes within groups":
                val gn = GroupNorm__create(num_groups: 2, num_channels: 4, eps: 0.00001)

                # Input: [1, 4, 1, 1] - 4 channels, 2 groups of 2
                val input = tensor_from_data([
                    1.0, 3.0, 10.0, 20.0
                ], [1, 4, 1, 1])

                val output = gn.forward(input)

                expect(output.shape).to_equal([1, 4, 1, 1])
                # Group 0 (ch 0,1): mean=2, channels normalized around 0
                expect(output.data[0]).to_be_less_than(0.0)
                expect(output.data[1]).to_be_greater_than(0.0)
                # Group 1 (ch 2,3): mean=15, channels normalized around 0
                expect(output.data[2]).to_be_less_than(0.0)
                expect(output.data[3]).to_be_greater_than(0.0)

            it "preserves shape":
                val gn = GroupNorm__create(num_groups: 2, num_channels: 4, eps: 0.00001)

                val input = tensor_from_data([
                    1.0, 2.0, 3.0, 4.0,
                    5.0, 6.0, 7.0, 8.0,
                    9.0, 10.0, 11.0, 12.0,
                    13.0, 14.0, 15.0, 16.0
                ], [1, 4, 2, 2])

                val output = gn.forward(input)
                expect(output.shape).to_equal([1, 4, 2, 2])
                expect(output.data.len()).to_equal(16)

        describe "Layer Interface":
            it "has two trainable parameters":
                val gn = GroupNorm__create(num_groups: 2, num_channels: 4, eps: 0.00001)
                val params = gn.parameters()
                expect(params.len()).to_equal(2)

            it "has string representation":
                val gn = GroupNorm__create(num_groups: 4, num_channels: 16, eps: 0.00001)
                val s = gn.to_string()
                expect(s).to_contain("GroupNorm")
                expect(s).to_contain("4")
                expect(s).to_contain("16")

    describe "InstanceNorm2d":
        describe "Layer Creation":
            it "creates instancenorm2d with specified parameters":
                val inst = InstanceNorm2d__create(num_features: 3, eps: 0.00001)
                expect(inst.num_features).to_equal(3)
                expect(inst.training).to_equal(true)

            it "initializes weight and bias correctly":
                val inst = InstanceNorm2d__create(num_features: 2, eps: 0.00001)
                expect(inst.weight.data[0]).to_equal(1.0)
                expect(inst.weight.data[1]).to_equal(1.0)
                expect(inst.bias.data[0]).to_equal(0.0)

            it "creates layer via factory function":
                val inst = instancenorm2d_create(4, 0.00001)
                expect(inst.num_features).to_equal(4)

        describe "Forward Pass":
            it "normalizes each channel independently":
                val inst = InstanceNorm2d__create(num_features: 2, eps: 0.00001)

                # Input: [1, 2, 2, 1] - 2 channels, 2x1 spatial
                val input = tensor_from_data([
                    1.0, 3.0,   # Channel 0: mean=2
                    10.0, 20.0  # Channel 1: mean=15
                ], [1, 2, 2, 1])

                val output = inst.forward(input)

                expect(output.shape).to_equal([1, 2, 2, 1])
                # Channel 0 normalized around 0
                expect(output.data[0]).to_be_less_than(0.0)
                expect(output.data[1]).to_be_greater_than(0.0)
                # Channel 1 normalized around 0
                expect(output.data[2]).to_be_less_than(0.0)
                expect(output.data[3]).to_be_greater_than(0.0)

            it "normalizes per batch sample":
                val inst = InstanceNorm2d__create(num_features: 1, eps: 0.00001)

                # Input: [2, 1, 2, 1] - 2 batches, 1 channel, 2x1 spatial
                val input = tensor_from_data([
                    2.0, 6.0,   # Batch 0: mean=4
                    10.0, 20.0  # Batch 1: mean=15
                ], [2, 1, 2, 1])

                val output = inst.forward(input)

                expect(output.shape).to_equal([2, 1, 2, 1])
                # Batch 0 normalized
                expect(output.data[0]).to_be_less_than(0.0)
                expect(output.data[1]).to_be_greater_than(0.0)
                # Batch 1 normalized independently
                expect(output.data[2]).to_be_less_than(0.0)
                expect(output.data[3]).to_be_greater_than(0.0)

            it "preserves shape with spatial dimensions":
                val inst = InstanceNorm2d__create(num_features: 2, eps: 0.00001)

                val input = tensor_from_data([
                    1.0, 2.0, 3.0, 4.0,
                    5.0, 6.0, 7.0, 8.0
                ], [1, 2, 2, 2])

                val output = inst.forward(input)
                expect(output.shape).to_equal([1, 2, 2, 2])
                expect(output.data.len()).to_equal(8)

        describe "Layer Interface":
            it "has two trainable parameters":
                val inst = InstanceNorm2d__create(num_features: 3, eps: 0.00001)
                val params = inst.parameters()
                expect(params.len()).to_equal(2)

            it "switches between train and eval modes":
                val inst = InstanceNorm2d__create(num_features: 2, eps: 0.00001)
                expect(inst.training).to_equal(true)

                inst.eval_mode()
                expect(inst.training).to_equal(false)

                inst.train_mode()
                expect(inst.training).to_equal(true)

            it "has string representation":
                val inst = InstanceNorm2d__create(num_features: 8, eps: 0.00001)
                val s = inst.to_string()
                expect(s).to_contain("InstanceNorm2d")
                expect(s).to_contain("8")
