# Tests for Pure Simple Learning Rate Schedulers

use lib.pure.optim.scheduler.{ReduceLROnPlateau, CyclicLR, WarmupLR, LinearLR, OneCycleLR}
use lib.pure.optim.scheduler.{_sched_cos}

describe "Learning Rate Schedulers":
    describe "Helper Functions":
        it "computes cos(0) approximately 1.0":
            val result = _sched_cos(0.0)
            expect(result).to_equal(1.0)

        it "computes cos(pi) approximately -1.0":
            val pi = 3.14159265358979
            val result = _sched_cos(pi)
            # Taylor series should be close to -1.0
            expect(result < -0.99).to_equal(true)
            expect(result > -1.01).to_equal(true)

        it "computes cos(pi/2) approximately 0.0":
            val half_pi = 3.14159265358979 / 2.0
            val result = _sched_cos(half_pi)
            # Should be close to 0.0
            expect(result > -0.01).to_equal(true)
            expect(result < 0.01).to_equal(true)

    describe "ReduceLROnPlateau":
        it "creates with initial parameters":
            val sched = ReduceLROnPlateau.create(0.01, 0.5, 3, 0.0001)
            expect(sched.current_lr).to_equal(0.01)
            expect(sched.factor).to_equal(0.5)
            expect(sched.patience).to_equal(3)
            expect(sched.min_lr).to_equal(0.0001)

        it "does not reduce LR when metric improves":
            val sched = ReduceLROnPlateau.create(0.01, 0.5, 3, 0.0001)
            sched.step(1.0)
            sched.step(0.9)
            sched.step(0.8)
            expect(sched.get_lr()).to_equal(0.01)

        it "reduces LR after patience steps without improvement":
            val sched = ReduceLROnPlateau.create(0.01, 0.5, 3, 0.0001)
            sched.step(1.0)  # Sets best
            sched.step(1.1)  # No improve (1)
            sched.step(1.2)  # No improve (2)
            sched.step(1.3)  # No improve (3) -> reduce
            expect(sched.get_lr()).to_equal(0.005)

        it "respects min_lr floor":
            val sched = ReduceLROnPlateau.create(0.001, 0.1, 1, 0.0005)
            sched.step(1.0)
            sched.step(1.1)  # Patience=1, reduce: 0.001*0.1=0.0001 < min_lr
            expect(sched.get_lr()).to_equal(0.0005)

        it "resets patience counter on improvement":
            val sched = ReduceLROnPlateau.create(0.01, 0.5, 3, 0.0001)
            sched.step(1.0)
            sched.step(1.1)  # No improve (1)
            sched.step(1.2)  # No improve (2)
            sched.step(0.5)  # Improve -> reset
            sched.step(0.6)  # No improve (1)
            expect(sched.get_lr()).to_equal(0.01)

        it "has string representation":
            val sched = ReduceLROnPlateau.create(0.01, 0.5, 3, 0.0001)
            val s = sched.to_string()
            expect(s.contains("ReduceLROnPlateau")).to_equal(true)

    describe "CyclicLR":
        it "creates with initial parameters":
            val sched = CyclicLR.create(0.001, 0.01, 10)
            expect(sched.base_lr).to_equal(0.001)
            expect(sched.max_lr).to_equal(0.01)
            expect(sched.step_size_up).to_equal(10)
            expect(sched.current_step).to_equal(0)

        it "starts at base_lr":
            val sched = CyclicLR.create(0.001, 0.01, 10)
            expect(sched.get_lr()).to_equal(0.001)

        it "increases LR during ascending phase":
            val sched = CyclicLR.create(0.001, 0.01, 10)
            sched.step()
            sched.step()
            sched.step()
            sched.step()
            sched.step()
            # At step 5, progress = 5/10 = 0.5
            val lr = sched.get_lr()
            expect(lr > 0.004).to_equal(true)
            expect(lr < 0.006).to_equal(true)

        it "reaches max_lr at peak":
            val sched = CyclicLR.create(0.0, 1.0, 10)
            # Step 10 times to reach peak
            var i = 0
            while i < 10:
                sched.step()
                i = i + 1
            # At step 10, in descending phase, pos=10, progress=0/10=0
            val lr = sched.get_lr()
            expect(lr).to_equal(1.0)

        it "decreases LR during descending phase":
            val sched = CyclicLR.create(0.0, 1.0, 10)
            # Step 15 times: descending, pos=15, progress=5/10=0.5
            var i = 0
            while i < 15:
                sched.step()
                i = i + 1
            val lr = sched.get_lr()
            expect(lr > 0.4).to_equal(true)
            expect(lr < 0.6).to_equal(true)

        it "cycles back after full period":
            val sched = CyclicLR.create(0.0, 1.0, 10)
            # Step 20 times: full cycle, back to base
            var i = 0
            while i < 20:
                sched.step()
                i = i + 1
            val lr = sched.get_lr()
            expect(lr).to_equal(0.0)

        it "has string representation":
            val sched = CyclicLR.create(0.001, 0.01, 10)
            val s = sched.to_string()
            expect(s.contains("CyclicLR")).to_equal(true)

    describe "WarmupLR":
        it "creates with initial parameters":
            val sched = WarmupLR.create(0.01, 100)
            expect(sched.target_lr).to_equal(0.01)
            expect(sched.warmup_steps).to_equal(100)
            expect(sched.current_step).to_equal(0)

        it "starts at zero LR":
            val sched = WarmupLR.create(0.01, 100)
            expect(sched.get_lr()).to_equal(0.0)

        it "linearly increases during warmup":
            val sched = WarmupLR.create(0.01, 100)
            # Step 50 times: half warmup
            var i = 0
            while i < 50:
                sched.step()
                i = i + 1
            val lr = sched.get_lr()
            expect(lr).to_equal(0.005)

        it "reaches target_lr at end of warmup":
            val sched = WarmupLR.create(0.01, 10)
            var i = 0
            while i < 10:
                sched.step()
                i = i + 1
            expect(sched.get_lr()).to_equal(0.01)

        it "holds at target_lr after warmup":
            val sched = WarmupLR.create(0.01, 10)
            var i = 0
            while i < 20:
                sched.step()
                i = i + 1
            expect(sched.get_lr()).to_equal(0.01)

        it "has string representation":
            val sched = WarmupLR.create(0.01, 100)
            val s = sched.to_string()
            expect(s.contains("WarmupLR")).to_equal(true)

    describe "LinearLR":
        it "creates with initial parameters":
            val sched = LinearLR.create(0.01, 1.0, 0.1, 100)
            expect(sched.base_lr).to_equal(0.01)
            expect(sched.start_factor).to_equal(1.0)
            expect(sched.end_factor).to_equal(0.1)
            expect(sched.total_iters).to_equal(100)

        it "starts at base_lr * start_factor":
            val sched = LinearLR.create(0.01, 1.0, 0.1, 100)
            expect(sched.get_lr()).to_equal(0.01)

        it "linearly interpolates LR":
            val sched = LinearLR.create(0.01, 1.0, 0.1, 100)
            var i = 0
            while i < 50:
                sched.step()
                i = i + 1
            # At step 50: factor = 1.0 + (0.1 - 1.0) * 0.5 = 0.55
            val lr = sched.get_lr()
            expect(lr > 0.0054).to_equal(true)
            expect(lr < 0.0056).to_equal(true)

        it "reaches end factor at total_iters":
            val sched = LinearLR.create(0.01, 1.0, 0.1, 10)
            var i = 0
            while i < 10:
                sched.step()
                i = i + 1
            expect(sched.get_lr()).to_equal(0.001)

        it "holds at end value after total_iters":
            val sched = LinearLR.create(0.01, 1.0, 0.1, 10)
            var i = 0
            while i < 20:
                sched.step()
                i = i + 1
            expect(sched.get_lr()).to_equal(0.001)

        it "has string representation":
            val sched = LinearLR.create(0.01, 1.0, 0.1, 100)
            val s = sched.to_string()
            expect(s.contains("LinearLR")).to_equal(true)

    describe "OneCycleLR":
        it "creates with initial parameters":
            val sched = OneCycleLR.create(0.01, 100, 0.0001)
            expect(sched.max_lr).to_equal(0.01)
            expect(sched.total_steps).to_equal(100)
            expect(sched.min_lr).to_equal(0.0001)
            expect(sched.current_step).to_equal(0)

        it "starts at min_lr":
            val sched = OneCycleLR.create(0.01, 100, 0.0001)
            expect(sched.get_lr()).to_equal(0.0001)

        it "warms up during phase 1 (0-30%)":
            val sched = OneCycleLR.create(0.01, 100, 0.0)
            # Step 15 times (15% progress, in warmup phase)
            var i = 0
            while i < 15:
                sched.step()
                i = i + 1
            val lr = sched.get_lr()
            # phase_progress = 0.15/0.3 = 0.5, lr = 0.0 + 0.01 * 0.5 = 0.005
            expect(lr > 0.004).to_equal(true)
            expect(lr < 0.006).to_equal(true)

        it "reaches max_lr at 30% progress":
            val sched = OneCycleLR.create(0.01, 100, 0.0)
            var i = 0
            while i < 30:
                sched.step()
                i = i + 1
            val lr = sched.get_lr()
            # At 30%: start of phase 2, cosine(0) = 1.0
            # lr = 0.0 + 0.01 * (1.0 + 1.0) / 2.0 = 0.01
            expect(lr > 0.009).to_equal(true)
            expect(lr < 0.011).to_equal(true)

        it "decays during phase 2 (30-70%)":
            val sched = OneCycleLR.create(0.01, 100, 0.0)
            # Step to 50% progress
            var i = 0
            while i < 50:
                sched.step()
                i = i + 1
            val lr = sched.get_lr()
            # Should be between min and max
            expect(lr > 0.0).to_equal(true)
            expect(lr < 0.01).to_equal(true)

        it "final decay during phase 3 (70-100%)":
            val sched = OneCycleLR.create(0.01, 100, 0.001)
            # Step to 85% progress
            var i = 0
            while i < 85:
                sched.step()
                i = i + 1
            val lr = sched.get_lr()
            # Phase 3: decays from min_lr toward min_lr/10
            expect(lr < 0.001).to_equal(true)

        it "has string representation":
            val sched = OneCycleLR.create(0.01, 100, 0.0001)
            val s = sched.to_string()
            expect(s.contains("OneCycleLR")).to_equal(true)

    describe "Integration":
        it "schedulers can be used in a training loop pattern":
            val warmup = WarmupLR.create(0.01, 5)
            var lrs: [f64] = []
            var i = 0
            while i < 10:
                warmup.step()
                lrs.push(warmup.get_lr())
                i = i + 1
            # First 5 should be increasing
            expect(lrs[0] < lrs[4]).to_equal(true)
            # After warmup, should all be target_lr
            expect(lrs[4]).to_equal(0.01)
            expect(lrs[9]).to_equal(0.01)

        it "cyclic and warmup can be composed sequentially":
            val warmup = WarmupLR.create(0.01, 5)
            var i = 0
            while i < 5:
                warmup.step()
                i = i + 1
            val final_warmup_lr = warmup.get_lr()
            expect(final_warmup_lr).to_equal(0.01)

            val cyclic = CyclicLR.create(0.001, final_warmup_lr, 10)
            cyclic.step()
            val lr = cyclic.get_lr()
            expect(lr > 0.001).to_equal(true)
            expect(lr < 0.01).to_equal(true)
