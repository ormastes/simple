# Tests for Autograd Support for Advanced Operations

use lib.pure.autograd (Tensor, tensor_from_data, backward)
use lib.pure.autograd_advanced (
    tensor_stack, tensor_concat, tensor_split, tensor_reshape, tensor_permute,
    backward_stack, backward_concat, backward_reshape, backward_permute,
    inverse_permutation
)
use lib.pure.tensor_f64 (TensorF64, from_data)

describe "Autograd Advanced Operations":
    describe "tensor_stack":
        it "stacks tensors with gradient tracking":
            val t1 = tensor_from_data([1.0, 2.0], [2], true)
            val t2 = tensor_from_data([3.0, 4.0], [2], true)
            val result = tensor_stack([t1, t2], 0)

            expect(result.requires_grad).to_equal(true)
            expect(result.shape()).to_equal([2, 2])
            expect(result.op_name).to_equal("stack")

        it "does not track gradient when inputs don't require grad":
            val t1 = tensor_from_data([1.0, 2.0], [2], false)
            val t2 = tensor_from_data([3.0, 4.0], [2], false)
            val result = tensor_stack([t1, t2], 0)

            expect(result.requires_grad).to_equal(false)

        it "tracks gradient when at least one input requires grad":
            val t1 = tensor_from_data([1.0, 2.0], [2], true)
            val t2 = tensor_from_data([3.0, 4.0], [2], false)
            val result = tensor_stack([t1, t2], 0)

            expect(result.requires_grad).to_equal(true)

    describe "tensor_concat":
        it "concatenates tensors with gradient tracking":
            val t1 = tensor_from_data([1.0, 2.0], [2], true)
            val t2 = tensor_from_data([3.0, 4.0, 5.0], [3], true)
            val result = tensor_concat([t1, t2], 0)

            expect(result.requires_grad).to_equal(true)
            expect(result.shape()).to_equal([5])
            expect(result.op_name).to_equal("concat")

        it "handles 2D concatenation":
            val t1 = tensor_from_data([1.0, 2.0, 3.0, 4.0], [2, 2], true)
            val t2 = tensor_from_data([5.0, 6.0], [1, 2], true)
            val result = tensor_concat([t1, t2], 0)

            expect(result.shape()).to_equal([3, 2])
            expect(result.requires_grad).to_equal(true)

    describe "tensor_split":
        it "splits tensor with gradient tracking":
            val t = tensor_from_data([1.0, 2.0, 3.0, 4.0, 5.0, 6.0], [6], true)
            val chunks = tensor_split(t, [2, 2, 2], 0)

            expect(chunks.len()).to_equal(3)
            expect(chunks[0].requires_grad).to_equal(true)
            expect(chunks[1].requires_grad).to_equal(true)
            expect(chunks[2].requires_grad).to_equal(true)
            expect(chunks[0].shape()).to_equal([2])

        it "splits without gradient when input doesn't require grad":
            val t = tensor_from_data([1.0, 2.0, 3.0, 4.0], [4], false)
            val chunks = tensor_split(t, [2, 2], 0)

            expect(chunks[0].requires_grad).to_equal(false)
            expect(chunks[1].requires_grad).to_equal(false)

        it "splits 2D tensor":
            val t = tensor_from_data([1.0, 2.0, 3.0, 4.0, 5.0, 6.0], [3, 2], true)
            val chunks = tensor_split(t, [1, 2], 0)

            expect(chunks.len()).to_equal(2)
            expect(chunks[0].shape()).to_equal([1, 2])
            expect(chunks[1].shape()).to_equal([2, 2])

    describe "tensor_reshape":
        it "reshapes tensor with gradient tracking":
            val t = tensor_from_data([1.0, 2.0, 3.0, 4.0, 5.0, 6.0], [6], true)
            val result = tensor_reshape(t, [2, 3])

            expect(result.requires_grad).to_equal(true)
            expect(result.shape()).to_equal([2, 3])
            expect(result.op_name).to_equal("reshape")

        it "infers dimension with -1":
            val t = tensor_from_data([1.0, 2.0, 3.0, 4.0, 5.0, 6.0], [6], true)
            val result = tensor_reshape(t, [2, -1])

            expect(result.shape()).to_equal([2, 3])
            expect(result.requires_grad).to_equal(true)

        it "does not track gradient when input doesn't require grad":
            val t = tensor_from_data([1.0, 2.0, 3.0, 4.0], [4], false)
            val result = tensor_reshape(t, [2, 2])

            expect(result.requires_grad).to_equal(false)

        it "reshapes 3D tensor":
            val t = tensor_from_data([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0], [8], true)
            val result = tensor_reshape(t, [2, 2, 2])

            expect(result.shape()).to_equal([2, 2, 2])
            expect(result.requires_grad).to_equal(true)

    describe "tensor_permute":
        it "permutes 2D tensor with gradient tracking":
            val t = tensor_from_data([1.0, 2.0, 3.0, 4.0, 5.0, 6.0], [2, 3], true)
            val result = tensor_permute(t, [1, 0])

            expect(result.requires_grad).to_equal(true)
            expect(result.shape()).to_equal([3, 2])
            expect(result.op_name).to_equal("permute")

        it "permutes 3D tensor":
            val t = tensor_from_data([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0], [2, 2, 2], true)
            val result = tensor_permute(t, [2, 0, 1])

            expect(result.shape()).to_equal([2, 2, 2])
            expect(result.requires_grad).to_equal(true)

        it "identity permutation":
            val t = tensor_from_data([1.0, 2.0, 3.0, 4.0], [2, 2], true)
            val result = tensor_permute(t, [0, 1])

            expect(result.shape()).to_equal([2, 2])

    describe "backward_stack":
        it "computes gradients for stacked tensors":
            val grad_out = from_data([1.0, 2.0, 3.0, 4.0, 5.0, 6.0], [3, 2])
            val input_shapes = [[2], [2], [2]]
            val grads = backward_stack(grad_out, input_shapes, 0)

            expect(grads.len()).to_equal(3)
            expect(grads[0].shape).to_equal([1, 2])
            expect(grads[1].shape).to_equal([1, 2])
            expect(grads[2].shape).to_equal([1, 2])

    describe "backward_concat":
        it "computes gradients for concatenated tensors":
            val grad_out = from_data([1.0, 2.0, 3.0, 4.0, 5.0, 6.0], [6])
            val input_shapes = [[2], [3], [1]]
            val grads = backward_concat(grad_out, input_shapes, 0)

            expect(grads.len()).to_equal(3)
            expect(grads[0].shape).to_equal([2])
            expect(grads[1].shape).to_equal([3])
            expect(grads[2].shape).to_equal([1])
            expect(grads[0].get([0])).to_equal(1.0)
            expect(grads[1].get([0])).to_equal(3.0)

        it "handles 2D concatenation gradient":
            val grad_out = from_data([1.0, 2.0, 3.0, 4.0, 5.0, 6.0], [3, 2])
            val input_shapes = [[2, 2], [1, 2]]
            val grads = backward_concat(grad_out, input_shapes, 0)

            expect(grads.len()).to_equal(2)
            expect(grads[0].shape).to_equal([2, 2])
            expect(grads[1].shape).to_equal([1, 2])

    describe "backward_reshape":
        it "computes gradient for reshape":
            val grad_out = from_data([1.0, 2.0, 3.0, 4.0, 5.0, 6.0], [2, 3])
            val input_shape = [6]
            val grad_in = backward_reshape(grad_out, input_shape)

            expect(grad_in.shape).to_equal([6])
            expect(grad_in.get([0])).to_equal(1.0)
            expect(grad_in.get([5])).to_equal(6.0)

        it "handles 3D to 1D reshape gradient":
            val grad_out = from_data([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0], [2, 2, 2])
            val input_shape = [8]
            val grad_in = backward_reshape(grad_out, input_shape)

            expect(grad_in.shape).to_equal([8])

    describe "backward_permute":
        it "computes gradient for 2D transpose":
            val grad_out = from_data([1.0, 2.0, 3.0, 4.0, 5.0, 6.0], [3, 2])
            val forward_dims = [1, 0]
            val grad_in = backward_permute(grad_out, forward_dims)

            expect(grad_in.shape).to_equal([2, 3])
            expect(grad_in.get([0, 0])).to_equal(1.0)
            expect(grad_in.get([1, 2])).to_equal(6.0)

        it "computes gradient for 3D permutation":
            val grad_out = from_data([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0], [2, 2, 2])
            val forward_dims = [2, 0, 1]
            val grad_in = backward_permute(grad_out, forward_dims)

            expect(grad_in.shape).to_equal([2, 2, 2])

    describe "inverse_permutation":
        it "computes inverse of simple permutation":
            val perm = [1, 0]
            val inv = inverse_permutation(perm)

            expect(inv).to_equal([1, 0])

        it "computes inverse of 3D permutation":
            val perm = [2, 0, 1]
            val inv = inverse_permutation(perm)

            expect(inv).to_equal([1, 2, 0])

        it "computes inverse of complex permutation":
            val perm = [1, 2, 0]
            val inv = inverse_permutation(perm)

            expect(inv).to_equal([2, 0, 1])

        it "handles identity permutation":
            val perm = [0, 1, 2]
            val inv = inverse_permutation(perm)

            expect(inv).to_equal([0, 1, 2])

    describe "Integration Tests":
        it "combines reshape and permute with gradients":
            val t = tensor_from_data([1.0, 2.0, 3.0, 4.0, 5.0, 6.0], [6], true)
            val reshaped = tensor_reshape(t, [2, 3])
            val permuted = tensor_permute(reshaped, [1, 0])

            expect(permuted.shape()).to_equal([3, 2])
            expect(permuted.requires_grad).to_equal(true)

        it "stacks then splits with gradients":
            val t1 = tensor_from_data([1.0, 2.0], [2], true)
            val t2 = tensor_from_data([3.0, 4.0], [2], true)
            val stacked = tensor_stack([t1, t2], 0)
            val chunks = tensor_split(stacked, [1, 1], 0)

            expect(chunks.len()).to_equal(2)
            expect(chunks[0].requires_grad).to_equal(true)
            expect(chunks[1].requires_grad).to_equal(true)

        it "concatenates then reshapes with gradients":
            val t1 = tensor_from_data([1.0, 2.0], [2], true)
            val t2 = tensor_from_data([3.0, 4.0], [2], true)
            val concatenated = tensor_concat([t1, t2], 0)
            val reshaped = tensor_reshape(concatenated, [2, 2])

            expect(reshaped.shape()).to_equal([2, 2])
            expect(reshaped.requires_grad).to_equal(true)
