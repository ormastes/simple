# Pointer Library Unit Tests
# @tag:test
#
# Tests all pointer types: Handle, UniquePtr, WeakRef.

use std.ptr.handle.{handle_pool_new, handle_pool_reset, handle_alloc, handle_deref, handle_is_valid, handle_free, handle_pool_size, handle_pool_capacity}
use std.ptr.unique.{unique_new, unique_reset, unique_get, unique_is_valid, unique_move, unique_invalidate, unique_into_inner}
use std.ptr.weak.{weak_register, weak_reset, weak_create, weak_upgrade, weak_is_alive, weak_invalidate, weak_add_strong, weak_remove_strong, weak_strong_count}


# ============================================================================
# Handle Tests
# ============================================================================

describe "Handle - alloc and deref":
    it "allocates and dereferences":
        handle_pool_new(16)
        val h = handle_alloc(42)
        val v = handle_deref(h)
        expect(v).to_equal(42)
        expect(handle_is_valid(h)).to_equal(true)
        handle_pool_reset()

describe "Handle - free invalidates":
    it "freed handle is invalid":
        handle_pool_new(16)
        val h = handle_alloc(99)
        expect(handle_is_valid(h)).to_equal(true)
        handle_free(h)
        expect(handle_is_valid(h)).to_equal(false)
        expect(handle_deref(h)).to_equal(-1)
        handle_pool_reset()

describe "Handle - generation counter":
    it "prevents stale access after reuse":
        handle_pool_new(16)
        val h1 = handle_alloc(10)
        handle_free(h1)
        val h2 = handle_alloc(20)
        expect(handle_is_valid(h1)).to_equal(false)
        expect(handle_is_valid(h2)).to_equal(true)
        expect(handle_deref(h2)).to_equal(20)
        handle_pool_reset()

describe "Handle - pool size tracking":
    it "tracks allocations and frees":
        handle_pool_new(8)
        expect(handle_pool_size()).to_equal(0)
        val h1 = handle_alloc(1)
        val h2 = handle_alloc(2)
        expect(handle_pool_size()).to_equal(2)
        handle_free(h1)
        expect(handle_pool_size()).to_equal(1)
        handle_pool_reset()

describe "Handle - slot reuse":
    it "reuses freed slot index":
        handle_pool_new(4)
        val h1 = handle_alloc(100)
        val idx1 = h1.index
        handle_free(h1)
        val h2 = handle_alloc(200)
        val idx2 = h2.index
        expect(idx1).to_equal(idx2)
        expect(handle_deref(h2)).to_equal(200)
        handle_pool_reset()

describe "Handle - stale deref returns -1":
    it "returns -1 for freed handle":
        handle_pool_new(4)
        val h = handle_alloc(5)
        handle_free(h)
        val v = handle_deref(h)
        expect(v).to_equal(-1)
        handle_pool_reset()


# ============================================================================
# UniquePtr Tests
# ============================================================================

describe "Unique - create and get":
    it "creates and reads value":
        unique_reset()
        val p = unique_new(42, "test_val")
        val v = unique_get(p)
        expect(v).to_equal(42)
        expect(unique_is_valid(p)).to_equal(true)
        unique_reset()

describe "Unique - move transfers ownership":
    it "old ptr invalid after move":
        unique_reset()
        val p1 = unique_new(100, "moveable")
        val p2 = unique_move(p1)
        expect(unique_is_valid(p1)).to_equal(false)
        expect(unique_is_valid(p2)).to_equal(true)
        expect(unique_get(p2)).to_equal(100)
        unique_reset()

describe "Unique - moved ptr returns -1":
    it "get on moved returns -1":
        unique_reset()
        val p = unique_new(77, "once")
        val p2 = unique_move(p)
        val v = unique_get(p)
        expect(v).to_equal(-1)
        unique_reset()

describe "Unique - invalidate":
    it "marks as moved":
        unique_reset()
        val p = unique_new(55, "will_invalidate")
        unique_invalidate(p.id)
        expect(unique_is_valid(p)).to_equal(false)
        expect(unique_get(p)).to_equal(-1)
        unique_reset()

describe "Unique - into_inner":
    it "consumes and returns value":
        unique_reset()
        val p = unique_new(33, "consume_me")
        val v = unique_into_inner(p)
        expect(v).to_equal(33)
        expect(unique_is_valid(p)).to_equal(false)
        unique_reset()

describe "Unique - double move":
    it "second move returns invalid":
        unique_reset()
        val p1 = unique_new(10, "double_move")
        val p2 = unique_move(p1)
        val p3 = unique_move(p1)
        expect(p3.id).to_equal(-1)
        unique_reset()


# ============================================================================
# WeakRef Tests
# ============================================================================

describe "Weak - register and upgrade":
    it "creates and dereferences":
        weak_reset()
        val tid = weak_register(42)
        val w = weak_create(tid)
        val v = weak_upgrade(w)
        expect(v).to_equal(42)
        expect(weak_is_alive(w)).to_equal(true)
        weak_reset()

describe "Weak - invalidated target":
    it "returns -1 after invalidation":
        weak_reset()
        val tid = weak_register(99)
        val w = weak_create(tid)
        weak_invalidate(tid)
        val v = weak_upgrade(w)
        expect(v).to_equal(-1)
        expect(weak_is_alive(w)).to_equal(false)
        weak_reset()

describe "Weak - strong count":
    it "tracks add and remove":
        weak_reset()
        val tid = weak_register(10)
        expect(weak_strong_count(tid)).to_equal(1)
        weak_add_strong(tid)
        expect(weak_strong_count(tid)).to_equal(2)
        weak_remove_strong(tid)
        expect(weak_strong_count(tid)).to_equal(1)
        weak_reset()

describe "Weak - auto-invalidate at zero":
    it "invalidates when strong count drops":
        weak_reset()
        val tid = weak_register(50)
        val w = weak_create(tid)
        weak_remove_strong(tid)
        expect(weak_is_alive(w)).to_equal(false)
        expect(weak_upgrade(w)).to_equal(-1)
        weak_reset()

describe "Weak - invalid target_id":
    it "returns invalid ref":
        weak_reset()
        val w = weak_create(-1)
        expect(weak_upgrade(w)).to_equal(-1)
        expect(weak_is_alive(w)).to_equal(false)
        weak_reset()

describe "Weak - multiple refs":
    it "both expire together":
        weak_reset()
        val tid = weak_register(77)
        val w1 = weak_create(tid)
        val w2 = weak_create(tid)
        expect(weak_upgrade(w1)).to_equal(77)
        expect(weak_upgrade(w2)).to_equal(77)
        weak_invalidate(tid)
        expect(weak_upgrade(w1)).to_equal(-1)
        expect(weak_upgrade(w2)).to_equal(-1)
        weak_reset()
