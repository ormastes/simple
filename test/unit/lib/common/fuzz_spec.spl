# # Fuzzing Library Specification
#
#
# **Feature IDs:** Testing Infrastructure
# **Category:** Testing
# **Status:** Prototype
#
# ## Overview
#
# SSpec tests for the `std.testing.fuzz` property-based testing library.
#
# ## Examples
#
# Basic fuzzing with different generators and properties.

import std.spec
import std.testing.fuzz as fuzz

describe "Fuzzing Library":
    context "Integer generator":
        it "generates values in range":
            val generator = fuzz.int(0, 10)
            var all_in_range = true

            for i in 0..100:
                val rng = random.RandomState.new(42 + i)
                val value = generator.generate(rng)
                if value < 0 or value > 10:
                    all_in_range = false

            expect all_in_range

    context "Text generator":
        it "generates strings of correct length":
            val generator = fuzz.text(5, 15)
            val rng = random.RandomState.new(42)

            for i in 0..20:
                val s = generator.generate(rng)
                expect s.len() >= 5
                expect s.len() <= 15

    context "List generator":
        it "generates lists of correct size":
            val item_gen = fuzz.int(0, 100)
            val generator = fuzz.list(item_gen, 3, 10)
            val rng = random.RandomState.new(42)

            for i in 0..20:
                val xs = generator.generate(rng)
                expect xs.len() >= 3
                expect xs.len() <= 10

    context "Property testing":
        it "passes when property always holds":
            fn always_true(x):
                true

            val generator = fuzz.int(0, 100)
            val result = fuzz.fuzz(always_true, generator, 50)

            expect result.is_pass()

        it "fails when property doesn't hold":
            fn always_false(x):
                false

            val generator = fuzz.int(0, 100)
            val result = fuzz.fuzz(always_false, generator, 50)

            expect result.is_fail()

    context "Math properties":
        it "tests addition commutative":
            fn prop_add_commutative(x: i32) -> bool:
                val y = x + 1
                x + y == y + x

            val result = fuzz.fuzz(
                prop_add_commutative,
                fuzz.int(-100, 100),
                100
            )

            expect result.is_pass()

        it "tests multiplication by zero":
            fn prop_mul_zero(x: i32) -> bool:
                x * 0 == 0

            val result = fuzz.fuzz(
                prop_mul_zero,
                fuzz.int(-1000, 1000),
                200
            )

            expect result.is_pass()

    context "String properties":
        it "tests concatenation length":
            fn prop_concat_len(s: text) -> bool:
                val doubled = s + s
                doubled.len() == s.len() * 2

            val result = fuzz.fuzz(
                prop_concat_len,
                fuzz.text(0, 30),
                100
            )

            expect result.is_pass()

    context "List properties":
        it "tests reverse involution":
            fn prop_reverse_involution(xs: List) -> bool:
                val original = xs.clone()
                val reversed_twice = xs.reverse().reverse()
                # Compare element by element
                if original.len() != reversed_twice.len():
                    return false
                for i in 0..original.len():
                    if original[i] != reversed_twice[i]:
                        return false
                true

            val result = fuzz.fuzz(
                prop_reverse_involution,
                fuzz.list(fuzz.int(0, 100), 0, 20),
                100
            )

            expect result.is_pass()

    context "Result API":
        it "provides is_pass()":
            val result = FuzzResult::Pass(iterations: 100)
            expect result.is_pass()

        it "provides is_fail()":
            val result = FuzzResult::Fail(
                input: "test",
                error: "failed",
                iteration: 5
            )
            expect result.is_fail()

        it "provides summary()":
            val pass_result = FuzzResult::Pass(iterations: 100)
            val summary = pass_result.summary()
            expect summary.contains("Passed")
            expect summary.contains("100")
