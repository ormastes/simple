# Data Structure Utilities Module Extended Specification
#
# Comprehensive tests for std.ds_utils module: Stack, Queue, Deque.
# Tests constructors, operations, edge cases, and helper functions.

use std.ds_utils.{Stack, Queue, Deque}
use std.ds_utils.{stack_from_list, queue_from_list, deque_from_list}
use std.ds_utils.{stack_get, queue_get, reverse_stack, merge_queues}

# ============================================================================
# Stack - LIFO
# ============================================================================

describe "Stack creation":

    it "creates empty stack via Stack.create":
        var stack = Stack(items: [])
        val empty = stack.is_empty()
        expect(empty).to_equal(true)
        expect(stack.size()).to_equal(0)

describe "Stack push and pop":

    it "pushes an item onto stack":
        var stack = Stack(items: [])
        stack.push(42)
        expect(stack.size()).to_equal(1)
        val empty = stack.is_empty()
        expect(empty).to_equal(false)

    it "pops items in LIFO order":
        var stack = Stack(items: [])
        stack.push(1)
        stack.push(2)
        stack.push(3)
        val a = stack.pop()
        val b = stack.pop()
        val c = stack.pop()
        expect(a).to_equal(3)
        expect(b).to_equal(2)
        expect(c).to_equal(1)

    it "pop returns nil on empty stack":
        var stack = Stack(items: [])
        val result = stack.pop()
        expect(result).to_be_nil()

    it "push and pop maintain correct size":
        var stack = Stack(items: [])
        stack.push(10)
        stack.push(20)
        expect(stack.size()).to_equal(2)
        stack.pop()
        expect(stack.size()).to_equal(1)
        stack.pop()
        expect(stack.size()).to_equal(0)

describe "Stack peek":

    it "peeks at top element without removing":
        var stack = Stack(items: [])
        stack.push(10)
        stack.push(20)
        val top = stack.peek()
        expect(top).to_equal(20)
        expect(stack.size()).to_equal(2)

    it "peek returns nil on empty stack":
        var stack = Stack(items: [])
        val result = stack.peek()
        expect(result).to_be_nil()

describe "Stack clear":

    it "clears all items":
        var stack = Stack(items: [])
        stack.push(1)
        stack.push(2)
        stack.push(3)
        stack.clear()
        val empty = stack.is_empty()
        expect(empty).to_equal(true)
        expect(stack.size()).to_equal(0)

describe "Stack to_list":

    it "returns internal item list":
        var stack = Stack(items: [])
        stack.push(1)
        stack.push(2)
        stack.push(3)
        val list = stack.to_list()
        expect(list.len()).to_equal(3)
        expect(list[0]).to_equal(1)
        expect(list[1]).to_equal(2)
        expect(list[2]).to_equal(3)

# ============================================================================
# Queue - FIFO
# ============================================================================

describe "Queue creation":

    it "creates empty queue":
        var queue = Queue(items: [])
        val empty = queue.is_empty()
        expect(empty).to_equal(true)
        expect(queue.size()).to_equal(0)

describe "Queue enqueue and dequeue":

    it "enqueues items":
        var queue = Queue(items: [])
        queue.enqueue(10)
        queue.enqueue(20)
        expect(queue.size()).to_equal(2)

    it "dequeues items in FIFO order":
        var queue = Queue(items: [])
        queue.enqueue(1)
        queue.enqueue(2)
        queue.enqueue(3)
        val a = queue.dequeue()
        val b = queue.dequeue()
        val c = queue.dequeue()
        expect(a).to_equal(1)
        expect(b).to_equal(2)
        expect(c).to_equal(3)

    it "dequeue returns nil on empty queue":
        var queue = Queue(items: [])
        val result = queue.dequeue()
        expect(result).to_be_nil()

    it "enqueue and dequeue maintain correct size":
        var queue = Queue(items: [])
        queue.enqueue(10)
        queue.enqueue(20)
        expect(queue.size()).to_equal(2)
        queue.dequeue()
        expect(queue.size()).to_equal(1)
        queue.dequeue()
        expect(queue.size()).to_equal(0)

describe "Queue peek":

    it "peeks at front element without removing":
        var queue = Queue(items: [])
        queue.enqueue(10)
        queue.enqueue(20)
        val front = queue.peek()
        expect(front).to_equal(10)
        expect(queue.size()).to_equal(2)

    it "peek returns nil on empty queue":
        var queue = Queue(items: [])
        val result = queue.peek()
        expect(result).to_be_nil()

describe "Queue clear":

    it "clears all items":
        var queue = Queue(items: [])
        queue.enqueue(1)
        queue.enqueue(2)
        queue.clear()
        val empty = queue.is_empty()
        expect(empty).to_equal(true)

# ============================================================================
# Deque - Double-Ended Queue
# ============================================================================

describe "Deque creation":

    it "creates empty deque":
        var deque = Deque(items: [])
        val empty = deque.is_empty()
        expect(empty).to_equal(true)
        expect(deque.size()).to_equal(0)

describe "Deque push operations":

    it "push_back adds to end":
        var deque = Deque(items: [])
        deque.push_back(1)
        deque.push_back(2)
        val front = deque.peek_front()
        val back = deque.peek_back()
        expect(front).to_equal(1)
        expect(back).to_equal(2)

    it "push_front adds to beginning":
        var deque = Deque(items: [])
        deque.push_front(1)
        deque.push_front(2)
        val front = deque.peek_front()
        val back = deque.peek_back()
        expect(front).to_equal(2)
        expect(back).to_equal(1)

    it "push_front and push_back together":
        var deque = Deque(items: [])
        deque.push_back(2)
        deque.push_front(1)
        deque.push_back(3)
        val front = deque.peek_front()
        val back = deque.peek_back()
        expect(front).to_equal(1)
        expect(back).to_equal(3)
        expect(deque.size()).to_equal(3)

describe "Deque pop operations":

    it "pop_front removes from beginning":
        var deque = Deque(items: [])
        deque.push_back(1)
        deque.push_back(2)
        deque.push_back(3)
        val a = deque.pop_front()
        expect(a).to_equal(1)
        expect(deque.size()).to_equal(2)

    it "pop_back removes from end":
        var deque = Deque(items: [])
        deque.push_back(1)
        deque.push_back(2)
        deque.push_back(3)
        val a = deque.pop_back()
        expect(a).to_equal(3)
        expect(deque.size()).to_equal(2)

    it "pop_front returns nil on empty deque":
        var deque = Deque(items: [])
        val result = deque.pop_front()
        expect(result).to_be_nil()

    it "pop_back returns nil on empty deque":
        var deque = Deque(items: [])
        val result = deque.pop_back()
        expect(result).to_be_nil()

describe "Deque peek operations":

    it "peek_front returns nil on empty deque":
        var deque = Deque(items: [])
        val result = deque.peek_front()
        expect(result).to_be_nil()

    it "peek_back returns nil on empty deque":
        var deque = Deque(items: [])
        val result = deque.peek_back()
        expect(result).to_be_nil()

    it "peek does not modify deque":
        var deque = Deque(items: [])
        deque.push_back(10)
        deque.push_back(20)
        deque.peek_front()
        deque.peek_back()
        expect(deque.size()).to_equal(2)

describe "Deque clear":

    it "clears all items":
        var deque = Deque(items: [])
        deque.push_back(1)
        deque.push_front(0)
        deque.clear()
        val empty = deque.is_empty()
        expect(empty).to_equal(true)

# ============================================================================
# Helper Functions
# ============================================================================

describe "stack_from_list":

    it "creates stack from list of items":
        var stack = stack_from_list([10, 20, 30])
        expect(stack.size()).to_equal(3)
        val top = stack.peek()
        expect(top).to_equal(30)

    it "creates empty stack from empty list":
        var stack = stack_from_list([])
        val empty = stack.is_empty()
        expect(empty).to_equal(true)

describe "queue_from_list":

    it "creates queue from list of items":
        var queue = queue_from_list([10, 20, 30])
        expect(queue.size()).to_equal(3)
        val front = queue.peek()
        expect(front).to_equal(10)

    it "creates empty queue from empty list":
        var queue = queue_from_list([])
        val empty = queue.is_empty()
        expect(empty).to_equal(true)

describe "deque_from_list":

    it "creates deque from list of items":
        var deque = deque_from_list([10, 20, 30])
        expect(deque.size()).to_equal(3)
        val front = deque.peek_front()
        val back = deque.peek_back()
        expect(front).to_equal(10)
        expect(back).to_equal(30)

    it "creates empty deque from empty list":
        var deque = deque_from_list([])
        val empty = deque.is_empty()
        expect(empty).to_equal(true)

describe "stack_get":

    it "gets element by index from top (0 = top)":
        var stack = stack_from_list([10, 20, 30])
        val top = stack_get(stack, 0)
        expect(top).to_equal(30)
        val mid = stack_get(stack, 1)
        expect(mid).to_equal(20)
        val bot = stack_get(stack, 2)
        expect(bot).to_equal(10)

    it "returns nil for out-of-bounds index":
        var stack = stack_from_list([10, 20])
        val result = stack_get(stack, 5)
        expect(result).to_be_nil()

describe "queue_get":

    it "gets element by index from front (0 = front)":
        var queue = queue_from_list([10, 20, 30])
        val front = queue_get(queue, 0)
        expect(front).to_equal(10)
        val mid = queue_get(queue, 1)
        expect(mid).to_equal(20)
        val back = queue_get(queue, 2)
        expect(back).to_equal(30)

    it "returns nil for out-of-bounds index":
        var queue = queue_from_list([10, 20])
        val result = queue_get(queue, 5)
        expect(result).to_be_nil()

describe "reverse_stack":

    it "reverses a stack":
        var stack = stack_from_list([1, 2, 3])
        var reversed = reverse_stack(stack)
        val top = reversed.peek()
        expect(top).to_equal(1)
        val a = reversed.pop()
        expect(a).to_equal(1)
        val b = reversed.pop()
        expect(b).to_equal(2)
        val c = reversed.pop()
        expect(c).to_equal(3)

    it "reversing empty stack returns empty":
        var stack = stack_from_list([])
        var reversed = reverse_stack(stack)
        val empty = reversed.is_empty()
        expect(empty).to_equal(true)

    it "reversing single element returns same":
        var stack = stack_from_list([42])
        var reversed = reverse_stack(stack)
        val top = reversed.peek()
        expect(top).to_equal(42)

describe "merge_queues":

    it "merges two queues":
        var q1 = queue_from_list([1, 2])
        var q2 = queue_from_list([3, 4])
        var merged = merge_queues(q1, q2)
        expect(merged.size()).to_equal(4)
        val a = merged.dequeue()
        val b = merged.dequeue()
        val c = merged.dequeue()
        val d = merged.dequeue()
        expect(a).to_equal(1)
        expect(b).to_equal(2)
        expect(c).to_equal(3)
        expect(d).to_equal(4)

    it "merging with empty queue returns copy":
        var q1 = queue_from_list([1, 2, 3])
        var q2 = queue_from_list([])
        var merged = merge_queues(q1, q2)
        expect(merged.size()).to_equal(3)

    it "merging two empty queues returns empty":
        var q1 = queue_from_list([])
        var q2 = queue_from_list([])
        var merged = merge_queues(q1, q2)
        val empty = merged.is_empty()
        expect(empty).to_equal(true)
