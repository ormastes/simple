# # Numeric Robustness Specification Tests
#
# **Feature IDs:** #NR-001 to #NR-010
# **Category:** Stdlib
# **Status:** In Progress
#
# ## Overview
#
# Tests for the numeric robustness system defined in `doc/spec/numeric_robustness.md`.
# Verifies checked arithmetic, fault detection, saturating operations,
# robust float comparison, tiny canonicalization, and PyTorch interop helpers.
#
# ## Key Concepts
#
# | Concept | Description |
# |---------|-------------|
# | CheckedF64 | Float result that may contain a fault (NaN, Inf, DivByZero, etc.) |
# | CheckedI64 | Integer result that may contain a fault (DivByZero, Overflow, etc.) |
# | Fault | Text tag identifying the numeric hazard that occurred |
# | Saturating | Arithmetic that clamps to min/max on overflow instead of faulting |
# | Dual tolerance | Float comparison using both relative and absolute tolerance |
# | Tiny canonicalization | Flushing subnormal/tiny values to signed zero |
#
# ## Related Specifications
#
# - [Numeric Robustness Spec](../../../doc/spec/numeric_robustness.md)

# Local math helpers (avoid import issues with std.math)
fn math_abs(x: f64) -> f64:
    if x < 0.0:
        return -x
    x

fn math_max(a: f64, b: f64) -> f64:
    if a > b:
        return a
    b

# ============================================================================
# Fault Constants
# ============================================================================

val FAULT_NONE = ""
val FAULT_NAN = "nan"
val FAULT_POSINF = "posinf"
val FAULT_NEGINF = "neginf"
val FAULT_DIVBYZERO = "divbyzero"
val FAULT_OVERFLOW = "overflow"
val FAULT_INVALIDOP = "invalidop"
val FAULT_SHIFT_RANGE = "shift_out_of_range"
val FAULT_INVALID_CAST = "invalid_cast"

# ============================================================================
# Checked Result Types (monomorphic structs)
# ============================================================================

class CheckedF64:
    value: f64
    fault: text

class CheckedI64:
    value: i64
    fault: text

# ============================================================================
# Constructors
# ============================================================================

fn ok_f64(v: f64) -> CheckedF64:
    CheckedF64(value: v, fault: FAULT_NONE)

fn fault_f64(f: text) -> CheckedF64:
    CheckedF64(value: 0.0, fault: f)

fn ok_i64(v: i64) -> CheckedI64:
    CheckedI64(value: v, fault: FAULT_NONE)

fn fault_i64(f: text) -> CheckedI64:
    CheckedI64(value: 0, fault: f)

# ============================================================================
# Predicates
# ============================================================================

fn is_ok_f64(r: CheckedF64) -> bool:
    r.fault == FAULT_NONE

fn is_fault_f64(r: CheckedF64) -> bool:
    r.fault != FAULT_NONE

fn is_ok_i64(r: CheckedI64) -> bool:
    r.fault == FAULT_NONE

fn is_fault_i64(r: CheckedI64) -> bool:
    r.fault != FAULT_NONE

# ============================================================================
# Recovery Helpers
# ============================================================================

fn recover_f64(r: CheckedF64, fallback: f64) -> f64:
    if is_ok_f64(r):
        r.value
    else:
        fallback

fn recover_i64(r: CheckedI64, fallback: i64) -> i64:
    if is_ok_i64(r):
        r.value
    else:
        fallback

# ============================================================================
# Checked Float Operations (Spec Section 7.1)
# ============================================================================

fn checked_div_f64(x: f64, y: f64) -> CheckedF64:
    # Checked float division. Detects 0/0, x/0, and returns fault.
    if y == 0.0:
        if x == 0.0:
            return fault_f64(FAULT_NAN)
        if x > 0.0:
            return fault_f64(FAULT_POSINF)
        return fault_f64(FAULT_NEGINF)
    ok_f64(x / y)

fn checked_sqrt_f64(x: f64) -> CheckedF64:
    # Checked square root. Faults on negative input.
    if x < 0.0:
        return fault_f64(FAULT_INVALIDOP)
    # Use Newton's method for integer-safe sqrt approximation
    if x == 0.0:
        return ok_f64(0.0)
    var guess = x / 2.0
    var i = 0
    while i < 20:
        guess = (guess + x / guess) / 2.0
        i = i + 1
    ok_f64(guess)

fn checked_log_f64(x: f64) -> CheckedF64:
    # Checked natural log. Faults on negative input, -Inf on zero.
    if x < 0.0:
        return fault_f64(FAULT_INVALIDOP)
    if x == 0.0:
        return fault_f64(FAULT_NEGINF)
    # Simple log approximation using series expansion
    # ln(x) = 2 * sum( ((x-1)/(x+1))^(2k+1) / (2k+1) ) for x > 0
    val s = (x - 1.0) / (x + 1.0)
    var result = 0.0
    var term = s
    var k = 0
    while k < 30:
        val denom = 2 * k + 1
        result = result + term / (denom * 1.0)
        term = term * s * s
        k = k + 1
    ok_f64(result * 2.0)

# ============================================================================
# Checked Integer Operations (Spec Section 7.2)
# ============================================================================

val MAX_I64 = 9223372036854775807
val MIN_I64 = -9223372036854775807 - 1

fn checked_div_i64(a: i64, b: i64) -> CheckedI64:
    # Checked integer division. Detects div-by-zero and MIN/-1 overflow.
    if b == 0:
        return fault_i64(FAULT_DIVBYZERO)
    if (a == MIN_I64 and b == -1):
        return fault_i64(FAULT_OVERFLOW)
    ok_i64(a / b)

fn checked_mod_i64(a: i64, b: i64) -> CheckedI64:
    # Checked integer modulo. Detects div-by-zero.
    if b == 0:
        return fault_i64(FAULT_DIVBYZERO)
    ok_i64(a % b)

fn checked_add_i64(a: i64, b: i64) -> CheckedI64:
    # Checked integer addition. Detects overflow in both directions.
    if (a > 0 and b > MAX_I64 - a):
        return fault_i64(FAULT_OVERFLOW)
    if (a < 0 and b < MIN_I64 - a):
        return fault_i64(FAULT_OVERFLOW)
    ok_i64(a + b)

fn checked_sub_i64(a: i64, b: i64) -> CheckedI64:
    # Checked integer subtraction. Detects overflow.
    if (b > 0 and a < MIN_I64 + b):
        return fault_i64(FAULT_OVERFLOW)
    if (b < 0 and a > MAX_I64 + b):
        return fault_i64(FAULT_OVERFLOW)
    ok_i64(a - b)

fn checked_mul_i64(a: i64, b: i64) -> CheckedI64:
    # Checked integer multiplication. Detects overflow via back-division.
    if a == 0 or b == 0:
        return ok_i64(0)
    val result = a * b
    if result / a != b:
        return fault_i64(FAULT_OVERFLOW)
    ok_i64(result)

fn checked_shl_i64(x: i64, k: i64) -> CheckedI64:
    # Checked left shift. Faults if shift amount is negative or >= 64.
    if (k < 0 or k >= 64):
        return fault_i64(FAULT_SHIFT_RANGE)
    ok_i64(x << k)

fn checked_shr_i64(x: i64, k: i64) -> CheckedI64:
    # Checked right shift. Faults if shift amount is negative or >= 64.
    if (k < 0 or k >= 64):
        return fault_i64(FAULT_SHIFT_RANGE)
    ok_i64(x >> k)

# ============================================================================
# Saturating Arithmetic (Spec Section 7.2C)
# ============================================================================

fn saturate_add_i64(a: i64, b: i64) -> i64:
    # Add with saturation: clamps to i64 bounds on overflow.
    if (a > 0 and b > MAX_I64 - a):
        return MAX_I64
    if (a < 0 and b < MIN_I64 - a):
        return MIN_I64
    a + b

fn saturate_sub_i64(a: i64, b: i64) -> i64:
    # Subtract with saturation: clamps to i64 bounds on overflow.
    if (b > 0 and a < MIN_I64 + b):
        return MIN_I64
    if (b < 0 and a > MAX_I64 + b):
        return MAX_I64
    a - b

fn saturate_mul_i64(a: i64, b: i64) -> i64:
    # Multiply with saturation: clamps to i64 bounds on overflow.
    if a == 0 or b == 0:
        return 0
    val result = a * b
    if result / a != b:
        if (a > 0 and b > 0) or (a < 0 and b < 0):
            return MAX_I64
        return MIN_I64
    result

# ============================================================================
# Float Comparison: Dual Tolerance (Spec Section 9)
# ============================================================================

fn float_eq_robust(a: f64, b: f64, rel_tol: f64, abs_tol: f64) -> bool:
    """Robust float comparison using combined relative + absolute tolerance.
    Formula: abs(a-b) <= abs_tol + rel_tol * max(abs(a), abs(b))
    Based on numpy.isclose."""
    if a == b:
        return true
    val diff = math_abs(a - b)
    val max_val = math_max(math_abs(a), math_abs(b))
    diff <= abs_tol + rel_tol * max_val

fn float_eq(a: f64, b: f64) -> bool:
    # Convenience float comparison with common defaults.
    float_eq_robust(a, b, 1e-9, 1e-12)

# ============================================================================
# Tiny Canonicalization (Spec Section 5.3)
# ============================================================================

var TINY_EPS = 1e-20

fn canonicalize_tiny(x: f64) -> f64:
    # Flush tiny values to signed zero under small_like_zero policy.
    if (x > 0.0 and x < TINY_EPS):
        return 0.0
    if (x < 0.0 and x > -TINY_EPS):
        return 0.0
    x

fn canonicalize_tiny_with_eps(x: f64, eps: f64) -> f64:
    # Flush tiny values with custom epsilon.
    if (x > 0.0 and x < eps):
        return 0.0
    if (x < 0.0 and x > -eps):
        return 0.0
    x

# ============================================================================
# PyTorch Interop: nan_to_num (Spec Section 11)
# ============================================================================

fn nan_to_num(x: f64, nan_val: f64, posinf_val: f64, neginf_val: f64) -> f64:
    # Replace fault-producing values. Works on checked results.
    x

fn nan_to_num_checked(r: CheckedF64, nan_val: f64, posinf_val: f64, neginf_val: f64) -> f64:
    # Map a CheckedF64 result to a plain f64 by replacing faults.
    if is_ok_f64(r):
        return r.value
    if r.fault == FAULT_NAN:
        return nan_val
    if r.fault == FAULT_POSINF:
        return posinf_val
    if r.fault == FAULT_NEGINF:
        return neginf_val
    if r.fault == FAULT_DIVBYZERO:
        return nan_val
    if r.fault == FAULT_INVALIDOP:
        return nan_val
    if r.fault == FAULT_OVERFLOW:
        return posinf_val
    nan_val

fn nan_to_num_default(r: CheckedF64) -> f64:
    # Default nan_to_num: NaN->0, +Inf->max, -Inf->min.
    nan_to_num_checked(r, 0.0, 9999999.0, -9999999.0)

# ============================================================================
# Checked Float Conversion (Spec Section 7.1E)
# ============================================================================

fn checked_f64_to_i64(x: f64) -> CheckedI64:
    # Checked float-to-int conversion. Faults on out-of-range values.
    if (x > 9223372036854775807.0 or x < -9223372036854775807.0):
        return fault_i64(FAULT_INVALID_CAST)
    ok_i64(int(x))


# ############################################################################
# TESTS
# ############################################################################

# ============================================================================
# Test Group 1: Checked Float Division (#NR-001)
# ============================================================================

describe "Checked Float Division":
    # ## Float Division Fault Detection
    #
    # Verifies that `checked_div_f64` correctly identifies all IEEE-754
    # division hazards: 0/0 (NaN), positive/0 (+Inf), negative/0 (-Inf),
    # and passes through normal division.

    context "normal division":
        it "divides two positive numbers":
            val r = checked_div_f64(10.0, 2.0)
            expect(is_ok_f64(r)).to_equal(true)
            expect(r.value).to_equal(5.0)

        it "divides negative by positive":
            val r = checked_div_f64(-10.0, 2.0)
            expect(is_ok_f64(r)).to_equal(true)
            expect(r.value).to_equal(-5.0)

        it "divides positive by negative":
            val r = checked_div_f64(10.0, -2.0)
            expect(is_ok_f64(r)).to_equal(true)
            expect(r.value).to_equal(-5.0)

        it "divides zero by nonzero":
            val r = checked_div_f64(0.0, 5.0)
            expect(is_ok_f64(r)).to_equal(true)
            expect(r.value).to_equal(0.0)

        it "divides with fractional result":
            val r = checked_div_f64(1.0, 3.0)
            expect(is_ok_f64(r)).to_equal(true)
            val close = float_eq_robust(r.value, 0.333333, 1e-4, 1e-6)
            expect(close).to_equal(true)

    context "division by zero":
        # ### Scenario: Division by Zero
        #
        # IEEE-754 defines: x/0 = +Inf (x>0), x/0 = -Inf (x<0), 0/0 = NaN.

        it "detects 0/0 as NaN fault":
            val r = checked_div_f64(0.0, 0.0)
            expect(is_fault_f64(r)).to_equal(true)
            expect(r.fault).to_equal(FAULT_NAN)

        it "detects positive/0 as +Inf fault":
            val r = checked_div_f64(1.0, 0.0)
            expect(is_fault_f64(r)).to_equal(true)
            expect(r.fault).to_equal(FAULT_POSINF)

        it "detects large positive/0 as +Inf fault":
            val r = checked_div_f64(999999.0, 0.0)
            expect(is_fault_f64(r)).to_equal(true)
            expect(r.fault).to_equal(FAULT_POSINF)

        it "detects negative/0 as -Inf fault":
            val r = checked_div_f64(-1.0, 0.0)
            expect(is_fault_f64(r)).to_equal(true)
            expect(r.fault).to_equal(FAULT_NEGINF)

        it "detects large negative/0 as -Inf fault":
            val r = checked_div_f64(-999999.0, 0.0)
            expect(is_fault_f64(r)).to_equal(true)
            expect(r.fault).to_equal(FAULT_NEGINF)

# ============================================================================
# Test Group 2: Checked Float Domain Functions (#NR-002)
# ============================================================================

describe "Checked Float Domain Functions":
    # ## Domain-Restricted Float Functions
    #
    # Tests `checked_sqrt_f64` and `checked_log_f64` for correct fault
    # detection on invalid domain inputs (negative sqrt, negative/zero log).

    context "checked sqrt":
        it "computes sqrt of positive number":
            val r = checked_sqrt_f64(4.0)
            expect(is_ok_f64(r)).to_equal(true)
            val close = float_eq_robust(r.value, 2.0, 1e-9, 1e-12)
            expect(close).to_equal(true)

        it "computes sqrt of 1":
            val r = checked_sqrt_f64(1.0)
            expect(is_ok_f64(r)).to_equal(true)
            val close = float_eq_robust(r.value, 1.0, 1e-9, 1e-12)
            expect(close).to_equal(true)

        it "computes sqrt of zero":
            val r = checked_sqrt_f64(0.0)
            expect(is_ok_f64(r)).to_equal(true)
            expect(r.value).to_equal(0.0)

        it "faults on negative input":
            val r = checked_sqrt_f64(-1.0)
            expect(is_fault_f64(r)).to_equal(true)
            expect(r.fault).to_equal(FAULT_INVALIDOP)

        it "faults on large negative input":
            val r = checked_sqrt_f64(-100.0)
            expect(is_fault_f64(r)).to_equal(true)
            expect(r.fault).to_equal(FAULT_INVALIDOP)

    context "checked log":
        it "computes log of positive number":
            val r = checked_log_f64(1.0)
            expect(is_ok_f64(r)).to_equal(true)
            val close = float_eq_robust(r.value, 0.0, 1e-6, 1e-9)
            expect(close).to_equal(true)

        it "computes log of e (approximately 1)":
            val r = checked_log_f64(2.718281828)
            expect(is_ok_f64(r)).to_equal(true)
            val close = float_eq_robust(r.value, 1.0, 1e-4, 1e-6)
            expect(close).to_equal(true)

        it "faults on negative input":
            val r = checked_log_f64(-1.0)
            expect(is_fault_f64(r)).to_equal(true)
            expect(r.fault).to_equal(FAULT_INVALIDOP)

        it "faults on zero (log 0 = -Inf)":
            val r = checked_log_f64(0.0)
            expect(is_fault_f64(r)).to_equal(true)
            expect(r.fault).to_equal(FAULT_NEGINF)

# ============================================================================
# Test Group 3: Checked Integer Division (#NR-003)
# ============================================================================

describe "Checked Integer Division":
    # ## Integer Division Fault Detection
    #
    # Verifies `checked_div_i64` and `checked_mod_i64` detect division by zero
    # and the special MIN_INT / -1 overflow case.

    context "normal division":
        it "divides two positive numbers":
            val r = checked_div_i64(10, 2)
            expect(is_ok_i64(r)).to_equal(true)
            expect(r.value).to_equal(5)

        it "divides negative by positive":
            val r = checked_div_i64(-10, 2)
            expect(is_ok_i64(r)).to_equal(true)
            expect(r.value).to_equal(-5)

        it "divides with remainder truncated":
            val r = checked_div_i64(7, 2)
            expect(is_ok_i64(r)).to_equal(true)
            expect(r.value).to_equal(3)

        it "divides by 1":
            val r = checked_div_i64(42, 1)
            expect(is_ok_i64(r)).to_equal(true)
            expect(r.value).to_equal(42)

        it "divides zero by nonzero":
            val r = checked_div_i64(0, 5)
            expect(is_ok_i64(r)).to_equal(true)
            expect(r.value).to_equal(0)

    context "division by zero":
        it "detects division by zero":
            val r = checked_div_i64(42, 0)
            expect(is_fault_i64(r)).to_equal(true)
            expect(r.fault).to_equal(FAULT_DIVBYZERO)

        it "detects zero divided by zero":
            val r = checked_div_i64(0, 0)
            expect(is_fault_i64(r)).to_equal(true)
            expect(r.fault).to_equal(FAULT_DIVBYZERO)

        it "detects modulo by zero":
            val r = checked_mod_i64(42, 0)
            expect(is_fault_i64(r)).to_equal(true)
            expect(r.fault).to_equal(FAULT_DIVBYZERO)

    context "MIN_INT / -1 overflow":
        # ### Scenario: MIN_INT / -1
        #
        # The result would be MAX_INT + 1, which overflows.
        # This is the only division that can overflow for integers.

        it "detects MIN_INT / -1 as overflow":
            val r = checked_div_i64(MIN_I64, -1)
            expect(is_fault_i64(r)).to_equal(true)
            expect(r.fault).to_equal(FAULT_OVERFLOW)

        it "allows MIN_INT / 1":
            val r = checked_div_i64(MIN_I64, 1)
            expect(is_ok_i64(r)).to_equal(true)
            expect(r.value).to_equal(MIN_I64)

        it "allows MIN_INT / 2":
            val r = checked_div_i64(MIN_I64, 2)
            expect(is_ok_i64(r)).to_equal(true)

# ============================================================================
# Test Group 4: Checked Integer Addition/Subtraction (#NR-004)
# ============================================================================

describe "Checked Integer Addition":
    # ## Integer Overflow Detection
    #
    # Verifies that `checked_add_i64` and `checked_sub_i64` detect overflow
    # in both positive and negative directions.

    context "normal addition":
        it "adds two positive numbers":
            val r = checked_add_i64(3, 4)
            expect(is_ok_i64(r)).to_equal(true)
            expect(r.value).to_equal(7)

        it "adds positive and negative":
            val r = checked_add_i64(10, -3)
            expect(is_ok_i64(r)).to_equal(true)
            expect(r.value).to_equal(7)

        it "adds two negative numbers":
            val r = checked_add_i64(-3, -4)
            expect(is_ok_i64(r)).to_equal(true)
            expect(r.value).to_equal(-7)

        it "adds zero":
            val r = checked_add_i64(42, 0)
            expect(is_ok_i64(r)).to_equal(true)
            expect(r.value).to_equal(42)

    context "positive overflow":
        it "detects MAX + 1 overflow":
            val r = checked_add_i64(MAX_I64, 1)
            expect(is_fault_i64(r)).to_equal(true)
            expect(r.fault).to_equal(FAULT_OVERFLOW)

        it "detects large positive overflow":
            val r = checked_add_i64(MAX_I64, MAX_I64)
            expect(is_fault_i64(r)).to_equal(true)
            expect(r.fault).to_equal(FAULT_OVERFLOW)

        it "allows MAX + 0":
            val r = checked_add_i64(MAX_I64, 0)
            expect(is_ok_i64(r)).to_equal(true)
            expect(r.value).to_equal(MAX_I64)

    context "negative overflow":
        it "detects MIN - 1 overflow":
            val r = checked_add_i64(MIN_I64, -1)
            expect(is_fault_i64(r)).to_equal(true)
            expect(r.fault).to_equal(FAULT_OVERFLOW)

        it "allows MIN + 0":
            val r = checked_add_i64(MIN_I64, 0)
            expect(is_ok_i64(r)).to_equal(true)
            expect(r.value).to_equal(MIN_I64)

    context "subtraction overflow":
        it "normal subtraction":
            val r = checked_sub_i64(10, 3)
            expect(is_ok_i64(r)).to_equal(true)
            expect(r.value).to_equal(7)

        it "detects positive overflow on subtract negative":
            val r = checked_sub_i64(MAX_I64, -1)
            expect(is_fault_i64(r)).to_equal(true)
            expect(r.fault).to_equal(FAULT_OVERFLOW)

        it "detects negative overflow on subtract positive":
            val r = checked_sub_i64(MIN_I64, 1)
            expect(is_fault_i64(r)).to_equal(true)
            expect(r.fault).to_equal(FAULT_OVERFLOW)

# ============================================================================
# Test Group 5: Checked Integer Multiplication (#NR-005)
# ============================================================================

describe "Checked Integer Multiplication":
    # ## Multiplication Overflow Detection
    #
    # Uses back-division (result / a != b) to detect overflow.

    context "normal multiplication":
        it "multiplies two small numbers":
            val r = checked_mul_i64(3, 4)
            expect(is_ok_i64(r)).to_equal(true)
            expect(r.value).to_equal(12)

        it "multiplies by zero":
            val r = checked_mul_i64(MAX_I64, 0)
            expect(is_ok_i64(r)).to_equal(true)
            expect(r.value).to_equal(0)

        it "multiplies zero by large":
            val r = checked_mul_i64(0, MAX_I64)
            expect(is_ok_i64(r)).to_equal(true)
            expect(r.value).to_equal(0)

        it "multiplies by one":
            val r = checked_mul_i64(42, 1)
            expect(is_ok_i64(r)).to_equal(true)
            expect(r.value).to_equal(42)

        it "multiplies by negative one":
            val r = checked_mul_i64(42, -1)
            expect(is_ok_i64(r)).to_equal(true)
            expect(r.value).to_equal(-42)

    context "overflow":
        it "detects MAX * 2 overflow":
            val r = checked_mul_i64(MAX_I64, 2)
            expect(is_fault_i64(r)).to_equal(true)
            expect(r.fault).to_equal(FAULT_OVERFLOW)

        it "detects large factor overflow":
            val r = checked_mul_i64(1000000000, 10000000000)
            expect(is_fault_i64(r)).to_equal(true)
            expect(r.fault).to_equal(FAULT_OVERFLOW)

# ============================================================================
# Test Group 6: Checked Shifts (#NR-006)
# ============================================================================

describe "Checked Bit Shifts":
    # ## Shift Range Validation
    #
    # Verifies that shifts with amounts < 0 or >= 64 are caught as faults.

    context "valid shifts":
        it "shifts left by small amount":
            val r = checked_shl_i64(1, 3)
            expect(is_ok_i64(r)).to_equal(true)
            expect(r.value).to_equal(8)

        it "shifts left by zero":
            val r = checked_shl_i64(42, 0)
            expect(is_ok_i64(r)).to_equal(true)
            expect(r.value).to_equal(42)

        it "shifts right by small amount":
            val r = checked_shr_i64(8, 3)
            expect(is_ok_i64(r)).to_equal(true)
            expect(r.value).to_equal(1)

        it "shifts left by 63 (max valid)":
            val r = checked_shl_i64(1, 63)
            expect(is_ok_i64(r)).to_equal(true)

    context "invalid shifts":
        it "faults on shift left by 64":
            val r = checked_shl_i64(1, 64)
            expect(is_fault_i64(r)).to_equal(true)
            expect(r.fault).to_equal(FAULT_SHIFT_RANGE)

        it "faults on shift left by negative":
            val r = checked_shl_i64(1, -1)
            expect(is_fault_i64(r)).to_equal(true)
            expect(r.fault).to_equal(FAULT_SHIFT_RANGE)

        it "faults on shift right by 100":
            val r = checked_shr_i64(1, 100)
            expect(is_fault_i64(r)).to_equal(true)
            expect(r.fault).to_equal(FAULT_SHIFT_RANGE)

        it "faults on shift left by very large amount":
            val r = checked_shl_i64(1, 1000)
            expect(is_fault_i64(r)).to_equal(true)
            expect(r.fault).to_equal(FAULT_SHIFT_RANGE)

# ============================================================================
# Test Group 7: Saturating Arithmetic (#NR-007)
# ============================================================================

describe "Saturating Arithmetic":
    # ## Zig-Inspired Saturation
    #
    # Saturating operations clamp to MIN/MAX instead of faulting.
    # Returns plain i64, not Checked<i64>, since saturation IS the handling.

    context "saturating addition":
        it "adds normally when no overflow":
            expect(saturate_add_i64(3, 4)).to_equal(7)

        it "clamps to MAX on positive overflow":
            expect(saturate_add_i64(MAX_I64, 1)).to_equal(MAX_I64)

        it "clamps to MAX on large positive overflow":
            expect(saturate_add_i64(MAX_I64, MAX_I64)).to_equal(MAX_I64)

        it "clamps to MIN on negative overflow":
            expect(saturate_add_i64(MIN_I64, -1)).to_equal(MIN_I64)

        it "handles zero addend at MAX":
            expect(saturate_add_i64(MAX_I64, 0)).to_equal(MAX_I64)

        it "handles mixed signs (no overflow)":
            expect(saturate_add_i64(MAX_I64, -1)).to_equal(MAX_I64 - 1)

    context "saturating subtraction":
        it "subtracts normally when no overflow":
            expect(saturate_sub_i64(10, 3)).to_equal(7)

        it "clamps to MIN on negative overflow":
            expect(saturate_sub_i64(MIN_I64, 1)).to_equal(MIN_I64)

        it "clamps to MAX on positive overflow":
            expect(saturate_sub_i64(MAX_I64, -1)).to_equal(MAX_I64)

    context "saturating multiplication":
        it "multiplies normally when no overflow":
            expect(saturate_mul_i64(3, 4)).to_equal(12)

        it "returns zero for zero operand":
            expect(saturate_mul_i64(MAX_I64, 0)).to_equal(0)

        it "clamps to MAX on positive overflow":
            expect(saturate_mul_i64(MAX_I64, 2)).to_equal(MAX_I64)

        it "clamps to MIN on negative overflow":
            expect(saturate_mul_i64(MAX_I64, -2)).to_equal(MIN_I64)

# ============================================================================
# Test Group 8: Float Comparison - Dual Tolerance (#NR-008)
# ============================================================================

describe "Robust Float Comparison":
    # ## Dual Tolerance: Relative + Absolute
    #
    # Formula: abs(a-b) <= abs_tol + rel_tol * max(abs(a), abs(b))
    #
    # Absolute-only fails at large magnitudes. Relative-only fails near zero.
    # Combined formula handles all ranges correctly.

    context "exact equality":
        it "detects identical values":
            expect(float_eq(0.0, 0.0)).to_equal(true)

        it "detects identical integers":
            expect(float_eq(42.0, 42.0)).to_equal(true)

        it "detects identical negative values":
            expect(float_eq(-1.5, -1.5)).to_equal(true)

    context "near-zero comparison":
        # ### Scenario: Values Near Zero
        #
        # Near zero, absolute tolerance dominates.
        # This is where relative-only comparison fails.

        it "treats very small difference as equal":
            expect(float_eq_robust(0.0, 1e-15, 1e-9, 1e-12)).to_equal(true)

        it "treats larger difference as not equal":
            expect(float_eq_robust(0.0, 1.0, 1e-9, 1e-12)).to_equal(false)

        it "treats small negative as close to zero":
            expect(float_eq_robust(0.0, -1e-15, 1e-9, 1e-12)).to_equal(true)

    context "large value comparison":
        # ### Scenario: Large Magnitude Values
        #
        # At large magnitudes, relative tolerance dominates.
        # This is where absolute-only comparison fails.

        it "treats close large values as equal":
            val a = 1000000000.0
            val b = 1000000001.0
            expect(float_eq_robust(a, b, 1e-6, 1e-12)).to_equal(true)

        it "treats distant large values as not equal":
            val a = 1000000000.0
            val b = 1001000000.0
            expect(float_eq_robust(a, b, 1e-6, 1e-12)).to_equal(false)

    context "clearly different values":
        it "detects 1 vs 2 as different":
            expect(float_eq(1.0, 2.0)).to_equal(false)

        it "detects positive vs negative as different":
            expect(float_eq(1.0, -1.0)).to_equal(false)

    context "tolerance parameters":
        it "wider tolerance accepts larger differences":
            expect(float_eq_robust(1.0, 1.1, 0.2, 0.0)).to_equal(true)

        it "tighter tolerance rejects same difference":
            expect(float_eq_robust(1.0, 1.1, 0.01, 0.0)).to_equal(false)

        it "absolute tolerance handles zero case":
            expect(float_eq_robust(0.0, 0.05, 0.0, 0.1)).to_equal(true)

# ============================================================================
# Test Group 9: Tiny Canonicalization (#NR-009)
# ============================================================================

describe "Tiny Canonicalization":
    # ## Small-Like-Zero Policy
    #
    # Under `small_like_zero` mode, values smaller than epsilon
    # in absolute value are flushed to zero. Mirrors FTZ/DAZ hardware behavior.

    context "positive tiny values":
        it "flushes small positive to zero":
            val result = canonicalize_tiny_with_eps(1e-30, 1e-20)
            expect(result).to_equal(0.0)

        it "preserves normal positive":
            val result = canonicalize_tiny_with_eps(1.0, 1e-20)
            expect(result).to_equal(1.0)

        it "preserves value at epsilon boundary":
            val result = canonicalize_tiny_with_eps(1e-10, 1e-20)
            expect(result).to_equal(1e-10)

    context "negative tiny values":
        it "flushes small negative to zero":
            val result = canonicalize_tiny_with_eps(-1e-30, 1e-20)
            expect(result).to_equal(0.0)

        it "preserves normal negative":
            val result = canonicalize_tiny_with_eps(-1.0, 1e-20)
            expect(result).to_equal(-1.0)

    context "zero passthrough":
        it "preserves exact zero":
            val result = canonicalize_tiny_with_eps(0.0, 1e-20)
            expect(result).to_equal(0.0)

    context "custom epsilon":
        it "uses larger epsilon for embedded":
            val result = canonicalize_tiny_with_eps(0.001, 0.01)
            expect(result).to_equal(0.0)

        it "preserves value above larger epsilon":
            val result = canonicalize_tiny_with_eps(0.1, 0.01)
            expect(result).to_equal(0.1)

# ============================================================================
# Test Group 10: nan_to_num and Recovery (#NR-010)
# ============================================================================

describe "Fault Recovery and nan_to_num":
    # ## Recovery Patterns
    #
    # Tests the recovery helpers that convert Checked results back to plain values
    # by mapping faults to specified fallback values. Mirrors PyTorch's nan_to_num.

    context "recover_f64":
        it "passes through valid values":
            val r = ok_f64(42.0)
            expect(recover_f64(r, 0.0)).to_equal(42.0)

        it "returns fallback on fault":
            val r = fault_f64(FAULT_NAN)
            expect(recover_f64(r, -1.0)).to_equal(-1.0)

        it "returns fallback on any fault type":
            val r = fault_f64(FAULT_OVERFLOW)
            expect(recover_f64(r, 99.0)).to_equal(99.0)

    context "recover_i64":
        it "passes through valid values":
            val r = ok_i64(42)
            expect(recover_i64(r, 0)).to_equal(42)

        it "returns fallback on fault":
            val r = fault_i64(FAULT_DIVBYZERO)
            expect(recover_i64(r, -1)).to_equal(-1)

    context "nan_to_num_checked (PyTorch interop)":
        it "passes through valid value":
            val r = ok_f64(3.14)
            val v = nan_to_num_checked(r, 0.0, 9999999.0, -9999999.0)
            val close = float_eq_robust(v, 3.14, 1e-9, 1e-12)
            expect(close).to_equal(true)

        it "maps NaN fault to nan_val":
            val r = fault_f64(FAULT_NAN)
            val v = nan_to_num_checked(r, 0.0, 9999999.0, -9999999.0)
            expect(v).to_equal(0.0)

        it "maps PosInf fault to posinf_val":
            val r = fault_f64(FAULT_POSINF)
            val v = nan_to_num_checked(r, 0.0, 9999999.0, -9999999.0)
            expect(v).to_equal(9999999.0)

        it "maps NegInf fault to neginf_val":
            val r = fault_f64(FAULT_NEGINF)
            val v = nan_to_num_checked(r, 0.0, 9999999.0, -9999999.0)
            expect(v).to_equal(-9999999.0)

        it "maps DivByZero fault to nan_val":
            val r = fault_f64(FAULT_DIVBYZERO)
            val v = nan_to_num_checked(r, 0.0, 9999999.0, -9999999.0)
            expect(v).to_equal(0.0)

    context "nan_to_num_default":
        it "maps NaN to 0":
            val r = fault_f64(FAULT_NAN)
            expect(nan_to_num_default(r)).to_equal(0.0)

        it "maps PosInf to 9999999":
            val r = fault_f64(FAULT_POSINF)
            expect(nan_to_num_default(r)).to_equal(9999999.0)

        it "maps NegInf to -9999999":
            val r = fault_f64(FAULT_NEGINF)
            expect(nan_to_num_default(r)).to_equal(-9999999.0)

    context "composition: checked -> recovery":
        # ### Scenario: End-to-End Pipeline
        #
        # Tests the full workflow: checked operation -> fault detection -> recovery.

        it "recovers from division by zero":
            val r = checked_div_f64(1.0, 0.0)
            val v = recover_f64(r, 0.0)
            expect(v).to_equal(0.0)

        it "preserves normal division result":
            val r = checked_div_f64(10.0, 2.0)
            val v = recover_f64(r, 0.0)
            expect(v).to_equal(5.0)

        it "chains division and nan_to_num":
            val r = checked_div_f64(0.0, 0.0)
            val v = nan_to_num_default(r)
            expect(v).to_equal(0.0)

        it "chains sqrt fault recovery":
            val r = checked_sqrt_f64(-4.0)
            val v = nan_to_num_default(r)
            expect(v).to_equal(0.0)

# ============================================================================
# Test Group 11: Float-to-Int Conversion (#NR-011)
# ============================================================================

describe "Checked Float-to-Int Conversion":
    # ## Type Conversion Safety
    #
    # Verifies `checked_f64_to_i64` catches out-of-range values.

    context "normal conversions":
        it "converts integer-valued float":
            val r = checked_f64_to_i64(42.0)
            expect(is_ok_i64(r)).to_equal(true)
            expect(r.value).to_equal(42)

        it "converts zero":
            val r = checked_f64_to_i64(0.0)
            expect(is_ok_i64(r)).to_equal(true)
            expect(r.value).to_equal(0)

        it "truncates fractional part":
            val r = checked_f64_to_i64(3.7)
            expect(is_ok_i64(r)).to_equal(true)
            expect(r.value).to_equal(3)

        it "converts negative":
            val r = checked_f64_to_i64(-5.0)
            expect(is_ok_i64(r)).to_equal(true)
            expect(r.value).to_equal(-5)

    context "out-of-range conversions":
        it "faults on very large positive":
            val r = checked_f64_to_i64(1e19)
            expect(is_fault_i64(r)).to_equal(true)
            expect(r.fault).to_equal(FAULT_INVALID_CAST)

        it "faults on very large negative":
            val r = checked_f64_to_i64(-1e19)
            expect(is_fault_i64(r)).to_equal(true)
            expect(r.fault).to_equal(FAULT_INVALID_CAST)

# ============================================================================
# Test Group 12: Integration - Multiple Checked Operations (#NR-012)
# ============================================================================

describe "Checked Operation Composition":
    # ## Composing Multiple Checked Operations
    #
    # Tests chaining checked operations where any step can fault,
    # demonstrating the propagation pattern from the spec.

    context "chained float operations":
        it "chains two successful divisions":
            val r1 = checked_div_f64(100.0, 5.0)
            var v1 = recover_f64(r1, 0.0)
            val r2 = checked_div_f64(v1, 4.0)
            var v2 = recover_f64(r2, 0.0)
            expect(v2).to_equal(5.0)

        it "propagates fault from first operation":
            val r1 = checked_div_f64(1.0, 0.0)
            val recovered = recover_f64(r1, 0.0)
            val r2 = checked_div_f64(recovered, 2.0)
            expect(is_ok_f64(r2)).to_equal(true)
            expect(r2.value).to_equal(0.0)

    context "chained integer operations":
        it "chains add and multiply":
            val r1 = checked_add_i64(10, 20)
            val v1 = recover_i64(r1, 0)
            val r2 = checked_mul_i64(v1, 3)
            expect(is_ok_i64(r2)).to_equal(true)
            expect(r2.value).to_equal(90)

        it "detects overflow in chain":
            val r1 = checked_add_i64(MAX_I64, 0)
            val v1 = recover_i64(r1, 0)
            val r2 = checked_add_i64(v1, 1)
            expect(is_fault_i64(r2)).to_equal(true)
            expect(r2.fault).to_equal(FAULT_OVERFLOW)

    context "mixed float and int":
        it "converts checked float to checked int":
            val r1 = checked_div_f64(10.0, 3.0)
            val v = recover_f64(r1, 0.0)
            val r2 = checked_f64_to_i64(v)
            expect(is_ok_i64(r2)).to_equal(true)
            expect(r2.value).to_equal(3)
