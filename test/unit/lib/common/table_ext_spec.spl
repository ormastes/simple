# Table (DataFrame) Module Extended Specification
#
# Tests for std.table module logic.
# Since the module uses Dict<text, Column> generics not supported by runtime,
# we test inline implementations of Column and Table operations.

# ============================================================================
# Inline Column implementation (mirroring std.table)
# ============================================================================

fn column_create(col_name: text, col_data) -> dict:
    {"name": col_name, "data": col_data}

fn column_len(col: dict) -> i64:
    col["data"].len()

fn column_get(col: dict, idx: i64):
    col["data"][idx]

fn column_sum(col: dict) -> f64:
    var total = 0.0
    for item in col["data"]:
        total = total + item
    total

fn column_mean(col: dict) -> f64:
    if col["data"].len() == 0:
        return 0.0
    column_sum(col) / col["data"].len()

fn column_min(col: dict):
    val data = col["data"]
    if data.len() == 0:
        return nil
    var best = data[0]
    var i = 1
    while i < data.len():
        if data[i] < best:
            best = data[i]
        i = i + 1
    best

fn column_max(col: dict):
    val data = col["data"]
    if data.len() == 0:
        return nil
    var best = data[0]
    var i = 1
    while i < data.len():
        if data[i] > best:
            best = data[i]
        i = i + 1
    best

fn column_unique(col: dict):
    var seen = {}
    var result = []
    for item in col["data"]:
        val key = "{item}"
        if not seen.contains_key(key):
            seen[key] = true
            result.push(item)
    result

fn column_value_counts(col: dict) -> dict:
    var counts = {}
    for item in col["data"]:
        val key = "{item}"
        if counts.contains_key(key):
            counts[key] = counts[key] + 1
        else:
            counts[key] = 1
    counts

# ============================================================================
# Inline Table implementation (mirroring std.table)
# ============================================================================

fn table_empty() -> dict:
    {"columns": {}, "column_names": [], "num_rows": 0}

fn table_from_columns(cols) -> dict:
    var table_cols = {}
    var names = []
    var rows = 0
    for col in cols:
        table_cols[col["name"]] = col
        names.push(col["name"])
        if rows == 0:
            rows = col["data"].len()
    {"columns": table_cols, "column_names": names, "num_rows": rows}

fn table_get(table: dict, col_name: text):
    if table["columns"].contains_key(col_name):
        table["columns"][col_name]
    else:
        nil

fn table_col_index(table: dict, col_name: text) -> i64:
    var i = 0
    while i < table["column_names"].len():
        if table["column_names"][i] == col_name:
            return i
        i = i + 1
    -1

fn table_select(table: dict, col_names) -> dict:
    var new_cols = []
    for col_name in col_names:
        if table["columns"].contains_key(col_name):
            new_cols.push(table["columns"][col_name])
    table_from_columns(new_cols)

fn table_drop(table: dict, col_names) -> dict:
    var keep_names = []
    for col_name in table["column_names"]:
        var should_keep = true
        for drop_name in col_names:
            if col_name == drop_name:
                should_keep = false
        if should_keep:
            keep_names.push(col_name)
    table_select(table, keep_names)

fn table_with_column(table: dict, col_name: text, values) -> dict:
    if values.len() != table["num_rows"]:
        return table
    var new_col_names = []
    for n in table["column_names"]:
        new_col_names.push(n)
    new_col_names.push(col_name)
    var new_cols = {}
    for (k, v) in table["columns"]:
        new_cols[k] = v
    new_cols[col_name] = {"name": col_name, "data": values}
    {"columns": new_cols, "column_names": new_col_names, "num_rows": table["num_rows"]}

# ============================================================================
# Column Tests
# ============================================================================

describe "column_create":

    it "creates a column with name and data":
        val col = column_create("age", [25, 30, 35])
        expect(col["name"]).to_equal("age")
        expect(col["data"].len()).to_equal(3)

    it "creates empty column":
        val col = column_create("empty", [])
        expect(col["name"]).to_equal("empty")
        expect(col["data"].len()).to_equal(0)

describe "column_len":

    it "returns length of column":
        val col = column_create("x", [1, 2, 3, 4, 5])
        expect(column_len(col)).to_equal(5)

    it "returns 0 for empty column":
        val col = column_create("x", [])
        expect(column_len(col)).to_equal(0)

describe "column_get":

    it "gets value by index":
        val col = column_create("x", [10, 20, 30])
        expect(column_get(col, 0)).to_equal(10)
        expect(column_get(col, 1)).to_equal(20)
        expect(column_get(col, 2)).to_equal(30)

describe "column_sum":

    it "sums integer values":
        val col = column_create("x", [1, 2, 3, 4, 5])
        var result = column_sum(col)
        expect(result).to_equal(15.0)

    it "sums to 0 for empty column":
        val col = column_create("x", [])
        var result = column_sum(col)
        expect(result).to_equal(0.0)

describe "column_mean":

    it "computes mean of values":
        val col = column_create("x", [2, 4, 6])
        var result = column_mean(col)
        expect(result).to_equal(4.0)

    it "returns 0 for empty column":
        val col = column_create("x", [])
        var result = column_mean(col)
        expect(result).to_equal(0.0)

    it "computes mean of single value":
        val col = column_create("x", [10])
        var result = column_mean(col)
        expect(result).to_equal(10.0)

describe "column_min":

    it "finds minimum value":
        val col = column_create("x", [5, 3, 8, 1, 4])
        var result = column_min(col)
        expect(result).to_equal(1)

    it "returns nil for empty column":
        val col = column_create("x", [])
        var result = column_min(col)
        expect(result).to_be_nil()

    it "works with single element":
        val col = column_create("x", [42])
        var result = column_min(col)
        expect(result).to_equal(42)

describe "column_max":

    it "finds maximum value":
        val col = column_create("x", [5, 3, 8, 1, 4])
        var result = column_max(col)
        expect(result).to_equal(8)

    it "returns nil for empty column":
        val col = column_create("x", [])
        var result = column_max(col)
        expect(result).to_be_nil()

    it "works with single element":
        val col = column_create("x", [42])
        var result = column_max(col)
        expect(result).to_equal(42)

describe "column_unique":

    it "returns unique values":
        val col = column_create("x", [1, 2, 2, 3, 3, 3])
        var result = column_unique(col)
        expect(result.len()).to_equal(3)

    it "preserves order":
        val col = column_create("x", [3, 1, 2, 1, 3])
        var result = column_unique(col)
        expect(result[0]).to_equal(3)
        expect(result[1]).to_equal(1)
        expect(result[2]).to_equal(2)

    it "handles empty column":
        val col = column_create("x", [])
        var result = column_unique(col)
        expect(result.len()).to_equal(0)

    it "handles all unique values":
        val col = column_create("x", [10, 20, 30])
        var result = column_unique(col)
        expect(result.len()).to_equal(3)

describe "column_value_counts":

    it "counts value occurrences":
        val col = column_create("x", ["a", "b", "a", "c", "b", "a"])
        val counts = column_value_counts(col)
        expect(counts["a"]).to_equal(3)
        expect(counts["b"]).to_equal(2)
        expect(counts["c"]).to_equal(1)

    it "handles single unique value":
        val col = column_create("x", [5, 5, 5])
        val counts = column_value_counts(col)
        expect(counts["5"]).to_equal(3)

    it "handles empty column":
        val col = column_create("x", [])
        val counts = column_value_counts(col)
        val count = 0
        for (k, v) in counts:
            pass
        expect(count).to_equal(0)

# ============================================================================
# Table Tests
# ============================================================================

describe "table_empty":

    it "creates table with no columns":
        val table = table_empty()
        expect(table["column_names"].len()).to_equal(0)
        expect(table["num_rows"]).to_equal(0)

describe "table_from_columns":

    it "creates table from columns":
        val col1 = column_create("name", ["Alice", "Bob", "Charlie"])
        val col2 = column_create("age", [25, 30, 35])
        val table = table_from_columns([col1, col2])
        expect(table["column_names"].len()).to_equal(2)
        expect(table["num_rows"]).to_equal(3)

    it "creates table from single column":
        val col = column_create("x", [1, 2, 3])
        val table = table_from_columns([col])
        expect(table["column_names"].len()).to_equal(1)
        expect(table["num_rows"]).to_equal(3)

    it "creates empty table from no columns":
        val table = table_from_columns([])
        expect(table["column_names"].len()).to_equal(0)
        expect(table["num_rows"]).to_equal(0)

describe "table_get":

    it "gets column by name":
        val col1 = column_create("x", [1, 2, 3])
        val col2 = column_create("y", [4, 5, 6])
        val table = table_from_columns([col1, col2])
        val found = table_get(table, "x")
        expect(found["name"]).to_equal("x")
        expect(found["data"][0]).to_equal(1)

    it "returns nil for non-existent column":
        val col = column_create("x", [1, 2])
        val table = table_from_columns([col])
        val found = table_get(table, "z")
        expect(found).to_be_nil()

describe "table_col_index":

    it "returns index of existing column":
        val col1 = column_create("a", [1])
        val col2 = column_create("b", [2])
        val col3 = column_create("c", [3])
        val table = table_from_columns([col1, col2, col3])
        expect(table_col_index(table, "a")).to_equal(0)
        expect(table_col_index(table, "b")).to_equal(1)
        expect(table_col_index(table, "c")).to_equal(2)

    it "returns -1 for non-existent column":
        val col = column_create("a", [1])
        val table = table_from_columns([col])
        expect(table_col_index(table, "z")).to_equal(-1)

describe "table_select":

    it "selects specific columns":
        val col1 = column_create("a", [1, 2])
        val col2 = column_create("b", [3, 4])
        val col3 = column_create("c", [5, 6])
        val table = table_from_columns([col1, col2, col3])
        val selected = table_select(table, ["a", "c"])
        expect(selected["column_names"].len()).to_equal(2)
        expect(selected["column_names"][0]).to_equal("a")
        expect(selected["column_names"][1]).to_equal("c")

    it "returns empty table for non-existent columns":
        val col = column_create("a", [1, 2])
        val table = table_from_columns([col])
        val selected = table_select(table, ["x", "y"])
        expect(selected["column_names"].len()).to_equal(0)

describe "table_drop":

    it "drops specified columns":
        val col1 = column_create("a", [1, 2])
        val col2 = column_create("b", [3, 4])
        val col3 = column_create("c", [5, 6])
        val table = table_from_columns([col1, col2, col3])
        val dropped = table_drop(table, ["b"])
        expect(dropped["column_names"].len()).to_equal(2)
        expect(dropped["column_names"][0]).to_equal("a")
        expect(dropped["column_names"][1]).to_equal("c")

    it "returns same table when dropping non-existent column":
        val col = column_create("a", [1, 2])
        val table = table_from_columns([col])
        val dropped = table_drop(table, ["x"])
        expect(dropped["column_names"].len()).to_equal(1)
        expect(dropped["column_names"][0]).to_equal("a")

describe "table_with_column":

    it "adds a new column":
        val col = column_create("a", [1, 2, 3])
        val table = table_from_columns([col])
        val updated = table_with_column(table, "b", [4, 5, 6])
        expect(updated["column_names"].len()).to_equal(2)
        val new_col = updated["columns"]["b"]
        expect(new_col["data"][0]).to_equal(4)
        expect(new_col["data"][2]).to_equal(6)

    it "rejects column with wrong length":
        val col = column_create("a", [1, 2, 3])
        val table = table_from_columns([col])
        val updated = table_with_column(table, "b", [4, 5])
        # Should return original table unchanged
        expect(updated["column_names"].len()).to_equal(1)
