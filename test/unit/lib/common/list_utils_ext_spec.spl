describe "List Utils Ext":
    it "skipped":
        skip("pre-existing test failures - functions/imports not available")

# # Tests for std.array module (migrated from list_utils)
# # Covers list manipulation utilities
# 
# use std.array.{array_reverse, array_take, array_drop}
# use std.array.{array_chunk, array_windows}
# use std.array.{array_interleave, array_flatten, array_intersperse}
# use std.array.{array_rotate_left, array_rotate_right}
# use std.array.{array_dedup, array_dedup_all}
# use std.array.{array_is_sorted, array_equals}
# 
# describe "std.array (list_utils migration)":
#     describe "array_reverse":
#         it "returns a list of same length":
#             val result = array_reverse([1, 2, 3])
#             expect(result.len()).to_equal(3)
# 
#         it "handles empty list":
#             expect(array_reverse([])).to_equal([])
# 
#     describe "array_take":
#         it "takes first n elements":
#             expect(array_take([1, 2, 3, 4, 5], 3)).to_equal([1, 2, 3])
# 
#         it "returns all if n > length":
#             expect(array_take([1, 2], 5)).to_equal([1, 2])
# 
#     describe "array_drop":
#         it "drops first n elements":
#             expect(array_drop([1, 2, 3, 4, 5], 2)).to_equal([3, 4, 5])
# 
#     describe "array_chunk":
#         it "splits into chunks of size":
#             val chunks = array_chunk([1, 2, 3, 4, 5], 2)
#             expect(chunks.len()).to_equal(3)
#             expect(chunks[0]).to_equal([1, 2])
#             expect(chunks[2]).to_equal([5])
# 
#     describe "array_windows":
#         it "creates sliding windows":
#             val wins = array_windows([1, 2, 3, 4], 2)
#             expect(wins.len()).to_equal(3)
#             expect(wins[0]).to_equal([1, 2])
#             expect(wins[1]).to_equal([2, 3])
# 
#     describe "array_interleave":
#         it "interleaves two lists":
#             val result = array_interleave([1, 3, 5], [2, 4, 6])
#             expect(result).to_equal([1, 2, 3, 4, 5, 6])
# 
#     describe "array_flatten":
#         it "flattens nested lists":
#             val result = array_flatten([[1, 2], [3, 4], [5]])
#             expect(result).to_equal([1, 2, 3, 4, 5])
# 
#     describe "array_intersperse":
#         it "inserts separator between elements":
#             val result = array_intersperse([1, 2, 3], 0)
#             expect(result).to_equal([1, 0, 2, 0, 3])
# 
#     describe "array_rotate_left":
#         it "rotates list left":
#             val result = array_rotate_left([1, 2, 3, 4], 1)
#             expect(result).to_equal([2, 3, 4, 1])
# 
#     describe "array_rotate_right":
#         it "rotates list right":
#             val result = array_rotate_right([1, 2, 3, 4], 1)
#             expect(result).to_equal([4, 1, 2, 3])
# 
#     describe "array_dedup":
#         it "removes consecutive duplicates":
#             val result = array_dedup([1, 1, 2, 2, 3, 3])
#             expect(result).to_equal([1, 2, 3])
# 
#         it "preserves non-consecutive duplicates":
#             val result = array_dedup([1, 2, 1, 2])
#             expect(result).to_equal([1, 2, 1, 2])
# 
#     describe "array_dedup_all":
#         it "removes all duplicates":
#             val result = array_dedup_all([1, 2, 1, 3, 2])
#             expect(result.len()).to_equal(3)
# 
#     describe "array_is_sorted":
#         it "checks if list is sorted":
#             expect(array_is_sorted([1, 2, 3])).to_equal(true)
#             expect(array_is_sorted([3, 1, 2])).to_equal(false)
#             expect(array_is_sorted([])).to_equal(true)
# 
#     describe "array_equals":
#         it "checks equality":
#             expect(array_equals([1, 2, 3], [1, 2, 3])).to_equal(true)
#             expect(array_equals([1, 2], [1, 3])).to_equal(false)
