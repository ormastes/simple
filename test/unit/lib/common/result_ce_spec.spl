# ResultCE builder spec
#
# Tests for src/lib/result_ce.spl
# Result computation expression builder - monadic nil-as-error propagation.

use std.result_ce.{
    result_ce_bind, result_ce_return, result_ce_zero,
    result_ce_combine, result_ce_map, result_ce_for
}

describe "ResultCE builder":
    describe "result_ce_zero":
        it "returns nil":
            expect(result_ce_zero()).to_be_nil()

    describe "result_ce_return":
        it "returns integer value unchanged":
            expect(result_ce_return(42)).to_equal(42)

        it "returns text value unchanged":
            expect(result_ce_return("ok")).to_equal("ok")

        it "returns zero unchanged":
            expect(result_ce_return(0)).to_equal(0)

    describe "result_ce_bind":
        it "calls continuation on non-nil value":
            val result = result_ce_bind("hello", fn(v):
                "got: {v}"
            )
            expect(result).to_equal("got: hello")

        it "short-circuits on nil":
            val result = result_ce_bind(nil, fn(v):
                "should not reach"
            )
            expect(result).to_be_nil()

        it "passes integer to continuation":
            val result = result_ce_bind(10, fn(n):
                n + 5
            )
            expect(result).to_equal(15)

        it "chains two successful binds":
            val result = result_ce_bind("a", fn(x):
                result_ce_bind("b", fn(y):
                    "{x}{y}"
                )
            )
            expect(result).to_equal("ab")

        it "chain short-circuits when first is nil":
            val result = result_ce_bind(nil, fn(x):
                result_ce_bind("b", fn(y):
                    "{x}{y}"
                )
            )
            expect(result).to_be_nil()

        it "chain short-circuits when second is nil":
            val result = result_ce_bind("a", fn(x):
                result_ce_bind(nil, fn(y):
                    "{x}{y}"
                )
            )
            expect(result).to_be_nil()

        it "chains three levels successfully":
            val result = result_ce_bind("x", fn(a):
                result_ce_bind("y", fn(b):
                    result_ce_bind("z", fn(c):
                        "{a}{b}{c}"
                    )
                )
            )
            expect(result).to_equal("xyz")

        it "chain short-circuits at middle nil":
            val result = result_ce_bind("x", fn(a):
                result_ce_bind(nil, fn(b):
                    result_ce_bind("z", fn(c):
                        "{a}{b}{c}"
                    )
                )
            )
            expect(result).to_be_nil()

    describe "result_ce_map":
        it "transforms a non-nil text value":
            val result = result_ce_map("hello", fn(v):
                v.len()
            )
            expect(result).to_equal(5)

        it "transforms a non-nil integer value":
            val result = result_ce_map(7, fn(n):
                n * 3
            )
            expect(result).to_equal(21)

        it "passes through nil":
            val result = result_ce_map(nil, fn(v):
                "transformed"
            )
            expect(result).to_be_nil()

        it "can be chained with bind":
            val bound = result_ce_bind("hello", fn(v): v)
            val result = result_ce_map(bound, fn(v):
                v.len()
            )
            expect(result).to_equal(5)

    describe "result_ce_combine":
        it "returns result of second when first succeeds":
            val result = result_ce_combine("first", fn():
                "second"
            )
            expect(result).to_equal("second")

        it "short-circuits when first is nil":
            val result = result_ce_combine(nil, fn():
                "second"
            )
            expect(result).to_be_nil()

        it "returns integer second when first succeeds":
            val result = result_ce_combine("ok", fn():
                42
            )
            expect(result).to_equal(42)

        it "returns nil when second thunk returns nil":
            val result = result_ce_combine("first", fn():
                nil
            )
            expect(result).to_be_nil()

    describe "result_ce_for":
        it "returns nil after iterating empty array":
            val result = result_ce_for([], fn(item):
                item
            )
            expect(result).to_be_nil()

        it "returns nil after iterating array where body returns non-nil":
            val result = result_ce_for(["a", "b", "c"], fn(item):
                item
            )
            expect(result).to_be_nil()

        it "short-circuits when body returns nil on first element":
            var count = 0
            val result = result_ce_for(["a", "b", "c"], fn(item):
                count = count + 1
                nil
            )
            expect(result).to_be_nil()

        it "returns nil when body never returns nil":
            val result = result_ce_for(["x", "y"], fn(item):
                "processed: {item}"
            )
            expect(result).to_be_nil()

    describe "composition patterns":
        it "bind then map succeeds":
            val bound = result_ce_bind("hello", fn(v): v)
            val result = result_ce_map(bound, fn(v):
                v.len()
            )
            expect(result).to_equal(5)

        it "map after nil bind returns nil":
            val bound = result_ce_bind(nil, fn(v): v)
            val result = result_ce_map(bound, fn(v):
                "should not reach"
            )
            expect(result).to_be_nil()

        it "combine after successful bind executes second":
            val bound = result_ce_bind("first", fn(v): v)
            val result = result_ce_combine(bound, fn():
                "combined"
            )
            expect(result).to_equal("combined")
