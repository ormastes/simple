# Bulk Collection Operations Specification
#
# Tests for map_join, filter_map_join, map_to_text, enumerate_join
#
# Note: uses inline function definitions because use std.functions.{...}
# does not resolve in interpreter mode (known limitation).

fn map_join(arr, f, sep: text) -> text:
    var parts: [text] = []
    for item in arr:
        parts.push(f(item))
    parts.join(sep)

fn filter_map_join(arr, pred, f, sep: text) -> text:
    var parts: [text] = []
    for item in arr:
        if pred(item):
            parts.push(f(item))
    parts.join(sep)

fn map_to_text(arr, f) -> text:
    var parts: [text] = []
    for item in arr:
        parts.push(f(item))
    parts.join("")

fn enumerate_join(arr, f, sep: text) -> text:
    var parts: [text] = []
    for i in 0..arr.len():
        parts.push(f(arr[i], i))
    parts.join(sep)

# ============================================================================
# Test Group 1: map_join
# ============================================================================

describe "map_join":
    it "maps and joins with separator":
        val result = map_join([1, 2, 3], \x: "{x}", ", ")
        expect(result).to_equal("1, 2, 3")

    it "handles empty array":
        val result = map_join([], \x: "{x}", ", ")
        expect(result).to_equal("")

    it "handles single element":
        val result = map_join([42], \x: "num={x}", ", ")
        expect(result).to_equal("num=42")

    it "works with transform function":
        val result = map_join([1, 2, 3], \x: "{x * 10}", "-")
        expect(result).to_equal("10-20-30")

# ============================================================================
# Test Group 2: filter_map_join
# ============================================================================

describe "filter_map_join":
    it "filters then maps then joins":
        val result = filter_map_join([1, 2, 3, 4, 5], \x: x > 2, \x: "{x}", ", ")
        expect(result).to_equal("3, 4, 5")

    it "handles all filtered out":
        val result = filter_map_join([1, 2, 3], \x: x > 10, \x: "{x}", ", ")
        expect(result).to_equal("")

    it "handles none filtered out":
        val result = filter_map_join([1, 2], \x: x > 0, \x: "v{x}", "+")
        expect(result).to_equal("v1+v2")

# ============================================================================
# Test Group 3: map_to_text
# ============================================================================

describe "map_to_text":
    it "maps and concatenates without separator":
        val result = map_to_text([1, 2, 3], \x: "{x}")
        expect(result).to_equal("123")

    it "handles empty array":
        val result = map_to_text([], \x: "{x}")
        expect(result).to_equal("")

    it "works with text transform":
        val result = map_to_text(["a", "b", "c"], \x: "[{x}]")
        expect(result).to_equal("[a][b][c]")

# ============================================================================
# Test Group 4: enumerate_join
# ============================================================================

describe "enumerate_join":
    it "provides element and index":
        val result = enumerate_join(["a", "b", "c"], \elem, i: "{i}:{elem}", ", ")
        expect(result).to_equal("0:a, 1:b, 2:c")

    it "handles empty array":
        val result = enumerate_join([], \elem, i: "{i}:{elem}", ", ")
        expect(result).to_equal("")

    it "handles single element":
        val result = enumerate_join(["only"], \elem, i: "{i}={elem}", ", ")
        expect(result).to_equal("0=only")
