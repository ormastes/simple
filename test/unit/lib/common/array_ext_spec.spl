describe "Array Ext":
    it "skipped":
        skip("pre-existing test failures - functions/imports not available")

# # Tests for std.array module
# # Covers all exported functions from src/lib/array.spl
# 
# use std.array.{array_position, array_find, array_find_or}
# use std.array.{array_enumerate, array_zip, array_chunk}
# use std.array.{array_flat_map, array_take_while, array_drop_while}
# use std.array.{array_count, array_any, array_all}
# use std.array.{array_sum, array_max, array_min}
# use std.array.{array_range, array_repeat, array_append_all}
# use std.array.{array_partition, array_concat, array_flatten}
# use std.array.{array_uniq, array_compact, array_reverse}
# 
# describe "std.array":
#     describe "array_position":
#         it "finds index of matching element":
#             val idx = array_position([10, 20, 30], fn(x): x == 20)
#             expect(idx).to_equal(1)
# 
#         it "returns -1 when not found":
#             val idx = array_position([10, 20, 30], fn(x): x == 99)
#             expect(idx).to_equal(-1)
# 
#     describe "array_find":
#         it "finds first matching element":
#             val found = array_find([10, 20, 30], fn(x): x > 15)
#             expect(found).to_equal(20)
# 
#         it "returns nil when not found":
#             val found = array_find([10, 20, 30], fn(x): x > 100)
#             expect(found).to_be_nil()
# 
#     describe "array_find_or":
#         it "finds element or returns default":
#             val found = array_find_or([10, 20, 30], fn(x): x > 100, -1)
#             expect(found).to_equal(-1)
# 
#         it "finds element when present":
#             val found = array_find_or([10, 20, 30], fn(x): x > 15, -1)
#             expect(found).to_equal(20)
# 
#     describe "array_enumerate":
#         it "returns index-value pairs":
#             val pairs = array_enumerate(["a", "b", "c"])
#             expect(pairs.len()).to_equal(3)
# 
#     describe "array_zip":
#         it "zips two arrays":
#             val zipped = array_zip([1, 2, 3], ["a", "b", "c"])
#             expect(zipped.len()).to_equal(3)
# 
#         it "truncates to shorter length":
#             val zipped = array_zip([1, 2], ["a", "b", "c"])
#             expect(zipped.len()).to_equal(2)
# 
#     describe "array_chunk":
#         it "splits into chunks":
#             val chunks = array_chunk([1, 2, 3, 4, 5], 2)
#             expect(chunks.len()).to_equal(3)
# 
#     describe "array_flat_map":
#         it "maps and flattens":
#             val result = array_flat_map([1, 2, 3], fn(x): [x, x * 10])
#             expect(result.len()).to_equal(6)
#             expect(result[0]).to_equal(1)
#             expect(result[1]).to_equal(10)
# 
#     describe "array_take_while":
#         it "takes elements while predicate is true":
#             val result = array_take_while([1, 2, 3, 4, 5], fn(x): x < 4)
#             expect(result.len()).to_equal(3)
#             expect(result[0]).to_equal(1)
#             expect(result[2]).to_equal(3)
# 
#     describe "array_drop_while":
#         it "drops elements while predicate is true":
#             val result = array_drop_while([1, 2, 3, 4, 5], fn(x): x < 4)
#             expect(result.len()).to_equal(2)
#             expect(result[0]).to_equal(4)
# 
#     describe "array_count":
#         it "counts matching elements":
#             val n = array_count([1, 2, 3, 4, 5], fn(x): x > 3)
#             expect(n).to_equal(2)
# 
#     describe "array_any":
#         it "returns true if any match":
#             expect(array_any([1, 2, 3], fn(x): x > 2)).to_equal(true)
# 
#         it "returns false if none match":
#             expect(array_any([1, 2, 3], fn(x): x > 10)).to_equal(false)
# 
#     describe "array_all":
#         it "returns true if all match":
#             expect(array_all([2, 4, 6], fn(x): x > 0)).to_equal(true)
# 
#         it "returns false if any fails":
#             expect(array_all([2, 4, 6], fn(x): x > 3)).to_equal(false)
# 
#     describe "array_sum":
#         it "sums numeric array":
#             expect(array_sum([1, 2, 3, 4, 5])).to_equal(15)
# 
#         it "returns 0 for empty array":
#             expect(array_sum([])).to_equal(0)
# 
#     describe "array_max":
#         it "finds maximum element":
#             val m = array_max([3, 1, 4, 1, 5])
#             expect(m).to_equal(5)
# 
#         it "returns nil for empty array":
#             val m = array_max([])
#             expect(m).to_be_nil()
# 
#     describe "array_min":
#         it "finds minimum element":
#             val m = array_min([3, 1, 4, 1, 5])
#             expect(m).to_equal(1)
# 
#         it "returns nil for empty array":
#             val m = array_min([])
#             expect(m).to_be_nil()
# 
#     describe "array_range":
#         it "creates range array":
#             val r = array_range(0, 5)
#             expect(r.len()).to_equal(5)
#             expect(r[0]).to_equal(0)
#             expect(r[4]).to_equal(4)
# 
#         it "handles empty range":
#             val r = array_range(5, 5)
#             expect(r.len()).to_equal(0)
# 
#     describe "array_repeat":
#         it "creates array of repeated values":
#             val r = array_repeat("x", 3)
#             expect(r.len()).to_equal(3)
#             expect(r[0]).to_equal("x")
#             expect(r[2]).to_equal("x")
# 
#     describe "array_append_all":
#         it "concatenates two arrays":
#             val result = array_append_all([1, 2], [3, 4])
#             expect(result.len()).to_equal(4)
#             expect(result[2]).to_equal(3)
# 
#     describe "array_partition":
#         it "splits by predicate":
#             val parts = array_partition([1, 2, 3, 4, 5], fn(x): x > 3)
#             expect(parts.len()).to_equal(2)
# 
#     describe "array_concat":
#         it "concatenates multiple arrays":
#             val result = array_concat([[1, 2], [3, 4], [5]])
#             expect(result.len()).to_equal(5)
# 
#     describe "array_flatten":
#         it "flattens nested arrays":
#             val result = array_flatten([[1, 2], [3, 4]])
#             expect(result.len()).to_equal(4)
# 
#     describe "array_uniq":
#         it "removes duplicates":
#             val result = array_uniq([1, 2, 2, 3, 3, 3])
#             expect(result.len()).to_equal(3)
# 
#     describe "array_compact":
#         it "removes nil values":
#             val result = array_compact([1, nil, 2, nil, 3])
#             expect(result.len()).to_equal(3)
# 
#     describe "array_reverse":
#         it "reverses array":
#             val result = array_reverse([1, 2, 3])
#             expect(result[0]).to_equal(3)
#             expect(result[2]).to_equal(1)
# 
#         it "handles empty array":
#             val result = array_reverse([])
#             expect(result.len()).to_equal(0)
