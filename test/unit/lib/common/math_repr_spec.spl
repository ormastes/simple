# Tests for std.math_repr module
# Covers: to_text, to_debug, to_pretty, to_md, render_latex_raw

use std.math_repr.{to_text, to_debug, to_pretty, to_md, render_latex_raw}

describe "std.math_repr":

    describe "to_text":
        it "renders number literal":
            expect(to_text("42")).to_equal("42")

        it "renders decimal number":
            expect(to_text("3.14")).to_equal("3.14")

        it "renders variable":
            expect(to_text("x")).to_equal("x")

        it "renders addition":
            expect(to_text("x + 1")).to_equal("x + 1")

        it "renders subtraction":
            expect(to_text("x - 1")).to_equal("x - 1")

        it "renders power":
            expect(to_text("x^2")).to_equal("x^2")

        it "renders explicit multiplication":
            expect(to_text("a * b")).to_equal("a * b")

        it "renders implicit multiplication":
            expect(to_text("2x")).to_equal("2x")

        it "renders function call":
            expect(to_text("sin(x)")).to_equal("sin(x)")

        it "renders nested expression":
            expect(to_text("x^2 + 2x + 1")).to_equal("x^2 + 2x + 1")

        it "renders negation":
            expect(to_text("-x")).to_equal("-x")

        it "renders grouped expression":
            expect(to_text("(x + 1)")).to_equal("(x + 1)")

        it "renders subscript":
            expect(to_text("x[i]")).to_equal("x[i]")

        it "renders transpose":
            expect(to_text("A'")).to_equal("A'")

        it "renders frac as division":
            expect(to_text("frac(a, b)")).to_equal("a / b")

        it "renders sqrt function":
            expect(to_text("sqrt(x)")).to_equal("sqrt(x)")

    describe "to_debug":
        it "renders number":
            expect(to_debug("42")).to_equal("Num(42)")

        it "renders variable":
            expect(to_debug("x")).to_equal("Id(x)")

        it "renders addition":
            expect(to_debug("x + 1")).to_equal("Add(Id(x), Num(1))")

        it "renders power":
            expect(to_debug("x^2")).to_equal("Pow(Id(x), Num(2))")

        it "renders complex expression":
            expect(to_debug("x^2 + 1")).to_equal("Add(Pow(Id(x), Num(2)), Num(1))")

        it "renders implicit multiplication":
            expect(to_debug("2x")).to_equal("Mul(Num(2), Id(x))")

        it "renders negation":
            expect(to_debug("-x")).to_equal("Neg(Id(x))")

        it "renders function call":
            expect(to_debug("sin(x)")).to_equal("Call(sin, Id(x))")

        it "renders frac":
            expect(to_debug("frac(a, b)")).to_equal("Frac(Id(a), Id(b))")

        it "renders subscript":
            expect(to_debug("x[i]")).to_equal("Sub(Id(x), Id(i))")

        it "renders transpose":
            expect(to_debug("A'")).to_equal("Transpose(Id(A))")

    describe "to_pretty":
        it "renders number":
            expect(to_pretty("42")).to_equal("42")

        it "renders variable":
            expect(to_pretty("x")).to_equal("x")

        it "renders power with superscript":
            expect(to_pretty("x^2")).to_equal("x²")

        it "renders power with n":
            expect(to_pretty("x^n")).to_equal("xⁿ")

        it "renders addition":
            expect(to_pretty("x + 1")).to_equal("x + 1")

        it "renders x^2 + 1":
            expect(to_pretty("x^2 + 1")).to_equal("x² + 1")

        it "renders greek letter alpha":
            expect(to_pretty("alpha")).to_equal("α")

        it "renders greek letter pi":
            expect(to_pretty("pi")).to_equal("π")

        it "renders greek uppercase Sigma":
            expect(to_pretty("Sigma")).to_equal("Σ")

        it "renders implicit multiplication":
            expect(to_pretty("2x")).to_equal("2x")

        it "renders sqrt with symbol":
            expect(to_pretty("sqrt(x)")).to_equal("√(x)")

        it "renders subscript with subscript chars":
            expect(to_pretty("x[1]")).to_equal("x₁")

        it "renders negation":
            expect(to_pretty("-x")).to_equal("-x")

        it "renders fraction with stacked format":
            val result = to_pretty("frac(a, b)")
            expect(result).to_contain("a")
            expect(result).to_contain("b")
            expect(result).to_contain("─")

        it "renders sum with sigma":
            val result = to_pretty("sum(i, 1..n) i^2")
            expect(result).to_contain("∑")

        it "renders integral with symbol":
            val result = to_pretty("int(x, 0..1) x^2")
            expect(result).to_contain("∫")

    describe "to_md":
        it "wraps in dollar signs":
            val result = to_md("42")
            expect(result).to_start_with("$")
            expect(result).to_end_with("$")

        it "renders number":
            expect(to_md("42")).to_equal("$42$")

        it "renders variable":
            expect(to_md("x")).to_equal("$x$")

        it "renders addition":
            expect(to_md("x + 1")).to_equal("$x + 1$")

        it "renders power with braces":
            expect(to_md("x^2")).to_equal("$x^2$")

        it "renders multi-char power with braces":
            expect(to_md("x^10")).to_contain("^{10}")

        it "renders greek with backslash":
            expect(to_md("alpha")).to_contain("\\alpha")

        it "renders sqrt with latex command":
            val result = to_md("sqrt(x)")
            expect(result).to_contain("\\sqrt")

        it "renders frac with latex command":
            val result = to_md("frac(a, b)")
            expect(result).to_contain("\\frac")

        it "renders sin with latex command":
            val result = to_md("sin(x)")
            expect(result).to_contain("\\sin")

        it "renders subscript with underscore":
            val result = to_md("x[i]")
            expect(result).to_contain("_")

        it "renders transpose":
            val result = to_md("A'")
            expect(result).to_contain("^{T}")

        it "renders implicit mul with space":
            val result = to_md("2x")
            expect(result).to_equal("$2 x$")

    describe "render_latex_raw":
        it "renders without dollar signs":
            expect(render_latex_raw("x^2")).to_equal("x^2")

        it "renders fraction":
            val result = render_latex_raw("frac(a, b)")
            expect(result).to_contain("\\frac")

    describe "operator precedence":
        it "parses power before addition":
            expect(to_debug("x^2 + 1")).to_equal("Add(Pow(Id(x), Num(2)), Num(1))")

        it "parses multiplication before addition":
            expect(to_debug("a + b * c")).to_equal("Add(Id(a), Mul(Id(b), Id(c)))")

        it "parses negation correctly":
            expect(to_debug("-x + 1")).to_equal("Add(Neg(Id(x)), Num(1))")

        it "parses grouped expression":
            expect(to_debug("(x + 1)^2")).to_equal("Pow(Group(Add(Id(x), Num(1))), Num(2))")

    describe "complex expressions":
        it "renders quadratic formula text":
            val result = to_text("x^2 + 2x + 1")
            expect(result).to_equal("x^2 + 2x + 1")

        it "renders quadratic formula pretty":
            val result = to_pretty("x^2 + 2x + 1")
            expect(result).to_equal("x² + 2x + 1")

        it "renders nested function calls":
            val result = to_debug("sin(cos(x))")
            expect(result).to_equal("Call(sin, Call(cos, Id(x)))")

        it "renders multi-arg function":
            val result = to_text("max(a, b)")
            expect(result).to_equal("max(a, b)")
