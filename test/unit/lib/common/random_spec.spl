# Random Number Generation Specification
#
# Tests for random-like number generation using a simple linear
# congruential generator (LCG) implemented inline.

# Simple LCG random number generator (no external module needed)
var rng_state = 42

fn rng_seed(seed_val: i64):
    rng_state = seed_val

fn rng_next() -> i64:
    # LCG: state = (a * state + c) % m
    rng_state = (1103515245 * rng_state + 12345) % 2147483648
    if rng_state < 0: rng_state = -rng_state
    return rng_state

fn rng_int(lo: i64, hi: i64) -> i64:
    val range_size = hi - lo + 1
    val raw = rng_next()
    return lo + (raw % range_size)

describe "Random number generation":
    # Tests for random number generation patterns using a simple LCG.
    context "Seeding":
        it "same seed produces same sequence":
            rng_seed(42)
            val a1 = rng_next()
            val a2 = rng_next()
            rng_seed(42)
            val b1 = rng_next()
            val b2 = rng_next()
            expect(a1).to_equal(b1)
            expect(a2).to_equal(b2)

        it "different seeds produce different sequences":
            rng_seed(42)
            val a1 = rng_next()
            rng_seed(99)
            val b1 = rng_next()
            # Very unlikely to be equal
            val different = a1 != b1
            expect(different).to_equal(true)

    context "Range generation":
        it "generates value in range":
            rng_seed(42)
            val result = rng_int(1, 10)
            val in_range = result >= 1
            expect(in_range).to_equal(true)
            val in_upper = result <= 10
            expect(in_upper).to_equal(true)

        it "generates multiple values in range":
            rng_seed(123)
            var all_in_range = true
            for _ in 0..20:
                val v = rng_int(0, 100)
                if v < 0 or v > 100:
                    all_in_range = false
            expect(all_in_range).to_equal(true)

        it "generates different values":
            rng_seed(42)
            val v1 = rng_next()
            val v2 = rng_next()
            val v3 = rng_next()
            # At least two should differ
            val some_different = v1 != v2 or v2 != v3
            expect(some_different).to_equal(true)

    context "Distribution properties":
        it "generates non-negative values":
            rng_seed(42)
            var all_positive = true
            for _ in 0..50:
                val v = rng_next()
                if v < 0:
                    all_positive = false
            expect(all_positive).to_equal(true)

        it "generates values spread across range":
            rng_seed(42)
            var low_count = 0
            var high_count = 0
            for _ in 0..100:
                val v = rng_int(0, 99)
                if v < 50: low_count = low_count + 1
                if v >= 50: high_count = high_count + 1
            # Both halves should have some values
            expect(low_count).to_be_greater_than(10)
            expect(high_count).to_be_greater_than(10)

    context "Sequence operations":
        it "shuffles array by swapping":
            rng_seed(42)
            var arr = [1, 2, 3, 4, 5]
            # Fisher-Yates shuffle
            for i in 0..4:
                val j = rng_int(i, 4)
                val tmp = arr[i]
                arr[i] = arr[j]
                arr[j] = tmp
            # Should still have same length
            expect(arr.len()).to_equal(5)
            # Sum should be preserved
            var sum = 0
            for v in arr:
                sum = sum + v
            expect(sum).to_equal(15)

        it "picks random element from array":
            rng_seed(42)
            val items = [10, 20, 30, 40, 50]
            val idx = rng_int(0, 4)
            val picked = items[idx]
            val valid = picked == 10 or picked == 20 or picked == 30 or picked == 40 or picked == 50
            expect(valid).to_equal(true)
