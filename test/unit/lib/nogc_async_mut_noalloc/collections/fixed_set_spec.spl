# FixedSet - Hash Set Tests

# Local FixedSet implementation for testing
class FixedSet:
    keys: [i64]
    used: [bool]
    cap: i64
    count: i64

    static fn new(cap: i64) -> FixedSet:
        var k = [0]
        var u = [false]
        var i = 1
        while i < cap:
            k = k + [0]
            u = u + [false]
            i = i + 1
        FixedSet(keys: k, used: u, cap: cap, count: 0)

    fn is_empty() -> bool:
        self.count == 0

    fn is_full() -> bool:
        self.count >= self.cap

    fn size() -> i64:
        self.count

    fn capacity() -> i64:
        self.cap

    me add(key: i64) -> bool:
        var idx = key % self.cap
        if idx < 0:
            idx = -idx
        var start = idx
        var first = true
        while first or idx != start:
            first = false
            if not self.used[idx]:
                self.keys[idx] = key
                self.used[idx] = true
                self.count = self.count + 1
                return true
            if self.keys[idx] == key:
                return true
            idx = (idx + 1) % self.cap
        return false

    fn contains(key: i64) -> bool:
        var idx = key % self.cap
        if idx < 0:
            idx = -idx
        var start = idx
        var first = true
        while first or idx != start:
            first = false
            if not self.used[idx]:
                return false
            if self.keys[idx] == key:
                return true
            idx = (idx + 1) % self.cap
        return false

    me remove(key: i64) -> bool:
        var idx = key % self.cap
        if idx < 0:
            idx = -idx
        var start = idx
        var first = true
        while first or idx != start:
            first = false
            if not self.used[idx]:
                return false
            if self.keys[idx] == key:
                self.used[idx] = false
                self.count = self.count - 1
                return true
            idx = (idx + 1) % self.cap
        return false

describe "FixedSet":

    describe "construction":
        it "creates empty set":
            val s = FixedSet.new(16)
            expect(s.is_empty()).to_equal(true)
            expect(s.is_full()).to_equal(false)
            expect(s.size()).to_equal(0)
            expect(s.capacity()).to_equal(16)

    describe "add":
        it "adds values":
            val s = FixedSet.new(16)
            expect(s.add(42)).to_equal(true)
            expect(s.add(7)).to_equal(true)
            expect(s.size()).to_equal(2)

        it "returns true for duplicate values":
            val s = FixedSet.new(16)
            s.add(42)
            expect(s.add(42)).to_equal(true)
            expect(s.size()).to_equal(1)

        it "returns false when set is full":
            val s = FixedSet.new(2)
            expect(s.add(1)).to_equal(true)
            expect(s.add(2)).to_equal(true)
            expect(s.add(3)).to_equal(false)

    describe "contains":
        it "returns true for existing value":
            val s = FixedSet.new(16)
            s.add(42)
            expect(s.contains(42)).to_equal(true)

        it "returns false for missing value":
            val s = FixedSet.new(16)
            expect(s.contains(42)).to_equal(false)

    describe "remove":
        it "removes existing value":
            val s = FixedSet.new(16)
            s.add(42)
            s.add(7)
            expect(s.remove(42)).to_equal(true)
            expect(s.contains(42)).to_equal(false)
            expect(s.contains(7)).to_equal(true)
            expect(s.size()).to_equal(1)

        it "returns false for missing value":
            val s = FixedSet.new(16)
            expect(s.remove(42)).to_equal(false)

    describe "multiple elements":
        it "handles multiple elements":
            val s = FixedSet.new(32)
            s.add(1)
            s.add(2)
            s.add(3)
            s.add(4)
            s.add(5)
            expect(s.size()).to_equal(5)
            expect(s.contains(1)).to_equal(true)
            expect(s.contains(3)).to_equal(true)
            expect(s.contains(5)).to_equal(true)
            expect(s.contains(99)).to_equal(false)

    describe "size tracking":
        it "tracks size through add and remove":
            val s = FixedSet.new(16)
            expect(s.size()).to_equal(0)
            s.add(1)
            expect(s.size()).to_equal(1)
            s.add(2)
            expect(s.size()).to_equal(2)
            s.add(2)
            expect(s.size()).to_equal(2)
            s.remove(1)
            expect(s.size()).to_equal(1)

    describe "capacity":
        it "reports full correctly":
            val s = FixedSet.new(3)
            s.add(10)
            s.add(20)
            expect(s.is_full()).to_equal(false)
            s.add(30)
            expect(s.is_full()).to_equal(true)
