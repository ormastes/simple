# FixedMap - Linear-Probe Hash Map Tests

# Local FixedMap implementation for testing
class FixedMap:
    keys: [i64]
    values: [i64]
    used: [bool]
    capacity: i64
    count: i64

    static fn new(cap: i64) -> FixedMap:
        var k = [0]
        var v = [0]
        var u = [false]
        var i = 1
        while i < cap:
            k = k + [0]
            v = v + [0]
            u = u + [false]
            i = i + 1
        FixedMap(keys: k, values: v, used: u, capacity: cap, count: 0)

    fn is_empty() -> bool:
        self.count == 0

    fn is_full() -> bool:
        self.count >= self.capacity

    fn size() -> i64:
        self.count

    fn find_slot(key: i64) -> i64:
        var idx = key % self.capacity
        if idx < 0:
            idx = -idx
        var start = idx
        var first = true
        while first or idx != start:
            first = false
            if not self.used[idx]:
                return idx
            if self.keys[idx] == key:
                return idx
            idx = (idx + 1) % self.capacity
        return -1

    me put(key: i64, value: i64) -> bool:
        var idx = key % self.capacity
        if idx < 0:
            idx = -idx
        var start = idx
        var first = true
        while first or idx != start:
            first = false
            if not self.used[idx]:
                self.keys[idx] = key
                self.values[idx] = value
                self.used[idx] = true
                self.count = self.count + 1
                return true
            if self.keys[idx] == key:
                self.values[idx] = value
                return true
            idx = (idx + 1) % self.capacity
        return false

    fn get(key: i64) -> i64:
        var idx = key % self.capacity
        if idx < 0:
            idx = -idx
        var start = idx
        var first = true
        while first or idx != start:
            first = false
            if not self.used[idx]:
                return 0
            if self.keys[idx] == key:
                return self.values[idx]
            idx = (idx + 1) % self.capacity
        return 0

    fn contains(key: i64) -> bool:
        var idx = key % self.capacity
        if idx < 0:
            idx = -idx
        var start = idx
        var first = true
        while first or idx != start:
            first = false
            if not self.used[idx]:
                return false
            if self.keys[idx] == key:
                return true
            idx = (idx + 1) % self.capacity
        return false

    me remove(key: i64) -> bool:
        var idx = key % self.capacity
        if idx < 0:
            idx = -idx
        var start = idx
        var first = true
        while first or idx != start:
            first = false
            if not self.used[idx]:
                return false
            if self.keys[idx] == key:
                self.used[idx] = false
                self.count = self.count - 1
                return true
            idx = (idx + 1) % self.capacity
        return false

describe "FixedMap":

    describe "construction":
        it "creates empty map":
            val map = FixedMap.new(16)
            expect(map.is_empty()).to_equal(true)
            expect(map.is_full()).to_equal(false)
            expect(map.size()).to_equal(0)

    describe "put and get":
        it "stores and retrieves values":
            val map = FixedMap.new(16)
            map.put(42, 100)
            map.put(7, 200)
            expect(map.get(42)).to_equal(100)
            expect(map.get(7)).to_equal(200)

        it "returns 0 for missing keys":
            val map = FixedMap.new(16)
            expect(map.get(99)).to_equal(0)

        it "updates existing key":
            val map = FixedMap.new(16)
            map.put(42, 100)
            map.put(42, 999)
            expect(map.get(42)).to_equal(999)
            expect(map.size()).to_equal(1)

        it "returns false when map is full":
            val map = FixedMap.new(2)
            expect(map.put(1, 10)).to_equal(true)
            expect(map.put(2, 20)).to_equal(true)
            expect(map.put(3, 30)).to_equal(false)

    describe "contains":
        it "returns true for existing key":
            val map = FixedMap.new(16)
            map.put(42, 100)
            expect(map.contains(42)).to_equal(true)

        it "returns false for missing key":
            val map = FixedMap.new(16)
            expect(map.contains(42)).to_equal(false)

    describe "remove":
        it "removes existing key":
            val map = FixedMap.new(16)
            map.put(42, 100)
            map.put(7, 200)
            expect(map.remove(42)).to_equal(true)
            expect(map.contains(42)).to_equal(false)
            expect(map.get(7)).to_equal(200)
            expect(map.size()).to_equal(1)

        it "returns false for missing key":
            val map = FixedMap.new(16)
            expect(map.remove(42)).to_equal(false)

    describe "multiple entries":
        it "handles multiple entries with different keys":
            val map = FixedMap.new(32)
            map.put(1, 10)
            map.put(2, 20)
            map.put(3, 30)
            map.put(4, 40)
            map.put(5, 50)
            expect(map.size()).to_equal(5)
            expect(map.get(1)).to_equal(10)
            expect(map.get(3)).to_equal(30)
            expect(map.get(5)).to_equal(50)

    describe "size tracking":
        it "tracks size through put and remove":
            val map = FixedMap.new(16)
            expect(map.size()).to_equal(0)
            map.put(1, 10)
            expect(map.size()).to_equal(1)
            map.put(2, 20)
            expect(map.size()).to_equal(2)
            map.remove(1)
            expect(map.size()).to_equal(1)
