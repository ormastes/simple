# # Branch Coverage Test Suite
#
# **Feature IDs:** #BRANCH
# **Category:** Testing
# **Status:** Implemented
#
# ## Overview
#
# Comprehensive branch coverage ensuring every code path is executed.
# Tests all conditional branches, loops, and match statements.

fn check(condition: bool):
    expect(condition).to_equal(true)

describe "Conditional Branch Coverage":
    it "if-then branch taken":
        val x = 10
        if x > 5:
            check(true)
        else:
            check(false)
            
    it "if-else branch taken":
        val x = 2
        if x > 5:
            check(false)
        else:
            check(true)
            
    it "if-elif-then first":
        val x = 15
        if x > 10:
            check(true)
        elif x > 5:
            check(false)
        else:
            check(false)
            
    it "if-elif-then second":
        val x = 7
        if x > 10:
            check(false)
        elif x > 5:
            check(true)
        else:
            check(false)
            
    it "if-elif-else taken":
        val x = 3
        if x > 10:
            check(false)
        elif x > 5:
            check(false)
        else:
            check(true)
            
    it "nested if - true/true":
        if true:
            if true:
                check(true)
            else:
                check(false)
        else:
            check(false)
            
    it "nested if - true/false":
        if true:
            if false:
                check(false)
            else:
                check(true)
        else:
            check(false)
            
    it "nested if - false/true":
        if false:
            if true:
                check(false)
            else:
                check(false)
        else:
            check(true)
            
    it "nested if - false/false":
        if false:
            if false:
                check(false)
            else:
                check(false)
        else:
            check(true)
            
    it "triple nested - all true":
        if true:
            if true:
                if true:
                    check(true)
                else:
                    check(false)
            else:
                check(false)
        else:
            check(false)


describe "Match Statement Coverage":
    it "match - pattern 1":
        val x = 1
        val result = match x:
            1: "one"
            2: "two"
            3: "three"
            _: "other"
        check(result == "one")
        
    it "match - pattern 2":
        val x = 2
        val result = match x:
            1: "one"
            2: "two"
            3: "three"
            _: "other"
        check(result == "two")
        
    it "match - pattern 3":
        val x = 3
        val result = match x:
            1: "one"
            2: "two"
            3: "three"
            _: "other"
        check(result == "three")
        
    it "match - default":
        val x = 99
        val result = match x:
            1: "one"
            2: "two"
            3: "three"
            _: "other"
        check(result == "other")
        
    it "match Some":
        val opt = Some(42)
        match opt:
            Some(x): check(x == 42)
            nil: check(false)
            
    it "match nil":
        val opt = nil
        match opt:
            Some(x): check(false)
            nil: check(true)
            
    it "match nested Some":
        val nested = Some(Some(10))
        match nested:
            Some(Some(x)): check(x == 10)
            Some(nil): check(false)
            nil: check(false)
            
    it "match boolean true":
        val b = true
        match b:
            true: check(true)
            false: check(false)
            
    it "match boolean false":
        val b = false
        match b:
            true: check(false)
            false: check(true)


describe "Loop Branch Coverage":
    it "for loop - executed":
        fn run_for_executed() -> i64:
            var count = 0
            for i in 0..10:
                count = count + 1
            count
        check(run_for_executed() == 10)
        
    it "for loop - empty range":
        fn run_for_empty() -> i64:
            var count = 0
            for i in 0..0:
                count = count + 1
            count
        check(run_for_empty() == 0)
        
    it "for loop - with break":
        fn run_for_break() -> i64:
            var count = 0
            for i in 0..100:
                count = count + 1
                if count == 5:
                    break
            count
        check(run_for_break() == 5)
        
    it "for loop - with continue":
        fn run_for_continue() -> i64:
            var count = 0
            for i in 0..10:
                if i % 2 == 0:
                    continue
                count = count + 1
            count
        check(run_for_continue() == 5)
        
    it "for loop - all continue":
        fn run_for_all_continue() -> i64:
            var count = 0
            for i in 0..10:
                continue
                count = count + 1  # Never reached
            count
        check(run_for_all_continue() == 0)
        
    it "while loop - executed":
        fn run_while_exec() -> i64:
            var count = 0
            while count < 5:
                count = count + 1
            count
        check(run_while_exec() == 5)
        
    it "while loop - not executed":
        fn run_while_skip() -> i64:
            var count = 10
            while count < 5:
                count = count + 1
            count
        check(run_while_skip() == 10)
        
    it "while loop - with break":
        fn run_while_break() -> i64:
            var count = 0
            while true:
                count = count + 1
                if count == 3:
                    break
            count
        check(run_while_break() == 3)
        
    it "while loop - with continue":
        fn run_while_continue() -> i64:
            var count = 0
            var iterations = 0
            while count < 10:
                count = count + 1
                if count % 2 == 0:
                    continue
                iterations = iterations + 1
            iterations
        check(run_while_continue() == 5)
        
    it "nested loops - both execute":
        fn run_nested_loops() -> i64:
            var total = 0
            for i in 0..3:
                for j in 0..3:
                    total = total + 1
            total
        check(run_nested_loops() == 9)


describe "Boolean Expression Coverage":
    it "and - true/true":
        check(true and true)
        
    it "and - true/false":
        check(not (true and false))
        
    it "and - false/true":
        check(not (false and true))
        
    it "and - false/false":
        check(not (false and false))
        
    it "or - true/true":
        check(true or true)
        
    it "or - true/false":
        check(true or false)
        
    it "or - false/true":
        check(false or true)
        
    it "or - false/false":
        check(not (false or false))
        
    it "not - true":
        check(not true == false)
        
    it "not - false":
        check(not false == true)
        
    it "complex - (A and B) or C - true":
        check((true and true) or false)
        
    it "complex - (A and B) or C - false then true":
        check((false and true) or true)
        
    it "complex - A and (B or C) - true":
        check(true and (true or false))
        
    it "complex - A and (B or C) - false":
        check(not (false and (true or false)))


describe "Comparison Branch Coverage":
    it "equals - true":
        check(5 == 5)
        
    it "equals - false":
        check(not (5 == 3))
        
    it "not equals - true":
        check(5 != 3)
        
    it "not equals - false":
        check(not (5 != 5))
        
    it "less than - true":
        check(3 < 5)
        
    it "less than - false":
        check(not (5 < 3))
        
    it "greater than - true":
        check(5 > 3)
        
    it "greater than - false":
        check(not (3 > 5))
        
    it "less equal - true equal":
        check(5 <= 5)
        
    it "less equal - true less":
        check(3 <= 5)
        
    it "less equal - false":
        check(not (5 <= 3))
        
    it "greater equal - true equal":
        check(5 >= 5)
        
    it "greater equal - true greater":
        check(5 >= 3)
        
    it "greater equal - false":
        check(not (3 >= 5))


describe "Arithmetic Branch Coverage":
    it "division - positive/positive":
        check(10 / 2 == 5)
        
    it "division - negative/positive":
        check(-10 / 2 == -5)
        
    it "division - positive/negative":
        check(10 / -2 == -5)
        
    it "modulo - positive remainder":
        check(7 % 3 == 1)
        
    it "modulo - zero remainder":
        check(6 % 3 == 0)
        
    it "power - positive exponent":
        check(2 ** 3 == 8)
        
    it "power - zero exponent":
        check(5 ** 0 == 1)


describe "Collection Operation Coverage":
    it "array index - valid":
        var arr = [1, 2, 3]
        check(arr[0] == 1)
        
    it "array index - negative":
        var arr = [1, 2, 3]
        check(arr[-1] == 3)
        
    it "array slice - full range":
        var arr = [1, 2, 3, 4, 5]
        check(arr[0..-1].len() == 5)
        
    it "array slice - partial":
        var arr = [1, 2, 3, 4, 5]
        check(arr[1..3].len() == 2)
        
    it "array append - to empty":
        var arr = []
        val result = arr.append(1)
        check(result.len() == 1)
        
    it "array append - to non-empty":
        var arr = [1, 2]
        val result = arr.append(3)
        check(result.len() == 3)
        
    it "dict get - exists":
        val d = {"key": "value"}
        check(d.get("key").?)
        
    it "dict get - missing":
        val d = {"key": "value"}
        check(not d.get("missing").?)


describe "Option Type Coverage":
    it "option is some":
        val opt = Some(42)
        check(opt.?)
        
    it "option is nil":
        val opt = nil
        check(not opt.?)
        
    it "option unwrap some":
        val opt = Some(42)
        check(opt? == 42)
        
    it "option chain - some/some":
        val opt1 = Some(Some(10))
        check(opt1.?)
        
    it "option coalesce - some":
        val opt = Some(42)
        val result = opt ?? 0
        check(result == 42)
        
    it "option coalesce - nil":
        val opt = nil
        val result = opt ?? 99
        check(result == 99)
