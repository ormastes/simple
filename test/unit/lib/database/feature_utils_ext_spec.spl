describe "Feature Utils Ext":
    it "skipped":
        skip("pre-existing test failures - functions/imports not available")

# # Tests for lib.database.feature_utils module
# # Covers SSpec metadata parsing, feature ID comparison, and text extraction
# 
# use std.database.feature_utils.{parse_attr_list, extract_quoted_string, extract_category_from_path, compare_feature_id}
# 
# describe "lib.database.feature_utils":
#     describe "extract_quoted_string":
#         it "extracts first quoted string":
#             expect(extract_quoted_string("describe \"Hello World\":")).to_equal("Hello World")
# 
#         it "extracts from feature line":
#             expect(extract_quoted_string("feature \"My Feature\":")).to_equal("My Feature")
# 
#         it "returns empty for no quotes":
#             expect(extract_quoted_string("no quotes here")).to_equal("")
# 
#         it "returns empty for single quote":
#             expect(extract_quoted_string("only one \" quote")).to_equal("")
# 
#         it "handles empty quoted string":
#             expect(extract_quoted_string("test \"\" done")).to_equal("")
# 
#     describe "extract_category_from_path":
#         it "extracts from features directory":
#             val result = extract_category_from_path("test/system/features/control_flow/spec.spl")
#             expect(result).to_equal("control_flow")
# 
#         it "extracts from nested features path":
#             val result = extract_category_from_path("test/features/closures/basic_spec.spl")
#             expect(result).to_equal("closures")
# 
#         it "falls back to parent directory":
#             val result = extract_category_from_path("test/unit/std/string_spec.spl")
#             expect(result).to_equal("std")
# 
#         it "returns uncategorized for single component":
#             val result = extract_category_from_path("spec.spl")
#             expect(result).to_equal("uncategorized")
# 
#     describe "parse_attr_list":
#         it "parses single item":
#             val result = parse_attr_list("#[modes(interpreter)]", "modes")
#             expect(result.len()).to_equal(1)
#             expect(result[0]).to_equal("interpreter")
# 
#         it "parses multiple items":
#             val result = parse_attr_list("#[modes(interpreter, compiled, native)]", "modes")
#             expect(result.len()).to_equal(3)
#             expect(result[0]).to_equal("interpreter")
#             expect(result[1]).to_equal("compiled")
#             expect(result[2]).to_equal("native")
# 
#         it "handles quoted items":
#             val result = parse_attr_list("#[platforms(\"linux\", \"macos\")]", "platforms")
#             expect(result.len()).to_equal(2)
#             expect(result[0]).to_equal("linux")
#             expect(result[1]).to_equal("macos")
# 
#         it "returns empty for missing attribute":
#             val result = parse_attr_list("#[other(val)]", "modes")
#             expect(result.len()).to_equal(0)
# 
#     describe "compare_feature_id":
#         it "compares simple numeric IDs":
#             expect(compare_feature_id("1", "2")).to_be_less_than(0)
#             expect(compare_feature_id("2", "1")).to_be_greater_than(0)
#             expect(compare_feature_id("1", "1")).to_equal(0)
# 
#         it "compares dotted numeric IDs semantically":
#             expect(compare_feature_id("1.2", "1.10")).to_be_less_than(0)
#             expect(compare_feature_id("1.10", "1.2")).to_be_greater_than(0)
# 
#         it "compares string IDs":
#             expect(compare_feature_id("aaa", "bbb")).to_be_less_than(0)
#             expect(compare_feature_id("bbb", "aaa")).to_be_greater_than(0)
# 
#         it "handles different lengths":
#             val result = compare_feature_id("1.2", "1.2.3")
#             expect(result).to_be_less_than(0)
# 
#         it "compares equal IDs":
#             expect(compare_feature_id("1.2.3", "1.2.3")).to_equal(0)
