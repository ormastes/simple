# Database Library Tests
#
# Tests for the unified database library (BugDatabase, TestDatabase, FeatureDatabase)

fn check(condition: bool):
    expect(condition).to_equal(true)
fn check_msg(condition: bool, message: text):
    if not condition:
        expect(message).to_equal("")
# use std.database.core.{StringInterner, SdnTable, SdnRow, SdnDatabase}
# use std.database.bug.{BugDatabase, Bug, BugSeverity, BugStatus}
# use app.io.{file_exists, file_delete, rt_timestamp_now}

# Stub: StringInterner (uses str_to_id / id_to_str)
class StringInterner:
    str_to_id: {text: i64}
    id_to_str: {text: text}
    next_id: i64
    me intern(s: text) -> i64:
        if self.str_to_id.contains_key(s):
            return self.str_to_id[s]
        val id = self.next_id
        self.str_to_id[s] = id
        self.id_to_str["{id}"] = s
        self.next_id = self.next_id + 1
        id
    fn get(id: i64):
        val key = "{id}"
        if self.id_to_str.contains_key(key):
            return Some(self.id_to_str[key])
        nil
    fn to_sdn() -> SdnTable:
        var table = SdnTable(name: "strings", columns: ["id", "value"], rows: [], index: {})
        for k in self.str_to_id.keys():
            val id = self.str_to_id[k]
            var row = SdnRow(fields: {})
            row.set("id", "{id}")
            row.set("value", k)
            table.add_row(row)
        table

fn StringInterner__from_sdn(table: SdnTable) -> StringInterner:
    var interner = StringInterner(str_to_id: {}, id_to_str: {}, next_id: 0)
    for row in table.rows:
        val id_str = row.get("id") ?? "0"
        val value = row.get("value") ?? ""
        val id = id_str.to_i64()
        interner.str_to_id[value] = id
        interner.id_to_str["{id}"] = value
        if id >= interner.next_id:
            interner.next_id = id + 1
    interner

# Stub: SdnRow
class SdnRow:
    fields: {text: text}
    me set(key: text, value: text):
        self.fields[key] = value
    fn get(key: text):
        if self.fields.contains_key(key):
            return Some(self.fields[key])
        nil
    fn get_i64(key: text):
        val v = self.get(key)
        if v.?:
            return Some(v?.to_i64())
        nil
    fn get_bool(key: text):
        val v = self.get(key)
        if v.?:
            if v? == "true":
                return Some(true)
            if v? == "false":
                return Some(false)
        nil
    fn has(key: text) -> bool:
        self.fields.contains_key(key)

# Stub: SdnTable
class SdnTable:
    name: text
    columns: [text]
    rows: [SdnRow]
    index: {text: i64}
    me add_row(row: SdnRow):
        val id_opt = row.get("id")
        if id_opt.?:
            val id = id_opt?
            if self.index.contains_key(id):
                return
            self.index[id] = self.rows.len()
        self.rows = self.rows + [row]
    fn get_row(id: text):
        if self.index.contains_key(id):
            val idx = self.index[id]
            return Some(self.rows[idx])
        nil
    me update_row(id: text, new_row: SdnRow):
        if self.index.contains_key(id):
            val idx = self.index[id]
            self.rows[idx] = new_row
    me mark_deleted(id: text):
        if self.index.contains_key(id):
            val idx = self.index[id]
            var row = self.rows[idx]
            row.set("valid", "false")
    fn valid_rows() -> [SdnRow]:
        var result = []
        for row in self.rows:
            val valid = row.get("valid")
            if valid.? and valid? == "true":
                result = result + [row]
        result
    fn to_sdn() -> text:
        var cols_str = self.columns.join(", ")
        var result = "{self.name} |{cols_str}|\n"
        for row in self.rows:
            var values = []
            for col in self.columns:
                val v = row.get(col) ?? ""
                values = values + [v]
            result = result + "    {values.join(", ")}\n"
        result

# Stub: SdnDatabase
class SdnDatabase:
    path: text
    tables: {text: SdnTable}
    interner: StringInterner
    modified: bool
    me set_table(name: text, table: SdnTable):
        self.tables[name] = table
    fn get_table(name: text):
        if self.tables.contains_key(name):
            return Some(self.tables[name])
        nil
    me intern(s: text) -> i64:
        self.interner.intern(s)
    fn resolve(id: i64):
        self.interner.get(id)

# Stub: BugSeverity / BugStatus / Bug / BugDatabase
class BugSeverity:
    static fn P0() -> text: "P0"
    static fn P1() -> text: "P1"
    static fn P2() -> text: "P2"
    static fn P3() -> text: "P3"

class BugStatus:
    static fn Open() -> text: "Open"
    static fn Fixed() -> text: "Fixed"
    static fn Investigating() -> text: "Investigating"
    static fn Closed() -> text: "Closed"

class Bug:
    id: text
    severity: text
    status: text
    title: text
    description: [text]
    file: text
    line: i64
    reproducible_by: text
    fix_strategy: [text]
    investigation_log: [text]
    created_at: text
    updated_at: text
    valid: bool

class BugDatabase:
    db: SdnDatabase
    bugs: [Bug]
    me add_bug(bug: Bug) -> bool:
        self.bugs = self.bugs + [bug]
        true
    fn all_bugs() -> [Bug]:
        self.bugs
    fn bugs_by_status(status: text) -> [Bug]:
        var result = []
        for bug in self.bugs:
            if bug.status == status:
                result = result + [bug]
        result
    fn critical_bugs() -> [Bug]:
        var result = []
        for bug in self.bugs:
            if bug.severity == "P0":
                result = result + [bug]
        result
    fn stats():
        var total = self.bugs.len()
        var open = 0
        var fixed = 0
        var p1 = 0
        for bug in self.bugs:
            if bug.status == "Open":
                open = open + 1
            if bug.status == "Fixed":
                fixed = fixed + 1
            if bug.severity == "P1":
                p1 = p1 + 1
        {total: total, open: open, fixed: fixed, p1: p1}
    fn validate_test_links() -> [text]:
        var errors = []
        for bug in self.bugs:
            if bug.reproducible_by == "":
                errors = errors + ["{bug.id} has no test link"]
        errors

fn create_bug_database(path: text) -> BugDatabase:
    val db = SdnDatabase(path: path, tables: {}, interner: StringInterner(str_to_id: {}, id_to_str: {}, next_id: 0), modified: false)
    var bugdb = BugDatabase(db: db, bugs: [])
    bugdb.db.set_table("bugs", SdnTable(name: "bugs", columns: ["id"], rows: [], index: {}))
    bugdb.db.set_table("bug_descriptions", SdnTable(name: "bug_descriptions", columns: ["id"], rows: [], index: {}))
    bugdb.db.set_table("bug_fix_strategies", SdnTable(name: "bug_fix_strategies", columns: ["id"], rows: [], index: {}))
    bugdb.db.set_table("bug_investigation_logs", SdnTable(name: "bug_investigation_logs", columns: ["id"], rows: [], index: {}))
    bugdb

# ============================================================================
# StringInterner Tests
# ============================================================================

describe "StringInterner":
    it "creates empty interner":
        val interner = StringInterner(str_to_id: {}, id_to_str: {}, next_id: 0)
        check(interner.next_id == 0)
        check(interner.str_to_id.len() == 0)

    it "interns strings with unique IDs":
        var interner = StringInterner(str_to_id: {}, id_to_str: {}, next_id: 0)
        val id1 = interner.intern("hello")
        val id2 = interner.intern("world")
        val id3 = interner.intern("hello")  # Same string

        check(id1 == 0)
        check(id2 == 1)
        check(id3 == 0)  # Reuses ID

    it "resolves IDs to strings":
        var interner = StringInterner(str_to_id: {}, id_to_str: {}, next_id: 0)
        val id = interner.intern("test")
        val resolved = interner.get(id)?

        check(resolved == "test")

    it "returns None for invalid ID":
        val interner = StringInterner(str_to_id: {}, id_to_str: {}, next_id: 0)
        val resolved = interner.get(999)

        check(not resolved.?)

    it "exports to SDN table":
        var interner = StringInterner(str_to_id: {}, id_to_str: {}, next_id: 0)
        interner.intern("foo")
        interner.intern("bar")

        val table = interner.to_sdn()
        check(table.name == "strings")
        check(table.rows.len() == 2)

    it "loads from SDN table":
        # Create table
        val table = SdnTable(name: "strings", columns: ["id", "value"], rows: [], index: {})
        var row1 = SdnRow(fields: {})
        row1.set("id", "0")
        row1.set("value", "test1")
        table.add_row(row1)

        var row2 = SdnRow(fields: {})
        row2.set("id", "1")
        row2.set("value", "test2")
        table.add_row(row2)

        # Load interner
        val interner = StringInterner__from_sdn(table)
        check(interner.get(0)? == "test1")
        check(interner.get(1)? == "test2")

# ============================================================================
# SdnRow Tests
# ============================================================================

describe "SdnRow":
    it "creates empty row":
        val row = SdnRow(fields: {})
        check(row.fields.len() == 0)

    it "sets and gets field values":
        var row = SdnRow(fields: {})
        row.set("name", "Alice")
        row.set("age", "30")

        check(row.get("name")? == "Alice")
        check(row.get("age")? == "30")

    it "returns None for missing field":
        val row = SdnRow(fields: {})
        check(not row.get("missing").?)

    it "parses i64 fields":
        var row = SdnRow(fields: {})
        row.set("count", "42")

        check(row.get_i64("count")? == 42)

    it "parses bool fields":
        var row = SdnRow(fields: {})
        row.set("active", "true")
        row.set("disabled", "false")

        check(row.get_bool("active")? == true)
        check(row.get_bool("disabled")? == false)

    it "checks if has column":
        var row = SdnRow(fields: {})
        row.set("name", "Bob")

        check(row.has("name"))
        check(not row.has("age"))

# ============================================================================
# SdnTable Tests
# ============================================================================

describe "SdnTable":
    it "creates new table":
        val table = SdnTable(name: "users", columns: ["id", "name", "email"], rows: [], index: {})

        check(table.name == "users")
        check(table.columns.len() == 3)
        check(table.rows.len() == 0)

    it "adds rows":
        var table = SdnTable(name: "users", columns: ["id", "name"], rows: [], index: {})

        var row = SdnRow(fields: {})
        row.set("id", "1")
        row.set("name", "Alice")

        table.add_row(row)
        check(table.rows.len() == 1)

    it "indexes rows by primary key":
        var table = SdnTable(name: "users", columns: ["id", "name"], rows: [], index: {})

        var row = SdnRow(fields: {})
        row.set("id", "user_1")
        row.set("name", "Alice")
        table.add_row(row)

        val found = table.get_row("user_1")?
        check(found.get("name")? == "Alice")

    it "updates row by key":
        var table = SdnTable(name: "users", columns: ["id", "name"], rows: [], index: {})

        var row1 = SdnRow(fields: {})
        row1.set("id", "user_1")
        row1.set("name", "Alice")
        table.add_row(row1)

        var row2 = SdnRow(fields: {})
        row2.set("id", "user_1")
        row2.set("name", "Bob")
        table.update_row("user_1", row2)

        val found = table.get_row("user_1")?
        check(found.get("name")? == "Bob")

    it "soft deletes rows":
        var table = SdnTable(name: "users", columns: ["id", "name", "valid"], rows: [], index: {})

        var row = SdnRow(fields: {})
        row.set("id", "user_1")
        row.set("name", "Alice")
        row.set("valid", "true")
        table.add_row(row)

        table.mark_deleted("user_1")

        val all_rows = table.rows
        val valid_rows = table.valid_rows()

        check(all_rows.len() == 1)
        check(valid_rows.len() == 0)

    it "exports to SDN format":
        var table = SdnTable(name: "users", columns: ["id", "name"], rows: [], index: {})

        var row = SdnRow(fields: {})
        row.set("id", "1")
        row.set("name", "Alice")
        table.add_row(row)

        val sdn = table.to_sdn()
        check(sdn.contains("users |id, name|"))
        check(sdn.contains("1, Alice"))

# ============================================================================
# SdnDatabase Tests
# ============================================================================

describe "SdnDatabase":
    it "creates new database":
        val db = SdnDatabase(path: "test_db.sdn", tables: {}, interner: StringInterner(str_to_id: {}, id_to_str: {}, next_id: 0), modified: false)

        check(db.path == "test_db.sdn")
        check(db.tables.len() == 0)

    it "adds and retrieves tables":
        var db = SdnDatabase(path: "test_db.sdn", tables: {}, interner: StringInterner(str_to_id: {}, id_to_str: {}, next_id: 0), modified: false)

        val table = SdnTable(name: "users", columns: ["id", "name"], rows: [], index: {})
        db.set_table("users", table)

        val retrieved = db.get_table("users")?
        check(retrieved.name == "users")

    it "interns strings":
        var db = SdnDatabase(path: "test_db.sdn", tables: {}, interner: StringInterner(str_to_id: {}, id_to_str: {}, next_id: 0), modified: false)

        val id1 = db.intern("hello")
        val id2 = db.intern("hello")

        check(id1 == id2)
        check(db.resolve(id1)? == "hello")

# ============================================================================
# BugDatabase Tests
# ============================================================================

describe "BugDatabase":
    it "creates new bug database":
        val bugdb = create_bug_database("/tmp/test_bugdb.sdn")

        check(bugdb.db.tables.contains_key("bugs"))
        check(bugdb.db.tables.contains_key("bug_descriptions"))
        check(bugdb.db.tables.contains_key("bug_fix_strategies"))
        check(bugdb.db.tables.contains_key("bug_investigation_logs"))

    it "adds and retrieves bugs":
        var bugdb = create_bug_database("/tmp/test_bugdb.sdn")

        val bug = Bug(
            id: "test_001",
            severity: BugSeverity.P1(),
            status: BugStatus.Open(),
            title: "Test bug",
            description: ["Line 1", "Line 2"],
            file: "test.spl",
            line: 42,
            reproducible_by: "test_case",
            fix_strategy: ["Fix step 1"],
            investigation_log: [],
            created_at: "2026-02-05T10:00:00",
            updated_at: "2026-02-05T10:00:00",
            valid: true
        )

        val added = bugdb.add_bug(bug)
        check(added)

        # Check we can get all bugs
        val all_bugs = bugdb.all_bugs()
        check(all_bugs.len() == 1)

        val first_bug = all_bugs[0]
        check(first_bug.title == "Test bug")
        check(first_bug.severity == BugSeverity.P1())
        check(first_bug.description.len() == 2)

    it "queries bugs by status":
        
        var bugdb = create_bug_database("/tmp/test.sdn")

        val bug1 = Bug(
            id: "bug_001",
            severity: BugSeverity.P1(),
            status: BugStatus.Open(),
            title: "Bug 1",
            description: [],
            file: "test.spl",
            line: 1,
            reproducible_by: "test",
            fix_strategy: [],
            investigation_log: [],
            created_at: "2026-02-05",
            updated_at: "2026-02-05",
            valid: true
        )

        val bug2 = Bug(
            id: "bug_002",
            severity: BugSeverity.P2(),
            status: BugStatus.Fixed(),
            title: "Bug 2",
            description: [],
            file: "test.spl",
            line: 2,
            reproducible_by: "test",
            fix_strategy: [],
            investigation_log: [],
            created_at: "2026-02-05",
            updated_at: "2026-02-05",
            valid: true
        )

        bugdb.add_bug(bug1)
        bugdb.add_bug(bug2)

        val open_bugs = bugdb.bugs_by_status(BugStatus.Open())
        val fixed_bugs = bugdb.bugs_by_status(BugStatus.Fixed())

        check(open_bugs.len() == 1)
        check(fixed_bugs.len() == 1)


    it "queries critical bugs":
        
        var bugdb = create_bug_database("/tmp/test.sdn")

        val p0_bug = Bug(
            id: "bug_p0",
            severity: BugSeverity.P0(),
            status: BugStatus.Open(),
            title: "Critical",
            description: [],
            file: "test.spl",
            line: 1,
            reproducible_by: "test",
            fix_strategy: [],
            investigation_log: [],
            created_at: "2026-02-05",
            updated_at: "2026-02-05",
            valid: true
        )

        val p2_bug = Bug(
            id: "bug_p2",
            severity: BugSeverity.P2(),
            status: BugStatus.Open(),
            title: "Low",
            description: [],
            file: "test.spl",
            line: 2,
            reproducible_by: "test",
            fix_strategy: [],
            investigation_log: [],
            created_at: "2026-02-05",
            updated_at: "2026-02-05",
            valid: true
        )

        bugdb.add_bug(p0_bug)
        bugdb.add_bug(p2_bug)

        val critical = bugdb.critical_bugs()
        check(critical.len() == 1)


    it "generates statistics":
        
        var bugdb = create_bug_database("/tmp/test.sdn")

        # Add various bugs
        for i in 0..5:
            val severity = if i < 2:
                BugSeverity.P1()
            else:
                BugSeverity.P2()

            val status = if i < 3:
                BugStatus.Open()
            else:
                BugStatus.Fixed()

            val bug = Bug(
                id: "bug_{i}",
                severity: severity,
                status: status,
                title: "Bug {i}",
                description: [],
                file: "test.spl",
                line: i,
                reproducible_by: "test",
                fix_strategy: [],
                investigation_log: [],
                created_at: "2026-02-05",
                updated_at: "2026-02-05",
                valid: true
            )
            bugdb.add_bug(bug)

        val stats = bugdb.stats()
        check(stats.total == 5)
        check(stats.open == 3)
        check(stats.fixed == 2)
        check(stats.p1 == 2)


    it "validates test links":
        
        var bugdb = create_bug_database("/tmp/test.sdn")

        val bug_with_test = Bug(
            id: "bug_001",
            severity: BugSeverity.P1(),
            status: BugStatus.Open(),
            title: "With test",
            description: [],
            file: "test.spl",
            line: 1,
            reproducible_by: "test_case",
            fix_strategy: [],
            investigation_log: [],
            created_at: "2026-02-05",
            updated_at: "2026-02-05",
            valid: true
        )

        val bug_no_test = Bug(
            id: "bug_002",
            severity: BugSeverity.P1(),
            status: BugStatus.Open(),
            title: "No test",
            description: [],
            file: "test.spl",
            line: 2,
            reproducible_by: "",
            fix_strategy: [],
            investigation_log: [],
            created_at: "2026-02-05",
            updated_at: "2026-02-05",
            valid: true
        )

        bugdb.add_bug(bug_with_test)
        bugdb.add_bug(bug_no_test)

        val errors = bugdb.validate_test_links()
        check(errors.len() == 1)
        check(errors[0].contains("bug_002"))

