# Database Core Extended Tests
#
# Comprehensive tests for all exported functions and classes from lib.database.core:
# - StringInterner: intern, get, lookup, get_id, all_strings, to_sdn
# - SdnRow: get, get_i32, get_i64, get_f64, get_bool, set, has
# - SdnTable: add_row, update_row, get_row, mark_deleted, delete_row,
#             clear, rebuild_index, to_sdn, parse
# - SdnDatabase: set_table, get_table, get_table_mut, add_row_to_table,
#                intern, resolve, validate, save, load
# - Standalone: parse_sdn_table, interner_from_sdn, new_sdn_database, load_sdn_database

use std.database.core.{StringInterner, SdnRow, SdnTable, SdnDatabase}
use std.database.core.{parse_sdn_table, interner_from_sdn, new_sdn_database, load_sdn_database}
use app.io.file_ops.{file_exists, file_delete}
use app.io.file_ops as fops

fn file_read(p: text) -> text:
    val result = fops.file_read(p)
    result ?? ""

# ============================================================================
# StringInterner Tests
# ============================================================================

describe "StringInterner":
    it "creates empty interner":
        val interner = StringInterner(str_to_id: {}, id_to_str: {}, next_id: 0)
        expect(interner.next_id).to_equal(0)

    it "interns a string and returns an ID":
        var interner = StringInterner(str_to_id: {}, id_to_str: {}, next_id: 0)
        val id = interner.intern("hello")
        expect(id).to_equal(0)

    it "interns same string to same ID (deduplication)":
        var interner = StringInterner(str_to_id: {}, id_to_str: {}, next_id: 0)
        val id1 = interner.intern("test")
        val id2 = interner.intern("test")
        expect(id1).to_equal(id2)

    it "interns different strings to different IDs":
        var interner = StringInterner(str_to_id: {}, id_to_str: {}, next_id: 0)
        val id1 = interner.intern("alpha")
        val id2 = interner.intern("beta")
        expect(id1).to_equal(0)
        expect(id2).to_equal(1)

    it "increments next_id for each new string":
        var interner = StringInterner(str_to_id: {}, id_to_str: {}, next_id: 0)
        interner.intern("a")
        expect(interner.next_id).to_equal(1)
        interner.intern("b")
        expect(interner.next_id).to_equal(2)
        interner.intern("a")
        expect(interner.next_id).to_equal(2)

    it "gets string by ID via get()":
        var interner = StringInterner(str_to_id: {}, id_to_str: {}, next_id: 0)
        val id = interner.intern("lookup_me")
        val result = interner.get(id)
        expect(result.?).to_equal(true)
        expect(result?).to_equal("lookup_me")

    it "returns nil for unknown ID via get()":
        val interner = StringInterner(str_to_id: {}, id_to_str: {}, next_id: 0)
        val result = interner.get(999)
        expect(result.?).to_equal(false)

    it "lookup is alias for get":
        var interner = StringInterner(str_to_id: {}, id_to_str: {}, next_id: 0)
        val id = interner.intern("alias_test")
        val result = interner.lookup(id)
        expect(result.?).to_equal(true)
        expect(result?).to_equal("alias_test")

    it "gets ID by string via get_id()":
        var interner = StringInterner(str_to_id: {}, id_to_str: {}, next_id: 0)
        val expected_id = interner.intern("find_me")
        val result = interner.get_id("find_me")
        expect(result.?).to_equal(true)
        expect(result?).to_equal(expected_id)

    it "returns nil for unknown string via get_id()":
        val interner = StringInterner(str_to_id: {}, id_to_str: {}, next_id: 0)
        val result = interner.get_id("nonexistent")
        expect(result.?).to_equal(false)

    it "returns all strings via all_strings()":
        var interner = StringInterner(str_to_id: {}, id_to_str: {}, next_id: 0)
        interner.intern("x")
        interner.intern("y")
        interner.intern("z")
        val all = interner.all_strings()
        expect(all.len()).to_equal(3)

    it "handles empty string interning":
        var interner = StringInterner(str_to_id: {}, id_to_str: {}, next_id: 0)
        val id = interner.intern("")
        val result = interner.get(id)
        expect(result.?).to_equal(true)
        expect(result?).to_equal("")

    it "handles special characters":
        var interner = StringInterner(str_to_id: {}, id_to_str: {}, next_id: 0)
        val id = interner.intern("hello world\ttab")
        val result = interner.get(id)
        expect(result.?).to_equal(true)

    it "exports to SDN table via to_sdn()":
        var interner = StringInterner(str_to_id: {}, id_to_str: {}, next_id: 0)
        interner.intern("alpha")
        interner.intern("beta")
        val table = interner.to_sdn()
        expect(table.name).to_equal("strings")
        expect(table.columns.len()).to_equal(2)
        expect(table.columns[0]).to_equal("id")
        expect(table.columns[1]).to_equal("value")
        expect(table.rows.len()).to_equal(2)

# ============================================================================
# SdnRow Tests
# ============================================================================

describe "SdnRow":
    it "creates empty row with fields dict":
        val row = SdnRow(fields: {})
        expect(row.fields.len()).to_equal(0)

    it "sets and gets a text field":
        var row = SdnRow(fields: {})
        row.set("name", "Alice")
        val result = row.get("name")
        expect(result.?).to_equal(true)
        expect(result?).to_equal("Alice")

    it "returns nil for missing field":
        val row = SdnRow(fields: {})
        val result = row.get("missing")
        expect(result.?).to_equal(false)

    it "gets field as i32":
        var row = SdnRow(fields: {})
        row.set("count", "42")
        val result = row.get_i32("count")
        expect(result.?).to_equal(true)
        expect(result?).to_equal(42)

    it "gets field as i64":
        var row = SdnRow(fields: {})
        row.set("big", "1000000")
        val result = row.get_i64("big")
        expect(result.?).to_equal(true)
        expect(result?).to_equal(1000000)

    it "gets field as i64 with zero value":
        var row = SdnRow(fields: {})
        row.set("zero", "0")
        val result = row.get_i64("zero")
        expect(result.?).to_equal(true)
        expect(result?).to_equal(0)

    it "gets field as bool true":
        var row = SdnRow(fields: {})
        row.set("flag", "true")
        val result = row.get_bool("flag")
        expect(result.?).to_equal(true)
        expect(result?).to_equal(true)

    it "gets field as bool false":
        var row = SdnRow(fields: {})
        row.set("flag", "false")
        val result = row.get_bool("flag")
        expect(result.?).to_equal(true)
        expect(result?).to_equal(false)

    it "returns nil for non-boolean string via get_bool":
        var row = SdnRow(fields: {})
        row.set("flag", "maybe")
        val result = row.get_bool("flag")
        expect(result.?).to_equal(false)

    it "checks field existence with has()":
        var row = SdnRow(fields: {})
        row.set("present", "yes")
        expect(row.has("present")).to_equal(true)
        expect(row.has("absent")).to_equal(false)

    it "overwrites existing field":
        var row = SdnRow(fields: {})
        row.set("key", "old")
        row.set("key", "new")
        expect(row.get("key")?).to_equal("new")

    it "handles multiple fields":
        var row = SdnRow(fields: {})
        row.set("a", "1")
        row.set("b", "2")
        row.set("c", "3")
        expect(row.has("a")).to_equal(true)
        expect(row.has("b")).to_equal(true)
        expect(row.has("c")).to_equal(true)
        expect(row.get("a")?).to_equal("1")
        expect(row.get("c")?).to_equal("3")

# ============================================================================
# SdnTable Tests
# ============================================================================

describe "SdnTable":
    it "creates table with name and columns":
        val table = SdnTable(name: "users", columns: ["id", "name", "email"], rows: [], index: {})
        expect(table.name).to_equal("users")
        expect(table.columns.len()).to_equal(3)
        expect(table.rows.len()).to_equal(0)

    it "adds a row and indexes by id":
        var table = SdnTable(name: "items", columns: ["id", "value"], rows: [], index: {})
        var row = SdnRow(fields: {})
        row.set("id", "item_1")
        row.set("value", "data")
        table.add_row(row)
        expect(table.rows.len()).to_equal(1)

    it "gets row by primary key":
        var table = SdnTable(name: "records", columns: ["id", "data"], rows: [], index: {})
        var row = SdnRow(fields: {})
        row.set("id", "rec_1")
        row.set("data", "payload")
        table.add_row(row)
        val result = table.get_row("rec_1")
        expect(result.?).to_equal(true)
        val r = result ?? SdnRow(fields: {})
        expect(r.get("data")?).to_equal("payload")

    it "returns nil for missing row key":
        val table = SdnTable(name: "empty", columns: ["id"], rows: [], index: {})
        val result = table.get_row("nonexistent")
        expect(result.?).to_equal(false)

    it "updates row by primary key":
        var table = SdnTable(name: "data", columns: ["id", "status"], rows: [], index: {})
        var row1 = SdnRow(fields: {})
        row1.set("id", "r1")
        row1.set("status", "pending")
        table.add_row(row1)
        var row2 = SdnRow(fields: {})
        row2.set("id", "r1")
        row2.set("status", "done")
        val updated = table.update_row("r1", row2)
        expect(updated).to_equal(true)
        val result = table.get_row("r1")
        val r = result ?? SdnRow(fields: {})
        expect(r.get("status")?).to_equal("done")

    it "returns false for updating nonexistent row":
        var table = SdnTable(name: "data", columns: ["id"], rows: [], index: {})
        var row = SdnRow(fields: {})
        row.set("id", "missing")
        val updated = table.update_row("missing", row)
        expect(updated).to_equal(false)

    it "soft deletes row via mark_deleted":
        var table = SdnTable(name: "soft", columns: ["id", "valid"], rows: [], index: {})
        var row = SdnRow(fields: {})
        row.set("id", "del1")
        row.set("valid", "true")
        table.add_row(row)
        val result = table.mark_deleted("del1")
        expect(result).to_equal(true)
        val fetched = table.get_row("del1")
        val r = fetched ?? SdnRow(fields: {})
        expect(r.get("valid")?).to_equal("false")

    it "delete_row is alias for mark_deleted":
        var table = SdnTable(name: "alias", columns: ["id", "valid"], rows: [], index: {})
        var row = SdnRow(fields: {})
        row.set("id", "del2")
        row.set("valid", "true")
        table.add_row(row)
        val result = table.delete_row("del2")
        expect(result).to_equal(true)
        val fetched = table.get_row("del2")
        val r = fetched ?? SdnRow(fields: {})
        expect(r.get("valid")?).to_equal("false")

    it "returns false for deleting nonexistent row":
        var table = SdnTable(name: "data", columns: ["id"], rows: [], index: {})
        val result = table.mark_deleted("ghost")
        expect(result).to_equal(false)

    it "clears all rows and index":
        var table = SdnTable(name: "clearable", columns: ["id"], rows: [], index: {})
        var row = SdnRow(fields: {})
        row.set("id", "c1")
        table.add_row(row)
        expect(table.rows.len()).to_equal(1)
        table.clear()
        expect(table.rows.len()).to_equal(0)

    it "rebuilds index after manual row addition":
        var table = SdnTable(name: "reindex", columns: ["id", "name"], rows: [], index: {})
        var row = SdnRow(fields: {})
        row.set("id", "idx1")
        row.set("name", "test")
        table.rows.push(row)
        # At this point index is empty since we bypassed add_row
        val before = table.get_row("idx1")
        expect(before.?).to_equal(false)
        table.rebuild_index()
        val after = table.get_row("idx1")
        expect(after.?).to_equal(true)

    it "exports to SDN format via to_sdn()":
        var table = SdnTable(name: "export_test", columns: ["id", "name"], rows: [], index: {})
        var row = SdnRow(fields: {})
        row.set("id", "e1")
        row.set("name", "Bob")
        table.add_row(row)
        val sdn = table.to_sdn()
        expect(sdn).to_contain("export_test |id, name|")
        expect(sdn).to_contain("e1, Bob")

    it "parses SDN content via parse":
        val content = "items |id, label|\n    i1, First\n    i2, Second"
        val result = parse_sdn_table(content)
        expect(result.?).to_equal(true)
        val table = result?
        expect(table.name).to_equal("items")
        expect(table.columns.len()).to_equal(2)
        expect(table.rows.len()).to_equal(2)

    it "returns nil for empty content via parse":
        val result = parse_sdn_table("")
        expect(result.?).to_equal(false)

    it "returns nil for content with no table header":
        val result = parse_sdn_table("just some text\nwith no table")
        expect(result.?).to_equal(false)

    it "skips rows with wrong column count during parse":
        val content = "data |a, b, c|\n    1, 2, 3\n    only_one\n    4, 5, 6"
        val result = parse_sdn_table(content)
        expect(result.?).to_equal(true)
        val table = result?
        expect(table.rows.len()).to_equal(2)

    it "roundtrips through to_sdn and parse":
        var table = SdnTable(name: "round", columns: ["key", "value"], rows: [], index: {})
        var row = SdnRow(fields: {})
        row.set("key", "k1")
        row.set("value", "v1")
        table.add_row(row)
        val sdn = table.to_sdn()
        val parsed = parse_sdn_table(sdn)
        expect(parsed.?).to_equal(true)
        val t2 = parsed?
        expect(t2.name).to_equal("round")
        expect(t2.rows.len()).to_equal(1)

    it "adds multiple rows with indexing":
        var table = SdnTable(name: "multi", columns: ["id", "data"], rows: [], index: {})
        for i in 0..10:
            var row = SdnRow(fields: {})
            row.set("id", "row_{i}")
            row.set("data", "data_{i}")
            table.add_row(row)
        expect(table.rows.len()).to_equal(10)
        val r5 = table.get_row("row_5")
        expect(r5.?).to_equal(true)
        val row5 = r5 ?? SdnRow(fields: {})
        expect(row5.get("data")?).to_equal("data_5")

    it "handles empty table operations":
        val table = SdnTable(name: "empty_ops", columns: ["id"], rows: [], index: {})
        expect(table.rows.len()).to_equal(0)
        val sdn = table.to_sdn()
        expect(sdn).to_contain("empty_ops |id|")

# ============================================================================
# SdnDatabase Tests
# ============================================================================

describe "SdnDatabase":
    it "creates new database via new_sdn_database":
        var db = new_sdn_database("/tmp/core_ext_test_new.sdn")
        expect(db.path).to_equal("/tmp/core_ext_test_new.sdn")
        expect(db.modified).to_equal(false)
        expect(db.tables.len()).to_equal(0)

    it "sets and gets a table":
        var db = new_sdn_database("/tmp/core_ext_test_table.sdn")
        val table = SdnTable(name: "my_table", columns: ["id", "col"], rows: [], index: {})
        db.set_table("my_table", table)
        expect(db.tables.len()).to_equal(1)
        val result = db.get_table("my_table")
        expect(result.?).to_equal(true)
        val t = result?
        expect(t.name).to_equal("my_table")

    it "returns nil for missing table":
        var db = new_sdn_database("/tmp/core_ext_test_miss.sdn")
        val result = db.get_table("no_such_table")
        expect(result.?).to_equal(false)

    it "marks modified when setting table":
        var db = new_sdn_database("/tmp/core_ext_test_mod.sdn")
        expect(db.modified).to_equal(false)
        val table = SdnTable(name: "t", columns: ["id"], rows: [], index: {})
        db.set_table("t", table)
        expect(db.modified).to_equal(true)

    it "gets mutable table via get_table_mut":
        var db = new_sdn_database("/tmp/core_ext_test_mut.sdn")
        val table = SdnTable(name: "mut_t", columns: ["id"], rows: [], index: {})
        db.set_table("mut_t", table)
        var mt = db.get_table_mut("mut_t")
        expect(mt.?).to_equal(true)

    it "returns nil for missing table via get_table_mut":
        var db = new_sdn_database("/tmp/core_ext_test_mut_miss.sdn")
        var result = db.get_table_mut("missing")
        expect(result.?).to_equal(false)

    it "replaces existing table":
        var db = new_sdn_database("/tmp/core_ext_test_replace.sdn")
        val t1 = SdnTable(name: "rep", columns: ["old"], rows: [], index: {})
        db.set_table("rep", t1)
        val t2 = SdnTable(name: "rep", columns: ["new_a", "new_b"], rows: [], index: {})
        db.set_table("rep", t2)
        val result = db.get_table("rep")?
        expect(result.columns.len()).to_equal(2)
        expect(result.columns[0]).to_equal("new_a")

    it "adds row to table via helper":
        var db = new_sdn_database("/tmp/core_ext_test_addrow.sdn")
        val table = SdnTable(name: "items", columns: ["id", "val"], rows: [], index: {})
        db.set_table("items", table)
        var row = SdnRow(fields: {})
        row.set("id", "i1")
        row.set("val", "v1")
        val added = db.add_row_to_table("items", row)
        expect(added).to_equal(true)

    it "returns false when adding row to nonexistent table":
        var db = new_sdn_database("/tmp/core_ext_test_addrow_miss.sdn")
        var row = SdnRow(fields: {})
        row.set("id", "i1")
        val added = db.add_row_to_table("missing_table", row)
        expect(added).to_equal(false)

    it "interns strings through database":
        var db = new_sdn_database("/tmp/core_ext_test_intern.sdn")
        val id1 = db.intern("hello")
        val id2 = db.intern("hello")
        val id3 = db.intern("world")
        expect(id1).to_equal(id2)
        expect(id1).to_equal(0)
        expect(id3).to_equal(1)
        expect(db.modified).to_equal(true)

    it "resolves interned string IDs":
        var db = new_sdn_database("/tmp/core_ext_test_resolve.sdn")
        val id = db.intern("resolve_me")
        val result = db.resolve(id)
        expect(result.?).to_equal(true)
        expect(result?).to_equal("resolve_me")

    it "returns nil for unresolved ID":
        var db = new_sdn_database("/tmp/core_ext_test_resolve_miss.sdn")
        val result = db.resolve(999)
        expect(result.?).to_equal(false)

    it "validates empty database with no errors":
        var db = new_sdn_database("/tmp/core_ext_test_validate.sdn")
        val errors = db.validate()
        expect(errors.len()).to_equal(0)

    it "saves database to disk":
        val path = "/tmp/core_ext_test_save.sdn"
        if file_exists(path):
            file_delete(path)
        var db = new_sdn_database(path)
        var table = SdnTable(name: "saved", columns: ["id", "data"], rows: [], index: {})
        var row = SdnRow(fields: {})
        row.set("id", "s1")
        row.set("data", "saved_data")
        table.add_row(row)
        db.set_table("saved", table)
        val result = db.save()
        expect(result).to_equal(true)
        expect(file_exists(path)).to_equal(true)
        file_delete(path)

    it "loads database from disk":
        val path = "/tmp/core_ext_test_load.sdn"
        if file_exists(path):
            file_delete(path)
        var db = new_sdn_database(path)
        var table = SdnTable(name: "loadable", columns: ["id", "info"], rows: [], index: {})
        var row = SdnRow(fields: {})
        row.set("id", "l1")
        row.set("info", "loaded_data")
        table.add_row(row)
        db.set_table("loadable", table)
        db.save()
        val loaded = load_sdn_database(path)
        expect(loaded.?).to_equal(true)
        val db2 = loaded?
        val t = db2.get_table("loadable")
        expect(t.?).to_equal(true)
        file_delete(path)

    it "returns nil when loading nonexistent file":
        val loaded = load_sdn_database("/tmp/core_ext_nonexistent_12345.sdn")
        expect(loaded.?).to_equal(false)

    it "handles multiple tables in database":
        var db = new_sdn_database("/tmp/core_ext_test_multi.sdn")
        for i in 0..3:
            val table = SdnTable(name: "table_{i}", columns: ["id"], rows: [], index: {})
            db.set_table("table_{i}", table)
        expect(db.tables.len()).to_equal(3)
        expect(db.get_table("table_0").?).to_equal(true)
        expect(db.get_table("table_1").?).to_equal(true)
        expect(db.get_table("table_2").?).to_equal(true)

# ============================================================================
# Standalone Function Tests
# ============================================================================

describe "Standalone Functions":
    it "parse_sdn_table parses valid content":
        val content = "test |id, name|\n    1, Alice\n    2, Bob"
        val result = parse_sdn_table(content)
        expect(result.?).to_equal(true)
        val table = result?
        expect(table.name).to_equal("test")
        expect(table.rows.len()).to_equal(2)

    it "parse_sdn_table returns nil for invalid content":
        val result = parse_sdn_table("no table here")
        expect(result.?).to_equal(false)

    it "interner_from_sdn creates interner from table":
        var table = SdnTable(name: "strings", columns: ["id", "value"], rows: [], index: {})
        var row1 = SdnRow(fields: {})
        row1.set("id", "0")
        row1.set("value", "hello")
        table.add_row(row1)
        var row2 = SdnRow(fields: {})
        row2.set("id", "1")
        row2.set("value", "world")
        table.add_row(row2)
        val interner = interner_from_sdn(table)
        expect(interner.next_id).to_equal(2)
        val r1 = interner.get(0)
        expect(r1.?).to_equal(true)
        expect(r1?).to_equal("hello")
        val r2 = interner.get(1)
        expect(r2.?).to_equal(true)
        expect(r2?).to_equal("world")

    it "new_sdn_database creates empty database":
        var db = new_sdn_database("/tmp/standalone_new.sdn")
        expect(db.path).to_equal("/tmp/standalone_new.sdn")
        expect(db.tables.len()).to_equal(0)

    it "load_sdn_database returns nil for missing file":
        val result = load_sdn_database("/tmp/standalone_missing_xyz.sdn")
        expect(result.?).to_equal(false)

    it "save and load roundtrip preserves interner":
        val path = "/tmp/core_ext_interner_roundtrip.sdn"
        if file_exists(path):
            file_delete(path)
        var db = new_sdn_database(path)
        db.intern("apple")
        db.intern("banana")
        db.save()
        val loaded = load_sdn_database(path)
        expect(loaded.?).to_equal(true)
        val db2 = loaded?
        val r1 = db2.resolve(0)
        expect(r1.?).to_equal(true)
        expect(r1?).to_equal("apple")
        val r2 = db2.resolve(1)
        expect(r2.?).to_equal(true)
        expect(r2?).to_equal("banana")
        file_delete(path)

    it "parse_sdn_table skips comment lines":
        val content = "data |id, val|\n# this is a comment\n    a, 1\n    b, 2"
        val result = parse_sdn_table(content)
        expect(result.?).to_equal(true)
        val table = result?
        expect(table.rows.len()).to_equal(2)
