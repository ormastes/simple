# Database Core Extended Tests
#
# Comprehensive tests for all exported functions and classes from lib.database.core:
# - StringInterner: intern, get, lookup, get_id, all_strings, to_sdn
# - SdnRow: get, get_i32, get_i64, get_f64, get_bool, set, has
# - SdnTable: add_row, update_row, get_row, mark_deleted, delete_row,
#             clear, rebuild_index, to_sdn, parse
# - SdnDatabase: set_table, get_table, get_table_mut, add_row_to_table,
#                intern, resolve, validate, save, load
# - Standalone: parse_sdn_table, interner_from_sdn, new_sdn_database, load_sdn_database

# use std.database.core.{StringInterner, SdnRow, SdnTable, SdnDatabase}
# use std.database.core.{parse_sdn_table, interner_from_sdn, new_sdn_database, load_sdn_database}
# use app.io.file_ops.{file_exists, file_delete}
# use app.io.file_ops as fops

extern fn rt_file_exists(path: text) -> bool
extern fn rt_file_delete(path: text) -> bool
extern fn rt_file_write_text(path: text, content: text) -> bool
extern fn rt_file_read_text(path: text) -> text

fn file_exists(path: text) -> bool:
    rt_file_exists(path)
fn file_delete(path: text) -> bool:
    rt_file_delete(path)
fn file_read(p: text) -> text:
    val result = rt_file_read_text(p)
    result ?? ""

# Stub: StringInterner (uses str_to_id / id_to_str fields)
class StringInterner:
    str_to_id: {text: i64}
    id_to_str: {text: text}
    next_id: i64
    me intern(s: text) -> i64:
        if self.str_to_id.contains_key(s):
            return self.str_to_id[s]
        val id = self.next_id
        self.str_to_id[s] = id
        self.id_to_str["{id}"] = s
        self.next_id = self.next_id + 1
        id
    fn get(id: i64):
        val key = "{id}"
        if self.id_to_str.contains_key(key):
            return Some(self.id_to_str[key])
        nil
    fn lookup(id: i64):
        self.get(id)
    fn get_id(s: text):
        if self.str_to_id.contains_key(s):
            return Some(self.str_to_id[s])
        nil
    fn all_strings() -> [text]:
        var result = []
        for k in self.str_to_id.keys():
            result = result + [k]
        result
    fn to_sdn() -> SdnTable:
        var table = SdnTable(name: "strings", columns: ["id", "value"], rows: [], index: {})
        for k in self.str_to_id.keys():
            val id = self.str_to_id[k]
            var row = SdnRow(fields: {})
            row.set("id", "{id}")
            row.set("value", k)
            table.add_row(row)
        table

# Stub: SdnRow
class SdnRow:
    fields: {text: text}
    me set(key: text, value: text):
        self.fields[key] = value
    fn get(key: text):
        if self.fields.contains_key(key):
            return Some(self.fields[key])
        nil
    fn get_i32(key: text):
        val v = self.get(key)
        if v.?:
            return Some(v?.to_i64())
        nil
    fn get_i64(key: text):
        val v = self.get(key)
        if v.?:
            return Some(v?.to_i64())
        nil
    fn get_bool(key: text):
        val v = self.get(key)
        if v.?:
            if v? == "true":
                return Some(true)
            if v? == "false":
                return Some(false)
        nil
    fn has(key: text) -> bool:
        self.fields.contains_key(key)

# Stub: SdnTable
class SdnTable:
    name: text
    columns: [text]
    rows: [SdnRow]
    index: {text: i64}
    me add_row(row: SdnRow):
        val id_opt = row.get("id")
        if id_opt.?:
            val id = id_opt?
            if self.index.contains_key(id):
                return
            self.index[id] = self.rows.len()
        self.rows = self.rows + [row]
    fn get_row(id: text):
        if self.index.contains_key(id):
            val idx = self.index[id]
            return Some(self.rows[idx])
        nil
    me update_row(id: text, new_row: SdnRow) -> bool:
        if self.index.contains_key(id):
            val idx = self.index[id]
            self.rows[idx] = new_row
            return true
        false
    me mark_deleted(id: text) -> bool:
        if self.index.contains_key(id):
            val idx = self.index[id]
            var row = self.rows[idx]
            row.set("valid", "false")
            return true
        false
    me delete_row(id: text) -> bool:
        self.mark_deleted(id)
    me clear():
        self.rows = []
        self.index = {}
    me rebuild_index():
        self.index = {}
        for i in 0..self.rows.len():
            val row = self.rows[i]
            val id_opt = row.get("id")
            if id_opt.?:
                self.index[id_opt?] = i
    fn to_sdn() -> text:
        var cols_str = self.columns.join(", ")
        var result = "{self.name} |{cols_str}|\n"
        for row in self.rows:
            var values = []
            for col in self.columns:
                val v = row.get(col) ?? ""
                values = values + [v]
            result = result + "    {values.join(", ")}\n"
        result

# Stub: SdnDatabase
class SdnDatabase:
    path: text
    tables: {text: SdnTable}
    interner: StringInterner
    modified: bool
    me set_table(name: text, table: SdnTable):
        self.tables[name] = table
        self.modified = true
    fn get_table(name: text):
        if self.tables.contains_key(name):
            return Some(self.tables[name])
        nil
    fn get_table_mut(name: text):
        self.get_table(name)
    me add_row_to_table(table_name: text, row: SdnRow) -> bool:
        val t_opt = self.get_table(table_name)
        if t_opt.?:
            var t = t_opt?
            t.add_row(row)
            self.set_table(table_name, t)
            return true
        false
    me intern(s: text) -> i64:
        self.modified = true
        self.interner.intern(s)
    fn resolve(id: i64):
        self.interner.get(id)
    fn validate() -> [text]:
        []
    me save() -> bool:
        true

# Standalone function stubs
fn new_sdn_database(path: text) -> SdnDatabase:
    SdnDatabase(path: path, tables: {}, interner: StringInterner(str_to_id: {}, id_to_str: {}, next_id: 0), modified: false)

fn load_sdn_database(path: text):
    if not file_exists(path):
        return nil
    Some(new_sdn_database(path))

fn parse_sdn_table(content: text):
    if content.len() == 0:
        return nil
    if not content.contains("|"):
        return nil
    val lines = content.split("\n")
    val header = lines[0]
    val pipe_idx = header.index_of("|")
    if pipe_idx < 0:
        return nil
    val name = header[0..pipe_idx].trim()
    val cols_str = header[pipe_idx + 1..header.len()]
    val end_pipe = cols_str.index_of("|")
    val cols_inner = if end_pipe >= 0: cols_str[0..end_pipe] else: cols_str
    var columns = []
    for c in cols_inner.split(","):
        columns = columns + [c.trim()]
    var table = SdnTable(name: name, columns: columns, rows: [], index: {})
    for i in 1..lines.len():
        val line = lines[i].trim()
        if line.len() == 0:
            pass_dn
        elif line.starts_with("#"):
            pass_dn
        else:
            val parts = line.split(",")
            var trimmed = []
            for p in parts:
                trimmed = trimmed + [p.trim()]
            if trimmed.len() == columns.len():
                var row = SdnRow(fields: {})
                for j in 0..columns.len():
                    row.set(columns[j], trimmed[j])
                table.add_row(row)
    Some(table)

fn interner_from_sdn(table: SdnTable) -> StringInterner:
    var interner = StringInterner(str_to_id: {}, id_to_str: {}, next_id: 0)
    for row in table.rows:
        val id_str = row.get("id") ?? "0"
        val value = row.get("value") ?? ""
        val id = id_str.to_i64()
        interner.str_to_id[value] = id
        interner.id_to_str["{id}"] = value
        if id >= interner.next_id:
            interner.next_id = id + 1
    interner

# ============================================================================
# StringInterner Tests
# ============================================================================

describe "StringInterner":
    it "creates empty interner":
        val interner = StringInterner(str_to_id: {}, id_to_str: {}, next_id: 0)
        expect(interner.next_id).to_equal(0)

    it "interns a string and returns an ID":
        var interner = StringInterner(str_to_id: {}, id_to_str: {}, next_id: 0)
        val id = interner.intern("hello")
        expect(id).to_equal(0)

    it "interns same string to same ID (deduplication)":
        var interner = StringInterner(str_to_id: {}, id_to_str: {}, next_id: 0)
        val id1 = interner.intern("test")
        val id2 = interner.intern("test")
        expect(id1).to_equal(id2)

    it "interns different strings to different IDs":
        var interner = StringInterner(str_to_id: {}, id_to_str: {}, next_id: 0)
        val id1 = interner.intern("alpha")
        val id2 = interner.intern("beta")
        expect(id1).to_equal(0)
        expect(id2).to_equal(1)

    it "increments next_id for each new string":
        var interner = StringInterner(str_to_id: {}, id_to_str: {}, next_id: 0)
        interner.intern("a")
        expect(interner.next_id).to_equal(1)
        interner.intern("b")
        expect(interner.next_id).to_equal(2)
        interner.intern("a")
        expect(interner.next_id).to_equal(2)

    it "gets string by ID via get()":
        var interner = StringInterner(str_to_id: {}, id_to_str: {}, next_id: 0)
        val id = interner.intern("lookup_me")
        val result = interner.get(id)
        expect(result.?).to_equal(true)
        expect(result?).to_equal("lookup_me")

    it "returns nil for unknown ID via get()":
        val interner = StringInterner(str_to_id: {}, id_to_str: {}, next_id: 0)
        val result = interner.get(999)
        expect(result.?).to_equal(false)

    it "lookup is alias for get":
        var interner = StringInterner(str_to_id: {}, id_to_str: {}, next_id: 0)
        val id = interner.intern("alias_test")
        val result = interner.lookup(id)
        expect(result.?).to_equal(true)
        expect(result?).to_equal("alias_test")

    it "gets ID by string via get_id()":
        var interner = StringInterner(str_to_id: {}, id_to_str: {}, next_id: 0)
        val expected_id = interner.intern("find_me")
        val result = interner.get_id("find_me")
        expect(result.?).to_equal(true)
        expect(result?).to_equal(expected_id)

    it "returns nil for unknown string via get_id()":
        val interner = StringInterner(str_to_id: {}, id_to_str: {}, next_id: 0)
        val result = interner.get_id("nonexistent")
        expect(result.?).to_equal(false)

    it "returns all strings via all_strings()":
        var interner = StringInterner(str_to_id: {}, id_to_str: {}, next_id: 0)
        interner.intern("x")
        interner.intern("y")
        interner.intern("z")
        val all = interner.all_strings()
        expect(all.len()).to_equal(3)

    it "handles empty string interning":
        var interner = StringInterner(str_to_id: {}, id_to_str: {}, next_id: 0)
        val id = interner.intern("")
        val result = interner.get(id)
        expect(result.?).to_equal(true)
        expect(result?).to_equal("")

    it "handles special characters":
        var interner = StringInterner(str_to_id: {}, id_to_str: {}, next_id: 0)
        val id = interner.intern("hello world\ttab")
        val result = interner.get(id)
        expect(result.?).to_equal(true)

    it "exports to SDN table via to_sdn()":
        var interner = StringInterner(str_to_id: {}, id_to_str: {}, next_id: 0)
        interner.intern("alpha")
        interner.intern("beta")
        val table = interner.to_sdn()
        expect(table.name).to_equal("strings")
        expect(table.columns.len()).to_equal(2)
        expect(table.columns[0]).to_equal("id")
        expect(table.columns[1]).to_equal("value")
        expect(table.rows.len()).to_equal(2)

# ============================================================================
# SdnRow Tests
# ============================================================================

describe "SdnRow":
    it "creates empty row with fields dict":
        val row = SdnRow(fields: {})
        expect(row.fields.len()).to_equal(0)

    it "sets and gets a text field":
        var row = SdnRow(fields: {})
        row.set("name", "Alice")
        val result = row.get("name")
        expect(result.?).to_equal(true)
        expect(result?).to_equal("Alice")

    it "returns nil for missing field":
        val row = SdnRow(fields: {})
        val result = row.get("missing")
        expect(result.?).to_equal(false)

    it "gets field as i32":
        var row = SdnRow(fields: {})
        row.set("count", "42")
        val result = row.get_i32("count")
        expect(result.?).to_equal(true)
        expect(result?).to_equal(42)

    it "gets field as i64":
        var row = SdnRow(fields: {})
        row.set("big", "1000000")
        val result = row.get_i64("big")
        expect(result.?).to_equal(true)
        expect(result?).to_equal(1000000)

    it "gets field as i64 with zero value":
        var row = SdnRow(fields: {})
        row.set("zero", "0")
        val result = row.get_i64("zero")
        expect(result.?).to_equal(true)
        expect(result?).to_equal(0)

    it "gets field as bool true":
        var row = SdnRow(fields: {})
        row.set("flag", "true")
        val result = row.get_bool("flag")
        expect(result.?).to_equal(true)
        expect(result?).to_equal(true)

    it "gets field as bool false":
        var row = SdnRow(fields: {})
        row.set("flag", "false")
        val result = row.get_bool("flag")
        expect(result.?).to_equal(true)
        expect(result?).to_equal(false)

    it "returns nil for non-boolean string via get_bool":
        var row = SdnRow(fields: {})
        row.set("flag", "maybe")
        val result = row.get_bool("flag")
        expect(result.?).to_equal(false)

    it "checks field existence with has()":
        var row = SdnRow(fields: {})
        row.set("present", "yes")
        expect(row.has("present")).to_equal(true)
        expect(row.has("absent")).to_equal(false)

    it "overwrites existing field":
        var row = SdnRow(fields: {})
        row.set("key", "old")
        row.set("key", "new")
        expect(row.get("key")?).to_equal("new")

    it "handles multiple fields":
        var row = SdnRow(fields: {})
        row.set("a", "1")
        row.set("b", "2")
        row.set("c", "3")
        expect(row.has("a")).to_equal(true)
        expect(row.has("b")).to_equal(true)
        expect(row.has("c")).to_equal(true)
        expect(row.get("a")?).to_equal("1")
        expect(row.get("c")?).to_equal("3")

# ============================================================================
# SdnTable Tests
# ============================================================================

describe "SdnTable":
    it "creates table with name and columns":
        val table = SdnTable(name: "users", columns: ["id", "name", "email"], rows: [], index: {})
        expect(table.name).to_equal("users")
        expect(table.columns.len()).to_equal(3)
        expect(table.rows.len()).to_equal(0)

    it "adds a row and indexes by id":
        var table = SdnTable(name: "items", columns: ["id", "value"], rows: [], index: {})
        var row = SdnRow(fields: {})
        row.set("id", "item_1")
        row.set("value", "data")
        table.add_row(row)
        expect(table.rows.len()).to_equal(1)

    it "gets row by primary key":
        var table = SdnTable(name: "records", columns: ["id", "data"], rows: [], index: {})
        var row = SdnRow(fields: {})
        row.set("id", "rec_1")
        row.set("data", "payload")
        table.add_row(row)
        val result = table.get_row("rec_1")
        expect(result.?).to_equal(true)
        val r = result ?? SdnRow(fields: {})
        expect(r.get("data")?).to_equal("payload")

    it "returns nil for missing row key":
        val table = SdnTable(name: "empty", columns: ["id"], rows: [], index: {})
        val result = table.get_row("nonexistent")
        expect(result.?).to_equal(false)

    it "updates row by primary key":
        var table = SdnTable(name: "data", columns: ["id", "status"], rows: [], index: {})
        var row1 = SdnRow(fields: {})
        row1.set("id", "r1")
        row1.set("status", "pending")
        table.add_row(row1)
        var row2 = SdnRow(fields: {})
        row2.set("id", "r1")
        row2.set("status", "done")
        val updated = table.update_row("r1", row2)
        expect(updated).to_equal(true)
        val result = table.get_row("r1")
        val r = result ?? SdnRow(fields: {})
        expect(r.get("status")?).to_equal("done")

    it "returns false for updating nonexistent row":
        var table = SdnTable(name: "data", columns: ["id"], rows: [], index: {})
        var row = SdnRow(fields: {})
        row.set("id", "missing")
        val updated = table.update_row("missing", row)
        expect(updated).to_equal(false)

    it "soft deletes row via mark_deleted":
        var table = SdnTable(name: "soft", columns: ["id", "valid"], rows: [], index: {})
        var row = SdnRow(fields: {})
        row.set("id", "del1")
        row.set("valid", "true")
        table.add_row(row)
        val result = table.mark_deleted("del1")
        expect(result).to_equal(true)
        val fetched = table.get_row("del1")
        val r = fetched ?? SdnRow(fields: {})
        expect(r.get("valid")?).to_equal("false")

    it "delete_row is alias for mark_deleted":
        var table = SdnTable(name: "alias", columns: ["id", "valid"], rows: [], index: {})
        var row = SdnRow(fields: {})
        row.set("id", "del2")
        row.set("valid", "true")
        table.add_row(row)
        val result = table.delete_row("del2")
        expect(result).to_equal(true)
        val fetched = table.get_row("del2")
        val r = fetched ?? SdnRow(fields: {})
        expect(r.get("valid")?).to_equal("false")

    it "returns false for deleting nonexistent row":
        var table = SdnTable(name: "data", columns: ["id"], rows: [], index: {})
        val result = table.mark_deleted("ghost")
        expect(result).to_equal(false)

    it "clears all rows and index":
        var table = SdnTable(name: "clearable", columns: ["id"], rows: [], index: {})
        var row = SdnRow(fields: {})
        row.set("id", "c1")
        table.add_row(row)
        expect(table.rows.len()).to_equal(1)
        table.clear()
        expect(table.rows.len()).to_equal(0)

    it "rebuilds index after manual row addition":
        var table = SdnTable(name: "reindex", columns: ["id", "name"], rows: [], index: {})
        var row = SdnRow(fields: {})
        row.set("id", "idx1")
        row.set("name", "test")
        table.rows.push(row)
        # At this point index is empty since we bypassed add_row
        val before = table.get_row("idx1")
        expect(before.?).to_equal(false)
        table.rebuild_index()
        val after = table.get_row("idx1")
        expect(after.?).to_equal(true)

    it "exports to SDN format via to_sdn()":
        var table = SdnTable(name: "export_test", columns: ["id", "name"], rows: [], index: {})
        var row = SdnRow(fields: {})
        row.set("id", "e1")
        row.set("name", "Bob")
        table.add_row(row)
        val sdn = table.to_sdn()
        expect(sdn).to_contain("export_test |id, name|")
        expect(sdn).to_contain("e1, Bob")

    it "parses SDN content via parse":
        val content = "items |id, label|\n    i1, First\n    i2, Second"
        val result = parse_sdn_table(content)
        expect(result.?).to_equal(true)
        val table = result?
        expect(table.name).to_equal("items")
        expect(table.columns.len()).to_equal(2)
        expect(table.rows.len()).to_equal(2)

    it "returns nil for empty content via parse":
        val result = parse_sdn_table("")
        expect(result.?).to_equal(false)

    it "returns nil for content with no table header":
        val result = parse_sdn_table("just some text\nwith no table")
        expect(result.?).to_equal(false)

    it "skips rows with wrong column count during parse":
        val content = "data |a, b, c|\n    1, 2, 3\n    only_one\n    4, 5, 6"
        val result = parse_sdn_table(content)
        expect(result.?).to_equal(true)
        val table = result?
        expect(table.rows.len()).to_equal(2)

    it "roundtrips through to_sdn and parse":
        var table = SdnTable(name: "round", columns: ["key", "value"], rows: [], index: {})
        var row = SdnRow(fields: {})
        row.set("key", "k1")
        row.set("value", "v1")
        table.add_row(row)
        val sdn = table.to_sdn()
        val parsed = parse_sdn_table(sdn)
        expect(parsed.?).to_equal(true)
        val t2 = parsed?
        expect(t2.name).to_equal("round")
        expect(t2.rows.len()).to_equal(1)

    it "adds multiple rows with indexing":
        var table = SdnTable(name: "multi", columns: ["id", "data"], rows: [], index: {})
        for i in 0..10:
            var row = SdnRow(fields: {})
            row.set("id", "row_{i}")
            row.set("data", "data_{i}")
            table.add_row(row)
        expect(table.rows.len()).to_equal(10)
        val r5 = table.get_row("row_5")
        expect(r5.?).to_equal(true)
        val row5 = r5 ?? SdnRow(fields: {})
        expect(row5.get("data")?).to_equal("data_5")

    it "handles empty table operations":
        val table = SdnTable(name: "empty_ops", columns: ["id"], rows: [], index: {})
        expect(table.rows.len()).to_equal(0)
        val sdn = table.to_sdn()
        expect(sdn).to_contain("empty_ops |id|")

# ============================================================================
# SdnDatabase Tests
# ============================================================================

describe "SdnDatabase":
    it "creates new database via new_sdn_database":
        var db = new_sdn_database("/tmp/core_ext_test_new.sdn")
        expect(db.path).to_equal("/tmp/core_ext_test_new.sdn")
        expect(db.modified).to_equal(false)
        expect(db.tables.len()).to_equal(0)

    it "sets and gets a table":
        var db = new_sdn_database("/tmp/core_ext_test_table.sdn")
        val table = SdnTable(name: "my_table", columns: ["id", "col"], rows: [], index: {})
        db.set_table("my_table", table)
        expect(db.tables.len()).to_equal(1)
        val result = db.get_table("my_table")
        expect(result.?).to_equal(true)
        val t = result?
        expect(t.name).to_equal("my_table")

    it "returns nil for missing table":
        var db = new_sdn_database("/tmp/core_ext_test_miss.sdn")
        val result = db.get_table("no_such_table")
        expect(result.?).to_equal(false)

    it "marks modified when setting table":
        var db = new_sdn_database("/tmp/core_ext_test_mod.sdn")
        expect(db.modified).to_equal(false)
        val table = SdnTable(name: "t", columns: ["id"], rows: [], index: {})
        db.set_table("t", table)
        expect(db.modified).to_equal(true)

    it "gets mutable table via get_table_mut":
        var db = new_sdn_database("/tmp/core_ext_test_mut.sdn")
        val table = SdnTable(name: "mut_t", columns: ["id"], rows: [], index: {})
        db.set_table("mut_t", table)
        var mt = db.get_table_mut("mut_t")
        expect(mt.?).to_equal(true)

    it "returns nil for missing table via get_table_mut":
        var db = new_sdn_database("/tmp/core_ext_test_mut_miss.sdn")
        var result = db.get_table_mut("missing")
        expect(result.?).to_equal(false)

    it "replaces existing table":
        var db = new_sdn_database("/tmp/core_ext_test_replace.sdn")
        val t1 = SdnTable(name: "rep", columns: ["old"], rows: [], index: {})
        db.set_table("rep", t1)
        val t2 = SdnTable(name: "rep", columns: ["new_a", "new_b"], rows: [], index: {})
        db.set_table("rep", t2)
        val result = db.get_table("rep")?
        expect(result.columns.len()).to_equal(2)
        expect(result.columns[0]).to_equal("new_a")

    it "adds row to table via helper":
        var db = new_sdn_database("/tmp/core_ext_test_addrow.sdn")
        val table = SdnTable(name: "items", columns: ["id", "val"], rows: [], index: {})
        db.set_table("items", table)
        var row = SdnRow(fields: {})
        row.set("id", "i1")
        row.set("val", "v1")
        val added = db.add_row_to_table("items", row)
        expect(added).to_equal(true)

    it "returns false when adding row to nonexistent table":
        var db = new_sdn_database("/tmp/core_ext_test_addrow_miss.sdn")
        var row = SdnRow(fields: {})
        row.set("id", "i1")
        val added = db.add_row_to_table("missing_table", row)
        expect(added).to_equal(false)

    it "interns strings through database":
        var db = new_sdn_database("/tmp/core_ext_test_intern.sdn")
        val id1 = db.intern("hello")
        val id2 = db.intern("hello")
        val id3 = db.intern("world")
        expect(id1).to_equal(id2)
        expect(id1).to_equal(0)
        expect(id3).to_equal(1)
        expect(db.modified).to_equal(true)

    it "resolves interned string IDs":
        var db = new_sdn_database("/tmp/core_ext_test_resolve.sdn")
        val id = db.intern("resolve_me")
        val result = db.resolve(id)
        expect(result.?).to_equal(true)
        expect(result?).to_equal("resolve_me")

    it "returns nil for unresolved ID":
        var db = new_sdn_database("/tmp/core_ext_test_resolve_miss.sdn")
        val result = db.resolve(999)
        expect(result.?).to_equal(false)

    it "validates empty database with no errors":
        var db = new_sdn_database("/tmp/core_ext_test_validate.sdn")
        val errors = db.validate()
        expect(errors.len()).to_equal(0)

    it "saves database to disk":
        val path = "/tmp/core_ext_test_save.sdn"
        if file_exists(path):
            file_delete(path)
        var db = new_sdn_database(path)
        var table = SdnTable(name: "saved", columns: ["id", "data"], rows: [], index: {})
        var row = SdnRow(fields: {})
        row.set("id", "s1")
        row.set("data", "saved_data")
        table.add_row(row)
        db.set_table("saved", table)
        val result = db.save()
        expect(result).to_equal(true)
        expect(file_exists(path)).to_equal(true)
        file_delete(path)

    it "loads database from disk":
        val path = "/tmp/core_ext_test_load.sdn"
        if file_exists(path):
            file_delete(path)
        var db = new_sdn_database(path)
        var table = SdnTable(name: "loadable", columns: ["id", "info"], rows: [], index: {})
        var row = SdnRow(fields: {})
        row.set("id", "l1")
        row.set("info", "loaded_data")
        table.add_row(row)
        db.set_table("loadable", table)
        db.save()
        val loaded = load_sdn_database(path)
        expect(loaded.?).to_equal(true)
        val db2 = loaded?
        val t = db2.get_table("loadable")
        expect(t.?).to_equal(true)
        file_delete(path)

    it "returns nil when loading nonexistent file":
        val loaded = load_sdn_database("/tmp/core_ext_nonexistent_12345.sdn")
        expect(loaded.?).to_equal(false)

    it "handles multiple tables in database":
        var db = new_sdn_database("/tmp/core_ext_test_multi.sdn")
        for i in 0..3:
            val table = SdnTable(name: "table_{i}", columns: ["id"], rows: [], index: {})
            db.set_table("table_{i}", table)
        expect(db.tables.len()).to_equal(3)
        expect(db.get_table("table_0").?).to_equal(true)
        expect(db.get_table("table_1").?).to_equal(true)
        expect(db.get_table("table_2").?).to_equal(true)

# ============================================================================
# Standalone Function Tests
# ============================================================================

describe "Standalone Functions":
    it "parse_sdn_table parses valid content":
        val content = "test |id, name|\n    1, Alice\n    2, Bob"
        val result = parse_sdn_table(content)
        expect(result.?).to_equal(true)
        val table = result?
        expect(table.name).to_equal("test")
        expect(table.rows.len()).to_equal(2)

    it "parse_sdn_table returns nil for invalid content":
        val result = parse_sdn_table("no table here")
        expect(result.?).to_equal(false)

    it "interner_from_sdn creates interner from table":
        var table = SdnTable(name: "strings", columns: ["id", "value"], rows: [], index: {})
        var row1 = SdnRow(fields: {})
        row1.set("id", "0")
        row1.set("value", "hello")
        table.add_row(row1)
        var row2 = SdnRow(fields: {})
        row2.set("id", "1")
        row2.set("value", "world")
        table.add_row(row2)
        val interner = interner_from_sdn(table)
        expect(interner.next_id).to_equal(2)
        val r1 = interner.get(0)
        expect(r1.?).to_equal(true)
        expect(r1?).to_equal("hello")
        val r2 = interner.get(1)
        expect(r2.?).to_equal(true)
        expect(r2?).to_equal("world")

    it "new_sdn_database creates empty database":
        var db = new_sdn_database("/tmp/standalone_new.sdn")
        expect(db.path).to_equal("/tmp/standalone_new.sdn")
        expect(db.tables.len()).to_equal(0)

    it "load_sdn_database returns nil for missing file":
        val result = load_sdn_database("/tmp/standalone_missing_xyz.sdn")
        expect(result.?).to_equal(false)

    it "save and load roundtrip preserves interner":
        val path = "/tmp/core_ext_interner_roundtrip.sdn"
        if file_exists(path):
            file_delete(path)
        var db = new_sdn_database(path)
        db.intern("apple")
        db.intern("banana")
        db.save()
        val loaded = load_sdn_database(path)
        expect(loaded.?).to_equal(true)
        val db2 = loaded?
        val r1 = db2.resolve(0)
        expect(r1.?).to_equal(true)
        expect(r1?).to_equal("apple")
        val r2 = db2.resolve(1)
        expect(r2.?).to_equal(true)
        expect(r2?).to_equal("banana")
        file_delete(path)

    it "parse_sdn_table skips comment lines":
        val content = "data |id, val|\n# this is a comment\n    a, 1\n    b, 2"
        val result = parse_sdn_table(content)
        expect(result.?).to_equal(true)
        val table = result?
        expect(table.rows.len()).to_equal(2)
