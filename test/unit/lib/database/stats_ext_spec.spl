# Database Statistics Extended Tests
#
# Thorough tests for all exported functions from lib.database.stats:
# - calculate_mean, calculate_std_dev, percentile
# - coefficient_of_variation, is_flaky
# - rolling_average, update_baseline, is_significant_change
# - stats_from_values, detect_outliers_iqr

use lib.database.stats.{calculate_mean, calculate_std_dev, percentile, coefficient_of_variation, is_flaky, rolling_average, update_baseline, is_significant_change, stats_from_values, detect_outliers_iqr}

describe "calculate_mean":
    it "returns average of positive values":
        expect(calculate_mean([1.0, 2.0, 3.0, 4.0, 5.0])).to_equal(3.0)

    it "returns average of mixed values":
        expect(calculate_mean([10.0, 20.0, 30.0])).to_equal(20.0)

    it "returns the value for single-element array":
        expect(calculate_mean([42.0])).to_equal(42.0)

    it "returns 0.0 for empty array":
        val empty: [f64] = []
        expect(calculate_mean(empty)).to_equal(0.0)

    it "handles identical values":
        expect(calculate_mean([7.0, 7.0, 7.0, 7.0])).to_equal(7.0)

    it "handles large values":
        expect(calculate_mean([1000000.0, 2000000.0])).to_equal(1500000.0)

    it "handles two values":
        expect(calculate_mean([3.0, 7.0])).to_equal(5.0)

describe "calculate_std_dev":
    it "returns 0.0 for single element":
        expect(calculate_std_dev([5.0], 5.0)).to_equal(0.0)

    it "returns 0.0 for empty array":
        val empty: [f64] = []
        expect(calculate_std_dev(empty, 0.0)).to_equal(0.0)

    it "returns 0.0 for constant values":
        val values = [5.0, 5.0, 5.0, 5.0]
        expect(calculate_std_dev(values, 5.0)).to_equal(0.0)

    it "computes correct std_dev for known dataset":
        # [2, 4, 4, 4, 5, 5, 7, 9], mean = 5.0
        # Variance = sum((v-5)^2) / (8-1) = (9+1+1+1+0+0+4+16)/7 = 32/7 ~ 4.571
        # std_dev ~ 2.138
        val values = [2.0, 4.0, 4.0, 4.0, 5.0, 5.0, 7.0, 9.0]
        val std = calculate_std_dev(values, 5.0)
        val ok = std > 2.0 and std < 2.3
        expect(ok).to_equal(true)

    it "computes std_dev for symmetric distribution":
        # [1, 3, 5, 7, 9], mean = 5.0
        # sum_sq_diff = 16 + 4 + 0 + 4 + 16 = 40, variance = 40/4 = 10, std = sqrt(10) ~ 3.162
        val values = [1.0, 3.0, 5.0, 7.0, 9.0]
        val std = calculate_std_dev(values, 5.0)
        val ok = std > 3.0 and std < 3.3
        expect(ok).to_equal(true)

    it "computes std_dev for two values":
        # [0, 10], mean = 5.0
        # sum_sq_diff = 25 + 25 = 50, variance = 50/1 = 50, std = sqrt(50) ~ 7.071
        val values = [0.0, 10.0]
        val std = calculate_std_dev(values, 5.0)
        val ok = std > 7.0 and std < 7.2
        expect(ok).to_equal(true)

describe "percentile":
    it "returns 0.0 for empty array":
        val empty: [f64] = []
        expect(percentile(empty, 50.0)).to_equal(0.0)

    it "returns the only value for single element":
        expect(percentile([42.0], 50.0)).to_equal(42.0)
        expect(percentile([42.0], 0.0)).to_equal(42.0)
        expect(percentile([42.0], 100.0)).to_equal(42.0)

    it "returns median of odd-count sorted array":
        expect(percentile([1.0, 2.0, 3.0, 4.0, 5.0], 50.0)).to_equal(3.0)

    it "interpolates for even-count sorted array":
        # [1, 2, 3, 4], p50 -> index = 0.5 * 3 = 1.5 -> interpolate between 2.0 and 3.0
        expect(percentile([1.0, 2.0, 3.0, 4.0], 50.0)).to_equal(2.5)

    it "returns min at p0":
        expect(percentile([10.0, 20.0, 30.0], 0.0)).to_equal(10.0)

    it "returns max at p100":
        expect(percentile([10.0, 20.0, 30.0], 100.0)).to_equal(30.0)

    it "returns p25 correctly":
        # [1, 2, 3, 4, 5], p25 -> index = 0.25 * 4 = 1.0 -> exact -> 2.0
        expect(percentile([1.0, 2.0, 3.0, 4.0, 5.0], 25.0)).to_equal(2.0)

    it "returns p75 correctly":
        # [1, 2, 3, 4, 5], p75 -> index = 0.75 * 4 = 3.0 -> exact -> 4.0
        expect(percentile([1.0, 2.0, 3.0, 4.0, 5.0], 75.0)).to_equal(4.0)

    it "interpolates p90 for 10 elements":
        val values = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]
        val p90 = percentile(values, 90.0)
        # index = 0.9 * 9 = 8.1, lower=8 -> 9.0, upper=9 -> 10.0
        # result = 9.0 + (10.0-9.0)*0.1 = 9.1
        val ok = p90 > 9.0 and p90 < 9.2
        expect(ok).to_equal(true)

describe "coefficient_of_variation":
    it "returns 0.0 for empty array":
        val empty: [f64] = []
        expect(coefficient_of_variation(empty)).to_equal(0.0)

    it "returns 0.0 for constant values":
        expect(coefficient_of_variation([5.0, 5.0, 5.0])).to_equal(0.0)

    it "returns 0.0 for all-zero values":
        expect(coefficient_of_variation([0.0, 0.0, 0.0])).to_equal(0.0)

    it "computes CV for known dataset":
        # [10, 20, 30], mean = 20, std_dev = sqrt(200/2) = 10, CV = 10/20 = 0.5
        val cv = coefficient_of_variation([10.0, 20.0, 30.0])
        expect(cv).to_equal(0.5)

    it "higher variance gives higher CV":
        val cv_low = coefficient_of_variation([10.0, 10.5, 10.2])
        val cv_high = coefficient_of_variation([10.0, 50.0, 100.0])
        expect(cv_high).to_be_greater_than(cv_low)

describe "is_flaky":
    it "returns false for fewer than 3 runs":
        expect(is_flaky([10.0], 0.5)).to_equal(false)
        expect(is_flaky([10.0, 100.0], 0.5)).to_equal(false)

    it "returns false for empty timings":
        val empty: [f64] = []
        expect(is_flaky(empty, 0.5)).to_equal(false)

    it "returns true for highly variable timings":
        val timings = [10.0, 100.0, 10.0, 100.0, 10.0]
        expect(is_flaky(timings, 0.5)).to_equal(true)

    it "returns false for stable timings":
        val timings = [10.0, 10.1, 10.0, 9.9, 10.0]
        expect(is_flaky(timings, 0.5)).to_equal(false)

    it "returns false when CV equals threshold exactly":
        # CV = 0.5 exactly is NOT > 0.5, so not flaky
        val timings = [10.0, 20.0, 30.0]
        # CV = 10/20 = 0.5
        expect(is_flaky(timings, 0.5)).to_equal(false)

    it "returns true when CV exceeds threshold":
        val timings = [10.0, 20.0, 30.0]
        # CV = 0.5
        expect(is_flaky(timings, 0.4)).to_equal(true)

    it "detects flaky test with spike":
        val timings = [10.0, 15.0, 100.0, 12.0, 11.0]
        expect(is_flaky(timings, 0.5)).to_equal(true)

describe "rolling_average":
    it "returns 0.0 for empty array":
        val empty: [f64] = []
        expect(rolling_average(empty, 3)).to_equal(0.0)

    it "returns the value for single element":
        expect(rolling_average([42.0], 3)).to_equal(42.0)

    it "averages last N values":
        # values: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], window=3
        # last 3: [8, 9, 10], average = 9.0
        val values = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]
        expect(rolling_average(values, 3)).to_equal(9.0)

    it "uses all values when window exceeds array length":
        expect(rolling_average([1.0, 2.0, 3.0], 10)).to_equal(2.0)

    it "uses all values when window equals array length":
        expect(rolling_average([2.0, 4.0, 6.0], 3)).to_equal(4.0)

    it "window of 1 returns last value":
        expect(rolling_average([1.0, 2.0, 3.0, 100.0], 1)).to_equal(100.0)

describe "update_baseline":
    it "computes exponential moving average with alpha 0.5":
        # alpha=0.5: 0.5*20 + 0.5*10 = 15.0
        expect(update_baseline(10.0, 20.0, 0.5)).to_equal(15.0)

    it "computes with alpha 0.2":
        # alpha=0.2: 0.2*20 + 0.8*10 = 4 + 8 = 12.0
        expect(update_baseline(10.0, 20.0, 0.2)).to_equal(12.0)

    it "alpha 0.0 keeps current baseline":
        expect(update_baseline(10.0, 999.0, 0.0)).to_equal(10.0)

    it "alpha 1.0 replaces with new value":
        expect(update_baseline(10.0, 999.0, 1.0)).to_equal(999.0)

    it "handles zero baseline":
        expect(update_baseline(0.0, 50.0, 0.5)).to_equal(25.0)

    it "handles zero new value":
        expect(update_baseline(100.0, 0.0, 0.5)).to_equal(50.0)

describe "is_significant_change":
    it "returns false for zero baseline":
        expect(is_significant_change(0.0, 100.0, 10.0)).to_equal(false)

    it "detects large increase":
        # 50% change > 40% threshold
        expect(is_significant_change(100.0, 150.0, 40.0)).to_equal(true)

    it "detects large decrease":
        # 50% change > 40% threshold (abs value used)
        expect(is_significant_change(100.0, 50.0, 40.0)).to_equal(true)

    it "does not flag small changes":
        # 5% change < 10% threshold
        expect(is_significant_change(100.0, 105.0, 10.0)).to_equal(false)

    it "does not flag identical values":
        expect(is_significant_change(100.0, 100.0, 1.0)).to_equal(false)

    it "boundary: exactly at threshold is not significant":
        # 10% change is NOT > 10% threshold (strict inequality)
        expect(is_significant_change(100.0, 110.0, 10.0)).to_equal(false)

    it "boundary: just above threshold is significant":
        expect(is_significant_change(100.0, 111.0, 10.0)).to_equal(true)

describe "stats_from_values":
    it "returns zeroed stats for empty array":
        val empty: [f64] = []
        val s = stats_from_values(empty)
        expect(s.mean).to_equal(0.0)
        expect(s.median).to_equal(0.0)
        expect(s.std_dev).to_equal(0.0)
        expect(s.min).to_equal(0.0)
        expect(s.max).to_equal(0.0)
        expect(s.count).to_equal(0)
        expect(s.iqr).to_equal(0.0)

    it "computes stats for single value":
        val s = stats_from_values([42.0])
        expect(s.mean).to_equal(42.0)
        expect(s.median).to_equal(42.0)
        expect(s.std_dev).to_equal(0.0)
        expect(s.min).to_equal(42.0)
        expect(s.max).to_equal(42.0)
        expect(s.count).to_equal(1)

    it "computes stats for 1-10 range":
        val values = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]
        val s = stats_from_values(values)
        expect(s.mean).to_equal(5.5)
        expect(s.count).to_equal(10)
        expect(s.min).to_equal(1.0)
        expect(s.max).to_equal(10.0)
        expect(s.p50).to_equal(5.5)

    it "computes correct median for odd count":
        val s = stats_from_values([3.0, 1.0, 2.0])
        # Sorted: [1, 2, 3], median = 2.0
        expect(s.median).to_equal(2.0)
        expect(s.mean).to_equal(2.0)

    it "sorts values before computing":
        # Unsorted input should still give correct min/max
        val s = stats_from_values([5.0, 1.0, 3.0, 2.0, 4.0])
        expect(s.min).to_equal(1.0)
        expect(s.max).to_equal(5.0)
        expect(s.mean).to_equal(3.0)

    it "p90 and p95 are greater than median":
        val values = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]
        val s = stats_from_values(values)
        expect(s.p90).to_be_greater_than(s.p50)
        expect(s.p95).to_be_greater_than(s.p90)
        expect(s.p99).to_be_greater_than(s.p95)

    it "iqr is non-negative":
        val s = stats_from_values([1.0, 2.0, 3.0, 4.0, 5.0])
        val non_neg = s.iqr >= 0.0
        expect(non_neg).to_equal(true)

describe "detect_outliers_iqr":
    it "returns empty for fewer than 4 values":
        expect(detect_outliers_iqr([1.0]).len()).to_equal(0)
        expect(detect_outliers_iqr([1.0, 2.0]).len()).to_equal(0)
        expect(detect_outliers_iqr([1.0, 2.0, 3.0]).len()).to_equal(0)

    it "returns empty for empty array":
        val empty: [f64] = []
        expect(detect_outliers_iqr(empty).len()).to_equal(0)

    it "detects extreme outlier":
        val values = [1.0, 2.0, 3.0, 4.0, 5.0, 100.0]
        val outliers = detect_outliers_iqr(values)
        expect(outliers.len()).to_equal(1)
        expect(outliers[0]).to_equal(5)

    it "returns no outliers for normal data":
        val values = [1.0, 2.0, 3.0, 4.0, 5.0]
        val outliers = detect_outliers_iqr(values)
        expect(outliers.len()).to_equal(0)

    it "returns no outliers for identical values":
        val values = [5.0, 5.0, 5.0, 5.0, 5.0]
        val outliers = detect_outliers_iqr(values)
        expect(outliers.len()).to_equal(0)

    it "detects both low and high outliers":
        val values = [1.0, 50.0, 51.0, 52.0, 53.0, 100.0]
        val outliers = detect_outliers_iqr(values)
        # 1.0 is low outlier, 100.0 is high outlier
        expect(outliers.len()).to_be_greater_than(0)

    it "returns indices into original array":
        # Outlier detection uses original indices, not sorted indices
        val values = [100.0, 1.0, 2.0, 3.0, 4.0, 5.0]
        val outliers = detect_outliers_iqr(values)
        # 100.0 is at index 0 in original array
        expect(outliers).to_contain(0)
