# Bug Database Helper Function Tests
#
# Tests standalone helper functions from lib.database.bug:
# - severity_to_string / parse_severity (BugSeverity enum)
# - status_to_string / parse_status (BugStatus enum)
#
# Only tests pure functions that do not require database or class instantiation.

use std.database.bug.{severity_to_string, parse_severity, status_to_string, parse_status, BugSeverity, BugStatus}

# ============================================================================
# severity_to_string
# ============================================================================

describe "severity_to_string":
    it "converts P0 to string":
        expect(severity_to_string(BugSeverity.P0)).to_equal("P0")

    it "converts P1 to string":
        expect(severity_to_string(BugSeverity.P1)).to_equal("P1")

    it "converts P2 to string":
        expect(severity_to_string(BugSeverity.P2)).to_equal("P2")

    it "converts P3 to string":
        expect(severity_to_string(BugSeverity.P3)).to_equal("P3")

    it "converts Important to string":
        expect(severity_to_string(BugSeverity.Important)).to_equal("Important")

# ============================================================================
# parse_severity
# ============================================================================

describe "parse_severity":
    it "parses P0":
        val sev = parse_severity("P0")
        expect(severity_to_string(sev)).to_equal("P0")

    it "parses P1":
        val sev = parse_severity("P1")
        expect(severity_to_string(sev)).to_equal("P1")

    it "parses P2":
        val sev = parse_severity("P2")
        expect(severity_to_string(sev)).to_equal("P2")

    it "parses P3":
        val sev = parse_severity("P3")
        expect(severity_to_string(sev)).to_equal("P3")

    it "parses Important":
        val sev = parse_severity("Important")
        expect(severity_to_string(sev)).to_equal("Important")

    it "defaults to P3 for unknown string":
        val sev = parse_severity("Unknown")
        expect(severity_to_string(sev)).to_equal("P3")

    it "defaults to P3 for empty string":
        val sev = parse_severity("")
        expect(severity_to_string(sev)).to_equal("P3")

    it "defaults to P3 for lowercase":
        val sev = parse_severity("p0")
        expect(severity_to_string(sev)).to_equal("P3")

    it "defaults to P3 for random text":
        val sev = parse_severity("critical")
        expect(severity_to_string(sev)).to_equal("P3")

# ============================================================================
# severity roundtrip
# ============================================================================

describe "severity roundtrip":
    it "P0 roundtrips through string":
        val s = severity_to_string(BugSeverity.P0)
        val back = parse_severity(s)
        expect(severity_to_string(back)).to_equal("P0")

    it "P1 roundtrips through string":
        val s = severity_to_string(BugSeverity.P1)
        val back = parse_severity(s)
        expect(severity_to_string(back)).to_equal("P1")

    it "P2 roundtrips through string":
        val s = severity_to_string(BugSeverity.P2)
        val back = parse_severity(s)
        expect(severity_to_string(back)).to_equal("P2")

    it "P3 roundtrips through string":
        val s = severity_to_string(BugSeverity.P3)
        val back = parse_severity(s)
        expect(severity_to_string(back)).to_equal("P3")

    it "Important roundtrips through string":
        val s = severity_to_string(BugSeverity.Important)
        val back = parse_severity(s)
        expect(severity_to_string(back)).to_equal("Important")

# ============================================================================
# status_to_string
# ============================================================================

describe "status_to_string":
    it "converts Open to string":
        expect(status_to_string(BugStatus.Open)).to_equal("Open")

    it "converts Investigating to string":
        expect(status_to_string(BugStatus.Investigating)).to_equal("Investigating")

    it "converts Confirmed to string":
        expect(status_to_string(BugStatus.Confirmed)).to_equal("Confirmed")

    it "converts Fixed to string":
        expect(status_to_string(BugStatus.Fixed)).to_equal("Fixed")

    it "converts Closed to string":
        expect(status_to_string(BugStatus.Closed)).to_equal("Closed")

    it "converts Wontfix to string":
        expect(status_to_string(BugStatus.Wontfix)).to_equal("Wontfix")

# ============================================================================
# parse_status
# ============================================================================

describe "parse_status":
    it "parses Open":
        val st = parse_status("Open")
        expect(status_to_string(st)).to_equal("Open")

    it "parses Investigating":
        val st = parse_status("Investigating")
        expect(status_to_string(st)).to_equal("Investigating")

    it "parses Confirmed":
        val st = parse_status("Confirmed")
        expect(status_to_string(st)).to_equal("Confirmed")

    it "parses Fixed":
        val st = parse_status("Fixed")
        expect(status_to_string(st)).to_equal("Fixed")

    it "parses Closed":
        val st = parse_status("Closed")
        expect(status_to_string(st)).to_equal("Closed")

    it "parses Wontfix":
        val st = parse_status("Wontfix")
        expect(status_to_string(st)).to_equal("Wontfix")

    it "defaults to Open for unknown string":
        val st = parse_status("Unknown")
        expect(status_to_string(st)).to_equal("Open")

    it "defaults to Open for empty string":
        val st = parse_status("")
        expect(status_to_string(st)).to_equal("Open")

    it "defaults to Open for lowercase":
        val st = parse_status("open")
        expect(status_to_string(st)).to_equal("Open")

    it "defaults to Open for random text":
        val st = parse_status("resolved")
        expect(status_to_string(st)).to_equal("Open")

# ============================================================================
# status roundtrip
# ============================================================================

describe "status roundtrip":
    it "Open roundtrips through string":
        val s = status_to_string(BugStatus.Open)
        val back = parse_status(s)
        expect(status_to_string(back)).to_equal("Open")

    it "Investigating roundtrips through string":
        val s = status_to_string(BugStatus.Investigating)
        val back = parse_status(s)
        expect(status_to_string(back)).to_equal("Investigating")

    it "Confirmed roundtrips through string":
        val s = status_to_string(BugStatus.Confirmed)
        val back = parse_status(s)
        expect(status_to_string(back)).to_equal("Confirmed")

    it "Fixed roundtrips through string":
        val s = status_to_string(BugStatus.Fixed)
        val back = parse_status(s)
        expect(status_to_string(back)).to_equal("Fixed")

    it "Closed roundtrips through string":
        val s = status_to_string(BugStatus.Closed)
        val back = parse_status(s)
        expect(status_to_string(back)).to_equal("Closed")

    it "Wontfix roundtrips through string":
        val s = status_to_string(BugStatus.Wontfix)
        val back = parse_status(s)
        expect(status_to_string(back)).to_equal("Wontfix")

# ============================================================================
# Cross-function interaction
# ============================================================================

describe "cross-function interaction":
    it "severity strings are distinct":
        val s0 = severity_to_string(BugSeverity.P0)
        val s1 = severity_to_string(BugSeverity.P1)
        val s2 = severity_to_string(BugSeverity.P2)
        val s3 = severity_to_string(BugSeverity.P3)
        val si = severity_to_string(BugSeverity.Important)
        val all_different = s0 != s1 and s1 != s2 and s2 != s3 and s3 != si
        expect(all_different).to_equal(true)

    it "status strings are distinct":
        val s_open = status_to_string(BugStatus.Open)
        val s_inv = status_to_string(BugStatus.Investigating)
        val s_conf = status_to_string(BugStatus.Confirmed)
        val s_fix = status_to_string(BugStatus.Fixed)
        val s_close = status_to_string(BugStatus.Closed)
        val s_wont = status_to_string(BugStatus.Wontfix)
        val d1 = s_open != s_inv and s_inv != s_conf
        val d2 = s_conf != s_fix and s_fix != s_close
        val d3 = s_close != s_wont
        val all_distinct = d1 and d2 and d3
        expect(all_distinct).to_equal(true)

    it "severity and status strings do not overlap":
        val sev_str = severity_to_string(BugSeverity.P0)
        val stat_str = status_to_string(BugStatus.Open)
        val different = sev_str != stat_str
        expect(different).to_equal(true)

    it "parse_severity does not interfere with parse_status":
        val sev = parse_severity("Open")
        val stat = parse_status("P0")
        # "Open" is unknown severity -> defaults to P3
        expect(severity_to_string(sev)).to_equal("P3")
        # "P0" is unknown status -> defaults to Open
        expect(status_to_string(stat)).to_equal("Open")
