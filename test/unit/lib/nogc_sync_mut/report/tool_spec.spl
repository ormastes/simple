describe "Tool":
    it "skipped":
        skip("pre-existing test failures - functions/imports not available")

# # # Tool Reports Specification
# #
# # **Feature IDs:** #RPT-007
# # **Category:** Infrastructure
# # **Difficulty:** 3/5
# # **Status:** Implemented
# #
# # ## Overview
# #
# # Tests for tool-specific reports from the unified reporting system.
# # Verifies LintReport, TestReport, BuildReport, and related types.
# #
# # ## Key Concepts
# #
# # | Concept | Description |
# # |---------|-------------|
# # | LintReport | Report for linter warnings/errors |
# # | TestReport | Report for test results |
# # | BuildReport | Report for build status |
# 
# use std.report.*
# use std.report.tool.*
# 
# # ============================================================================
# # Test Group 1: LintReport
# # ============================================================================
# 
# describe "LintReport":
#     # ## LintReport
#     #
#     # Tests for lint reports.
# 
#     context "creation":
#         # ### Lint Report Creation
#         #
#         # Lint reports can be created with different severities.
# 
#         it "creates warning":
#             val loc = SourceLocation__at("test.spl", 10, 5)
#             val report = LintReport__warning("L:unused", "unused variable", loc)
#             expect(report.severity).to_equal(LintSeverity.Warning)
#             expect(report.rule_id).to_equal("L:unused")
# 
#         it "creates error":
#             val loc = SourceLocation__at("test.spl", 10, 5)
#             val report = LintReport__error("L:security", "security issue", loc)
#             expect(report.severity).to_equal(LintSeverity.Error)
# 
#         it "creates info":
#             val loc = SourceLocation__at("test.spl", 10, 5)
#             val report = LintReport__info("L:style", "style suggestion", loc)
#             expect(report.severity).to_equal(LintSeverity.Info)
# 
#     context "builder pattern":
#         # ### Builder Pattern
#         #
#         # Lint reports support builder methods.
# 
#         it "adds note":
#             val loc = SourceLocation__at("test.spl", 10, 5)
#             val report = LintReport__warning("L:test", "message", loc)
#                 .with_note("additional info")
#             expect(report.notes.len()).to_equal(1)
# 
#         it "adds fix suggestion":
#             val loc = SourceLocation__at("test.spl", 10, 5)
#             val suggestion = Suggestion__replace(loc, "new_code", "fix it")
#             val report = LintReport__warning("L:test", "message", loc)
#                 .with_suggestion(suggestion)
#             expect(report.suggestion.?).to_equal(true)
# 
#         it "sets category":
#             val loc = SourceLocation__at("test.spl", 10, 5)
#             val report = LintReport__warning("L:test", "message", loc)
#                 .with_category(LintCategory.Style)
#             expect(report.category).to_equal(LintCategory.Style)
# 
#     context "conversion":
#         # ### Conversion to Report
#         #
#         # Lint reports can convert to standard reports.
# 
#         it "converts to warning report":
#             val loc = SourceLocation__at("test.spl", 10, 5)
#             val lint = LintReport__warning("L:test", "message", loc)
#             val report = lint.to_report()
#             expect(report.level).to_equal(ReportLevel.Warning)
#             expect(report.code.unwrap()).to_equal("L:test")
# 
# describe "LintRule":
#     # ## LintRule
#     #
#     # Tests for lint rule definitions.
# 
#     context "creation":
#         # ### Rule Creation
#         #
#         # Lint rules define linting behavior.
# 
#         it "creates rule":
#             val rule = LintRule__create("L:unused_var", "detects unused variables")
#             expect(rule.id).to_equal("L:unused_var")
#             expect(rule.description).to_equal("detects unused variables")
# 
#         it "rule has default severity":
#             val rule = LintRule__create("L:test", "test rule")
#             expect(rule.default_severity).to_equal(LintSeverity.Warning)
# 
#         it "creates rule with severity":
#             val rule = LintRule__with_severity(
#                 "L:security",
#                 "security issue",
#                 LintSeverity.Error
#             )
#             expect(rule.default_severity).to_equal(LintSeverity.Error)
# 
#     context "category":
#         # ### Rule Categories
#         #
#         # Rules belong to categories.
# 
#         it "sets category":
#             val rule = LintRule__create("L:test", "test")
#                 .in_category(LintCategory.Correctness)
#             expect(rule.category).to_equal(LintCategory.Correctness)
# 
# describe "LintSummary":
#     # ## LintSummary
#     #
#     # Tests for lint result summaries.
# 
#     context "creation":
#         # ### Summary Creation
#         #
#         # Summaries aggregate lint results.
# 
#         it "creates empty summary":
#             val summary = LintSummary__empty()
#             expect(summary.total()).to_equal(0)
# 
#     context "adding results":
#         # ### Adding Results
#         #
#         # Results can be added to summaries.
# 
#         it "adds result":
#             val summary = LintSummary__empty()
#             val loc = SourceLocation__at("test.spl", 10, 5)
#             val result = LintResult__warning("L:test", "message", loc)
#             summary.add_result(result)
#             expect(summary.total()).to_equal(1)
# 
#         it "counts warnings":
#             val summary = LintSummary__empty()
#             val loc = SourceLocation__at("test.spl", 10, 5)
#             summary.add_result(LintResult__warning("L:w1", "warning 1", loc))
#             summary.add_result(LintResult__warning("L:w2", "warning 2", loc))
#             summary.add_result(LintResult__error("L:e1", "error 1", loc))
#             expect(summary.warning_count()).to_equal(2)
# 
#         it "counts errors":
#             val summary = LintSummary__empty()
#             val loc = SourceLocation__at("test.spl", 10, 5)
#             summary.add_result(LintResult__error("L:e1", "error 1", loc))
#             summary.add_result(LintResult__error("L:e2", "error 2", loc))
#             expect(summary.error_count()).to_equal(2)
# 
#     context "formatting":
#         # ### Summary Formatting
#         #
#         # Summaries can be formatted.
# 
#         it "formats with counts":
#             val summary = LintSummary__empty()
#             val loc = SourceLocation__at("test.spl", 10, 5)
#             summary.add_result(LintResult__warning("L:test", "message", loc))
#             val formatted = summary.format(false)  # no colors
#             expect(formatted).to_contain("1")
#             expect(formatted).to_contain("warning")
# 
# # ============================================================================
# # Test Group 2: TestReport
# # ============================================================================
# 
# describe "TestResult":
#     # ## TestResult
#     #
#     # Tests for test result types.
# 
#     context "creation":
#         # ### Result Creation
#         #
#         # Test results indicate pass/fail status.
# 
#         it "creates passed result":
#             val result = TestResult__passed("test_add", 50)  # 50ms
#             expect(result.status).to_equal(TestStatus.Passed)
#             expect(result.name).to_equal("test_add")
#             expect(result.duration_ms).to_equal(50)
# 
#         it "creates failed result":
#             val failure = TestFailure__assertion("expected 5, got 4")
#             val result = TestResult__failed("test_add", 100, failure)
#             expect(result.status).to_equal(TestStatus.Failed)
#             expect(result.failure.?).to_equal(true)
# 
#         it "creates skipped result":
#             val result = TestResult__skipped("test_slow", "too slow")
#             expect(result.status).to_equal(TestStatus.Skipped)
# 
#         it "creates errored result":
#             val result = TestResult__errored("test_crash", "panic occurred")
#             expect(result.status).to_equal(TestStatus.Errored)
# 
#     context "predicates":
#         # ### Result Predicates
#         #
#         # Results have predicate methods.
# 
#         it "is_passed returns true for passed":
#             val result = TestResult__passed("test", 50)
#             expect(result.is_passed()).to_equal(true)
# 
#         it "is_passed returns false for failed":
#             val failure = TestFailure__assertion("failed")
#             val result = TestResult__failed("test", 50, failure)
#             expect(result.is_passed()).to_equal(false)
# 
#         it "is_failed returns true for failed":
#             val failure = TestFailure__assertion("failed")
#             val result = TestResult__failed("test", 50, failure)
#             expect(result.is_failed()).to_equal(true)
# 
# describe "TestFailure":
#     # ## TestFailure
#     #
#     # Tests for test failure details.
# 
#     context "creation":
#         # ### Failure Creation
#         #
#         # Failures capture why tests failed.
# 
#         it "creates assertion failure":
#             val failure = TestFailure__assertion("expected 5, got 4")
#             expect(failure.message).to_contain("expected")
# 
#         it "creates timeout failure":
#             val failure = TestFailure__timeout(5000)  # 5s timeout
#             expect(failure.message).to_contain("timeout")
# 
#         it "creates panic failure":
#             val failure = TestFailure__panic("assertion failed: x > 0")
#             expect(failure.message).to_contain("panic")
# 
#     context "location":
#         # ### Failure Location
#         #
#         # Failures can have location info.
# 
#         it "adds location":
#             val failure = TestFailure__assertion("test")
#                 .at("test_spec.spl", 42, 10)
#             expect(failure.location.?).to_equal(true)
#             expect(failure.location.unwrap().line).to_equal(42)
# 
# describe "TestSuite":
#     # ## TestSuite
#     #
#     # Tests for test suite management.
# 
#     context "creation":
#         # ### Suite Creation
#         #
#         # Test suites group related tests.
# 
#         it "creates named suite":
#             val suite = TestSuite__named("math_tests")
#             expect(suite.name).to_equal("math_tests")
#             expect(suite.count()).to_equal(0)
# 
#     context "adding tests":
#         # ### Adding Tests
#         #
#         # Tests can be added to suites.
# 
#         it "adds test result":
#             val suite = TestSuite__named("tests")
#             suite.add(TestResult__passed("test_1", 50))
#             expect(suite.count()).to_equal(1)
# 
#         it "adds multiple results":
#             val suite = TestSuite__named("tests")
#             suite.add(TestResult__passed("test_1", 50))
#             suite.add(TestResult__passed("test_2", 75))
#             suite.add(TestResult__failed("test_3", 100, TestFailure__assertion("fail")))
#             expect(suite.count()).to_equal(3)
# 
#     context "statistics":
#         # ### Suite Statistics
#         #
#         # Suites track pass/fail counts.
# 
#         it "counts passed":
#             val suite = TestSuite__named("tests")
#             suite.add(TestResult__passed("test_1", 50))
#             suite.add(TestResult__passed("test_2", 50))
#             suite.add(TestResult__failed("test_3", 50, TestFailure__assertion("fail")))
#             expect(suite.passed_count()).to_equal(2)
# 
#         it "counts failed":
#             val suite = TestSuite__named("tests")
#             suite.add(TestResult__passed("test_1", 50))
#             suite.add(TestResult__failed("test_2", 50, TestFailure__assertion("fail")))
#             suite.add(TestResult__failed("test_3", 50, TestFailure__assertion("fail")))
#             expect(suite.failed_count()).to_equal(2)
# 
#         it "calculates total duration":
#             val suite = TestSuite__named("tests")
#             suite.add(TestResult__passed("test_1", 50))
#             suite.add(TestResult__passed("test_2", 100))
#             suite.add(TestResult__passed("test_3", 150))
#             expect(suite.total_duration_ms()).to_equal(300)
# 
#         it "all_passed returns true when all pass":
#             val suite = TestSuite__named("tests")
#             suite.add(TestResult__passed("test_1", 50))
#             suite.add(TestResult__passed("test_2", 50))
#             expect(suite.all_passed()).to_equal(true)
# 
#         it "all_passed returns false with failures":
#             val suite = TestSuite__named("tests")
#             suite.add(TestResult__passed("test_1", 50))
#             suite.add(TestResult__failed("test_2", 50, TestFailure__assertion("fail")))
#             expect(suite.all_passed()).to_equal(false)
# 
# describe "TestSummary":
#     # ## TestSummary
#     #
#     # Tests for test summary reports.
# 
#     context "creation":
#         # ### Summary Creation
#         #
#         # Summaries aggregate suite results.
# 
#         it "creates empty summary":
#             val summary = TestSummary__empty()
#             expect(summary.suite_count()).to_equal(0)
# 
#     context "adding suites":
#         # ### Adding Suites
#         #
#         # Suites can be added to summaries.
# 
#         it "adds suite":
#             val summary = TestSummary__empty()
#             val suite = TestSuite__named("tests")
#             suite.add(TestResult__passed("test", 50))
#             summary.add_suite(suite)
#             expect(summary.suite_count()).to_equal(1)
# 
#     context "totals":
#         # ### Summary Totals
#         #
#         # Summaries provide total counts.
# 
#         it "calculates total tests":
#             val summary = TestSummary__empty()
#             val suite1 = TestSuite__named("suite1")
#             suite1.add(TestResult__passed("test_1", 50))
#             suite1.add(TestResult__passed("test_2", 50))
#             val suite2 = TestSuite__named("suite2")
#             suite2.add(TestResult__passed("test_3", 50))
#             summary.add_suite(suite1)
#             summary.add_suite(suite2)
#             expect(summary.total_tests()).to_equal(3)
# 
# # ============================================================================
# # Test Group 3: BuildReport
# # ============================================================================
# 
# describe "BuildResult":
#     # ## BuildResult
#     #
#     # Tests for build result types.
# 
#     context "creation":
#         # ### Result Creation
#         #
#         # Build results indicate success/failure.
# 
#         it "creates success result":
#             val result = BuildResult__success(1500)  # 1500ms
#             expect(result.status).to_equal(BuildStatus.Success)
#             expect(result.duration_ms).to_equal(1500)
# 
#         it "creates failure result":
#             val result = BuildResult__failure(2000)
#             expect(result.status).to_equal(BuildStatus.Failure)
# 
#         it "creates partial result":
#             val result = BuildResult__partial(1000)
#             expect(result.status).to_equal(BuildStatus.Partial)
# 
#     context "errors and warnings":
#         # ### Errors and Warnings
#         #
#         # Build results track errors and warnings.
# 
#         it "adds error":
#             val result = BuildResult__failure(1000)
#             val error = BuildError__compile("type mismatch", "main.spl", 10)
#             result.add_error(error)
#             expect(result.errors.len()).to_equal(1)
# 
#         it "adds warning":
#             val result = BuildResult__success(1000)
#             val warning = BuildWarning__unused("unused variable 'x'", "main.spl", 5)
#             result.add_warning(warning)
#             expect(result.warnings.len()).to_equal(1)
# 
#         it "has_errors returns true with errors":
#             val result = BuildResult__failure(1000)
#             result.add_error(BuildError__compile("error", "file.spl", 1))
#             expect(result.has_errors()).to_equal(true)
# 
#         it "has_warnings returns true with warnings":
#             val result = BuildResult__success(1000)
#             result.add_warning(BuildWarning__unused("warning", "file.spl", 1))
#             expect(result.has_warnings()).to_equal(true)
# 
#     context "artifacts":
#         # ### Build Artifacts
#         #
#         # Build results track output artifacts.
# 
#         it "adds artifact":
#             val result = BuildResult__success(1000)
#             result.add_artifact("target/release/myapp")
#             expect(result.artifacts.len()).to_equal(1)
# 
#         it "adds multiple artifacts":
#             val result = BuildResult__success(1000)
#             result.add_artifact("target/release/myapp")
#             result.add_artifact("target/release/libmylib.so")
#             expect(result.artifacts.len()).to_equal(2)
# 
# describe "BuildError":
#     # ## BuildError
#     #
#     # Tests for build error types.
# 
#     context "creation":
#         # ### Error Creation
#         #
#         # Build errors capture failure details.
# 
#         it "creates compile error":
#             val error = BuildError__compile("type mismatch", "main.spl", 10)
#             expect(error.kind).to_equal("compile")
#             expect(error.message).to_equal("type mismatch")
# 
#         it "creates link error":
#             val error = BuildError__link("undefined symbol 'foo'")
#             expect(error.kind).to_equal("link")
# 
#         it "creates missing dependency error":
#             val error = BuildError__missing_dependency("libssl")
#             expect(error.kind).to_equal("dependency")
#             expect(error.message).to_contain("libssl")
# 
# describe "BuildStep":
#     # ## BuildStep
#     #
#     # Tests for build step tracking.
# 
#     context "creation":
#         # ### Step Creation
#         #
#         # Build steps track compilation phases.
# 
#         it "creates step":
#             val step = BuildStep__create("compile", "main.spl")
#             expect(step.name).to_equal("compile")
#             expect(step.target).to_equal("main.spl")
# 
#     context "completion":
#         # ### Step Completion
#         #
#         # Steps track completion status.
# 
#         it "marks complete":
#             val step = BuildStep__create("compile", "main.spl")
#             step.complete(100)  # 100ms
#             expect(step.is_complete()).to_equal(true)
#             expect(step.duration_ms).to_equal(100)
# 
#         it "marks failed":
#             val step = BuildStep__create("compile", "main.spl")
#             step.fail("compilation error")
#             expect(step.is_failed()).to_equal(true)
#             expect(step.error.?).to_equal(true)
# 
