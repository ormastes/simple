# # Runtime Reports Specification
#
# **Feature IDs:** #RPT-006
# **Category:** Infrastructure
# **Difficulty:** 3/5
# **Status:** Implemented
#
# ## Overview
#
# Tests for runtime-specific reports from the unified reporting system.
# Verifies PanicReport, Logger, MemoryReport, and related types.
#
# ## Key Concepts
#
# | Concept | Description |
# |---------|-------------|
# | PanicReport | Report for runtime panics with stack traces |
# | Logger | Debug logging with levels and targets |
# | MemoryReport | Memory diagnostics and GC statistics |

use std.report.*
use std.report.runtime.*

# ============================================================================
# Test Group 1: PanicReport
# ============================================================================

describe "PanicReport":
    # ## PanicReport
    #
    # Tests for runtime panic reports.

    context "creation":
        # ### Panic Creation
        #
        # Panics can be created for various runtime failures.

        it "creates assertion panic":
            val panic = PanicReport__assertion("x must be positive")
            expect(panic.kind).to_equal(PanicKind.Assertion)
            expect(panic.message).to_contain("x must be positive")

        it "creates index panic":
            val panic = PanicReport__index_out_of_bounds(10, 5)
            expect(panic.kind).to_equal(PanicKind.IndexOutOfBounds)
            expect(panic.message).to_contain("10")
            expect(panic.message).to_contain("5")

        it "creates null panic":
            val panic = PanicReport__null_reference("optional_value")
            expect(panic.kind).to_equal(PanicKind.NullReference)

        it "creates overflow panic":
            val panic = PanicReport__arithmetic_overflow("addition")
            expect(panic.kind).to_equal(PanicKind.ArithmeticOverflow)

        it "creates division by zero panic":
            val panic = PanicReport__division_by_zero()
            expect(panic.kind).to_equal(PanicKind.DivisionByZero)

        it "creates stack overflow panic":
            val panic = PanicReport__stack_overflow()
            expect(panic.kind).to_equal(PanicKind.StackOverflow)

        it "creates out of memory panic":
            val panic = PanicReport__out_of_memory(1024 * 1024)
            expect(panic.kind).to_equal(PanicKind.OutOfMemory)

        it "creates unreachable panic":
            val panic = PanicReport__unreachable("invalid state")
            expect(panic.kind).to_equal(PanicKind.Unreachable)

    context "builder pattern":
        # ### Builder Pattern
        #
        # Panics support builder pattern for additional info.

        it "adds location":
            val panic = PanicReport__assertion("test")
                .at("main.spl", 42, 10)
            expect(panic.location.?).to_equal(true)
            expect(panic.location.unwrap().line).to_equal(42)

        it "adds context variable":
            val panic = PanicReport__assertion("x must be positive")
                .with_context("x", "-5")
            expect(panic.context.len()).to_equal(1)

        it "adds multiple context variables":
            val panic = PanicReport__assertion("invalid range")
                .with_context("start", "10")
                .with_context("end", "5")
            expect(panic.context.len()).to_equal(2)

        it "adds note":
            val panic = PanicReport__assertion("test")
                .with_note("this should not happen")
            expect(panic.notes.len()).to_equal(1)

    context "stack trace":
        # ### Stack Trace
        #
        # Panics can include stack traces.

        it "adds stack frame":
            val frame = StackFrame__at("main", "main.spl", 10)
            val panic = PanicReport__assertion("test")
                .with_frame(frame)
            expect(panic.stack_trace.frames.len()).to_equal(1)

        it "adds stack trace":
            var trace = StackTrace__empty()
            trace.push(StackFrame__at("inner", "lib.spl", 5))
            trace.push(StackFrame__at("outer", "main.spl", 10))
            val panic = PanicReport__assertion("test")
                .with_stack_trace(trace)
            expect(panic.stack_trace.frames.len()).to_equal(2)

    context "conversion":
        # ### Conversion to Report
        #
        # Panics can be converted to standard reports.

        it "converts to fatal report":
            val panic = PanicReport__assertion("test")
                .at("main.spl", 10, 5)
            val report = panic.to_report()
            expect(report.level).to_equal(ReportLevel.Fatal)
            expect(report.kind).to_equal(ReportKind.Panic)

    context "panic codes":
        # ### Panic Codes
        #
        # Each panic kind has a unique code.

        it "assertion has code P0001":
            val panic = PanicReport__assertion("test")
            expect(panic.code()).to_equal("P0001")

        it "index out of bounds has code P0002":
            val panic = PanicReport__index_out_of_bounds(10, 5)
            expect(panic.code()).to_equal("P0002")

        it "null reference has code P0003":
            val panic = PanicReport__null_reference("x")
            expect(panic.code()).to_equal("P0003")

# ============================================================================
# Test Group 2: StackFrame and StackTrace
# ============================================================================

describe "StackFrame":
    # ## StackFrame
    #
    # Tests for stack frame information.

    context "creation":
        # ### Frame Creation
        #
        # Stack frames capture call site information.

        it "creates frame at location":
            val frame = StackFrame__at("my_function", "module.spl", 42)
            expect(frame.function_name).to_equal("my_function")
            expect(frame.file).to_equal("module.spl")
            expect(frame.line).to_equal(42)

        it "creates frame with column":
            val frame = StackFrame__full("my_function", "module.spl", 42, 10)
            expect(frame.column.?).to_equal(true)
            expect(frame.column.unwrap()).to_equal(10)

        it "creates unknown frame":
            val frame = StackFrame__unknown()
            expect(frame.function_name).to_equal("<unknown>")

    context "formatting":
        # ### Frame Formatting
        #
        # Frames can be formatted for display.

        it "formats as string":
            val frame = StackFrame__at("my_func", "test.spl", 10)
            val formatted = frame.format()
            expect(formatted).to_contain("my_func")
            expect(formatted).to_contain("test.spl")
            expect(formatted).to_contain("10")

describe "StackTrace":
    # ## StackTrace
    #
    # Tests for stack trace management.

    context "operations":
        # ### Stack Trace Operations
        #
        # Stack traces support push, pop, and traversal.

        it "creates empty trace":
            var trace = StackTrace__empty()
            expect(trace.is_empty()).to_equal(true)

        it "pushes frames":
            var trace = StackTrace__empty()
            trace.push(StackFrame__at("a", "a.spl", 1))
            trace.push(StackFrame__at("b", "b.spl", 2))
            expect(trace.depth()).to_equal(2)

        it "pops frames":
            var trace = StackTrace__empty()
            trace.push(StackFrame__at("a", "a.spl", 1))
            trace.push(StackFrame__at("b", "b.spl", 2))
            val popped = trace.pop()
            expect(popped.?).to_equal(true)
            expect(popped.unwrap().function_name).to_equal("b")
            expect(trace.depth()).to_equal(1)

        it "gets top frame":
            var trace = StackTrace__empty()
            trace.push(StackFrame__at("a", "a.spl", 1))
            trace.push(StackFrame__at("b", "b.spl", 2))
            val top = trace.top()
            expect(top.?).to_equal(true)
            expect(top.unwrap().function_name).to_equal("b")

# ============================================================================
# Test Group 3: Logger
# ============================================================================

describe "Logger":
    # ## Logger
    #
    # Tests for debug logging system.

    context "creation":
        # ### Logger Creation
        #
        # Loggers can be created with names and configurations.

        it "creates named logger":
            val logger = Logger__named("my_module")
            expect(logger.name).to_equal("my_module")

        it "creates root logger":
            val logger = Logger__root()
            expect(logger.name).to_equal("root")

        it "creates child logger":
            val parent = Logger__named("parent")
            val child = parent.child("child")
            expect(child.name).to_equal("parent.child")

    context "logging levels":
        # ### Logging Levels
        #
        # Loggers filter messages by level.

        it "has default level Info":
            val logger = Logger__named("test")
            expect(logger.level).to_equal(ReportLevel.Info)

        it "sets level":
            val logger = Logger__named("test")
            logger.set_level(ReportLevel.Debug)
            expect(logger.level).to_equal(ReportLevel.Debug)

        it "should_log returns true for higher levels":
            val logger = Logger__named("test")
            logger.set_level(ReportLevel.Warning)
            expect(logger.should_log(ReportLevel.Error)).to_equal(true)

        it "should_log returns false for lower levels":
            val logger = Logger__named("test")
            logger.set_level(ReportLevel.Warning)
            expect(logger.should_log(ReportLevel.Info)).to_equal(false)

    context "log entries":
        # ### Log Entries
        #
        # Loggers create entries with metadata.

        it "creates debug entry":
            val logger = Logger__named("test")
            logger.set_level(ReportLevel.Debug)
            val entry = logger.debug("debug message")
            expect(entry.level).to_equal(ReportLevel.Debug)
            expect(entry.message).to_equal("debug message")

        it "creates info entry":
            val logger = Logger__named("test")
            val entry = logger.info("info message")
            expect(entry.level).to_equal(ReportLevel.Info)

        it "creates warning entry":
            val logger = Logger__named("test")
            val entry = logger.warn("warning message")
            expect(entry.level).to_equal(ReportLevel.Warning)

        it "creates error entry":
            val logger = Logger__named("test")
            val entry = logger.error("error message")
            expect(entry.level).to_equal(ReportLevel.Error)

        it "entry includes logger name":
            val logger = Logger__named("my_module")
            val entry = logger.info("test")
            expect(entry.logger_name).to_equal("my_module")

describe "LogEntry":
    # ## LogEntry
    #
    # Tests for log entry structure.

    context "creation":
        # ### Entry Creation
        #
        # Log entries capture logging information.

        it "creates entry with all fields":
            val entry = LogEntry__create(
                ReportLevel.Info,
                "test message",
                "my_logger"
            )
            expect(entry.level).to_equal(ReportLevel.Info)
            expect(entry.message).to_equal("test message")
            expect(entry.logger_name).to_equal("my_logger")

    context "formatting":
        # ### Entry Formatting
        #
        # Entries can be formatted for output.

        it "formats with level":
            val entry = LogEntry__create(ReportLevel.Info, "test", "logger")
            val formatted = entry.format()
            expect(formatted).to_contain("INFO")
            expect(formatted).to_contain("test")

# ============================================================================
# Test Group 4: MemoryReport
# ============================================================================

describe "MemoryReport":
    # ## MemoryReport
    #
    # Tests for memory diagnostics.

    context "creation":
        # ### Report Creation
        #
        # Memory reports track allocations and GC.

        it "creates empty report":
            val report = MemoryReport__empty()
            expect(report.events.len()).to_equal(0)

        it "creates report with capacity":
            val report = MemoryReport__with_capacity(100)
            expect(report.events.len()).to_equal(0)

    context "memory events":
        # ### Memory Events
        #
        # Memory reports track allocation/deallocation events.

        it "records allocation":
            val report = MemoryReport__empty()
            report.record_alloc(0x1000, 1024, "MyStruct")
            expect(report.events.len()).to_equal(1)
            expect(report.events[0].kind).to_equal(MemoryEventKind.Alloc)

        it "records deallocation":
            val report = MemoryReport__empty()
            report.record_free(0x1000, 1024)
            expect(report.events.len()).to_equal(1)
            expect(report.events[0].kind).to_equal(MemoryEventKind.Free)

        it "records reallocation":
            val report = MemoryReport__empty()
            report.record_realloc(0x1000, 0x2000, 1024, 2048)
            expect(report.events.len()).to_equal(1)
            expect(report.events[0].kind).to_equal(MemoryEventKind.Realloc)

    context "leak detection":
        # ### Leak Detection
        #
        # Memory reports can track leaks.

        it "adds leak info":
            val report = MemoryReport__empty()
            val leak = LeakInfo__at_address(0x1000, 1024)
            report.add_leak(leak)
            expect(report.leaks.len()).to_equal(1)

        it "has_leaks returns true with leaks":
            val report = MemoryReport__empty()
            report.add_leak(LeakInfo__at_address(0x1000, 512))
            expect(report.has_leaks()).to_equal(true)

        it "has_leaks returns false without leaks":
            val report = MemoryReport__empty()
            expect(report.has_leaks()).to_equal(false)

        it "calculates total leak size":
            val report = MemoryReport__empty()
            report.add_leak(LeakInfo__at_address(0x1000, 100))
            report.add_leak(LeakInfo__at_address(0x2000, 200))
            expect(report.total_leaked()).to_equal(300)

describe "LeakInfo":
    # ## LeakInfo
    #
    # Tests for memory leak information.

    context "creation":
        # ### Leak Info Creation
        #
        # Leak info captures allocation details.

        it "creates leak at address":
            val leak = LeakInfo__at_address(0x1000, 1024)
            expect(leak.address).to_equal(0x1000)
            expect(leak.size).to_equal(1024)

        it "creates leak with type":
            val leak = LeakInfo__with_type(0x1000, 1024, "MyStruct")
            expect(leak.type_name.?).to_equal(true)
            expect(leak.type_name.unwrap()).to_equal("MyStruct")

        it "creates leak with location":
            val loc = SourceLocation__at("main.spl", 10, 5)
            val leak = LeakInfo__with_location(0x1000, 1024, loc)
            expect(leak.location.?).to_equal(true)

describe "GCStats":
    # ## GCStats
    #
    # Tests for garbage collection statistics.

    context "creation":
        # ### GC Stats Creation
        #
        # GC stats track collection metrics.

        it "creates empty stats":
            val stats = GCStats__empty()
            expect(stats.collections).to_equal(0)
            expect(stats.total_freed).to_equal(0)

    context "updates":
        # ### Stats Updates
        #
        # GC stats are updated after collections.

        it "records collection":
            val stats = GCStats__empty()
            stats.record_collection(1024, 50)  # freed 1024 bytes in 50ms
            expect(stats.collections).to_equal(1)
            expect(stats.total_freed).to_equal(1024)

        it "accumulates multiple collections":
            val stats = GCStats__empty()
            stats.record_collection(1024, 50)
            stats.record_collection(2048, 75)
            expect(stats.collections).to_equal(2)
            expect(stats.total_freed).to_equal(3072)

        it "tracks average time":
            val stats = GCStats__empty()
            stats.record_collection(1000, 50)
            stats.record_collection(1000, 100)
            expect(stats.average_time_ms()).to_equal(75)

