# # I/O Traits Specification
#
# **Feature IDs:** #IO-TRAITS
# **Category:** Stdlib
# **Difficulty:** 3/5
# **Status:** Implemented
#
# ## Overview
#
# Fine-grained I/O traits (Read, Write, Seek, Close) form the core
# abstraction for all synchronous I/O. Async mirrors (AsyncRead, AsyncWrite,
# AsyncSeek, AsyncClose) wrap return types in Future.
#
# ## Syntax
#
# ```simple
# class MyReader with Read:
# fn read(size: i64) -> Result<[u8], IoError>:
# Ok([])
# # ... other Read methods
# ```
#
# ## Key Concepts
#
# | Concept | Description |
# |---------|-------------|
# | Read | Byte/text input: read, read_exact, read_all, read_text, read_line |
# | Write | Byte/text output: write, write_all, write_text, flush |
# | Seek | Random access: seek, position, rewind |
# | Close | Resource cleanup: close (me), is_open |
# | Mirror traits | AsyncRead/Write/Seek/Close — same names, Future returns |
#
# ## Behavior
#
# - Traits are independent — implementors mix in only what they support
# - `me` keyword on close() marks it as mutating (transitions state)
# - BufferedReader/Writer accept any Read/Write implementor (composition)

use std.spec

# ============================================================================
# Mock Implementations for Testing Trait Composition
# ============================================================================

class MockReader:
    # Mock reader for testing Read and Close traits.
    data: [u8]
    pos: i64
    open: bool

    static fn from_bytes(data: [u8]) -> MockReader:
        MockReader(data: data, pos: 0, open: true)

    me read(size: i64) -> [u8]:
        if not self.open:
            return []
        val end = if self.pos + size > self.data.len(): self.data.len() else: self.pos + size
        val chunk = self.data.slice(self.pos, end)
        self.pos = end
        chunk

    me read_exact(size: i64) -> [u8]:
        val result = self.read(size)
        result

    me read_all() -> [u8]:
        self.read(self.data.len() - self.pos)

    me close():
        self.open = false

    fn is_open() -> bool:
        self.open

class MockWriter:
    # Mock writer for testing Write and Close traits.
    buffer: [u8]
    flushed: bool
    open: bool

    static fn new() -> MockWriter:
        MockWriter(buffer: [], flushed: false, open: true)

    me write(data: [u8]) -> i64:
        if not self.open:
            return 0
        self.buffer = self.buffer + data
        data.len()

    me write_all(data: [u8]):
        self.write(data)

    me write_text(s: text):
        # Track that write happened by adding a byte per char
        var i = 0
        while i < s.len():
            self.buffer = self.buffer + [0]
            i = i + 1

    me flush():
        self.flushed = true

    me close():
        self.open = false

    fn is_open() -> bool:
        self.open

# ============================================================================
# Read Trait Tests
# ============================================================================

describe "Read Trait":
    # ## Byte-Level Input
    #
    # The Read trait provides methods for reading bytes and text
    # from any source. Implementors define how bytes are produced.

    context "reading bytes":
        # ### Basic Byte Reading
        #
        # read(size) returns up to `size` bytes.

        it "reads requested number of bytes":
            var reader = MockReader.from_bytes([72, 101, 108, 108, 111])
            val data = reader.read(3)
            expect(data.len()).to_equal(3)
            expect(data[0]).to_equal(72)

        it "reads remaining bytes when fewer available":
            var reader = MockReader.from_bytes([65, 66])
            val data = reader.read(10)
            expect(data.len()).to_equal(2)

    context "read_exact":
        # ### Exact Byte Reading
        #
        # read_exact(size) returns exactly `size` bytes or short result.

        it "reads exact count when available":
            var reader = MockReader.from_bytes([1, 2, 3, 4, 5])
            val data = reader.read_exact(5)
            expect(data.len()).to_equal(5)

        it "returns short result when insufficient bytes":
            var reader = MockReader.from_bytes([1, 2])
            val data = reader.read_exact(5)
            expect(data.len()).to_equal(2)

    context "read_all":
        # ### Reading All Content
        #
        # read_all() reads all remaining bytes.

        it "reads all remaining bytes":
            var reader = MockReader.from_bytes([72, 101, 108, 108, 111])
            val data = reader.read_all()
            expect(data.len()).to_equal(5)

# ============================================================================
# Write Trait Tests
# ============================================================================

describe "Write Trait":
    # ## Byte-Level Output
    #
    # The Write trait provides methods for writing bytes and text
    # to any destination, with explicit flush support.

    context "writing bytes":
        it "writes bytes and returns count":
            var writer = MockWriter.new()
            val n = writer.write([72, 105])
            expect(n).to_equal(2)

        it "accumulates writes":
            var writer = MockWriter.new()
            writer.write_all([72, 101])
            writer.write_all([108, 108, 111])
            expect(writer.buffer.len()).to_equal(5)

    context "flush":
        it "marks writer as flushed":
            var writer = MockWriter.new()
            expect(writer.flushed).to_equal(false)
            writer.flush()
            expect(writer.flushed).to_equal(true)

    context "writing text":
        it "writes text content":
            var writer = MockWriter.new()
            writer.write_text("hello")
            expect(writer.buffer.len()).to_be_greater_than(0)

# ============================================================================
# Close Trait Tests
# ============================================================================

describe "Close Trait":
    # ## Resource Cleanup
    #
    # The Close trait transitions a resource from open to closed state.
    # Uses `me` keyword since close() mutates the object.

    context "closing a reader":
        it "transitions from open to closed":
            var reader = MockReader.from_bytes([1, 2, 3])
            expect(reader.is_open()).to_equal(true)
            reader.close()
            expect(reader.is_open()).to_equal(false)

        it "returns empty when reading after close":
            var reader = MockReader.from_bytes([1, 2, 3])
            reader.close()
            val data = reader.read(1)
            expect(data.len()).to_equal(0)

    context "closing a writer":
        it "transitions from open to closed":
            var writer = MockWriter.new()
            expect(writer.is_open()).to_equal(true)
            writer.close()
            expect(writer.is_open()).to_equal(false)

# ============================================================================
# Trait Composition Tests
# ============================================================================

describe "Trait Composition":
    # ## Mixing Multiple Traits
    #
    # Types can implement multiple I/O traits simultaneously.
    # This enables generic I/O code that works with any implementor.

    context "Read + Close composition":
        it "reader implements both Read and Close":
            var reader = MockReader.from_bytes([72, 101, 108])
            val data = reader.read(3)
            expect(reader.is_open()).to_equal(true)
            reader.close()
            expect(reader.is_open()).to_equal(false)

    context "Write + Close composition":
        it "writer implements both Write and Close":
            var writer = MockWriter.new()
            writer.write_text("test")
            writer.flush()
            writer.close()
            expect(writer.is_open()).to_equal(false)
