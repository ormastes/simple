"""
# Sync UDP I/O Specification

**Feature IDs:** #IO-SYNC-UDP
**Category:** Stdlib
**Difficulty:** 2/5
**Status:** Implemented

## Overview

UdpSocket provides connectionless, message-oriented network I/O.
Implements Close trait only (UDP is message-based, not stream-based).

## Syntax

```simple
val socket = UdpSocket.bind("127.0.0.1:0")?
socket.send_to([72, 105], "127.0.0.1:9001")?
val (data, sender) = socket.recv_from(1024)?
socket.close()?
```

## Key Concepts

| Concept | Description |
|---------|-------------|
| UdpSocket | Datagram socket implementing Close |
| send_to/recv_from | Addressed mode — each message has explicit destination/source |
| connect/send/recv | Connected mode — default peer address |

## Behavior

- UdpSocket.bind() creates bound socket
- send_to/recv_from work without prior connect
- connect() sets default peer; then use send/recv
- close() releases the socket fd
"""

use std.spec

# ============================================================================
# UdpSocket
# ============================================================================

describe "UdpSocket":
    """
    ## UDP Datagram Socket

    Connectionless socket for sending and receiving datagrams.
    """

    context "bind":
        """
        ### Binding to an Address
        """

        it "binds to ephemeral port":
            val result = UdpSocket.bind("127.0.0.1:0")
            match result:
                case Ok(socket):
                    expect(socket.is_open()).to_equal(true)
                    socket.close()?
                case Err(e):
                    pass

    context "local_addr":
        """
        ### Retrieving Bound Address
        """

        it "returns bound address":
            val socket = UdpSocket.bind("127.0.0.1:0")?
            val addr = socket.local_addr()?
            expect(addr).to_contain("127.0.0.1")
            socket.close()?

    context "close":
        """
        ### Closing the Socket
        """

        it "transitions to closed":
            val socket = UdpSocket.bind("127.0.0.1:0")?
            expect(socket.is_open()).to_equal(true)
            socket.close()?
            expect(socket.is_open()).to_equal(false)

        it "close is idempotent":
            val socket = UdpSocket.bind("127.0.0.1:0")?
            socket.close()?
            val result = socket.close()
            match result:
                case Ok(_): expect(true).to_equal(true)
                case Err(_): pass

    context "operations on closed socket":
        """
        ### Closed Socket Errors
        """

        it "send_to returns error after close":
            var socket = UdpSocket(fd: -1, open: false)
            val result = socket.send_to([72, 105], "127.0.0.1:9001")
            match result:
                case Ok(_): pass
                case Err(e):
                    expect(e.message).to_contain("closed")

        it "recv_from returns error after close":
            var socket = UdpSocket(fd: -1, open: false)
            val result = socket.recv_from(1024)
            match result:
                case Ok(_): pass
                case Err(e):
                    expect(e.message).to_contain("closed")

    context "connected mode":
        """
        ### Connected UDP

        After connect(), use send/recv instead of send_to/recv_from.
        """

        it "documents connected mode usage":
            # val socket = UdpSocket.bind("127.0.0.1:0")?
            # socket.connect("127.0.0.1:9001")?
            # socket.send([72, 105])?
            # val data = socket.recv(1024)?
            # socket.close()?
            pass

    context "broadcast":
        """
        ### Broadcast Mode
        """

        it "documents broadcast usage":
            # val socket = UdpSocket.bind("0.0.0.0:0")?
            # socket.set_broadcast(true)?
            # socket.send_to(data, "255.255.255.255:9000")?
            # socket.close()?
            pass
