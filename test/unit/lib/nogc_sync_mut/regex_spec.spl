# Regex-like Pattern Matching Specification
#
# Tests for string pattern matching operations using built-in string methods.
# Covers contains, starts_with, ends_with, split, replace, and manual
# pattern searching implemented without external regex module.

# Helper: simple manual find (returns index or -1)
fn find_substr(haystack: text, needle: text) -> i64:
    val hlen = haystack.len()
    val nlen = needle.len()
    if nlen == 0: return 0
    if nlen > hlen: return -1
    val limit = hlen - nlen + 1
    for i in 0..limit:
        val slc = haystack[i:i + nlen]
        if slc == needle: return i
    return -1

# Helper: count occurrences
fn count_substr(haystack: text, needle: text) -> i64:
    var count = 0
    val hlen = haystack.len()
    val nlen = needle.len()
    if nlen == 0: return 0
    var i = 0
    for _ in 0..hlen:
        if i + nlen > hlen: return count
        val slc = haystack[i:i + nlen]
        if slc == needle:
            count = count + 1
            i = i + nlen
        else:
            i = i + 1
    return count

describe "String pattern matching":
    # Validates string pattern matching operations using built-in methods
    # and manual search algorithms.
    context "contains matching":
        it "finds substring at start":
            expect("hello world".contains("hello")).to_equal(true)

        it "finds substring in middle":
            expect("hello world".contains("lo wo")).to_equal(true)

        it "finds substring at end":
            expect("hello world".contains("world")).to_equal(true)

        it "returns false for missing substring":
            expect("hello world".contains("xyz")).to_equal(false)

        it "empty string is always contained":
            expect("hello".contains("")).to_equal(true)

    context "starts_with matching":
        it "matches at start":
            expect("hello world".starts_with("hello")).to_equal(true)

        it "does not match middle":
            expect("hello world".starts_with("world")).to_equal(false)

        it "empty prefix always matches":
            expect("hello".starts_with("")).to_equal(true)

    context "ends_with matching":
        it "matches at end":
            expect("hello world".ends_with("world")).to_equal(true)

        it "does not match start":
            expect("hello world".ends_with("hello")).to_equal(false)

        it "empty suffix always matches":
            expect("hello".ends_with("")).to_equal(true)

    context "Manual find operations":
        it "finds pattern in middle":
            expect(find_substr("hello world", "world")).to_equal(6)

        it "finds pattern at start":
            expect(find_substr("hello world", "hello")).to_equal(0)

        it "returns -1 for missing":
            expect(find_substr("hello world", "xyz")).to_equal(-1)

        it "finds empty string at 0":
            expect(find_substr("hello", "")).to_equal(0)

    context "Count occurrences":
        it "counts single occurrence":
            expect(count_substr("hello world", "world")).to_equal(1)

        it "counts multiple occurrences":
            expect(count_substr("abcabc", "abc")).to_equal(2)

        it "counts non-overlapping":
            expect(count_substr("aaaa", "aa")).to_equal(2)

        it "returns 0 for missing":
            expect(count_substr("hello", "xyz")).to_equal(0)

    context "Split by delimiter":
        it "splits by comma":
            val parts = "a,b,c".split(",")
            expect(parts.len()).to_equal(3)
            expect(parts[0]).to_equal("a")
            expect(parts[1]).to_equal("b")
            expect(parts[2]).to_equal("c")

        it "splits by space":
            val parts = "hello world test".split(" ")
            expect(parts.len()).to_equal(3)

        it "handles no separator found":
            val parts = "no-sep".split(",")
            expect(parts.len()).to_equal(1)
            expect(parts[0]).to_equal("no-sep")

    context "Replace operations":
        it "replaces all occurrences":
            var s = "hello world"
            s = s.replace("o", "X")
            expect(s).to_contain("X")

        it "handles no matches":
            val s = "hello world"
            val result = s.replace("xyz", "X")
            expect(result).to_equal("hello world")
