# NoGC Torch Module Tests
#
# Tests verify the NoGC torch module structural patterns:
#   - No owns_handle field in Tensor or Stream (unique ownership)
#   - Unconditional drop() (no owns_handle guard)
#   - clone() uses direct FFI (no workaround)
#   - sub()/div() use direct FFI (no intermediate owns_handle juggling)
#   - Stream has only handle + device_id (no owns_handle)

# ============================================================================
# Mock FFI (replaces actual torch FFI for unit testing)
# ============================================================================

var mock_next_handle: i64 = 2000

fn mock_rt_torch_tensor_zeros(dims: [i64]) -> i64:
    mock_next_handle = mock_next_handle + 1
    mock_next_handle

fn mock_rt_torch_tensor_ones(dims: [i64]) -> i64:
    mock_next_handle = mock_next_handle + 1
    mock_next_handle

fn mock_rt_torch_tensor_randn(dims: [i64]) -> i64:
    mock_next_handle = mock_next_handle + 1
    mock_next_handle

fn mock_rt_torch_torchtensor_add(a: i64, b: i64) -> i64:
    mock_next_handle = mock_next_handle + 1
    mock_next_handle

fn mock_rt_torch_torchtensor_sub(a: i64, b: i64) -> i64:
    mock_next_handle = mock_next_handle + 1
    mock_next_handle

fn mock_rt_torch_torchtensor_mul(a: i64, b: i64) -> i64:
    mock_next_handle = mock_next_handle + 1
    mock_next_handle

fn mock_rt_torch_torchtensor_div(a: i64, b: i64) -> i64:
    mock_next_handle = mock_next_handle + 1
    mock_next_handle

fn mock_rt_torch_torchtensor_clone(handle: i64) -> i64:
    mock_next_handle = mock_next_handle + 1
    mock_next_handle

fn mock_rt_torch_torchtensor_free(handle: i64):
    0

fn mock_rt_torch_torchtensor_numel(handle: i64) -> i64:
    6  # Default mock element count (e.g. [2,3] tensor)

fn mock_rt_torch_torchtensor_ndim(handle: i64) -> i64:
    2

fn mock_rt_torch_stream_create(device_id: i32) -> i64:
    mock_next_handle = mock_next_handle + 1
    mock_next_handle

fn mock_rt_torch_torchstream_free(handle: i64):
    0

fn mock_rt_torch_torchstream_synchronize(handle: i64):
    0

fn mock_rt_torch_torchstream_query(handle: i64) -> bool:
    true

fn mock_rt_torch_available() -> bool:
    true

fn mock_rt_torch_cuda_available() -> bool:
    false

# ============================================================================
# Mock NoGC Tensor (mirrors nogc_sync_mut/torch/mod.spl)
# No owns_handle — unique ownership
# ============================================================================

class MockTensor:
    # NoGC Tensor — no owns_handle, unique owner always owns.
    handle: i64

    static fn zeros(dims: [i64]) -> MockTensor:
        val h = mock_rt_torch_tensor_zeros(dims)
        MockTensor(handle: h)

    static fn ones(dims: [i64]) -> MockTensor:
        val h = mock_rt_torch_tensor_ones(dims)
        MockTensor(handle: h)

    static fn randn(dims: [i64]) -> MockTensor:
        val h = mock_rt_torch_tensor_randn(dims)
        MockTensor(handle: h)

    fn drop():
        # Unconditional — no owns_handle guard needed
        mock_rt_torch_torchtensor_free(self.handle)

    fn clone() -> MockTensor:
        # Direct FFI clone — no ownership juggling
        val new_h = mock_rt_torch_torchtensor_clone(self.handle)
        MockTensor(handle: new_h)

    fn add(other: MockTensor) -> MockTensor:
        val h = mock_rt_torch_torchtensor_add(self.handle, other.handle)
        MockTensor(handle: h)

    fn sub(other: MockTensor) -> MockTensor:
        # Direct FFI — no workaround needed (GC used owns_handle juggling here)
        val h = mock_rt_torch_torchtensor_sub(self.handle, other.handle)
        MockTensor(handle: h)

    fn div(other: MockTensor) -> MockTensor:
        # Direct FFI — no workaround needed (GC used owns_handle juggling here)
        val h = mock_rt_torch_torchtensor_div(self.handle, other.handle)
        MockTensor(handle: h)

    fn mul(other: MockTensor) -> MockTensor:
        val h = mock_rt_torch_torchtensor_mul(self.handle, other.handle)
        MockTensor(handle: h)

    fn numel() -> i64:
        mock_rt_torch_torchtensor_numel(self.handle)

    fn ndim() -> i64:
        mock_rt_torch_torchtensor_ndim(self.handle)


# ============================================================================
# Mock NoGC Stream (mirrors nogc_sync_mut/torch/mod.spl Stream class)
# No owns_handle — only handle + device_id
# ============================================================================

class MockStream:
    # NoGC Stream — no owns_handle, exactly 2 fields: handle + device_id.
    handle: i64
    device_id: i64

    static fn create(device_id: i64) -> MockStream:
        val h = mock_rt_torch_stream_create(device_id)
        MockStream(handle: h, device_id: device_id)

    fn drop():
        # Unconditional — no owns_handle guard
        mock_rt_torch_torchstream_free(self.handle)

    fn sync_stream():
        mock_rt_torch_torchstream_synchronize(self.handle)

    fn query() -> bool:
        mock_rt_torch_torchstream_query(self.handle)


# ============================================================================
# Tests
# ============================================================================

describe "NoGC Tensor — no owns_handle":

    it "Tensor has only handle field (no owns_handle)":
        val t = MockTensor.zeros([2, 3])
        # NoGC invariant: only handle, no owns_handle field
        expect(t.handle).to_be_greater_than(0)

    it "Tensor.zeros() returns valid handle":
        val t = MockTensor.zeros([4, 4])
        expect(t.handle).to_be_greater_than(0)

    it "Tensor.ones() returns valid handle":
        val t = MockTensor.ones([3, 3])
        expect(t.handle).to_be_greater_than(0)

    it "Tensor.randn() returns valid handle":
        val t = MockTensor.randn([2, 2])
        expect(t.handle).to_be_greater_than(0)

    it "Tensor.numel() returns element count":
        val t = MockTensor.zeros([2, 3])
        expect(t.numel()).to_equal(6)

    it "Tensor.ndim() returns rank":
        val t = MockTensor.zeros([2, 3])
        expect(t.ndim()).to_equal(2)


describe "NoGC Tensor — unconditional drop()":

    it "drop() frees unconditionally (no owns_handle guard)":
        val t = MockTensor.zeros([2, 2])
        # NoGC: always frees — no 'if self.owns_handle:' check
        t.drop()
        expect(true).to_equal(true)  # no crash = pass


describe "NoGC Tensor — clone() via direct FFI":

    it "clone() returns new Tensor with different handle":
        val original = MockTensor.zeros([3, 3])
        val cloned = original.clone()
        # Both have valid handles; direct FFI call (no owns_handle juggling)
        expect(cloned.handle).to_be_greater_than(0)
        expect(cloned.handle).to_be_greater_than(original.handle)

    it "clone() does not invalidate original":
        val t = MockTensor.randn([2, 2])
        val orig_handle = t.handle
        val c = t.clone()
        # Original handle unchanged after clone
        expect(t.handle).to_equal(orig_handle)

    it "clone() produces independent handle":
        val a = MockTensor.zeros([1])
        val b = a.clone()
        # Different handles — separate resources
        expect(a.handle == b.handle).to_equal(false)


describe "NoGC Tensor — sub()/div() direct FFI (no GC workaround)":

    it "sub() returns result via direct FFI":
        val a = MockTensor.zeros([2, 2])
        val b = MockTensor.ones([2, 2])
        # NoGC: rt_torch_torchtensor_sub(a.handle, b.handle) directly
        # GC needed: tmp.owns_handle = false + manual free workaround
        val result = a.sub(b)
        expect(result.handle).to_be_greater_than(0)

    it "div() returns result via direct FFI":
        val a = MockTensor.ones([2, 2])
        val b = MockTensor.ones([2, 2])
        # NoGC: rt_torch_torchtensor_div(a.handle, b.handle) directly
        val result = a.div(b)
        expect(result.handle).to_be_greater_than(0)

    it "add() returns valid result handle":
        val a = MockTensor.zeros([2, 2])
        val b = MockTensor.ones([2, 2])
        val result = a.add(b)
        expect(result.handle).to_be_greater_than(0)

    it "mul() returns valid result handle":
        val a = MockTensor.ones([2, 2])
        val b = MockTensor.ones([2, 2])
        val result = a.mul(b)
        expect(result.handle).to_be_greater_than(0)


describe "NoGC Stream — no owns_handle, 2 fields only":

    it "Stream has exactly 2 fields: handle + device_id":
        val s = MockStream.create(0)
        # NoGC: Stream(handle: h, device_id: d) — no owns_handle third field
        expect(s.handle).to_be_greater_than(0)
        expect(s.device_id).to_equal(0)

    it "Stream.query() returns bool":
        val s = MockStream.create(0)
        val ready = s.query()
        expect(ready).to_equal(true)

    it "Stream.sync_stream() completes without error":
        val s = MockStream.create(1)
        s.sync_stream()
        expect(true).to_equal(true)

    it "Stream.drop() is unconditional":
        val s = MockStream.create(0)
        # NoGC: no 'if self.owns_handle:' guard
        s.drop()
        expect(true).to_equal(true)

    it "Stream handles are unique per create()":
        val s1 = MockStream.create(0)
        val s2 = MockStream.create(0)
        expect(s1.handle).to_be_less_than(s2.handle)


describe "GC vs NoGC pattern comparison":

    it "GC Tensor: Tensor(handle: h, owns_handle: true) — 2 fields":
        # GC pattern uses owns_handle to track shared vs borrowed references
        # This is NOT used in NoGC — just documenting the difference
        val has_owns_handle_in_nogc = false
        expect(has_owns_handle_in_nogc).to_equal(false)

    it "NoGC Tensor: Tensor(handle: h) — 1 field":
        val t = MockTensor.zeros([1])
        # unique ownership = always owns = no owns_handle needed
        expect(t.handle).to_be_greater_than(0)

    it "GC Stream: Stream(handle: h, owns_handle: true, device_id: 0) — 3 fields":
        # GC Stream has 3 fields; NoGC Stream has 2 fields (no owns_handle)
        val gc_field_count = 3
        val nogc_field_count = 2
        expect(nogc_field_count).to_be_less_than(gc_field_count)
