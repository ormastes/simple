# # Resource Limits Specification
#
# **Feature ID:** Resource-limiting threads
# **Category:** Runtime | Concurrency
# **Difficulty:** 3/5
# **Status:** In Progress
#
# ## Overview
#
# Tests for the ResourceLimits API and LimitViolation enum.
# Verifies the builder pattern, preset configurations, and limit checking.
#
# ## Behavior
#
# - ResourceLimits can be created with builder pattern
# - Preset configurations (strict, default_test_limits) have expected values
# - LimitViolation correctly reports violation types

use concurrency.resource_limits.{ResourceLimits, LimitViolation, LimitedResult}

# ============================================================================
# ResourceLimits Basic API
# ============================================================================

describe "ResourceLimits":
    # ## ResourceLimits Configuration
    #
    # Tests the ResourceLimits struct and its builder methods.

    describe "Creation":
        # ### Factory Methods
        #
        # ResourceLimits can be created with various factory methods.

        it "creates unlimited limits with new()":
            val limits = ResourceLimits__new()
            expect limits.cpu_time_seconds == None
            expect limits.memory_bytes == None
            expect limits.file_descriptors == None
            expect limits.thread_count == None
            expect not limits.has_limits()

        it "creates default test limits":
            val limits = ResourceLimits__default_test_limits()
            expect limits.cpu_time_seconds == Some(300)
            expect limits.memory_bytes == Some(1073741824)  # 1 GB
            expect limits.file_descriptors == Some(256)
            expect limits.thread_count == None
            expect limits.has_limits()

        it "creates strict limits":
            val limits = ResourceLimits__strict()
            expect limits.cpu_time_seconds == Some(10)
            expect limits.memory_bytes == Some(134217728)  # 128 MB
            expect limits.file_descriptors == Some(16)
            expect limits.thread_count == Some(4)
            expect limits.has_limits()

    describe "Builder Pattern":
        # ### Builder Methods
        #
        # ResourceLimits supports fluent builder pattern for configuration.

        it "sets CPU time limit":
            val limits = ResourceLimits__new().with_cpu_time(60)
            expect limits.cpu_time_seconds == Some(60)
            expect limits.memory_bytes == None
            expect limits.has_limits()

        it "sets memory limit in megabytes":
            val limits = ResourceLimits__new().with_memory_mb(512)
            expect limits.memory_bytes == Some(536870912)  # 512 * 1024 * 1024
            expect limits.cpu_time_seconds == None
            expect limits.has_limits()

        it "sets memory limit in bytes":
            val limits = ResourceLimits__new().with_memory_bytes(1048576)
            expect limits.memory_bytes == Some(1048576)
            expect limits.has_limits()

        it "sets file descriptor limit":
            val limits = ResourceLimits__new().with_file_descriptors(64)
            expect limits.file_descriptors == Some(64)
            expect limits.has_limits()

        it "sets thread count limit":
            val limits = ResourceLimits__new().with_threads(8)
            expect limits.thread_count == Some(8)
            expect limits.has_limits()

        it "chains multiple builders":
            val limits = ResourceLimits__new()
                .with_cpu_time(30)
                .with_memory_mb(256)
                .with_file_descriptors(32)
                .with_threads(4)
            expect limits.cpu_time_seconds == Some(30)
            expect limits.memory_bytes == Some(268435456)  # 256 MB
            expect limits.file_descriptors == Some(32)
            expect limits.thread_count == Some(4)

    describe "Summary":
        # ### Human-Readable Summary
        #
        # ResourceLimits can generate human-readable summaries.

        it "summarizes unlimited limits":
            val limits = ResourceLimits__new()
            expect limits.summary() == "ResourceLimits(unlimited)"

        it "summarizes configured limits":
            val limits = ResourceLimits__new()
                .with_cpu_time(60)
                .with_memory_mb(128)
            val summary = limits.summary()
            expect summary.contains("cpu=60s")
            expect summary.contains("mem=128MB")


# ============================================================================
# LimitViolation
# ============================================================================

describe "LimitViolation":
    # ## LimitViolation Types
    #
    # Tests for the different violation types and their messages.

    describe "Violation Types":
        it "creates CPU time violation":
            val v = LimitViolation__CpuTimeExceeded(60)
            expect v.is_cpu_time()
            expect not v.is_memory()
            expect not v.is_fd()
            expect not v.is_thread()

        it "creates memory violation":
            val v = LimitViolation__MemoryExceeded(1073741824)
            expect v.is_memory()
            expect not v.is_cpu_time()

        it "creates file descriptor violation":
            val v = LimitViolation__FileDescriptorExceeded(256)
            expect v.is_fd()
            expect not v.is_memory()

        it "creates thread limit violation":
            val v = LimitViolation__ThreadLimitExceeded(4)
            expect v.is_thread()
            expect not v.is_cpu_time()

    describe "Messages":
        it "generates CPU time message":
            val v = LimitViolation__CpuTimeExceeded(60)
            val msg = v.message()
            expect msg.contains("CPU time")
            expect msg.contains("60")

        it "generates memory message":
            val v = LimitViolation__MemoryExceeded(134217728)
            val msg = v.message()
            expect msg.contains("Memory")
            expect msg.contains("128")  # 128 MB

        it "generates file descriptor message":
            val v = LimitViolation__FileDescriptorExceeded(256)
            val msg = v.message()
            expect msg.contains("File descriptor")
            expect msg.contains("256")

        it "generates thread limit message":
            val v = LimitViolation__ThreadLimitExceeded(4)
            val msg = v.message()
            expect msg.contains("Thread")
            expect msg.contains("4")

        it "generates unknown violation message":
            val v = LimitViolation__Unknown("test error")
            val msg = v.message()
            expect msg.contains("Unknown")
            expect msg.contains("test error")


# ============================================================================
# LimitedResult
# ============================================================================

describe "LimitedResult":
    # ## LimitedResult Type
    #
    # Tests for the result type used by resource-limited execution.

    describe "Success":
        it "creates success result":
            val result = LimitedResult__Success(42)
            expect result.is_success()
            expect not result.is_killed()
            expect not result.is_error()

        it "retrieves success value":
            val result = LimitedResult__Success(42)
            expect result.value() == Some(42)
            expect result.violation() == None
            expect result.error_message() == None

        it "unwraps success value":
            val result = LimitedResult__Success("hello")
            expect result.unwrap() == "hello"

    describe "Killed":
        it "creates killed result":
            val v = LimitViolation__CpuTimeExceeded(60)
            val result = LimitedResult__Killed(v)
            expect result.is_killed()
            expect not result.is_success()
            expect not result.is_error()

        it "retrieves violation":
            val v = LimitViolation__MemoryExceeded(1024)
            val result = LimitedResult__Killed(v)
            expect result.value() == None
            match result.violation():
                case Some(violation):
                    expect violation.is_memory()
                case None:
                    fail("Expected violation")

    describe "Error":
        it "creates error result":
            val result = LimitedResult__Error("something went wrong")
            expect result.is_error()
            expect not result.is_success()
            expect not result.is_killed()

        it "retrieves error message":
            val result = LimitedResult__Error("test error")
            expect result.error_message() == Some("test error")
            expect result.value() == None
            expect result.violation() == None
