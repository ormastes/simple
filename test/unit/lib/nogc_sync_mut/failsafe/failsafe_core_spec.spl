# Fail-Safe Core Tests
# Feature: Fail-Safe Core Types
# Category: FailSafe
# Status: In Progress

use std.failsafe.core.*

describe "ErrorSeverity":
    it "converts to string":
        expect(ErrorSeverity.Debug.to_string() == "debug")
        expect(ErrorSeverity.Info.to_string() == "info")
        expect(ErrorSeverity.Warning.to_string() == "warning")
        expect(ErrorSeverity.Error.to_string() == "error")
        expect(ErrorSeverity.Fatal.to_string() == "fatal")

    it "converts to level":
        expect(ErrorSeverity.Debug.to_level() == 0)
        expect(ErrorSeverity.Info.to_level() == 1)
        expect(ErrorSeverity.Fatal.to_level() == 5)

describe "ErrorCategory":
    it "converts to string":
        expect(ErrorCategory.Network.to_string() == "network")
        expect(ErrorCategory.Timeout.to_string() == "timeout")
        expect(ErrorCategory.Panic.to_string() == "panic")

    it "identifies recoverable categories":
        expect(ErrorCategory.Network.is_recoverable())
        expect(ErrorCategory.Timeout.is_recoverable())
        expect(not ErrorCategory.Panic.is_recoverable())
        expect(not ErrorCategory.Internal.is_recoverable())

describe "FailSafeError":
    it "creates basic error":
        val err = FailSafeError.new(ErrorCategory.Network, "Connection failed")
        expect(err.category == ErrorCategory.Network)
        expect(err.message == "Connection failed")
        expect(err.recoverable)

    it "sets severity":
        val err = FailSafeError.new(ErrorCategory.Internal, "Bug")
            .with_severity(ErrorSeverity.Fatal)
        expect(err.severity == ErrorSeverity.Fatal)

    it "marks as unrecoverable":
        val err = FailSafeError.new(ErrorCategory.Network, "Permanent")
            .as_unrecoverable()
        expect(not err.recoverable)

describe "FailSafeResult":
    it "creates Ok result":
        val result: FailSafeResult<i64> = FailSafeResult.Ok(42)
        expect(result.is_ok())
        expect(not result.is_err())

    it "creates Err result":
        val err = FailSafeError.new(ErrorCategory.Validation, "Invalid")
        val result: FailSafeResult<i64> = FailSafeResult.Err(err)
        expect(not result.is_ok())
        expect(result.is_err())

    it "unwraps Ok value":
        val result: FailSafeResult<i64> = FailSafeResult.Ok(42)
        expect(result.unwrap() == 42)

    it "provides default on Err":
        val err = FailSafeError.new(ErrorCategory.Validation, "Invalid")
        val result: FailSafeResult<i64> = FailSafeResult.Err(err)
        expect(result.unwrap_or(99) == 99)

describe "HealthStatus":
    it "converts to string":
        expect(HealthStatus.Healthy.to_string() == "healthy")
        expect(HealthStatus.Degraded.to_string() == "degraded")
        expect(HealthStatus.Unhealthy.to_string() == "unhealthy")

    it "identifies healthy states":
        expect(HealthStatus.Healthy.is_healthy())
        expect(not HealthStatus.Degraded.is_healthy())

describe "Counter":
    it "increments count":
        var counter = Counter.new("test")
        expect(counter.value == 0)
        counter.inc()
        expect(counter.value == 1)

    it "adds value":
        var counter = Counter.new("test")
        counter.add(10)
        expect(counter.value == 10)

    it "resets":
        var counter = Counter.new("test")
        counter.add(100)
        counter.reset()
        expect(counter.value == 0)

describe "Gauge":
    it "sets value":
        var gauge = Gauge.new("test")
        gauge.set(42.5)
        expect(gauge.value == 42.5)

    it "increments and decrements":
        var gauge = Gauge.new("test")
        gauge.inc()
        expect(gauge.value == 1.0)
        gauge.dec()
        expect(gauge.value == 0.0)

describe "MetricsRegistry":
    it "creates and retrieves counters":
        var registry = MetricsRegistry.new()
        var counter1 = registry.get_counter("requests")
        counter1.inc()
        expect(counter1.value == 1)
        # Registry stores counters
        expect(registry.counters.len() == 1)

describe "LogLevel":
    it "converts to string":
        expect(LogLevel.Debug.to_string() == "DEBUG")
        expect(LogLevel.Info.to_string() == "INFO")
        expect(LogLevel.Error.to_string() == "ERROR")

describe "ConsoleLogger":
    it "checks if level is enabled":
        val logger = ConsoleLogger.new(LogLevel.Warn)
        expect(not logger.is_enabled(LogLevel.Debug))
        expect(not logger.is_enabled(LogLevel.Info))
        expect(logger.is_enabled(LogLevel.Warn))
        expect(logger.is_enabled(LogLevel.Error))
