# Fail-Safe Module Integration Tests
# Feature: Fail-Safe Module Complete Integration
# Category: FailSafe, Module
# Status: In Progress
#
# Note: Full integration tests require module system improvements.
# Individual component tests are in their respective spec files:
# - failsafe_core_spec.spl
# - panic_spec.spl
# - ratelimit_spec.spl
# - circuit_spec.spl
# - timeout_spec.spl
# - resource_monitor_spec.spl

use std.failsafe.core.*
use std.failsafe.panic.*
use std.failsafe.ratelimit.*
use std.failsafe.circuit.*
use std.failsafe.timeout.*
use std.failsafe.resource_monitor.*
fn check(condition: bool):
    expect(condition).to_equal(true)
fn check_msg(condition: bool, message: text):
    if not condition:
        expect(message).to_equal("")

describe "Component Integration":
    it "core types work together":
        val err = FailSafeError__new(ErrorCategory.Network, "Connection failed")
        expect(err.recoverable)
        expect(err.category == ErrorCategory.Network)

    it "panic handler uses core types":
        val info = PanicInfo__new("Test panic")
        val error = info.to_error()
        expect(error.category == ErrorCategory.Panic)
        expect(not error.recoverable)

    it "rate limiter returns core result":
        var limiter = RateLimiter__default()
        match rate_limit_check(limiter, "client1"):
            case FailSafeResult__Ok(_):
                expect(true)
            case FailSafeResult__Err(_):
                expect(false)

    it "circuit breaker uses core result":
        var breaker = CircuitBreaker__default("test")
        val result = execute_with_circuit_breaker(breaker, \: FailSafeResult__Ok(42))
        match result:
            case FailSafeResult__Ok(v):
                expect(v == 42)
            case FailSafeResult__Err(_):
                expect(false)

    it "timeout manager creates tokens":
        var manager = TimeoutManager__default()
        val token = manager.start_timeout("operation")
        expect(token.is_active())
        manager.complete_timeout(token.id)
        expect(manager.stats.completed == 1)

    it "resource monitor tracks alerts":
        var monitor = ResourceMonitor__default()
        val alert = ResourceAlert__new("a1", ResourceType.Memory, AlertLevel.Warning, "High memory")
        monitor.alerts.append(alert)
        expect(monitor.get_unacknowledged_alerts().len() == 1)

describe "Cross-Component Patterns":
    it "safe operations with circuit breaker":
        var breaker = CircuitBreaker__default("safe_ops")

        # Successful operation
        val result = execute_with_circuit_breaker(breaker, \: safe_div(10, 2))
        match result:
            case FailSafeResult__Ok(inner):
                match inner:
                    case FailSafeResult__Ok(v):
                        expect(v == 5)
                    case _:
                        expect(false)
            case _:
                expect(false)

    it "fallback with circuit breaker":
        var breaker = CircuitBreaker__default("fallback")

        val result = execute_with_fallback(
            breaker,
            \: FailSafeResult__Err(FailSafeError__new(ErrorCategory.Network, "Failed")),
            \: FailSafeResult__Ok(99)
        )

        match result:
            case FailSafeResult__Ok(v):
                expect(v == 99)
            case _:
                expect(false)

    it "rate limiting with stats":
        var limiter = RateLimiter__default()

        # Make several requests
        limiter.check("client1")
        limiter.check("client1")
        limiter.check("client2")

        expect(limiter.stats.allowed_requests >= 3)

    it "timeout with deadline":
        var deadline = Deadline__new(10000)
        deadline.start_operation()
        deadline.complete_operation()

        expect(deadline.operations_started == 1)
        expect(deadline.operations_completed == 1)
