# NoGC GPU Context Tests
#
# Tests verify the NoGC GPU context module structural patterns:
#   - DeviceBackend enum and Device struct from common/gpu/device
#   - Context class with NoGC Stream (no owns_handle)
#   - Backend detection and device constructors

# ============================================================================
# Mock Device Backend enum and Device struct
# (mirrors common/gpu/device.spl)
# ============================================================================

enum MockDeviceBackend:
    # Device backend type (NoGC).
    Cuda
    Vulkan
    None_

struct MockDevice:
    # Device handle (pure data, no ownership).
    backend: MockDeviceBackend
    device_id: i32
    is_initialized: bool

impl MockDevice:
    fn is_valid() -> bool:
        self.is_initialized

    fn sync_device() -> bool:
        true

fn make_cuda_device(device_id: i32) -> MockDevice:
    MockDevice(backend: MockDeviceBackend.Cuda, device_id: device_id, is_initialized: true)

fn make_none_device() -> MockDevice:
    MockDevice(backend: MockDeviceBackend.None_, device_id: -1, is_initialized: true)

# ============================================================================
# Mock Stream (mirrors nogc_sync_mut/torch Stream — no owns_handle)
# ============================================================================

class MockStream:
    # NoGC stream — no owns_handle, unconditional drop.
    handle: i64
    device_id: i64

    static fn create(device_id: i64) -> MockStream:
        MockStream(handle: 42, device_id: device_id)

    fn drop():
        # Unconditional — unique ownership always owns
        0

    fn synchronize():
        0

    fn query() -> bool:
        true

# ============================================================================
# Mock Context (mirrors nogc_sync_mut/gpu/context.spl)
# ============================================================================

class MockContext:
    # Mock device context — NoGC pattern.
    backend: MockDeviceBackend
    device: MockDevice
    default_stream: MockStream?

    static fn default_ctx() -> MockContext:
        val dev = make_cuda_device(0)
        val stream = MockStream.create(0)
        MockContext(backend: MockDeviceBackend.Cuda, device: dev, default_stream: Some(stream))

    static fn cpu_ctx() -> MockContext:
        val dev = make_none_device()
        MockContext(backend: MockDeviceBackend.None_, device: dev, default_stream: nil)

    fn backend_name() -> text:
        match self.backend:
            case MockDeviceBackend.Cuda: "CUDA"
            case MockDeviceBackend.Vulkan: "Vulkan"
            case MockDeviceBackend.None_: "CPU"

    fn device_id() -> i32:
        self.device.device_id

    fn sync_device():
        match self.default_stream:
            case Some(s):
                s.synchronize()
            case nil:
                self.device.sync_device()

    fn drop():
        # NoGC: Stream? field — drop() is unconditional if present
        ()

# ============================================================================
# Tests
# ============================================================================

describe "NoGC device common types":

    it "DeviceBackend enum variants are distinct":
        val cuda = MockDeviceBackend.Cuda
        val vulkan = MockDeviceBackend.Vulkan
        val none = MockDeviceBackend.None_
        expect(cuda == vulkan).to_equal(false)
        expect(cuda == none).to_equal(false)

    it "make_cuda_device creates valid device struct":
        val dev = make_cuda_device(0)
        expect(dev.is_valid()).to_equal(true)
        expect(dev.device_id).to_equal(0)

    it "make_none_device creates CPU fallback with device_id -1":
        val dev = make_none_device()
        expect(dev.is_valid()).to_equal(true)
        expect(dev.device_id).to_equal(-1)

    it "Device.sync_device() returns true (stub)":
        val dev = make_cuda_device(0)
        expect(dev.sync_device()).to_equal(true)


describe "NoGC Device Context":

    it "Context has no owns_handle in Stream (NoGC invariant)":
        val ctx = MockContext.default_ctx()
        # Stream field — no owns_handle, just handle + device_id
        match ctx.default_stream:
            case Some(s):
                expect(s.handle).to_equal(42)
            case nil:
                expect(false).to_equal(true)

    it "Context.backend_name() returns CUDA for Cuda backend":
        val ctx = MockContext.default_ctx()
        expect(ctx.backend_name()).to_equal("CUDA")

    it "Context.backend_name() returns CPU for None backend":
        val ctx = MockContext.cpu_ctx()
        expect(ctx.backend_name()).to_equal("CPU")

    it "Context.device_id() returns 0 for default CUDA context":
        val ctx = MockContext.default_ctx()
        expect(ctx.device_id()).to_equal(0)

    it "Context.device_id() returns -1 for CPU context":
        val ctx = MockContext.cpu_ctx()
        expect(ctx.device_id()).to_equal(-1)

    it "CPU context has nil stream":
        val ctx = MockContext.cpu_ctx()
        match ctx.default_stream:
            case Some(_):
                expect(false).to_equal(true)
            case nil:
                expect(true).to_equal(true)

    it "Context.sync_device() works with CUDA stream":
        val ctx = MockContext.default_ctx()
        ctx.sync_device()
        expect(true).to_equal(true)

    it "Context.sync_device() works with CPU fallback":
        val ctx = MockContext.cpu_ctx()
        ctx.sync_device()
        expect(true).to_equal(true)
