# NoGC GPU Context Tests
#
# Tests verify the NoGC GPU context module structural patterns:
#   - GpuBackend enum and Gpu struct from common/gpu/device
#   - Context class with NoGC Stream (no owns_handle)
#   - Backend detection and device constructors

# ============================================================================
# Mock GPU Backend enum and Gpu struct
# (mirrors common/gpu/device.spl)
# ============================================================================

enum MockGpuBackend:
    """GPU backend type (NoGC)."""
    Cuda
    Vulkan
    None_

struct MockGpu:
    """GPU device handle (pure data, no ownership)."""
    backend: MockGpuBackend
    device_id: i32
    is_initialized: bool

impl MockGpu:
    fn is_valid() -> bool:
        self.is_initialized

    fn sync() -> bool:
        true

fn mock_gpu_cuda(device_id: i32) -> MockGpu:
    MockGpu(backend: MockGpuBackend.Cuda, device_id: device_id, is_initialized: true)

fn mock_gpu_none() -> MockGpu:
    MockGpu(backend: MockGpuBackend.None, device_id: -1, is_initialized: true)

# ============================================================================
# Mock Stream (mirrors nogc_sync_mut/torch Stream — no owns_handle)
# ============================================================================

class MockStream:
    """NoGC stream — no owns_handle, unconditional drop."""
    handle: i64
    device_id: i64

    static fn create(device_id: i64) -> MockStream:
        MockStream(handle: 42, device_id: device_id)

    fn drop():
        # Unconditional — unique ownership always owns
        pass_dn

    fn synchronize():
        pass_dn

    fn query() -> bool:
        true

# ============================================================================
# Mock Context (mirrors nogc_sync_mut/gpu/context.spl)
# ============================================================================

class MockContext:
    """Mock GPU context — NoGC pattern."""
    backend: MockGpuBackend
    device: MockGpu
    default_stream: MockStream?

    static fn default_ctx() -> MockContext:
        val gpu = mock_gpu_cuda(0)
        val stream = MockStream.create(0)
        MockContext(backend: MockGpuBackend.Cuda, device: gpu, default_stream: Some(stream))

    static fn cpu_ctx() -> MockContext:
        val gpu = mock_gpu_none()
        MockContext(backend: MockGpuBackend.None, device: gpu, default_stream: nil)

    fn backend_name() -> text:
        match self.backend:
            case MockGpuBackend.Cuda: "CUDA"
            case MockGpuBackend.Vulkan: "Vulkan"
            case MockGpuBackend.None: "CPU"

    fn device_id() -> i32:
        self.device.device_id

    fn sync():
        match self.default_stream:
            case Some(s):
                s.synchronize()
            case nil:
                self.device.sync()

    fn drop():
        # NoGC: Stream? field — drop() is unconditional if present
        ()

# ============================================================================
# Tests
# ============================================================================

describe "NoGC GPU common types":

    it "GpuBackend enum variants are distinct":
        val cuda = MockGpuBackend.Cuda
        val vulkan = MockGpuBackend.Vulkan
        val none = MockGpuBackend.None
        expect(cuda == vulkan).to_equal(false)
        expect(cuda == none).to_equal(false)

    it "gpu_cuda() creates valid Gpu struct":
        val gpu = mock_gpu_cuda(0)
        expect(gpu.is_valid()).to_equal(true)
        expect(gpu.device_id).to_equal(0)

    it "gpu_none() creates CPU fallback with device_id -1":
        val gpu = mock_gpu_none()
        expect(gpu.is_valid()).to_equal(true)
        expect(gpu.device_id).to_equal(-1)

    it "Gpu.sync() returns true (stub)":
        val gpu = mock_gpu_cuda(0)
        expect(gpu.sync()).to_equal(true)


describe "NoGC GPU Context":

    it "Context has no owns_handle in Stream (NoGC invariant)":
        val ctx = MockContext.default_ctx()
        # Stream field — no owns_handle, just handle + device_id
        match ctx.default_stream:
            case Some(s):
                expect(s.handle).to_equal(42)
            case nil:
                expect(false).to_equal(true)

    it "Context.backend_name() returns CUDA for Cuda backend":
        val ctx = MockContext.default_ctx()
        expect(ctx.backend_name()).to_equal("CUDA")

    it "Context.backend_name() returns CPU for None backend":
        val ctx = MockContext.cpu_ctx()
        expect(ctx.backend_name()).to_equal("CPU")

    it "Context.device_id() returns 0 for default CUDA context":
        val ctx = MockContext.default_ctx()
        expect(ctx.device_id()).to_equal(0)

    it "Context.device_id() returns -1 for CPU context":
        val ctx = MockContext.cpu_ctx()
        expect(ctx.device_id()).to_equal(-1)

    it "CPU context has nil stream":
        val ctx = MockContext.cpu_ctx()
        match ctx.default_stream:
            case Some(_):
                expect(false).to_equal(true)
            case nil:
                expect(true).to_equal(true)

    it "Context.sync() works with CUDA stream":
        val ctx = MockContext.default_ctx()
        ctx.sync()
        expect(true).to_equal(true)

    it "Context.sync() works with CPU fallback":
        val ctx = MockContext.cpu_ctx()
        ctx.sync()
        expect(true).to_equal(true)
