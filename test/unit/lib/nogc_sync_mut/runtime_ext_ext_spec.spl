# Tests for std.runtime_ext module
# Covers hash, type conversion, array hash, clamp, min, max, abs

use std.runtime_ext.{hash, to_usize, from_usize, array_hash, clamp, min, max, abs}

describe "std.runtime_ext":
    describe "hash":
        it "returns consistent hash for same string":
            val h1 = hash("hello")
            val h2 = hash("hello")
            expect(h1).to_equal(h2)

        it "returns different hashes for different strings":
            val h1 = hash("hello")
            val h2 = hash("world")
            # Different strings should have different hashes (not guaranteed but highly likely)
            val same = h1 == h2
            expect(same).to_equal(false)

        it "handles empty string":
            val h = hash("")
            val h2 = hash("")
            expect(h).to_equal(h2)

    describe "to_usize":
        it "converts positive i64":
            val result = to_usize(42)
            expect(result).to_equal(42)

        it "converts zero":
            val result = to_usize(0)
            expect(result).to_equal(0)

    describe "from_usize":
        it "converts back to i64":
            val result = from_usize(42)
            expect(result).to_equal(42)

        it "roundtrips":
            val original = 100
            val converted = to_usize(original)
            val back = from_usize(converted)
            expect(back).to_equal(original)

    describe "array_hash":
        it "hashes empty array":
            val h = array_hash([])
            expect(h).to_equal(0)

        it "hashes single element":
            val h = array_hash(["hello"])
            val expected = hash("hello")
            expect(h).to_equal(expected)

        it "returns consistent hash":
            val h1 = array_hash(["a", "b", "c"])
            val h2 = array_hash(["a", "b", "c"])
            expect(h1).to_equal(h2)

        it "differs for different arrays":
            val h1 = array_hash(["a", "b"])
            val h2 = array_hash(["c", "d"])
            val same = h1 == h2
            expect(same).to_equal(false)

    describe "clamp":
        it "returns value when in range":
            expect(clamp(5, 0, 10)).to_equal(5)

        it "clamps to minimum":
            expect(clamp(-5, 0, 10)).to_equal(0)

        it "clamps to maximum":
            expect(clamp(15, 0, 10)).to_equal(10)

        it "handles equal min and max":
            expect(clamp(5, 3, 3)).to_equal(3)

        it "handles value at boundaries":
            expect(clamp(0, 0, 10)).to_equal(0)
            expect(clamp(10, 0, 10)).to_equal(10)

        it "handles negative ranges":
            expect(clamp(-5, -10, -1)).to_equal(-5)
            expect(clamp(-15, -10, -1)).to_equal(-10)

    describe "min":
        it "returns smaller value":
            expect(min(3, 7)).to_equal(3)
            expect(min(7, 3)).to_equal(3)

        it "handles equal values":
            expect(min(5, 5)).to_equal(5)

        it "handles negative values":
            expect(min(-3, -7)).to_equal(-7)
            expect(min(-3, 5)).to_equal(-3)

        it "handles zero":
            expect(min(0, 5)).to_equal(0)
            expect(min(-5, 0)).to_equal(-5)

    describe "max":
        it "returns larger value":
            expect(max(3, 7)).to_equal(7)
            expect(max(7, 3)).to_equal(7)

        it "handles equal values":
            expect(max(5, 5)).to_equal(5)

        it "handles negative values":
            expect(max(-3, -7)).to_equal(-3)
            expect(max(-3, 5)).to_equal(5)

        it "handles zero":
            expect(max(0, 5)).to_equal(5)
            expect(max(-5, 0)).to_equal(0)

    describe "abs":
        it "returns positive for negative":
            expect(abs(-5)).to_equal(5)
            expect(abs(-100)).to_equal(100)

        it "returns same for positive":
            expect(abs(5)).to_equal(5)
            expect(abs(100)).to_equal(100)

        it "returns zero for zero":
            expect(abs(0)).to_equal(0)
