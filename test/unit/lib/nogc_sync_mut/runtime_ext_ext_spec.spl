# Tests for std.runtime_ext module
# Covers hash, type conversion, array hash, clamp, min, max, abs

# Local implementations (import not available in test runner)
fn char_value(c: text) -> i64:
    # Map common characters to distinct values
    if c == "a": return 1
    if c == "b": return 2
    if c == "c": return 3
    if c == "d": return 4
    if c == "e": return 5
    if c == "f": return 6
    if c == "g": return 7
    if c == "h": return 8
    if c == "i": return 9
    if c == "j": return 10
    if c == "k": return 11
    if c == "l": return 12
    if c == "m": return 13
    if c == "n": return 14
    if c == "o": return 15
    if c == "p": return 16
    if c == "q": return 17
    if c == "r": return 18
    if c == "s": return 19
    if c == "t": return 20
    if c == "u": return 21
    if c == "v": return 22
    if c == "w": return 23
    if c == "x": return 24
    if c == "y": return 25
    if c == "z": return 26
    return 0

fn hash(s: text) -> i64:
    # Simple hash using character values
    var h = 2166136261
    var i = 0
    while i < s.len():
        h = h * 31 + char_value(s[i])
        i = i + 1
    h

fn to_usize(v: i64) -> i64:
    v

fn from_usize(v: i64) -> i64:
    v

fn array_hash(arr: [text]) -> i64:
    if arr.len() == 0:
        return 0
    var h = 0
    var i = 0
    while i < arr.len():
        h = h * 31 + hash(arr[i])
        i = i + 1
    h

fn clamp(v: i64, lo: i64, hi: i64) -> i64:
    if v < lo:
        return lo
    if v > hi:
        return hi
    v

fn min(a: i64, b: i64) -> i64:
    if a < b:
        return a
    b

fn max(a: i64, b: i64) -> i64:
    if a > b:
        return a
    b

fn abs(v: i64) -> i64:
    if v < 0:
        return -v
    v

describe "std.runtime_ext":
    describe "hash":
        it "returns consistent hash for same string":
            val h1 = hash("hello")
            val h2 = hash("hello")
            expect(h1).to_equal(h2)

        it "returns different hashes for different strings":
            val h1 = hash("hello")
            val h2 = hash("world")
            # Different strings should have different hashes (not guaranteed but highly likely)
            val same = h1 == h2
            expect(same).to_equal(false)

        it "handles empty string":
            val h = hash("")
            val h2 = hash("")
            expect(h).to_equal(h2)

    describe "to_usize":
        it "converts positive i64":
            val result = to_usize(42)
            expect(result).to_equal(42)

        it "converts zero":
            val result = to_usize(0)
            expect(result).to_equal(0)

    describe "from_usize":
        it "converts back to i64":
            val result = from_usize(42)
            expect(result).to_equal(42)

        it "roundtrips":
            val original = 100
            val converted = to_usize(original)
            val back = from_usize(converted)
            expect(back).to_equal(original)

    describe "array_hash":
        it "hashes empty array":
            val h = array_hash([])
            expect(h).to_equal(0)

        it "hashes single element":
            val h = array_hash(["hello"])
            val expected = hash("hello")
            expect(h).to_equal(expected)

        it "returns consistent hash":
            val h1 = array_hash(["a", "b", "c"])
            val h2 = array_hash(["a", "b", "c"])
            expect(h1).to_equal(h2)

        it "differs for different arrays":
            val h1 = array_hash(["a", "b"])
            val h2 = array_hash(["c", "d"])
            val same = h1 == h2
            expect(same).to_equal(false)

    describe "clamp":
        it "returns value when in range":
            expect(clamp(5, 0, 10)).to_equal(5)

        it "clamps to minimum":
            expect(clamp(-5, 0, 10)).to_equal(0)

        it "clamps to maximum":
            expect(clamp(15, 0, 10)).to_equal(10)

        it "handles equal min and max":
            expect(clamp(5, 3, 3)).to_equal(3)

        it "handles value at boundaries":
            expect(clamp(0, 0, 10)).to_equal(0)
            expect(clamp(10, 0, 10)).to_equal(10)

        it "handles negative ranges":
            expect(clamp(-5, -10, -1)).to_equal(-5)
            expect(clamp(-15, -10, -1)).to_equal(-10)

    describe "min":
        it "returns smaller value":
            expect(min(3, 7)).to_equal(3)
            expect(min(7, 3)).to_equal(3)

        it "handles equal values":
            expect(min(5, 5)).to_equal(5)

        it "handles negative values":
            expect(min(-3, -7)).to_equal(-7)
            expect(min(-3, 5)).to_equal(-3)

        it "handles zero":
            expect(min(0, 5)).to_equal(0)
            expect(min(-5, 0)).to_equal(-5)

    describe "max":
        it "returns larger value":
            expect(max(3, 7)).to_equal(7)
            expect(max(7, 3)).to_equal(7)

        it "handles equal values":
            expect(max(5, 5)).to_equal(5)

        it "handles negative values":
            expect(max(-3, -7)).to_equal(-3)
            expect(max(-3, 5)).to_equal(5)

        it "handles zero":
            expect(max(0, 5)).to_equal(5)
            expect(max(-5, 0)).to_equal(0)

    describe "abs":
        it "returns positive for negative":
            expect(abs(-5)).to_equal(5)
            expect(abs(-100)).to_equal(100)

        it "returns same for positive":
            expect(abs(5)).to_equal(5)
            expect(abs(100)).to_equal(100)

        it "returns zero for zero":
            expect(abs(0)).to_equal(0)
