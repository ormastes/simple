# Platform Newline Translation Tests

# use std.platform.newline.{TextMode, translate_write, translate_read}
# use std.platform.config.{host_config, make_config}
# use std.common.target.{TargetArch, TargetOS}

class Endian:
    value: text
    static fn Little() -> Endian: Endian(value: "little")
    static fn Big() -> Endian: Endian(value: "big")

class TargetArch:
    value: text
    static fn X86_64() -> TargetArch: TargetArch(value: "x86_64")
    fn endianness() -> Endian:
        Endian.Little()
    fn pointer_bytes() -> i64:
        8

class TargetOS:
    value: text
    static fn Linux() -> TargetOS: TargetOS(value: "linux")
    static fn Windows() -> TargetOS: TargetOS(value: "windows")

class PlatformConfig:
    arch: TargetArch
    os: TargetOS
    endian: Endian
    pointer_bytes: i64
    newline: text

fn host_config() -> PlatformConfig:
    PlatformConfig(arch: TargetArch.X86_64(), os: TargetOS.Linux(), endian: Endian.Little(), pointer_bytes: 8, newline: "\n")

fn make_config(arch: TargetArch, os: TargetOS) -> PlatformConfig:
    val endian = arch.endianness()
    val nl = if os.value == "windows": "\r\n" else: "\n"
    PlatformConfig(arch: arch, os: os, endian: endian, pointer_bytes: arch.pointer_bytes(), newline: nl)

class TextMode:
    value: text
    static fn Binary() -> TextMode: TextMode(value: "binary")
    static fn Text() -> TextMode: TextMode(value: "text")
    static fn Remote() -> TextMode: TextMode(value: "remote")

fn translate_write(content: text, mode: TextMode, remote: PlatformConfig) -> text:
    if mode.value == "binary":
        return content
    if mode.value == "text":
        return content
    # Remote mode: convert host newlines to remote newlines
    val host = host_config()
    if host.newline == remote.newline:
        return content
    content.replace(host.newline, remote.newline)

fn translate_read(content: text, mode: TextMode, remote: PlatformConfig) -> text:
    if mode.value == "binary":
        return content
    if mode.value == "text":
        # Normalize to host LF
        return content.replace("\r\n", "\n")
    # Remote mode: convert remote newlines back to host
    val host = host_config()
    if host.newline == remote.newline:
        return content
    content.replace(remote.newline, host.newline)

describe "TextMode Translation":
    it "Binary mode does not translate":
        val remote = make_config(TargetArch.X86_64(), TargetOS.Windows())
        val content = "line1\nline2\n"
        val result = translate_write(content, TextMode.Binary(), remote)
        expect(result).to_equal(content)

    it "Text mode normalizes to host":
        val remote = make_config(TargetArch.X86_64(), TargetOS.Windows())
        val content = "line1\nline2\n"
        val result = translate_write(content, TextMode.Text(), remote)
        # Text mode sends host→host, which normalizes
        expect(result).to_equal(content)

    it "Remote mode translates to remote newlines":
        val unix = make_config(TargetArch.X86_64(), TargetOS.Linux())
        val win = make_config(TargetArch.X86_64(), TargetOS.Windows())
        val content = "line1\nline2\n"
        val result = translate_write(content, TextMode.Remote(), win)
        # If host is Unix, translates LF→CRLF
        # If host is Windows, stays CRLF
        val has_crlf = result.contains("\r\n")
        expect(has_crlf).to_equal(true)

    it "translate_read inverts translate_write":
        val remote = make_config(TargetArch.X86_64(), TargetOS.Windows())
        val content = "line1\nline2\n"
        val written = translate_write(content, TextMode.Remote(), remote)
        val read_back = translate_read(written, TextMode.Remote(), remote)
        expect(read_back).to_equal(content)

    it "Binary mode read does not translate":
        val remote = make_config(TargetArch.X86_64(), TargetOS.Windows())
        val content = "line1\r\nline2\r\n"
        val result = translate_read(content, TextMode.Binary(), remote)
        expect(result).to_equal(content)

    it "Text mode read normalizes to host":
        val remote = make_config(TargetArch.X86_64(), TargetOS.Windows())
        val content = "line1\r\nline2\r\n"
        val result = translate_read(content, TextMode.Text(), remote)
        # Text mode receives host→host, which normalizes to LF
        expect(result.contains("\r\n")).to_equal(false)
        expect(result.contains("\n")).to_equal(true)
