# Platform Newline Translation Tests

# use std.platform.newline.{TextMode, translate_write, translate_read}
# use std.platform.config.{host_config, make_config}
# use std.common.target.{TargetArch, TargetOS}

class Endian:
    val: text
    static fn Little(): Endian: Endian(val: "little")
    static fn Big(): Endian: Endian(val: "big")

class TargetArch:
    val: text
    static fn X86_64(): TargetArch: TargetArch(val: "x86_64")
    fn endianness() -> Endian:
        Endian.Little()
    fn pointer_bytes() -> i64:
        8

class TargetOS:
    val: text
    static fn Linux(): TargetOS: TargetOS(val: "linux")
    static fn Windows(): TargetOS: TargetOS(val: "windows")

class PlatformConfig:
    arch: TargetArch
    os: TargetOS
    endian: Endian
    pointer_bytes: i64
    newline: text

fn host_config() -> PlatformConfig:
    PlatformConfig(arch: TargetArch.X86_64(), os: TargetOS.Linux(), endian: Endian.Little(), pointer_bytes: 8, newline: "\n")

fn make_config(arch: TargetArch, os: TargetOS) -> PlatformConfig:
    val endian = arch.endianness()
    val nl = if os.val == "windows": "\r\n" else: "\n"
    PlatformConfig(arch: arch, os: os, endian: endian, pointer_bytes: arch.pointer_bytes(), newline: nl)

class TextMode:
    val: text
    static fn Binary(): TextMode: TextMode(val: "binary")
    static fn Text(): TextMode: TextMode(val: "text")
    static fn Remote(): TextMode: TextMode(val: "remote")

fn translate_write(content: text, mode: TextMode, remote: PlatformConfig) -> text:
    if mode.val == "binary":
        return content
    if mode.val == "text":
        return content
    # Remote mode: convert host newlines to remote newlines
    val host = host_config()
    if host.newline == remote.newline:
        return content
    content.replace(host.newline, remote.newline)

fn translate_read(content: text, mode: TextMode, remote: PlatformConfig) -> text:
    if mode.val == "binary":
        return content
    if mode.val == "text":
        # Normalize to host LF
        return content.replace("\r\n", "\n")
    # Remote mode: convert remote newlines back to host
    val host = host_config()
    if host.newline == remote.newline:
        return content
    content.replace(remote.newline, host.newline)

describe "TextMode Translation":
    it "Binary mode does not translate":
        val remote = make_config(TargetArch.X86_64, TargetOS.Windows)
        val content = "line1\nline2\n"
        val result = translate_write(content, TextMode.Binary, remote)
        expect(result).to_equal(content)

    it "Text mode normalizes to host":
        val remote = make_config(TargetArch.X86_64, TargetOS.Windows)
        val content = "line1\nline2\n"
        val result = translate_write(content, TextMode.Text, remote)
        # Text mode sends host→host, which normalizes
        expect(result).to_equal(content)

    it "Remote mode translates to remote newlines":
        val unix = make_config(TargetArch.X86_64, TargetOS.Linux)
        val win = make_config(TargetArch.X86_64, TargetOS.Windows)
        val content = "line1\nline2\n"
        val result = translate_write(content, TextMode.Remote, win)
        # If host is Unix, translates LF→CRLF
        # If host is Windows, stays CRLF
        val has_crlf = result.contains("\r\n")
        expect(has_crlf).to_equal(true)

    it "translate_read inverts translate_write":
        val remote = make_config(TargetArch.X86_64, TargetOS.Windows)
        val content = "line1\nline2\n"
        val written = translate_write(content, TextMode.Remote, remote)
        val read_back = translate_read(written, TextMode.Remote, remote)
        expect(read_back).to_equal(content)

    it "Binary mode read does not translate":
        val remote = make_config(TargetArch.X86_64, TargetOS.Windows)
        val content = "line1\r\nline2\r\n"
        val result = translate_read(content, TextMode.Binary, remote)
        expect(result).to_equal(content)

    it "Text mode read normalizes to host":
        val remote = make_config(TargetArch.X86_64, TargetOS.Windows)
        val content = "line1\r\nline2\r\n"
        val result = translate_read(content, TextMode.Text, remote)
        # Text mode receives host→host, which normalizes to LF
        expect(result.contains("\r\n")).to_equal(false)
        expect(result.contains("\n")).to_equal(true)
