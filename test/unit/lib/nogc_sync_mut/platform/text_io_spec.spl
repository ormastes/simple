# Platform Text I/O Tests

# use std.platform.text_io.{text_file_write, text_file_write_local, text_file_read, text_file_read_local}
# use std.platform.config.{make_config}
# use std.common.target.{TargetArch, TargetOS}
# use app.io.mod.{file_read_text, file_delete}

extern fn rt_file_write_text(path: text, content: text) -> bool
extern fn rt_file_read_text(path: text) -> text
extern fn rt_file_delete(path: text) -> bool

fn file_read_text(path: text) -> text:
    val result = rt_file_read_text(path)
    result ?? ""
fn file_delete(path: text):
    rt_file_delete(path)
fn file_write(path: text, content: text):
    rt_file_write_text(path, content)

class Endian:
    val: text
    static fn Little(): Endian: Endian(val: "little")
    static fn Big(): Endian: Endian(val: "big")

class TargetArch:
    val: text
    static fn X86_64(): TargetArch: TargetArch(val: "x86_64")
    fn endianness() -> Endian:
        Endian.Little()
    fn pointer_bytes() -> i64:
        8

class TargetOS:
    val: text
    static fn Linux(): TargetOS: TargetOS(val: "linux")
    static fn Windows(): TargetOS: TargetOS(val: "windows")

class PlatformConfig:
    arch: TargetArch
    os: TargetOS
    endian: Endian
    pointer_bytes: i64
    newline: text

fn make_config(arch: TargetArch, os: TargetOS) -> PlatformConfig:
    val endian = arch.endianness()
    val nl = if os.val == "windows": "\r\n" else: "\n"
    PlatformConfig(arch: arch, os: os, endian: endian, pointer_bytes: arch.pointer_bytes(), newline: nl)

fn text_file_write_local(path: text, content: text):
    rt_file_write_text(path, content)

fn text_file_read_local(path: text) -> text:
    val raw = rt_file_read_text(path)
    raw ?? ""

fn text_file_write(path: text, content: text, config: PlatformConfig):
    # Convert content to target newlines
    val host_nl = "\n"
    val target_nl = config.newline
    val converted = if host_nl == target_nl: content else: content.replace(host_nl, target_nl)
    rt_file_write_text(path, converted)

fn text_file_read(path: text, config: PlatformConfig) -> text:
    val raw = rt_file_read_text(path)
    val content = raw ?? ""
    # Normalize remote newlines to host
    val host_nl = "\n"
    val remote_nl = config.newline
    if host_nl == remote_nl:
        return content
    content.replace(remote_nl, host_nl)

describe "Platform Text I/O":
    it "text_file_write_local writes with host newlines":
        val path = "/tmp/test_platform_local.txt"
        val content = "line1\nline2\nline3\n"
        text_file_write_local(path, content)
        val raw = file_read_text(path)
        file_delete(path)
        # Should contain the content (may have CRLF on Windows, LF on Unix)
        expect(raw.contains("line1")).to_equal(true)
        expect(raw.contains("line2")).to_equal(true)
        expect(raw.contains("line3")).to_equal(true)

    it "text_file_read_local reads and normalizes":
        val path = "/tmp/test_platform_read.txt"
        # Write with mixed newlines
        use app.io.mod.{file_write}
        file_write(path, "line1\r\nline2\nline3\r")
        val content = text_file_read_local(path)
        file_delete(path)
        # Should normalize to LF
        expect(content).to_equal("line1\nline2\nline3\n")

    it "text_file_write with Windows config uses CRLF":
        val path = "/tmp/test_platform_win.txt"
        val win_cfg = make_config(TargetArch.X86_64, TargetOS.Windows)
        val content = "line1\nline2\n"
        text_file_write(path, content, win_cfg)
        val raw = file_read_text(path)
        file_delete(path)
        # Should have CRLF
        expect(raw).to_equal("line1\r\nline2\r\n")

    it "text_file_write with Unix config uses LF":
        val path = "/tmp/test_platform_unix.txt"
        val unix_cfg = make_config(TargetArch.X86_64, TargetOS.Linux)
        val content = "line1\nline2\n"
        text_file_write(path, content, unix_cfg)
        val raw = file_read_text(path)
        file_delete(path)
        # Should have LF only
        expect(raw).to_equal("line1\nline2\n")

    it "text_file_read with Windows config normalizes CRLF":
        val path = "/tmp/test_platform_read_win.txt"
        use app.io.mod.{file_write}
        file_write(path, "line1\r\nline2\r\n")
        val win_cfg = make_config(TargetArch.X86_64, TargetOS.Windows)
        val content = text_file_read(path, win_cfg)
        file_delete(path)
        # Should normalize to host (LF on Unix, CRLF on Windows)
        expect(content.contains("line1")).to_equal(true)
        expect(content.contains("line2")).to_equal(true)

    it "write/read round-trip preserves content":
        val path = "/tmp/test_platform_roundtrip.txt"
        val content = "Hello\nWorld\nTest\n"
        text_file_write_local(path, content)
        val read_back = text_file_read_local(path)
        file_delete(path)
        expect(read_back).to_equal(content)

    it "write Windows / read Unix normalizes":
        val path = "/tmp/test_platform_cross.txt"
        val win_cfg = make_config(TargetArch.X86_64, TargetOS.Windows)
        val unix_cfg = make_config(TargetArch.X86_64, TargetOS.Linux)
        val content = "line1\nline2\n"

        # Write as Windows (CRLF)
        text_file_write(path, content, win_cfg)

        # Read as Unix (should normalize to LF)
        val read_back = text_file_read(path, unix_cfg)
        file_delete(path)

        expect(read_back).to_equal(content)

    it "handles empty file":
        val path = "/tmp/test_platform_empty.txt"
        text_file_write_local(path, "")
        val content = text_file_read_local(path)
        file_delete(path)
        expect(content).to_equal("")

    it "handles single line without trailing newline":
        val path = "/tmp/test_platform_single.txt"
        val content = "single line"
        text_file_write_local(path, content)
        val read_back = text_file_read_local(path)
        file_delete(path)
        expect(read_back).to_equal(content)
