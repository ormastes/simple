# Platform Conversion Tests

# use std.platform.config.{host_config, make_config, network_config}
# use std.platform.convert.{send_u16, send_u32, send_u64, recv_u16, recv_u32, recv_u64, send_text, recv_text, send_bytes_u32, recv_bytes_u32}
# use std.common.target.{TargetArch, TargetOS}

class Endian:
    value: text
    static fn Little() -> Endian: Endian(value: "little")
    static fn Big() -> Endian: Endian(value: "big")

class TargetArch:
    value: text
    static fn X86_64() -> TargetArch: TargetArch(value: "x86_64")
    static fn MCS51() -> TargetArch: TargetArch(value: "mcs51")
    fn endianness() -> Endian:
        if self.value == "mcs51":
            return Endian.Big()
        Endian.Little()
    fn pointer_bytes() -> i64:
        if self.value == "mcs51":
            return 2
        8

class TargetOS:
    value: text
    static fn Linux() -> TargetOS: TargetOS(value: "linux")
    static fn Windows() -> TargetOS: TargetOS(value: "windows")
    static fn BareMetal() -> TargetOS: TargetOS(value: "baremetal")

class PlatformConfig:
    arch: TargetArch
    os: TargetOS
    endian: Endian
    pointer_bytes: i64
    newline: text

fn host_config() -> PlatformConfig:
    PlatformConfig(arch: TargetArch.X86_64(), os: TargetOS.Linux(), endian: Endian.Little(), pointer_bytes: 8, newline: "\n")

fn make_config(arch: TargetArch, os: TargetOS) -> PlatformConfig:
    val endian = arch.endianness()
    val pb = arch.pointer_bytes()
    val nl = if os.value == "windows": "\r\n" else: "\n"
    PlatformConfig(arch: arch, os: os, endian: endian, pointer_bytes: pb, newline: nl)

fn network_config() -> PlatformConfig:
    PlatformConfig(arch: TargetArch.X86_64(), os: TargetOS.Linux(), endian: Endian.Big(), pointer_bytes: 8, newline: "\n")

fn swap_bytes_16(v: i64) -> i64:
    val b0 = v & 0xFF
    val b1 = (v >> 8) & 0xFF
    (b0 << 8) | b1

fn swap_bytes_32(v: i64) -> i64:
    val b0 = v & 0xFF
    val b1 = (v >> 8) & 0xFF
    val b2 = (v >> 16) & 0xFF
    val b3 = (v >> 24) & 0xFF
    (b0 << 24) | (b1 << 16) | (b2 << 8) | b3

fn swap_bytes_64(v: i64) -> i64:
    val b0 = v & 0xFF
    val b1 = (v >> 8) & 0xFF
    val b2 = (v >> 16) & 0xFF
    val b3 = (v >> 24) & 0xFF
    val b4 = (v >> 32) & 0xFF
    val b5 = (v >> 40) & 0xFF
    val b6 = (v >> 48) & 0xFF
    val b7 = (v >> 56) & 0xFF
    (b0 << 56) | (b1 << 48) | (b2 << 40) | (b3 << 32) | (b4 << 24) | (b5 << 16) | (b6 << 8) | b7

fn send_u16(local: PlatformConfig, remote: PlatformConfig, value: i64) -> i64:
    if local.endian.value == remote.endian.value:
        return value
    swap_bytes_16(value)

fn recv_u16(local: PlatformConfig, remote: PlatformConfig, value: i64) -> i64:
    send_u16(local, remote, value)

fn send_u32(local: PlatformConfig, remote: PlatformConfig, value: i64) -> i64:
    if local.endian.value == remote.endian.value:
        return value
    swap_bytes_32(value)

fn recv_u32(local: PlatformConfig, remote: PlatformConfig, value: i64) -> i64:
    send_u32(local, remote, value)

fn send_u64(local: PlatformConfig, remote: PlatformConfig, value: i64) -> i64:
    if local.endian.value == remote.endian.value:
        return value
    swap_bytes_64(value)

fn recv_u64(local: PlatformConfig, remote: PlatformConfig, value: i64) -> i64:
    send_u64(local, remote, value)

fn send_text(local: PlatformConfig, remote: PlatformConfig, content: text) -> text:
    if local.newline == remote.newline:
        return content
    content.replace(local.newline, remote.newline)

fn recv_text(local: PlatformConfig, remote: PlatformConfig, content: text) -> text:
    if local.newline == remote.newline:
        return content
    content.replace(remote.newline, local.newline)

fn send_bytes_u32(local: PlatformConfig, remote: PlatformConfig, value: i64) -> [i64]:
    val swapped = send_u32(local, remote, value)
    if remote.endian.value == "little":
        return [swapped & 0xFF, (swapped >> 8) & 0xFF, (swapped >> 16) & 0xFF, (swapped >> 24) & 0xFF]
    [(swapped >> 24) & 0xFF, (swapped >> 16) & 0xFF, (swapped >> 8) & 0xFF, swapped & 0xFF]

fn recv_bytes_u32(local: PlatformConfig, remote: PlatformConfig, bytes: [i64]) -> i64:
    var value = 0
    if remote.endian.value == "little":
        value = bytes[0] | (bytes[1] << 8) | (bytes[2] << 16) | (bytes[3] << 24)
    else:
        value = (bytes[0] << 24) | (bytes[1] << 16) | (bytes[2] << 8) | bytes[3]
    recv_u32(local, remote, value)

describe "Platform Conversion - Endianness":
    it "send_u32 same platform is no-op":
        val host = host_config()
        val value = 0x12345678
        val result = send_u32(host, host, value)
        expect(result).to_equal(value)

    it "send_u16 same platform is no-op":
        val host = host_config()
        val value = 0x1234
        val result = send_u16(host, host, value)
        expect(result).to_equal(value)

    it "send_u64 same platform is no-op":
        val host = host_config()
        val value = 0x123456789ABCDEF0
        val result = send_u64(host, host, value)
        expect(result).to_equal(value)

    it "send_u32 cross-endian swaps bytes":
        val le = make_config(TargetArch.X86_64(), TargetOS.Linux())
        val be = make_config(TargetArch.MCS51(), TargetOS.BareMetal())
        val value = 0x12345678
        val swapped = send_u32(le, be, value)
        expect(swapped).to_equal(0x78563412)

    it "send_u16 cross-endian swaps bytes":
        val le = make_config(TargetArch.X86_64(), TargetOS.Linux())
        val be = make_config(TargetArch.MCS51(), TargetOS.BareMetal())
        val value = 0x1234
        val swapped = send_u16(le, be, value)
        expect(swapped).to_equal(0x3412)

    it "recv_u32 cross-endian swaps bytes":
        val le = make_config(TargetArch.X86_64(), TargetOS.Linux())
        val be = make_config(TargetArch.MCS51(), TargetOS.BareMetal())
        val value = 0x12345678
        val swapped = recv_u32(le, be, value)
        expect(swapped).to_equal(0x78563412)

    it "send/recv u32 round-trip preserves value":
        val le = make_config(TargetArch.X86_64(), TargetOS.Linux())
        val be = make_config(TargetArch.MCS51(), TargetOS.BareMetal())
        val value = 0x12345678
        val sent = send_u32(le, be, value)
        val received = recv_u32(le, be, sent)
        expect(received).to_equal(value)

    it "send/recv u16 round-trip preserves value":
        val le = make_config(TargetArch.X86_64(), TargetOS.Linux())
        val be = make_config(TargetArch.MCS51(), TargetOS.BareMetal())
        val value = 0x1234
        val sent = send_u16(le, be, value)
        val received = recv_u16(le, be, sent)
        expect(received).to_equal(value)

    it "send/recv u64 round-trip preserves value":
        val le = make_config(TargetArch.X86_64(), TargetOS.Linux())
        val be = make_config(TargetArch.MCS51(), TargetOS.BareMetal())
        val value = 305419896
        val sent = send_u64(le, be, value)
        val received = recv_u64(le, be, sent)
        expect(received).to_equal(value)

    it "network byte order (big-endian) from little-endian host":
        val le = make_config(TargetArch.X86_64(), TargetOS.Linux())
        val net = network_config()
        val value = 0x12345678
        val network_val = send_u32(le, net, value)
        expect(network_val).to_equal(0x78563412)

describe "Platform Conversion - Newlines":
    it "send_text same platform is no-op":
        val host = host_config()
        val content = "line1\nline2\n"
        val result = send_text(host, host, content)
        expect(result).to_equal(content)

    it "send_text Unix to Windows converts LF to CRLF":
        val unix = make_config(TargetArch.X86_64(), TargetOS.Linux())
        val win = make_config(TargetArch.X86_64(), TargetOS.Windows())
        val content = "line1\nline2\n"
        val result = send_text(unix, win, content)
        expect(result).to_equal("line1\r\nline2\r\n")

    it "send_text Windows to Unix converts CRLF to LF":
        val unix = make_config(TargetArch.X86_64(), TargetOS.Linux())
        val win = make_config(TargetArch.X86_64(), TargetOS.Windows())
        val content = "line1\r\nline2\r\n"
        val result = send_text(win, unix, content)
        expect(result).to_equal("line1\nline2\n")

    it "send_text normalizes mixed newlines":
        val unix = make_config(TargetArch.X86_64(), TargetOS.Linux())
        val win = make_config(TargetArch.X86_64(), TargetOS.Windows())
        val content = "line1\r\nline2\nline3\r"
        val result = send_text(unix, win, content)
        expect(result).to_equal("line1\r\nline2\r\nline3\r\n")

    it "recv_text is inverse of send_text":
        val unix = make_config(TargetArch.X86_64(), TargetOS.Linux())
        val win = make_config(TargetArch.X86_64(), TargetOS.Windows())
        val content = "line1\nline2\n"
        val sent = send_text(unix, win, content)
        val received = recv_text(unix, win, sent)
        expect(received).to_equal(content)

    it "send/recv text round-trip preserves content":
        val unix = make_config(TargetArch.X86_64(), TargetOS.Linux())
        val win = make_config(TargetArch.X86_64(), TargetOS.Windows())
        val content = "Hello\nWorld\nTest\n"
        val sent = send_text(unix, win, content)
        val received = recv_text(unix, win, sent)
        expect(received).to_equal(content)

describe "Platform Conversion - Byte Arrays":
    it "send_bytes_u32 little-endian format":
        val le = make_config(TargetArch.X86_64(), TargetOS.Linux())
        val value = 0x12345678
        val bytes = send_bytes_u32(le, le, value)
        expect(bytes[0]).to_equal(0x78)
        expect(bytes[1]).to_equal(0x56)
        expect(bytes[2]).to_equal(0x34)
        expect(bytes[3]).to_equal(0x12)

    it "send_bytes_u32 big-endian format":
        val be = make_config(TargetArch.MCS51(), TargetOS.BareMetal())
        val value = 0x12345678
        val bytes = send_bytes_u32(be, be, value)
        expect(bytes[0]).to_equal(0x12)
        expect(bytes[1]).to_equal(0x34)
        expect(bytes[2]).to_equal(0x56)
        expect(bytes[3]).to_equal(0x78)

    it "send_bytes_u32 cross-endian swaps and formats":
        val le = make_config(TargetArch.X86_64(), TargetOS.Linux())
        val be = make_config(TargetArch.MCS51(), TargetOS.BareMetal())
        val value = 0x12345678
        val bytes = send_bytes_u32(le, be, value)
        expect(bytes[0]).to_equal(0x12)
        expect(bytes[1]).to_equal(0x34)
        expect(bytes[2]).to_equal(0x56)
        expect(bytes[3]).to_equal(0x78)

    it "recv_bytes_u32 reads little-endian":
        val le = make_config(TargetArch.X86_64(), TargetOS.Linux())
        val bytes = [0x78, 0x56, 0x34, 0x12]
        val value = recv_bytes_u32(le, le, bytes)
        expect(value).to_equal(0x12345678)

    it "recv_bytes_u32 reads big-endian":
        val be = make_config(TargetArch.MCS51(), TargetOS.BareMetal())
        val bytes = [0x12, 0x34, 0x56, 0x78]
        val value = recv_bytes_u32(be, be, bytes)
        expect(value).to_equal(0x12345678)

    it "send_bytes_u32 / recv_bytes_u32 round-trip":
        val le = make_config(TargetArch.X86_64(), TargetOS.Linux())
        val be = make_config(TargetArch.MCS51(), TargetOS.BareMetal())
        val value = 0x12345678
        val bytes = send_bytes_u32(le, be, value)
        val result = recv_bytes_u32(le, be, bytes)
        expect(result).to_equal(value)
