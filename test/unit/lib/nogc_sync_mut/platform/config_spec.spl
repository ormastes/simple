# Platform Config Tests

# use std.platform.config.{PlatformConfig, host_config, make_config, network_config, needs_swap, same_platform}
# use std.common.target.{TargetArch, TargetOS, Endian}

class Endian:
    val: text
    static fn Little(): Endian: Endian(val: "little")
    static fn Big(): Endian: Endian(val: "big")
    fn name() -> text: self.val

class TargetArch:
    val: text
    static fn X86_64(): TargetArch: TargetArch(val: "x86_64")
    static fn Arm(): TargetArch: TargetArch(val: "arm")
    static fn Riscv64(): TargetArch: TargetArch(val: "riscv64")
    static fn MCS51(): TargetArch: TargetArch(val: "mcs51")
    fn name() -> text: self.val
    fn endianness() -> Endian:
        if self.val == "mcs51":
            return Endian.Big()
        Endian.Little()
    fn pointer_bytes() -> i64:
        if self.val == "arm":
            return 4
        if self.val == "mcs51":
            return 2
        8

class TargetOS:
    val: text
    static fn Linux(): TargetOS: TargetOS(val: "linux")
    static fn Windows(): TargetOS: TargetOS(val: "windows")
    static fn BareMetal(): TargetOS: TargetOS(val: "baremetal")
    fn name() -> text: self.val

class PlatformConfig:
    arch: TargetArch
    os: TargetOS
    endian: Endian
    pointer_bytes: i64
    newline: text
    fn to_text() -> text:
        "{self.arch.name()}-{self.os.name()} ({self.endian.name()}-endian, {self.pointer_bytes}b ptr)"

fn TargetArch__host() -> TargetArch:
    TargetArch.X86_64()
fn TargetOS__host() -> TargetOS:
    TargetOS.Linux()

fn host_config() -> PlatformConfig:
    val arch = TargetArch__host()
    val os = TargetOS__host()
    PlatformConfig(arch: arch, os: os, endian: arch.endianness(), pointer_bytes: arch.pointer_bytes(), newline: "\n")

fn make_config(arch: TargetArch, os: TargetOS) -> PlatformConfig:
    val endian = arch.endianness()
    val pb = arch.pointer_bytes()
    val nl = if os.val == "windows": "\r\n" else: "\n"
    PlatformConfig(arch: arch, os: os, endian: endian, pointer_bytes: pb, newline: nl)

fn network_config() -> PlatformConfig:
    PlatformConfig(arch: TargetArch.X86_64(), os: TargetOS.Linux(), endian: Endian.Big(), pointer_bytes: 8, newline: "\n")

fn needs_swap(a: PlatformConfig, b: PlatformConfig) -> bool:
    a.endian.val != b.endian.val

fn same_platform(a: PlatformConfig, b: PlatformConfig) -> bool:
    (a.endian.val == b.endian.val and a.newline == b.newline and a.pointer_bytes == b.pointer_bytes)

describe "PlatformConfig":
    it "host_config() auto-detects platform":
        val cfg = host_config()
        expect(cfg.arch).to_equal(TargetArch__host())
        expect(cfg.os).to_equal(TargetOS__host())
        expect(cfg.pointer_bytes > 0).to_equal(true)
        expect(cfg.newline.len() > 0).to_equal(true)

    it "host_config() returns consistent arch/endian":
        val cfg = host_config()
        expect(cfg.endian).to_equal(cfg.arch.endianness())

    it "host_config() returns consistent arch/pointer_bytes":
        val cfg = host_config()
        expect(cfg.pointer_bytes).to_equal(cfg.arch.pointer_bytes())

    it "host_config() uses CRLF on Windows, LF on Unix":
        val cfg = host_config()
        if cfg.os.name() == "windows":
            expect(cfg.newline).to_equal("\r\n")
        else:
            expect(cfg.newline).to_equal("\n")

    it "make_config() creates config for x86_64 Linux":
        val cfg = make_config(TargetArch.X86_64, TargetOS.Linux)
        expect(cfg.arch).to_equal(TargetArch.X86_64)
        expect(cfg.os).to_equal(TargetOS.Linux)
        expect(cfg.endian).to_equal(Endian.Little)
        expect(cfg.pointer_bytes).to_equal(8)
        expect(cfg.newline).to_equal("\n")

    it "make_config() creates config for ARM Windows":
        val cfg = make_config(TargetArch.Arm, TargetOS.Windows)
        expect(cfg.arch).to_equal(TargetArch.Arm)
        expect(cfg.os).to_equal(TargetOS.Windows)
        expect(cfg.endian).to_equal(Endian.Little)
        expect(cfg.pointer_bytes).to_equal(4)
        expect(cfg.newline).to_equal("\r\n")

    it "make_config() creates config for MCS51 (big-endian)":
        val cfg = make_config(TargetArch.MCS51, TargetOS.BareMetal)
        expect(cfg.arch).to_equal(TargetArch.MCS51)
        expect(cfg.os).to_equal(TargetOS.BareMetal)
        expect(cfg.endian).to_equal(Endian.Big)
        expect(cfg.pointer_bytes).to_equal(2)
        expect(cfg.newline).to_equal("\n")

    it "network_config() is big-endian with LF":
        val cfg = network_config()
        expect(cfg.endian).to_equal(Endian.Big)
        expect(cfg.newline).to_equal("\n")
        expect(cfg.pointer_bytes).to_equal(8)

    it "needs_swap() detects same-endian platforms":
        val le1 = make_config(TargetArch.X86_64, TargetOS.Linux)
        val le2 = make_config(TargetArch.Arm, TargetOS.Windows)
        expect(needs_swap(le1, le2)).to_equal(false)

    it "needs_swap() detects cross-endian platforms":
        val le = make_config(TargetArch.X86_64, TargetOS.Linux)
        val be = make_config(TargetArch.MCS51, TargetOS.BareMetal)
        expect(needs_swap(le, be)).to_equal(true)
        expect(needs_swap(be, le)).to_equal(true)

    it "same_platform() returns true for identical configs":
        val cfg1 = make_config(TargetArch.X86_64, TargetOS.Linux)
        val cfg2 = make_config(TargetArch.X86_64, TargetOS.Linux)
        expect(same_platform(cfg1, cfg2)).to_equal(true)

    it "same_platform() returns false for different endianness":
        val le = make_config(TargetArch.X86_64, TargetOS.Linux)
        val be = make_config(TargetArch.MCS51, TargetOS.BareMetal)
        expect(same_platform(le, be)).to_equal(false)

    it "same_platform() returns false for different newlines":
        val unix = make_config(TargetArch.X86_64, TargetOS.Linux)
        val win = make_config(TargetArch.X86_64, TargetOS.Windows)
        expect(same_platform(unix, win)).to_equal(false)

    it "same_platform() returns false for different pointer sizes":
        val x64 = make_config(TargetArch.X86_64, TargetOS.Linux)
        val arm32 = make_config(TargetArch.Arm, TargetOS.Linux)
        expect(same_platform(x64, arm32)).to_equal(false)

    it "to_text() formats config info":
        val cfg = make_config(TargetArch.X86_64, TargetOS.Linux)
        val txt = cfg.to_text()
        expect(txt.contains("x86_64")).to_equal(true)
        expect(txt.contains("linux")).to_equal(true)
        expect(txt.contains("little")).to_equal(true)
