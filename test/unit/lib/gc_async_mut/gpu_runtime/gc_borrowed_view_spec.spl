# GC Borrowed View Pattern Spec
# Documents the borrowed-view pattern in gc_async_mut/gpu_runtime/mod.spl

class MockWrapper:
    handle: i64
    owns_handle: bool

    fn should_free() -> bool:
        self.owns_handle

    fn is_cuda() -> bool:
        self.handle > 0

    fn numel() -> i64:
        self.handle * 10

# Simulates gc_async_mut/gpu_runtime/mod.spl pattern:
# fn gpu_tensor_is_cuda(tensor_handle: i64) -> bool:
#     val t = TorchTensorWrapper(handle: tensor_handle, owns_handle: false)
#     t.is_cuda()
fn mock_gpu_tensor_is_cuda(tensor_handle: i64) -> bool:
    val t = MockWrapper(handle: tensor_handle, owns_handle: false)
    t.is_cuda()

fn mock_gpu_tensor_numel(tensor_handle: i64) -> i64:
    val t = MockWrapper(handle: tensor_handle, owns_handle: false)
    t.numel()

describe "GC Borrowed View Pattern":
    describe "Temporary wrapper access":
        it "borrowed view does not free handle":
            val t = MockWrapper(handle: 42, owns_handle: false)
            expect(t.should_free()).to_equal(false)
            val result = mock_gpu_tensor_is_cuda(42)
            expect(result).to_equal(true)

        it "borrowed view returns correct value":
            val numel = mock_gpu_tensor_numel(5)
            expect(numel).to_equal(50)

    describe "Owned vs borrowed comparison":
        it "owned wrapper frees, borrowed does not":
            val owned = MockWrapper(handle: 10, owns_handle: true)
            val borrowed = MockWrapper(handle: 10, owns_handle: false)
            expect(borrowed.should_free()).to_equal(false)
            expect(owned.should_free()).to_equal(true)

    describe "NoGC replacement pattern":
        it "direct FFI call replaces borrowed view":
            # In NoGC: fn gpu_tensor_is_cuda(h: i64) -> bool:
            #     rt_torch_torchtensor_is_cuda(h)
            # No wrapper created, no ownership question
            val handle = 42
            val is_cuda = handle > 0
            expect(is_cuda).to_equal(true)
