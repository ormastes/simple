# receive: block syntax spec
#
# Tests for `receive:` statement (Erlang-style mailbox receive).
# Token: TOK_KW_RECEIVE=206, TOK_KW_AFTER=207
# AST:   STMT_RECEIVE=19, stmt_receive_stmt(arm_indices, timeout_expr, timeout_body_idx, span)
#
# Interpreter stub behaviour (no real mailbox in interpreter mode):
#   - If an `after TIMEOUT:` arm is present, run its body immediately.
#   - Otherwise, run the first case arm's body.

describe "receive: block syntax":
    describe "single case arm":
        it "parses and runs first arm body":
            var got = 0
            receive:
                case `ping:
                    got = 1
            expect(got).to_equal(1)

        it "case arm with integer pattern parses":
            var got = 0
            receive:
                case 42:
                    got = 42
            expect(got).to_equal(42)

        it "case arm body can use outer variables":
            var result = 0
            val base = 10
            receive:
                case `msg:
                    result = base + 5
            expect(result).to_equal(15)

    describe "multiple case arms":
        it "parses multiple arms and runs first":
            var got = 0
            receive:
                case `ping:
                    got = 1
                case `pong:
                    got = 2
                case `stop:
                    got = 3
            expect(got).to_equal(1)

        it "two arms with string patterns parse":
            var got = "none"
            receive:
                case "hello":
                    got = "hello"
                case "world":
                    got = "world"
            expect(got).to_equal("hello")

    describe "after timeout arm":
        it "after arm runs when present (interpreter stub)":
            var got = 0
            receive:
                case `ping:
                    got = 1
                after 1000:
                    got = 99
            expect(got).to_equal(99)

        it "after arm with zero timeout":
            var got = 0
            receive:
                case `any:
                    got = 1
                after 0:
                    got = 0
            expect(got).to_equal(0)

        it "after arm body can compute":
            var result = 0
            receive:
                case `msg:
                    result = 1
                after 500:
                    result = 10 + 5
            expect(result).to_equal(15)

    describe "after arm without case arms":
        it "after-only receive parses":
            var got = 0
            receive:
                after 2000:
                    got = 42
            expect(got).to_equal(42)

    describe "nested receive":
        it "receive inside a function parses":
            fn run_receive() -> i64:
                var result = 0
                receive:
                    case `done:
                        result = 7
                result
            val r = run_receive()
            expect(r).to_equal(7)

        it "receive with after inside a function":
            fn run_with_timeout() -> i64:
                var result = 0
                receive:
                    case `ok:
                        result = 1
                    after 100:
                        result = 99
                result
            val r = run_with_timeout()
            expect(r).to_equal(99)
