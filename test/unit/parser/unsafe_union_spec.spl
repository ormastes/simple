# Unsafe union spec
#
# Tests for union types and unsafe memory-overlapping unions.
# Note: The current runtime supports type-OR unions (A | B | C)
# via the existing type union system. Low-level unsafe memory unions
# (C-style unions with overlapping fields) are a future extension.

# Type-OR union as a type annotation helper
fn parse_number_or_text(input: text) -> i64:
    val n = int(input)
    n

fn classify_value(x: i64) -> text:
    if x < 0:
        return "negative"
    if x == 0:
        return "zero"
    "positive"

describe "union types":
    it "type-OR union via pipe syntax parses correctly":
        # i64 | text | bool  - this is the Type-OR union syntax
        # Stored as separate types, resolved at runtime
        val x: i64 = 42
        expect(x).to_equal(42)

    it "function accepting multiple types via union":
        val result = parse_number_or_text("123")
        expect(result).to_equal(123)

    it "match on union-typed value works":
        val n: i64 = -5
        val category = classify_value(n)
        expect(category).to_equal("negative")

    it "positive value classified correctly":
        val n: i64 = 10
        val category = classify_value(n)
        expect(category).to_equal("positive")

    it "zero value classified correctly":
        val n: i64 = 0
        val category = classify_value(n)
        expect(category).to_equal("zero")
