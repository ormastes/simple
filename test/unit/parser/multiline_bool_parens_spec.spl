# Unit Test: Multi-line Boolean Expressions with Parentheses
#
# Tests for lexer support of multi-line boolean expressions using parentheses.
# The lexer should suppress newline tokens inside round parentheses `()`.

use core.lexer.{lex_init, lex_next, lex_token_kind, lex_token_text}
use core.tokens.{TOK_LPAREN, TOK_RPAREN, TOK_IDENT, TOK_AND, TOK_OR}
use core.tokens.{TOK_NEWLINE, TOK_COLON, TOK_EOF, TOK_INDENT}
use core.tokens.{TOK_KW_IF, TOK_LBRACKET, TOK_RBRACKET}

describe "Multi-line Boolean Expressions with Parentheses":

    it "suppresses newlines inside round parentheses":
        val source: text = "if (a and\n    b):"
        lex_init(source)

        # Expected tokens: IF LPAREN IDENT AND IDENT RPAREN COLON EOF
        # Newline should be suppressed inside ()

        var kind: i64 = lex_next()
        expect(kind).to_equal(TOK_KW_IF)

        kind = lex_next()
        expect(kind).to_equal(TOK_LPAREN)

        kind = lex_next()
        expect(kind).to_equal(TOK_IDENT)
        expect(lex_token_text()).to_equal("a")

        kind = lex_next()
        expect(kind).to_equal(TOK_AND)

        # Next should be identifier 'b', NOT a newline
        kind = lex_next()
        expect(kind).to_equal(TOK_IDENT)
        expect(lex_token_text()).to_equal("b")

        kind = lex_next()
        expect(kind).to_equal(TOK_RPAREN)

        kind = lex_next()
        expect(kind).to_equal(TOK_COLON)

        kind = lex_next()
        expect(kind).to_equal(TOK_EOF)

    it "suppresses newlines for complex boolean expressions":
        val source: text = "if (a and\n    b and\n    c or\n    d):"
        lex_init(source)

        var kind: i64 = lex_next()
        expect(kind).to_equal(TOK_KW_IF)

        kind = lex_next()
        expect(kind).to_equal(TOK_LPAREN)

        kind = lex_next()
        expect(kind).to_equal(TOK_IDENT)
        expect(lex_token_text()).to_equal("a")

        kind = lex_next()
        expect(kind).to_equal(TOK_AND)

        kind = lex_next()
        expect(kind).to_equal(TOK_IDENT)
        expect(lex_token_text()).to_equal("b")

        kind = lex_next()
        expect(kind).to_equal(TOK_AND)

        kind = lex_next()
        expect(kind).to_equal(TOK_IDENT)
        expect(lex_token_text()).to_equal("c")

        kind = lex_next()
        expect(kind).to_equal(TOK_OR)

        kind = lex_next()
        expect(kind).to_equal(TOK_IDENT)
        expect(lex_token_text()).to_equal("d")

        kind = lex_next()
        expect(kind).to_equal(TOK_RPAREN)

    it "does NOT suppress newlines inside square brackets":
        val source: text = "[a,\nb]"
        lex_init(source)

        var kind: i64 = lex_next()
        expect(kind).to_equal(TOK_LBRACKET)

        kind = lex_next()
        expect(kind).to_equal(TOK_IDENT)
        expect(lex_token_text()).to_equal("a")

        kind = lex_next()
        # Should skip comma token (TOK_COMMA)

        # Next should be NEWLINE (not suppressed in square brackets)
        kind = lex_next()
        expect(kind).to_equal(TOK_NEWLINE)

    it "suppresses indentation inside round parentheses":
        val source: text = "if (a and\n        b):\n    do_work()"
        lex_init(source)

        var kind: i64 = lex_next()
        expect(kind).to_equal(TOK_KW_IF)

        kind = lex_next()
        expect(kind).to_equal(TOK_LPAREN)

        kind = lex_next()
        expect(kind).to_equal(TOK_IDENT)
        expect(lex_token_text()).to_equal("a")

        kind = lex_next()
        expect(kind).to_equal(TOK_AND)

        # Next should be 'b', NOT an indent token
        kind = lex_next()
        expect(kind).to_equal(TOK_IDENT)
        expect(lex_token_text()).to_equal("b")

        kind = lex_next()
        expect(kind).to_equal(TOK_RPAREN)

        kind = lex_next()
        expect(kind).to_equal(TOK_COLON)

        kind = lex_next()
        expect(kind).to_equal(TOK_NEWLINE)

        # After closing paren, indentation should resume
        kind = lex_next()
        expect(kind).to_equal(TOK_INDENT)

    it "handles nested parentheses correctly":
        val source: text = "if ((a and\n     b) or\n    c):"
        lex_init(source)

        var kind: i64 = lex_next()
        expect(kind).to_equal(TOK_KW_IF)

        kind = lex_next()
        expect(kind).to_equal(TOK_LPAREN)

        kind = lex_next()
        expect(kind).to_equal(TOK_LPAREN)

        kind = lex_next()
        expect(kind).to_equal(TOK_IDENT)
        expect(lex_token_text()).to_equal("a")

        kind = lex_next()
        expect(kind).to_equal(TOK_AND)

        kind = lex_next()
        expect(kind).to_equal(TOK_IDENT)
        expect(lex_token_text()).to_equal("b")

        kind = lex_next()
        expect(kind).to_equal(TOK_RPAREN)

        kind = lex_next()
        expect(kind).to_equal(TOK_OR)

        kind = lex_next()
        expect(kind).to_equal(TOK_IDENT)
        expect(lex_token_text()).to_equal("c")

        kind = lex_next()
        expect(kind).to_equal(TOK_RPAREN)

    it "handles multi-line function calls with parentheses":
        val source: text = "result = foo(\n    arg1,\n    arg2\n)"
        lex_init(source)

        # Skip to opening paren
        var kind: i64 = lex_next()  # result
        kind = lex_next()           # =
        kind = lex_next()           # foo

        kind = lex_next()
        expect(kind).to_equal(TOK_LPAREN)

        # No newlines inside function call parens
        kind = lex_next()
        expect(kind).to_equal(TOK_IDENT)
        expect(lex_token_text()).to_equal("arg1")
