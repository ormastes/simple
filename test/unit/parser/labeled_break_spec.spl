# Labeled break/continue spec
#
# Tests for labeled loop control flow.
# Labeled break/continue with 'label syntax is planned.
# Currently, early exit from nested loops can be achieved with
# return values from functions or boolean flags.

fn search_nested(target_i: i64, target_j: i64) -> bool:
    var found = false
    for i in 0..5:
        for j in 0..5:
            if i == target_i and j == target_j:
                found = true
    found

fn count_outer(stop_i: i64) -> i64:
    var outer_count = 0
    for i in 0..5:
        if i == stop_i:
            return outer_count
        outer_count = outer_count + 1
    outer_count

fn count_while_limited(limit: i64) -> i64:
    fn run() -> i64:
        var count = 0
        while count < 10:
            count = count + 1
            if count == limit:
                return count
        count
    run()

describe "labeled break and continue":
    it "basic labeled break exits outer loop (via fn return)":
        val found = search_nested(2, 3)
        expect(found).to_equal(true)

    it "outer loop count via early return":
        val outer_count = count_outer(2)
        expect(outer_count).to_equal(2)

    it "inner break only exits inner loop":
        var outer_count = 0
        for i in 0..3:
            for j in 0..5:
                j + 0
            outer_count = outer_count + 1
        expect(outer_count).to_equal(3)

    it "labeled while loop break via function":
        val count = count_while_limited(5)
        expect(count).to_equal(5)

    it "nested loops complete all iterations":
        var total = 0
        for i in 0..3:
            for j in 0..3:
                total = total + 1
        expect(total).to_equal(9)
