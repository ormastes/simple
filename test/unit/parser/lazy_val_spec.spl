# Lazy val spec
#
# Tests for lazy/deferred evaluation.
# The `lazy val` keyword is planned; currently we use thunks
# (zero-argument functions) to achieve deferred evaluation.

fn make_thunk(f: fn() -> i64) -> fn() -> i64:
    f

fn make_text_thunk(f: fn() -> text) -> fn() -> text:
    f

val expensive_result = fn(): 42 * 1000
val lazy_string = fn(): "hello" + " world"

describe "lazy val declarations":
    it "lazy thunk at module level is evaluatable":
        expect(expensive_result()).to_equal(42000)

    it "lazy string concatenation works":
        expect(lazy_string()).to_equal("hello world")

    it "lazy val in function body via thunk":
        fn compute():
            val thunk = fn(): 10 + 20
            thunk()
        val r = compute()
        expect(r).to_equal(30)

    it "lazy val with complex expression":
        val thunk = fn(): 5 * 5 + 3
        val n = thunk()
        expect(n).to_equal(28)

    it "make_thunk wraps a thunk":
        val orig = fn(): 99
        val wrapped = make_thunk(orig)
        expect(wrapped()).to_equal(99)
