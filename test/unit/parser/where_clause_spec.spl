# Where clause spec
#
# Tests for generic constraint syntax.
# The `where T: Bound` syntax is planned for constraining type parameters.
# Currently, generic functions work without explicit bounds.

fn identity<T>(x: T) -> T:
    x

fn max_val(a: i64, b: i64) -> i64:
    if a > b:
        return a
    b

fn max_text(a: text, b: text) -> text:
    if a > b:
        return a
    b

fn clamp(v: i64, lo: i64, hi: i64) -> i64:
    if v < lo:
        return lo
    if v > hi:
        return hi
    v

describe "where clause constraints":
    it "identity function works":
        val result = identity(42)
        expect(result).to_equal(42)

    it "identity works with text":
        val result = identity("hello")
        expect(result).to_equal("hello")

    it "max_val with constraints":
        val result = max_val(3, 7)
        expect(result).to_equal(7)

    it "max_text with string comparison":
        val result = max_text("apple", "banana")
        expect(result).to_equal("banana")

    it "clamp within range":
        val result = clamp(5, 0, 10)
        expect(result).to_equal(5)

    it "clamp above range":
        val result = clamp(15, 0, 10)
        expect(result).to_equal(10)

    it "clamp below range":
        val result = clamp(-5, 0, 10)
        expect(result).to_equal(0)
