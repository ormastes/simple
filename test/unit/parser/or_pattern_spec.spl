# Or-pattern spec
#
# Tests for `case X | Y:` in match statements

describe "or-patterns in match":
    it "matches first alternative":
        val x = 1
        val result = match x:
            case 1 | 2 | 3: "small"
            case _: "other"
        expect(result).to_equal("small")

    it "matches second alternative":
        val x = 2
        val result = match x:
            case 1 | 2 | 3: "small"
            case _: "other"
        expect(result).to_equal("small")

    it "matches third alternative":
        val x = 3
        val result = match x:
            case 1 | 2 | 3: "small"
            case _: "other"
        expect(result).to_equal("small")

    it "falls through to wildcard when no alternative matches":
        val x = 99
        val result = match x:
            case 1 | 2 | 3: "small"
            case _: "other"
        expect(result).to_equal("other")

    it "or-pattern on text":
        val s = "yes"
        val result = match s:
            case "yes" | "y" | "true": "affirmative"
            case "no" | "n" | "false": "negative"
            case _: "unknown"
        expect(result).to_equal("affirmative")

    it "or-pattern on text second branch":
        val s = "n"
        val result = match s:
            case "yes" | "y" | "true": "affirmative"
            case "no" | "n" | "false": "negative"
            case _: "unknown"
        expect(result).to_equal("negative")

    it "two-way or-pattern":
        val n = 7
        val result = match n:
            case 7 | 42: "magic"
            case _: "mundane"
        expect(result).to_equal("magic")
