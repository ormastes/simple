# # FFI Module Generation Specification
#
# **Feature IDs:** #FFI-001
# **Category:** Tooling
# **Difficulty:** 3/5
# **Status:** In Progress
#
# ## Overview
#
# Tests for the FFI module code generator that converts ModuleSpec to Rust source code.
#
# ## Key Concepts
#
# | Concept | Description |
# |---------|-------------|
# | ModuleSpec | Specification for a complete Rust module |
# | ModuleBuilder | Fluent API for building ModuleSpec |
# | generate_module_source | Converts ModuleSpec to Rust code |

import std.spec

use app.ffi_gen.types*
use app.ffi_gen.module_gen (generate_module_source, ModuleBuilder)
use app.ffi_gen.enum_gen (generate_enum)
use app.ffi_gen.fn_gen (generate_ffi_fn)
use app.ffi_gen.specs.runtime_value_full (runtime_value_module)


# ============================================================================
# Test Group 1: Basic Module Generation
# ============================================================================

describe "Module Generation Basic":
    # ## Basic Module Generation
    #
    # Tests that ModuleSpec correctly generates Rust module source.

    it "generates module with doc comment":
        val spec = ModuleSpec__empty("test_module")
        spec.doc = "Test module documentation"

        val source = generate_module_source(spec)

        expect(source.contains("//! test_module module")).to_equal(true)
        expect(source.contains("//! Test module documentation")).to_equal(true)

    it "generates empty module without errors":
        val spec = ModuleSpec__empty("empty")
        val source = generate_module_source(spec)

        expect(source.len() > 0).to_equal(true)


# ============================================================================
# Test Group 2: Enum Generation
# ============================================================================

describe "Enum Generation":
    # ## Enum Code Generation
    #
    # Tests that EnumSpec correctly generates Rust enum definitions.

    it "generates unit enum":
        val spec = EnumSpec__c_repr("TestEnum", [
            EnumVariantSpec__unit("A"),
            EnumVariantSpec__unit("B")
        ])

        val source = generate_enum(spec)

        expect(source.contains("#[repr(C)]")).to_equal(true)
        expect(source.contains("pub enum TestEnum")).to_equal(true)
        expect(source.contains("A,")).to_equal(true)
        expect(source.contains("B,")).to_equal(true)

    it "generates tuple enum":
        val spec = EnumSpec__c_repr("Value", [
            EnumVariantSpec__unit("Nil"),
            EnumVariantSpec__tuple("Int", ["i64"]),
            EnumVariantSpec__tuple("String", ["Arc<String>"])
        ])

        val source = generate_enum(spec)

        expect(source.contains("Nil,")).to_equal(true)
        expect(source.contains("Int(i64)")).to_equal(true)
        expect(source.contains("String(Arc<String>)")).to_equal(true)

    it "generates enum with discriminants":
        val spec = EnumSpec__c_repr("Status", [
            EnumVariantSpec__unit_with_value("Ok", "0"),
            EnumVariantSpec__unit_with_value("Error", "1")
        ])

        val source = generate_enum(spec)

        expect(source.contains("Ok = 0")).to_equal(true)
        expect(source.contains("Error = 1")).to_equal(true)


# ============================================================================
# Test Group 3: FFI Function Generation
# ============================================================================

describe "FFI Function Generation":
    # ## FFI Function Code Generation
    #
    # Tests that FFIFnSpec correctly generates extern "C" functions.

    it "generates simple extern C function":
        val spec = FFIFnSpec__extern_c("rt_test", [], "i64", "42")

        val source = generate_ffi_fn(spec)

        expect(source.contains("#[no_mangle]")).to_equal(true)
        expect(source.contains("pub extern \"C\" fn rt_test()")).to_equal(true)
        expect(source.contains("-> i64")).to_equal(true)
        expect(source.contains("42")).to_equal(true)

    it "generates unsafe extern C function":
        val spec = FFIFnSpec__unsafe_extern_c(
            "rt_unsafe_test",
            [FFIParamSpec__simple("ptr", "*const i64")],
            "bool",
            "*ptr != 0"
        )

        val source = generate_ffi_fn(spec)

        expect(source.contains("pub unsafe extern \"C\" fn")).to_equal(true)
        expect(source.contains("ptr: *const i64")).to_equal(true)

    it "generates function with multi-line body":
        val body = "if value.is_null() {\n    return false;\n}\ntrue"
        val spec = FFIFnSpec__unsafe_extern_c(
            "rt_check",
            [FFIParamSpec__simple("value", "*const i64")],
            "bool",
            body
        )

        val source = generate_ffi_fn(spec)

        expect(source.contains("if value.is_null()")).to_equal(true)
        expect(source.contains("return false")).to_equal(true)


# ============================================================================
# Test Group 4: ModuleBuilder Integration
# ============================================================================

describe "ModuleBuilder Integration":
    # ## ModuleBuilder Fluent API
    #
    # Tests that ModuleBuilder correctly builds and generates modules.

    it "builds module with imports":
        var builder = ModuleBuilder__start("test")
        builder = builder.add_import("std::ffi::CString")
        builder = builder.add_import("std::os::raw::c_char")
        val spec = builder.build()

        expect(spec.imports.len()).to_equal(2)

        val source = generate_module_source(spec)
        expect(source.contains("use std::ffi::CString")).to_equal(true)

    it "builds module with enum and function":
        var builder = ModuleBuilder__start("combined")
            .doc("Combined test module")

        # Add enum
        val enum_spec = EnumSpec__c_repr("TestType", [
            EnumVariantSpec__unit("None"),
            EnumVariantSpec__tuple("Some", ["i64"])
        ])
        builder = builder.add_enum(enum_spec)

        # Add function
        val fn_spec = FFIFnSpec__extern_c("rt_create", [], "*mut TestType",
            "Box::into_raw(Box::new(TestType::None))")
        builder = builder.add_fn(fn_spec)

        val spec = builder.build()

        expect(spec.types.len()).to_equal(1)
        expect(spec.functions.len()).to_equal(1)

        val source = generate_module_source(spec)

        expect(source.contains("pub enum TestType")).to_equal(true)
        expect(source.contains("fn rt_create")).to_equal(true)

    it "generates complete runtime_value-like module":
        var builder = ModuleBuilder__start("runtime_value")
            .doc("Runtime Value FFI")
            .add_import("std::collections::HashMap")
            .add_import("std::sync::Arc")

        # Add ValueType enum
        builder = builder.add_enum(EnumSpec(
            name: "ValueType",
            generics: [],
            repr_attr: "C",
            derives: ["Debug", "Clone", "Copy"],
            variants: [
                EnumVariantSpec__unit_with_value("Nil", "0"),
                EnumVariantSpec__unit_with_value("Int", "1")
            ],
            visibility: "pub",
            doc: "Value type tags"
        ))

        # Add constructor function
        builder = builder.add_fn(FFIFnSpec__extern_c(
            "rt_value_nil", [], "*mut ValueType",
            "Box::into_raw(Box::new(ValueType::Nil))"
        ))

        val source = builder.generate()

        # Verify all parts are present
        expect(source.contains("//! runtime_value module")).to_equal(true)
        expect(source.contains("use std::collections::HashMap")).to_equal(true)
        expect(source.contains("#[repr(C)]")).to_equal(true)
        expect(source.contains("pub enum ValueType")).to_equal(true)
        expect(source.contains("Nil = 0")).to_equal(true)
        expect(source.contains("fn rt_value_nil")).to_equal(true)
        expect(source.contains("Box::into_raw")).to_equal(true)


# ============================================================================
# Test Group 5: Full Spec Integration
# ============================================================================

describe "Full Spec Integration":
    # ## Full Module Spec Integration
    #
    # Tests that the full runtime_value spec generates correct code.

    it "runtime_value_module returns non-empty spec":
        val spec = runtime_value_module()

        expect(spec.name).to_equal("runtime_value")
        expect(spec.types.len() > 0).to_equal(true)
        expect(spec.functions.len() > 0).to_equal(true)

    it "runtime_value generates full source code":
        val spec = runtime_value_module()
        val source = generate_module_source(spec)

        # Should have significant content
        expect(source.len() > 1000).to_equal(true)

        # Should contain key elements
        expect(source.contains("ValueType")).to_equal(true)
        expect(source.contains("RuntimeValue")).to_equal(true)
        expect(source.contains("rt_value_nil")).to_equal(true)
