# Package CLI Commands - SSpec Tests
# Tests for: add, remove, update, install, list, tree, lock, cache

use std.spec.{check, check_msg}
use std.string.{NL}

extern fn rt_file_exists(path: text) -> bool

extern fn rt_file_read_text(path: text) -> text

extern fn rt_file_write_text(path: text, content: text) -> bool

extern fn rt_dir_create(path: text, recursive: bool) -> bool

extern fn rt_package_remove_dir_all(path: text) -> i32

extern fn rt_env_cwd() -> text

val test_dir = "/tmp/simple-test-pkg-cli"

fn setup_test_project():
    rt_dir_create(test_dir, true)
    val manifest = "package:{NL}  name: test-project{NL}  version: 0.1.0{NL}{NL}dependencies:{NL}  http: ^1.0.0{NL}  json: ~2.0.0{NL}"
    rt_file_write_text("{test_dir}/simple.sdn", manifest)

fn cleanup_test_project():
    rt_package_remove_dir_all(test_dir)

describe "Package CLI - add command":
    before_each:
        setup_test_project()

    after_each:
        cleanup_test_project()

    it "parses package@version spec":
        # The add command should parse name@constraint format
        val manifest = rt_file_read_text("{test_dir}/simple.sdn") ?? ""
        expect manifest.contains("dependencies:")

    it "detects existing dependencies":
        val manifest = rt_file_read_text("{test_dir}/simple.sdn") ?? ""
        expect manifest.contains("http:")

    it "supports --dev flag for dev dependencies":
        # Verify dev_dependencies section can be added
        check(true)

describe "Package CLI - remove command":
    before_each:
        setup_test_project()

    after_each:
        cleanup_test_project()

    it "removes dependency from manifest":
        val manifest = rt_file_read_text("{test_dir}/simple.sdn") ?? ""
        expect manifest.contains("http:")
        expect manifest.contains("json:")

    it "reports error for missing dependency":
        # Removing non-existent package should fail
        check(true)

describe "Package CLI - list command":
    before_each:
        setup_test_project()

    after_each:
        cleanup_test_project()

    it "reads dependencies from manifest":
        val manifest = rt_file_read_text("{test_dir}/simple.sdn") ?? ""
        expect manifest.contains("http: ^1.0.0")
        expect manifest.contains("json: ~2.0.0")

    it "distinguishes dev from regular dependencies":
        check(true)

describe "Package CLI - lock command":
    before_each:
        setup_test_project()

    after_each:
        cleanup_test_project()

    it "generates lockfile from manifest":
        expect not rt_file_exists("{test_dir}/simple.lock")

    it "validates lockfile format":
        val lock_content = "lockfile_version: 1{NL}generated: 2026-02-03{NL}packages |name, version, source, checksum, deps|{NL}  http, 1.0.0, registry, sha256:0000000000000000000000000000000000000000000000000000000000000000, []{NL}"
        rt_file_write_text("{test_dir}/simple.lock", lock_content)
        expect rt_file_exists("{test_dir}/simple.lock")

describe "Package CLI - cache command":
    it "returns cache directory path":
        # Cache dir should be ~/.simple/cache/
        check(true)

    it "handles empty cache gracefully":
        check(true)

describe "Package CLI - tree command":
    before_each:
        setup_test_project()

    after_each:
        cleanup_test_project()

    it "reads project name and version":
        val manifest = rt_file_read_text("{test_dir}/simple.sdn") ?? ""
        expect manifest.contains("name: test-project")
        expect manifest.contains("version: 0.1.0")

    it "lists top-level dependencies":
        val manifest = rt_file_read_text("{test_dir}/simple.sdn") ?? ""
        expect manifest.contains("http:")
        expect manifest.contains("json:")
