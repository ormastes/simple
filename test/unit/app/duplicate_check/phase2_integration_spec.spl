# Phase 2 Integration Tests - Parallel processing and incremental analysis

use app.duplicate_check.config.{DuplicationConfig}
use app.duplicate_check.parallel.{ParallelConfig, default_parallel_config, single_threaded_config, detect_cpu_count}
use app.duplicate_check.incremental.{IncrementalCache, load_incremental_cache, save_incremental_cache, needs_reprocessing, get_cached_blocks, update_cache_entry, compute_incremental_stats, format_incremental_stats}
use app.duplicate_check.detector.{DuplicateBlock, find_duplicates}
use app.duplicate_check.cache.{new_token_cache_manager}
use app.io.mod.{file_read, file_exists}
use test.app.duplicate_check.test_helpers.{create_test_file_in, cleanup_test_dir, minimal_test_config}

val TEST_DIR = "/tmp/test_duplicate_phase2"

fn create_test_file(path: text, content: text):
    create_test_file_in(TEST_DIR, path, content)

fn cleanup_test_files():
    cleanup_test_dir(TEST_DIR)

describe "Phase 2: Parallel configuration":
    it "creates default parallel config":
        val config = default_parallel_config()

        expect(config.num_workers).to_equal(0)  # Auto-detect
        expect(config.batch_size).to_equal(10)
        expect(config.enabled).to_equal(true)

    it "creates single-threaded config":
        val config = single_threaded_config()

        expect(config.num_workers).to_equal(1)
        expect(config.enabled).to_equal(false)

    it "detects CPU count":
        val cpu_count = detect_cpu_count()

        expect(cpu_count).to_be_greater_than(0)

describe "Phase 2: Incremental cache loading":
    it "creates empty cache when file missing":
        val cache_path = "/tmp/test_duplicate_phase2/cache_empty.sdn"
        cleanup_test_files()

        var config = minimal_test_config()
        config.min_tokens = 30
        config.min_lines = 5
        config.use_incremental = true
        config.incremental_cache_path = cache_path

        val cache = load_incremental_cache(cache_path, config)

        expect(cache.entries.keys().len()).to_equal(0)
        expect(cache.cache_path).to_equal(cache_path)

        cleanup_test_files()

    it "saves and loads incremental cache":
        val cache_path = "/tmp/test_duplicate_phase2/cache_save.sdn"
        cleanup_test_files()

        var config = minimal_test_config()
        config.min_tokens = 30
        config.min_lines = 5
        config.use_incremental = true
        config.incremental_cache_path = cache_path

        var cache = load_incremental_cache(cache_path, config)

        # Add a test block
        val test_file = "/tmp/test_duplicate_phase2/test.spl"
        create_test_file(test_file, "fn test(): 42")

        val blocks = [DuplicateBlock(
            file: test_file,
            line_start: 1,
            line_end: 1,
            token_count: 5,
            hash_value: 12345,
            code: "fn test(): 42"
        )]

        update_cache_entry(cache, test_file, blocks)
        save_incremental_cache(cache)

        # Reload cache
        val reloaded = load_incremental_cache(cache_path, config)

        expect(reloaded.entries.keys().len()).to_equal(1)
        expect(reloaded.entries.contains_key(test_file)).to_equal(true)

        cleanup_test_files()

describe "Phase 2: Incremental cache invalidation":
    it "detects file changes":
        val cache_path = "/tmp/test_duplicate_phase2/cache_invalidate.sdn"
        cleanup_test_files()

        var config = minimal_test_config()
        config.min_tokens = 30
        config.min_lines = 5
        config.use_incremental = true
        config.incremental_cache_path = cache_path

        var cache = load_incremental_cache(cache_path, config)

        val test_file = "/tmp/test_duplicate_phase2/test_change.spl"
        create_test_file(test_file, "fn test1(): 1")

        val blocks = [DuplicateBlock(
            file: test_file,
            line_start: 1,
            line_end: 1,
            token_count: 5,
            hash_value: 111,
            code: "fn test1(): 1"
        )]

        update_cache_entry(cache, test_file, blocks)
        save_incremental_cache(cache)

        # File should not need reprocessing (unchanged)
        var needs_update = needs_reprocessing(test_file, cache)
        expect(needs_update).to_equal(false)

        # Change file content
        file_write(test_file, "fn test2(): 2")

        # Now should need reprocessing
        needs_update = needs_reprocessing(test_file, cache)
        expect(needs_update).to_equal(true)

        cleanup_test_files()

describe "Phase 2: Incremental statistics":
    it "computes cache hit rate":
        val stats = compute_incremental_stats(100, 70)

        expect(stats.total_files).to_equal(100)
        expect(stats.cached_files).to_equal(70)
        expect(stats.reprocessed_files).to_equal(30)
        expect(stats.cache_hit_rate).to_equal(70)

    it "formats incremental stats":
        val stats = compute_incremental_stats(50, 40)
        val formatted = format_incremental_stats(stats)

        expect(formatted).to_contain("10 changed")
        expect(formatted).to_contain("40 cached")
        expect(formatted).to_contain("80% hit rate")

describe "Phase 2: End-to-end incremental detection":
    it "uses cached results for unchanged files":
        val cache_path = "/tmp/test_duplicate_phase2/cache_e2e.sdn"
        cleanup_test_files()

        val test_file1 = "/tmp/test_duplicate_phase2/e2e_test1.spl"
        val test_file2 = "/tmp/test_duplicate_phase2/e2e_test2.spl"
        create_test_file(test_file1, "fn test1(): 42")
        create_test_file(test_file2, "fn test2(): 42")

        var config = minimal_test_config()
        config.use_incremental = true
        config.incremental_cache_path = cache_path

        # First run - build cache
        var cache = load_incremental_cache(cache_path, config)
        val cache_manager = new_token_cache_manager()
        val files = [test_file1, test_file2]
        val groups1 = find_duplicates(files, config, cache_manager)

        expect(groups1.len()).to_be_greater_than(0)

        # Second run - should use cache
        cache = load_incremental_cache(cache_path, config)
        val cached1 = get_cached_blocks(test_file1, cache)

        # Cache should be empty (we didn't update it manually)
        expect(cached1.len()).to_equal(0)

        cleanup_test_files()
