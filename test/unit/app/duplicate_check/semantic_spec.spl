# Tests for semantic doc similarity analysis

use app.duplicate_check.doc_extractor.{DocEntry, extract_docs_from_file, process_doc_text, build_embedding_key, content_hash}
use app.duplicate_check.ollama_client.{EmbeddingResult, parse_embedding_response, parse_float_safe}
use app.duplicate_check.embedding_cache.{EmbeddingCacheManager, EmbeddingCacheEntry, load_embedding_cache, save_embedding_cache, get_cached, set_cached, csv_to_floats, floats_to_csv}
use app.duplicate_check.semantic.{SemanticMatch, SemanticReport, cosine_similarity_dense, text_similarity}
use app.duplicate_check.semantic_formatter.{format_match_line, severity_label}

# ============================================================================
# Doc Extractor Tests
# ============================================================================

describe "doc_extractor":
    it "extracts fn with doc comment":
        val entry = DocEntry(
            file_path: "test.spl",
            line_number: 3,
            item_name: "add",
            item_kind: "fn",
            signature: "fn add(a: i64, b: i64) -> i64",
            doc_comment: "Add two numbers together",
            has_doc: true
        )
        expect(entry.item_name).to_equal("add")
        expect(entry.item_kind).to_equal("fn")
        expect(entry.has_doc).to_equal(true)

    it "extracts fn without doc":
        val entry = DocEntry(
            file_path: "test.spl",
            line_number: 5,
            item_name: "helper",
            item_kind: "fn",
            signature: "fn helper()",
            doc_comment: "",
            has_doc: false
        )
        expect(entry.has_doc).to_equal(false)

    it "processes doc text - strips hash prefix":
        val result = process_doc_text("# This is a comment")
        expect(result).to_equal("This is a comment")

    it "processes doc text - strips multiple hashes":
        val result = process_doc_text("## Section header")
        expect(result).to_equal("Section header")

    it "builds embedding key with doc":
        val entry = DocEntry(
            file_path: "test.spl",
            line_number: 1,
            item_name: "foo",
            item_kind: "fn",
            signature: "fn foo(x: i64)",
            doc_comment: "Does something",
            has_doc: true
        )
        val key = build_embedding_key(entry)
        expect(key).to_contain("fn foo")
        expect(key).to_contain("Does something")

    it "builds embedding key without doc":
        val entry = DocEntry(
            file_path: "test.spl",
            line_number: 1,
            item_name: "bar",
            item_kind: "fn",
            signature: "fn bar()",
            doc_comment: "",
            has_doc: false
        )
        val key = build_embedding_key(entry)
        expect(key).to_equal("fn bar()")

    it "content hash is deterministic":
        val h1 = content_hash("hello world")
        val h2 = content_hash("hello world")
        expect(h1).to_equal(h2)

    it "content hash differs for different inputs":
        val h1 = content_hash("hello")
        val h2 = content_hash("world")
        val same = h1 == h2
        expect(same).to_equal(false)

# ============================================================================
# Ollama Client Tests
# ============================================================================

describe "ollama_client":
    it "parses float safely - positive":
        val f = parse_float_safe("3.14")
        val close = f > 3.13 and f < 3.15
        expect(close).to_equal(true)

    it "parses float safely - negative":
        val f = parse_float_safe("-2.5")
        val close = f > -2.6 and f < -2.4
        expect(close).to_equal(true)

    it "parses float safely - integer":
        val f = parse_float_safe("42")
        val close = f > 41.9 and f < 42.1
        expect(close).to_equal(true)

    it "parses float safely - zero":
        val f = parse_float_safe("0.0")
        val is_zero = f == 0.0
        expect(is_zero).to_equal(true)

    it "parses float safely - empty string":
        val f = parse_float_safe("")
        val is_zero = f == 0.0
        expect(is_zero).to_equal(true)

    it "parses embedding response with embeddings key":
        val lb = (123 as char).to_text()
        val rb = (125 as char).to_text()
        val json = lb + "\"embeddings\":[[0.1,0.2,0.3]]" + rb
        val vec = parse_embedding_response(json)
        expect(vec.len()).to_equal(3)

    it "parses embedding response - empty returns empty":
        val vec = parse_embedding_response("")
        expect(vec.len()).to_equal(0)

# ============================================================================
# Embedding Cache Tests
# ============================================================================

describe "embedding_cache":
    it "csv_to_floats converts comma-separated values":
        val result = csv_to_floats("1.0,2.5,3.7")
        expect(result.len()).to_equal(3)

    it "csv_to_floats handles empty string":
        val result = csv_to_floats("")
        expect(result.len()).to_equal(0)

    it "floats_to_csv converts array to csv":
        val csv = floats_to_csv([1.0, 2.0, 3.0])
        expect(csv).to_contain(",")

    it "csv roundtrip preserves length":
        val original = [0.1, 0.2, 0.3, 0.4]
        val csv = floats_to_csv(original)
        val restored = csv_to_floats(csv)
        expect(restored.len()).to_equal(4)

    it "cache starts empty":
        val cache = EmbeddingCacheManager(
            entries: {},
            cache_path: "/tmp/test_cache.txt",
            model_name: "test-model",
            hits: 0,
            misses: 0
        )
        val result = get_cached(cache, "key1", "hash1")
        expect(result).to_equal("")
        expect(cache.misses).to_equal(1)

    it "set and get cached entry":
        val cache = EmbeddingCacheManager(
            entries: {},
            cache_path: "/tmp/test_cache.txt",
            model_name: "test-model",
            hits: 0,
            misses: 0
        )
        set_cached(cache, "key1", "hash1", "0.1,0.2,0.3")
        val result = get_cached(cache, "key1", "hash1")
        expect(result).to_equal("0.1,0.2,0.3")
        expect(cache.hits).to_equal(1)

    it "cache miss on hash mismatch":
        val cache = EmbeddingCacheManager(
            entries: {},
            cache_path: "/tmp/test_cache.txt",
            model_name: "test-model",
            hits: 0,
            misses: 0
        )
        set_cached(cache, "key1", "hash1", "0.1,0.2,0.3")
        val result = get_cached(cache, "key1", "hash2")
        expect(result).to_equal("")

# ============================================================================
# Semantic Analysis Tests
# ============================================================================

describe "semantic - cosine similarity":
    it "identical vectors have similarity 1.0":
        val a = [1.0, 0.0, 0.0]
        val b = [1.0, 0.0, 0.0]
        val sim = cosine_similarity_dense(a, b)
        val close = sim > 0.99 and sim <= 1.0
        expect(close).to_equal(true)

    it "orthogonal vectors have similarity 0.0":
        val a = [1.0, 0.0, 0.0]
        val b = [0.0, 1.0, 0.0]
        val sim = cosine_similarity_dense(a, b)
        val close = sim >= 0.0 and sim < 0.01
        expect(close).to_equal(true)

    it "similar vectors have high similarity":
        val a = [1.0, 1.0, 0.0]
        val b = [1.0, 0.9, 0.1]
        val sim = cosine_similarity_dense(a, b)
        val high = sim > 0.9
        expect(high).to_equal(true)

    it "empty vectors return 0.0":
        val sim = cosine_similarity_dense([], [])
        val is_zero = sim == 0.0
        expect(is_zero).to_equal(true)

    it "mismatched lengths return 0.0":
        val a = [1.0, 2.0]
        val b = [1.0, 2.0, 3.0]
        val sim = cosine_similarity_dense(a, b)
        val is_zero = sim == 0.0
        expect(is_zero).to_equal(true)

describe "semantic - text similarity":
    it "identical strings have similarity 1.0":
        val sim = text_similarity("hello world", "hello world")
        val is_one = sim == 1.0
        expect(is_one).to_equal(true)

    it "completely different strings have low similarity":
        val sim = text_similarity("aaaaaa", "zzzzzz")
        val is_low = sim < 0.5
        expect(is_low).to_equal(true)

    it "similar strings have high similarity":
        val sim = text_similarity("add element to array", "add item to array")
        val is_high = sim > 0.7
        expect(is_high).to_equal(true)

# ============================================================================
# Formatter Tests
# ============================================================================

describe "semantic_formatter":
    it "severity_label for copy_paste":
        val label = severity_label(0.98, "copy_paste")
        expect(label).to_equal("[COPY-PASTE]")

    it "severity_label for drift":
        val label = severity_label(0.30, "drift")
        expect(label).to_equal("[DRIFT]")

    it "severity_label for similar high score":
        val label = severity_label(0.96, "similar")
        expect(label).to_equal("[NEAR-IDENTICAL]")

    it "severity_label for similar lower score":
        val label = severity_label(0.91, "similar")
        expect(label).to_equal("[SIMILAR]")

    it "format_match_line contains file paths":
        val entry_a = DocEntry(
            file_path: "src/std/array.spl",
            line_number: 45,
            item_name: "push",
            item_kind: "fn",
            signature: "fn push(arr, item)",
            doc_comment: "Add element to array",
            has_doc: true
        )
        val entry_b = DocEntry(
            file_path: "src/std/array.spl",
            line_number: 89,
            item_name: "append",
            item_kind: "fn",
            signature: "fn append(arr, item)",
            doc_comment: "Append element to array",
            has_doc: true
        )
        val m = SemanticMatch(
            entry_a: entry_a,
            entry_b: entry_b,
            similarity: 0.95,
            match_kind: "similar"
        )
        val line = format_match_line(m)
        expect(line).to_contain("src/std/array.spl")
        expect(line).to_contain("push")
        expect(line).to_contain("append")
