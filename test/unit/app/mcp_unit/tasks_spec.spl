# MCP Task Lifecycle Tests
# Feature: MCP Task Management
# Category: MCP, Async
# Status: Complete
#
# Tests for task lifecycle management and progress tracking.
#
# NOTE: Classes defined inline because std.mcp.core.tasks module
# does not exist yet. .new() anti-pattern replaced with direct construction.


# ============================================================================
# Inline type definitions (std.mcp.core.tasks not yet implemented)
# ============================================================================

enum TaskStatus:
    Pending
    Running
    Completed
    Failed
    Cancelled
    TimedOut

impl TaskStatus:
    fn to_string() -> text:
        match self:
            case TaskStatus.Pending: "pending"
            case TaskStatus.Running: "running"
            case TaskStatus.Completed: "completed"
            case TaskStatus.Failed: "failed"
            case TaskStatus.Cancelled: "cancelled"
            case TaskStatus.TimedOut: "timed_out"

    fn is_terminal() -> bool:
        match self:
            case TaskStatus.Pending: false
            case TaskStatus.Running: false
            case TaskStatus.Completed: true
            case TaskStatus.Failed: true
            case TaskStatus.Cancelled: true
            case TaskStatus.TimedOut: true

enum TaskPriority:
    Low
    Normal
    High
    Critical

impl TaskPriority:
    fn to_string() -> text:
        match self:
            case TaskPriority.Low: "low"
            case TaskPriority.Normal: "normal"
            case TaskPriority.High: "high"
            case TaskPriority.Critical: "critical"

    fn to_i64() -> i64:
        match self:
            case TaskPriority.Low: 0
            case TaskPriority.Normal: 1
            case TaskPriority.High: 2
            case TaskPriority.Critical: 3

enum ErrorCategory:
    Tool
    Transport
    Protocol
    RateLimit

class McpError:
    category: ErrorCategory
    msg: text

class TaskProgress:
    current: i64
    total: i64?
    message: text?
    percentage: f64?

impl TaskProgress:
    fn with_total(t: i64) -> TaskProgress:
        val pct = (self.current * 100) / t
        TaskProgress(current: self.current, total: Some(t), message: self.message, percentage: Some(pct.to_f64()))

    fn with_message(m: text) -> TaskProgress:
        TaskProgress(current: self.current, total: self.total, message: Some(m), percentage: self.percentage)

    fn to_dict() -> Dict<text, Any>:
        var d: Dict<text, Any> = {}
        d.set("current", self.current)
        match self.total:
            case Some(t):
                d.set("total", t)
            case nil: pass
        match self.message:
            case Some(m):
                d.set("message", m)
            case nil: pass
        match self.percentage:
            case Some(p):
                d.set("percentage", p)
            case nil: pass
        d

class TaskError:
    code: text
    message: text
    retryable: bool
    details: text?

impl TaskError:
    fn with_details(d: text) -> TaskError:
        TaskError(code: self.code, message: self.message, retryable: self.retryable, details: Some(d))

    fn as_retryable() -> TaskError:
        TaskError(code: self.code, message: self.message, retryable: true, details: self.details)

    fn to_mcp_error() -> McpError:
        McpError(category: ErrorCategory.Tool, msg: self.message)

class Task:
    id: text
    operation: text
    status: TaskStatus
    priority: TaskPriority
    timeout_ms: i64?
    started_at: text?
    completed_at: text?
    progress: TaskProgress?
    error: TaskError?

impl Task:
    fn with_priority(p: TaskPriority) -> Task:
        Task(id: self.id, operation: self.operation, status: self.status, priority: p, timeout_ms: self.timeout_ms, started_at: self.started_at, completed_at: self.completed_at, progress: self.progress, error: self.error)

    fn with_timeout(t: i64) -> Task:
        Task(id: self.id, operation: self.operation, status: self.status, priority: self.priority, timeout_ms: Some(t), started_at: self.started_at, completed_at: self.completed_at, progress: self.progress, error: self.error)

    fn is_running() -> bool:
        match self.status:
            case TaskStatus.Running: true
            case _: false

    fn is_complete() -> bool:
        match self.status:
            case TaskStatus.Completed: true
            case TaskStatus.Failed: true
            case TaskStatus.Cancelled: true
            case TaskStatus.TimedOut: true
            case _: false

    fn to_dict() -> Dict<text, Any>:
        var d: Dict<text, Any> = {}
        d.set("id", self.id)
        d.set("operation", self.operation)
        d.set("status", match self.status:
            case TaskStatus.Pending: "pending"
            case TaskStatus.Running: "running"
            case TaskStatus.Completed: "completed"
            case TaskStatus.Failed: "failed"
            case TaskStatus.Cancelled: "cancelled"
            case TaskStatus.TimedOut: "timed_out"
        )
        d.set("priority", match self.priority:
            case TaskPriority.Low: "low"
            case TaskPriority.Normal: "normal"
            case TaskPriority.High: "high"
            case TaskPriority.Critical: "critical"
        )
        d

class TaskManager:
    tasks: Dict<text, Task>
    running_count: i64
    max_concurrent_tasks: i64
    next_id: i64

impl TaskManager:
    me create_task(operation: text) -> text:
        val task_id = "task_{self.next_id}"
        self.next_id = self.next_id + 1
        val task = Task(id: task_id, operation: operation, status: TaskStatus.Pending, priority: TaskPriority.Normal, timeout_ms: nil, started_at: nil, completed_at: nil, progress: nil, error: nil)
        self.tasks.set(task_id, task)
        task_id

    me create_task_with_options(operation: text, priority: TaskPriority, timeout: i64?) -> text:
        val task_id = "task_{self.next_id}"
        self.next_id = self.next_id + 1
        val task = Task(id: task_id, operation: operation, status: TaskStatus.Pending, priority: priority, timeout_ms: timeout, started_at: nil, completed_at: nil, progress: nil, error: nil)
        self.tasks.set(task_id, task)
        task_id

    fn get_task(task_id: text) -> Task?:
        if self.tasks.contains_key(task_id):
            Some(self.tasks.get(task_id))
        else:
            nil

    me start_task(task_id: text) -> Result<bool, McpError>:
        if self.running_count >= self.max_concurrent_tasks:
            return Err(McpError(category: ErrorCategory.RateLimit, msg: "Max concurrent tasks reached"))
        if self.tasks.contains_key(task_id):
            var task = self.tasks.get(task_id)
            task.status = TaskStatus.Running
            task.started_at = Some("now")
            self.tasks.set(task_id, task)
            self.running_count = self.running_count + 1
            Ok(true)
        else:
            Err(McpError(category: ErrorCategory.Tool, msg: "Task not found"))

    me update_progress(task_id: text, current: i64, total: i64) -> Result<bool, McpError>:
        if self.tasks.contains_key(task_id):
            var task = self.tasks.get(task_id)
            val pct = (current * 100) / total
            task.progress = Some(TaskProgress(current: current, total: Some(total), message: nil, percentage: Some(pct.to_f64())))
            self.tasks.set(task_id, task)
            Ok(true)
        else:
            Err(McpError(category: ErrorCategory.Tool, msg: "Task not found"))

    me update_progress_with_message(task_id: text, current: i64, total: i64, msg: text) -> Result<bool, McpError>:
        if self.tasks.contains_key(task_id):
            var task = self.tasks.get(task_id)
            val pct = (current * 100) / total
            task.progress = Some(TaskProgress(current: current, total: Some(total), message: Some(msg), percentage: Some(pct.to_f64())))
            self.tasks.set(task_id, task)
            Ok(true)
        else:
            Err(McpError(category: ErrorCategory.Tool, msg: "Task not found"))

    me complete_task(task_id: text, result_msg: text) -> Result<bool, McpError>:
        if self.tasks.contains_key(task_id):
            var task = self.tasks.get(task_id)
            task.status = TaskStatus.Completed
            task.completed_at = Some("now")
            self.tasks.set(task_id, task)
            self.running_count = self.running_count - 1
            Ok(true)
        else:
            Err(McpError(category: ErrorCategory.Tool, msg: "Task not found"))

    me fail_task(task_id: text, err: TaskError) -> Result<bool, McpError>:
        if self.tasks.contains_key(task_id):
            var task = self.tasks.get(task_id)
            task.status = TaskStatus.Failed
            task.error = Some(err)
            self.tasks.set(task_id, task)
            self.running_count = self.running_count - 1
            Ok(true)
        else:
            Err(McpError(category: ErrorCategory.Tool, msg: "Task not found"))

    me cancel_task(task_id: text) -> Result<bool, McpError>:
        if self.tasks.contains_key(task_id):
            var task = self.tasks.get(task_id)
            val was_running = task.is_running()
            task.status = TaskStatus.Cancelled
            self.tasks.set(task_id, task)
            if was_running:
                self.running_count = self.running_count - 1
            Ok(true)
        else:
            Err(McpError(category: ErrorCategory.Tool, msg: "Task not found"))

    fn list_tasks() -> [Task]:
        var result: [Task] = []
        for key in self.tasks.keys():
            result.push(self.tasks.get(key))
        result

    fn list_tasks_by_status(status: TaskStatus) -> [Task]:
        var result: [Task] = []
        for key in self.tasks.keys():
            val task = self.tasks.get(key)
            if task.status.to_string() == status.to_string():
                result.push(task)
        result

    me cleanup_completed(max_age_ms: i64):
        var to_remove: [text] = []
        for key in self.tasks.keys():
            val task = self.tasks.get(key)
            if task.is_complete():
                to_remove.push(key)
        for key in to_remove:
            self.tasks.remove(key)

# ============================================================================
# Tests
# ============================================================================

describe "TaskStatus":
    it "converts to string":
        expect(TaskStatus.Pending.to_string() == "pending")
        expect(TaskStatus.Running.to_string() == "running")
        expect(TaskStatus.Completed.to_string() == "completed")
        expect(TaskStatus.Failed.to_string() == "failed")
        expect(TaskStatus.Cancelled.to_string() == "cancelled")
        expect(TaskStatus.TimedOut.to_string() == "timed_out")

    it "identifies terminal states":
        expect(not TaskStatus.Pending.is_terminal())
        expect(not TaskStatus.Running.is_terminal())
        expect(TaskStatus.Completed.is_terminal())
        expect(TaskStatus.Failed.is_terminal())
        expect(TaskStatus.Cancelled.is_terminal())
        expect(TaskStatus.TimedOut.is_terminal())

describe "TaskPriority":
    it "converts to string":
        expect(TaskPriority.Low.to_string() == "low")
        expect(TaskPriority.Normal.to_string() == "normal")
        expect(TaskPriority.High.to_string() == "high")
        expect(TaskPriority.Critical.to_string() == "critical")

    it "converts to numeric":
        expect(TaskPriority.Low.to_i64() == 0)
        expect(TaskPriority.Normal.to_i64() == 1)
        expect(TaskPriority.High.to_i64() == 2)
        expect(TaskPriority.Critical.to_i64() == 3)

describe "TaskProgress":
    it "creates basic progress":
        val progress = TaskProgress(current: 50, total: nil, message: nil, percentage: nil)
        expect(progress.current == 50)

    it "adds total for percentage":
        var p0 = TaskProgress(current: 25, total: nil, message: nil, percentage: nil)
        val progress = p0.with_total(100)
        expect(progress.current == 25)

        match progress.total:
            case Some(t):
                expect(t == 100)
            case nil:
                expect(false)

        match progress.percentage:
            case Some(p):
                expect(p == 25.0)
            case nil:
                expect(false)

    it "adds message":
        var p0 = TaskProgress(current: 10, total: nil, message: nil, percentage: nil)
        val progress = p0.with_message("Processing...")

        match progress.message:
            case Some(m):
                expect(m == "Processing...")
            case nil:
                expect(false)

    it "converts to dict":
        var p0 = TaskProgress(current: 50, total: nil, message: nil, percentage: nil)
        var p1 = p0.with_total(100)
        val progress = p1.with_message("Half done")
        val dict = progress.to_dict()

        expect(dict.get("current") == 50)
        expect(dict.contains_key("total"))
        expect(dict.contains_key("message"))
        expect(dict.contains_key("percentage"))

describe "Task":
    it "creates new task":
        val task = Task(id: "task_1", operation: "test_operation", status: TaskStatus.Pending, priority: TaskPriority.Normal, timeout_ms: nil, started_at: nil, completed_at: nil, progress: nil, error: nil)
        expect(task.id == "task_1")
        expect(task.operation == "test_operation")

    it "sets priority":
        var t0 = Task(id: "task_1", operation: "op", status: TaskStatus.Pending, priority: TaskPriority.Normal, timeout_ms: nil, started_at: nil, completed_at: nil, progress: nil, error: nil)
        val task = t0.with_priority(TaskPriority.High)
        expect(task.priority == TaskPriority.High)

    it "sets timeout":
        var t0 = Task(id: "task_1", operation: "op", status: TaskStatus.Pending, priority: TaskPriority.Normal, timeout_ms: nil, started_at: nil, completed_at: nil, progress: nil, error: nil)
        val task = t0.with_timeout(5000)

        match task.timeout_ms:
            case Some(t):
                expect(t == 5000)
            case nil:
                expect(false)

    it "checks running state":
        var task = Task(id: "task_1", operation: "op", status: TaskStatus.Pending, priority: TaskPriority.Normal, timeout_ms: nil, started_at: nil, completed_at: nil, progress: nil, error: nil)
        expect(not task.is_running())

        # Simulate starting
        task.status = TaskStatus.Running
        expect(task.is_running())

    it "checks complete state":
        var task = Task(id: "task_1", operation: "op", status: TaskStatus.Pending, priority: TaskPriority.Normal, timeout_ms: nil, started_at: nil, completed_at: nil, progress: nil, error: nil)
        expect(not task.is_complete())

        task.status = TaskStatus.Completed
        expect(task.is_complete())

        task.status = TaskStatus.Failed
        expect(task.is_complete())

    it "converts to dict":
        var t0 = Task(id: "task_1", operation: "test", status: TaskStatus.Pending, priority: TaskPriority.Normal, timeout_ms: nil, started_at: nil, completed_at: nil, progress: nil, error: nil)
        val task = t0.with_priority(TaskPriority.High)
        val dict = task.to_dict()

        expect(dict.get("id") == "task_1")
        expect(dict.get("operation") == "test")
        expect(dict.get("status") == "pending")
        expect(dict.get("priority") == "high")

describe "TaskError":
    it "creates error":
        val error = TaskError(code: "ERR_001", message: "Something went wrong", retryable: false, details: nil)
        expect(error.code == "ERR_001")
        expect(error.message == "Something went wrong")
        expect(not error.retryable)

    it "adds details":
        var e0 = TaskError(code: "ERR", message: "msg", retryable: false, details: nil)
        val error = e0.with_details("extra info")

        match error.details:
            case Some(d):
                expect(d == "extra info")
            case nil:
                expect(false)

    it "marks as retryable":
        var e0 = TaskError(code: "ERR", message: "msg", retryable: false, details: nil)
        val error = e0.as_retryable()
        expect(error.retryable)

    it "converts to MCP error":
        val error = TaskError(code: "timeout", message: "Operation timed out", retryable: false, details: nil)
        val mcp_error = error.to_mcp_error()
        expect(mcp_error.category == ErrorCategory.Tool)

describe "TaskManager":
    it "creates task manager":
        val manager = TaskManager(tasks: {}, running_count: 0, max_concurrent_tasks: 10, next_id: 0)
        expect(manager.running_count == 0)
        expect(manager.max_concurrent_tasks == 10)

    it "creates task":
        var manager = TaskManager(tasks: {}, running_count: 0, max_concurrent_tasks: 10, next_id: 0)
        val task_id = manager.create_task("test_operation")
        expect(task_id.starts_with("task_"))

        match manager.get_task(task_id):
            case Some(task):
                expect(task.operation == "test_operation")
            case nil:
                expect(false)

    it "creates task with options":
        var manager = TaskManager(tasks: {}, running_count: 0, max_concurrent_tasks: 10, next_id: 0)
        val task_id = manager.create_task_with_options(
            "important_op",
            TaskPriority.Critical,
            Some(30000)
        )

        match manager.get_task(task_id):
            case Some(task):
                expect(task.priority == TaskPriority.Critical)
                match task.timeout_ms:
                    case Some(t):
                        expect(t == 30000)
                    case nil:
                        expect(false)
            case nil:
                expect(false)

    it "starts task":
        var manager = TaskManager(tasks: {}, running_count: 0, max_concurrent_tasks: 10, next_id: 0)
        val task_id = manager.create_task("op")

        var result = manager.start_task(task_id)
        match result:
            case Ok(_):
                expect(true)
            case Err(_):
                expect(false)

        match manager.get_task(task_id):
            case Some(task):
                expect(task.status == TaskStatus.Running)
                expect(task.started_at.is_some())
            case nil:
                expect(false)

        expect(manager.running_count == 1)

    it "updates progress":
        var manager = TaskManager(tasks: {}, running_count: 0, max_concurrent_tasks: 10, next_id: 0)
        val task_id = manager.create_task("op")
        manager.start_task(task_id)

        var result = manager.update_progress(task_id, 50, 100)
        match result:
            case Ok(_):
                expect(true)
            case Err(_):
                expect(false)

        match manager.get_task(task_id):
            case Some(task):
                match task.progress:
                    case Some(p):
                        expect(p.current == 50)
                    case nil:
                        expect(false)
            case nil:
                expect(false)

    it "updates progress with message":
        var manager = TaskManager(tasks: {}, running_count: 0, max_concurrent_tasks: 10, next_id: 0)
        val task_id = manager.create_task("op")
        manager.start_task(task_id)

        var result = manager.update_progress_with_message(task_id, 75, 100, "Almost done")
        match result:
            case Ok(_):
                expect(true)
            case Err(_):
                expect(false)

    it "completes task":
        var manager = TaskManager(tasks: {}, running_count: 0, max_concurrent_tasks: 10, next_id: 0)
        val task_id = manager.create_task("op")
        manager.start_task(task_id)

        var result = manager.complete_task(task_id, "success")
        match result:
            case Ok(_):
                expect(true)
            case Err(_):
                expect(false)

        match manager.get_task(task_id):
            case Some(task):
                expect(task.status == TaskStatus.Completed)
                expect(task.completed_at.is_some())
            case nil:
                expect(false)

        expect(manager.running_count == 0)

    it "fails task":
        var manager = TaskManager(tasks: {}, running_count: 0, max_concurrent_tasks: 10, next_id: 0)
        val task_id = manager.create_task("op")
        manager.start_task(task_id)

        val error = TaskError(code: "ERR", message: "Failed", retryable: false, details: nil)
        var result = manager.fail_task(task_id, error)

        match result:
            case Ok(_):
                expect(true)
            case Err(_):
                expect(false)

        match manager.get_task(task_id):
            case Some(task):
                expect(task.status == TaskStatus.Failed)
                expect(task.error.is_some())
            case nil:
                expect(false)

    it "cancels task":
        var manager = TaskManager(tasks: {}, running_count: 0, max_concurrent_tasks: 10, next_id: 0)
        val task_id = manager.create_task("op")
        manager.start_task(task_id)

        var result = manager.cancel_task(task_id)
        match result:
            case Ok(_):
                expect(true)
            case Err(_):
                expect(false)

        match manager.get_task(task_id):
            case Some(task):
                expect(task.status == TaskStatus.Cancelled)
            case nil:
                expect(false)

    it "lists all tasks":
        var manager = TaskManager(tasks: {}, running_count: 0, max_concurrent_tasks: 10, next_id: 0)
        manager.create_task("op1")
        manager.create_task("op2")
        manager.create_task("op3")

        val tasks = manager.list_tasks()
        expect(tasks.len() == 3)

    it "lists tasks by status":
        var manager = TaskManager(tasks: {}, running_count: 0, max_concurrent_tasks: 10, next_id: 0)
        val id1 = manager.create_task("op1")
        val id2 = manager.create_task("op2")
        manager.create_task("op3")

        manager.start_task(id1)
        manager.start_task(id2)

        val running = manager.list_tasks_by_status(TaskStatus.Running)
        expect(running.len() == 2)

        val pending = manager.list_tasks_by_status(TaskStatus.Pending)
        expect(pending.len() == 1)

    it "respects max concurrent tasks":
        var manager = TaskManager(tasks: {}, running_count: 0, max_concurrent_tasks: 2, next_id: 0)

        val id1 = manager.create_task("op1")
        val id2 = manager.create_task("op2")
        val id3 = manager.create_task("op3")

        manager.start_task(id1)
        manager.start_task(id2)

        var result = manager.start_task(id3)
        match result:
            case Ok(_):
                expect(false)
            case Err(e):
                expect(e.category == ErrorCategory.RateLimit)

    it "cleans up completed tasks":
        var manager = TaskManager(tasks: {}, running_count: 0, max_concurrent_tasks: 10, next_id: 0)
        val id1 = manager.create_task("op1")
        val id2 = manager.create_task("op2")

        manager.start_task(id1)
        manager.complete_task(id1, "done")

        # Wait a bit for cleanup
        manager.cleanup_completed(0)  # Cleanup immediately

        expect(manager.list_tasks().len() == 1)
