# MCP TCP Transport Tests
# Feature: MCP Transport Layer
# Category: MCP, Transport
# Status: Complete
#
# Tests for TCP transport layer operations using MCP helpers
# for JSON-RPC message building and response formatting.

use std.spec
use std.common.text.{NL}
use std.nogc_async_mut.mcp.helpers.{LB, RB, Q, jp, js, jo1, jo2, jo3, extract_json_string, extract_json_value, escape_json, make_result_response, make_error_response, make_notification, make_notification_no_params, log_level_to_int}
use std.nogc_async_mut.mcp.error_handler.{ErrorCategory, McpError}
use std.nogc_async_mut.mcp.error_handler.{mcp_error, input_validator}

describe "TCP Transport - message building":
    it "builds valid JSON-RPC request":
        val request = jo3(jp("jsonrpc", js("2.0")), jp("id", "1"), jp("method", js("test")))
        expect(request.contains("jsonrpc")).to_equal(true)
        expect(request.contains("2.0")).to_equal(true)
        expect(request.contains("test")).to_equal(true)

    it "builds request with params":
        val params = jo1(jp("path", js("/test.spl")))
        val request = jo3(jp("jsonrpc", js("2.0")), jp("id", "1"), jp("method", js("tools/call")))
        expect(request.contains("tools/call")).to_equal(true)

    it "builds notification without id":
        val notif = make_notification("notifications/initialized", LB() + RB())
        expect(notif.contains("notifications/initialized")).to_equal(true)
        expect(notif.contains("jsonrpc")).to_equal(true)

describe "TCP Transport - response formatting":
    it "formats result response":
        val response = make_result_response("1", jo1(jp("status", js("ok"))))
        expect(response.contains("jsonrpc")).to_equal(true)
        expect(response.contains("result")).to_equal(true)
        expect(response.contains("ok")).to_equal(true)

    it "formats error response":
        val response = make_error_response("1", -32600, "Invalid request")
        expect(response.contains("error")).to_equal(true)
        expect(response.contains("-32600")).to_equal(true)

    it "includes id in response":
        val response = make_result_response("42", js("done"))
        expect(response.contains("42")).to_equal(true)

describe "TCP Transport - Content-Length framing":
    it "calculates content length for response":
        val response = make_result_response("1", js("ok"))
        val content_length = response.len()
        expect(content_length > 0).to_equal(true)

    it "builds Content-Length header":
        val response = make_result_response("1", js("ok"))
        val header = "Content-Length: " + response.len().to_string() + "\r{NL}\r{NL}"
        expect(header.starts_with("Content-Length:")).to_equal(true)
        expect(header.ends_with("\r{NL}\r{NL}")).to_equal(true)

describe "TCP Transport - read operations":
    it "extracts method from received message":
        val json = jo2(jp("method", js("initialize")), jp("id", "1"))
        expect(extract_json_string(json, "method")).to_equal("initialize")

    it "extracts id from received message":
        val json = jo2(jp("id", "42"), jp("method", js("test")))
        expect(extract_json_value(json, "id")).to_equal("42")

    it "extracts params from received message":
        val params = jo1(jp("name", js("read_code")))
        val json = jo2(jp("method", js("tools/call")), jp("params", params))
        expect(extract_json_string(json, "method")).to_equal("tools/call")

describe "TCP Transport - write operations":
    it "writes result response":
        val response = make_result_response("1", jo1(jp("data", js("hello"))))
        expect(response.contains("result")).to_equal(true)
        expect(response.contains("hello")).to_equal(true)

    it "writes error response":
        val response = make_error_response("1", -32603, "Internal error")
        expect(response.contains("error")).to_equal(true)
        expect(response.contains("-32603")).to_equal(true)

    it "writes notification":
        val notif = make_notification_no_params("notifications/tools/list_changed")
        expect(notif.contains("tools/list_changed")).to_equal(true)

describe "TCP Transport - connection validation":
    it "validates content length":
        val validator = input_validator()
        val result = validator.validate_content_length(1000)
        expect(result).to_be_nil()

    it "rejects invalid content length":
        val validator = input_validator()
        val result = validator.validate_content_length(-1)
        match result:
            case nil: expect(false).to_equal(true)
            case err: expect(err.message.contains("negative")).to_equal(true)

    it "validates string content":
        val validator = input_validator()
        val result = validator.validate_string("test message")
        expect(result).to_be_nil()

describe "TCP Transport - error handling":
    it "creates connection error":
        val err = mcp_error(ErrorCategory.Network, "Connection refused")
        expect(err.category).to_equal(ErrorCategory.Network)
        expect(err.message).to_equal("Connection refused")

    it "creates timeout error":
        val err = mcp_error(ErrorCategory.Timeout, "Read timeout")
        expect(err.category).to_equal(ErrorCategory.Timeout)

    it "creates parse error for malformed data":
        val err = mcp_error(ErrorCategory.ParseError, "Invalid JSON received")
        expect(err.category).to_equal(ErrorCategory.ParseError)

describe "TCP Transport - logging":
    it "debug level for connection events":
        expect(log_level_to_int("debug")).to_equal(0)

    it "info level for successful connections":
        expect(log_level_to_int("info")).to_equal(1)

    it "error level for connection failures":
        expect(log_level_to_int("error")).to_equal(4)

describe "TCP Transport - escape for wire format":
    it "escapes special characters":
        val escaped = escape_json("data{NL}with{NL}newlines")
        expect(escaped.contains(NL)).to_equal(false)

    it "preserves normal data":
        expect(escape_json("normal")).to_equal("normal")
