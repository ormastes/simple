# MCP Debug Session Manager Tests
# Feature: Debug Session Management
# Category: MCP, Debug
# Status: Complete

use std.spec

# Inline type definitions for testing (avoids heavy core.* dependency)
enum SessionState:
    Created
    Running
    Paused
    Terminated

enum TargetType:
    Interpreter
    Smf
    Native

class SessionBreakpoint:
    id: Int
    file: String
    line: Int
    condition: Option<String>
    enabled: Bool
    hit_count: Int

    static fn at_line(id: Int, file: String, line: Int) -> SessionBreakpoint:
        SessionBreakpoint(
            id: id,
            file: file,
            line: line,
            condition: nil,
            enabled: true,
            hit_count: 0
        )

class DebugSession:
    id: String
    target_type: TargetType
    program_path: String
    state: SessionState
    breakpoints: [SessionBreakpoint]
    args: [String]

    static fn create(id: String, target_type: TargetType, program_path: String) -> DebugSession:
        DebugSession(
            id: id,
            target_type: target_type,
            program_path: program_path,
            state: SessionState.Created,
            breakpoints: [],
            args: []
        )

class SessionManager:
    sessions: Dict<String, DebugSession>
    next_session_id: Int
    next_bp_id: Int

    static fn empty() -> SessionManager:
        SessionManager(
            sessions: {},
            next_session_id: 1,
            next_bp_id: 1
        )

impl SessionManager:
    me create_session(target_type: TargetType, program_path: String) -> String:
        val id = "session_{self.next_session_id}"
        self.next_session_id = self.next_session_id + 1
        val session = DebugSession.create(id, target_type, program_path)
        self.sessions[id] = session
        id

    fn get_session(id: String) -> Option<DebugSession>:
        self.sessions.get(id)

    fn list_sessions() -> [DebugSession]:
        var result: [DebugSession] = []
        for (_, session) in self.sessions.items():
            result.push(session)
        result

    me remove_session(id: String) -> Bool:
        match self.sessions.get(id):
            case Some(_):
                self.sessions.remove(id)
                true
            case nil:
                false

    me add_breakpoint(session_id: String, file: String, line: Int) -> Option<Int>:
        match self.sessions.get(session_id):
            case Some(session):
                val bp_id = self.next_bp_id
                self.next_bp_id = self.next_bp_id + 1
                val bp = SessionBreakpoint.at_line(bp_id, file, line)
                session.breakpoints.push(bp)
                Some(bp_id)
            case nil:
                nil

    fn remove_breakpoint(session_id: String, bp_id: Int) -> Bool:
        match self.sessions.get(session_id):
            case Some(session):
                val initial_len = session.breakpoints.len()
                session.breakpoints = session.breakpoints.filter(\bp: bp.id != bp_id)
                session.breakpoints.len() < initial_len
            case nil:
                false

# ----------- Tests -----------

describe "SessionBreakpoint":
    it "creates breakpoint at line":
        val bp = SessionBreakpoint.at_line(1, "test.spl", 42)
        expect(bp.id).to_equal(1)
        expect(bp.file).to_equal("test.spl")
        expect(bp.line).to_equal(42)
        expect(bp.enabled).to_equal(true)
        expect(bp.hit_count).to_equal(0)

    it "creates breakpoint with no condition":
        val bp = SessionBreakpoint.at_line(5, "main.spl", 10)
        expect(bp.condition).to_be_nil()

describe "DebugSession":
    it "creates session with correct defaults":
        val session = DebugSession.create("s1", TargetType.Interpreter, "test.spl")
        expect(session.id).to_equal("s1")
        expect(session.program_path).to_equal("test.spl")
        expect(session.breakpoints.len()).to_equal(0)
        expect(session.args.len()).to_equal(0)

describe "SessionManager":
    context "session creation":
        it "creates sessions with unique ids":
            var mgr = SessionManager.empty()
            val id1 = mgr.create_session(TargetType.Interpreter, "a.spl")
            val id2 = mgr.create_session(TargetType.Smf, "b.smf")
            expect(id1).to_equal("session_1")
            expect(id2).to_equal("session_2")

        it "stores sessions retrievably":
            var mgr = SessionManager.empty()
            val id = mgr.create_session(TargetType.Native, "prog")
            match mgr.get_session(id):
                case Some(session):
                    expect(session.program_path).to_equal("prog")
                case nil:
                    expect(false).to_equal(true)

    context "session listing":
        it "lists all sessions":
            var mgr = SessionManager.empty()
            mgr.create_session(TargetType.Interpreter, "a.spl")
            mgr.create_session(TargetType.Interpreter, "b.spl")
            val sessions = mgr.list_sessions()
            expect(sessions.len()).to_equal(2)

        it "returns empty list when no sessions":
            var mgr = SessionManager.empty()
            expect(mgr.list_sessions().len()).to_equal(0)

    context "session removal":
        it "removes existing session":
            var mgr = SessionManager.empty()
            val id = mgr.create_session(TargetType.Interpreter, "a.spl")
            expect(mgr.remove_session(id)).to_equal(true)
            expect(mgr.get_session(id)).to_be_nil()

        it "returns false for non-existent session":
            var mgr = SessionManager.empty()
            expect(mgr.remove_session("nonexistent")).to_equal(false)

    context "breakpoint management":
        it "adds breakpoint to session":
            var mgr = SessionManager.empty()
            val sid = mgr.create_session(TargetType.Interpreter, "test.spl")
            match mgr.add_breakpoint(sid, "test.spl", 10):
                case Some(bp_id):
                    expect(bp_id).to_equal(1)
                case nil:
                    expect(false).to_equal(true)

        it "tracks breakpoints in session":
            var mgr = SessionManager.empty()
            val sid = mgr.create_session(TargetType.Interpreter, "test.spl")
            mgr.add_breakpoint(sid, "test.spl", 10)
            mgr.add_breakpoint(sid, "test.spl", 20)
            match mgr.get_session(sid):
                case Some(session):
                    expect(session.breakpoints.len()).to_equal(2)
                case nil:
                    expect(false).to_equal(true)

        it "removes breakpoint by id":
            var mgr = SessionManager.empty()
            val sid = mgr.create_session(TargetType.Interpreter, "test.spl")
            mgr.add_breakpoint(sid, "test.spl", 10)
            expect(mgr.remove_breakpoint(sid, 1)).to_equal(true)
            match mgr.get_session(sid):
                case Some(session):
                    expect(session.breakpoints.len()).to_equal(0)
                case nil:
                    expect(false).to_equal(true)

        it "returns false removing non-existent breakpoint":
            var mgr = SessionManager.empty()
            val sid = mgr.create_session(TargetType.Interpreter, "test.spl")
            expect(mgr.remove_breakpoint(sid, 999)).to_equal(false)

        it "returns nil adding breakpoint to non-existent session":
            var mgr = SessionManager.empty()
            expect(mgr.add_breakpoint("fake_id", "test.spl", 10)).to_be_nil()
