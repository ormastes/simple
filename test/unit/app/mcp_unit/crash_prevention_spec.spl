# MCP Crash Prevention Tests
# Feature: MCP Crash Prevention and Error Isolation
# Category: MCP, Error Handling
# Status: Complete
#
# Tests for crash prevention features to ensure MCP errors don't affect Claude sessions.

use std.spec
use std.nogc_async_mut.mcp.helpers.{LB, RB, jp, js, jo1, jo2, make_result_response, make_error_response, log_level_to_int}
use std.nogc_async_mut.mcp.error_handler.{default_validation_limits, strict_validation_limits, input_validator}

describe "Crash prevention architecture":
    slow_it "validates content length limits exist":
        val limits = default_validation_limits()
        expect(limits.max_content_length > 0).to_equal(true)
        expect(limits.max_string_length > 0).to_equal(true)
        expect(limits.max_content_length > limits.max_string_length).to_equal(true)

    slow_it "has error recovery tracking":
        var consecutive_errors = 0
        var max_errors = 5
        consecutive_errors = consecutive_errors + 1
        consecutive_errors = consecutive_errors + 1
        expect(consecutive_errors).to_equal(2)
        expect(consecutive_errors < max_errors).to_equal(true)

    slow_it "resets error count on success":
        var consecutive_errors = 3
        consecutive_errors = 0
        expect(consecutive_errors).to_equal(0)

    slow_it "stops after max consecutive errors":
        var consecutive_errors = 0
        var max_errors = 5
        for i in 0..5:
            consecutive_errors = consecutive_errors + 1
        val should_stop = consecutive_errors >= max_errors
        expect(should_stop).to_equal(true)

describe "Input validation bounds":
    slow_it "rejects negative content length":
        val validator = input_validator()
        val result = validator.validate_content_length(-100)
        match result:
            case nil: expect(false).to_equal(true)
            case err: expect(err.message.contains("negative")).to_equal(true)

    slow_it "rejects excessive content length":
        val validator = input_validator()
        val result = validator.validate_content_length(2000000)
        match result:
            case nil: expect(false).to_equal(true)
            case err: expect(err.message.contains("exceeds")).to_equal(true)

    slow_it "accepts valid content length":
        val validator = input_validator()
        val result = validator.validate_content_length(1000)
        expect(result).to_be_nil()

describe "URI validation":
    slow_it "validates file URI prefix":
        val validator = input_validator()
        val result = validator.validate_uri("file:///home/user/test.spl")
        expect(result).to_be_nil()

    slow_it "validates symbol URI prefix":
        val validator = input_validator()
        val result = validator.validate_uri("symbol://project/MyClass")
        expect(result).to_be_nil()

    slow_it "rejects invalid URI scheme":
        val validator = input_validator()
        val result = validator.validate_uri("invalid://test")
        match result:
            case nil: expect(false).to_equal(true)
            case err: expect(err.message.contains("scheme")).to_equal(true)

    slow_it "validates URI length limit":
        val uri = "file:///test.spl"
        val max_uri_length = 2048
        val is_valid = uri.len() <= max_uri_length
        expect(is_valid).to_equal(true)

describe "Tool name validation":
    slow_it "validates simple tool name":
        val validator = input_validator()
        val result = validator.validate_tool_name("read_code")
        expect(result).to_be_nil()

    slow_it "validates tool name with slash":
        val validator = input_validator()
        val result = validator.validate_tool_name("tools/list")
        expect(result).to_be_nil()

    slow_it "rejects empty tool name":
        val validator = input_validator()
        val result = validator.validate_tool_name("")
        match result:
            case nil: expect(false).to_equal(true)
            case err: expect(err.message.contains("empty")).to_equal(true)

describe "Error categories":
    slow_it "has transport errors":
        val response = make_error_response("1", -32000, "Transport error")
        expect(response.contains("Transport")).to_equal(true)

    slow_it "has protocol errors":
        val response = make_error_response("1", -32600, "Protocol error")
        expect(response.contains("Protocol")).to_equal(true)

    slow_it "has validation errors":
        val response = make_error_response("1", -32602, "Validation error")
        expect(response.contains("Validation")).to_equal(true)

    slow_it "has resource errors":
        val response = make_error_response("1", -32001, "Resource error")
        expect(response.contains("Resource")).to_equal(true)

    slow_it "has tool errors":
        val response = make_error_response("1", -32002, "Tool error")
        expect(response.contains("Tool")).to_equal(true)

    slow_it "has internal errors":
        val response = make_error_response("1", -32603, "Internal error")
        expect(response.contains("Internal")).to_equal(true)

describe "Log levels":
    slow_it "has trace level":
        expect(log_level_to_int("debug")).to_equal(0)

    slow_it "has info level":
        expect(log_level_to_int("info")).to_equal(1)

    slow_it "has warn level":
        expect(log_level_to_int("warning")).to_equal(3)

    slow_it "has error level":
        expect(log_level_to_int("error")).to_equal(4)

    slow_it "has critical level":
        expect(log_level_to_int("critical")).to_equal(5)

    slow_it "has emergency level":
        expect(log_level_to_int("emergency")).to_equal(7)

    slow_it "orders levels correctly":
        val debug_val = log_level_to_int("debug")
        val info_val = log_level_to_int("info")
        val warning_val = log_level_to_int("warning")
        val error_val = log_level_to_int("error")
        val emergency_val = log_level_to_int("emergency")
        expect(debug_val < info_val).to_equal(true)
        expect(info_val < warning_val).to_equal(true)
        expect(warning_val < error_val).to_equal(true)
        expect(error_val < emergency_val).to_equal(true)

describe "Validation limits":
    slow_it "has default limits":
        val limits = default_validation_limits()
        expect(limits.max_content_length).to_equal(1048576)
        expect(limits.max_string_length).to_equal(65536)
        expect(limits.max_array_length).to_equal(1000)

    slow_it "has strict limits":
        val limits = strict_validation_limits()
        expect(limits.max_content_length).to_equal(524288)
        expect(limits.max_string_length).to_equal(32768)
        expect(limits.max_array_length).to_equal(500)

    slow_it "strict limits are more restrictive":
        val d = default_validation_limits()
        val s = strict_validation_limits()
        expect(s.max_content_length < d.max_content_length).to_equal(true)

describe "Error codes":
    slow_it "has JSON-RPC parse error code":
        val response = make_error_response("1", -32700, "Parse error")
        expect(response.contains("-32700")).to_equal(true)

    slow_it "has JSON-RPC invalid request code":
        val response = make_error_response("1", -32600, "Invalid Request")
        expect(response.contains("-32600")).to_equal(true)

    slow_it "has JSON-RPC method not found code":
        val response = make_error_response("1", -32601, "Method not found")
        expect(response.contains("-32601")).to_equal(true)

    slow_it "has JSON-RPC invalid params code":
        val response = make_error_response("1", -32602, "Invalid params")
        expect(response.contains("-32602")).to_equal(true)

    slow_it "has JSON-RPC internal error code":
        val response = make_error_response("1", -32603, "Internal error")
        expect(response.contains("-32603")).to_equal(true)

    slow_it "has custom timeout code":
        val response = make_error_response("1", -32000, "Timeout")
        expect(response.contains("-32000")).to_equal(true)

    slow_it "has custom rate limit code":
        val response = make_error_response("1", -32001, "Rate limit")
        expect(response.contains("-32001")).to_equal(true)

    slow_it "has custom validation code":
        val response = make_error_response("1", -32002, "Validation")
        expect(response.contains("-32002")).to_equal(true)
