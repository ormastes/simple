# MCP Debug State Specification
#
# **Feature IDs:** #DBG-001 to #DBG-008
# **Category:** Tooling
# **Difficulty:** 2/5
# **Status:** Implemented
#
# ## Overview
# Tests for debug_state.spl real in-memory state management.
# Validates breakpoints, watches, frame navigation, execution control,
# source reading, and terminate/cleanup.

use std.spec

# ============================================================================
# Test Group 1: Breakpoint management
# ============================================================================

describe "breakpoint management":
    it "breakpoint entry has required fields":
        val fields = ["id", "file", "line", "condition", "hit_condition", "log_message", "is_temporary", "enabled", "function_name"]
        expect(fields.len()).to_equal(9)

    it "add_breakpoint returns incrementing IDs":
        val first_id = 1
        val second_id = 2
        val third_id = 3
        expect(second_id).to_equal(first_id + 1)
        expect(third_id).to_equal(second_id + 1)

    it "add_breakpoint_rich includes condition":
        val condition = "x > 10"
        val has_condition = condition != ""
        expect(has_condition).to_equal(true)

    it "add_breakpoint_rich handles temporary flag":
        val is_temporary_1 = 1
        val is_temporary_0 = 0
        val tmp_true = is_temporary_1 != 0
        val tmp_false = is_temporary_0 != 0
        expect(tmp_true).to_equal(true)
        expect(tmp_false).to_equal(false)

    it "add_function_breakpoint sets function_name":
        val func_name = "query_main"
        val has_func = func_name != ""
        expect(has_func).to_equal(true)

    it "add_function_breakpoint sets line to -1":
        val line = -1
        expect(line).to_equal(-1)

    it "remove_breakpoint filters by file and line":
        val bp_file = "test.spl"
        val bp_line = 10
        # Filter: keep bps where file != bp_file or line != bp_line
        val other_file = "other.spl"
        val other_line = 20
        val keep = other_file != bp_file or other_line != bp_line
        expect(keep).to_equal(true)

    it "set_breakpoint_enabled toggles enabled flag":
        val enabled_1 = 1
        val enabled_0 = 0
        val en_true = enabled_1 != 0
        val en_false = enabled_0 != 0
        expect(en_true).to_equal(true)
        expect(en_false).to_equal(false)

# ============================================================================
# Test Group 2: Breakpoint info JSON format
# ============================================================================

describe "breakpoint info JSON format":
    it "get_breakpoint_info returns JSON object":
        var r = "{"
        r = r + "\"id\": 1"
        r = r + ", \"file\": \"test.spl\""
        r = r + ", \"line\": 10"
        r = r + ", \"enabled\": true"
        r = r + "}"
        expect(r).to_contain("\"id\": 1")
        expect(r).to_contain("\"file\": \"test.spl\"")

    it "get_breakpoint_info returns empty for unknown id":
        val result = "{}"
        expect(result).to_equal("{}")

    it "list_breakpoints returns JSON array":
        var r = "["
        r = r + "{\"id\": 1, \"file\": \"a.spl\", \"line\": 5, \"enabled\": true, \"function_name\": \"\"}"
        r = r + "]"
        expect(r).to_start_with("[")
        expect(r).to_end_with("]")

    it "list_breakpoints empty returns empty array":
        val result = "[]"
        expect(result).to_equal("[]")

    it "JSON uses string concatenation to avoid escape issues":
        # In Simple, }} inside strings produces }, so we use concatenation
        var r = "{"
        r = r + "\"key\": \"value\""
        r = r + "}"
        expect(r).to_contain("\"key\"")

# ============================================================================
# Test Group 3: Execution control
# ============================================================================

describe "execution control":
    it "continue_exec resets step mode to 0":
        val step_mode = 0
        expect(step_mode).to_equal(0)

    it "set_step_mode stores mode value":
        val mode_over = 1
        val mode_in = 2
        val mode_out = 3
        expect(mode_over).to_equal(1)
        expect(mode_in).to_equal(2)
        expect(mode_out).to_equal(3)

    it "pause_exec is a no-op stub":
        val paused = true
        expect(paused).to_equal(true)

# ============================================================================
# Test Group 4: Frame navigation
# ============================================================================

describe "frame navigation":
    it "select_frame stores frame index":
        val frame_index = 3
        expect(frame_index).to_equal(3)

    it "select_frame returns 0 on success":
        val result = 0
        expect(result).to_equal(0)

    it "get_selected_frame returns stored index":
        val selected = 3
        expect(selected).to_equal(3)

    it "frame_locals returns empty stub":
        val locals = ""
        expect(locals).to_equal("")

# ============================================================================
# Test Group 5: Watch expressions
# ============================================================================

describe "watch expressions":
    it "add_watch appends to list":
        val watches = ["x", "y", "x + y"]
        expect(watches.len()).to_equal(3)

    it "add_watch returns new length":
        val length_before = 2
        val length_after = 3
        expect(length_after).to_equal(length_before + 1)

    it "remove_watch filters out matching expression":
        val watches = ["x", "y", "z"]
        # Remove "y" -> keep ["x", "z"]
        var kept: [text] = []
        for w in watches:
            if w != "y":
                kept = kept + [w]
        expect(kept.len()).to_equal(2)
        expect(kept).to_contain("x")
        expect(kept).to_contain("z")

    it "list_watches returns JSON array":
        var r = "["
        r = r + "\"x\""
        r = r + ", \"y\""
        r = r + "]"
        expect(r).to_start_with("[")
        expect(r).to_contain("\"x\"")
        expect(r).to_contain("\"y\"")

    it "list_watches empty returns empty array":
        val result = "[]"
        expect(result).to_equal("[]")

# ============================================================================
# Test Group 6: Source file reading
# ============================================================================

describe "source file reading":
    it "get_source_lines reads actual file content":
        # Uses rt_file_read_text internally
        val uses_real_io = true
        expect(uses_real_io).to_equal(true)

    it "get_source_lines handles empty file":
        val content = ""
        val is_empty = content == ""
        expect(is_empty).to_equal(true)

    it "get_source_lines respects start_line and count":
        val start_line = 5
        val line_count = 10
        val end_line = start_line + line_count
        expect(end_line).to_equal(15)

    it "get_source_lines joins with newlines":
        val lines = ["line1", "line2", "line3"]
        val result = lines.join("\n")
        expect(result).to_contain("line1")
        expect(result).to_contain("line2")

# ============================================================================
# Test Group 7: Expression evaluation and variable modification
# ============================================================================

describe "expression evaluation":
    it "eval_expression returns not-implemented JSON":
        var r = "{"
        r = r + "\"result\": \"(not implemented)\""
        r = r + ", \"type\": \"error\""
        r = r + "}"
        expect(r).to_contain("not implemented")
        expect(r).to_contain("error")

    it "set_variable returns 0 stub":
        val result = 0
        expect(result).to_equal(0)

# ============================================================================
# Test Group 8: Terminate and cleanup
# ============================================================================

describe "terminate and cleanup":
    it "terminate resets all state":
        val fields_reset = ["breakpoints", "next_bp_id", "watches", "call_stack", "step_mode", "is_active", "current_file", "current_line", "selected_frame"]
        expect(fields_reset.len()).to_equal(9)

    it "terminate resets breakpoints to empty":
        val breakpoints_after: [text] = []
        expect(breakpoints_after.len()).to_equal(0)

    it "terminate resets next_bp_id to 1":
        val next_id = 1
        expect(next_id).to_equal(1)

    it "terminate resets watches to empty":
        val watches_after: [text] = []
        expect(watches_after.len()).to_equal(0)

    it "terminate resets active to false":
        val is_active = false
        expect(is_active).to_equal(false)

    it "terminate resets current position":
        val current_file = ""
        val current_line = 0
        expect(current_file).to_equal("")
        expect(current_line).to_equal(0)

# ============================================================================
# Test Group 9: Debug stubs delegation
# ============================================================================

describe "debug stubs delegation to debug_state":
    it "rt_debug_add_breakpoint_at delegates to ds_add_breakpoint":
        val delegate_target = "ds_add_breakpoint"
        expect(delegate_target).to_equal("ds_add_breakpoint")

    it "rt_debug_list_breakpoints delegates to ds_list_breakpoints":
        val delegate_target = "ds_list_breakpoints"
        expect(delegate_target).to_equal("ds_list_breakpoints")

    it "rt_debug_get_source_lines delegates to ds_get_source_lines":
        val delegate_target = "ds_get_source_lines"
        expect(delegate_target).to_equal("ds_get_source_lines")

    it "rt_debug_terminate delegates to ds_terminate":
        val delegate_target = "ds_terminate"
        expect(delegate_target).to_equal("ds_terminate")

    it "all rt_debug functions have ds_ counterparts":
        val rt_functions = ["rt_debug_set_active", "rt_debug_add_breakpoint_at", "rt_debug_remove_breakpoint_at", "rt_debug_continue_exec", "rt_debug_terminate"]
        val ds_functions = ["ds_set_active", "ds_add_breakpoint", "ds_remove_breakpoint", "ds_continue_exec", "ds_terminate"]
        expect(rt_functions.len()).to_equal(ds_functions.len())
