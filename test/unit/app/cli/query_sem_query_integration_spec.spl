# Semantic Query Integration Specification
#
# **Feature IDs:** #SQ-011 to #SQ-024
# **Category:** Tooling (Integration)
# **Difficulty:** 3/5
# **Status:** Implemented
#
# ## Overview
# Integration tests exercising the full semantic query pipeline:
# query parsing -> file scanning -> predicate eval -> output.
# Uses real source files in the project tree.

use std.spec

extern fn rt_process_run(cmd: text, args: [text]) -> (text, text, i64)

# ============================================================================
# Helper: run sem-query CLI and capture output
# ============================================================================

fn _run_sem(query: text, files: text) -> text:
    var args: [text] = ["-c", "bin/simple query sem-query '" + query + "' --files " + files + " 2>&1"]
    val (stdout, stderr, code) = rt_process_run("/bin/sh", args)
    stdout

fn _run_sem_json(query: text, files: text) -> text:
    var args: [text] = ["-c", "bin/simple query sem-query '" + query + "' --files " + files + " --format json 2>&1"]
    val (stdout, stderr, code) = rt_process_run("/bin/sh", args)
    stdout

# ============================================================================
# Test Group 1: FIND fn WHERE — basic field matches
# ============================================================================

describe "sem query basic field matches":
    it "finds functions by return type":
        val out = _run_sem("FIND fn WHERE return_type = \"i64\"", "src/app/cli/query_engine.spl")
        expect(out).to_contain("[fn]")
        expect(out).to_contain("Total:")

    it "finds functions by name equals":
        val out = _run_sem("FIND fn WHERE name = \"_parse_file\"", "src/app/cli/query_engine.spl")
        expect(out).to_contain("_parse_file")
        expect(out).to_contain("Total: 1 results")

    it "finds no match for nonexistent name":
        val out = _run_sem("FIND fn WHERE name = \"nonexistent_xyz_abc\"", "src/app/cli/query_engine.spl")
        expect(out).to_contain("No results found")

    it "finds functions by name starts_with":
        val out = _run_sem("FIND fn WHERE name starts_with \"engine_\"", "src/app/cli/query_engine.spl")
        expect(out).to_contain("engine_find_definition")
        expect(out).to_contain("engine_hover")

    it "finds functions by name contains":
        val out = _run_sem("FIND fn WHERE name contains \"parse\"", "src/app/cli/query_engine.spl")
        expect(out).to_contain("_parse_file")
        expect(out).to_contain("_parse_source")

# ============================================================================
# Test Group 2: FIND fn WHERE — numeric predicates
# ============================================================================

describe "sem query numeric predicates":
    it "finds functions with param_count > 2":
        val out = _run_sem("FIND fn WHERE param_count > 2", "src/app/cli/query_engine.spl")
        expect(out).to_contain("[fn]")
        # engine_completions has 3 params, engine_hover has 3
        expect(out).to_contain("Total:")

    it "finds functions with param_count = 0":
        val out = _run_sem("FIND fn WHERE param_count = 0", "src/app/cli/query_schema.spl")
        # _print_ast_schema and _print_sem_schema have 0 params
        expect(out).to_contain("Total:")

    it "finds structs with field_count > 3":
        val out = _run_sem("FIND struct WHERE field_count > 3", "src/app/cli/query_engine.spl")
        # _SymInfo has 8 fields
        expect(out).to_contain("_SymInfo")

    it "finds structs with field_count = 2":
        val out = _run_sem("FIND struct WHERE field_count = 2", "src/app/cli/query_engine.spl")
        # _ImpInfo has 2 fields
        expect(out).to_contain("_ImpInfo")

# ============================================================================
# Test Group 3: FIND fn WHERE — AND conjunction
# ============================================================================

describe "sem query AND conjunction":
    it "combines name and return_type":
        val out = _run_sem("FIND fn WHERE name starts_with \"engine_\" AND return_type = \"i64\"", "src/app/cli/query_engine.spl")
        expect(out).to_contain("engine_")
        expect(out).to_contain("[fn]")

    it "combines name and param_count":
        val out = _run_sem("FIND fn WHERE name starts_with \"_extract\" AND param_count = 1", "src/app/cli/query_engine.spl")
        expect(out).to_contain("_extract")

    it "AND with no results":
        val out = _run_sem("FIND fn WHERE name = \"_parse_file\" AND return_type = \"text\"", "src/app/cli/query_engine.spl")
        # _parse_file returns [_SymInfo] not text
        expect(out).to_contain("No results found")

# ============================================================================
# Test Group 4: FIND fn WHERE — function predicates
# ============================================================================

describe "sem query function predicates":
    it "finds functions that call rt_file_read_text":
        val out = _run_sem("FIND fn WHERE calls(\"rt_file_read_text\")", "src/app/cli/query_engine.spl")
        expect(out).to_contain("_parse_file")
        expect(out).to_contain("[fn]")

    it "finds functions that call _parse_file":
        val out = _run_sem("FIND fn WHERE calls(\"_parse_file\")", "src/app/cli/query_engine.spl")
        expect(out).to_contain("engine_")

    it "calls predicate with no match":
        val out = _run_sem("FIND fn WHERE calls(\"nonexistent_function_xyz\")", "src/app/cli/query_engine.spl")
        expect(out).to_contain("No results found")

# ============================================================================
# Test Group 5: FIND type/struct/import targets
# ============================================================================

describe "sem query target types":
    it "finds structs":
        val out = _run_sem("FIND struct", "src/app/cli/query_engine.spl")
        expect(out).to_contain("_SymInfo")
        expect(out).to_contain("_ImpInfo")

    it "finds imports by module contains":
        val out = _run_sem("FIND import WHERE module contains \"query\"", "src/app/cli/query.spl")
        expect(out).to_contain("[import]")
        expect(out).to_contain("query_engine")

    it "finds all imports":
        val out = _run_sem("FIND import", "src/app/cli/query.spl")
        expect(out).to_contain("[import]")
        expect(out).to_contain("Total:")

    it "FIND type matches classes and structs":
        val out = _run_sem("FIND type", "src/app/cli/query_engine.spl")
        expect(out).to_contain("[struct]")

# ============================================================================
# Test Group 6: Semantic query — json output
# ============================================================================

describe "sem query json output":
    it "outputs json array":
        val out = _run_sem_json("FIND struct", "src/app/cli/query_engine.spl")
        expect(out).to_contain("[")
        expect(out).to_contain("]")

    it "json contains required fields":
        val out = _run_sem_json("FIND struct", "src/app/cli/query_engine.spl")
        expect(out).to_contain("\"file\":")
        expect(out).to_contain("\"line\":")
        expect(out).to_contain("\"kind\":")
        expect(out).to_contain("\"name\":")

# ============================================================================
# Test Group 7: Semantic query — directory scan
# ============================================================================

describe "sem query directory scan":
    it "scans directory for matching functions":
        val out = _run_sem("FIND fn WHERE name = \"engine_query_schema\"", "src/app/cli/")
        expect(out).to_contain("query_schema.spl")
        expect(out).to_contain("engine_query_schema")

    it "scans directory for structs":
        val out = _run_sem("FIND struct WHERE name = \"_AstPattern\"", "src/app/cli/")
        expect(out).to_contain("query_ast_query.spl")

# ============================================================================
# Test Group 8: Semantic query — error handling
# ============================================================================

describe "sem query error handling":
    it "reports error for missing FIND keyword":
        val (stdout, stderr, code) = rt_process_run("/bin/sh", ["-c", "bin/simple query sem-query 'SELECT fn' --files src/app/cli/query.spl 2>&1"])
        expect(stdout).to_contain("Error")

    it "reports error for empty query":
        val (stdout, stderr, code) = rt_process_run("/bin/sh", ["-c", "bin/simple query sem-query '' 2>&1"])
        expect(stdout).to_contain("Error")

    it "handles missing file gracefully":
        val out = _run_sem("FIND fn", "nonexistent_file.spl")
        expect(out).to_contain("No results found")

# ============================================================================
# Test Group 9: Schema discovery
# ============================================================================

describe "query schema discovery":
    it "shows both schemas by default":
        val (stdout, stderr, code) = rt_process_run("/bin/sh", ["-c", "bin/simple query query-schema 2>&1"])
        expect(stdout).to_contain("AST Pattern Query Schema")
        expect(stdout).to_contain("Semantic Query Schema")

    it "shows ast schema only":
        val (stdout, stderr, code) = rt_process_run("/bin/sh", ["-c", "bin/simple query query-schema ast 2>&1"])
        expect(stdout).to_contain("AST Pattern Query Schema")
        expect(stdout).to_contain("Node Kinds")
        expect(stdout).to_contain("Predicates")

    it "shows sem schema only":
        val (stdout, stderr, code) = rt_process_run("/bin/sh", ["-c", "bin/simple query query-schema sem 2>&1"])
        expect(stdout).to_contain("Semantic Query Schema")
        expect(stdout).to_contain("Targets")
        expect(stdout).to_contain("Function Predicates")

    it "ast schema lists all node kinds":
        val (stdout, stderr, code) = rt_process_run("/bin/sh", ["-c", "bin/simple query query-schema ast 2>&1"])
        expect(stdout).to_contain("function")
        expect(stdout).to_contain("class")
        expect(stdout).to_contain("struct")
        expect(stdout).to_contain("enum")
        expect(stdout).to_contain("trait")
        expect(stdout).to_contain("impl")

    it "sem schema lists all operators":
        val (stdout, stderr, code) = rt_process_run("/bin/sh", ["-c", "bin/simple query query-schema sem 2>&1"])
        expect(stdout).to_contain("starts_with")
        expect(stdout).to_contain("ends_with")
        expect(stdout).to_contain("contains")
        expect(stdout).to_contain("calls")
        expect(stdout).to_contain("has_method")
        expect(stdout).to_contain("implements")

    it "sem schema lists numeric fields":
        val (stdout, stderr, code) = rt_process_run("/bin/sh", ["-c", "bin/simple query query-schema sem 2>&1"])
        expect(stdout).to_contain("param_count")
        expect(stdout).to_contain("field_count")
