# AST Pattern Query Integration Specification
#
# **Feature IDs:** #AQ-011 to #AQ-024
# **Category:** Tooling (Integration)
# **Difficulty:** 3/5
# **Status:** Implemented
#
# ## Overview
# Integration tests that exercise the full AST query pipeline:
# file parsing -> pattern matching -> result formatting.
# Uses real source files in the project tree.

use std.spec

extern fn rt_file_read_text(path: text) -> text
extern fn rt_process_run(cmd: text, args: [text]) -> (text, text, i64)

# ============================================================================
# Helper: run ast-query CLI and capture output
# ============================================================================

fn _run_ast_query(query: text, files: text) -> text:
    var args: [text] = ["-c", "bin/simple query ast-query '" + query + "' --files " + files + " 2>&1"]
    val (stdout, stderr, code) = rt_process_run("/bin/sh", args)
    stdout

fn _run_ast_query_json(query: text, files: text) -> text:
    var args: [text] = ["-c", "bin/simple query ast-query '" + query + "' --files " + files + " --format json 2>&1"]
    val (stdout, stderr, code) = rt_process_run("/bin/sh", args)
    stdout

fn _run_sem_query(query: text, files: text) -> text:
    var args: [text] = ["-c", "bin/simple query sem-query '" + query + "' --files " + files + " 2>&1"]
    val (stdout, stderr, code) = rt_process_run("/bin/sh", args)
    stdout

fn _run_schema(kind: text) -> text:
    var cmd = "bin/simple query query-schema"
    if kind != "":
        cmd = cmd + " " + kind
    cmd = cmd + " 2>&1"
    val (stdout, stderr, code) = rt_process_run("/bin/sh", ["-c", cmd])
    stdout

# ============================================================================
# Test Group 1: AST query — find functions in real file
# ============================================================================

describe "ast query find functions":
    it "finds query_main in query.spl":
        val out = _run_ast_query("(function name: \"query_main\")", "src/app/cli/query.spl")
        expect(out).to_contain("query_main")
        expect(out).to_contain("[fn]")
        expect(out).to_contain("Total: 1 matches")

    it "finds multiple functions with return_type i64":
        val out = _run_ast_query("(function return_type: \"i64\")", "src/app/cli/query.spl")
        expect(out).to_contain("[fn]")
        expect(out).to_contain("Total:")

    it "finds no match for nonexistent function":
        val out = _run_ast_query("(function name: \"nonexistent_xyz_function\")", "src/app/cli/query.spl")
        expect(out).to_contain("No matches found")

    it "finds all functions with wildcard":
        val out = _run_ast_query("(function)", "src/app/cli/query_schema.spl")
        expect(out).to_contain("[fn]")
        expect(out).to_contain("engine_query_schema")

# ============================================================================
# Test Group 2: AST query — find types in real file
# ============================================================================

describe "ast query find types":
    it "finds structs in query_engine.spl":
        val out = _run_ast_query("(struct)", "src/app/cli/query_engine.spl")
        expect(out).to_contain("_SymInfo")
        expect(out).to_contain("_ImpInfo")
        expect(out).to_contain("[struct]")

    it "finds struct by name":
        val out = _run_ast_query("(struct name: \"_SymInfo\")", "src/app/cli/query_engine.spl")
        expect(out).to_contain("_SymInfo")
        expect(out).to_contain("Total: 1 matches")

    it "finds imports in query.spl":
        val out = _run_ast_query("(import)", "src/app/cli/query.spl")
        expect(out).to_contain("[import]")
        expect(out).to_contain("app.cli.query_engine")
        expect(out).to_contain("app.cli.query_ast_query")

    it "finds imports with glob pattern":
        val out = _run_ast_query("(import module: \"app.cli.query_*\")", "src/app/cli/query.spl")
        expect(out).to_contain("[import]")
        expect(out).to_contain("query_engine")

# ============================================================================
# Test Group 3: AST query — json format
# ============================================================================

describe "ast query json output":
    it "outputs valid json structure":
        val out = _run_ast_query_json("(struct)", "src/app/cli/query_engine.spl")
        expect(out).to_contain("[")
        expect(out).to_contain("]")
        expect(out).to_contain("\"file\":")
        expect(out).to_contain("\"name\":")

    it "json contains file path":
        val out = _run_ast_query_json("(struct name: \"_SymInfo\")", "src/app/cli/query_engine.spl")
        expect(out).to_contain("query_engine.spl")

    it "json contains line number":
        val out = _run_ast_query_json("(struct name: \"_SymInfo\")", "src/app/cli/query_engine.spl")
        expect(out).to_contain("\"line\":")

    it "json contains kind":
        val out = _run_ast_query_json("(struct)", "src/app/cli/query_engine.spl")
        expect(out).to_contain("\"kind\": \"struct\"")

# ============================================================================
# Test Group 4: AST query — wildcard node kind
# ============================================================================

describe "ast query wildcard":
    it "wildcard finds functions and structs":
        val out = _run_ast_query("(* name: \"_parse_file\")", "src/app/cli/query_engine.spl")
        expect(out).to_contain("_parse_file")

    it "wildcard finds across all kinds":
        val out = _run_ast_query("(*)", "src/app/cli/query_schema.spl")
        expect(out).to_contain("[fn]")
        expect(out).to_contain("Total:")

# ============================================================================
# Test Group 5: AST query — directory scanning
# ============================================================================

describe "ast query directory scan":
    it "scans directory for pattern":
        val out = _run_ast_query("(function name: \"engine_query_schema\")", "src/app/cli/")
        expect(out).to_contain("query_schema.spl")
        expect(out).to_contain("engine_query_schema")

    it "finds struct across multiple files in directory":
        val out = _run_ast_query("(struct name: \"_SymInfo\")", "src/app/cli/")
        expect(out).to_contain("_SymInfo")
        expect(out).to_contain("[struct]")

# ============================================================================
# Test Group 6: AST query — visibility predicate
# ============================================================================

describe "ast query visibility":
    it "finds public functions (no _ prefix)":
        val out = _run_ast_query("(function name: \"engine_query_schema\" visibility: \"pub\")", "src/app/cli/query_schema.spl")
        expect(out).to_contain("engine_query_schema")

    it "finds private functions (_ prefix)":
        val out = _run_ast_query("(function name: \"_print_ast_schema\" visibility: \"private\")", "src/app/cli/query_schema.spl")
        expect(out).to_contain("_print_ast_schema")

# ============================================================================
# Test Group 7: AST query — error handling
# ============================================================================

describe "ast query error handling":
    it "reports error for empty query":
        val (stdout, stderr, code) = rt_process_run("/bin/sh", ["-c", "bin/simple query ast-query '' 2>&1"])
        expect(stdout).to_contain("Error")

    it "reports error for malformed pattern":
        val out = _run_ast_query("not_a_pattern", "src/app/cli/query.spl")
        # Should still attempt to parse
        expect(out.len()).to_be_greater_than(0)

    it "handles missing file gracefully":
        val out = _run_ast_query("(function)", "nonexistent_file.spl")
        expect(out).to_contain("No matches found")
