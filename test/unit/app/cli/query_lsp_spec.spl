"""
# CLI Query LSP Subcommands Specification

**Feature IDs:** #500-510
**Category:** Tooling
**Status:** Implemented

## Overview
Tests for the 10 new `bin/simple query` CLI subcommands.
Validates argument parsing, command construction, and output format.
"""

describe "query CLI subcommand dispatch":
    """
    ## Subcommand Dispatch
    Validates all 10 new subcommands are recognized.
    """
    it "recognizes signature-help":
        val subcmd = "signature-help"
        val valid_subcmds = ["definition", "references", "hover", "completions", "type-at", "signature-help", "rename", "code-actions", "workspace-symbols", "call-hierarchy", "type-hierarchy", "semantic-tokens", "inlay-hints", "selection-range", "document-formatting"]
        expect(valid_subcmds).to_contain(subcmd)

    it "recognizes rename":
        val subcmd = "rename"
        val valid_subcmds = ["signature-help", "rename", "code-actions", "workspace-symbols", "call-hierarchy", "type-hierarchy", "semantic-tokens", "inlay-hints", "selection-range", "document-formatting"]
        expect(valid_subcmds).to_contain(subcmd)

    it "recognizes all 15 subcommands":
        val all_subcmds = ["definition", "references", "hover", "completions", "type-at", "signature-help", "rename", "code-actions", "workspace-symbols", "call-hierarchy", "type-hierarchy", "semantic-tokens", "inlay-hints", "selection-range", "document-formatting"]
        expect(all_subcmds.len()).to_equal(15)

describe "query argument parsing":
    """
    ## Argument Parsing
    Different subcommands have different argument patterns.
    """
    it "standard tools parse file line column":
        val args = ["signature-help", "src/test.spl", "42", "10"]
        expect(args[0]).to_equal("signature-help")
        expect(args[1]).to_equal("src/test.spl")
        expect(args[2]).to_equal("42")
        expect(args[3]).to_equal("10")

    it "workspace-symbols parses query flag":
        val args = ["workspace-symbols", "--query", "parse", "--kind", "fn"]
        expect(args[0]).to_equal("workspace-symbols")
        expect(args[1]).to_equal("--query")
        expect(args[2]).to_equal("parse")

    it "rename parses new-name flag":
        val args = ["rename", "src/test.spl", "10", "--new-name", "better"]
        expect(args[0]).to_equal("rename")
        expect(args[3]).to_equal("--new-name")
        expect(args[4]).to_equal("better")

    it "call-hierarchy parses direction flag":
        val args = ["call-hierarchy", "src/test.spl", "10", "--direction", "incoming"]
        expect(args[3]).to_equal("--direction")
        expect(args[4]).to_equal("incoming")

    it "semantic-tokens parses line range flags":
        val args = ["semantic-tokens", "src/test.spl", "--start-line", "10", "--end-line", "50"]
        expect(args[2]).to_equal("--start-line")
        expect(args[4]).to_equal("--end-line")

    it "document-formatting takes only file":
        val args = ["document-formatting", "src/test.spl"]
        expect(args.len()).to_equal(2)

describe "extract_symbol_at function":
    """
    ## Symbol Extraction
    Tests the helper that extracts symbol name at file:line:col position.
    """
    it "extracts fn name from function declaration":
        val line = "fn query_main() -> i64:"
        # Extract word after "fn " using split on "("
        val after_fn = line.substring(3)
        val name = after_fn.split("(")[0]
        expect(name).to_equal("query_main")

    it "extracts class name from class declaration":
        val line = "class LazySession:"
        # Extract word after "class " using split on ":"
        val after_class = line.substring(6)
        val name = after_class.split(":")[0]
        expect(name).to_equal("LazySession")

    it "extracts struct name":
        val line = "struct Position:"
        # Extract word after "struct " using split on ":"
        val after_struct = line.substring(7)
        val name = after_struct.split(":")[0]
        expect(name).to_equal("Position")

    it "extracts val name":
        val line = "val SERVER_NAME = \"simple-mcp\""
        # Extract word after "val " using split on " "
        val after_val = line.substring(4)
        val name = after_val.split(" ")[0]
        expect(name).to_equal("SERVER_NAME")

describe "query command construction":
    """
    ## Command Construction
    Tests that CLI commands are built correctly for shell execution.
    """
    it "signature-help uses correct subcommand":
        val cmd = "bin/simple query signature-help src/test.spl 10"
        expect(cmd).to_contain("query signature-help")

    it "rename includes new-name flag":
        val cmd = "bin/simple query rename src/test.spl 10 --new-name x"
        expect(cmd).to_contain("--new-name x")

    it "workspace-symbols uses query flag":
        val cmd = "bin/simple query workspace-symbols --query parse"
        expect(cmd).to_contain("--query parse")

    it "semantic-tokens uses range flags":
        val cmd = "bin/simple query semantic-tokens src/test.spl --start-line 1 --end-line 50"
        expect(cmd).to_contain("--start-line 1")
        expect(cmd).to_contain("--end-line 50")

describe "query help text":
    """
    ## Help Output
    Validates updated help text includes all 15 subcommands.
    """
    it "lists all original 5 subcommands":
        val original = ["definition", "references", "hover", "completions", "type-at"]
        expect(original.len()).to_equal(5)

    it "lists all new 10 subcommands":
        val new_cmds = ["signature-help", "rename", "code-actions", "workspace-symbols", "call-hierarchy", "type-hierarchy", "semantic-tokens", "inlay-hints", "selection-range", "document-formatting"]
        expect(new_cmds.len()).to_equal(10)

    it "total subcommands is 15":
        val total = 5 + 10
        expect(total).to_equal(15)

describe "semantic token types":
    """
    ## Semantic Token Classification
    Tests the token type classification for semantic highlighting.
    """
    it "classifies fn as keyword":
        val keywords = ["fn", "class", "struct", "enum", "val", "var", "if", "else", "elif", "for", "while", "match", "case", "return", "import", "use", "trait", "impl", "static", "me", "self", "nil", "true", "false", "extern", "export", "type", "alias", "mixin", "ce", "bind", "receive", "after"]
        expect(keywords).to_contain("fn")

    it "classifies string literals":
        val line = "val name = \"hello\""
        val has_string = line.contains("\"")
        expect(has_string).to_equal(true)

    it "classifies comments":
        val line = "# this is a comment"
        val is_comment = line.starts_with("#")
        expect(is_comment).to_equal(true)

    it "classifies numbers":
        val token = "42"
        # Check if all chars are digits
        var all_digits = true
        for ch in token:
            val is_digit = ch >= "0" and ch <= "9"
            if not is_digit:
                all_digits = false
        expect(all_digits).to_equal(true)

describe "inlay hint type inference":
    """
    ## Inlay Hint Type Inference
    Tests the heuristic type inference for inlay hints.
    """
    it "infers text from string literal":
        val rhs = "\"hello\""
        val is_string = rhs.starts_with("\"")
        val inferred = "text"
        expect(is_string).to_equal(true)
        expect(inferred).to_equal("text")

    it "infers i64 from integer literal":
        val rhs = "42"
        var all_digits = true
        for ch in rhs:
            val is_digit = ch >= "0" and ch <= "9"
            if not is_digit:
                all_digits = false
        expect(all_digits).to_equal(true)

    it "infers bool from true/false":
        val rhs_true = "true"
        val rhs_false = "false"
        val is_bool_true = rhs_true == "true"
        val is_bool_false = rhs_false == "false"
        expect(is_bool_true).to_equal(true)
        expect(is_bool_false).to_equal(true)

    it "infers array from bracket literal":
        val rhs = "[1, 2, 3]"
        val is_array = rhs.starts_with("[")
        expect(is_array).to_equal(true)

    it "detects val without type annotation needs hint":
        val line = "val count = 0"
        val has_colon = line.contains(": ")
        val needs_hint = not has_colon
        expect(needs_hint).to_equal(true)

    it "skips val with type annotation":
        val line = "val count: i64 = 0"
        val has_colon = line.contains(": ")
        expect(has_colon).to_equal(true)
