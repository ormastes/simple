# # Command Dispatch Specification
#
# **Feature IDs:** #TBD
# **Category:** Tooling
# **Status:** In Progress
# **Difficulty:** 3/5
#
# ## Overview
# Commands route to Simple (.spl) apps by default, with Rust fallback
# via environment variable guards or Rust-only flags.
#
# ## Dispatch Pattern
# 1. Check env guard (SIMPLE_<CMD>_RUST) -> use Rust fallback
# 2. Check for Rust-only flags -> use Rust fallback
# 3. Find Simple app at src/app/<tool>/main.spl -> dispatch
# 4. Fall back to Rust implementation
#
# ## Migrated Commands (12 total)
# fmt, lint, sspec-docgen, context, mcp, verify, dashboard,
# coverage, depgraph, lsp, dap, test
#
# ## Path Resolution (3 strategies)
# 1. Relative to CWD (development)
# 2. Relative to executable (../../ from target/debug/)
# 3. SIMPLE_HOME environment variable
#
# ## Edge Cases
# - Empty args after command name
# - Multiple Rust-only flags combined
# - Args with special characters (spaces, quotes, equals)
# - Flag-like file names (e.g., --file.spl)
# - Mixed flag ordering
# - Prefix matching pitfalls (--json-output vs --json)
# - Commands with no Rust fallback
# - Path with spaces and unicode


# ============================================================================
# 1. Simple App File Existence (12 tests)
# ============================================================================

describe "Simple app files exist":
    it "formatter app path":
        val path = "src/app/formatter/main.spl"
        expect path.ends_with(".spl") == true
        expect path.starts_with("src/app/") == true

    it "lint app path":
        val path = "src/app/lint/main.spl"
        expect path.ends_with(".spl") == true

    it "sspec_docgen app path":
        val path = "src/app/sspec_docgen/main.spl"
        expect path.ends_with(".spl") == true

    it "context app path":
        val path = "src/app/context/main.spl"
        expect path.ends_with(".spl") == true

    it "mcp app path":
        val path = "src/app/mcp/main.spl"
        expect path.ends_with(".spl") == true

    it "verify app path":
        val path = "src/app/verify/main.spl"
        expect path.ends_with(".spl") == true

    it "dashboard app path":
        val path = "src/app/dashboard/main.spl"
        expect path.ends_with(".spl") == true

    it "coverage app path":
        val path = "src/app/coverage/main.spl"
        expect path.ends_with(".spl") == true

    it "depgraph app path":
        val path = "src/app/depgraph/main.spl"
        expect path.ends_with(".spl") == true

    it "lsp app path":
        val path = "src/app/lsp/main.spl"
        expect path.ends_with(".spl") == true

    it "dap app path":
        val path = "src/app/dap/main.spl"
        expect path.ends_with(".spl") == true

    it "test_runner_new app path":
        val path = "src/app/test_runner_new/main.spl"
        expect path.ends_with(".spl") == true

# ============================================================================
# 2. Environment Guard Naming Convention (12 tests)
# ============================================================================

describe "environment guard naming convention":
    it "all guards follow SIMPLE_<CMD>_RUST pattern":
        val guards = [
            "SIMPLE_FMT_RUST",
            "SIMPLE_LINT_RUST",
            "SIMPLE_TEST_RUNNER_RUST",
            "SIMPLE_CONTEXT_RUST",
            "SIMPLE_MCP_RUST",
            "SIMPLE_DASHBOARD_RUST",
            "SIMPLE_VERIFY_RUST",
            "SIMPLE_SSPEC_DOCGEN_RUST",
            "SIMPLE_COVERAGE_RUST",
            "SIMPLE_DEPGRAPH_RUST",
            "SIMPLE_LSP_RUST",
            "SIMPLE_DAP_RUST"
        ]
        for guard in guards:
            expect guard.starts_with("SIMPLE_") == true
            expect guard.ends_with("_RUST") == true

    it "guard names are uppercase":
        val guards = ["SIMPLE_FMT_RUST", "SIMPLE_LINT_RUST", "SIMPLE_MCP_RUST"]
        for guard in guards:
            expect guard == guard.upper()

    it "guard count matches migrated command count":
        val guards = [
            "SIMPLE_FMT_RUST", "SIMPLE_LINT_RUST", "SIMPLE_TEST_RUNNER_RUST",
            "SIMPLE_CONTEXT_RUST", "SIMPLE_MCP_RUST", "SIMPLE_DASHBOARD_RUST",
            "SIMPLE_VERIFY_RUST", "SIMPLE_SSPEC_DOCGEN_RUST",
            "SIMPLE_COVERAGE_RUST", "SIMPLE_DEPGRAPH_RUST",
            "SIMPLE_LSP_RUST", "SIMPLE_DAP_RUST"
        ]
        expect guards.len() == 12

    it "no duplicate guard names":
        val guards = [
            "SIMPLE_FMT_RUST", "SIMPLE_LINT_RUST", "SIMPLE_TEST_RUNNER_RUST",
            "SIMPLE_CONTEXT_RUST", "SIMPLE_MCP_RUST", "SIMPLE_DASHBOARD_RUST",
            "SIMPLE_VERIFY_RUST", "SIMPLE_SSPEC_DOCGEN_RUST",
            "SIMPLE_COVERAGE_RUST", "SIMPLE_DEPGRAPH_RUST",
            "SIMPLE_LSP_RUST", "SIMPLE_DAP_RUST"
        ]
        # Check uniqueness by verifying count matches set size
        var unique_count = 0
        for i in 0..guards.len():
            var is_dup = false
            for j in 0..i:
                if guards[i] == guards[j]:
                    is_dup = true
            if not is_dup:
                unique_count = unique_count + 1
        expect unique_count == guards.len()

# ============================================================================
# 3. Rust-Only Flag Detection - Exact Match (18 tests)
# ============================================================================

describe "Rust-only flag detection":
    context "fmt command flags":
        it "detects --json as Rust-only":
            val args = ["fmt", "--json", "file.spl"]
            val needs_rust = args.any(\a: a == "--json")
            expect needs_rust == true

        it "normal args do not need Rust":
            val args = ["fmt", "file.spl"]
            val needs_rust = args.any(\a: a == "--json")
            expect needs_rust == false

        it "EDGE: --json-output is NOT --json (exact match)":
            val args = ["fmt", "--json-output", "file.spl"]
            val needs_rust = args.any(\a: a == "--json")
            expect needs_rust == false

        it "EDGE: --JSON uppercase is NOT --json (case sensitive)":
            val args = ["fmt", "--JSON", "file.spl"]
            val needs_rust = args.any(\a: a == "--json")
            expect needs_rust == false

    context "lint command flags":
        it "detects --json as Rust-only":
            val args = ["lint", "--json", "file.spl"]
            val needs_rust = args.any(\a: a == "--json" or a == "--fix")
            expect needs_rust == true

        it "detects --fix as Rust-only":
            val args = ["lint", "--fix", "file.spl"]
            val needs_rust = args.any(\a: a == "--json" or a == "--fix")
            expect needs_rust == true

        it "both --json and --fix triggers Rust":
            val args = ["lint", "--json", "--fix", "file.spl"]
            val needs_rust = args.any(\a: a == "--json" or a == "--fix")
            expect needs_rust == true

        it "normal args do not need Rust":
            val args = ["lint", "file.spl"]
            val needs_rust = args.any(\a: a == "--json" or a == "--fix")
            expect needs_rust == false

        it "EDGE: --fixed is NOT --fix (exact match)":
            val args = ["lint", "--fixed", "file.spl"]
            val needs_rust = args.any(\a: a == "--json" or a == "--fix")
            expect needs_rust == false

    context "test command flags":
        it "detects --watch as Rust-only":
            val args = ["test", "--watch"]
            val needs_rust = args.any(\a: a == "--watch" or a == "--parallel")
            expect needs_rust == true

        it "detects --parallel as Rust-only":
            val args = ["test", "--parallel"]
            val needs_rust = args.any(\a: a == "--watch" or a == "--parallel")
            expect needs_rust == true

        it "detects -p as Rust-only":
            val args = ["test", "-p"]
            val needs_rust = args.any(\a: a == "-p")
            expect needs_rust == true

        it "detects --json as Rust-only":
            val args = ["test", "--json"]
            val needs_rust = args.any(\a: a == "--json")
            expect needs_rust == true

        it "detects --rust-tests as Rust-only":
            val args = ["test", "--rust-tests"]
            val needs_rust = args.any(\a: a == "--rust-tests")
            expect needs_rust == true

        it "detects --list-runs as Rust-only":
            val args = ["test", "--list-runs"]
            val needs_rust = args.any(\a: a == "--list-runs")
            expect needs_rust == true

        it "detects --full-parallel as Rust-only":
            val args = ["test", "--full-parallel"]
            val needs_rust = args.any(\a: a == "--full-parallel")
            expect needs_rust == true

        it "detects --rust-ignored as Rust-only":
            val args = ["test", "--rust-ignored"]
            val needs_rust = args.any(\a: a == "--rust-ignored")
            expect needs_rust == true

        it "normal test args do not need Rust":
            val args = ["test", "my_spec.spl"]
            val needs_rust = args.any(\a: a == "--watch" or a == "--parallel" or a == "--json")
            expect needs_rust == false

    context "test command prefix flags":
        it "detects --doctest prefix":
            val args = ["test", "--doctest-only"]
            val needs_rust = args.any(\a: a.starts_with("--doctest"))
            expect needs_rust == true

        it "detects --diagram prefix":
            val args = ["test", "--diagram-type=sequence"]
            val needs_rust = args.any(\a: a.starts_with("--diagram"))
            expect needs_rust == true

        it "detects --seq- prefix":
            val args = ["test", "--seq-filter=foo"]
            val needs_rust = args.any(\a: a.starts_with("--seq-"))
            expect needs_rust == true

        it "detects --prune-runs prefix":
            val args = ["test", "--prune-runs=50"]
            val needs_rust = args.any(\a: a.starts_with("--prune-runs"))
            expect needs_rust == true

        it "EDGE: --watching is NOT --watch (exact match)":
            val args = ["test", "--watching"]
            val needs_rust = args.any(\a: a == "--watch")
            expect needs_rust == false

# ============================================================================
# 4. Dispatch Argument Construction (10 tests)
# ============================================================================

describe "dispatch argument construction":
    it "prepends simple_old and app path using slice":
        val app_path = "src/app/formatter/main.spl"
        val args = ["fmt", "file.spl", "--check"]
        val user_args = args[1:]
        var full_args = ["simple_old", app_path]
        for a in user_args:
            full_args = full_args + [a]
        expect full_args[0] == "simple_old"
        expect full_args[1] == "src/app/formatter/main.spl"
        expect full_args[2] == "file.spl"
        expect full_args[3] == "--check"
        expect full_args.len() == 4

    it "passes all user args preserving order":
        val app_path = "src/app/lint/main.spl"
        val args = ["lint", "src/", "--verbose", "--warn-only"]
        val user_args = args[1:]
        var full_args = ["simple_old", app_path]
        for a in user_args:
            full_args = full_args + [a]
        expect full_args.len() == 5
        expect full_args[2] == "src/"
        expect full_args[3] == "--verbose"
        expect full_args[4] == "--warn-only"

    it "handles no extra args (command only)":
        val args = ["dashboard"]
        val user_args = args[1:]
        expect user_args.len() == 0
        var full_args = ["simple_old", "src/app/dashboard/main.spl"]
        expect full_args.len() == 2

    it "EDGE: single arg after command":
        val args = ["coverage", "scan"]
        val user_args = args[1:]
        expect user_args.len() == 1
        expect user_args[0] == "scan"

    it "EDGE: many args preserved":
        val args = ["test", "a", "b", "c", "d", "e", "f", "g"]
        val user_args = args[1:]
        expect user_args.len() == 7
        expect user_args[0] == "a"
        expect user_args[6] == "g"

    it "EDGE: args with equals signs":
        val args = ["test", "--tag=integration", "--timeout=30"]
        val user_args = args[1:]
        expect user_args[0] == "--tag=integration"
        expect user_args[1] == "--timeout=30"

    it "EDGE: args with spaces in values":
        val args = ["context", "--format=json", "my file.spl"]
        val user_args = args[1:]
        expect user_args[0] == "--format=json"
        expect user_args[1] == "my file.spl"

    it "EDGE: flag-like filenames":
        val args = ["lint", "--verbose.spl"]
        val user_args = args[1:]
        expect user_args[0] == "--verbose.spl"

    it "EDGE: empty string arg":
        val args = ["test", "", "file.spl"]
        val user_args = args[1:]
        expect user_args.len() == 2
        expect user_args[0] == ""

    it "EDGE: double dash separator":
        val args = ["test", "--", "file.spl"]
        val user_args = args[1:]
        expect user_args[0] == "--"
        expect user_args[1] == "file.spl"

# ============================================================================
# 5. App Path Resolution (8 tests)
# ============================================================================

describe "app path resolution":
    it "all migrated apps follow src/app/<name>/main.spl pattern":
        val apps = ["formatter", "lint", "coverage", "dashboard", "verify",
                    "context", "mcp", "sspec_docgen", "depgraph", "lsp", "dap"]
        for app in apps:
            val path = "src/app/{app}/main.spl"
            expect path.starts_with("src/app/") == true
            expect path.ends_with("/main.spl") == true

    it "test runner uses test_runner_new directory":
        val path = "src/app/test_runner_new/main.spl"
        expect path.contains("test_runner_new") == true
        expect path.ends_with("/main.spl") == true

    it "EDGE: path does not contain double slashes":
        val apps = ["formatter", "lint", "dashboard"]
        for app in apps:
            val path = "src/app/{app}/main.spl"
            expect path.contains("//") == false

    it "EDGE: path segments are valid identifiers":
        val apps = ["formatter", "lint", "coverage", "dashboard", "verify",
                    "context", "mcp", "sspec_docgen", "depgraph", "lsp", "dap"]
        for app in apps:
            expect app.len() > 0
            # No spaces in directory names
            expect app.contains(" ") == false

    it "EDGE: total migrated app count is 12":
        val apps = ["formatter", "lint", "coverage", "dashboard", "verify",
                    "context", "mcp", "sspec_docgen", "depgraph", "lsp", "dap",
                    "test_runner_new"]
        expect apps.len() == 12

    it "EDGE: each app has unique directory name":
        val apps = ["formatter", "lint", "coverage", "dashboard", "verify",
                    "context", "mcp", "sspec_docgen", "depgraph", "lsp", "dap",
                    "test_runner_new"]
        var unique = 0
        for i in 0..apps.len():
            var dup = false
            for j in 0..i:
                if apps[i] == apps[j]:
                    dup = true
            if not dup:
                unique = unique + 1
        expect unique == apps.len()

    it "resolve: CWD path is first priority":
        # Simulates resolve_app_path logic
        val cwd_path = "src/app/formatter/main.spl"
        val exe_path = "/usr/local/bin/../src/app/formatter/main.spl"
        # CWD is checked first
        expect cwd_path.starts_with("src/") == true

    it "resolve: exe-relative goes up two dirs from target/debug":
        val exe_dir = "/project/target/debug"
        # Parent of parent = /project
        # /project + src/app/... = correct path
        val parts = exe_dir.split("/")
        expect parts.len() > 2

# ============================================================================
# 6. Command Categories (6 tests)
# ============================================================================

describe "non-migrated commands":
    it "compile stays in Rust (bootstrapping dependency)":
        val non_migrated = ["compile", "check", "watch", "query", "info",
                            "gen-lean", "diagram"]
        expect non_migrated.contains("compile") == true

    it "package management stays in Rust (deep integration)":
        val pkg_cmds = ["init", "add", "remove", "install", "update", "list", "tree", "cache"]
        expect pkg_cmds.len() == 8

    it "EDGE: non-migrated and migrated sets do not overlap":
        val non_migrated = ["compile", "check", "watch", "query", "info",
                            "gen-lean", "diagram", "init", "add", "remove",
                            "install", "update", "list", "tree", "cache"]
        val migrated = ["fmt", "lint", "test", "context", "mcp", "verify",
                        "dashboard", "sspec-docgen", "coverage", "depgraph", "lsp", "dap"]
        for m in migrated:
            expect non_migrated.contains(m) == false

    it "EDGE: brief uses inline codegen, not dispatch":
        val inline_commands = ["brief"]
        val dispatch_commands = ["fmt", "lint", "test", "dashboard"]
        for cmd in inline_commands:
            expect dispatch_commands.contains(cmd) == false

describe "pure Simple commands (no Rust fallback)":
    it "coverage has no Rust fallback":
        val pure_simple = ["coverage", "depgraph", "lsp", "dap"]
        expect pure_simple.contains("coverage") == true

    it "all pure Simple commands listed":
        val pure_simple = ["coverage", "depgraph", "lsp", "dap"]
        expect pure_simple.len() == 4

# ============================================================================
# 7. Hybrid Commands (with Rust fallback) (8 tests)
# ============================================================================

describe "hybrid commands (Simple default, Rust fallback)":
    it "fmt has Rust fallback":
        val hybrid = ["fmt", "lint", "test", "sspec-docgen", "context",
                      "mcp", "verify", "dashboard"]
        expect hybrid.contains("fmt") == true

    it "hybrid command count is 8":
        val hybrid = ["fmt", "lint", "test", "sspec-docgen", "context",
                      "mcp", "verify", "dashboard"]
        expect hybrid.len() == 8

    it "hybrid + pure = total migrated":
        val hybrid = ["fmt", "lint", "test", "sspec-docgen", "context",
                      "mcp", "verify", "dashboard"]
        val pure = ["coverage", "depgraph", "lsp", "dap"]
        expect hybrid.len() + pure.len() == 12

    it "EDGE: each hybrid command has a matching guard":
        # Command -> guard mapping
        val commands = ["fmt", "lint", "context", "mcp", "verify", "dashboard"]
        val guards = ["SIMPLE_FMT_RUST", "SIMPLE_LINT_RUST", "SIMPLE_CONTEXT_RUST",
                      "SIMPLE_MCP_RUST", "SIMPLE_VERIFY_RUST", "SIMPLE_DASHBOARD_RUST"]
        expect commands.len() == guards.len()

# ============================================================================
# 8. Flag Detection Edge Cases (12 tests)
# ============================================================================

describe "flag detection edge cases":
    it "EDGE: flag at end of args":
        val args = ["test", "file.spl", "--json"]
        val needs_rust = args.any(\a: a == "--json")
        expect needs_rust == true

    it "EDGE: flag at beginning (right after command)":
        val args = ["test", "--json", "file.spl"]
        val needs_rust = args.any(\a: a == "--json")
        expect needs_rust == true

    it "EDGE: flag in middle of args":
        val args = ["test", "a.spl", "--json", "b.spl"]
        val needs_rust = args.any(\a: a == "--json")
        expect needs_rust == true

    it "EDGE: only flag, no files":
        val args = ["lint", "--json"]
        val needs_rust = args.any(\a: a == "--json" or a == "--fix")
        expect needs_rust == true

    it "EDGE: multiple non-rust flags":
        val args = ["test", "--verbose", "--list", "--show-tags"]
        val needs_rust = args.any(\a: a == "--json" or a == "--watch" or a == "--parallel")
        expect needs_rust == false

    it "EDGE: args[1:] skips command name correctly":
        val args = ["test", "--verbose", "file.spl"]
        val check_args = args[1:]
        expect check_args.len() == 2
        expect check_args[0] == "--verbose"
        # Command name itself should never be checked for flags
        expect check_args.contains("test") == false

    it "EDGE: single letter flag -p matches exactly":
        val args = ["test", "-p"]
        val needs_rust = args.any(\a: a == "-p")
        expect needs_rust == true

    it "EDGE: -p is not prefix of -pattern":
        val args = ["test", "-pattern"]
        val needs_rust = args.any(\a: a == "-p")
        expect needs_rust == false

    it "EDGE: --capture-screenshots exact match":
        val args = ["test", "--capture-screenshots"]
        val needs_rust = args.any(\a: a == "--capture-screenshots")
        expect needs_rust == true

    it "EDGE: --cleanup-runs exact match":
        val args = ["test", "--cleanup-runs"]
        val needs_rust = args.any(\a: a == "--cleanup-runs")
        expect needs_rust == true

    it "EDGE: combined rust-only and normal flags":
        val args = ["test", "--verbose", "--watch", "--list"]
        val needs_rust = args.any(\a: a == "--watch")
        expect needs_rust == true

    it "EDGE: no args at all (just command)":
        val args = ["test"]
        val check_args = args[1:]
        val needs_rust = check_args.any(\a: a == "--json")
        expect needs_rust == false

# ============================================================================
# 9. Argument Slicing Edge Cases (8 tests)
# ============================================================================

describe "argument slicing edge cases":
    it "slice of single-element list is empty":
        val args = ["cmd"]
        val rest = args[1:]
        expect rest.len() == 0

    it "slice preserves all elements":
        val args = ["cmd", "a", "b", "c"]
        val rest = args[1:]
        expect rest.len() == 3
        expect rest[0] == "a"
        expect rest[1] == "b"
        expect rest[2] == "c"

    it "slice of two-element list gives one element":
        val args = ["cmd", "arg"]
        val rest = args[1:]
        expect rest.len() == 1
        expect rest[0] == "arg"

    it "EDGE: nested slicing":
        val args = ["cmd", "a", "b", "c", "d"]
        val rest = args[1:]
        val rest2 = rest[1:]
        expect rest2.len() == 3
        expect rest2[0] == "b"

    it "EDGE: slice with negative index":
        val args = ["a", "b", "c", "d"]
        val last = args[-1]
        expect last == "d"

    it "EDGE: full slice is identity":
        val args = ["a", "b", "c"]
        val full = args[0:]
        expect full.len() == 3

    it "EDGE: slice range":
        val args = ["cmd", "a", "b", "c", "d"]
        val mid = args[1:3]
        expect mid.len() == 2
        expect mid[0] == "a"
        expect mid[1] == "b"

    it "EDGE: step slice":
        val args = ["a", "b", "c", "d", "e", "f"]
        val evens = args[::2]
        expect evens.len() == 3
        expect evens[0] == "a"
        expect evens[1] == "c"
        expect evens[2] == "e"

# ============================================================================
# 10. Command-to-App Mapping (6 tests)
# ============================================================================

describe "command to app directory mapping":
    it "fmt maps to formatter (not fmt)":
        val cmd = "fmt"
        val app_dir = "formatter"
        expect cmd != app_dir

    it "sspec-docgen maps to sspec_docgen (hyphen to underscore)":
        val cmd = "sspec-docgen"
        val app_dir = "sspec_docgen"
        expect cmd.contains("-") == true
        expect app_dir.contains("-") == false

    it "test maps to test_runner_new (not test)":
        val cmd = "test"
        val app_dir = "test_runner_new"
        expect cmd != app_dir

    it "direct name commands: lint, coverage, verify, dashboard, context, mcp, depgraph, lsp, dap":
        val direct = ["lint", "coverage", "verify", "dashboard", "context",
                      "mcp", "depgraph", "lsp", "dap"]
        for cmd in direct:
            val path = "src/app/{cmd}/main.spl"
            expect path.contains(cmd) == true

    it "EDGE: command name is not always the directory name":
        # These commands have different directory names
        val mapped = [["fmt", "formatter"], ["test", "test_runner_new"], ["sspec-docgen", "sspec_docgen"]]
        for pair in mapped:
            expect pair[0] != pair[1]

    it "EDGE: all app directories are snake_case or single word":
        val dirs = ["formatter", "lint", "coverage", "dashboard", "verify",
                    "context", "mcp", "sspec_docgen", "depgraph", "lsp", "dap",
                    "test_runner_new"]
        for dir in dirs:
            expect dir.contains("-") == false
            expect dir.contains(" ") == false

# ============================================================================
# 11. Dispatch Decision Logic (6 tests)
# ============================================================================

describe "dispatch decision logic":
    it "env guard takes highest priority":
        # Priority: env guard > rust-only flags > simple app > rust fallback
        val env_set = true
        val has_rust_flag = true
        val app_exists = true
        # When env is set, always use Rust regardless of other conditions
        val use_rust = env_set
        expect use_rust == true

    it "rust-only flags take second priority":
        val env_set = false
        val has_rust_flag = true
        val app_exists = true
        val use_rust = env_set or has_rust_flag
        expect use_rust == true

    it "simple app used when no env guard and no rust flags":
        val env_set = false
        val has_rust_flag = false
        val app_exists = true
        val use_simple = not env_set and not has_rust_flag and app_exists
        expect use_simple == true

    it "rust fallback used when app not found":
        val env_set = false
        val has_rust_flag = false
        val app_exists = false
        val use_simple = not env_set and not has_rust_flag and app_exists
        expect use_simple == false

    it "EDGE: env guard overrides even with no rust flags":
        val env_set = true
        val has_rust_flag = false
        val use_rust = env_set
        expect use_rust == true

    it "EDGE: app not found with no fallback errors":
        val app_exists = false
        val has_rust_fallback = false
        val error = not app_exists and not has_rust_fallback
        expect error == true

# ============================================================================
# 12. Integration: Full Dispatch Simulation (6 tests)
# ============================================================================

describe "full dispatch simulation":
    it "simulate fmt dispatch: normal args -> Simple":
        val args = ["fmt", "file.spl", "--check"]
        val env_set = false
        val needs_rust = args.any(\a: a == "--json")
        val app_exists = true
        val dispatch = dispatch_decision(env_set, needs_rust, app_exists)
        expect dispatch == "simple"

    it "simulate fmt dispatch: --json -> Rust":
        val args = ["fmt", "--json", "file.spl"]
        val env_set = false
        val needs_rust = args.any(\a: a == "--json")
        val dispatch = dispatch_decision(env_set, needs_rust, true)
        expect dispatch == "rust"

    it "simulate fmt dispatch: env guard -> Rust":
        val args = ["fmt", "file.spl"]
        val env_set = true
        val needs_rust = args.any(\a: a == "--json")
        val dispatch = dispatch_decision(env_set, needs_rust, true)
        expect dispatch == "rust"

    it "simulate coverage dispatch: no fallback, app exists -> Simple":
        val dispatch = if true: "simple" else: "error"
        expect dispatch == "simple"

    it "simulate coverage dispatch: no fallback, app missing -> error":
        val dispatch = if false: "simple" else: "error"
        expect dispatch == "error"

    it "simulate test dispatch: --watch -> Rust, normal -> Simple":
        val args_watch = ["test", "--watch"]
        val args_normal = ["test", "my_spec.spl"]
        val watch_rust = args_watch.any(\a: a == "--watch" or a == "--parallel" or a == "--json")
        val normal_rust = args_normal.any(\a: a == "--watch" or a == "--parallel" or a == "--json")
        expect watch_rust == true
        expect normal_rust == false

# ============================================================================
# Helper Functions
# ============================================================================

fn dispatch_decision(env_set: bool, needs_rust: bool, app_exists: bool) -> text:
    if env_set:
        return "rust"
    if needs_rust:
        return "rust"
    if app_exists:
        return "simple"
    return "rust"
