# @pending
"""
# Brief View Specification

**Feature IDs:** LLM-Friendly Brief View
**Category:** Tooling
**Difficulty:** 2/5
**Status:** Implemented

## Overview

Unit tests for the brief view generator module. Validates extraction of code structure,
tree formatting, JSON export, and symbol expansion for LLM-friendly code overview.

## Key Features

- Extract function, class, struct, enum, trait, const signatures from source
- Tree-like output with box-drawing characters
- JSON export for tooling integration
- Symbol expansion for drilling into specific items
- Token estimation for LLM context planning

## Related Specifications

- [Context Pack Specification](context_pack_spec.spl)
- [LLM Features Architecture](../../../docs/design/llm_features.md)
"""

use tooling.brief_view.{BriefItem, BriefView, extract_brief, format_tree_item, find_char, extract_signature}


# ============================================================================
# BriefItem: Core Item Representation
# ============================================================================

describe "BriefItem":
    """
    ## BriefItem Creation and Formatting

    Validates creation of brief items and their signature formatting.
    """

    describe "creation":
        """
        ### Basic Item Creation

        Tests creating items with different kinds and attributes.
        """

        it "creates a simple function item":
            val item = BriefItem.new("fn", "main", "()", 1)
            expect item.kind == "fn"
            expect item.name == "main"
            expect item.signature == "()"
            expect item.line == 1
            expect item.collapsed == true

        it "creates a public function item":
            val item = BriefItem.public("fn", "process", "(data: List<i64>) -> i64", 10)
            expect item.kind == "fn"
            expect item.name == "process"
            expect item.visibility == "pub"

        it "creates a class item":
            val item = BriefItem.new("class", "UserService", "", 5)
            expect item.kind == "class"
            expect item.name == "UserService"

    describe "effects":
        """
        ### Effect Annotations

        Tests adding effect annotations to items.
        """

        it "adds single effect":
            var item = BriefItem.new("fn", "read_file", "(path: text) -> text", 1)
            item.add_effect("@io")
            expect item.effects.len() == 1
            expect item.effects[0] == "@io"

        it "adds multiple effects":
            var item = BriefItem.new("fn", "async_io", "()", 1)
            item.add_effect("@async")
            item.add_effect("@io")
            expect item.effects.len() == 2

    describe "children":
        """
        ### Nested Items

        Tests adding child items (methods, fields) to containers.
        """

        it "adds child methods to class":
            var class_item = BriefItem.new("class", "Service", "", 1)
            val method = BriefItem.new("fn", "run", "()", 3)
            class_item.add_child(method)
            expect class_item.children.len() == 1
            expect class_item.children[0].name == "run"

    describe "format_signature":
        """
        ### Signature Formatting

        Tests formatting items as one-line signatures.
        """

        it "formats simple function":
            val item = BriefItem.new("fn", "add", "(a: i64, b: i64) -> i64", 1)
            val sig = item.format_signature()
            expect sig == "fn add(a: i64, b: i64) -> i64"

        it "formats public function":
            var item = BriefItem.new("fn", "process", "()", 1)
            item.visibility = "pub"
            val sig = item.format_signature()
            expect sig == "pub fn process()"

        it "formats function with effects":
            var item = BriefItem.new("fn", "write", "(data: text)", 1)
            item.add_effect("@io")
            val sig = item.format_signature()
            expect sig.contains("@io")


# ============================================================================
# BriefView: File View Representation
# ============================================================================

describe "BriefView":
    """
    ## BriefView Creation and Export

    Validates creation of file views and export to tree/JSON formats.
    """

    describe "creation":
        """
        ### Creating Empty Views

        Tests basic view initialization.
        """

        it "creates empty view with file path":
            val view = BriefView.new("src/main.spl")
            expect view.file_path == "src/main.spl"
            expect view.items.len() == 0
            expect view.total_lines == 0

        it "adds items to view":
            var view = BriefView.new("test.spl")
            val item = BriefItem.new("fn", "test", "()", 1)
            view.add_item(item)
            expect view.items.len() == 1

    describe "to_tree export":
        """
        ### Tree Format Export

        Validates tree-like output with box-drawing characters.
        """

        it "generates tree with file header":
            var view = BriefView.new("src/service.spl")
            val tree = view.to_tree()
            expect tree.contains("src/service.spl")

        it "generates tree with single item":
            var view = BriefView.new("test.spl")
            val item = BriefItem.new("fn", "main", "()", 1)
            view.add_item(item)
            val tree = view.to_tree()
            expect tree.contains("fn main()")

        it "generates tree with multiple items":
            var view = BriefView.new("test.spl")
            view.add_item(BriefItem.new("fn", "one", "()", 1))
            view.add_item(BriefItem.new("fn", "two", "()", 5))
            val tree = view.to_tree()
            expect tree.contains("one")
            expect tree.contains("two")

    describe "to_json export":
        """
        ### JSON Format Export

        Validates JSON output for tooling integration.
        """

        it "generates valid JSON":
            var view = BriefView.new("test.spl")
            val json = view.to_json()
            expect json.contains("\"file_path\"")
            expect json.contains("\"items\"")

        it "includes all fields":
            var view = BriefView.new("test.spl")
            view.total_lines = 100
            view.add_item(BriefItem.new("fn", "test", "()", 1))
            val json = view.to_json()
            expect json.contains("\"total_lines\"")
            expect json.contains("\"token_estimate\"")

    describe "expand symbol":
        """
        ### Symbol Expansion

        Tests expanding specific symbols for detailed view.
        """

        it "expands matching symbol":
            var view = BriefView.new("test.spl")
            view.add_item(BriefItem.new("fn", "target", "()", 1))
            view.add_item(BriefItem.new("fn", "other", "()", 5))
            val expanded = view.expand("target")
            expect expanded.items.len() == 1
            expect expanded.items[0].name == "target"

        it "returns empty for non-matching":
            # This test works because we test on an empty view
            var view = BriefView.new("test.spl")
            val expanded = view.expand("nonexistent")
            expect expanded.items.len() == 0


# ============================================================================
# extract_brief: Source Code Parsing
# ============================================================================

describe "extract_brief":
    """
    ## Source Code Extraction

    Validates extraction of code structure from source text.
    """

    describe "function extraction":
        """
        ### Function Definitions

        Tests extracting function signatures from source.
        """

        it "extracts simple function":
            val source = "fn main():\n    print 42"
            val view = extract_brief(source)
            expect view.items.len() == 1
            expect view.items[0].kind == "fn"
            expect view.items[0].name == "main"

        it "extracts public function":
            val source = "pub fn process(data: text) -> i64:\n    42"
            val view = extract_brief(source)
            expect view.items.len() == 1
            expect view.items[0].visibility == "pub"

        it "extracts function with return type":
            val source = "fn add(a: i64, b: i64) -> i64:\n    a + b"
            val view = extract_brief(source)
            expect view.items[0].signature.contains("->")

        it "extracts async function":
            val source = "async fn fetch(url: text) -> text:\n    pass"
            val view = extract_brief(source)
            expect view.items[0].effects.contains("@async")

    describe "class extraction":
        """
        ### Class Definitions

        Tests extracting class signatures from source.
        """

        it "extracts class":
            val source = "class Service:\n    val name: text"
            val view = extract_brief(source)
            expect view.items.len() == 1
            expect view.items[0].kind == "class"
            expect view.items[0].name == "Service"

        it "extracts public class":
            val source = "pub class UserService:\n    pass"
            val view = extract_brief(source)
            expect view.items[0].visibility == "pub"

    describe "struct extraction":
        """
        ### Struct Definitions

        Tests extracting struct signatures from source.
        """

        it "extracts struct":
            val source = "struct Point:\n    x: i64\n    y: i64"
            val view = extract_brief(source)
            expect view.items.len() == 1
            expect view.items[0].kind == "struct"
            expect view.items[0].name == "Point"

    describe "enum extraction":
        """
        ### Enum Definitions

        Tests extracting enum signatures from source.
        """

        it "extracts enum":
            val source = "enum Color:\n    Red\n    Green\n    Blue"
            val view = extract_brief(source)
            expect view.items.len() == 1
            expect view.items[0].kind == "enum"
            expect view.items[0].name == "Color"

    describe "trait extraction":
        """
        ### Trait Definitions

        Tests extracting trait signatures from source.
        """

        it "extracts trait":
            val source = "trait Drawable:\n    fn draw()"
            val view = extract_brief(source)
            expect view.items.len() >= 1
            # First item should be the trait
            val trait_item = view.items[0]
            expect trait_item.kind == "trait"
            expect trait_item.name == "Drawable"

    describe "const extraction":
        """
        ### Const Definitions

        Tests extracting const signatures from source.
        """

        it "extracts const":
            val source = "const MAX_SIZE: i64 = 1000"
            val view = extract_brief(source)
            expect view.items.len() == 1
            expect view.items[0].kind == "const"
            expect view.items[0].name == "MAX_SIZE"

    describe "impl extraction":
        """
        ### Impl Blocks

        Tests extracting impl block headers from source.
        """

        it "extracts impl block":
            val source = "impl Point:\n    fn distance() -> f64:\n        0.0"
            val view = extract_brief(source)
            expect view.items.len() >= 1
            # Should have impl and fn
            val has_impl = view.items.any(\item: item.kind == "impl")
            expect has_impl == true

    describe "method extraction":
        """
        ### Method Definitions

        Tests extracting mutable method signatures.
        """

        it "extracts mutable method":
            val source = "me update(value: i64):\n    self.x = value"
            val view = extract_brief(source)
            expect view.items.len() == 1
            expect view.items[0].kind == "me"

    describe "line counting":
        """
        ### Line Information

        Tests line number tracking in extracted items.
        """

        it "tracks line numbers":
            val source = "fn first():\n    pass\n\nfn second():\n    pass"
            val view = extract_brief(source)
            expect view.items[0].line == 1
            expect view.items[1].line == 4

        it "counts total lines":
            val source = "line1\nline2\nline3\nline4\nline5"
            val view = extract_brief(source)
            expect view.total_lines == 5


# ============================================================================
# Helper Functions
# ============================================================================

describe "helper functions":
    """
    ## Utility Functions

    Tests helper functions used in brief view generation.
    """

    describe "find_char":
        """
        ### Character Search

        Tests finding character position in string.
        """

        it "finds character at start":
            expect find_char("(test)", '(') == 0

        it "finds character in middle":
            expect find_char("fn main()", '(') == 7

        it "returns -1 when not found":
            expect find_char("no paren here", '(') == -1

    describe "extract_signature":
        """
        ### Signature Extraction

        Tests extracting parameter and return type signatures.
        """

        it "extracts simple params":
            val sig = extract_signature("main()")
            expect sig == "()"

        it "extracts params with types":
            val sig = extract_signature("add(a: i64, b: i64) -> i64:")
            expect sig.contains("a: i64")
            expect sig.contains("->")

    describe "format_tree_item":
        """
        ### Tree Item Formatting

        Tests box-drawing character formatting.
        """

        it "formats last item with corner":
            val item = BriefItem.new("fn", "test", "()", 1)
            val output = format_tree_item(item, "", true)
            expect output.contains("fn test()")


# ============================================================================
# Integration Tests
# ============================================================================

describe "integration":
    """
    ## Integration Tests

    Tests complete workflows combining multiple features.
    """

    describe "complex source":
        """
        ### Multi-Item Source Files

        Tests extracting from realistic source files.
        """

        it "extracts multiple item types":
            val source = """
struct Config:
    name: text
    value: i64

enum Status:
    Active
    Inactive

fn main():
    val cfg = Config(name: "test", value: 42)
    print cfg.name

pub fn process(data: text) -> Result<i64, text>:
    Ok(42)
"""
            val view = extract_brief(source)
            # Should have struct, enum, and 2 functions
            expect view.items.len() >= 3

            # Check we have different kinds
            val has_struct = view.items.any(\item: item.kind == "struct")
            val has_enum = view.items.any(\item: item.kind == "enum")
            val has_fn = view.items.any(\item: item.kind == "fn")

            expect has_struct == true
            expect has_enum == true
            expect has_fn == true

    describe "token estimation":
        """
        ### Token Count Estimation

        Tests token count estimation for LLM context planning.
        """

        it "estimates tokens for brief view":
            var view = BriefView.new("test.spl")
            view.add_item(BriefItem.new("fn", "test", "()", 1))
            val json = view.to_json_compact()
            # Token estimate should be roughly json.len() / 4
            expect view.token_estimate >= 0
