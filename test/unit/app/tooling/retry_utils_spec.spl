"""
Feature: Retry Utilities
Category: Standard Library / Tooling
Status: Complete

Comprehensive retry mechanisms with circuit breaker, rate limiting, timeout
handling, and retry statistics tracking for resilience patterns.
"""


# =====================================
# Retry Strategy Enum
# =====================================

enum RetryStrategy:
    FixedDelay(delay: i64)
    LinearBackoff(start: i64, increment: i64)
    ExponentialBackoff(base: i64, max_delay: i64)
    NoRetry

# =====================================
# Circuit State Enum
# =====================================

enum CircuitState:
    Closed
    Open
    HalfOpen

# =====================================
# RetryConfig Struct
# =====================================

struct RetryConfig:
    max_attempts: i64
    timeout_ms: i64
    strategy: RetryStrategy

impl RetryConfig:
    static fn default() -> RetryConfig:
        RetryConfig(max_attempts: 3, timeout_ms: 30000, strategy: RetryStrategy.FixedDelay(1000))

    static fn fixed_delay(attempts: i64, delay: i64) -> RetryConfig:
        RetryConfig(max_attempts: attempts, timeout_ms: 30000, strategy: RetryStrategy.FixedDelay(delay))

    static fn linear_backoff(attempts: i64, start: i64, increment: i64) -> RetryConfig:
        RetryConfig(max_attempts: attempts, timeout_ms: 30000, strategy: RetryStrategy.LinearBackoff(start, increment))

    static fn exponential_backoff(attempts: i64, base: i64, max_delay: i64) -> RetryConfig:
        RetryConfig(max_attempts: attempts, timeout_ms: 30000, strategy: RetryStrategy.ExponentialBackoff(base, max_delay))

    static fn no_retry() -> RetryConfig:
        RetryConfig(max_attempts: 1, timeout_ms: 30000, strategy: RetryStrategy.NoRetry)

# =====================================
# Delay Calculation
# =====================================

fn calculate_delay(strategy: RetryStrategy, attempt: i64) -> i64:
    match strategy:
        case RetryStrategy.FixedDelay(delay): delay
        case RetryStrategy.LinearBackoff(start, increment): start + (attempt - 1) * increment
        case RetryStrategy.ExponentialBackoff(base, max_delay):
            var result = base
            for _ in 1..attempt:
                result = result * 2
            if result > max_delay: max_delay else: result
        case RetryStrategy.NoRetry: 0

fn calculate_retry_schedule(config: RetryConfig) -> [i64]:
    var schedule: [i64] = []
    for i in 1..config.max_attempts:
        schedule = schedule + [calculate_delay(config.strategy, i)]
    schedule

fn calculate_total_retry_time(config: RetryConfig) -> i64:
    var total = 0
    val schedule = calculate_retry_schedule(config)
    for delay in schedule:
        total = total + delay
    total

# =====================================
# Error Predicates
# =====================================

fn is_transient_error(status: i64) -> bool:
    status == 500 or status == 503 or status == 429

fn is_network_error(msg: text) -> bool:
    msg.contains("timeout") or msg.contains("connection failed") or msg.contains("network unreachable")

# =====================================
# Circuit Breaker Class
# =====================================

class CircuitBreaker:
    failure_threshold: i64
    success_threshold: i64
    state: CircuitState
    failure_count: i64
    success_count: i64
    last_failure_time: i64

impl CircuitBreaker:
    static fn create(failure_threshold: i64, success_threshold: i64) -> CircuitBreaker:
        CircuitBreaker(
            failure_threshold: failure_threshold,
            success_threshold: success_threshold,
            state: CircuitState.Closed,
            failure_count: 0,
            success_count: 0,
            last_failure_time: 0
        )

    me on_failure(timestamp: i64):
        self.failure_count = self.failure_count + 1
        self.last_failure_time = timestamp
        if self.failure_count >= self.failure_threshold:
            self.state = CircuitState.Open

    me on_success():
        self.success_count = self.success_count + 1
        if self.success_count >= self.success_threshold:
            self.state = CircuitState.Closed
            self.failure_count = 0

    fn can_attempt(current_time: i64, timeout: i64) -> bool:
        match self.state:
            case CircuitState.Closed: true
            case CircuitState.Open:
                if current_time - self.last_failure_time >= timeout:
                    true
                else:
                    false
            case CircuitState.HalfOpen: true

# =====================================
# Rate Limiter Class
# =====================================

class RateLimiter:
    max_requests: i64
    window_ms: i64
    request_times: [i64]

impl RateLimiter:
    static fn create(max_requests: i64, window_ms: i64) -> RateLimiter:
        RateLimiter(max_requests: max_requests, window_ms: window_ms, request_times: [])

    fn is_allowed(current_time: i64) -> bool:
        var valid_count = 0
        for t in self.request_times:
            if current_time - t < self.window_ms:
                valid_count = valid_count + 1
        valid_count < self.max_requests

    me record_request(timestamp: i64):
        var new_times: [i64] = []
        for t in self.request_times:
            if timestamp - t < self.window_ms:
                new_times = new_times + [t]
        self.request_times = new_times + [timestamp]

    fn delay_until_allowed(current_time: i64) -> i64:
        if self.is_allowed(current_time):
            return 0
        if self.request_times.len() == 0:
            return 0
        val oldest = self.request_times[0]
        val wait_until = oldest + self.window_ms
        if wait_until > current_time:
            wait_until - current_time
        else:
            0

# =====================================
# Timeout Functions
# =====================================

fn is_timed_out(start_time: i64, current_time: i64, timeout: i64) -> bool:
    current_time - start_time >= timeout

fn remaining_time(start_time: i64, current_time: i64, timeout: i64) -> i64:
    val remaining = timeout - (current_time - start_time)
    if remaining < 0: 0 else: remaining

# =====================================
# Retry Stats Class
# =====================================

class RetryStats:
    total_attempts: i64
    successful_attempts: i64
    failed_attempts: i64
    total_duration: i64

impl RetryStats:
    static fn create() -> RetryStats:
        RetryStats(total_attempts: 0, successful_attempts: 0, failed_attempts: 0, total_duration: 0)

    me record_success(duration: i64):
        self.total_attempts = self.total_attempts + 1
        self.successful_attempts = self.successful_attempts + 1
        self.total_duration = self.total_duration + duration

    me record_failure(duration: i64):
        self.total_attempts = self.total_attempts + 1
        self.failed_attempts = self.failed_attempts + 1
        self.total_duration = self.total_duration + duration

    fn success_rate() -> f64:
        if self.total_attempts == 0:
            return 0.0
        (self.successful_attempts as f64 / self.total_attempts as f64) * 100.0

    fn summary() -> text:
        "Total: {self.total_attempts}, Success: {self.successful_attempts}, Failed: {self.failed_attempts}"

# =====================================
# BDD Tests
# =====================================

describe "Retry Utilities":
    """
    Tests for comprehensive retry and resilience mechanisms including
    various backoff strategies, circuit breaker pattern, rate limiting,
    and execution statistics tracking.
    """

    describe "RetryConfig":
        """Test retry configuration factories with various strategies"""
        it "default config has 3 attempts":
            val config = RetryConfig.default()
            expect config.max_attempts == 3
            expect config.timeout_ms == 30000

        it "fixed_delay creates correct strategy":
            val config = RetryConfig.fixed_delay(attempts=5, delay=1000)
            expect config.max_attempts == 5
            match config.strategy:
                case RetryStrategy.FixedDelay(delay): expect delay == 1000
                case _: expect false

        it "linear_backoff creates correct strategy":
            val config = RetryConfig.linear_backoff(attempts=4, start=100, increment=50)
            expect config.max_attempts == 4
            match config.strategy:
                case RetryStrategy.LinearBackoff(start, increment):
                    expect start == 100
                    expect increment == 50
                case _: expect false

        it "exponential_backoff creates correct strategy":
            val config = RetryConfig.exponential_backoff(attempts=5, base=100, max_delay=5000)
            expect config.max_attempts == 5
            match config.strategy:
                case RetryStrategy.ExponentialBackoff(base, max_delay):
                    expect base == 100
                    expect max_delay == 5000
                case _: expect false

        it "no_retry has 1 attempt":
            val config = RetryConfig.no_retry()
            expect config.max_attempts == 1

    describe "Delay Calculation":
        """Test retry delay calculation for different backoff strategies"""
        it "fixed delay returns same value":
            val strategy = RetryStrategy.FixedDelay(1000)
            expect calculate_delay(strategy, 1) == 1000
            expect calculate_delay(strategy, 2) == 1000
            expect calculate_delay(strategy, 5) == 1000

        it "linear backoff increases linearly":
            val strategy = RetryStrategy.LinearBackoff(100, 50)
            expect calculate_delay(strategy, 1) == 100
            expect calculate_delay(strategy, 2) == 150
            expect calculate_delay(strategy, 3) == 200

        it "exponential backoff doubles":
            val strategy = RetryStrategy.ExponentialBackoff(100, 5000)
            expect calculate_delay(strategy, 1) == 100
            expect calculate_delay(strategy, 2) == 200
            expect calculate_delay(strategy, 3) == 400
            expect calculate_delay(strategy, 4) == 800

        it "exponential backoff caps at max":
            val strategy = RetryStrategy.ExponentialBackoff(100, 5000)
            val delay = calculate_delay(strategy, 10)
            expect delay <= 5000

        it "no retry returns 0":
            val strategy = RetryStrategy.NoRetry
            expect calculate_delay(strategy, 1) == 0

    describe "Retry Schedule":
        """Test retry schedule generation and timing calculations"""
        it "calculates fixed schedule":
            val config = RetryConfig.fixed_delay(attempts=3, delay=1000)
            val schedule = calculate_retry_schedule(config)
            expect schedule.len() == 2
            expect schedule[0] == 1000
            expect schedule[1] == 1000

        it "calculates exponential schedule":
            val config = RetryConfig.exponential_backoff(attempts=4, base=100, max_delay=5000)
            val schedule = calculate_retry_schedule(config)
            expect schedule.len() == 3
            expect schedule[0] == 100
            expect schedule[1] == 200
            expect schedule[2] == 400

        it "calculates total retry time":
            val config = RetryConfig.fixed_delay(attempts=3, delay=1000)
            val total = calculate_total_retry_time(config)
            expect total == 2000

    describe "Error Predicates":
        """Test identification of transient and network errors"""
        it "identifies transient errors":
            expect is_transient_error(500)
            expect is_transient_error(503)
            expect is_transient_error(429)
            expect not is_transient_error(200)
            expect not is_transient_error(404)
            expect not is_transient_error(400)

        it "identifies network errors":
            expect is_network_error("timeout")
            expect is_network_error("connection failed")
            expect is_network_error("network unreachable")
            expect not is_network_error("invalid input")
            expect not is_network_error("parse error")

    describe "Circuit Breaker":
        """Test circuit breaker state machine for failure handling"""
        it "creates with closed state":
            val cb = CircuitBreaker.create(failure_threshold=5, success_threshold=2)
            expect cb.failure_threshold == 5
            expect cb.success_threshold == 2
            match cb.state:
                case CircuitState.Closed: expect true
                case _: expect false

        it "opens after failure threshold":
            var cb = CircuitBreaker.create(failure_threshold=3, success_threshold=2)
            match cb.state:
                case CircuitState.Closed: expect true
                case _: expect false
            cb.on_failure(100)
            cb.on_failure(200)
            cb.on_failure(300)
            match cb.state:
                case CircuitState.Open: expect true
                case _: expect false

        it "allows attempt when closed":
            var cb = CircuitBreaker.create(failure_threshold=2, success_threshold=1)
            expect cb.can_attempt(current_time=0, timeout=1000)

        it "blocks attempt when open":
            var cb = CircuitBreaker.create(failure_threshold=2, success_threshold=1)
            cb.on_failure(100)
            cb.on_failure(200)
            expect not cb.can_attempt(current_time=250, timeout=1000)

        it "allows attempt after timeout":
            var cb = CircuitBreaker.create(failure_threshold=2, success_threshold=1)
            cb.on_failure(100)
            cb.on_failure(200)
            expect cb.can_attempt(current_time=1300, timeout=1000)

    describe "Rate Limiter":
        """Test rate limiting with sliding window"""
        it "creates with correct settings":
            val limiter = RateLimiter.create(max_requests=10, window_ms=1000)
            expect limiter.max_requests == 10
            expect limiter.window_ms == 1000

        it "allows requests under limit":
            var limiter = RateLimiter.create(max_requests=5, window_ms=1000)
            expect limiter.is_allowed(100)
            limiter.record_request(100)
            expect limiter.is_allowed(100)
            limiter.record_request(100)

        it "rejects requests over limit":
            var limiter = RateLimiter.create(max_requests=2, window_ms=1000)
            limiter.record_request(100)
            limiter.record_request(100)
            expect not limiter.is_allowed(100)

        it "resets after window":
            var limiter = RateLimiter.create(max_requests=2, window_ms=1000)
            limiter.record_request(100)
            limiter.record_request(100)
            expect not limiter.is_allowed(500)
            limiter.record_request(1200)
            expect limiter.is_allowed(1200)

        it "calculates delay until allowed":
            var limiter = RateLimiter.create(max_requests=1, window_ms=1000)
            limiter.record_request(100)
            val delay = limiter.delay_until_allowed(500)
            expect delay > 0
            expect delay <= 1000

    describe "Timeout":
        """Test timeout detection and remaining time calculation"""
        it "detects timed out":
            expect not is_timed_out(start_time=100, current_time=500, timeout=1000)
            expect is_timed_out(start_time=100, current_time=1200, timeout=1000)

        it "calculates remaining time":
            expect remaining_time(start_time=100, current_time=500, timeout=1000) == 600
            expect remaining_time(start_time=100, current_time=1200, timeout=1000) == 0

    describe "Retry Stats":
        """Test retry statistics tracking and reporting"""
        it "creates empty stats":
            val stats = RetryStats.create()
            expect stats.total_attempts == 0
            expect stats.successful_attempts == 0
            expect stats.failed_attempts == 0

        it "records success":
            var stats = RetryStats.create()
            stats.record_success(100)
            expect stats.total_attempts == 1
            expect stats.successful_attempts == 1
            expect stats.failed_attempts == 0

        it "records failure":
            var stats = RetryStats.create()
            stats.record_failure(200)
            expect stats.total_attempts == 1
            expect stats.successful_attempts == 0
            expect stats.failed_attempts == 1

        it "calculates success rate":
            var stats = RetryStats.create()
            stats.record_success(100)
            stats.record_success(100)
            stats.record_failure(100)
            val rate = stats.success_rate()
            expect rate > 66.0 and rate < 67.0

        it "generates summary":
            var stats = RetryStats.create()
            stats.record_success(100)
            stats.record_failure(200)
            val summary = stats.summary()
            expect summary.len() > 0
