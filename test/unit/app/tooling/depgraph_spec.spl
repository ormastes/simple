# # Dependency Graph Generator Specification
#
# **Feature IDs:** #3100
# **Category:** Tooling
# **Status:** Planned
#
# Tool for auto-generating .__init__.spl files with dependency analysis.
# Scans directories for .spl files, extracts imports, identifies external
# dependencies, and enforces child module visibility rules via parent
# re-export declarations.

describe "Dependency Graph Generator":
    # Tool for auto-generating import statements and analyzing
    # external dependencies. Outputs to .__init__.spl files (dot-prefixed).
    #
    # Key features:
    # - Scans directories for .spl files
    # - Extracts imports from each file
    # - Identifies external dependencies (outside module tree)
    # - Enforces child blocking unless parent re-exports
    # - Uses AOP for logging all operations

    context "Directory Scanning":
        it "finds all .spl files in directory":
            # scanner.scan_directory("./test_dir", recursive=false)
            # should return list of .spl files in directory
            val files = ["module1.spl", "module2.spl", "helper.spl"]
            expect files.len() == 3

        it "excludes .__init__.spl from scan":
            # Dot-prefixed files are generated, not source
            val files = ["module1.spl", ".__init__.spl", "module2.spl"]
            val filtered = files.filter(\f: not f.starts_with("."))
            expect filtered.len() == 2

        it "excludes __init__.spl from module list":
            # __init__.spl is manifest, not a module
            val files = ["module1.spl", "__init__.spl", "module2.spl"]
            val modules = files.filter(\f: f != "__init__.spl")
            expect modules.len() == 2

        it "identifies child directories with __init__.spl":
            # Directories with __init__.spl are child modules
            val has_init = true
            expect has_init == true

        it "skips directories without __init__.spl":
            # Directories without __init__.spl are not modules
            val has_init = false
            expect has_init == false

    context "Import Extraction":
        it "extracts use statements":
            val source = "use std.io\nuse core.json"
            val imports = ["std.io", "core.json"]
            expect imports.len() == 2

        it "extracts export use statements":
            val source = "export use router.Router"
            val exports = ["router.Router"]
            expect exports.len() == 1

        it "extracts common use statements":
            val source = "common use core.prelude"
            val common = ["core.prelude.*"]
            expect common.len() == 1

        it "extracts glob imports":
            val source = "use std.collections"
            val imports = ["std.collections.*"]
            expect imports[0].ends_with(".*")

        it "extracts grouped imports":
            val source = "use std.{io, fs, net}"
            val imports = ["std.io", "std.fs", "std.net"]
            expect imports.len() == 3

        it "extracts aliased imports":
            val source = "use std.collections as col"
            val imports = [("std.collections", "col")]
            expect imports.len() == 1

    context "External Dependency Detection":
        it "identifies imports outside module tree":
            val module_path = "myapp.server"
            val import_path = "std.io"
            val is_external = not import_path.starts_with("myapp.")
            expect is_external == true

        it "marks stdlib imports as external":
            val import_path = "std.collections"
            val is_stdlib = import_path.starts_with("std.")
            expect is_stdlib == true

        it "marks core imports as external":
            val import_path = "core.json"
            val is_core = import_path.starts_with("core.")
            expect is_core == true

        it "identifies internal imports":
            val module_path = "myapp.server"
            val import_path = "myapp.utils"
            val is_internal = import_path.starts_with("myapp.")
            expect is_internal == true

        it "identifies sibling imports":
            val module_path = "myapp.server.handler"
            val import_path = "myapp.server.router"
            val is_sibling = true  # Same parent
            expect is_sibling == true

    context "Child Blocking Rules":
        it "blocks child exports unless parent has pub mod":
            # Child module cannot export unless parent declares: pub mod child
            val parent_has_pub_mod = false
            val child_can_export = parent_has_pub_mod
            expect child_can_export == false

        it "allows child exports when parent has pub mod":
            val parent_has_pub_mod = true
            val child_can_export = parent_has_pub_mod
            expect child_can_export == true

        it "blocks symbols not in parent export use":
            # Even with pub mod, symbol must be in export use
            val parent_has_pub_mod = true
            val in_export_list = false
            val symbol_visible = parent_has_pub_mod and in_export_list
            expect symbol_visible == false

        it "allows symbols in parent export use":
            val parent_has_pub_mod = true
            val in_export_list = true
            val symbol_visible = parent_has_pub_mod and in_export_list
            expect symbol_visible == true

        it "glob export includes non-macro public items":
            # export use child includes all pub non-macro items
            val has_glob_export = true
            val is_macro = false
            val is_public = true
            val visible = has_glob_export and is_public and not is_macro
            expect visible == true

        it "glob export excludes macros unless auto import":
            val has_glob_export = true
            val is_macro = true
            val in_auto_import = false
            val visible = has_glob_export and is_macro and in_auto_import
            expect visible == false

    context ".__init__.spl Generation":
        it "generates dot-prefixed file":
            val output_name = ".__init__.spl"
            expect output_name.starts_with(".")

        it "includes header comment":
            val header = "# Auto-generated dependency analysis"
            expect header.starts_with("#")

        it "includes external dependency list":
            val externals = ["std.io", "core.json"]
            val comments = externals.map(\e: "# external: " + e)
            expect comments.len() == 2

        it "includes child module declarations":
            val children = ["scanner", "parser", "analyzer"]
            val mods = children.map(\c: "mod " + c)
            expect mods.len() == 3

        it "includes pub mod for public children":
            val public_children = ["api", "types"]
            val pub_mods = public_children.map(\c: "pub mod " + c)
            expect pub_mods[0] == "pub mod api"

        it "includes export use statements":
            val exports = ["scanner.scan_directory", "analyzer.analyze"]
            val export_stmts = exports.map(\e: "export use " + e)
            expect export_stmts.len() == 2

        it "preserves existing manual exports":
            # If __init__.spl exists with manual exports, preserve them
            val manual_exports = ["special.CustomType"]
            expect manual_exports.len() == 1

    context "Recursive Mode":
        it "processes subdirectories when recursive=true":
            val recursive = true
            val process_children = recursive
            expect process_children == true

        it "skips subdirectories when recursive=false":
            val recursive = false
            val process_children = recursive
            expect process_children == false

        it "generates .__init__.spl for each directory":
            val dirs = ["src/", "src/api/", "src/utils/"]
            val generated = dirs.map(\d: d + ".__init__.spl")
            expect generated.len() == 3

    context "AOP Logging":
        it "logs directory scan start":
            val log_msg = "[SCAN] Starting scan: ./src"
            expect log_msg.contains("[SCAN]")

        it "logs each file processed":
            val log_msg = "[FILE] Processing: module.spl"
            expect log_msg.contains("[FILE]")

        it "logs external dependencies found":
            val log_msg = "[DEP] External: std.io"
            expect log_msg.contains("[DEP]")

        it "logs child modules found":
            val log_msg = "[MOD] Child: utils"
            expect log_msg.contains("[MOD]")

        it "logs generation complete":
            val log_msg = "[GEN] Generated: .__init__.spl"
            expect log_msg.contains("[GEN]")

    context "CLI Interface":
        it "accepts directory argument":
            val args = ["simple_depgraph", "./src"]
            expect args.len() >= 2

        it "accepts --recursive flag":
            val args = ["simple_depgraph", "./src", "--recursive"]
            val has_recursive = args.contains("--recursive")
            expect has_recursive == true

        it "accepts --verbose flag for detailed logging":
            val args = ["simple_depgraph", "./src", "--verbose"]
            val has_verbose = args.contains("--verbose")
            expect has_verbose == true

        it "shows usage on no arguments":
            val args = ["simple_depgraph"]
            val show_usage = args.len() < 2
            expect show_usage == true

        it "returns exit code 0 on success":
            val exit_code = 0
            expect exit_code == 0

        it "returns exit code 1 on error":
            val exit_code = 1
            expect exit_code == 1

    context "Error Handling":
        it "reports file read errors":
            val error = "Failed to read: module.spl"
            expect error.contains("Failed to read")

        it "reports directory not found":
            val error = "Directory not found: ./nonexistent"
            expect error.contains("not found")

        it "reports parse errors":
            val error = "Parse error in module.spl:10"
            expect error.contains("Parse error")

        it "continues on non-fatal errors":
            val continue_on_error = true
            expect continue_on_error == true
