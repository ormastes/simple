# # Test DB Validation Specification
#
# **Feature IDs:** #DB-VALIDATION
# **Category:** Tooling
# **Status:** Implemented
#
# ## Overview
#
# Tests database integrity validation: count consistency, stale run detection.
# Note: Tests involving StringInterner__intern() are skipped due to interpreter
# limitation (fn vs me method for self-mutation). Those are tested in compiled mode.

use app.test_runner_new.test_db_types.*
use app.test_runner_new.test_db_core.TestDatabase
use app.test_runner_new.test_db_validation.*

# ============================================================================
# Test Group 1: Count Consistency
# ============================================================================

describe "validate_count_consistency":
    it "returns no issues for consistent counts":
        val db = TestDatabase__empty()
        db.counters.push(CounterRecord(
            test_id: 0, total_runs: 10, passed: 7, failed: 3,
            flaky_count: 0, last_change: "no_change",
            last_10_runs: "", failure_rate_pct: 30.0
        ))
        val issues = validate_count_consistency(db)
        expect(issues.len()).to_equal(0)

    it "detects passed + failed > total_runs":
        val db = TestDatabase__empty()
        db.counters.push(CounterRecord(
            test_id: 0, total_runs: 5, passed: 4, failed: 3,
            flaky_count: 0, last_change: "no_change",
            last_10_runs: "", failure_rate_pct: 0.0
        ))
        val issues = validate_count_consistency(db)
        expect(issues.len() > 0).to_equal(true)
        expect(issues[0].severity).to_equal("warning")
        expect(issues[0].auto_fixable).to_equal(true)

    it "accepts equal counts":
        val db = TestDatabase__empty()
        db.counters.push(CounterRecord(
            test_id: 0, total_runs: 10, passed: 5, failed: 5,
            flaky_count: 0, last_change: "no_change",
            last_10_runs: "", failure_rate_pct: 50.0
        ))
        val issues = validate_count_consistency(db)
        expect(issues.len()).to_equal(0)

    it "accepts zero counts":
        val db = TestDatabase__empty()
        db.counters.push(CounterRecord(
            test_id: 0, total_runs: 0, passed: 0, failed: 0,
            flaky_count: 0, last_change: "new_test",
            last_10_runs: "", failure_rate_pct: 0.0
        ))
        val issues = validate_count_consistency(db)
        expect(issues.len()).to_equal(0)

# ============================================================================
# Test Group 2: Stale Runs
# ============================================================================

describe "validate_stale_runs":
    it "returns no issues when no runs exist":
        val db = TestDatabase__empty()
        val issues = validate_stale_runs(db)
        expect(issues.len()).to_equal(0)

    it "returns no issues for completed runs":
        val db = TestDatabase__empty()
        db.test_runs.push(RunRecord(
            run_id: "run_1", start_time: "2026-01-01T00:00:00Z",
            end_time: "2026-01-01T00:01:00Z", pid: 1234,
            hostname: "host", status: "completed",
            test_count: 10, passed: 10, failed: 0, crashed: 0, timed_out: 0
        ))
        val issues = validate_stale_runs(db)
        expect(issues.len()).to_equal(0)

    it "flags runs still marked as running":
        val db = TestDatabase__empty()
        db.test_runs.push(RunRecord(
            run_id: "run_2", start_time: "2026-01-01T00:00:00Z",
            end_time: "", pid: 5678,
            hostname: "host", status: "running",
            test_count: 0, passed: 0, failed: 0, crashed: 0, timed_out: 0
        ))
        val issues = validate_stale_runs(db)
        expect(issues.len()).to_equal(1)
        expect(issues[0].severity).to_equal("warning")
        expect(issues[0].auto_fixable).to_equal(true)

    it "ignores crashed runs":
        val db = TestDatabase__empty()
        db.test_runs.push(RunRecord(
            run_id: "r1", start_time: "2026-01-01T00:00:00Z",
            end_time: "2026-01-01T00:01:00Z", pid: 1,
            hostname: "h", status: "crashed",
            test_count: 0, passed: 0, failed: 0, crashed: 0, timed_out: 0
        ))
        val issues = validate_stale_runs(db)
        expect(issues.len()).to_equal(0)

    it "flags multiple running runs":
        val db = TestDatabase__empty()
        db.test_runs.push(RunRecord(
            run_id: "r1", start_time: "", end_time: "", pid: 1,
            hostname: "h", status: "running",
            test_count: 0, passed: 0, failed: 0, crashed: 0, timed_out: 0
        ))
        db.test_runs.push(RunRecord(
            run_id: "r2", start_time: "", end_time: "", pid: 2,
            hostname: "h", status: "running",
            test_count: 0, passed: 0, failed: 0, crashed: 0, timed_out: 0
        ))
        val issues = validate_stale_runs(db)
        expect(issues.len()).to_equal(2)

# ============================================================================
# Test Group 3: Full Validation
# ============================================================================

describe "validate_database":
    it "returns empty issues for clean database":
        val db = TestDatabase__empty()
        val issues = validate_database(db)
        expect(issues.len()).to_equal(0)

    it "detects inconsistent counters":
        val db = TestDatabase__empty()
        db.counters.push(CounterRecord(
            test_id: 0, total_runs: 1, passed: 5, failed: 5,
            flaky_count: 0, last_change: "",
            last_10_runs: "", failure_rate_pct: 0.0
        ))
        val issues = validate_database(db)
        expect(issues.len() > 0).to_equal(true)

    it "detects stale runs":
        val db = TestDatabase__empty()
        db.test_runs.push(RunRecord(
            run_id: "stale", start_time: "", end_time: "", pid: 0,
            hostname: "", status: "running",
            test_count: 0, passed: 0, failed: 0, crashed: 0, timed_out: 0
        ))
        val issues = validate_database(db)
        expect(issues.len() > 0).to_equal(true)

# ============================================================================
# Test Group 4: ValidationIssue Type
# ============================================================================

describe "ValidationIssue":
    it "can be created with error severity":
        val issue = ValidationIssue(
            severity: "error",
            message: "test error",
            auto_fixable: false
        )
        expect(issue.severity).to_equal("error")
        expect(issue.message).to_equal("test error")
        expect(issue.auto_fixable).to_equal(false)

    it "can be created with warning severity":
        val issue = ValidationIssue(
            severity: "warning",
            message: "test warning",
            auto_fixable: true
        )
        expect(issue.severity).to_equal("warning")
        expect(issue.auto_fixable).to_equal(true)

