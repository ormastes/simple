# Test Database Edge Cases & Robustness Tests
#
# Tests boundary conditions and error handling:
# - Empty databases
# - Boundary values (0, max, negative, unicode)
# - Timing edge cases
# - Counter edge cases
# - Timestamp parsing
# - Validation integration

use app.io.sysinfo_ops (getpid)
use app.io.file_ops (file_exists, file_delete, file_read, file_write)
use app.io.time_ops (time_now_unix_micros)
use app.test_runner_new.test_db_core (TestDatabase, micros_to_rfc3339, parse_rfc3339_to_micros)
use app.test_runner_new.test_db_types.*
use app.test_runner_new.test_db_validation (validate_run_record)


describe "Test Database Edge Cases":

    describe "Boundary Values":

        it "handles zero tests in database":
            var db = TestDatabase.empty()

            expect(db.tests.len()).to_be(0)
            expect(db.counters.len()).to_be(0)
            expect(db.timing.len()).to_be(0)

            # Operations on empty database should work
            val runs = db.list_runs("all")
            expect(runs.len()).to_be(0)

        it "handles empty strings in all text fields":
            val run = RunRecord(
                run_id: "",
                start_time: "",
                end_time: "",
                pid: getpid(),
                hostname: "",
                status: "",
                test_count: 0,
                passed: 0,
                failed: 0,
                crashed: 0,
                timed_out: 0
            )

            # Should validate (may have violations for empty fields)
            val report = validate_run_record(run)
            # Shouldn't crash

        it "handles very long test names (1000+ chars)":
            var db = TestDatabase.empty()

            # Create test with very long name
            var long_name = ""
            for i in 0..100:
                long_name = "{long_name}test_name_"

            db.update_test_result(
                test_name: long_name,
                test_file: "test/long.spl",
                suite_name: "Long Suite",
                category: "unit",
                status: TestStatus.Passed,
                duration_ms: 10.0
            )

            expect(db.tests.len()).to_be(1)

        it "handles unicode in all fields":
            var db = TestDatabase.empty()

            db.update_test_result(
                test_name: "テスト_test",
                test_file: "test/i18n.spl",
                suite_name: "Suite Française",
                category: "unit",
                status: TestStatus.Passed,
                duration_ms: 10.0
            )

            expect(db.tests.len()).to_be(1)

        it "handles special characters (quotes, newlines, etc)":
            var db = TestDatabase.empty()

            db.update_test_result(
                test_name: "test with \"quotes\" and 'apostrophes'",
                test_file: "test/special.spl",
                suite_name: "Suite\nwith\nnewlines",
                category: "cat\twith\ttabs",
                status: TestStatus.Passed,
                duration_ms: 10.0
            )

            expect(db.tests.len()).to_be(1)

    describe "Corrupted Database":

        it "handles malformed timestamps":
            val run = RunRecord(
                run_id: "bad_timestamp",
                start_time: "not-a-timestamp",
                end_time: "also-not-valid",
                pid: getpid(),
                hostname: "test",
                status: "Running",
                test_count: 10,
                passed: 0,
                failed: 0,
                crashed: 0,
                timed_out: 0
            )

            # Validation should catch this
            val report = validate_run_record(run)
            expect(report.has_violations()).to_be(true)

    describe "Timing Edge Cases":

        it "handles negative duration":
            var db = TestDatabase.empty()

            db.update_test_result(
                test_name: "negative_test",
                test_file: "test/neg.spl",
                suite_name: "Negative",
                category: "unit",
                status: TestStatus.Passed,
                duration_ms: -10.0
            )

            # Should handle gracefully (may clamp to 0 or reject)
            expect(db.tests.len()).to_be(1)

        it "handles zero duration":
            var db = TestDatabase.empty()

            db.update_test_result(
                test_name: "zero_test",
                test_file: "test/zero.spl",
                suite_name: "Zero",
                category: "unit",
                status: TestStatus.Passed,
                duration_ms: 0.0
            )

            expect(db.tests.len()).to_be(1)

            # Statistics should handle zero duration
            val name_str = db.interner.intern("zero_test")
            expect(db.timing.any(\ts: ts.test_id == name_str)).to_be(true)
            val matched = db.timing.filter(\ts: ts.test_id == name_str)
            if matched.len() > 0:
                expect(matched[0].last_ms).to_be(0.0)

        it "handles very large duration (hours)":
            var db = TestDatabase.empty()

            # 10 hours in milliseconds
            val ten_hours_ms = 10.0 * 60.0 * 60.0 * 1000.0

            db.update_test_result(
                test_name: "slow_test",
                test_file: "test/slow.spl",
                suite_name: "Slow",
                category: "integration",
                status: TestStatus.Passed,
                duration_ms: ten_hours_ms
            )

            expect(db.tests.len()).to_be(1)

    describe "Counter Edge Cases":

        it "handles 0 total runs (division by zero in failure rate)":
            val counter = CounterRecord(
                test_id: 1,
                total_runs: 0,
                passed: 0,
                failed: 0,
                flaky_count: 0,
                last_change: "new_test",
                last_10_runs: "",
                failure_rate_pct: 0.0
            )

            # Should have 0% failure rate, not NaN or error
            expect(counter.failure_rate_pct).to_be(0.0)
            expect(counter.total_runs).to_be(0)

        it "handles all tests failed (100% failure rate)":
            var db = TestDatabase.empty()

            # Add test that always fails
            for i in 0..10:
                db.update_test_result(
                    test_name: "always_fails",
                    test_file: "test/fail.spl",
                    suite_name: "Failures",
                    category: "unit",
                    status: TestStatus.Failed,
                    duration_ms: 10.0
                )

            # Check counter using filter() to avoid for-loop closure capture issue
            val name_str = db.interner.intern("always_fails")
            val matched = db.counters.filter(\c: c.test_id == name_str)
            expect(matched.len() > 0).to_be(true)
            if matched.len() > 0:
                val c = matched[0]
                expect(c.total_runs).to_be(10)
                expect(c.failed).to_be(10)
                expect(c.passed).to_be(0)
                expect(c.failure_rate_pct).to_be(100.0)

        it "handles count overflow scenario":
            # Simulate very large numbers (though unlikely in practice)
            val large_count = 2147483647  # Max i32

            val counter = CounterRecord(
                test_id: 1,
                total_runs: large_count,
                passed: large_count - 1,
                failed: 1,
                flaky_count: 0,
                last_change: "no_change",
                last_10_runs: "pass,pass,pass,pass,pass,pass,pass,pass,pass,fail",
                failure_rate_pct: 0.0
            )

            # Should handle large numbers without overflow
            expect(counter.total_runs).to_be(large_count)

    describe "Timestamp Parsing Edge Cases":

        it "parses valid RFC3339 timestamps correctly":
            val valid_timestamps = [
                "2026-02-03T10:30:45Z",
                "2020-01-01T00:00:00Z",
                "2099-12-31T23:59:59Z"
            ]

            for ts in valid_timestamps:
                val micros = parse_rfc3339_to_micros(ts)
                expect(micros).to_be_greater_than(0)

        it "handles invalid timestamp formats gracefully":
            val invalid_timestamps = [
                "not-a-timestamp",
                "2026-13-45T99:99:99Z",  # Invalid month/time
                "",
                "2026",
                "10:30:45"
            ]

            for ts in invalid_timestamps:
                val micros = parse_rfc3339_to_micros(ts)
                # Should return 0 or some error value, not crash
                expect(micros >= 0).to_be(true)

    describe "File System Edge Cases":

        it "handles path that doesn't exist":
            val nonexistent = "/nonexistent/path/that/does/not/exist/db.sdn"
            val result = TestDatabase.load_from(nonexistent)
            # load_from returns empty DB for non-existent files
            expect(result.ok.?).to_be(true)

    describe "Validation Integration":

        it "validates all edge cases in run records":
            # Create run with multiple edge case violations
            val problematic_run = RunRecord(
                run_id: "",
                start_time: "invalid",
                end_time: "also-invalid",
                pid: -1,
                hostname: "",
                status: "InvalidStatus",
                test_count: 0,
                passed: 10,  # More than test_count!
                failed: 10,  # Also more than test_count!
                crashed: 0,
                timed_out: 0
            )

            val report = validate_run_record(problematic_run)

            # Should detect multiple violations (CountInconsistent + InvalidValue = 2)
            expect(report.has_violations()).to_be(true)
            expect(report.violations.len()).to_be_greater_than(1)

    describe "Stress Test - Extreme Values":

        it "handles maximum practical database size":
            var db = TestDatabase.empty()

            # Add many records to approach practical limits
            for i in 0..100:
                db.update_test_result(
                    test_name: "test_{i}",
                    test_file: "test/suite.spl",
                    suite_name: "Suite",
                    category: "unit",
                    status: TestStatus.Passed,
                    duration_ms: 10.0
                )

            expect(db.tests.len()).to_be(100)
