describe "Rapier2D Ffi":
    it "skipped":
        skip("pre-existing test failures - functions/imports not available")

# # Feature: Rapier2D Physics SFFI Wrapper
# # Category: Physics, FFI
# # Status: Implemented
# #
# # Tests for the Rapier2D 2D physics engine SFFI wrapper.
# # Covers world creation, rigid bodies, colliders, forces, and collision detection.
# 
# use app.io.rapier2d_ffi.{
#     Vector2, Transform2, Rotation2,
#     PhysicsWorld, physics_create_world, physics_create_world_default,
#     physics_destroy_world, physics_step, physics_set_gravity, physics_world_stats,
#     BodyType, RigidBody,
#     physics_create_body, physics_create_dynamic_body, physics_create_static_body,
#     physics_destroy_body, physics_body_get_position, physics_body_set_position,
#     physics_body_get_velocity, physics_body_set_velocity,
#     physics_body_apply_force, physics_body_apply_impulse, physics_body_apply_torque,
#     physics_body_set_mass, physics_body_get_mass, physics_body_set_damping,
#     physics_body_is_sleeping, physics_body_wake_up,
#     ColliderShape, Collider, PhysicsMaterial,
#     physics_create_circle_collider, physics_create_box_collider,
#     physics_create_capsule_collider, physics_destroy_collider,
#     physics_collider_set_offset, physics_collider_set_material, physics_collider_set_sensor,
#     Contact, ContactList,
#     physics_get_contacts, physics_contacts_count, physics_contacts_get, physics_destroy_contacts,
#     physics_intersection_test, RayCastResult, physics_cast_ray,
#     JointType, Joint,
#     physics_create_distance_joint, physics_create_revolute_joint,
#     physics_create_prismatic_joint, physics_create_fixed_joint,
#     physics_destroy_joint, physics_joint_set_limits, physics_joint_set_motor
# }
# 
# describe "Vector2":
#     # Tests for 2D vector math operations.
#     it "calculates length":
#         val v = Vector2(x: 3.0, y: 4.0)
#         expect(v.length()).to_equal(5.0)
# 
#     it "normalizes vector":
#         val v = Vector2(x: 3.0, y: 4.0)
#         val n = v.normalize()
#         expect(n.x).to_equal(0.6)
#         expect(n.y).to_equal(0.8)
# 
#     it "calculates dot product":
#         val v1 = Vector2(x: 1.0, y: 2.0)
#         val v2 = Vector2(x: 3.0, y: 4.0)
#         expect(v1.dot(v2)).to_equal(11.0)
# 
#     it "adds vectors":
#         val v1 = Vector2(x: 1.0, y: 2.0)
#         val v2 = Vector2(x: 3.0, y: 4.0)
#         val result = v1.add(v2)
#         expect(result.x).to_equal(4.0)
#         expect(result.y).to_equal(6.0)
# 
#     it "subtracts vectors":
#         val v1 = Vector2(x: 5.0, y: 7.0)
#         val v2 = Vector2(x: 2.0, y: 3.0)
#         val result = v1.sub(v2)
#         expect(result.x).to_equal(3.0)
#         expect(result.y).to_equal(4.0)
# 
#     it "scales vector":
#         val v = Vector2(x: 2.0, y: 3.0)
#         val result = v.scale(2.5)
#         expect(result.x).to_equal(5.0)
#         expect(result.y).to_equal(7.5)
# 
# describe "Rotation2":
#     # Tests for 2D rotation representation.
#     it "converts radians to degrees":
#         val rot = Rotation2(angle: 1.5707963267948966)  # Ï€/2
#         expect(rot.to_degrees()).to_be_greater_than(89.9)
#         expect(rot.to_degrees()).to_be_less_than(90.1)
# 
#     it "creates from degrees":
#         val rot = Rotation2.from_degrees(90.0)
#         expect(rot.angle).to_be_greater_than(1.57)
#         expect(rot.angle).to_be_less_than(1.58)
# 
# describe "PhysicsWorld":
#     # Tests for physics world creation and management.
#     it "creates world with custom gravity":
#         val gravity = Vector2(x: 0.0, y: -9.81)
#         val world = physics_create_world(gravity)
#         expect(world.is_valid).to_equal(true)
#         physics_destroy_world(world)
# 
#     it "creates world with default gravity":
#         val world = physics_create_world_default()
#         expect(world.is_valid).to_equal(true)
#         physics_destroy_world(world)
# 
#     it "sets gravity after creation":
#         val world = physics_create_world_default()
#         val new_gravity = Vector2(x: 1.0, y: -5.0)
#         val success = physics_set_gravity(world, new_gravity)
#         expect(success).to_equal(true)
#         physics_destroy_world(world)
# 
#     it "steps simulation":
#         val world = physics_create_world_default()
#         val success = physics_step(world, 0.016)
#         expect(success).to_equal(true)
#         physics_destroy_world(world)
# 
#     it "reports world stats":
#         val world = physics_create_world_default()
#         val stats = physics_world_stats(world)
#         # Initially should have 0 bodies, 0 colliders, 0 joints
#         expect(stats.0).to_equal(0)
#         expect(stats.1).to_equal(0)
#         expect(stats.2).to_equal(0)
#         physics_destroy_world(world)
# 
# describe "RigidBody":
#     # Tests for rigid body creation and manipulation.
#     it "creates dynamic body":
#         val world = physics_create_world_default()
#         val pos = Vector2(x: 1.0, y: 2.0)
#         val body = physics_create_dynamic_body(world, pos)
#         expect(body.is_valid).to_equal(true)
#         expect(body.body_type).to_equal(BodyType.Dynamic)
#         physics_destroy_world(world)
# 
#     it "creates static body":
#         val world = physics_create_world_default()
#         val pos = Vector2(x: 0.0, y: 0.0)
#         val body = physics_create_static_body(world, pos)
#         expect(body.is_valid).to_equal(true)
#         expect(body.body_type).to_equal(BodyType.Static)
#         physics_destroy_world(world)
# 
#     it "gets and sets position":
#         val world = physics_create_world_default()
#         val body = physics_create_dynamic_body(world, Vector2(x: 1.0, y: 2.0))
#         val transform = physics_body_get_position(body)
#         expect(transform.position.x).to_equal(1.0)
#         expect(transform.position.y).to_equal(2.0)
# 
#         val new_transform = Transform2(
#             position: Vector2(x: 5.0, y: 10.0),
#             rotation: Rotation2(angle: 0.0)
#         )
#         physics_body_set_position(body, new_transform)
#         val updated = physics_body_get_position(body)
#         expect(updated.position.x).to_equal(5.0)
#         expect(updated.position.y).to_equal(10.0)
#         physics_destroy_world(world)
# 
#     it "gets and sets velocity":
#         val world = physics_create_world_default()
#         val body = physics_create_dynamic_body(world, Vector2(x: 0.0, y: 0.0))
# 
#         val linear = Vector2(x: 3.0, y: 4.0)
#         val angular = 1.5
#         physics_body_set_velocity(body, linear, angular)
# 
#         val vel = physics_body_get_velocity(body)
#         expect(vel.0.x).to_equal(3.0)
#         expect(vel.0.y).to_equal(4.0)
#         expect(vel.1).to_equal(1.5)
#         physics_destroy_world(world)
# 
#     it "applies force":
#         val world = physics_create_world_default()
#         val body = physics_create_dynamic_body(world, Vector2(x: 0.0, y: 0.0))
#         val force = Vector2(x: 10.0, y: 0.0)
#         val success = physics_body_apply_force(body, force)
#         expect(success).to_equal(true)
#         physics_destroy_world(world)
# 
#     it "applies impulse":
#         val world = physics_create_world_default()
#         val body = physics_create_dynamic_body(world, Vector2(x: 0.0, y: 0.0))
#         val impulse = Vector2(x: 5.0, y: 0.0)
#         val success = physics_body_apply_impulse(body, impulse)
#         expect(success).to_equal(true)
#         physics_destroy_world(world)
# 
#     it "applies torque":
#         val world = physics_create_world_default()
#         val body = physics_create_dynamic_body(world, Vector2(x: 0.0, y: 0.0))
#         val success = physics_body_apply_torque(body, 2.5)
#         expect(success).to_equal(true)
#         physics_destroy_world(world)
# 
#     it "sets and gets mass":
#         val world = physics_create_world_default()
#         val body = physics_create_dynamic_body(world, Vector2(x: 0.0, y: 0.0))
#         physics_body_set_mass(body, 5.0)
#         val mass = physics_body_get_mass(body)
#         expect(mass).to_equal(5.0)
#         physics_destroy_world(world)
# 
#     it "sets damping":
#         val world = physics_create_world_default()
#         val body = physics_create_dynamic_body(world, Vector2(x: 0.0, y: 0.0))
#         val success = physics_body_set_damping(body, 0.5, 0.3)
#         expect(success).to_equal(true)
#         physics_destroy_world(world)
# 
#     it "checks sleep state":
#         val world = physics_create_world_default()
#         val body = physics_create_dynamic_body(world, Vector2(x: 0.0, y: 0.0))
#         # New bodies should be awake
#         val is_sleeping = physics_body_is_sleeping(body)
#         expect(is_sleeping).to_equal(false)
#         physics_destroy_world(world)
# 
# describe "Collider":
#     # Tests for collider shapes and properties.
#     it "creates circle collider":
#         val world = physics_create_world_default()
#         val body = physics_create_dynamic_body(world, Vector2(x: 0.0, y: 0.0))
#         val collider = physics_create_circle_collider(world, body, 1.0)
#         expect(collider.is_valid).to_equal(true)
#         expect(collider.shape).to_equal(ColliderShape.Circle)
#         physics_destroy_world(world)
# 
#     it "creates box collider":
#         val world = physics_create_world_default()
#         val body = physics_create_dynamic_body(world, Vector2(x: 0.0, y: 0.0))
#         val collider = physics_create_box_collider(world, body, 2.0, 1.0)
#         expect(collider.is_valid).to_equal(true)
#         expect(collider.shape).to_equal(ColliderShape.Box)
#         physics_destroy_world(world)
# 
#     it "creates capsule collider":
#         val world = physics_create_world_default()
#         val body = physics_create_dynamic_body(world, Vector2(x: 0.0, y: 0.0))
#         val collider = physics_create_capsule_collider(world, body, 2.0, 0.5)
#         expect(collider.is_valid).to_equal(true)
#         expect(collider.shape).to_equal(ColliderShape.Capsule)
#         physics_destroy_world(world)
# 
#     it "sets collider offset":
#         val world = physics_create_world_default()
#         val body = physics_create_dynamic_body(world, Vector2(x: 0.0, y: 0.0))
#         val collider = physics_create_circle_collider(world, body, 1.0)
#         val offset = Vector2(x: 0.5, y: 0.5)
#         val success = physics_collider_set_offset(collider, offset, 0.0)
#         expect(success).to_equal(true)
#         physics_destroy_world(world)
# 
#     it "sets collider material":
#         val world = physics_create_world_default()
#         val body = physics_create_dynamic_body(world, Vector2(x: 0.0, y: 0.0))
#         val collider = physics_create_circle_collider(world, body, 1.0)
#         val material = PhysicsMaterial(restitution: 0.8, friction: 0.3, density: 1.5)
#         val success = physics_collider_set_material(collider, material)
#         expect(success).to_equal(true)
#         physics_destroy_world(world)
# 
#     it "creates sensor collider":
#         val world = physics_create_world_default()
#         val body = physics_create_dynamic_body(world, Vector2(x: 0.0, y: 0.0))
#         val collider = physics_create_circle_collider(world, body, 1.0)
#         val success = physics_collider_set_sensor(collider, true)
#         expect(success).to_equal(true)
#         physics_destroy_world(world)
# 
# describe "Collision Detection":
#     # Tests for collision detection and contact information.
#     it "gets contact list":
#         val world = physics_create_world_default()
#         val contacts = physics_get_contacts(world)
#         expect(contacts.is_valid).to_equal(true)
#         physics_destroy_contacts(contacts)
#         physics_destroy_world(world)
# 
#     it "counts contacts":
#         val world = physics_create_world_default()
#         val contacts = physics_get_contacts(world)
#         val count = physics_contacts_count(contacts)
#         # Initially should be 0
#         expect(count).to_equal(0)
#         physics_destroy_contacts(contacts)
#         physics_destroy_world(world)
# 
#     it "performs intersection test":
#         val world = physics_create_world_default()
#         val body1 = physics_create_dynamic_body(world, Vector2(x: 0.0, y: 0.0))
#         val body2 = physics_create_dynamic_body(world, Vector2(x: 10.0, y: 0.0))
#         val collider1 = physics_create_circle_collider(world, body1, 1.0)
#         val collider2 = physics_create_circle_collider(world, body2, 1.0)
# 
#         # They're far apart, should not intersect
#         val intersects = physics_intersection_test(world, collider1, collider2)
#         expect(intersects).to_equal(false)
#         physics_destroy_world(world)
# 
#     it "casts ray":
#         val world = physics_create_world_default()
#         val body = physics_create_static_body(world, Vector2(x: 5.0, y: 0.0))
#         val collider = physics_create_circle_collider(world, body, 1.0)
# 
#         val origin = Vector2(x: 0.0, y: 0.0)
#         val direction = Vector2(x: 1.0, y: 0.0)
#         val result = physics_cast_ray(world, origin, direction, 10.0)
# 
#         # Should hit the circle at x=5.0
#         expect(result.hit).to_equal(true)
#         physics_destroy_world(world)
# 
# describe "Joints":
#     # Tests for physics joints and constraints.
#     it "creates distance joint":
#         val world = physics_create_world_default()
#         val body1 = physics_create_dynamic_body(world, Vector2(x: 0.0, y: 0.0))
#         val body2 = physics_create_dynamic_body(world, Vector2(x: 2.0, y: 0.0))
#         val anchor1 = Vector2(x: 0.0, y: 0.0)
#         val anchor2 = Vector2(x: 0.0, y: 0.0)
#         val joint = physics_create_distance_joint(world, body1, body2, anchor1, anchor2, 2.0)
#         expect(joint.is_valid).to_equal(true)
#         expect(joint.joint_type).to_equal(JointType.Distance)
#         physics_destroy_world(world)
# 
#     it "creates revolute joint":
#         val world = physics_create_world_default()
#         val body1 = physics_create_dynamic_body(world, Vector2(x: 0.0, y: 0.0))
#         val body2 = physics_create_dynamic_body(world, Vector2(x: 1.0, y: 0.0))
#         val anchor = Vector2(x: 0.5, y: 0.0)
#         val joint = physics_create_revolute_joint(world, body1, body2, anchor)
#         expect(joint.is_valid).to_equal(true)
#         expect(joint.joint_type).to_equal(JointType.Revolute)
#         physics_destroy_world(world)
# 
#     it "creates prismatic joint":
#         val world = physics_create_world_default()
#         val body1 = physics_create_dynamic_body(world, Vector2(x: 0.0, y: 0.0))
#         val body2 = physics_create_dynamic_body(world, Vector2(x: 1.0, y: 0.0))
#         val axis = Vector2(x: 1.0, y: 0.0)
#         val joint = physics_create_prismatic_joint(world, body1, body2, axis)
#         expect(joint.is_valid).to_equal(true)
#         expect(joint.joint_type).to_equal(JointType.Prismatic)
#         physics_destroy_world(world)
# 
#     it "creates fixed joint":
#         val world = physics_create_world_default()
#         val body1 = physics_create_dynamic_body(world, Vector2(x: 0.0, y: 0.0))
#         val body2 = physics_create_dynamic_body(world, Vector2(x: 1.0, y: 0.0))
#         val joint = physics_create_fixed_joint(world, body1, body2)
#         expect(joint.is_valid).to_equal(true)
#         expect(joint.joint_type).to_equal(JointType.Fixed)
#         physics_destroy_world(world)
# 
#     it "sets joint limits":
#         val world = physics_create_world_default()
#         val body1 = physics_create_dynamic_body(world, Vector2(x: 0.0, y: 0.0))
#         val body2 = physics_create_dynamic_body(world, Vector2(x: 1.0, y: 0.0))
#         val anchor = Vector2(x: 0.5, y: 0.0)
#         val joint = physics_create_revolute_joint(world, body1, body2, anchor)
#         val success = physics_joint_set_limits(joint, -1.57, 1.57)
#         expect(success).to_equal(true)
#         physics_destroy_world(world)
# 
#     it "sets joint motor":
#         val world = physics_create_world_default()
#         val body1 = physics_create_dynamic_body(world, Vector2(x: 0.0, y: 0.0))
#         val body2 = physics_create_dynamic_body(world, Vector2(x: 1.0, y: 0.0))
#         val anchor = Vector2(x: 0.5, y: 0.0)
#         val joint = physics_create_revolute_joint(world, body1, body2, anchor)
#         val success = physics_joint_set_motor(joint, 2.0, 10.0)
#         expect(success).to_equal(true)
#         physics_destroy_world(world)
