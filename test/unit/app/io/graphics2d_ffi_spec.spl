"""
Feature: Lyon 2D Graphics SFFI Wrapper
Category: Graphics, FFI, Tessellation
Status: Implemented

Tests for the Lyon 2D vector graphics tessellation SFFI wrapper.
Covers path building, stroke, fill, shape primitives, transforms, and tessellation.
"""

use app.io.graphics2d_ffi.{
    Point2D, Vector2D, Rect, Bounds,
    PathBuilder, graphics_path_builder_new, graphics_path_builder_free,
    graphics_path_begin, graphics_path_line_to, graphics_path_quadratic_to,
    graphics_path_cubic_to, graphics_path_arc_to, graphics_path_close, graphics_path_build,
    Path, graphics_path_free, graphics_path_get_bounds, graphics_path_contains_point,
    graphics_rectangle, graphics_rounded_rectangle, graphics_circle, graphics_ellipse,
    graphics_polygon, graphics_star,
    FillRule, FillTessellation,
    graphics_fill_tessellate, graphics_fill_tessellate_with_rule, graphics_fill_free,
    graphics_fill_vertex_count, graphics_fill_index_count,
    graphics_fill_get_vertices, graphics_fill_get_indices,
    LineCap, LineJoin, StrokeOptions, stroke_options_default, StrokeTessellation,
    graphics_stroke_tessellate, graphics_stroke_tessellate_with_options, graphics_stroke_free,
    graphics_stroke_vertex_count, graphics_stroke_index_count,
    graphics_stroke_get_vertices, graphics_stroke_get_indices,
    VertexBuffer, graphics_vertex_buffer_free, graphics_vertex_buffer_size,
    graphics_vertex_buffer_get_position, graphics_vertex_buffer_get_normal,
    graphics_vertex_buffer_to_array,
    IndexBuffer, graphics_index_buffer_free, graphics_index_buffer_size,
    graphics_index_buffer_get, graphics_index_buffer_to_array,
    Transform2D, graphics_transform_identity, graphics_transform_translate,
    graphics_transform_rotate, graphics_transform_scale, graphics_transform_multiply,
    graphics_transform_free, graphics_path_transform,
    graphics_last_error
}

describe "Point2D and Vector2D":
    """
    Tests for basic 2D geometry types.
    """
    it "creates point":
        val point = Point2D(x: 10.5, y: 20.3)
        expect(point.x).to_equal(10.5)
        expect(point.y).to_equal(20.3)

    it "creates vector":
        val vector = Vector2D(x: 5.0, y: 12.0)
        expect(vector.x).to_equal(5.0)
        expect(vector.y).to_equal(12.0)

describe "Rect":
    """
    Tests for rectangle structure.
    """
    it "creates rectangle":
        val rect = Rect(x: 10.0, y: 20.0, width: 100.0, height: 50.0)
        expect(rect.x).to_equal(10.0)
        expect(rect.y).to_equal(20.0)
        expect(rect.width).to_equal(100.0)
        expect(rect.height).to_equal(50.0)

describe "Bounds":
    """
    Tests for bounding box operations.
    """
    it "calculates width":
        val bounds = Bounds(min_x: 10.0, min_y: 20.0, max_x: 110.0, max_y: 70.0)
        expect(bounds.width()).to_equal(100.0)

    it "calculates height":
        val bounds = Bounds(min_x: 10.0, min_y: 20.0, max_x: 110.0, max_y: 70.0)
        expect(bounds.height()).to_equal(50.0)

    it "calculates center":
        val bounds = Bounds(min_x: 0.0, min_y: 0.0, max_x: 100.0, max_y: 50.0)
        val center = bounds.center()
        expect(center.x).to_equal(50.0)
        expect(center.y).to_equal(25.0)

describe "PathBuilder - Creation":
    """
    Tests for path builder creation and destruction.
    """
    it "creates path builder":
        val builder = graphics_path_builder_new()
        expect(builder.is_valid).to_equal(true)
        graphics_path_builder_free(builder)

    it "frees path builder":
        val builder = graphics_path_builder_new()
        val success = graphics_path_builder_free(builder)
        expect(success).to_equal(true)

describe "PathBuilder - Building Paths":
    """
    Tests for building paths with lines and curves.
    """
    it "begins path at point":
        val builder = graphics_path_builder_new()
        val start = Point2D(x: 0.0, y: 0.0)
        val success = graphics_path_begin(builder, start)
        expect(success).to_equal(true)
        graphics_path_builder_free(builder)

    it "adds line to path":
        val builder = graphics_path_builder_new()
        graphics_path_begin(builder, Point2D(x: 0.0, y: 0.0))
        val success = graphics_path_line_to(builder, Point2D(x: 100.0, y: 0.0))
        expect(success).to_equal(true)
        graphics_path_builder_free(builder)

    it "adds quadratic bezier":
        val builder = graphics_path_builder_new()
        graphics_path_begin(builder, Point2D(x: 0.0, y: 0.0))
        val ctrl = Point2D(x: 50.0, y: 50.0)
        val to = Point2D(x: 100.0, y: 0.0)
        val success = graphics_path_quadratic_to(builder, ctrl, to)
        expect(success).to_equal(true)
        graphics_path_builder_free(builder)

    it "adds cubic bezier":
        val builder = graphics_path_builder_new()
        graphics_path_begin(builder, Point2D(x: 0.0, y: 0.0))
        val ctrl1 = Point2D(x: 33.0, y: 50.0)
        val ctrl2 = Point2D(x: 67.0, y: 50.0)
        val to = Point2D(x: 100.0, y: 0.0)
        val success = graphics_path_cubic_to(builder, ctrl1, ctrl2, to)
        expect(success).to_equal(true)
        graphics_path_builder_free(builder)

    it "adds arc to path":
        val builder = graphics_path_builder_new()
        graphics_path_begin(builder, Point2D(x: 100.0, y: 0.0))
        val center = Point2D(x: 0.0, y: 0.0)
        val success = graphics_path_arc_to(builder, center, 100.0, 0.0, 1.5707963)
        expect(success).to_equal(true)
        graphics_path_builder_free(builder)

    it "closes path":
        val builder = graphics_path_builder_new()
        graphics_path_begin(builder, Point2D(x: 0.0, y: 0.0))
        graphics_path_line_to(builder, Point2D(x: 100.0, y: 0.0))
        graphics_path_line_to(builder, Point2D(x: 100.0, y: 100.0))
        val success = graphics_path_close(builder)
        expect(success).to_equal(true)
        graphics_path_builder_free(builder)

    it "builds path from builder":
        val builder = graphics_path_builder_new()
        graphics_path_begin(builder, Point2D(x: 0.0, y: 0.0))
        graphics_path_line_to(builder, Point2D(x: 100.0, y: 0.0))
        val path = graphics_path_build(builder)
        expect(path.is_valid).to_equal(true)
        graphics_path_free(path)
        graphics_path_builder_free(builder)

describe "Path Operations":
    """
    Tests for path operations and queries.
    """
    it "frees path":
        val builder = graphics_path_builder_new()
        graphics_path_begin(builder, Point2D(x: 0.0, y: 0.0))
        graphics_path_line_to(builder, Point2D(x: 100.0, y: 100.0))
        val path = graphics_path_build(builder)
        val success = graphics_path_free(path)
        expect(success).to_equal(true)
        graphics_path_builder_free(builder)

    it "gets path bounds":
        val builder = graphics_path_builder_new()
        graphics_path_begin(builder, Point2D(x: 10.0, y: 20.0))
        graphics_path_line_to(builder, Point2D(x: 110.0, y: 70.0))
        val path = graphics_path_build(builder)
        val bounds = graphics_path_get_bounds(path)
        expect(bounds.min_x).to_equal(10.0)
        expect(bounds.min_y).to_equal(20.0)
        graphics_path_free(path)
        graphics_path_builder_free(builder)

    it "tests point containment in closed path":
        val rect = graphics_rectangle(Rect(x: 0.0, y: 0.0, width: 100.0, height: 100.0))
        val inside = graphics_path_contains_point(rect, Point2D(x: 50.0, y: 50.0))
        val outside = graphics_path_contains_point(rect, Point2D(x: 150.0, y: 150.0))
        expect(inside).to_equal(true)
        expect(outside).to_equal(false)
        graphics_path_free(rect)

describe "Shape Primitives - Rectangle":
    """
    Tests for rectangle shape creation.
    """
    it "creates rectangle":
        val rect = graphics_rectangle(Rect(x: 10.0, y: 20.0, width: 100.0, height: 50.0))
        expect(rect.is_valid).to_equal(true)
        graphics_path_free(rect)

    it "creates rounded rectangle":
        val rect = graphics_rounded_rectangle(Rect(x: 10.0, y: 20.0, width: 100.0, height: 50.0), 5.0)
        expect(rect.is_valid).to_equal(true)
        graphics_path_free(rect)

    it "rectangle has correct bounds":
        val rect = graphics_rectangle(Rect(x: 10.0, y: 20.0, width: 100.0, height: 50.0))
        val bounds = graphics_path_get_bounds(rect)
        expect(bounds.min_x).to_equal(10.0)
        expect(bounds.min_y).to_equal(20.0)
        expect(bounds.max_x).to_equal(110.0)
        expect(bounds.max_y).to_equal(70.0)
        graphics_path_free(rect)

describe "Shape Primitives - Circle and Ellipse":
    """
    Tests for circle and ellipse shapes.
    """
    it "creates circle":
        val circle = graphics_circle(Point2D(x: 50.0, y: 50.0), 25.0)
        expect(circle.is_valid).to_equal(true)
        graphics_path_free(circle)

    it "creates ellipse":
        val ellipse = graphics_ellipse(Point2D(x: 50.0, y: 50.0), 40.0, 20.0)
        expect(ellipse.is_valid).to_equal(true)
        graphics_path_free(ellipse)

    it "circle contains center point":
        val circle = graphics_circle(Point2D(x: 50.0, y: 50.0), 25.0)
        val contains = graphics_path_contains_point(circle, Point2D(x: 50.0, y: 50.0))
        expect(contains).to_equal(true)
        graphics_path_free(circle)

describe "Shape Primitives - Polygon and Star":
    """
    Tests for polygon and star shapes.
    """
    it "creates triangle polygon":
        val points = [
            Point2D(x: 0.0, y: 0.0),
            Point2D(x: 100.0, y: 0.0),
            Point2D(x: 50.0, y: 86.6)
        ]
        val polygon = graphics_polygon(points)
        expect(polygon.is_valid).to_equal(true)
        graphics_path_free(polygon)

    it "creates star":
        val star = graphics_star(Point2D(x: 50.0, y: 50.0), 20.0, 40.0, 5)
        expect(star.is_valid).to_equal(true)
        graphics_path_free(star)

    it "creates hexagon":
        var points: [Point2D] = []
        for i in 0..6:
            val angle = i * 1.0471975  # 60 degrees in radians
            val x = 50.0 + 30.0 * angle.cos()
            val y = 50.0 + 30.0 * angle.sin()
            points.push(Point2D(x: x, y: y))
        val hexagon = graphics_polygon(points)
        expect(hexagon.is_valid).to_equal(true)
        graphics_path_free(hexagon)

describe "Fill Tessellation - Basic Fill":
    """
    Tests for basic fill tessellation.
    """
    it "tessellates rectangle fill":
        val rect = graphics_rectangle(Rect(x: 0.0, y: 0.0, width: 100.0, height: 50.0))
        val tess = graphics_fill_tessellate(rect, 0.1)
        expect(tess.is_valid).to_equal(true)
        graphics_fill_free(tess)
        graphics_path_free(rect)

    it "tessellates circle fill":
        val circle = graphics_circle(Point2D(x: 50.0, y: 50.0), 25.0)
        val tess = graphics_fill_tessellate(circle, 0.1)
        expect(tess.is_valid).to_equal(true)
        graphics_fill_free(tess)
        graphics_path_free(circle)

describe "Fill Tessellation - Fill Rules":
    """
    Tests for fill tessellation with different fill rules.
    """
    it "tessellates with even-odd rule":
        val circle = graphics_circle(Point2D(x: 50.0, y: 50.0), 25.0)
        val tess = graphics_fill_tessellate_with_rule(circle, 0.1, FillRule.EvenOdd)
        expect(tess.is_valid).to_equal(true)
        graphics_fill_free(tess)
        graphics_path_free(circle)

    it "tessellates with non-zero rule":
        val circle = graphics_circle(Point2D(x: 50.0, y: 50.0), 25.0)
        val tess = graphics_fill_tessellate_with_rule(circle, 0.1, FillRule.NonZero)
        expect(tess.is_valid).to_equal(true)
        graphics_fill_free(tess)
        graphics_path_free(circle)

describe "Fill Tessellation - Vertex and Index Counts":
    """
    Tests for querying fill tessellation vertex and index counts.
    """
    it "gets fill vertex count":
        val rect = graphics_rectangle(Rect(x: 0.0, y: 0.0, width: 100.0, height: 50.0))
        val tess = graphics_fill_tessellate(rect, 0.1)
        val count = graphics_fill_vertex_count(tess)
        expect(count).to_be_greater_than(0)
        graphics_fill_free(tess)
        graphics_path_free(rect)

    it "gets fill index count":
        val rect = graphics_rectangle(Rect(x: 0.0, y: 0.0, width: 100.0, height: 50.0))
        val tess = graphics_fill_tessellate(rect, 0.1)
        val count = graphics_fill_index_count(tess)
        expect(count).to_be_greater_than(0)
        graphics_fill_free(tess)
        graphics_path_free(rect)

    it "gets vertices from fill tessellation":
        val rect = graphics_rectangle(Rect(x: 0.0, y: 0.0, width: 100.0, height: 50.0))
        val tess = graphics_fill_tessellate(rect, 0.1)
        val vertices = graphics_fill_get_vertices(tess)
        expect(vertices.is_valid).to_equal(true)
        graphics_vertex_buffer_free(vertices)
        graphics_fill_free(tess)
        graphics_path_free(rect)

    it "gets indices from fill tessellation":
        val rect = graphics_rectangle(Rect(x: 0.0, y: 0.0, width: 100.0, height: 50.0))
        val tess = graphics_fill_tessellate(rect, 0.1)
        val indices = graphics_fill_get_indices(tess)
        expect(indices.is_valid).to_equal(true)
        graphics_index_buffer_free(indices)
        graphics_fill_free(tess)
        graphics_path_free(rect)

describe "Stroke Tessellation - Basic Stroke":
    """
    Tests for basic stroke tessellation.
    """
    it "tessellates line stroke":
        val builder = graphics_path_builder_new()
        graphics_path_begin(builder, Point2D(x: 0.0, y: 0.0))
        graphics_path_line_to(builder, Point2D(x: 100.0, y: 0.0))
        val path = graphics_path_build(builder)
        val tess = graphics_stroke_tessellate(path, 2.0, 0.1)
        expect(tess.is_valid).to_equal(true)
        graphics_stroke_free(tess)
        graphics_path_free(path)
        graphics_path_builder_free(builder)

    it "tessellates circle stroke":
        val circle = graphics_circle(Point2D(x: 50.0, y: 50.0), 25.0)
        val tess = graphics_stroke_tessellate(circle, 3.0, 0.1)
        expect(tess.is_valid).to_equal(true)
        graphics_stroke_free(tess)
        graphics_path_free(circle)

describe "Stroke Tessellation - Stroke Options":
    """
    Tests for stroke tessellation with options.
    """
    it "creates default stroke options":
        val options = stroke_options_default()
        expect(options.width).to_equal(1.0)
        expect(options.line_cap).to_equal(LineCap.Butt)
        expect(options.line_join).to_equal(LineJoin.Miter)

    it "tessellates with round cap":
        val circle = graphics_circle(Point2D(x: 50.0, y: 50.0), 25.0)
        var options = stroke_options_default()
        options.width = 5.0
        options.line_cap = LineCap.Round
        val tess = graphics_stroke_tessellate_with_options(circle, options, 0.1)
        expect(tess.is_valid).to_equal(true)
        graphics_stroke_free(tess)
        graphics_path_free(circle)

    it "tessellates with bevel join":
        val rect = graphics_rectangle(Rect(x: 0.0, y: 0.0, width: 100.0, height: 50.0))
        var options = stroke_options_default()
        options.width = 4.0
        options.line_join = LineJoin.Bevel
        val tess = graphics_stroke_tessellate_with_options(rect, options, 0.1)
        expect(tess.is_valid).to_equal(true)
        graphics_stroke_free(tess)
        graphics_path_free(rect)

describe "Stroke Tessellation - Vertex and Index Counts":
    """
    Tests for querying stroke tessellation vertex and index counts.
    """
    it "gets stroke vertex count":
        val circle = graphics_circle(Point2D(x: 50.0, y: 50.0), 25.0)
        val tess = graphics_stroke_tessellate(circle, 2.0, 0.1)
        val count = graphics_stroke_vertex_count(tess)
        expect(count).to_be_greater_than(0)
        graphics_stroke_free(tess)
        graphics_path_free(circle)

    it "gets stroke index count":
        val circle = graphics_circle(Point2D(x: 50.0, y: 50.0), 25.0)
        val tess = graphics_stroke_tessellate(circle, 2.0, 0.1)
        val count = graphics_stroke_index_count(tess)
        expect(count).to_be_greater_than(0)
        graphics_stroke_free(tess)
        graphics_path_free(circle)

    it "gets vertices from stroke tessellation":
        val circle = graphics_circle(Point2D(x: 50.0, y: 50.0), 25.0)
        val tess = graphics_stroke_tessellate(circle, 2.0, 0.1)
        val vertices = graphics_stroke_get_vertices(tess)
        expect(vertices.is_valid).to_equal(true)
        graphics_vertex_buffer_free(vertices)
        graphics_stroke_free(tess)
        graphics_path_free(circle)

    it "gets indices from stroke tessellation":
        val circle = graphics_circle(Point2D(x: 50.0, y: 50.0), 25.0)
        val tess = graphics_stroke_tessellate(circle, 2.0, 0.1)
        val indices = graphics_stroke_get_indices(tess)
        expect(indices.is_valid).to_equal(true)
        graphics_index_buffer_free(indices)
        graphics_stroke_free(tess)
        graphics_path_free(circle)

describe "Vertex Buffer":
    """
    Tests for vertex buffer operations.
    """
    it "gets vertex buffer size":
        val rect = graphics_rectangle(Rect(x: 0.0, y: 0.0, width: 100.0, height: 50.0))
        val tess = graphics_fill_tessellate(rect, 0.1)
        val vertices = graphics_fill_get_vertices(tess)
        val size = graphics_vertex_buffer_size(vertices)
        expect(size).to_be_greater_than(0)
        graphics_vertex_buffer_free(vertices)
        graphics_fill_free(tess)
        graphics_path_free(rect)

    it "gets vertex position":
        val rect = graphics_rectangle(Rect(x: 0.0, y: 0.0, width: 100.0, height: 50.0))
        val tess = graphics_fill_tessellate(rect, 0.1)
        val vertices = graphics_fill_get_vertices(tess)
        val pos = graphics_vertex_buffer_get_position(vertices, 0)
        # Position should be within bounds
        expect(pos.x).to_be_greater_than(-1.0)
        expect(pos.y).to_be_greater_than(-1.0)
        graphics_vertex_buffer_free(vertices)
        graphics_fill_free(tess)
        graphics_path_free(rect)

    it "gets vertex normal":
        val circle = graphics_circle(Point2D(x: 50.0, y: 50.0), 25.0)
        val tess = graphics_stroke_tessellate(circle, 2.0, 0.1)
        val vertices = graphics_stroke_get_vertices(tess)
        val normal = graphics_vertex_buffer_get_normal(vertices, 0)
        # Normal should be a unit-ish vector
        expect(normal.x).to_be_greater_than(-2.0)
        expect(normal.x).to_be_less_than(2.0)
        graphics_vertex_buffer_free(vertices)
        graphics_stroke_free(tess)
        graphics_path_free(circle)

    it "converts vertex buffer to array":
        val rect = graphics_rectangle(Rect(x: 0.0, y: 0.0, width: 100.0, height: 50.0))
        val tess = graphics_fill_tessellate(rect, 0.1)
        val vertices = graphics_fill_get_vertices(tess)
        val array = graphics_vertex_buffer_to_array(vertices)
        expect(array.len()).to_be_greater_than(0)
        graphics_vertex_buffer_free(vertices)
        graphics_fill_free(tess)
        graphics_path_free(rect)

describe "Index Buffer":
    """
    Tests for index buffer operations.
    """
    it "gets index buffer size":
        val rect = graphics_rectangle(Rect(x: 0.0, y: 0.0, width: 100.0, height: 50.0))
        val tess = graphics_fill_tessellate(rect, 0.1)
        val indices = graphics_fill_get_indices(tess)
        val size = graphics_index_buffer_size(indices)
        expect(size).to_be_greater_than(0)
        graphics_index_buffer_free(indices)
        graphics_fill_free(tess)
        graphics_path_free(rect)

    it "gets index value":
        val rect = graphics_rectangle(Rect(x: 0.0, y: 0.0, width: 100.0, height: 50.0))
        val tess = graphics_fill_tessellate(rect, 0.1)
        val indices = graphics_fill_get_indices(tess)
        val index = graphics_index_buffer_get(indices, 0)
        # Index should be a valid vertex index
        expect(index).to_be_greater_than(-1)
        graphics_index_buffer_free(indices)
        graphics_fill_free(tess)
        graphics_path_free(rect)

    it "converts index buffer to array":
        val rect = graphics_rectangle(Rect(x: 0.0, y: 0.0, width: 100.0, height: 50.0))
        val tess = graphics_fill_tessellate(rect, 0.1)
        val indices = graphics_fill_get_indices(tess)
        val array = graphics_index_buffer_to_array(indices)
        expect(array.len()).to_be_greater_than(0)
        graphics_index_buffer_free(indices)
        graphics_fill_free(tess)
        graphics_path_free(rect)

describe "Transform - Creation":
    """
    Tests for transform creation.
    """
    it "creates identity transform":
        val transform = graphics_transform_identity()
        expect(transform.is_valid).to_equal(true)
        graphics_transform_free(transform)

    it "creates translation transform":
        val offset = Vector2D(x: 50.0, y: 30.0)
        val transform = graphics_transform_translate(offset)
        expect(transform.is_valid).to_equal(true)
        graphics_transform_free(transform)

    it "creates rotation transform":
        val angle = 1.5707963  # 90 degrees
        val transform = graphics_transform_rotate(angle)
        expect(transform.is_valid).to_equal(true)
        graphics_transform_free(transform)

    it "creates scale transform":
        val scale = Vector2D(x: 2.0, y: 1.5)
        val transform = graphics_transform_scale(scale)
        expect(transform.is_valid).to_equal(true)
        graphics_transform_free(transform)

describe "Transform - Composition":
    """
    Tests for transform composition.
    """
    it "multiplies transforms":
        val t1 = graphics_transform_translate(Vector2D(x: 10.0, y: 20.0))
        val t2 = graphics_transform_scale(Vector2D(x: 2.0, y: 2.0))
        val result = graphics_transform_multiply(t1, t2)
        expect(result.is_valid).to_equal(true)
        graphics_transform_free(result)
        graphics_transform_free(t1)
        graphics_transform_free(t2)

    it "chains multiple transforms":
        val translate = graphics_transform_translate(Vector2D(x: 50.0, y: 0.0))
        val rotate = graphics_transform_rotate(0.785398)  # 45 degrees
        val scale = graphics_transform_scale(Vector2D(x: 1.5, y: 1.5))
        var combined = graphics_transform_multiply(translate, rotate)
        val final_transform = graphics_transform_multiply(combined, scale)
        expect(final_transform.is_valid).to_equal(true)
        graphics_transform_free(final_transform)
        graphics_transform_free(combined)
        graphics_transform_free(translate)
        graphics_transform_free(rotate)
        graphics_transform_free(scale)

describe "Transform - Path Transformation":
    """
    Tests for applying transforms to paths.
    """
    it "transforms rectangle":
        val rect = graphics_rectangle(Rect(x: 0.0, y: 0.0, width: 100.0, height: 50.0))
        val transform = graphics_transform_translate(Vector2D(x: 50.0, y: 30.0))
        val transformed = graphics_path_transform(rect, transform)
        expect(transformed.is_valid).to_equal(true)
        graphics_path_free(transformed)
        graphics_transform_free(transform)
        graphics_path_free(rect)

    it "transforms circle":
        val circle = graphics_circle(Point2D(x: 0.0, y: 0.0), 25.0)
        val transform = graphics_transform_scale(Vector2D(x: 2.0, y: 2.0))
        val transformed = graphics_path_transform(circle, transform)
        expect(transformed.is_valid).to_equal(true)
        graphics_path_free(transformed)
        graphics_transform_free(transform)
        graphics_path_free(circle)
