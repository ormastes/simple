# Tag Generator Tests
# Tests for documentation coverage tag generation

use std.spec.{describe, it, expect}
use doc_coverage.tagging.tag_generator.{generate_coverage_tag, generate_doc_status_tags, generate_scope_tag, generate_api_tag, generate_all_tags, filter_items_by_tag, get_unique_tags}
use doc_coverage.types.doc_item.{DocItem, DocKind}

# ============================================================================
# Helper Functions
# ============================================================================

fn create_test_function(name: text, file: text, has_inline: bool, has_doc: bool, has_test: bool, is_public: bool, is_exported: bool) -> DocItem:
    var item = DocItem.create_function(name, file, 10, 5, "pub", "fn {name}() -> i64")
    item.has_inline_comment = has_inline
    item.has_docstring = has_doc
    item.has_sdoctest = has_test
    item.is_public = is_public
    item.is_exported = is_exported
    item

fn create_test_struct(name: text, file: text, has_doc: bool) -> DocItem:
    var item = DocItem.create_struct(name, file, 20, 5, "pub")
    item.has_docstring = has_doc
    item

# ============================================================================
# Tests for generate_coverage_tag
# ============================================================================

describe "generate_coverage_tag":
    it "returns excellent for 100% coverage":
        val tag = generate_coverage_tag(100)
        expect(tag).to_equal("coverage:excellent")

    it "returns excellent for 95% coverage":
        val tag = generate_coverage_tag(95)
        expect(tag).to_equal("coverage:excellent")

    it "returns good for 94% coverage":
        val tag = generate_coverage_tag(94)
        expect(tag).to_equal("coverage:good")

    it "returns good for 80% coverage":
        val tag = generate_coverage_tag(80)
        expect(tag).to_equal("coverage:good")

    it "returns acceptable for 79% coverage":
        val tag = generate_coverage_tag(79)
        expect(tag).to_equal("coverage:acceptable")

    it "returns acceptable for 60% coverage":
        val tag = generate_coverage_tag(60)
        expect(tag).to_equal("coverage:acceptable")

    it "returns poor for 59% coverage":
        val tag = generate_coverage_tag(59)
        expect(tag).to_equal("coverage:poor")

    it "returns poor for 40% coverage":
        val tag = generate_coverage_tag(40)
        expect(tag).to_equal("coverage:poor")

    it "returns insufficient for 39% coverage":
        val tag = generate_coverage_tag(39)
        expect(tag).to_equal("coverage:insufficient")

    it "returns insufficient for 0% coverage":
        val tag = generate_coverage_tag(0)
        expect(tag).to_equal("coverage:insufficient")

# ============================================================================
# Tests for generate_doc_status_tags
# ============================================================================

describe "generate_doc_status_tags":
    it "returns complete for fully documented public function":
        val item = create_test_function("foo", "/src/std/test.spl", true, true, true, true, true)
        val tags = generate_doc_status_tags(item)

        expect(tags.len()).to_equal(1)
        expect(tags[0]).to_equal("doc:complete")

    it "returns incomplete for public function missing sdoctest":
        val item = create_test_function("foo", "/src/std/test.spl", true, true, false, true, true)
        val tags = generate_doc_status_tags(item)

        var has_incomplete = false
        var has_missing_sdoctest = false

        for tag in tags:
            if tag == "doc:incomplete":
                has_incomplete = true
            if tag == "doc:missing_sdoctest":
                has_missing_sdoctest = true

        expect(has_incomplete).to_equal(true)
        expect(has_missing_sdoctest).to_equal(true)

    it "returns incomplete for function missing inline comment":
        val item = create_test_function("foo", "/src/std/test.spl", false, true, true, true, true)
        val tags = generate_doc_status_tags(item)

        var has_incomplete = false
        var has_missing_inline = false

        for tag in tags:
            if tag == "doc:incomplete":
                has_incomplete = true
            if tag == "doc:missing_inline_comment":
                has_missing_inline = true

        expect(has_incomplete).to_equal(true)
        expect(has_missing_inline).to_equal(true)

    it "returns complete for private function with inline or docstring":
        val item = create_test_function("_private", "/src/std/test.spl", true, false, false, false, false)
        val tags = generate_doc_status_tags(item)

        expect(tags.len()).to_equal(1)
        expect(tags[0]).to_equal("doc:complete")

    it "returns incomplete for completely undocumented function":
        val item = create_test_function("foo", "/src/std/test.spl", false, false, false, true, true)
        val tags = generate_doc_status_tags(item)

        var has_incomplete = false
        var has_missing_inline = false
        var has_missing_sdoctest = false

        for tag in tags:
            if tag == "doc:incomplete":
                has_incomplete = true
            if tag == "doc:missing_inline_comment":
                has_missing_inline = true
            if tag == "doc:missing_sdoctest":
                has_missing_sdoctest = true

        expect(has_incomplete).to_equal(true)
        expect(has_missing_inline).to_equal(true)
        expect(has_missing_sdoctest).to_equal(true)

    it "handles struct with docstring as complete":
        val item = create_test_struct("Point", "/src/std/test.spl", true)
        val tags = generate_doc_status_tags(item)

        expect(tags[0]).to_equal("doc:complete")

    it "handles struct without docstring as incomplete":
        val item = create_test_struct("Point", "/src/std/test.spl", false)
        val tags = generate_doc_status_tags(item)

        var has_incomplete = false
        var has_missing_inline = false

        for tag in tags:
            if tag == "doc:incomplete":
                has_incomplete = true
            if tag == "doc:missing_inline_comment":
                has_missing_inline = true

        expect(has_incomplete).to_equal(true)
        expect(has_missing_inline).to_equal(true)

# ============================================================================
# Tests for generate_scope_tag
# ============================================================================

describe "generate_scope_tag":
    it "returns stdlib for src/std/ path":
        val tag = generate_scope_tag("/home/user/project/src/std/string.spl")
        expect(tag).to_equal("scope:stdlib")

    it "returns core for src/core/ path":
        val tag = generate_scope_tag("/home/user/project/src/core/parser.spl")
        expect(tag).to_equal("scope:core")

    it "returns lib for src/lib/ path":
        val tag = generate_scope_tag("/home/user/project/src/lib/database/core.spl")
        expect(tag).to_equal("scope:lib")

    it "returns app for src/app/ path":
        val tag = generate_scope_tag("/home/user/project/src/app/cli/main.spl")
        expect(tag).to_equal("scope:app")

    it "returns compiler for src/compiler/ path":
        val tag = generate_scope_tag("/home/user/project/src/compiler/backend/native.spl")
        expect(tag).to_equal("scope:compiler")

    it "returns unknown for unrecognized path":
        val tag = generate_scope_tag("/home/user/other/file.spl")
        expect(tag).to_equal("scope:unknown")

    it "handles relative paths":
        val tag = generate_scope_tag("src/std/spec.spl")
        expect(tag).to_equal("scope:stdlib")

# ============================================================================
# Tests for generate_api_tag
# ============================================================================

describe "generate_api_tag":
    it "returns public for exported function":
        val tag = generate_api_tag(true)
        expect(tag).to_equal("api:public")

    it "returns internal for non-exported function":
        val tag = generate_api_tag(false)
        expect(tag).to_equal("api:internal")

# ============================================================================
# Tests for generate_all_tags
# ============================================================================

describe "generate_all_tags":
    it "generates all tags for fully documented public function":
        val item = create_test_function("add", "/home/user/src/std/math.spl", true, true, true, true, true)
        val tags = generate_all_tags(item)

        var has_scope = false
        var has_api = false
        var has_doc = false
        var has_kind = false

        for tag in tags:
            if tag == "scope:stdlib":
                has_scope = true
            if tag == "api:public":
                has_api = true
            if tag == "doc:complete":
                has_doc = true
            if tag == "kind:function":
                has_kind = true

        expect(has_scope).to_equal(true)
        expect(has_api).to_equal(true)
        expect(has_doc).to_equal(true)
        expect(has_kind).to_equal(true)

    it "generates correct tags for undocumented internal function":
        val item = create_test_function("_helper", "/home/user/src/app/cli/main.spl", false, false, false, false, false)
        val tags = generate_all_tags(item)

        var has_scope_app = false
        var has_api_internal = false
        var has_kind_func = false

        for tag in tags:
            if tag == "scope:app":
                has_scope_app = true
            if tag == "api:internal":
                has_api_internal = true
            if tag == "kind:function":
                has_kind_func = true

        expect(has_scope_app).to_equal(true)
        expect(has_api_internal).to_equal(true)
        expect(has_kind_func).to_equal(true)

    it "includes multiple doc status tags when appropriate":
        val item = create_test_function("foo", "/home/user/src/core/lexer.spl", false, false, false, true, true)
        val tags = generate_all_tags(item)

        var has_incomplete = false
        var has_missing_inline = false
        var has_missing_sdoctest = false

        for tag in tags:
            if tag == "doc:incomplete":
                has_incomplete = true
            if tag == "doc:missing_inline_comment":
                has_missing_inline = true
            if tag == "doc:missing_sdoctest":
                has_missing_sdoctest = true

        expect(has_incomplete).to_equal(true)
        expect(has_missing_inline).to_equal(true)
        expect(has_missing_sdoctest).to_equal(true)

# ============================================================================
# Tests for filter_items_by_tag
# ============================================================================

describe "filter_items_by_tag":
    it "filters items by scope tag":
        val item1 = create_test_function("foo", "/src/std/test.spl", true, true, true, true, true)
        val item2 = create_test_function("bar", "/src/core/test.spl", true, true, true, true, true)
        val item3 = create_test_function("baz", "/src/std/other.spl", true, true, true, true, true)

        val items: [DocItem] = [item1, item2, item3]
        val filtered = filter_items_by_tag(items, "scope:stdlib")

        expect(filtered.len()).to_equal(2)

    it "filters items by doc status tag":
        val item1 = create_test_function("foo", "/src/std/test.spl", true, true, true, true, true)
        val item2 = create_test_function("bar", "/src/std/test.spl", false, false, false, true, true)
        val item3 = create_test_function("baz", "/src/std/test.spl", true, true, false, true, true)

        val items: [DocItem] = [item1, item2, item3]
        val filtered = filter_items_by_tag(items, "doc:complete")

        expect(filtered.len()).to_equal(1)

    it "returns empty array when no items match":
        val item1 = create_test_function("foo", "/src/std/test.spl", true, true, true, true, true)
        val item2 = create_test_function("bar", "/src/std/test.spl", true, true, true, true, true)

        val items: [DocItem] = [item1, item2]
        val filtered = filter_items_by_tag(items, "scope:compiler")

        expect(filtered.len()).to_equal(0)

    it "handles empty input array":
        val items: [DocItem] = []
        val filtered = filter_items_by_tag(items, "scope:stdlib")

        expect(filtered.len()).to_equal(0)

# ============================================================================
# Tests for get_unique_tags
# ============================================================================

describe "get_unique_tags":
    it "returns unique tags from multiple items":
        val item1 = create_test_function("foo", "/src/std/test.spl", true, true, true, true, true)
        val item2 = create_test_function("bar", "/src/core/test.spl", false, false, false, true, true)

        val items: [DocItem] = [item1, item2]
        val tags = get_unique_tags(items)

        var has_stdlib = false
        var has_core = false

        for tag in tags:
            if tag == "scope:stdlib":
                has_stdlib = true
            if tag == "scope:core":
                has_core = true

        expect(has_stdlib).to_equal(true)
        expect(has_core).to_equal(true)

    it "does not duplicate tags":
        val item1 = create_test_function("foo", "/src/std/test.spl", true, true, true, true, true)
        val item2 = create_test_function("bar", "/src/std/test.spl", true, true, true, true, true)

        val items: [DocItem] = [item1, item2]
        val tags = get_unique_tags(items)

        var count_stdlib = 0
        for tag in tags:
            if tag == "scope:stdlib":
                count_stdlib = count_stdlib + 1

        expect(count_stdlib).to_equal(1)

    it "handles empty input array":
        val items: [DocItem] = []
        val tags = get_unique_tags(items)

        expect(tags.len()).to_equal(0)

    it "includes all tag categories":
        val item = create_test_function("foo", "/src/std/test.spl", true, true, true, true, true)
        val items: [DocItem] = [item]
        val tags = get_unique_tags(items)

        var has_scope = false
        var has_api = false
        var has_doc = false
        var has_kind = false

        for tag in tags:
            if tag.starts_with("scope:"):
                has_scope = true
            if tag.starts_with("api:"):
                has_api = true
            if tag.starts_with("doc:"):
                has_doc = true
            if tag.starts_with("kind:"):
                has_kind = true

        expect(has_scope).to_equal(true)
        expect(has_api).to_equal(true)
        expect(has_doc).to_equal(true)
        expect(has_kind).to_equal(true)
