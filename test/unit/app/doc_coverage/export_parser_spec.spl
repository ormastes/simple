# Export Parser Tests
# Tests for public API detection via __init__.spl and mod.spl parsing

use std.spec.{describe, it, expect}
use doc_coverage.analysis.export_parser.{find_module_init, parse_exports, is_function_exported, extract_export_names}
use app.io.mod (cwd)

# ============================================================================
# Helper Functions
# ============================================================================

fn fixture_path(relative_path: text) -> text:
    val base = cwd()
    base + "/test/fixtures/doc_coverage/" + relative_path

# ============================================================================
# Tests for find_module_init
# ============================================================================

describe "find_module_init":
    it "finds __init__.spl in parent directory":
        val file_path = fixture_path("sample_module/feature.spl")
        val result = find_module_init(file_path)

        expect(result).not_to_be_nil()
        val ends_init = result.ends_with("__init__.spl")
        expect(ends_init).to_equal(true)

    it "finds mod.spl in current directory":
        val file_path = fixture_path("mod_example/helpers.spl")
        val result = find_module_init(file_path)

        expect(result).not_to_be_nil()
        val ends_mod = result.ends_with("mod.spl")
        expect(ends_mod).to_equal(true)

    it "returns nil when no module file exists":
        val file_path = fixture_path("no_module/standalone.spl")
        val result = find_module_init(file_path)

        # Should be nil since no __init__.spl or mod.spl exists
        # Note: Might find a parent module if one exists higher up
        # For this test, we just verify it doesn't crash
        val not_crashed = true
        expect(not_crashed).to_equal(true)

    it "handles nil input gracefully":
        val result = find_module_init(nil)
        expect(result).to_be_nil()

    it "handles empty string input gracefully":
        val result = find_module_init("")
        expect(result).to_be_nil()

# ============================================================================
# Tests for extract_export_names
# ============================================================================

describe "extract_export_names":
    it "extracts names from simple export statement":
        val line = "export Foo, Bar"
        val names = extract_export_names(line)

        expect(names.len()).to_equal(2)
        expect(names[0]).to_equal("Foo")
        expect(names[1]).to_equal("Bar")

    it "extracts names from export with spaces":
        val line = "export   Foo  ,  Bar  ,  Baz  "
        val names = extract_export_names(line)

        expect(names.len()).to_equal(3)
        expect(names[0]).to_equal("Foo")
        expect(names[1]).to_equal("Bar")
        expect(names[2]).to_equal("Baz")

    it "handles export with curly braces":
        val line = "export {Foo, Bar}"
        val names = extract_export_names(line)

        expect(names.len()).to_equal(2)
        expect(names[0]).to_equal("Foo")
        expect(names[1]).to_equal("Bar")

    it "handles single name export":
        val line = "export SingleName"
        val names = extract_export_names(line)

        expect(names.len()).to_equal(1)
        expect(names[0]).to_equal("SingleName")

    it "handles export with curly braces and spaces":
        val line = "export { Foo , Bar , Baz }"
        val names = extract_export_names(line)

        expect(names.len()).to_equal(3)
        expect(names[0]).to_equal("Foo")
        expect(names[1]).to_equal("Bar")
        expect(names[2]).to_equal("Baz")

    it "returns empty array for non-export line":
        val line = "use module.{function}"
        val names = extract_export_names(line)

        expect(names.len()).to_equal(0)

    it "returns empty array for comment line":
        val line = "# export Foo"
        val names = extract_export_names(line)

        expect(names.len()).to_equal(0)

# ============================================================================
# Tests for parse_exports
# ============================================================================

describe "parse_exports":
    it "parses exports from __init__.spl":
        val module_file = fixture_path("sample_module/__init__.spl")
        val exports = parse_exports(module_file)

        expect(exports.len()).to_equal(2)
        # Should contain public_function and PublicStruct
        var has_public_func = false
        var has_public_struct = false

        for name in exports:
            if name == "public_function":
                has_public_func = true
            if name == "PublicStruct":
                has_public_struct = true

        expect(has_public_func).to_equal(true)
        expect(has_public_struct).to_equal(true)

    it "parses exports from mod.spl with multiple styles":
        val module_file = fixture_path("mod_example/mod.spl")
        val exports = parse_exports(module_file)

        expect(exports.len()).to_equal(3)
        # Should contain helper_one, helper_two, helper_three
        var has_one = false
        var has_two = false
        var has_three = false

        for name in exports:
            if name == "helper_one":
                has_one = true
            if name == "helper_two":
                has_two = true
            if name == "helper_three":
                has_three = true

        expect(has_one).to_equal(true)
        expect(has_two).to_equal(true)
        expect(has_three).to_equal(true)

    it "returns empty array for non-existent file":
        val module_file = fixture_path("nonexistent/mod.spl")
        val exports = parse_exports(module_file)

        expect(exports.len()).to_equal(0)

    it "ignores comment lines":
        val module_file = fixture_path("sample_module/__init__.spl")
        val exports = parse_exports(module_file)

        # Should not include any comments
        var has_comment = false
        for name in exports:
            if name.starts_with("#"):
                has_comment = true

        expect(has_comment).to_equal(false)

# ============================================================================
# Tests for is_function_exported
# ============================================================================

describe "is_function_exported":
    it "returns true for exported function":
        val source_file = fixture_path("sample_module/feature.spl")
        val is_exported = is_function_exported("public_function", source_file)

        expect(is_exported).to_equal(true)

    it "returns false for non-exported function":
        val source_file = fixture_path("sample_module/feature.spl")
        val is_exported = is_function_exported("_internal_helper", source_file)

        expect(is_exported).to_equal(false)

    it "returns true for exported struct":
        val source_file = fixture_path("sample_module/feature.spl")
        val is_exported = is_function_exported("PublicStruct", source_file)

        expect(is_exported).to_equal(true)

    it "returns false for non-exported struct":
        val source_file = fixture_path("sample_module/feature.spl")
        val is_exported = is_function_exported("InternalStruct", source_file)

        expect(is_exported).to_equal(false)

    it "returns false when no module file exists":
        val source_file = fixture_path("no_module/standalone.spl")
        val is_exported = is_function_exported("standalone_function", source_file)

        # Should return false since no module file defines exports
        expect(is_exported).to_equal(false)

    it "returns true for helper_one in mod_example":
        val source_file = fixture_path("mod_example/helpers.spl")
        val is_exported = is_function_exported("helper_one", source_file)

        expect(is_exported).to_equal(true)

    it "returns true for helper_two in mod_example":
        val source_file = fixture_path("mod_example/helpers.spl")
        val is_exported = is_function_exported("helper_two", source_file)

        expect(is_exported).to_equal(true)

    it "returns true for helper_three in mod_example":
        val source_file = fixture_path("mod_example/helpers.spl")
        val is_exported = is_function_exported("helper_three", source_file)

        expect(is_exported).to_equal(true)

    it "returns false for not_exported in mod_example":
        val source_file = fixture_path("mod_example/helpers.spl")
        val is_exported = is_function_exported("not_exported", source_file)

        expect(is_exported).to_equal(false)

# ============================================================================
# Integration Tests
# ============================================================================

describe "export_parser integration":
    it "correctly identifies public API across module hierarchy":
        # Test with real module structure
        val feature_file = fixture_path("sample_module/feature.spl")

        # Public function should be exported
        val public_is_exported = is_function_exported("public_function", feature_file)
        expect(public_is_exported).to_equal(true)

        # Internal helper should not be exported
        val internal_is_exported = is_function_exported("_internal_helper", feature_file)
        expect(internal_is_exported).to_equal(false)

        # Verify the module file was found
        val module_file = find_module_init(feature_file)
        expect(module_file).not_to_be_nil()

    it "handles multiple export statements in one file":
        val helpers_file = fixture_path("mod_example/helpers.spl")
        val module_file = find_module_init(helpers_file)

        expect(module_file).not_to_be_nil()

        val exports = parse_exports(module_file)
        # Should have 3 exports from 2 export statements
        expect(exports.len()).to_equal(3)
