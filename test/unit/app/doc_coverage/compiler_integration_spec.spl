# Compiler Integration Test for Documentation Warnings
#
# Tests the integration of doc warnings into the build pipeline.

use std.spec.{describe, it, expect}
use app.io.mod (file_write, file_read, dir_create, cwd, file_exists, shell)
use app.doc_coverage.compiler_warnings.{check_file_documentation, emit_doc_warnings, format_warning, check_multiple_files, emit_summary}
use app.doc_coverage.scanner.mod.{DocItem}
use std.string.{NL}

describe "Compiler Documentation Warnings":
    it "checks single file for missing documentation":
        # Create test file
        val test_file = "test_doc_warn.spl"
        val content = "fn undocumented_function():{NL}    42{NL}"

        val write_ok = file_write(test_file, content)
        expect(write_ok).to_equal(true)

        # Check for warnings
        val warnings = check_file_documentation(test_file)

        # Should find warning for undocumented function
        expect(warnings.len()).to_be_greater_than(0)

        # Cleanup
        val cleanup = shell("rm -f {test_file}")
        pass_do_nothing

    it "returns empty warnings for documented file":
        # Create test file with documentation
        val test_file = "test_doc_ok.spl"
        val content = "# This function is documented{NL}fn documented_function():{NL}    42{NL}"

        val write_ok = file_write(test_file, content)
        expect(write_ok).to_equal(true)

        # Check for warnings
        val warnings = check_file_documentation(test_file)

        # Should find no warnings
        expect(warnings.len()).to_equal(0)

        # Cleanup
        val cleanup = shell("rm -f {test_file}")
        pass_do_nothing

    it "formats warning message correctly":
        # Create test DocItem
        val item = DocItem(
            name: "test_fn",
            kind: "fn",
            file: "test.spl",
            line: 42,
            has_comment: false,
            has_docstring: false,
            comment_text: "",
            docstring_text: ""
        )

        val warning = format_warning(item)

        # Should contain function name
        expect(warning.contains("test_fn")).to_equal(true)

        # Should contain file and line
        expect(warning.contains("test.spl:42")).to_equal(true)

        # Should contain "missing documentation"
        expect(warning.contains("missing documentation")).to_equal(true)

    it "checks multiple files":
        # Create two test files
        val test_file1 = "test_multi1.spl"
        val test_file2 = "test_multi2.spl"

        val content1 = "fn undoc1():{NL}    1{NL}"
        val content2 = "# Documented{NL}fn doc2():{NL}    2{NL}"

        val write1 = file_write(test_file1, content1)
        val write2 = file_write(test_file2, content2)

        expect(write1).to_equal(true)
        expect(write2).to_equal(true)

        # Check both files
        val files = [test_file1, test_file2]
        val result = check_multiple_files(files)
        val all_warnings = result.0
        val files_with_warnings = result.1

        # Should find warnings in first file only
        expect(files_with_warnings.len()).to_equal(1)
        expect(all_warnings.len()).to_be_greater_than(0)

        # Cleanup
        val cleanup1 = shell("rm -f {test_file1}")
        val cleanup2 = shell("rm -f {test_file2}")
        pass_do_nothing

    it "handles non-existent file gracefully":
        val warnings = check_file_documentation("nonexistent_file_xyz.spl")

        # Should return empty array, not crash
        expect(warnings.len()).to_equal(0)

    it "detects undocumented struct":
        val test_file = "test_struct.spl"
        val content = "struct UndocumentedStruct:{NL}    field: i64{NL}"

        val write_ok = file_write(test_file, content)
        expect(write_ok).to_equal(true)

        val warnings = check_file_documentation(test_file)

        # Should find warning for struct
        expect(warnings.len()).to_be_greater_than(0)

        # Check warning mentions struct
        val first_warning = warnings[0]
        expect(first_warning.contains("struct")).to_equal(true)

        # Cleanup
        val cleanup = shell("rm -f {test_file}")
        pass_do_nothing

    it "detects undocumented class":
        val test_file = "test_class.spl"
        val content = "class UndocumentedClass:{NL}    field: i64{NL}"

        val write_ok = file_write(test_file, content)
        expect(write_ok).to_equal(true)

        val warnings = check_file_documentation(test_file)

        # Should find warning for class
        expect(warnings.len()).to_be_greater_than(0)

        # Cleanup
        val cleanup = shell("rm -f {test_file}")
        pass_do_nothing

    it "detects undocumented enum":
        val test_file = "test_enum.spl"
        val content = "enum UndocumentedEnum:{NL}    Variant1{NL}    Variant2{NL}"

        val write_ok = file_write(test_file, content)
        expect(write_ok).to_equal(true)

        val warnings = check_file_documentation(test_file)

        # Should find warning for enum
        expect(warnings.len()).to_be_greater_than(0)

        # Cleanup
        val cleanup = shell("rm -f {test_file}")
        pass_do_nothing
