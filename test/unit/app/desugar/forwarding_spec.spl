describe "Forwarding":
    it "skipped":
        skip("pre-existing test failures - functions/imports not available")

# # Forwarding Desugar Unit Tests
# #
# # Tests the forwarding desugar pass which transforms:
# # - fn name = target -> fn name(params): target(params) (DEPRECATED)
# # - alias fn NAME = FIELD.METHOD -> fn NAME(): self.FIELD.METHOD()
# # - alias me NAME = FIELD.METHOD -> me NAME(): self.FIELD.METHOD()
# # - alias TraitName = field -> forwarding methods for each trait method
# # - alias field_name -> blanket forwarding of all field type methods
# 
# use app.desugar.forwarding (desugar_forwarding)
# 
# describe "desugar_forwarding - Phase 2 alias fn/me":
# 
#     it "generates fn forwarding for no-arg method":
#         var src = "class Wrapper:" + "\n"
#         src = src + "    inner: Inner" + "\n"
#         src = src + "    alias fn len = inner.len" + "\n"
#         val out = desugar_forwarding(src)
#         expect(out).to_contain("fn len():")
#         expect(out).to_contain("self.inner.len()")
# 
#     it "generates fn forwarding with args":
#         var src = "class Wrapper:" + "\n"
#         src = src + "    inner: Inner" + "\n"
#         src = src + "    alias fn get(key, default) = inner.get" + "\n"
#         val out = desugar_forwarding(src)
#         expect(out).to_contain("fn get(key, default):")
#         expect(out).to_contain("self.inner.get(key, default)")
# 
#     it "generates me forwarding":
#         var src = "class Wrapper:" + "\n"
#         src = src + "    inner: Inner" + "\n"
#         src = src + "    alias me push(item) = inner.push" + "\n"
#         val out = desugar_forwarding(src)
#         expect(out).to_contain("me push(item):")
#         expect(out).to_contain("self.inner.push(item)")
# 
#     it "preserves non-alias lines":
#         var src = "class Wrapper:" + "\n"
#         src = src + "    inner: Inner" + "\n"
#         src = src + "    fn own_method() -> i64:" + "\n"
#         src = src + "        42" + "\n"
#         val out = desugar_forwarding(src)
#         expect(out).to_contain("fn own_method() -> i64:")
#         expect(out).to_contain("42")
# 
# describe "desugar_forwarding - Phase 3 alias Trait":
# 
#     it "generates forwarding for trait fn methods":
#         var src = "trait Sizeable:" + "\n"
#         src = src + "    fn size() -> i64" + "\n"
#         src = src + "    fn is_empty() -> bool" + "\n"
#         src = src + "\n"
#         src = src + "class MyList:" + "\n"
#         src = src + "    items: Storage" + "\n"
#         src = src + "    alias Sizeable = items" + "\n"
#         val out = desugar_forwarding(src)
#         expect(out).to_contain("fn size():")
#         expect(out).to_contain("self.items.size()")
#         expect(out).to_contain("fn is_empty():")
#         expect(out).to_contain("self.items.is_empty()")
# 
#     it "generates forwarding for trait me methods":
#         var src = "trait Writable:" + "\n"
#         src = src + "    me write(data: text)" + "\n"
#         src = src + "    me clear()" + "\n"
#         src = src + "\n"
#         src = src + "class Stream:" + "\n"
#         src = src + "    buf: Buffer" + "\n"
#         src = src + "    alias Writable = buf" + "\n"
#         val out = desugar_forwarding(src)
#         expect(out).to_contain("me write(data):")
#         expect(out).to_contain("self.buf.write(data)")
#         expect(out).to_contain("me clear():")
#         expect(out).to_contain("self.buf.clear()")
# 
#     it "skips default methods":
#         var src = "trait Eq:" + "\n"
#         src = src + "    fn eq(other: Self) -> bool" + "\n"
#         src = src + "    fn ne(other: Self) -> bool:" + "\n"
#         src = src + "        not self.eq(other)" + "\n"
#         src = src + "\n"
#         src = src + "class Point:" + "\n"
#         src = src + "    inner: Coord" + "\n"
#         src = src + "    alias Eq = inner" + "\n"
#         val out = desugar_forwarding(src)
#         # eq is abstract (no default) - should be forwarded
#         expect(out).to_contain("fn eq(other):")
#         expect(out).to_contain("self.inner.eq(other)")
#         # ne has a default - should NOT be forwarded
#         val has_ne_forward = out.contains("self.inner.ne(")
#         expect(has_ne_forward).to_equal(false)
# 
#     it "handles multiple trait aliases on same class":
#         var src = "trait Readable:" + "\n"
#         src = src + "    fn read() -> text" + "\n"
#         src = src + "\n"
#         src = src + "trait Closeable:" + "\n"
#         src = src + "    me close()" + "\n"
#         src = src + "\n"
#         src = src + "class FileStream:" + "\n"
#         src = src + "    reader: Reader" + "\n"
#         src = src + "    handle: Handle" + "\n"
#         src = src + "    alias Readable = reader" + "\n"
#         src = src + "    alias Closeable = handle" + "\n"
#         val out = desugar_forwarding(src)
#         expect(out).to_contain("fn read():")
#         expect(out).to_contain("self.reader.read()")
#         expect(out).to_contain("me close():")
#         expect(out).to_contain("self.handle.close()")
# 
#     it "generates nothing for unknown trait":
#         var src = "class Wrapper:" + "\n"
#         src = src + "    inner: Inner" + "\n"
#         src = src + "    alias UnknownTrait = inner" + "\n"
#         val out = desugar_forwarding(src)
#         # Should not contain any forwarding methods (trait not found in source)
#         val has_self_inner = out.contains("self.inner.")
#         expect(has_self_inner).to_equal(false)
# 
# describe "desugar_forwarding - DEPRECATED fn name = target":
# 
#     it "generates delegation for fn alias with known target":
#         var src = "fn greet(name: text) -> text:" + "\n"
#         src = src + "    \"Hello, \" + name" + "\n"
#         src = src + "\n"
#         src = src + "fn hello = greet" + "\n"
#         val out = desugar_forwarding(src)
#         expect(out).to_contain("DEPRECATED")
#         expect(out).to_contain("fn hello(name):")
#         expect(out).to_contain("greet(name)")
# 
#     it "generates no-arg delegation when target has no params":
#         var src = "fn get_value() -> i64:" + "\n"
#         src = src + "    42" + "\n"
#         src = src + "\n"
#         src = src + "fn fetch = get_value" + "\n"
#         val out = desugar_forwarding(src)
#         expect(out).to_contain("fn fetch():")
#         expect(out).to_contain("get_value()")
# 
#     it "does not treat normal functions as aliases":
#         var src = "fn normal(x: i64) -> i64:" + "\n"
#         src = src + "    x + 1" + "\n"
#         val out = desugar_forwarding(src)
#         expect(out).to_contain("fn normal(x: i64) -> i64:")
#         val has_deprecated = out.contains("DEPRECATED")
#         expect(has_deprecated).to_equal(false)
# 
# describe "desugar_forwarding - Phase 4 blanket alias":
# 
#     it "forwards all methods from field type":
#         var src = "class Storage:" + "\n"
#         src = src + "    fn size() -> i64:" + "\n"
#         src = src + "        0" + "\n"
#         src = src + "    me clear():" + "\n"
#         src = src + "        0" + "\n"
#         src = src + "\n"
#         src = src + "class Wrapper:" + "\n"
#         src = src + "    store: Storage" + "\n"
#         src = src + "    alias store" + "\n"
#         val out = desugar_forwarding(src)
#         expect(out).to_contain("fn size():")
#         expect(out).to_contain("self.store.size()")
#         expect(out).to_contain("me clear():")
#         expect(out).to_contain("self.store.clear()")
# 
#     it "forwards methods with parameters":
#         var src = "class Engine:" + "\n"
#         src = src + "    fn power(rpm: i64) -> i64:" + "\n"
#         src = src + "        rpm * 2" + "\n"
#         src = src + "\n"
#         src = src + "class Car:" + "\n"
#         src = src + "    engine: Engine" + "\n"
#         src = src + "    alias engine" + "\n"
#         val out = desugar_forwarding(src)
#         expect(out).to_contain("fn power(rpm):")
#         expect(out).to_contain("self.engine.power(rpm)")
# 
#     it "generates nothing for unknown field type":
#         var src = "class Wrapper:" + "\n"
#         src = src + "    inner: UnknownType" + "\n"
#         src = src + "    alias inner" + "\n"
#         val out = desugar_forwarding(src)
#         # UnknownType not defined in source, so no methods to forward
#         val has_self_inner = out.contains("self.inner.")
#         expect(has_self_inner).to_equal(false)
