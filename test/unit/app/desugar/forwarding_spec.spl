# Forwarding Desugar Unit Tests
#
# Tests the forwarding desugar pass which transforms:
# - fn name = target -> fn name(params): target(params) (DEPRECATED)
# - alias fn NAME = FIELD.METHOD -> fn NAME(): self.FIELD.METHOD()
# - alias me NAME = FIELD.METHOD -> me NAME(): self.FIELD.METHOD()
# - alias TraitName = field -> forwarding methods for each trait method
# - alias field_name -> blanket forwarding of all field type methods

use app.desugar.forwarding (desugar_forwarding)
use std.text.{NL}

describe "desugar_forwarding - Phase 2 alias fn/me":

    it "generates fn forwarding for no-arg method":
        var src = "class Wrapper:" + NL
        src = src + "    inner: Inner" + NL
        src = src + "    alias fn len = inner.len" + NL
        val out = desugar_forwarding(src)
        expect(out).to_contain("fn len():")
        expect(out).to_contain("self.inner.len()")

    it "generates fn forwarding with args":
        var src = "class Wrapper:" + NL
        src = src + "    inner: Inner" + NL
        src = src + "    alias fn get(key, default) = inner.get" + NL
        val out = desugar_forwarding(src)
        expect(out).to_contain("fn get(key, default):")
        expect(out).to_contain("self.inner.get(key, default)")

    it "generates me forwarding":
        var src = "class Wrapper:" + NL
        src = src + "    inner: Inner" + NL
        src = src + "    alias me push(item) = inner.push" + NL
        val out = desugar_forwarding(src)
        expect(out).to_contain("me push(item):")
        expect(out).to_contain("self.inner.push(item)")

    it "preserves non-alias lines":
        var src = "class Wrapper:" + NL
        src = src + "    inner: Inner" + NL
        src = src + "    fn own_method() -> i64:" + NL
        src = src + "        42" + NL
        val out = desugar_forwarding(src)
        expect(out).to_contain("fn own_method() -> i64:")
        expect(out).to_contain("42")

describe "desugar_forwarding - Phase 3 alias Trait":

    it "generates forwarding for trait fn methods":
        var src = "trait Sizeable:" + NL
        src = src + "    fn size() -> i64" + NL
        src = src + "    fn is_empty() -> bool" + NL
        src = src + NL
        src = src + "class MyList:" + NL
        src = src + "    items: Storage" + NL
        src = src + "    alias Sizeable = items" + NL
        val out = desugar_forwarding(src)
        expect(out).to_contain("fn size():")
        expect(out).to_contain("self.items.size()")
        expect(out).to_contain("fn is_empty():")
        expect(out).to_contain("self.items.is_empty()")

    it "generates forwarding for trait me methods":
        var src = "trait Writable:" + NL
        src = src + "    me write(data: text)" + NL
        src = src + "    me clear()" + NL
        src = src + NL
        src = src + "class Stream:" + NL
        src = src + "    buf: Buffer" + NL
        src = src + "    alias Writable = buf" + NL
        val out = desugar_forwarding(src)
        expect(out).to_contain("me write(data):")
        expect(out).to_contain("self.buf.write(data)")
        expect(out).to_contain("me clear():")
        expect(out).to_contain("self.buf.clear()")

    it "skips default methods":
        var src = "trait Eq:" + NL
        src = src + "    fn eq(other: Self) -> bool" + NL
        src = src + "    fn ne(other: Self) -> bool:" + NL
        src = src + "        not self.eq(other)" + NL
        src = src + NL
        src = src + "class Point:" + NL
        src = src + "    inner: Coord" + NL
        src = src + "    alias Eq = inner" + NL
        val out = desugar_forwarding(src)
        # eq is abstract (no default) - should be forwarded
        expect(out).to_contain("fn eq(other):")
        expect(out).to_contain("self.inner.eq(other)")
        # ne has a default - should NOT be forwarded
        val has_ne_forward = out.contains("self.inner.ne(")
        expect(has_ne_forward).to_equal(false)

    it "handles multiple trait aliases on same class":
        var src = "trait Readable:" + NL
        src = src + "    fn read() -> text" + NL
        src = src + NL
        src = src + "trait Closeable:" + NL
        src = src + "    me close()" + NL
        src = src + NL
        src = src + "class FileStream:" + NL
        src = src + "    reader: Reader" + NL
        src = src + "    handle: Handle" + NL
        src = src + "    alias Readable = reader" + NL
        src = src + "    alias Closeable = handle" + NL
        val out = desugar_forwarding(src)
        expect(out).to_contain("fn read():")
        expect(out).to_contain("self.reader.read()")
        expect(out).to_contain("me close():")
        expect(out).to_contain("self.handle.close()")

    it "generates nothing for unknown trait":
        var src = "class Wrapper:" + NL
        src = src + "    inner: Inner" + NL
        src = src + "    alias UnknownTrait = inner" + NL
        val out = desugar_forwarding(src)
        # Should not contain any forwarding methods (trait not found in source)
        val has_self_inner = out.contains("self.inner.")
        expect(has_self_inner).to_equal(false)

describe "desugar_forwarding - DEPRECATED fn name = target":

    it "generates delegation for fn alias with known target":
        var src = "fn greet(name: text) -> text:" + NL
        src = src + "    \"Hello, \" + name" + NL
        src = src + NL
        src = src + "fn hello = greet" + NL
        val out = desugar_forwarding(src)
        expect(out).to_contain("DEPRECATED")
        expect(out).to_contain("fn hello(name):")
        expect(out).to_contain("greet(name)")

    it "generates no-arg delegation when target has no params":
        var src = "fn get_value() -> i64:" + NL
        src = src + "    42" + NL
        src = src + NL
        src = src + "fn fetch = get_value" + NL
        val out = desugar_forwarding(src)
        expect(out).to_contain("fn fetch():")
        expect(out).to_contain("get_value()")

    it "does not treat normal functions as aliases":
        var src = "fn normal(x: i64) -> i64:" + NL
        src = src + "    x + 1" + NL
        val out = desugar_forwarding(src)
        expect(out).to_contain("fn normal(x: i64) -> i64:")
        val has_deprecated = out.contains("DEPRECATED")
        expect(has_deprecated).to_equal(false)

describe "desugar_forwarding - Phase 4 blanket alias":

    it "forwards all methods from field type":
        var src = "class Storage:" + NL
        src = src + "    fn size() -> i64:" + NL
        src = src + "        0" + NL
        src = src + "    me clear():" + NL
        src = src + "        pass_do_nothing" + NL
        src = src + NL
        src = src + "class Wrapper:" + NL
        src = src + "    store: Storage" + NL
        src = src + "    alias store" + NL
        val out = desugar_forwarding(src)
        expect(out).to_contain("fn size():")
        expect(out).to_contain("self.store.size()")
        expect(out).to_contain("me clear():")
        expect(out).to_contain("self.store.clear()")

    it "forwards methods with parameters":
        var src = "class Engine:" + NL
        src = src + "    fn power(rpm: i64) -> i64:" + NL
        src = src + "        rpm * 2" + NL
        src = src + NL
        src = src + "class Car:" + NL
        src = src + "    engine: Engine" + NL
        src = src + "    alias engine" + NL
        val out = desugar_forwarding(src)
        expect(out).to_contain("fn power(rpm):")
        expect(out).to_contain("self.engine.power(rpm)")

    it "generates nothing for unknown field type":
        var src = "class Wrapper:" + NL
        src = src + "    inner: UnknownType" + NL
        src = src + "    alias inner" + NL
        val out = desugar_forwarding(src)
        # UnknownType not defined in source, so no methods to forward
        val has_self_inner = out.contains("self.inner.")
        expect(has_self_inner).to_equal(false)
