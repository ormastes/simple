describe "Struct Defaults":
    it "skipped":
        skip("pre-existing test failures - functions/imports not available")

# # Struct Default Field Values — Desugar Passthrough Tests
# #
# # Feature 3: Default Field Values
# # Syntax: `field: Type = expr` inside struct/class bodies.
# #
# # Investigation Result: NO desugar pass needed.
# #
# # The core runtime (parser.spl + ast.spl + eval.spl) already handles
# # struct default field values natively:
# #
# #   parser.spl  — parse_struct_decl() detects `=` after the type annotation
# #                 and calls parse_expr() to capture the default expression.
# #   ast.spl     — decl_field_defaults: [[i64]] stores per-field default
# #                 expression indices; decl_struct_def() and decl_get() expose
# #                 them; CoreDecl.field_defaults is populated on every struct.
# #   eval.spl    — eval_struct_constructor() iterates over unfilled fields and
# #                 calls eval_expr(def_eid) for each default expression when the
# #                 caller omits those fields.
# #
# # Because Approach A (core-level) is already implemented, Approach B
# # (text-level desugar at the desugar pipeline) is neither required nor
# # desirable. Adding a desugar pass would duplicate logic and could conflict
# # with the already-working runtime behaviour.
# #
# # These tests verify that the existing desugar pipeline passes struct
# # declarations with default values through unchanged, i.e. that none of
# # the existing passes corrupt or drop default initialiser expressions.
# 
# use app.desugar.mod.{desugar_source}
# 
# describe "struct default field values — desugar passthrough":
# 
#     it "passes struct with single integer default unchanged":
#         val input = "struct Counter:\n    count: i64 = 0"
#         val output = desugar_source(input)
#         expect(output).to_contain("count: i64 = 0")
# 
#     it "passes struct with multiple defaults unchanged":
#         val input = "struct Point:\n    x: i64 = 0\n    y: i64 = 0"
#         val output = desugar_source(input)
#         expect(output).to_contain("x: i64 = 0")
#         expect(output).to_contain("y: i64 = 0")
# 
#     it "passes struct with text default unchanged":
#         val input = "struct Config:\n    name: text = \"default\""
#         val output = desugar_source(input)
#         expect(output).to_contain("name: text = \"default\"")
# 
#     it "passes struct with bool default unchanged":
#         val input = "struct Flags:\n    enabled: bool = true"
#         val output = desugar_source(input)
#         expect(output).to_contain("enabled: bool = true")
# 
#     it "passes struct with float default unchanged":
#         val input = "struct Scale:\n    factor: f64 = 1.0"
#         val output = desugar_source(input)
#         expect(output).to_contain("factor: f64 = 1.0")
# 
#     it "passes struct mixing fields with and without defaults":
#         val input = "struct Node:\n    id: i64\n    count: i64 = 0"
#         val output = desugar_source(input)
#         expect(output).to_contain("id: i64")
#         expect(output).to_contain("count: i64 = 0")
# 
#     it "does not corrupt struct name when default is present":
#         val input = "struct Timer:\n    ticks: i64 = 0"
#         val output = desugar_source(input)
#         expect(output).to_contain("struct Timer:")
# 
#     it "preserves default expr after static method extraction":
#         # Pass 1 (static constants) and Pass 2 (static methods) should not
#         # touch field declarations — only lines inside impl blocks.
#         val input = "struct Counter:\n    count: i64 = 0\n\nimpl Counter:\n    static fn zero() -> Counter:\n        Counter()"
#         val output = desugar_source(input)
#         expect(output).to_contain("count: i64 = 0")
#         expect(output).to_contain("fn Counter__zero()")
# 
#     it "preserves default expr after call-site rewriting":
#         # Pass 4 (rewrite_static_calls) rewrites Type.method() patterns.
#         # It must not misinterpret the `= value` as a static call.
#         val input = "struct Config:\n    timeout: i64 = 30"
#         val output = desugar_source(input)
#         expect(output).to_contain("timeout: i64 = 30")
# 
#     it "passes struct with expression default (arithmetic) unchanged":
#         val input = "struct Buffer:\n    capacity: i64 = 4 * 1024"
#         val output = desugar_source(input)
#         expect(output).to_contain("capacity: i64 = 4 * 1024")
# 
#     it "passes class body with default fields unchanged":
#         val input = "class Counter:\n    count: i64 = 0\n    fn get() -> i64:\n        self.count"
#         val output = desugar_source(input)
#         expect(output).to_contain("count: i64 = 0")
#         expect(output).to_contain("fn get() -> i64:")
# 
#     it "preserves default through context_params pass":
#         # Pass -2 (context params) should not touch struct field defaults.
#         val input = "struct Logger:\n    level: i64 = 1"
#         val output = desugar_source(input)
#         expect(output).to_contain("level: i64 = 1")
# 
#     it "preserves default through trait desugar pass":
#         # Pass -1 (trait desugar) rewrites trait declarations but must not
#         # alter struct field default syntax.
#         val input = "struct Entity:\n    active: bool = true"
#         val output = desugar_source(input)
#         expect(output).to_contain("active: bool = true")
# 
#     it "handles multiple structs each with defaults":
#         val input = "struct A:\n    x: i64 = 1\n\nstruct B:\n    y: i64 = 2"
#         val output = desugar_source(input)
#         expect(output).to_contain("x: i64 = 1")
#         expect(output).to_contain("y: i64 = 2")
