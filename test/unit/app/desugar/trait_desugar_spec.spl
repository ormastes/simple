# Trait Desugar Unit Tests
#
# Tests the trait_desugar pass which transforms trait declarations
# into struct-with-fn-fields. This is a source-level text transformation
# that runs before the parser.
#
# Transformations tested:
#   trait Name: -> struct Name:
#   fn method(p: T) -> R -> method_fn: fn(T) -> R
#   me method(p: T)      -> method_fn: fn(T)
#   impl TraitName for value: -> fn value_as_TraitName() -> TraitName:

use app.desugar.trait_desugar (desugar_traits)
use app.desugar.mod (desugar_source)
use std.text.{NL}

describe "desugar_traits - basic trait to struct conversion":

    it "converts trait header to struct header":
        var src = "trait Repo:" + NL
        src = src + "    fn find(id: text) -> Item" + NL
        val out = desugar_traits(src)
        expect(out).to_contain("struct Repo:")
        val has_trait = out.contains("trait Repo:")
        expect(has_trait).to_equal(false)

    it "converts fn method to fn-field with type":
        var src = "trait Repo:" + NL
        src = src + "    fn find(id: text) -> Item" + NL
        val out = desugar_traits(src)
        expect(out).to_contain("find_fn: fn(text) -> Item")

    it "converts fn method with no params to fn-field":
        var src = "trait Display:" + NL
        src = src + "    fn to_string() -> text" + NL
        val out = desugar_traits(src)
        expect(out).to_contain("to_string_fn: fn() -> text")

    it "converts fn method with no return type to fn-field":
        var src = "trait Logger:" + NL
        src = src + "    fn log(msg: text)" + NL
        val out = desugar_traits(src)
        expect(out).to_contain("log_fn: fn(text)")

    it "converts me method to fn-field (without me keyword)":
        var src = "trait Writer:" + NL
        src = src + "    me write(data: text)" + NL
        val out = desugar_traits(src)
        expect(out).to_contain("write_fn: fn(text)")
        val has_me = out.contains("me write")
        expect(has_me).to_equal(false)

    it "converts multiple methods in one trait":
        var src = "trait OrderRepo:" + NL
        src = src + "    fn save(order: Order)" + NL
        src = src + "    fn find(id: text) -> Order" + NL
        src = src + "    fn list() -> [Order]" + NL
        src = src + "    me delete(id: text)" + NL
        val out = desugar_traits(src)
        expect(out).to_contain("struct OrderRepo:")
        expect(out).to_contain("save_fn: fn(Order)")
        expect(out).to_contain("find_fn: fn(text) -> Order")
        expect(out).to_contain("list_fn: fn() -> [Order]")
        expect(out).to_contain("delete_fn: fn(text)")

    it "preserves multiple param types":
        var src = "trait Calculator:" + NL
        src = src + "    fn add(a: i64, b: i64) -> i64" + NL
        val out = desugar_traits(src)
        expect(out).to_contain("add_fn: fn(i64, i64) -> i64")

    it "handles array return types":
        var src = "trait Lister:" + NL
        src = src + "    fn list() -> [Item]" + NL
        val out = desugar_traits(src)
        expect(out).to_contain("list_fn: fn() -> [Item]")

    it "preserves non-trait code unchanged":
        var src = "struct Plain:" + NL
        src = src + "    field: text" + NL
        val out = desugar_traits(src)
        expect(out).to_contain("struct Plain:")
        expect(out).to_contain("field: text")

describe "desugar_traits - skipping and filtering":

    it "skips comment lines in trait body":
        var src = "trait Repo:" + NL
        src = src + "    # This is a comment" + NL
        src = src + "    fn find(id: text) -> Item" + NL
        val out = desugar_traits(src)
        expect(out).to_contain("find_fn: fn(text) -> Item")
        val has_comment = out.contains("# This is a comment")
        expect(has_comment).to_equal(false)

    it "skips type declarations in trait body":
        var src = "trait Iter:" + NL
        src = src + "    type Item" + NL
        src = src + "    fn next() -> Item" + NL
        val out = desugar_traits(src)
        expect(out).to_contain("next_fn: fn() -> Item")
        val has_type = out.contains("type Item")
        expect(has_type).to_equal(false)

    it "handles default method body (skips it)":
        var src = "trait Printable:" + NL
        src = src + "    fn print():" + NL
        src = src + "        show(self)" + NL
        val out = desugar_traits(src)
        # Method with default body is still converted to fn-field
        expect(out).to_contain("print_fn: fn()")
        # The body content should not appear in struct
        val has_body = out.contains("show(self)")
        expect(has_body).to_equal(false)

describe "desugar_traits - multiple traits":

    it "converts multiple traits in same source":
        var src = "trait Reader:" + NL
        src = src + "    fn read() -> text" + NL
        src = src + NL
        src = src + "trait Writer:" + NL
        src = src + "    me write(data: text)" + NL
        val out = desugar_traits(src)
        expect(out).to_contain("struct Reader:")
        expect(out).to_contain("read_fn: fn() -> text")
        expect(out).to_contain("struct Writer:")
        expect(out).to_contain("write_fn: fn(text)")

    it "does not transform lowercase-named blocks":
        var src = "trait notATrait:" + NL
        src = src + "    fn method()" + NL
        val out = desugar_traits(src)
        # Lowercase trait names are NOT desugared
        val has_trait = out.contains("trait notATrait:")
        expect(has_trait).to_equal(true)
        val has_struct = out.contains("struct notATrait:")
        expect(has_struct).to_equal(false)

describe "desugar_traits - impl for factory generation":

    it "generates factory function from impl-for block":
        var src = "trait Repo:" + NL
        src = src + "    fn find(id: text) -> Item" + NL
        src = src + NL
        src = src + "impl Repo for sql:" + NL
        src = src + "    fn find(id: text) -> Item: sql_select(id)" + NL
        val out = desugar_traits(src)
        expect(out).to_contain("fn sql_as_Repo() -> Repo:")

    it "generates factory with correct field assignment":
        var src = "trait Repo:" + NL
        src = src + "    fn find(id: text) -> Item" + NL
        src = src + NL
        src = src + "impl Repo for sql:" + NL
        src = src + "    fn find(id: text) -> Item: sql_select(id)" + NL
        val out = desugar_traits(src)
        expect(out).to_contain("find_fn:")
        expect(out).to_contain("sql_select(id)")

    it "does not generate factory for impl without 'for'":
        var src = "impl Repo:" + NL
        src = src + "    fn find(id: text) -> Item: sql_select(id)" + NL
        val out = desugar_traits(src)
        # Plain impl (no 'for') is passed through unchanged
        val has_factory = out.contains("_as_Repo")
        expect(has_factory).to_equal(false)

describe "desugar_traits - integration with desugar_source":

    it "works through the full desugar pipeline":
        var src = "trait Cache:" + NL
        src = src + "    fn get(key: text) -> text" + NL
        src = src + "    me put(key: text, value: text)" + NL
        val out = desugar_source(src)
        expect(out).to_contain("struct Cache:")
        expect(out).to_contain("get_fn: fn(text) -> text")
        expect(out).to_contain("put_fn: fn(text, text)")
