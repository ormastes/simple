# Static Methods Desugaring Extended Tests
#
# Tests the exported function desugar_static_methods from app.desugar.static_methods
# which transforms static method definitions in impl blocks into module-level functions.
#
# Internal functions tested indirectly:
# - parse_impl_header: impl header parsing
# - split_on_for: splitting "Trait for Type" patterns
# - strip_generics: removing generic parameters
# - extract_generics: extracting generic parameters
# - process_impl_block: separating static and instance methods
# - extract_methods: parsing method blocks from impl body
# - parse_method_header: identifying fn/me/static fn
# - hoist_static_method: transforming static methods to module-level
# - get_indent: measuring leading whitespace

use app.desugar.static_methods (desugar_static_methods)
use std.text.{NL}

describe "desugar_static_methods":

    # ================================================================
    # Basic Static Method Hoisting
    # ================================================================

    it "hoists a static fn to module level":
        val input = "impl Point:{NL}    static fn origin() -> Point:{NL}        Point(x: 0, y: 0){NL}"
        val output = desugar_static_methods(input)
        expect(output).to_contain("fn Point__origin() -> Point:")
        expect(output).to_contain("Point(x: 0, y: 0)")

    it "removes static keyword from hoisted function":
        val input = "impl Foo:{NL}    static fn bar() -> i64:{NL}        42{NL}"
        val output = desugar_static_methods(input)
        expect(output).to_contain("fn Foo__bar() -> i64:")
        # Should not contain "static fn" in the hoisted version
        val has_static = output.contains("static fn Foo__bar")
        expect(has_static).to_equal(false)

    it "hoists multiple static methods from same impl":
        val input = "impl Builder:{NL}    static fn create() -> Builder:{NL}        Builder(items: []){NL}    static fn from_list(items: [text]) -> Builder:{NL}        Builder(items: items){NL}"
        val output = desugar_static_methods(input)
        expect(output).to_contain("fn Builder__create() -> Builder:")
        expect(output).to_contain("fn Builder__from_list(items: [text]) -> Builder:")

    it "preserves function parameters in hoisted method":
        val input = "impl Parser:{NL}    static fn new(src: text, mode: i64) -> Parser:{NL}        Parser(source: src, pos: 0){NL}"
        val output = desugar_static_methods(input)
        expect(output).to_contain("fn Parser__new(src: text, mode: i64) -> Parser:")

    it "preserves multi-line body in hoisted method":
        val input = "impl Config:{NL}    static fn defaults() -> Config:{NL}        val x = 10{NL}        val y = 20{NL}        Config(x: x, y: y){NL}"
        val output = desugar_static_methods(input)
        expect(output).to_contain("fn Config__defaults() -> Config:")
        expect(output).to_contain("val x = 10")
        expect(output).to_contain("val y = 20")

    # ================================================================
    # Instance Method Preservation
    # ================================================================

    it "preserves instance methods in impl block":
        val input = "impl Point:{NL}    static fn origin() -> Point:{NL}        Point(x: 0, y: 0){NL}    fn distance() -> f64:{NL}        (self.x ** 2 + self.y ** 2).sqrt(){NL}"
        val output = desugar_static_methods(input)
        expect(output).to_contain("impl Point:")
        expect(output).to_contain("fn distance() -> f64:")

    it "preserves mutable methods (me keyword)":
        val input = "impl Counter:{NL}    static fn zero() -> Counter:{NL}        Counter(count: 0){NL}    me increment():{NL}        self.count = self.count + 1{NL}"
        val output = desugar_static_methods(input)
        expect(output).to_contain("fn Counter__zero() -> Counter:")
        expect(output).to_contain("me increment():")
        expect(output).to_contain("impl Counter:")

    it "keeps multiple instance methods intact":
        val input = "impl Widget:{NL}    fn width() -> i64:{NL}        self.w{NL}    fn height() -> i64:{NL}        self.h{NL}"
        val output = desugar_static_methods(input)
        expect(output).to_contain("fn width() -> i64:")
        expect(output).to_contain("fn height() -> i64:")

    # ================================================================
    # Empty Impl Block Handling
    # ================================================================

    it "drops empty impl block when all methods are static":
        val input = "impl Config:{NL}    static fn defaults() -> Config:{NL}        Config(value: 0){NL}"
        val output = desugar_static_methods(input)
        expect(output).to_contain("fn Config__defaults() -> Config:")
        # Should not have an empty impl block
        val has_impl = output.contains("impl Config:")
        expect(has_impl).to_equal(false)

    it "drops impl when multiple static methods removed":
        val input = "impl Factory:{NL}    static fn create() -> Factory:{NL}        Factory(){NL}    static fn build(x: i64) -> Factory:{NL}        Factory(val: x){NL}"
        val output = desugar_static_methods(input)
        expect(output).to_contain("fn Factory__create()")
        expect(output).to_contain("fn Factory__build(x: i64)")
        val has_impl = output.contains("impl Factory:")
        expect(has_impl).to_equal(false)

    # ================================================================
    # Trait Impl Handling
    # ================================================================

    it "handles trait for type impl pattern":
        val input = "impl Display for Point:{NL}    fn format() -> text:{NL}        return self.x{NL}"
        val output = desugar_static_methods(input)
        expect(output).to_contain("impl Display for Point:")
        expect(output).to_contain("fn format() -> text:")

    it "hoists static from trait impl":
        val input = "impl Parseable for Config:{NL}    static fn parse(s: text) -> Config:{NL}        Config(value: s){NL}    fn to_string() -> text:{NL}        self.value{NL}"
        val output = desugar_static_methods(input)
        expect(output).to_contain("fn Config__parse(s: text) -> Config:")
        expect(output).to_contain("impl Parseable for Config:")
        expect(output).to_contain("fn to_string() -> text:")

    # ================================================================
    # Non-Impl Lines Preservation
    # ================================================================

    it "preserves non-impl code untouched":
        val input = "val x = 10{NL}fn helper() -> i64:{NL}    42{NL}"
        val output = desugar_static_methods(input)
        expect(output).to_contain("val x = 10")
        expect(output).to_contain("fn helper() -> i64:")
        expect(output).to_contain("42")

    it "preserves struct definitions":
        val input = "struct Point:{NL}    x: i64{NL}    y: i64{NL}{NL}impl Point:{NL}    static fn origin() -> Point:{NL}        Point(x: 0, y: 0){NL}"
        val output = desugar_static_methods(input)
        expect(output).to_contain("struct Point:")
        expect(output).to_contain("x: i64")
        expect(output).to_contain("y: i64")

    it "preserves comments":
        val input = "# This is a comment{NL}impl Foo:{NL}    static fn bar() -> i64:{NL}        1{NL}"
        val output = desugar_static_methods(input)
        expect(output).to_contain("# This is a comment")

    it "preserves blank lines between non-impl code":
        val input = "val a = 1{NL}{NL}val b = 2{NL}"
        val output = desugar_static_methods(input)
        expect(output).to_contain("val a = 1")
        expect(output).to_contain("val b = 2")

    # ================================================================
    # Multiple Impl Blocks
    # ================================================================

    it "handles multiple separate impl blocks":
        val input = "impl Foo:{NL}    static fn create() -> Foo:{NL}        Foo(){NL}{NL}impl Bar:{NL}    static fn build() -> Bar:{NL}        Bar(){NL}"
        val output = desugar_static_methods(input)
        expect(output).to_contain("fn Foo__create() -> Foo:")
        expect(output).to_contain("fn Bar__build() -> Bar:")

    it "handles impl block with mixed methods followed by another impl":
        val input = "impl A:{NL}    static fn make() -> A:{NL}        A(){NL}    fn get() -> i64:{NL}        self.val{NL}{NL}impl B:{NL}    fn show() -> text:{NL}        self.name{NL}"
        val output = desugar_static_methods(input)
        expect(output).to_contain("fn A__make() -> A:")
        expect(output).to_contain("impl A:")
        expect(output).to_contain("fn get() -> i64:")
        expect(output).to_contain("impl B:")
        expect(output).to_contain("fn show() -> text:")

    # ================================================================
    # Generic Types
    # ================================================================

    it "handles impl with generic type":
        val input = "impl Container<T>:{NL}    static fn empty() -> Container:{NL}        Container(items: []){NL}"
        val output = desugar_static_methods(input)
        expect(output).to_contain("fn Container__empty")

    it "strips generics from type name in hoisted function":
        val input = "impl Option<T>:{NL}    static fn none() -> Option:{NL}        nil{NL}"
        val output = desugar_static_methods(input)
        expect(output).to_contain("fn Option__none")

    # ================================================================
    # Indentation Handling
    # ================================================================

    it "de-indents hoisted method body to module level":
        val input = "impl Math:{NL}    static fn add(a: i64, b: i64) -> i64:{NL}        a + b{NL}"
        val output = desugar_static_methods(input)
        expect(output).to_contain("fn Math__add(a: i64, b: i64) -> i64:")
        expect(output).to_contain("a + b")

    it "handles deeply nested body in hoisted method":
        val input = "impl Logic:{NL}    static fn check(x: i64) -> bool:{NL}        if x > 0:{NL}            return true{NL}        false{NL}"
        val output = desugar_static_methods(input)
        expect(output).to_contain("fn Logic__check(x: i64) -> bool:")
        expect(output).to_contain("if x > 0:")
        expect(output).to_contain("return true")

    # ================================================================
    # Edge Cases
    # ================================================================

    it "handles empty input":
        val output = desugar_static_methods("")
        expect(output).to_equal("")

    it "handles input with no impl blocks":
        val input = "fn standalone():{NL}    pass{NL}"
        val output = desugar_static_methods(input)
        expect(output).to_contain("fn standalone():")

    it "handles impl with only instance methods unchanged":
        val input = "impl Simple:{NL}    fn value() -> i64:{NL}        0{NL}"
        val output = desugar_static_methods(input)
        expect(output).to_contain("impl Simple:")
        expect(output).to_contain("fn value() -> i64:")

    it "handles static fn with no return type":
        val input = "impl Logger:{NL}    static fn init():{NL}        print \"init\"{NL}"
        val output = desugar_static_methods(input)
        expect(output).to_contain("fn Logger__init():")

    it "preserves return type annotation":
        val input = "impl Creator:{NL}    static fn make(n: i64) -> Creator:{NL}        Creator(n: n){NL}"
        val output = desugar_static_methods(input)
        expect(output).to_contain("fn Creator__make(n: i64) -> Creator:")

    it "handles static method with complex body":
        val input = "impl Validator:{NL}    static fn is_valid(s: text) -> bool:{NL}        val len = s.len(){NL}        if len == 0:{NL}            return false{NL}        if len > 100:{NL}            return false{NL}        true{NL}"
        val output = desugar_static_methods(input)
        expect(output).to_contain("fn Validator__is_valid(s: text) -> bool:")
        expect(output).to_contain("val len = s.len()")
