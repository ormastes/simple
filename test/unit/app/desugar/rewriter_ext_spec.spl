# Static Call Rewriter Extended Tests
#
# Tests the exported function rewrite_static_calls from app.desugar.rewriter
# which transforms Type.method(args) calls to TypeName__method(args) in source text.
#
# Internal functions tested indirectly:
# - extract_word: extracts identifier from string start
# - is_ident_char: checks if character is part of identifier
# - is_upper: checks for uppercase letter
# - is_lower_or_underscore: checks for lowercase letter or underscore
# - rewrite_line: rewrites a single line
# - rewrite_static_patterns: scans and rewrites UppercaseWord.method( patterns
# - is_in_string_context: detects if position is inside string literal

use app.desugar.rewriter (rewrite_static_calls)

describe "rewrite_static_calls":

    # ================================================================
    # Basic Static Call Rewriting
    # ================================================================

    it "rewrites Type.method() to Type__method()":
        val input = "val p = Point.origin()\n"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("Point__origin()")

    it "rewrites call with arguments":
        val input = "val p = Point.from_pair(1, 2)\n"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("Point__from_pair(1, 2)")

    it "rewrites call with no arguments":
        val input = "Config.defaults()\n"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("Config__defaults()")

    it "rewrites call with text argument":
        val input = "val parser = Parser.from_source(src)\n"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("Parser__from_source(src)")

    it "replaces dot with double underscore":
        val input = "Builder.create()\n"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("Builder__create()")
        val has_dot = output.contains("Builder.create()")
        expect(has_dot).to_equal(false)

    # ================================================================
    # Instance Method Preservation
    # ================================================================

    it "does not rewrite instance method calls (lowercase receiver)":
        val input = "val d = point.distance()\n"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("point.distance()")

    it "does not rewrite self access":
        val input = "self.field\n"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("self.field")

    it "does not rewrite lowercase variable method calls":
        val input = "result.unwrap()\n"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("result.unwrap()")

    it "does not rewrite field access without parens":
        val input = "val x = point.x\n"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("point.x")

    it "rewrites Uppercase.field even without parens":
        val input = "val n = Config.name\n"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("Config__name")

    # ================================================================
    # Comment and String Preservation
    # ================================================================

    it "skips comment lines entirely":
        val input = "# Point.origin() is a factory\n"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("# Point.origin() is a factory")

    it "does not rewrite inside string literals":
        val input = "val s = \"Point.origin()\"\n"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("\"Point.origin()\"")

    it "skips import/use lines":
        val input = "use app.desugar.rewriter (rewrite_static_calls)\n"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("use app.desugar.rewriter (rewrite_static_calls)")

    it "skips export lines":
        val input = "export Point, Config\n"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("export Point, Config")

    it "skips impl definition lines":
        val input = "impl Point:\n"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("impl Point:")

    it "skips class definition lines":
        val input = "class Widget:\n"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("class Widget:")

    it "skips struct definition lines":
        val input = "struct Data:\n"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("struct Data:")

    it "skips enum definition lines":
        val input = "enum Color:\n"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("enum Color:")

    it "skips static fn definition lines":
        val input = "static fn Point__origin() -> Point:\n"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("static fn Point__origin()")

    # ================================================================
    # Nested and Complex Patterns
    # ================================================================

    it "rewrites nested static calls":
        val input = "val r = Type.method(Other.factory())\n"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("Type__method(Other__factory())")

    it "rewrites multiple static calls on same line":
        val input = "val x = Foo.bar() + Baz.qux()\n"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("Foo__bar()")
        expect(output).to_contain("Baz__qux()")

    it "rewrites call in assignment":
        val input = "var config = Config.load(path)\n"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("Config__load(path)")

    it "rewrites call in if condition":
        val input = "if Validator.check(x):\n"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("Validator__check(x)")

    it "rewrites call in return statement":
        val input = "return Factory.create()\n"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("Factory__create()")

    it "rewrites call in val binding":
        val input = "val result = Builder.from_args(a, b, c)\n"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("Builder__from_args(a, b, c)")

    # ================================================================
    # Multi-Line Input
    # ================================================================

    it "rewrites across multiple lines":
        val input = "val a = Foo.bar()\nval b = Baz.qux()\n"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("Foo__bar()")
        expect(output).to_contain("Baz__qux()")

    it "preserves non-static lines among static calls":
        val input = "val x = 10\nval p = Point.origin()\nval y = 20\n"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("val x = 10")
        expect(output).to_contain("Point__origin()")
        expect(output).to_contain("val y = 20")

    it "handles mix of comments and code":
        val input = "# factory call\nval p = Point.origin()\n# done\n"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("# factory call")
        expect(output).to_contain("Point__origin()")
        expect(output).to_contain("# done")

    # ================================================================
    # Word Boundary Detection
    # ================================================================

    it "does not rewrite when uppercase word is part of longer word":
        val input = "val myPoint = getPoint.origin()\n"
        val output = rewrite_static_calls(input)
        # "getPoint" starts with lowercase g, so it's an instance call
        expect(output).to_contain("getPoint.origin()")

    it "rewrites when preceded by space":
        val input = "val x = Point.new()\n"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("Point__new()")

    it "rewrites when preceded by opening paren":
        val input = "call(Point.new())\n"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("Point__new()")

    it "rewrites when preceded by equals sign":
        val input = "x=Point.new()\n"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("Point__new()")

    # ================================================================
    # Edge Cases
    # ================================================================

    it "handles empty input":
        val output = rewrite_static_calls("")
        expect(output).to_equal("")

    it "handles single newline":
        val output = rewrite_static_calls("\n")
        expect(output).to_equal("\n")

    it "handles short lines (less than 3 chars)":
        val output = rewrite_static_calls("ab")
        expect(output).to_equal("ab")

    it "handles line with only spaces":
        val output = rewrite_static_calls("    \n")
        expect(output).to_contain("    ")

    it "handles type name with underscores":
        val input = "val x = My_Type.create()\n"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("My_Type__create()")

    it "handles method name with underscores":
        val input = "val x = Point.from_polar(r, theta)\n"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("Point__from_polar(r, theta)")

    it "does not rewrite method call on number":
        val input = "val x = 42.to_string()\n"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("42.to_string()")

    it "handles chained: Type.static().instance_method()":
        val input = "val r = Builder.create().build()\n"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("Builder__create().build()")

    it "preserves indented code":
        val input = "    val p = Point.origin()\n"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("    ")
        expect(output).to_contain("Point__origin()")
