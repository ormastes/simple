# Static Call Rewriter Extended Tests
#
# Tests the exported function rewrite_static_calls from app.desugar.rewriter
# which transforms Type.method(args) calls to TypeName__method(args) in source text.
#
# Internal functions tested indirectly:
# - extract_word: extracts identifier from string start
# - is_ident_char: checks if character is part of identifier
# - is_upper: checks for uppercase letter
# - is_lower_or_underscore: checks for lowercase letter or underscore
# - rewrite_line: rewrites a single line
# - rewrite_static_patterns: scans and rewrites UppercaseWord.method( patterns
# - is_in_string_context: detects if position is inside string literal

use app.desugar.rewriter (rewrite_static_calls)
use std.string.{NL}

describe "rewrite_static_calls":

    # ================================================================
    # Basic Static Call Rewriting
    # ================================================================

    it "rewrites Type.method() to Type__method()":
        val input = "val p = Point.origin(){NL}"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("Point__origin()")

    it "rewrites call with arguments":
        val input = "val p = Point.from_pair(1, 2){NL}"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("Point__from_pair(1, 2)")

    it "rewrites call with no arguments":
        val input = "Config.defaults(){NL}"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("Config__defaults()")

    it "rewrites call with text argument":
        val input = "val parser = Parser.from_source(src){NL}"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("Parser__from_source(src)")

    it "replaces dot with double underscore":
        val input = "Builder.create(){NL}"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("Builder__create()")
        val has_dot = output.contains("Builder.create()")
        expect(has_dot).to_equal(false)

    # ================================================================
    # Instance Method Preservation
    # ================================================================

    it "does not rewrite instance method calls (lowercase receiver)":
        val input = "val d = point.distance(){NL}"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("point.distance()")

    it "does not rewrite self access":
        val input = "self.field{NL}"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("self.field")

    it "does not rewrite lowercase variable method calls":
        val input = "result.unwrap(){NL}"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("result.unwrap()")

    it "does not rewrite field access without parens":
        val input = "val x = point.x{NL}"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("point.x")

    it "does not rewrite Uppercase.field (no parens)":
        val input = "val n = Config.name{NL}"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("Config.name")

    # ================================================================
    # Comment and String Preservation
    # ================================================================

    it "skips comment lines entirely":
        val input = "# Point.origin() is a factory{NL}"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("# Point.origin() is a factory")

    it "does not rewrite inside string literals":
        val input = "val s = \"Point.origin()\"{NL}"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("\"Point.origin()\"")

    it "skips import/use lines":
        val input = "use app.desugar.rewriter (rewrite_static_calls){NL}"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("use app.desugar.rewriter (rewrite_static_calls)")

    it "skips export lines":
        val input = "export Point, Config{NL}"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("export Point, Config")

    it "skips impl definition lines":
        val input = "impl Point:{NL}"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("impl Point:")

    it "skips class definition lines":
        val input = "class Widget:{NL}"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("class Widget:")

    it "skips struct definition lines":
        val input = "struct Data:{NL}"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("struct Data:")

    it "skips enum definition lines":
        val input = "enum Color:{NL}"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("enum Color:")

    it "skips static fn definition lines":
        val input = "static fn Point__origin() -> Point:{NL}"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("static fn Point__origin()")

    # ================================================================
    # Nested and Complex Patterns
    # ================================================================

    it "rewrites nested static calls":
        val input = "val r = Type.method(Other.factory()){NL}"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("Type__method(Other__factory())")

    it "rewrites multiple static calls on same line":
        val input = "val x = Foo.bar() + Baz.qux(){NL}"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("Foo__bar()")
        expect(output).to_contain("Baz__qux()")

    it "rewrites call in assignment":
        val input = "var config = Config.load(path){NL}"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("Config__load(path)")

    it "rewrites call in if condition":
        val input = "if Validator.check(x):{NL}"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("Validator__check(x)")

    it "rewrites call in return statement":
        val input = "return Factory.create(){NL}"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("Factory__create()")

    it "rewrites call in val binding":
        val input = "val result = Builder.from_args(a, b, c){NL}"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("Builder__from_args(a, b, c)")

    # ================================================================
    # Multi-Line Input
    # ================================================================

    it "rewrites across multiple lines":
        val input = "val a = Foo.bar(){NL}val b = Baz.qux(){NL}"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("Foo__bar()")
        expect(output).to_contain("Baz__qux()")

    it "preserves non-static lines among static calls":
        val input = "val x = 10{NL}val p = Point.origin(){NL}val y = 20{NL}"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("val x = 10")
        expect(output).to_contain("Point__origin()")
        expect(output).to_contain("val y = 20")

    it "handles mix of comments and code":
        val input = "# factory call{NL}val p = Point.origin(){NL}# done{NL}"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("# factory call")
        expect(output).to_contain("Point__origin()")
        expect(output).to_contain("# done")

    # ================================================================
    # Word Boundary Detection
    # ================================================================

    it "does not rewrite when uppercase word is part of longer word":
        val input = "val myPoint = getPoint.origin(){NL}"
        val output = rewrite_static_calls(input)
        # "getPoint" starts with lowercase g, so it's an instance call
        expect(output).to_contain("getPoint.origin()")

    it "rewrites when preceded by space":
        val input = "val x = Point.new(){NL}"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("Point__new()")

    it "rewrites when preceded by opening paren":
        val input = "call(Point.new()){NL}"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("Point__new()")

    it "rewrites when preceded by equals sign":
        val input = "x=Point.new(){NL}"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("Point__new()")

    # ================================================================
    # Edge Cases
    # ================================================================

    it "handles empty input":
        val output = rewrite_static_calls("")
        expect(output).to_equal("")

    it "handles single newline":
        val output = rewrite_static_calls("{NL}")
        expect(output).to_equal("{NL}")

    it "handles short lines (less than 3 chars)":
        val output = rewrite_static_calls("ab")
        expect(output).to_equal("ab")

    it "handles line with only spaces":
        val output = rewrite_static_calls("    {NL}")
        expect(output).to_contain("    ")

    it "handles type name with underscores":
        val input = "val x = My_Type.create(){NL}"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("My_Type__create()")

    it "handles method name with underscores":
        val input = "val x = Point.from_polar(r, theta){NL}"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("Point__from_polar(r, theta)")

    it "does not rewrite method call on number":
        val input = "val x = 42.to_string(){NL}"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("42.to_string()")

    it "handles chained: Type.static().instance_method()":
        val input = "val r = Builder.create().build(){NL}"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("Builder__create().build()")

    it "preserves indented code":
        val input = "    val p = Point.origin(){NL}"
        val output = rewrite_static_calls(input)
        expect(output).to_contain("    ")
        expect(output).to_contain("Point__origin()")
