# ActorHeap Tests
#
# Tests for per-actor heap isolation.

use std.actor_heap.{
    ActorHeap, HeapConfig, HeapStats, AllocationResult,
    HeapConfig__default, HeapConfig__small, HeapConfig__large, HeapConfig__no_gc,
    HeapStats__new, HeapRegion, HeapRegion__new, ActorHeap__new,
    AllocationResult__success, AllocationResult__failure
}
use std.types.{ByteSize}
fn check(condition: bool):
    expect(condition).to_equal(true)
fn check_msg(condition: bool, message: text):
    if not condition:
        expect(message).to_equal("")

describe "ActorHeap - Configuration":
    it "creates with default config":
        val heap = ActorHeap__new(HeapConfig__default())
        val config = heap.config

        check(config.initial_size.value == 2048)
        check(config.gc_enabled)
        check(config.generational)

    it "creates with custom config":
        val config = HeapConfig(
            initial_size: ByteSize(value: 1024),
            max_size: ByteSize(value: 4096),
            gc_enabled: true,
            generational: false,
            pretenure_threshold: 5
        )
        val heap = ActorHeap__new(config)

        check(heap.config.initial_size.value == 1024)
        check(heap.config.max_size.value == 4096)
        check(not heap.config.generational)

    it "creates small heap":
        val heap = ActorHeap__new(HeapConfig__small())
        check(heap.config.initial_size.value == 512)

    it "creates large heap":
        val heap = ActorHeap__new(HeapConfig__large())
        check(heap.config.initial_size.value == 65536)

describe "ActorHeap - Allocation":
    it "allocates memory":
        var heap = ActorHeap__new(HeapConfig__default())
        val result = heap.allocate(100)

        check(result.is_success())

    it "tracks allocation stats":
        var heap = ActorHeap__new(HeapConfig__default())
        heap.allocate(100)
        heap.allocate(200)

        val stats = heap.get_stats()
        check(stats.used_bytes.value == 300)
        check(stats.object_count.value == 2)

    it "fails when heap exhausted":
        val config = HeapConfig(
            initial_size: ByteSize(value: 100),
            max_size: ByteSize(value: 100),
            gc_enabled: false,
            generational: false,
            pretenure_threshold: 0
        )
        var heap = ActorHeap__new(config)

        # Fill the heap
        heap.allocate(90)

        # Next allocation should fail
        val result = heap.allocate(50)
        check(not result.is_success())

    it "handles zero-size allocation":
        var heap = ActorHeap__new(HeapConfig__default())
        val result = heap.allocate(0)

        check(result.is_success())

describe "ActorHeap - Garbage Collection":
    it "triggers GC when threshold reached":
        val config = HeapConfig__default()
        var heap = ActorHeap__new(config)

        heap.allocate(200 * 1024)

        val stats = heap.get_stats()
        check(stats.allocated_bytes.value >= 0)

    it "collects garbage manually":
        var heap = ActorHeap__new(HeapConfig__default())
        heap.allocate(1000)

        heap.collect_garbage()

        val stats = heap.get_stats()
        check(stats.gc_count.value >= 1)

    it "collects young generation only":
        var heap = ActorHeap__new(HeapConfig__default())
        heap.allocate(500)

        heap.collect_young_generation()

        val stats = heap.get_stats()
        check(stats.young_gen_size.value >= 0)

    it "respects gc_enabled flag":
        val config = HeapConfig(
            initial_size: ByteSize(value: 1024),
            max_size: ByteSize(value: 4096),
            gc_enabled: false,
            generational: false,
            pretenure_threshold: 0
        )
        var heap = ActorHeap__new(config)

        heap.collect_garbage()

        val stats = heap.get_stats()
        check(stats.gc_count.value == 0)

describe "ActorHeap - Statistics":
    it "tracks peak usage":
        var heap = ActorHeap__new(HeapConfig__default())

        heap.allocate(100)
        heap.allocate(200)

        val stats = heap.get_stats()
        check(stats.peak_used_bytes.value >= 300)

    it "reports usage percent":
        var heap = ActorHeap__new(HeapConfig__default())
        heap.allocate(100)

        val usage = heap.usage_percent()
        check(usage >= 0)
        check(usage <= 100)

    it "checks heap health":
        var heap = ActorHeap__new(HeapConfig__default())
        heap.allocate(1000)

        check(heap.is_healthy())

describe "ActorHeap - Display":
    it "formats heap for display":
        val heap = ActorHeap__new(HeapConfig__default())
        val s = heap.fmt()

        check(s.contains("ActorHeap"))

    it "formats stats for display":
        val stats = HeapStats__new()
        val s = stats.fmt()

        check(s.contains("HeapStats"))

describe "ActorHeap - Region Management":
    it "tracks young generation":
        var heap = ActorHeap__new(HeapConfig__default())
        heap.allocate(100)

        check(heap.young_generation.used.value >= 100)

    it "handles non-generational heap":
        val config = HeapConfig__no_gc(1024)
        var heap = ActorHeap__new(config)

        heap.allocate(100)

        check(not heap.has_old_generation)
