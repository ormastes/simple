# Mailbox Tests
#
# Tests for off-heap message queue.

use std.mailbox.{
    Mailbox, MailboxConfig, MailboxStats, MessageRef,
    MailboxConfig__default, MailboxConfig__bounded, MailboxConfig__unbounded, MailboxConfig__with_priority,
    MessageRef__new,
    MailboxStats__new,
    Mailbox__new, Mailbox__default, Mailbox__unbounded,
    MessagePriority__High__to_i64, MessagePriority__Normal__to_i64, MessagePriority__Low__to_i64,
    MessagePriority__High__cmp, MessagePriority__Normal__cmp, MessagePriority__Low__cmp,
    SEND_SUCCESS, SEND_QUEUE_FULL, SEND_MAILBOX_CLOSED
}
use std.types.{Capacity}
fn check(condition: bool):
    expect(condition).to_equal(true)
fn check_msg(condition: bool, message: text):
    if not condition:
        expect(message).to_equal("")

describe "Mailbox - Configuration":
    it "creates with default config":
        val mailbox = Mailbox__default()

        check(mailbox.config.capacity.value == 1000)
        check(mailbox.config.off_heap)
        check(not mailbox.config.priority_enabled)

    it "creates unbounded mailbox":
        val mailbox = Mailbox__unbounded()

        check(mailbox.config.capacity.value == 0)

    it "creates bounded mailbox":
        val config = MailboxConfig__bounded(Capacity(value: 500))
        val mailbox = Mailbox__new(config)

        check(mailbox.config.capacity.value == 500)

    it "creates priority-enabled mailbox":
        val config = MailboxConfig__with_priority()
        val mailbox = Mailbox__new(config)

        check(mailbox.config.priority_enabled)

describe "Mailbox - Send":
    it "sends normal message":
        var mailbox = Mailbox__default()
        val result = mailbox.send_normal(12345, 100, 1)

        check(result == SEND_SUCCESS)
        check(mailbox.total_size() == 1)

    it "sends high priority message":
        var mailbox = Mailbox__new(MailboxConfig__with_priority())
        val result = mailbox.send_high(12345, 100, 1)

        check(result == SEND_SUCCESS)
        check(mailbox.stats.high_priority_count.value == 1)

    it "rejects when queue full":
        var mailbox = Mailbox__new(MailboxConfig__bounded(Capacity(value: 2)))

        mailbox.send_normal(1, 10, nil)
        mailbox.send_normal(2, 10, nil)
        val result = mailbox.send_normal(3, 10, nil)

        check(result == SEND_QUEUE_FULL)

    it "reserves space for high priority":
        val config = MailboxConfig(capacity: Capacity(value: 10), off_heap: true, priority_enabled: true, high_priority_reserve: Capacity(value: 1))
        var mailbox = Mailbox__new(config)

        # Fill 9 normal messages (effective_cap = 10 - 1 = 9)
        for i in 0..9:
            mailbox.send_normal(i, 10, nil)

        # Normal fails but high succeeds
        val normal_result = mailbox.send_normal(100, 10, nil)
        val high_result = mailbox.send_high(101, 10, nil)

        check(normal_result == SEND_QUEUE_FULL)
        check(high_result == SEND_SUCCESS)

    it "rejects after close":
        var mailbox = Mailbox__default()
        mailbox.close()

        val result = mailbox.send_normal(1, 10, nil)

        check(result == SEND_MAILBOX_CLOSED)

describe "Mailbox - Receive":
    it "receives in FIFO order":
        var mailbox = Mailbox__default()

        mailbox.send_normal(1, 10, nil)
        mailbox.send_normal(2, 10, nil)
        mailbox.send_normal(3, 10, nil)

        val msg1 = mailbox.receive()
        val msg2 = mailbox.receive()

        check(msg1.id.value == 0)
        check(msg2.id.value == 1)

    it "receives high priority first":
        var mailbox = Mailbox__new(MailboxConfig__with_priority())

        # Send normal first, then high priority
        mailbox.send_normal(3, 10, nil)
        mailbox.send_high(1, 10, nil)

        # Should receive high priority first
        val msg = mailbox.receive()
        check(msg.priority == 0)

    it "returns nil when empty":
        var mailbox = Mailbox__default()
        val msg = mailbox.receive()

        check(not msg.?)

    it "updates stats on receive":
        var mailbox = Mailbox__default()
        mailbox.send_normal(1, 100, nil)
        mailbox.receive()

        val stats = mailbox.get_stats()
        check(stats.total_processed.value == 1)
        check(stats.off_heap_bytes.value == 0)

describe "Mailbox - Selective Receive":
    it "selects by predicate":
        var mailbox = Mailbox__default()

        mailbox.send_normal(100, 10, 1)
        mailbox.send_normal(200, 20, 2)
        mailbox.send_normal(300, 30, 1)

        # Select message from sender 2
        val msg = mailbox.select(fn(m): m.sender_id.value == 2)

        check(msg.?)
        check(msg.sender_id.value == 2)
        # Other messages remain
        check(mailbox.total_size() == 2)

    it "selects by sender":
        var mailbox = Mailbox__default()

        mailbox.send_normal(100, 10, 5)
        mailbox.send_normal(200, 20, 10)

        val msg = mailbox.select_by_sender(10)

        check(msg.?)
        check(msg.sender_id.value == 10)

    it "returns nil when no match":
        var mailbox = Mailbox__default()
        mailbox.send_normal(100, 10, 1)

        val msg = mailbox.select(fn(m): m.sender_id.value == 999)

        check(not msg.?)
        # Message still there
        check(mailbox.total_size() == 1)

describe "Mailbox - Management":
    it "clears all messages":
        var mailbox = Mailbox__default()

        mailbox.send_normal(1, 10, nil)
        mailbox.send_normal(2, 10, nil)
        mailbox.clear()

        check(mailbox.is_empty())
        check(mailbox.stats.current_size.value == 0)

    it "drops stale messages":
        var mailbox = Mailbox__default()

        # Send messages (they'll have timestamp 0 from placeholder)
        mailbox.send_normal(1, 10, nil)
        mailbox.send_normal(2, 10, nil)

        # Drop messages older than -1 (all of them)
        val dropped = mailbox.drop_stale(-1)

        check(dropped == 2)
        check(mailbox.is_empty())

    it "closes mailbox":
        var mailbox = Mailbox__default()
        mailbox.send_normal(1, 10, nil)

        mailbox.close()

        check(mailbox.is_closed)
        # Can still receive existing messages
        val msg = mailbox.receive()
        check(msg.?)

describe "Mailbox - Queries":
    it "reports size":
        var mailbox = Mailbox__default()

        check(mailbox.total_size() == 0)
        mailbox.send_normal(1, 10, nil)
        check(mailbox.total_size() == 1)

    it "reports empty status":
        var mailbox = Mailbox__default()

        check(mailbox.is_empty())
        mailbox.send_normal(1, 10, nil)
        check(not mailbox.is_empty())

    it "reports full status":
        var mailbox = Mailbox__new(MailboxConfig__bounded(Capacity(value: 2)))

        check(not mailbox.is_full())
        mailbox.send_normal(1, 10, nil)
        mailbox.send_normal(2, 10, nil)
        check(mailbox.is_full())

describe "Mailbox - Statistics":
    it "tracks throughput":
        var mailbox = Mailbox__default()

        mailbox.send_normal(1, 10, nil)
        mailbox.send_normal(2, 10, nil)
        mailbox.receive()

        val stats = mailbox.get_stats()
        val tp = stats.throughput()

        # 1 processed / 2 received
        check(tp == 0.5)

    it "tracks drop rate":
        var mailbox = Mailbox__new(MailboxConfig__bounded(Capacity(value: 1)))

        mailbox.send_normal(1, 10, nil)
        mailbox.send_normal(2, 10, nil)  # Dropped

        val stats = mailbox.get_stats()
        val dr = stats.drop_rate()

        # 1 dropped / 2 attempted
        check(dr == 50.0)

    it "tracks peak size":
        var mailbox = Mailbox__default()

        mailbox.send_normal(1, 10, nil)
        mailbox.send_normal(2, 10, nil)
        mailbox.send_normal(3, 10, nil)
        mailbox.receive()
        mailbox.receive()

        val stats = mailbox.get_stats()
        check(stats.peak_size.value == 3)

describe "MessagePriority - Ordering":
    it "compares priorities":
        val high_cmp = MessagePriority__High__cmp(MessagePriority__Normal__to_i64())
        check(high_cmp < 0)
        val normal_cmp = MessagePriority__Normal__cmp(MessagePriority__Low__to_i64())
        check(normal_cmp < 0)
        val low_cmp = MessagePriority__Low__cmp(MessagePriority__High__to_i64())
        check(low_cmp > 0)

    it "converts to i64":
        check(MessagePriority__High__to_i64() == 0)
        check(MessagePriority__Normal__to_i64() == 1)
        check(MessagePriority__Low__to_i64() == 2)

describe "MessageRef - Age":
    it "calculates message age":
        val msg = MessageRef__new(1, nil, 1, 100, 0)
        # With placeholder current_time_ms() returning 0, age is 0
        check(msg.age_ms() == 0)

    it "checks staleness":
        val msg = MessageRef__new(1, nil, 1, 100, 0)
        # Message with age 0 is not stale for positive threshold
        check(not msg.is_stale(1000))
        # But is stale for negative threshold
        check(msg.is_stale(-1))

describe "Mailbox - Display":
    it "formats mailbox for display":
        val mailbox = Mailbox__default()
        val s = mailbox.fmt()

        check(s.contains("Mailbox"))
        check(s.contains("size=0"))

    it "formats stats for display":
        val stats = MailboxStats__new()
        val s = stats.fmt()

        check(s.contains("MailboxStats"))
