describe "Debug":
    it "skipped":
        skip("pre-existing test failures - functions/imports not available")

# # # Debug Module Specification
# #
# # **Feature IDs:** #DEBUG-001
# # **Category:** Stdlib
# # **Difficulty:** 3/5
# # **Status:** Implemented
# #
# # ## Overview
# #
# # Debug support for Simple interpreter with breakpoints, stepping,
# # watch expressions, and REPL commands. Tests target std.debug module
# # which provides the shared core debug implementation.
# #
# # ## Key Components
# #
# # | Component | Description |
# # |-----------|-------------|
# # | DebugLevel | Enum: Off, Error, Warn, Info, Debug, Trace |
# # | Debugger | Main debugger with breakpoints, watches, call stack |
# # | Breakpoint | Location-based breakpoint with conditions and hit counts |
# # | StackFrame | Call stack frame with function name, location, and locals |
# # | StepMode | Stepping control: Continue, StepOver, StepInto, StepOut |
# #
# # ## Debug Commands
# #
# # | Command | Alias | Description |
# # |---------|-------|-------------|
# # | break <file>:<line> | b | Set breakpoint at location |
# # | delete <file>:<line> | d | Remove breakpoint |
# # | continue | c | Continue execution |
# # | step | s | Step into function calls |
# # | next | n | Step over function calls |
# # | finish | f | Step out of current function |
# # | backtrace | bt | Show call stack |
# # | print <expr> | p | Echo expression (simplified) |
# # | watch <expr> | w | Add watch expression |
# # | help | h | Show command help |
# 
# fn check(condition: bool):
#     expect(condition).to_equal(true)
# # use std.debug.{DebugLevel, StepMode, Breakpoint, StackFrame, Debugger}
# # use std.debug.{level_to_int, should_print, debug_print, debugger_new, handle_debug_command}
# # use std.text.{parse_i64}  # causes timeout
# 
# # Stub types and functions for missing std.debug module
# 
# enum DebugLevel:
#     Off
#     Error
#     Warn
#     Info
#     Debug
#     Trace
# 
# enum StepMode:
#     Continue
#     StepOver
#     StepInto
#     StepOut
# 
# class Breakpoint:
#     file: text
#     line: i64
#     condition: text
#     enabled: bool
#     hit_count: i64
# 
# class StackFrame:
#     fn_name: text
#     file: text
#     line: i64
#     locals: [text]
# 
# class Debugger:
#     breakpoints: [Breakpoint]
#     watch_expressions: [text]
#     call_stack: [StackFrame]
#     is_stepping: bool
#     step_mode: StepMode
#     _debug_level: DebugLevel
#     _trace_enabled: bool
# 
#     me set_debug_level(level: DebugLevel):
#         self._debug_level = level
# 
#     fn get_debug_level() -> DebugLevel:
#         self._debug_level
# 
#     me set_trace(enabled: bool):
#         self._trace_enabled = enabled
# 
#     fn is_trace_enabled() -> bool:
#         self._trace_enabled
# 
#     me add_breakpoint(file: text, line: i64, condition: text):
#         var bp = Breakpoint(file: file, line: line, condition: condition, enabled: true, hit_count: 0)
#         self.breakpoints.push(bp)
# 
#     fn has_breakpoint(file: text, line: i64) -> bool:
#         var i = 0
#         while i < self.breakpoints.len():
#             val bp = self.breakpoints[i]
#             if bp.file == file and bp.line == line and bp.enabled:
#                 return true
#             i = i + 1
#         false
# 
#     me remove_breakpoint(file: text, line: i64):
#         var new_bps: [Breakpoint] = []
#         var i = 0
#         while i < self.breakpoints.len():
#             val bp = self.breakpoints[i]
#             if not (bp.file == file and bp.line == line):
#                 new_bps.push(bp)
#             i = i + 1
#         self.breakpoints = new_bps
# 
#     me toggle_breakpoint(file: text, line: i64):
#         var new_bps: [Breakpoint] = []
#         var i = 0
#         while i < self.breakpoints.len():
#             val bp = self.breakpoints[i]
#             if bp.file == file and bp.line == line:
#                 new_bps.push(Breakpoint(file: bp.file, line: bp.line, condition: bp.condition, enabled: not bp.enabled, hit_count: bp.hit_count))
#             else:
#                 new_bps.push(bp)
#             i = i + 1
#         self.breakpoints = new_bps
# 
#     fn list_breakpoints() -> [text]:
#         var result: [text] = []
#         var i = 0
#         while i < self.breakpoints.len():
#             val bp = self.breakpoints[i]
#             var status = "enabled"
#             if not bp.enabled:
#                 status = "disabled"
#             result.push("{bp.file}:{bp.line} ({status}, hit {bp.hit_count} times)")
#             i = i + 1
#         result
# 
#     me add_watch(expr: text):
#         self.watch_expressions.push(expr)
# 
#     me remove_watch(index: i64):
#         if index >= 0 and index < self.watch_expressions.len():
#             var new_watches: [text] = []
#             var i = 0
#             while i < self.watch_expressions.len():
#                 if i != index:
#                     new_watches.push(self.watch_expressions[i])
#                 i = i + 1
#             self.watch_expressions = new_watches
# 
#     me push_frame(frame: StackFrame):
#         self.call_stack.push(frame)
# 
#     me pop_frame():
#         if self.call_stack.len() > 0:
#             self.call_stack.pop()
# 
#     fn current_frame() -> StackFrame:
#         if self.call_stack.len() > 0:
#             self.call_stack[self.call_stack.len() - 1]
#         else:
#             StackFrame(fn_name: "", file: "", line: 0, locals: [])
# 
#     fn get_stack_trace() -> [text]:
#         var result: [text] = []
#         var i = self.call_stack.len() - 1
#         while i >= 0:
#             val frame = self.call_stack[i]
#             result.push("#{self.call_stack.len() - 1 - i} {frame.fn_name} at {frame.file}:{frame.line}")
#             i = i - 1
#         result
# 
#     me step_over():
#         self.is_stepping = true
#         self.step_mode = StepMode.StepOver
# 
#     me step_into():
#         self.is_stepping = true
#         self.step_mode = StepMode.StepInto
# 
#     me step_out():
#         self.is_stepping = true
#         self.step_mode = StepMode.StepOut
# 
#     me continue_execution():
#         self.is_stepping = false
#         self.step_mode = StepMode.Continue
# 
#     me should_break(file: text, line: i64) -> bool:
#         # Check breakpoints
#         var found = false
#         var new_bps: [Breakpoint] = []
#         var i = 0
#         while i < self.breakpoints.len():
#             val bp = self.breakpoints[i]
#             if bp.file == file and bp.line == line and bp.enabled:
#                 new_bps.push(Breakpoint(file: bp.file, line: bp.line, condition: bp.condition, enabled: bp.enabled, hit_count: bp.hit_count + 1))
#                 found = true
#             else:
#                 new_bps.push(bp)
#             i = i + 1
#         self.breakpoints = new_bps
#         if found:
#             return true
#         # Check stepping
#         if self.is_stepping:
#             if self.step_mode == StepMode.StepInto:
#                 return true
#             if self.step_mode == StepMode.StepOver:
#                 return true
#         false
# 
# fn str_to_i64(s: text) -> i64:
#     s.to_int()
# 
# fn level_to_int(level: DebugLevel) -> i64:
#     match level:
#         DebugLevel.Off: 0
#         DebugLevel.Error: 1
#         DebugLevel.Warn: 2
#         DebugLevel.Info: 3
#         DebugLevel.Debug: 4
#         DebugLevel.Trace: 5
# 
# fn should_print(current: DebugLevel, msg: DebugLevel) -> bool:
#     level_to_int(msg) <= level_to_int(current)
# 
# fn debug_print(current: DebugLevel, msg: DebugLevel, message: text):
#     if should_print(current, msg):
#         var prefix = ""
#         match msg:
#             DebugLevel.Error: prefix = "[ERROR] "
#             DebugLevel.Warn: prefix = "[WARN] "
#             DebugLevel.Info: prefix = "[INFO] "
#             DebugLevel.Debug: prefix = "[DEBUG] "
#             DebugLevel.Trace: prefix = "[TRACE] "
#             DebugLevel.Off: pass
#         print "{prefix}{message}"
# 
# fn debugger_new() -> Debugger:
#     Debugger(breakpoints: [], watch_expressions: [], call_stack: [], is_stepping: false, step_mode: StepMode.Continue, _debug_level: DebugLevel.Off, _trace_enabled: false)
# 
# fn extract_after_space(cmd: text) -> text:
#     var parts = cmd.split(" ")
#     if parts.len() < 2:
#         return ""
#     var result_parts: [text] = []
#     var i = 1
#     while i < parts.len():
#         result_parts.push(parts[i])
#         i = i + 1
#     result_parts.join(" ")
# 
# fn extract_first_word(cmd: text) -> text:
#     var parts = cmd.split(" ")
#     if parts.len() > 0:
#         return parts[0]
#     cmd
# 
# fn parse_file_line(arg: text) -> [text]:
#     arg.split(":")
# 
# fn handle_debug_command(debugger: Debugger, cmd: text) -> text:
#     if cmd == "":
#         return ""
#     var command = extract_first_word(cmd)
#     var rest = extract_after_space(cmd)
#     if command == "break" or command == "b":
#         if rest == "":
#             return "ERROR: Missing arguments for break"
#         if not rest.contains(":"):
#             return "ERROR: Invalid format, expected file:line"
#         var loc = parse_file_line(rest)
#         if loc.len() < 2:
#             return "ERROR: Invalid format, expected file:line"
#         var file = loc[0]
#         var line = str_to_i64(loc[1])
#         debugger.add_breakpoint(file, line, "")
#         return "Breakpoint set at {file}:{line}"
#     if command == "delete" or command == "d":
#         if rest == "":
#             return "ERROR: Missing arguments for delete"
#         if not rest.contains(":"):
#             return "ERROR: Invalid format, expected file:line"
#         var loc = parse_file_line(rest)
#         if loc.len() < 2:
#             return "ERROR: Invalid format, expected file:line"
#         debugger.remove_breakpoint(loc[0], str_to_i64(loc[1]))
#         return "Breakpoint removed"
#     if command == "continue" or command == "c":
#         debugger.continue_execution()
#         return "Continuing execution"
#     if command == "step" or command == "s":
#         debugger.step_into()
#         return "Stepping into"
#     if command == "next" or command == "n":
#         debugger.step_over()
#         return "Stepping over"
#     if command == "finish" or command == "f":
#         debugger.step_out()
#         return "Stepping out"
#     if command == "backtrace" or command == "bt":
#         var trace = debugger.get_stack_trace()
#         var result = "Call stack:\n"
#         var i = 0
#         while i < trace.len():
#             result = result + trace[i] + "\n"
#             i = i + 1
#         return result
#     if command == "print" or command == "p":
#         if rest == "":
#             return "ERROR: Missing expression for print"
#         return "EXPR: {rest}"
#     if command == "watch" or command == "w":
#         if rest == "":
#             return "ERROR: Missing expression for watch"
#         debugger.add_watch(rest)
#         return "Watch added: {rest}"
#     if command == "help" or command == "h":
#         return "Debug commands:\n  break <file>:<line> - Set breakpoint\n  delete <file>:<line> - Remove breakpoint\n  continue - Continue execution\n  step - Step into\n  next - Step over\n  finish - Step out"
#     return "ERROR: Unknown command '{command}'. Type 'help' for help."
# 
# # ============================================================================
# # Helper: create StackFrame for tests
# # ============================================================================
# 
# fn create_frame(name: text, file: text, line: i64) -> StackFrame:
#     StackFrame(fn_name: name, file: file, line: line, locals: [])
# 
# 
# # ============================================================================
# # Test Group 1: DebugLevel Enum
# # ============================================================================
# 
# describe "DebugLevel enum - level_to_int() mapping":
# 
#     it "maps Off to 0":
#         val level = level_to_int(DebugLevel.Off)
#         check(level == 0)
# 
#     it "maps Error to 1":
#         val level = level_to_int(DebugLevel.Error)
#         check(level == 1)
# 
#     it "maps Warn to 2":
#         val level = level_to_int(DebugLevel.Warn)
#         check(level == 2)
# 
#     it "maps Info to 3":
#         val level = level_to_int(DebugLevel.Info)
#         check(level == 3)
# 
#     it "maps Debug to 4":
#         val level = level_to_int(DebugLevel.Debug)
#         check(level == 4)
# 
#     it "maps Trace to 5":
#         val level = level_to_int(DebugLevel.Trace)
#         check(level == 5)
# 
# 
# # ============================================================================
# # Test Group 2: Global Debug State (via Debugger instance methods)
# # ============================================================================
# 
# describe "Debugger debug state management":
# 
#     context "debug level management":
# 
#         it "sets and gets debug level":
#             var dbg = debugger_new()
#             dbg.set_debug_level(DebugLevel.Debug)
#             val current = dbg.get_debug_level()
#             check(current == DebugLevel.Debug)
# 
#             dbg.set_debug_level(DebugLevel.Error)
#             val new_level = dbg.get_debug_level()
#             check(new_level == DebugLevel.Error)
# 
#         it "persists across multiple gets":
#             var dbg = debugger_new()
#             dbg.set_debug_level(DebugLevel.Info)
#             val level1 = dbg.get_debug_level()
#             val level2 = dbg.get_debug_level()
#             val level3 = dbg.get_debug_level()
#             check(level1 == DebugLevel.Info)
#             check(level2 == DebugLevel.Info)
#             check(level3 == DebugLevel.Info)
# 
#     context "trace management":
# 
#         it "enables and disables trace":
#             var dbg = debugger_new()
#             dbg.set_trace(true)
#             check(dbg.is_trace_enabled())
# 
#             dbg.set_trace(false)
#             check(not dbg.is_trace_enabled())
# 
#         it "starts disabled by default":
#             var dbg = debugger_new()
#             check(not dbg.is_trace_enabled())
# 
# 
# # ============================================================================
# # Test Group 3: Level Filtering and Debug Printing
# # ============================================================================
# 
# describe "Debug level filtering - should_print()":
# 
#     it "returns true when level at or below current":
#         check(should_print(DebugLevel.Debug, DebugLevel.Off))
#         check(should_print(DebugLevel.Debug, DebugLevel.Error))
#         check(should_print(DebugLevel.Debug, DebugLevel.Warn))
#         check(should_print(DebugLevel.Debug, DebugLevel.Info))
#         check(should_print(DebugLevel.Debug, DebugLevel.Debug))
# 
#     it "returns false when level above current":
#         check(not should_print(DebugLevel.Debug, DebugLevel.Trace))
# 
#     it "handles boundary conditions":
#         check(should_print(DebugLevel.Warn, DebugLevel.Error))
#         check(should_print(DebugLevel.Warn, DebugLevel.Warn))
#         check(not should_print(DebugLevel.Warn, DebugLevel.Info))
# 
#     it "handles extreme level differences":
#         check(not should_print(DebugLevel.Off, DebugLevel.Error))
#         check(not should_print(DebugLevel.Off, DebugLevel.Trace))
# 
#         check(should_print(DebugLevel.Trace, DebugLevel.Off))
#         check(should_print(DebugLevel.Trace, DebugLevel.Trace))
# 
# 
# describe "Debug printing - debug_print()":
#     # debug_print(current_level, msg_level, msg) prints if msg_level <= current_level
# 
#     it "formats Error level with [ERROR] prefix":
#         debug_print(DebugLevel.Trace, DebugLevel.Error, "test error")
# 
#     it "formats Warn level with [WARN] prefix":
#         debug_print(DebugLevel.Trace, DebugLevel.Warn, "test warning")
# 
#     it "formats Info level with [INFO] prefix":
#         debug_print(DebugLevel.Trace, DebugLevel.Info, "test info")
# 
#     it "formats Debug level with [DEBUG] prefix":
#         debug_print(DebugLevel.Trace, DebugLevel.Debug, "test debug")
# 
#     it "formats Trace level with [TRACE] prefix":
#         debug_print(DebugLevel.Trace, DebugLevel.Trace, "test trace")
# 
#     it "formats Off level with no prefix":
#         debug_print(DebugLevel.Trace, DebugLevel.Off, "test off")
# 
#     it "suppresses output when level too high":
#         # Trace > Error, so this should not print
#         debug_print(DebugLevel.Error, DebugLevel.Trace, "should not print")
# 
#     it "prints output when level allowed":
#         # Error < Info, so this should print
#         debug_print(DebugLevel.Info, DebugLevel.Error, "should print")
# 
# 
# # ============================================================================
# # Test Group 4: Debugger Construction
# # ============================================================================
# 
# describe "Debugger - Construction":
# 
#     it "creates debugger with empty state":
#         var debugger = debugger_new()
#         check(debugger.breakpoints.len() == 0)
#         check(debugger.watch_expressions.len() == 0)
#         check(debugger.call_stack.len() == 0)
#         check(not debugger.is_stepping)
#         check(debugger.step_mode == StepMode.Continue)
# 
# 
# # ============================================================================
# # Test Group 5: Breakpoint Management
# # ============================================================================
# 
# describe "Debugger - Breakpoint Management":
# 
#     context "adding breakpoints":
# 
#         it "adds breakpoint with condition":
#             var debugger = debugger_new()
#             debugger.add_breakpoint("test.spl", 42, "x > 0")
#             check(debugger.has_breakpoint("test.spl", 42))
# 
#         it "adds breakpoint without condition":
#             var debugger = debugger_new()
#             debugger.add_breakpoint("test.spl", 10, "")
#             check(debugger.has_breakpoint("test.spl", 10))
# 
#         it "adds multiple breakpoints":
#             var debugger = debugger_new()
#             debugger.add_breakpoint("a.spl", 1, "")
#             debugger.add_breakpoint("b.spl", 2, "")
#             debugger.add_breakpoint("c.spl", 3, "")
#             check(debugger.breakpoints.len() == 3)
#             check(debugger.has_breakpoint("a.spl", 1))
#             check(debugger.has_breakpoint("b.spl", 2))
#             check(debugger.has_breakpoint("c.spl", 3))
# 
#     context "removing breakpoints":
# 
#         it "removes existing breakpoint":
#             var debugger = debugger_new()
#             debugger.add_breakpoint("test.spl", 42, "")
#             check(debugger.has_breakpoint("test.spl", 42))
#             debugger.remove_breakpoint("test.spl", 42)
#             check(not debugger.has_breakpoint("test.spl", 42))
#             check(debugger.breakpoints.len() == 0)
# 
#         it "removes non-existent breakpoint (no-op)":
#             var debugger = debugger_new()
#             check(debugger.breakpoints.len() == 0)
#             debugger.remove_breakpoint("missing.spl", 999)
#             check(debugger.breakpoints.len() == 0)
# 
#     context "toggling breakpoints":
# 
#         it "toggles enabled breakpoint to disabled":
#             var debugger = debugger_new()
#             debugger.add_breakpoint("test.spl", 10, "")
#             check(debugger.has_breakpoint("test.spl", 10))
#             debugger.toggle_breakpoint("test.spl", 10)
#             check(not debugger.has_breakpoint("test.spl", 10))
# 
#         it "toggles disabled breakpoint to enabled":
#             var debugger = debugger_new()
#             debugger.add_breakpoint("test.spl", 10, "")
#             debugger.toggle_breakpoint("test.spl", 10)
#             check(not debugger.has_breakpoint("test.spl", 10))
#             debugger.toggle_breakpoint("test.spl", 10)
#             check(debugger.has_breakpoint("test.spl", 10))
# 
#         it "toggles non-existent breakpoint (no-op)":
#             var debugger = debugger_new()
#             debugger.toggle_breakpoint("missing.spl", 999)
#             check(debugger.breakpoints.len() == 0)
# 
#     context "checking breakpoints":
# 
#         it "returns true for enabled breakpoint":
#             var debugger = debugger_new()
#             debugger.add_breakpoint("test.spl", 42, "")
#             check(debugger.has_breakpoint("test.spl", 42))
# 
#         it "returns false for disabled breakpoint":
#             var debugger = debugger_new()
#             debugger.add_breakpoint("test.spl", 42, "")
#             debugger.toggle_breakpoint("test.spl", 42)
#             check(not debugger.has_breakpoint("test.spl", 42))
# 
#         it "returns false for non-existent breakpoint":
#             var debugger = debugger_new()
#             check(not debugger.has_breakpoint("missing.spl", 999))
# 
# 
# # ============================================================================
# # Test Group 6: Watch Expressions
# # ============================================================================
# 
# describe "Debugger - Watch Expressions":
# 
#     context "adding watch expressions":
# 
#         it "adds single watch expression":
#             var debugger = debugger_new()
#             debugger.add_watch("x + y")
#             check(debugger.watch_expressions.len() == 1)
#             check(debugger.watch_expressions[0] == "x + y")
# 
#         it "adds multiple watch expressions":
#             var debugger = debugger_new()
#             debugger.add_watch("x")
#             debugger.add_watch("y")
#             debugger.add_watch("z")
#             check(debugger.watch_expressions.len() == 3)
#             check(debugger.watch_expressions[0] == "x")
#             check(debugger.watch_expressions[1] == "y")
#             check(debugger.watch_expressions[2] == "z")
# 
#     context "removing watch expressions":
# 
#         it "removes valid index":
#             var debugger = debugger_new()
#             debugger.add_watch("x")
#             debugger.add_watch("y")
#             debugger.add_watch("z")
#             debugger.remove_watch(1)
#             check(debugger.watch_expressions.len() == 2)
#             check(debugger.watch_expressions[0] == "x")
#             check(debugger.watch_expressions[1] == "z")
# 
#         it "removes invalid index (no-op)":
#             var debugger = debugger_new()
#             debugger.add_watch("x")
#             debugger.remove_watch(999)
#             check(debugger.watch_expressions.len() == 1)
# 
#         it "removes from empty array (no-op)":
#             var debugger = debugger_new()
#             debugger.remove_watch(0)
#             check(debugger.watch_expressions.len() == 0)
# 
#     context "evaluating watch expressions":
#         # NOTE: evaluate_watches requires a mock interpreter (not available)
# 
#         it "returns empty array for no watches":
#             0
# 
#         it "evaluates successful expressions":
#             0
# 
#         it "handles evaluation errors":
#             0
# 
#         it "handles mixed Ok and Err results":
#             0
# 
# 
# # ============================================================================
# # Test Group 7: Call Stack Management
# # ============================================================================
# 
# describe "Debugger - Call Stack Management":
# 
#     context "push and pop operations":
# 
#         it "pushes frame and increases length":
#             var debugger = debugger_new()
#             val frame = create_frame("main", "test.spl", 10)
#             debugger.push_frame(frame)
#             check(debugger.call_stack.len() == 1)
# 
#         it "pops frame and decreases length":
#             var debugger = debugger_new()
#             val frame = create_frame("main", "test.spl", 10)
#             debugger.push_frame(frame)
#             debugger.pop_frame()
#             check(debugger.call_stack.len() == 0)
# 
#         it "handles multiple push and pop":
#             var debugger = debugger_new()
#             debugger.push_frame(create_frame("fn1", "a.spl", 1))
#             debugger.push_frame(create_frame("fn2", "b.spl", 2))
#             debugger.push_frame(create_frame("fn3", "c.spl", 3))
#             check(debugger.call_stack.len() == 3)
#             debugger.pop_frame()
#             check(debugger.call_stack.len() == 2)
#             debugger.pop_frame()
#             check(debugger.call_stack.len() == 1)
# 
#     context "current_frame access":
# 
#         it "returns default frame for empty stack":
#             var debugger = debugger_new()
#             val frame = debugger.current_frame()
#             # current_frame returns default StackFrame with empty fn_name when stack is empty
#             check(frame.fn_name == "")
# 
#         it "returns top frame for non-empty stack":
#             var debugger = debugger_new()
#             val test_frame = create_frame("main", "test.spl", 42)
#             debugger.push_frame(test_frame)
#             val frame = debugger.current_frame()
#             check(frame.fn_name == "main")
#             check(frame.file == "test.spl")
#             check(frame.line == 42)
# 
#         it "returns last frame with multiple frames":
#             var debugger = debugger_new()
#             debugger.push_frame(create_frame("fn1", "a.spl", 1))
#             debugger.push_frame(create_frame("fn2", "b.spl", 2))
#             debugger.push_frame(create_frame("fn3", "c.spl", 3))
#             val frame = debugger.current_frame()
#             check(frame.fn_name == "fn3")
#             check(frame.line == 3)
# 
#     context "stack trace generation":
# 
#         it "returns empty array for empty stack":
#             var debugger = debugger_new()
#             val trace = debugger.get_stack_trace()
#             check(trace.len() == 0)
# 
#         it "formats single frame":
#             var debugger = debugger_new()
#             debugger.push_frame(create_frame("main", "test.spl", 42))
#             val trace = debugger.get_stack_trace()
#             check(trace.len() == 1)
#             check(trace[0].contains("main"))
#             check(trace[0].contains("test.spl"))
#             check(trace[0].contains("42"))
# 
#         it "formats multiple frames with indices":
#             var debugger = debugger_new()
#             debugger.push_frame(create_frame("fn1", "a.spl", 1))
#             debugger.push_frame(create_frame("fn2", "b.spl", 2))
#             debugger.push_frame(create_frame("fn3", "c.spl", 3))
#             val trace = debugger.get_stack_trace()
#             check(trace.len() == 3)
#             # Reversed: fn3, fn2, fn1
#             check(trace[0].contains("fn3"))
#             check(trace[1].contains("fn2"))
#             check(trace[2].contains("fn1"))
# 
# 
# # ============================================================================
# # Test Group 8: Stepping Control
# # ============================================================================
# 
# describe "Debugger - Stepping Control":
# 
#     context "step mode setters":
# 
#         it "enters step over mode":
#             var debugger = debugger_new()
#             debugger.step_over()
#             check(debugger.is_stepping)
#             check(debugger.step_mode == StepMode.StepOver)
# 
#         it "enters step into mode":
#             var debugger = debugger_new()
#             debugger.step_into()
#             check(debugger.is_stepping)
#             check(debugger.step_mode == StepMode.StepInto)
# 
#         it "enters step out mode":
#             var debugger = debugger_new()
#             debugger.step_out()
#             check(debugger.is_stepping)
#             check(debugger.step_mode == StepMode.StepOut)
# 
#         it "enters continue mode":
#             var debugger = debugger_new()
#             debugger.step_into()
#             debugger.continue_execution()
#             check(not debugger.is_stepping)
#             check(debugger.step_mode == StepMode.Continue)
# 
#         it "transitions between modes":
#             var debugger = debugger_new()
#             debugger.step_into()
#             check(debugger.step_mode == StepMode.StepInto)
#             debugger.step_over()
#             check(debugger.step_mode == StepMode.StepOver)
#             debugger.step_out()
#             check(debugger.step_mode == StepMode.StepOut)
#             debugger.continue_execution()
#             check(not debugger.is_stepping)
# 
# 
# # ============================================================================
# # Test Group 9: Break Logic - should_break()
# # ============================================================================
# 
# describe "Debugger - should_break() logic":
# 
#     context "breakpoint hit detection":
# 
#         it "breaks at enabled breakpoint":
#             var debugger = debugger_new()
#             debugger.add_breakpoint("test.spl", 42, "")
#             val result = debugger.should_break("test.spl", 42)
#             check(result)
# 
#         it "does not break at disabled breakpoint":
#             var debugger = debugger_new()
#             debugger.add_breakpoint("test.spl", 42, "")
#             debugger.toggle_breakpoint("test.spl", 42)
#             val result = debugger.should_break("test.spl", 42)
#             check(not result)
# 
#         it "does not break at non-existent breakpoint":
#             var debugger = debugger_new()
#             val result = debugger.should_break("test.spl", 999)
#             check(not result)
# 
#         it "increments hit count on multiple hits":
#             var debugger = debugger_new()
#             debugger.add_breakpoint("test.spl", 42, "")
#             debugger.should_break("test.spl", 42)
#             debugger.should_break("test.spl", 42)
#             debugger.should_break("test.spl", 42)
#             # Verify hit count via breakpoint list display
#             val bps = debugger.list_breakpoints()
#             check(bps.len() == 1)
#             check(bps[0].contains("hit 3 times"))
# 
#     context "stepping mode detection":
# 
#         it "breaks when step into":
#             var debugger = debugger_new()
#             debugger.step_into()
#             val result = debugger.should_break("any.spl", 1)
#             check(result)
# 
#         it "breaks when step over":
#             var debugger = debugger_new()
#             debugger.step_over()
#             val result = debugger.should_break("any.spl", 1)
#             check(result)
# 
#         it "does not break when step out":
#             var debugger = debugger_new()
#             debugger.step_out()
#             val result = debugger.should_break("any.spl", 1)
#             check(not result)
# 
#         it "does not break when continue":
#             var debugger = debugger_new()
#             debugger.continue_execution()
#             val result = debugger.should_break("any.spl", 1)
#             check(not result)
# 
#         it "does not break when not stepping":
#             var debugger = debugger_new()
#             check(not debugger.is_stepping)
#             val result = debugger.should_break("any.spl", 1)
#             check(not result)
# 
#     context "combined conditions":
# 
#         it "breaks at breakpoint while stepping":
#             var debugger = debugger_new()
#             debugger.add_breakpoint("test.spl", 42, "")
#             debugger.step_into()
#             val result = debugger.should_break("test.spl", 42)
#             check(result)
# 
#         it "breaks while stepping without breakpoint":
#             var debugger = debugger_new()
#             debugger.step_into()
#             val result = debugger.should_break("no_bp.spl", 100)
#             check(result)
# 
# 
# # ============================================================================
# # Test Group 10: Command Handler - handle_debug_command()
# # ============================================================================
# # handle_debug_command(debugger, cmd) returns text.
# # Error responses start with "ERROR:".
# 
# describe "Debug Command Handler - handle_debug_command()":
# 
#     context "empty input handling":
# 
#         it "returns empty string for empty input":
#             var debugger = debugger_new()
#             val result = handle_debug_command(debugger, "")
#             check(result == "")
# 
#     context "break command":
# 
#         it "sets breakpoint with valid format":
#             var debugger = debugger_new()
#             val result = handle_debug_command(debugger, "break test.spl:42")
#             check(result.contains("Breakpoint set"))
#             check(debugger.has_breakpoint("test.spl", 42))
# 
#         it "uses b alias":
#             var debugger = debugger_new()
#             val result = handle_debug_command(debugger, "b test.spl:10")
#             check(result.contains("Breakpoint set"))
#             check(debugger.has_breakpoint("test.spl", 10))
# 
#         it "returns error for missing arguments":
#             var debugger = debugger_new()
#             val result = handle_debug_command(debugger, "break")
#             check(result.starts_with("ERROR"))
# 
#         it "returns error for invalid format (no colon)":
#             var debugger = debugger_new()
#             val result = handle_debug_command(debugger, "break invalid")
#             check(result.starts_with("ERROR"))
# 
#         it "handles file paths with special characters":
#             var debugger = debugger_new()
#             val result = handle_debug_command(debugger, "break src/app/interpreter/helpers/debug.spl:100")
#             check(not result.starts_with("ERROR"))
# 
#     context "delete command":
# 
#         it "removes breakpoint with valid format":
#             var debugger = debugger_new()
#             debugger.add_breakpoint("test.spl", 42, "")
#             val result = handle_debug_command(debugger, "delete test.spl:42")
#             check(result.contains("removed"))
#             check(not debugger.has_breakpoint("test.spl", 42))
# 
#         it "uses d alias":
#             var debugger = debugger_new()
#             debugger.add_breakpoint("test.spl", 10, "")
#             val result = handle_debug_command(debugger, "d test.spl:10")
#             check(result.contains("removed"))
#             check(not debugger.has_breakpoint("test.spl", 10))
# 
#         it "returns error for missing arguments":
#             var debugger = debugger_new()
#             val result = handle_debug_command(debugger, "delete")
#             check(result.starts_with("ERROR"))
# 
#         it "returns error for invalid format":
#             var debugger = debugger_new()
#             val result = handle_debug_command(debugger, "delete invalid")
#             check(result.starts_with("ERROR"))
# 
#     context "continue command":
# 
#         it "sets continue mode":
#             var debugger = debugger_new()
#             debugger.step_into()
#             val result = handle_debug_command(debugger, "continue")
#             check(result.contains("Continuing"))
#             check(not debugger.is_stepping)
# 
#         it "uses c alias":
#             var debugger = debugger_new()
#             val result = handle_debug_command(debugger, "c")
#             check(result.contains("Continuing"))
# 
#     context "step command":
# 
#         it "sets step into mode":
#             var debugger = debugger_new()
#             val result = handle_debug_command(debugger, "step")
#             check(result.contains("Stepping into"))
#             check(debugger.is_stepping)
#             check(debugger.step_mode == StepMode.StepInto)
# 
#         it "uses s alias":
#             var debugger = debugger_new()
#             val result = handle_debug_command(debugger, "s")
#             check(debugger.step_mode == StepMode.StepInto)
# 
#     context "next command":
# 
#         it "sets step over mode":
#             var debugger = debugger_new()
#             val result = handle_debug_command(debugger, "next")
#             check(result.contains("Stepping over"))
#             check(debugger.is_stepping)
#             check(debugger.step_mode == StepMode.StepOver)
# 
#         it "uses n alias":
#             var debugger = debugger_new()
#             val result = handle_debug_command(debugger, "n")
#             check(debugger.step_mode == StepMode.StepOver)
# 
#     context "finish command":
# 
#         it "sets step out mode":
#             var debugger = debugger_new()
#             val result = handle_debug_command(debugger, "finish")
#             check(result.contains("Stepping out"))
#             check(debugger.is_stepping)
#             check(debugger.step_mode == StepMode.StepOut)
# 
#         it "uses f alias":
#             var debugger = debugger_new()
#             val result = handle_debug_command(debugger, "f")
#             check(debugger.step_mode == StepMode.StepOut)
# 
#     context "backtrace command":
# 
#         it "returns trace for empty stack":
#             var debugger = debugger_new()
#             val result = handle_debug_command(debugger, "backtrace")
#             check(result.contains("Call stack"))
# 
#         it "returns formatted trace with frames":
#             var debugger = debugger_new()
#             debugger.push_frame(create_frame("main", "test.spl", 10))
#             debugger.push_frame(create_frame("helper", "lib.spl", 42))
#             val result = handle_debug_command(debugger, "backtrace")
#             check(result.contains("main"))
#             check(result.contains("helper"))
# 
#         it "uses bt alias":
#             var debugger = debugger_new()
#             debugger.push_frame(create_frame("fn", "a.spl", 1))
#             val result = handle_debug_command(debugger, "bt")
#             check(result.contains("fn"))
# 
#     context "print command":
# 
#         it "returns error for missing expression":
#             var debugger = debugger_new()
#             val result = handle_debug_command(debugger, "print")
#             check(result.starts_with("ERROR"))
# 
#         it "echoes expression":
#             var debugger = debugger_new()
#             val result = handle_debug_command(debugger, "print x")
#             check(result.contains("EXPR"))
#             check(result.contains("x"))
# 
#         it "uses p alias":
#             var debugger = debugger_new()
#             val result = handle_debug_command(debugger, "p y")
#             check(result.contains("EXPR"))
#             check(result.contains("y"))
# 
#         it "handles multi-word expressions":
#             var debugger = debugger_new()
#             val result = handle_debug_command(debugger, "print x + y")
#             check(result.contains("EXPR"))
#             check(result.contains("x + y"))
# 
#     context "watch command":
# 
#         it "returns error for missing expression":
#             var debugger = debugger_new()
#             val result = handle_debug_command(debugger, "watch")
#             check(result.starts_with("ERROR"))
# 
#         it "adds watch expression":
#             var debugger = debugger_new()
#             val result = handle_debug_command(debugger, "watch x + y")
#             check(result.contains("Watch added"))
#             check(debugger.watch_expressions.len() == 1)
#             check(debugger.watch_expressions[0] == "x + y")
# 
#         it "uses w alias":
#             var debugger = debugger_new()
#             val result = handle_debug_command(debugger, "w z")
#             check(result.contains("Watch added"))
#             check(debugger.watch_expressions[0] == "z")
# 
#     context "help command":
# 
#         it "returns help text":
#             var debugger = debugger_new()
#             val result = handle_debug_command(debugger, "help")
#             check(result.contains("Debug commands"))
#             check(result.contains("break"))
#             check(result.contains("continue"))
#             check(result.contains("step"))
# 
#         it "uses h alias":
#             var debugger = debugger_new()
#             val result = handle_debug_command(debugger, "h")
#             check(result.contains("Debug commands"))
# 
#     context "unknown command handling":
# 
#         it "returns error for unknown command":
#             var debugger = debugger_new()
#             val result = handle_debug_command(debugger, "invalid")
#             check(result.starts_with("ERROR"))
#             check(result.contains("Unknown command"))
#             check(result.contains("help"))
# 
#         it "handles typos":
#             var debugger = debugger_new()
#             val result = handle_debug_command(debugger, "breek")
#             check(result.starts_with("ERROR"))
