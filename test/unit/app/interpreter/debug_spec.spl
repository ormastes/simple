"""
# Debug Module Specification

**Feature IDs:** #DEBUG-001
**Category:** Stdlib
**Difficulty:** 3/5
**Status:** Implemented

## Overview

Debug support for Simple interpreter with breakpoints, stepping,
watch expressions, and REPL commands. Tests target std.debug module
which provides the shared core debug implementation.

## Key Components

| Component | Description |
|-----------|-------------|
| DebugLevel | Enum: Off, Error, Warn, Info, Debug, Trace |
| Debugger | Main debugger with breakpoints, watches, call stack |
| Breakpoint | Location-based breakpoint with conditions and hit counts |
| StackFrame | Call stack frame with function name, location, and locals |
| StepMode | Stepping control: Continue, StepOver, StepInto, StepOut |

## Debug Commands

| Command | Alias | Description |
|---------|-------|-------------|
| break <file>:<line> | b | Set breakpoint at location |
| delete <file>:<line> | d | Remove breakpoint |
| continue | c | Continue execution |
| step | s | Step into function calls |
| next | n | Step over function calls |
| finish | f | Step out of current function |
| backtrace | bt | Show call stack |
| print <expr> | p | Echo expression (simplified) |
| watch <expr> | w | Add watch expression |
| help | h | Show command help |
"""

use std.spec.{check, skip_it}
use std.debug.{DebugLevel, StepMode, Breakpoint, StackFrame, Debugger}
use std.debug.{level_to_int, should_print, debug_print, debugger_new, handle_debug_command}

# ============================================================================
# Helper: create StackFrame for tests
# ============================================================================

fn create_frame(name: text, file: text, line: i64) -> StackFrame:
    StackFrame(fn_name: name, file: file, line: line, locals: [])


# ============================================================================
# Test Group 1: DebugLevel Enum
# ============================================================================

describe "DebugLevel enum - level_to_int() mapping":

    it "maps Off to 0":
        val level = level_to_int(DebugLevel.Off)
        check(level == 0)

    it "maps Error to 1":
        val level = level_to_int(DebugLevel.Error)
        check(level == 1)

    it "maps Warn to 2":
        val level = level_to_int(DebugLevel.Warn)
        check(level == 2)

    it "maps Info to 3":
        val level = level_to_int(DebugLevel.Info)
        check(level == 3)

    it "maps Debug to 4":
        val level = level_to_int(DebugLevel.Debug)
        check(level == 4)

    it "maps Trace to 5":
        val level = level_to_int(DebugLevel.Trace)
        check(level == 5)


# ============================================================================
# Test Group 2: Global Debug State (via Debugger instance methods)
# ============================================================================

describe "Debugger debug state management":

    context "debug level management":

        it "sets and gets debug level":
            var dbg = debugger_new()
            dbg.set_debug_level(DebugLevel.Debug)
            val current = dbg.get_debug_level()
            check(current == DebugLevel.Debug)

            dbg.set_debug_level(DebugLevel.Error)
            val new_level = dbg.get_debug_level()
            check(new_level == DebugLevel.Error)

        it "persists across multiple gets":
            var dbg = debugger_new()
            dbg.set_debug_level(DebugLevel.Info)
            val level1 = dbg.get_debug_level()
            val level2 = dbg.get_debug_level()
            val level3 = dbg.get_debug_level()
            check(level1 == DebugLevel.Info)
            check(level2 == DebugLevel.Info)
            check(level3 == DebugLevel.Info)

    context "trace management":

        it "enables and disables trace":
            var dbg = debugger_new()
            dbg.set_trace(true)
            check(dbg.is_trace_enabled())

            dbg.set_trace(false)
            check(not dbg.is_trace_enabled())

        it "starts disabled by default":
            var dbg = debugger_new()
            check(not dbg.is_trace_enabled())


# ============================================================================
# Test Group 3: Level Filtering and Debug Printing
# ============================================================================

describe "Debug level filtering - should_print()":

    it "returns true when level at or below current":
        check(should_print(DebugLevel.Debug, DebugLevel.Off))
        check(should_print(DebugLevel.Debug, DebugLevel.Error))
        check(should_print(DebugLevel.Debug, DebugLevel.Warn))
        check(should_print(DebugLevel.Debug, DebugLevel.Info))
        check(should_print(DebugLevel.Debug, DebugLevel.Debug))

    it "returns false when level above current":
        check(not should_print(DebugLevel.Debug, DebugLevel.Trace))

    it "handles boundary conditions":
        check(should_print(DebugLevel.Warn, DebugLevel.Error))
        check(should_print(DebugLevel.Warn, DebugLevel.Warn))
        check(not should_print(DebugLevel.Warn, DebugLevel.Info))

    it "handles extreme level differences":
        check(not should_print(DebugLevel.Off, DebugLevel.Error))
        check(not should_print(DebugLevel.Off, DebugLevel.Trace))

        check(should_print(DebugLevel.Trace, DebugLevel.Off))
        check(should_print(DebugLevel.Trace, DebugLevel.Trace))


describe "Debug printing - debug_print()":
    # debug_print(current_level, msg_level, msg) prints if msg_level <= current_level

    it "formats Error level with [ERROR] prefix":
        debug_print(DebugLevel.Trace, DebugLevel.Error, "test error")

    it "formats Warn level with [WARN] prefix":
        debug_print(DebugLevel.Trace, DebugLevel.Warn, "test warning")

    it "formats Info level with [INFO] prefix":
        debug_print(DebugLevel.Trace, DebugLevel.Info, "test info")

    it "formats Debug level with [DEBUG] prefix":
        debug_print(DebugLevel.Trace, DebugLevel.Debug, "test debug")

    it "formats Trace level with [TRACE] prefix":
        debug_print(DebugLevel.Trace, DebugLevel.Trace, "test trace")

    it "formats Off level with no prefix":
        debug_print(DebugLevel.Trace, DebugLevel.Off, "test off")

    it "suppresses output when level too high":
        # Trace > Error, so this should not print
        debug_print(DebugLevel.Error, DebugLevel.Trace, "should not print")

    it "prints output when level allowed":
        # Error < Info, so this should print
        debug_print(DebugLevel.Info, DebugLevel.Error, "should print")


# ============================================================================
# Test Group 4: Debugger Construction
# ============================================================================

describe "Debugger - Construction":

    it "creates debugger with empty state":
        var debugger = debugger_new()
        check(debugger.breakpoints.len() == 0)
        check(debugger.watch_expressions.len() == 0)
        check(debugger.call_stack.len() == 0)
        check(not debugger.is_stepping)
        check(debugger.step_mode == StepMode.Continue)


# ============================================================================
# Test Group 5: Breakpoint Management
# ============================================================================

describe "Debugger - Breakpoint Management":

    context "adding breakpoints":

        it "adds breakpoint with condition":
            var debugger = debugger_new()
            debugger.add_breakpoint("test.spl", 42, "x > 0")
            check(debugger.has_breakpoint("test.spl", 42))

        it "adds breakpoint without condition":
            var debugger = debugger_new()
            debugger.add_breakpoint("test.spl", 10, "")
            check(debugger.has_breakpoint("test.spl", 10))

        it "adds multiple breakpoints":
            var debugger = debugger_new()
            debugger.add_breakpoint("a.spl", 1, "")
            debugger.add_breakpoint("b.spl", 2, "")
            debugger.add_breakpoint("c.spl", 3, "")
            check(debugger.breakpoints.len() == 3)
            check(debugger.has_breakpoint("a.spl", 1))
            check(debugger.has_breakpoint("b.spl", 2))
            check(debugger.has_breakpoint("c.spl", 3))

    context "removing breakpoints":

        it "removes existing breakpoint":
            var debugger = debugger_new()
            debugger.add_breakpoint("test.spl", 42, "")
            check(debugger.has_breakpoint("test.spl", 42))
            debugger.remove_breakpoint("test.spl", 42)
            check(not debugger.has_breakpoint("test.spl", 42))
            check(debugger.breakpoints.len() == 0)

        it "removes non-existent breakpoint (no-op)":
            var debugger = debugger_new()
            check(debugger.breakpoints.len() == 0)
            debugger.remove_breakpoint("missing.spl", 999)
            check(debugger.breakpoints.len() == 0)

    context "toggling breakpoints":

        it "toggles enabled breakpoint to disabled":
            var debugger = debugger_new()
            debugger.add_breakpoint("test.spl", 10, "")
            check(debugger.has_breakpoint("test.spl", 10))
            debugger.toggle_breakpoint("test.spl", 10)
            check(not debugger.has_breakpoint("test.spl", 10))

        it "toggles disabled breakpoint to enabled":
            var debugger = debugger_new()
            debugger.add_breakpoint("test.spl", 10, "")
            debugger.toggle_breakpoint("test.spl", 10)
            check(not debugger.has_breakpoint("test.spl", 10))
            debugger.toggle_breakpoint("test.spl", 10)
            check(debugger.has_breakpoint("test.spl", 10))

        it "toggles non-existent breakpoint (no-op)":
            var debugger = debugger_new()
            debugger.toggle_breakpoint("missing.spl", 999)
            check(debugger.breakpoints.len() == 0)

    context "checking breakpoints":

        it "returns true for enabled breakpoint":
            var debugger = debugger_new()
            debugger.add_breakpoint("test.spl", 42, "")
            check(debugger.has_breakpoint("test.spl", 42))

        it "returns false for disabled breakpoint":
            var debugger = debugger_new()
            debugger.add_breakpoint("test.spl", 42, "")
            debugger.toggle_breakpoint("test.spl", 42)
            check(not debugger.has_breakpoint("test.spl", 42))

        it "returns false for non-existent breakpoint":
            var debugger = debugger_new()
            check(not debugger.has_breakpoint("missing.spl", 999))


# ============================================================================
# Test Group 6: Watch Expressions
# ============================================================================

describe "Debugger - Watch Expressions":

    context "adding watch expressions":

        it "adds single watch expression":
            var debugger = debugger_new()
            debugger.add_watch("x + y")
            check(debugger.watch_expressions.len() == 1)
            check(debugger.watch_expressions[0] == "x + y")

        it "adds multiple watch expressions":
            var debugger = debugger_new()
            debugger.add_watch("x")
            debugger.add_watch("y")
            debugger.add_watch("z")
            check(debugger.watch_expressions.len() == 3)
            check(debugger.watch_expressions[0] == "x")
            check(debugger.watch_expressions[1] == "y")
            check(debugger.watch_expressions[2] == "z")

    context "removing watch expressions":

        it "removes valid index":
            var debugger = debugger_new()
            debugger.add_watch("x")
            debugger.add_watch("y")
            debugger.add_watch("z")
            debugger.remove_watch(1)
            check(debugger.watch_expressions.len() == 2)
            check(debugger.watch_expressions[0] == "x")
            check(debugger.watch_expressions[1] == "z")

        it "removes invalid index (no-op)":
            var debugger = debugger_new()
            debugger.add_watch("x")
            debugger.remove_watch(999)
            check(debugger.watch_expressions.len() == 1)

        it "removes from empty array (no-op)":
            var debugger = debugger_new()
            debugger.remove_watch(0)
            check(debugger.watch_expressions.len() == 0)

    context "evaluating watch expressions":
        # NOTE: evaluate_watches requires a mock interpreter (not available)

        skip_it "returns empty array for no watches":
            pass_do_nothing

        skip_it "evaluates successful expressions":
            pass_do_nothing

        skip_it "handles evaluation errors":
            pass_do_nothing

        skip_it "handles mixed Ok and Err results":
            pass_do_nothing


# ============================================================================
# Test Group 7: Call Stack Management
# ============================================================================

describe "Debugger - Call Stack Management":

    context "push and pop operations":

        it "pushes frame and increases length":
            var debugger = debugger_new()
            val frame = create_frame("main", "test.spl", 10)
            debugger.push_frame(frame)
            check(debugger.call_stack.len() == 1)

        it "pops frame and decreases length":
            var debugger = debugger_new()
            val frame = create_frame("main", "test.spl", 10)
            debugger.push_frame(frame)
            debugger.pop_frame()
            check(debugger.call_stack.len() == 0)

        it "handles multiple push and pop":
            var debugger = debugger_new()
            debugger.push_frame(create_frame("fn1", "a.spl", 1))
            debugger.push_frame(create_frame("fn2", "b.spl", 2))
            debugger.push_frame(create_frame("fn3", "c.spl", 3))
            check(debugger.call_stack.len() == 3)
            debugger.pop_frame()
            check(debugger.call_stack.len() == 2)
            debugger.pop_frame()
            check(debugger.call_stack.len() == 1)

    context "current_frame access":

        it "returns default frame for empty stack":
            var debugger = debugger_new()
            val frame = debugger.current_frame()
            # current_frame returns default StackFrame with empty fn_name when stack is empty
            check(frame.fn_name == "")

        it "returns top frame for non-empty stack":
            var debugger = debugger_new()
            val test_frame = create_frame("main", "test.spl", 42)
            debugger.push_frame(test_frame)
            val frame = debugger.current_frame()
            check(frame.fn_name == "main")
            check(frame.file == "test.spl")
            check(frame.line == 42)

        it "returns last frame with multiple frames":
            var debugger = debugger_new()
            debugger.push_frame(create_frame("fn1", "a.spl", 1))
            debugger.push_frame(create_frame("fn2", "b.spl", 2))
            debugger.push_frame(create_frame("fn3", "c.spl", 3))
            val frame = debugger.current_frame()
            check(frame.fn_name == "fn3")
            check(frame.line == 3)

    context "stack trace generation":

        it "returns empty array for empty stack":
            var debugger = debugger_new()
            val trace = debugger.get_stack_trace()
            check(trace.len() == 0)

        it "formats single frame":
            var debugger = debugger_new()
            debugger.push_frame(create_frame("main", "test.spl", 42))
            val trace = debugger.get_stack_trace()
            check(trace.len() == 1)
            check(trace[0].contains("main"))
            check(trace[0].contains("test.spl"))
            check(trace[0].contains("42"))

        it "formats multiple frames with indices":
            var debugger = debugger_new()
            debugger.push_frame(create_frame("fn1", "a.spl", 1))
            debugger.push_frame(create_frame("fn2", "b.spl", 2))
            debugger.push_frame(create_frame("fn3", "c.spl", 3))
            val trace = debugger.get_stack_trace()
            check(trace.len() == 3)
            # Reversed: fn3, fn2, fn1
            check(trace[0].contains("fn3"))
            check(trace[1].contains("fn2"))
            check(trace[2].contains("fn1"))


# ============================================================================
# Test Group 8: Stepping Control
# ============================================================================

describe "Debugger - Stepping Control":

    context "step mode setters":

        it "enters step over mode":
            var debugger = debugger_new()
            debugger.step_over()
            check(debugger.is_stepping)
            check(debugger.step_mode == StepMode.StepOver)

        it "enters step into mode":
            var debugger = debugger_new()
            debugger.step_into()
            check(debugger.is_stepping)
            check(debugger.step_mode == StepMode.StepInto)

        it "enters step out mode":
            var debugger = debugger_new()
            debugger.step_out()
            check(debugger.is_stepping)
            check(debugger.step_mode == StepMode.StepOut)

        it "enters continue mode":
            var debugger = debugger_new()
            debugger.step_into()
            debugger.continue_execution()
            check(not debugger.is_stepping)
            check(debugger.step_mode == StepMode.Continue)

        it "transitions between modes":
            var debugger = debugger_new()
            debugger.step_into()
            check(debugger.step_mode == StepMode.StepInto)
            debugger.step_over()
            check(debugger.step_mode == StepMode.StepOver)
            debugger.step_out()
            check(debugger.step_mode == StepMode.StepOut)
            debugger.continue_execution()
            check(not debugger.is_stepping)


# ============================================================================
# Test Group 9: Break Logic - should_break()
# ============================================================================

describe "Debugger - should_break() logic":

    context "breakpoint hit detection":

        it "breaks at enabled breakpoint":
            var debugger = debugger_new()
            debugger.add_breakpoint("test.spl", 42, "")
            val result = debugger.should_break("test.spl", 42)
            check(result)

        it "does not break at disabled breakpoint":
            var debugger = debugger_new()
            debugger.add_breakpoint("test.spl", 42, "")
            debugger.toggle_breakpoint("test.spl", 42)
            val result = debugger.should_break("test.spl", 42)
            check(not result)

        it "does not break at non-existent breakpoint":
            var debugger = debugger_new()
            val result = debugger.should_break("test.spl", 999)
            check(not result)

        it "increments hit count on multiple hits":
            var debugger = debugger_new()
            debugger.add_breakpoint("test.spl", 42, "")
            debugger.should_break("test.spl", 42)
            debugger.should_break("test.spl", 42)
            debugger.should_break("test.spl", 42)
            # Verify hit count via breakpoint list display
            val bps = debugger.list_breakpoints()
            check(bps.len() == 1)
            check(bps[0].contains("hit 3 times"))

    context "stepping mode detection":

        it "breaks when step into":
            var debugger = debugger_new()
            debugger.step_into()
            val result = debugger.should_break("any.spl", 1)
            check(result)

        it "breaks when step over":
            var debugger = debugger_new()
            debugger.step_over()
            val result = debugger.should_break("any.spl", 1)
            check(result)

        it "does not break when step out":
            var debugger = debugger_new()
            debugger.step_out()
            val result = debugger.should_break("any.spl", 1)
            check(not result)

        it "does not break when continue":
            var debugger = debugger_new()
            debugger.continue_execution()
            val result = debugger.should_break("any.spl", 1)
            check(not result)

        it "does not break when not stepping":
            var debugger = debugger_new()
            check(not debugger.is_stepping)
            val result = debugger.should_break("any.spl", 1)
            check(not result)

    context "combined conditions":

        it "breaks at breakpoint while stepping":
            var debugger = debugger_new()
            debugger.add_breakpoint("test.spl", 42, "")
            debugger.step_into()
            val result = debugger.should_break("test.spl", 42)
            check(result)

        it "breaks while stepping without breakpoint":
            var debugger = debugger_new()
            debugger.step_into()
            val result = debugger.should_break("no_bp.spl", 100)
            check(result)


# ============================================================================
# Test Group 10: Command Handler - handle_debug_command()
# ============================================================================
# handle_debug_command(debugger, cmd) returns text.
# Error responses start with "ERROR:".

describe "Debug Command Handler - handle_debug_command()":

    context "empty input handling":

        it "returns empty string for empty input":
            var debugger = debugger_new()
            val result = handle_debug_command(debugger, "")
            check(result == "")

    context "break command":

        it "sets breakpoint with valid format":
            var debugger = debugger_new()
            val result = handle_debug_command(debugger, "break test.spl:42")
            check(result.contains("Breakpoint set"))
            check(debugger.has_breakpoint("test.spl", 42))

        it "uses b alias":
            var debugger = debugger_new()
            val result = handle_debug_command(debugger, "b test.spl:10")
            check(result.contains("Breakpoint set"))
            check(debugger.has_breakpoint("test.spl", 10))

        it "returns error for missing arguments":
            var debugger = debugger_new()
            val result = handle_debug_command(debugger, "break")
            check(result.starts_with("ERROR"))

        it "returns error for invalid format (no colon)":
            var debugger = debugger_new()
            val result = handle_debug_command(debugger, "break invalid")
            check(result.starts_with("ERROR"))

        it "handles file paths with special characters":
            var debugger = debugger_new()
            val result = handle_debug_command(debugger, "break src/app/interpreter/helpers/debug.spl:100")
            check(not result.starts_with("ERROR"))

    context "delete command":

        it "removes breakpoint with valid format":
            var debugger = debugger_new()
            debugger.add_breakpoint("test.spl", 42, "")
            val result = handle_debug_command(debugger, "delete test.spl:42")
            check(result.contains("removed"))
            check(not debugger.has_breakpoint("test.spl", 42))

        it "uses d alias":
            var debugger = debugger_new()
            debugger.add_breakpoint("test.spl", 10, "")
            val result = handle_debug_command(debugger, "d test.spl:10")
            check(result.contains("removed"))
            check(not debugger.has_breakpoint("test.spl", 10))

        it "returns error for missing arguments":
            var debugger = debugger_new()
            val result = handle_debug_command(debugger, "delete")
            check(result.starts_with("ERROR"))

        it "returns error for invalid format":
            var debugger = debugger_new()
            val result = handle_debug_command(debugger, "delete invalid")
            check(result.starts_with("ERROR"))

    context "continue command":

        it "sets continue mode":
            var debugger = debugger_new()
            debugger.step_into()
            val result = handle_debug_command(debugger, "continue")
            check(result.contains("Continuing"))
            check(not debugger.is_stepping)

        it "uses c alias":
            var debugger = debugger_new()
            val result = handle_debug_command(debugger, "c")
            check(result.contains("Continuing"))

    context "step command":

        it "sets step into mode":
            var debugger = debugger_new()
            val result = handle_debug_command(debugger, "step")
            check(result.contains("Stepping into"))
            check(debugger.is_stepping)
            check(debugger.step_mode == StepMode.StepInto)

        it "uses s alias":
            var debugger = debugger_new()
            val result = handle_debug_command(debugger, "s")
            check(debugger.step_mode == StepMode.StepInto)

    context "next command":

        it "sets step over mode":
            var debugger = debugger_new()
            val result = handle_debug_command(debugger, "next")
            check(result.contains("Stepping over"))
            check(debugger.is_stepping)
            check(debugger.step_mode == StepMode.StepOver)

        it "uses n alias":
            var debugger = debugger_new()
            val result = handle_debug_command(debugger, "n")
            check(debugger.step_mode == StepMode.StepOver)

    context "finish command":

        it "sets step out mode":
            var debugger = debugger_new()
            val result = handle_debug_command(debugger, "finish")
            check(result.contains("Stepping out"))
            check(debugger.is_stepping)
            check(debugger.step_mode == StepMode.StepOut)

        it "uses f alias":
            var debugger = debugger_new()
            val result = handle_debug_command(debugger, "f")
            check(debugger.step_mode == StepMode.StepOut)

    context "backtrace command":

        it "returns trace for empty stack":
            var debugger = debugger_new()
            val result = handle_debug_command(debugger, "backtrace")
            check(result.contains("Call stack"))

        it "returns formatted trace with frames":
            var debugger = debugger_new()
            debugger.push_frame(create_frame("main", "test.spl", 10))
            debugger.push_frame(create_frame("helper", "lib.spl", 42))
            val result = handle_debug_command(debugger, "backtrace")
            check(result.contains("main"))
            check(result.contains("helper"))

        it "uses bt alias":
            var debugger = debugger_new()
            debugger.push_frame(create_frame("fn", "a.spl", 1))
            val result = handle_debug_command(debugger, "bt")
            check(result.contains("fn"))

    context "print command":

        it "returns error for missing expression":
            var debugger = debugger_new()
            val result = handle_debug_command(debugger, "print")
            check(result.starts_with("ERROR"))

        it "echoes expression":
            var debugger = debugger_new()
            val result = handle_debug_command(debugger, "print x")
            check(result.contains("EXPR"))
            check(result.contains("x"))

        it "uses p alias":
            var debugger = debugger_new()
            val result = handle_debug_command(debugger, "p y")
            check(result.contains("EXPR"))
            check(result.contains("y"))

        it "handles multi-word expressions":
            var debugger = debugger_new()
            val result = handle_debug_command(debugger, "print x + y")
            check(result.contains("EXPR"))
            check(result.contains("x + y"))

    context "watch command":

        it "returns error for missing expression":
            var debugger = debugger_new()
            val result = handle_debug_command(debugger, "watch")
            check(result.starts_with("ERROR"))

        it "adds watch expression":
            var debugger = debugger_new()
            val result = handle_debug_command(debugger, "watch x + y")
            check(result.contains("Watch added"))
            check(debugger.watch_expressions.len() == 1)
            check(debugger.watch_expressions[0] == "x + y")

        it "uses w alias":
            var debugger = debugger_new()
            val result = handle_debug_command(debugger, "w z")
            check(result.contains("Watch added"))
            check(debugger.watch_expressions[0] == "z")

    context "help command":

        it "returns help text":
            var debugger = debugger_new()
            val result = handle_debug_command(debugger, "help")
            check(result.contains("Debug commands"))
            check(result.contains("break"))
            check(result.contains("continue"))
            check(result.contains("step"))

        it "uses h alias":
            var debugger = debugger_new()
            val result = handle_debug_command(debugger, "h")
            check(result.contains("Debug commands"))

    context "unknown command handling":

        it "returns error for unknown command":
            var debugger = debugger_new()
            val result = handle_debug_command(debugger, "invalid")
            check(result.starts_with("ERROR"))
            check(result.contains("Unknown command"))
            check(result.contains("help"))

        it "handles typos":
            var debugger = debugger_new()
            val result = handle_debug_command(debugger, "breek")
            check(result.starts_with("ERROR"))
