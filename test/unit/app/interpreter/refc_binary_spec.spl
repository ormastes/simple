# RefcBinary Tests
#
# Tests for reference-counted binaries and shared heap.

use std.spec.{check, check_msg}
use lib.types.{ByteSize}
use lib.memory.refc_binary.{
    RefcBinary,
    RefcBinary__new,
    RefcBinary__sub_binary,
    BinaryRef,
    BinaryRef__new,
    SharedHeap,
    SharedHeap__new,
    SharedHeapConfig,
    SharedHeapConfig__default,
    SharedHeapConfig__small,
    SharedHeapConfig__large,
    SharedHeapStats,
    SharedHeapStats__new,
    AllocResult,
    AllocResult__Success,
    AllocResult__OutOfMemory,
    AllocResult__TooLarge,
    AllocResult__InvalidSize,
    AllocResult__InvalidRange,
    AllocResult__ParentNotFound,
    SMALL_BINARY_THRESHOLD,
    copy_strategy,
    CopyStrategy__DeepCopy__should_share,
    CopyStrategy__ShareRef__should_share,
    CopyStrategy__Hybrid__should_share
}

describe "CopyStrategy":
    it "recommends deep copy for small values":
        val strategy = copy_strategy(32)
        check(strategy == "DeepCopy")

    it "recommends share ref for large values":
        val strategy = copy_strategy(128)
        check(strategy == "ShareRef")

    it "uses threshold of 64 bytes":
        check(copy_strategy(63) == "DeepCopy")
        check(copy_strategy(64) == "ShareRef")

    it "determines sharing based on strategy":
        check(not CopyStrategy__DeepCopy__should_share(1000))
        check(CopyStrategy__ShareRef__should_share(10))
        check(not CopyStrategy__Hybrid__should_share(32))
        check(CopyStrategy__Hybrid__should_share(128))

describe "BinaryRef":
    it "creates reference":
        val ref_val = BinaryRef__new(1, 100, 256)

        check(ref_val.id.value == 1)
        check(ref_val.offset.value == 100)
        check(ref_val.length.value == 256)

    it "reports size":
        val ref_val = BinaryRef__new(1, 0, 1024)
        check(ref_val.size() == 1024)

    it "identifies small binaries":
        val small = BinaryRef__new(1, 0, 32)
        val large = BinaryRef__new(2, 0, 128)

        check(small.is_small())
        check(not large.is_small())

    it "compares for equality":
        val ref1 = BinaryRef__new(1, 0, 100)
        val ref2 = BinaryRef__new(1, 50, 200)
        val ref3 = BinaryRef__new(2, 0, 100)

        check(ref1.eq(ref2))  # Same ID
        check(not ref1.eq(ref3))  # Different ID

    it "formats for display":
        val ref_val = BinaryRef__new(42, 0, 256)
        val s = ref_val.fmt()

        check(s.contains("BinaryRef"))
        check(s.contains("42"))
        check(s.contains("256"))

describe "RefcBinary":
    it "creates with initial refcount of 1":
        val binary = RefcBinary__new(1, 1024, 0)

        check(binary.id.value == 1)
        check(binary.refcount.value == 1)
        check(binary.length.value == 1024)

    it "increments refcount":
        var binary = RefcBinary__new(1, 100, 0)

        val count = binary.incref()

        check(count == 2)
        check(binary.refcount.value == 2)

    it "decrements refcount":
        var binary = RefcBinary__new(1, 100, 0)
        binary.incref()

        val count = binary.decref()

        check(count == 1)

    it "checks if can collect":
        var binary = RefcBinary__new(1, 100, 0)

        check(not binary.can_collect())

        binary.decref()
        check(binary.can_collect())

    it "respects pinning":
        var binary = RefcBinary__new(1, 100, 0)
        binary.decref()
        binary.pin()

        check(not binary.can_collect())

        binary.unpin()
        check(binary.can_collect())

    it "creates sub-binary":
        val sub = RefcBinary__sub_binary(2, 1, 10, 50, 0)

        check(sub.id.value == 2)
        check(sub.is_sub_binary)
        check(sub.parent_id.value == 1)
        check(sub.length.value == 50)

    it "calculates total size":
        val binary = RefcBinary__new(1, 1024, 1024)
        val total = binary.total_size()

        # Header (~64) + capacity (1024)
        check(total >= 1024)

    it "creates ref from binary":
        val binary = RefcBinary__new(1, 256, 0)
        val ref_val = binary.to_ref(100)

        check(ref_val.id.value == 1)
        check(ref_val.offset.value == 100)
        check(ref_val.length.value == 256)

describe "SharedHeapConfig":
    it "creates default config":
        val config = SharedHeapConfig__default()

        check(config.initial_size.value == 64 * 1024 * 1024)
        check(config.gc_threshold == 0.8)

    it "creates small config":
        val config = SharedHeapConfig__small()

        check(config.initial_size.value == 1024 * 1024)

    it "creates large config":
        val config = SharedHeapConfig__large()

        check(config.initial_size.value == 256 * 1024 * 1024)

describe "SharedHeap - Allocation":
    it "allocates binary":
        var heap = SharedHeap__new(SharedHeapConfig__small())

        val result = heap.allocate(0, 1024)

        check(result.is_success())
        val ref_val = result.unwrap()
        check(ref_val.length.value == 1024)

    it "tracks allocation stats":
        var heap = SharedHeap__new(SharedHeapConfig__small())

        heap.allocate(0, 1000)
        heap.allocate(0, 2000)

        val stats = heap.get_stats()
        check(stats.binary_count.value == 2)
        check(stats.used_size.value == 3000)
        check(stats.total_allocations.value == 2)

    it "rejects zero size":
        var heap = SharedHeap__new(SharedHeapConfig__small())

        val result = heap.allocate(0, 0)

        check(result.tag == "InvalidSize")

    it "rejects too large":
        var heap = SharedHeap__new(SharedHeapConfig__small())

        val result = heap.allocate(0, 2 * 1024 * 1024 * 1024)  # 2 GB

        check(result.tag == "TooLarge")

    it "returns out of memory when full":
        val config = SharedHeapConfig(
            initial_size: ByteSize(value: 1000),
            max_size: ByteSize(value: 1000),
            grow_factor: 1.5,
            gc_threshold: 0.99,
            defrag_threshold: 0.3
        )
        var heap = SharedHeap__new(config)

        heap.allocate(0, 900)
        val result = heap.allocate(0, 200)

        check(result.tag == "OutOfMemory")

describe "SharedHeap - Sub-binaries":
    it "allocates sub-binary":
        var heap = SharedHeap__new(SharedHeapConfig__small())

        val parent_result = heap.allocate(0, 1024)
        val parent_ref = parent_result.unwrap()

        val sub_result = heap.allocate_sub_binary(parent_ref.id.value, 100, 200)

        check(sub_result.is_success())
        val sub_ref = sub_result.unwrap()
        check(sub_ref.length.value == 200)

    it "fails for nonexistent parent":
        var heap = SharedHeap__new(SharedHeapConfig__small())

        val result = heap.allocate_sub_binary(999, 0, 100)

        check(result.tag == "ParentNotFound")

    it "fails for invalid range":
        var heap = SharedHeap__new(SharedHeapConfig__small())

        val parent_result = heap.allocate(0, 100)
        val parent_ref = parent_result.unwrap()

        val result = heap.allocate_sub_binary(parent_ref.id.value, 50, 100)  # 50 + 100 > 100

        check(result.tag == "InvalidRange")

    it "tracks sub-binary count":
        var heap = SharedHeap__new(SharedHeapConfig__small())

        val parent_result = heap.allocate(0, 1024)
        val parent_ref = parent_result.unwrap()

        heap.allocate_sub_binary(parent_ref.id.value, 0, 100)
        heap.allocate_sub_binary(parent_ref.id.value, 100, 200)

        val stats = heap.get_stats()
        check(stats.sub_binary_count.value == 2)

describe "SharedHeap - Reference Counting":
    it "increments refcount":
        var heap = SharedHeap__new(SharedHeapConfig__small())

        val result = heap.allocate(0, 100)
        val ref_val = result.unwrap()

        check(heap.incref(ref_val.id.value))

        val binary = heap.get(ref_val.id.value)
        check(binary.?.refcount.value == 2)

    it "decrements refcount":
        var heap = SharedHeap__new(SharedHeapConfig__small())

        val result = heap.allocate(0, 100)
        val ref_val = result.unwrap()
        heap.incref(ref_val.id.value)

        check(heap.decref(ref_val.id.value))

        val binary = heap.get(ref_val.id.value)
        check(binary.?.refcount.value == 1)

    it "deallocates when refcount reaches zero":
        var heap = SharedHeap__new(SharedHeapConfig__small())

        val result = heap.allocate(0, 100)
        val ref_val = result.unwrap()

        heap.decref(ref_val.id.value)

        check(not heap.contains(ref_val.id.value))
        check(heap.get_stats().binary_count.value == 0)

    it "tracks incref and decref stats":
        var heap = SharedHeap__new(SharedHeapConfig__small())

        val result = heap.allocate(0, 100)
        val ref_val = result.unwrap()

        heap.incref(ref_val.id.value)
        heap.incref(ref_val.id.value)
        heap.decref(ref_val.id.value)

        val stats = heap.get_stats()
        check(stats.total_incref.value == 2)
        check(stats.total_decref.value == 1)

describe "SharedHeap - Garbage Collection":
    it "collects unreferenced binaries":
        var heap = SharedHeap__new(SharedHeapConfig__small())

        heap.allocate(0, 1000)
        heap.allocate(0, 2000)

        # Decref both to make them collectible
        heap.decref(0)
        heap.decref(1)

        # They should already be removed by decref
        check(heap.binary_count() == 0)

    it "preserves referenced binaries":
        var heap = SharedHeap__new(SharedHeapConfig__small())

        val result = heap.allocate(0, 1000)
        val ref_val = result.unwrap()
        heap.incref(ref_val.id.value)  # Extra reference

        heap.decref(ref_val.id.value)  # Drop one reference
        heap.collect_garbage()

        check(heap.contains(ref_val.id.value))

    it "preserves pinned binaries":
        var heap = SharedHeap__new(SharedHeapConfig__small())

        val result = heap.allocate(0, 1000)
        val ref_val = result.unwrap()
        heap.pin(ref_val.id.value)
        heap.decref(ref_val.id.value)  # Refcount = 0

        heap.collect_garbage()

        check(heap.contains(ref_val.id.value))  # Still there because pinned

describe "SharedHeap - Pinning":
    it "pins binary":
        var heap = SharedHeap__new(SharedHeapConfig__small())

        val result = heap.allocate(0, 100)
        val ref_val = result.unwrap()

        check(heap.pin(ref_val.id.value))

        val stats = heap.get_stats()
        check(stats.pinned_count.value == 1)

    it "unpins binary":
        var heap = SharedHeap__new(SharedHeapConfig__small())

        val result = heap.allocate(0, 100)
        val ref_val = result.unwrap()

        heap.pin(ref_val.id.value)
        heap.unpin(ref_val.id.value)

        val stats = heap.get_stats()
        check(stats.pinned_count.value == 0)

describe "SharedHeap - Statistics":
    it "tracks peak usage":
        var heap = SharedHeap__new(SharedHeapConfig__small())

        heap.allocate(0, 1000)
        heap.allocate(0, 2000)
        heap.decref(0)

        val stats = heap.get_stats()
        check(stats.peak_usage.value == 3000)

    it "calculates utilization":
        var heap = SharedHeap__new(SharedHeapConfig__small())

        heap.allocate(0, 512 * 1024)  # 512 KB of 1 MB

        val stats = heap.get_stats()
        val util = stats.utilization()
        val ok = util > 40.0 and util < 60.0
        check(ok)

    it "calculates fragmentation":
        val stats = SharedHeapStats__new()
        # Fragmentation depends on free block distribution
        val frag = stats.fragmentation()
        val ok = frag >= 0.0 and frag <= 1.0
        check(ok)

describe "SharedHeap - Defragmentation":
    it "merges adjacent free blocks":
        var heap = SharedHeap__new(SharedHeapConfig__small())

        # Allocate and free multiple binaries
        heap.allocate(0, 100)
        heap.allocate(0, 100)
        heap.allocate(0, 100)

        heap.decref(0)
        heap.decref(1)
        heap.decref(2)

        heap.defragment()

        val stats = heap.get_stats()
        check(stats.defrag_count.value == 1)

describe "SharedHeap - Queries":
    it "gets binary by ID":
        var heap = SharedHeap__new(SharedHeapConfig__small())

        val result = heap.allocate(0, 256)
        val ref_val = result.unwrap()

        val binary = heap.get(ref_val.id.value)

        check(binary.?)
        check(binary.length.value == 256)

    it "gets ref for binary":
        var heap = SharedHeap__new(SharedHeapConfig__small())

        heap.allocate(0, 256)

        val ref_val = heap.get_ref(0)

        check(ref_val.?)
        check(ref_val.length.value == 256)

    it "checks containment":
        var heap = SharedHeap__new(SharedHeapConfig__small())

        heap.allocate(0, 100)

        check(heap.contains(0))
        check(not heap.contains(999))

describe "AllocResult":
    it "checks success":
        val success = AllocResult__Success(BinaryRef__new(1, 0, 100))
        val failure = AllocResult__OutOfMemory()

        check(success.is_success())
        check(not failure.is_success())

    it "unwraps success":
        val result = AllocResult__Success(BinaryRef__new(1, 0, 100))
        val ref_val = result.unwrap()

        check(ref_val.id.value == 1)

    it "gets optional ref":
        val success = AllocResult__Success(BinaryRef__new(1, 0, 100))
        val failure = AllocResult__OutOfMemory()

        check(success.ref_option().?)
        check(not failure.ref_option().?)

    it "formats for display":
        val success = AllocResult__Success(BinaryRef__new(1, 0, 100))
        val failure = AllocResult__OutOfMemory()

        check(success.fmt().contains("Success"))
        check(failure.fmt() == "OutOfMemory")
