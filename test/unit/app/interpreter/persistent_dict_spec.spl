# PersistentDict Tests
#
# Tests for the persistent dictionary.

use lib.collections.persistent_dict.{PersistentDict, PersistentDict__empty, PersistentDict__from_entries, PersistentDict__from_dict}
use std.spec.{check, check_msg}

describe "PersistentDict - Basic Operations":
    it "creates empty dictionary":
        val dict = PersistentDict__empty()
        check(dict.is_empty())
        check(dict.len() == 0)

    it "sets and gets a single entry":
        val dict = PersistentDict__empty()
        val dict2 = dict.set("key", 42)
        check(dict2.get("key").?)
        check(dict2.get("key") == 42)
        check(dict2.len() == 1)

    it "returns None for missing key":
        val dict = PersistentDict__empty()
        check(not dict.get("missing").?)

    it "original is unchanged after set":
        val dict1 = PersistentDict__empty()
        val dict2 = dict1.set("key", 100)

        # Original still empty
        check(dict1.is_empty())
        check(dict1.len() == 0)
        check(not dict1.get("key").?)

        # New dict has entry
        check(dict2.len() == 1)
        check(dict2.get("key") == 100)

    it "updates existing key":
        val dict1 = PersistentDict__empty()
        val dict2 = dict1.set("x", 1)
        val dict3 = dict2.set("x", 2)

        check(dict2.get("x") == 1)
        check(dict3.get("x") == 2)
        # Still one entry
        check(dict3.len() == 1)

    it "handles multiple keys":
        var dict = PersistentDict__empty()
        dict = dict.set("a", 1)
        dict = dict.set("b", 2)
        dict = dict.set("c", 3)

        check(dict.len() == 3)
        check(dict.get("a") == 1)
        check(dict.get("b") == 2)
        check(dict.get("c") == 3)

describe "PersistentDict - Remove":
    it "removes existing key":
        var dict = PersistentDict__empty()
        dict = dict.set("key", 42)
        val dict2 = dict.remove("key")

        check(dict.len() == 1)
        check(dict.get("key").?)

        check(dict2.is_empty())
        check(not dict2.get("key").?)

    it "handles remove of non-existent key":
        val dict = PersistentDict__empty()
        val dict2 = dict.set("a", 1)
        val dict3 = dict2.remove("b")  # Key does not exist

        check(dict3.len() == 1)
        check(dict3.get("a") == 1)

    it "removes from multiple entries":
        var dict = PersistentDict__empty()
        dict = dict.set("a", 1)
        dict = dict.set("b", 2)
        dict = dict.set("c", 3)

        val dict2 = dict.remove("b")

        check(dict2.len() == 2)
        check(dict2.get("a") == 1)
        check(not dict2.get("b").?)
        check(dict2.get("c") == 3)

describe "PersistentDict - Structural Sharing":
    it "shares structure between versions":
        var dict1 = PersistentDict__empty()
        for i in 0..100:
            dict1 = dict1.set("key_{i}", i)

        val dict2 = dict1.set("new_key", 999)

        # Both should work independently
        check(dict1.len() == 100)
        check(dict2.len() == 101)

        check(not dict1.get("new_key").?)
        check(dict2.get("new_key") == 999)

        # Original entries preserved in both
        check(dict1.get("key_50") == 50)
        check(dict2.get("key_50") == 50)

    it "handles many insertions efficiently":
        var dict = PersistentDict__empty()

        for i in 0..1000:
            dict = dict.set(i, i * 2)

        check(dict.len() == 1000)

        for i in 0..1000:
            check(dict.get(i) == i * 2)

describe "PersistentDict - Query Methods":
    it "checks contains":
        var dict = PersistentDict__empty()
        dict = dict.set("present_val", 1)

        check(dict.contains("present_val"))
        check(not dict.contains("missing"))

    it "gets with default":
        var dict = PersistentDict__empty()
        dict = dict.set("key", 42)

        check(dict.get_or("key", 0) == 42)
        check(dict.get_or("missing", -1) == -1)

describe "PersistentDict - Bulk Operations":
    it "merges dictionaries":
        var dict1 = PersistentDict__empty()
        dict1 = dict1.set("a", 1)
        dict1 = dict1.set("b", 2)

        var dict2 = PersistentDict__empty()
        dict2 = dict2.set("b", 20)
        dict2 = dict2.set("c", 3)

        val merged = dict1.merge(dict2)

        check(merged.len() == 3)
        check(merged.get("a") == 1)
        # dict2 wins
        check(merged.get("b") == 20)
        check(merged.get("c") == 3)

    it "filters entries":
        var dict = PersistentDict__empty()
        dict = dict.set("a", 1)
        dict = dict.set("b", 2)
        dict = dict.set("c", 3)
        dict = dict.set("d", 4)

        val filtered = dict.filter(fn(k, v): v > 2)

        check(filtered.len() == 2)
        check(filtered.get("c") == 3)
        check(filtered.get("d") == 4)

    it "maps values":
        var dict = PersistentDict__empty()
        dict = dict.set("a", 1)
        dict = dict.set("b", 2)

        val mapped = dict.map_values(fn(v): v * 10)

        check(mapped.get("a") == 10)
        check(mapped.get("b") == 20)

describe "PersistentDict - Conversion":
    it "creates from entries":
        val dict = PersistentDict__from_entries([
            ["x", 10],
            ["y", 20],
            ["z", 30]
        ])

        check(dict.len() == 3)
        check(dict.get("y") == 20)

    it "gets all entries":
        var dict = PersistentDict__empty()
        dict = dict.set("a", 1)
        dict = dict.set("b", 2)

        val entries = dict.entries()
        check(entries.len() == 2)

    it "gets all keys":
        var dict = PersistentDict__empty()
        dict = dict.set("x", 1)
        dict = dict.set("y", 2)

        val key_list = dict.keys()
        check(key_list.len() == 2)

    it "gets all values":
        var dict = PersistentDict__empty()
        dict = dict.set("a", 100)
        dict = dict.set("b", 200)

        val value_list = dict.values()
        check(value_list.len() == 2)

    it "converts to regular Dict":
        var pdict = PersistentDict__empty()
        pdict = pdict.set("key", 42)

        val d = pdict.to_dict()
        check(d["key"] == 42)

describe "PersistentDict - Update":
    it "updates with function":
        var dict = PersistentDict__empty()
        dict = dict.set("counter", 0)

        val dict2 = dict.update("counter", fn(v):
            if v.?:
                return v + 1
            0
        )

        check(dict2.get("counter") == 1)

    it "inserts via update when key missing":
        val dict = PersistentDict__empty()

        val dict2 = dict.update("new_key", fn(v):
            if v.?:
                return v
            42
        )

        check(dict2.get("new_key") == 42)

describe "PersistentDict - Integer Keys":
    it "handles integer keys":
        var dict = PersistentDict__empty()
        dict = dict.set(1, "one")
        dict = dict.set(2, "two")
        dict = dict.set(1000, "thousand")

        check(dict.get(1) == "one")
        check(dict.get(2) == "two")
        check(dict.get(1000) == "thousand")

describe "PersistentDict - Hash Collisions":
    # These tests verify collision handling works correctly
    it "handles entries with similar hashes":
        var dict = PersistentDict__empty()

        # Insert many entries - some may collide
        for i in 0..100:
            dict = dict.set(i * 32, i)

        check(dict.len() == 100)

        for i in 0..100:
            check(dict.get(i * 32) == i)
