# Lazy Value Tests
#
# Tests for lazy evaluation and memoization.

use std.spec.{check}
use std.lazy_val.{Lazy, Lazy__new, Lazy__of, Lazy__failed, lazy, LazyState, LazyError, LazyError__CycleDetected, LazyError__EvaluationFailed, lazy_error_message, reset_lazy_stats, get_lazy_stats, Memo, Memo__new, MemoStats}

describe "LazyState":
    it "checks pending state":
        val lz = Lazy__new(fn(): 0)
        check(lz.is_pending())
        check(not lz.is_evaluated())

    it "checks ready state":
        val lz = Lazy__of(42)
        check(lz.is_evaluated())
        check(not lz.is_pending())

    it "checks failed state":
        val lz = Lazy__failed("error")
        check(lz.is_failed())
        check(not lz.is_evaluated())

describe "Lazy - Creation":
    it "creates lazy value":
        val lazy_val = Lazy__new(fn(): 42)
        check(lazy_val.is_pending())

    it "creates already-evaluated value":
        val lazy_val = Lazy__of(42)
        check(lazy_val.is_evaluated())
        check(lazy_val.get() == 42)

    it "creates failed value":
        val lazy_val = Lazy__failed("test error")
        check(lazy_val.is_failed())

    it "uses shorthand constructor":
        val lazy_val = lazy(fn(): 42)
        check(lazy_val.is_pending())

describe "Lazy - Force Evaluation":
    it "forces evaluation":
        var lazy_val = Lazy__new(fn(): 42)
        val result = lazy_val.force()
        check(result == 42)
        check(lazy_val.is_evaluated())

    it "returns cached value":
        var lazy_val = Lazy__of(42)
        val r1 = lazy_val.force()
        val r2 = lazy_val.force()
        check(r1 == 42)
        check(r2 == 42)

    it "handles force_or_default":
        var lazy_val = Lazy__new(fn(): 42)
        val result = lazy_val.force_or_default(0)
        check(result == 42)

    it "uses default on failed value":
        var lazy_val = Lazy__failed("error")
        val result = lazy_val.force_or_default(99)
        check(result == 99)

describe "Lazy - Queries":
    it "checks is_evaluated":
        var lazy_val = Lazy__new(fn(): 42)
        check(not lazy_val.is_evaluated())
        lazy_val.force()
        check(lazy_val.is_evaluated())

    it "checks is_pending":
        var lazy_val = Lazy__new(fn(): 42)
        check(lazy_val.is_pending())
        lazy_val.force()
        check(not lazy_val.is_pending())

    it "gets value without forcing":
        var lazy_val = Lazy__new(fn(): 42)
        check(lazy_val.get() == nil)
        lazy_val.force()
        check(lazy_val.get() == 42)

describe "Lazy - Display":
    it "formats pending":
        val lazy_val = Lazy__new(fn(): 42)
        check(lazy_val.fmt().contains("pending"))

    it "formats ready":
        val lazy_val = Lazy__of(42)
        check(lazy_val.fmt().contains("ready"))

    it "formats failed":
        val lazy_val = Lazy__failed("error")
        check(lazy_val.fmt().contains("failed"))

describe "Lazy - Statistics":
    it "tracks created count":
        reset_lazy_stats()
        Lazy__new(fn(): 1)
        Lazy__new(fn(): 2)
        Lazy__new(fn(): 3)
        val stats = get_lazy_stats()
        check(stats.total_created.value >= 3)

    it "tracks forced count":
        reset_lazy_stats()
        var lazy_val = Lazy__new(fn(): 42)
        lazy_val.force()
        val stats = get_lazy_stats()
        check(stats.total_forced.value >= 1)

    it "tracks cache hits and misses":
        reset_lazy_stats()
        var lazy_val = Lazy__new(fn(): 42)
        lazy_val.force()  # Miss
        lazy_val.force()  # Hit
        lazy_val.force()  # Hit
        val stats = get_lazy_stats()
        check(stats.cache_misses.value >= 1)
        check(stats.cache_hits.value >= 2)

    it "calculates hit rate":
        reset_lazy_stats()
        var lazy_val = Lazy__new(fn(): 42)
        lazy_val.force()  # Miss
        lazy_val.force()  # Hit
        val stats = get_lazy_stats()
        check(stats.hit_rate() == 0.5)

describe "LazyError":
    it "formats cycle detected":
        val err = LazyError__CycleDetected()
        check(lazy_error_message(err).contains("Cycle"))

    it "formats evaluation failed":
        val err = LazyError__EvaluationFailed("test error")
        check(lazy_error_message(err).contains("test error"))

describe "Memo - Basic Operations":
    it "creates empty memo":
        val memo = Memo__new()
        check(memo.size() == 0)

    it "computes and caches":
        var memo = Memo__new()
        val result = memo.get_or_compute(5, fn(): 5 * 5)
        check(result == 25)
        check(memo.size() == 1)

    it "returns cached value on second call":
        var memo = Memo__new()
        memo.get_or_compute(5, fn(): 25)
        val result2 = memo.get_or_compute(5, fn(): 999)
        check(result2 == 25)

    it "computes different keys":
        var memo = Memo__new()
        memo.get_or_compute(2, fn(): 4)
        memo.get_or_compute(3, fn(): 9)
        memo.get_or_compute(4, fn(): 16)
        check(memo.size() == 3)
        check(memo.get(2) == 4)
        check(memo.get(3) == 9)
        check(memo.get(4) == 16)

    it "checks containment":
        var memo = Memo__new()
        memo.get_or_compute(5, fn(): 25)
        check(memo.contains(5))
        check(not memo.contains(10))

    it "clears cache":
        var memo = Memo__new()
        memo.get_or_compute(1, fn(): 1)
        memo.get_or_compute(2, fn(): 4)
        memo.clear()
        check(memo.size() == 0)

describe "Memo - Statistics":
    it "tracks lookups":
        var memo = Memo__new()
        memo.get_or_compute(1, fn(): 1)
        memo.get_or_compute(1, fn(): 1)
        memo.get_or_compute(2, fn(): 4)
        val stats = memo.get_stats()
        check(stats.total_lookups.value == 3)

    it "tracks hits and misses":
        var memo = Memo__new()
        memo.get_or_compute(1, fn(): 1)  # Miss
        memo.get_or_compute(1, fn(): 1)  # Hit
        memo.get_or_compute(2, fn(): 4)  # Miss
        val stats = memo.get_stats()
        check(stats.cache_misses.value == 2)
        check(stats.cache_hits.value == 1)

    it "calculates hit rate":
        var memo = Memo__new()
        memo.get_or_compute(1, fn(): 1)  # Miss
        memo.get_or_compute(1, fn(): 1)  # Hit
        memo.get_or_compute(1, fn(): 1)  # Hit
        val stats = memo.get_stats()
        val hit_rate = stats.hit_rate()
        # 2 hits / 3 lookups = 0.666...
        val rate_ok = hit_rate > 0.6 and hit_rate < 0.7
        check(rate_ok)
