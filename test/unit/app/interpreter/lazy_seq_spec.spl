# Lazy Sequence Tests
#
# Tests for lazy/infinite sequences.

use std.spec.{check, check_msg}
use lib.collections.lazy_seq.{
    LazySeq,
    SeqIterator,
    naturals,
    naturals_from,
    fibonacci,
    primes,
    repeat_seq,
    cycle,
    range_lazy,
    range_step,
    LazySeq__empty,
    LazySeq__single,
    LazySeq__cons,
    LazySeq__from_array,
    LazySeq__iterate,
    LazySeq__unfold,
    LazySeq__generate,
    LazySeq__repeat_val,
    LazySeq__repeat_n,
    SeqIterator__new
}

describe "LazySeq - Creation":
    it "creates empty sequence":
        val seq = LazySeq__empty()

        check(seq.is_empty())

    it "creates single element":
        val seq = LazySeq__single(42)

        check(not seq.is_empty())
        check(seq.head() == 42)
        check(seq.tail().is_empty())

    it "creates from array":
        val seq = LazySeq__from_array([1, 2, 3])

        check(seq.head() == 1)
        val t1 = seq.tail()
        check(t1.head() == 2)
        val t2 = t1.tail()
        check(t2.head() == 3)

    it "creates with cons":
        val t = LazySeq__single(2)
        val seq = LazySeq__cons(1, t)

        check(seq.head() == 1)
        check(seq.tail().head() == 2)

    it "creates with iterate":
        val seq = LazySeq__iterate(1, fn(x): x * 2)

        check(seq.head() == 1)
        val t1 = seq.tail()
        check(t1.head() == 2)
        val t2 = t1.tail()
        check(t2.head() == 4)

    it "creates with unfold":
        val seq = LazySeq__unfold(0, fn(n):
            if n < 3:
                return [n * 10, n + 1]
            nil
        )

        val arr = seq.to_array()
        check(arr.len() == 3)
        check(arr[0] == 0)
        check(arr[1] == 10)
        check(arr[2] == 20)

    it "creates with generate":
        val seq = LazySeq__generate(fn(i):
            if i < 3:
                return i * i
            nil
        )

        val arr = seq.to_array()
        check(arr.len() == 3)
        check(arr[0] == 0)
        check(arr[1] == 1)
        check(arr[2] == 4)

    it "creates repeat":
        val seq = LazySeq__repeat_val(5)
        val arr = seq.take(4).to_array()

        check(arr.len() == 4)
        check(arr[0] == 5)
        check(arr[3] == 5)

    it "creates repeat_n":
        val seq = LazySeq__repeat_n(7, 3)
        val arr = seq.to_array()

        check(arr.len() == 3)
        check(arr[0] == 7)
        check(arr[2] == 7)

describe "LazySeq - Basic Operations":
    it "gets head":
        val seq = LazySeq__from_array([10, 20, 30])

        check(seq.head() == 10)

    it "returns nil for empty head":
        val seq = LazySeq__empty()

        check(not seq.head().?)

    it "gets tail":
        val seq = LazySeq__from_array([1, 2, 3])
        val t = seq.tail()

        check(t.head() == 2)

    it "gets nth element":
        val seq = LazySeq__from_array([10, 20, 30, 40, 50])

        check(seq.nth(0) == 10)
        check(seq.nth(2) == 30)
        check(seq.nth(4) == 50)
        check(not seq.nth(10).?)

describe "LazySeq - Transformations":
    it "maps elements":
        val seq = LazySeq__from_array([1, 2, 3])
        val doubled = seq.map(fn(x): x * 2)
        val arr = doubled.to_array()

        check(arr.len() == 3)
        check(arr[0] == 2)
        check(arr[1] == 4)
        check(arr[2] == 6)

    it "filters elements":
        val seq = LazySeq__from_array([1, 2, 3, 4, 5, 6])
        val evens = seq.filter(fn(x): x % 2 == 0)
        val arr = evens.to_array()

        check(arr.len() == 3)
        check(arr[0] == 2)
        check(arr[1] == 4)
        check(arr[2] == 6)

    it "flat_maps elements":
        val seq = LazySeq__from_array([1, 2, 3])
        val expanded = seq.flat_map(fn(x): LazySeq__from_array([x, x * 10]))
        val arr = expanded.to_array()

        check(arr.len() == 6)
        check(arr[0] == 1)
        check(arr[1] == 10)
        check(arr[2] == 2)
        check(arr[3] == 20)

    it "takes first n elements":
        val seq = naturals()
        val first5 = seq.take(5)
        val arr = first5.to_array()

        check(arr.len() == 5)
        check(arr[0] == 0)
        check(arr[4] == 4)

    it "drops first n elements":
        val seq = LazySeq__from_array([1, 2, 3, 4, 5])
        val dropped = seq.drop(2)
        val arr = dropped.to_array()

        check(arr.len() == 3)
        check(arr[0] == 3)

    it "takes while predicate":
        val seq = LazySeq__from_array([1, 2, 3, 10, 4, 5])
        val small = seq.take_while(fn(x): x < 5)
        val arr = small.to_array()

        check(arr.len() == 3)
        check(arr[0] == 1)
        check(arr[2] == 3)

    it "drops while predicate":
        val seq = LazySeq__from_array([1, 2, 3, 10, 4, 5])
        val rest = seq.drop_while(fn(x): x < 5)
        val arr = rest.to_array()

        check(arr.len() == 3)
        check(arr[0] == 10)

    it "concatenates sequences":
        val seq1 = LazySeq__from_array([1, 2])
        val seq2 = LazySeq__from_array([3, 4])
        val combined = seq1.concat(seq2)
        val arr = combined.to_array()

        check(arr.len() == 4)
        check(arr[0] == 1)
        check(arr[3] == 4)

    it "interleaves sequences":
        val seq1 = LazySeq__from_array([1, 3, 5])
        val seq2 = LazySeq__from_array([2, 4, 6])
        val inter = seq1.interleave(seq2)
        val arr = inter.to_array()

        check(arr.len() == 6)
        check(arr[0] == 1)
        check(arr[1] == 2)
        check(arr[2] == 3)

describe "LazySeq - Terminal Operations":
    it "converts to array":
        val seq = LazySeq__from_array([1, 2, 3])
        val arr = seq.to_array()

        check(arr.len() == 3)
        check(arr[0] == 1)

    it "converts to array with limit":
        val seq = naturals()
        val arr = seq.to_array_n(5)

        check(arr.len() == 5)
        check(arr[0] == 0)
        check(arr[4] == 4)

    it "folds elements":
        val seq = LazySeq__from_array([1, 2, 3, 4])
        val total = seq.fold(0, fn(acc, x): acc + x)

        check(total == 10)

    it "reduces elements":
        val seq = LazySeq__from_array([1, 2, 3, 4])
        val product = seq.reduce(fn(a, b): a * b)

        check(product == 24)

    it "reduces empty sequence":
        val seq = LazySeq__empty()
        val result = seq.reduce(fn(a, b): a + b)

        check(not result.?)

    it "finds element":
        val seq = LazySeq__from_array([1, 5, 10, 15, 20])
        val found = seq.find(fn(x): x > 8)

        check(found == 10)

    it "finds nothing":
        val seq = LazySeq__from_array([1, 2, 3])
        val found = seq.find(fn(x): x > 100)

        check(not found.?)

    it "checks any":
        val seq = LazySeq__from_array([1, 2, 3, 4, 5])

        check(seq.any(fn(x): x == 3))
        check(not seq.any(fn(x): x == 10))

    it "checks all":
        val seq = LazySeq__from_array([2, 4, 6, 8])

        check(seq.all(fn(x): x % 2 == 0))
        check(not seq.all(fn(x): x < 5))

    it "counts elements":
        val seq = LazySeq__from_array([1, 2, 3, 4, 5])

        check(seq.count() == 5)

    it "checks contains":
        val seq = LazySeq__from_array([1, 2, 3])

        check(seq.contains(2))
        check(not seq.contains(10))

describe "Standard Sequences - Naturals":
    it "generates natural numbers":
        val first10 = naturals().take(10).to_array()

        check(first10.len() == 10)
        check(first10[0] == 0)
        check(first10[9] == 9)

    it "generates from starting point":
        val first5 = naturals_from(100).take(5).to_array()

        check(first5.len() == 5)
        check(first5[0] == 100)
        check(first5[4] == 104)

describe "Standard Sequences - Fibonacci":
    it "generates fibonacci numbers":
        val first10 = fibonacci().take(10).to_array()

        check(first10.len() == 10)
        check(first10[0] == 0)
        check(first10[1] == 1)
        check(first10[2] == 1)
        check(first10[3] == 2)
        check(first10[9] == 34)

describe "Standard Sequences - Primes":
    it "generates prime numbers":
        val first10 = primes().take(10).to_array()

        check(first10.len() == 10)
        check(first10[0] == 2)
        check(first10[1] == 3)
        check(first10[2] == 5)
        check(first10[9] == 29)

describe "Standard Sequences - Repeat":
    it "repeats value":
        val first5 = repeat_seq(42).take(5).to_array()

        check(first5.len() == 5)
        check(first5[0] == 42)
        check(first5[4] == 42)

describe "Standard Sequences - Cycle":
    it "cycles through array":
        val first8 = cycle([1, 2, 3]).take(8).to_array()

        check(first8.len() == 8)
        check(first8[0] == 1)
        check(first8[3] == 1)
        check(first8[7] == 2)

    it "handles empty array":
        val seq = cycle([])

        check(seq.is_empty())

describe "Standard Sequences - Range":
    it "creates lazy range":
        val seq = range_lazy(0, 5)
        val arr = seq.to_array()

        check(arr.len() == 5)
        check(arr[0] == 0)
        check(arr[4] == 4)

    it "creates empty range":
        val seq = range_lazy(5, 5)

        check(seq.is_empty())

    it "creates range with step":
        val seq = range_step(0, 10, 2)
        val arr = seq.to_array()

        check(arr.len() == 5)
        check(arr[0] == 0)
        check(arr[4] == 8)

    it "creates reverse range":
        val seq = range_step(10, 0, -2)
        val arr = seq.to_array()

        check(arr.len() == 5)
        check(arr[0] == 10)
        check(arr[4] == 2)

describe "SeqIterator":
    it "iterates over sequence":
        val seq = LazySeq__from_array([1, 2, 3])
        var iter = SeqIterator__new(seq)

        check(iter.has_next())
        check(iter.next() == 1)
        check(iter.next() == 2)
        check(iter.next() == 3)
        check(not iter.has_next())
        check(not iter.next().?)

describe "LazySeq - Complex Examples":
    it "computes sum of first 100 naturals":
        val nat = naturals()
        val taken = nat.take(101)
        val total = taken.fold(0, fn(acc, x): acc + x)

        check(total == 5050)

    it "finds first fibonacci greater than 1000":
        val fib = fibonacci()
        val result = fib.find(fn(x): x > 1000)

        check(result == 1597)

    it "composes multiple transformations":
        val nat = naturals()
        val squares = nat.map(fn(x): x * x)
        val even_sq = squares.filter(fn(x): x % 2 == 0)
        val first5 = even_sq.take(5)
        val arr = first5.to_array()

        check(arr.len() == 5)
        check(arr[0] == 0)
        check(arr[1] == 4)
        check(arr[2] == 16)
        check(arr[3] == 36)
        check(arr[4] == 64)
