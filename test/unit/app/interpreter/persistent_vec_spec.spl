# PersistentVec Tests
#
# Tests for the persistent vector.

use std.spec.{check}
use lib.collections.persistent_vec.{PersistentVec, PersistentVec__empty, PersistentVec__from_array, PersistentVec__of}

describe "PersistentVec - Basic Operations":
    it "creates empty vector":
        val vec_val = PersistentVec__empty()
        check(vec_val.is_empty())
        check(vec_val.len() == 0)

    it "pushes single element":
        val vec_val = PersistentVec__empty()
        val vec2 = vec_val.push(42)

        check(vec2.len() == 1)
        check(vec2.get(0) == 42)

    it "original unchanged after push":
        val vec1 = PersistentVec__empty()
        val vec2 = vec1.push(1)

        check(vec1.is_empty())
        check(vec2.len() == 1)

    it "pushes multiple elements":
        var vec_val = PersistentVec__empty()
        vec_val = vec_val.push(1)
        vec_val = vec_val.push(2)
        vec_val = vec_val.push(3)

        check(vec_val.len() == 3)
        check(vec_val.get(0) == 1)
        check(vec_val.get(1) == 2)
        check(vec_val.get(2) == 3)

    it "gets with negative index":
        var vec_val = PersistentVec__empty()
        vec_val = vec_val.push(10)
        vec_val = vec_val.push(20)
        vec_val = vec_val.push(30)

        check(vec_val.get(-1) == 30)  # Last
        check(vec_val.get(-2) == 20)  # Second to last
        check(vec_val.get(-3) == 10)  # First

    it "returns None for out of bounds":
        val vec_val = PersistentVec__empty().push(1)

        check(not vec_val.get(5).?)
        check(not vec_val.get(-10).?)

describe "PersistentVec - Update":
    it "updates element at index":
        var vec_val = PersistentVec__empty()
        vec_val = vec_val.push(1)
        vec_val = vec_val.push(2)
        vec_val = vec_val.push(3)

        val vec2 = vec_val.set(1, 99)

        check(vec_val.get(1) == 2)   # Original unchanged
        check(vec2.get(1) == 99)  # Updated

    it "updates with negative index":
        var vec_val = PersistentVec__empty()
        vec_val = vec_val.push(1)
        vec_val = vec_val.push(2)
        vec_val = vec_val.push(3)

        val vec2 = vec_val.set(-1, 999)

        check(vec2.get(2) == 999)

    it "ignores out of bounds update":
        val vec_val = PersistentVec__empty().push(1)
        val vec2 = vec_val.set(100, 999)

        check(vec2.len() == 1)
        check(vec2.get(0) == 1)

describe "PersistentVec - Pop":
    it "pops last element":
        var vec_val = PersistentVec__empty()
        vec_val = vec_val.push(1)
        vec_val = vec_val.push(2)
        vec_val = vec_val.push(3)

        val vec2 = vec_val.pop()

        check(vec_val.len() == 3)
        check(vec2.len() == 2)
        check(vec2.get(0) == 1)
        check(vec2.get(1) == 2)

    it "handles pop on empty vector":
        val vec_val = PersistentVec__empty()
        val vec2 = vec_val.pop()

        check(vec2.is_empty())

    it "handles pop to empty":
        val vec_val = PersistentVec__empty().push(1)
        val vec2 = vec_val.pop()

        check(vec2.is_empty())

describe "PersistentVec - First/Last":
    it "gets first element":
        var vec_val = PersistentVec__empty()
        vec_val = vec_val.push(10)
        vec_val = vec_val.push(20)
        check(vec_val.first() == 10)

    it "gets last element":
        var vec_val = PersistentVec__empty()
        vec_val = vec_val.push(10)
        vec_val = vec_val.push(20)
        check(vec_val.last() == 20)

    it "returns None for empty vector":
        val vec_val = PersistentVec__empty()
        check(not vec_val.first().?)
        check(not vec_val.last().?)

describe "PersistentVec - Contains":
    it "checks if element exists":
        var vec_val = PersistentVec__empty()
        vec_val = vec_val.push(1)
        vec_val = vec_val.push(2)
        vec_val = vec_val.push(3)

        check(vec_val.contains(2))
        check(not vec_val.contains(99))

describe "PersistentVec - Structural Sharing":
    it "shares structure between versions":
        var vec1 = PersistentVec__empty()
        for i in 0..100:
            vec1 = vec1.push(i)

        val vec2 = vec1.push(999)

        check(vec1.len() == 100)
        check(vec2.len() == 101)

        check(vec1.get(50) == 50)
        check(vec2.get(50) == 50)
        check(not vec1.get(100).?)
        check(vec2.get(100) == 999)

    it "handles many pushes efficiently":
        var vec_val = PersistentVec__empty()

        for i in 0..1000:
            vec_val = vec_val.push(i)

        check(vec_val.len() == 1000)

        for i in 0..1000:
            check(vec_val.get(i) == i)

describe "PersistentVec - Bulk Operations":
    it "concatenates vectors":
        var vec1 = PersistentVec__empty()
        vec1 = vec1.push(1)
        vec1 = vec1.push(2)
        var vec2 = PersistentVec__empty()
        vec2 = vec2.push(3)
        vec2 = vec2.push(4)

        val result = vec1.concat(vec2)

        check(result.len() == 4)
        check(result.get(0) == 1)
        check(result.get(2) == 3)

    it "maps elements":
        var vec_val = PersistentVec__empty()
        vec_val = vec_val.push(1)
        vec_val = vec_val.push(2)
        vec_val = vec_val.push(3)
        val doubled = vec_val.map(fn(x): x * 2)

        check(doubled.get(0) == 2)
        check(doubled.get(1) == 4)
        check(doubled.get(2) == 6)

    it "filters elements":
        var vec_val = PersistentVec__empty()
        vec_val = vec_val.push(1)
        vec_val = vec_val.push(2)
        vec_val = vec_val.push(3)
        vec_val = vec_val.push(4)
        val evens = vec_val.filter(fn(x): x % 2 == 0)

        check(evens.len() == 2)
        check(evens.get(0) == 2)
        check(evens.get(1) == 4)

    it "folds elements":
        var vec_val = PersistentVec__empty()
        vec_val = vec_val.push(1)
        vec_val = vec_val.push(2)
        vec_val = vec_val.push(3)
        val sum = vec_val.fold(0, fn(acc, x): acc + x)

        check(sum == 6)

    it "takes first n elements":
        var vec_val = PersistentVec__empty()
        vec_val = vec_val.push(1)
        vec_val = vec_val.push(2)
        vec_val = vec_val.push(3)
        vec_val = vec_val.push(4)
        val first2 = vec_val.take(2)

        check(first2.len() == 2)
        check(first2.get(0) == 1)
        check(first2.get(1) == 2)

    it "drops first n elements":
        var vec_val = PersistentVec__empty()
        vec_val = vec_val.push(1)
        vec_val = vec_val.push(2)
        vec_val = vec_val.push(3)
        vec_val = vec_val.push(4)
        val last2 = vec_val.drop(2)

        check(last2.len() == 2)
        check(last2.get(0) == 3)
        check(last2.get(1) == 4)

    it "slices vector":
        var vec_val = PersistentVec__empty()
        vec_val = vec_val.push(0)
        vec_val = vec_val.push(1)
        vec_val = vec_val.push(2)
        vec_val = vec_val.push(3)
        vec_val = vec_val.push(4)
        val sliced = vec_val.slice(1, 4)

        check(sliced.len() == 3)
        check(sliced.get(0) == 1)
        check(sliced.get(1) == 2)
        check(sliced.get(2) == 3)

    it "reverses vector":
        var vec_val = PersistentVec__empty()
        vec_val = vec_val.push(1)
        vec_val = vec_val.push(2)
        vec_val = vec_val.push(3)
        val reversed = vec_val.reverse()

        check(reversed.get(0) == 3)
        check(reversed.get(1) == 2)
        check(reversed.get(2) == 1)

describe "PersistentVec - Conversion":
    it "creates from array":
        val vec_val = PersistentVec__from_array([10, 20, 30])

        check(vec_val.len() == 3)
        check(vec_val.get(1) == 20)

    it "creates with of":
        val vec_val = PersistentVec__of(["a", "b", "c"])

        check(vec_val.len() == 3)
        check(vec_val.get(0) == "a")

    it "converts to array":
        var vec_val = PersistentVec__empty()
        vec_val = vec_val.push(1)
        vec_val = vec_val.push(2)
        vec_val = vec_val.push(3)
        val arr = vec_val.to_array()

        check(arr.len() == 3)
        check(arr[0] == 1)
        check(arr[1] == 2)
        check(arr[2] == 3)

describe "PersistentVec - String Elements":
    it "handles string elements":
        var vec_val = PersistentVec__empty()
        vec_val = vec_val.push("hello")
        vec_val = vec_val.push("world")

        check(vec_val.get(0) == "hello")
        check(vec_val.get(1) == "world")

describe "PersistentVec - Edge Cases":
    it "handles single element operations":
        val vec_val = PersistentVec__empty().push(42)

        check(vec_val.first() == 42)
        check(vec_val.last() == 42)
        check(vec_val.len() == 1)

        val popped = vec_val.pop()
        check(popped.is_empty())

    it "handles boundary at branch factor":
        var vec_val = PersistentVec__empty()

        # Push exactly 32 elements (one full leaf)
        for i in 0..32:
            vec_val = vec_val.push(i)

        check(vec_val.len() == 32)
        check(vec_val.get(0) == 0)
        check(vec_val.get(31) == 31)

        # Push one more (forces tree growth)
        vec_val = vec_val.push(32)

        check(vec_val.len() == 33)
        check(vec_val.get(32) == 32)

    it "handles large vectors":
        var vec_val = PersistentVec__empty()

        for i in 0..500:
            vec_val = vec_val.push(i * 2)

        check(vec_val.len() == 500)

        # Spot check
        check(vec_val.get(0) == 0)
        check(vec_val.get(100) == 200)
        check(vec_val.get(499) == 998)
