# Interpreter Hooks Integration Tests
#
# Tests the InterpreterHookContext and its integration with the Rust FFI layer.
# This validates breakpoint management, execution control, stack inspection,
# and variable inspection capabilities.

fn check(condition: bool):
    expect(condition).to_equal(true)
fn check_msg(condition: bool, message: text):
    if not condition:
        expect(message).to_equal("")
import runtime.hooks.{
    InterpreterHookContext,
    BreakpointID,
    BreakpointType,
    ExecutionState,
    StackFrame,
    Variable,
    VariableScope,
    EvalResult,
    StepMode
}

describe "InterpreterHookContext":
    describe "Creation and Initialization":
        it "creates a new hook context":
            val ctx = InterpreterHookContext.create()

            # Should start disabled
            check(not ctx.enabled)

            # Should start with running state
            check(ctx.execution_state == ExecutionState.Running)

            # Should start with no breakpoints
            val breakpoints = ctx.get_breakpoints()
            check(breakpoints.length == 0)

            # Should start with no step mode
            check(not ctx.step_mode.?)

        it "can be enabled and disabled":
            val ctx = InterpreterHookContext.create()

            # Enable debugging
            ctx.enable()
            check(ctx.enabled)

            # Disable debugging
            ctx.disable()
            check(not ctx.enabled)

    describe "Breakpoint Management":
        it "adds a simple line breakpoint":
            val ctx = InterpreterHookContext.create()
            ctx.enable()

            val bp_id = ctx.add_breakpoint("test.spl", 10)

            # Should return a valid ID
            check(bp_id.id > 0)

            # Should be in breakpoint list
            val breakpoints = ctx.get_breakpoints()
            check(breakpoints.length == 1)
            check(breakpoints[0].file == "test.spl")
            check(breakpoints[0].line == 10)
            check(breakpoints[0].enabled)

        it "adds multiple breakpoints":
            val ctx = InterpreterHookContext.create()
            ctx.enable()

            val bp1 = ctx.add_breakpoint("test.spl", 10)
            val bp2 = ctx.add_breakpoint("test.spl", 20)
            val bp3 = ctx.add_breakpoint("other.spl", 15)

            val breakpoints = ctx.get_breakpoints()
            check(breakpoints.length == 3)

            # Each should have unique ID
            check(bp1.id != bp2.id)
            check(bp2.id != bp3.id)
            check(bp1.id != bp3.id)

        it "adds breakpoint with condition":
            val ctx = InterpreterHookContext.create()
            ctx.enable()

            val bp_id = ctx.add_breakpoint_with_options(
                file: "test.spl",
                line: 10,
                condition: Some("x > 5"),
                hit_condition: None,
                log_message: None
            )

            val breakpoints = ctx.get_breakpoints()
            check(breakpoints.length == 1)
            check(breakpoints[0].type == BreakpointType.Conditional)
            check(breakpoints[0].condition.?)
            check(breakpoints[0].condition.unwrap() == "x > 5")

        it "adds breakpoint with log message (log point)":
            val ctx = InterpreterHookContext.create()
            ctx.enable()

            val bp_id = ctx.add_breakpoint_with_options(
                file: "test.spl",
                line: 10,
                condition: None,
                hit_condition: None,
                log_message: Some("Value is {x}")
            )

            val breakpoints = ctx.get_breakpoints()
            check(breakpoints.length == 1)
            check(breakpoints[0].type == BreakpointType.LogPoint)
            check(breakpoints[0].log_message.?)

        it "removes a breakpoint":
            val ctx = InterpreterHookContext.create()
            ctx.enable()

            val bp_id = ctx.add_breakpoint("test.spl", 10)
            check(ctx.get_breakpoints().length == 1)

            ctx.remove_breakpoint(bp_id)
            check(ctx.get_breakpoints().length == 0)

        it "enables and disables a breakpoint":
            val ctx = InterpreterHookContext.create()
            ctx.enable()

            val bp_id = ctx.add_breakpoint("test.spl", 10)

            # Initially enabled
            var breakpoints = ctx.get_breakpoints()
            check(breakpoints[0].enabled)

            # Disable it
            ctx.set_breakpoint_enabled(bp_id, false)
            breakpoints = ctx.get_breakpoints()
            check(not breakpoints[0].enabled)

            # Enable it again
            ctx.set_breakpoint_enabled(bp_id, true)
            breakpoints = ctx.get_breakpoints()
            check(breakpoints[0].enabled)

        it "tracks hit count":
            val ctx = InterpreterHookContext.create()
            ctx.enable()

            val bp_id = ctx.add_breakpoint("test.spl", 10)

            # Initially 0 hits
            var breakpoints = ctx.get_breakpoints()
            check(breakpoints[0].hit_count == 0)

            # Simulate hitting the breakpoint
            ctx.should_break("test.spl", 10)

            breakpoints = ctx.get_breakpoints()
            check(breakpoints[0].hit_count == 1)

            # Hit again
            ctx.should_break("test.spl", 10)
            breakpoints = ctx.get_breakpoints()
            check(breakpoints[0].hit_count == 2)

    describe "Execution Control":
        it "continues execution":
            val ctx = InterpreterHookContext.create()
            ctx.enable()

            # Start paused
            ctx.pause()
            check(ctx.execution_state == ExecutionState.Paused)

            # Continue
            val state = ctx.continue()
            check(state == ExecutionState.Running)
            check(ctx.execution_state == ExecutionState.Running)

        it "pauses execution":
            val ctx = InterpreterHookContext.create()
            ctx.enable()

            # Start running
            check(ctx.execution_state == ExecutionState.Running)

            # Pause
            ctx.pause()
            check(ctx.execution_state == ExecutionState.Paused)

        it "terminates execution":
            val ctx = InterpreterHookContext.create()
            ctx.enable()

            ctx.terminate()
            check(ctx.execution_state == ExecutionState.Stopped)

        it "steps over":
            val ctx = InterpreterHookContext.create()
            ctx.enable()

            val state = ctx.step_over()

            # Should be running (will pause at next line)
            check(state == ExecutionState.Running)

            # Should have step mode set
            check(ctx.step_mode.?)
            check(ctx.step_mode.unwrap() == StepMode.Over)

        it "steps into":
            val ctx = InterpreterHookContext.create()
            ctx.enable()

            val state = ctx.step_into()

            check(state == ExecutionState.Running)
            check(ctx.step_mode.?)
            check(ctx.step_mode.unwrap() == StepMode.Into)

        it "steps out":
            val ctx = InterpreterHookContext.create()
            ctx.enable()

            val state = ctx.step_out()

            check(state == ExecutionState.Running)
            check(ctx.step_mode.?)
            check(ctx.step_mode.unwrap() == StepMode.Out)

    describe "Breakpoint Checking":
        it "should not break when debugging is disabled":
            val ctx = InterpreterHookContext.create()
            # Leave debugging disabled

            ctx.add_breakpoint("test.spl", 10)

            # Should not break (debugging disabled)
            val should_break = ctx.should_break("test.spl", 10)
            check(not should_break)

        it "should break at enabled breakpoint":
            val ctx = InterpreterHookContext.create()
            ctx.enable()

            ctx.add_breakpoint("test.spl", 10)

            # Should break
            val should_break = ctx.should_break("test.spl", 10)
            check(should_break)

        it "should not break at disabled breakpoint":
            val ctx = InterpreterHookContext.create()
            ctx.enable()

            val bp_id = ctx.add_breakpoint("test.spl", 10)
            ctx.set_breakpoint_enabled(bp_id, false)

            # Should not break (disabled)
            val should_break = ctx.should_break("test.spl", 10)
            check(not should_break)

        it "should not break at non-existent location":
            val ctx = InterpreterHookContext.create()
            ctx.enable()

            ctx.add_breakpoint("test.spl", 10)

            # Different line - should not break
            val should_break = ctx.should_break("test.spl", 11)
            check(not should_break)

        it "should not break at log point":
            val ctx = InterpreterHookContext.create()
            ctx.enable()

            # Add log point
            ctx.add_breakpoint_with_options(
                file: "test.spl",
                line: 10,
                condition: None,
                hit_condition: None,
                log_message: Some("Log message")
            )

            # Should not break (log points don't stop execution)
            val should_break = ctx.should_break("test.spl", 10)
            check(not should_break)

    describe "Stack Inspection":
        it "returns empty stack when not paused":
            val ctx = InterpreterHookContext.create()
            ctx.enable()

            # Not paused - should return empty
            val frames = ctx.stack_frames()
            check(frames.length == 0)

        it "returns stack frames when paused":
            val ctx = InterpreterHookContext.create()
            ctx.enable()

            # Pause execution
            ctx.pause()

            # In real implementation, interpreter would capture stack
            # For now, this will return empty (placeholder)
            val frames = ctx.stack_frames()
            # NOTE: Add assertion when interpreter integration is complete

    describe "Variable Inspection":
        it "returns variables in local scope":
            val ctx = InterpreterHookContext.create()
            ctx.enable()
            ctx.pause()

            # Get local variables (frame 0)
            val vars = ctx.variables_in_scope(0, VariableScope.Local)

            # Currently returns empty (placeholder)
            # NOTE: Add assertions when interpreter integration is complete
            check(vars.length >= 0)

        it "returns variables in global scope":
            val ctx = InterpreterHookContext.create()
            ctx.enable()
            ctx.pause()

            val vars = ctx.variables_in_scope(0, VariableScope.Global)
            check(vars.length >= 0)

        it "returns all variables in frame":
            val ctx = InterpreterHookContext.create()
            ctx.enable()
            ctx.pause()

            val vars = ctx.variables_in_frame(0)

            # Should include locals, arguments, closures, and globals
            check(vars.length >= 0)

        it "gets specific variable by name":
            val ctx = InterpreterHookContext.create()
            ctx.enable()
            ctx.pause()

            val var_opt = ctx.get_variable(0, "some_var")

            # Currently returns None (placeholder)
            # NOTE: Add assertions when interpreter integration is complete

    describe "Expression Evaluation":
        it "evaluates expression in current frame":
            val ctx = InterpreterHookContext.create()
            ctx.enable()
            ctx.pause()

            val result = ctx.evaluate("1 + 2", 0)

            # Currently returns error (placeholder)
            check(result.error.?)

        it "cannot evaluate when not paused":
            val ctx = InterpreterHookContext.create()
            ctx.enable()
            # Not paused

            val result = ctx.evaluate("1 + 2", 0)

            # Should return error
            check(result.error.?)
            check(result.error.unwrap().contains("not paused"))

    describe "Event Callbacks":
        it "can set event callback":
            val ctx = InterpreterHookContext.create()

            var event_received = false
            val callback = fn(event):
                event_received = true

            ctx.set_event_callback(callback)

            # Callback should be set
            check(ctx.event_callback.?)

        it "sends event to callback":
            val ctx = InterpreterHookContext.create()

            var received_event = None
            val callback = fn(event):
                received_event = Some(event)

            ctx.set_event_callback(callback)

            # Send event (this would normally be called internally)
            # For testing, we can't directly call send_event
            # NOTE: Test when interpreter integration is complete

    describe "FFI Integration":
        it "calls rt_hook_add_breakpoint FFI":
            val ctx = InterpreterHookContext.create()
            ctx.enable()

            # This should call the Rust FFI function
            val bp_id = ctx.add_breakpoint("test.spl", 10)

            # Verify it was added via FFI
            check(bp_id.id > 0)

        it "calls rt_hook_remove_breakpoint FFI":
            val ctx = InterpreterHookContext.create()
            ctx.enable()

            val bp_id = ctx.add_breakpoint("test.spl", 10)

            # This should call the Rust FFI function
            ctx.remove_breakpoint(bp_id)

            # Verify it was removed
            check(ctx.get_breakpoints().length == 0)

        it "calls rt_hook_continue FFI":
            val ctx = InterpreterHookContext.create()
            ctx.enable()
            ctx.pause()

            # This should call the Rust FFI function
            ctx.continue()

            check(ctx.execution_state == ExecutionState.Running)

        it "calls rt_hook_pause FFI":
            val ctx = InterpreterHookContext.create()
            ctx.enable()

            # This should call the Rust FFI function
            ctx.pause()

            check(ctx.execution_state == ExecutionState.Paused)

        it "calls rt_hook_step FFI":
            val ctx = InterpreterHookContext.create()
            ctx.enable()

            # This should call the Rust FFI function
            ctx.step_over()

            check(ctx.step_mode.?)

        it "calls rt_hook_enable_debugging FFI":
            val ctx = InterpreterHookContext.create()

            # This should call the Rust FFI function
            ctx.enable()

            check(ctx.enabled)

        it "calls rt_hook_disable_debugging FFI":
            val ctx = InterpreterHookContext.create()
            ctx.enable()

            # This should call the Rust FFI function
            ctx.disable()

            check(not ctx.enabled)

describe "Rust FFI Functions":
    describe "Breakpoint Management FFI":
        it "rt_hook_add_breakpoint registers breakpoint":
            import app.io.rt_hook_enable_debugging
            import app.io.rt_hook_add_breakpoint
            import app.io.rt_hook_disable_debugging

            rt_hook_enable_debugging()

            # Should not throw
            rt_hook_add_breakpoint("test.spl", 10, 1)

            rt_hook_disable_debugging()

        it "rt_hook_remove_breakpoint removes breakpoint":
            import app.io.rt_hook_enable_debugging
            import app.io.rt_hook_add_breakpoint
            import app.io.rt_hook_remove_breakpoint
            import app.io.rt_hook_disable_debugging

            rt_hook_enable_debugging()
            rt_hook_add_breakpoint("test.spl", 10, 1)

            # Should not throw
            rt_hook_remove_breakpoint("test.spl", 10)

            rt_hook_disable_debugging()

        it "rt_hook_set_breakpoint_enabled changes state":
            import app.io.rt_hook_enable_debugging
            import app.io.rt_hook_add_breakpoint
            import app.io.rt_hook_set_breakpoint_enabled
            import app.io.rt_hook_disable_debugging

            rt_hook_enable_debugging()
            rt_hook_add_breakpoint("test.spl", 10, 1)

            # Should not throw
            rt_hook_set_breakpoint_enabled("test.spl", 10, false)
            rt_hook_set_breakpoint_enabled("test.spl", 10, true)

            rt_hook_disable_debugging()

    describe "Execution Control FFI":
        it "rt_hook_continue resumes execution":
            import app.io.rt_hook_enable_debugging
            import app.io.rt_hook_continue
            import app.io.rt_hook_disable_debugging

            rt_hook_enable_debugging()

            # Should not throw
            rt_hook_continue()

            rt_hook_disable_debugging()

        it "rt_hook_pause pauses execution":
            import app.io.rt_hook_enable_debugging
            import app.io.rt_hook_pause
            import app.io.rt_hook_disable_debugging

            rt_hook_enable_debugging()

            # Should not throw
            rt_hook_pause()

            rt_hook_disable_debugging()

        it "rt_hook_step executes single step":
            import app.io.rt_hook_enable_debugging
            import app.io.rt_hook_step
            import app.io.rt_hook_disable_debugging

            rt_hook_enable_debugging()

            # Should not throw
            rt_hook_step()

            rt_hook_disable_debugging()

        it "rt_hook_terminate stops execution":
            import app.io.rt_hook_enable_debugging
            import app.io.rt_hook_terminate
            import app.io.rt_hook_disable_debugging

            rt_hook_enable_debugging()

            # Should not throw
            rt_hook_terminate()

            rt_hook_disable_debugging()

    describe "Stack Inspection FFI":
        it "rt_hook_get_call_depth returns depth":
            import app.io.rt_hook_enable_debugging
            import app.io.rt_hook_get_call_depth
            import app.io.rt_hook_disable_debugging

            rt_hook_enable_debugging()

            val depth = rt_hook_get_call_depth()

            # Should return a valid depth (>= 0)
            check(depth >= 0)

            rt_hook_disable_debugging()

        it "rt_hook_get_stack_frames returns frames":
            import app.io.rt_hook_enable_debugging
            import app.io.rt_hook_get_stack_frames
            import app.io.rt_hook_disable_debugging

            rt_hook_enable_debugging()

            val frames = rt_hook_get_stack_frames()

            # Should return an array (may be empty)
            check(frames.length >= 0)

            rt_hook_disable_debugging()

    describe "Variable Inspection FFI":
        it "rt_hook_get_variables returns variables":
            import app.io.rt_hook_enable_debugging
            import app.io.rt_hook_get_variables
            import app.io.rt_hook_disable_debugging
            import runtime.hooks.VariableScope

            rt_hook_enable_debugging()

            val vars = rt_hook_get_variables(0, VariableScope.Local)

            # Should return an array (currently empty placeholder)
            check(vars.length >= 0)

            rt_hook_disable_debugging()

    describe "Expression Evaluation FFI":
        it "rt_hook_evaluate_expression evaluates expr":
            import app.io.rt_hook_enable_debugging
            import app.io.rt_hook_evaluate_expression
            import app.io.rt_hook_disable_debugging

            rt_hook_enable_debugging()

            val result = rt_hook_evaluate_expression("1 + 2", 0)

            # Currently returns placeholder with error
            check(result.error.?)

            rt_hook_disable_debugging()

        it "rt_hook_evaluate_condition evaluates condition":
            import app.io.rt_hook_enable_debugging
            import app.io.rt_hook_evaluate_condition
            import app.io.rt_hook_disable_debugging

            rt_hook_enable_debugging()

            val result = rt_hook_evaluate_condition("x > 5")

            # Currently returns false (placeholder)
            check(not result)

            rt_hook_disable_debugging()

    describe "Debugging Mode FFI":
        it "rt_hook_enable_debugging enables debugging":
            import app.io.rt_hook_enable_debugging
            import app.io.rt_hook_disable_debugging

            # Should not throw
            rt_hook_enable_debugging()
            rt_hook_disable_debugging()

        it "rt_hook_disable_debugging disables debugging":
            import app.io.rt_hook_enable_debugging
            import app.io.rt_hook_disable_debugging

            rt_hook_enable_debugging()

            # Should not throw
            rt_hook_disable_debugging()
