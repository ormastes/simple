# DAP Server Hooks Integration Tests
#
# Tests the integration between the DAP server and the InterpreterHookContext.
# This validates that DAP protocol requests correctly invoke the debugging hooks.

fn check(condition: bool):
    expect(condition).to_equal(true)
fn check_msg(condition: bool, message: text):
    if not condition:
        expect(message).to_equal("")
use dap.server.{DapServer, LaunchConfig, DebuggerState, StepMode}
use runtime.hooks.{InterpreterHookContext, ExecutionState, VariableScope}

describe "DapServer with InterpreterHookContext":
    describe "Initialization":
        it "creates server with hook context":
            val server = DapServer__new()

            # Should have hook context
            check(server.hook_context != nil)

            # Hook context should start disabled
            check(not server.hook_context.enabled)

            # Server should start uninitialized
            check(server.state == DebuggerState.Uninitialized)

        it "hook context is created fresh":
            val server1 = DapServer__new()
            val server2 = DapServer__new()

            # Each server should have its own context
            # (though they share global DEBUG_STATE in Rust)
            check(server1.hook_context != nil)
            check(server2.hook_context != nil)

    describe "Launch Integration":
        it "enables debugging on launch":
            val server = DapServer__new()

            # Simulate initialize
            server.state = DebuggerState.Initialized

            # Launch with arguments
            val args = {
                "program": "test.spl",
                "args": [],
                "stopOnEntry": true
            }

            # Handle launch (simplified - would normally parse from protocol)
            server.launch_config = LaunchConfig__from_json(args)
            server.hook_context.enable()
            server.state = DebuggerState.Launched

            # Hook context should be enabled
            check(server.hook_context.enabled)

        it "sets up launch configuration":
            val server = DapServer__new()

            val args = {
                "program": "test.spl",
                "args": ["arg1", "arg2"],
                "cwd": "/path/to/project",
                "stopOnEntry": false
            }

            server.launch_config = LaunchConfig__from_json(args)

            check(server.launch_config.program == "test.spl")
            check(server.launch_config.args.length == 2)
            check(server.launch_config.stop_on_entry == false)

    describe "Breakpoint Management Integration":
        it "adds breakpoints via hook context":
            val server = DapServer__new()
            server.hook_context.enable()

            # Add breakpoint directly (simulating DAP setBreakpoints request)
            val bp_id = server.hook_context.add_breakpoint("test.spl", 10)

            # Verify it was added
            val breakpoints = server.hook_context.get_breakpoints()
            check(breakpoints.length == 1)
            check(breakpoints[0].file == "test.spl")
            check(breakpoints[0].line == 10)

        it "handles multiple breakpoints in same file":
            val server = DapServer__new()
            server.hook_context.enable()

            # Add multiple breakpoints
            server.hook_context.add_breakpoint("test.spl", 10)
            server.hook_context.add_breakpoint("test.spl", 20)
            server.hook_context.add_breakpoint("test.spl", 30)

            val breakpoints = server.hook_context.get_breakpoints()
            check(breakpoints.length == 3)

        it "handles breakpoints in multiple files":
            val server = DapServer__new()
            server.hook_context.enable()

            server.hook_context.add_breakpoint("file1.spl", 10)
            server.hook_context.add_breakpoint("file2.spl", 20)
            server.hook_context.add_breakpoint("file3.spl", 30)

            val breakpoints = server.hook_context.get_breakpoints()
            check(breakpoints.length == 3)

        it "removes breakpoints":
            val server = DapServer__new()
            server.hook_context.enable()

            val bp_id = server.hook_context.add_breakpoint("test.spl", 10)
            check(server.hook_context.get_breakpoints().length == 1)

            server.hook_context.remove_breakpoint(bp_id)
            check(server.hook_context.get_breakpoints().length == 0)

        it "handles conditional breakpoints":
            val server = DapServer__new()
            server.hook_context.enable()

            val bp_id = server.hook_context.add_breakpoint_with_options(
                file: "test.spl",
                line: 10,
                condition: Some("x > 5"),
                hit_condition: None,
                log_message: None
            )

            val breakpoints = server.hook_context.get_breakpoints()
            check(breakpoints[0].condition.?)
            check(breakpoints[0].condition.unwrap() == "x > 5")

    describe "Execution Control Integration":
        it "continues execution via hook context":
            val server = DapServer__new()
            server.hook_context.enable()
            server.hook_context.pause()

            # Simulate continue command
            server.hook_context.continue()
            server.state = DebuggerState.Running

            check(server.hook_context.execution_state == ExecutionState.Running)
            check(server.state == DebuggerState.Running)

        it "pauses execution via hook context":
            val server = DapServer__new()
            server.hook_context.enable()

            # Simulate pause command
            server.hook_context.pause()

            check(server.hook_context.execution_state == ExecutionState.Paused)

        it "handles step over":
            val server = DapServer__new()
            server.hook_context.enable()

            # Simulate step over command
            server.hook_context.step_over()
            server.step_mode = Some(StepMode.StepOver)

            check(server.step_mode.?)
            check(server.step_mode.unwrap() == StepMode.StepOver)

        it "handles step into":
            val server = DapServer__new()
            server.hook_context.enable()

            server.hook_context.step_into()
            server.step_mode = Some(StepMode.StepIn)

            check(server.step_mode.?)
            check(server.step_mode.unwrap() == StepMode.StepIn)

        it "handles step out":
            val server = DapServer__new()
            server.hook_context.enable()

            server.hook_context.step_out()
            server.step_mode = Some(StepMode.StepOut)

            check(server.step_mode.?)
            check(server.step_mode.unwrap() == StepMode.StepOut)

        it "terminates execution":
            val server = DapServer__new()
            server.hook_context.enable()

            server.hook_context.terminate()

            check(server.hook_context.execution_state == ExecutionState.Stopped)

    describe "Stack Trace Integration":
        it "retrieves stack frames from hook context":
            val server = DapServer__new()
            server.hook_context.enable()
            server.hook_context.pause()

            # Get stack frames (will be empty until interpreter integration)
            val frames = server.hook_context.stack_frames()

            # Should return an array (currently empty)
            check(frames.length >= 0)

        it "handles empty stack":
            val server = DapServer__new()
            server.hook_context.enable()
            # Not paused

            val frames = server.hook_context.stack_frames()

            # Should return empty when not paused
            check(frames.length == 0)

    describe "Variable Inspection Integration":
        it "retrieves local variables from hook context":
            val server = DapServer__new()
            server.hook_context.enable()
            server.hook_context.pause()

            # Get local variables (frame 0)
            val vars = server.hook_context.variables_in_scope(0, VariableScope.Local)

            # Should return an array (currently empty placeholder)
            check(vars.length >= 0)

        it "retrieves global variables from hook context":
            val server = DapServer__new()
            server.hook_context.enable()
            server.hook_context.pause()

            val vars = server.hook_context.variables_in_scope(0, VariableScope.Global)
            check(vars.length >= 0)

        it "retrieves all variables in frame":
            val server = DapServer__new()
            server.hook_context.enable()
            server.hook_context.pause()

            val vars = server.hook_context.variables_in_frame(0)
            check(vars.length >= 0)

    describe "State Synchronization":
        it "synchronizes execution state":
            val server = DapServer__new()
            server.hook_context.enable()

            # Hook context starts running
            check(server.hook_context.execution_state == ExecutionState.Running)

            # Pause via hook context
            server.hook_context.pause()
            server.state = DebuggerState.Stopped

            # Both should be synchronized
            check(server.hook_context.execution_state == ExecutionState.Paused)
            check(server.state == DebuggerState.Stopped)

        it "clears step mode on continue":
            val server = DapServer__new()
            server.hook_context.enable()

            # Set step mode
            server.hook_context.step_over()
            server.step_mode = Some(StepMode.StepOver)

            # Continue - should clear step mode
            server.hook_context.continue()
            server.step_mode = None

            check(not server.step_mode.?)

    describe "Breakpoint Hit Detection":
        it "detects breakpoint hit":
            val server = DapServer__new()
            server.hook_context.enable()

            server.hook_context.add_breakpoint("test.spl", 10)

            # Check if should break
            val should_break = server.hook_context.should_break("test.spl", 10)
            check(should_break)

        it "increments hit count on break":
            val server = DapServer__new()
            server.hook_context.enable()

            server.hook_context.add_breakpoint("test.spl", 10)

            # Hit the breakpoint
            server.hook_context.should_break("test.spl", 10)

            val breakpoints = server.hook_context.get_breakpoints()
            check(breakpoints[0].hit_count == 1)

            # Hit again
            server.hook_context.should_break("test.spl", 10)
            check(breakpoints[0].hit_count == 2)

        it "does not break at disabled breakpoint":
            val server = DapServer__new()
            server.hook_context.enable()

            val bp_id = server.hook_context.add_breakpoint("test.spl", 10)
            server.hook_context.set_breakpoint_enabled(bp_id, false)

            val should_break = server.hook_context.should_break("test.spl", 10)
            check(not should_break)

    describe "Cleanup on Disconnect":
        it "disables debugging on disconnect":
            val server = DapServer__new()
            server.hook_context.enable()

            # Add some breakpoints
            server.hook_context.add_breakpoint("test.spl", 10)
            server.hook_context.add_breakpoint("test.spl", 20)

            # Simulate disconnect
            server.hook_context.disable()
            server.state = DebuggerState.Terminated

            # Debugging should be disabled
            check(not server.hook_context.enabled)

            # Breakpoints should be cleared (by FFI)
            # Note: The Simple-side context may still have them,
            # but the Rust FFI layer clears them

    describe "Error Handling":
        it "handles expression evaluation errors":
            val server = DapServer__new()
            server.hook_context.enable()
            server.hook_context.pause()

            # Try to evaluate (will return error - not implemented)
            val result = server.hook_context.evaluate("invalid expr", 0)

            check(result.error.?)

        it "handles evaluation when not paused":
            val server = DapServer__new()
            server.hook_context.enable()
            # Not paused

            val result = server.hook_context.evaluate("1 + 1", 0)

            check(result.error.?)
            check(result.error.unwrap().contains("not paused"))

    describe "Thread Safety":
        it "multiple servers share global debug state":
            val server1 = DapServer__new()
            val server2 = DapServer__new()

            server1.hook_context.enable()

            # Add breakpoint via server1
            server1.hook_context.add_breakpoint("test.spl", 10)

            # Note: Breakpoints are stored in global Rust state
            # Both contexts access the same underlying DEBUG_STATE
            # This is by design for single-threaded debugging

        it "handles concurrent operations safely":
            val server = DapServer__new()
            server.hook_context.enable()

            # Add and remove breakpoints rapidly
            val bp1 = server.hook_context.add_breakpoint("test.spl", 10)
            val bp2 = server.hook_context.add_breakpoint("test.spl", 20)

            server.hook_context.remove_breakpoint(bp1)

            # Should have one breakpoint left
            val breakpoints = server.hook_context.get_breakpoints()
            check(breakpoints.length == 1)

    describe "Integration Scenarios":
        it "scenario: set breakpoint, run, hit breakpoint, inspect, continue":
            val server = DapServer__new()
            server.hook_context.enable()

            # 1. Set breakpoint
            val bp_id = server.hook_context.add_breakpoint("test.spl", 10)

            # 2. Start running
            server.hook_context.continue()

            # 3. Simulate hitting breakpoint
            val should_break = server.hook_context.should_break("test.spl", 10)
            check(should_break)

            # 4. Pause (breakpoint hit)
            server.hook_context.pause()

            # 5. Inspect stack
            val frames = server.hook_context.stack_frames()
            # (will be empty until interpreter integration)

            # 6. Inspect variables
            val vars = server.hook_context.variables_in_frame(0)

            # 7. Continue
            server.hook_context.continue()
            check(server.hook_context.execution_state == ExecutionState.Running)

        it "scenario: step through code":
            val server = DapServer__new()
            server.hook_context.enable()

            # 1. Start paused
            server.hook_context.pause()

            # 2. Step over
            server.hook_context.step_over()

            # 3. Step into
            server.hook_context.step_into()

            # 4. Step out
            server.hook_context.step_out()

            # All should work without errors

        it "scenario: conditional breakpoint":
            val server = DapServer__new()
            server.hook_context.enable()

            # 1. Add conditional breakpoint
            val bp_id = server.hook_context.add_breakpoint_with_options(
                file: "test.spl",
                line: 10,
                condition: Some("x > 5"),
                hit_condition: None,
                log_message: None
            )

            # 2. Check breakpoint (will check condition via FFI)
            val should_break = server.hook_context.should_break("test.spl", 10)

            # Currently returns false (condition eval not implemented)
            # When implemented, would evaluate condition and decide

        it "scenario: log point (breakpoint that doesn't stop)":
            val server = DapServer__new()
            server.hook_context.enable()

            # 1. Add log point
            val bp_id = server.hook_context.add_breakpoint_with_options(
                file: "test.spl",
                line: 10,
                condition: None,
                hit_condition: None,
                log_message: Some("Value: {x}")
            )

            # 2. Check breakpoint
            val should_break = server.hook_context.should_break("test.spl", 10)

            # Should not break (log points don't stop)
            check(not should_break)

            # (Would log message via event callback)

describe "End-to-End DAP Workflow":
    it "complete debugging session":
        val server = DapServer__new()

        # 1. Initialize
        server.state = DebuggerState.Initialized

        # 2. Launch
        val launch_args = {
            "program": "test.spl",
            "args": [],
            "stopOnEntry": true
        }
        server.launch_config = LaunchConfig__from_json(launch_args)
        server.hook_context.enable()
        server.state = DebuggerState.Launched

        # 3. Set breakpoints
        server.hook_context.add_breakpoint("test.spl", 10)
        server.hook_context.add_breakpoint("test.spl", 20)

        # 4. Configuration done - start execution
        server.state = DebuggerState.Running

        # 5. Stop on entry (if requested)
        if server.launch_config.stop_on_entry:
            server.hook_context.pause()

        # 6. Continue
        server.hook_context.continue()

        # 7. Hit breakpoint (simulated)
        server.hook_context.pause()

        # 8. Inspect state
        val frames = server.hook_context.stack_frames()
        val vars = server.hook_context.variables_in_frame(0)

        # 9. Step over
        server.hook_context.step_over()

        # 10. Continue to next breakpoint
        server.hook_context.continue()

        # 11. Disconnect
        server.hook_context.disable()
        server.state = DebuggerState.Terminated

        check(server.state == DebuggerState.Terminated)
        check(not server.hook_context.enabled)
