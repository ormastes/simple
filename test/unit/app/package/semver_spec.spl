# SemVer Parser - SSpec Tests
import std.spec

use package.types
use package.semver

describe "SemVer Version Parsing":

    describe "Basic version strings":

        it "parses simple version":
            val (ok, v_opt, err) = parse_version("1.2.3")
            expect(ok).to_be(true)
            if val v = v_opt:
                expect(v.major).to_equal(1)
                expect(v.minor).to_equal(2)
                expect(v.patch).to_equal(3)
                expect(v.prerelease == nil).to_be(true)

        it "parses version with prerelease":
            val (ok, v_opt, err) = parse_version("1.2.3-alpha.1")
            expect(ok).to_be(true)
            if val v = v_opt:
                expect(v.major).to_equal(1)
                expect(v.minor).to_equal(2)
                expect(v.patch).to_equal(3)
                if val pre = v.prerelease:
                    expect(pre).to_equal("alpha.1")

        it "parses version with build metadata":
            val (ok, v_opt, err) = parse_version("1.2.3+20130313144700")
            expect(ok).to_be(true)
            if val v = v_opt:
                expect(v.major).to_equal(1)
                if val bld = v.build:
                    expect(bld).to_equal("20130313144700")

        it "parses version with both prerelease and build":
            val (ok, v_opt, err) = parse_version("1.2.3-beta.2+exp.sha.5114f85")
            expect(ok).to_be(true)
            if val v = v_opt:
                if val pre = v.prerelease:
                    expect(pre).to_equal("beta.2")
                if val bld = v.build:
                    expect(bld).to_equal("exp.sha.5114f85")

    describe "Version comparison":

        it "compares major versions":
            val (ok1, v1_opt, e1) = parse_version("2.0.0")
            val (ok2, v2_opt, e2) = parse_version("1.9.9")
            if val v1 = v1_opt:
                if val v2 = v2_opt:
                    expect(version_greater(v1, v2)).to_be(true)
                    expect(version_greater(v2, v1)).to_be(false)
                    expect(version_equal(v1, v2)).to_be(false)

        it "compares minor versions when major equal":
            val (ok1, v1_opt, e1) = parse_version("1.5.0")
            val (ok2, v2_opt, e2) = parse_version("1.3.9")
            if val v1 = v1_opt:
                if val v2 = v2_opt:
                    expect(version_greater(v1, v2)).to_be(true)

        it "compares patch versions when major and minor equal":
            val (ok1, v1_opt, e1) = parse_version("1.2.5")
            val (ok2, v2_opt, e2) = parse_version("1.2.3")
            if val v1 = v1_opt:
                if val v2 = v2_opt:
                    expect(version_greater(v1, v2)).to_be(true)

        it "treats equal versions as equal":
            val (ok1, v1_opt, e1) = parse_version("1.2.3")
            val (ok2, v2_opt, e2) = parse_version("1.2.3")
            if val v1 = v1_opt:
                if val v2 = v2_opt:
                    expect(version_equal(v1, v2)).to_be(true)
                    expect(version_greater(v1, v2)).to_be(false)

        it "prerelease versions have lower precedence":
            val (ok1, v1_opt, e1) = parse_version("1.2.3")
            val (ok2, v2_opt, e2) = parse_version("1.2.3-alpha.1")
            if val v1 = v1_opt:
                if val v2 = v2_opt:
                    expect(version_greater(v1, v2)).to_be(true)

describe "SemVer Constraint Parsing":

    describe "Caret constraints (^)":

        it "parses caret constraint":
            val (ok, c_opt, err) = parse_constraint("^1.2.3")
            expect(ok).to_be(true)

        it "caret allows compatible versions":
            val (ok_c, c_opt, e_c) = parse_constraint("^1.2.3")
            if val constraint = c_opt:
                val (ok1, v1_opt, e1) = parse_version("1.2.3")
                if val v1 = v1_opt:
                    expect(satisfies(v1, constraint)).to_be(true)
                val (ok2, v2_opt, e2) = parse_version("1.2.4")
                if val v2 = v2_opt:
                    expect(satisfies(v2, constraint)).to_be(true)
                val (ok3, v3_opt, e3) = parse_version("1.9.9")
                if val v3 = v3_opt:
                    expect(satisfies(v3, constraint)).to_be(true)
                val (ok4, v4_opt, e4) = parse_version("2.0.0")
                if val v4 = v4_opt:
                    expect(satisfies(v4, constraint)).to_be(false)
                val (ok5, v5_opt, e5) = parse_version("1.1.0")
                if val v5 = v5_opt:
                    expect(satisfies(v5, constraint)).to_be(false)

        it "caret on 0.x is more restrictive":
            val (ok_c, c_opt, e_c) = parse_constraint("^0.2.3")
            if val constraint = c_opt:
                val (ok1, v1_opt, e1) = parse_version("0.2.3")
                if val v1 = v1_opt:
                    expect(satisfies(v1, constraint)).to_be(true)
                val (ok2, v2_opt, e2) = parse_version("0.2.4")
                if val v2 = v2_opt:
                    expect(satisfies(v2, constraint)).to_be(true)
                val (ok3, v3_opt, e3) = parse_version("0.3.0")
                if val v3 = v3_opt:
                    expect(satisfies(v3, constraint)).to_be(false)

        it "caret on 0.0.x is exact":
            val (ok_c, c_opt, e_c) = parse_constraint("^0.0.3")
            if val constraint = c_opt:
                val (ok1, v1_opt, e1) = parse_version("0.0.3")
                if val v1 = v1_opt:
                    expect(satisfies(v1, constraint)).to_be(true)
                val (ok2, v2_opt, e2) = parse_version("0.0.4")
                if val v2 = v2_opt:
                    expect(satisfies(v2, constraint)).to_be(false)

    describe "Tilde constraints (~)":

        it "parses tilde constraint":
            val (ok, c_opt, err) = parse_constraint("~1.2.3")
            expect(ok).to_be(true)

        it "tilde allows patch-level changes":
            val (ok_c, c_opt, e_c) = parse_constraint("~1.2.3")
            if val constraint = c_opt:
                val (ok1, v1_opt, e1) = parse_version("1.2.3")
                if val v1 = v1_opt:
                    expect(satisfies(v1, constraint)).to_be(true)
                val (ok2, v2_opt, e2) = parse_version("1.2.9")
                if val v2 = v2_opt:
                    expect(satisfies(v2, constraint)).to_be(true)
                val (ok3, v3_opt, e3) = parse_version("1.3.0")
                if val v3 = v3_opt:
                    expect(satisfies(v3, constraint)).to_be(false)

    describe "Range constraints":

        it "parses range constraint":
            # Range parsing (>=x, <y combined) not yet implemented
            # Just verify that parsing does not hang
            val (ok, c_opt, err) = parse_constraint(">=1.0.0, <2.0.0")
            expect(ok == ok).to_be(true)

        it "range matches within bounds":
            val (ok, c_opt, err) = parse_constraint(">=1.0.0, <2.0.0")
            if ok:
                if val constraint = c_opt:
                    val (ok1, v1_opt, e1) = parse_version("1.0.0")
                    if val v1 = v1_opt:
                        expect(satisfies(v1, constraint)).to_be(true)
                    val (ok2, v2_opt, e2) = parse_version("0.9.9")
                    if val v2 = v2_opt:
                        expect(satisfies(v2, constraint)).to_be(false)

    describe "Exact constraints":

        it "parses exact version":
            val (ok, c_opt, err) = parse_constraint("1.2.3")
            expect(ok).to_be(true)

        it "exact only matches exact version":
            val (ok_c, c_opt, e_c) = parse_constraint("1.2.3")
            if val constraint = c_opt:
                val (ok1, v1_opt, e1) = parse_version("1.2.3")
                if val v1 = v1_opt:
                    expect(satisfies(v1, constraint)).to_be(true)
                val (ok2, v2_opt, e2) = parse_version("1.2.4")
                if val v2 = v2_opt:
                    expect(satisfies(v2, constraint)).to_be(false)

    describe "Wildcard constraints":

        it "parses wildcard":
            val (ok, c_opt, err) = parse_constraint("*")
            expect(ok).to_be(true)

        it "wildcard matches any version":
            val (ok_c, c_opt, e_c) = parse_constraint("*")
            if val constraint = c_opt:
                val (ok1, v1_opt, e1) = parse_version("0.1.0")
                if val v1 = v1_opt:
                    expect(satisfies(v1, constraint)).to_be(true)
                val (ok2, v2_opt, e2) = parse_version("99.99.99")
                if val v2 = v2_opt:
                    expect(satisfies(v2, constraint)).to_be(true)

describe "SemVer Edge Cases":

    describe "Invalid versions":

        it "rejects non-numeric components":
            val (ok, v_opt, err) = parse_version("1.x.3")
            expect(ok).to_be(false)

        it "rejects missing components":
            val (ok, v_opt, err) = parse_version("1.2")
            expect(ok).to_be(false)

        it "rejects negative numbers":
            val (ok, v_opt, err) = parse_version("1.-2.3")
            expect(ok).to_be(false)

    describe "String representation":

        it "converts version to string":
            val (ok, v_opt, err) = parse_version("1.2.3")
            if val v = v_opt:
                expect(v.to_string()).to_equal("1.2.3")

        it "includes prerelease in string":
            val (ok, v_opt, err) = parse_version("1.2.3-alpha.1")
            if val v = v_opt:
                expect(v.to_string()).to_equal("1.2.3-alpha.1")

        it "includes build metadata in string":
            val (ok, v_opt, err) = parse_version("1.2.3+build")
            if val v = v_opt:
                expect(v.to_string()).to_equal("1.2.3+build")
