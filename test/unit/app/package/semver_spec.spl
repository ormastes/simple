import std.spec

struct Version:
    major: i64
    minor: i64
    patch: i64
    prerelease: text?
    build: text?

enum VersionConstraint:
    Any
    Caret(version: Version)

fn parse_int_component(s: text) -> (bool, i64, text):
    if s.is_empty():
        return (false, 0, "empty")
    if s.starts_with("-"):
        return (false, 0, "negative")
    for ch in s.chars():
        if ch < '0' or ch > '9':
            return (false, 0, "non-numeric")
    val n = s.to_int()
    if n < 0:
        return (false, 0, "negative")
    (true, n, "")

fn parse_version(s: text) -> (bool, Version?, text):
    val plus = s.split("+")
    val core_plus = plus[0]
    var build = nil
    if plus.length > 1:
        build = Some(plus[1])

    val dash = core_plus.split("-")
    val core = dash[0]
    var pre = nil
    if dash.length > 1:
        pre = Some(dash[1])

    val c = core.split(".")
    if c.length != 3:
        return (false, nil, "invalid")
    val (ok1, major, _e1) = parse_int_component(c[0])
    val (ok2, minor, _e2) = parse_int_component(c[1])
    val (ok3, patch, _e3) = parse_int_component(c[2])
    if not ok1 or not ok2 or not ok3:
        return (false, nil, "invalid")
    (true, Some(Version(major: major, minor: minor, patch: patch, prerelease: pre, build: build)), "")

fn parse_constraint(s: text) -> (bool, VersionConstraint?, text):
    val t = s.trim()
    if t == "*":
        return (true, Some(VersionConstraint.Any), "")
    if t.starts_with("^"):
        val (ok, v_opt, err) = parse_version(t.substring(1).trim())
        if not ok:
            return (false, nil, err)
        if val v = v_opt:
            return (true, Some(VersionConstraint.Caret(version: v)), "")
    (false, nil, "unsupported")

fn version_equal(a: Version, b: Version) -> bool:
    a.major == b.major and a.minor == b.minor and a.patch == b.patch and a.prerelease == b.prerelease

fn version_greater(a: Version, b: Version) -> bool:
    if a.major != b.major:
        return a.major > b.major
    if a.minor != b.minor:
        return a.minor > b.minor
    if a.patch != b.patch:
        return a.patch > b.patch
    match a.prerelease:
        Some(_):
            match b.prerelease:
                Some(_): false
                nil: false
        nil:
            match b.prerelease:
                Some(_): true
                nil: false

fn satisfies(version: Version, constraint: VersionConstraint) -> bool:
    match constraint:
        VersionConstraint.Any:
            true
        VersionConstraint.Caret(v):
            version_greater(version, v) or version_equal(version, v)

describe "SemVer":
    it "parses a normal version":
        val (ok, v_opt, _err) = parse_version("1.2.3")
        expect(ok).to_be(true)
        match v_opt:
            Some(v):
                expect(v.major).to_equal(1)
                expect(v.minor).to_equal(2)
                expect(v.patch).to_equal(3)
            nil:
                fail("expected parsed version")

    it "parses prerelease and build metadata":
        val (ok, v_opt, _err) = parse_version("1.2.3-alpha.1+build.7")
        expect(ok).to_be(true)
        match v_opt:
            Some(v):
                match v.prerelease:
                    Some(pre): expect(pre).to_equal("alpha.1")
                    nil: fail("expected prerelease")
                match v.build:
                    Some(bld): expect(bld).to_equal("build.7")
                    nil: fail("expected build metadata")
            nil:
                fail("expected parsed version")

    it "rejects invalid versions":
        val (ok1, _v1, _e1) = parse_version("1.x.3")
        val (ok2, _v2, _e2) = parse_version("1.2")
        expect(ok1).to_be(false)
        expect(ok2).to_be(false)

    it "compares versions":
        val (ok1, a_opt, _e1) = parse_version("2.0.0")
        val (ok2, b_opt, _e2) = parse_version("1.9.9")
        expect(ok1).to_be(true)
        expect(ok2).to_be(true)
        match a_opt:
            Some(a):
                match b_opt:
                    Some(b):
                        expect(version_greater(a, b)).to_be(true)
                        expect(version_equal(a, b)).to_be(false)
                    nil:
                        fail("expected rhs version")
            nil:
                fail("expected lhs version")

    it "parses caret constraints":
        val (ok, c_opt, _e) = parse_constraint("^1.2.3")
        expect(ok).to_be(true)
        match c_opt:
            Some(c):
                val (okv, v_opt, _ev) = parse_version("1.5.0")
                expect(okv).to_be(true)
                match v_opt:
                    Some(v): expect(satisfies(v, c)).to_be(true)
                    nil: fail("expected parsed version")
            nil:
                fail("expected parsed constraint")

    it "supports wildcard constraints":
        val (ok, c_opt, _e) = parse_constraint("*")
        expect(ok).to_be(true)
        match c_opt:
            Some(c):
                val (okv, v_opt, _ev) = parse_version("99.99.99")
                expect(okv).to_be(true)
                match v_opt:
                    Some(v): expect(satisfies(v, c)).to_be(true)
                    nil: fail("expected parsed version")
            nil:
                fail("expected parsed constraint")
