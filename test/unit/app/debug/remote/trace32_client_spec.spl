describe "Trace32 Client":
    it "skipped":
        skip("pre-existing test failures - functions/imports not available")

# # Trace32 Client Parser Unit Tests
# # Tests Trace32Parser output parsing without hardware or shell calls.
# # All tests use canned output strings.
# 
# use remote.protocol.trace32.Trace32Parser
# use app.debug.coordinator.{VarInfo, FrameInfo}
# 
# describe "Trace32Parser":
# 
#     context "parse_variables":
#         it "parses variable list with name, type, value":
#             val raw = "counter  int  42\nname  char*  0x20001000\nflag  bool  1"
#             val vars = Trace32Parser.parse_variables(raw)
#             expect(vars.len()).to_equal(3)
#             expect(vars[0].name).to_equal("counter")
#             expect(vars[0].type_name).to_equal("int")
#             expect(vars[0].value).to_equal("42")
#             expect(vars[1].name).to_equal("name")
#             expect(vars[1].type_name).to_equal("char*")
#             expect(vars[2].name).to_equal("flag")
#             expect(vars[2].value).to_equal("1")
# 
#         it "skips empty lines and header lines":
#             val raw = "name  type  value\n---  ---  ---\n\ncounter  int  42"
#             val vars = Trace32Parser.parse_variables(raw)
#             expect(vars.len()).to_equal(1)
#             expect(vars[0].name).to_equal("counter")
# 
#         it "handles two-column output (name and value only)":
#             val raw = "x  0xFF"
#             val vars = Trace32Parser.parse_variables(raw)
#             expect(vars.len()).to_equal(1)
#             expect(vars[0].name).to_equal("x")
#             expect(vars[0].value).to_equal("0xFF")
#             expect(vars[0].type_name).to_equal("")
# 
#         it "returns empty list for empty input":
#             val vars = Trace32Parser.parse_variables("")
#             expect(vars.len()).to_equal(0)
# 
#     context "parse_stack_trace":
#         it "parses stack frames with function and location":
#             val raw = "#0  0x08001234  main  main.c:42\n#1  0x08001000  reset_handler  startup.s:10"
#             val frames = Trace32Parser.parse_stack_trace(raw)
#             expect(frames.len()).to_equal(2)
#             expect(frames[0].index).to_equal(0)
#             expect(frames[0].function_name).to_equal("main")
#             expect(frames[0].file).to_equal("main.c")
#             expect(frames[0].line).to_equal(42)
#             expect(frames[1].index).to_equal(1)
#             expect(frames[1].function_name).to_equal("reset_handler")
# 
#         it "skips empty and separator lines":
#             val raw = "---\n\n#0  0x08001234  main  main.c:42"
#             val frames = Trace32Parser.parse_stack_trace(raw)
#             expect(frames.len()).to_equal(1)
# 
#         it "returns empty list for empty input":
#             val frames = Trace32Parser.parse_stack_trace("")
#             expect(frames.len()).to_equal(0)
# 
#     context "parse_memory_dump":
#         it "parses hex byte dump with address prefix":
#             val raw = "0x20000000: 01 02 03 04\n0x20000004: 0A 0B 0C 0D"
#             val bytes = Trace32Parser.parse_memory_dump(raw)
#             expect(bytes.len()).to_equal(8)
#             expect(bytes[0]).to_equal(1)
#             expect(bytes[1]).to_equal(2)
#             expect(bytes[4]).to_equal(10)
#             expect(bytes[7]).to_equal(13)
# 
#         it "parses dump without address prefix":
#             val raw = "FF 00 AB CD"
#             val bytes = Trace32Parser.parse_memory_dump(raw)
#             expect(bytes.len()).to_equal(4)
#             expect(bytes[0]).to_equal(255)
#             expect(bytes[1]).to_equal(0)
#             expect(bytes[2]).to_equal(171)
#             expect(bytes[3]).to_equal(205)
# 
#         it "returns empty for empty input":
#             val bytes = Trace32Parser.parse_memory_dump("")
#             expect(bytes.len()).to_equal(0)
# 
#     context "parse_register_value":
#         it "parses hex register value":
#             val result = Trace32Parser.parse_register_value("0x12345678")
#             match result:
#                 Ok(v): expect(v).to_equal(305419896)
#                 Err(_): expect(true).to_equal(false)
# 
#         it "parses uppercase hex value":
#             val result = Trace32Parser.parse_register_value("0XABCDEF00")
#             match result:
#                 Ok(v): expect(v).to_equal(2882400000)
#                 Err(_): expect(true).to_equal(false)
# 
#         it "parses zero":
#             val result = Trace32Parser.parse_register_value("0x0")
#             match result:
#                 Ok(v): expect(v).to_equal(0)
#                 Err(_): expect(true).to_equal(false)
# 
#         it "parses decimal value":
#             val result = Trace32Parser.parse_register_value("12345")
#             match result:
#                 Ok(v): expect(v).to_equal(12345)
#                 Err(_): expect(true).to_equal(false)
# 
#         it "trims whitespace":
#             val result = Trace32Parser.parse_register_value("  0xFF  ")
#             match result:
#                 Ok(v): expect(v).to_equal(255)
#                 Err(_): expect(true).to_equal(false)
# 
#         it "returns error for invalid input":
#             val result = Trace32Parser.parse_register_value("not_a_number")
#             match result:
#                 Ok(_): expect(true).to_equal(false)
#                 Err(e): expect(e).to_contain("cannot parse")
# 
#     context "parse_register_list":
#         it "parses register=value pairs":
#             val raw = "R0=0x00000000  R1=0x12345678  R2=0xFF"
#             val regs = Trace32Parser.parse_register_list(raw)
#             expect(regs["R0"]).to_equal(0)
#             expect(regs["R1"]).to_equal(305419896)
#             expect(regs["R2"]).to_equal(255)
# 
#         it "handles multiline register output":
#             val raw = "R0=0x00  R1=0x01\nR2=0x02  R3=0x03"
#             val regs = Trace32Parser.parse_register_list(raw)
#             expect(regs["R0"]).to_equal(0)
#             expect(regs["R1"]).to_equal(1)
#             expect(regs["R2"]).to_equal(2)
#             expect(regs["R3"]).to_equal(3)
# 
#         it "returns empty dict for empty input":
#             val regs = Trace32Parser.parse_register_list("")
#             expect(regs.keys().len()).to_equal(0)
# 
#     context "hex utilities":
#         it "converts integer to hex string":
#             expect(Trace32Parser.to_hex(0)).to_equal("0x0")
#             expect(Trace32Parser.to_hex(255)).to_equal("0xff")
#             expect(Trace32Parser.to_hex(4096)).to_equal("0x1000")
# 
#         it "converts byte to two-char hex string":
#             expect(Trace32Parser.byte_to_hex(0)).to_equal("00")
#             expect(Trace32Parser.byte_to_hex(255)).to_equal("ff")
#             expect(Trace32Parser.byte_to_hex(171)).to_equal("ab")
# 
#         it "parses hex byte string":
#             expect(Trace32Parser.parse_hex_byte("FF")).to_equal(255)
#             expect(Trace32Parser.parse_hex_byte("00")).to_equal(0)
#             expect(Trace32Parser.parse_hex_byte("AB")).to_equal(171)
# 
#         it "returns -1 for invalid hex byte":
#             expect(Trace32Parser.parse_hex_byte("GG")).to_equal(-1)
#             expect(Trace32Parser.parse_hex_byte("X")).to_equal(-1)
# 
#     context "split_whitespace":
#         it "splits on spaces":
#             val parts = Trace32Parser.split_whitespace("hello world")
#             expect(parts.len()).to_equal(2)
#             expect(parts[0]).to_equal("hello")
#             expect(parts[1]).to_equal("world")
# 
#         it "handles multiple spaces":
#             val parts = Trace32Parser.split_whitespace("a   b   c")
#             expect(parts.len()).to_equal(3)
# 
#         it "handles tabs":
#             val parts = Trace32Parser.split_whitespace("a\tb\tc")
#             expect(parts.len()).to_equal(3)
# 
#         it "returns empty for empty input":
#             val parts = Trace32Parser.split_whitespace("")
#             expect(parts.len()).to_equal(0)
