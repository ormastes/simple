# Outline Renderer Specification
# Feature: Foldable MCP Block-mark Format
# Category: MCP, Outline
# Status: Complete

use app.mcp.outline_renderer.{render_outline, expand_at_source, scan_source_symbols, OutlineSym, sym_marker}
use app.mcp.diag_core.{DiagEntry}

describe "Outline Renderer - scan_source_symbols":
    context "with empty source":
        it "returns empty list for no lines":
            val lines: [text] = []
            val result = scan_source_symbols(lines)
            expect(result.len()).to_equal(0)

    context "with single function":
        it "detects function name and kind":
            val lines = ["fn square(x: i64) -> i64:", "    x * x"]
            val syms = scan_source_symbols(lines)
            expect(syms.len()).to_equal(1)
            expect(syms[0].kind).to_equal("fn")
            expect(syms[0].name).to_equal("square")

        it "strips trailing colon from signature":
            val lines = ["fn foo(x: i64):"]
            val syms = scan_source_symbols(lines)
            expect(syms[0].signature).to_equal("fn foo(x: i64)")

    context "with multiple symbols":
        it "detects all top-level symbols":
            val lines = ["fn foo():", "    0", "fn bar():", "    0"]
            val syms = scan_source_symbols(lines)
            expect(syms.len()).to_equal(2)
            expect(syms[0].name).to_equal("foo")
            expect(syms[1].name).to_equal("bar")

        it "ignores indented functions (class methods)":
            val lines = ["class User:", "    fn get_name():", "        self.name"]
            val syms = scan_source_symbols(lines)
            expect(syms.len()).to_equal(1)
            expect(syms[0].kind).to_equal("class")

    context "with struct":
        it "detects struct":
            val lines = ["struct Point:", "    x: i64", "    y: i64"]
            val syms = scan_source_symbols(lines)
            expect(syms.len()).to_equal(1)
            expect(syms[0].kind).to_equal("struct")
            expect(syms[0].name).to_equal("Point")

    context "with enum":
        it "detects enum":
            val lines = ["enum Color:", "    Red", "    Green", "    Blue"]
            val syms = scan_source_symbols(lines)
            expect(syms.len()).to_equal(1)
            expect(syms[0].kind).to_equal("enum")
            expect(syms[0].name).to_equal("Color")

describe "Outline Renderer - sym_marker":
    it "returns F> for fn":
        expect(sym_marker("fn")).to_equal("F>")

    it "returns C> for class":
        expect(sym_marker("class")).to_equal("C>")

    it "returns S> for struct":
        expect(sym_marker("struct")).to_equal("S>")

    it "returns E> for enum":
        expect(sym_marker("enum")).to_equal("E>")

describe "Outline Renderer - render_outline":
    context "with empty source":
        it "returns empty string":
            val entries: [DiagEntry] = []
            val result = render_outline("", entries, "outline")
            expect(result).to_equal("")

    context "single function outline mode":
        it "collapses multi-line function":
            val src = "fn square(x: i64) -> i64:\n    x * x"
            val entries: [DiagEntry] = []
            val result = render_outline(src, entries, "outline")
            expect(result.contains("F>")).to_equal(true)
            expect(result.contains("square")).to_equal(true)
            expect(result.contains("{ ... }")).to_equal(true)

        it "does not add braces for single-line body":
            val src = "fn add(x: i64, y: i64) -> i64: x + y"
            val entries: [DiagEntry] = []
            val result = render_outline(src, entries, "outline")
            expect(result.contains("F>")).to_equal(true)
            expect(result.contains("{ ... }")).to_equal(false)

    context "with diagnostics outline mode":
        it "adds V* error line for function range":
            val src = "fn foo():\n    bad_code()"
            val entry = DiagEntry(line_num: 2, col_num: 5, severity: "error", message: "undefined: bad_code", easyfix: "", code: "E001")
            val entries = [entry]
            val result = render_outline(src, entries, "outline")
            expect(result.contains("V* [E]")).to_equal(true)
            expect(result.contains("undefined: bad_code")).to_equal(true)

        it "adds V* hint when easyfix present":
            val src = "fn bar():\n    x + 1"
            val entry = DiagEntry(line_num: 2, col_num: 5, severity: "error", message: "type error", easyfix: "cast to i64", code: "E002")
            val entries = [entry]
            val result = render_outline(src, entries, "outline")
            expect(result.contains("V* [H]")).to_equal(true)
            expect(result.contains("cast to i64")).to_equal(true)

    context "compact mode":
        it "adds grouped error summary at end":
            val src = "fn foo():\n    bad\nfn bar():\n    ok"
            val entry = DiagEntry(line_num: 2, col_num: 1, severity: "error", message: "err", easyfix: "", code: "E001")
            val entries = [entry]
            val result = render_outline(src, entries, "compact")
            expect(result.contains("1E")).to_equal(true)
            expect(result.contains("in file]")).to_equal(true)

describe "Outline Renderer - expand_at_source":
    context "by name":
        it "expands function by name with all content":
            val src = "fn add(x: i64, y: i64) -> i64:\n    x + y"
            val result = expand_at_source(src, "add", "all")
            expect(result.contains("F_")).to_equal(true)
            expect(result.contains("fn add")).to_equal(true)
            expect(result.contains("x + y")).to_equal(true)

        it "returns error message for unknown symbol":
            val src = "fn foo():\n    0"
            val result = expand_at_source(src, "missing", "all")
            expect(result.contains("not found")).to_equal(true)

        it "returns only signature when what is signature":
            val src = "fn square(x: i64) -> i64:\n    x * x"
            val result = expand_at_source(src, "square", "signature")
            expect(result.contains("F_")).to_equal(true)
            expect(result.contains("x * x")).to_equal(false)

    context "by line number":
        it "expands by line: prefix":
            val src = "fn greet(name: text) -> text:\n    \"Hello \" + name"
            val result = expand_at_source(src, "line:1", "signature")
            expect(result.contains("greet")).to_equal(true)

describe "Outline Renderer - trait and impl support":
    it "detects trait":
        val lines = ["trait Drawable:", "    fn draw(self):"]
        val syms = scan_source_symbols(lines)
        expect(syms.len()).to_equal(1)
        expect(syms[0].kind).to_equal("trait")
        expect(syms[0].name).to_equal("Drawable")

    it "returns T> marker for trait":
        expect(sym_marker("trait")).to_equal("T>")

    it "returns T_ marker for expanded trait":
        expect(expanded_sym_marker("trait")).to_equal("T_")

    it "detects impl":
        val lines = ["impl Drawable:", "    fn draw(self):"]
        val syms = scan_source_symbols(lines)
        expect(syms.len()).to_equal(1)
        expect(syms[0].kind).to_equal("impl")

    it "returns I> marker for impl":
        expect(sym_marker("impl")).to_equal("I>")

    it "detects extern fn":
        val lines = ["extern fn rt_file_read(path: text) -> text"]
        val syms = scan_source_symbols(lines)
        expect(syms.len()).to_equal(1)
        expect(syms[0].kind).to_equal("fn")
        expect(syms[0].name).to_equal("rt_file_read")

describe "Outline Renderer - backward compat full mode":
    it "full mode falls through to regular behavior":
        val src = "fn foo():\n    x"
        val entries: [DiagEntry] = []
        val result = render_outline(src, entries, "outline")
        expect(result.contains("F>")).to_equal(true)

    it "diag_severity_tag returns E for error":
        expect(diag_severity_tag("error")).to_equal("E")

    it "diag_severity_tag returns W for warning":
        expect(diag_severity_tag("warning")).to_equal("W")

    it "diag_severity_tag returns H for hint":
        expect(diag_severity_tag("hint")).to_equal("H")

describe "Outline Renderer - class and member summary":
    it "collapses class with methods":
        val src = "class Point:\n    x: i64\n    y: i64\n    fn len() -> f64:\n        0.0"
        val entries: [DiagEntry] = []
        val result = render_outline(src, entries, "outline")
        expect(result.contains("C>")).to_equal(true)
        expect(result.contains("Point")).to_equal(true)
        expect(result.contains("{ ... }")).to_equal(true)
