# MCP Resource Subscriptions Specification
# Feature: MCP Resource Subscriptions
# Category: MCP, Resources
# Status: Complete

use std.spec
use app.mcp.helpers.{make_resource_updated_notification}

# Inline subscription state for testing
class TestSubscriptions:
    subs: Dict<String, Bool>

    static fn create() -> TestSubscriptions:
        TestSubscriptions(subs: {})

impl TestSubscriptions:
    me subscribe(uri: String):
        self.subs[uri] = true

    me unsubscribe(uri: String):
        self.subs.remove(uri)

    fn is_subscribed(uri: String) -> Bool:
        self.subs.get(uri).?

    fn get_subscribed_uris() -> [String]:
        var result: [String] = []
        for (uri, _) in self.subs.items():
            result.push(uri)
        result

describe "MCP Resource Subscriptions":
    it "subscribes to resource URI":
        var subs = TestSubscriptions.create()
        subs.subscribe("file:///test.spl")
        expect(subs.is_subscribed("file:///test.spl")).to_equal(true)

    it "unsubscribes from resource URI":
        var subs = TestSubscriptions.create()
        subs.subscribe("file:///test.spl")
        subs.unsubscribe("file:///test.spl")
        expect(subs.is_subscribed("file:///test.spl")).to_equal(false)

    it "tracks multiple subscriptions":
        var subs = TestSubscriptions.create()
        subs.subscribe("file:///a.spl")
        subs.subscribe("file:///b.spl")
        val uris = subs.get_subscribed_uris()
        expect(uris.len()).to_equal(2)

    it "returns false for non-subscribed URI":
        var subs = TestSubscriptions.create()
        expect(subs.is_subscribed("file:///nonexistent.spl")).to_equal(false)

describe "MCP Resource Updated Notification":
    it "builds notification for subscribed resource":
        val notif = make_resource_updated_notification("file:///test.spl")
        expect(notif.contains("notifications/resources/updated")).to_equal(true)
        expect(notif.contains("file:///test.spl")).to_equal(true)
