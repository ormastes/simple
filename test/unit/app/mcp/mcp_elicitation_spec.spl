"""
MCP Elicitation Support Specification
Feature: MCP Elicitation Requests
Category: MCP, Protocol
Status: Complete
"""

use std.spec
use app.mcp.helpers.{LB, RB, jp, js, jo1, jo2, jo3, extract_json_string, extract_json_value, make_elicitation_request, make_result_response}

describe "MCP Elicitation Create":
    context "when building elicitation request":
        it "uses correct method":
            val schema = jo1(jp("type", js("object")))
            val req = make_elicitation_request("srv-1", "Please enter your API key", schema)
            expect(req.contains("\"method\":\"elicitation/create\"")).to_equal(true)

        it "includes message":
            val schema = jo1(jp("type", js("object")))
            val req = make_elicitation_request("srv-1", "Please enter your API key", schema)
            expect(req.contains("Please enter your API key")).to_equal(true)

        it "includes requestedSchema":
            val schema = jo2(jp("type", js("object")), jp("properties", jo1(jp("key", jo1(jp("type", js("string")))))))
            val req = make_elicitation_request("srv-1", "Enter key", schema)
            expect(req.contains("requestedSchema")).to_equal(true)

        it "is a request (has id)":
            val schema = jo1(jp("type", js("object")))
            val req = make_elicitation_request("srv-1", "Enter", schema)
            expect(req.contains("\"id\":srv-1")).to_equal(true)

        it "is valid JSON-RPC":
            val schema = jo1(jp("type", js("object")))
            val req = make_elicitation_request("srv-1", "test", schema)
            expect(req.contains("\"jsonrpc\":\"2.0\"")).to_equal(true)

describe "MCP Elicitation Schema Types":
    context "when using string schema":
        it "supports basic string":
            val prop = jo1(jp("type", js("string")))
            val schema = jo2(jp("type", js("object")), jp("properties", jo1(jp("name", prop))))
            val req = make_elicitation_request("1", "Name?", schema)
            expect(req.contains("string")).to_equal(true)

        it "supports minLength/maxLength constraints":
            val prop = jo3(jp("type", js("string")), jp("minLength", "1"), jp("maxLength", "255"))
            expect(prop.contains("minLength")).to_equal(true)
            expect(prop.contains("maxLength")).to_equal(true)

    context "when using numeric schema":
        it "supports number type":
            val prop = jo1(jp("type", js("number")))
            expect(prop.contains("number")).to_equal(true)

        it "supports integer type":
            val prop = jo1(jp("type", js("integer")))
            expect(prop.contains("integer")).to_equal(true)

        it "supports minimum/maximum":
            val prop = jo3(jp("type", js("integer")), jp("minimum", "0"), jp("maximum", "100"))
            expect(prop.contains("minimum")).to_equal(true)
            expect(prop.contains("maximum")).to_equal(true)

    context "when using boolean schema":
        it "supports boolean type":
            val prop = jo1(jp("type", js("boolean")))
            expect(prop.contains("boolean")).to_equal(true)

    context "when using enum schema":
        it "supports string enum":
            val values = "[" + js("option1") + "," + js("option2") + "," + js("option3") + "]"
            val prop = jo2(jp("type", js("string")), jp("enum", values))
            expect(prop.contains("enum")).to_equal(true)
            expect(prop.contains("option1")).to_equal(true)

describe "MCP Elicitation Response":
    context "when user accepts":
        it "action is accept in response":
            val response = jo2(jp("action", js("accept")), jp("content", jo1(jp("key", js("abc123")))))
            val action = extract_json_string(response, "action")
            expect(action).to_equal("accept")

        it "includes content in accept response":
            val response = jo2(jp("action", js("accept")), jp("content", jo1(jp("key", js("abc123")))))
            expect(response.contains("content")).to_equal(true)
            expect(response.contains("abc123")).to_equal(true)

    context "when user declines":
        it "action is decline in response":
            val response = jo1(jp("action", js("decline")))
            val action = extract_json_string(response, "action")
            expect(action).to_equal("decline")

    context "when user cancels":
        it "action is cancel in response":
            val response = jo1(jp("action", js("cancel")))
            val action = extract_json_string(response, "action")
            expect(action).to_equal("cancel")
