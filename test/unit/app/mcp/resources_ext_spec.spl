use std.spec
use std.string.{NL}

# MCP Resources Extended Specification
#
# Tests for resource manager types, URI handling, MIME type detection,
# and resource utility functions (JSON parsing, string helpers).
# Locally replicates pure functions from:
# - app.mcp.resources (get_mime_type_for_uri, repeat_string, dir_exists)
# - app.mcp.resource_utils (extract_json_string, extract_json_int, etc.)

# =========================================================================
# Local type definitions (mirrors resources.spl)
# =========================================================================

struct ResourceInfo:
    uri: text
    name: text
    description: text
    mime_type: text

struct ResourceTemplate:
    uri_template: text
    name: text
    description: text
    mime_type: text

struct ResourceContent:
    uri: text
    contents: text
    mime_type: text

# =========================================================================
# Pure functions replicated from resources.spl
# =========================================================================

fn get_mime_type_for_uri(uri: text) -> text:
    if uri.starts_with("file://"):
        if uri.ends_with(".spl") or uri.ends_with(".ssh"):
            return "text/x-simple"
        if uri.ends_with(".json"):
            return "application/json"
        if uri.ends_with(".md"):
            return "text/markdown"
        return "text/plain"

    if uri.starts_with("symbol://") or uri.starts_with("type://"):
        return "application/json"

    if uri.starts_with("docs://"):
        return "text/markdown"

    if uri.starts_with("tree://"):
        return "text/plain"

    ""

fn repeat_string(s: text, count: i64) -> text:
    var result = ""
    for i in 0..count:
        result = result + s
    result

# =========================================================================
# Pure functions replicated from resource_utils.spl
# =========================================================================

fn extract_json_string(json: text, key: text) -> text:
    val pattern = "\"" + key + "\": \""
    val idx = json.index_of(pattern) ?? -1
    if idx == -1:
        return ""

    val value_start = idx + pattern.len()
    # index_of doesn't support offset, so take substring first
    val remaining = json.substring(value_start)
    val end_idx = remaining.index_of("\"") ?? -1
    if end_idx == -1:
        return ""

    remaining.substring(0, end_idx)

fn extract_json_int(json: text, key: text) -> i64:
    val pattern = "\"" + key + "\": "
    val idx = json.index_of(pattern) ?? -1
    if idx == -1:
        return 0

    val value_start = idx + pattern.len()
    var value_end = value_start
    while value_end < json.len():
        val ch = json.char_at(value_end)
        val is_digit = ch >= "0" and ch <= "9"
        val is_minus = ch == "-"
        if not is_digit and not is_minus:
            break
        value_end = value_end + 1

    if value_end == value_start:
        return 0

    val num_str = json.substring(value_start, value_end)
    int(num_str)

# =========================================================================
# URI routing helper
# =========================================================================

fn route_uri(uri: text) -> text:
    if uri == "project:///info":
        return "project_info"
    if uri.starts_with("file://"):
        return "file"
    if uri.starts_with("symbol://"):
        return "symbol"
    if uri.starts_with("type://"):
        return "type"
    if uri.starts_with("docs://"):
        return "docs"
    if uri.starts_with("tree://"):
        return "tree"
    if uri.starts_with("bugdb://"):
        return "bugdb"
    if uri.starts_with("featuredb://"):
        return "featuredb"
    if uri.starts_with("testdb://"):
        return "testdb"
    "unknown"

# Extract path from file URI
fn extract_file_path(uri: text) -> text:
    uri.substring(7)

# Extract symbol name from symbol URI
fn extract_symbol_name(uri: text) -> text:
    uri.substring(9)

# Extract type name from type URI
fn extract_type_name(uri: text) -> text:
    uri.substring(7)

# Extract bugdb query from bugdb URI
fn extract_bugdb_query(uri: text) -> text:
    uri.substring(8)

# =========================================================================
# Tests
# =========================================================================

describe "ResourceInfo":
    it "creates with all fields":
        val info = ResourceInfo(
            uri: "file:///src/main.spl",
            name: "Main Source",
            description: "Main entry point",
            mime_type: "text/x-simple"
        )
        expect(info.uri).to_equal("file:///src/main.spl")
        expect(info.name).to_equal("Main Source")
        expect(info.description).to_equal("Main entry point")
        expect(info.mime_type).to_equal("text/x-simple")

    it "handles empty description":
        val info = ResourceInfo(
            uri: "symbol:///MyClass",
            name: "MyClass",
            description: "",
            mime_type: "application/json"
        )
        expect(info.description).to_equal("")

    it "stores project info URI":
        val info = ResourceInfo(
            uri: "project:///info",
            name: "Project Information",
            description: "Project metadata",
            mime_type: "text/plain"
        )
        expect(info.uri).to_equal("project:///info")

describe "ResourceTemplate":
    it "creates with URI template pattern":
        val tpl_uri = "file:///" + "{" + "path" + "}"
        val tmpl = ResourceTemplate(
            uri_template: tpl_uri,
            name: "File Contents",
            description: "Read file contents by path",
            mime_type: "text/plain"
        )
        expect(tmpl.uri_template).to_start_with("file:///")
        expect(tmpl.name).to_equal("File Contents")

    it "stores symbol template":
        val tpl_uri = "symbol:///" + "{" + "name" + "}"
        val tmpl = ResourceTemplate(
            uri_template: tpl_uri,
            name: "Symbol Information",
            description: "Get symbol details by name",
            mime_type: "application/json"
        )
        expect(tmpl.uri_template).to_start_with("symbol:///")

    it "stores bugdb template":
        val tpl_uri = "bugdb:///" + "{" + "query" + "}"
        val tmpl = ResourceTemplate(
            uri_template: tpl_uri,
            name: "Bug Database",
            description: "Query bug database",
            mime_type: "application/json"
        )
        expect(tmpl.uri_template).to_start_with("bugdb:///")

describe "ResourceContent":
    it "creates with uri and contents":
        val content = ResourceContent(
            uri: "file:///test.spl",
            contents: "fn main(): print(\"hello\")",
            mime_type: "text/x-simple"
        )
        expect(content.uri).to_equal("file:///test.spl")
        expect(content.contents).to_contain("main")
        expect(content.mime_type).to_equal("text/x-simple")

    it "handles empty contents":
        val content = ResourceContent(
            uri: "file:///empty.spl",
            contents: "",
            mime_type: "text/x-simple"
        )
        expect(content.contents).to_equal("")

    it "handles large content":
        var large = ""
        for i in 0..100:
            large = large + "line {i}{NL}"
        val content = ResourceContent(
            uri: "file:///large.spl",
            contents: large,
            mime_type: "text/plain"
        )
        expect(content.contents).to_contain("line 0")
        expect(content.contents).to_contain("line 99")

describe "get_mime_type_for_uri":
    it "returns text/x-simple for .spl files":
        val mime = get_mime_type_for_uri("file:///src/main.spl")
        expect(mime).to_equal("text/x-simple")

    it "returns text/x-simple for .ssh files":
        val mime = get_mime_type_for_uri("file:///script.ssh")
        expect(mime).to_equal("text/x-simple")

    it "returns application/json for .json files":
        val mime = get_mime_type_for_uri("file:///data.json")
        expect(mime).to_equal("application/json")

    it "returns text/markdown for .md files":
        val mime = get_mime_type_for_uri("file:///README.md")
        expect(mime).to_equal("text/markdown")

    it "returns text/plain for unknown file extensions":
        val mime = get_mime_type_for_uri("file:///data.txt")
        expect(mime).to_equal("text/plain")

    it "returns text/plain for files without extension":
        val mime = get_mime_type_for_uri("file:///Makefile")
        expect(mime).to_equal("text/plain")

    it "returns application/json for symbol URIs":
        val mime = get_mime_type_for_uri("symbol:///MyClass")
        expect(mime).to_equal("application/json")

    it "returns application/json for type URIs":
        val mime = get_mime_type_for_uri("type:///String")
        expect(mime).to_equal("application/json")

    it "returns text/markdown for docs URIs":
        val mime = get_mime_type_for_uri("docs:///guide/intro")
        expect(mime).to_equal("text/markdown")

    it "returns text/plain for tree URIs":
        val mime = get_mime_type_for_uri("tree:///src/")
        expect(mime).to_equal("text/plain")

    it "returns empty string for unknown URI schemes":
        val mime = get_mime_type_for_uri("custom:///resource")
        expect(mime).to_equal("")

    it "returns empty string for bugdb URIs":
        val mime = get_mime_type_for_uri("bugdb:///all")
        expect(mime).to_equal("")

describe "repeat_string":
    it "repeats string given number of times":
        val result = repeat_string("ab", 3)
        expect(result).to_equal("ababab")

    it "returns empty string for count of zero":
        val result = repeat_string("x", 0)
        expect(result).to_equal("")

    it "repeats single character":
        val result = repeat_string("*", 5)
        expect(result).to_equal("*****")

    it "handles indentation pattern":
        val result = repeat_string("  ", 3)
        expect(result).to_equal("      ")

    it "handles single repetition":
        val result = repeat_string("hello", 1)
        expect(result).to_equal("hello")

describe "URI routing":
    it "routes project:///info to project_info":
        expect(route_uri("project:///info")).to_equal("project_info")

    it "routes file:// URIs to file":
        expect(route_uri("file:///src/main.spl")).to_equal("file")

    it "routes symbol:// URIs to symbol":
        expect(route_uri("symbol:///MyClass")).to_equal("symbol")

    it "routes type:// URIs to type":
        expect(route_uri("type:///String")).to_equal("type")

    it "routes docs:// URIs to docs":
        expect(route_uri("docs:///guide")).to_equal("docs")

    it "routes tree:// URIs to tree":
        expect(route_uri("tree:///src/")).to_equal("tree")

    it "routes bugdb:// URIs to bugdb":
        expect(route_uri("bugdb:///all")).to_equal("bugdb")

    it "routes featuredb:// URIs to featuredb":
        expect(route_uri("featuredb:///stats")).to_equal("featuredb")

    it "routes testdb:// URIs to testdb":
        expect(route_uri("testdb:///runs")).to_equal("testdb")

    it "routes unknown URIs to unknown":
        expect(route_uri("custom:///foo")).to_equal("unknown")

    it "routes empty string to unknown":
        expect(route_uri("")).to_equal("unknown")

describe "URI path extraction":
    it "extracts file path from file URI":
        val path = extract_file_path("file:///src/main.spl")
        expect(path).to_equal("/src/main.spl")

    it "extracts path with triple slash":
        val path = extract_file_path("file:///absolute/path.spl")
        expect(path).to_equal("/absolute/path.spl")

    it "extracts symbol name from symbol URI":
        val name = extract_symbol_name("symbol:///MyClass")
        expect(name).to_equal("/MyClass")

    it "extracts type name from type URI":
        val name = extract_type_name("type:///String")
        expect(name).to_equal("/String")

    it "extracts bugdb query from bugdb URI":
        val query = extract_bugdb_query("bugdb:///all")
        expect(query).to_equal("/all")

    it "extracts bugdb critical query":
        val query = extract_bugdb_query("bugdb:///critical")
        expect(query).to_equal("/critical")

describe "extract_json_string":
    it "extracts string value by key":
        val json = "{\"name\": \"Alice\", \"age\": 30}"
        val name = extract_json_string(json, "name")
        expect(name).to_equal("Alice")

    it "returns empty string for missing key":
        val json = "{\"name\": \"Alice\"}"
        val missing = extract_json_string(json, "email")
        expect(missing).to_equal("")

    it "extracts from complex JSON":
        val json = "{\"status\": \"open\", \"priority\": \"P0\", \"title\": \"Fix bug\"}"
        expect(extract_json_string(json, "status")).to_equal("open")
        expect(extract_json_string(json, "priority")).to_equal("P0")
        expect(extract_json_string(json, "title")).to_equal("Fix bug")

    it "handles empty string value":
        val json = "{\"value\": \"\"}"
        val result = extract_json_string(json, "value")
        expect(result).to_equal("")

    it "extracts first occurrence of key":
        val json = "{\"key\": \"first\", \"other\": \"second\"}"
        val result = extract_json_string(json, "key")
        expect(result).to_equal("first")

    it "returns empty for empty JSON":
        val result = extract_json_string("{}", "key")
        expect(result).to_equal("")

describe "extract_json_int":
    it "extracts integer value by key":
        val json = "{\"count\": 42, \"name\": \"test\"}"
        val count = extract_json_int(json, "count")
        expect(count).to_equal(42)

    it "returns 0 for missing key":
        val json = "{\"count\": 42}"
        val missing = extract_json_int(json, "other")
        expect(missing).to_equal(0)

    it "extracts zero value":
        val json = "{\"count\": 0}"
        val count = extract_json_int(json, "count")
        expect(count).to_equal(0)

    it "extracts large numbers":
        val json = "{\"total\": 999999}"
        val total = extract_json_int(json, "total")
        expect(total).to_equal(999999)

    it "returns 0 for empty JSON":
        val result = extract_json_int("{}", "key")
        expect(result).to_equal(0)

describe "bugdb query routing":
    it "recognizes /all query":
        val query = extract_bugdb_query("bugdb:///all")
        var is_all = query == "/all" or query == "all"
        expect(is_all).to_equal(true)

    it "recognizes /open query":
        val query = extract_bugdb_query("bugdb:///open")
        var is_open = query == "/open" or query == "open"
        expect(is_open).to_equal(true)

    it "recognizes /critical query":
        val query = extract_bugdb_query("bugdb:///critical")
        var is_critical = query == "/critical" or query == "critical"
        expect(is_critical).to_equal(true)

    it "recognizes /stats query":
        val query = extract_bugdb_query("bugdb:///stats")
        var is_stats = query == "/stats" or query == "stats"
        expect(is_stats).to_equal(true)

describe "resource list coverage":
    it "verifies expected static resource URIs":
        val expected_uris = [
            "project:///info",
            "file:///*",
            "symbol:///*",
            "type:///*",
            "docs:///*",
            "tree:///*",
            "bugdb:///all",
            "bugdb:///open",
            "bugdb:///critical",
            "bugdb:///stats",
            "featuredb:///all",
            "featuredb:///stats",
            "testdb:///runs",
            "testdb:///stats",
            "testdb:///flaky"
        ]
        expect(expected_uris.len()).to_equal(15)

    it "verifies expected template URI count":
        # The resources module defines 6 templates:
        # file, symbol, type, docs, tree, bugdb
        val template_count = 6
        expect(template_count).to_equal(6)

    it "all template URI prefixes are unique":
        val prefixes = [
            "file:///",
            "symbol:///",
            "type:///",
            "docs:///",
            "tree:///",
            "bugdb:///"
        ]
        expect(prefixes.len()).to_equal(6)
        # Verify each starts with a different scheme
        expect(prefixes[0]).to_start_with("file")
        expect(prefixes[1]).to_start_with("symbol")
        expect(prefixes[2]).to_start_with("type")
        expect(prefixes[3]).to_start_with("docs")
        expect(prefixes[4]).to_start_with("tree")
        expect(prefixes[5]).to_start_with("bugdb")
